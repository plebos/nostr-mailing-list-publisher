[
    {
        "title": "[bitcoin-dev] BIP proposal, Pay to Contract BIP43 Application",
        "thread_messages": [
            {
                "author": "Omar Shibli",
                "date": "2017-09-01T07:16:41",
                "message_text_only": "Hello Gregory,\n\nThanks for you feedback.\n\nThe BIP has been updated to explicitly specify the multiparty key\nderivation scheme which hopefully addresses your concerns.\n\nPlease have a look at the updated draft of the BIP at the link below:\n\nhttps://github.com/commerceblock/pay-to-contract-protocol-specification/blob/master/bip-draft.mediawiki\n\nAny feedback is highly appreciated.\n\nRegards,\nOmar\n\nOn Tue, Aug 15, 2017 at 7:40 PM, omar shibli <omarshib at gmail.com> wrote:\n\n> Thank you for your time Gregory, I really appreciate that.\n>\n> What we are describing here is a method to embed cryptographic signatures\n> into a public key based on HD Wallets - BIP32.\n> In a practical application, we should have two cryptographic signatures\n> from both sides, I don't think in that case your scenario would be an issue.\n>\n> More specifically in our application, we do the following construction:\n>\n> contract base: m/200'/0'/<contract_number>'\n> payment base (merchant commitment): contract_base/<merchant_\n> contract_signature>\n> payment address (customer commitment): contract_base/<merchant_\n> contract_signature>/<customer_contract_signature>\n>\n> payment address funds could be reclaimed only if the\n> customer_contract_signature is provided by the customer.\n>\n> In terms of durability, our app is pretty simple at this point, we don't\n> store anything, we let customer download and manage the files.\n>\n> I will update the BIP to address your concerns.\n>\n> On Tue, Aug 15, 2017 at 8:12 AM, Gregory Maxwell <greg at xiph.org> wrote:\n>\n>> This construction appears to me to be completely insecure.\n>>\n>>\n>> Say my pubkey (the result of the derivation path) is P.\n>>\n>> We agree to contract C1.   A payment is made to P + G*H(C1).\n>>\n>> But in secret, I constructed contract C2 and pubkey Q and set P = Q +\n>> G*H(C2).\n>>\n>> Now I can take that payment (paid to Q + G*(C1) + G*H(C2)) and assert\n>> it was in act a payment to P' + G*H(C2).   (P' is simply Q + G*H(C1))\n>>\n>> I don't see anything in the proposal that addresses this. Am I missing it?\n>>\n>> The applications are also not clear to me, and it doesn't appear to\n>> address durability issues (how do you avoid losing your funds if you\n>> lose the exact contract?).\n>>\n>>\n>>\n>>\n>> On Mon, Aug 14, 2017 at 6:05 AM, omar shibli via bitcoin-dev\n>> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> > Hey all,\n>> >\n>> > A lot of us familiar with the pay to contract protocol, and how it uses\n>> > cleverly the homomorphic property of elliptic curve encryption system to\n>> > achieve it.\n>> > Unfortunately, there is no standard specification on how to conduct such\n>> > transactions in the cyberspace.\n>> >\n>> > We have developed a basic trade finance application that relies on the\n>> > original idea described in the Homomorphic Payment Addresses and the\n>> > Pay-to-Contract Protocol paper, yet we have generalized it and made it\n>> BIP43\n>> > complaint.\n>> >\n>> > We would like to share our method, and get your feedback about it,\n>> hopefully\n>> > this effort will result into a standard for the benefit of the\n>> community.\n>> >\n>> > Abstract idea:\n>> >\n>> > We define the following levels in BIP32 path.\n>> > m / purpose' / coin_type' / contract_id' / *\n>> >\n>> > contract_id is is an arbitrary number within the valid range of indices.\n>> >\n>> > Then we define, contract base as following prefix:\n>> > m / purpose' / coin_type' / contract_id'\n>> >\n>> > contract commitment address is computed as follows:\n>> > hash document using cryptographic hash function of your choice (e.g.\n>> blake2)\n>> > map hash to partial derivation path\n>> > Convert hash to binary array.\n>> > Partition the array into parts, each part length should be 16.\n>> > Convert each part to integer in decimal format.\n>> > Convert each integer to string.\n>> > Join all strings with slash `/`.\n>> > compute child public key by chaining the derivation path from step 2\n>> with\n>> > contract base:\n>> > m/<contract_base>/<hash_derivation_path>\n>> > compute address\n>> > Example:\n>> >\n>> > master private extended key:\n>> > xprv9s21ZrQH143K2JF8RafpqtKiTbsbaxEeUaMnNHsm5o6wCW3z8ySyH4Ux\n>> FVSfZ8n7ESu7fgir8imbZKLYVBxFPND1pniTZ81vKfd45EHKX73\n>> > coin type: 0\n>> > contract id: 7777777\n>> >\n>> > contract base computation :\n>> >\n>> > derivation path:\n>> > m/999'/0'/7777777'\n>> > contract base public extended key:\n>> > xpub6CMCS9rY5GKdkWWyoeXEbmJmxGgDcbihofyARxucufdw7k3oc1JNnnii\n>> D5H2HynKBwhaem4KnPTue6s9R2tcroqkHv7vpLFBgbKRDwM5WEE\n>> >\n>> > Contract content:\n>> > foo\n>> >\n>> > Contract sha256 signature:\n>> > 2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\n>> >\n>> > Contract partial derivation path:\n>> > 11302/46187/26879/50831/63899/17724/7472/16692/4930/11632/25\n>> 731/49056/63882/24200/25190/59310\n>> >\n>> > Contract commitment pub key path:\n>> > m/999'/0'/7777777'/11302/46187/26879/50831/63899/17724/7472/\n>> 16692/4930/11632/25731/49056/63882/24200/25190/59310\n>> > or\n>> > <contract_base_extended_pub_key>/11302/46187/26879/50831/638\n>> 99/17724/7472/16692/4930/11632/25731/49056/63882/24200/25190/59310\n>> >\n>> > Contract commitment pub key:\n>> > xpub6iQVNpbZxdf9QJC8mGmz7cd3Cswt2itcQofZbKmyka5jdvQKQCqYSDFj\n>> 8KCmRm4GBvcQW8gaFmDGAfDyz887msEGqxb6Pz4YUdEH8gFuaiS\n>> >\n>> > Contract commitment address:\n>> > 17yTyx1gXPPkEUN1Q6Tg3gPFTK4dhvmM5R\n>> >\n>> >\n>> > You can find the full BIP draft in the following link:\n>> > https://github.com/commerceblock/pay-to-contract-protocol-\n>> specification/blob/master/bip-draft.mediawiki\n>> >\n>> >\n>> > Regards,\n>> > Omar\n>> >\n>> > _______________________________________________\n>> > bitcoin-dev mailing list\n>> > bitcoin-dev at lists.linuxfoundation.org\n>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>> >\n>>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170901/94a90deb/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP proposal, Pay to Contract BIP43 Application",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Omar Shibli"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5913
        }
    },
    {
        "title": "[bitcoin-dev] Horizontal scaling of blockchain",
        "thread_messages": [
            {
                "author": "Cserveny Tamas",
                "date": "2017-09-01T12:47:08",
                "message_text_only": "Hi,\n\nI was thinking about how to scale the block-chain.\n\nThe fundamental problem is that if the miners add capacity it will only\nincrease (protect) their share of block reward, but does not increase the\nspeed of transactions. This will only raise the fee in the long run with\nthe block reward decreasing.\nThe throughput is limited by the block size and the complexity. Changing\nany of variables in the above equation was raised already many times and\nthere was no consensus on them.\n\nThe current chain is effectively single threaded. If we look around in the\nsw industry how single threaded applications could be scaled, one viable\noption emerge: horizontal scaling. This is an option if the problem can be\npartitioned, and transactions in partitions could be processed alongside.\nNumber of partitions would be start with a fairly low number, something\nbetween 2-10, but nothing is against setting it to a higher number later on\naccording to a schedule.\n\nPartitioning key alternatives:\n*Ordering on inputs:*\n\n1) In this case transactions would need to be mined per input address\npartition.\n2) TX have inputs in partition 1 and 2, then needs a confirmation in both\npartitions.\n3) All partitioned chains have the same longest valid approach.\n4) Only one chain needed to be considered for double spending, others are\ninvalid in case they contain that input.\n\nThis opens up questions like:\n- how the fee will be shared? Fees per partition?\n- Ensure a good hash function which spreads evenly, because the inputs\ncannot be manipulated for load balancing\n- What to do about half mined transactions (Maybe they should be two\ntransactions and then there is less effect about it, but payment won't be\natomic in both partitions)\n\n*Ordering on transaction ids:*\n\n1) Transactions would be partitioned by their TX-id. Maybe a field allowing\ntxid-s to match a given partition.\n2) Creating blocks like this parallel would be safe for bonefide\ntransactions. A block will be created each 10 mins.\n3) In order to get malicious/doublespent transactions out of the system\nanother layer must be introduced.\n- This layer would be used to merge the parallel blocks. It would have to\nrefer all previous blocks considered for unspent inputs.\n- Most of the blocks will merge just fine as normally block 1 and block 2\nwould not contain double spending. (of course malicious double spending\nwill revert speed to current levels, because the miner might have to drop a\nblock in the partition because it contains a spent input on another\nstronger branch)\n- The standard longest chain wins strategy would be used for validity on\nthe meta level\n- Meta does not require mining, a branches can be added and they are valid\nunless there are double spent inputs inside. Block inside this meta already\n\"paid for\".\n\nGenerally both ways would have an effect on the block reward and\ncomplexity, which is needs to be adjusted. (not to create more BTC at the\nend, reduced hashing power on partitions.)\nI think complexity is not an issue, the important thing is that we tune it\nto 10mins / block rate per partition.\n\nActivation could be done by creating the infrastructure first and using\nonly one partitions only, which is effectively the same as today. Then\nactivate partitions on a certain block according to a schedule. From that\nblock, partition enforcement will be active and the transactions will be\nsorted to the right partition / chain.\n\nIt is easy to make new partitions, just need to activate them on branch\nblock number.\nClosing partitions is a bit more complex in case of TX partitioned\ntransactions, but managed by the meta layer and activated at a certain\npartition block. Maybe it is not even possible in case of input partitions.\n\nI could imagine that it is too big change. Many cons and pros on partition\nkeys.\n\nWhat is your opinion about it?\n\nCheers,\n\nTamas\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170901/ce983641/attachment-0001.html>"
            },
            {
                "author": "Tom Zander",
                "date": "2017-09-01T13:12:18",
                "message_text_only": "On Friday, 1 September 2017 14:47:08 CEST Cserveny Tamas via bitcoin-dev \nwrote:\n> The fundamental problem is that if the miners add capacity it will only\n> increase (protect) their share of block reward, but does not increase the\n> speed of transactions.\n\nAdding more space in blocks has no effect on the block-reward. It does \nactually increase the throughput speed of transactions.\n\n> This will only raise the fee in the long run with\n> the block reward decreasing.\n\nAlso this is exactly the opposite of what actually happened.\n\n> The current chain is effectively single threaded. \n\nThis is not true, since xthin/compactblocks have been introduced we \ncompletely removed this bottle-neck.\nThe transactions will be validated continuously, in parallel and not just \nwhen a block is found.\n\n-- \nTom Zander\nBlog: https://zander.github.io\nVlog: https://vimeo.com/channels/tomscryptochannel"
            },
            {
                "author": "Lucas Clemente Vella",
                "date": "2017-09-01T17:15:10",
                "message_text_only": "> > The current chain is effectively single threaded.\n>\n> This is not true, since xthin/compactblocks have been introduced we\n> completely removed this bottle-neck.\n> The transactions will be validated continuously, in parallel and not just\n> when a block is found.\n>\n\nIf I understood correctly, OP was not talking about the process inside a\nnode being single threaded, but instead that the whole bitcoin distributed\nsystem behaves as single threaded computation. OP seems to be describing a\nsystem closer to what IOTA uses, by distributing among the miners the task\nof validating the transactions. Although, without more specific details, it\nis hard to judge the benefits.\n\n-- \nLucas Clemente Vella\nlvella at gmail.com\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170901/01e7e191/attachment.html>"
            },
            {
                "author": "Thomas Guyot-Sionnest",
                "date": "2017-09-01T17:24:56",
                "message_text_only": "On 01/09/17 01:15 PM, Lucas Clemente Vella via bitcoin-dev wrote:\n>\n>     > The current chain is effectively single threaded.\n>\n>     This is not true, since xthin/compactblocks have been introduced we\n>     completely removed this bottle-neck.\n>     The transactions will be validated continuously, in parallel and\n>     not just\n>     when a block is found.\n>\n>\n> If I understood correctly, OP was not talking about the process inside\n> a node being single threaded, but instead that the whole bitcoin\n> distributed system behaves as single threaded computation. OP seems to\n> be describing a system closer to what IOTA uses, by distributing among\n> the miners the task of validating the transactions. Although, without\n> more specific details, it is hard to judge the benefits.\n>\n\nIf the goal is reducing the delay for validation then I don't get what\nadvantage there would be vs. reducing the difficulty.\n\nAlso it is my understanding that with the Lightning network transactions\ncould be validated instantly by third parties and could be subject to\nsmaller fees overall...\n\nRegards,\n\n-- \nThomas\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170901/44c8986f/attachment-0001.html>"
            },
            {
                "author": "Cserveny Tamas",
                "date": "2017-09-01T18:15:53",
                "message_text_only": "Yes. I meant the single thread as an analogy, if a block is found, other\nblocks are worthless. (more or less) Longest chain wins.\n\nMy line of though was, that currently the only way to scale with the\ntraffic (and lowering the fees) is increasing the block size (which is hard\nas I learned from recent events), or reducing the complexity which is less\nsecure (most likely more controversial)\n\nSplitting the chain is effectively increasing the block size, but without\nthe increased hashing and validation overhead.\n\nThe usage growth seems to be more of exponential rather than linear. Sooner\nor later the block size will need to be 4 mb then 40 mb, then what is the\nreal limit? Otherwise waiting times and thus the fees will just grow\nrapidly. I don't think that it is desirable.\n\nWith splitting the ledger, the block size can remain 1-2 mb for long time,\nonly new partitions needs to be added on a schedule. This would also make\nbetter use of the hashing capacity.\n\nCheers,\n\nTamas\n\n\n\n\n\n\nOn Fri, Sep 1, 2017 at 7:15 PM Lucas Clemente Vella <lvella at gmail.com>\nwrote:\n\n> > The current chain is effectively single threaded.\n>>\n>> This is not true, since xthin/compactblocks have been introduced we\n>> completely removed this bottle-neck.\n>> The transactions will be validated continuously, in parallel and not just\n>> when a block is found.\n>>\n>\n> If I understood correctly, OP was not talking about the process inside a\n> node being single threaded, but instead that the whole bitcoin distributed\n> system behaves as single threaded computation. OP seems to be describing a\n> system closer to what IOTA uses, by distributing among the miners the task\n> of validating the transactions. Although, without more specific details, it\n> is hard to judge the benefits.\n>\n> --\n> Lucas Clemente Vella\n> lvella at gmail.com\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170901/d908e965/attachment.html>"
            },
            {
                "author": "Thomas Guyot-Sionnest",
                "date": "2017-09-01T19:40:44",
                "message_text_only": "On 01/09/17 02:15 PM, Cserveny Tamas via bitcoin-dev wrote:\n> Yes. I meant the single thread as an analogy, if a block is found,\n> other blocks are worthless. (more or less) Longest chain wins.\n>\n> My line of though was, that currently the only way to scale with the\n> traffic (and lowering the fees) is increasing the block size (which is\n> hard as I learned from recent events), or reducing the complexity\n> which is less secure (most likely more controversial)\n>\n\nIt wouldn't be less secure as long as you adjust the confirmation\naccordingly. If we decided to mine one block every minute, then your\nusual 6 confirmation should become 60 confirmation. In the end, the same\namount of work will have been done to prove the transaction is legit and\nso it's just as secure... Actually, one could argue since the average\nhash rate over 60 block is more accurate than over 6, it's actually more\nsecure if you also pay attention to hash rate variation as part of the\nconfirmation... That help in the scenario a very large pool goes dark to\nmine a sidechain.\n\n-- \nThomas"
            },
            {
                "author": "Tom Zander",
                "date": "2017-09-02T21:13:57",
                "message_text_only": "On Friday, 1 September 2017 20:15:53 CEST Cserveny Tamas wrote:\n> The usage growth seems to be more of exponential rather than linear.\n> Sooner or later the block size will need to be 4 mb then 40 mb, then what\n> is the real limit? Otherwise waiting times and thus the fees will just\n> grow rapidly. I don't think that it is desirable.\n\nThe real limit is set by the technology. Just like in 1990 we could not \nfathom having something like YouTube and high-res video streaming (Netflix), \nthe limits of what is possible continually shifts.\n\nThis is basically how any successful product has ever grown, I think that it \nis not just desirable, it is inevitable.\n-- \nTom Zander\nBlog: https://zander.github.io\nVlog: https://vimeo.com/channels/tomscryptochannel"
            }
        ],
        "thread_summary": {
            "title": "Horizontal scaling of blockchain",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Lucas Clemente Vella",
                "Cserveny Tamas",
                "Tom Zander",
                "Thomas Guyot-Sionnest"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 10910
        }
    },
    {
        "title": "[bitcoin-dev] BIP49 Derivation scheme changes",
        "thread_messages": [
            {
                "author": "Thomas Voegtlin",
                "date": "2017-09-03T05:19:12",
                "message_text_only": "On 30.08.2017 09:24, shiva sitamraju via bitcoin-dev wrote:\n\n> \n> 2. Segwit wallet seed words have a different format which is incompatible\n> with previous wallet seed words. This  encodes the information that this\n> wallet is segwit in the seed words itself. We need to define a structure\n> for this\n> \n\nThat is what Electrum does.\nSee http://docs.electrum.org/en/latest/seedphrase.html"
            },
            {
                "author": "shiva sitamraju",
                "date": "2017-09-05T07:10:15",
                "message_text_only": "Hi,\n\nThanks Thomas. The procedure described in\nhttp://docs.electrum.org/en/latest/seedphrase.html is really what I was\nlooking for ! I really don't see any point of following BIP49, If possible\nit would be great if you can propose an alternative to BIP49 that follows\nsimilar structure to what is used in electrum.\n\nI have proposed following changes to BIP32 serialization format\nhttps://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#serialization-format\nto differentiate segwit xpub/xprv. Below the list of new version bytes,\nresulting base58 prefix and network type:\n\n0x042393df ,  sxpr ,   segwit mainnet private key\n0x04239377 , sxpb , segwit mainnet public key\n0x04222463 , stpb ,  segwit testnet public key\n0x042224cc ,  stpr ,  segwit testnet private key\n\nLet me know your thoughts\n\nOn Tue, Sep 5, 2017 at 12:12 AM, <\nbitcoin-dev-request at lists.linuxfoundation.org> wrote:\n\n> Send bitcoin-dev mailing list submissions to\n>         bitcoin-dev at lists.linuxfoundation.org\n>\n> To subscribe or unsubscribe via the World Wide Web, visit\n>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> or, via email, send a message with subject or body 'help' to\n>         bitcoin-dev-request at lists.linuxfoundation.org\n>\n> You can reach the person managing the list at\n>         bitcoin-dev-owner at lists.linuxfoundation.org\n>\n> When replying, please edit your Subject line so it is more specific\n> than \"Re: Contents of bitcoin-dev digest...\"\n>\n>\n> Today's Topics:\n>\n>    1. Re: Horizontal scaling of blockchain (Cserveny Tamas)\n>    2. Re: Horizontal scaling of blockchain (Thomas Guyot-Sionnest)\n>    3. Re: Horizontal scaling of blockchain (Tom Zander)\n>    4. Re: BIP49 Derivation scheme changes (Thomas Voegtlin)\n>    5. Re: Fwd:  \"Compressed\" headers stream (Peter Todd)\n>    6. Re: \"Compressed\" headers stream (Peter Todd)\n>\n>\n> ----------------------------------------------------------------------\n>\n> Message: 1\n> Date: Fri, 01 Sep 2017 18:15:53 +0000\n> From: Cserveny Tamas <cserveny.tamas+bc at gmail.com>\n> To: Lucas Clemente Vella <lvella at gmail.com>, Tom Zander\n>         <tomz at freedommail.ch>,  Bitcoin Protocol Discussion\n>         <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: Re: [bitcoin-dev] Horizontal scaling of blockchain\n> Message-ID:\n>         <CACY+MSOPWhTnR-ZR67T1a5ZU2w4pWa6FkXsGF3_C+\n> n3gKFCPSA at mail.gmail.com>\n> Content-Type: text/plain; charset=\"utf-8\"\n>\n> Yes. I meant the single thread as an analogy, if a block is found, other\n> blocks are worthless. (more or less) Longest chain wins.\n>\n> My line of though was, that currently the only way to scale with the\n> traffic (and lowering the fees) is increasing the block size (which is hard\n> as I learned from recent events), or reducing the complexity which is less\n> secure (most likely more controversial)\n>\n> Splitting the chain is effectively increasing the block size, but without\n> the increased hashing and validation overhead.\n>\n> The usage growth seems to be more of exponential rather than linear. Sooner\n> or later the block size will need to be 4 mb then 40 mb, then what is the\n> real limit? Otherwise waiting times and thus the fees will just grow\n> rapidly. I don't think that it is desirable.\n>\n> With splitting the ledger, the block size can remain 1-2 mb for long time,\n> only new partitions needs to be added on a schedule. This would also make\n> better use of the hashing capacity.\n>\n> Cheers,\n>\n> Tamas\n>\n>\n>\n>\n>\n>\n> On Fri, Sep 1, 2017 at 7:15 PM Lucas Clemente Vella <lvella at gmail.com>\n> wrote:\n>\n> > > The current chain is effectively single threaded.\n> >>\n> >> This is not true, since xthin/compactblocks have been introduced we\n> >> completely removed this bottle-neck.\n> >> The transactions will be validated continuously, in parallel and not\n> just\n> >> when a block is found.\n> >>\n> >\n> > If I understood correctly, OP was not talking about the process inside a\n> > node being single threaded, but instead that the whole bitcoin\n> distributed\n> > system behaves as single threaded computation. OP seems to be describing\n> a\n> > system closer to what IOTA uses, by distributing among the miners the\n> task\n> > of validating the transactions. Although, without more specific details,\n> it\n> > is hard to judge the benefits.\n> >\n> > --\n> > Lucas Clemente Vella\n> > lvella at gmail.com\n> >\n> -------------- next part --------------\n> An HTML attachment was scrubbed...\n> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> attachments/20170901/d908e965/attachment-0001.html>\n>\n> ------------------------------\n>\n> Message: 2\n> Date: Fri, 1 Sep 2017 15:40:44 -0400\n> From: Thomas Guyot-Sionnest <dermoth at aei.ca>\n> To: Cserveny Tamas <cserveny.tamas+bc at gmail.com>,       Bitcoin Protocol\n>         Discussion <bitcoin-dev at lists.linuxfoundation.org>,     Lucas\n> Clemente\n>         Vella <lvella at gmail.com>, Tom Zander <tomz at freedommail.ch>\n> Subject: Re: [bitcoin-dev] Horizontal scaling of blockchain\n> Message-ID: <e9531342-db9b-ffdf-5ada-0c143eb89d9e at aei.ca>\n> Content-Type: text/plain; charset=windows-1252\n>\n> On 01/09/17 02:15 PM, Cserveny Tamas via bitcoin-dev wrote:\n> > Yes. I meant the single thread as an analogy, if a block is found,\n> > other blocks are worthless. (more or less) Longest chain wins.\n> >\n> > My line of though was, that currently the only way to scale with the\n> > traffic (and lowering the fees) is increasing the block size (which is\n> > hard as I learned from recent events), or reducing the complexity\n> > which is less secure (most likely more controversial)\n> >\n>\n> It wouldn't be less secure as long as you adjust the confirmation\n> accordingly. If we decided to mine one block every minute, then your\n> usual 6 confirmation should become 60 confirmation. In the end, the same\n> amount of work will have been done to prove the transaction is legit and\n> so it's just as secure... Actually, one could argue since the average\n> hash rate over 60 block is more accurate than over 6, it's actually more\n> secure if you also pay attention to hash rate variation as part of the\n> confirmation... That help in the scenario a very large pool goes dark to\n> mine a sidechain.\n>\n> --\n> Thomas\n>\n>\n>\n> ------------------------------\n>\n> Message: 3\n> Date: Sat, 02 Sep 2017 23:13:57 +0200\n> From: Tom Zander <tomz at freedommail.ch>\n> To: Cserveny Tamas <cserveny.tamas+bc at gmail.com>\n> Cc: Bitcoin Protocol Discussion\n>         <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: Re: [bitcoin-dev] Horizontal scaling of blockchain\n> Message-ID: <3416963.LpSpYe5DLS at strawberry>\n> Content-Type: text/plain; charset=\"us-ascii\"\n>\n> On Friday, 1 September 2017 20:15:53 CEST Cserveny Tamas wrote:\n> > The usage growth seems to be more of exponential rather than linear.\n> > Sooner or later the block size will need to be 4 mb then 40 mb, then what\n> > is the real limit? Otherwise waiting times and thus the fees will just\n> > grow rapidly. I don't think that it is desirable.\n>\n> The real limit is set by the technology. Just like in 1990 we could not\n> fathom having something like YouTube and high-res video streaming\n> (Netflix),\n> the limits of what is possible continually shifts.\n>\n> This is basically how any successful product has ever grown, I think that\n> it\n> is not just desirable, it is inevitable.\n> --\n> Tom Zander\n> Blog: https://zander.github.io\n> Vlog: https://vimeo.com/channels/tomscryptochannel\n>\n>\n> ------------------------------\n>\n> Message: 4\n> Date: Sun, 3 Sep 2017 07:19:12 +0200\n> From: Thomas Voegtlin <thomasv at electrum.org>\n> To: bitcoin-dev at lists.linuxfoundation.org\n> Subject: Re: [bitcoin-dev] BIP49 Derivation scheme changes\n> Message-ID: <5a27e555-173e-b5a7-8c05-5ee32e885ee2 at electrum.org>\n> Content-Type: text/plain; charset=utf-8\n>\n>\n>\n> On 30.08.2017 09:24, shiva sitamraju via bitcoin-dev wrote:\n>\n> >\n> > 2. Segwit wallet seed words have a different format which is incompatible\n> > with previous wallet seed words. This  encodes the information that this\n> > wallet is segwit in the seed words itself. We need to define a structure\n> > for this\n> >\n>\n> That is what Electrum does.\n> See http://docs.electrum.org/en/latest/seedphrase.html\n>\n>\n> ------------------------------\n>\n> Message: 5\n> Date: Mon, 4 Sep 2017 10:06:44 -0400\n> From: Peter Todd <pete at petertodd.org>\n> To: Gregory Maxwell <greg at xiph.org>,    Bitcoin Protocol Discussion\n>         <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: Re: [bitcoin-dev] Fwd:  \"Compressed\" headers stream\n> Message-ID: <20170904140644.GF1276 at fedora-23-dvm>\n> Content-Type: text/plain; charset=\"us-ascii\"\n>\n> On Mon, Aug 28, 2017 at 05:12:15PM +0000, Gregory Maxwell via bitcoin-dev\n> wrote:\n> > You are leaving a lot of bytes on the table.\n> >\n> > The bits field can only change every 2016 blocks (4 bytes per header),\n> > the timestamp can not be less than the median of the last 11 and is\n> > usually only a small amount over the last one (saves 2 bytes per\n> > header), the block version is usually one of the last few (save 3\n> > bytes per header).\n> >\n> > But all these things improvements are just a constant factor. I think\n> > you want the compact SPV proofs described in the appendix of the\n> > sidechains whitepaper which creates log scaling proofs.\n>\n> Note that I'm already planning on OpenTimestamps having infrastructure for\n> trusted validity attestations; log scaling proofs alone only prove total\n> work,\n> not validity. Timestamping has all kinds of very dubious security\n> properties\n> when done via proof-of-work, due to various ways that miners can get away\n> with\n> inaccurate block times. In particular, setting a block time backwards is\n> something that miners can do, particularly with majority hashing power,\n> which\n> is the exact thing we're trying to prevent in a timestamp proof.\n>\n> This all makes me dubious about risking further weakening of this already\n> weak\n> security with compact SPV proofs; we'd need a lot more analysis to\n> understand\n> what we're risking. Also note that we can ship a known-good\n> sum-merkle-tree tip hash with the software, which further reduces initial\n> download bandwidth needed to get the block headers on top of this obviously\n> safe eliding of redundant hashes.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> -------------- next part --------------\n> A non-text attachment was scrubbed...\n> Name: signature.asc\n> Type: application/pgp-signature\n> Size: 455 bytes\n> Desc: Digital signature\n> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> attachments/20170904/8be560f7/attachment-0001.sig>\n>\n> ------------------------------\n>\n> Message: 6\n> Date: Mon, 4 Sep 2017 10:10:17 -0400\n> From: Peter Todd <pete at petertodd.org>\n> To: Greg Sanders <gsanders87 at gmail.com>,        Bitcoin Protocol\n> Discussion\n>         <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: Re: [bitcoin-dev] \"Compressed\" headers stream\n> Message-ID: <20170904141017.GG1276 at fedora-23-dvm>\n> Content-Type: text/plain; charset=\"us-ascii\"\n>\n> On Mon, Aug 28, 2017 at 12:26:48PM -0400, Greg Sanders via bitcoin-dev\n> wrote:\n> > Well, if anything my question may bolster your use-case. If there's a\n> > heavier chain that is invalid, I kind of doubt it matters for\n> timestamping\n> > reasons.\n>\n> Timestamping can easily be *more* vulnerable to malicious miners than\n> financial\n> applications for a number of reasons, including the fact that there's no\n> financial feedback loop of miners destroying the value of the coins they\n> produce - timestamping is a non-financial piggy-back application that\n> doesn't\n> directly interact with the Bitcoin economy, beyond a trival number of\n> timestamp\n> transactions.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> -------------- next part --------------\n> A non-text attachment was scrubbed...\n> Name: signature.asc\n> Type: application/pgp-signature\n> Size: 455 bytes\n> Desc: Digital signature\n> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> attachments/20170904/818e9344/attachment.sig>\n>\n> ------------------------------\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> End of bitcoin-dev Digest, Vol 28, Issue 3\n> ******************************************\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170905/a3ece874/attachment-0001.html>"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2017-09-05T15:41:37",
                "message_text_only": "On 05/09/17 09:10, shiva sitamraju via bitcoin-dev wrote:\n> 0x042393df ,  sxpr ,   segwit mainnet private key\n> 0x04239377 , sxpb , segwit mainnet public key\n> 0x04222463 , stpb ,  segwit testnet public key\n> 0x042224cc ,  stpr ,  segwit testnet private key \n\nI am fine with both your proposal and proposal from Thomas\n({x,y,z}{pub,prv}).\n\nLet's just decide ASAP which one we'll use.\n\n\n-- \nBest Regards / S pozdravom,\n\nPavol \"stick\" Rusnak\nCTO, SatoshiLabs"
            },
            {
                "author": "Thomas Voegtlin",
                "date": "2017-09-05T16:33:00",
                "message_text_only": "On 05.09.2017 09:10, shiva sitamraju via bitcoin-dev wrote:\n> Hi,\n> \n> Thanks Thomas. The procedure described in\n> http://docs.electrum.org/en/latest/seedphrase.html is really what I was\n> looking for ! I really don't see any point of following BIP49, If possible\n> it would be great if you can propose an alternative to BIP49 that follows\n> similar structure to what is used in electrum.\n> \n> I have proposed following changes to BIP32 serialization format\n> https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#serialization-format\n> to differentiate segwit xpub/xprv. Below the list of new version bytes,\n> resulting base58 prefix and network type:\n> \n> 0x042393df ,  sxpr ,   segwit mainnet private key\n> 0x04239377 , sxpb , segwit mainnet public key\n> 0x04222463 , stpb ,  segwit testnet public key\n> 0x042224cc ,  stpr ,  segwit testnet private key\n> \n\nI have proposed a similar idea, with letters z,y,z combined with pub/prv\n(see the electrum documentation page)\n\nThe point is that we need 3 types of keys, not 2, because there are two\ntypes of segwit output scripts: native and nested in p2sh.\n\nWe could use t,u,v for testnet."
            },
            {
                "author": "shiva sitamraju",
                "date": "2017-09-06T05:20:31",
                "message_text_only": "Hi Thomas,\n\nCan you explain why P2WPKH nested in BIP16 P2SH require a different version\nthan P2WPKH? It seems to me both would would generate same bitcoin address\nin txout and hence would be in the same wallet account.\n\nI am fine with your proposal too. Would be great if you can list all new\nversions including testnet ones. I would prefer all testnet ones start with\nt (easier to identify) instead of having t,u,v\n\nThanks\n\n\n\nOn Wed, Sep 6, 2017 at 3:21 AM, <\nbitcoin-dev-request at lists.linuxfoundation.org> wrote:\n\n> Send bitcoin-dev mailing list submissions to\n>         bitcoin-dev at lists.linuxfoundation.org\n>\n> To subscribe or unsubscribe via the World Wide Web, visit\n>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> or, via email, send a message with subject or body 'help' to\n>         bitcoin-dev-request at lists.linuxfoundation.org\n>\n> You can reach the person managing the list at\n>         bitcoin-dev-owner at lists.linuxfoundation.org\n>\n> When replying, please edit your Subject line so it is more specific\n> than \"Re: Contents of bitcoin-dev digest...\"\n>\n>\n> Today's Topics:\n>\n>    1. Re: BIP49 Derivation scheme changes (Pavol Rusnak)\n>    2. Re: Proposal: bip32 version bytes for segwit scripts\n>       (Pavol Rusnak)\n>    3. Re: BIP49 Derivation scheme changes (Thomas Voegtlin)\n>    4. Re: Proposal: bip32 version bytes for segwit scripts (Luke Dashjr)\n>    5. Re: Sidechain headers on mainchain (unification of\n>       drivechains and spv proofs) (Chris Stewart)\n>    6. Re: Proposal: bip32 version bytes for segwit scripts\n>       (Thomas Voegtlin)\n>    7. SF proposal: prohibit unspendable outputs with    amount=0\n>       (Jorge Tim?n)\n>\n>\n> ----------------------------------------------------------------------\n>\n> Message: 1\n> Date: Tue, 5 Sep 2017 17:41:37 +0200\n> From: Pavol Rusnak <stick at satoshilabs.com>\n> To: shiva sitamraju <shiva at blockonomics.co>,    Bitcoin Protocol\n>         Discussion <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: Re: [bitcoin-dev] BIP49 Derivation scheme changes\n> Message-ID: <9da64df3-c6a9-c232-c801-f379a6d65e44 at satoshilabs.com>\n> Content-Type: text/plain; charset=windows-1252\n>\n> On 05/09/17 09:10, shiva sitamraju via bitcoin-dev wrote:\n> > 0x042393df ,  sxpr ,   segwit mainnet private key\n> > 0x04239377 , sxpb , segwit mainnet public key\n> > 0x04222463 , stpb ,  segwit testnet public key\n> > 0x042224cc ,  stpr ,  segwit testnet private key\n>\n> I am fine with both your proposal and proposal from Thomas\n> ({x,y,z}{pub,prv}).\n>\n> Let's just decide ASAP which one we'll use.\n>\n>\n> --\n> Best Regards / S pozdravom,\n>\n> Pavol \"stick\" Rusnak\n> CTO, SatoshiLabs\n>\n>\n> ------------------------------\n>\n> Message: 2\n> Date: Tue, 5 Sep 2017 17:44:01 +0200\n> From: Pavol Rusnak <stick at satoshilabs.com>\n> To: Thomas Voegtlin <thomasv at electrum.org>,     Bitcoin Protocol\n>         Discussion <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: Re: [bitcoin-dev] Proposal: bip32 version bytes for segwit\n>         scripts\n> Message-ID: <198be73d-4676-45e9-6e3d-b89f73e31702 at satoshilabs.com>\n> Content-Type: text/plain; charset=windows-1252\n>\n> On 05/09/17 12:25, Thomas Voegtlin via bitcoin-dev wrote:\n> > ========== =========== ===================================\n> > Version    Prefix      Description\n> > ========== =========== ===================================\n> > 0x0488ade4 xprv        P2PKH or P2SH\n> > 0x0488b21e xpub        P2PKH or P2SH\n> > 0x049d7878 yprv        (P2WPKH or P2WSH) nested in P2SH\n> > 0x049d7cb2 ypub        (P2WPKH or P2WSH) nested in P2SH\n> > 0x04b2430c zprv        P2WPKH or P2WSH\n> > 0x04b24746 zpub        P2WPKH or P2WSH\n> > ========== =========== ===================================\n> > (source: http://docs.electrum.org/en/latest/seedphrase.html)\n> >\n> > I have heard the argument that xpub/xprv serialization is a format for\n> > keys, and that it should not be used to encode how these keys are used.\n>\n> I used this argument for mnemonic/seed, not xpub/xprv. I am fine with\n> this proposal of yours, so don't worry.\n>\n> --\n> Best Regards / S pozdravom,\n>\n> Pavol \"stick\" Rusnak\n> CTO, SatoshiLabs\n>\n>\n> ------------------------------\n>\n> Message: 3\n> Date: Tue, 5 Sep 2017 18:33:00 +0200\n> From: Thomas Voegtlin <thomasv at electrum.org>\n> To: bitcoin-dev at lists.linuxfoundation.org\n> Subject: Re: [bitcoin-dev] BIP49 Derivation scheme changes\n> Message-ID: <28d57503-c2b3-7736-bfea-46506636d999 at electrum.org>\n> Content-Type: text/plain; charset=utf-8\n>\n>\n>\n> On 05.09.2017 09:10, shiva sitamraju via bitcoin-dev wrote:\n> > Hi,\n> >\n> > Thanks Thomas. The procedure described in\n> > http://docs.electrum.org/en/latest/seedphrase.html is really what I was\n> > looking for ! I really don't see any point of following BIP49, If\n> possible\n> > it would be great if you can propose an alternative to BIP49 that follows\n> > similar structure to what is used in electrum.\n> >\n> > I have proposed following changes to BIP32 serialization format\n> > https://github.com/bitcoin/bips/blob/master/bip-0032.\n> mediawiki#serialization-format\n> > to differentiate segwit xpub/xprv. Below the list of new version bytes,\n> > resulting base58 prefix and network type:\n> >\n> > 0x042393df ,  sxpr ,   segwit mainnet private key\n> > 0x04239377 , sxpb , segwit mainnet public key\n> > 0x04222463 , stpb ,  segwit testnet public key\n> > 0x042224cc ,  stpr ,  segwit testnet private key\n> >\n>\n> I have proposed a similar idea, with letters z,y,z combined with pub/prv\n> (see the electrum documentation page)\n>\n> The point is that we need 3 types of keys, not 2, because there are two\n> types of segwit output scripts: native and nested in p2sh.\n>\n> We could use t,u,v for testnet.\n>\n>\n> ------------------------------\n>\n> Message: 4\n> Date: Tue, 5 Sep 2017 13:03:39 -0400\n> From: Luke Dashjr <luke at dashjr.org>\n> To: bitcoin-dev at lists.linuxfoundation.org,      Thomas Voegtlin\n>         <thomasv at electrum.org>\n> Subject: Re: [bitcoin-dev] Proposal: bip32 version bytes for segwit\n>         scripts\n> Message-ID: <201709051303.43410.luke at dashjr.org>\n> Content-Type: Text/Plain;  charset=\"iso-8859-1\"\n>\n> On Tuesday 05 September 2017 06:25:16 Thomas Voegtlin via bitcoin-dev\n> wrote:\n> > I have heard the argument that xpub/xprv serialization is a format for\n> > keys, and that it should not be used to encode how these keys are used.\n> > However, the very existence of version bytes, and the fact that they are\n> > used to signal whether keys will be used on testnet or mainnet goes\n> > against that argument.\n> >\n> > If we do not signal the script type in the version bytes, I believe\n> > wallet developers are going to use dirtier tricks, such as the bip32\n> > child number field in combination with bip43/bip44/bip49.\n>\n> I think it makes more sense to use a child number field for this purpose.\n> It seems desirable to use the same seed for all different script formats...\n>\n> As you note, xpub\\xprv are already being used for both P2PKH and P2SH. It\n> really doesn't make sense to differentiate segwit specifically.\n>\n> Luke\n>\n>\n> ------------------------------\n>\n> Message: 5\n> Date: Tue, 5 Sep 2017 12:06:32 -0500\n> From: Chris Stewart <chris at suredbits.com>\n> To: ZmnSCPxj <ZmnSCPxj at protonmail.com>,         Bitcoin Protocol\n> Discussion\n>         <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: Re: [bitcoin-dev] Sidechain headers on mainchain (unification\n>         of drivechains and spv proofs)\n> Message-ID:\n>         <CAGL6+mFHe_SfMea1oMZ3n-G3ey9yToAvTMTcfdxJ5qDD1dTXyQ@\n> mail.gmail.com>\n> Content-Type: text/plain; charset=\"utf-8\"\n>\n> Hi ZmnSCPxj,\n>\n> Basically, in case of a sidechain fork, the mainchain considers the longest\n> > chain to be valid if it is longer by the SPV proof required length.  In\n> the\n> > above, at mainchain block 10, the sidechain H is now 4 blocks (H,G,F,E)\n> > longer than the other sidechain fork that ended at d.\n> >\n> > Mainchain nodes can validate this rule because the sidechain headers are\n> > embedded in the mainchain block's coinbase.  Thus, mainchain fullnodes\n> can\n> > validate this part of the sidechain rule of \"longest work chain\".\n> >\n>\n> What happens in the case that the provided merkle tree hash has a invalid\n> transaction in it? Wouldn't this mean that the mainchain nodes would think\n> the longest work chain is the valid chain, and it would kill off any\n> consensus valid chain that sidechain miners are trying to construct? It\n> seems that a malicious miner could extend the chain to whatever the SPV\n> proof block height is and make it impossible for the chain to reorg after\n> that. I guess if that is a sufficiently long block waiting period it may\n> not be a realistic concern, but something to think about any way.\n>\n> Just a side note -- I think it should be highly recommended that the\n> coinbase maturity period on the sidechain to be longer than 288 (or\n> whatever we decide on the parameter). This incentivizes the s:miners to\n> work together to extend the chain by working with other s:miners (otherwise\n> they won't be able to claim their bribes). If they do not work together\n> they will not be able to spend their s:coinbase_tx outputs until they\n> extend their own sidechain by 288 blocks meaning they need to tie up a\n> large amount of capital to go rogue on their fork.\n>\n> Another interesting thing might be to use the OP_WITHDRAWPROOFVERIFY op\n> code\n> <https://github.com/ElementsProject/elements/blob/\n> elements-0.14.1/src/script/interpreter.cpp#L1420>\n> used in the elements project. Since the cannonical merkle root hashes are\n> included in the mainchain, we can provide a merkle proof to the bitcoin\n> blockchain to initiate a withdrawl from the sidechain. I wrote up a blog\n> post on how OP_WPV works here\n> <https://medium.com/@Chris_Stewart_5/what-can-go-wrong-\n> when-transferring-coins-into-a-sidechain-with-op-withdrawproofverify-\n> b2f49b02ab60>.\n> This allows us to prove that a transaction occurred on the sidechain to\n> lock up those funds.\n>\n> -Chris\n> ?\n> -------------- next part --------------\n> An HTML attachment was scrubbed...\n> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> attachments/20170905/37b0bcbe/attachment-0001.html>\n>\n> ------------------------------\n>\n> Message: 6\n> Date: Tue, 5 Sep 2017 20:09:19 +0200\n> From: Thomas Voegtlin <thomasv at electrum.org>\n> To: Luke Dashjr <luke at dashjr.org>,\n>         \"bitcoin-dev at lists.linuxfoundation.org\"\n>         <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: Re: [bitcoin-dev] Proposal: bip32 version bytes for segwit\n>         scripts\n> Message-ID: <41fb5a09-a964-a81b-497e-70a930b6923c at electrum.org>\n> Content-Type: text/plain; charset=utf-8\n>\n>\n>\n> On 05.09.2017 19:03, Luke Dashjr wrote:\n>\n> > It seems desirable to use the same seed for all different script\n> formats...\n>\n> That does not seem desirable to everybody.\n>\n> If you want to guarantee that users will be able to recover all their\n> funds from their mnemonic seed (and that is what they expect), then\n> wallets must implement all script formats, even the ones that are\n> deprecated. In addition, the list of script formats that must be\n> supported is not defined in advance, but it keeps growing. This makes\n> wallet implementation increasingly difficult. In the long run, seed\n> portability is guaranteed to fail in such a system.\n>\n> > As you note, xpub\\xprv are already being used for both P2PKH and P2SH. It\n> > really doesn't make sense to differentiate segwit specifically.\n>\n> That's not a reason. The fact that xpub/xprv can be used for both P2PKH\n> and P2SH has already resulted in users receiving coins on addresses they\n> do not control.\n>\n>\n> ------------------------------\n>\n> Message: 7\n> Date: Tue, 5 Sep 2017 23:51:45 +0200\n> From: Jorge Tim?n <jtimon at jtimon.cc>\n> To: Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: [bitcoin-dev] SF proposal: prohibit unspendable outputs with\n>         amount=0\n> Message-ID:\n>         <CABm2gDojDQWMhw8wW1UkRGKtdbby2+6AFFZLPuRcUb7WF_u5qQ at mail.\n> gmail.com>\n> Content-Type: text/plain; charset=\"UTF-8\"\n>\n> This is not a priority, not very important either.\n> Right now it is possible to create 0-value outputs that are spendable\n> and thus stay in the utxo (potentially forever). Requiring at least 1\n> satoshi per output doesn't really do much against a spam attack to the\n> utxo, but I think it would be slightly better than the current\n> situation.\n>\n> Is there any reason or use case to keep allowing spendable outputs\n> with null amounts in them?\n>\n> If not, I'm happy to create a BIP with its code, this should be simple.\n>\n>\n> ------------------------------\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> End of bitcoin-dev Digest, Vol 28, Issue 6\n> ******************************************\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170906/4a418ba1/attachment-0001.html>"
            },
            {
                "author": "Dan Libby",
                "date": "2017-09-06T07:19:31",
                "message_text_only": "On 08/30/2017 12:24 AM, shiva sitamraju via bitcoin-dev wrote:\n\n> What would happen if you recover a wallet  using seed words ?\n>   1. Since there is no difference in seed words between segwit/non\n> segwit, the wallet would discover both m/44' and m/49' accounts\n>   2. Note that we cannot ask the user to choose an account he wants to\n> operate on (Segwit/Non segwit). This is like asking him the HD\n> derivation path and a really bad UI\n>   3. The wallet now has to constantly monitor both m/44' and m/49'\n> accounts for transactions\n\nsmall nit with 3.\n\nIt seems to me that the wallet would perform initial discovery on m/44\nand m/49, and then would find transactions at one or the other, so it\ncan then record the type somewhere and from then on need only monitor\none branch.\n\nStill, I agree it is ugly, makes initial discovery up to 2x slower, etc.\n\n> *- XPUB Derivation*\n> This is something not addressed in the BIP yet.\n> \n> 1. Right now you can get an xpub balance/transaction history. With m/49'\n> there is no way to know whether an xpub is from m/44' or m/49'\n> \n> 2. This breaks lots of things. Wallets like electrum/armory/mycelium\n> <https://blog.trezor.io/using-mycelium-to-watch-your-trezor-accounts-a836dce0b954>support\n> importing  xpub as a watch only wallet. Also services like\n> blockonomics/blockchain.info <http://blockchain.info> use xpub for\n> displaying balance/generating merchant addresses\n> \n> Looking forward to hearing your thoughts\n\nspeaking as author of tools hd-wallet-addrs and hd-wallet-derive, I\nagree this is problematic.\n\nwould be great if xpub/xprv could somehow encode their absolute path in\nwallet for tools to read.  Users cannot be expected to know."
            }
        ],
        "thread_summary": {
            "title": "BIP49 Derivation scheme changes",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "shiva sitamraju",
                "Thomas Voegtlin",
                "Dan Libby",
                "Pavol Rusnak"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 29366
        }
    },
    {
        "title": "[bitcoin-dev] P2WPKH Scripts, P2PKH Addresses, and Uncompressed Public Keys",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2017-09-04T13:51:35",
                "message_text_only": "On Mon, Aug 28, 2017 at 08:55:47PM +0000, Alex Nagy via bitcoin-dev wrote:\n> Thanks Gregory - to be clear should Native P2WPKH scripts only appear in redeem scripts?  From reading the various BIPs it had seemed like Native P2WPKH and Native P2WSH were also valid and identifiable if they were encoded in TxOuts.  The theoretical use case for this would be saving bytes in Txes with many outputs.\n\nIt's not a theoretical use-case: the two OpenTimestamps calendar servers I run\n- {alice,bob}.btc.calendar.opentimestamps.org - use native P2WPKH segwit\noutputs to keep transaction size to the absolute minimum possible; previously\nthey used bare CHECKSIG <pubkey> output scripts for the same reason.\n\nI enabled support for it the moment segwit activated, so I'm probably the first\never production user of P2WPKH on mainnet, and quite possibly, the first person\nto create P2WPKH outputs on mainnet for any reason.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170904/74b9488c/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "P2WPKH Scripts, P2PKH Addresses, and Uncompressed Public Keys",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Peter Todd"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1239
        }
    },
    {
        "title": "[bitcoin-dev] Fwd:  \"Compressed\" headers stream",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2017-09-04T14:06:44",
                "message_text_only": "On Mon, Aug 28, 2017 at 05:12:15PM +0000, Gregory Maxwell via bitcoin-dev wrote:\n> You are leaving a lot of bytes on the table.\n> \n> The bits field can only change every 2016 blocks (4 bytes per header),\n> the timestamp can not be less than the median of the last 11 and is\n> usually only a small amount over the last one (saves 2 bytes per\n> header), the block version is usually one of the last few (save 3\n> bytes per header).\n> \n> But all these things improvements are just a constant factor. I think\n> you want the compact SPV proofs described in the appendix of the\n> sidechains whitepaper which creates log scaling proofs.\n\nNote that I'm already planning on OpenTimestamps having infrastructure for\ntrusted validity attestations; log scaling proofs alone only prove total work,\nnot validity. Timestamping has all kinds of very dubious security properties\nwhen done via proof-of-work, due to various ways that miners can get away with\ninaccurate block times. In particular, setting a block time backwards is\nsomething that miners can do, particularly with majority hashing power, which\nis the exact thing we're trying to prevent in a timestamp proof.\n\nThis all makes me dubious about risking further weakening of this already weak\nsecurity with compact SPV proofs; we'd need a lot more analysis to understand\nwhat we're risking. Also note that we can ship a known-good\nsum-merkle-tree tip hash with the software, which further reduces initial\ndownload bandwidth needed to get the block headers on top of this obviously\nsafe eliding of redundant hashes.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170904/8be560f7/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Fwd:  \"Compressed\" headers stream",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Peter Todd"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1889
        }
    },
    {
        "title": "[bitcoin-dev] \"Compressed\" headers stream",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2017-09-04T14:10:17",
                "message_text_only": "On Mon, Aug 28, 2017 at 12:26:48PM -0400, Greg Sanders via bitcoin-dev wrote:\n> Well, if anything my question may bolster your use-case. If there's a\n> heavier chain that is invalid, I kind of doubt it matters for timestamping\n> reasons.\n\nTimestamping can easily be *more* vulnerable to malicious miners than financial\napplications for a number of reasons, including the fact that there's no\nfinancial feedback loop of miners destroying the value of the coins they\nproduce - timestamping is a non-financial piggy-back application that doesn't\ndirectly interact with the Bitcoin economy, beyond a trival number of timestamp\ntransactions.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170904/818e9344/attachment-0001.sig>"
            }
        ],
        "thread_summary": {
            "title": "\"Compressed\" headers stream",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Peter Todd"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 972
        }
    },
    {
        "title": "[bitcoin-dev] Sidechain headers on mainchain (unification of drivechains and spv proofs)",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2017-09-05T08:21:59",
                "message_text_only": "Good morning all,\n\nI have started to consider a unification of drivechains, blind merged mining, and sidechain SPV proofs to form yet another solution for sidechains.\n\nBriefly, below are the starting assumptions:\n\n1.  SPV proofs are a short chain of sidechain block headers.  This is used to prove to the mainchain that some fund has been locked in the sidechain and the mainchain should unlock an equivalent fund to the redeemer.\n\n2.  SPV proofs are large and even in compact form, are still large.  We can instead use miner voting to control whether some mainchain fund should be unlocked.  Presumably, the mainchain miners are monitoring that the sidechain is operating correctly and can know directly if a side-to-main peg is valid.\n\n3.  To maintain mainchain's security, we should use merged mining for sidechain mining rather than have a separate set of miners for mainchain and each sidechain.\n\n4.  A blockchain is just a singly-linked list.  Genesis block is the NULL of the list.  Additional blocks are added at the \"front\" of the singly-linked list.  In Bitcoin, the Merkle tree root is the \"pointer to head\" and the previous block header ID is the \"pointer to tail\"; additional data like proof-of-work nonce, timestamp, and version bits exist but are not inherent parts of the blockchain linked list.\n\n5.  In addition to SPV proofs, we should also support reorg proofs.  Basically, a reorg proof is a longer SPV proof that shows that a previous SPV proof is invalid.\n\n--\n\nWith those, I present the idea, \"sidechain headers in mainchain\".\n\nLet us modify Sztorc's OP_BRIBEVERIFY to require the below SCRIPT to use:\n\n<Previous Sidechain Block Header Hash> <Current Sidechain Block Merkle Tree> <Sidechain ID> OP_BRIBEVERIFY OP_DROP OP_DROP OP_DROP\n\nWe also require that <Sidechain ID> be filled only once per mainchain block, as per the \"blind\" merge mining of Sztorc.\n\nThe key insight is that the <Previous Sidechain Block Header Hash> and <Current Sidechain Block Merkle Tree> are, in fact, the sidechain header.  Concatenating those data and hashing them is the block header hash.  Just as additional information (like extranonce and witness commitment) are put in the mainchain coinbase transaction, any additional information that the sidechain would have wanted to put in its header can be committed to in the sidechain's equivalent of a coinbase transaction (i.e. a sidechain header transaction).\n\n(All three pieces of data can be \"merged\" into a single very long data push to reduce the number of OP_DROP operations, this is a detail)\n\nThus, the sidechain header chain (but not the block data) is embedded in the mainchain itself.\n\nThus, SPV proofs do not need to present new data to the mainchain.  Instead, the mainchain already embeds the SPV proof, since the headers are already in the mainchain's blocks.  All that is needed to unlock a lockbox is to provide some past sidechain header hash (or possibly just a previous mainchain block that contains the sidechain header hash, to make it easier for mainchain nodes to look up) and the Merkle path to a sidechain-side side-to-main peg  transaction.  If the sidechain header chain is \"long enough\" (for example, 288 sidechain block headers) then it is presumably SPV-safe to release the funds on the mainchain side.\n\n--\n\nSuppose a sidechain is reorganized, while a side-to-main peg transaction is in the sidechain that is to be reorganized away.\n\nLet us make our example simpler by requiring an SPV proof to be only 4 sidechain block headers.\n\nIn the example below, small letters are sidechain block headers to be reorganized, large letters are sidechain block headers that will be judged valid.  The sidechain block header \"Aa\" is the fork point.  b' is the sidechain block containing the side-to-main peg that is lost.\n\nRemember, for each mainchain block, only a single sidechain block header for a particular sidechain ID can be added.\n\nThe numbers in this example below are mainchain block height numbers.\n\n0: Aa\n1: b'\n2: c\n4: C\n5: d\n6: D\n7: E\n8: F\n9: G\n10: H <- b' side-to-main is judged as \"not valid\"\n\nBasically, in case of a sidechain fork, the mainchain considers the longest chain to be valid if it is longer by the SPV proof required length.  In the above, at mainchain block 10, the sidechain H is now 4 blocks (H,G,F,E) longer than the other sidechain fork that ended at d.\n\nMainchain nodes can validate this rule because the sidechain headers are embedded in the mainchain block's coinbase.  Thus, mainchain fullnodes can validate this part of the sidechain rule of \"longest work chain\".\n\n--\n\nSuppose I wish to steal funds from sidechain, by stealing the sidechain lockboxes on the mainchain.  I can use the OP_BRIBEVERIFY opcode which Sztorc has graciously provided to cause miners that are otherwise uninterested in the sidechain to put random block headers on a sidechain fork.  Since the mainchain nodes are not going to verify the sidechain blocks (and are unaware of sidechain block formats in detail, just the sidechain block headers), I can get away with this on the mainchain.\n\nHowever, to do so, I need to pay OP_BRIBEVERIFY multiple times.  If our rule is 288 sidechain blocks for an SPV proof, then I need to pay OP_BRIBEVERIFY 288 times.\n\nThis can then be used to reduce the risk of theft.  If lockboxes have a limit in value, or are fixed in value, that maximum/fixed value can be made small enough that paying OP_BRIBEVERIFY 288 times is likely to be more expensive than the lockbox value.\n\nIn addition, because only one sidechain header can be put for each mainchain header, I will also need to compete with legitimate users of the sidechain.  Those users may devote some of their mainchain funds to keep the sidechain alive and valid by paying OP_BRIBEVERIFY themselves.  They will reject my invalid sidechain block and build from a fork point before my theft attempt.\n\nBecause the rule is that the longest sidechain must beat the second-longest chain by 288 (or however many) sidechain block headers, legitimate users of the sidechain will impede my progress to successful theft.  This makes it less attractive for me to attempt to steal from the sidechain.\n\nThe effect is that legitimate users are generating reorg proofs while I try to complete my SPV proof.  As the legitimate users increase their fork, I need to keep up and overtake them.  This can make it unattractive for me to steal from the sidechain.\n\nNote however that we assume here that a side-to-main peg cannot occur more often than an entire SPV proof period.\n\n--\n\nSuppose I am a major power with influence over >51% of mainchain miners.  What happens if I use that influence to cause the greatest damage to the sidechain?\n\nI can simply ask my miners to create invalid side-to-main pegs that unlock the sidechain's lockboxes.  With a greater than 51% of mainchain miners, I do not need to do anything like attempt to double-spend mainchain UTXO's.  Instead, I can simply ask my miners to operate correctly to mainchain rules, but violate sidechain rules and steal the sidechain's lockboxes.\n\nWith greater than 51% of mainchain miners, I can extend my invalid sidechain until we reach the minimum necessary SPV proof.  Assuming a two-way race between legitimate users of the sidechain and me, since I have >51% of mainchain miners, I can build the SPV proof faster than the legitimate users can create a reorg proof against me.  This is precisely the same situation that causes drivechain to fail.\n\nAn alternative is to require that miners participating in sidechains to check the sidechain in full, and to consider mainchain blocks containing invalid sidechain headers as invalid.  However, this greatly increases the amount of data that a full miner needs to be able to receive and verify, effectively increasing centralization risk for the mainchain.\n\n--\n\nThe central idea of drivechain is simply that miners vote on the validity of sidechain side-to-main pegs.  But this is effectively the same as miners - and/or OP_BRIBEVERIFY users - only putting valid sidechain block headers on top of valid sidechain block headers.  Thus, if we instead use sidechain-headers-on-mainchain, the \"vote\" that the sidechain side-to-main peg is valid, is the same as a valid merge-mine of the sidechain.\n\nSPV proofs are unnecessary in drivechain.  In sidechain-header-on-mainchain, SPV proofs are already embedded in the mainchain.  In drivechain, we ask mainchain fullnodes to trust miners.  In sidechain-header-on-mainchain, mainchain fullnodes validate SPV proofs on the mainchain, without trusting anyone and without running sidechain software.\n\nTo validate the mainchain, a mainchain node keeps a data structure for each existing sidechain's fork.\n\nWhen the sidechain is first created (perhaps by some special transaction that creates the sidechain's genesis block header and/or sidechain ID, possibly with some proof-of-burn to ensure that Bitcoin users do not arbitrarily create \"useless\" sidechains, but still allowing permissionless creation of sidechains), the mainchain node creates that data structure.\n\nThe data structure contains:\n\n1.  A sidechain block height, a large number initially 0 at sidechain genesis.\n2.  A side-to-main peg pointer, which may be NULL, and which also includes a block height at which the side-to-main peg is.\n3.  Links to other forks of the same sidechain ID, if any.\n4.  The top block header hash of the sidechain (sidechain tip).\n\nIf the sidechain's block header on a mainchain block is the direct descendant of the current sidechain tip, we just update the top block header hash and increment the block height.\n\nIf there is a side-to-main peg on the sidechain block header, if the side-to-main peg pointer is NULL, we initialize it and store the block height at which the side-to-main peg exists.  If there is already a pending side-to-main peg, the mainchain block is judged invalid; thus for a 288-block region only one side-to-main peg can be done.\n\nIf, for a mainchain block, the sidechain header does NOT extend the most recent sidechain tip, we have detected a sidechain split condition.  We then create a copy of the data structure for the tallest fork, then roll it back until we reach the split point; this rollback should also clear the side-to-main pointer, if we rollback to a blockheight below the side-to-main peg.  Rollback is delimited: if after 288 sidechain headers we have not found the split point, the mainchain node rejects the mainchain block as invalid.  Thus new sidechain forks cannot be started further back than our SPV proof size on the current longest sidechain.  This allows powerful individuals to kill the sidechain by spending sufficient OP_BRIBEVERIFY to put random numbers on the sidechain headers, preventing the sidechain from ever operating correctly unless the sidechain accepts this loss of valid headers specially.\n\nIf there is only a single such structure for a sidechain, the sidechain is single-chained and not under attack.  If the side-to-main peg pointer is non-null and the block height of the sidechain is 288 higher than the recorded block height, the side-to-main peg is added as a UTXO to our UTXO set.\n\nIf there are multiple such structures, the sidechain is in a contentious chainsplit condition (the \"under attack\" flag).  A side-to-main peg is valid (becomes a UTXO) only if it exists (i.e. is the same) on all forks of the sidechain, and the shortest fork is 288 higher than the side-to-main peg height.  This allows side-to-main pegs occurring before a contentious fork to be redeemed.\n\nWhen there are multiple forks of a sidechain, the mainchain node keeps track of all of them.  It sorts these forks by blockheight.  The tallest chain is the reference.  If some fork has height less than the height of the tallest chain minus 288 (the SPV proof size), the mainchain node drops it.  Then that sidechain fork can no longer be extended; if it is the only fork lacking a particular side-to-main peg that exists on all the other forks, then the side-to-main peg becomes a UTXO.  Once all contentious forks have been dropped, the sidechain returns to normal operation.\n\nNote that this implies that side-to-main pegs that occur after a contentious sidechain fork will be delayed.  This is to be expected as there is contention as to which chain is correct.\n\nNote that this implies that sidechains must \"run in lockstep\" with mainchain.  In particular, if the mainchain splits, the sidechain also splits.  This allows two-way pegs to be asymmetrical, with sidechain fullnodes also being mainchain fullnodes, and immediate main-to-side pegs.\n\nFinally, mainchain fullnodes validate side-to-main transfers, but do not need to run sidechain software.  Users of sidechains are expected to protect themselves by ensuring they have mainchain miners that will do their best to protect the sidechain by only extending the valid longest sidechain, and by spending maincoin on OP_BRIBEVERIFY.\n\n--\n\nSuppose I want to use a sidechain, but I worry some troll will want to attack the sidechain via the OP_BRIBEVERIFY vulnerability.  What can I do to protect my investment?\n\nPerhaps a \"protector\" can be hired.  Such a protector will be paid in sidechain funds, at a premium, for use of its mainchain funds.  Such a protector will then use OP_BRIBEVERIFY on the mainchain to ensure a valid sidechain is extended on the mainchain.  Indeed, this is exactly the \"sidechain miner\" envisioned by Sztorc in blind merged mining: sidechain users offer a sidecoin fee to these protectors, who spend maincoin to perform OP_BRIBEVERIFY on the mainchain.  These protectors are paid in sidecoin in order to encourage them to protect the sidechain; they cannot spend sidecoin if the sidechain is successfully attacked.\n\nMainchain miners who wish to take on \"protector\" role can simply act as if they are being paid OP_BRIBEVERIFY for the sidechain they wish to protect.  However, in particular mainchain miners should not treat sidechain rules at the same level as mainchain rules: even if a sidechain block header is judged to be invalid, the mainchain miner should not reject the mainchain block.  It can only refuse to build a sidechain block header on top of an invalid sidechain block header.  Only if a sidechain is sufficiently in use can we propose the sidechain's rules to be added to mainchain as mainchain rules in a softfork.  Needless to say, miners taking on this role must have even larger datacenters in order to handle the increased bandwidth, storage, and processing load to handle both mainchain mining and sidechain protection.\n\n--\n\nThe number 288 in all cases is a parameter that can be endlessly debated.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170905/def51eaf/attachment-0001.html>"
            },
            {
                "author": "Chris Stewart",
                "date": "2017-09-05T17:06:32",
                "message_text_only": "Hi ZmnSCPxj,\n\nBasically, in case of a sidechain fork, the mainchain considers the longest\n> chain to be valid if it is longer by the SPV proof required length.  In the\n> above, at mainchain block 10, the sidechain H is now 4 blocks (H,G,F,E)\n> longer than the other sidechain fork that ended at d.\n>\n> Mainchain nodes can validate this rule because the sidechain headers are\n> embedded in the mainchain block's coinbase.  Thus, mainchain fullnodes can\n> validate this part of the sidechain rule of \"longest work chain\".\n>\n\nWhat happens in the case that the provided merkle tree hash has a invalid\ntransaction in it? Wouldn't this mean that the mainchain nodes would think\nthe longest work chain is the valid chain, and it would kill off any\nconsensus valid chain that sidechain miners are trying to construct? It\nseems that a malicious miner could extend the chain to whatever the SPV\nproof block height is and make it impossible for the chain to reorg after\nthat. I guess if that is a sufficiently long block waiting period it may\nnot be a realistic concern, but something to think about any way.\n\nJust a side note -- I think it should be highly recommended that the\ncoinbase maturity period on the sidechain to be longer than 288 (or\nwhatever we decide on the parameter). This incentivizes the s:miners to\nwork together to extend the chain by working with other s:miners (otherwise\nthey won't be able to claim their bribes). If they do not work together\nthey will not be able to spend their s:coinbase_tx outputs until they\nextend their own sidechain by 288 blocks meaning they need to tie up a\nlarge amount of capital to go rogue on their fork.\n\nAnother interesting thing might be to use the OP_WITHDRAWPROOFVERIFY op code\n<https://github.com/ElementsProject/elements/blob/elements-0.14.1/src/script/interpreter.cpp#L1420>\nused in the elements project. Since the cannonical merkle root hashes are\nincluded in the mainchain, we can provide a merkle proof to the bitcoin\nblockchain to initiate a withdrawl from the sidechain. I wrote up a blog\npost on how OP_WPV works here\n<https://medium.com/@Chris_Stewart_5/what-can-go-wrong-when-transferring-coins-into-a-sidechain-with-op-withdrawproofverify-b2f49b02ab60>.\nThis allows us to prove that a transaction occurred on the sidechain to\nlock up those funds.\n\n-Chris\n\u200b\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170905/37b0bcbe/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-09-05T23:32:17",
                "message_text_only": "Good morning Chris,\n\n>>Basically, in case of a sidechain fork, the mainchain considers the longest chain to be valid if it is longer by the SPV proof required length.  In the above, at mainchain block 10, the sidechain H is now 4 blocks (H,G,F,E) longer than the other sidechain fork that ended at d.\n>>\n>>Mainchain nodes can validate this rule because the sidechain headers are embedded in the mainchain block's coinbase.  Thus, mainchain fullnodes can validate this part of the sidechain rule of \"longest work chain\".\n>>\n>What happens in the case that the provided merkle tree hash has a invalid transaction in it? Wouldn't this mean that the mainchain nodes would think the longest work chain is the valid chain, and it would kill off any consensus valid chain that sidechain miners are trying to construct? It seems that a malicious miner could extend the chain to whatever the SPV proof block height is and make it impossible for the chain to reorg after that. I guess if that is a sufficiently long block waiting period it may not be a realistic concern, but something to think about any way.\n\nThis is exactly the problem, and one which exists in a different form in any sidechain proposal.  In drivechain, malicious mainchain miners may arbitrarily downvote any side-to-main peg even if the side-to-main peg is valid on the sidechain, with mainchain fullnodes unable to gainsay them.  In original sidechain's SPV proofs, malicious mainchain miners may provide an invalid SPV proof and then censor any reorg proof against that SPV proof.  In both of those cases, trust in the sidechain and the value of sidecoin necessarily takes a hit.\n\nOf course, in both of those two cases, the hit is \"temporary\" and the sidechain could theoretically recover.  In sidechain-headers-on-mainchain, the hit would permanently kill the sidechain.\n\nThe fact that sidechains are merge mined and cannot be mined off-mainchain makes sidechains entirely dependent on mainchain miner's support.  I agree with Sztorc that sidechains must be merge mined entirely, otherwise the sidechain will effectively reduce mainchain security by pulling away potential miners from mainchain.\n\nOP_BRIBEVERIFY, which is intended to allow sidechain miners/protectors to be a separate datacenter from miners, allows anyone with either enough hashpower or enough maincoin to disrupt a sidechain by spamming its slot with random hash values.  With enough disruption, the sidechain may become unusable in drivechains, but may indeed be killed that way in sidechain-headers-on-mainchain.\n\n>\n>Just a side note -- I think it should be highly recommended that the coinbase maturity period on the sidechain to be longer than 288 (or whatever we decide on the parameter). This incentivizes the s:miners to work together to extend the chain by working with other s:miners (otherwise they won't be able to claim their bribes). If they do not work together they will not be able to spend their s:coinbase_tx outputs until they extend their own sidechain by 288 blocks meaning they need to tie up a large amount of capital to go rogue on their fork.\n\nYes, this seems sensible.\n\n>\n>Another interesting thing might be to use the OP_WITHDRAWPROOFVERIFY op code used in the elements project. Since the cannonical merkle root hashes are included in the mainchain, we can provide a merkle proof to the bitcoin blockchain to initiate a withdrawl from the sidechain. I wrote up a blog post on how OP_WPV works here. This allows us to prove that a transaction occurred on the sidechain to lock up those funds.\n\nYes.\n\nEven without sidechain headers on mainchain, one might consider plain blind merged mining to have put even the \"previous block hash\" in the sidechain block coinbase transaction.  Thus, one might consider that in blind merged mining, h' commitments are really merkle tree roots, and the previous block hash is encoded in a special sidechain transaction on one side of the merkle tree, while sidechain block transactions are encoded in the other side of the merkle tree root.  This allows OP_WITHDRAWPROOFVERIFY to be used on blind merged mining, but without sidechain headers on mainchain, a compact SPV proof somehow must still be provided, or we are forced to use drivechain miner voting.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170905/e263f3ff/attachment.html>"
            },
            {
                "author": "Chris Stewart",
                "date": "2017-09-08T20:14:30",
                "message_text_only": "Hi ZmnSCPxj,\n\nHowever, a lockbox on one chain is a WT on the other\n> chain.  We can create a free lockbox on Ess, then use that lockbox as\n> a WT on Tee, inflating TeeCoin.\n\n\nI'm not sure if I follow what you are saying here. What do you mean by\n'free lockbox'? I was assuming that I created an arbitrary blockchain, say\nChrisChain, that is NOT pegged to the bitcoin blockchain? I.e. the tokens\non ChrisChain are worthless. Then I create a lockbox on ChrisChain with my\nworthless tokens and attempt to transfer them into TeeCoin's chain? However\nthis doesn't make sense with\n\n\nHowever, this parameter is used to determine if it is a WT.  Sidechain\n> consensus should require that freely-created lockboxes set this\n> parameter to 0, so that a side block that creates free lockboxes where\n> this parameter is non-zero is an invalid side block.  Then a sidechain\n> will only treat a lockbox on another chain as a WT if the wtFlag\n> parameter is nonzero.  This way, freely-created lockboxes are not\n> valid WT.  Valid WT must lock actual, already unlocked coins, not\n> create new locked coins.\n>\n\nbecause I could arbitrarily set this parameter to 0. It seems that a\nsidechain upon inception should pay all of it's tokens to a single UTXO and\nprevent minting of coins after that. I'm fairly certain this is what\nelements does in it's genesis block.\n\nThe is unrelated to the problem above, but it will be a problem in\nsidchain-headers-on-mainchain if we have a limited amount of mining slots\nin the coinbase_tx output vector.\n\nLet us assume we have a fixed set of sidechain slots in the coinbase output\nvector, in this case 10. However there are 15 competing sidechains for\nthese 10 slots. It may be possible for sidechains (say 15 sidechains) to\ncompete indefinitely for these 10 slots -- causing indefinite forks. Let us\nsay sidechain 10 and sidechain 11 alternate block hashes in\ncoinbase_tx.vout[10] output. This means that a WT^ will never be considered\nvalid because it will appear to mainchain miners that there are competing\nforks of the SAME sidechain, when in reality it is two unique sidechains\ncompeting to mine the the limited coinbase output vector space.\n\n-Chris\n\nOn Fri, Sep 8, 2017 at 9:56 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning,\n>\n> Chris mentioned the use of OP_WITHDRAWPROOFVERIFY.  I've come to realize\n> that this is actually superior to use OP_WITHDRAWPROOFVERIFY with a\n> sidechain-headers-on-mainchain approach.\n>\n> Briefly, a payment to OP_WITHDRAWPROOFVERIFY is an instruction to transfer\n> value from the mainchain to a sidechain.  Thus, a payment to\n> OP_WITHDRAWPROOFVERIFY includes the sidechain to pay to, and a commitment\n> to a sidechain address (or whatever is the equivalent to a sidechain\n> address).\n>\n> Various OP_WITHDRAWPROOFVERIFY explanations exist.  Most of them include\n> OP_REORGPROOFVERIFY.  With sidechain-headers-on-mainchain, however, there\n> is\n> no need for reorg proofs.  This is because, the mainchain can see, in real\n> time, which branch of the sidechain is getting extended.  Thus if someone\n> attempts to defraud a sidechain by forking the sidechain to an invalid\n> state, sidechainers can immediately detect this on the mainchain and\n> immediately act to prevent the invalid fork from being advanced.  After\n> all, a reorg proof is really just an SPV proof that is longer than some\n> previous SPV proof, that shows that the previous SPV proof is incorrect,\n> by showing that the block at the specified height of the WT is not present\n> on a longer SPV proof.\n>\n> Since sidechain-headers-on-mainchain implies merge mining of sidechains,\n> with no option to have independent proof-of-work of sidechains, the\n> sidechain's entire history is recorded on the mainchain, visible to all\n> mainchain nodes.\n>\n> --\n>\n> An advantage of sidechain-headers-on-mainchain is a side-to-side peg\n> without\n> passing through the mainchain.\n> That is, a 2-way peg between any two chains, whether side or main.\n>\n> Sidechains supporting side-to-side transfer would require supporting\n> OP_WITHDRAWPROOFVERIFY, but not any of the other parts of sidechains.\n>\n> We must consider a WT format (withdrawal transaction) that is compatible\n> with an OP_WITHDRAWPROOFVERIFY Bitcoin transaction.\n>\n> ***That is, a lockbox UTXO on one chain is a WT on another chain.***\n>\n> Sidechains need not follow the mainchain format for its normal\n> transactions, only for WT transactions that move coins across chains.\n>\n> For this, mainchain should also have its own \"sidechain ID\".  Perhaps a\n> sidechain ID of 0 would be appropriate for mainchain, as its status as\n> mainchain.\n>\n> Suppose we have two sidechains, Ess and Tee, both of which support\n> side-to-side pegs.\n>\n> An Ess fullnode is a Bitcoin fullnode, but an Ess fullnode is not\n> necessarily a Tee fullnode, and vice versa.\n>\n> A lockbox redemption in sidechain-headers-on-mainchain is simply a spend of\n> a lockbox, pointing to the sidechain header containing WT, the merkle tree\n> path to the WT transaction from the h* commitment of the header, the output\n> which locks, and so on as per usual OP_WITHDRAWPROOFVERIFY.\n>\n> Then a sidechain can create tokens from nothing, that are locked in a\n> OP_WITHDRAWPROOFVERIFY lockbox; this is the only way to create sidecoin.\n> When transferring into a sidechain from mainchain, or anywhere, the\n> sidechain either creates tokens locked into OP_WITHDRAWPROOFVERIFY, or\n> looks for an existing UTXO with OP_WITHDRAWPROOFVERIFY from the source\n> chain and spends them (the latter is preferred as it is fewer\n> transactions and less space on the sideblock, reducing sidechain fees).\n>\n> OP_WITHDRAWPROOFVERIFY on a sidechain would query the mainchain fullnodes.\n> Whatever rules allow lockbox unlocking on mainchain, will also be the same\n> rules that allow lockbox unlocking on sidechains.\n> A mainchain RPC can even be made to simplify sidechain verification of\n> side-to-side pegs, and to ensure that sidechains follow the same consensus\n> rules for OP_WITHDRAWPROOFVERIFY.\n>\n> So if we want transfer TeeCoin to EssCoin, we spend into a\n> OP_WITHDRAWPROOFVERIFY lockbox on Teechain pointing to Esschain (i.e. a\n> Tee->Ess lockbox).  This lockbox is itself a WT from the point of view of\n> Esschain.  On Esschain, we look for an existing Ess->Tee lockbox, or\n> create a Ess->Tee lockbox of our own for a EssCoin fee.  Then we create a\n> spend of the Ess->Tee lockbox on Esschain, wait until spending is\n> possible, and then post that transaction on Esschain.\n>\n> Again, with sidechain-headers-on-mainchain, reorg proofs are unnecessary,\n> since any invalid chain should be quickly buried by a valid chain,\n> unless the economic majority decides that a sidechain is not worth\n> protecting.\n>\n> --\n>\n> All is not well, however.  Remember, on a sidechain, we can create new\n> sidecoin for free, provided they are in a lockbox.  Unlocking that\n> lockbox would require a valid WT on the chain that the lockbox is\n> dedicated to.  However, a lockbox on one chain is a WT on the other\n> chain.  We can create a free lockbox on Ess, then use that lockbox as\n> a WT on Tee, inflating TeeCoin.\n>\n> Instead, we add an additional parameter, wtFlag, to\n> OP_WITHDRAWPROOFVERIFY.\n> This parameter is ignored by OP_WITHDRAWPROOFVERIFY opcode.\n>\n> However, this parameter is used to determine if it is a WT.  Sidechain\n> consensus should require that freely-created lockboxes set this\n> parameter to 0, so that a side block that creates free lockboxes where\n> this parameter is non-zero is an invalid side block.  Then a sidechain\n> will only treat a lockbox on another chain as a WT if the wtFlag\n> parameter is nonzero.  This way, freely-created lockboxes are not\n> valid WT.  Valid WT must lock actual, already unlocked coins, not\n> create new locked coins.\n>\n> On Bitcoin, of course, this parameter must always be nonzero, since\n> freely-created lockboxes are not allowed on mainchain, as asset\n> issuance on mainchain is already fixed.\n>\n> --\n>\n> Let us now flesh out how WT and lockboxes look like.  As we mentioned, a\n> lockbox on one chain is a WT on the destination chain.  Or to be more\n> precise, what a destination chain sees as a WT, is a lockbox on the source\n> chain.\n>\n> Thus, a lockbox is a Bitcoin-formatted transaction output paying to the\n> scriptPubKey:\n>\n>   <sidechain address commitment> <sidechain ID> OP_WITHDRAWPROOFVERIFY\n>\n> (assuming a softfork, additional OP_DROP operations may occur after\n> OP_WITHDRAWPROOFVERIFY)\n>\n> Suppose the above lockbox is paid to in the Bitcoin mainchain, with the\n> sidechain ID being the ID of Esschain.  This is itself a WT transaction\n> from the point of view of Esschain, on the principle that a lockbox on\n> one chain is a WT on another chain.\n>\n> Assuming Esschain is a brand-new sidechain, it has no EssCoins yet.  The\n> sidechain allows the arbitrary creation of sidecoin provided the new\n> sidecoins are in a lockbox whose sidechain address commitment is 0.  So\n> in Esschain, we create the same coins on a UTXO paying to the\n> scriptPubKey:\n>\n>   0 0 OP_WITHDRAWPROOFVERIFY\n>\n> The first 0 is the sidechain address commitment, which is 0 since this\n> output was not created by transferring to a sidechain; we\n> reuse the sidechain address commitment as the wtFlag.  The\n> second 0 is the mainchain's ID.  The above is a lockbox from the point of\n> view of Esschain.  It is not a WT on mainchain, however, because the\n> sidechain address commitment is 0, which we use also as the wtFlag\n> parameter.\n>\n> Now, how does a main-to-side peg work?  After creating the above output on\n> Esschain, we now spend the output with the below scriptSig:\n>\n>   <mainchain output ID> <mainchain WT transaction> <merkle path to WT\n> transaction> <mainchain block hash>\n>\n> On Esschain, OP_WITHDRAWPROOFVERIFY then verifies that the mainchain block\n> hash is a valid past block of the mainchain, then locates the mainchain\n> header.  It then checks the merkle tree path to the mainchain WT\n> transaction,\n> confirming that the mainchain contains that transaction, and confirms that\n> the\n> indicated output is in fact, a payment to an OP_WITHDRAWPROOFVERIFY, which\n> pushes the Esschain ID, and with a nonzero sidechain address commitment.\n>\n> (Esschain also needs to ensure that a single WT is not used to unlock\n> multiple lockboxes on Esschain; the easiest way is to add it to a set,\n> but this set cannot be pruned; other ways of ensuring only a WT is only\n> used to unlock once might be designed)\n>\n> On Esschain, the sidechain does one final check: the transaction that\n> spends\n> an OP_WITHDRAWPROOFVERIFY must have an output that pays to the sidechain\n> address committed to, and that output's value must be the same as the value\n> locked in the mainchain.\n>\n> (for now, I think all lockboxes must have the same fixed amount, for\n> simplicity)\n>\n> Now suppose we want to convert back our EssCoin to Bitcoin.  We create a\n> lockbox on Esschain, paying to the below:\n>\n>   <bitcoin P2SH address> 0 OP_WITHDRAWPROOFVERIFY\n>\n> The bitcoin P2SH address is mainchain address commitment; for simplicity\n> we just use P2SH on mainchain as it can encode any address.  The 0 is the\n> mainchain ID.  The above Esschain lockbox is itself a WT from Esschain to\n> mainchain.\n>\n> Then, we look for an unspent lockbox on Esschain whose sidechain ID is the\n> Esschain ID.  Note that we can select any lockbox with the correct\n> sidechain ID, regardless of the sidechain address commitment it may have.\n>\n> Locating an appropriate mainchain lockbox for Esschain coins, we then\n> provide the below scriptSig, paying out to the bitcoin P2SH address we\n> selected:\n>\n>   <esschain output ID> <esschain WT tx> <merkle path to WT tx> <esschain\n> block header hash>\n>\n> On mainchain, we check that the indicated sidechain block header hash is a\n> block header on the longest chain of Esschain.  We check it has sufficient\n> depth.  Then we check if the merkle path to the WT tx is correct and goes\n> to esschain WT tx.  Finally, we check the indicated output ID, and check\n> that\n> it is indeed an Esschain lockbox dedicated to mainchain.  Finally, we check\n> that the transaction has an output that spends the lockbox amount to the\n> specified bitcoin P2SH address.\n>\n> (similarly mainchain nees to ensure that the Esschain WT is only used\n> once)\n>\n> The key insight here is that side-to-side pegs are just like side-to-main\n> pegs.  Suppose instead we want to transfer our coins from Esscoin to\n> Teecoin.  We would instead pay to the following lockbox on Esschain:\n>\n>   <teecoin address commitment> <teechain ID> OP_WITHDRAWPROOFVERIFY\n>\n> Then a Teechain transaction spending some Tee->Ess lockbox (or a fresh\n> lockbox if there are no Tee->Ess lockboxes on Teechain) is created.\n> We proceed as if it were a side-to-main peg, except it is a peg to\n> Teechain, either creating or unlocking TeeCoins.  Indeed, mainchain\n> fullnodes may even provide an RPC for checking OP_WITHDRAWPROOFVERIFY,\n> so as to reduce risk that a sidechain breaks consensus due to buggy\n> code.\n>\n> --\n>\n> All is still not well with side-to-side pegs, however.\n>\n> Suppose the economic majority decides that Esschain must die.  Perhaps it\n> has some irrecoverable security bug, perhaps it adds features that allow\n> Esschain fullnodes to kill baby seals, perhaps a successful theft of\n> Esschain lockboxes was performed and Esscoins are now functionally\n> worthless.  Killing a sidechain is done by bribing miners to put invalid\n> values into h*, and thus stealing Bitcoin->Ess lockboxes.\n>\n> If Esschain dies, however, and the economic majority is not prepared to\n> keep\n> Esschain dead, it is possible to unlock Tee->Ess lockboxes on Teechain.\n> Unlocking existing Tee->Ess lockboxes on Teechain is safe, since they\n> represent coins that were locked into Bitcoin->Tee lockboxes.  However,\n> it is still possible to create \"free\" Tee->Ess lockboxes on Teechain, then\n> provide an invalid Tee->Ess WT lockbox on the now-moribund Esschain to\n> unlock the free Tee->Ess lockbox on Teechain, inflating TeeCoin value.\n> Thus in the presence of side-to-side pegs, the death of even one sidechain\n> represents the death of every other sidechain!\n>\n> Thus, to properly kill Esschain, the economic majority should spam the\n> Esschain headers slot with a fixed value, say 0, forever.  This makes it\n> very difficult to create a Tee->Ess WT lockbox on Esschain, as you would\n> now be able to reverse a one-way hash function.\n>\n> Alternatively, Teechain can softfork so that Tee->Ess lockboxes are no\n> longer creatable or spendable.  However, the death of Esschain requires\n> that all other sidechains, including Youchain, Veechain, Dubyachain, and\n> so on, to softfork similarly.\n>\n> Perhaps both can be done: first the economic majority wanting to kill\n> Esschain starts spamming it with invalid spends of Bitcoin->Ess lockboxes,\n> then when all Bitcoin->Ess lockboxes have been stolen, spam it with 0s\n> until all other sidechains have banned free Ess lockboxes on their chains.\n> Then, the economic majority can leave Esschain dead, and a later softfork\n> of mainchain prevents Esschain from being extended and allows mainchain\n> fullnodes to prune Esschain headers.\n>\n> --\n>\n> Thieves will still have the same difficulty stealing from sidechains, but\n> now their payoff is increased.  If a thief wants to steal Esschain\n> lockboxes, then it is possible to pack an invalid Esschain block full of\n> invalid WT to other chains.  Even chains that don't have lockboxes to\n> Esschain can create lockboxes to Esschain for free.  Thus, instead of\n> stealing only one lockbox at a time on mainchain, the thief can steal one\n> lockbox on mainchain, and on every sidechain that supports side-to-side\n> pegs, at a time.  The risk/reward ratio may shift drastically in that case.\n>\n> However, this does mean that users of one chain must pay attention to\n> attacks on other chains, not just the chain they use.  If Teechain has no\n> side-to-side pegs, then Teechain users will not care if Esschain is under\n> attack.  But if side-to-side pegs are allowed on Teechain, then Teechain\n> users must also care about Esschain's health, as well as the health of\n> every other sidechain in existence.  Mainchain is protected since free\n> lockboxes are not creatable on mainchain.  Each sidechain is not; thus\n> the user of any sidechain must also stand by users of every other\n> sidechain, or else they all fall apart.  Of course, this could more\n> simply lead to \"I will not use Teechain even if it would be useful to me,\n> because if I use Teechain, I have to care about Esschain and Youchain and\n> whatever.\"\n>\n> --\n>\n> Side-to-side pegs are useful to allow better liquidity and provide\n> arbitrage quickly between sidechains, without having to pass through\n> mainchain.  Otherwise, Esscoin may be valued slightly lower than Bitcoin,\n> then Teecoin valued slightly higher than Bitcoin, creating a larger\n> difference between Esscoin and Teecoin values than what a full\n> side-to-side peg could support.  2-way pegs from mainchain\n> to sidechain stabilize sidecoin with respect to maincoin.  Side-to-side\n> pegs stabilize all sidecoins to all other sidecoins.\n>\n> Side-to-side pegs are enabled implicitly by sidechain-headers-on-\n> mainchain,\n> as all sidechain fullnodes must necessarily be mainchain fullnodes, and\n> any mainchain fullnode can judge the validity of any WT from any sidechain\n> without a miner voting period.\n>\n> Side-to-side pegs are a generalization of main-to-side and side-to-main\n> pegs.  A sidechain can simply implement OP_WITHDRAWPROOFVERIFY and allow\n> free lockboxes, and that is sufficient for the sidechain to support\n> imports of bitcoin from mainchain and from any other sidechain.\n>\n> Side-to-side pegs seem to imply that all pegs must have the same bitcoin\n> value transferred.  What that value must be, is something that may be\n> debated endlessly.\n>\n> A side-to-side peg is a cut-through of a side-to-main peg from\n> one sidechain into a main-to-side peg into another sidechain.  If a\n> withdrawal from side-to-main peg would be accepted by mainchain, then\n> another sidechain could, in principle, accept a proof that would\n> authorize a side-to-main peg directly as a side-to-side peg.\n>\n> Side-to-side pegs make attacks on sidechains more lucrative, as it\n> becomes possible to print sidecoins by successfully attacking a\n> different sidechain.\n>\n> Drivechain cannot implement side-to-side pegs, as WT validity is\n> voted on by mainchain miners, and asking mainchain miners about\n> side-to-side pegs requires mainchain miners to be aware of both\n> sidechains.  Sidechain-headers-on-mainchain publishes SPV proofs\n> continuously to the mainchain, and since any sidechain fullnode is\n> also a mainchain fullnode (since sidechains are mergemined), then\n> every sidechain fullnode is automatically capable of accessing\n> and verifying SPV proofs for every other sidechain.\n>\n> However, the pegging here seems less flexible than the pegging\n> supported by drivechain.  Drivechain lets pegs be any size, with\n> miner voting being the basis of knowing how much money is owned\n> by whom.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170908/c9a39c04/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Sidechain headers on mainchain (unification of drivechains and spv proofs)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Chris Stewart"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 41156
        }
    },
    {
        "title": "[bitcoin-dev] Proposal: bip32 version bytes for segwit scripts",
        "thread_messages": [
            {
                "author": "Thomas Voegtlin",
                "date": "2017-09-05T10:25:16",
                "message_text_only": "BIP32 extended public/private keys have version bytes that result in the\nuser visible xpub/xprv prefix. The BIP's recommendation is to use\ndifferent version bytes for other networks (such as tpub/tprv for testnet)\n\nI would like to use additional version bytes to indicate the type of\noutput script used with the public keys.\n\nI believe the change should be user visible, because users are exposed\nto master public keys. I propose the following prefixes:\n\n========== =========== ===================================\nVersion    Prefix      Description\n========== =========== ===================================\n0x0488ade4 xprv        P2PKH or P2SH\n0x0488b21e xpub        P2PKH or P2SH\n0x049d7878 yprv        (P2WPKH or P2WSH) nested in P2SH\n0x049d7cb2 ypub        (P2WPKH or P2WSH) nested in P2SH\n0x04b2430c zprv        P2WPKH or P2WSH\n0x04b24746 zpub        P2WPKH or P2WSH\n========== =========== ===================================\n(source: http://docs.electrum.org/en/latest/seedphrase.html)\n\nI have heard the argument that xpub/xprv serialization is a format for\nkeys, and that it should not be used to encode how these keys are used.\nHowever, the very existence of version bytes, and the fact that they are\nused to signal whether keys will be used on testnet or mainnet goes\nagainst that argument.\n\nIf we do not signal the script type in the version bytes, I believe\nwallet developers are going to use dirtier tricks, such as the bip32\nchild number field in combination with bip43/bip44/bip49.\n\n\nThomas"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2017-09-05T15:44:01",
                "message_text_only": "On 05/09/17 12:25, Thomas Voegtlin via bitcoin-dev wrote:\n> ========== =========== ===================================\n> Version    Prefix      Description\n> ========== =========== ===================================\n> 0x0488ade4 xprv        P2PKH or P2SH\n> 0x0488b21e xpub        P2PKH or P2SH\n> 0x049d7878 yprv        (P2WPKH or P2WSH) nested in P2SH\n> 0x049d7cb2 ypub        (P2WPKH or P2WSH) nested in P2SH\n> 0x04b2430c zprv        P2WPKH or P2WSH\n> 0x04b24746 zpub        P2WPKH or P2WSH\n> ========== =========== ===================================\n> (source: http://docs.electrum.org/en/latest/seedphrase.html)\n> \n> I have heard the argument that xpub/xprv serialization is a format for\n> keys, and that it should not be used to encode how these keys are used.\n\nI used this argument for mnemonic/seed, not xpub/xprv. I am fine with\nthis proposal of yours, so don't worry.\n\n-- \nBest Regards / S pozdravom,\n\nPavol \"stick\" Rusnak\nCTO, SatoshiLabs"
            },
            {
                "author": "Luke Dashjr",
                "date": "2017-09-05T17:03:39",
                "message_text_only": "On Tuesday 05 September 2017 06:25:16 Thomas Voegtlin via bitcoin-dev wrote:\n> I have heard the argument that xpub/xprv serialization is a format for\n> keys, and that it should not be used to encode how these keys are used.\n> However, the very existence of version bytes, and the fact that they are\n> used to signal whether keys will be used on testnet or mainnet goes\n> against that argument.\n> \n> If we do not signal the script type in the version bytes, I believe\n> wallet developers are going to use dirtier tricks, such as the bip32\n> child number field in combination with bip43/bip44/bip49.\n\nI think it makes more sense to use a child number field for this purpose.\nIt seems desirable to use the same seed for all different script formats...\n\nAs you note, xpub\\xprv are already being used for both P2PKH and P2SH. It \nreally doesn't make sense to differentiate segwit specifically.\n\nLuke"
            },
            {
                "author": "Thomas Voegtlin",
                "date": "2017-09-05T18:09:19",
                "message_text_only": "On 05.09.2017 19:03, Luke Dashjr wrote:\n\n> It seems desirable to use the same seed for all different script formats...\n\nThat does not seem desirable to everybody.\n\nIf you want to guarantee that users will be able to recover all their\nfunds from their mnemonic seed (and that is what they expect), then\nwallets must implement all script formats, even the ones that are\ndeprecated. In addition, the list of script formats that must be\nsupported is not defined in advance, but it keeps growing. This makes\nwallet implementation increasingly difficult. In the long run, seed\nportability is guaranteed to fail in such a system.\n\n> As you note, xpub\\xprv are already being used for both P2PKH and P2SH. It \n> really doesn't make sense to differentiate segwit specifically.\n\nThat's not a reason. The fact that xpub/xprv can be used for both P2PKH\nand P2SH has already resulted in users receiving coins on addresses they\ndo not control."
            },
            {
                "author": "Pavol Rusnak",
                "date": "2017-09-06T17:02:59",
                "message_text_only": "On 05/09/17 19:03, Luke Dashjr via bitcoin-dev wrote:\n> I think it makes more sense to use a child number field for this purpose.\n> It seems desirable to use the same seed for all different script formats...\n\nIf I were designing the serialization format today, I would drop the\nfingerprint and expand child number to full BIP32 path. Good thing is\nthat we already have depth, so we know how long the BIP32 path would be.\n\nSo I suggest the following:\n\n4 byte: version bytes\n1 byte: depth\ndepth * 4 bytes: bip32 path\n32 bytes\n33 bytes\n\n-- \nBest Regards / S pozdravom,\n\nPavol \"stick\" Rusnak\nCTO, SatoshiLabs"
            },
            {
                "author": "Andreas Schildbach",
                "date": "2017-09-05T22:13:12",
                "message_text_only": "Generally I like the idea, but maybe we should come up with a\n(Bech32-based?) new standard that also includes the key birthdate (aka\n\"wallet birthdate\").\n\nAlso I heard Core will mix addresses of all types on the same HD chain.\nWhat prefix would it pick? \"*pub\"?\n\n\nOn 09/05/2017 12:25 PM, Thomas Voegtlin via bitcoin-dev wrote:\n> BIP32 extended public/private keys have version bytes that result in the\n> user visible xpub/xprv prefix. The BIP's recommendation is to use\n> different version bytes for other networks (such as tpub/tprv for testnet)\n> \n> I would like to use additional version bytes to indicate the type of\n> output script used with the public keys.\n> \n> I believe the change should be user visible, because users are exposed\n> to master public keys. I propose the following prefixes:\n> \n> ========== =========== ===================================\n> Version    Prefix      Description\n> ========== =========== ===================================\n> 0x0488ade4 xprv        P2PKH or P2SH\n> 0x0488b21e xpub        P2PKH or P2SH\n> 0x049d7878 yprv        (P2WPKH or P2WSH) nested in P2SH\n> 0x049d7cb2 ypub        (P2WPKH or P2WSH) nested in P2SH\n> 0x04b2430c zprv        P2WPKH or P2WSH\n> 0x04b24746 zpub        P2WPKH or P2WSH\n> ========== =========== ===================================\n> (source: http://docs.electrum.org/en/latest/seedphrase.html)\n> \n> I have heard the argument that xpub/xprv serialization is a format for\n> keys, and that it should not be used to encode how these keys are used.\n> However, the very existence of version bytes, and the fact that they are\n> used to signal whether keys will be used on testnet or mainnet goes\n> against that argument.\n> \n> If we do not signal the script type in the version bytes, I believe\n> wallet developers are going to use dirtier tricks, such as the bip32\n> child number field in combination with bip43/bip44/bip49."
            },
            {
                "author": "Kabuto Samourai",
                "date": "2017-09-05T19:00:04",
                "message_text_only": "We support a change to the version bits of the HD serialization that will\ninform the receiving utility of the exact derivation method used for the\npubkeys. Third-parties handling xpubs must not require additional\ninformation from the user about the derivation path or serialization format\nof the addresses under that xpub. When you have to ask, \"Is this a SegWit\nxpub?\" then you've already lost.\n\nAvoiding a total UX nightmare is in everyone's interests.\n\nI think Luke and Thomas may be talking past one another. When exporting a\nroot master HD seed, encoding the {x,y,z}{pub,prv} distinctions makes no\nsense, as the root seed should derive all paths for all coins. Wallets may\nneed additional code to discover which paths have been used when importing\na root seed. But when exporting / importing an account-level seed for\nwatch-only and receive address generation, changing the serialization\nversion bytes is appropriate and (in our view) essential to avoid loss of\nfunds.\n\nThe Electrum approach is nice but may not go far enough, as xpub and zpub\nboth list \"P2PKH or P2SH.\" Why not expand the number of version prefixes to\neliminate the ambiguity?\n\n\nOn Tue, Sep 5, 2017 at 1:09 PM, Thomas Voegtlin via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n>\n> On 05.09.2017 19:03, Luke Dashjr wrote:\n>\n> > It seems desirable to use the same seed for all different script\n> formats...\n>\n> That does not seem desirable to everybody.\n>\n> If you want to guarantee that users will be able to recover all their\n> funds from their mnemonic seed (and that is what they expect), then\n> wallets must implement all script formats, even the ones that are\n> deprecated. In addition, the list of script formats that must be\n> supported is not defined in advance, but it keeps growing. This makes\n> wallet implementation increasingly difficult. In the long run, seed\n> portability is guaranteed to fail in such a system.\n>\n> > As you note, xpub\\xprv are already being used for both P2PKH and P2SH. It\n> > really doesn't make sense to differentiate segwit specifically.\n>\n> That's not a reason. The fact that xpub/xprv can be used for both P2PKH\n> and P2SH has already resulted in users receiving coins on addresses they\n> do not control.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n\n-- \n-Kabuto\n\nPGP Fingerprint: 1A83 4A96 EDE7 E286 2C5A  B065 320F B934 A79B 6A99\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170905/2725c4f2/attachment.html>"
            },
            {
                "author": "Thomas Voegtlin",
                "date": "2017-09-06T09:26:48",
                "message_text_only": "On 05.09.2017 21:00, Kabuto Samourai wrote:\n> \n> The Electrum approach is nice but may not go far enough, as xpub and zpub\n> both list \"P2PKH or P2SH.\" Why not expand the number of version prefixes to\n> eliminate the ambiguity?\n> \n\nI agree that this would make sense if we had done it from the start.\nHowever, fixing that now might be difficult.\n\nMy \"xyz\" proposal extends the current format in a way that is very easy\nto deploy, because existing software will require minimal changes.\nHowever, if we eliminate the p2sh ambiguity now, wallets will need to\nadd extra safeguards, in order to prevent scenarios that are currently\nallowed, and they will need to handle legacy xpub/xprv differently than\nypub and zpub. This would take much more time to deploy.\n\nIn addition, consensus might be more difficult to reach on that; I guess\nnot all developers will not agree that removing that ambiguity is\nuseful. Since there is an infinity of possible P2SH scripts, it will\nnever be possible to remove ambiguity from a master key associated to a\nP2SH script. Thus, the benefit of separating P2SH from P2PKH is not as\nstrong."
            },
            {
                "author": "Kabuto Samourai",
                "date": "2017-09-06T13:47:20",
                "message_text_only": "> In addition, consensus might be more difficult to reach on that\n\nLet's move forward with the simplest solution that solves the problem and\nachieves consensus! Version bytes {x,y,z} fits the bill.\n\nOn Wed, Sep 6, 2017 at 4:26 AM, Thomas Voegtlin via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n>\n> On 05.09.2017 21:00, Kabuto Samourai wrote:\n> >\n> > The Electrum approach is nice but may not go far enough, as xpub and zpub\n> > both list \"P2PKH or P2SH.\" Why not expand the number of version prefixes\n> to\n> > eliminate the ambiguity?\n> >\n>\n> I agree that this would make sense if we had done it from the start.\n> However, fixing that now might be difficult.\n>\n> My \"xyz\" proposal extends the current format in a way that is very easy\n> to deploy, because existing software will require minimal changes.\n> However, if we eliminate the p2sh ambiguity now, wallets will need to\n> add extra safeguards, in order to prevent scenarios that are currently\n> allowed, and they will need to handle legacy xpub/xprv differently than\n> ypub and zpub. This would take much more time to deploy.\n>\n> In addition, consensus might be more difficult to reach on that; I guess\n> not all developers will not agree that removing that ambiguity is\n> useful. Since there is an infinity of possible P2SH scripts, it will\n> never be possible to remove ambiguity from a master key associated to a\n> P2SH script. Thus, the benefit of separating P2SH from P2PKH is not as\n> strong.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n\n-- \n-Kabuto\n\nPGP Fingerprint: 1A83 4A96 EDE7 E286 2C5A  B065 320F B934 A79B 6A99\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170906/57f3bc91/attachment.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2017-09-07T19:02:17",
                "message_text_only": "On Tuesday 05 September 2017 15:00:04 Kabuto Samourai via bitcoin-dev wrote:\n> I think Luke and Thomas may be talking past one another. When exporting a\n> root master HD seed, encoding the {x,y,z}{pub,prv} distinctions makes no\n> sense, as the root seed should derive all paths for all coins. Wallets may\n> need additional code to discover which paths have been used when importing\n> a root seed. But when exporting / importing an account-level seed for\n> watch-only and receive address generation, changing the serialization\n> version bytes is appropriate and (in our view) essential to avoid loss of\n> funds.\n\nIn that case, I think we should go back to the proposal I started with in \nMarch...\n\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013726.html\n\nThis handles not only simple HD seeds, but also multisig HD and such.\n\nLuke"
            }
        ],
        "thread_summary": {
            "title": "Proposal: bip32 version bytes for segwit scripts",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Thomas Voegtlin",
                "Kabuto Samourai",
                "Andreas Schildbach",
                "Pavol Rusnak",
                "Luke Dashjr"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 13351
        }
    },
    {
        "title": "[bitcoin-dev] Partial UTXO tree as commitment",
        "thread_messages": [
            {
                "author": "Tomas",
                "date": "2017-09-05T14:17:26",
                "message_text_only": "I would like to propose an efficient UTXO commitment scheme.\n\nA UTXO commitment can be useful for:\n\n1. Fast syncing a full node, by downloading the UTXO-set\n2. Proofing (non) existence of a UTXO..\n\nVarious schemes have been proposed:\n\n* Merkle/radix trees and variants; all of which have the problem that\nthey significantly increase the burden of maintaining the UTXO set.\nFurthermore, such schemes tend to practically prescribe the UTXO storage\nformat severely limiting continuous per-implementation optimizations.\n* A \"flat\" rolling hash, eg the ECMH proposed by Pieter Wiulle which is\ncheap to calculate but only solves (1) and not (2).\n\nI propose a hybrid approach, with very limited extra burden to maintain\nand reasonably small proofs: \n\nWe divide the UTXO set in buckets by prefix of their TXID, then maintain\na rolling hash for each bucket. The commitment is then the root of the\ntree constructed from the resulting bucket hashes. To construct the\ntree: For each depth, we group the hashes of the next depth per 64\nhashes and calculate the rolling hash of each. (Effectively, this is a\nprefix tree with a fixed branch-size of 64).\n\nBucketcount\n-------------------\ntxcount = number of TXIDs in the UTXO set\nbucketcount = (smallest power of 2 larger than sqrt(txcount))  << 6\n\nRationale for bucketcount:\n\n* This currently gives a bucketcount of 2^19, which is very cheap to\nmaintain with a 16mb array of rolling hashes.\n* This currently gives an average bucket size of 4kb. With a rolling\nhash, full nodes don't need to maintain the buckets themselves, but they\nare used for proofs.\n* The burden of future UTXO growth is divided among maintaining the\nrolling hashes and size of the proof: 10,000x as large UTXO set (20TB),\ngives ~400kb buckets and ~1.6gb in maintaining rolling hashes.\n* This gives a tree depth of 5, which means the cost of every UTXO\nupdate is increased  by ~3 rolling hashes (and a double SHA), as the\nlowest depths don't benefit from caching.\n* A proof for (non) existence of a UTXO is ~ 4*64*32 =8kb (branch-nodes)\n+ 4kb (bucket) = ~12kb\n\nSpecification [WIP]\n---------------------------\nWe define the \"UTXO commitment\" as the serialized byte array: \"U\" \"T\"\n\"X\" \"O\" VARINT(version) VARINT(txcount) UINT256(UTXO-root)    [todo\nclarify]\n\nA block that contains an output in the coinbase whose scriptPubKey\nconsists solely of OP_RETURN [UTXO commitment] must be rejected if in\nthe UTXO commitment the version equals 1 and either \n* After updating the UTXO state, the number of distinct TXIDs in the\nUTXO set is not equal to the txcount value of the UTXO commitment\n* After updating the UTXO state, the UTXO-root in the UTXO commitment is\nnot equal to the UTXO-root defined below.\n\nThe UTXO-root can be calculated as follows:\n\n* Define _bucketcount_ as (smallest power of 2 larger than\nsqrt(txcount))  << 6\n* Given a TXID in the UTXO set, define UTXO(TXID) as the double SHA256\nof (TXID + coins). (coins is the serialization of unspent outputs to be\nspec'ed). \n* Let bucket N be the set of values UTXO(TXID) for each TXID in the\nUTXO-set where (TXID mod _bucketcount_) equals N.\n* Let rhash N be the rolling hash (TBD) of all values in bucket N\n* Let the hash sequence be the ordered sequence  rhash\n[0,_bucketcount_).\n\n1. If the hash sequence contains at most 64 entries, then the UTXO-root\nis the rolling hash of all entries in the hash sequence, otherwise:\n2. Group the hash sequence in ordered subsequences of 64 entries each.\n3. Find the rolling hash of each subsequence\n4. Continue with 1., with the hash sequence being the ordered sequence\nof these rolling hashes.\n\nNote: an implementation may want to maintain and update the set of\nrolling hashes at higher depths on each UTXO set operation.\n\nNote: the secure ECMH is a good candidate for the bucket hash. This\ncould also be used for the branch rolling hashes, but it might be worth\nconsidering XOR for those as there seem to be simply not enough\ncandidates to find a colliding set?\n\nNote: two magic numbers are used: \"<< 6\" for the bucket count, and \"64\"\nfor the branch size. They work nicely but are pulled out of a dark place\nand merit some experimentation.\n\nUse cases for light clients\n-------------------------------------\nThese UTXO proofs could be used as compact fraud proofs, although the\nbenefit of this is not generally agreed upon.\n\nThey can also be used to increase low-conf security to light clients, by\nvalidating the signatures and order-validity of incoming transactions\nagainst the right bucket of the current UTXO set.\n\nAn interesting use case may be another type of light client. It could be\ninteresting for a light client to abandon the bloom filters, and instead\nuse the UTXO proofs to verify whether an incoming or outgoing\ntransaction is confirmed. This could be beneficial for \"rarely active\"\nlight clients such as smartphone apps, as it prevents the need to\nsynchronize previous blocks with bloom filters, and allows syncing to\nthe latest block with 12kb/output.\n\nSummary \n--------------\n* Allows fast full node syncing.\n* Costs full nodes ~20mb extra in RAM\n* Costs full nodes ~3 rolling hash operations per UTXO operation.\n* Allows UTXO (non) existence proofs for currently avg ~12kb.\n* Size of proof grows O(sqrt(N)) with UTXO set\n* Size of extra full node memory grows O(sqrt(N)) with UTXO set\n\n\nTomas van der Wansem\nbitcrust"
            }
        ],
        "thread_summary": {
            "title": "Partial UTXO tree as commitment",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tomas"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5335
        }
    },
    {
        "title": "[bitcoin-dev] SF proposal: prohibit unspendable outputs with amount=0",
        "thread_messages": [
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2017-09-05T21:51:45",
                "message_text_only": "This is not a priority, not very important either.\nRight now it is possible to create 0-value outputs that are spendable\nand thus stay in the utxo (potentially forever). Requiring at least 1\nsatoshi per output doesn't really do much against a spam attack to the\nutxo, but I think it would be slightly better than the current\nsituation.\n\nIs there any reason or use case to keep allowing spendable outputs\nwith null amounts in them?\n\nIf not, I'm happy to create a BIP with its code, this should be simple."
            },
            {
                "author": "Tier Nolan",
                "date": "2017-09-06T22:20:02",
                "message_text_only": "On Tue, Sep 5, 2017 at 10:51 PM, Jorge Tim\u00f3n via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Is there any reason or use case to keep allowing spendable outputs\n> with null amounts in them?\n>\n\nSomeone could have created a timelocked transaction that depends on a zero\nvalue output.\n\nThis could be protected by requiring a tx version number change.  Only zero\noutputs in the new version would be affected.\n\nI am not sure how strictly people are sticking to that rule though.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170906/ea09555c/attachment.html>"
            },
            {
                "author": "CryptAxe",
                "date": "2017-09-06T23:54:03",
                "message_text_only": "As long as an unspendable outputs (OP_RETURN outputs for example) with\namount=0 are still allowed I don't see it being an issue for anything.\n\nOn Sep 5, 2017 2:52 PM, \"Jorge Tim\u00f3n via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> This is not a priority, not very important either.\n> Right now it is possible to create 0-value outputs that are spendable\n> and thus stay in the utxo (potentially forever). Requiring at least 1\n> satoshi per output doesn't really do much against a spam attack to the\n> utxo, but I think it would be slightly better than the current\n> situation.\n>\n> Is there any reason or use case to keep allowing spendable outputs\n> with null amounts in them?\n>\n> If not, I'm happy to create a BIP with its code, this should be simple.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170906/83476b7f/attachment.html>"
            },
            {
                "author": "Adam Back",
                "date": "2017-09-07T01:29:55",
                "message_text_only": "The pattern used by Felix Weiss' BIP for Confidential Transactions\ndepends on or is tidier with 0-value outputs.\n\nAdam\n\n\nOn 7 September 2017 at 00:54, CryptAxe via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> As long as an unspendable outputs (OP_RETURN outputs for example) with\n> amount=0 are still allowed I don't see it being an issue for anything.\n>\n> On Sep 5, 2017 2:52 PM, \"Jorge Tim\u00f3n via bitcoin-dev\"\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> This is not a priority, not very important either.\n>> Right now it is possible to create 0-value outputs that are spendable\n>> and thus stay in the utxo (potentially forever). Requiring at least 1\n>> satoshi per output doesn't really do much against a spam attack to the\n>> utxo, but I think it would be slightly better than the current\n>> situation.\n>>\n>> Is there any reason or use case to keep allowing spendable outputs\n>> with null amounts in them?\n>>\n>> If not, I'm happy to create a BIP with its code, this should be simple.\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "CryptAxe",
                "date": "2017-09-07T03:41:49",
                "message_text_only": "After reading\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-January/012194.html\nI see that Adam is correct. Unfortunately this SF would make Felix's\nconfidential transactions\nmore complicated. The blinding and unblinding transactions would have to\nbe created with\nminimal output values, and this will need to be considered when checking\nthat the fee is equal\nto the total amount of input. (it would now be SUM(inputs) -\nSUM(minimalOutputs))\n\nBlinding transaction:\n  Ins:\n    All non-confidential inputs are valid\n  Outs:\n  - 0..N: (new confidential outputs)\n    amount: 0\n    scriptPubkey: OP_2 <0x{32-byte-hash-value}>\n    witnessOut: <0x{petersen-commitment}> <0x{range-proof}>\n  - last:\n    amount: 0\n    scriptPubkey: OP_RETURN OP_2 {blinding-fee-amount}\n  Fee: Sum of the all inputs value\n\n\nHowever, looking at the format of the blinding transaction, and how the\nGCTXO is added to the UTXO set\nby miners, it seems that a change to the blinding scriptPubKey could\nallow for the use of 0 value\noutputs. Even with the SF proposed by this email thread.\n\nOP_RETURN could be added to the scriptPubKey during blinding. The amount\nand scriptPubKey destination of\nunblinded funds is part of the witness and the outputs of an unblinded\ntransaction are unspendable, so\nwhy not also make them unspendable in the blind transaction? As far as I\ncan tell those outputs don't need to\nbe spendable, they are really just encoding data. It doesn't seem like\nanything besides the confidential base\ntransaction and the fee output from the blind transaction need to be in\nthe UTXO set.\n\nIs it still possible to add this data to the witness if the scriptPubKey\nis unspendable? :\n\nwitnessOut: <0x{petersen-commitment}> <0x{range-proof}>\n\nI think I'm missing something obvious, someone point out why this is\nstupid please :)\n\nOn 09/06/2017 06:29 PM, Adam Back wrote:\n> The pattern used by Felix Weiss' BIP for Confidential Transactions\n> depends on or is tidier with 0-value outputs.\n>\n> Adam\n>\n>\n> On 7 September 2017 at 00:54, CryptAxe via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> As long as an unspendable outputs (OP_RETURN outputs for example) with\n>> amount=0 are still allowed I don't see it being an issue for anything.\n>>\n>> On Sep 5, 2017 2:52 PM, \"Jorge Tim\u00f3n via bitcoin-dev\"\n>> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>> This is not a priority, not very important either.\n>>> Right now it is possible to create 0-value outputs that are spendable\n>>> and thus stay in the utxo (potentially forever). Requiring at least 1\n>>> satoshi per output doesn't really do much against a spam attack to the\n>>> utxo, but I think it would be slightly better than the current\n>>> situation.\n>>>\n>>> Is there any reason or use case to keep allowing spendable outputs\n>>> with null amounts in them?\n>>>\n>>> If not, I'm happy to create a BIP with its code, this should be simple.\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>"
            },
            {
                "author": "Hampus Sj\u00f6berg",
                "date": "2017-09-07T09:56:19",
                "message_text_only": "Forbidding 0 satoshi outputs (I wasn't actually aware that it was possible,\nis 0 satoshi inputs also allowed?) would complicate a divisibility increase\nsoftfork (I'm working on an idea for >= 1 satoshi transactions, but now it\nseems like < 1 satoshi transactions would work too).\n\nI don't think it's a good idea to deploy this softfork.\n\nHampus\n\n2017-09-07 5:41 GMT+02:00 CryptAxe via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org>:\n\n> After reading\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> 2016-January/012194.html\n> I see that Adam is correct. Unfortunately this SF would make Felix's\n> confidential transactions\n> more complicated. The blinding and unblinding transactions would have to\n> be created with\n> minimal output values, and this will need to be considered when checking\n> that the fee is equal\n> to the total amount of input. (it would now be SUM(inputs) -\n> SUM(minimalOutputs))\n>\n> Blinding transaction:\n>   Ins:\n>     All non-confidential inputs are valid\n>   Outs:\n>   - 0..N: (new confidential outputs)\n>     amount: 0\n>     scriptPubkey: OP_2 <0x{32-byte-hash-value}>\n>     witnessOut: <0x{petersen-commitment}> <0x{range-proof}>\n>   - last:\n>     amount: 0\n>     scriptPubkey: OP_RETURN OP_2 {blinding-fee-amount}\n>   Fee: Sum of the all inputs value\n>\n>\n> However, looking at the format of the blinding transaction, and how the\n> GCTXO is added to the UTXO set\n> by miners, it seems that a change to the blinding scriptPubKey could\n> allow for the use of 0 value\n> outputs. Even with the SF proposed by this email thread.\n>\n> OP_RETURN could be added to the scriptPubKey during blinding. The amount\n> and scriptPubKey destination of\n> unblinded funds is part of the witness and the outputs of an unblinded\n> transaction are unspendable, so\n> why not also make them unspendable in the blind transaction? As far as I\n> can tell those outputs don't need to\n> be spendable, they are really just encoding data. It doesn't seem like\n> anything besides the confidential base\n> transaction and the fee output from the blind transaction need to be in\n> the UTXO set.\n>\n> Is it still possible to add this data to the witness if the scriptPubKey\n> is unspendable? :\n>\n> witnessOut: <0x{petersen-commitment}> <0x{range-proof}>\n>\n> I think I'm missing something obvious, someone point out why this is\n> stupid please :)\n>\n> On 09/06/2017 06:29 PM, Adam Back wrote:\n> > The pattern used by Felix Weiss' BIP for Confidential Transactions\n> > depends on or is tidier with 0-value outputs.\n> >\n> > Adam\n> >\n> >\n> > On 7 September 2017 at 00:54, CryptAxe via bitcoin-dev\n> > <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >> As long as an unspendable outputs (OP_RETURN outputs for example) with\n> >> amount=0 are still allowed I don't see it being an issue for anything.\n> >>\n> >> On Sep 5, 2017 2:52 PM, \"Jorge Tim\u00f3n via bitcoin-dev\"\n> >> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >>> This is not a priority, not very important either.\n> >>> Right now it is possible to create 0-value outputs that are spendable\n> >>> and thus stay in the utxo (potentially forever). Requiring at least 1\n> >>> satoshi per output doesn't really do much against a spam attack to the\n> >>> utxo, but I think it would be slightly better than the current\n> >>> situation.\n> >>>\n> >>> Is there any reason or use case to keep allowing spendable outputs\n> >>> with null amounts in them?\n> >>>\n> >>> If not, I'm happy to create a BIP with its code, this should be simple.\n> >>> _______________________________________________\n> >>> bitcoin-dev mailing list\n> >>> bitcoin-dev at lists.linuxfoundation.org\n> >>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >>\n> >> _______________________________________________\n> >> bitcoin-dev mailing list\n> >> bitcoin-dev at lists.linuxfoundation.org\n> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/52539276/attachment.html>"
            },
            {
                "author": "Tier Nolan",
                "date": "2017-09-07T10:31:41",
                "message_text_only": "You could have a timelocked transaction that has a zero value input (and\nother non-zero inputs).  If the SF happened, that transaction would become\nunspendable.\n\nThe keys to the outputs may be lost or the co-signer may refuse to\ncooperate.\n\nThere seems to be some objections to long term timelocked transactions.\n\nIf someone asked me about it, I would recommend that any timelocked\ntransactions should very carefully make sure that they use forms that are\npopular.\n\nI think the fairest rule would be that any change which makes some\ntransactions invalid should be opt-in and only apply to new transaction\nversion numbers.\n\nIf you create a timelocked transactions with an undefined version number,\nthen you have little to complain about.\n\nIf the version number is defined and in-use, then transactions should not\nsuddenly lose validity.\n\nA refusal to commit to that makes long term locktime use much more risky.\n\nOn Thu, Sep 7, 2017 at 12:54 AM, CryptAxe via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> As long as an unspendable outputs (OP_RETURN outputs for example) with\n> amount=0 are still allowed I don't see it being an issue for anything.\n>\n> On Sep 5, 2017 2:52 PM, \"Jorge Tim\u00f3n via bitcoin-dev\" <bitcoin-dev at lists.\n> linuxfoundation.org> wrote:\n>\n>> This is not a priority, not very important either.\n>> Right now it is possible to create 0-value outputs that are spendable\n>> and thus stay in the utxo (potentially forever). Requiring at least 1\n>> satoshi per output doesn't really do much against a spam attack to the\n>> utxo, but I think it would be slightly better than the current\n>> situation.\n>>\n>> Is there any reason or use case to keep allowing spendable outputs\n>> with null amounts in them?\n>>\n>> If not, I'm happy to create a BIP with its code, this should be simple.\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/d1dfecc7/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2017-09-07T18:00:14",
                "message_text_only": "On Tue, Sep 05, 2017 at 11:51:45PM +0200, Jorge Tim\u00f3n via bitcoin-dev wrote:\n> This is not a priority, not very important either.\n> Right now it is possible to create 0-value outputs that are spendable\n> and thus stay in the utxo (potentially forever). Requiring at least 1\n> satoshi per output doesn't really do much against a spam attack to the\n> utxo, but I think it would be slightly better than the current\n> situation.\n\nGiven that this has a very minimal cost for spammers - just a single satoshi -\nI don't think this is worth the risk of making future upgrades more complex as\nother posters have brought up.\n\nSecondly, I think we have good reason to think that things like my own TXO\ncommitments and Bram's related work will make UTXO growth a non-issue in the\nfuture.\n\nSo, I'd NACK such a proposal myself.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/da9b038a/attachment-0001.sig>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2017-09-09T21:11:57",
                "message_text_only": "Tier Nolan, right, a new tx version would be required.\n\nI have to look deeper into the CT as sf proposal.\n\nWhat futures upgrades could this conflict with it's precisely the\nquestion here. So that vague statement without providing any example\nit's not very valuable.\n\nAlthough TXO commitments are interesting, I don't think they make UTXO\ngrowth a \"non-issue\" and I also don't think they justify not doing\nthis.\n\nYeah, the costs for spammers are very small and doesn't really improve\nthings all that much, as acknowledged in the initial post.\n\n\n\nOn Thu, Sep 7, 2017 at 8:00 PM, Peter Todd <pete at petertodd.org> wrote:\n> On Tue, Sep 05, 2017 at 11:51:45PM +0200, Jorge Tim\u00f3n via bitcoin-dev wrote:\n>> This is not a priority, not very important either.\n>> Right now it is possible to create 0-value outputs that are spendable\n>> and thus stay in the utxo (potentially forever). Requiring at least 1\n>> satoshi per output doesn't really do much against a spam attack to the\n>> utxo, but I think it would be slightly better than the current\n>> situation.\n>\n> Given that this has a very minimal cost for spammers - just a single satoshi -\n> I don't think this is worth the risk of making future upgrades more complex as\n> other posters have brought up.\n>\n> Secondly, I think we have good reason to think that things like my own TXO\n> commitments and Bram's related work will make UTXO growth a non-issue in the\n> future.\n>\n> So, I'd NACK such a proposal myself.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org"
            },
            {
                "author": "Peter Todd",
                "date": "2017-09-13T09:24:34",
                "message_text_only": "On Sat, Sep 09, 2017 at 11:11:57PM +0200, Jorge Tim\u00f3n wrote:\n> Tier Nolan, right, a new tx version would be required.\n> \n> I have to look deeper into the CT as sf proposal.\n> \n> What futures upgrades could this conflict with it's precisely the\n> question here. So that vague statement without providing any example\n> it's not very valuable.\n\nSo with Confidential Transactions, the only thing that's changed relative to a\nnormal Bitcoin transaction is that fact that the sum of input values is >= the\nsum of output values is proven via a CT proof, rather than revealing the actual\nsums. Other than that, CT transactions don't need to be any different from\nregular transactions.\n\nFor CT to be a softfork, we have to ensure that each CT transaction's sum of\ninputs and outputs is valid. An obvious way to do this is to have a pool of\n\"shielded\" outputs, whose total value is the sum of all CT-protected outputs.\nOutputs in this pool would appear to be anyone-can-spend outputs to pre-CT\nnodes.\n\nThis gives us three main cases:\n\n1) Spending unshielded outputs to CT-shielded outputs\n\nSince the CT-shielded output's value is unknown, we can simply set their value\nto zero. Secondly, we will add the newly CT-shielded value to the pool with an\nadditional output whose value is the sum of all newly created CT-shielded\noutputs.\n\n\n2) Spending CT-shielded outputs to unshielded outputs\n\nHere one or more CT-shielded outputs will be spent. Since their value is zero,\nwe make up the difference by spending one or more outputs from the CT pool,\nwith the change - if any - assigned to a CT-pool output.\n\n\n3) Spending CT-shielded outputs to CT-shielded outputs\n\nSince both the inputs and outputs are zero-valued, to pre-CT nodes the\ntransaction is perfectly valid: the sum of coins spent is 0 BTC, and the sum of\ncoins created is also 0 BTC. We do have the problem of paying miners fees, but\nthat could be done with an additional CT output that the miner can spend, a\nchild-pays-for-parent transaction, or something else entirely that I haven't\nthought of.\n\n\n> Although TXO commitments are interesting, I don't think they make UTXO\n> growth a \"non-issue\" and I also don't think they justify not doing\n> this.\n> \n> Yeah, the costs for spammers are very small and doesn't really improve\n> things all that much, as acknowledged in the initial post.\n\nSuppose zero-valued outputs are prohibited. In case #3 above, if there are more\noutputs than inputs, we need to add an additional input from the CT-shielded\npool to make up the difference, and an additional change output back to the\nCT-shielded pool.\n\nIf shielded-to-shielded transactions are common, these extra outputs could\nconsume a significant % of the total blockchain space - that's a significant\ncost. Meanwhile the benefit is so small it's essentially theoretical: an\nadditional satoshi per output is an almost trivial cost to an attacker.\n\nQuite simply, I just don't think the cost-benefit tradeoff of what you're\nproposing makes sense.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170913/e57a0a4e/attachment-0001.sig>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2017-09-13T09:34:37",
                "message_text_only": "On Wed, Sep 13, 2017 at 9:24 AM, Peter Todd via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Quite simply, I just don't think the cost-benefit tradeoff of what you're\n> proposing makes sense.\n\nI agree that dropping zero value outputs is a needless loss of\nflexibility.  In addition to the CT example, something similar could\nbe done for increased precision (nanobitcoin!).\n\nMaybe if in the future the value of 1e-8 btc is high enough then an\nargument could be made that requiring one is a meaningful reduction in\na miner's ability to spam up the network... but the argument doesn't\nfly today... the cost in lost fee income from the spam just totally\ndwarfs it."
            }
        ],
        "thread_summary": {
            "title": "SF proposal: prohibit unspendable outputs with amount=0",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "CryptAxe",
                "Adam Back",
                "Hampus Sj\u00f6berg",
                "Peter Todd",
                "Tier Nolan",
                "Jorge Tim\u00f3n",
                "Gregory Maxwell"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 20330
        }
    },
    {
        "title": "[bitcoin-dev] [BIP Proposal] Token Protocol Specification",
        "thread_messages": [
            {
                "author": "Luca Venturini",
                "date": "2017-09-06T15:44:47",
                "message_text_only": "Hi everyone,\n\nI would like to propose a standard protocol to manage tokens on top of \nthe Bitcoin blockchain.\n\nThe full text is enclosed and can be found here:\n\nhttps://github.com/token21/token-protocol-specification\n\nAny feedback will be appreciated.\n\nLuca Venturini\n\n---\n\nAbstract\n========\nThis document describes a protocol to manage digital assets (tokens) on \ntop of the bitcoin blockchain. The protocol enables a semantic layer \nthat permits reading the bitcoin transactions as operations related to \ntokens.\n\nThe protocol allows a new level of plausible deniability, while \npermitting statefull public auditability on each issued token. It allows \nboth the user and the issuer to deny that an existing bitcoin \ntransaction between the two is actually a token transaction, or a new \ntoken issuance. While both the token sender and the token issuer cannot \ndeny to have sent bitcoins, nobody can prove the transaction was related \nto a digital asset. On top of that, to guarantee plausible deniability, \ntokens can be issued, sent, and received using any existing bitcoin \nclient software.\n\nThere is no need to have a wallet exclusively dedicated to manage the \ntokens. With a few simple precautions by the user, tokens can be managed \nusing any existing Bitcoin wallet, while it is used for normal bitcoin \ntransactions as well.\n\nSince it is possible to infinitely split a token in parts, there is no \ndefinition of the number of decimals of token generated and transferred. \nThe number of tokens is always an integer.\n\nEvery operation of the protocol is performed with Bitcoin transactions, \nwithout the use of OP_RETURN and without any form of pollution of the \nblockchain, or of the UTXO set.\n\nThe protocol permits atomic buy and sell transactions between tokens and \nBitcoin, and between different types of tokens. The only operations that \nrequire a coin selection enabled wallet are the split and join special \noperations and the token offering issuance operations. Those are used to \nmodify the token unit of measure and to receive bitcoins from third \nparties during a token offering issuance.\n\nCopyright\n=========\nThis document is licensed under the 2-clause BSD license.\n\nMotivation\n==========\nThe current protocols that permit to issue tokens based on the bitcoin \nblockchain (i.e. Counterparty, Omni, Colored Coins, Coinprism, Colu) are \nflawed.\n\nThe existing solutions usually need dedicated wallets and/or \nverification nodes. Usually, a \"pivot\" currency is involved and atomic \ntransactions are not permitted unless they use the pivot currency. Those \nprotocols pollute the blockchain (30% or more) and in some cases they do \nnot accept P2SH scripts. Since the use of a dedicated wallet is \nrequired, the users cannot plausibly deny they have got tokens. \nPlausible deniability on the issuer side is not available either. None \nof these protocols permits infinite division of the tokens, so usually \nthe number of decimals has to be specified at issuance time. The \nautomatic token offering issuance is not enabled as well.\n\nRationale\n=========\nLet's take an example from the real world, a yacht. We write on the \nyacht's license that the owner is any person that can show a one dollar \nbill having the serial number F82119977F. Thus the one dollar bill can \nbe exchanged between owners with extreme simplicity and full plausible \ndeniability. The US government will guarantee that there is no other \nperson having the same dollar bill.\n\nThe protocol permits managing a token in the same way. The underlying \nBitcoin protocol will guarantee against double spending.\n\nFeatures:\n\n  - Easy of use. Tokens can be managed using any wallet. Even if the \nwallet has no coin selection feature.\n  - Plausible Deniability by the issuer. The issuer can generate a new \ntype of token and nobody analyzing the blockchain will understand that \nthe transaction is issuing a token. Even if a token is known, the issuer \ncan issue other tokens. Since a single output contains a large number of \ndifferent token types, the issuer is actually generating different types \nof tokens every time she sends a new Bitcoin transaction to the network.\n  - Plausible Deniability by the user (no use of tokens at all, or use \nof a different token type). A transaction that sends tokens from Alice \nto Bob is a normal transaction. Nobody can understand that this \ntransaction is moving tokens unless they explicitly know which \ntransaction is the token issuance. In fact a single address contains a \nlarge number of token types, and the use of tokens itself can be denied.\n  - Accountability. Everybody can see the state of the distribution of a \ntype of token.\n  - Tunnel mode (confidentiality by issuer and user versus a third \nparty). Alice can send tokens to Bob and ask him to give the tokens to \nCharlie, without telling to Bob what is the type of the token given. \nAlice can disclose this information in the future, if she wants.\n  - It is possible to perform open or closed issuances. While an open \nissuance permits to continue the issuance of tokens in the future, \nclosed issuance guarantees that no other token of the same type will \never be issued.\n  - The power to continue the issuance of an open token can be sent to \nanother address, using a transaction. Once the power to continue the \nissuance is sent to someone, the former issuer cannot issue any more tokens.\n  - The power to continue the issuance has the same features of \nplausible deniability of the possess of a token.\n  - Since a token type is uniquely identified by a transaction hash, or, \nin some cases, by a Bitcoin address, a user can prove to be the issuer \nby signing a message using the Bitcoin protocol.\n  - Future proof. Tokens can move following P2PKH, P2SH, P2SH-P2WPKH \noutputs or any other type of script\n  - Blockchain pollution of the protocol transactions is almost zero. \nThere is no OP_RETURN involved, nor any other type of \"fake\" addresses \nthat pollute the UTXO database.\n  - The protocol is based on the Bitcoin blockchain, but, with small \nchanges, can be considered blockchain agnostic.\n  - Atomic transactions between tokens and Bitcoin are possible.\n  - Atomic transactions between different types of tokens are possible.\n  - Tokens of different types can be held by the same address and by the \nsame output.\n  - Tokens can be divided indefintely, thus having any number of decimals.\n  - Tokens can be issued automatically on the receiving of bitcoins. \nThis operation performs a token offering issuance (also known as Initial \nCoin Offering).\n\nIntroduction\n============\n\nWhere are the tokens?\n---------------------\nAs with bitcoins, tokens are contained in unspent Bitcoin outputs. In \nsome cases, defined below, the last five digits of the satoshi value \nsent to the output represent the number of tokens contained in the output.\n\nWhen an output is spent, the tokens contained in the output are fully \nspent in the same transaction. There are no tokens outside of the tokens \ncontained in the UTXO database.\n\nToken issuance\n--------------\nThe large majority of bitcoin transactions can be semantically seen as \ntoken issuances. There are two types of token issuances: closed and \nopened. A closed token issuance guarantees that no other token of the \nsame type will ever be issued.\n\nIssuance chains\n---------------\nAn open issuance gives to one, or more, of its output the power to \ncontinue the issuance of tokens of the same type. We define such a power \nas Power of Continuation (POC). The transaction that will spend the \noutput appointed with the POC will be a continuation of the same \nissuance chain.\n\nEvery transaction of the chain will issue the same type of token. On top \nof that, every transaction that is part of the chain, can also be seen \nas as issuance of tokens of its, new, type. A chain will be closed by a \ntransaction having more than one output and the first output with five \nzeros as the last five digits of the satoshis value. No other \ntransactions can send tokens of the same type after the close of the \nissuance.\n\nToken names\n-----------\nA token type can have multiple names. The default name is the hash of \nthe first transaction that issued the token.\n\ni.e: 68330b6ab26e44f9c3e515f04d15ffe6547f29e60b809a47e50d9abf59045c1e\n\nAs alternative names, a token type can be named after the bitcoin \naddress of one of the outputs of the transaction that first issued the \ntoken, provided the fact that the address has never been used before in \nthe blockchain.\n\nNote: it is better to use one of the alternate names in cases when \ntransaction malleability is a concern.\n\nVanity token names\n------------------\nA token can be identified using only the first characters of the Bitcoin \naddress, as alternate name defined above, if the characters are \ndifferent from every previous Bitcoin address seen in the blockchain. An \nexample is provided below.\n\nTokens can coexist\n-------------------\nToken of different types can coexist in a single output while remaining \nof different types. Thus a bitcoin address (actually an output of the \nUTXO database) can hold tokens of different types. Every Bitcoin address \ncontains a lot of types of tokens, so that a user usually does not know \nall the type of tokens contained in an address.\n\nA single transaction can send a type of token to some of the outputs \nwhile sending another type of token to a different set of its outputs. \nTokens are never burned or deleted.\n\nUse the protocol\n================\nThis section explains a basic use case. In all the examples provided, we \ndo not consider the fee. We assume that there is another input, not \nlisted, that pays the transaction fee.\n\nAlice, Bob, Charlie, and Daniel decides that they want to start a new \ncompany. Each of them will give to the new company some time, money, \nfurniture, knowledge. They decide everyone contributed to the company \nwith a percentage of value as follows: Alice - 40%, Bob - 12%, Charlie - \n34% and Daniel - 14%. They decide that the shares of the new company can \nbe freely resold to others and that they will accept that the annual \nmeeting will consent vote through messages signed using the Bitcoin \nprotocol by the owners of the shares.\n\nIssue tokens\n------------\nAlice asks Bob, Charlie, and Daniel to send her 1 Bitcoin each. She asks \neach of them to give her a bitcoin address where they want to receive \nback the bitcoins along with the tokens.\n\nShe asks Charlie to generate a vanity address that has never been used \nbefore of type 1CompanyXWXjLgud9jxwxm34u.... Since there has been a \nprevious address in the blockchain having 1Companx as the first \ncharacters, but this is the first address seen in the blockchain that \nhas 1Company as the first characters, they will call the token with the \nname 1Company. This step is optional.\n\nThen she sends, from her wallet, a transaction having the following outputs:\n\n  - 1.00000040 to an address controlled by Alice\n  - 1.00000012 to an address controlled by Bob\n  - 1.00000034 to the vanity address 1CompanyXWXjLgud9jxwxm34u... \ncontrolled by Charlie\n  - 1.00000014 to an address controlled by Daniel\n  - 3.45322112 is the change generated by Alice's wallet\n\nThis transaction gives 40, 12, 34, 14 tokens to each one. The newly \ngenerated token type can be named after the transaction hash, or after \nthe vanity address (optional), or after one of the addresses of the \npersons involved, provided that the address has never been used before.\n\nThe issuance is still open. Since they do not want to issue more shares, \nthey decide to close the issuance (on the other side, they could decide \nto leave the issuance open and to hold the issuing key somewhere, or to \nhave a multisignature address and to give the keys to the directors of \nthe company). In order to close the issuance, Alice generates the \nfollowing transaction that sends bitcoins from her wallet to addresses \nof her same wallet, using the change output of the previous transaction \nas an input:\n\n  - 0.45000000 to an address of her wallet\n  - 3.00322112 change generated by the wallet\n\nThis closes the issuance.\n\nSend tokens\n--------------\nAfter some while, Bob decides to give some shares of the company to his \nhusband Giacomo. He generates a new transaction spending the output of \nthe issuance transaction:\n\n  - 0.03400008 to Giacomo\n  - 0.96600004 change generated by Bob's wallet\n\nThis transaction gives to Giacomo 8 shares of the company.\n\nAtomic transactions\n-------------------\nDaniel wants to sell 3 of his 14 shares to Frank. They negotiate a price \nof 0.00323200 bitcoin per share. This is a total of 0.00969600 bitcoin \nto buy the three shares. They do not know each other very well, so they \ndecide to make an atomic transaction that will give 0.00969600 bitcoins \nto Daniel and 3 shares to Frank. Daniel set an input of the new \ntransaction with his issuance transaction output. Frank put in another \ninput of 1.23242454 bitcoins from his wallet. The outputs of the \ntransaction are as follows:\n\n  - 0.22400003 to an address controlled by Frank (this gives the 3 \nshares to Frank)\n  - 0.23200000 to an address controlled by Daniel (this is part of the \npayment to Daniel)\n  - 0.77769614 to an address controlled by Daniel (this can be \nconsidered the change of the original issuance output of 1.00000014)\n  - 0.99872851 to an address controlled by Frank (change to Frank)\n\nDaniel sent to the inputs of the transaction 1.00000014 bitcoins and \nreceives back 1.00969614. This gives to Daniel the 0.00969600 paid by \nFrank. On the other side, Frank sends 1.23242454 as an input of the \ntransaction and receives back 1.22272854 bitcoins, thus paying exactly \nthe 0.00969600 that needs to be paid to Daniel. This transaction sends 3 \ntokens from Daniel to Frank. Another 11 tokens are the tokens that are \ngiven as a change to Daniel, along with 0.23200000 bitcoins.\n\nSpecification\n=============\n\nDefinitions\n-----------\nIn order to evaluate a transaction, the outputs are sorted by the \nsatoshis value. Once sorted, we define a \"cut\" output the first output \nhaving five zeros as the last five digits of the satoshi value (satoshis \nmodulo 10^5 == 0). In the following, \"first\", \"second\", \"last\" are all \nreferred to the sorted outputs.\n\nWe define as \"signal\" of an output the value of satoshis of the output \nmodulo 10^5. This is the last five digits of the value, as expressed in \nsatoshis.\n\nDespite not mandatory, we sometimes call \"c\", or \"change\", the output \nhaving the biggest value in Satoshi. This is the last output, as sorted \nabove. Such behavior follows the \"Guidelines\" section, explained below.\n\nWe use n=0 related to a sequence a1, ..., an, to indicate that there are \nno elements in the sequence.\n\nIssuance of a token\n-------------------\nA transaction that has only one output, or has the first output that is \na cut, issues no token. Every other Bitcoin transaction is an issuance \nof tokens of the type of the transaction.\n\nWhen a issuance is open, Power of Continuation (POC), will be given to \nan output that will be spent in a transaction that continues the \nissuance of the same type of tokens.\n\nAs for the protocol behavior, we divide the structure of the sorted \noutputs of a bitcoin transaction in the following groups. For each \ngroup, a description of the behavior of the protocol is provided.\n\n  - a1, ..., an, cut(POC), z1(POC), ... zm(POC), b1, ..., bl, with n>0, \nm>=0, m+l>0\n      * zi are outputs signaling zero. They are optional.\n      * This is an open issuance. It generates the number of tokens \nsignaled by the outputs before the cut: a1, ..., an. Every output of \nthat set receives a number of tokens as signaled by the output satoshis' \nvalue.\n      * The cut output, and every other output zi, signaling zero, that \nis directly after the cut, receive the POC. This means that the \ntransactions that will spend the POC will be a continuation of this \nissuance and a continuation of every issuance that gave the POC to the \nthis transaction.\n  - cut, b1, ..., bm with m>0 (a cut alone is a case of the fourth type)\n      * This is a particular case of the first group, having n=0 and \nm=0. This transaction *closes the issuance forever*. Every token's chain \nthat ends into this transaction is closed as well.\n      * It generates no tokens and there are no other outputs that can \ncontinue the issuance in the future.\n      * If b1 or b2 have a signal of zero and m>2, this is a token \noffering issuance transaction. It will be described in a following section.\n  - a1, ..., an, c(POC) with n>0\n      * This is an open issuance. It generates the number of tokens that \nare signaled in a1, ..., an. The last output c will not receive tokens.\n      * The last output c will receive the POC. A following transaction \nthat spends the output c is an issuance transaction of the same type of \ntoken.\n      * The fact that c is a cut (or not) does not modify the behavior \nof the transactions of this group\n  - c(POC) (single output, also seen as the previous one, with n=0)\n      * This transaction generates no tokens at all.\n      * The output c receives the POC. Thus a following transaction that \nspends the output c is an issuance transaction of the same type of token.\n\nNotes on token issuances\n------------------------\nThe number of tokens generated by an issuance transaction is always the \nsum of the signals of all the outputs, excluding the last one and the \noutputs that are listed after a cut. Thus the number of tokens sent to \neach output, that receives tokens, is always the number signaled by the \noutput.\n\nWho has the power to generate other tokens of the same issuance (POC):\n\n  - If there is no cut, the issuance is open and the transaction that \nwill spend the last (biggest) output can continue to generate token of \nthe same type.\n  - If there is a cut, in a position different than the first, the \nissuance is open. The cut output will be the input of a following \ntransaction that issues more tokens of the same issuance chain. The \nfollowing transaction can close tha chain, or can be an open issuance, \nthus having another output that will continue the generation chain.\n\nIn order to close forever the issuance of tokens, the transaction should \nhave a cut as the first output and have more than one output.\n\nTransfer of tokens\n------------------\nEvery bitcoin transaction spends all the tokens' content of the inputs \nand sends them to the outputs. Some of the outputs receive the number of \ntokens exactly stated in the last five digits of the satoshis sent (the \nsignal), in a way similar to an issuance transaction.\n\nA transaction can be seen as having one of the three following shapes \n(ai means an output that is not a cut, bi and c are outputs that can be \ncut):\n\n  - a1, ..., an, cut, b1, ..., bm, c (transactions with a cut) (n=0 is \ndescribed here)\n      * No output (bi) after a cut receives tokens.\n      * Tokens will be assigned to outputs a1, ..., an trying to follow \nthe signal as follows:\n          - If there are enough tokens, the tokens signaled by the first \noutput are assigned to that output.\n          - If there are still remaining tokens, the tokens are sent to \nthe following output based on the signal.\n          - This continues until there is a cut or the tokens signaled \nby an output are more than the remaining tokens. In these cases:\n              * If there is a cut, it receives all the remaining tokens.\n              * If there is an output receiving more tokens than the \nremaining tokens (we define it a \"remaining error\"), the output receives \nno token at all. No other output will receive tokens after this and all \nthe remaining tokens will be sent to the last output c (thus, if there \nis a cut in the transaction, the algorithm \"jumps\" the cut).\n              * If there is a \"remaining error\" and the transaction is a \nspecial transaction as defined in the next section, and the number of \ntokens in input is exactly the same of the two types (big and small) \nthat are the result of a previous split or join special transaction, the \n\"remaining error\" output gets one of the smallest tokens involved. This \nwill be better explained in the following section about \"special \ntransactions\".\n      * If the first output is a cut, and the transaction is not a \nspecial one as defined below in the document, the last output (c) \nreceives all the tokens\n  - a1, ..., an, c (ai is not a cut, for every i; c can be a cut)\n      * The tokens are assigned to a1, ..., an as described in the \nprevious group.\n      * The last output c receives all the remaining tokens. This \nbehavior is not modified by the fact that the last output is a cut.\n  - c (single output transaction, also seen as the previous one, with n=0)\n      * The output receives all the tokens received from the inputs\n\nTransactions receiving both the POC of an issuance and some tokens of \nthe same issuance\n---------------------------------------------------------------------------------------\nThe protocol is designed such that a transaction of an issuance chain \nnever issue new tokens to an output, that receives the POC of the same \ntype of token. But two different inputs can give to a transaction both \nsome tokens and the POC of the same type of token. In this case, there \nis a double role for the transaction that is both a continuation of the \nissuance and a transfer transaction sending tokens of the same type.\n\nIn this case, the tokens will be allocated as defined in the following \nfour different shapes of transaction:\n\n  - a1, ..., an, cut, b1, ..., bm, c (transaction with a cut)\n      * The generated tokens are sent to the outputs a1, ..., an as \ndescribed in the definition of an issuance of tokens\n      * All the tokens received in input of the same type of the \nissuance we are continuing will be sent to the cut output\n  - a1, ..., an, c (transaction without a cut, or with c that is a cut: \nai is not a cut, for every i)\n      * The generated tokens are sent to the outputs a1, ..., an as \ndescribed in the definition of an issuance of tokens transaction\n      * All the tokens received in input, of the same type of the \nissuance we are continuing, will be sent to the last output c\n  - cut, b1, ..., bm\n      * The issuance will be closed and all the tokens will be given to \nthe last output bm. The behavior described in the issuance transaction \nand in the transaction sending tokens do not influence each other, in \nthis case.\n      * If it is a special transaction, as defined below, there is no \noverlap between the definitions. The issuance chain is closed and the \nreceived tokens will be given as defined.\n  - c only\n      * The definitions of issuance transaction and transfer transaction \ncan be used. The issuance will remain open and the address will receive \nall the tokens received from the inputs\n\nSince both the first and the second group of transactions are giving the \nPOC to the same output that receives the tokens, the output will \ncontinue to carry both the tokens received and the POC. This delegates \nsomeone to issue new tokens and allocates some tokens from a previous \nissuance that are still not assigned.\n\nSplit and join transactions\n---------------------------\nA split or join transaction is one that has one of the following formats \nof outputs:\n\n  - cut, a1, ..., an, z, b1, ..., bm (z is an output signaling zero, \nlike a cut)\n  - cut, a1, ..., an, c\n\nhaving the added condition that the sum of the signals of the outputs \na1, ..., an is:\n\n  - equal to the number of tokens received in input divided by 1000 (we \ncall it a join transaction), or\n  - equal to the number of tokens received in input multiplied by 1000 \n(we call it a split transaction)\n\nSince the presence of these two extra conditions, the fact that a \ntransaction is a join or split transaction, or it is not (hence it is a \nsimple transfer transaction), depends on the number of tokens received \nin the input. A given transaction can be both split or join for some \ntype of tokens, and normal for other types of tokens.\n\nNote: this is the same format that closes an issuance chain. If the \ntransaction receives both POC and tokens of the same type, the \ntransaction chain will be closed and the received tokens will be sent as \ndescribed here.\n\nNote: this is also the format of a transfer transaction that assigns to \nthe change c or bm, the token received in the input. But, if a \ntransaction is a special one of the first two types, that behavior \nshould not be considered and no tokens will be transferred to the change.\n\nThe split transaction generates a new type of tokens with a value that \nis one thousandth of the value of the type of tokens received in the \ninput. This new type can be mixed with tokens generated by other similar \nsplit transactions, based on the same original token. Split tokens have \nthe same value and can be joined in the future with join transactions.\n\nThe join transaction generates a new type of tokens with one thousand \ntimes the value of the type of tokens received in the input. This new \ntype of token can coexist with tokens generated by other similar join \ntransactions, based on the same original token. Joined tokens from the \nsame original token, have the same value and can be split in the future \nwith split transactions. Thus becoming again original tokens.\n\nIn a special transaction of the second group, without \"the second cut\" \nz, the change is mandatory and does not receive tokens. This means that \nthe number of tokens sent is summed up without the last output. If the \nnumber is not correct, then it is not a split or join transaction.\n\nTokens split or joined are of a different type than their original \nsource. This means that they can coexist in the same output and will \nnever mix together. Thus a output having 3 big tokens and 456 tokens \nobtained by a split transaction, seems to have 3.456 tokens, but, in \nfact, has 3 tokens of a type and 456 tokens of another type (the second \ntype is referred as the original type with a 0.001 unit of measure).\n\nNote: as described below, there is a procedure of separating tokens of \ndifferent types contained in the same output. This procedure will not \nwork if the two type of tokens are present in the same output in the \nsame number. Thus if an output contains exactly 3.003 tokens (3 big and \n3 small), the tokens cannot be separated anymore. This is why we \nintroduced, in the transfer transaction definition, the rule that \nassigns in this case one single token of the smallest type to the \n\"remaining error\" output.\n\nToken offering issuance transactions\n------------------------------------\nA token offering issuance transaction is a transaction having one of the \nfollowing formats (z is an output signaling zero, like a cut; r and s \nare outputs that signal a value greater than zero; the group of outputs \n(t1, t2, z) is optional; t1 or t2 can signal zero, but not both):\n\n  - cut, z, r, (t1, t2, z,) a1, ..., an, c\n      * price of tokens are predefined\n  - cut, s, z, (t1, t2, z,) a1, ..., an, c\n      * price of tokens are not predefined\n\nThe tokens will be assigned to one of the outputs of every transaction \nthat sends bitcoin to the address of the outputs r or s, as follows:\n  - if the sending transaction has only two outputs (r, c), (c, r), (s, \nc) or (c, s), the \"other\" output c receives the tokens.\n  - if the sending transaction has more than two outputs, the last \n(biggest) output that is not the one sending bitcoins to r or s, will \nreceive the tokens.\n  - if the sending transaction has only one output, the generated tokens \nwill be assigned to the output r or s itself. This can be considered as \na donation: it generates tokens, but the tokens remain in the \navailability of the issuer.\n  - since the number of token emitted is always an integer, the \nremaining satoshis are not considered in the number of tokens issued and \nare sent to the issuer without any token generation.\n\nNote: this is the second place, in this document, where the bitcoin \naddress of an output is used. The other place regards the alternate \nnames of an issuance. Everything else in the protocol is based on \noutputs, not addresses.\n\nIf the group (t1, t2, z) is present, it signals how many token will be \nissued. The total number of tokens that will be issued is the number \nsignaled by t1 * 10^6 + the number signaled by t2. In any block, the \nissuance can be closed by the transaction that spends the outputs r or s.\n\nTimeline:\n  - The offer starts in the block that contains the token offering \nissuance transaction. Every transaction of the starting block receives \ntokens, without order.\n  - If there is a defined total number of tokens, the issuance will end \nwhen the total number of tokens has been reached.\n      * Inside the last block, the transactions are considered in the \norder they are listed. So if a transaction takes the last tokens, every \nother transaction sending bitcoins to r or s, do not receive tokens.\n  - The transaction that spends the outputs r or s ends the issuance. \nThis transaction suspends the issuance even if a defined number of \ntokens was defined in the token offering issuance transaction.\n      * In case of an issuance suspeded, or ended, by a transaction \nspending r or s, every transaction of the block containing the spending \ntransaction will be considered valid as a receiver of tokens.\n      * Thus, sending bitcoins to the address of the outputs r or s will \nbe considered as part of the offering, only if it is included in a block \nbetween the block of the transaction that has r or s as an output \n(start), and the block of the transaction that spends the output r or s \n(end), inclusive.\n\nA token offering issuance transaction of the first type permits to set a \nrate, and to issue tokens every time bitcoins are received by an \naddress. The rate is defined by the number signaled by the output r. One \ntoken will be issued for every r satoshis received.\n\nA token offering issuance transaction of the second type does not set a \npredefined rate at the start. The rate will be defined by the \ntransaction that closes the issuance by spending the output s. The first \n(smallest) output of the closing transaction, or the first output after \nthe cut (if a cut is present), will signal the rate. This type of token \noffering issuance, having the price defined at the end, permits to issue \ntoken based on parameters related to the issuance itself. This is the \ncase, for example, of Dutch Auctions.\n\nNote: A token offering issuance transaction can be seen as a transfer \ntransaction, that sends all the tokens that receives to the output c.\n\nNote: the type of token issued is defined by the token offering issuance \ntransaction, seen as an issuance transaction. Since a token offering \ntransaction is also the closure of some issuing chains, this means that \nthe same token offer will issue different type of tokens. In fact, a \ndifferent type of token will be issued for every issuance chain that \nends with the same token offering issuance transaction. Thus a token \ntype can be first issued in a controlled way (this is usually called \npre-ICO) and then the rate can be stated, and the same type of token can \nbe offered to the public (this is usually called the ICO). Since the \ntoken offering issuance transaction closes the issuance forever, there \nis the guarantee that no other tokens of the same type will ever be \nissued after the offer is closed. In order to offer tokens at different \nprices, multiple issuance transactions can be generated with POCs \noriginating from the same issuance chain.\n\nAtomic transactions between bitcoins and tokens\n-----------------------------------------------\nUsing the cut signal and software that allows full \"coin selection\", \nit's possible to make atomic exchange transactions. The outputs before \nthe cut will determine who will receive the tokens and the following \noutputs will define the rest of the transaction. Both the changes (the \none of the token wallet and the one of the Bitcoin wallet), should be in \nthe second set (after the cut). Since the cut will receive the remaining \ntokens, it is suggested that the cut is sent to the seller of tokens. \nUsing this method, the remaining tokens can be sent without involving a \ncalculation of the remaining tokens. The outputs of an atomic exchange \ntransaction will have the following format (seller is the token seller, \nbuyer is the token buyer).\n\n  - a1: tokens sent from the seller to the buyer\n  - a2: tokens sent from the seller to the buyer\n  - cut: part of the bitcoin payment sent from buyer to seller\n  - b1: part of the bitcoin payment sent from buyer to seller (or change \nsent from seller to buyer, if the price to be paid is less than the \nvalue of the cut)\n  - b2: Bitcoin change sent to the token wallet\n  - b3: Bitcoin change sent to the bitcoin wallet\n\nIt is impossible to make an atomic exchange transaction if the wallet in \nuse does not allow coin selection.\n\nCross token atomic transactions\n-------------------------------\nLet's say that Alice wants to sell a number x of tokens of type Ta and \nBob wants to pay using y tokens of type Tb. Token of type Tb are of \nlesser value than the tokens of type Ta, so Bob will pay more Tb tokens \nand Alice will pay fewer Ta tokens (x < y). Let's say that the \ntransaction spends an output from Alice containing BTCa bitcoins and \n*exactly* x tokens, while Bob sends to the same transaction BTCb \nbitcoins and a number z of tokens of type Tb. Since z > y, Bob will \nreceive a change c in tokens of type Tb.\n\nAlice managed the previous transactions so that a fixed number x of \ntokens can be sent as the input with a number BTCa of bitcoins. Bob is \nnot required do the same, because there is the cut that gives the \nremaining tokens back to Bob. In order to simplify let's say that there \nis another input giving the fee for the transaction and the Bitcoin \nassigned to each output will be calculated accordingly.\n\nThe atomic transaction can be made by signaling with the first output \nthe number y of tokens that Bob should pay to Alice. This output will go \nto Alice. Since y is higher than x, all the x tokens of type Ta will go \nto the change (directed to Bob), while the y tokens of type Tb will go \nto the first output. A following cut can be used to send the change to \nBob. The addresses following the cut can be used as changes of bitcoins.\n\nThe inputs of the transaction will have a content in Bitcoin and tokens \nas follows:\n\n  - Alice will spend an output having BTCa bitcoins and containing \n*exactly* x tokens of type Ta\n  - Bob will spend an output having BTCb bitcoins and containing y + c \ntokens of type Tb\n\nThe outputs of the transaction will have the following form:\n\n  - Bitcoin sent: BTCa1; Signal sent: y; Directed to Alice (the output \ngets y tokens of type Tb, but does not get any token of type Ta, because \nx < y)\n  - Bitcoin sent: BTCb1; Signal sent: cut; Directed to Bob (no token of \ntype Ta given, but receives c tokens of type Tb)\n  - Bitcoin sent: BTCa - BTCa1; Signal sent: not important; Directed to \nAlice (no token sent, but useful to send a change in Bitcoin to Alice, \nif needed)\n  - Bitcoin sent: BTCb - BTCb1; Signal sent: not important; Directed to \nBob (this output gets number x tokens of type Ta)\n\nCross token atomic transactions in the case of the same number of tokens \nto be exchanged\n----------------------------------------------------------------------------------------\nThe atomic transactions described above do not work if the value of \ntokens of type Ta is equal to the value of tokens of type Tb. In this \ncase, there is no way of doing an atomic exchange.\n\nLet's say that we need to do a transaction between two tokens that have \nthe same value: TetherA and TetherB. Let's say that Alice and Bob want \nto change 199 tokens. The atomic transaction cannot be made, but, with a \nsmall risk, two transactions can be made. The first will be an atomic \ntransaction giving 100 tokens of type TetherA from Alice to Bob and \nreceiving 99 of type TetherB back, and the second will be 99 to 100.\n\nHow to separate different types of token\n----------------------------------------\nLet's say that an output contains two different types of tokens of \ninterest to the user. Is there a way to separate the tokens so that they \ncan be sent to different outputs? If the tokens are exactly the same \nnumber, there is not. If the tokens are two different numbers: x tokens \nof type A and y tokens of type B, then the separation can be done. Since \nthe \"remaining error\" of an output goes to the change, we can send the \nhigher value of the two and have the change receive the lower. We assume \nthat x < y.\n\nLet's call A1 the output that will receive A and B1 the output that will \nreceive the tokens of type B.\n\nThe transaction will be similar to the cross token atomic transaction:\n\n  - Signal sent: x (the output gets x tokens of type B, but does not get \nany token of type A, because x < y)\n  - Signal sent: cut (no token of type A given, but receives a change in \ntoken of type B if the previous signal was less than y)\n  - Other outputs\n  - Signal sent: not important (this output gets number x tokens of type A)\n\nGuidelines\n==========\nThere are some suggestions that, if followed by the user, permit \nmanaging tokens in a simple manner, without technical knowledge of the \nrest of the protocol, with plausible deniability. This can be done using \nany existing wallet.\n\nThe guidelines described here are based on a wallet that will be \n\"consolidated\". This means that all the outputs of the wallet are linked \ntoghether. In some cases, this behavior diminish the level of privacy of \nthe user. Thus, it is advised to use a number of different wallets, in \norder to reach the desired level of privacy.\n\nPlausible deniability: how to use a wallet to manage tokens\n-----------------------------------------------------------\nSome of the protocol's operations are designed to be managed using a \ncoin selection software, however, any wallet without coin selection can \nbe used to generate, send, or receive tokens. The option to use any \nexisting Bitcoin wallet is the base of the plausible deniability of the \nprotocol. The user can send, receive and generate tokens by using any \nwallet in a way that seems a normal use of the Bitcoin protocol to \nmanage bitcoins.\n\nThus, the guidelines in this section are based on a use of a wallet by a \nuser without involving any \"coin selection\".\n\nIn order to send or generate tokens, the user needs to have, at any \ntime, only one output in the wallet. Let's call it a \"consolidated\" \nwallet. In order to consolidate a wallet:\n\n  - Send all the bitcoins contained in the wallet to a new address of \nthe same wallet\n\nIf the user departs from these guidelines by mistake, he can \"fix\" his \nwallet and re-consolidate it without losing the tokens contained in the \nwallet. If the wallet is consolidated, it remains consolidated while \ntokens are generated or sent, and while bitcoins from the wallet are \nspent. If bitcoins or tokens are received by any address of the wallet, \nthen the wallet needs to be consolidated again.\n\nIssuance of tokens\n------------------\nIn order to generate tokens:\n\n  - Consolidate the wallet if it is not already consolidated.\n  - Send a minority of the bitcoins contained in the wallet to a new \naddress (outside of the wallet). The last five digits of the satoshis \nsent are the number of tokens generated.\n  - From the same wallet, other tokens can be generated by sending again \na number of satoshis, having the last five digits that are the number of \ntokens to issue to the new address.\n  - The value of bitcoins sent should always be less than the bitcoin \nthat remains in the wallet\n  - If during the process of generating tokens the wallet receives \nbitcoins, it should be consolidated again before continuing to generate \ntokens.\n  - The type (or name) of tokens will be the txid of the transaction. If \nthe transaction sends bitcoin to a new, never used, address, the address \ncan be used as the name of the tokens, as well.\n\nIn order to give the power to generate new tokens to another person:\n\n  - Send all the Bitcoin content of the wallet to the other person, with \na single transaction\n\nIn order to close an issuance:\n\n  - To close the issuance and guarantee that no other tokens of this \ntype will ever be generated again, send to another address of the same \nwallet a number of bitcoins with the last five digits of the satoshis \nthat is zero. Be aware that this shouldn't be all the content of the \nwallet. If all the content of the wallet is sent to some address, the \nissuance will not be closed. Instead, this gives to the receiver the \npower to generate new tokens.\n\nSpending bitcoins and not tokens\n--------------------------------\nIn order to spend bitcoins from the wallet without sending any tokens, \nthe user should spend less than half of the bitcoin value contained in \nthe wallet, and:\n\n  - Spend a number of satoshis where the last five digits are all zeros,\n  or\n  - Spend a number of satoshis where the last five digits are a number \ngreater than the tokens that are in the wallet,\n\nTransfer of tokens\n------------------\nIn order to send tokens to another person:\n\n  - Consolidate the wallet if it is not already consolidated.\n  - Send a value less than half of the content of the wallet and having \nthe number of satoshis where the last five digits are the number of \ntokens that need to be transferred,\n  or\n  - Send all the bitcoins of the wallet (even if the wallet is not \nconsolidated).\n\nIf the user sends all the content of the wallet to a single address (no \nchange), then he's emptying the token content from the wallet, as well. \nAll the tokens will go to the address and nothing will remain to the user.\n\nIn order to receive tokens from other users:\n\n  - Give to the other person a Bitcoin address of the wallet and ask to \nsend tokens as explained above.\n  - If the wallet was empty before of receiving tokens, then it is \nalready consolidated. Instead, if the wallet already had some bitcoins, \nthen the wallet needs to be consolidated before sending or generating \ntokens.\n\nEffects of the use of these guidelines\n--------------------------------------\nWhen using the guidelines, the number of tokens sent to the recipient is \nalways stated in the last five digits of the satoshis sent. There are \nthree exceptions:\n\n  - In a single output transaction, all the tokens of the wallet will be \nsent to the recipient.\n  - In a transaction where the amount of satoshis sent ends with five \nzeros, no tokens are sent.\n  - In a transaction sending more tokens than the number of tokens of \nthat type held in the wallet, no tokens are sent.\n\nTechnical notes\n---------------\n  - Sending a number of bitcoins that is greater than half of the \nbitcoins contained in the wallet brings to unpredicted results.\n  - Thus, if there are not enough bitcoins to continue to operate, the \nwallet needs to be \"re-charged\" by sending some bitcoins to it. By doing \nso, there will be more than one UTXO in the wallet. This departs from \n\"consolidated mode\" and the wallet needs to be consolidated again.\n  - A consolidated wallet contains only one UTXO.\n  - Every transaction made from a consolidated wallet contains only two \noutputs: one is the address outside of the wallet, and the other is the \nchange.\n  - Every transaction spends all the content of the wallet.\n\nReference Implementation\n========================\nA reference implementation will be included when the protocol will be \nreviewed and accepted by the community."
            },
            {
                "author": "Luke Dashjr",
                "date": "2017-09-06T18:58:44",
                "message_text_only": "I think you could check out and coordinate with the OpenAssets proposal.\n\nYour current draft also claims to solve a lot of problems that it doesn't \nactually solve technically...\n\nLuke\n\n\nOn Wednesday 06 September 2017 11:44:47 Luca Venturini via bitcoin-dev wrote:\n> Hi everyone,\n> \n> I would like to propose a standard protocol to manage tokens on top of\n> the Bitcoin blockchain.\n> \n> The full text is enclosed and can be found here:\n> \n> https://github.com/token21/token-protocol-specification\n> \n> Any feedback will be appreciated.\n> \n> Luca Venturini\n> \n> ---\n> \n> Abstract\n> ========\n> This document describes a protocol to manage digital assets (tokens) on\n> top of the bitcoin blockchain. The protocol enables a semantic layer\n> that permits reading the bitcoin transactions as operations related to\n> tokens.\n> \n> The protocol allows a new level of plausible deniability, while\n> permitting statefull public auditability on each issued token. It allows\n> both the user and the issuer to deny that an existing bitcoin\n> transaction between the two is actually a token transaction, or a new\n> token issuance. While both the token sender and the token issuer cannot\n> deny to have sent bitcoins, nobody can prove the transaction was related\n> to a digital asset. On top of that, to guarantee plausible deniability,\n> tokens can be issued, sent, and received using any existing bitcoin\n> client software.\n> \n> There is no need to have a wallet exclusively dedicated to manage the\n> tokens. With a few simple precautions by the user, tokens can be managed\n> using any existing Bitcoin wallet, while it is used for normal bitcoin\n> transactions as well.\n> \n> Since it is possible to infinitely split a token in parts, there is no\n> definition of the number of decimals of token generated and transferred.\n> The number of tokens is always an integer.\n> \n> Every operation of the protocol is performed with Bitcoin transactions,\n> without the use of OP_RETURN and without any form of pollution of the\n> blockchain, or of the UTXO set.\n> \n> The protocol permits atomic buy and sell transactions between tokens and\n> Bitcoin, and between different types of tokens. The only operations that\n> require a coin selection enabled wallet are the split and join special\n> operations and the token offering issuance operations. Those are used to\n> modify the token unit of measure and to receive bitcoins from third\n> parties during a token offering issuance.\n> \n> Copyright\n> =========\n> This document is licensed under the 2-clause BSD license.\n> \n> Motivation\n> ==========\n> The current protocols that permit to issue tokens based on the bitcoin\n> blockchain (i.e. Counterparty, Omni, Colored Coins, Coinprism, Colu) are\n> flawed.\n> \n> The existing solutions usually need dedicated wallets and/or\n> verification nodes. Usually, a \"pivot\" currency is involved and atomic\n> transactions are not permitted unless they use the pivot currency. Those\n> protocols pollute the blockchain (30% or more) and in some cases they do\n> not accept P2SH scripts. Since the use of a dedicated wallet is\n> required, the users cannot plausibly deny they have got tokens.\n> Plausible deniability on the issuer side is not available either. None\n> of these protocols permits infinite division of the tokens, so usually\n> the number of decimals has to be specified at issuance time. The\n> automatic token offering issuance is not enabled as well.\n> \n> Rationale\n> =========\n> Let's take an example from the real world, a yacht. We write on the\n> yacht's license that the owner is any person that can show a one dollar\n> bill having the serial number F82119977F. Thus the one dollar bill can\n> be exchanged between owners with extreme simplicity and full plausible\n> deniability. The US government will guarantee that there is no other\n> person having the same dollar bill.\n> \n> The protocol permits managing a token in the same way. The underlying\n> Bitcoin protocol will guarantee against double spending.\n> \n> Features:\n> \n>   - Easy of use. Tokens can be managed using any wallet. Even if the\n> wallet has no coin selection feature.\n>   - Plausible Deniability by the issuer. The issuer can generate a new\n> type of token and nobody analyzing the blockchain will understand that\n> the transaction is issuing a token. Even if a token is known, the issuer\n> can issue other tokens. Since a single output contains a large number of\n> different token types, the issuer is actually generating different types\n> of tokens every time she sends a new Bitcoin transaction to the network.\n>   - Plausible Deniability by the user (no use of tokens at all, or use\n> of a different token type). A transaction that sends tokens from Alice\n> to Bob is a normal transaction. Nobody can understand that this\n> transaction is moving tokens unless they explicitly know which\n> transaction is the token issuance. In fact a single address contains a\n> large number of token types, and the use of tokens itself can be denied.\n>   - Accountability. Everybody can see the state of the distribution of a\n> type of token.\n>   - Tunnel mode (confidentiality by issuer and user versus a third\n> party). Alice can send tokens to Bob and ask him to give the tokens to\n> Charlie, without telling to Bob what is the type of the token given.\n> Alice can disclose this information in the future, if she wants.\n>   - It is possible to perform open or closed issuances. While an open\n> issuance permits to continue the issuance of tokens in the future,\n> closed issuance guarantees that no other token of the same type will\n> ever be issued.\n>   - The power to continue the issuance of an open token can be sent to\n> another address, using a transaction. Once the power to continue the\n> issuance is sent to someone, the former issuer cannot issue any more\n> tokens. - The power to continue the issuance has the same features of\n> plausible deniability of the possess of a token.\n>   - Since a token type is uniquely identified by a transaction hash, or,\n> in some cases, by a Bitcoin address, a user can prove to be the issuer\n> by signing a message using the Bitcoin protocol.\n>   - Future proof. Tokens can move following P2PKH, P2SH, P2SH-P2WPKH\n> outputs or any other type of script\n>   - Blockchain pollution of the protocol transactions is almost zero.\n> There is no OP_RETURN involved, nor any other type of \"fake\" addresses\n> that pollute the UTXO database.\n>   - The protocol is based on the Bitcoin blockchain, but, with small\n> changes, can be considered blockchain agnostic.\n>   - Atomic transactions between tokens and Bitcoin are possible.\n>   - Atomic transactions between different types of tokens are possible.\n>   - Tokens of different types can be held by the same address and by the\n> same output.\n>   - Tokens can be divided indefintely, thus having any number of decimals.\n>   - Tokens can be issued automatically on the receiving of bitcoins.\n> This operation performs a token offering issuance (also known as Initial\n> Coin Offering).\n> \n> Introduction\n> ============\n> \n> Where are the tokens?\n> ---------------------\n> As with bitcoins, tokens are contained in unspent Bitcoin outputs. In\n> some cases, defined below, the last five digits of the satoshi value\n> sent to the output represent the number of tokens contained in the output.\n> \n> When an output is spent, the tokens contained in the output are fully\n> spent in the same transaction. There are no tokens outside of the tokens\n> contained in the UTXO database.\n> \n> Token issuance\n> --------------\n> The large majority of bitcoin transactions can be semantically seen as\n> token issuances. There are two types of token issuances: closed and\n> opened. A closed token issuance guarantees that no other token of the\n> same type will ever be issued.\n> \n> Issuance chains\n> ---------------\n> An open issuance gives to one, or more, of its output the power to\n> continue the issuance of tokens of the same type. We define such a power\n> as Power of Continuation (POC). The transaction that will spend the\n> output appointed with the POC will be a continuation of the same\n> issuance chain.\n> \n> Every transaction of the chain will issue the same type of token. On top\n> of that, every transaction that is part of the chain, can also be seen\n> as as issuance of tokens of its, new, type. A chain will be closed by a\n> transaction having more than one output and the first output with five\n> zeros as the last five digits of the satoshis value. No other\n> transactions can send tokens of the same type after the close of the\n> issuance.\n> \n> Token names\n> -----------\n> A token type can have multiple names. The default name is the hash of\n> the first transaction that issued the token.\n> \n> i.e: 68330b6ab26e44f9c3e515f04d15ffe6547f29e60b809a47e50d9abf59045c1e\n> \n> As alternative names, a token type can be named after the bitcoin\n> address of one of the outputs of the transaction that first issued the\n> token, provided the fact that the address has never been used before in\n> the blockchain.\n> \n> Note: it is better to use one of the alternate names in cases when\n> transaction malleability is a concern.\n> \n> Vanity token names\n> ------------------\n> A token can be identified using only the first characters of the Bitcoin\n> address, as alternate name defined above, if the characters are\n> different from every previous Bitcoin address seen in the blockchain. An\n> example is provided below.\n> \n> Tokens can coexist\n> -------------------\n> Token of different types can coexist in a single output while remaining\n> of different types. Thus a bitcoin address (actually an output of the\n> UTXO database) can hold tokens of different types. Every Bitcoin address\n> contains a lot of types of tokens, so that a user usually does not know\n> all the type of tokens contained in an address.\n> \n> A single transaction can send a type of token to some of the outputs\n> while sending another type of token to a different set of its outputs.\n> Tokens are never burned or deleted.\n> \n> Use the protocol\n> ================\n> This section explains a basic use case. In all the examples provided, we\n> do not consider the fee. We assume that there is another input, not\n> listed, that pays the transaction fee.\n> \n> Alice, Bob, Charlie, and Daniel decides that they want to start a new\n> company. Each of them will give to the new company some time, money,\n> furniture, knowledge. They decide everyone contributed to the company\n> with a percentage of value as follows: Alice - 40%, Bob - 12%, Charlie -\n> 34% and Daniel - 14%. They decide that the shares of the new company can\n> be freely resold to others and that they will accept that the annual\n> meeting will consent vote through messages signed using the Bitcoin\n> protocol by the owners of the shares.\n> \n> Issue tokens\n> ------------\n> Alice asks Bob, Charlie, and Daniel to send her 1 Bitcoin each. She asks\n> each of them to give her a bitcoin address where they want to receive\n> back the bitcoins along with the tokens.\n> \n> She asks Charlie to generate a vanity address that has never been used\n> before of type 1CompanyXWXjLgud9jxwxm34u.... Since there has been a\n> previous address in the blockchain having 1Companx as the first\n> characters, but this is the first address seen in the blockchain that\n> has 1Company as the first characters, they will call the token with the\n> name 1Company. This step is optional.\n> \n> Then she sends, from her wallet, a transaction having the following\n> outputs:\n> \n>   - 1.00000040 to an address controlled by Alice\n>   - 1.00000012 to an address controlled by Bob\n>   - 1.00000034 to the vanity address 1CompanyXWXjLgud9jxwxm34u...\n> controlled by Charlie\n>   - 1.00000014 to an address controlled by Daniel\n>   - 3.45322112 is the change generated by Alice's wallet\n> \n> This transaction gives 40, 12, 34, 14 tokens to each one. The newly\n> generated token type can be named after the transaction hash, or after\n> the vanity address (optional), or after one of the addresses of the\n> persons involved, provided that the address has never been used before.\n> \n> The issuance is still open. Since they do not want to issue more shares,\n> they decide to close the issuance (on the other side, they could decide\n> to leave the issuance open and to hold the issuing key somewhere, or to\n> have a multisignature address and to give the keys to the directors of\n> the company). In order to close the issuance, Alice generates the\n> following transaction that sends bitcoins from her wallet to addresses\n> of her same wallet, using the change output of the previous transaction\n> as an input:\n> \n>   - 0.45000000 to an address of her wallet\n>   - 3.00322112 change generated by the wallet\n> \n> This closes the issuance.\n> \n> Send tokens\n> --------------\n> After some while, Bob decides to give some shares of the company to his\n> husband Giacomo. He generates a new transaction spending the output of\n> the issuance transaction:\n> \n>   - 0.03400008 to Giacomo\n>   - 0.96600004 change generated by Bob's wallet\n> \n> This transaction gives to Giacomo 8 shares of the company.\n> \n> Atomic transactions\n> -------------------\n> Daniel wants to sell 3 of his 14 shares to Frank. They negotiate a price\n> of 0.00323200 bitcoin per share. This is a total of 0.00969600 bitcoin\n> to buy the three shares. They do not know each other very well, so they\n> decide to make an atomic transaction that will give 0.00969600 bitcoins\n> to Daniel and 3 shares to Frank. Daniel set an input of the new\n> transaction with his issuance transaction output. Frank put in another\n> input of 1.23242454 bitcoins from his wallet. The outputs of the\n> transaction are as follows:\n> \n>   - 0.22400003 to an address controlled by Frank (this gives the 3\n> shares to Frank)\n>   - 0.23200000 to an address controlled by Daniel (this is part of the\n> payment to Daniel)\n>   - 0.77769614 to an address controlled by Daniel (this can be\n> considered the change of the original issuance output of 1.00000014)\n>   - 0.99872851 to an address controlled by Frank (change to Frank)\n> \n> Daniel sent to the inputs of the transaction 1.00000014 bitcoins and\n> receives back 1.00969614. This gives to Daniel the 0.00969600 paid by\n> Frank. On the other side, Frank sends 1.23242454 as an input of the\n> transaction and receives back 1.22272854 bitcoins, thus paying exactly\n> the 0.00969600 that needs to be paid to Daniel. This transaction sends 3\n> tokens from Daniel to Frank. Another 11 tokens are the tokens that are\n> given as a change to Daniel, along with 0.23200000 bitcoins.\n> \n> Specification\n> =============\n> \n> Definitions\n> -----------\n> In order to evaluate a transaction, the outputs are sorted by the\n> satoshis value. Once sorted, we define a \"cut\" output the first output\n> having five zeros as the last five digits of the satoshi value (satoshis\n> modulo 10^5 == 0). In the following, \"first\", \"second\", \"last\" are all\n> referred to the sorted outputs.\n> \n> We define as \"signal\" of an output the value of satoshis of the output\n> modulo 10^5. This is the last five digits of the value, as expressed in\n> satoshis.\n> \n> Despite not mandatory, we sometimes call \"c\", or \"change\", the output\n> having the biggest value in Satoshi. This is the last output, as sorted\n> above. Such behavior follows the \"Guidelines\" section, explained below.\n> \n> We use n=0 related to a sequence a1, ..., an, to indicate that there are\n> no elements in the sequence.\n> \n> Issuance of a token\n> -------------------\n> A transaction that has only one output, or has the first output that is\n> a cut, issues no token. Every other Bitcoin transaction is an issuance\n> of tokens of the type of the transaction.\n> \n> When a issuance is open, Power of Continuation (POC), will be given to\n> an output that will be spent in a transaction that continues the\n> issuance of the same type of tokens.\n> \n> As for the protocol behavior, we divide the structure of the sorted\n> outputs of a bitcoin transaction in the following groups. For each\n> group, a description of the behavior of the protocol is provided.\n> \n>   - a1, ..., an, cut(POC), z1(POC), ... zm(POC), b1, ..., bl, with n>0,\n> m>=0, m+l>0\n>       * zi are outputs signaling zero. They are optional.\n>       * This is an open issuance. It generates the number of tokens\n> signaled by the outputs before the cut: a1, ..., an. Every output of\n> that set receives a number of tokens as signaled by the output satoshis'\n> value.\n>       * The cut output, and every other output zi, signaling zero, that\n> is directly after the cut, receive the POC. This means that the\n> transactions that will spend the POC will be a continuation of this\n> issuance and a continuation of every issuance that gave the POC to the\n> this transaction.\n>   - cut, b1, ..., bm with m>0 (a cut alone is a case of the fourth type)\n>       * This is a particular case of the first group, having n=0 and\n> m=0. This transaction *closes the issuance forever*. Every token's chain\n> that ends into this transaction is closed as well.\n>       * It generates no tokens and there are no other outputs that can\n> continue the issuance in the future.\n>       * If b1 or b2 have a signal of zero and m>2, this is a token\n> offering issuance transaction. It will be described in a following section.\n>   - a1, ..., an, c(POC) with n>0\n>       * This is an open issuance. It generates the number of tokens that\n> are signaled in a1, ..., an. The last output c will not receive tokens.\n>       * The last output c will receive the POC. A following transaction\n> that spends the output c is an issuance transaction of the same type of\n> token.\n>       * The fact that c is a cut (or not) does not modify the behavior\n> of the transactions of this group\n>   - c(POC) (single output, also seen as the previous one, with n=0)\n>       * This transaction generates no tokens at all.\n>       * The output c receives the POC. Thus a following transaction that\n> spends the output c is an issuance transaction of the same type of token.\n> \n> Notes on token issuances\n> ------------------------\n> The number of tokens generated by an issuance transaction is always the\n> sum of the signals of all the outputs, excluding the last one and the\n> outputs that are listed after a cut. Thus the number of tokens sent to\n> each output, that receives tokens, is always the number signaled by the\n> output.\n> \n> Who has the power to generate other tokens of the same issuance (POC):\n> \n>   - If there is no cut, the issuance is open and the transaction that\n> will spend the last (biggest) output can continue to generate token of\n> the same type.\n>   - If there is a cut, in a position different than the first, the\n> issuance is open. The cut output will be the input of a following\n> transaction that issues more tokens of the same issuance chain. The\n> following transaction can close tha chain, or can be an open issuance,\n> thus having another output that will continue the generation chain.\n> \n> In order to close forever the issuance of tokens, the transaction should\n> have a cut as the first output and have more than one output.\n> \n> Transfer of tokens\n> ------------------\n> Every bitcoin transaction spends all the tokens' content of the inputs\n> and sends them to the outputs. Some of the outputs receive the number of\n> tokens exactly stated in the last five digits of the satoshis sent (the\n> signal), in a way similar to an issuance transaction.\n> \n> A transaction can be seen as having one of the three following shapes\n> (ai means an output that is not a cut, bi and c are outputs that can be\n> cut):\n> \n>   - a1, ..., an, cut, b1, ..., bm, c (transactions with a cut) (n=0 is\n> described here)\n>       * No output (bi) after a cut receives tokens.\n>       * Tokens will be assigned to outputs a1, ..., an trying to follow\n> the signal as follows:\n>           - If there are enough tokens, the tokens signaled by the first\n> output are assigned to that output.\n>           - If there are still remaining tokens, the tokens are sent to\n> the following output based on the signal.\n>           - This continues until there is a cut or the tokens signaled\n> by an output are more than the remaining tokens. In these cases:\n>               * If there is a cut, it receives all the remaining tokens.\n>               * If there is an output receiving more tokens than the\n> remaining tokens (we define it a \"remaining error\"), the output receives\n> no token at all. No other output will receive tokens after this and all\n> the remaining tokens will be sent to the last output c (thus, if there\n> is a cut in the transaction, the algorithm \"jumps\" the cut).\n>               * If there is a \"remaining error\" and the transaction is a\n> special transaction as defined in the next section, and the number of\n> tokens in input is exactly the same of the two types (big and small)\n> that are the result of a previous split or join special transaction, the\n> \"remaining error\" output gets one of the smallest tokens involved. This\n> will be better explained in the following section about \"special\n> transactions\".\n>       * If the first output is a cut, and the transaction is not a\n> special one as defined below in the document, the last output (c)\n> receives all the tokens\n>   - a1, ..., an, c (ai is not a cut, for every i; c can be a cut)\n>       * The tokens are assigned to a1, ..., an as described in the\n> previous group.\n>       * The last output c receives all the remaining tokens. This\n> behavior is not modified by the fact that the last output is a cut.\n>   - c (single output transaction, also seen as the previous one, with n=0)\n>       * The output receives all the tokens received from the inputs\n> \n> Transactions receiving both the POC of an issuance and some tokens of\n> the same issuance\n> ---------------------------------------------------------------------------\n> ------------ The protocol is designed such that a transaction of an\n> issuance chain never issue new tokens to an output, that receives the POC\n> of the same type of token. But two different inputs can give to a\n> transaction both some tokens and the POC of the same type of token. In\n> this case, there is a double role for the transaction that is both a\n> continuation of the issuance and a transfer transaction sending tokens of\n> the same type.\n> \n> In this case, the tokens will be allocated as defined in the following\n> four different shapes of transaction:\n> \n>   - a1, ..., an, cut, b1, ..., bm, c (transaction with a cut)\n>       * The generated tokens are sent to the outputs a1, ..., an as\n> described in the definition of an issuance of tokens\n>       * All the tokens received in input of the same type of the\n> issuance we are continuing will be sent to the cut output\n>   - a1, ..., an, c (transaction without a cut, or with c that is a cut:\n> ai is not a cut, for every i)\n>       * The generated tokens are sent to the outputs a1, ..., an as\n> described in the definition of an issuance of tokens transaction\n>       * All the tokens received in input, of the same type of the\n> issuance we are continuing, will be sent to the last output c\n>   - cut, b1, ..., bm\n>       * The issuance will be closed and all the tokens will be given to\n> the last output bm. The behavior described in the issuance transaction\n> and in the transaction sending tokens do not influence each other, in\n> this case.\n>       * If it is a special transaction, as defined below, there is no\n> overlap between the definitions. The issuance chain is closed and the\n> received tokens will be given as defined.\n>   - c only\n>       * The definitions of issuance transaction and transfer transaction\n> can be used. The issuance will remain open and the address will receive\n> all the tokens received from the inputs\n> \n> Since both the first and the second group of transactions are giving the\n> POC to the same output that receives the tokens, the output will\n> continue to carry both the tokens received and the POC. This delegates\n> someone to issue new tokens and allocates some tokens from a previous\n> issuance that are still not assigned.\n> \n> Split and join transactions\n> ---------------------------\n> A split or join transaction is one that has one of the following formats\n> of outputs:\n> \n>   - cut, a1, ..., an, z, b1, ..., bm (z is an output signaling zero,\n> like a cut)\n>   - cut, a1, ..., an, c\n> \n> having the added condition that the sum of the signals of the outputs\n> a1, ..., an is:\n> \n>   - equal to the number of tokens received in input divided by 1000 (we\n> call it a join transaction), or\n>   - equal to the number of tokens received in input multiplied by 1000\n> (we call it a split transaction)\n> \n> Since the presence of these two extra conditions, the fact that a\n> transaction is a join or split transaction, or it is not (hence it is a\n> simple transfer transaction), depends on the number of tokens received\n> in the input. A given transaction can be both split or join for some\n> type of tokens, and normal for other types of tokens.\n> \n> Note: this is the same format that closes an issuance chain. If the\n> transaction receives both POC and tokens of the same type, the\n> transaction chain will be closed and the received tokens will be sent as\n> described here.\n> \n> Note: this is also the format of a transfer transaction that assigns to\n> the change c or bm, the token received in the input. But, if a\n> transaction is a special one of the first two types, that behavior\n> should not be considered and no tokens will be transferred to the change.\n> \n> The split transaction generates a new type of tokens with a value that\n> is one thousandth of the value of the type of tokens received in the\n> input. This new type can be mixed with tokens generated by other similar\n> split transactions, based on the same original token. Split tokens have\n> the same value and can be joined in the future with join transactions.\n> \n> The join transaction generates a new type of tokens with one thousand\n> times the value of the type of tokens received in the input. This new\n> type of token can coexist with tokens generated by other similar join\n> transactions, based on the same original token. Joined tokens from the\n> same original token, have the same value and can be split in the future\n> with split transactions. Thus becoming again original tokens.\n> \n> In a special transaction of the second group, without \"the second cut\"\n> z, the change is mandatory and does not receive tokens. This means that\n> the number of tokens sent is summed up without the last output. If the\n> number is not correct, then it is not a split or join transaction.\n> \n> Tokens split or joined are of a different type than their original\n> source. This means that they can coexist in the same output and will\n> never mix together. Thus a output having 3 big tokens and 456 tokens\n> obtained by a split transaction, seems to have 3.456 tokens, but, in\n> fact, has 3 tokens of a type and 456 tokens of another type (the second\n> type is referred as the original type with a 0.001 unit of measure).\n> \n> Note: as described below, there is a procedure of separating tokens of\n> different types contained in the same output. This procedure will not\n> work if the two type of tokens are present in the same output in the\n> same number. Thus if an output contains exactly 3.003 tokens (3 big and\n> 3 small), the tokens cannot be separated anymore. This is why we\n> introduced, in the transfer transaction definition, the rule that\n> assigns in this case one single token of the smallest type to the\n> \"remaining error\" output.\n> \n> Token offering issuance transactions\n> ------------------------------------\n> A token offering issuance transaction is a transaction having one of the\n> following formats (z is an output signaling zero, like a cut; r and s\n> are outputs that signal a value greater than zero; the group of outputs\n> (t1, t2, z) is optional; t1 or t2 can signal zero, but not both):\n> \n>   - cut, z, r, (t1, t2, z,) a1, ..., an, c\n>       * price of tokens are predefined\n>   - cut, s, z, (t1, t2, z,) a1, ..., an, c\n>       * price of tokens are not predefined\n> \n> The tokens will be assigned to one of the outputs of every transaction\n> that sends bitcoin to the address of the outputs r or s, as follows:\n>   - if the sending transaction has only two outputs (r, c), (c, r), (s,\n> c) or (c, s), the \"other\" output c receives the tokens.\n>   - if the sending transaction has more than two outputs, the last\n> (biggest) output that is not the one sending bitcoins to r or s, will\n> receive the tokens.\n>   - if the sending transaction has only one output, the generated tokens\n> will be assigned to the output r or s itself. This can be considered as\n> a donation: it generates tokens, but the tokens remain in the\n> availability of the issuer.\n>   - since the number of token emitted is always an integer, the\n> remaining satoshis are not considered in the number of tokens issued and\n> are sent to the issuer without any token generation.\n> \n> Note: this is the second place, in this document, where the bitcoin\n> address of an output is used. The other place regards the alternate\n> names of an issuance. Everything else in the protocol is based on\n> outputs, not addresses.\n> \n> If the group (t1, t2, z) is present, it signals how many token will be\n> issued. The total number of tokens that will be issued is the number\n> signaled by t1 * 10^6 + the number signaled by t2. In any block, the\n> issuance can be closed by the transaction that spends the outputs r or s.\n> \n> Timeline:\n>   - The offer starts in the block that contains the token offering\n> issuance transaction. Every transaction of the starting block receives\n> tokens, without order.\n>   - If there is a defined total number of tokens, the issuance will end\n> when the total number of tokens has been reached.\n>       * Inside the last block, the transactions are considered in the\n> order they are listed. So if a transaction takes the last tokens, every\n> other transaction sending bitcoins to r or s, do not receive tokens.\n>   - The transaction that spends the outputs r or s ends the issuance.\n> This transaction suspends the issuance even if a defined number of\n> tokens was defined in the token offering issuance transaction.\n>       * In case of an issuance suspeded, or ended, by a transaction\n> spending r or s, every transaction of the block containing the spending\n> transaction will be considered valid as a receiver of tokens.\n>       * Thus, sending bitcoins to the address of the outputs r or s will\n> be considered as part of the offering, only if it is included in a block\n> between the block of the transaction that has r or s as an output\n> (start), and the block of the transaction that spends the output r or s\n> (end), inclusive.\n> \n> A token offering issuance transaction of the first type permits to set a\n> rate, and to issue tokens every time bitcoins are received by an\n> address. The rate is defined by the number signaled by the output r. One\n> token will be issued for every r satoshis received.\n> \n> A token offering issuance transaction of the second type does not set a\n> predefined rate at the start. The rate will be defined by the\n> transaction that closes the issuance by spending the output s. The first\n> (smallest) output of the closing transaction, or the first output after\n> the cut (if a cut is present), will signal the rate. This type of token\n> offering issuance, having the price defined at the end, permits to issue\n> token based on parameters related to the issuance itself. This is the\n> case, for example, of Dutch Auctions.\n> \n> Note: A token offering issuance transaction can be seen as a transfer\n> transaction, that sends all the tokens that receives to the output c.\n> \n> Note: the type of token issued is defined by the token offering issuance\n> transaction, seen as an issuance transaction. Since a token offering\n> transaction is also the closure of some issuing chains, this means that\n> the same token offer will issue different type of tokens. In fact, a\n> different type of token will be issued for every issuance chain that\n> ends with the same token offering issuance transaction. Thus a token\n> type can be first issued in a controlled way (this is usually called\n> pre-ICO) and then the rate can be stated, and the same type of token can\n> be offered to the public (this is usually called the ICO). Since the\n> token offering issuance transaction closes the issuance forever, there\n> is the guarantee that no other tokens of the same type will ever be\n> issued after the offer is closed. In order to offer tokens at different\n> prices, multiple issuance transactions can be generated with POCs\n> originating from the same issuance chain.\n> \n> Atomic transactions between bitcoins and tokens\n> -----------------------------------------------\n> Using the cut signal and software that allows full \"coin selection\",\n> it's possible to make atomic exchange transactions. The outputs before\n> the cut will determine who will receive the tokens and the following\n> outputs will define the rest of the transaction. Both the changes (the\n> one of the token wallet and the one of the Bitcoin wallet), should be in\n> the second set (after the cut). Since the cut will receive the remaining\n> tokens, it is suggested that the cut is sent to the seller of tokens.\n> Using this method, the remaining tokens can be sent without involving a\n> calculation of the remaining tokens. The outputs of an atomic exchange\n> transaction will have the following format (seller is the token seller,\n> buyer is the token buyer).\n> \n>   - a1: tokens sent from the seller to the buyer\n>   - a2: tokens sent from the seller to the buyer\n>   - cut: part of the bitcoin payment sent from buyer to seller\n>   - b1: part of the bitcoin payment sent from buyer to seller (or change\n> sent from seller to buyer, if the price to be paid is less than the\n> value of the cut)\n>   - b2: Bitcoin change sent to the token wallet\n>   - b3: Bitcoin change sent to the bitcoin wallet\n> \n> It is impossible to make an atomic exchange transaction if the wallet in\n> use does not allow coin selection.\n> \n> Cross token atomic transactions\n> -------------------------------\n> Let's say that Alice wants to sell a number x of tokens of type Ta and\n> Bob wants to pay using y tokens of type Tb. Token of type Tb are of\n> lesser value than the tokens of type Ta, so Bob will pay more Tb tokens\n> and Alice will pay fewer Ta tokens (x < y). Let's say that the\n> transaction spends an output from Alice containing BTCa bitcoins and\n> *exactly* x tokens, while Bob sends to the same transaction BTCb\n> bitcoins and a number z of tokens of type Tb. Since z > y, Bob will\n> receive a change c in tokens of type Tb.\n> \n> Alice managed the previous transactions so that a fixed number x of\n> tokens can be sent as the input with a number BTCa of bitcoins. Bob is\n> not required do the same, because there is the cut that gives the\n> remaining tokens back to Bob. In order to simplify let's say that there\n> is another input giving the fee for the transaction and the Bitcoin\n> assigned to each output will be calculated accordingly.\n> \n> The atomic transaction can be made by signaling with the first output\n> the number y of tokens that Bob should pay to Alice. This output will go\n> to Alice. Since y is higher than x, all the x tokens of type Ta will go\n> to the change (directed to Bob), while the y tokens of type Tb will go\n> to the first output. A following cut can be used to send the change to\n> Bob. The addresses following the cut can be used as changes of bitcoins.\n> \n> The inputs of the transaction will have a content in Bitcoin and tokens\n> as follows:\n> \n>   - Alice will spend an output having BTCa bitcoins and containing\n> *exactly* x tokens of type Ta\n>   - Bob will spend an output having BTCb bitcoins and containing y + c\n> tokens of type Tb\n> \n> The outputs of the transaction will have the following form:\n> \n>   - Bitcoin sent: BTCa1; Signal sent: y; Directed to Alice (the output\n> gets y tokens of type Tb, but does not get any token of type Ta, because\n> x < y)\n>   - Bitcoin sent: BTCb1; Signal sent: cut; Directed to Bob (no token of\n> type Ta given, but receives c tokens of type Tb)\n>   - Bitcoin sent: BTCa - BTCa1; Signal sent: not important; Directed to\n> Alice (no token sent, but useful to send a change in Bitcoin to Alice,\n> if needed)\n>   - Bitcoin sent: BTCb - BTCb1; Signal sent: not important; Directed to\n> Bob (this output gets number x tokens of type Ta)\n> \n> Cross token atomic transactions in the case of the same number of tokens\n> to be exchanged\n> ---------------------------------------------------------------------------\n> ------------- The atomic transactions described above do not work if the\n> value of tokens of type Ta is equal to the value of tokens of type Tb. In\n> this case, there is no way of doing an atomic exchange.\n> \n> Let's say that we need to do a transaction between two tokens that have\n> the same value: TetherA and TetherB. Let's say that Alice and Bob want\n> to change 199 tokens. The atomic transaction cannot be made, but, with a\n> small risk, two transactions can be made. The first will be an atomic\n> transaction giving 100 tokens of type TetherA from Alice to Bob and\n> receiving 99 of type TetherB back, and the second will be 99 to 100.\n> \n> How to separate different types of token\n> ----------------------------------------\n> Let's say that an output contains two different types of tokens of\n> interest to the user. Is there a way to separate the tokens so that they\n> can be sent to different outputs? If the tokens are exactly the same\n> number, there is not. If the tokens are two different numbers: x tokens\n> of type A and y tokens of type B, then the separation can be done. Since\n> the \"remaining error\" of an output goes to the change, we can send the\n> higher value of the two and have the change receive the lower. We assume\n> that x < y.\n> \n> Let's call A1 the output that will receive A and B1 the output that will\n> receive the tokens of type B.\n> \n> The transaction will be similar to the cross token atomic transaction:\n> \n>   - Signal sent: x (the output gets x tokens of type B, but does not get\n> any token of type A, because x < y)\n>   - Signal sent: cut (no token of type A given, but receives a change in\n> token of type B if the previous signal was less than y)\n>   - Other outputs\n>   - Signal sent: not important (this output gets number x tokens of type A)\n> \n> Guidelines\n> ==========\n> There are some suggestions that, if followed by the user, permit\n> managing tokens in a simple manner, without technical knowledge of the\n> rest of the protocol, with plausible deniability. This can be done using\n> any existing wallet.\n> \n> The guidelines described here are based on a wallet that will be\n> \"consolidated\". This means that all the outputs of the wallet are linked\n> toghether. In some cases, this behavior diminish the level of privacy of\n> the user. Thus, it is advised to use a number of different wallets, in\n> order to reach the desired level of privacy.\n> \n> Plausible deniability: how to use a wallet to manage tokens\n> -----------------------------------------------------------\n> Some of the protocol's operations are designed to be managed using a\n> coin selection software, however, any wallet without coin selection can\n> be used to generate, send, or receive tokens. The option to use any\n> existing Bitcoin wallet is the base of the plausible deniability of the\n> protocol. The user can send, receive and generate tokens by using any\n> wallet in a way that seems a normal use of the Bitcoin protocol to\n> manage bitcoins.\n> \n> Thus, the guidelines in this section are based on a use of a wallet by a\n> user without involving any \"coin selection\".\n> \n> In order to send or generate tokens, the user needs to have, at any\n> time, only one output in the wallet. Let's call it a \"consolidated\"\n> wallet. In order to consolidate a wallet:\n> \n>   - Send all the bitcoins contained in the wallet to a new address of\n> the same wallet\n> \n> If the user departs from these guidelines by mistake, he can \"fix\" his\n> wallet and re-consolidate it without losing the tokens contained in the\n> wallet. If the wallet is consolidated, it remains consolidated while\n> tokens are generated or sent, and while bitcoins from the wallet are\n> spent. If bitcoins or tokens are received by any address of the wallet,\n> then the wallet needs to be consolidated again.\n> \n> Issuance of tokens\n> ------------------\n> In order to generate tokens:\n> \n>   - Consolidate the wallet if it is not already consolidated.\n>   - Send a minority of the bitcoins contained in the wallet to a new\n> address (outside of the wallet). The last five digits of the satoshis\n> sent are the number of tokens generated.\n>   - From the same wallet, other tokens can be generated by sending again\n> a number of satoshis, having the last five digits that are the number of\n> tokens to issue to the new address.\n>   - The value of bitcoins sent should always be less than the bitcoin\n> that remains in the wallet\n>   - If during the process of generating tokens the wallet receives\n> bitcoins, it should be consolidated again before continuing to generate\n> tokens.\n>   - The type (or name) of tokens will be the txid of the transaction. If\n> the transaction sends bitcoin to a new, never used, address, the address\n> can be used as the name of the tokens, as well.\n> \n> In order to give the power to generate new tokens to another person:\n> \n>   - Send all the Bitcoin content of the wallet to the other person, with\n> a single transaction\n> \n> In order to close an issuance:\n> \n>   - To close the issuance and guarantee that no other tokens of this\n> type will ever be generated again, send to another address of the same\n> wallet a number of bitcoins with the last five digits of the satoshis\n> that is zero. Be aware that this shouldn't be all the content of the\n> wallet. If all the content of the wallet is sent to some address, the\n> issuance will not be closed. Instead, this gives to the receiver the\n> power to generate new tokens.\n> \n> Spending bitcoins and not tokens\n> --------------------------------\n> In order to spend bitcoins from the wallet without sending any tokens,\n> the user should spend less than half of the bitcoin value contained in\n> the wallet, and:\n> \n>   - Spend a number of satoshis where the last five digits are all zeros,\n>   or\n>   - Spend a number of satoshis where the last five digits are a number\n> greater than the tokens that are in the wallet,\n> \n> Transfer of tokens\n> ------------------\n> In order to send tokens to another person:\n> \n>   - Consolidate the wallet if it is not already consolidated.\n>   - Send a value less than half of the content of the wallet and having\n> the number of satoshis where the last five digits are the number of\n> tokens that need to be transferred,\n>   or\n>   - Send all the bitcoins of the wallet (even if the wallet is not\n> consolidated).\n> \n> If the user sends all the content of the wallet to a single address (no\n> change), then he's emptying the token content from the wallet, as well.\n> All the tokens will go to the address and nothing will remain to the user.\n> \n> In order to receive tokens from other users:\n> \n>   - Give to the other person a Bitcoin address of the wallet and ask to\n> send tokens as explained above.\n>   - If the wallet was empty before of receiving tokens, then it is\n> already consolidated. Instead, if the wallet already had some bitcoins,\n> then the wallet needs to be consolidated before sending or generating\n> tokens.\n> \n> Effects of the use of these guidelines\n> --------------------------------------\n> When using the guidelines, the number of tokens sent to the recipient is\n> always stated in the last five digits of the satoshis sent. There are\n> three exceptions:\n> \n>   - In a single output transaction, all the tokens of the wallet will be\n> sent to the recipient.\n>   - In a transaction where the amount of satoshis sent ends with five\n> zeros, no tokens are sent.\n>   - In a transaction sending more tokens than the number of tokens of\n> that type held in the wallet, no tokens are sent.\n> \n> Technical notes\n> ---------------\n>   - Sending a number of bitcoins that is greater than half of the\n> bitcoins contained in the wallet brings to unpredicted results.\n>   - Thus, if there are not enough bitcoins to continue to operate, the\n> wallet needs to be \"re-charged\" by sending some bitcoins to it. By doing\n> so, there will be more than one UTXO in the wallet. This departs from\n> \"consolidated mode\" and the wallet needs to be consolidated again.\n>   - A consolidated wallet contains only one UTXO.\n>   - Every transaction made from a consolidated wallet contains only two\n> outputs: one is the address outside of the wallet, and the other is the\n> change.\n>   - Every transaction spends all the content of the wallet.\n> \n> Reference Implementation\n> ========================\n> A reference implementation will be included when the protocol will be\n> reviewed and accepted by the community.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Luca Venturini",
                "date": "2017-09-06T19:25:16",
                "message_text_only": "Hi Luke,\n\nthanks for your feedback.\n\nI can try to coordinate with the OpenAssets group, but the base \nrequirements are completely different. For example, they are very far \nfrom any form of plausible deniability.\n\nPlease tell me which problems are not solved technically, so that I can \ntry to fix the differences between the claims and the technical part, if \nany.\n\nLuca\n\nOn 09/06/2017 08:58 PM, Luke Dashjr wrote:\n> I think you could check out and coordinate with the OpenAssets proposal.\n>\n> Your current draft also claims to solve a lot of problems that it doesn't\n> actually solve technically...\n>\n> Luke\n>\n>\n> On Wednesday 06 September 2017 11:44:47 Luca Venturini via bitcoin-dev wrote:\n>> Hi everyone,\n>>\n>> I would like to propose a standard protocol to manage tokens on top of\n>> the Bitcoin blockchain.\n>>\n>> The full text is enclosed and can be found here:\n>>\n>> https://github.com/token21/token-protocol-specification\n>>\n>> Any feedback will be appreciated.\n>>\n>> Luca Venturini\n>>\n>> ---\n>>\n>> Abstract\n>> ========\n>> This document describes a protocol to manage digital assets (tokens) on\n>> top of the bitcoin blockchain. The protocol enables a semantic layer\n>> that permits reading the bitcoin transactions as operations related to\n>> tokens.\n>>\n>> The protocol allows a new level of plausible deniability, while\n>> permitting statefull public auditability on each issued token. It allows\n>> both the user and the issuer to deny that an existing bitcoin\n>> transaction between the two is actually a token transaction, or a new\n>> token issuance. While both the token sender and the token issuer cannot\n>> deny to have sent bitcoins, nobody can prove the transaction was related\n>> to a digital asset. On top of that, to guarantee plausible deniability,\n>> tokens can be issued, sent, and received using any existing bitcoin\n>> client software.\n>>\n>> There is no need to have a wallet exclusively dedicated to manage the\n>> tokens. With a few simple precautions by the user, tokens can be managed\n>> using any existing Bitcoin wallet, while it is used for normal bitcoin\n>> transactions as well.\n>>\n>> Since it is possible to infinitely split a token in parts, there is no\n>> definition of the number of decimals of token generated and transferred.\n>> The number of tokens is always an integer.\n>>\n>> Every operation of the protocol is performed with Bitcoin transactions,\n>> without the use of OP_RETURN and without any form of pollution of the\n>> blockchain, or of the UTXO set.\n>>\n>> The protocol permits atomic buy and sell transactions between tokens and\n>> Bitcoin, and between different types of tokens. The only operations that\n>> require a coin selection enabled wallet are the split and join special\n>> operations and the token offering issuance operations. Those are used to\n>> modify the token unit of measure and to receive bitcoins from third\n>> parties during a token offering issuance.\n>>\n>> Copyright\n>> =========\n>> This document is licensed under the 2-clause BSD license.\n>>\n>> Motivation\n>> ==========\n>> The current protocols that permit to issue tokens based on the bitcoin\n>> blockchain (i.e. Counterparty, Omni, Colored Coins, Coinprism, Colu) are\n>> flawed.\n>>\n>> The existing solutions usually need dedicated wallets and/or\n>> verification nodes. Usually, a \"pivot\" currency is involved and atomic\n>> transactions are not permitted unless they use the pivot currency. Those\n>> protocols pollute the blockchain (30% or more) and in some cases they do\n>> not accept P2SH scripts. Since the use of a dedicated wallet is\n>> required, the users cannot plausibly deny they have got tokens.\n>> Plausible deniability on the issuer side is not available either. None\n>> of these protocols permits infinite division of the tokens, so usually\n>> the number of decimals has to be specified at issuance time. The\n>> automatic token offering issuance is not enabled as well.\n>>\n>> Rationale\n>> =========\n>> Let's take an example from the real world, a yacht. We write on the\n>> yacht's license that the owner is any person that can show a one dollar\n>> bill having the serial number F82119977F. Thus the one dollar bill can\n>> be exchanged between owners with extreme simplicity and full plausible\n>> deniability. The US government will guarantee that there is no other\n>> person having the same dollar bill.\n>>\n>> The protocol permits managing a token in the same way. The underlying\n>> Bitcoin protocol will guarantee against double spending.\n>>\n>> Features:\n>>\n>>   - Easy of use. Tokens can be managed using any wallet. Even if the\n>> wallet has no coin selection feature.\n>>   - Plausible Deniability by the issuer. The issuer can generate a new\n>> type of token and nobody analyzing the blockchain will understand that\n>> the transaction is issuing a token. Even if a token is known, the issuer\n>> can issue other tokens. Since a single output contains a large number of\n>> different token types, the issuer is actually generating different types\n>> of tokens every time she sends a new Bitcoin transaction to the network.\n>>   - Plausible Deniability by the user (no use of tokens at all, or use\n>> of a different token type). A transaction that sends tokens from Alice\n>> to Bob is a normal transaction. Nobody can understand that this\n>> transaction is moving tokens unless they explicitly know which\n>> transaction is the token issuance. In fact a single address contains a\n>> large number of token types, and the use of tokens itself can be denied.\n>>   - Accountability. Everybody can see the state of the distribution of a\n>> type of token.\n>>   - Tunnel mode (confidentiality by issuer and user versus a third\n>> party). Alice can send tokens to Bob and ask him to give the tokens to\n>> Charlie, without telling to Bob what is the type of the token given.\n>> Alice can disclose this information in the future, if she wants.\n>>   - It is possible to perform open or closed issuances. While an open\n>> issuance permits to continue the issuance of tokens in the future,\n>> closed issuance guarantees that no other token of the same type will\n>> ever be issued.\n>>   - The power to continue the issuance of an open token can be sent to\n>> another address, using a transaction. Once the power to continue the\n>> issuance is sent to someone, the former issuer cannot issue any more\n>> tokens. - The power to continue the issuance has the same features of\n>> plausible deniability of the possess of a token.\n>>   - Since a token type is uniquely identified by a transaction hash, or,\n>> in some cases, by a Bitcoin address, a user can prove to be the issuer\n>> by signing a message using the Bitcoin protocol.\n>>   - Future proof. Tokens can move following P2PKH, P2SH, P2SH-P2WPKH\n>> outputs or any other type of script\n>>   - Blockchain pollution of the protocol transactions is almost zero.\n>> There is no OP_RETURN involved, nor any other type of \"fake\" addresses\n>> that pollute the UTXO database.\n>>   - The protocol is based on the Bitcoin blockchain, but, with small\n>> changes, can be considered blockchain agnostic.\n>>   - Atomic transactions between tokens and Bitcoin are possible.\n>>   - Atomic transactions between different types of tokens are possible.\n>>   - Tokens of different types can be held by the same address and by the\n>> same output.\n>>   - Tokens can be divided indefintely, thus having any number of decimals.\n>>   - Tokens can be issued automatically on the receiving of bitcoins.\n>> This operation performs a token offering issuance (also known as Initial\n>> Coin Offering).\n>>\n>> Introduction\n>> ============\n>>\n>> Where are the tokens?\n>> ---------------------\n>> As with bitcoins, tokens are contained in unspent Bitcoin outputs. In\n>> some cases, defined below, the last five digits of the satoshi value\n>> sent to the output represent the number of tokens contained in the output.\n>>\n>> When an output is spent, the tokens contained in the output are fully\n>> spent in the same transaction. There are no tokens outside of the tokens\n>> contained in the UTXO database.\n>>\n>> Token issuance\n>> --------------\n>> The large majority of bitcoin transactions can be semantically seen as\n>> token issuances. There are two types of token issuances: closed and\n>> opened. A closed token issuance guarantees that no other token of the\n>> same type will ever be issued.\n>>\n>> Issuance chains\n>> ---------------\n>> An open issuance gives to one, or more, of its output the power to\n>> continue the issuance of tokens of the same type. We define such a power\n>> as Power of Continuation (POC). The transaction that will spend the\n>> output appointed with the POC will be a continuation of the same\n>> issuance chain.\n>>\n>> Every transaction of the chain will issue the same type of token. On top\n>> of that, every transaction that is part of the chain, can also be seen\n>> as as issuance of tokens of its, new, type. A chain will be closed by a\n>> transaction having more than one output and the first output with five\n>> zeros as the last five digits of the satoshis value. No other\n>> transactions can send tokens of the same type after the close of the\n>> issuance.\n>>\n>> Token names\n>> -----------\n>> A token type can have multiple names. The default name is the hash of\n>> the first transaction that issued the token.\n>>\n>> i.e: 68330b6ab26e44f9c3e515f04d15ffe6547f29e60b809a47e50d9abf59045c1e\n>>\n>> As alternative names, a token type can be named after the bitcoin\n>> address of one of the outputs of the transaction that first issued the\n>> token, provided the fact that the address has never been used before in\n>> the blockchain.\n>>\n>> Note: it is better to use one of the alternate names in cases when\n>> transaction malleability is a concern.\n>>\n>> Vanity token names\n>> ------------------\n>> A token can be identified using only the first characters of the Bitcoin\n>> address, as alternate name defined above, if the characters are\n>> different from every previous Bitcoin address seen in the blockchain. An\n>> example is provided below.\n>>\n>> Tokens can coexist\n>> -------------------\n>> Token of different types can coexist in a single output while remaining\n>> of different types. Thus a bitcoin address (actually an output of the\n>> UTXO database) can hold tokens of different types. Every Bitcoin address\n>> contains a lot of types of tokens, so that a user usually does not know\n>> all the type of tokens contained in an address.\n>>\n>> A single transaction can send a type of token to some of the outputs\n>> while sending another type of token to a different set of its outputs.\n>> Tokens are never burned or deleted.\n>>\n>> Use the protocol\n>> ================\n>> This section explains a basic use case. In all the examples provided, we\n>> do not consider the fee. We assume that there is another input, not\n>> listed, that pays the transaction fee.\n>>\n>> Alice, Bob, Charlie, and Daniel decides that they want to start a new\n>> company. Each of them will give to the new company some time, money,\n>> furniture, knowledge. They decide everyone contributed to the company\n>> with a percentage of value as follows: Alice - 40%, Bob - 12%, Charlie -\n>> 34% and Daniel - 14%. They decide that the shares of the new company can\n>> be freely resold to others and that they will accept that the annual\n>> meeting will consent vote through messages signed using the Bitcoin\n>> protocol by the owners of the shares.\n>>\n>> Issue tokens\n>> ------------\n>> Alice asks Bob, Charlie, and Daniel to send her 1 Bitcoin each. She asks\n>> each of them to give her a bitcoin address where they want to receive\n>> back the bitcoins along with the tokens.\n>>\n>> She asks Charlie to generate a vanity address that has never been used\n>> before of type 1CompanyXWXjLgud9jxwxm34u.... Since there has been a\n>> previous address in the blockchain having 1Companx as the first\n>> characters, but this is the first address seen in the blockchain that\n>> has 1Company as the first characters, they will call the token with the\n>> name 1Company. This step is optional.\n>>\n>> Then she sends, from her wallet, a transaction having the following\n>> outputs:\n>>\n>>   - 1.00000040 to an address controlled by Alice\n>>   - 1.00000012 to an address controlled by Bob\n>>   - 1.00000034 to the vanity address 1CompanyXWXjLgud9jxwxm34u...\n>> controlled by Charlie\n>>   - 1.00000014 to an address controlled by Daniel\n>>   - 3.45322112 is the change generated by Alice's wallet\n>>\n>> This transaction gives 40, 12, 34, 14 tokens to each one. The newly\n>> generated token type can be named after the transaction hash, or after\n>> the vanity address (optional), or after one of the addresses of the\n>> persons involved, provided that the address has never been used before.\n>>\n>> The issuance is still open. Since they do not want to issue more shares,\n>> they decide to close the issuance (on the other side, they could decide\n>> to leave the issuance open and to hold the issuing key somewhere, or to\n>> have a multisignature address and to give the keys to the directors of\n>> the company). In order to close the issuance, Alice generates the\n>> following transaction that sends bitcoins from her wallet to addresses\n>> of her same wallet, using the change output of the previous transaction\n>> as an input:\n>>\n>>   - 0.45000000 to an address of her wallet\n>>   - 3.00322112 change generated by the wallet\n>>\n>> This closes the issuance.\n>>\n>> Send tokens\n>> --------------\n>> After some while, Bob decides to give some shares of the company to his\n>> husband Giacomo. He generates a new transaction spending the output of\n>> the issuance transaction:\n>>\n>>   - 0.03400008 to Giacomo\n>>   - 0.96600004 change generated by Bob's wallet\n>>\n>> This transaction gives to Giacomo 8 shares of the company.\n>>\n>> Atomic transactions\n>> -------------------\n>> Daniel wants to sell 3 of his 14 shares to Frank. They negotiate a price\n>> of 0.00323200 bitcoin per share. This is a total of 0.00969600 bitcoin\n>> to buy the three shares. They do not know each other very well, so they\n>> decide to make an atomic transaction that will give 0.00969600 bitcoins\n>> to Daniel and 3 shares to Frank. Daniel set an input of the new\n>> transaction with his issuance transaction output. Frank put in another\n>> input of 1.23242454 bitcoins from his wallet. The outputs of the\n>> transaction are as follows:\n>>\n>>   - 0.22400003 to an address controlled by Frank (this gives the 3\n>> shares to Frank)\n>>   - 0.23200000 to an address controlled by Daniel (this is part of the\n>> payment to Daniel)\n>>   - 0.77769614 to an address controlled by Daniel (this can be\n>> considered the change of the original issuance output of 1.00000014)\n>>   - 0.99872851 to an address controlled by Frank (change to Frank)\n>>\n>> Daniel sent to the inputs of the transaction 1.00000014 bitcoins and\n>> receives back 1.00969614. This gives to Daniel the 0.00969600 paid by\n>> Frank. On the other side, Frank sends 1.23242454 as an input of the\n>> transaction and receives back 1.22272854 bitcoins, thus paying exactly\n>> the 0.00969600 that needs to be paid to Daniel. This transaction sends 3\n>> tokens from Daniel to Frank. Another 11 tokens are the tokens that are\n>> given as a change to Daniel, along with 0.23200000 bitcoins.\n>>\n>> Specification\n>> =============\n>>\n>> Definitions\n>> -----------\n>> In order to evaluate a transaction, the outputs are sorted by the\n>> satoshis value. Once sorted, we define a \"cut\" output the first output\n>> having five zeros as the last five digits of the satoshi value (satoshis\n>> modulo 10^5 == 0). In the following, \"first\", \"second\", \"last\" are all\n>> referred to the sorted outputs.\n>>\n>> We define as \"signal\" of an output the value of satoshis of the output\n>> modulo 10^5. This is the last five digits of the value, as expressed in\n>> satoshis.\n>>\n>> Despite not mandatory, we sometimes call \"c\", or \"change\", the output\n>> having the biggest value in Satoshi. This is the last output, as sorted\n>> above. Such behavior follows the \"Guidelines\" section, explained below.\n>>\n>> We use n=0 related to a sequence a1, ..., an, to indicate that there are\n>> no elements in the sequence.\n>>\n>> Issuance of a token\n>> -------------------\n>> A transaction that has only one output, or has the first output that is\n>> a cut, issues no token. Every other Bitcoin transaction is an issuance\n>> of tokens of the type of the transaction.\n>>\n>> When a issuance is open, Power of Continuation (POC), will be given to\n>> an output that will be spent in a transaction that continues the\n>> issuance of the same type of tokens.\n>>\n>> As for the protocol behavior, we divide the structure of the sorted\n>> outputs of a bitcoin transaction in the following groups. For each\n>> group, a description of the behavior of the protocol is provided.\n>>\n>>   - a1, ..., an, cut(POC), z1(POC), ... zm(POC), b1, ..., bl, with n>0,\n>> m>=0, m+l>0\n>>       * zi are outputs signaling zero. They are optional.\n>>       * This is an open issuance. It generates the number of tokens\n>> signaled by the outputs before the cut: a1, ..., an. Every output of\n>> that set receives a number of tokens as signaled by the output satoshis'\n>> value.\n>>       * The cut output, and every other output zi, signaling zero, that\n>> is directly after the cut, receive the POC. This means that the\n>> transactions that will spend the POC will be a continuation of this\n>> issuance and a continuation of every issuance that gave the POC to the\n>> this transaction.\n>>   - cut, b1, ..., bm with m>0 (a cut alone is a case of the fourth type)\n>>       * This is a particular case of the first group, having n=0 and\n>> m=0. This transaction *closes the issuance forever*. Every token's chain\n>> that ends into this transaction is closed as well.\n>>       * It generates no tokens and there are no other outputs that can\n>> continue the issuance in the future.\n>>       * If b1 or b2 have a signal of zero and m>2, this is a token\n>> offering issuance transaction. It will be described in a following section.\n>>   - a1, ..., an, c(POC) with n>0\n>>       * This is an open issuance. It generates the number of tokens that\n>> are signaled in a1, ..., an. The last output c will not receive tokens.\n>>       * The last output c will receive the POC. A following transaction\n>> that spends the output c is an issuance transaction of the same type of\n>> token.\n>>       * The fact that c is a cut (or not) does not modify the behavior\n>> of the transactions of this group\n>>   - c(POC) (single output, also seen as the previous one, with n=0)\n>>       * This transaction generates no tokens at all.\n>>       * The output c receives the POC. Thus a following transaction that\n>> spends the output c is an issuance transaction of the same type of token.\n>>\n>> Notes on token issuances\n>> ------------------------\n>> The number of tokens generated by an issuance transaction is always the\n>> sum of the signals of all the outputs, excluding the last one and the\n>> outputs that are listed after a cut. Thus the number of tokens sent to\n>> each output, that receives tokens, is always the number signaled by the\n>> output.\n>>\n>> Who has the power to generate other tokens of the same issuance (POC):\n>>\n>>   - If there is no cut, the issuance is open and the transaction that\n>> will spend the last (biggest) output can continue to generate token of\n>> the same type.\n>>   - If there is a cut, in a position different than the first, the\n>> issuance is open. The cut output will be the input of a following\n>> transaction that issues more tokens of the same issuance chain. The\n>> following transaction can close tha chain, or can be an open issuance,\n>> thus having another output that will continue the generation chain.\n>>\n>> In order to close forever the issuance of tokens, the transaction should\n>> have a cut as the first output and have more than one output.\n>>\n>> Transfer of tokens\n>> ------------------\n>> Every bitcoin transaction spends all the tokens' content of the inputs\n>> and sends them to the outputs. Some of the outputs receive the number of\n>> tokens exactly stated in the last five digits of the satoshis sent (the\n>> signal), in a way similar to an issuance transaction.\n>>\n>> A transaction can be seen as having one of the three following shapes\n>> (ai means an output that is not a cut, bi and c are outputs that can be\n>> cut):\n>>\n>>   - a1, ..., an, cut, b1, ..., bm, c (transactions with a cut) (n=0 is\n>> described here)\n>>       * No output (bi) after a cut receives tokens.\n>>       * Tokens will be assigned to outputs a1, ..., an trying to follow\n>> the signal as follows:\n>>           - If there are enough tokens, the tokens signaled by the first\n>> output are assigned to that output.\n>>           - If there are still remaining tokens, the tokens are sent to\n>> the following output based on the signal.\n>>           - This continues until there is a cut or the tokens signaled\n>> by an output are more than the remaining tokens. In these cases:\n>>               * If there is a cut, it receives all the remaining tokens.\n>>               * If there is an output receiving more tokens than the\n>> remaining tokens (we define it a \"remaining error\"), the output receives\n>> no token at all. No other output will receive tokens after this and all\n>> the remaining tokens will be sent to the last output c (thus, if there\n>> is a cut in the transaction, the algorithm \"jumps\" the cut).\n>>               * If there is a \"remaining error\" and the transaction is a\n>> special transaction as defined in the next section, and the number of\n>> tokens in input is exactly the same of the two types (big and small)\n>> that are the result of a previous split or join special transaction, the\n>> \"remaining error\" output gets one of the smallest tokens involved. This\n>> will be better explained in the following section about \"special\n>> transactions\".\n>>       * If the first output is a cut, and the transaction is not a\n>> special one as defined below in the document, the last output (c)\n>> receives all the tokens\n>>   - a1, ..., an, c (ai is not a cut, for every i; c can be a cut)\n>>       * The tokens are assigned to a1, ..., an as described in the\n>> previous group.\n>>       * The last output c receives all the remaining tokens. This\n>> behavior is not modified by the fact that the last output is a cut.\n>>   - c (single output transaction, also seen as the previous one, with n=0)\n>>       * The output receives all the tokens received from the inputs\n>>\n>> Transactions receiving both the POC of an issuance and some tokens of\n>> the same issuance\n>> ---------------------------------------------------------------------------\n>> ------------ The protocol is designed such that a transaction of an\n>> issuance chain never issue new tokens to an output, that receives the POC\n>> of the same type of token. But two different inputs can give to a\n>> transaction both some tokens and the POC of the same type of token. In\n>> this case, there is a double role for the transaction that is both a\n>> continuation of the issuance and a transfer transaction sending tokens of\n>> the same type.\n>>\n>> In this case, the tokens will be allocated as defined in the following\n>> four different shapes of transaction:\n>>\n>>   - a1, ..., an, cut, b1, ..., bm, c (transaction with a cut)\n>>       * The generated tokens are sent to the outputs a1, ..., an as\n>> described in the definition of an issuance of tokens\n>>       * All the tokens received in input of the same type of the\n>> issuance we are continuing will be sent to the cut output\n>>   - a1, ..., an, c (transaction without a cut, or with c that is a cut:\n>> ai is not a cut, for every i)\n>>       * The generated tokens are sent to the outputs a1, ..., an as\n>> described in the definition of an issuance of tokens transaction\n>>       * All the tokens received in input, of the same type of the\n>> issuance we are continuing, will be sent to the last output c\n>>   - cut, b1, ..., bm\n>>       * The issuance will be closed and all the tokens will be given to\n>> the last output bm. The behavior described in the issuance transaction\n>> and in the transaction sending tokens do not influence each other, in\n>> this case.\n>>       * If it is a special transaction, as defined below, there is no\n>> overlap between the definitions. The issuance chain is closed and the\n>> received tokens will be given as defined.\n>>   - c only\n>>       * The definitions of issuance transaction and transfer transaction\n>> can be used. The issuance will remain open and the address will receive\n>> all the tokens received from the inputs\n>>\n>> Since both the first and the second group of transactions are giving the\n>> POC to the same output that receives the tokens, the output will\n>> continue to carry both the tokens received and the POC. This delegates\n>> someone to issue new tokens and allocates some tokens from a previous\n>> issuance that are still not assigned.\n>>\n>> Split and join transactions\n>> ---------------------------\n>> A split or join transaction is one that has one of the following formats\n>> of outputs:\n>>\n>>   - cut, a1, ..., an, z, b1, ..., bm (z is an output signaling zero,\n>> like a cut)\n>>   - cut, a1, ..., an, c\n>>\n>> having the added condition that the sum of the signals of the outputs\n>> a1, ..., an is:\n>>\n>>   - equal to the number of tokens received in input divided by 1000 (we\n>> call it a join transaction), or\n>>   - equal to the number of tokens received in input multiplied by 1000\n>> (we call it a split transaction)\n>>\n>> Since the presence of these two extra conditions, the fact that a\n>> transaction is a join or split transaction, or it is not (hence it is a\n>> simple transfer transaction), depends on the number of tokens received\n>> in the input. A given transaction can be both split or join for some\n>> type of tokens, and normal for other types of tokens.\n>>\n>> Note: this is the same format that closes an issuance chain. If the\n>> transaction receives both POC and tokens of the same type, the\n>> transaction chain will be closed and the received tokens will be sent as\n>> described here.\n>>\n>> Note: this is also the format of a transfer transaction that assigns to\n>> the change c or bm, the token received in the input. But, if a\n>> transaction is a special one of the first two types, that behavior\n>> should not be considered and no tokens will be transferred to the change.\n>>\n>> The split transaction generates a new type of tokens with a value that\n>> is one thousandth of the value of the type of tokens received in the\n>> input. This new type can be mixed with tokens generated by other similar\n>> split transactions, based on the same original token. Split tokens have\n>> the same value and can be joined in the future with join transactions.\n>>\n>> The join transaction generates a new type of tokens with one thousand\n>> times the value of the type of tokens received in the input. This new\n>> type of token can coexist with tokens generated by other similar join\n>> transactions, based on the same original token. Joined tokens from the\n>> same original token, have the same value and can be split in the future\n>> with split transactions. Thus becoming again original tokens.\n>>\n>> In a special transaction of the second group, without \"the second cut\"\n>> z, the change is mandatory and does not receive tokens. This means that\n>> the number of tokens sent is summed up without the last output. If the\n>> number is not correct, then it is not a split or join transaction.\n>>\n>> Tokens split or joined are of a different type than their original\n>> source. This means that they can coexist in the same output and will\n>> never mix together. Thus a output having 3 big tokens and 456 tokens\n>> obtained by a split transaction, seems to have 3.456 tokens, but, in\n>> fact, has 3 tokens of a type and 456 tokens of another type (the second\n>> type is referred as the original type with a 0.001 unit of measure).\n>>\n>> Note: as described below, there is a procedure of separating tokens of\n>> different types contained in the same output. This procedure will not\n>> work if the two type of tokens are present in the same output in the\n>> same number. Thus if an output contains exactly 3.003 tokens (3 big and\n>> 3 small), the tokens cannot be separated anymore. This is why we\n>> introduced, in the transfer transaction definition, the rule that\n>> assigns in this case one single token of the smallest type to the\n>> \"remaining error\" output.\n>>\n>> Token offering issuance transactions\n>> ------------------------------------\n>> A token offering issuance transaction is a transaction having one of the\n>> following formats (z is an output signaling zero, like a cut; r and s\n>> are outputs that signal a value greater than zero; the group of outputs\n>> (t1, t2, z) is optional; t1 or t2 can signal zero, but not both):\n>>\n>>   - cut, z, r, (t1, t2, z,) a1, ..., an, c\n>>       * price of tokens are predefined\n>>   - cut, s, z, (t1, t2, z,) a1, ..., an, c\n>>       * price of tokens are not predefined\n>>\n>> The tokens will be assigned to one of the outputs of every transaction\n>> that sends bitcoin to the address of the outputs r or s, as follows:\n>>   - if the sending transaction has only two outputs (r, c), (c, r), (s,\n>> c) or (c, s), the \"other\" output c receives the tokens.\n>>   - if the sending transaction has more than two outputs, the last\n>> (biggest) output that is not the one sending bitcoins to r or s, will\n>> receive the tokens.\n>>   - if the sending transaction has only one output, the generated tokens\n>> will be assigned to the output r or s itself. This can be considered as\n>> a donation: it generates tokens, but the tokens remain in the\n>> availability of the issuer.\n>>   - since the number of token emitted is always an integer, the\n>> remaining satoshis are not considered in the number of tokens issued and\n>> are sent to the issuer without any token generation.\n>>\n>> Note: this is the second place, in this document, where the bitcoin\n>> address of an output is used. The other place regards the alternate\n>> names of an issuance. Everything else in the protocol is based on\n>> outputs, not addresses.\n>>\n>> If the group (t1, t2, z) is present, it signals how many token will be\n>> issued. The total number of tokens that will be issued is the number\n>> signaled by t1 * 10^6 + the number signaled by t2. In any block, the\n>> issuance can be closed by the transaction that spends the outputs r or s.\n>>\n>> Timeline:\n>>   - The offer starts in the block that contains the token offering\n>> issuance transaction. Every transaction of the starting block receives\n>> tokens, without order.\n>>   - If there is a defined total number of tokens, the issuance will end\n>> when the total number of tokens has been reached.\n>>       * Inside the last block, the transactions are considered in the\n>> order they are listed. So if a transaction takes the last tokens, every\n>> other transaction sending bitcoins to r or s, do not receive tokens.\n>>   - The transaction that spends the outputs r or s ends the issuance.\n>> This transaction suspends the issuance even if a defined number of\n>> tokens was defined in the token offering issuance transaction.\n>>       * In case of an issuance suspeded, or ended, by a transaction\n>> spending r or s, every transaction of the block containing the spending\n>> transaction will be considered valid as a receiver of tokens.\n>>       * Thus, sending bitcoins to the address of the outputs r or s will\n>> be considered as part of the offering, only if it is included in a block\n>> between the block of the transaction that has r or s as an output\n>> (start), and the block of the transaction that spends the output r or s\n>> (end), inclusive.\n>>\n>> A token offering issuance transaction of the first type permits to set a\n>> rate, and to issue tokens every time bitcoins are received by an\n>> address. The rate is defined by the number signaled by the output r. One\n>> token will be issued for every r satoshis received.\n>>\n>> A token offering issuance transaction of the second type does not set a\n>> predefined rate at the start. The rate will be defined by the\n>> transaction that closes the issuance by spending the output s. The first\n>> (smallest) output of the closing transaction, or the first output after\n>> the cut (if a cut is present), will signal the rate. This type of token\n>> offering issuance, having the price defined at the end, permits to issue\n>> token based on parameters related to the issuance itself. This is the\n>> case, for example, of Dutch Auctions.\n>>\n>> Note: A token offering issuance transaction can be seen as a transfer\n>> transaction, that sends all the tokens that receives to the output c.\n>>\n>> Note: the type of token issued is defined by the token offering issuance\n>> transaction, seen as an issuance transaction. Since a token offering\n>> transaction is also the closure of some issuing chains, this means that\n>> the same token offer will issue different type of tokens. In fact, a\n>> different type of token will be issued for every issuance chain that\n>> ends with the same token offering issuance transaction. Thus a token\n>> type can be first issued in a controlled way (this is usually called\n>> pre-ICO) and then the rate can be stated, and the same type of token can\n>> be offered to the public (this is usually called the ICO). Since the\n>> token offering issuance transaction closes the issuance forever, there\n>> is the guarantee that no other tokens of the same type will ever be\n>> issued after the offer is closed. In order to offer tokens at different\n>> prices, multiple issuance transactions can be generated with POCs\n>> originating from the same issuance chain.\n>>\n>> Atomic transactions between bitcoins and tokens\n>> -----------------------------------------------\n>> Using the cut signal and software that allows full \"coin selection\",\n>> it's possible to make atomic exchange transactions. The outputs before\n>> the cut will determine who will receive the tokens and the following\n>> outputs will define the rest of the transaction. Both the changes (the\n>> one of the token wallet and the one of the Bitcoin wallet), should be in\n>> the second set (after the cut). Since the cut will receive the remaining\n>> tokens, it is suggested that the cut is sent to the seller of tokens.\n>> Using this method, the remaining tokens can be sent without involving a\n>> calculation of the remaining tokens. The outputs of an atomic exchange\n>> transaction will have the following format (seller is the token seller,\n>> buyer is the token buyer).\n>>\n>>   - a1: tokens sent from the seller to the buyer\n>>   - a2: tokens sent from the seller to the buyer\n>>   - cut: part of the bitcoin payment sent from buyer to seller\n>>   - b1: part of the bitcoin payment sent from buyer to seller (or change\n>> sent from seller to buyer, if the price to be paid is less than the\n>> value of the cut)\n>>   - b2: Bitcoin change sent to the token wallet\n>>   - b3: Bitcoin change sent to the bitcoin wallet\n>>\n>> It is impossible to make an atomic exchange transaction if the wallet in\n>> use does not allow coin selection.\n>>\n>> Cross token atomic transactions\n>> -------------------------------\n>> Let's say that Alice wants to sell a number x of tokens of type Ta and\n>> Bob wants to pay using y tokens of type Tb. Token of type Tb are of\n>> lesser value than the tokens of type Ta, so Bob will pay more Tb tokens\n>> and Alice will pay fewer Ta tokens (x < y). Let's say that the\n>> transaction spends an output from Alice containing BTCa bitcoins and\n>> *exactly* x tokens, while Bob sends to the same transaction BTCb\n>> bitcoins and a number z of tokens of type Tb. Since z > y, Bob will\n>> receive a change c in tokens of type Tb.\n>>\n>> Alice managed the previous transactions so that a fixed number x of\n>> tokens can be sent as the input with a number BTCa of bitcoins. Bob is\n>> not required do the same, because there is the cut that gives the\n>> remaining tokens back to Bob. In order to simplify let's say that there\n>> is another input giving the fee for the transaction and the Bitcoin\n>> assigned to each output will be calculated accordingly.\n>>\n>> The atomic transaction can be made by signaling with the first output\n>> the number y of tokens that Bob should pay to Alice. This output will go\n>> to Alice. Since y is higher than x, all the x tokens of type Ta will go\n>> to the change (directed to Bob), while the y tokens of type Tb will go\n>> to the first output. A following cut can be used to send the change to\n>> Bob. The addresses following the cut can be used as changes of bitcoins.\n>>\n>> The inputs of the transaction will have a content in Bitcoin and tokens\n>> as follows:\n>>\n>>   - Alice will spend an output having BTCa bitcoins and containing\n>> *exactly* x tokens of type Ta\n>>   - Bob will spend an output having BTCb bitcoins and containing y + c\n>> tokens of type Tb\n>>\n>> The outputs of the transaction will have the following form:\n>>\n>>   - Bitcoin sent: BTCa1; Signal sent: y; Directed to Alice (the output\n>> gets y tokens of type Tb, but does not get any token of type Ta, because\n>> x < y)\n>>   - Bitcoin sent: BTCb1; Signal sent: cut; Directed to Bob (no token of\n>> type Ta given, but receives c tokens of type Tb)\n>>   - Bitcoin sent: BTCa - BTCa1; Signal sent: not important; Directed to\n>> Alice (no token sent, but useful to send a change in Bitcoin to Alice,\n>> if needed)\n>>   - Bitcoin sent: BTCb - BTCb1; Signal sent: not important; Directed to\n>> Bob (this output gets number x tokens of type Ta)\n>>\n>> Cross token atomic transactions in the case of the same number of tokens\n>> to be exchanged\n>> ---------------------------------------------------------------------------\n>> ------------- The atomic transactions described above do not work if the\n>> value of tokens of type Ta is equal to the value of tokens of type Tb. In\n>> this case, there is no way of doing an atomic exchange.\n>>\n>> Let's say that we need to do a transaction between two tokens that have\n>> the same value: TetherA and TetherB. Let's say that Alice and Bob want\n>> to change 199 tokens. The atomic transaction cannot be made, but, with a\n>> small risk, two transactions can be made. The first will be an atomic\n>> transaction giving 100 tokens of type TetherA from Alice to Bob and\n>> receiving 99 of type TetherB back, and the second will be 99 to 100.\n>>\n>> How to separate different types of token\n>> ----------------------------------------\n>> Let's say that an output contains two different types of tokens of\n>> interest to the user. Is there a way to separate the tokens so that they\n>> can be sent to different outputs? If the tokens are exactly the same\n>> number, there is not. If the tokens are two different numbers: x tokens\n>> of type A and y tokens of type B, then the separation can be done. Since\n>> the \"remaining error\" of an output goes to the change, we can send the\n>> higher value of the two and have the change receive the lower. We assume\n>> that x < y.\n>>\n>> Let's call A1 the output that will receive A and B1 the output that will\n>> receive the tokens of type B.\n>>\n>> The transaction will be similar to the cross token atomic transaction:\n>>\n>>   - Signal sent: x (the output gets x tokens of type B, but does not get\n>> any token of type A, because x < y)\n>>   - Signal sent: cut (no token of type A given, but receives a change in\n>> token of type B if the previous signal was less than y)\n>>   - Other outputs\n>>   - Signal sent: not important (this output gets number x tokens of type A)\n>>\n>> Guidelines\n>> ==========\n>> There are some suggestions that, if followed by the user, permit\n>> managing tokens in a simple manner, without technical knowledge of the\n>> rest of the protocol, with plausible deniability. This can be done using\n>> any existing wallet.\n>>\n>> The guidelines described here are based on a wallet that will be\n>> \"consolidated\". This means that all the outputs of the wallet are linked\n>> toghether. In some cases, this behavior diminish the level of privacy of\n>> the user. Thus, it is advised to use a number of different wallets, in\n>> order to reach the desired level of privacy.\n>>\n>> Plausible deniability: how to use a wallet to manage tokens\n>> -----------------------------------------------------------\n>> Some of the protocol's operations are designed to be managed using a\n>> coin selection software, however, any wallet without coin selection can\n>> be used to generate, send, or receive tokens. The option to use any\n>> existing Bitcoin wallet is the base of the plausible deniability of the\n>> protocol. The user can send, receive and generate tokens by using any\n>> wallet in a way that seems a normal use of the Bitcoin protocol to\n>> manage bitcoins.\n>>\n>> Thus, the guidelines in this section are based on a use of a wallet by a\n>> user without involving any \"coin selection\".\n>>\n>> In order to send or generate tokens, the user needs to have, at any\n>> time, only one output in the wallet. Let's call it a \"consolidated\"\n>> wallet. In order to consolidate a wallet:\n>>\n>>   - Send all the bitcoins contained in the wallet to a new address of\n>> the same wallet\n>>\n>> If the user departs from these guidelines by mistake, he can \"fix\" his\n>> wallet and re-consolidate it without losing the tokens contained in the\n>> wallet. If the wallet is consolidated, it remains consolidated while\n>> tokens are generated or sent, and while bitcoins from the wallet are\n>> spent. If bitcoins or tokens are received by any address of the wallet,\n>> then the wallet needs to be consolidated again.\n>>\n>> Issuance of tokens\n>> ------------------\n>> In order to generate tokens:\n>>\n>>   - Consolidate the wallet if it is not already consolidated.\n>>   - Send a minority of the bitcoins contained in the wallet to a new\n>> address (outside of the wallet). The last five digits of the satoshis\n>> sent are the number of tokens generated.\n>>   - From the same wallet, other tokens can be generated by sending again\n>> a number of satoshis, having the last five digits that are the number of\n>> tokens to issue to the new address.\n>>   - The value of bitcoins sent should always be less than the bitcoin\n>> that remains in the wallet\n>>   - If during the process of generating tokens the wallet receives\n>> bitcoins, it should be consolidated again before continuing to generate\n>> tokens.\n>>   - The type (or name) of tokens will be the txid of the transaction. If\n>> the transaction sends bitcoin to a new, never used, address, the address\n>> can be used as the name of the tokens, as well.\n>>\n>> In order to give the power to generate new tokens to another person:\n>>\n>>   - Send all the Bitcoin content of the wallet to the other person, with\n>> a single transaction\n>>\n>> In order to close an issuance:\n>>\n>>   - To close the issuance and guarantee that no other tokens of this\n>> type will ever be generated again, send to another address of the same\n>> wallet a number of bitcoins with the last five digits of the satoshis\n>> that is zero. Be aware that this shouldn't be all the content of the\n>> wallet. If all the content of the wallet is sent to some address, the\n>> issuance will not be closed. Instead, this gives to the receiver the\n>> power to generate new tokens.\n>>\n>> Spending bitcoins and not tokens\n>> --------------------------------\n>> In order to spend bitcoins from the wallet without sending any tokens,\n>> the user should spend less than half of the bitcoin value contained in\n>> the wallet, and:\n>>\n>>   - Spend a number of satoshis where the last five digits are all zeros,\n>>   or\n>>   - Spend a number of satoshis where the last five digits are a number\n>> greater than the tokens that are in the wallet,\n>>\n>> Transfer of tokens\n>> ------------------\n>> In order to send tokens to another person:\n>>\n>>   - Consolidate the wallet if it is not already consolidated.\n>>   - Send a value less than half of the content of the wallet and having\n>> the number of satoshis where the last five digits are the number of\n>> tokens that need to be transferred,\n>>   or\n>>   - Send all the bitcoins of the wallet (even if the wallet is not\n>> consolidated).\n>>\n>> If the user sends all the content of the wallet to a single address (no\n>> change), then he's emptying the token content from the wallet, as well.\n>> All the tokens will go to the address and nothing will remain to the user.\n>>\n>> In order to receive tokens from other users:\n>>\n>>   - Give to the other person a Bitcoin address of the wallet and ask to\n>> send tokens as explained above.\n>>   - If the wallet was empty before of receiving tokens, then it is\n>> already consolidated. Instead, if the wallet already had some bitcoins,\n>> then the wallet needs to be consolidated before sending or generating\n>> tokens.\n>>\n>> Effects of the use of these guidelines\n>> --------------------------------------\n>> When using the guidelines, the number of tokens sent to the recipient is\n>> always stated in the last five digits of the satoshis sent. There are\n>> three exceptions:\n>>\n>>   - In a single output transaction, all the tokens of the wallet will be\n>> sent to the recipient.\n>>   - In a transaction where the amount of satoshis sent ends with five\n>> zeros, no tokens are sent.\n>>   - In a transaction sending more tokens than the number of tokens of\n>> that type held in the wallet, no tokens are sent.\n>>\n>> Technical notes\n>> ---------------\n>>   - Sending a number of bitcoins that is greater than half of the\n>> bitcoins contained in the wallet brings to unpredicted results.\n>>   - Thus, if there are not enough bitcoins to continue to operate, the\n>> wallet needs to be \"re-charged\" by sending some bitcoins to it. By doing\n>> so, there will be more than one UTXO in the wallet. This departs from\n>> \"consolidated mode\" and the wallet needs to be consolidated again.\n>>   - A consolidated wallet contains only one UTXO.\n>>   - Every transaction made from a consolidated wallet contains only two\n>> outputs: one is the address outside of the wallet, and the other is the\n>> change.\n>>   - Every transaction spends all the content of the wallet.\n>>\n>> Reference Implementation\n>> ========================\n>> A reference implementation will be included when the protocol will be\n>> reviewed and accepted by the community.\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Alex Kravets",
                "date": "2017-09-08T08:06:01",
                "message_text_only": "Hi Luca,\n\nBravissimo!\n\nPlease allow me to encourage your to follow the BIP workflow as specified\nhere\nhttps://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki#BIP_workflow\n\nBIP Editor freely allocates BIP numberss, however that does not constitute\napproval but allows for much easier discussion of and communication about\nthe proposal.\n\nGood luck !\n\n\nOn Wed, Sep 6, 2017 at 9:08 AM Luca Venturini via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi everyone,\n>\n> I would like to propose a standard protocol to manage tokens on top of\n> the Bitcoin blockchain.\n>\n> The full text is enclosed and can be found here:\n>\n> https://github.com/token21/token-protocol-specification\n>\n> Any feedback will be appreciated.\n>\n> Luca Venturini\n>\n> ---\n>\n> Abstract\n> ========\n> This document describes a protocol to manage digital assets (tokens) on\n> top of the bitcoin blockchain. The protocol enables a semantic layer\n> that permits reading the bitcoin transactions as operations related to\n> tokens.\n>\n> The protocol allows a new level of plausible deniability, while\n> permitting statefull public auditability on each issued token. It allows\n> both the user and the issuer to deny that an existing bitcoin\n> transaction between the two is actually a token transaction, or a new\n> token issuance. While both the token sender and the token issuer cannot\n> deny to have sent bitcoins, nobody can prove the transaction was related\n> to a digital asset. On top of that, to guarantee plausible deniability,\n> tokens can be issued, sent, and received using any existing bitcoin\n> client software.\n>\n> There is no need to have a wallet exclusively dedicated to manage the\n> tokens. With a few simple precautions by the user, tokens can be managed\n> using any existing Bitcoin wallet, while it is used for normal bitcoin\n> transactions as well.\n>\n> Since it is possible to infinitely split a token in parts, there is no\n> definition of the number of decimals of token generated and transferred.\n> The number of tokens is always an integer.\n>\n> Every operation of the protocol is performed with Bitcoin transactions,\n> without the use of OP_RETURN and without any form of pollution of the\n> blockchain, or of the UTXO set.\n>\n> The protocol permits atomic buy and sell transactions between tokens and\n> Bitcoin, and between different types of tokens. The only operations that\n> require a coin selection enabled wallet are the split and join special\n> operations and the token offering issuance operations. Those are used to\n> modify the token unit of measure and to receive bitcoins from third\n> parties during a token offering issuance.\n>\n> Copyright\n> =========\n> This document is licensed under the 2-clause BSD license.\n>\n> Motivation\n> ==========\n> The current protocols that permit to issue tokens based on the bitcoin\n> blockchain (i.e. Counterparty, Omni, Colored Coins, Coinprism, Colu) are\n> flawed.\n>\n> The existing solutions usually need dedicated wallets and/or\n> verification nodes. Usually, a \"pivot\" currency is involved and atomic\n> transactions are not permitted unless they use the pivot currency. Those\n> protocols pollute the blockchain (30% or more) and in some cases they do\n> not accept P2SH scripts. Since the use of a dedicated wallet is\n> required, the users cannot plausibly deny they have got tokens.\n> Plausible deniability on the issuer side is not available either. None\n> of these protocols permits infinite division of the tokens, so usually\n> the number of decimals has to be specified at issuance time. The\n> automatic token offering issuance is not enabled as well.\n>\n> Rationale\n> =========\n> Let's take an example from the real world, a yacht. We write on the\n> yacht's license that the owner is any person that can show a one dollar\n> bill having the serial number F82119977F. Thus the one dollar bill can\n> be exchanged between owners with extreme simplicity and full plausible\n> deniability. The US government will guarantee that there is no other\n> person having the same dollar bill.\n>\n> The protocol permits managing a token in the same way. The underlying\n> Bitcoin protocol will guarantee against double spending.\n>\n> Features:\n>\n>   - Easy of use. Tokens can be managed using any wallet. Even if the\n> wallet has no coin selection feature.\n>   - Plausible Deniability by the issuer. The issuer can generate a new\n> type of token and nobody analyzing the blockchain will understand that\n> the transaction is issuing a token. Even if a token is known, the issuer\n> can issue other tokens. Since a single output contains a large number of\n> different token types, the issuer is actually generating different types\n> of tokens every time she sends a new Bitcoin transaction to the network.\n>   - Plausible Deniability by the user (no use of tokens at all, or use\n> of a different token type). A transaction that sends tokens from Alice\n> to Bob is a normal transaction. Nobody can understand that this\n> transaction is moving tokens unless they explicitly know which\n> transaction is the token issuance. In fact a single address contains a\n> large number of token types, and the use of tokens itself can be denied.\n>   - Accountability. Everybody can see the state of the distribution of a\n> type of token.\n>   - Tunnel mode (confidentiality by issuer and user versus a third\n> party). Alice can send tokens to Bob and ask him to give the tokens to\n> Charlie, without telling to Bob what is the type of the token given.\n> Alice can disclose this information in the future, if she wants.\n>   - It is possible to perform open or closed issuances. While an open\n> issuance permits to continue the issuance of tokens in the future,\n> closed issuance guarantees that no other token of the same type will\n> ever be issued.\n>   - The power to continue the issuance of an open token can be sent to\n> another address, using a transaction. Once the power to continue the\n> issuance is sent to someone, the former issuer cannot issue any more\n> tokens.\n>   - The power to continue the issuance has the same features of\n> plausible deniability of the possess of a token.\n>   - Since a token type is uniquely identified by a transaction hash, or,\n> in some cases, by a Bitcoin address, a user can prove to be the issuer\n> by signing a message using the Bitcoin protocol.\n>   - Future proof. Tokens can move following P2PKH, P2SH, P2SH-P2WPKH\n> outputs or any other type of script\n>   - Blockchain pollution of the protocol transactions is almost zero.\n> There is no OP_RETURN involved, nor any other type of \"fake\" addresses\n> that pollute the UTXO database.\n>   - The protocol is based on the Bitcoin blockchain, but, with small\n> changes, can be considered blockchain agnostic.\n>   - Atomic transactions between tokens and Bitcoin are possible.\n>   - Atomic transactions between different types of tokens are possible.\n>   - Tokens of different types can be held by the same address and by the\n> same output.\n>   - Tokens can be divided indefintely, thus having any number of decimals.\n>   - Tokens can be issued automatically on the receiving of bitcoins.\n> This operation performs a token offering issuance (also known as Initial\n> Coin Offering).\n>\n> Introduction\n> ============\n>\n> Where are the tokens?\n> ---------------------\n> As with bitcoins, tokens are contained in unspent Bitcoin outputs. In\n> some cases, defined below, the last five digits of the satoshi value\n> sent to the output represent the number of tokens contained in the output.\n>\n> When an output is spent, the tokens contained in the output are fully\n> spent in the same transaction. There are no tokens outside of the tokens\n> contained in the UTXO database.\n>\n> Token issuance\n> --------------\n> The large majority of bitcoin transactions can be semantically seen as\n> token issuances. There are two types of token issuances: closed and\n> opened. A closed token issuance guarantees that no other token of the\n> same type will ever be issued.\n>\n> Issuance chains\n> ---------------\n> An open issuance gives to one, or more, of its output the power to\n> continue the issuance of tokens of the same type. We define such a power\n> as Power of Continuation (POC). The transaction that will spend the\n> output appointed with the POC will be a continuation of the same\n> issuance chain.\n>\n> Every transaction of the chain will issue the same type of token. On top\n> of that, every transaction that is part of the chain, can also be seen\n> as as issuance of tokens of its, new, type. A chain will be closed by a\n> transaction having more than one output and the first output with five\n> zeros as the last five digits of the satoshis value. No other\n> transactions can send tokens of the same type after the close of the\n> issuance.\n>\n> Token names\n> -----------\n> A token type can have multiple names. The default name is the hash of\n> the first transaction that issued the token.\n>\n> i.e: 68330b6ab26e44f9c3e515f04d15ffe6547f29e60b809a47e50d9abf59045c1e\n>\n> As alternative names, a token type can be named after the bitcoin\n> address of one of the outputs of the transaction that first issued the\n> token, provided the fact that the address has never been used before in\n> the blockchain.\n>\n> Note: it is better to use one of the alternate names in cases when\n> transaction malleability is a concern.\n>\n> Vanity token names\n> ------------------\n> A token can be identified using only the first characters of the Bitcoin\n> address, as alternate name defined above, if the characters are\n> different from every previous Bitcoin address seen in the blockchain. An\n> example is provided below.\n>\n> Tokens can coexist\n> -------------------\n> Token of different types can coexist in a single output while remaining\n> of different types. Thus a bitcoin address (actually an output of the\n> UTXO database) can hold tokens of different types. Every Bitcoin address\n> contains a lot of types of tokens, so that a user usually does not know\n> all the type of tokens contained in an address.\n>\n> A single transaction can send a type of token to some of the outputs\n> while sending another type of token to a different set of its outputs.\n> Tokens are never burned or deleted.\n>\n> Use the protocol\n> ================\n> This section explains a basic use case. In all the examples provided, we\n> do not consider the fee. We assume that there is another input, not\n> listed, that pays the transaction fee.\n>\n> Alice, Bob, Charlie, and Daniel decides that they want to start a new\n> company. Each of them will give to the new company some time, money,\n> furniture, knowledge. They decide everyone contributed to the company\n> with a percentage of value as follows: Alice - 40%, Bob - 12%, Charlie -\n> 34% and Daniel - 14%. They decide that the shares of the new company can\n> be freely resold to others and that they will accept that the annual\n> meeting will consent vote through messages signed using the Bitcoin\n> protocol by the owners of the shares.\n>\n> Issue tokens\n> ------------\n> Alice asks Bob, Charlie, and Daniel to send her 1 Bitcoin each. She asks\n> each of them to give her a bitcoin address where they want to receive\n> back the bitcoins along with the tokens.\n>\n> She asks Charlie to generate a vanity address that has never been used\n> before of type 1CompanyXWXjLgud9jxwxm34u.... Since there has been a\n> previous address in the blockchain having 1Companx as the first\n> characters, but this is the first address seen in the blockchain that\n> has 1Company as the first characters, they will call the token with the\n> name 1Company. This step is optional.\n>\n> Then she sends, from her wallet, a transaction having the following\n> outputs:\n>\n>   - 1.00000040 to an address controlled by Alice\n>   - 1.00000012 to an address controlled by Bob\n>   - 1.00000034 to the vanity address 1CompanyXWXjLgud9jxwxm34u...\n> controlled by Charlie\n>   - 1.00000014 to an address controlled by Daniel\n>   - 3.45322112 is the change generated by Alice's wallet\n>\n> This transaction gives 40, 12, 34, 14 tokens to each one. The newly\n> generated token type can be named after the transaction hash, or after\n> the vanity address (optional), or after one of the addresses of the\n> persons involved, provided that the address has never been used before.\n>\n> The issuance is still open. Since they do not want to issue more shares,\n> they decide to close the issuance (on the other side, they could decide\n> to leave the issuance open and to hold the issuing key somewhere, or to\n> have a multisignature address and to give the keys to the directors of\n> the company). In order to close the issuance, Alice generates the\n> following transaction that sends bitcoins from her wallet to addresses\n> of her same wallet, using the change output of the previous transaction\n> as an input:\n>\n>   - 0.45000000 to an address of her wallet\n>   - 3.00322112 change generated by the wallet\n>\n> This closes the issuance.\n>\n> Send tokens\n> --------------\n> After some while, Bob decides to give some shares of the company to his\n> husband Giacomo. He generates a new transaction spending the output of\n> the issuance transaction:\n>\n>   - 0.03400008 to Giacomo\n>   - 0.96600004 change generated by Bob's wallet\n>\n> This transaction gives to Giacomo 8 shares of the company.\n>\n> Atomic transactions\n> -------------------\n> Daniel wants to sell 3 of his 14 shares to Frank. They negotiate a price\n> of 0.00323200 bitcoin per share. This is a total of 0.00969600 bitcoin\n> to buy the three shares. They do not know each other very well, so they\n> decide to make an atomic transaction that will give 0.00969600 bitcoins\n> to Daniel and 3 shares to Frank. Daniel set an input of the new\n> transaction with his issuance transaction output. Frank put in another\n> input of 1.23242454 bitcoins from his wallet. The outputs of the\n> transaction are as follows:\n>\n>   - 0.22400003 to an address controlled by Frank (this gives the 3\n> shares to Frank)\n>   - 0.23200000 to an address controlled by Daniel (this is part of the\n> payment to Daniel)\n>   - 0.77769614 to an address controlled by Daniel (this can be\n> considered the change of the original issuance output of 1.00000014)\n>   - 0.99872851 to an address controlled by Frank (change to Frank)\n>\n> Daniel sent to the inputs of the transaction 1.00000014 bitcoins and\n> receives back 1.00969614. This gives to Daniel the 0.00969600 paid by\n> Frank. On the other side, Frank sends 1.23242454 as an input of the\n> transaction and receives back 1.22272854 bitcoins, thus paying exactly\n> the 0.00969600 that needs to be paid to Daniel. This transaction sends 3\n> tokens from Daniel to Frank. Another 11 tokens are the tokens that are\n> given as a change to Daniel, along with 0.23200000 bitcoins.\n>\n> Specification\n> =============\n>\n> Definitions\n> -----------\n> In order to evaluate a transaction, the outputs are sorted by the\n> satoshis value. Once sorted, we define a \"cut\" output the first output\n> having five zeros as the last five digits of the satoshi value (satoshis\n> modulo 10^5 == 0). In the following, \"first\", \"second\", \"last\" are all\n> referred to the sorted outputs.\n>\n> We define as \"signal\" of an output the value of satoshis of the output\n> modulo 10^5. This is the last five digits of the value, as expressed in\n> satoshis.\n>\n> Despite not mandatory, we sometimes call \"c\", or \"change\", the output\n> having the biggest value in Satoshi. This is the last output, as sorted\n> above. Such behavior follows the \"Guidelines\" section, explained below.\n>\n> We use n=0 related to a sequence a1, ..., an, to indicate that there are\n> no elements in the sequence.\n>\n> Issuance of a token\n> -------------------\n> A transaction that has only one output, or has the first output that is\n> a cut, issues no token. Every other Bitcoin transaction is an issuance\n> of tokens of the type of the transaction.\n>\n> When a issuance is open, Power of Continuation (POC), will be given to\n> an output that will be spent in a transaction that continues the\n> issuance of the same type of tokens.\n>\n> As for the protocol behavior, we divide the structure of the sorted\n> outputs of a bitcoin transaction in the following groups. For each\n> group, a description of the behavior of the protocol is provided.\n>\n>   - a1, ..., an, cut(POC), z1(POC), ... zm(POC), b1, ..., bl, with n>0,\n> m>=0, m+l>0\n>       * zi are outputs signaling zero. They are optional.\n>       * This is an open issuance. It generates the number of tokens\n> signaled by the outputs before the cut: a1, ..., an. Every output of\n> that set receives a number of tokens as signaled by the output satoshis'\n> value.\n>       * The cut output, and every other output zi, signaling zero, that\n> is directly after the cut, receive the POC. This means that the\n> transactions that will spend the POC will be a continuation of this\n> issuance and a continuation of every issuance that gave the POC to the\n> this transaction.\n>   - cut, b1, ..., bm with m>0 (a cut alone is a case of the fourth type)\n>       * This is a particular case of the first group, having n=0 and\n> m=0. This transaction *closes the issuance forever*. Every token's chain\n> that ends into this transaction is closed as well.\n>       * It generates no tokens and there are no other outputs that can\n> continue the issuance in the future.\n>       * If b1 or b2 have a signal of zero and m>2, this is a token\n> offering issuance transaction. It will be described in a following section.\n>   - a1, ..., an, c(POC) with n>0\n>       * This is an open issuance. It generates the number of tokens that\n> are signaled in a1, ..., an. The last output c will not receive tokens.\n>       * The last output c will receive the POC. A following transaction\n> that spends the output c is an issuance transaction of the same type of\n> token.\n>       * The fact that c is a cut (or not) does not modify the behavior\n> of the transactions of this group\n>   - c(POC) (single output, also seen as the previous one, with n=0)\n>       * This transaction generates no tokens at all.\n>       * The output c receives the POC. Thus a following transaction that\n> spends the output c is an issuance transaction of the same type of token.\n>\n> Notes on token issuances\n> ------------------------\n> The number of tokens generated by an issuance transaction is always the\n> sum of the signals of all the outputs, excluding the last one and the\n> outputs that are listed after a cut. Thus the number of tokens sent to\n> each output, that receives tokens, is always the number signaled by the\n> output.\n>\n> Who has the power to generate other tokens of the same issuance (POC):\n>\n>   - If there is no cut, the issuance is open and the transaction that\n> will spend the last (biggest) output can continue to generate token of\n> the same type.\n>   - If there is a cut, in a position different than the first, the\n> issuance is open. The cut output will be the input of a following\n> transaction that issues more tokens of the same issuance chain. The\n> following transaction can close tha chain, or can be an open issuance,\n> thus having another output that will continue the generation chain.\n>\n> In order to close forever the issuance of tokens, the transaction should\n> have a cut as the first output and have more than one output.\n>\n> Transfer of tokens\n> ------------------\n> Every bitcoin transaction spends all the tokens' content of the inputs\n> and sends them to the outputs. Some of the outputs receive the number of\n> tokens exactly stated in the last five digits of the satoshis sent (the\n> signal), in a way similar to an issuance transaction.\n>\n> A transaction can be seen as having one of the three following shapes\n> (ai means an output that is not a cut, bi and c are outputs that can be\n> cut):\n>\n>   - a1, ..., an, cut, b1, ..., bm, c (transactions with a cut) (n=0 is\n> described here)\n>       * No output (bi) after a cut receives tokens.\n>       * Tokens will be assigned to outputs a1, ..., an trying to follow\n> the signal as follows:\n>           - If there are enough tokens, the tokens signaled by the first\n> output are assigned to that output.\n>           - If there are still remaining tokens, the tokens are sent to\n> the following output based on the signal.\n>           - This continues until there is a cut or the tokens signaled\n> by an output are more than the remaining tokens. In these cases:\n>               * If there is a cut, it receives all the remaining tokens.\n>               * If there is an output receiving more tokens than the\n> remaining tokens (we define it a \"remaining error\"), the output receives\n> no token at all. No other output will receive tokens after this and all\n> the remaining tokens will be sent to the last output c (thus, if there\n> is a cut in the transaction, the algorithm \"jumps\" the cut).\n>               * If there is a \"remaining error\" and the transaction is a\n> special transaction as defined in the next section, and the number of\n> tokens in input is exactly the same of the two types (big and small)\n> that are the result of a previous split or join special transaction, the\n> \"remaining error\" output gets one of the smallest tokens involved. This\n> will be better explained in the following section about \"special\n> transactions\".\n>       * If the first output is a cut, and the transaction is not a\n> special one as defined below in the document, the last output (c)\n> receives all the tokens\n>   - a1, ..., an, c (ai is not a cut, for every i; c can be a cut)\n>       * The tokens are assigned to a1, ..., an as described in the\n> previous group.\n>       * The last output c receives all the remaining tokens. This\n> behavior is not modified by the fact that the last output is a cut.\n>   - c (single output transaction, also seen as the previous one, with n=0)\n>       * The output receives all the tokens received from the inputs\n>\n> Transactions receiving both the POC of an issuance and some tokens of\n> the same issuance\n>\n> ---------------------------------------------------------------------------------------\n> The protocol is designed such that a transaction of an issuance chain\n> never issue new tokens to an output, that receives the POC of the same\n> type of token. But two different inputs can give to a transaction both\n> some tokens and the POC of the same type of token. In this case, there\n> is a double role for the transaction that is both a continuation of the\n> issuance and a transfer transaction sending tokens of the same type.\n>\n> In this case, the tokens will be allocated as defined in the following\n> four different shapes of transaction:\n>\n>   - a1, ..., an, cut, b1, ..., bm, c (transaction with a cut)\n>       * The generated tokens are sent to the outputs a1, ..., an as\n> described in the definition of an issuance of tokens\n>       * All the tokens received in input of the same type of the\n> issuance we are continuing will be sent to the cut output\n>   - a1, ..., an, c (transaction without a cut, or with c that is a cut:\n> ai is not a cut, for every i)\n>       * The generated tokens are sent to the outputs a1, ..., an as\n> described in the definition of an issuance of tokens transaction\n>       * All the tokens received in input, of the same type of the\n> issuance we are continuing, will be sent to the last output c\n>   - cut, b1, ..., bm\n>       * The issuance will be closed and all the tokens will be given to\n> the last output bm. The behavior described in the issuance transaction\n> and in the transaction sending tokens do not influence each other, in\n> this case.\n>       * If it is a special transaction, as defined below, there is no\n> overlap between the definitions. The issuance chain is closed and the\n> received tokens will be given as defined.\n>   - c only\n>       * The definitions of issuance transaction and transfer transaction\n> can be used. The issuance will remain open and the address will receive\n> all the tokens received from the inputs\n>\n> Since both the first and the second group of transactions are giving the\n> POC to the same output that receives the tokens, the output will\n> continue to carry both the tokens received and the POC. This delegates\n> someone to issue new tokens and allocates some tokens from a previous\n> issuance that are still not assigned.\n>\n> Split and join transactions\n> ---------------------------\n> A split or join transaction is one that has one of the following formats\n> of outputs:\n>\n>   - cut, a1, ..., an, z, b1, ..., bm (z is an output signaling zero,\n> like a cut)\n>   - cut, a1, ..., an, c\n>\n> having the added condition that the sum of the signals of the outputs\n> a1, ..., an is:\n>\n>   - equal to the number of tokens received in input divided by 1000 (we\n> call it a join transaction), or\n>   - equal to the number of tokens received in input multiplied by 1000\n> (we call it a split transaction)\n>\n> Since the presence of these two extra conditions, the fact that a\n> transaction is a join or split transaction, or it is not (hence it is a\n> simple transfer transaction), depends on the number of tokens received\n> in the input. A given transaction can be both split or join for some\n> type of tokens, and normal for other types of tokens.\n>\n> Note: this is the same format that closes an issuance chain. If the\n> transaction receives both POC and tokens of the same type, the\n> transaction chain will be closed and the received tokens will be sent as\n> described here.\n>\n> Note: this is also the format of a transfer transaction that assigns to\n> the change c or bm, the token received in the input. But, if a\n> transaction is a special one of the first two types, that behavior\n> should not be considered and no tokens will be transferred to the change.\n>\n> The split transaction generates a new type of tokens with a value that\n> is one thousandth of the value of the type of tokens received in the\n> input. This new type can be mixed with tokens generated by other similar\n> split transactions, based on the same original token. Split tokens have\n> the same value and can be joined in the future with join transactions.\n>\n> The join transaction generates a new type of tokens with one thousand\n> times the value of the type of tokens received in the input. This new\n> type of token can coexist with tokens generated by other similar join\n> transactions, based on the same original token. Joined tokens from the\n> same original token, have the same value and can be split in the future\n> with split transactions. Thus becoming again original tokens.\n>\n> In a special transaction of the second group, without \"the second cut\"\n> z, the change is mandatory and does not receive tokens. This means that\n> the number of tokens sent is summed up without the last output. If the\n> number is not correct, then it is not a split or join transaction.\n>\n> Tokens split or joined are of a different type than their original\n> source. This means that they can coexist in the same output and will\n> never mix together. Thus a output having 3 big tokens and 456 tokens\n> obtained by a split transaction, seems to have 3.456 tokens, but, in\n> fact, has 3 tokens of a type and 456 tokens of another type (the second\n> type is referred as the original type with a 0.001 unit of measure).\n>\n> Note: as described below, there is a procedure of separating tokens of\n> different types contained in the same output. This procedure will not\n> work if the two type of tokens are present in the same output in the\n> same number. Thus if an output contains exactly 3.003 tokens (3 big and\n> 3 small), the tokens cannot be separated anymore. This is why we\n> introduced, in the transfer transaction definition, the rule that\n> assigns in this case one single token of the smallest type to the\n> \"remaining error\" output.\n>\n> Token offering issuance transactions\n> ------------------------------------\n> A token offering issuance transaction is a transaction having one of the\n> following formats (z is an output signaling zero, like a cut; r and s\n> are outputs that signal a value greater than zero; the group of outputs\n> (t1, t2, z) is optional; t1 or t2 can signal zero, but not both):\n>\n>   - cut, z, r, (t1, t2, z,) a1, ..., an, c\n>       * price of tokens are predefined\n>   - cut, s, z, (t1, t2, z,) a1, ..., an, c\n>       * price of tokens are not predefined\n>\n> The tokens will be assigned to one of the outputs of every transaction\n> that sends bitcoin to the address of the outputs r or s, as follows:\n>   - if the sending transaction has only two outputs (r, c), (c, r), (s,\n> c) or (c, s), the \"other\" output c receives the tokens.\n>   - if the sending transaction has more than two outputs, the last\n> (biggest) output that is not the one sending bitcoins to r or s, will\n> receive the tokens.\n>   - if the sending transaction has only one output, the generated tokens\n> will be assigned to the output r or s itself. This can be considered as\n> a donation: it generates tokens, but the tokens remain in the\n> availability of the issuer.\n>   - since the number of token emitted is always an integer, the\n> remaining satoshis are not considered in the number of tokens issued and\n> are sent to the issuer without any token generation.\n>\n> Note: this is the second place, in this document, where the bitcoin\n> address of an output is used. The other place regards the alternate\n> names of an issuance. Everything else in the protocol is based on\n> outputs, not addresses.\n>\n> If the group (t1, t2, z) is present, it signals how many token will be\n> issued. The total number of tokens that will be issued is the number\n> signaled by t1 * 10^6 + the number signaled by t2. In any block, the\n> issuance can be closed by the transaction that spends the outputs r or s.\n>\n> Timeline:\n>   - The offer starts in the block that contains the token offering\n> issuance transaction. Every transaction of the starting block receives\n> tokens, without order.\n>   - If there is a defined total number of tokens, the issuance will end\n> when the total number of tokens has been reached.\n>       * Inside the last block, the transactions are considered in the\n> order they are listed. So if a transaction takes the last tokens, every\n> other transaction sending bitcoins to r or s, do not receive tokens.\n>   - The transaction that spends the outputs r or s ends the issuance.\n> This transaction suspends the issuance even if a defined number of\n> tokens was defined in the token offering issuance transaction.\n>       * In case of an issuance suspeded, or ended, by a transaction\n> spending r or s, every transaction of the block containing the spending\n> transaction will be considered valid as a receiver of tokens.\n>       * Thus, sending bitcoins to the address of the outputs r or s will\n> be considered as part of the offering, only if it is included in a block\n> between the block of the transaction that has r or s as an output\n> (start), and the block of the transaction that spends the output r or s\n> (end), inclusive.\n>\n> A token offering issuance transaction of the first type permits to set a\n> rate, and to issue tokens every time bitcoins are received by an\n> address. The rate is defined by the number signaled by the output r. One\n> token will be issued for every r satoshis received.\n>\n> A token offering issuance transaction of the second type does not set a\n> predefined rate at the start. The rate will be defined by the\n> transaction that closes the issuance by spending the output s. The first\n> (smallest) output of the closing transaction, or the first output after\n> the cut (if a cut is present), will signal the rate. This type of token\n> offering issuance, having the price defined at the end, permits to issue\n> token based on parameters related to the issuance itself. This is the\n> case, for example, of Dutch Auctions.\n>\n> Note: A token offering issuance transaction can be seen as a transfer\n> transaction, that sends all the tokens that receives to the output c.\n>\n> Note: the type of token issued is defined by the token offering issuance\n> transaction, seen as an issuance transaction. Since a token offering\n> transaction is also the closure of some issuing chains, this means that\n> the same token offer will issue different type of tokens. In fact, a\n> different type of token will be issued for every issuance chain that\n> ends with the same token offering issuance transaction. Thus a token\n> type can be first issued in a controlled way (this is usually called\n> pre-ICO) and then the rate can be stated, and the same type of token can\n> be offered to the public (this is usually called the ICO). Since the\n> token offering issuance transaction closes the issuance forever, there\n> is the guarantee that no other tokens of the same type will ever be\n> issued after the offer is closed. In order to offer tokens at different\n> prices, multiple issuance transactions can be generated with POCs\n> originating from the same issuance chain.\n>\n> Atomic transactions between bitcoins and tokens\n> -----------------------------------------------\n> Using the cut signal and software that allows full \"coin selection\",\n> it's possible to make atomic exchange transactions. The outputs before\n> the cut will determine who will receive the tokens and the following\n> outputs will define the rest of the transaction. Both the changes (the\n> one of the token wallet and the one of the Bitcoin wallet), should be in\n> the second set (after the cut). Since the cut will receive the remaining\n> tokens, it is suggested that the cut is sent to the seller of tokens.\n> Using this method, the remaining tokens can be sent without involving a\n> calculation of the remaining tokens. The outputs of an atomic exchange\n> transaction will have the following format (seller is the token seller,\n> buyer is the token buyer).\n>\n>   - a1: tokens sent from the seller to the buyer\n>   - a2: tokens sent from the seller to the buyer\n>   - cut: part of the bitcoin payment sent from buyer to seller\n>   - b1: part of the bitcoin payment sent from buyer to seller (or change\n> sent from seller to buyer, if the price to be paid is less than the\n> value of the cut)\n>   - b2: Bitcoin change sent to the token wallet\n>   - b3: Bitcoin change sent to the bitcoin wallet\n>\n> It is impossible to make an atomic exchange transaction if the wallet in\n> use does not allow coin selection.\n>\n> Cross token atomic transactions\n> -------------------------------\n> Let's say that Alice wants to sell a number x of tokens of type Ta and\n> Bob wants to pay using y tokens of type Tb. Token of type Tb are of\n> lesser value than the tokens of type Ta, so Bob will pay more Tb tokens\n> and Alice will pay fewer Ta tokens (x < y). Let's say that the\n> transaction spends an output from Alice containing BTCa bitcoins and\n> *exactly* x tokens, while Bob sends to the same transaction BTCb\n> bitcoins and a number z of tokens of type Tb. Since z > y, Bob will\n> receive a change c in tokens of type Tb.\n>\n> Alice managed the previous transactions so that a fixed number x of\n> tokens can be sent as the input with a number BTCa of bitcoins. Bob is\n> not required do the same, because there is the cut that gives the\n> remaining tokens back to Bob. In order to simplify let's say that there\n> is another input giving the fee for the transaction and the Bitcoin\n> assigned to each output will be calculated accordingly.\n>\n> The atomic transaction can be made by signaling with the first output\n> the number y of tokens that Bob should pay to Alice. This output will go\n> to Alice. Since y is higher than x, all the x tokens of type Ta will go\n> to the change (directed to Bob), while the y tokens of type Tb will go\n> to the first output. A following cut can be used to send the change to\n> Bob. The addresses following the cut can be used as changes of bitcoins.\n>\n> The inputs of the transaction will have a content in Bitcoin and tokens\n> as follows:\n>\n>   - Alice will spend an output having BTCa bitcoins and containing\n> *exactly* x tokens of type Ta\n>   - Bob will spend an output having BTCb bitcoins and containing y + c\n> tokens of type Tb\n>\n> The outputs of the transaction will have the following form:\n>\n>   - Bitcoin sent: BTCa1; Signal sent: y; Directed to Alice (the output\n> gets y tokens of type Tb, but does not get any token of type Ta, because\n> x < y)\n>   - Bitcoin sent: BTCb1; Signal sent: cut; Directed to Bob (no token of\n> type Ta given, but receives c tokens of type Tb)\n>   - Bitcoin sent: BTCa - BTCa1; Signal sent: not important; Directed to\n> Alice (no token sent, but useful to send a change in Bitcoin to Alice,\n> if needed)\n>   - Bitcoin sent: BTCb - BTCb1; Signal sent: not important; Directed to\n> Bob (this output gets number x tokens of type Ta)\n>\n> Cross token atomic transactions in the case of the same number of tokens\n> to be exchanged\n>\n> ----------------------------------------------------------------------------------------\n> The atomic transactions described above do not work if the value of\n> tokens of type Ta is equal to the value of tokens of type Tb. In this\n> case, there is no way of doing an atomic exchange.\n>\n> Let's say that we need to do a transaction between two tokens that have\n> the same value: TetherA and TetherB. Let's say that Alice and Bob want\n> to change 199 tokens. The atomic transaction cannot be made, but, with a\n> small risk, two transactions can be made. The first will be an atomic\n> transaction giving 100 tokens of type TetherA from Alice to Bob and\n> receiving 99 of type TetherB back, and the second will be 99 to 100.\n>\n> How to separate different types of token\n> ----------------------------------------\n> Let's say that an output contains two different types of tokens of\n> interest to the user. Is there a way to separate the tokens so that they\n> can be sent to different outputs? If the tokens are exactly the same\n> number, there is not. If the tokens are two different numbers: x tokens\n> of type A and y tokens of type B, then the separation can be done. Since\n> the \"remaining error\" of an output goes to the change, we can send the\n> higher value of the two and have the change receive the lower. We assume\n> that x < y.\n>\n> Let's call A1 the output that will receive A and B1 the output that will\n> receive the tokens of type B.\n>\n> The transaction will be similar to the cross token atomic transaction:\n>\n>   - Signal sent: x (the output gets x tokens of type B, but does not get\n> any token of type A, because x < y)\n>   - Signal sent: cut (no token of type A given, but receives a change in\n> token of type B if the previous signal was less than y)\n>   - Other outputs\n>   - Signal sent: not important (this output gets number x tokens of type A)\n>\n> Guidelines\n> ==========\n> There are some suggestions that, if followed by the user, permit\n> managing tokens in a simple manner, without technical knowledge of the\n> rest of the protocol, with plausible deniability. This can be done using\n> any existing wallet.\n>\n> The guidelines described here are based on a wallet that will be\n> \"consolidated\". This means that all the outputs of the wallet are linked\n> toghether. In some cases, this behavior diminish the level of privacy of\n> the user. Thus, it is advised to use a number of different wallets, in\n> order to reach the desired level of privacy.\n>\n> Plausible deniability: how to use a wallet to manage tokens\n> -----------------------------------------------------------\n> Some of the protocol's operations are designed to be managed using a\n> coin selection software, however, any wallet without coin selection can\n> be used to generate, send, or receive tokens. The option to use any\n> existing Bitcoin wallet is the base of the plausible deniability of the\n> protocol. The user can send, receive and generate tokens by using any\n> wallet in a way that seems a normal use of the Bitcoin protocol to\n> manage bitcoins.\n>\n> Thus, the guidelines in this section are based on a use of a wallet by a\n> user without involving any \"coin selection\".\n>\n> In order to send or generate tokens, the user needs to have, at any\n> time, only one output in the wallet. Let's call it a \"consolidated\"\n> wallet. In order to consolidate a wallet:\n>\n>   - Send all the bitcoins contained in the wallet to a new address of\n> the same wallet\n>\n> If the user departs from these guidelines by mistake, he can \"fix\" his\n> wallet and re-consolidate it without losing the tokens contained in the\n> wallet. If the wallet is consolidated, it remains consolidated while\n> tokens are generated or sent, and while bitcoins from the wallet are\n> spent. If bitcoins or tokens are received by any address of the wallet,\n> then the wallet needs to be consolidated again.\n>\n> Issuance of tokens\n> ------------------\n> In order to generate tokens:\n>\n>   - Consolidate the wallet if it is not already consolidated.\n>   - Send a minority of the bitcoins contained in the wallet to a new\n> address (outside of the wallet). The last five digits of the satoshis\n> sent are the number of tokens generated.\n>   - From the same wallet, other tokens can be generated by sending again\n> a number of satoshis, having the last five digits that are the number of\n> tokens to issue to the new address.\n>   - The value of bitcoins sent should always be less than the bitcoin\n> that remains in the wallet\n>   - If during the process of generating tokens the wallet receives\n> bitcoins, it should be consolidated again before continuing to generate\n> tokens.\n>   - The type (or name) of tokens will be the txid of the transaction. If\n> the transaction sends bitcoin to a new, never used, address, the address\n> can be used as the name of the tokens, as well.\n>\n> In order to give the power to generate new tokens to another person:\n>\n>   - Send all the Bitcoin content of the wallet to the other person, with\n> a single transaction\n>\n> In order to close an issuance:\n>\n>   - To close the issuance and guarantee that no other tokens of this\n> type will ever be generated again, send to another address of the same\n> wallet a number of bitcoins with the last five digits of the satoshis\n> that is zero. Be aware that this shouldn't be all the content of the\n> wallet. If all the content of the wallet is sent to some address, the\n> issuance will not be closed. Instead, this gives to the receiver the\n> power to generate new tokens.\n>\n> Spending bitcoins and not tokens\n> --------------------------------\n> In order to spend bitcoins from the wallet without sending any tokens,\n> the user should spend less than half of the bitcoin value contained in\n> the wallet, and:\n>\n>   - Spend a number of satoshis where the last five digits are all zeros,\n>   or\n>   - Spend a number of satoshis where the last five digits are a number\n> greater than the tokens that are in the wallet,\n>\n> Transfer of tokens\n> ------------------\n> In order to send tokens to another person:\n>\n>   - Consolidate the wallet if it is not already consolidated.\n>   - Send a value less than half of the content of the wallet and having\n> the number of satoshis where the last five digits are the number of\n> tokens that need to be transferred,\n>   or\n>   - Send all the bitcoins of the wallet (even if the wallet is not\n> consolidated).\n>\n> If the user sends all the content of the wallet to a single address (no\n> change), then he's emptying the token content from the wallet, as well.\n> All the tokens will go to the address and nothing will remain to the user.\n>\n> In order to receive tokens from other users:\n>\n>   - Give to the other person a Bitcoin address of the wallet and ask to\n> send tokens as explained above.\n>   - If the wallet was empty before of receiving tokens, then it is\n> already consolidated. Instead, if the wallet already had some bitcoins,\n> then the wallet needs to be consolidated before sending or generating\n> tokens.\n>\n> Effects of the use of these guidelines\n> --------------------------------------\n> When using the guidelines, the number of tokens sent to the recipient is\n> always stated in the last five digits of the satoshis sent. There are\n> three exceptions:\n>\n>   - In a single output transaction, all the tokens of the wallet will be\n> sent to the recipient.\n>   - In a transaction where the amount of satoshis sent ends with five\n> zeros, no tokens are sent.\n>   - In a transaction sending more tokens than the number of tokens of\n> that type held in the wallet, no tokens are sent.\n>\n> Technical notes\n> ---------------\n>   - Sending a number of bitcoins that is greater than half of the\n> bitcoins contained in the wallet brings to unpredicted results.\n>   - Thus, if there are not enough bitcoins to continue to operate, the\n> wallet needs to be \"re-charged\" by sending some bitcoins to it. By doing\n> so, there will be more than one UTXO in the wallet. This departs from\n> \"consolidated mode\" and the wallet needs to be consolidated again.\n>   - A consolidated wallet contains only one UTXO.\n>   - Every transaction made from a consolidated wallet contains only two\n> outputs: one is the address outside of the wallet, and the other is the\n> change.\n>   - Every transaction spends all the content of the wallet.\n>\n> Reference Implementation\n> ========================\n> A reference implementation will be included when the protocol will be\n> reviewed and accepted by the community.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-- \nAlex Kravets\n@alexkravets <https://twitter.com/alexkravets>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170908/883d0e5e/attachment-0001.html>"
            },
            {
                "author": "Luca Venturini",
                "date": "2017-09-06T18:32:47",
                "message_text_only": "Hi Dan,\n\nthank you for your feedback. Let me clarify that the plausible \ndeniability is a property of the protocol. If this will become a BIP, \nand will be approved, there will be wallets that will manage tokens. In \nthe meantime, and in the future, it is important that a person with a \nlegacy bitcoin wallet can hold, issue and transfer bitcoins without \ndisclose that there are tokens involved. Tokens are contained in Bitcoin \ntransactions without any modification.\n\nVanity addresses are on option. They are not mandatory. In situations \nwhere plausible deniability is a concern they will, probably, not be used.\n\nSending to someone 0.23000012 bitcoin is really easy. You don't need any \nform of math and you are sending exactly 12 tokens from your wallet. \nSometimes it is suspect, but sending 0.03423122 in order to send 23122 \ntokens does not seem suspect to me. The large majority of the \ntransactions have strange numbers like this one.\n\nIn the document, when I say \"wallet\" I mean every single bitcoin wallet \nthat you can use today to hold bitcoins. The base of the plausible \ndeniability is that there is no \"special\" wallet involved. Maybe there \nwill be special wallets to manage tokens, but they are not mandatory. \nThe consolidation is needed only when using wallets that do not allow \ncoin selection.\n\nThe state of the tokens is fully contained in the bitcoin blockchain. \nThere is no need for verification nodes, nor for any other software. \nMaybe you already issued some tokens using this protocol and I cannot \nknow it. Unless you disclose it.\n\nThere is no \"special\" need to create small outputs. In order to send a \ntransaction containing tokens, you need to send a bitcoin transaction. \nThe bitcoin value will be transfered along with the token value. If you \nissue tokens with a token offering transactions (aka ICO), the value of \nthe bitcoin transferred to you is exactly the price of the tokens, so \nthere is no \"extra\" bitcoin value involved.\n\nI'm sorry if the example of the corporation is not clear. The idea was \nonly that Alice receives from the shareholders the bitcoin value, in \norder to use that same value to give back the tokens. There is no \ninterest. As I wrote, people got equity for \"time, money, furniture, \nknowledge\". I could simply write that Alice sends small outputs without \nreceiving the underlying bitcoin value beforehand.\n\nI agree that memorable names are great to social scalability. This is \nwhy you can use a vanity address or only the first part of the vanity \naddress to identify a token type.\n\nCheers,\n\nLuca\n\nOn 09/06/2017 07:24 PM, Dan Anderson wrote:\n> Hi Luca,\n>\n> Here are some comments...\n>\n> 1. This is clever, but it has a lot of \"gotchas\" that I think will work against its ability to scale socially. Especially, when you suggest that following the rules by memory/manually gains users the most advantage in terms of deniability.\n>\n> 2. The plausible deniability of this protocol is suspect as it would seem fairy apparent to a third party that it was being used. Vanity addresses, satoshis adding to tidy amounts, frequent \"consolidation\". Especially, when you make a mistake and perform actions to try again.\n>\n> 3. In your docs, when you say \"wallet\" do you mean a single Bitcoin address or do you mean an HD wallet? I become confused while reading. Address vs same wallet vs other wallet.\n>\n> 4. It's not clear to me how this protocol does not need verification nodes or some kind of node software to compute state.\n>\n> 5. I don't think it's a given that this design will cause less UTXOs. I could see people creating many small outputs as a result of trying to get the right amount of signal satoshis.\n>\n> 6. In your example of a corporation, it seems like people got equity for free. Why do they need to send 1 BTC at all, if they just get it back, plus interest?\n>\n> 7. I wouldn't underestimate the value of memorable names for social scalability.\n>\n> I will keep thinking about it, as the ICO portion is something I have been looking for ideas on and I have similar reservations about existing token protocols, so I hope these comments help you.\n>\n> ---------------------------------\n> Dan Anderson\n>"
            }
        ],
        "thread_summary": {
            "title": "Token Protocol Specification",
            "categories": [
                "bitcoin-dev",
                "BIP Proposal"
            ],
            "authors": [
                "Alex Kravets",
                "Luca Venturini",
                "Luke Dashjr"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 185230
        }
    },
    {
        "title": "[bitcoin-dev] Proposal: Extended serialization format for BIP-32 wallets",
        "thread_messages": [
            {
                "author": "Pavol Rusnak",
                "date": "2017-09-06T22:29:23",
                "message_text_only": "The discussion about changing bip32 version bytes for SegWit got me\nthinking and I ended up with what I think is the best proposal:\n\nhttps://github.com/satoshilabs/slips/blob/master/slip-0032.md\n\n(It is hosted in SL repo for now, but if there is will, I would love to\nhave this added to BIP repo as an extension to BIP32)\n\nFeel free to comment.\n\n-- \nBest Regards / S pozdravom,\n\nPavol \"stick\" Rusnak\nCTO, SatoshiLabs"
            },
            {
                "author": "Kabuto Samourai",
                "date": "2017-09-07T03:52:57",
                "message_text_only": "Thanks for the proposal. Aside from potential privacy implications of\nrevealing the derivation path for non BIP-44, 45, 49 HD nodes, this scheme\nis superior to the alternate {x,y,z}pub idea. Since coin_type is part of\nthe path, the 'xpub' prefix may be shared across all coins if they so\nchoose. This format provides lock-in for BIP-49 going forward and opens the\ndoor for a parallel native-SegWit BIP.\n\nThe birthday field is interesting. Could you provide some motivation for\nits inclusion?\n\nCould you also add some test vectors?\n\nThere are a few minor grammar / spelling errors, but we can nitpick those\nafter this goes to the pull request stage on bitcoin/bips.\n\nOn Wed, Sep 6, 2017 at 5:29 PM, Pavol Rusnak via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> The discussion about changing bip32 version bytes for SegWit got me\n> thinking and I ended up with what I think is the best proposal:\n>\n> https://github.com/satoshilabs/slips/blob/master/slip-0032.md\n>\n> (It is hosted in SL repo for now, but if there is will, I would love to\n> have this added to BIP repo as an extension to BIP32)\n>\n> Feel free to comment.\n>\n> --\n> Best Regards / S pozdravom,\n>\n> Pavol \"stick\" Rusnak\n> CTO, SatoshiLabs\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n\n-Kabuto\n\nPGP Fingerprint: 1A83 4A96 EDE7 E286 2C5A  B065 320F B934 A79B 6A99\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170906/de229129/attachment.html>"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2017-09-07T16:25:30",
                "message_text_only": "On 07/09/17 05:52, Kabuto Samourai wrote:\n> The birthday field is interesting. Could you provide some motivation for\n> its inclusion?\n\nBirthday is something SPV wallet developers have been wanting for years.\nIt helps them with the initial scan, so SPV wallet does not have to\ndownload every block in the blockchain, but only the ones after birthday.\n\n> Could you also add some test vectors?\n\nI will add some test vectors, when we agree this is the way to go.\n\n> There are a few minor grammar / spelling errors, but we can nitpick\n> those after this goes to the pull request stage on bitcoin/bips.\n\n+1\n\n-- \nBest Regards / S pozdravom,\n\nPavol \"stick\" Rusnak\nCTO, SatoshiLabs"
            },
            {
                "author": "Kabuto Samourai",
                "date": "2017-09-07T16:30:06",
                "message_text_only": "> Birthday\n\nWhy not make this block height, rather than a timestamp?\n\nOn Thu, Sep 7, 2017 at 11:25 AM, Pavol Rusnak <stick at satoshilabs.com> wrote:\n\n> On 07/09/17 05:52, Kabuto Samourai wrote:\n> > The birthday field is interesting. Could you provide some motivation for\n> > its inclusion?\n>\n> Birthday is something SPV wallet developers have been wanting for years.\n> It helps them with the initial scan, so SPV wallet does not have to\n> download every block in the blockchain, but only the ones after birthday.\n>\n> > Could you also add some test vectors?\n>\n> I will add some test vectors, when we agree this is the way to go.\n>\n> > There are a few minor grammar / spelling errors, but we can nitpick\n> > those after this goes to the pull request stage on bitcoin/bips.\n>\n> +1\n>\n> --\n> Best Regards / S pozdravom,\n>\n> Pavol \"stick\" Rusnak\n> CTO, SatoshiLabs\n>\n\n\n\n-- \n-Kabuto\n\nPGP Fingerprint: 1A83 4A96 EDE7 E286 2C5A  B065 320F B934 A79B 6A99\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/ac71a65b/attachment-0001.html>"
            },
            {
                "author": "Thomas Voegtlin",
                "date": "2017-09-07T04:29:32",
                "message_text_only": "On 07.09.2017 00:29, Pavol Rusnak via bitcoin-dev wrote:\n> The discussion about changing bip32 version bytes for SegWit got me\n> thinking and I ended up with what I think is the best proposal:\n> \n> https://github.com/satoshilabs/slips/blob/master/slip-0032.md\n> \n> (It is hosted in SL repo for now, but if there is will, I would love to\n> have this added to BIP repo as an extension to BIP32)\n> \n> Feel free to comment.\n> \n\n\nYour proposal forces wallets to use the derivation path in order to\ndetermine the type of output script. it will work only in the context of\nBIP43.\n\nTherefore, it should not be proposed as a BIP32 improvement, but as a\nimprovement of BIP43.\n\nA solution is still needed to wallets who do not wish to use BIP43"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2017-09-07T16:23:13",
                "message_text_only": "On 07/09/17 06:29, Thomas Voegtlin via bitcoin-dev wrote:\n> A solution is still needed to wallets who do not wish to use BIP43\n\nWhat if we added another byte field OutputType for wallets that do not\nfollow BIP43?\n\n0x00 - P2PKH output type\n0x01 - P2WPKH-in-P2SH output type\n0x02 - native Segwit output type\n\nWould that work for you?\n\nThe question is whether this field should be present only if depth==0x00\nor at all times. What is your suggestion, Thomas?\n\n-- \nBest Regards / S pozdravom,\n\nPavol \"stick\" Rusnak\nCTO, SatoshiLabs"
            },
            {
                "author": "Kabuto Samourai",
                "date": "2017-09-07T16:33:09",
                "message_text_only": "OutputType byte solution is nearly equivalent to {x,y,z} and adds redundant\ndata. Implementations could erroneously (maliciously) assign the wrong\noutput type for the given purpose field.\n\nWe could reduce the scope of this improvement to BIP43, as suggested by\nThomas. BIP32-generic wallets may implement something else.\n\nOn Thu, Sep 7, 2017 at 11:23 AM, Pavol Rusnak via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On 07/09/17 06:29, Thomas Voegtlin via bitcoin-dev wrote:\n> > A solution is still needed to wallets who do not wish to use BIP43\n>\n> What if we added another byte field OutputType for wallets that do not\n> follow BIP43?\n>\n> 0x00 - P2PKH output type\n> 0x01 - P2WPKH-in-P2SH output type\n> 0x02 - native Segwit output type\n>\n> Would that work for you?\n>\n> The question is whether this field should be present only if depth==0x00\n> or at all times. What is your suggestion, Thomas?\n>\n> --\n> Best Regards / S pozdravom,\n>\n> Pavol \"stick\" Rusnak\n> CTO, SatoshiLabs\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n\n-- \n-Kabuto\n\nPGP Fingerprint: 1A83 4A96 EDE7 E286 2C5A  B065 320F B934 A79B 6A99\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/e1d48d43/attachment-0001.html>"
            },
            {
                "author": "Andreas Schildbach",
                "date": "2017-09-07T19:35:49",
                "message_text_only": "On 09/07/2017 06:23 PM, Pavol Rusnak via bitcoin-dev wrote:\n> On 07/09/17 06:29, Thomas Voegtlin via bitcoin-dev wrote:\n>> A solution is still needed to wallets who do not wish to use BIP43\n> \n> What if we added another byte field OutputType for wallets that do not\n> follow BIP43?\n> \n> 0x00 - P2PKH output type\n> 0x01 - P2WPKH-in-P2SH output type\n> 0x02 - native Segwit output type\n> \n> Would that work for you?\n\nI think that would work.\n\n> The question is whether this field should be present only if depth==0x00\n> or at all times. What is your suggestion, Thomas?\n\nIn case of Bitcoin Wallet, the depth is not null (m/0'/[0,1]) and still\nwe need this field. I think it should always be present if a chain is\nlimited to a certain script type.\n\nThere is however the case where even on one chain, script types are\nmixed. In this case the field should be omitted and the wallet needs to\nscan for all (known) types. Afaik Bitcoin Core is taking this path."
            },
            {
                "author": "Pavol Rusnak",
                "date": "2017-09-07T20:00:05",
                "message_text_only": "On 07/09/17 21:35, Andreas Schildbach via bitcoin-dev wrote:\n> In case of Bitcoin Wallet, the depth is not null (m/0'/[0,1]) and still\n> we need this field.\n\nBut the depth of exported public key will be null. It does not make\nsense to export xpub for m or m/0' for your particular case.\n\n> I think it should always be present if a chain is\n> limited to a certain script type.\n\nI am fine with having the path there all the time.\n\n> There is however the case where even on one chain, script types are\n> mixed. In this case the field should be omitted and the wallet needs to\n> scan for all (known) types. Afaik Bitcoin Core is taking this path.\n\nIs that really the case? Why come up with a hierarchy and then don't use it?\n\n-- \nBest Regards / S pozdravom,\n\nPavol \"stick\" Rusnak\nCTO, SatoshiLabs"
            },
            {
                "author": "Thomas Voegtlin",
                "date": "2017-09-07T20:39:17",
                "message_text_only": "On 07.09.2017 18:23, Pavol Rusnak wrote:\n> On 07/09/17 06:29, Thomas Voegtlin via bitcoin-dev wrote:\n>> A solution is still needed to wallets who do not wish to use BIP43\n> \n> What if we added another byte field OutputType for wallets that do not\n> follow BIP43?\n> \n> 0x00 - P2PKH output type\n> 0x01 - P2WPKH-in-P2SH output type\n> 0x02 - native Segwit output type\n> \n> Would that work for you?\n> \n> The question is whether this field should be present only if depth==0x00\n> or at all times. What is your suggestion, Thomas?\n> \n\n\nwell, in my initial proposal, I wrote that this value should be user\nvisible. That is why I used version bytes. If you create an extra byte\nfield, and then use base58 or bech32 encoding, the value will not be\nuser visible anymore.\n\nThe initial implementation of segwit xpub/xprv in Electrum used a flag\nthat was not user visible (I added 1 to the bip32 version bytes, which\nleaves the xpub/xprv prefix unchanged). I have experimented with that\ninvisible flag for more than 6 months now, and I am now convinced that\nit is better to make that flag user visible.\n\nThe reason is that when users create wallets with multisig scripts, they\nneed to combine several master public keys. However, these master public\nkeys should all be of the same type: it would not make sense to create a\n2 of 3 multisig wallet with a one xpub, one ypub and one zpub. By\nimposing that all master keys are of the same type, we ensure that all\ncosigners agree on the script type that will be used to derive addresses.\n\nIn other words, if users are exposed to master keys and need to\nmanipulate them, it is better to let them see what they are doing.\n\nOTOH if you do not plan to expose your users to these keys, you probably\ndo not need a serialization format."
            },
            {
                "author": "Jonas Schnelli",
                "date": "2017-09-07T16:47:16",
                "message_text_only": "Thanks for the proposal.\n\nThree points it could see as possible improvements:\n\n1.\nFrom what I know, the exact birthday in seconds doesn\u2019t matter that much therefore it may be possible to just use 13 or 16bits to create a representation in week from 2009-01-09 00:00 UTC. 13bits would give you 157 years.\nAlways round down to the beginning of the week when the key was created.\nBut not sure if it\u2019s worth to save ~two bytes for that.\nAlso not sure if the key-birthday in seconds could have a security or privacy implication (week maybe better).\n\n2.\nWould it make sense to have special depth bytes that directly implies it\u2019s a BIP44 master key (and therefore avoid the bip32 path serialisation)? I know some \u201ecentralised\u201c table need to be available for that which may be not a good idea. But maybe the BIP could reserve a couple of depth-bytes (maybe 0xF0 to 0xFF) for predefined paths.\n\n3.\nWould adding a version bit make sense to allow future extensions?\n\n\n/jonas\n\n\n> Am 06.09.2017 um 15:29 schrieb Pavol Rusnak via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>:\n> \n> The discussion about changing bip32 version bytes for SegWit got me\n> thinking and I ended up with what I think is the best proposal:\n> \n> https://github.com/satoshilabs/slips/blob/master/slip-0032.md\n> \n> (It is hosted in SL repo for now, but if there is will, I would love to\n> have this added to BIP repo as an extension to BIP32)\n> \n> Feel free to comment.\n> \n> --\n> Best Regards / S pozdravom,\n> \n> Pavol \"stick\" Rusnak\n> CTO, SatoshiLabs\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/01c4fef5/attachment.sig>"
            },
            {
                "author": "Peter Todd",
                "date": "2017-09-07T18:09:02",
                "message_text_only": "On Thu, Sep 07, 2017 at 09:47:16AM -0700, Jonas Schnelli via bitcoin-dev wrote:\n> Thanks for the proposal.\n> \n> Three points it could see as possible improvements:\n> \n> 1.\n> From what I know, the exact birthday in seconds doesn\u2019t matter that much therefore it may be possible to just use 13 or 16bits to create a representation in week from 2009-01-09 00:00 UTC. 13bits would give you 157 years.\n> Always round down to the beginning of the week when the key was created.\n> But not sure if it\u2019s worth to save ~two bytes for that.\n> Also not sure if the key-birthday in seconds could have a security or privacy implication (week maybe better).\n\nNote how private key birthday is a potential privacy issue in certain cases.\nRare of course, because usually you don't release your private keys! But users\nwill on occasion have those keys be compromised.\n\nPersonally, I'd advocate rounding down to month-level resolution, as that\nshould be both enough to handle any likely reorg scenario, and it's still a\nprecision that won't add much extra scanning ot any reasonably old (~1yr)\nwallet.\n\nNote also how if transactions created with private keys in a seed use\nnLockTime, you can ensure coins won't exist in a block older than the seed\nbirthday by simply ensuring that nLockTime is set to a more recent date then\nthat birthday under all circumstances.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/08ad4b1a/attachment.sig>"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2017-09-07T18:38:37",
                "message_text_only": "On 07/09/17 18:47, Jonas Schnelli wrote:\n> But not sure if it\u2019s worth to save ~two bytes for that.\n\nI think it's not worth complicating the field just to save two bytes.\n\nBut if we agree (for privacy reasons) that resolution of this field\nshould be reduced to week-level (as suggested by Jonas) or month-level\n(as sugested by Peter), we could use just 16 bits for this.\n\nTBH I think TREZOR will provide hardcoded constant for this field\n(1.1.2014 for all its P2PKH xpubs and 1.8.2017 for all its\nP2WPKH-in-P2SH xpubs). So no privacy is lost in this case, but if we\nwant to ENFORCE this on BIP level, we should decrease the resolution.\n\n> 2.\n> Would it make sense to have special depth bytes that directly implies it\u2019s a BIP44 master key (and therefore avoid the bip32 path serialisation)? I know some \u201ecentralised\u201c table need to be available for that which may be not a good idea. But maybe the BIP could reserve a couple of depth-bytes (maybe 0xF0 to 0xFF) for predefined paths.\n\nI think this is exactly what Thomas meant by \"wallet developers are\ngoing to use dirtier tricks\" in his email, that's why I specifically\ntried to avoid this. I see no good reason to do this, unless we want to\nsave some bytes and I don't think we are in need of doing this.\n\n> 3.\n> Would adding a version bit make sense to allow future extensions?\n\nI think changing the human-readable part is the way to go. That way the\nwallet can immediately say if it understands the format or not, without\nparsing the binary data contents. Version bits were introduced in older\nstandards, because there was no such thing as human-readable prefix.\n\n-- \nBest Regards / S pozdravom,\n\nPavol \"stick\" Rusnak\nCTO, SatoshiLabs\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/1bdc5fe7/attachment.sig>"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2017-09-07T16:37:19",
                "message_text_only": "On 07/09/17 18:30, Kabuto Samourai wrote:\n> Why not make this block height, rather than a timestamp?\n\nBlockheight depends on the chain. XPUB is not tied to particular\nchain/coin.\n\nAlso there are already cryptocurrencies that do not use blockchain, but\ndirected acyclic graph (DAG) for storing transactions. So it would not\nbe obvious what number to use as a blockheight.\n\nOTOH all blockchains contain timestamps in their blocks, so we can use that.\n\n-- \nBest Regards / S pozdravom,\n\nPavol \"stick\" Rusnak\nCTO, SatoshiLabs"
            },
            {
                "author": "Peter Todd",
                "date": "2017-09-07T18:02:56",
                "message_text_only": "On Thu, Sep 07, 2017 at 06:37:19PM +0200, Pavol Rusnak via bitcoin-dev wrote:\n> On 07/09/17 18:30, Kabuto Samourai wrote:\n> > Why not make this block height, rather than a timestamp?\n> \n> Blockheight depends on the chain. XPUB is not tied to particular\n> chain/coin.\n> \n> Also there are already cryptocurrencies that do not use blockchain, but\n> directed acyclic graph (DAG) for storing transactions. So it would not\n> be obvious what number to use as a blockheight.\n> \n> OTOH all blockchains contain timestamps in their blocks, so we can use that.\n\nMore to the point, even for the blockchains that don't contain timestamps in\ntheir blocks, their blocks do exist in our spacetime continum and thus are\ncreated at a specific point in time. :)\n\nIf someone does however come up with an example of a blockchain that does not\noccupy our spacetime continum, I'd love to hear about it!\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/313a6629/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Proposal: Extended serialization format for BIP-32 wallets",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Thomas Voegtlin",
                "Kabuto Samourai",
                "Andreas Schildbach",
                "Pavol Rusnak",
                "Peter Todd",
                "Jonas Schnelli"
            ],
            "messages_count": 15,
            "total_messages_chars_count": 17476
        }
    },
    {
        "title": "[bitcoin-dev] Merkle branch verification & tail-call semantics for generalized MAST",
        "thread_messages": [
            {
                "author": "Mark Friedenbach",
                "date": "2017-09-07T00:38:55",
                "message_text_only": "I would like to propose two new script features to be added to the\nbitcoin protocol by means of soft-fork activation. These features are\na new opcode, MERKLE-BRANCH-VERIFY (MBV) and tail-call execution\nsemantics.\n\nIn brief summary, MERKLE-BRANCH-VERIFY allows script authors to force\nredemption to use values selected from a pre-determined set committed\nto in the scriptPubKey, but without requiring revelation of unused\nelements in the set for both enhanced privacy and smaller script\nsizes. Tail-call execution semantics allows a single level of\nrecursion into a subscript, providing properties similar to P2SH while\nat the same time more flexible.\n\nThese two features together are enough to enable a range of\napplications such as tree signatures (minus Schnorr aggregation) as\ndescribed by Pieter Wuille [1], and a generalized MAST useful for\nconstructing private smart contracts. It also brings privacy and\nfungibility improvements to users of counter-signing wallet/vault\nservices as unique redemption policies need only be revealed if/when\nexceptional circumstances demand it, leaving most transactions looking\nthe same as any other MAST-enabled multi-sig script.\n\nI believe that the implementation of these features is simple enough,\nand the use cases compelling enough that we could BIP 8/9 rollout of\nthese features in relatively short order, perhaps before the end of\nthe year.\n\nI have written three BIPs to describe these features, and their\nassociated implementation, for which I now invite public review and\ndiscussion:\n\nFast Merkle Trees\nBIP: https://gist.github.com/maaku/41b0054de0731321d23e9da90ba4ee0a\nCode: https://github.com/maaku/bitcoin/tree/fast-merkle-tree\n\nMERKLEBRANCHVERIFY\nBIP: https://gist.github.com/maaku/bcf63a208880bbf8135e453994c0e431\nCode: https://github.com/maaku/bitcoin/tree/merkle-branch-verify\n\nTail-call execution semantics\nBIP: https://gist.github.com/maaku/f7b2e710c53f601279549aa74eeb5368\nCode: https://github.com/maaku/bitcoin/tree/tail-call-semantics\n\nNote: I have circulated this idea privately among a few people, and I\nwill note that there is one piece of feedback which I agree with but\nis not incorporated yet: there should be a multi-element MBV opcode\nthat allows verifying multiple items are extracted from a single\ntree. It is not obvious how MBV could be modified to support this\nwithout sacrificing important properties, or whether should be a\nseparate multi-MBV opcode instead.\n\nKind regards,\nMark Friedenbach"
            },
            {
                "author": "Johnson Lau",
                "date": "2017-09-08T09:21:22",
                "message_text_only": "Some comments with the tail-call execution semantics BIP:\n\nTail-call execution semantics require \u201cunclean stake\u201d, i.e. final stake with more than one item. However, \u201cunclean stake\u201d is invalid (not just non-standard) in BIP141, so you could only use it with legacy P2SH (which is totally pointless\u2026.). A different design like OP_EVAL might be needed, or you need a new witness script version.\n\nI think you have also missed the sigOp counting of the executed script. As you can\u2019t count it without executing the script, the current static analysability is lost. This was one of the reasons for OP_EVAL being rejected. Since sigOp is a per-block limit, any OP_EVAL-like operation means block validity will depend on the precise outcome of script execution (instead of just pass or fail), which is a layer violation.\n\n(An alternative is to make sigOp a per-input limit instead of per-block limit, just like the 201 nOp limit. But this is a very different security model)\n\nWitness script versioning is by design fully compatible with P2SH and BIP173, so there will be no hurdle for existing wallets to pay to BIP114. Actually it should be completely transparent to them.\n\nFor code complexity, the minimal BIP114 could be really simple, like <30 lines of code? It looks complex now because it does much more than simply hiding scripts in a hash.\n\n\n\n> On 7 Sep 2017, at 8:38 AM, Mark Friedenbach via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> I would like to propose two new script features to be added to the\n> bitcoin protocol by means of soft-fork activation. These features are\n> a new opcode, MERKLE-BRANCH-VERIFY (MBV) and tail-call execution\n> semantics.\n> \n> In brief summary, MERKLE-BRANCH-VERIFY allows script authors to force\n> redemption to use values selected from a pre-determined set committed\n> to in the scriptPubKey, but without requiring revelation of unused\n> elements in the set for both enhanced privacy and smaller script\n> sizes. Tail-call execution semantics allows a single level of\n> recursion into a subscript, providing properties similar to P2SH while\n> at the same time more flexible.\n> \n> These two features together are enough to enable a range of\n> applications such as tree signatures (minus Schnorr aggregation) as\n> described by Pieter Wuille [1], and a generalized MAST useful for\n> constructing private smart contracts. It also brings privacy and\n> fungibility improvements to users of counter-signing wallet/vault\n> services as unique redemption policies need only be revealed if/when\n> exceptional circumstances demand it, leaving most transactions looking\n> the same as any other MAST-enabled multi-sig script.\n> \n> I believe that the implementation of these features is simple enough,\n> and the use cases compelling enough that we could BIP 8/9 rollout of\n> these features in relatively short order, perhaps before the end of\n> the year.\n> \n> I have written three BIPs to describe these features, and their\n> associated implementation, for which I now invite public review and\n> discussion:\n> \n> Fast Merkle Trees\n> BIP: https://gist.github.com/maaku/41b0054de0731321d23e9da90ba4ee0a\n> Code: https://github.com/maaku/bitcoin/tree/fast-merkle-tree\n> \n> MERKLEBRANCHVERIFY\n> BIP: https://gist.github.com/maaku/bcf63a208880bbf8135e453994c0e431\n> Code: https://github.com/maaku/bitcoin/tree/merkle-branch-verify\n> \n> Tail-call execution semantics\n> BIP: https://gist.github.com/maaku/f7b2e710c53f601279549aa74eeb5368\n> Code: https://github.com/maaku/bitcoin/tree/tail-call-semantics\n> \n> Note: I have circulated this idea privately among a few people, and I\n> will note that there is one piece of feedback which I agree with but\n> is not incorporated yet: there should be a multi-element MBV opcode\n> that allows verifying multiple items are extracted from a single\n> tree. It is not obvious how MBV could be modified to support this\n> without sacrificing important properties, or whether should be a\n> separate multi-MBV opcode instead.\n> \n> Kind regards,\n> Mark Friedenbach\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-09-12T02:03:42",
                "message_text_only": "My apologies for a delay in responding to emails on this list; I have\nbeen fighting a cold.\n\n(Also my apologies to Johnson Lau, as I forgot to forward this to the list.)\n\nOn Sep 8, 2017, at 2:21 AM, Johnson Lau <jl2012 at xbt.hk> wrote:\n\n> Tail-call execution semantics require \"unclean stake\" , i.e. final\n> stake with more than one item. However, \"unclean stake\" is invalid\n> (not just non-standard) in BIP141, so you could only use it with\n> legacy P2SH (which is totally pointless....). A different design\n> like OP_EVAL might be needed, or you need a new witness script\n> version.\n\nI believe you meant \"unclean stack,\" and you are correct. This was\nalso pointed out last tuesday by a participant at the in-person\nCoreDev meetup where the idea was presented.\n\nThis doesn't kill the idea, it just complicates the implementation\nslightly. A simple fix would be to allow tail-recursion to occur if\nthe stack is not clean (as can happen with legacy P2SH as you point\nout, or yet to be defined version 1+ forms of segwit script), OR if\nthere is a single item on the stack and the alt-stack is not empty.\nFor segwit v0 scripts you then have to move any arguments to the alt\nstack before ending the redeem script, leaving just the policy script\non the main stack.\n\n> I think you have also missed the sigOp counting of the executed\n> script. As you can't count it without executing the script, the\n> current static analysability is lost. This was one of the reasons\n> for OP_EVAL being rejected. Since sigOp is a per-block limit, any\n> OP_EVAL-like operation means block validity will depend on the\n> precise outcome of script execution (instead of just pass or fail),\n> which is a layer violation.\n\nI disagree with this design requirement.\n\nThe SigOp counting method used by bitcoin is flawed. It incorrectly\nlimits not the number of signature operations necessary to validate a\nblock, but rather the number of CHECKSIGs potentially encountered in\nscript execution, even if in an unexecuted branch. (Admitedly MAST\nmakes this less of an issue, but there are still useful compact\nscripts that use if/else constructs to elide a CHECKSIG.) Nor will it\naccount for aggregation when that feature is added, or properly\ndifferentiate between signature operations that can be batched and\nthose that can not.\n\nAdditionally there are other resources used by script that should be\nglobally limited, such as hash operations, which are not accounted for\nat this time and cannot be statically assessed, even by the flawed\nmechanism by which SigOps are counted. I have maintained for some time\nthat bitcoin should move from having multiple separate global limits\n(weight and sigops, hashed bytes in XT/Classic/BCH) to a single linear\nmetric that combines all of these factors with appropriate\ncoefficients.\n\nA better way of handling this problem, which works for both SigOps and\nHashOps, is to have the witness commit to the maximum resources\nconsumed by validation of the spend of the coin, to relay this data\nwith the transaction and include it in the SigHash, and to use the\ncommitted maximum for block validation. This could be added in a\nfuture script version upgrade. This change would also resolve the\nissue that led to the clean stack rule in segwit, allowing future\nversions of script to use tail-call recursion without involving the\nalt-stack.\n\nNevertheless it is constructive feedback that the current draft of the\nBIP and its implementation do not count SigOps, at all. There are a\ncouple of ways this can be fixed by evaluating the top-level script\nand then doing static analysis of the resulting policy script, or by\nrunning the script and counting operations actually performed.\n\nAdditionally, it is possible that we take this time to re-evaluate\nwhether we should be counting SigOps other than for legacy consensus\nrule compliance. The speed of verification in secp256k1 has made\nsignature operations no longer the chief concern in block validation\ntimes.\n\n> Witness script versioning is by design fully compatible with P2SH\n> and BIP173, so there will be no hurdle for existing wallets to pay\n> to BIP114. Actually it should be completely transparent to them.\n\nThis is correct. Your feedback will be incorporated.\n\n> For code complexity, the minimal BIP114 could be really simple, like\n> <30 lines of code? It looks complex now because it does much more\n> than simply hiding scripts in a hash.\n\nIs there a repo that contains the latest implementation of BIP 114,\nfor comparison purposes?\n\nKind regards,\nMark Friedenbach"
            },
            {
                "author": "Bryan Bishop",
                "date": "2017-09-12T02:13:24",
                "message_text_only": "On Mon, Sep 11, 2017 at 9:03 PM, Mark Friedenbach via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> I believe you meant \"unclean stack,\" and you are correct. This was\n> also pointed out last tuesday by a participant at the in-person\n> CoreDev meetup where the idea was presented.\n\nhttp://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2017-09-07-merkleized-abstract-syntax-trees/\n\n> > For code complexity, the minimal BIP114 could be really simple, like\n> > <30 lines of code? It looks complex now because it does much more\n> > than simply hiding scripts in a hash.\n>\n> Is there a repo that contains the latest implementation of BIP 114,\n> for comparison purposes?\n\noriginal bip114:\nhttps://github.com/bitcoin/bips/blob/775f26c02696e772dac4060aa092d35dedbc647c/bip-0114.mediawiki\nrevised bip114: https://github.com/jl2012/bips/blob/vault/bip-0114.mediawiki\nhttps://github.com/jl2012/bitcoin/commits/vault\nfrom https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/014963.html\n\n- Bryan\nhttp://heybryan.org/\n1 512 203 0507"
            },
            {
                "author": "Johnson Lau",
                "date": "2017-09-12T08:55:59",
                "message_text_only": "> On 12 Sep 2017, at 10:03 AM, Mark Friedenbach <mark at friedenbach.org> wrote:\n> \n> My apologies for a delay in responding to emails on this list; I have\n> been fighting a cold.\n> \n> (Also my apologies to Johnson Lau, as I forgot to forward this to the list.)\n> \n> On Sep 8, 2017, at 2:21 AM, Johnson Lau <jl2012 at xbt.hk> wrote:\n> \n>> Tail-call execution semantics require \"unclean stake\" , i.e. final\n>> stake with more than one item. However, \"unclean stake\" is invalid\n>> (not just non-standard) in BIP141, so you could only use it with\n>> legacy P2SH (which is totally pointless....). A different design\n>> like OP_EVAL might be needed, or you need a new witness script\n>> version.\n> \n> I believe you meant \"unclean stack,\" and you are correct. This was\n> also pointed out last tuesday by a participant at the in-person\n> CoreDev meetup where the idea was presented.\n> \n> This doesn't kill the idea, it just complicates the implementation\n> slightly. A simple fix would be to allow tail-recursion to occur if\n> the stack is not clean (as can happen with legacy P2SH as you point\n> out, or yet to be defined version 1+ forms of segwit script), OR if\n> there is a single item on the stack and the alt-stack is not empty.\n> For segwit v0 scripts you then have to move any arguments to the alt\n> stack before ending the redeem script, leaving just the policy script\n> on the main stack.\n\nThis is ugly and actually broken, as different script path may require different number of stack items, so you don\u2019t know how many OP_TOALTSTACK do you need. Easier to just use a new witness version\n\n> \n>> I think you have also missed the sigOp counting of the executed\n>> script. As you can't count it without executing the script, the\n>> current static analysability is lost. This was one of the reasons\n>> for OP_EVAL being rejected. Since sigOp is a per-block limit, any\n>> OP_EVAL-like operation means block validity will depend on the\n>> precise outcome of script execution (instead of just pass or fail),\n>> which is a layer violation.\n> \n> I disagree with this design requirement.\n> \n> The SigOp counting method used by bitcoin is flawed. It incorrectly\n> limits not the number of signature operations necessary to validate a\n> block, but rather the number of CHECKSIGs potentially encountered in\n> script execution, even if in an unexecuted branch. (Admitedly MAST\n> makes this less of an issue, but there are still useful compact\n> scripts that use if/else constructs to elide a CHECKSIG.) Nor will it\n> account for aggregation when that feature is added, or properly\n> differentiate between signature operations that can be batched and\n> those that can not.\n> \n> Additionally there are other resources used by script that should be\n> globally limited, such as hash operations, which are not accounted for\n> at this time and cannot be statically assessed, even by the flawed\n> mechanism by which SigOps are counted. I have maintained for some time\n> that bitcoin should move from having multiple separate global limits\n> (weight and sigops, hashed bytes in XT/Classic/BCH) to a single linear\n> metric that combines all of these factors with appropriate\n> coefficients.\n> \n\nI like the idea to have an unified global limit and suggested a way to do it (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-January/013472.html). But I think this is off-topic here.\n\n\n\n> A better way of handling this problem, which works for both SigOps and\n> HashOps, is to have the witness commit to the maximum resources\n> consumed by validation of the spend of the coin, to relay this data\n> with the transaction and include it in the SigHash, and to use the\n> committed maximum for block validation. This could be added in a\n> future script version upgrade. This change would also resolve the\n> issue that led to the clean stack rule in segwit, allowing future\n> versions of script to use tail-call recursion without involving the\n> alt-stack.\n> \n> Nevertheless it is constructive feedback that the current draft of the\n> BIP and its implementation do not count SigOps, at all. There are a\n> couple of ways this can be fixed by evaluating the top-level script\n> and then doing static analysis of the resulting policy script, or by\n> running the script and counting operations actually performed.\n\n\nIn any case, I think maintaining static analysability for global limit(s) is very important. Ethereum had to give up their DAO softfork plan at the last minute, exactly due to the lack of this: http://hackingdistributed.com/2016/06/28/ethereum-soft-fork-dos-vector/\n\nOtherwise, one could attack relay and mining nodes by sending many small size txs with many sigops, forcing them to validate, and discard due to insufficient fees.\n\nTechnically it might be ok if we commit the total validation cost (sigop + hashop + whatever) as the first witness stack item, but that\u2019d take more space and I\u2019m not sure if it is desirable. Anyway, giving up static analysability for scripts is a fundamental change to our existing model.\n\n> \n> Additionally, it is possible that we take this time to re-evaluate\n> whether we should be counting SigOps other than for legacy consensus\n> rule compliance. The speed of verification in secp256k1 has made\n> signature operations no longer the chief concern in block validation\n> times.\n\nWithout the limit I think we would be DoS-ed to dead\n\n\n>> Witness script versioning is by design fully compatible with P2SH\n>> and BIP173, so there will be no hurdle for existing wallets to pay\n>> to BIP114. Actually it should be completely transparent to them.\n> \n> This is correct. Your feedback will be incorporated.\n> \n>> For code complexity, the minimal BIP114 could be really simple, like\n>> <30 lines of code? It looks complex now because it does much more\n>> than simply hiding scripts in a hash.\n> \n> Is there a repo that contains the latest implementation of BIP 114,\n> for comparison purposes?\n\n\nYou can find it here: https://github.com/jl2012/bitcoin/commits/vault\nhttps://github.com/jl2012/bitcoin/commit/f3f201d232d3995db38e09b171e4d1dea8d04ad2\n\nBut this does more than your proposal as it allows users adding extra scripts when spending a coin. The rationale is described in the revised BIP114:\nhttps://github.com/jl2012/bips/blob/vault/bip-0114.mediawiki#Additional_scripts_in_witness\n\nSo to make it functionally comparable with your proposal, the IsMSV0Stack() function is not needed. The new 249-254 lines in interpreter.cpp could be removed. The new 1480-1519 lines could be replaced by a few lines copied from the existing P2WSH code. I can make a minimal version if you want to see how it looks like\n\n\n> \n> Kind regards,\n> Mark Friedenbach\n>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-09-12T19:57:10",
                "message_text_only": "On Sep 12, 2017, at 1:55 AM, Johnson Lau <jl2012 at xbt.hk> wrote:\n\n> This is ugly and actually broken, as different script path may\n> require different number of stack items, so you don't know how many\n> OP_TOALTSTACK do you need. Easier to just use a new witness version\n\nDEPTH makes this relatively easy to do. Just repeat the following for\nthe maximum number of stack elements that might be used:\n\n  DEPTH 1SUB IF SWAP TOALTSTACK ENDIF\n\nThere are probably more compact alternatives.\n\nUsing a new script version is easier, but not faster. There's a number\nof things that might be fixed in a v1 upgrade, and various design\ndecisions to sort out regarding specification of a witness version\n(version in the witness rather than the scriptPubKey).\n\nTree signatures and MAST are immediately useful to many services,\nhowever, and I would hate to delay usage by six months to a year or\nmore by serializing dependencies instead of doing them in parallel.\n\n> Otherwise, one could attack relay and mining nodes by sending many\n> small size txs with many sigops, forcing them to validate, and\n> discard due to insufficient fees.\n>\n> Technically it might be ok if we commit the total validation cost\n> (sigop + hashop + whatever) as the first witness stack item\n\nThat is what I'm suggesting. And yes, there are changes that would\nhave to be made to the p2p layer and transaction processing to handle\nthis safely. I'm arguing that the cost of doing so is worth it, and a\nbetter path forward.\n\n> Without the limit I think we would be DoS-ed to dead\n\n4MB of secp256k1 signatures takes 10s to validate on my 5 year old\nlaptop (125,000 signatures, ignoring public keys and other things that\nwould consume space). That's much less than bad blocks that can be\nconstructed using other vulnerabilities.\n\n> So to make it functionally comparable with your proposal, the\n> IsMSV0Stack() function is not needed. The new 249-254 lines in\n> interpreter.cpp could be removed. The new 1480-1519 lines could be\n> replaced by a few lines copied from the existing P2WSH code. I can\n> make a minimal version if you want to see how it looks like\n\nThat's alright, I don't think it's necessary to purposefully restrict\none to compare them head to head with the same features. They are\ndifferent proposals with different pros and cons.\n\nKind regards,\nMark Friedenbach"
            },
            {
                "author": "Karl Johan Alm",
                "date": "2017-09-12T23:27:36",
                "message_text_only": "On Wed, Sep 13, 2017 at 4:57 AM, Mark Friedenbach via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> Without the limit I think we would be DoS-ed to dead\n>\n> 4MB of secp256k1 signatures takes 10s to validate on my 5 year old\n> laptop (125,000 signatures, ignoring public keys and other things that\n> would consume space). That's much less than bad blocks that can be\n> constructed using other vulnerabilities.\n\nSidenote-ish, but I also believe it would be fairly trivial to keep a\nper UTXO tally and demand additional fees when trying to respend a\nUTXO which was previously \"spent\" with an invalid op count. I.e. if\nyou sign off on an input for a tx that you know is bad, the UTXO in\nquestion will be penalized proportionately to the wasted ops when\nincluded in another transaction later. That would probably kill that\nDoS attack as the attacker would effectively lose bitcoin every time,\neven if it was postponed until they spent the UTXO. The only thing\nclients would need to do is to add a fee rate penalty ivar and a\nmapping of outpoint to penalty value, probably stored as a separate\n.dat file. I think."
            },
            {
                "author": "Peter Todd",
                "date": "2017-09-13T09:41:07",
                "message_text_only": "On Wed, Sep 13, 2017 at 08:27:36AM +0900, Karl Johan Alm via bitcoin-dev wrote:\n> On Wed, Sep 13, 2017 at 4:57 AM, Mark Friedenbach via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >> Without the limit I think we would be DoS-ed to dead\n> >\n> > 4MB of secp256k1 signatures takes 10s to validate on my 5 year old\n> > laptop (125,000 signatures, ignoring public keys and other things that\n> > would consume space). That's much less than bad blocks that can be\n> > constructed using other vulnerabilities.\n> \n> Sidenote-ish, but I also believe it would be fairly trivial to keep a\n> per UTXO tally and demand additional fees when trying to respend a\n> UTXO which was previously \"spent\" with an invalid op count. I.e. if\n> you sign off on an input for a tx that you know is bad, the UTXO in\n> question will be penalized proportionately to the wasted ops when\n> included in another transaction later. That would probably kill that\n> DoS attack as the attacker would effectively lose bitcoin every time,\n> even if it was postponed until they spent the UTXO. The only thing\n> clients would need to do is to add a fee rate penalty ivar and a\n> mapping of outpoint to penalty value, probably stored as a separate\n> .dat file. I think.\n\nEthereum does something quite like this; it's a very bad idea for a few\nreasons:\n\n1) If you bailed out of verifying a script due to wasted ops, how did you know the\ntransaction trying to spend that txout did in fact come from the owner of it?\n\n2) How do you verify that transactions were penalized correctly without *all*\nnodes re-running the DoS script?\n\n3) If the DoS is significant enough to matter on a per-node level, you're going\nto have serious problems anyway, quite possibly so serious that the attacker\nmanages to cause consensus to fail. They can then spend the txouts in a block\nthat does *not* penalize their outputs, negating the deterrent.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170913/fe142009/attachment.sig>"
            },
            {
                "author": "Ad\u00e1n S\u00e1nchez de Pedro Crespo",
                "date": "2017-09-11T20:37:55",
                "message_text_only": "Coincidentally, the kind of Merkle tree that Mark describes in his\nproposal is exactly the one that we use at Stampery.\n\nThe Stampery BTA whitepaper[1] includes pseudocode for many of the\nalgorithms outlined by this proposal, including fast-SHA256, the tree\nbuilding process and the inclusion proving routine.\n\nThe wording is slightly different but the logic is just the same, so I\nhope it helps future implementations in case of eventual adoption.\n\n\n[1]\nhttps://s3.amazonaws.com/stampery-cdn/docs/Stampery-BTA-v6-whitepaper.pdf\n\n\nBest,\n-- \nAd\u00e1n S\u00e1nchez de Pedro Crespo\nCTO, Stampery Inc.\nSan Francisco - Madrid\nT: +34 663 163 375\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170911/bcc880d1/attachment-0001.sig>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-09-19T00:46:30",
                "message_text_only": "As some of you may know, the MAST proposal I sent to the mailing list\non September 6th was discussed that the in-person CoreDev meetup in\nSan Francisco. In this email I hope to summarize the outcome of that\ndiscussion. As chatham house rules were in effect, I will refrain from\nattributing names to this summary..\n\n* An introductory overview of the BIPs was presented, for the purpose\n  of familiarizing the audience with what they are attempting to\n  accomplish and how they do so.\n\n* There was a discussion of a single vs multi-element MBV opcode. It\n  was put forward that there should perhaps be different opcodes for\n  the sake of script analysis, since a multi-element MBV will\n  necessarily consume a variable number of inputs. However it was\n  countered that if the script encodes the number of elements as an\n  integer push to the top of the stack immediately before the opcode,\n  then static analyzability is maintained in such instances. I took\n  the action item to investigate what an ideal serialization format\n  would be for a multi-element proof, which is the only thing holding\n  back a multi-element MBV proposal.\n\n* It was pointed out that the non-clean-stack tail-call semantics is\n  not compatible with segwit's consensus-enforcement of the clean\n  stack rule. Some alternatives were suggested, such as changing\n  deployment mechanisms. After the main discussion session it was\n  observed that tail-call semantics could still be maintained if the\n  alt stack is used for transferring arguments to the policy script. I\n  will be updating the BIP and example implementation accordingly.\n\n* The observation was made that single-layer tail-call semantics can\n  be thought of as really being P2SH with user-specified hashing. If\n  the P2SH script template had been constructed slightly differently\n  such as to not consume the script, it would even have been fully\n  compatible with tail-call semantics.\n\n* It was mentioned that using script versioning to deploy a MAST\n  template allows for saving 32 bytes of witness per input, as the\n  root hash is contained directly in the output being spent. The\n  downside however is losing the permissionless innovation that comes\n  with a programmable hashing mechanism.\n\n* The discussion generally drifted into a wider discussion about\n  script version upgrades and related issues, such as whether script\n  versions should exist in the witness as well, and the difference in\n  meaning between the two. This is an important subject, but only of\n  relevance in far as using a script version upgrade to deploy MAST\n  would add significant delay from having to sort through these issues\n  first.\n\nThis feedback led to some minor tweaks to the proposal, which I will\nbe making, as well as the major feature request of a multi-element\nMERKLE-BLOCK-VERIFY opcode which requires a little bit more effort to\naccomplish. I will report back to this list again when that work is\ndone.\n\nSincerely,\nMark Friedenbach"
            },
            {
                "author": "Luke Dashjr",
                "date": "2017-09-30T23:23:32",
                "message_text_only": "On Thursday 07 September 2017 12:38:55 AM Mark Friedenbach via bitcoin-dev \nwrote:\n> Tail-call execution semantics\n> BIP: https://gist.github.com/maaku/f7b2e710c53f601279549aa74eeb5368\n> Code: https://github.com/maaku/bitcoin/tree/tail-call-semantics\n\nJust noticed this doesn't count sigops toward the block sigop limit.\nIs that really safe? How long would it take, to verify a malicious block with \nonly inputs such that there is nearly 4 MB of sigops?\n\n(I do already understand the difficulty in supporting the sigop limit.)\n\nLuke"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-09-30T23:51:49",
                "message_text_only": "10s of seconds if no further restrictions are placed. It would be trivial to include a new per input rule that reduces it to ~1s without cutting off any non-attack script (require sigops per input to be limited to witness/sig size). secp256k1 is now fast enough that we don\u2019t need a separate sigop limit.\n\n> On Sep 30, 2017, at 4:23 PM, Luke Dashjr <luke at dashjr.org> wrote:\n> \n> On Thursday 07 September 2017 12:38:55 AM Mark Friedenbach via bitcoin-dev \n> wrote:\n>> Tail-call execution semantics\n>> BIP: https://gist.github.com/maaku/f7b2e710c53f601279549aa74eeb5368\n>> Code: https://github.com/maaku/bitcoin/tree/tail-call-semantics\n> \n> Just noticed this doesn't count sigops toward the block sigop limit.\n> Is that really safe? How long would it take, to verify a malicious block with \n> only inputs such that there is nearly 4 MB of sigops?\n> \n> (I do already understand the difficulty in supporting the sigop limit.)\n> \n> Luke"
            }
        ],
        "thread_summary": {
            "title": "Merkle branch verification & tail-call semantics for generalized MAST",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Bryan Bishop",
                "Ad\u00e1n S\u00e1nchez de Pedro Crespo",
                "Peter Todd",
                "Johnson Lau",
                "Luke Dashjr",
                "Mark Friedenbach",
                "Karl Johan Alm"
            ],
            "messages_count": 12,
            "total_messages_chars_count": 29964
        }
    },
    {
        "title": "[bitcoin-dev] cleanstack alt stack & softfork improvements (Was: Merkle branch verification & tail-call semantics for generalized MAST)",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2017-09-19T03:09:08",
                "message_text_only": "On Tuesday 19 September 2017 12:46:30 AM Mark Friedenbach via bitcoin-dev \nwrote:\n> After the main discussion session it was observed that tail-call semantics\n> could still be maintained if the alt stack is used for transferring\n> arguments to the policy script.\n\nIsn't this a bug in the cleanstack rule?\n\n(Unrelated...)\n\nAnother thing that came up during the discussion was the idea of replacing all \nthe NOPs and otherwise-unallocated opcodes with a new OP_RETURNTRUE \nimplementation, in future versions of Script. This would immediately exit the \nprogram (perhaps performing some semantic checks on the remainder of the \nScript) with a successful outcome.\n\nThis is similar to CVE-2010-5141 in a sense, but since signatures are no \nlonger Scripts themselves, it shouldn't be exploitable.\n\nThe benefit of this is that it allows softforking in ANY new opcode, not only \nthe -VERIFY opcode variants we've been doing. That is, instead of merely \nterminating the Script with a failure, the new opcode can also remove or push \nstack items. This is because old nodes, upon encountering the undefined \nopcode, will always succeed immediately, allowing the new opcode to do \nliterally anything from that point onward.\n\nLuke"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-09-19T07:33:54",
                "message_text_only": "> On Sep 18, 2017, at 8:09 PM, Luke Dashjr <luke at dashjr.org> wrote:\n> \n> On Tuesday 19 September 2017 12:46:30 AM Mark Friedenbach via bitcoin-dev \n> wrote:\n>> After the main discussion session it was observed that tail-call semantics\n>> could still be maintained if the alt stack is used for transferring\n>> arguments to the policy script.\n> \n> Isn't this a bug in the cleanstack rule?\n\nWell in the sense that \"cleanstack\" doesn't do what it says, sure.\n\nHowever cleanstack was introduced as a consensus rule to prevent a\npossible denial of service vulnerability where a third party could\nintercept any* transaction broadcast and arbitrarily add data to the\nwitness stack, since witness data is not covered by a checksig.\n\nCleanstack as-is accomplishes this because any extra items on the\nstack would pass through all realistic scripts, remaining on the stack\nand thereby violating the rule. There is no reason to prohibit extra\nitems on the altstack as those items can only arrive there\npurposefully as an action of the script itself, not a third party\nmalleation of witness data. You could of course use DEPTH to write a\nscript that takes a variable number of parameters and sends them to\nthe altstack. Such a script would be malleable if those extra\nparameters are not used. But that is predicated on the script being\nspecifically written in such a way as to be vulnerable; why protect\nagainst that?\n\nThere are other solutions to this problem that could have been taken\ninstead, such as committing to the number of items or maximum size of\nthe stack as part of the sighash data, but cleanstack was the approach\ntaken. Arguably for a future script version upgrade one of these other\napproaches should be taken to allow for shorter tail-call scripts.\n\nMark\n\n* Well, almost any. You could end the script with DEPTH EQUAL and that\n  is a compact way of ensuring the stack is clean (assuming the script\n  finished with just \"true\" on the stack). Nobody does this however\n  and burning two witness bytes of every redeem script going forward\n  as a protective measure seems like an unnecessary ask."
            },
            {
                "author": "Sergio Demian Lerner",
                "date": "2017-09-22T20:32:56",
                "message_text_only": ">\n> There are other solutions to this problem that could have been taken\n> instead, such as committing to the number of items or maximum size of\n> the stack as part of the sighash data, but cleanstack was the approach\n> taken.\n\n\nThe lack of signed maximum segwit stack size was one of the objections to\nsegwit I presented last year. This together with the unlimited segwit stack\nsize.\n\nHowever, committing to the maximum stack size (in bytes) for an input is\ntricky. The only place where this could be packed is in sequence_no, with a\nsoft-fork. E.g. when transaction version is 2 and and only when lock_time\nis zero.\n\nFor transactions with locktime >0, we could soft-fork so transactions add a\nlast zero-satoshi output whose scriptPub contains OP_RETURN and followed by\nN VarInts, containing the maximum stack size of each input.\nNormally, for a 400 byte, 2-input transaction, this will add 11 bytes, or a\n2.5% overhead.\n\n\n\n\n\n\n\n\n> Arguably for a future script version upgrade one of these other\n> approaches should be taken to allow for shorter tail-call scripts.\n>\n> Mark\n>\n> * Well, almost any. You could end the script with DEPTH EQUAL and that\n>   is a compact way of ensuring the stack is clean (assuming the script\n>   finished with just \"true\" on the stack). Nobody does this however\n>   and burning two witness bytes of every redeem script going forward\n>   as a protective measure seems like an unnecessary ask.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170922/cc607dfd/attachment-0001.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-09-22T21:11:03",
                "message_text_only": "> On Sep 22, 2017, at 1:32 PM, Sergio Demian Lerner <sergio.d.lerner at gmail.com> wrote:\n> \n> \n> \n> There are other solutions to this problem that could have been taken\n> instead, such as committing to the number of items or maximum size of\n> the stack as part of the sighash data, but cleanstack was the approach\n> taken. \n> \n> The lack of signed maximum segwit stack size was one of the objections to segwit I presented last year. This together with the unlimited segwit stack size.\n> \n> However, committing to the maximum stack size (in bytes) for an input is tricky. The only place where this could be packed is in sequence_no, with a soft-fork. E.g. when transaction version is 2 and and only when lock_time is zero.\n> \n> For transactions with locktime >0, we could soft-fork so transactions add a last zero-satoshi output whose scriptPub contains OP_RETURN and followed by N VarInts, containing the maximum stack size of each input. \n> Normally, for a 400 byte, 2-input transaction, this will add 11 bytes, or a 2.5% overhead.\n\nThere\u2019s no need to put it in the transaction itself. You put it in the witness and it is either committed to as part of the witness (in which case it has to hold for all possible spend paths), or at spend time by including it in the data signed by CHECKSIG.\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170922/9800edc4/attachment.html>"
            },
            {
                "author": "Sergio Demian Lerner",
                "date": "2017-09-22T21:32:00",
                "message_text_only": "But generally before one signs a transaction one does not know the\nsignature size (which may be variable). One can only estimate the maximum\nsize.\n\nOn Fri, Sep 22, 2017 at 6:11 PM, Mark Friedenbach <mark at friedenbach.org>\nwrote:\n\n>\n> On Sep 22, 2017, at 1:32 PM, Sergio Demian Lerner <\n> sergio.d.lerner at gmail.com> wrote:\n>\n>\n>>\n>> There are other solutions to this problem that could have been taken\n>> instead, such as committing to the number of items or maximum size of\n>> the stack as part of the sighash data, but cleanstack was the approach\n>> taken.\n>\n>\n> The lack of signed maximum segwit stack size was one of the objections to\n> segwit I presented last year. This together with the unlimited segwit stack\n> size.\n>\n> However, committing to the maximum stack size (in bytes) for an input is\n> tricky. The only place where this could be packed is in sequence_no, with a\n> soft-fork. E.g. when transaction version is 2 and and only when lock_time\n> is zero.\n>\n> For transactions with locktime >0, we could soft-fork so transactions add\n> a last zero-satoshi output whose scriptPub contains OP_RETURN and followed\n> by N VarInts, containing the maximum stack size of each input.\n> Normally, for a 400 byte, 2-input transaction, this will add 11 bytes, or\n> a 2.5% overhead.\n>\n>\n> There\u2019s no need to put it in the transaction itself. You put it in the\n> witness and it is either committed to as part of the witness (in which case\n> it has to hold for all possible spend paths), or at spend time by including\n> it in the data signed by CHECKSIG.\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170922/87c83dee/attachment.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-09-22T21:39:45",
                "message_text_only": "You generally know the witness size to within a few bytes right before signing. Why would you not? You know the size of ECDSA signatures. You can be told the size of a hash preimage by the other party. It takes some contriving to come up with a scheme where one party has variable-length signatures of their chosing\n\n> On Sep 22, 2017, at 2:32 PM, Sergio Demian Lerner <sergio.d.lerner at gmail.com> wrote:\n> \n> But generally before one signs a transaction one does not know the signature size (which may be variable). One can only estimate the maximum size."
            },
            {
                "author": "Sergio Demian Lerner",
                "date": "2017-09-22T21:54:39",
                "message_text_only": "If the variable size increase is only a few bytes, then three possibilities\narise:\n\n- one should allow signatures to be zero padded (to reach the maximum size)\nand abandon strict DER encoding\n\n- one should allow spare witness stack elements (to pad the size to match\nthe maximum size) and remove the cleanstack rule. But this is tricky\nbecause empty stack elements must be counted as 1 byte.\n\n- signers must loop the generation of signatures until the signature\ngenerated is of its maximum size.\n\n\n\n\nOn Fri, Sep 22, 2017 at 6:39 PM, Mark Friedenbach <mark at friedenbach.org>\nwrote:\n\n> You generally know the witness size to within a few bytes right before\n> signing. Why would you not? You know the size of ECDSA signatures. You can\n> be told the size of a hash preimage by the other party. It takes some\n> contriving to come up with a scheme where one party has variable-length\n> signatures of their chosing\n>\n> > On Sep 22, 2017, at 2:32 PM, Sergio Demian Lerner <\n> sergio.d.lerner at gmail.com> wrote:\n> >\n> > But generally before one signs a transaction one does not know the\n> signature size (which may be variable). One can only estimate the maximum\n> size.\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170922/2f36b74f/attachment-0001.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-09-22T22:07:33",
                "message_text_only": "There is no harm in the value being a maximum off by a few bytes.\n\n> On Sep 22, 2017, at 2:54 PM, Sergio Demian Lerner <sergio.d.lerner at gmail.com> wrote:\n> \n> If the variable size increase is only a few bytes, then three possibilities arise:\n> \n> - one should allow signatures to be zero padded (to reach the maximum size) and abandon strict DER encoding\n> \n> - one should allow spare witness stack elements (to pad the size to match the maximum size) and remove the cleanstack rule. But this is tricky because empty stack elements must be counted as 1 byte.\n> \n> - signers must loop the generation of signatures until the signature generated is of its maximum size."
            },
            {
                "author": "Pieter Wuille",
                "date": "2017-09-22T22:09:07",
                "message_text_only": "On Fri, Sep 22, 2017 at 2:54 PM, Sergio Demian Lerner via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> If the variable size increase is only a few bytes, then three\n> possibilities arise:\n>\n> - one should allow signatures to be zero padded (to reach the maximum\n> size) and abandon strict DER encoding\n>\n> - one should allow spare witness stack elements (to pad the size to match\n> the maximum size) and remove the cleanstack rule. But this is tricky\n> because empty stack elements must be counted as 1 byte.\n>\n> - signers must loop the generation of signatures until the signature\n> generated is of its maximum size.\n>\n\nOr (my preference);\n\n- Get rid of DER encoding alltogether and switch to fixed size signatures.\n\nCheers,\n\n-- \nPieter\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170922/5cb68030/attachment.html>"
            },
            {
                "author": "Johnson Lau",
                "date": "2017-09-20T05:13:04",
                "message_text_only": "> On 19 Sep 2017, at 11:09 AM, Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> On Tuesday 19 September 2017 12:46:30 AM Mark Friedenbach via bitcoin-dev \n> wrote:\n>> After the main discussion session it was observed that tail-call semantics\n>> could still be maintained if the alt stack is used for transferring\n>> arguments to the policy script.\n> \n> Isn't this a bug in the cleanstack rule?\n> \n> (Unrelated...)\n> \n> Another thing that came up during the discussion was the idea of replacing all \n> the NOPs and otherwise-unallocated opcodes with a new OP_RETURNTRUE \n> implementation, in future versions of Script. This would immediately exit the \n> program (perhaps performing some semantic checks on the remainder of the \n> Script) with a successful outcome.\n> \n> This is similar to CVE-2010-5141 in a sense, but since signatures are no \n> longer Scripts themselves, it shouldn't be exploitable.\n> \n> The benefit of this is that it allows softforking in ANY new opcode, not only \n> the -VERIFY opcode variants we've been doing. That is, instead of merely \n> terminating the Script with a failure, the new opcode can also remove or push \n> stack items. This is because old nodes, upon encountering the undefined \n> opcode, will always succeed immediately, allowing the new opcode to do \n> literally anything from that point onward.\n> \n> Luke\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\nI have implemented OP_RETURNTRUE in an earlier version of MAST (BIP114) but have given up the idea, for 2 reasons:\n\n1. I\u2019ve updated BIP114 to allow inclusion of scripts in witness, and require them to be signed. In this way users could add additional conditions for the validity of a signature. For example, with OP_CHECKBLOCKHASH, it is possible to make the transaction valid only in the specified chain. (More discussion in https://github.com/jl2012/bips/blob/vault/bip-0114.mediawiki#Additional_scripts_in_witness <https://github.com/jl2012/bips/blob/vault/bip-0114.mediawiki#Additional_scripts_in_witness> )\n\n2. OP_RETURNTRUE does not work well with signature aggregation. Signature aggregation will collect (pubkey, message) pairs in a tx, combine them, and verify with one signature. However, consider the following case:\n\nOP_RETURNTRUE OP_IF <pubkey> OP_CHECKSIGVERIFY OP_ENDIF OP_TRUE\n\nFor old nodes, the script terminates at OP_RETURNTRUE, and it will not collect the (pubkey, message) pair.\n\nIf we use a softfork to transform OP_RETURNTRUE into OP_17 (pushing the number 17 to the stack), new nodes will collect the (pubkey, message) pair and try to aggregate with other pairs. This becomes a hardfork.\n\n--------\nTechnically, we could create ANY op code with an OP_NOP. For example, if we want OP_MUL, we could have OP_MULVERIFY, which verifies if the 3rd stack item is the product of the top 2 stack items. Therefore, OP_MULVERIFY OP_2DROP is functionally same as OP_MUL, which removes the top 2 items and returns the product. The problem is it takes more witness space.\n\nIf we don\u2019t want this ugliness, we could use a new script version for every new op code we add. In the new BIP114 (see link above), I suggest to move the script version to the witness, which is cheaper.\n\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170920/c37d065c/attachment-0001.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-09-20T19:29:17",
                "message_text_only": "> On Sep 19, 2017, at 10:13 PM, Johnson Lau <jl2012 at xbt.hk> wrote:\n> \n> If we don\u2019t want this ugliness, we could use a new script version for every new op code we add. In the new BIP114 (see link above), I suggest to move the script version to the witness, which is cheaper.\n\nTo be clear, I don\u2019t think it is so much that the version should be moved to the witness, but rather that there are two separate version values here \u2014 one in the scriptPubKey which specifies the format and structure of the segwit commitment itself, and another in the witness which gates functionality in script or whatever else is used by that witness type. Segwit just unfortunately didn\u2019t include the latter, an oversight that should be corrected on the on the next upgrade opportunity.\n\nThe address-visible \u201cscript version\u201d field should probably be renamed \u201cwitness type\u201d as it will only be used in the future to encode how to check the witness commitment in the scriptPubKey against the data provided in the witness. Upgrades and improvements to the features supported by those witness types won\u2019t require new top-level witness types to be defined. Defining a new opcode, even one with modifies the stack, doesn\u2019t change the hashing scheme used by the witness type.\n\nv0,32-bytes is presently defined to calculate the double-SHA256 hash of the top-most serialized item on the stack, and compare that against the 32-byte commitment value. Arguably it probably should have hashed the top two values, one of which would have been the real script version. This could be fixed however, even without introducing a new witness type. Do a soft-fork upgrade that checks if the witness redeem script is push-only, and if so then pop the last push off as the script version (>= 1), and concatenate the rest to form the actual redeem script. We inherit a little technical debt from having to deal with push limits, but we avoid burning v0 in an upgrade to v1 that does little more than add a script version.\n\nv1,32-bytes would then be used for a template version of MAST, or whatever other idea comes along that fundamentally changes the way the witness commitment is calculated.\n\nMark"
            },
            {
                "author": "Johnson Lau",
                "date": "2017-09-21T03:58:05",
                "message_text_only": "> On 21 Sep 2017, at 3:29 AM, Mark Friedenbach <mark at friedenbach.org> wrote:\n> \n> \n>> On Sep 19, 2017, at 10:13 PM, Johnson Lau <jl2012 at xbt.hk> wrote:\n>> \n>> If we don\u2019t want this ugliness, we could use a new script version for every new op code we add. In the new BIP114 (see link above), I suggest to move the script version to the witness, which is cheaper.\n> \n> To be clear, I don\u2019t think it is so much that the version should be moved to the witness, but rather that there are two separate version values here \u2014 one in the scriptPubKey which specifies the format and structure of the segwit commitment itself, and another in the witness which gates functionality in script or whatever else is used by that witness type. Segwit just unfortunately didn\u2019t include the latter, an oversight that should be corrected on the on the next upgrade opportunity.\n> \n> The address-visible \u201cscript version\u201d field should probably be renamed \u201cwitness type\u201d as it will only be used in the future to encode how to check the witness commitment in the scriptPubKey against the data provided in the witness. Upgrades and improvements to the features supported by those witness types won\u2019t require new top-level witness types to be defined. Defining a new opcode, even one with modifies the stack, doesn\u2019t change the hashing scheme used by the witness type.\n> \n> v0,32-bytes is presently defined to calculate the double-SHA256 hash of the top-most serialized item on the stack, and compare that against the 32-byte commitment value. Arguably it probably should have hashed the top two values, one of which would have been the real script version. This could be fixed however, even without introducing a new witness type. Do a soft-fork upgrade that checks if the witness redeem script is push-only, and if so then pop the last push off as the script version (>= 1), and concatenate the rest to form the actual redeem script. We inherit a little technical debt from having to deal with push limits, but we avoid burning v0 in an upgrade to v1 that does little more than add a script version.\n> \n> v1,32-bytes would then be used for a template version of MAST, or whatever other idea comes along that fundamentally changes the way the witness commitment is calculated.\n> \n> Mark\n\nThis is exactly what I suggest with BIP114. Using v1, 32-byte to define the basic structure of Merklized Script, and define the script version inside the witness\n\nJohnson"
            },
            {
                "author": "Luke Dashjr",
                "date": "2017-09-21T04:11:49",
                "message_text_only": "On Wednesday 20 September 2017 5:13:04 AM Johnson Lau wrote:\n> 2. OP_RETURNTRUE does not work well with signature aggregation. Signature\n> aggregation will collect (pubkey, message) pairs in a tx, combine them,\n> and verify with one signature. However, consider the following case:\n> \n> OP_RETURNTRUE OP_IF <pubkey> OP_CHECKSIGVERIFY OP_ENDIF OP_TRUE\n> \n> For old nodes, the script terminates at OP_RETURNTRUE, and it will not\n> collect the (pubkey, message) pair.\n> \n> If we use a softfork to transform OP_RETURNTRUE into OP_17 (pushing the\n> number 17 to the stack), new nodes will collect the (pubkey, message) pair\n> and try to aggregate with other pairs. This becomes a hardfork.\n\nThis seems like a problem for signature aggregation to address, not a problem \nfor OP_RETURNTRUE... In any case, I don't think it's insurmountable. Signature \naggregation can simply be setup upfront, and have the Script verify inclusion \nof keys in the aggregation?\n\n> Technically, we could create ANY op code with an OP_NOP. For example, if we\n> want OP_MUL, we could have OP_MULVERIFY, which verifies if the 3rd stack\n> item is the product of the top 2 stack items. Therefore, OP_MULVERIFY\n> OP_2DROP is functionally same as OP_MUL, which removes the top 2 items and\n> returns the product. The problem is it takes more witness space.\n\nThis is another approach, and one that seems like a good idea in general. I'm \nnot sure it actually needs to take more witness space - in theory, such stack \nitems could be implied if the Script engine is designed for it upfront. Then \nit would behave as if it were non-verify, while retaining backward \ncompatibility.\n\nLuke"
            },
            {
                "author": "Johnson Lau",
                "date": "2017-09-21T08:02:42",
                "message_text_only": "> On 21 Sep 2017, at 12:11 PM, Luke Dashjr <luke at dashjr.org> wrote:\n> \n> On Wednesday 20 September 2017 5:13:04 AM Johnson Lau wrote:\n>> 2. OP_RETURNTRUE does not work well with signature aggregation. Signature\n>> aggregation will collect (pubkey, message) pairs in a tx, combine them,\n>> and verify with one signature. However, consider the following case:\n>> \n>> OP_RETURNTRUE OP_IF <pubkey> OP_CHECKSIGVERIFY OP_ENDIF OP_TRUE\n>> \n>> For old nodes, the script terminates at OP_RETURNTRUE, and it will not\n>> collect the (pubkey, message) pair.\n>> \n>> If we use a softfork to transform OP_RETURNTRUE into OP_17 (pushing the\n>> number 17 to the stack), new nodes will collect the (pubkey, message) pair\n>> and try to aggregate with other pairs. This becomes a hardfork.\n> \n> This seems like a problem for signature aggregation to address, not a problem \n> for OP_RETURNTRUE... In any case, I don't think it's insurmountable. Signature \n> aggregation can simply be setup upfront, and have the Script verify inclusion \n> of keys in the aggregation?\n\nI think it\u2019s possible only if you spend more witness space to store the (pubkey, message) pairs, so that old clients could understand the aggregation produced by new clients. But this completely defeats the purpose of doing aggregation.\n\nWe use different skills to save space. For example, we use 1-byte SIGHASH flag to imply the 32-byte message. For maximal space saving, sig aggregation will also rely on such skills. However, the assumption is that all signatures aggregated must follow exactly the same set of rules.\n\n\n> \n>> Technically, we could create ANY op code with an OP_NOP. For example, if we\n>> want OP_MUL, we could have OP_MULVERIFY, which verifies if the 3rd stack\n>> item is the product of the top 2 stack items. Therefore, OP_MULVERIFY\n>> OP_2DROP is functionally same as OP_MUL, which removes the top 2 items and\n>> returns the product. The problem is it takes more witness space.\n> \n> This is another approach, and one that seems like a good idea in general. I'm \n> not sure it actually needs to take more witness space - in theory, such stack \n> items could be implied if the Script engine is designed for it upfront. Then \n> it would behave as if it were non-verify, while retaining backward \n> compatibility.\n\nSounds interesting but I don\u2019t get it. For example, how could you make a OP_MUL out of OP_NOP?\n\n\n> \n> Luke"
            },
            {
                "author": "Luke Dashjr",
                "date": "2017-09-21T16:33:16",
                "message_text_only": "On Thursday 21 September 2017 8:02:42 AM Johnson Lau wrote:\n> I think it\u2019s possible only if you spend more witness space to store the\n> (pubkey, message) pairs, so that old clients could understand the\n> aggregation produced by new clients. But this completely defeats the\n> purpose of doing aggregation.\n\nSigAgg is a softfork, so old clients *won't* understand it... am I missing \nsomething?\n\nFor example, perhaps the lookup opcode could have a data payload itself (eg, \nlike pushdata opcodes do), and the script can be parsed independently from \nexecution to collect the applicable ones.\n\n> > This is another approach, and one that seems like a good idea in general.\n> > I'm not sure it actually needs to take more witness space - in theory,\n> > such stack items could be implied if the Script engine is designed for\n> > it upfront. Then it would behave as if it were non-verify, while\n> > retaining backward compatibility.\n> \n> Sounds interesting but I don\u2019t get it. For example, how could you make a\n> OP_MUL out of OP_NOP?\n\nThe same as your OP_MULVERIFY at the consensus level, except new clients would \nexecute it as an OP_MUL, and inject pops/pushes when sending such a \ntransaction to older clients. The hash committed to for the script would \ninclude the inferred values, but not the actual on-chain data. This would \nprobably need to be part of some kind of MAST-like softfork to be viable, and \nmaybe not even then.\n\nLuke"
            },
            {
                "author": "Johnson Lau",
                "date": "2017-09-21T17:38:01",
                "message_text_only": "> On 22 Sep 2017, at 12:33 AM, Luke Dashjr <luke at dashjr.org> wrote:\n> \n> On Thursday 21 September 2017 8:02:42 AM Johnson Lau wrote:\n>> I think it\u2019s possible only if you spend more witness space to store the\n>> (pubkey, message) pairs, so that old clients could understand the\n>> aggregation produced by new clients. But this completely defeats the\n>> purpose of doing aggregation.\n> \n> SigAgg is a softfork, so old clients *won't* understand it... am I missing \n> something?\n> \n> For example, perhaps the lookup opcode could have a data payload itself (eg, \n> like pushdata opcodes do), and the script can be parsed independently from \n> execution to collect the applicable ones.\n\nI think the current idea of sigagg is something like this: the new OP_CHECKSIG still has 2 arguments: top stack must be a 33-byte public key, and the 2nd top stack item is signature. Depends on the sig size, it returns different value:\n\nIf sig size is 0, it returns a 0 to the top stack\nIf sig size is 1, it is treated as a SIGHASH flag, and the SignatureHash() \u201cmessage\u201d is calculated. It sends the (pubkey, message) pair to the aggregator, and always returns a 1 to the top stack\nIf sig size is >1, it is treated as the aggregated signature. The last byte is SIGHASH flag. It sends the (pubkey, message) pair and the aggregated signature to the aggregator, and always returns a 1 to the top stack.\n\nIf all scripts pass, the aggregator will combine all pairs to obtain the aggkey and aggmsg, and verify against aggsig. A tx may have at most 1 aggsig.\n\n(The version I presented above is somewhat simplified but should be enough to illustrate my point)\n\nSo if we have this script:\n\nOP_1 OP_RETURNTRUE <pubkey> OP_CHECKSIG\n\nOld clients would stop at the OP_RETURNTRUE, and will not send the pubkey to the aggregator\n\nIf we softfork OP_RETURNTRUE to something else, even as OP_NOP11, new clients will send the (key, msg) pair to the aggregator. Therefore, the aggregator of old and new clients will see different data, leading to a hardfork.\n\nOTOH, OP_NOP based softfork would not have this problem because it won\u2019t terminate script and return true.\n\n\n> \n>>> This is another approach, and one that seems like a good idea in general.\n>>> I'm not sure it actually needs to take more witness space - in theory,\n>>> such stack items could be implied if the Script engine is designed for\n>>> it upfront. Then it would behave as if it were non-verify, while\n>>> retaining backward compatibility.\n>> \n>> Sounds interesting but I don\u2019t get it. For example, how could you make a\n>> OP_MUL out of OP_NOP?\n> \n> The same as your OP_MULVERIFY at the consensus level, except new clients would \n> execute it as an OP_MUL, and inject pops/pushes when sending such a \n> transaction to older clients. The hash committed to for the script would \n> include the inferred values, but not the actual on-chain data. This would \n> probably need to be part of some kind of MAST-like softfork to be viable, and \n> maybe not even then.\n> \n> Luke\n\nI don\u2019t think it\u2019s worth the code complexity, just to save a few bytes of data sent over wire; and to be a soft fork, it still takes the block space.\n\nMaybe we could create many OP_DROPs and OP_2DROPs, so new VERIFY operations could pop the stack. This saves 1 byte and also looks cleaner.\n\nAnother approach is to use a new script version for every new non-verify type operation. Problem is we will end up with many versions. Also, signatures from different versions can\u2019t be aggregated. (We may have multiple aggregators in a transaction)"
            }
        ],
        "thread_summary": {
            "title": "cleanstack alt stack & softfork improvements (Was: Merkle branch verification & tail-call semantics for generalized MAST)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Johnson Lau",
                "Sergio Demian Lerner",
                "Luke Dashjr",
                "Mark Friedenbach",
                "Pieter Wuille"
            ],
            "messages_count": 16,
            "total_messages_chars_count": 28996
        }
    },
    {
        "title": "[bitcoin-dev] Fast Merkle Trees",
        "thread_messages": [
            {
                "author": "Russell O'Connor",
                "date": "2017-09-07T01:59:54",
                "message_text_only": "The fast hash for internal nodes needs to use an IV that is not the\nstandard SHA-256 IV. Instead needs to use some other fixed value, which\nshould itself be the SHA-256 hash of some fixed string (e.g. the string\n\"BIP ???\" or \"Fash SHA-256\").\n\nAs it stands, I believe someone can claim a leaf node as an internal node\nby creating a proof that provides a phony right-hand branch claiming to\nhave hash 0x80000..0000100 (which is really the padding value for the\nsecond half of a double SHA-256 hash).\n\n(I was schooled by Peter Todd by a similar issue in the past.)\n\nOn Wed, Sep 6, 2017 at 8:38 PM, Mark Friedenbach via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Fast Merkle Trees\n> BIP: https://gist.github.com/maaku/41b0054de0731321d23e9da90ba4ee0a\n> Code: https://github.com/maaku/bitcoin/tree/fast-merkle-tree\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170906/59d742fe/attachment-0001.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-09-07T02:20:06",
                "message_text_only": "This design purposefully does not distinguish leaf nodes from internal nodes. That way it chained invocations can be used to validate paths longer than 32 branches. Do you see a vulnerability due to this lack of distinction?\n\n> On Sep 6, 2017, at 6:59 PM, Russell O'Connor <roconnor at blockstream.io> wrote:\n> \n> The fast hash for internal nodes needs to use an IV that is not the standard SHA-256 IV. Instead needs to use some other fixed value, which should itself be the SHA-256 hash of some fixed string (e.g. the string \"BIP ???\" or \"Fash SHA-256\").\n> \n> As it stands, I believe someone can claim a leaf node as an internal node by creating a proof that provides a phony right-hand branch claiming to have hash 0x80000..0000100 (which is really the padding value for the second half of a double SHA-256 hash).\n> \n> (I was schooled by Peter Todd by a similar issue in the past.)\n> \n>> On Wed, Sep 6, 2017 at 8:38 PM, Mark Friedenbach via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> Fast Merkle Trees\n>> BIP: https://gist.github.com/maaku/41b0054de0731321d23e9da90ba4ee0a\n>> Code: https://github.com/maaku/bitcoin/tree/fast-merkle-tree\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170906/e53c24c8/attachment.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2017-09-07T15:43:52",
                "message_text_only": "In that case, you may as well remove all references to leaves and double\nSHA-256 from your BIP since your design has no method for distinguishing\nbetween internal nodes and leaves.\n\nI think that if this design stands, it will play a role in some future\nCVEs.  The BIP itself is too abstract about its data contents to\nspecifically say that it has a vulnerability; however, I believe it is\ninviting vulnerabilities.\nFor example, I might agree with a counterparty to a design of some sort of\nsmart contract in the form of a MAST.  My counterparty has shown me all the\n\"leaves\" of our MAST and I can verify its Merkle root computation.\nAfter being deployed, I found out that one of the leaves wasn't really a\nleaf but is instead a specially crafted \"script\" with a fake pubkey chosen\nby my couterparty so that this leaf can also be interpreted as a fake\ninternal node (i.e. an internal node with a right branch of 0x8000...100).\nBecause the Fast Merkle Tree design doesn't distinguish between leaves and\ninternal nodes my counter party gets away with building an Inclusion Proof\nthrough this \"leaf\" to reveal the evil code that they had designed into the\nMAST at a deeper level.\n\nTurns out my counterparty was grinding their evil code to produce an\ninternal node that can also be parsed as an innocent script.  They used\ntheir \"pubkey\" to absorb excess random data from their grinding that they\ncannot eliminate.\n(The counterparty doesn't actually know the discrete log of this \"pubkey\",\nthey just claimed it was their pubkey and I believed them).\n\n\nHaving ambiguity about whether a node is a leaf or an internal node is a\nsecurity risk. Furthermore, changing the design so that internal node and\nleaves are distinguishable still allows chained invocations.\nArbitrary data can be stored in Fast Merkle Tree leaves, including the\nMerkle root of another Fast Merkle Tree.\nApplications that are limited to proof with paths no longer than 32\nbranches can still circumvent this limit by staging these Fast Merkle Trees\nin explicit layers (as opposed to the implicit layers with the current\ndesign).\n\nBy storing a inner Fast Merkle Tree root inside the (explicit) leaf of an\nouter Fast Merkle Tree, the application can verify a Inclusion Proof of the\ninner Fast Merkle Tree Root in the outer Fast Merkle Tree Root, and then\nverify a second Inclusion Proof of the desired data in the inner Faster\nMerkle Tree Root.  The application will need to tag their data to\ndistinguish between inner Fast Merkle Tree Roots and other application\ndata, but that is just part of the general expectation that applications\nnot store ambiguous data inside the leaves of Fast Merkle Trees.\n\n\nOn Wed, Sep 6, 2017 at 10:20 PM, Mark Friedenbach <mark at friedenbach.org>\nwrote:\n\n> This design purposefully does not distinguish leaf nodes from internal\n> nodes. That way it chained invocations can be used to validate paths longer\n> than 32 branches. Do you see a vulnerability due to this lack of\n> distinction?\n>\n> On Sep 6, 2017, at 6:59 PM, Russell O'Connor <roconnor at blockstream.io>\n> wrote:\n>\n> The fast hash for internal nodes needs to use an IV that is not the\n> standard SHA-256 IV. Instead needs to use some other fixed value, which\n> should itself be the SHA-256 hash of some fixed string (e.g. the string\n> \"BIP ???\" or \"Fash SHA-256\").\n>\n> As it stands, I believe someone can claim a leaf node as an internal node\n> by creating a proof that provides a phony right-hand branch claiming to\n> have hash 0x80000..0000100 (which is really the padding value for the\n> second half of a double SHA-256 hash).\n>\n> (I was schooled by Peter Todd by a similar issue in the past.)\n>\n> On Wed, Sep 6, 2017 at 8:38 PM, Mark Friedenbach via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Fast Merkle Trees\n>> BIP: https://gist.github.com/maaku/41b0054de0731321d23e9da90ba4ee0a\n>> Code: https://github.com/maaku/bitcoin/tree/fast-merkle-tree\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/87bc87d5/attachment-0001.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-09-07T17:42:13",
                "message_text_only": "I've been puzzling over your email since receiving it. I'm not sure it\nis possible to perform the attack you describe with the tree structure\nspecified in the BIP. If I may rephrase your attack, I believe you are\nseeking a solution to the following:\n\nWant: An innocuous script and a malign script for which\n\n   double-SHA256(innocuous)\n\nis equal to either\n\n   fast-SHA256(double-SHA256(malign) || r) or\n   fast-SHA256(r || double-SHA256(malign))\n\nwhere r is a freely chosen 32-byte nonce. This would allow the\nattacker to reveal the innocuous script before funds are sent to the\nMAST, then use the malign script to spend.\n\nBecause of the double-SHA256 construction I do not see how this can be\naccomplished without a full break of SHA256. The trick of setting r\nequal to the padding only works when a single SHA256 is used for leaf\nvalues. This is why double-SHA256 is specified in the BIP, and I will\nedit the text to make that more clear.\n\nWhich brings us to the point that I think your original request of\nseparating the hash function of leaves from internal nodes is already\nin the specification. I misunderstood your request at first to be that\nMERKLEBRANCHVERIFY should itself perform this hash, which I objected\nto as it closes of certain use cases such as chained verification of\nproofs. But it is explicitly the case that leaf values and internal\nupdates are calculated with different hash functions.\n\nI'm not intrinsicly opposed to using a different IV for fast-SHA256 so\nas to remove the incompatability with single-SHA256 as the leaf hash\nfunction, if that is the consensus of the community. It just adds\ncomplication to implementations and so I want to make sure that\ncomplication is well justified.\n\nSincerely,\nMark Friedenbach\n\n> On Sep 7, 2017, at 8:43 AM, Russell O'Connor <roconnor at blockstream.io> wrote:\n> \n> In that case, you may as well remove all references to leaves and double SHA-256 from your BIP since your design has no method for distinguishing between internal nodes and leaves.\n> \n> I think that if this design stands, it will play a role in some future CVEs.  The BIP itself is too abstract about its data contents to specifically say that it has a vulnerability; however, I believe it is inviting vulnerabilities.\n> For example, I might agree with a counterparty to a design of some sort of smart contract in the form of a MAST.  My counterparty has shown me all the \"leaves\" of our MAST and I can verify its Merkle root computation.\n> After being deployed, I found out that one of the leaves wasn't really a leaf but is instead a specially crafted \"script\" with a fake pubkey chosen by my couterparty so that this leaf can also be interpreted as a fake internal node (i.e. an internal node with a right branch of 0x8000...100).\n> Because the Fast Merkle Tree design doesn't distinguish between leaves and internal nodes my counter party gets away with building an Inclusion Proof through this \"leaf\" to reveal the evil code that they had designed into the MAST at a deeper level.\n> \n> Turns out my counterparty was grinding their evil code to produce an internal node that can also be parsed as an innocent script.  They used their \"pubkey\" to absorb excess random data from their grinding that they cannot eliminate.\n> (The counterparty doesn't actually know the discrete log of this \"pubkey\", they just claimed it was their pubkey and I believed them).\n> \n> \n> Having ambiguity about whether a node is a leaf or an internal node is a security risk. Furthermore, changing the design so that internal node and leaves are distinguishable still allows chained invocations.\n> Arbitrary data can be stored in Fast Merkle Tree leaves, including the Merkle root of another Fast Merkle Tree.\n> Applications that are limited to proof with paths no longer than 32 branches can still circumvent this limit by staging these Fast Merkle Trees in explicit layers (as opposed to the implicit layers with the current design).\n> \n> By storing a inner Fast Merkle Tree root inside the (explicit) leaf of an outer Fast Merkle Tree, the application can verify a Inclusion Proof of the inner Fast Merkle Tree Root in the outer Fast Merkle Tree Root, and then verify a second Inclusion Proof of the desired data in the inner Faster Merkle Tree Root.  The application will need to tag their data to distinguish between inner Fast Merkle Tree Roots and other application data, but that is just part of the general expectation that applications not store ambiguous data inside the leaves of Fast Merkle Trees.\n> \n> \n> On Wed, Sep 6, 2017 at 10:20 PM, Mark Friedenbach <mark at friedenbach.org <mailto:mark at friedenbach.org>> wrote:\n> This design purposefully does not distinguish leaf nodes from internal nodes. That way it chained invocations can be used to validate paths longer than 32 branches. Do you see a vulnerability due to this lack of distinction?\n> \n> On Sep 6, 2017, at 6:59 PM, Russell O'Connor <roconnor at blockstream.io <mailto:roconnor at blockstream.io>> wrote:\n> \n>> The fast hash for internal nodes needs to use an IV that is not the standard SHA-256 IV. Instead needs to use some other fixed value, which should itself be the SHA-256 hash of some fixed string (e.g. the string \"BIP ???\" or \"Fash SHA-256\").\n>> \n>> As it stands, I believe someone can claim a leaf node as an internal node by creating a proof that provides a phony right-hand branch claiming to have hash 0x80000..0000100 (which is really the padding value for the second half of a double SHA-256 hash).\n>> \n>> (I was schooled by Peter Todd by a similar issue in the past.)\n>> \n>> On Wed, Sep 6, 2017 at 8:38 PM, Mark Friedenbach via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>> Fast Merkle Trees\n>> BIP: https://gist.github.com/maaku/41b0054de0731321d23e9da90ba4ee0a <https://gist.github.com/maaku/41b0054de0731321d23e9da90ba4ee0a>\n>> Code: https://github.com/maaku/bitcoin/tree/fast-merkle-tree <https://github.com/maaku/bitcoin/tree/fast-merkle-tree>\n> \n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/9a429e2c/attachment.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2017-09-07T18:55:25",
                "message_text_only": "On Thu, Sep 7, 2017 at 1:42 PM, Mark Friedenbach <mark at friedenbach.org>\nwrote:\n\n> I've been puzzling over your email since receiving it. I'm not sure it\n> is possible to perform the attack you describe with the tree structure\n> specified in the BIP. If I may rephrase your attack, I believe you are\n> seeking a solution to the following:\n>\n> Want: An innocuous script and a malign script for which\n>\n>    double-SHA256(innocuous)\n>\n> is equal to either\n>\n>    fast-SHA256(double-SHA256(malign) || r) or\n>    fast-SHA256(r || double-SHA256(malign))\n>\n\nor  fast-SHA256(fast-SHA256(double-SHA256(malign) || r1) || r0)\nor  fast-SHA256(fast-SHA256(r1 || double-SHA256(malign)) || r0)\nor ...\n\n\n> where r is a freely chosen 32-byte nonce. This would allow the\n> attacker to reveal the innocuous script before funds are sent to the\n> MAST, then use the malign script to spend.\n>\n> Because of the double-SHA256 construction I do not see how this can be\n> accomplished without a full break of SHA256.\n>\n\nThe particular scenario I'm imagining is a collision between\n\n    double-SHA256(innocuous)\n\nand\n\n    fast-SHA256(fast-SHA256(fast-SHA256(double-SHA256(malign) || r2) || r1)\n|| r0).\n\nwhere innocuous is a Bitcoin Script that is between 32 and 55 bytes long.\n\nObserve that when data is less than 55 bytes then double-SHA256(data) =\nfast-SHA256(fast-SHA256(padding-SHA256(data)) || 0x8000...100) (which is\nreally the crux of the matter).\n\nTherefore, to get our collision it suffices to find a collision between\n\n    padding-SHA256(innocuous)\n\nand\n\n    fast-SHA256(double-SHA256(malign) || r2) || r1\n\nr1 can freely be set to the second half of padding-SHA256(innocuous), so it\nsuffices to find a collision between\n\n   fast-SHA256(double-SHA256(malign) || r2)\n\nand the first half of padding-SHA256(innocuous) which is equal to the first\n32 bytes of innocuous.\n\nImagine the first opcode of innocuous is the push of a value that the\nattacker claims to be his 33-byte public key.\nSo long as the attacker doesn't need to prove that they know the discrete\nlog of this pubkey, they can grind r2 until the result of\nfast-SHA256(double-SHA256(malign) || r2) contains the correct first couple\nof bytes for the script header and the opcode for a 33-byte push.  I\nbelieve that is only about 3 or 4 bytes of they need to grind out.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/724c4de6/attachment.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-09-07T20:04:30",
                "message_text_only": "TL;DR I'll be updating the fast Merkle-tree spec to use a different\n      IV, using (for infrastructure compatability reasons) the scheme\n      provided by Peter Todd.\n\nThis is a specific instance of a general problem where you cannot\ntrust scripts given to you by another party. Notice that we run into\nthe same sort of problem when doing key aggregation, in which you must\nrequire the other party to prove knowledge of the discrete log before\nusing their public key, or else key cancellation can occur.\n\nWith script it is a little bit more complicated as you might want\nzero-knowledge proofs of hash pre-images for HTLCs as well as proofs\nof DL knowledge (signatures), but the basic idea is the same. Multi-\nparty wallet level protocols for jointly constructing scriptPubKeys\nshould require a 'delinearization' step that proves knowledge of\ninformation necessary to complete each part of the script, as part of\nproving the safety of a construct.\n\nI think my hangup before in understanding the attack you describe was\nin actualizing it into a practical attack that actually escalates the\nattacker's capabilities. If the attacker can get you to agree to a\nMAST policy that is nothing more than a CHECKSIG over a key they\npresumably control, then they don't need to do any complicated\ngrinding. The attacker in that scenario would just actually specify a\nkey they control and take the funds that way.\n\nWhere this presumably leads to an actual exploit is when you specify a\nscript that a curious counter-party actually takes the time to\ninvestigate and believes to be secure. For example, a script that\nrequires a signature or pre-image revelation from that counter-party.\nThat would require grinding not a few bytes, but at minimum 20-33\nbytes for either a HASH160 image or the counter-party's key.\n\nIf I understand the revised attack description correctly, then there\nis a small window in which the attacker can create a script less than\n55 bytes in length, where nearly all of the first 32 bytes are\nselected by the attacker, yet nevertheless the script seems safe to\nthe counter-party. The smallest such script I was able to construct\nwas the following:\n\n    <fake-pubkey> CHECKSIGVERIFY HASH160 <preimage> EQUAL\n\nThis is 56 bytes and requires only 7 bits of grinding in the fake\npubkey. But 56 bytes is too large. Switching to secp256k1 serialized\n32-byte pubkeys (in a script version upgrade, for example) would\nreduce this to the necessary 55 bytes with 0 bits of grinding. A\nsmaller variant is possible:\n\n    DUP HASH160 <fake-pubkey-hash> EQUALVERIFY CHECKSIGVERIFY HASH160 <preimage> EQUAL\n\nThis is 46 bytes, but requires grinding 96 bits, which is a bit less\nplausible.\n\nBelts and suspenders are not so terrible together, however, and I\nthink there is enough of a justification here to look into modifying\nthe scheme to use a different IV for hash tree updates. This would\nprevent even the above implausible attacks.\n\n\n> On Sep 7, 2017, at 11:55 AM, Russell O'Connor <roconnor at blockstream.io> wrote:\n> \n> \n> \n> On Thu, Sep 7, 2017 at 1:42 PM, Mark Friedenbach <mark at friedenbach.org <mailto:mark at friedenbach.org>> wrote:\n> I've been puzzling over your email since receiving it. I'm not sure it\n> is possible to perform the attack you describe with the tree structure\n> specified in the BIP. If I may rephrase your attack, I believe you are\n> seeking a solution to the following:\n> \n> Want: An innocuous script and a malign script for which\n> \n>    double-SHA256(innocuous)\n> \n> is equal to either\n> \n>    fast-SHA256(double-SHA256(malign) || r) or\n>    fast-SHA256(r || double-SHA256(malign))\n> \n> or  fast-SHA256(fast-SHA256(double-SHA256(malign) || r1) || r0)\n> or  fast-SHA256(fast-SHA256(r1 || double-SHA256(malign)) || r0)\n> or ...\n>  \n> where r is a freely chosen 32-byte nonce. This would allow the\n> attacker to reveal the innocuous script before funds are sent to the\n> MAST, then use the malign script to spend.\n> \n> Because of the double-SHA256 construction I do not see how this can be\n> accomplished without a full break of SHA256. \n> \n> The particular scenario I'm imagining is a collision between\n> \n>     double-SHA256(innocuous)\n> \n> and \n> \n>     fast-SHA256(fast-SHA256(fast-SHA256(double-SHA256(malign) || r2) || r1) || r0).\n> \n> where innocuous is a Bitcoin Script that is between 32 and 55 bytes long.\n> \n> Observe that when data is less than 55 bytes then double-SHA256(data) = fast-SHA256(fast-SHA256(padding-SHA256(data)) || 0x8000...100) (which is really the crux of the matter).\n> \n> Therefore, to get our collision it suffices to find a collision between\n> \n>     padding-SHA256(innocuous)\n> \n> and\n> \n>     fast-SHA256(double-SHA256(malign) || r2) || r1\n> \n> r1 can freely be set to the second half of padding-SHA256(innocuous), so it suffices to find a collision between\n> \n>    fast-SHA256(double-SHA256(malign) || r2)\n> \n> and the first half of padding-SHA256(innocuous) which is equal to the first 32 bytes of innocuous.\n> \n> Imagine the first opcode of innocuous is the push of a value that the attacker claims to be his 33-byte public key.\n> So long as the attacker doesn't need to prove that they know the discrete log of this pubkey, they can grind r2 until the result of fast-SHA256(double-SHA256(malign) || r2) contains the correct first couple of bytes for the script header and the opcode for a 33-byte push.  I believe that is only about 3 or 4 bytes of they need to grind out.\n> \n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/63af0292/attachment.html>"
            },
            {
                "author": "Johnson Lau",
                "date": "2017-09-12T11:44:48",
                "message_text_only": "> On 8 Sep 2017, at 4:04 AM, Mark Friedenbach via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> If I understand the revised attack description correctly, then there\n> is a small window in which the attacker can create a script less than\n> 55 bytes in length, where nearly all of the first 32 bytes are\n> selected by the attacker, yet nevertheless the script seems safe to\n> the counter-party. The smallest such script I was able to construct\n> was the following:\n> \n>     <fake-pubkey> CHECKSIGVERIFY HASH160 <preimage> EQUAL\n> \n> This is 56 bytes and requires only 7 bits of grinding in the fake\n> pubkey. But 56 bytes is too large. Switching to secp256k1 serialized\n> 32-byte pubkeys (in a script version upgrade, for example) would\n> reduce this to the necessary 55 bytes with 0 bits of grinding. A\n> smaller variant is possible:\n> \n>     DUP HASH160 <fake-pubkey-hash> EQUALVERIFY CHECKSIGVERIFY HASH160 <preimage> EQUAL\n> \n> This is 46 bytes, but requires grinding 96 bits, which is a bit less\n> plausible.\n> \n> Belts and suspenders are not so terrible together, however, and I\n> think there is enough of a justification here to look into modifying\n> the scheme to use a different IV for hash tree updates. This would\n> prevent even the above implausible attacks.\n> \n\nI think you overestimated the difficulty. Consider this MAST branch (an example in BIP114)\n\n\"Timestamp\" CHECKLOCKTIMEVERIFY <fake-pubkey> CHECKSIGVERIFY\n\nThis requires just a few bytes of collision."
            },
            {
                "author": "Peter Todd",
                "date": "2017-09-07T05:55:57",
                "message_text_only": "On Wed, Sep 06, 2017 at 09:59:54PM -0400, Russell O'Connor via bitcoin-dev wrote:\n> The fast hash for internal nodes needs to use an IV that is not the\n> standard SHA-256 IV. Instead needs to use some other fixed value, which\n> should itself be the SHA-256 hash of some fixed string (e.g. the string\n> \"BIP ???\" or \"Fash SHA-256\").\n\nNote that in general, designs should *not* create new hash functions by using\ncustom IVs, but rather use bog-standard SHA256, and make a fixed first block.\nThat allows unoptimised implementations to just hash a block with the second\ninitialization value, and optimized implementations to start with the fixed\nmidstate.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/357fa2db/attachment-0001.sig>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2017-09-07T15:51:14",
                "message_text_only": "On Thu, Sep 7, 2017 at 1:55 AM, Peter Todd <pete at petertodd.org> wrote:\n\n> On Wed, Sep 06, 2017 at 09:59:54PM -0400, Russell O'Connor via bitcoin-dev\n> wrote:\n> > The fast hash for internal nodes needs to use an IV that is not the\n> > standard SHA-256 IV. Instead needs to use some other fixed value, which\n> > should itself be the SHA-256 hash of some fixed string (e.g. the string\n> > \"BIP ???\" or \"Fash SHA-256\").\n>\n> Note that in general, designs should *not* create new hash functions by\n> using\n> custom IVs, but rather use bog-standard SHA256, and make a fixed first\n> block.\n> That allows unoptimised implementations to just hash a block with the\n> second\n> initialization value, and optimized implementations to start with the fixed\n> midstate.\n\n\nI 100% agree.\n\nWith SHA256 every final state is also a valid midstate.  Therefore, using a\ncustom IV of the SHA256 hash of some fixed string results in a hash of data\nthat is functionally equivalent to prefixing the data with the padded\nversion of the fixed string and using a regular SHA256 hash of the combined\ndata.  This is important and I should have explicitly pointed it out.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/98006cd2/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Fast Merkle Trees",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Russell O'Connor",
                "Peter Todd",
                "Johnson Lau",
                "Mark Friedenbach"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 24619
        }
    },
    {
        "title": "[bitcoin-dev] BIP114 Merklized Script update and 5 BIPs for new script functions",
        "thread_messages": [
            {
                "author": "Johnson Lau",
                "date": "2017-09-08T09:49:46",
                "message_text_only": "I have rewritten and simplified BIP114, and renamed it to \u201cMerklized Script\u201d, as a more accurate description after consulting the original proposers of MAST. It could be considered as a special case of MAST, but has basically the same functions and scaling properties of MAST.\n\nCompared with Friedenbach\u2019s latest tail-call execution semantics proposal, I think the most notable difference is BIP114 focuses on maintaining the static analysability, which was a reason of OP_EVAL (BIP12) being rejected. Currently we could count the number of sigOp without executing the script, and this remains true with BIP114. Since sigOp is a block-level limit, any OP_EVAL-like operation means block validity will depend on the precise outcome of script execution (instead of just pass or fail), which is a layer violation.\n\nLink to the revised BIP114: https://github.com/jl2012/bips/blob/vault/bip-0114.mediawiki\n\nOn top of BIP114, new script functions are defined with 5 BIPs:\n\nVVV: Pay-to-witness-public-key: https://github.com/jl2012/bips/blob/vault/bip-0VVV.mediawiki\nWWW: String and Bitwise Operations in Merklized Script Version 0: https://github.com/jl2012/bips/blob/vault/bip-0WWW.mediawiki\nXXX: Numeric Operations in Merklized Script Version 0: https://github.com/jl2012/bips/blob/vault/bip-0XXX.mediawiki\nYYY: ECDSA signature operations in Merklized Script Version 0: https://github.com/jl2012/bips/blob/vault/bip-0YYY.mediawiki\nZZZ: OP_PUSHTXDATA: https://github.com/jl2012/bips/blob/vault/bip-0ZZZ.mediawiki\n\nAs a summary, these BIPs have the following major features:\n\n1. Merklized Script: a special case of MAST, allows users to hide unexecuted branches in their scripts (BIP114)\n2. Delegation: key holder(s) may delegate the right of spending to other keys (scripts), with or without additional conditions such as locktime. (BIP114, VVV)\n3. Enabling all OP codes disabled by Satoshi (based on Elements project with modification. BIPWWW and XXX)\n4. New SIGHASH definition with very high flexibility (BIPYYY)\n5. Covenant (BIPZZZ)\n6. OP_CHECKSIGFROMSTACK, modified from Elements project (BIPYYY)\n7. Replace ~72 byte DER sig with fixed size 64 byte compact sig. (BIPYYY)\n\nAll of these features are modular and no need to be deployed at once. The very basic BIP114 (merklized script only, no delegation) could be done quite easily. BIP114 has its own versioning system which makes introducing new functions very easy.\n\nThings I\u2019d like to have:\n\n1. BIP114 now uses SHA256, but I\u2019m open to other hash design\n2. Using Schnorr or similar signature scheme, instead of ECDSA, in BIPYYY.\n\nReference implementation: https://github.com/jl2012/bitcoin/commits/vault"
            }
        ],
        "thread_summary": {
            "title": "BIP114 Merklized Script update and 5 BIPs for new script functions",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Johnson Lau"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2653
        }
    },
    {
        "title": "[bitcoin-dev] Proposal: Extended serialization format for BIP-32",
        "thread_messages": [
            {
                "author": "shiva sitamraju",
                "date": "2017-09-09T14:08:21",
                "message_text_only": "Hi,\n\nI understand the motivation of adding the birthdate field. However, not\nvery comfortable with having this in the public key serialization. There\nare privacy implication of both the birthday field and having the complete\nderivation path, which takes space.\n\nI am fine with Thomas proposal of {x,y,z}. Having additional version byte\nfield looks modular but since since we already have the big enough version\nfield in bip32, better to use that instead of adding more bytes.\n\nThomas, can you please explain why we require different version for P2WPKH\nor P2WSH versus (P2WPKH or P2WSH) nested in P2SH. It looked to me that they\nwould have the same output bitcoin address and under same account.\n\nOn Fri, Sep 8, 2017 at 2:09 AM, <\nbitcoin-dev-request at lists.linuxfoundation.org> wrote:\n\n> Send bitcoin-dev mailing list submissions to\n>         bitcoin-dev at lists.linuxfoundation.org\n>\n> To subscribe or unsubscribe via the World Wide Web, visit\n>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> or, via email, send a message with subject or body 'help' to\n>         bitcoin-dev-request at lists.linuxfoundation.org\n>\n> You can reach the person managing the list at\n>         bitcoin-dev-owner at lists.linuxfoundation.org\n>\n> When replying, please edit your Subject line so it is more specific\n> than \"Re: Contents of bitcoin-dev digest...\"\n>\n>\n> Today's Topics:\n>\n>    1. Re: Proposal: Extended serialization format for   BIP-32\n>       wallets (Andreas Schildbach)\n>    2. Re: Proposal: Extended serialization format for BIP-32\n>       wallets (Pavol Rusnak)\n>    3. Re: Fast Merkle Trees (Mark Friedenbach)\n>    4. Re: Proposal: Extended serialization format for BIP-32\n>       wallets (Thomas Voegtlin)\n>\n>\n> ----------------------------------------------------------------------\n>\n> Message: 1\n> Date: Thu, 7 Sep 2017 21:35:49 +0200\n> From: Andreas Schildbach <andreas at schildbach.de>\n> To: bitcoin-dev at lists.linuxfoundation.org\n> Subject: Re: [bitcoin-dev] Proposal: Extended serialization format for\n>         BIP-32 wallets\n> Message-ID: <oos72e$rjp$1 at blaine.gmane.org>\n> Content-Type: text/plain; charset=utf-8\n>\n> On 09/07/2017 06:23 PM, Pavol Rusnak via bitcoin-dev wrote:\n> > On 07/09/17 06:29, Thomas Voegtlin via bitcoin-dev wrote:\n> >> A solution is still needed to wallets who do not wish to use BIP43\n> >\n> > What if we added another byte field OutputType for wallets that do not\n> > follow BIP43?\n> >\n> > 0x00 - P2PKH output type\n> > 0x01 - P2WPKH-in-P2SH output type\n> > 0x02 - native Segwit output type\n> >\n> > Would that work for you?\n>\n> I think that would work.\n>\n> > The question is whether this field should be present only if depth==0x00\n> > or at all times. What is your suggestion, Thomas?\n>\n> In case of Bitcoin Wallet, the depth is not null (m/0'/[0,1]) and still\n> we need this field. I think it should always be present if a chain is\n> limited to a certain script type.\n>\n> There is however the case where even on one chain, script types are\n> mixed. In this case the field should be omitted and the wallet needs to\n> scan for all (known) types. Afaik Bitcoin Core is taking this path.\n>\n>\n>\n> ------------------------------\n>\n> Message: 2\n> Date: Thu, 7 Sep 2017 22:00:05 +0200\n> From: Pavol Rusnak <stick at satoshilabs.com>\n> To: Andreas Schildbach <andreas at schildbach.de>, Bitcoin Protocol\n>         Discussion <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: Re: [bitcoin-dev] Proposal: Extended serialization format for\n>         BIP-32 wallets\n> Message-ID: <40ed03a1-915c-33b0-c4ac-e898c8c733ba at satoshilabs.com>\n> Content-Type: text/plain; charset=windows-1252\n>\n> On 07/09/17 21:35, Andreas Schildbach via bitcoin-dev wrote:\n> > In case of Bitcoin Wallet, the depth is not null (m/0'/[0,1]) and still\n> > we need this field.\n>\n> But the depth of exported public key will be null. It does not make\n> sense to export xpub for m or m/0' for your particular case.\n>\n> > I think it should always be present if a chain is\n> > limited to a certain script type.\n>\n> I am fine with having the path there all the time.\n>\n> > There is however the case where even on one chain, script types are\n> > mixed. In this case the field should be omitted and the wallet needs to\n> > scan for all (known) types. Afaik Bitcoin Core is taking this path.\n>\n> Is that really the case? Why come up with a hierarchy and then don't use\n> it?\n>\n> --\n> Best Regards / S pozdravom,\n>\n> Pavol \"stick\" Rusnak\n> CTO, SatoshiLabs\n>\n>\n> ------------------------------\n>\n> Message: 3\n> Date: Thu, 7 Sep 2017 13:04:30 -0700\n> From: Mark Friedenbach <mark at friedenbach.org>\n> To: Russell O'Connor <roconnor at blockstream.io>\n> Cc: Bitcoin Protocol Discussion\n>         <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: Re: [bitcoin-dev] Fast Merkle Trees\n> Message-ID: <40D6F502-3380-4B64-BCD9-80D361EED35C at friedenbach.org>\n> Content-Type: text/plain; charset=\"us-ascii\"\n>\n> TL;DR I'll be updating the fast Merkle-tree spec to use a different\n>       IV, using (for infrastructure compatability reasons) the scheme\n>       provided by Peter Todd.\n>\n> This is a specific instance of a general problem where you cannot\n> trust scripts given to you by another party. Notice that we run into\n> the same sort of problem when doing key aggregation, in which you must\n> require the other party to prove knowledge of the discrete log before\n> using their public key, or else key cancellation can occur.\n>\n> With script it is a little bit more complicated as you might want\n> zero-knowledge proofs of hash pre-images for HTLCs as well as proofs\n> of DL knowledge (signatures), but the basic idea is the same. Multi-\n> party wallet level protocols for jointly constructing scriptPubKeys\n> should require a 'delinearization' step that proves knowledge of\n> information necessary to complete each part of the script, as part of\n> proving the safety of a construct.\n>\n> I think my hangup before in understanding the attack you describe was\n> in actualizing it into a practical attack that actually escalates the\n> attacker's capabilities. If the attacker can get you to agree to a\n> MAST policy that is nothing more than a CHECKSIG over a key they\n> presumably control, then they don't need to do any complicated\n> grinding. The attacker in that scenario would just actually specify a\n> key they control and take the funds that way.\n>\n> Where this presumably leads to an actual exploit is when you specify a\n> script that a curious counter-party actually takes the time to\n> investigate and believes to be secure. For example, a script that\n> requires a signature or pre-image revelation from that counter-party.\n> That would require grinding not a few bytes, but at minimum 20-33\n> bytes for either a HASH160 image or the counter-party's key.\n>\n> If I understand the revised attack description correctly, then there\n> is a small window in which the attacker can create a script less than\n> 55 bytes in length, where nearly all of the first 32 bytes are\n> selected by the attacker, yet nevertheless the script seems safe to\n> the counter-party. The smallest such script I was able to construct\n> was the following:\n>\n>     <fake-pubkey> CHECKSIGVERIFY HASH160 <preimage> EQUAL\n>\n> This is 56 bytes and requires only 7 bits of grinding in the fake\n> pubkey. But 56 bytes is too large. Switching to secp256k1 serialized\n> 32-byte pubkeys (in a script version upgrade, for example) would\n> reduce this to the necessary 55 bytes with 0 bits of grinding. A\n> smaller variant is possible:\n>\n>     DUP HASH160 <fake-pubkey-hash> EQUALVERIFY CHECKSIGVERIFY HASH160\n> <preimage> EQUAL\n>\n> This is 46 bytes, but requires grinding 96 bits, which is a bit less\n> plausible.\n>\n> Belts and suspenders are not so terrible together, however, and I\n> think there is enough of a justification here to look into modifying\n> the scheme to use a different IV for hash tree updates. This would\n> prevent even the above implausible attacks.\n>\n>\n> > On Sep 7, 2017, at 11:55 AM, Russell O'Connor <roconnor at blockstream.io>\n> wrote:\n> >\n> >\n> >\n> > On Thu, Sep 7, 2017 at 1:42 PM, Mark Friedenbach <mark at friedenbach.org\n> <mailto:mark at friedenbach.org>> wrote:\n> > I've been puzzling over your email since receiving it. I'm not sure it\n> > is possible to perform the attack you describe with the tree structure\n> > specified in the BIP. If I may rephrase your attack, I believe you are\n> > seeking a solution to the following:\n> >\n> > Want: An innocuous script and a malign script for which\n> >\n> >    double-SHA256(innocuous)\n> >\n> > is equal to either\n> >\n> >    fast-SHA256(double-SHA256(malign) || r) or\n> >    fast-SHA256(r || double-SHA256(malign))\n> >\n> > or  fast-SHA256(fast-SHA256(double-SHA256(malign) || r1) || r0)\n> > or  fast-SHA256(fast-SHA256(r1 || double-SHA256(malign)) || r0)\n> > or ...\n> >\n> > where r is a freely chosen 32-byte nonce. This would allow the\n> > attacker to reveal the innocuous script before funds are sent to the\n> > MAST, then use the malign script to spend.\n> >\n> > Because of the double-SHA256 construction I do not see how this can be\n> > accomplished without a full break of SHA256.\n> >\n> > The particular scenario I'm imagining is a collision between\n> >\n> >     double-SHA256(innocuous)\n> >\n> > and\n> >\n> >     fast-SHA256(fast-SHA256(fast-SHA256(double-SHA256(malign) || r2) ||\n> r1) || r0).\n> >\n> > where innocuous is a Bitcoin Script that is between 32 and 55 bytes long.\n> >\n> > Observe that when data is less than 55 bytes then double-SHA256(data) =\n> fast-SHA256(fast-SHA256(padding-SHA256(data)) || 0x8000...100) (which is\n> really the crux of the matter).\n> >\n> > Therefore, to get our collision it suffices to find a collision between\n> >\n> >     padding-SHA256(innocuous)\n> >\n> > and\n> >\n> >     fast-SHA256(double-SHA256(malign) || r2) || r1\n> >\n> > r1 can freely be set to the second half of padding-SHA256(innocuous), so\n> it suffices to find a collision between\n> >\n> >    fast-SHA256(double-SHA256(malign) || r2)\n> >\n> > and the first half of padding-SHA256(innocuous) which is equal to the\n> first 32 bytes of innocuous.\n> >\n> > Imagine the first opcode of innocuous is the push of a value that the\n> attacker claims to be his 33-byte public key.\n> > So long as the attacker doesn't need to prove that they know the\n> discrete log of this pubkey, they can grind r2 until the result of\n> fast-SHA256(double-SHA256(malign) || r2) contains the correct first\n> couple of bytes for the script header and the opcode for a 33-byte push.  I\n> believe that is only about 3 or 4 bytes of they need to grind out.\n> >\n>\n> -------------- next part --------------\n> An HTML attachment was scrubbed...\n> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> attachments/20170907/63af0292/attachment-0001.html>\n>\n> ------------------------------\n>\n> Message: 4\n> Date: Thu, 7 Sep 2017 22:39:17 +0200\n> From: Thomas Voegtlin <thomasv at electrum.org>\n> To: \"bitcoin-dev at lists.linuxfoundation.org\"\n>         <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: Re: [bitcoin-dev] Proposal: Extended serialization format for\n>         BIP-32 wallets\n> Message-ID: <9e74dc17-105c-b43c-7780-4fa690043fe2 at electrum.org>\n> Content-Type: text/plain; charset=windows-1252\n>\n>\n>\n> On 07.09.2017 18:23, Pavol Rusnak wrote:\n> > On 07/09/17 06:29, Thomas Voegtlin via bitcoin-dev wrote:\n> >> A solution is still needed to wallets who do not wish to use BIP43\n> >\n> > What if we added another byte field OutputType for wallets that do not\n> > follow BIP43?\n> >\n> > 0x00 - P2PKH output type\n> > 0x01 - P2WPKH-in-P2SH output type\n> > 0x02 - native Segwit output type\n> >\n> > Would that work for you?\n> >\n> > The question is whether this field should be present only if depth==0x00\n> > or at all times. What is your suggestion, Thomas?\n> >\n>\n>\n> well, in my initial proposal, I wrote that this value should be user\n> visible. That is why I used version bytes. If you create an extra byte\n> field, and then use base58 or bech32 encoding, the value will not be\n> user visible anymore.\n>\n> The initial implementation of segwit xpub/xprv in Electrum used a flag\n> that was not user visible (I added 1 to the bip32 version bytes, which\n> leaves the xpub/xprv prefix unchanged). I have experimented with that\n> invisible flag for more than 6 months now, and I am now convinced that\n> it is better to make that flag user visible.\n>\n> The reason is that when users create wallets with multisig scripts, they\n> need to combine several master public keys. However, these master public\n> keys should all be of the same type: it would not make sense to create a\n> 2 of 3 multisig wallet with a one xpub, one ypub and one zpub. By\n> imposing that all master keys are of the same type, we ensure that all\n> cosigners agree on the script type that will be used to derive addresses.\n>\n> In other words, if users are exposed to master keys and need to\n> manipulate them, it is better to let them see what they are doing.\n>\n> OTOH if you do not plan to expose your users to these keys, you probably\n> do not need a serialization format.\n>\n>\n> ------------------------------\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> End of bitcoin-dev Digest, Vol 28, Issue 17\n> *******************************************\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170909/93b760d3/attachment-0001.html>"
            },
            {
                "author": "Thomas Voegtlin",
                "date": "2017-09-12T09:06:15",
                "message_text_only": "On 09.09.2017 16:08, shiva sitamraju via bitcoin-dev wrote:\n> Hi,\n> \n> I understand the motivation of adding the birthdate field. However, not\n> very comfortable with having this in the public key serialization. There\n> are privacy implication of both the birthday field and having the complete\n> derivation path, which takes space.\n> > I am fine with Thomas proposal of {x,y,z}. Having additional version byte\n> field looks modular but since since we already have the big enough version\n> field in bip32, better to use that instead of adding more bytes.\n> \n> Thomas, can you please explain why we require different version for P2WPKH\n> or P2WSH versus (P2WPKH or P2WSH) nested in P2SH. It looked to me that they\n> would have the same output bitcoin address and under same account.\n\nno, native scripts do not have the same address. see bip173\n\n\n> \n> On Fri, Sep 8, 2017 at 2:09 AM, <\n> bitcoin-dev-request at lists.linuxfoundation.org> wrote:\n> \n>> Send bitcoin-dev mailing list submissions to\n>>         bitcoin-dev at lists.linuxfoundation.org\n>>\n>> To subscribe or unsubscribe via the World Wide Web, visit\n>>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>> or, via email, send a message with subject or body 'help' to\n>>         bitcoin-dev-request at lists.linuxfoundation.org\n>>\n>> You can reach the person managing the list at\n>>         bitcoin-dev-owner at lists.linuxfoundation.org\n>>\n>> When replying, please edit your Subject line so it is more specific\n>> than \"Re: Contents of bitcoin-dev digest...\"\n>>\n>>\n>> Today's Topics:\n>>\n>>    1. Re: Proposal: Extended serialization format for   BIP-32\n>>       wallets (Andreas Schildbach)\n>>    2. Re: Proposal: Extended serialization format for BIP-32\n>>       wallets (Pavol Rusnak)\n>>    3. Re: Fast Merkle Trees (Mark Friedenbach)\n>>    4. Re: Proposal: Extended serialization format for BIP-32\n>>       wallets (Thomas Voegtlin)\n>>\n>>\n>> ----------------------------------------------------------------------\n>>\n>> Message: 1\n>> Date: Thu, 7 Sep 2017 21:35:49 +0200\n>> From: Andreas Schildbach <andreas at schildbach.de>\n>> To: bitcoin-dev at lists.linuxfoundation.org\n>> Subject: Re: [bitcoin-dev] Proposal: Extended serialization format for\n>>         BIP-32 wallets\n>> Message-ID: <oos72e$rjp$1 at blaine.gmane.org>\n>> Content-Type: text/plain; charset=utf-8\n>>\n>> On 09/07/2017 06:23 PM, Pavol Rusnak via bitcoin-dev wrote:\n>>> On 07/09/17 06:29, Thomas Voegtlin via bitcoin-dev wrote:\n>>>> A solution is still needed to wallets who do not wish to use BIP43\n>>>\n>>> What if we added another byte field OutputType for wallets that do not\n>>> follow BIP43?\n>>>\n>>> 0x00 - P2PKH output type\n>>> 0x01 - P2WPKH-in-P2SH output type\n>>> 0x02 - native Segwit output type\n>>>\n>>> Would that work for you?\n>>\n>> I think that would work.\n>>\n>>> The question is whether this field should be present only if depth==0x00\n>>> or at all times. What is your suggestion, Thomas?\n>>\n>> In case of Bitcoin Wallet, the depth is not null (m/0'/[0,1]) and still\n>> we need this field. I think it should always be present if a chain is\n>> limited to a certain script type.\n>>\n>> There is however the case where even on one chain, script types are\n>> mixed. In this case the field should be omitted and the wallet needs to\n>> scan for all (known) types. Afaik Bitcoin Core is taking this path.\n>>\n>>\n>>\n>> ------------------------------\n>>\n>> Message: 2\n>> Date: Thu, 7 Sep 2017 22:00:05 +0200\n>> From: Pavol Rusnak <stick at satoshilabs.com>\n>> To: Andreas Schildbach <andreas at schildbach.de>, Bitcoin Protocol\n>>         Discussion <bitcoin-dev at lists.linuxfoundation.org>\n>> Subject: Re: [bitcoin-dev] Proposal: Extended serialization format for\n>>         BIP-32 wallets\n>> Message-ID: <40ed03a1-915c-33b0-c4ac-e898c8c733ba at satoshilabs.com>\n>> Content-Type: text/plain; charset=windows-1252\n>>\n>> On 07/09/17 21:35, Andreas Schildbach via bitcoin-dev wrote:\n>>> In case of Bitcoin Wallet, the depth is not null (m/0'/[0,1]) and still\n>>> we need this field.\n>>\n>> But the depth of exported public key will be null. It does not make\n>> sense to export xpub for m or m/0' for your particular case.\n>>\n>>> I think it should always be present if a chain is\n>>> limited to a certain script type.\n>>\n>> I am fine with having the path there all the time.\n>>\n>>> There is however the case where even on one chain, script types are\n>>> mixed. In this case the field should be omitted and the wallet needs to\n>>> scan for all (known) types. Afaik Bitcoin Core is taking this path.\n>>\n>> Is that really the case? Why come up with a hierarchy and then don't use\n>> it?\n>>\n>> --\n>> Best Regards / S pozdravom,\n>>\n>> Pavol \"stick\" Rusnak\n>> CTO, SatoshiLabs\n>>\n>>\n>> ------------------------------\n>>\n>> Message: 3\n>> Date: Thu, 7 Sep 2017 13:04:30 -0700\n>> From: Mark Friedenbach <mark at friedenbach.org>\n>> To: Russell O'Connor <roconnor at blockstream.io>\n>> Cc: Bitcoin Protocol Discussion\n>>         <bitcoin-dev at lists.linuxfoundation.org>\n>> Subject: Re: [bitcoin-dev] Fast Merkle Trees\n>> Message-ID: <40D6F502-3380-4B64-BCD9-80D361EED35C at friedenbach.org>\n>> Content-Type: text/plain; charset=\"us-ascii\"\n>>\n>> TL;DR I'll be updating the fast Merkle-tree spec to use a different\n>>       IV, using (for infrastructure compatability reasons) the scheme\n>>       provided by Peter Todd.\n>>\n>> This is a specific instance of a general problem where you cannot\n>> trust scripts given to you by another party. Notice that we run into\n>> the same sort of problem when doing key aggregation, in which you must\n>> require the other party to prove knowledge of the discrete log before\n>> using their public key, or else key cancellation can occur.\n>>\n>> With script it is a little bit more complicated as you might want\n>> zero-knowledge proofs of hash pre-images for HTLCs as well as proofs\n>> of DL knowledge (signatures), but the basic idea is the same. Multi-\n>> party wallet level protocols for jointly constructing scriptPubKeys\n>> should require a 'delinearization' step that proves knowledge of\n>> information necessary to complete each part of the script, as part of\n>> proving the safety of a construct.\n>>\n>> I think my hangup before in understanding the attack you describe was\n>> in actualizing it into a practical attack that actually escalates the\n>> attacker's capabilities. If the attacker can get you to agree to a\n>> MAST policy that is nothing more than a CHECKSIG over a key they\n>> presumably control, then they don't need to do any complicated\n>> grinding. The attacker in that scenario would just actually specify a\n>> key they control and take the funds that way.\n>>\n>> Where this presumably leads to an actual exploit is when you specify a\n>> script that a curious counter-party actually takes the time to\n>> investigate and believes to be secure. For example, a script that\n>> requires a signature or pre-image revelation from that counter-party.\n>> That would require grinding not a few bytes, but at minimum 20-33\n>> bytes for either a HASH160 image or the counter-party's key.\n>>\n>> If I understand the revised attack description correctly, then there\n>> is a small window in which the attacker can create a script less than\n>> 55 bytes in length, where nearly all of the first 32 bytes are\n>> selected by the attacker, yet nevertheless the script seems safe to\n>> the counter-party. The smallest such script I was able to construct\n>> was the following:\n>>\n>>     <fake-pubkey> CHECKSIGVERIFY HASH160 <preimage> EQUAL\n>>\n>> This is 56 bytes and requires only 7 bits of grinding in the fake\n>> pubkey. But 56 bytes is too large. Switching to secp256k1 serialized\n>> 32-byte pubkeys (in a script version upgrade, for example) would\n>> reduce this to the necessary 55 bytes with 0 bits of grinding. A\n>> smaller variant is possible:\n>>\n>>     DUP HASH160 <fake-pubkey-hash> EQUALVERIFY CHECKSIGVERIFY HASH160\n>> <preimage> EQUAL\n>>\n>> This is 46 bytes, but requires grinding 96 bits, which is a bit less\n>> plausible.\n>>\n>> Belts and suspenders are not so terrible together, however, and I\n>> think there is enough of a justification here to look into modifying\n>> the scheme to use a different IV for hash tree updates. This would\n>> prevent even the above implausible attacks.\n>>\n>>\n>>> On Sep 7, 2017, at 11:55 AM, Russell O'Connor <roconnor at blockstream.io>\n>> wrote:\n>>>\n>>>\n>>>\n>>> On Thu, Sep 7, 2017 at 1:42 PM, Mark Friedenbach <mark at friedenbach.org\n>> <mailto:mark at friedenbach.org>> wrote:\n>>> I've been puzzling over your email since receiving it. I'm not sure it\n>>> is possible to perform the attack you describe with the tree structure\n>>> specified in the BIP. If I may rephrase your attack, I believe you are\n>>> seeking a solution to the following:\n>>>\n>>> Want: An innocuous script and a malign script for which\n>>>\n>>>    double-SHA256(innocuous)\n>>>\n>>> is equal to either\n>>>\n>>>    fast-SHA256(double-SHA256(malign) || r) or\n>>>    fast-SHA256(r || double-SHA256(malign))\n>>>\n>>> or  fast-SHA256(fast-SHA256(double-SHA256(malign) || r1) || r0)\n>>> or  fast-SHA256(fast-SHA256(r1 || double-SHA256(malign)) || r0)\n>>> or ...\n>>>\n>>> where r is a freely chosen 32-byte nonce. This would allow the\n>>> attacker to reveal the innocuous script before funds are sent to the\n>>> MAST, then use the malign script to spend.\n>>>\n>>> Because of the double-SHA256 construction I do not see how this can be\n>>> accomplished without a full break of SHA256.\n>>>\n>>> The particular scenario I'm imagining is a collision between\n>>>\n>>>     double-SHA256(innocuous)\n>>>\n>>> and\n>>>\n>>>     fast-SHA256(fast-SHA256(fast-SHA256(double-SHA256(malign) || r2) ||\n>> r1) || r0).\n>>>\n>>> where innocuous is a Bitcoin Script that is between 32 and 55 bytes long.\n>>>\n>>> Observe that when data is less than 55 bytes then double-SHA256(data) =\n>> fast-SHA256(fast-SHA256(padding-SHA256(data)) || 0x8000...100) (which is\n>> really the crux of the matter).\n>>>\n>>> Therefore, to get our collision it suffices to find a collision between\n>>>\n>>>     padding-SHA256(innocuous)\n>>>\n>>> and\n>>>\n>>>     fast-SHA256(double-SHA256(malign) || r2) || r1\n>>>\n>>> r1 can freely be set to the second half of padding-SHA256(innocuous), so\n>> it suffices to find a collision between\n>>>\n>>>    fast-SHA256(double-SHA256(malign) || r2)\n>>>\n>>> and the first half of padding-SHA256(innocuous) which is equal to the\n>> first 32 bytes of innocuous.\n>>>\n>>> Imagine the first opcode of innocuous is the push of a value that the\n>> attacker claims to be his 33-byte public key.\n>>> So long as the attacker doesn't need to prove that they know the\n>> discrete log of this pubkey, they can grind r2 until the result of\n>> fast-SHA256(double-SHA256(malign) || r2) contains the correct first\n>> couple of bytes for the script header and the opcode for a 33-byte push.  I\n>> believe that is only about 3 or 4 bytes of they need to grind out.\n>>>\n>>\n>> -------------- next part --------------\n>> An HTML attachment was scrubbed...\n>> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n>> attachments/20170907/63af0292/attachment-0001.html>\n>>\n>> ------------------------------\n>>\n>> Message: 4\n>> Date: Thu, 7 Sep 2017 22:39:17 +0200\n>> From: Thomas Voegtlin <thomasv at electrum.org>\n>> To: \"bitcoin-dev at lists.linuxfoundation.org\"\n>>         <bitcoin-dev at lists.linuxfoundation.org>\n>> Subject: Re: [bitcoin-dev] Proposal: Extended serialization format for\n>>         BIP-32 wallets\n>> Message-ID: <9e74dc17-105c-b43c-7780-4fa690043fe2 at electrum.org>\n>> Content-Type: text/plain; charset=windows-1252\n>>\n>>\n>>\n>> On 07.09.2017 18:23, Pavol Rusnak wrote:\n>>> On 07/09/17 06:29, Thomas Voegtlin via bitcoin-dev wrote:\n>>>> A solution is still needed to wallets who do not wish to use BIP43\n>>>\n>>> What if we added another byte field OutputType for wallets that do not\n>>> follow BIP43?\n>>>\n>>> 0x00 - P2PKH output type\n>>> 0x01 - P2WPKH-in-P2SH output type\n>>> 0x02 - native Segwit output type\n>>>\n>>> Would that work for you?\n>>>\n>>> The question is whether this field should be present only if depth==0x00\n>>> or at all times. What is your suggestion, Thomas?\n>>>\n>>\n>>\n>> well, in my initial proposal, I wrote that this value should be user\n>> visible. That is why I used version bytes. If you create an extra byte\n>> field, and then use base58 or bech32 encoding, the value will not be\n>> user visible anymore.\n>>\n>> The initial implementation of segwit xpub/xprv in Electrum used a flag\n>> that was not user visible (I added 1 to the bip32 version bytes, which\n>> leaves the xpub/xprv prefix unchanged). I have experimented with that\n>> invisible flag for more than 6 months now, and I am now convinced that\n>> it is better to make that flag user visible.\n>>\n>> The reason is that when users create wallets with multisig scripts, they\n>> need to combine several master public keys. However, these master public\n>> keys should all be of the same type: it would not make sense to create a\n>> 2 of 3 multisig wallet with a one xpub, one ypub and one zpub. By\n>> imposing that all master keys are of the same type, we ensure that all\n>> cosigners agree on the script type that will be used to derive addresses.\n>>\n>> In other words, if users are exposed to master keys and need to\n>> manipulate them, it is better to let them see what they are doing.\n>>\n>> OTOH if you do not plan to expose your users to these keys, you probably\n>> do not need a serialization format.\n>>\n>>\n>> ------------------------------\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>> End of bitcoin-dev Digest, Vol 28, Issue 17\n>> *******************************************\n>>\n> \n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n\n-- \nElectrum Technologies GmbH / Waldemarstr 37a / 10999 Berlin / Germany\nSitz, Registergericht: Berlin, Amtsgericht Charlottenburg, HRB 164636\nGesch\u00e4ftsf\u00fchrer: Thomas Voegtlin"
            },
            {
                "author": "shiva sitamraju",
                "date": "2017-09-12T12:06:40",
                "message_text_only": "Thanks Thomas for pointing me to bip173. If everyone is fine, we should go\nforward with formalizing Thomas' proposal asap. Already segwit wallet\nusage/demand is increasing !\n\nOn Tue, Sep 12, 2017 at 4:54 PM, <\nbitcoin-dev-request at lists.linuxfoundation.org> wrote:\n\n> Send bitcoin-dev mailing list submissions to\n>         bitcoin-dev at lists.linuxfoundation.org\n>\n> To subscribe or unsubscribe via the World Wide Web, visit\n>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> or, via email, send a message with subject or body 'help' to\n>         bitcoin-dev-request at lists.linuxfoundation.org\n>\n> You can reach the person managing the list at\n>         bitcoin-dev-owner at lists.linuxfoundation.org\n>\n> When replying, please edit your Subject line so it is more specific\n> than \"Re: Contents of bitcoin-dev digest...\"\n>\n>\n> Today's Topics:\n>\n>    1. Re: Merkle branch verification & tail-call semantics for\n>       generalized MAST (Johnson Lau)\n>    2. Re: Proposal: Extended serialization format for BIP-32\n>       (Thomas Voegtlin)\n>    3. Re: Responsible disclosure of bugs (Sergio Demian Lerner)\n>\n>\n> ----------------------------------------------------------------------\n>\n> Message: 1\n> Date: Tue, 12 Sep 2017 16:55:59 +0800\n> From: Johnson Lau <jl2012 at xbt.hk>\n> To: Mark Friedenbach <mark at friedenbach.org>\n> Cc: bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: Re: [bitcoin-dev] Merkle branch verification & tail-call\n>         semantics for generalized MAST\n> Message-ID: <DA22C531-2FAE-4332-B158-A3F96BF34002 at xbt.hk>\n> Content-Type: text/plain; charset=utf-8\n>\n>\n> > On 12 Sep 2017, at 10:03 AM, Mark Friedenbach <mark at friedenbach.org>\n> wrote:\n> >\n> > My apologies for a delay in responding to emails on this list; I have\n> > been fighting a cold.\n> >\n> > (Also my apologies to Johnson Lau, as I forgot to forward this to the\n> list.)\n> >\n> > On Sep 8, 2017, at 2:21 AM, Johnson Lau <jl2012 at xbt.hk> wrote:\n> >\n> >> Tail-call execution semantics require \"unclean stake\" , i.e. final\n> >> stake with more than one item. However, \"unclean stake\" is invalid\n> >> (not just non-standard) in BIP141, so you could only use it with\n> >> legacy P2SH (which is totally pointless....). A different design\n> >> like OP_EVAL might be needed, or you need a new witness script\n> >> version.\n> >\n> > I believe you meant \"unclean stack,\" and you are correct. This was\n> > also pointed out last tuesday by a participant at the in-person\n> > CoreDev meetup where the idea was presented.\n> >\n> > This doesn't kill the idea, it just complicates the implementation\n> > slightly. A simple fix would be to allow tail-recursion to occur if\n> > the stack is not clean (as can happen with legacy P2SH as you point\n> > out, or yet to be defined version 1+ forms of segwit script), OR if\n> > there is a single item on the stack and the alt-stack is not empty.\n> > For segwit v0 scripts you then have to move any arguments to the alt\n> > stack before ending the redeem script, leaving just the policy script\n> > on the main stack.\n>\n> This is ugly and actually broken, as different script path may require\n> different number of stack items, so you don?t know how many OP_TOALTSTACK\n> do you need. Easier to just use a new witness version\n>\n> >\n> >> I think you have also missed the sigOp counting of the executed\n> >> script. As you can't count it without executing the script, the\n> >> current static analysability is lost. This was one of the reasons\n> >> for OP_EVAL being rejected. Since sigOp is a per-block limit, any\n> >> OP_EVAL-like operation means block validity will depend on the\n> >> precise outcome of script execution (instead of just pass or fail),\n> >> which is a layer violation.\n> >\n> > I disagree with this design requirement.\n> >\n> > The SigOp counting method used by bitcoin is flawed. It incorrectly\n> > limits not the number of signature operations necessary to validate a\n> > block, but rather the number of CHECKSIGs potentially encountered in\n> > script execution, even if in an unexecuted branch. (Admitedly MAST\n> > makes this less of an issue, but there are still useful compact\n> > scripts that use if/else constructs to elide a CHECKSIG.) Nor will it\n> > account for aggregation when that feature is added, or properly\n> > differentiate between signature operations that can be batched and\n> > those that can not.\n> >\n> > Additionally there are other resources used by script that should be\n> > globally limited, such as hash operations, which are not accounted for\n> > at this time and cannot be statically assessed, even by the flawed\n> > mechanism by which SigOps are counted. I have maintained for some time\n> > that bitcoin should move from having multiple separate global limits\n> > (weight and sigops, hashed bytes in XT/Classic/BCH) to a single linear\n> > metric that combines all of these factors with appropriate\n> > coefficients.\n> >\n>\n> I like the idea to have an unified global limit and suggested a way to do\n> it (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-January/\n> 013472.html). But I think this is off-topic here.\n>\n>\n>\n> > A better way of handling this problem, which works for both SigOps and\n> > HashOps, is to have the witness commit to the maximum resources\n> > consumed by validation of the spend of the coin, to relay this data\n> > with the transaction and include it in the SigHash, and to use the\n> > committed maximum for block validation. This could be added in a\n> > future script version upgrade. This change would also resolve the\n> > issue that led to the clean stack rule in segwit, allowing future\n> > versions of script to use tail-call recursion without involving the\n> > alt-stack.\n> >\n> > Nevertheless it is constructive feedback that the current draft of the\n> > BIP and its implementation do not count SigOps, at all. There are a\n> > couple of ways this can be fixed by evaluating the top-level script\n> > and then doing static analysis of the resulting policy script, or by\n> > running the script and counting operations actually performed.\n>\n>\n> In any case, I think maintaining static analysability for global limit(s)\n> is very important. Ethereum had to give up their DAO softfork plan at the\n> last minute, exactly due to the lack of this:\n> http://hackingdistributed.com/2016/06/28/ethereum-soft-fork-dos-vector/\n>\n> Otherwise, one could attack relay and mining nodes by sending many small\n> size txs with many sigops, forcing them to validate, and discard due to\n> insufficient fees.\n>\n> Technically it might be ok if we commit the total validation cost (sigop +\n> hashop + whatever) as the first witness stack item, but that?d take more\n> space and I?m not sure if it is desirable. Anyway, giving up static\n> analysability for scripts is a fundamental change to our existing model.\n>\n> >\n> > Additionally, it is possible that we take this time to re-evaluate\n> > whether we should be counting SigOps other than for legacy consensus\n> > rule compliance. The speed of verification in secp256k1 has made\n> > signature operations no longer the chief concern in block validation\n> > times.\n>\n> Without the limit I think we would be DoS-ed to dead\n>\n>\n> >> Witness script versioning is by design fully compatible with P2SH\n> >> and BIP173, so there will be no hurdle for existing wallets to pay\n> >> to BIP114. Actually it should be completely transparent to them.\n> >\n> > This is correct. Your feedback will be incorporated.\n> >\n> >> For code complexity, the minimal BIP114 could be really simple, like\n> >> <30 lines of code? It looks complex now because it does much more\n> >> than simply hiding scripts in a hash.\n> >\n> > Is there a repo that contains the latest implementation of BIP 114,\n> > for comparison purposes?\n>\n>\n> You can find it here: https://github.com/jl2012/bitcoin/commits/vault\n> https://github.com/jl2012/bitcoin/commit/f3f201d232d3995db38e09b171e4d1\n> dea8d04ad2\n>\n> But this does more than your proposal as it allows users adding extra\n> scripts when spending a coin. The rationale is described in the revised\n> BIP114:\n> https://github.com/jl2012/bips/blob/vault/bip-0114.\n> mediawiki#Additional_scripts_in_witness\n>\n> So to make it functionally comparable with your proposal, the\n> IsMSV0Stack() function is not needed. The new 249-254 lines in\n> interpreter.cpp could be removed. The new 1480-1519 lines could be replaced\n> by a few lines copied from the existing P2WSH code. I can make a minimal\n> version if you want to see how it looks like\n>\n>\n> >\n> > Kind regards,\n> > Mark Friedenbach\n> >\n>\n>\n>\n>\n> ------------------------------\n>\n> Message: 2\n> Date: Tue, 12 Sep 2017 11:06:15 +0200\n> From: Thomas Voegtlin <thomasv at electrum.org>\n> To: bitcoin-dev at lists.linuxfoundation.org\n> Subject: Re: [bitcoin-dev] Proposal: Extended serialization format for\n>         BIP-32\n> Message-ID: <99643f72-f72f-e4e9-ac2b-72bf519c25b5 at electrum.org>\n> Content-Type: text/plain; charset=utf-8\n>\n>\n>\n> On 09.09.2017 16:08, shiva sitamraju via bitcoin-dev wrote:\n> > Hi,\n> >\n> > I understand the motivation of adding the birthdate field. However, not\n> > very comfortable with having this in the public key serialization. There\n> > are privacy implication of both the birthday field and having the\n> complete\n> > derivation path, which takes space.\n> > > I am fine with Thomas proposal of {x,y,z}. Having additional version\n> byte\n> > field looks modular but since since we already have the big enough\n> version\n> > field in bip32, better to use that instead of adding more bytes.\n> >\n> > Thomas, can you please explain why we require different version for\n> P2WPKH\n> > or P2WSH versus (P2WPKH or P2WSH) nested in P2SH. It looked to me that\n> they\n> > would have the same output bitcoin address and under same account.\n>\n> no, native scripts do not have the same address. see bip173\n>\n>\n> >\n> > On Fri, Sep 8, 2017 at 2:09 AM, <\n> > bitcoin-dev-request at lists.linuxfoundation.org> wrote:\n> >\n> >> Send bitcoin-dev mailing list submissions to\n> >>         bitcoin-dev at lists.linuxfoundation.org\n> >>\n> >> To subscribe or unsubscribe via the World Wide Web, visit\n> >>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >> or, via email, send a message with subject or body 'help' to\n> >>         bitcoin-dev-request at lists.linuxfoundation.org\n> >>\n> >> You can reach the person managing the list at\n> >>         bitcoin-dev-owner at lists.linuxfoundation.org\n> >>\n> >> When replying, please edit your Subject line so it is more specific\n> >> than \"Re: Contents of bitcoin-dev digest...\"\n> >>\n> >>\n> >> Today's Topics:\n> >>\n> >>    1. Re: Proposal: Extended serialization format for   BIP-32\n> >>       wallets (Andreas Schildbach)\n> >>    2. Re: Proposal: Extended serialization format for BIP-32\n> >>       wallets (Pavol Rusnak)\n> >>    3. Re: Fast Merkle Trees (Mark Friedenbach)\n> >>    4. Re: Proposal: Extended serialization format for BIP-32\n> >>       wallets (Thomas Voegtlin)\n> >>\n> >>\n> >> ----------------------------------------------------------------------\n> >>\n> >> Message: 1\n> >> Date: Thu, 7 Sep 2017 21:35:49 +0200\n> >> From: Andreas Schildbach <andreas at schildbach.de>\n> >> To: bitcoin-dev at lists.linuxfoundation.org\n> >> Subject: Re: [bitcoin-dev] Proposal: Extended serialization format for\n> >>         BIP-32 wallets\n> >> Message-ID: <oos72e$rjp$1 at blaine.gmane.org>\n> >> Content-Type: text/plain; charset=utf-8\n> >>\n> >> On 09/07/2017 06:23 PM, Pavol Rusnak via bitcoin-dev wrote:\n> >>> On 07/09/17 06:29, Thomas Voegtlin via bitcoin-dev wrote:\n> >>>> A solution is still needed to wallets who do not wish to use BIP43\n> >>>\n> >>> What if we added another byte field OutputType for wallets that do not\n> >>> follow BIP43?\n> >>>\n> >>> 0x00 - P2PKH output type\n> >>> 0x01 - P2WPKH-in-P2SH output type\n> >>> 0x02 - native Segwit output type\n> >>>\n> >>> Would that work for you?\n> >>\n> >> I think that would work.\n> >>\n> >>> The question is whether this field should be present only if\n> depth==0x00\n> >>> or at all times. What is your suggestion, Thomas?\n> >>\n> >> In case of Bitcoin Wallet, the depth is not null (m/0'/[0,1]) and still\n> >> we need this field. I think it should always be present if a chain is\n> >> limited to a certain script type.\n> >>\n> >> There is however the case where even on one chain, script types are\n> >> mixed. In this case the field should be omitted and the wallet needs to\n> >> scan for all (known) types. Afaik Bitcoin Core is taking this path.\n> >>\n> >>\n> >>\n> >> ------------------------------\n> >>\n> >> Message: 2\n> >> Date: Thu, 7 Sep 2017 22:00:05 +0200\n> >> From: Pavol Rusnak <stick at satoshilabs.com>\n> >> To: Andreas Schildbach <andreas at schildbach.de>, Bitcoin Protocol\n> >>         Discussion <bitcoin-dev at lists.linuxfoundation.org>\n> >> Subject: Re: [bitcoin-dev] Proposal: Extended serialization format for\n> >>         BIP-32 wallets\n> >> Message-ID: <40ed03a1-915c-33b0-c4ac-e898c8c733ba at satoshilabs.com>\n> >> Content-Type: text/plain; charset=windows-1252\n> >>\n> >> On 07/09/17 21:35, Andreas Schildbach via bitcoin-dev wrote:\n> >>> In case of Bitcoin Wallet, the depth is not null (m/0'/[0,1]) and still\n> >>> we need this field.\n> >>\n> >> But the depth of exported public key will be null. It does not make\n> >> sense to export xpub for m or m/0' for your particular case.\n> >>\n> >>> I think it should always be present if a chain is\n> >>> limited to a certain script type.\n> >>\n> >> I am fine with having the path there all the time.\n> >>\n> >>> There is however the case where even on one chain, script types are\n> >>> mixed. In this case the field should be omitted and the wallet needs to\n> >>> scan for all (known) types. Afaik Bitcoin Core is taking this path.\n> >>\n> >> Is that really the case? Why come up with a hierarchy and then don't use\n> >> it?\n> >>\n> >> --\n> >> Best Regards / S pozdravom,\n> >>\n> >> Pavol \"stick\" Rusnak\n> >> CTO, SatoshiLabs\n> >>\n> >>\n> >> ------------------------------\n> >>\n> >> Message: 3\n> >> Date: Thu, 7 Sep 2017 13:04:30 -0700\n> >> From: Mark Friedenbach <mark at friedenbach.org>\n> >> To: Russell O'Connor <roconnor at blockstream.io>\n> >> Cc: Bitcoin Protocol Discussion\n> >>         <bitcoin-dev at lists.linuxfoundation.org>\n> >> Subject: Re: [bitcoin-dev] Fast Merkle Trees\n> >> Message-ID: <40D6F502-3380-4B64-BCD9-80D361EED35C at friedenbach.org>\n> >> Content-Type: text/plain; charset=\"us-ascii\"\n> >>\n> >> TL;DR I'll be updating the fast Merkle-tree spec to use a different\n> >>       IV, using (for infrastructure compatability reasons) the scheme\n> >>       provided by Peter Todd.\n> >>\n> >> This is a specific instance of a general problem where you cannot\n> >> trust scripts given to you by another party. Notice that we run into\n> >> the same sort of problem when doing key aggregation, in which you must\n> >> require the other party to prove knowledge of the discrete log before\n> >> using their public key, or else key cancellation can occur.\n> >>\n> >> With script it is a little bit more complicated as you might want\n> >> zero-knowledge proofs of hash pre-images for HTLCs as well as proofs\n> >> of DL knowledge (signatures), but the basic idea is the same. Multi-\n> >> party wallet level protocols for jointly constructing scriptPubKeys\n> >> should require a 'delinearization' step that proves knowledge of\n> >> information necessary to complete each part of the script, as part of\n> >> proving the safety of a construct.\n> >>\n> >> I think my hangup before in understanding the attack you describe was\n> >> in actualizing it into a practical attack that actually escalates the\n> >> attacker's capabilities. If the attacker can get you to agree to a\n> >> MAST policy that is nothing more than a CHECKSIG over a key they\n> >> presumably control, then they don't need to do any complicated\n> >> grinding. The attacker in that scenario would just actually specify a\n> >> key they control and take the funds that way.\n> >>\n> >> Where this presumably leads to an actual exploit is when you specify a\n> >> script that a curious counter-party actually takes the time to\n> >> investigate and believes to be secure. For example, a script that\n> >> requires a signature or pre-image revelation from that counter-party.\n> >> That would require grinding not a few bytes, but at minimum 20-33\n> >> bytes for either a HASH160 image or the counter-party's key.\n> >>\n> >> If I understand the revised attack description correctly, then there\n> >> is a small window in which the attacker can create a script less than\n> >> 55 bytes in length, where nearly all of the first 32 bytes are\n> >> selected by the attacker, yet nevertheless the script seems safe to\n> >> the counter-party. The smallest such script I was able to construct\n> >> was the following:\n> >>\n> >>     <fake-pubkey> CHECKSIGVERIFY HASH160 <preimage> EQUAL\n> >>\n> >> This is 56 bytes and requires only 7 bits of grinding in the fake\n> >> pubkey. But 56 bytes is too large. Switching to secp256k1 serialized\n> >> 32-byte pubkeys (in a script version upgrade, for example) would\n> >> reduce this to the necessary 55 bytes with 0 bits of grinding. A\n> >> smaller variant is possible:\n> >>\n> >>     DUP HASH160 <fake-pubkey-hash> EQUALVERIFY CHECKSIGVERIFY HASH160\n> >> <preimage> EQUAL\n> >>\n> >> This is 46 bytes, but requires grinding 96 bits, which is a bit less\n> >> plausible.\n> >>\n> >> Belts and suspenders are not so terrible together, however, and I\n> >> think there is enough of a justification here to look into modifying\n> >> the scheme to use a different IV for hash tree updates. This would\n> >> prevent even the above implausible attacks.\n> >>\n> >>\n> >>> On Sep 7, 2017, at 11:55 AM, Russell O'Connor <roconnor at blockstream.io\n> >\n> >> wrote:\n> >>>\n> >>>\n> >>>\n> >>> On Thu, Sep 7, 2017 at 1:42 PM, Mark Friedenbach <mark at friedenbach.org\n> >> <mailto:mark at friedenbach.org>> wrote:\n> >>> I've been puzzling over your email since receiving it. I'm not sure it\n> >>> is possible to perform the attack you describe with the tree structure\n> >>> specified in the BIP. If I may rephrase your attack, I believe you are\n> >>> seeking a solution to the following:\n> >>>\n> >>> Want: An innocuous script and a malign script for which\n> >>>\n> >>>    double-SHA256(innocuous)\n> >>>\n> >>> is equal to either\n> >>>\n> >>>    fast-SHA256(double-SHA256(malign) || r) or\n> >>>    fast-SHA256(r || double-SHA256(malign))\n> >>>\n> >>> or  fast-SHA256(fast-SHA256(double-SHA256(malign) || r1) || r0)\n> >>> or  fast-SHA256(fast-SHA256(r1 || double-SHA256(malign)) || r0)\n> >>> or ...\n> >>>\n> >>> where r is a freely chosen 32-byte nonce. This would allow the\n> >>> attacker to reveal the innocuous script before funds are sent to the\n> >>> MAST, then use the malign script to spend.\n> >>>\n> >>> Because of the double-SHA256 construction I do not see how this can be\n> >>> accomplished without a full break of SHA256.\n> >>>\n> >>> The particular scenario I'm imagining is a collision between\n> >>>\n> >>>     double-SHA256(innocuous)\n> >>>\n> >>> and\n> >>>\n> >>>     fast-SHA256(fast-SHA256(fast-SHA256(double-SHA256(malign) || r2)\n> ||\n> >> r1) || r0).\n> >>>\n> >>> where innocuous is a Bitcoin Script that is between 32 and 55 bytes\n> long.\n> >>>\n> >>> Observe that when data is less than 55 bytes then double-SHA256(data) =\n> >> fast-SHA256(fast-SHA256(padding-SHA256(data)) || 0x8000...100) (which\n> is\n> >> really the crux of the matter).\n> >>>\n> >>> Therefore, to get our collision it suffices to find a collision between\n> >>>\n> >>>     padding-SHA256(innocuous)\n> >>>\n> >>> and\n> >>>\n> >>>     fast-SHA256(double-SHA256(malign) || r2) || r1\n> >>>\n> >>> r1 can freely be set to the second half of padding-SHA256(innocuous),\n> so\n> >> it suffices to find a collision between\n> >>>\n> >>>    fast-SHA256(double-SHA256(malign) || r2)\n> >>>\n> >>> and the first half of padding-SHA256(innocuous) which is equal to the\n> >> first 32 bytes of innocuous.\n> >>>\n> >>> Imagine the first opcode of innocuous is the push of a value that the\n> >> attacker claims to be his 33-byte public key.\n> >>> So long as the attacker doesn't need to prove that they know the\n> >> discrete log of this pubkey, they can grind r2 until the result of\n> >> fast-SHA256(double-SHA256(malign) || r2) contains the correct first\n> >> couple of bytes for the script header and the opcode for a 33-byte\n> push.  I\n> >> believe that is only about 3 or 4 bytes of they need to grind out.\n> >>>\n> >>\n> >> -------------- next part --------------\n> >> An HTML attachment was scrubbed...\n> >> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> >> attachments/20170907/63af0292/attachment-0001.html>\n> >>\n> >> ------------------------------\n> >>\n> >> Message: 4\n> >> Date: Thu, 7 Sep 2017 22:39:17 +0200\n> >> From: Thomas Voegtlin <thomasv at electrum.org>\n> >> To: \"bitcoin-dev at lists.linuxfoundation.org\"\n> >>         <bitcoin-dev at lists.linuxfoundation.org>\n> >> Subject: Re: [bitcoin-dev] Proposal: Extended serialization format for\n> >>         BIP-32 wallets\n> >> Message-ID: <9e74dc17-105c-b43c-7780-4fa690043fe2 at electrum.org>\n> >> Content-Type: text/plain; charset=windows-1252\n> >>\n> >>\n> >>\n> >> On 07.09.2017 18:23, Pavol Rusnak wrote:\n> >>> On 07/09/17 06:29, Thomas Voegtlin via bitcoin-dev wrote:\n> >>>> A solution is still needed to wallets who do not wish to use BIP43\n> >>>\n> >>> What if we added another byte field OutputType for wallets that do not\n> >>> follow BIP43?\n> >>>\n> >>> 0x00 - P2PKH output type\n> >>> 0x01 - P2WPKH-in-P2SH output type\n> >>> 0x02 - native Segwit output type\n> >>>\n> >>> Would that work for you?\n> >>>\n> >>> The question is whether this field should be present only if\n> depth==0x00\n> >>> or at all times. What is your suggestion, Thomas?\n> >>>\n> >>\n> >>\n> >> well, in my initial proposal, I wrote that this value should be user\n> >> visible. That is why I used version bytes. If you create an extra byte\n> >> field, and then use base58 or bech32 encoding, the value will not be\n> >> user visible anymore.\n> >>\n> >> The initial implementation of segwit xpub/xprv in Electrum used a flag\n> >> that was not user visible (I added 1 to the bip32 version bytes, which\n> >> leaves the xpub/xprv prefix unchanged). I have experimented with that\n> >> invisible flag for more than 6 months now, and I am now convinced that\n> >> it is better to make that flag user visible.\n> >>\n> >> The reason is that when users create wallets with multisig scripts, they\n> >> need to combine several master public keys. However, these master public\n> >> keys should all be of the same type: it would not make sense to create a\n> >> 2 of 3 multisig wallet with a one xpub, one ypub and one zpub. By\n> >> imposing that all master keys are of the same type, we ensure that all\n> >> cosigners agree on the script type that will be used to derive\n> addresses.\n> >>\n> >> In other words, if users are exposed to master keys and need to\n> >> manipulate them, it is better to let them see what they are doing.\n> >>\n> >> OTOH if you do not plan to expose your users to these keys, you probably\n> >> do not need a serialization format.\n> >>\n> >>\n> >> ------------------------------\n> >>\n> >> _______________________________________________\n> >> bitcoin-dev mailing list\n> >> bitcoin-dev at lists.linuxfoundation.org\n> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >>\n> >>\n> >> End of bitcoin-dev Digest, Vol 28, Issue 17\n> >> *******************************************\n> >>\n> >\n> >\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n>\n> --\n> Electrum Technologies GmbH / Waldemarstr 37a / 10999 Berlin / Germany\n> Sitz, Registergericht: Berlin, Amtsgericht Charlottenburg, HRB 164636\n> Gesch?ftsf?hrer: Thomas Voegtlin\n>\n>\n> ------------------------------\n>\n> Message: 3\n> Date: Tue, 12 Sep 2017 01:49:34 -0300\n> From: Sergio Demian Lerner <sergio.d.lerner at gmail.com>\n> To: Anthony Towns <aj at erisian.com.au>,  Bitcoin Protocol Discussion\n>         <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: Re: [bitcoin-dev] Responsible disclosure of bugs\n> Message-ID:\n>         <CAKzdR-oYQ8EchpJVE56yJbfBgNHihx7WO_gtFtp6QKOcK7uT-w at mail.gmail.\n> com>\n> Content-Type: text/plain; charset=\"utf-8\"\n>\n> Historically people have published vulnerabilities in Bitcoin only after\n> >80% of the nodes have upgraded. This seems to be the general (but not\n> publicly stated) policy. If you're a core developer and you know better,\n> please correct me.\n>\n> This means that:\n>\n> - a critical vulnerability, like a remote code execution, will be patched\n> immediately (without disclosing the actual problem) and all participants\n> will be notified asap. This is no different from any other open source\n> project. An example of this case was the OpenSSL Heartbleed vulnerability\n> that affected Bitcoin.\n>\n> - a non-critical vulnerability, either because miners only can exploit it\n> or because it requires vast resources to pull, may require a wait of years\n> before publication, after a vulnerability was found and reported. This is\n> because the \"natural\" node upgrade rate is slow.\n>\n> It also implies that some times a researcher works hard to investigate a\n> vulnerability and later he finds out it was previously reported. It also\n> means that the researcher cannot report to alt-coins which have a different\n> policy.\n>\n> This policy has nothing to do with a loyalty to Bitcoin Core (or in fact,\n> the two or so developers that actually receive the e-mails to\n> security at bitcoincore.org).\n>\n> This is a policy that has simply proven to work to protect Bitcoiners. It\n> began long long ago.\n>\n>\n>\n> On Tue, Sep 12, 2017 at 12:37 AM, Anthony Towns via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > On Mon, Sep 11, 2017 at 07:34:33AM -0400, Alex Morcos wrote:\n> > > I don't think I know the right answer here, but I will point out two\n> > things\n> > > that make this a little more complicated.\n> > > 1 - There are lots of altcoin developers and while I'm sure the\n> majority\n> > would\n> > > greatly appreciate the disclosure and would behave responsibly with the\n> > > information, I don't know where you draw the line on who you tell and\n> > who you\n> > > don't.\n> >\n> > If you can't pick even a small group that's trustworthy (top five by\n> > market cap as a start [0]? or just major bitcoin wallets / exchanges /\n> > alt node implementations?), then it still seems better to (eventually)\n> > disclose publically than keep it unrevealed and let it be a potential\n> > advantage for attackers against people who haven't upgraded for other\n> > reasons?\n> >\n> > I find it hard to imagine bitcoin's still obscure enough that people\n> > aren't tracking git commit logs to use them as inspiration for attacks\n> > on bitcoin users and businesses; at best I would have thought it'd\n> > only be a few months of development time between a fix being proposed\n> > as a PR or committed to master and black hats having the ability to\n> > exploit it in users who are running older nodes. (Or for that matter,\n> > being able to be exploited by otherwise legitimate bitcoin businesses\n> > with an agenda to push, a strong financial motive behind that agenda,\n> > and a legal team that says they'll get away with it)\n> >\n> > > 2- Unlike other software, I'm not sure good security for bitcoin is\n> > defined by\n> > > constant upgrading.  Obviously upgrading has an important benefit, but\n> > one of\n> > > the security considerations for Bitcoin is knowing that your definition\n> > of the\n> > > money hasn't changed.  Much harder to know that if you change software.\n> >\n> > Isn't that just an argument for putting more effort into backporting\n> > fixes/workarounds? (I don't see how you do that without essentially\n> > publically disclosing which patches have a security impact -- \"oh,\n> > gosh, this patch gets a backport, I wonder if maybe it has security\n> > implications...\")\n> >\n> > (In so far as bitcoin is a consensus system, there can sometimes be a\n> > positive network effect, where having other people upgrade can help your\n> > security, even if you don't upgrade; \"herd immunity\" if you will. That\n> > way a new release going out to other people helps keep you safe, even\n> > while you continue to maintain the same definition of money by not\n> > upgrading at all)\n> >\n> > If altcoin maintainers are inconvenienced by tracking bitcoin-core\n> > updates, that would be an argument for them to contribute back to their\n> > upstream to make their own job easier; either helping with backports,\n> > or perhaps contributing to patches like PR#8994 might help.\n> >\n> > All of those things seem like they'd help not just altcoins but bitcoin\n> > investors/traders too, so it's not even a trade-off between classes of\n> > bitcoin core users.  And if in the end various altcoins aren't able to\n> > keep up with security fixes, that's probably valuable information to\n> > provide to the market...\n> >\n> > Cheers,\n> > aj\n> >\n> > [0] Roughly: BCash, Litecoin, Dash, BitConnect, ZCash, Dogecoin?\n> >     I've no idea which of those might have trustworthy devs to work with,\n> >     but surely at least a couple do?\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n> -------------- next part --------------\n> An HTML attachment was scrubbed...\n> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> attachments/20170912/78a88c9e/attachment.html>\n>\n> ------------------------------\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> End of bitcoin-dev Digest, Vol 28, Issue 26\n> *******************************************\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170912/39e7a072/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Proposal: Extended serialization format for BIP-32",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "shiva sitamraju",
                "Thomas Voegtlin"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 57924
        }
    },
    {
        "title": "[bitcoin-dev] Fwd: Sidechain headers on mainchain (unification of drivechains and spv proofs)",
        "thread_messages": [
            {
                "author": "Paul Sztorc",
                "date": "2017-09-09T15:33:28",
                "message_text_only": "Hi everyone,\n\nI have some agreements and disagreements.\n\nI agree with Zmn:\n\n1. That the sidechain's header is fully defined by the bits of data\nincluded in mainchain headers. These bits include \"h*\" (some hash that\nis either of the header itself or side:hashMerkleRoot), something that\nforces these hashes into a DAG-like structure (in Zmn's case, it is a\nfull hashPrevBlock, whereas for us it is just a tiny integer).\n2. That \"miner-voting\" (for lack of better phrase) accomplishes the same\ntask as any SPV Proof of any kind.\n3. That sidechains basically need to be merged-mined; to do otherwise,\nthere are marginal costs but really no marginal benefits.\n\nHowever:\n\nOn 9/8/2017 12:19 AM, ZmnSCPxj wrote:\n> Good morning.\n>\n> The obvious reply to all this is: what does\n> sidechain-headers-on-mainchain do that drivechain cannot do cheaper?\n>\n> 1.  Unifies merge mining (h* commitment) and WT^ validity voting.\n> Merge-mined headers increase the vote on a WT^, by increasing the depth\n> of the WT^.\n\n\n\n1. I think it is a mistake for SHOM (\"Sidechain Headers on Mainchain\")\nto \"unify merged-mining and the WT^ validity voting\". This causes the\nSHOM to regress to mere extension blocks, and they therefore take on\nmany of the negative properties of extension blocks.\n\nSee: http://www.drivechain.info/faq/index.html#usefulness\n\n\n> 2.  Through OP_BRIBEVERIFY, the power to decide the validity of a\n> sidechain lies in the economic majority rather than in the miners.\n\n\nI don't think that this is true. 51% miner-group can pay bribes to\nthemselves, and orphan any block or txn that disagrees with them.\n\nI also don't think that there is any meaningful difference between \"what\nthe economic majority wants\" and \"what the miners do\". To me it is a\nblindingly obvious fact: miners are paid more, only if they increase the\nvalue of { exchange_rate * ([x>=0] + txn_fees) }. This only increases if\nBitcoin is expected to be more objectively useful, and if its users\ntreasure its use sufficiently to warrant the payment of high tx fees.\n\nWhen miners disagree with, for example, the bitcoin-dev mailing list,\nthis is because miners are attempting to guess what the economic\nmajority wants, and, in making this earnest attempt, miners believe that\nthe bitcoin-dev interest is different from the economic majority interest.\n\nObviously, I don't expect to change any minds on this list. After all,\n(since no one dares oppose the economic majority), it is a smart\nstrategy to pretend that the economic majority always agrees with you.\nAnd it is extra smart to avoid examining that belief too carefully.\n\n\n  2.2.1.  This seems to imply that sidechains where unified merge-mining\n> and WT^ voting are paid for by economic majority, effectively work as\n> proof-of-stake.  The difference here is that the proof does not have to\n> cover itself (i.e. the stake being used to prove is outside the system\n> which the proof is proving) and it is really more of a\n> proof-of-sacrifice-of-stake, since the economic majority needs to pay\n> (and thus lose) the stake for continued operation of the sidechain.  One\n> can argue that proof-of-work is just an instance of\n> proof-of-sacrifice-of-stake anyway.\n\nI agree with most of this, but I think in proof of work and proof of\nstake the security guarantee is more reasonable.. In SHOM, there is no\nreason to believe that the the quantity \"total amount of money available\nfor withdrawal in a given time\" will always be smaller than \"sum of 288\nbribes\".\n\n> 2.2.2.  Miner behavior on Bcash and Bitcoin suggests to me that a good\n> portion of the miners are interested more in short-term profits than\n> long-term.\n\nAs long as some critical mass of investors exist, there is no difference\nbetween short and long term profits. It is impossible for an investor to\nact in a way that affects the long term, but does not immediately also\naffect the short term.\n\n\n> I have not seen a good explanation of how drivechain WT^ validity voting\n> works in detail; my understanding is that a WT^ is presented on the\n> mainchain, then a voting period is established during which miners\n> somehow vote for whether the WT^ is valid or not, then the voting ends\n> and a UTXO is somehow created.  If it is in some Sztorc video, I\n> apologize, I am unable to usefully view them.\nSome documentation is here:\nhttps://github.com/drivechain-project/docs/blob/master/bip1-hashrate-escrow.md\n\n\n> --\n>\n> I think lockboxes should have fixed value.  The value should be big\n> enough that the cost of OP_WITHDRAWPROOFVERIFY is low.  Particularly for\n> privacy-oriented sidechains, all lockboxes having the same value will\n> help tremendously in continuing obscurity after side-to-main transfers.\n> However, I am uncertain whether sidechain or mainchain should enforce\n> this fixed value.  This parameter is something to be endlessly debated.\n> Perhaps it should be sidechain that enforces this, but then mistakes\n> could occur on the mainchain where some lockbox on the mainchain is\n> deemed invalid on the sidechain, and cannot be unlocked validly except\n> by destroying the sidechain.\nI don't think this makes any sense, because it implies that the value of\n288 block's worth of mainchain BTC transaction fees should always be\nworth more than the entire market capitalization of Bitcoin.\n\nSpecifically, in this case, the error it introduces is that someone\ncould get around the fixed value by just using multiple sidechains. Then\nthe miners would just attack all the sidechains simultaneously. (And\nthese smaller sidechains would themselves have much smaller fees.)\n\n\n>\n> Sidechains may first be deployed as federated peg, then at some\n> sidechain height the federation may announce a move to\n> drivechain/sidechain-headers-on-mainchain.  The move from federated to\n> economic-majority-controlled would involve the federation moving its\n> controlled lockboxes to OP_WITHDRAWPROOFVERIFY lockboxes.\nSergio likes this idea, but I think that this attitude represents a lack\nof faith in the design. Either the design works or it does not. Either\nthe federation works or it does not.\n>\n> Sidechain hardforks would be very contentious, with only one clear\n> winner that can unlock lockboxes.  I think, part of sidechain design\n> must be the understanding that sidechains must never be hardforked, and\n> only softforked.  Indeed, I am very much convinced that it is impossible\n> to safely hardfork mainchain at all, and any block size increase must by\n> necessity be softforked in.\nThis is already the case in what we have done...the only way to\nguarantee that all clients report the same WT^ is if they are all\nrunning softforks of the first version.\n\n\n> The mechanism that supports sidechains supports any financial system,\n> including centralized, non blockchain ones.  The h* commitments can be\n> made into commitments to the financial system's state.  Basically, it is\n> an implementation of CoinWitness, without using zk-SNARKs and instead\n> using some mainchain-voted proof, where validity is judged by how much\n> maincoin was sacrified to advance that proof.  The supported financial\n> system might even allow arbitrary execution of Turing-complete code for\n> more vulnerabilities.\nThis is why I do not want ultra-easy, completely-permissionless creation\nof sidechains. Miners (and therefore, users) may NOT desire the EXPECTED\nbehavior of the sidechain.\n> Is there some spec for WT^ layout?\nYes, see above.\n\nThanks,\nPaul"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-09-10T05:32:42",
                "message_text_only": "Good morning Paul,\n\nThank you for your consideration.\n\n>> 1. Unifies merge mining (h* commitment) and WT^ validity voting.\n>> Merge-mined headers increase the vote on a WT^, by increasing the depth\n>> of the WT^.\n>\n>1. I think it is a mistake for SHOM (\"Sidechain Headers on Mainchain\")\n>to \"unify merged-mining and the WT^ validity voting\". This causes the\n>SHOM to regress to mere extension blocks, and they therefore take on\n>many of the negative properties of extension blocks.\n>\n>See: http://www.drivechain.info/faq/index.html#usefulness\n\nI don't see how this regress occurs.  Perhaps I need more information on extension blocks.\n\n>> 2. Through OP_BRIBEVERIFY, the power to decide the validity of a\n>> sidechain lies in the economic majority rather than in the miners.\n>\n>I don\"t think that this is true. 51% miner-group can pay bribes to\n>themselves, and orphan any block or txn that disagrees with them.\n\nAny miner that rejects a bribe from outside the miner-group in order to put their desired hash on the sidechain, values their desired hash more than the bribe to put a different hash.  This rejection is a loss of potential proift, and other miners who accept the bribe gain the profit from it.\n\n>I also don\"t think that there is any meaningful difference between \"what\n>the economic majority wants\" and \"what the miners do\". To me it is a\n>blindingly obvious fact: miners are paid more, only if they increase the\n>value of { exchange_rate * ([x>=0] + txn_fees) }. This only increases if\n>Bitcoin is expected to be more objectively useful, and if its users\n>treasure its use sufficiently to warrant the payment of high tx fees.\n>\n>When miners disagree with, for example, the bitcoin-dev mailing list,\n>this is because miners are attempting to guess what the economic\n>majority wants, and, in making this earnest attempt, miners believe that\n>the bitcoin-dev interest is different from the economic majority interest.\n>\n>Obviously, I don\"t expect to change any minds on this list. After all,\n>(since no one dares oppose the economic majority), it is a smart\n>strategy to pretend that the economic majority always agrees with you.\n>And it is extra smart to avoid examining that belief too carefully.\n\nYour last paragraph does not make sense to me.  I suspect I have hit upon a nerve and will make no further comment on this sub-topic.\n\n>>2.2.1. This seems to imply that sidechains where unified merge-mining\n>> and WT^ voting are paid for by economic majority, effectively work as\n>> proof-of-stake. The difference here is that the proof does not have to\n>> cover itself (i.e. the stake being used to prove is outside the system\n>> which the proof is proving) and it is really more of a\n>> proof-of-sacrifice-of-stake, since the economic majority needs to pay\n>> (and thus lose) the stake for continued operation of the sidechain. One\n>> can argue that proof-of-work is just an instance of\n>> proof-of-sacrifice-of-stake anyway.\n>\n>I agree with most of this, but I think in proof of work and proof of\n>stake the security guarantee is more reasonable.. In SHOM, there is no\n>reason to believe that the the quantity \"total amount of money available\n>for withdrawal in a given time\" will always be smaller than \"sum of 288\n>bribes\".\n\nThis is indeed the problem.  SHOM, as it unifies merge mining and WT^ voting, also allows theft attempts, and once the money available for withdrawal exceeds the sum of 288 bribes, we enter a dollar auction game between the thief and the sidechain users: https://en.wikipedia.org/wiki/Dollar_auction\n\nAs thieves are expected to follow the simple greedy algorithm, sidechain death can be triggered by a single theft attempt.\n\nAssuming potential thieves understand the dollar-auction irrationality, they may be disincentivized, as presumably there are more sidechain protectors than thieves, and the sidechain protectors can (we hope) all outbid the thief.  But the problem is that this require rational behavior from thieves.  Mere greedy algorithm, or disruption for the sake of disruption, would still collapse SHOM sidechains.\n\nBut given the many parallels between SHOM and drivechains: what happens if 26% of miners disrupt all sidechains by always downvoting WT^?  In that case, sidechains still collapse as a whole, with practically the same effect as the SHOM thief.\n\nWe could limit the money available for withdrawal, but that weakens the side-to-main peg, reducing the value of the sidecoin relative to the maincoin.\n\nThe problem, to my mind, is that blind merge mining is pointless if it does not also allow voting on WT^.  In the end, no matter how novel a sidechain may be, what is valued is the maincoin backing the sidecoin; that is the whole point of the two-way peg.  A sidechain user may OP_BRIBEVERIFY valid sideblocks onto the mainchain, but if that user cannot vote on WT^ anyway, no matter how valid sideblocks committed on the mainchain, it would be pointless if the sidechain is attacked by mainchain miners.  You may as well remove blind merge mining, as miners who must vote on WT^ will need to understand the sidechain validity rules anyway.\n\n>> 2.2.2. Miner behavior on Bcash and Bitcoin suggests to me that a good\n>> portion of the miners are interested more in short-term profits than\n>> long-term.\n>\n>As long as some critical mass of investors exist, there is no difference\n>between short and long term profits. It is impossible for an investor to\n>act in a way that affects the long term, but does not immediately also\n>affect the short term.\n\nI do not quite follow.  Can you expand more on this?\n\n>> I have not seen a good explanation of how drivechain WT^ validity voting\n>> works in detail; my understanding is that a WT^ is presented on the\n>> mainchain, then a voting period is established during which miners\n>> somehow vote for whether the WT^ is valid or not, then the voting ends\n>> and a UTXO is somehow created. If it is in some Sztorc video, I\n>> apologize, I am unable to usefully view them.\n>Some documentation is here:\n>https://github.com/drivechain-project/docs/blob/master/bip1-hashrate-escrow.md\n\nThank you.\n\n>> I think lockboxes should have fixed value. The value should be big\n>> enough that the cost of OP_WITHDRAWPROOFVERIFY is low. Particularly for\n>> privacy-oriented sidechains, all lockboxes having the same value will\n>> help tremendously in continuing obscurity after side-to-main transfers.\n>> However, I am uncertain whether sidechain or mainchain should enforce\n>> this fixed value. This parameter is something to be endlessly debated.\n>> Perhaps it should be sidechain that enforces this, but then mistakes\n>> could occur on the mainchain where some lockbox on the mainchain is\n>> deemed invalid on the sidechain, and cannot be unlocked validly except\n>> by destroying the sidechain.\n>I don\"t think this makes any sense, because it implies that the value of\n>288 block\"s worth of mainchain BTC transaction fees should always be\n>worth more than the entire market capitalization of Bitcoin.\n>\n>Specifically, in this case, the error it introduces is that someone\n>could get around the fixed value by just using multiple sidechains. Then\n>the miners would just attack all the sidechains simultaneously. (And\n>these smaller sidechains would themselves have much smaller fees.)\n\nIn order to attack multiple sidechains, bribing thieves must pay bribes for each sidechain being attacked.  Even if a miner attacks, bribes for valid sidechains must be rejected by the miner, effectively reducing the miner's profits, and the bribes to be rejected must be for all the sidechains to be attacked.\n\nIf withdrawals have a fixed or maximum value, then the bribe a thief must be prepared to pay (or turn down, in the case of thieving miners) must be no more than the maximum value / 288.\n\nUnfortunately, capping withdrawals weakens the side-to-main peg, which weakens the reason for even using SHOM.  This is the true weakness of SHOM: it provides only a very weak side-to-main peg.\n\n>>\n>> Sidechains may first be deployed as federated peg, then at some\n>> sidechain height the federation may announce a move to\n>> drivechain/sidechain-headers-on-mainchain. The move from federated to\n>> economic-majority-controlled would involve the federation moving its\n>> controlled lockboxes to OP_WITHDRAWPROOFVERIFY lockboxes.\n>Sergio likes this idea, but I think that this attitude represents a lack\n>of faith in the design. Either the design works or it does not. Either\n>the federation works or it does not.\n\nI agree.\n\n>>\n>> Sidechain hardforks would be very contentious, with only one clear\n>> winner that can unlock lockboxes. I think, part of sidechain design\n>> must be the understanding that sidechains must never be hardforked, and\n>> only softforked. Indeed, I am very much convinced that it is impossible\n>> to safely hardfork mainchain at all, and any block size increase must by\n>> necessity be softforked in.\n>This is already the case in what we have done...the only way to\n>guarantee that all clients report the same WT^ is if they are all\n>running softforks of the first version.\n\nYes.\n\n>> The mechanism that supports sidechains supports any financial system,\n>> including centralized, non blockchain ones. The h* commitments can be\n>> made into commitments to the financial system\"s state. Basically, it is\n>> an implementation of CoinWitness, without using zk-SNARKs and instead\n>> using some mainchain-voted proof, where validity is judged by how much\n>> maincoin was sacrified to advance that proof. The supported financial\n>> system might even allow arbitrary execution of Turing-complete code for\n>> more vulnerabilities.\n>This is why I do not want ultra-easy, completely-permissionless creation\n>of sidechains. Miners (and therefore, users) may NOT desire the EXPECTED\n>behavior of the sidechain.\n\nI am fine with some economic bond or proof-of-burn to start a sidechain.  But I am opposed to any permissioned method of starting sidechains.  To my mind, asking miners to install your software is already permissioned.\n\n>> Is there some spec for WT^ layout?\n>Yes, see above.\n\nThank you.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170910/12f519b9/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-09-10T05:33:06",
                "message_text_only": "Sent with [ProtonMail](https://protonmail.com) Secure Email.\n\n> -------- Original Message --------\n> Subject: Re: Fwd: [bitcoin-dev] Sidechain headers on mainchain (unification of drivechains and spv proofs)\n> Local Time: September 9, 2017 3:33 PM\n> UTC Time: September 9, 2017 3:33 PM\n> From: truthcoin at gmail.com\n> To: Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>, ZmnSCPxj <ZmnSCPxj at protonmail.com>\n>\n> Hi everyone,\n>\n> I have some agreements and disagreements.\n>\n> I agree with Zmn:\n>\n> 1. That the sidechain\"s header is fully defined by the bits of data\n> included in mainchain headers. These bits include \"h*\" (some hash that\n> is either of the header itself or side:hashMerkleRoot), something that\n> forces these hashes into a DAG-like structure (in Zmn\"s case, it is a\n> full hashPrevBlock, whereas for us it is just a tiny integer).\n> 2. That \"miner-voting\" (for lack of better phrase) accomplishes the same\n> task as any SPV Proof of any kind.\n> 3. That sidechains basically need to be merged-mined; to do otherwise,\n> there are marginal costs but really no marginal benefits.\n>\n> However:\n>\n> On 9/8/2017 12:19 AM, ZmnSCPxj wrote:\n>> Good morning.\n>>\n>> The obvious reply to all this is: what does\n>> sidechain-headers-on-mainchain do that drivechain cannot do cheaper?\n>>\n>> 1. Unifies merge mining (h* commitment) and WT^ validity voting.\n>> Merge-mined headers increase the vote on a WT^, by increasing the depth\n>> of the WT^.\n>\n> 1. I think it is a mistake for SHOM (\"Sidechain Headers on Mainchain\")\n> to \"unify merged-mining and the WT^ validity voting\". This causes the\n> SHOM to regress to mere extension blocks, and they therefore take on\n> many of the negative properties of extension blocks.\n>\n> See: http://www.drivechain.info/faq/index.html#usefulness\n>\n>> 2. Through OP_BRIBEVERIFY, the power to decide the validity of a\n>> sidechain lies in the economic majority rather than in the miners.\n>\n> I don\"t think that this is true. 51% miner-group can pay bribes to\n> themselves, and orphan any block or txn that disagrees with them.\n>\n> I also don\"t think that there is any meaningful difference between \"what\n> the economic majority wants\" and \"what the miners do\". To me it is a\n> blindingly obvious fact: miners are paid more, only if they increase the\n> value of { exchange_rate * ([x>=0] + txn_fees) }. This only increases if\n> Bitcoin is expected to be more objectively useful, and if its users\n> treasure its use sufficiently to warrant the payment of high tx fees.\n>\n> When miners disagree with, for example, the bitcoin-dev mailing list,\n> this is because miners are attempting to guess what the economic\n> majority wants, and, in making this earnest attempt, miners believe that\n> the bitcoin-dev interest is different from the economic majority interest.\n>\n> Obviously, I don\"t expect to change any minds on this list. After all,\n> (since no one dares oppose the economic majority), it is a smart\n> strategy to pretend that the economic majority always agrees with you.\n> And it is extra smart to avoid examining that belief too carefully.\n>\n> 2.2.1. This seems to imply that sidechains where unified merge-mining\n>> and WT^ voting are paid for by economic majority, effectively work as\n>> proof-of-stake. The difference here is that the proof does not have to\n>> cover itself (i.e. the stake being used to prove is outside the system\n>> which the proof is proving) and it is really more of a\n>> proof-of-sacrifice-of-stake, since the economic majority needs to pay\n>> (and thus lose) the stake for continued operation of the sidechain. One\n>> can argue that proof-of-work is just an instance of\n>> proof-of-sacrifice-of-stake anyway.\n>\n> I agree with most of this, but I think in proof of work and proof of\n> stake the security guarantee is more reasonable.. In SHOM, there is no\n> reason to believe that the the quantity \"total amount of money available\n> for withdrawal in a given time\" will always be smaller than \"sum of 288\n> bribes\".\n>\n>> 2.2.2. Miner behavior on Bcash and Bitcoin suggests to me that a good\n>> portion of the miners are interested more in short-term profits than\n>> long-term.\n>\n> As long as some critical mass of investors exist, there is no difference\n> between short and long term profits. It is impossible for an investor to\n> act in a way that affects the long term, but does not immediately also\n> affect the short term.\n>\n>> I have not seen a good explanation of how drivechain WT^ validity voting\n>> works in detail; my understanding is that a WT^ is presented on the\n>> mainchain, then a voting period is established during which miners\n>> somehow vote for whether the WT^ is valid or not, then the voting ends\n>> and a UTXO is somehow created. If it is in some Sztorc video, I\n>> apologize, I am unable to usefully view them.\n> Some documentation is here:\n> https://github.com/drivechain-project/docs/blob/master/bip1-hashrate-escrow.md\n>\n>> --\n>>\n>> I think lockboxes should have fixed value. The value should be big\n>> enough that the cost of OP_WITHDRAWPROOFVERIFY is low. Particularly for\n>> privacy-oriented sidechains, all lockboxes having the same value will\n>> help tremendously in continuing obscurity after side-to-main transfers.\n>> However, I am uncertain whether sidechain or mainchain should enforce\n>> this fixed value. This parameter is something to be endlessly debated.\n>> Perhaps it should be sidechain that enforces this, but then mistakes\n>> could occur on the mainchain where some lockbox on the mainchain is\n>> deemed invalid on the sidechain, and cannot be unlocked validly except\n>> by destroying the sidechain.\n> I don\"t think this makes any sense, because it implies that the value of\n> 288 block\"s worth of mainchain BTC transaction fees should always be\n> worth more than the entire market capitalization of Bitcoin.\n>\n> Specifically, in this case, the error it introduces is that someone\n> could get around the fixed value by just using multiple sidechains. Then\n> the miners would just attack all the sidechains simultaneously. (And\n> these smaller sidechains would themselves have much smaller fees.)\n>\n>>\n>> Sidechains may first be deployed as federated peg, then at some\n>> sidechain height the federation may announce a move to\n>> drivechain/sidechain-headers-on-mainchain. The move from federated to\n>> economic-majority-controlled would involve the federation moving its\n>> controlled lockboxes to OP_WITHDRAWPROOFVERIFY lockboxes.\n> Sergio likes this idea, but I think that this attitude represents a lack\n> of faith in the design. Either the design works or it does not. Either\n> the federation works or it does not.\n>>\n>> Sidechain hardforks would be very contentious, with only one clear\n>> winner that can unlock lockboxes. I think, part of sidechain design\n>> must be the understanding that sidechains must never be hardforked, and\n>> only softforked. Indeed, I am very much convinced that it is impossible\n>> to safely hardfork mainchain at all, and any block size increase must by\n>> necessity be softforked in.\n> This is already the case in what we have done...the only way to\n> guarantee that all clients report the same WT^ is if they are all\n> running softforks of the first version.\n>\n>> The mechanism that supports sidechains supports any financial system,\n>> including centralized, non blockchain ones. The h* commitments can be\n>> made into commitments to the financial system\"s state. Basically, it is\n>> an implementation of CoinWitness, without using zk-SNARKs and instead\n>> using some mainchain-voted proof, where validity is judged by how much\n>> maincoin was sacrified to advance that proof. The supported financial\n>> system might even allow arbitrary execution of Turing-complete code for\n>> more vulnerabilities.\n> This is why I do not want ultra-easy, completely-permissionless creation\n> of sidechains. Miners (and therefore, users) may NOT desire the EXPECTED\n> behavior of the sidechain.\n>> Is there some spec for WT^ layout?\n> Yes, see above.\n>\n> Thanks,\n> Paul\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170910/f2f8e653/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Fwd: Sidechain headers on mainchain (unification of drivechains and spv proofs)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Paul Sztorc"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 25893
        }
    },
    {
        "title": "[bitcoin-dev] Responsible disclosure of bugs",
        "thread_messages": [
            {
                "author": "Simon Liu",
                "date": "2017-09-10T22:03:48",
                "message_text_only": "Hi,\n\nGiven today's presentation by Chris Jeffrey at the Breaking Bitcoin\nconference, and the subsequent discussion around responsible disclosure\nand industry practice, perhaps now would be a good time to discuss\n\"Bitcoin and CVEs\" which has gone unanswered for 6 months.\n\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013751.html\n\nTo quote:\n\n\"Are there are any vulnerabilities in Bitcoin which have been fixed but\nnot yet publicly disclosed?  Is the following list of Bitcoin CVEs\nup-to-date?\n\nhttps://en.bitcoin.it/wiki/Common_Vulnerabilities_and_Exposures\n\nThere have been no new CVEs posted for almost three years, except for\nCVE-2015-3641, but there appears to be no information publicly available\nfor that issue:\n\nhttps://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3641\n\nIt would be of great benefit to end users if the community of clients\nand altcoins derived from Bitcoin Core could be patched for any known\nvulnerabilities.\n\nDoes anyone keep track of security related bugs and patches, where the\ndefect severity is similar to those found on the CVE list above?  If\nyes, can that list be shared with other developers?\"\n\nBest Regards,\nSimon"
            },
            {
                "author": "Matt Corallo",
                "date": "2017-09-10T23:02:36",
                "message_text_only": "I believe there continues to be concern over a number of altcoins which\nare running old, unpatched forks of Bitcoin Core, making it rather\ndifficult to disclose issues without putting people at risk (see, eg,\nsome of the dos issues which are preventing release of the alert key).\nI'd encourage the list to have a discussion about what reasonable\napproaches could be taken there.\n\nOn 09/10/17 18:03, Simon Liu via bitcoin-dev wrote:\n> Hi,\n> \n> Given today's presentation by Chris Jeffrey at the Breaking Bitcoin\n> conference, and the subsequent discussion around responsible disclosure\n> and industry practice, perhaps now would be a good time to discuss\n> \"Bitcoin and CVEs\" which has gone unanswered for 6 months.\n> \n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013751.html\n> \n> To quote:\n> \n> \"Are there are any vulnerabilities in Bitcoin which have been fixed but\n> not yet publicly disclosed?  Is the following list of Bitcoin CVEs\n> up-to-date?\n> \n> https://en.bitcoin.it/wiki/Common_Vulnerabilities_and_Exposures\n> \n> There have been no new CVEs posted for almost three years, except for\n> CVE-2015-3641, but there appears to be no information publicly available\n> for that issue:\n> \n> https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3641\n> \n> It would be of great benefit to end users if the community of clients\n> and altcoins derived from Bitcoin Core could be patched for any known\n> vulnerabilities.\n> \n> Does anyone keep track of security related bugs and patches, where the\n> defect severity is similar to those found on the CVE list above?  If\n> yes, can that list be shared with other developers?\"\n> \n> Best Regards,\n> Simon\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "CryptAxe",
                "date": "2017-09-10T23:28:18",
                "message_text_only": "I don't think we should put any Bitcoin users at additional risk to help\naltcoins. If they fork the code they are making maintenance their own\nresponsibly.\n\nIt's hard to disclose a bitcoin vulnerability considering the network is\ndecentralised and core can't force everyone to update. Maybe a timeout\nperiod for vulnerabilities could be decided. People might be expected to\npatched before then at which point the vulnerability can be published. Is\nthat not already sort of how it works?\n\nOn Sep 10, 2017 4:10 PM, \"Matt Corallo via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I believe there continues to be concern over a number of altcoins which\n> are running old, unpatched forks of Bitcoin Core, making it rather\n> difficult to disclose issues without putting people at risk (see, eg,\n> some of the dos issues which are preventing release of the alert key).\n> I'd encourage the list to have a discussion about what reasonable\n> approaches could be taken there.\n>\n> On 09/10/17 18:03, Simon Liu via bitcoin-dev wrote:\n> > Hi,\n> >\n> > Given today's presentation by Chris Jeffrey at the Breaking Bitcoin\n> > conference, and the subsequent discussion around responsible disclosure\n> > and industry practice, perhaps now would be a good time to discuss\n> > \"Bitcoin and CVEs\" which has gone unanswered for 6 months.\n> >\n> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> 2017-March/013751.html\n> >\n> > To quote:\n> >\n> > \"Are there are any vulnerabilities in Bitcoin which have been fixed but\n> > not yet publicly disclosed?  Is the following list of Bitcoin CVEs\n> > up-to-date?\n> >\n> > https://en.bitcoin.it/wiki/Common_Vulnerabilities_and_Exposures\n> >\n> > There have been no new CVEs posted for almost three years, except for\n> > CVE-2015-3641, but there appears to be no information publicly available\n> > for that issue:\n> >\n> > https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3641\n> >\n> > It would be of great benefit to end users if the community of clients\n> > and altcoins derived from Bitcoin Core could be patched for any known\n> > vulnerabilities.\n> >\n> > Does anyone keep track of security related bugs and patches, where the\n> > defect severity is similar to those found on the CVE list above?  If\n> > yes, can that list be shared with other developers?\"\n> >\n> > Best Regards,\n> > Simon\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170910/1b3bfb59/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2017-09-11T02:15:07",
                "message_text_only": "On Sun, Sep 10, 2017 at 07:02:36PM -0400, Matt Corallo via bitcoin-dev wrote:\n> I believe there continues to be concern over a number of altcoins which\n> are running old, unpatched forks of Bitcoin Core, making it rather\n> difficult to disclose issues without putting people at risk (see, eg,\n> some of the dos issues which are preventing release of the alert key).\n> I'd encourage the list to have a discussion about what reasonable\n> approaches could be taken there.\n\nThat seems like it just says bitcoin core has two classes of users:\npeople who use it directly following mainnet or testnet, and people who\nmake derived works based on it to run altcoins.\n\nHaving a \"responsible disclosure\" timeline something like:\n\n * day -N: vulnerability reported privately\n * day -N+1: details shared amongst private trusted bitcoin core group\n * day 0: patch/workaround/mitigation determined, CVE reserved\n * day 1: basic information shared with small group of trusted users\n      (eg, altcoin maintainers, exchanges, maybe wallet devs)\n * day ~7: patches can be included in git repo\n      (without references to vulnerability)\n * day 90: release candidate with fix available\n * day 120: official release including fix\n * day 134: CVE published with details and acknowledgements\n\ncould make sense. 90 days / 3 months is hopefully a fair strict upper\nbound for how long it should take to get a fix into a rc; but that's still\na lot longer than many responsible disclosure timeframes, like CERT's at\n45 days, but also shorter than some bitcoin core minor update cycles...\nObviously, those timelines could be varied down if something is more\nurgent (or just easy).\n\nAs it is, not publishing vulnerability info just seems like it gives\neveryone a false sense of security, and encourages ignoring good security\npractices, either not upgrading bitcoind nodes, or not ensuring altcoin\nimplementations keep up to date...\n\nI suppose both \"trusted bitcoin core group\" and \"small group of trusted\nusers\" isn't 100% cypherpunk, but it sure seems better than not both not\ndisclosing vulnerability details, and not disclosing vulnerabilities\nat all... (And maybe it could be made more cypherpunk by, say, having\nthe disclosures to trusted groups have the description/patches get\nautomatically fuzzed to perhaps allow identification of leakers?)\n\nCheers,\naj\n\n> On 09/10/17 18:03, Simon Liu via bitcoin-dev wrote:\n> > Hi,\n> > \n> > Given today's presentation by Chris Jeffrey at the Breaking Bitcoin\n> > conference, and the subsequent discussion around responsible disclosure\n> > and industry practice, perhaps now would be a good time to discuss\n> > \"Bitcoin and CVEs\" which has gone unanswered for 6 months.\n> > \n> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013751.html\n> > \n> > To quote:\n> > \n> > \"Are there are any vulnerabilities in Bitcoin which have been fixed but\n> > not yet publicly disclosed?  Is the following list of Bitcoin CVEs\n> > up-to-date?\n> > \n> > https://en.bitcoin.it/wiki/Common_Vulnerabilities_and_Exposures\n> > \n> > There have been no new CVEs posted for almost three years, except for\n> > CVE-2015-3641, but there appears to be no information publicly available\n> > for that issue:\n> > \n> > https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3641\n> > \n> > It would be of great benefit to end users if the community of clients\n> > and altcoins derived from Bitcoin Core could be patched for any known\n> > vulnerabilities.\n> > \n> > Does anyone keep track of security related bugs and patches, where the\n> > defect severity is similar to those found on the CVE list above?  If\n> > yes, can that list be shared with other developers?\"\n> > \n> > Best Regards,\n> > Simon\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> > \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Alex Morcos",
                "date": "2017-09-11T11:34:33",
                "message_text_only": "I don't think I know the right answer here, but I will point out two things\nthat make this a little more complicated.\n\n1 - There are lots of altcoin developers and while I'm sure the majority\nwould greatly appreciate the disclosure and would behave responsibly with\nthe information, I don't know where you draw the line on who you tell and\nwho you don't.\n\n2- Unlike other software, I'm not sure good security for bitcoin is defined\nby constant upgrading.  Obviously upgrading has an important benefit, but\none of the security considerations for Bitcoin is knowing that your\ndefinition of the money hasn't changed.  Much harder to know that if you\nchange software.\n\n\n\nOn Sun, Sep 10, 2017 at 10:15 PM, Anthony Towns via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Sun, Sep 10, 2017 at 07:02:36PM -0400, Matt Corallo via bitcoin-dev\n> wrote:\n> > I believe there continues to be concern over a number of altcoins which\n> > are running old, unpatched forks of Bitcoin Core, making it rather\n> > difficult to disclose issues without putting people at risk (see, eg,\n> > some of the dos issues which are preventing release of the alert key).\n> > I'd encourage the list to have a discussion about what reasonable\n> > approaches could be taken there.\n>\n> That seems like it just says bitcoin core has two classes of users:\n> people who use it directly following mainnet or testnet, and people who\n> make derived works based on it to run altcoins.\n>\n> Having a \"responsible disclosure\" timeline something like:\n>\n>  * day -N: vulnerability reported privately\n>  * day -N+1: details shared amongst private trusted bitcoin core group\n>  * day 0: patch/workaround/mitigation determined, CVE reserved\n>  * day 1: basic information shared with small group of trusted users\n>       (eg, altcoin maintainers, exchanges, maybe wallet devs)\n>  * day ~7: patches can be included in git repo\n>       (without references to vulnerability)\n>  * day 90: release candidate with fix available\n>  * day 120: official release including fix\n>  * day 134: CVE published with details and acknowledgements\n>\n> could make sense. 90 days / 3 months is hopefully a fair strict upper\n> bound for how long it should take to get a fix into a rc; but that's still\n> a lot longer than many responsible disclosure timeframes, like CERT's at\n> 45 days, but also shorter than some bitcoin core minor update cycles...\n> Obviously, those timelines could be varied down if something is more\n> urgent (or just easy).\n>\n> As it is, not publishing vulnerability info just seems like it gives\n> everyone a false sense of security, and encourages ignoring good security\n> practices, either not upgrading bitcoind nodes, or not ensuring altcoin\n> implementations keep up to date...\n>\n> I suppose both \"trusted bitcoin core group\" and \"small group of trusted\n> users\" isn't 100% cypherpunk, but it sure seems better than not both not\n> disclosing vulnerability details, and not disclosing vulnerabilities\n> at all... (And maybe it could be made more cypherpunk by, say, having\n> the disclosures to trusted groups have the description/patches get\n> automatically fuzzed to perhaps allow identification of leakers?)\n>\n> Cheers,\n> aj\n>\n> > On 09/10/17 18:03, Simon Liu via bitcoin-dev wrote:\n> > > Hi,\n> > >\n> > > Given today's presentation by Chris Jeffrey at the Breaking Bitcoin\n> > > conference, and the subsequent discussion around responsible disclosure\n> > > and industry practice, perhaps now would be a good time to discuss\n> > > \"Bitcoin and CVEs\" which has gone unanswered for 6 months.\n> > >\n> > > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> 2017-March/013751.html\n> > >\n> > > To quote:\n> > >\n> > > \"Are there are any vulnerabilities in Bitcoin which have been fixed but\n> > > not yet publicly disclosed?  Is the following list of Bitcoin CVEs\n> > > up-to-date?\n> > >\n> > > https://en.bitcoin.it/wiki/Common_Vulnerabilities_and_Exposures\n> > >\n> > > There have been no new CVEs posted for almost three years, except for\n> > > CVE-2015-3641, but there appears to be no information publicly\n> available\n> > > for that issue:\n> > >\n> > > https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3641\n> > >\n> > > It would be of great benefit to end users if the community of clients\n> > > and altcoins derived from Bitcoin Core could be patched for any known\n> > > vulnerabilities.\n> > >\n> > > Does anyone keep track of security related bugs and patches, where the\n> > > defect severity is similar to those found on the CVE list above?  If\n> > > yes, can that list be shared with other developers?\"\n> > >\n> > > Best Regards,\n> > > Simon\n> > > _______________________________________________\n> > > bitcoin-dev mailing list\n> > > bitcoin-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> > >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170911/e2ab7b78/attachment-0001.html>"
            },
            {
                "author": "Daniel Stadulis",
                "date": "2017-09-11T17:43:52",
                "message_text_only": "I think it's relevant to treat different bug severity levels with different\nresponse plans.\n\nE.g.\nCompromising UTXO custody (In CVE-2010-5141, OP_RETURN vulnerability)\nCompromising UTXO state (In CVE-2013-3220, blockchain split due to Berkeley\nDB -> LevelDB upgrade, CVE-2010-5139 Overflow bug, unscheduled inflation of\ncoins)\nCompromising Node performance (Various node-specific DoS attacks)\n\nShould have different disclosure policies, IMO\n\nOn Mon, Sep 11, 2017 at 4:34 AM, Alex Morcos via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I don't think I know the right answer here, but I will point out two\n> things that make this a little more complicated.\n>\n> 1 - There are lots of altcoin developers and while I'm sure the majority\n> would greatly appreciate the disclosure and would behave responsibly with\n> the information, I don't know where you draw the line on who you tell and\n> who you don't.\n>\n> 2- Unlike other software, I'm not sure good security for bitcoin is\n> defined by constant upgrading.  Obviously upgrading has an important\n> benefit, but one of the security considerations for Bitcoin is knowing that\n> your definition of the money hasn't changed.  Much harder to know that if\n> you change software.\n>\n>\n>\n> On Sun, Sep 10, 2017 at 10:15 PM, Anthony Towns via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> On Sun, Sep 10, 2017 at 07:02:36PM -0400, Matt Corallo via bitcoin-dev\n>> wrote:\n>> > I believe there continues to be concern over a number of altcoins which\n>> > are running old, unpatched forks of Bitcoin Core, making it rather\n>> > difficult to disclose issues without putting people at risk (see, eg,\n>> > some of the dos issues which are preventing release of the alert key).\n>> > I'd encourage the list to have a discussion about what reasonable\n>> > approaches could be taken there.\n>>\n>> That seems like it just says bitcoin core has two classes of users:\n>> people who use it directly following mainnet or testnet, and people who\n>> make derived works based on it to run altcoins.\n>>\n>> Having a \"responsible disclosure\" timeline something like:\n>>\n>>  * day -N: vulnerability reported privately\n>>  * day -N+1: details shared amongst private trusted bitcoin core group\n>>  * day 0: patch/workaround/mitigation determined, CVE reserved\n>>  * day 1: basic information shared with small group of trusted users\n>>       (eg, altcoin maintainers, exchanges, maybe wallet devs)\n>>  * day ~7: patches can be included in git repo\n>>       (without references to vulnerability)\n>>  * day 90: release candidate with fix available\n>>  * day 120: official release including fix\n>>  * day 134: CVE published with details and acknowledgements\n>>\n>> could make sense. 90 days / 3 months is hopefully a fair strict upper\n>> bound for how long it should take to get a fix into a rc; but that's still\n>> a lot longer than many responsible disclosure timeframes, like CERT's at\n>> 45 days, but also shorter than some bitcoin core minor update cycles...\n>> Obviously, those timelines could be varied down if something is more\n>> urgent (or just easy).\n>>\n>> As it is, not publishing vulnerability info just seems like it gives\n>> everyone a false sense of security, and encourages ignoring good security\n>> practices, either not upgrading bitcoind nodes, or not ensuring altcoin\n>> implementations keep up to date...\n>>\n>> I suppose both \"trusted bitcoin core group\" and \"small group of trusted\n>> users\" isn't 100% cypherpunk, but it sure seems better than not both not\n>> disclosing vulnerability details, and not disclosing vulnerabilities\n>> at all... (And maybe it could be made more cypherpunk by, say, having\n>> the disclosures to trusted groups have the description/patches get\n>> automatically fuzzed to perhaps allow identification of leakers?)\n>>\n>> Cheers,\n>> aj\n>>\n>> > On 09/10/17 18:03, Simon Liu via bitcoin-dev wrote:\n>> > > Hi,\n>> > >\n>> > > Given today's presentation by Chris Jeffrey at the Breaking Bitcoin\n>> > > conference, and the subsequent discussion around responsible\n>> disclosure\n>> > > and industry practice, perhaps now would be a good time to discuss\n>> > > \"Bitcoin and CVEs\" which has gone unanswered for 6 months.\n>> > >\n>> > > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017\n>> -March/013751.html\n>> > >\n>> > > To quote:\n>> > >\n>> > > \"Are there are any vulnerabilities in Bitcoin which have been fixed\n>> but\n>> > > not yet publicly disclosed?  Is the following list of Bitcoin CVEs\n>> > > up-to-date?\n>> > >\n>> > > https://en.bitcoin.it/wiki/Common_Vulnerabilities_and_Exposures\n>> > >\n>> > > There have been no new CVEs posted for almost three years, except for\n>> > > CVE-2015-3641, but there appears to be no information publicly\n>> available\n>> > > for that issue:\n>> > >\n>> > > https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3641\n>> > >\n>> > > It would be of great benefit to end users if the community of clients\n>> > > and altcoins derived from Bitcoin Core could be patched for any known\n>> > > vulnerabilities.\n>> > >\n>> > > Does anyone keep track of security related bugs and patches, where the\n>> > > defect severity is similar to those found on the CVE list above?  If\n>> > > yes, can that list be shared with other developers?\"\n>> > >\n>> > > Best Regards,\n>> > > Simon\n>> > > _______________________________________________\n>> > > bitcoin-dev mailing list\n>> > > bitcoin-dev at lists.linuxfoundation.org\n>> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>> > >\n>> > _______________________________________________\n>> > bitcoin-dev mailing list\n>> > bitcoin-dev at lists.linuxfoundation.org\n>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170911/06bf75a1/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2017-09-11T18:29:46",
                "message_text_only": "On Mon, Sep 11, 2017 at 5:43 PM, Daniel Stadulis via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> I think it's relevant to treat different bug severity levels with different\n> response plans.\n>\n> E.g.\n> Compromising UTXO custody (In CVE-2010-5141, OP_RETURN vulnerability)\n> Compromising UTXO state (In CVE-2013-3220, blockchain split due to Berkeley\n> DB -> LevelDB upgrade, CVE-2010-5139 Overflow bug, unscheduled inflation of\n> coins)\n> Compromising Node performance (Various node-specific DoS attacks)\n>\n> Should have different disclosure policies, IMO\n\nThis assumes the states are discernible.  They often aren't cleanly.\nYou obviously know how bad it is in the best case, but the worst could\nbe much worse.\n\nI've multiple time seen a hard to exploit issue turn out to be trivial\nwhen you find the right trick, or a minor dos issue turn our to far\nmore serious.\n\nSimple performance bugs, expertly deployed, can potentially be used to\ncarve up the network--- miner A and exchange B go in one partition,\neveryone else in another.. and doublespend.\n\nAnd so on.  So while I absolutely do agree that different things\nshould and can be handled differently, it is not always so clear cut.\nIt's prudent to treat things as more severe than you know them to be.\n\nIn fact, someone pointed out to me a major amplifier of the\nutxo-memory attack thing today that Bitcoin Core narrowly dodges which\nwould have made it very easy to exploit against some users, and which\nit seems no one previously considered.\n\nI also think it's somewhat incorrect to call this thread anything\nabout disclosure, this thread is not about disclosure. Disclosure is\nwhen you tell the vendor.  This thread is about publication and that\nhas very different implications. Publication is when you're sure\nyou've told the prospective attackers."
            },
            {
                "author": "Anthony Towns",
                "date": "2017-09-12T04:47:58",
                "message_text_only": "On Mon, Sep 11, 2017 at 10:43:52AM -0700, Daniel Stadulis wrote:\n> I think it's relevant to treat different bug severity levels with different\n> response plans.\u00a0\n\nThat makes sense.\n\nFor comparison, Monero defines a response process that has three levels\nand varies the response for each:\n\n]     a. HIGH: impacts network as a whole, has potential to break entire\n]        network, results in the loss of monero, or is on a scale of great\n]        catastrophe\n]     b. MEDIUM: impacts individual nodes, wallets, or must be carefully\n]        exploited\n]     c. LOW: is not easily exploitable\n\n -- https://github.com/monero-project/monero/blob/master/VULNERABILITY_RESPONSE_PROCESS.md\n\nAmong other things, HIGH gets treated as an emergency, MEDIUM get fixed\nin a point release; LOW get deferred to the next regular release eg.\n\nAdditionally, independently of the severity, Monero's doc says they'll\neither get their act together with a fix and report within 90 days,\nor otherwise the researcher that found the vulnerability has the right\nto publically disclose the issue themselves...\n\nI wouldn't say that's a perfect fit for bitcoin core (at a minimum, given\nthe size of the ecosystem and how much care needs to go into releases,\nI think 90 days is probably too short), but it seems better than current\npractice...\n\nFor comparison, if you're an altcoin developer or just bitcoin core user,\nand are trying to work out whether the software you're using is secure;\nif you do a quick google and end up at:\n\n  https://en.bitcoin.it/wiki/Common_Vulnerabilities_and_Exposures\n\nyou might conclude that as long as you're running version 0.11 or later,\nyou're fine. That doesn't seem like an accurate conclusion for people\nto draw; but if you're not tracking every commit/PR, how do you do any\nbetter than that?\n\nMaybe transitioning from keeping things private indefinitely to having\na public disclosure policy is tricky. Maybe it might work to build up to it,\nsomething like:\n\n  * We'll start releasing info about security vulnerabilities fixed in\n    0.12.0 and earlier releases as of 2018-01-01\n  * Then we'll continue with 0.13.0 and earlier as of 2018-03-01\n  * Likewise for 0.14.0 as of 2018-05-01\n  * Thereafter we'll adopt a regular policy at http://...\n\nThat or something like it at least gives people relying on older,\npotentially vulnerable versions a realistic chance to privately prepare\nand deploy any upgrades or fixes they've missed out on until now.\n\nCheers,\naj"
            },
            {
                "author": "Anthony Towns",
                "date": "2017-09-12T03:37:03",
                "message_text_only": "On Mon, Sep 11, 2017 at 07:34:33AM -0400, Alex Morcos wrote:\n> I don't think I know the right answer here, but I will point out two things\n> that make this a little more complicated.\n> 1 - There are lots of altcoin developers and while I'm sure the majority would\n> greatly appreciate the disclosure and would behave responsibly with the\n> information, I don't know where you draw the line on who you tell and who you\n> don't.\n\nIf you can't pick even a small group that's trustworthy (top five by\nmarket cap as a start [0]? or just major bitcoin wallets / exchanges /\nalt node implementations?), then it still seems better to (eventually)\ndisclose publically than keep it unrevealed and let it be a potential\nadvantage for attackers against people who haven't upgraded for other\nreasons?\n\nI find it hard to imagine bitcoin's still obscure enough that people\naren't tracking git commit logs to use them as inspiration for attacks\non bitcoin users and businesses; at best I would have thought it'd\nonly be a few months of development time between a fix being proposed\nas a PR or committed to master and black hats having the ability to\nexploit it in users who are running older nodes. (Or for that matter,\nbeing able to be exploited by otherwise legitimate bitcoin businesses\nwith an agenda to push, a strong financial motive behind that agenda,\nand a legal team that says they'll get away with it)\n\n> 2- Unlike other software, I'm not sure good security for bitcoin is defined by\n> constant upgrading.\u00a0 Obviously upgrading has an important benefit, but one of\n> the security considerations for Bitcoin is knowing that your definition of the\n> money hasn't changed.\u00a0 Much harder to know that if you change software.\n\nIsn't that just an argument for putting more effort into backporting\nfixes/workarounds? (I don't see how you do that without essentially\npublically disclosing which patches have a security impact -- \"oh,\ngosh, this patch gets a backport, I wonder if maybe it has security\nimplications...\")\n\n(In so far as bitcoin is a consensus system, there can sometimes be a\npositive network effect, where having other people upgrade can help your\nsecurity, even if you don't upgrade; \"herd immunity\" if you will. That\nway a new release going out to other people helps keep you safe, even\nwhile you continue to maintain the same definition of money by not\nupgrading at all)\n\nIf altcoin maintainers are inconvenienced by tracking bitcoin-core\nupdates, that would be an argument for them to contribute back to their\nupstream to make their own job easier; either helping with backports,\nor perhaps contributing to patches like PR#8994 might help.\n\nAll of those things seem like they'd help not just altcoins but bitcoin\ninvestors/traders too, so it's not even a trade-off between classes of\nbitcoin core users.  And if in the end various altcoins aren't able to\nkeep up with security fixes, that's probably valuable information to\nprovide to the market...\n\nCheers,\naj\n\n[0] Roughly: BCash, Litecoin, Dash, BitConnect, ZCash, Dogecoin?\n    I've no idea which of those might have trustworthy devs to work with,\n    but surely at least a couple do?"
            },
            {
                "author": "Sergio Demian Lerner",
                "date": "2017-09-12T04:49:34",
                "message_text_only": "Historically people have published vulnerabilities in Bitcoin only after\n>80% of the nodes have upgraded. This seems to be the general (but not\npublicly stated) policy. If you're a core developer and you know better,\nplease correct me.\n\nThis means that:\n\n- a critical vulnerability, like a remote code execution, will be patched\nimmediately (without disclosing the actual problem) and all participants\nwill be notified asap. This is no different from any other open source\nproject. An example of this case was the OpenSSL Heartbleed vulnerability\nthat affected Bitcoin.\n\n- a non-critical vulnerability, either because miners only can exploit it\nor because it requires vast resources to pull, may require a wait of years\nbefore publication, after a vulnerability was found and reported. This is\nbecause the \"natural\" node upgrade rate is slow.\n\nIt also implies that some times a researcher works hard to investigate a\nvulnerability and later he finds out it was previously reported. It also\nmeans that the researcher cannot report to alt-coins which have a different\npolicy.\n\nThis policy has nothing to do with a loyalty to Bitcoin Core (or in fact,\nthe two or so developers that actually receive the e-mails to\nsecurity at bitcoincore.org).\n\nThis is a policy that has simply proven to work to protect Bitcoiners. It\nbegan long long ago.\n\n\n\nOn Tue, Sep 12, 2017 at 12:37 AM, Anthony Towns via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Mon, Sep 11, 2017 at 07:34:33AM -0400, Alex Morcos wrote:\n> > I don't think I know the right answer here, but I will point out two\n> things\n> > that make this a little more complicated.\n> > 1 - There are lots of altcoin developers and while I'm sure the majority\n> would\n> > greatly appreciate the disclosure and would behave responsibly with the\n> > information, I don't know where you draw the line on who you tell and\n> who you\n> > don't.\n>\n> If you can't pick even a small group that's trustworthy (top five by\n> market cap as a start [0]? or just major bitcoin wallets / exchanges /\n> alt node implementations?), then it still seems better to (eventually)\n> disclose publically than keep it unrevealed and let it be a potential\n> advantage for attackers against people who haven't upgraded for other\n> reasons?\n>\n> I find it hard to imagine bitcoin's still obscure enough that people\n> aren't tracking git commit logs to use them as inspiration for attacks\n> on bitcoin users and businesses; at best I would have thought it'd\n> only be a few months of development time between a fix being proposed\n> as a PR or committed to master and black hats having the ability to\n> exploit it in users who are running older nodes. (Or for that matter,\n> being able to be exploited by otherwise legitimate bitcoin businesses\n> with an agenda to push, a strong financial motive behind that agenda,\n> and a legal team that says they'll get away with it)\n>\n> > 2- Unlike other software, I'm not sure good security for bitcoin is\n> defined by\n> > constant upgrading.  Obviously upgrading has an important benefit, but\n> one of\n> > the security considerations for Bitcoin is knowing that your definition\n> of the\n> > money hasn't changed.  Much harder to know that if you change software.\n>\n> Isn't that just an argument for putting more effort into backporting\n> fixes/workarounds? (I don't see how you do that without essentially\n> publically disclosing which patches have a security impact -- \"oh,\n> gosh, this patch gets a backport, I wonder if maybe it has security\n> implications...\")\n>\n> (In so far as bitcoin is a consensus system, there can sometimes be a\n> positive network effect, where having other people upgrade can help your\n> security, even if you don't upgrade; \"herd immunity\" if you will. That\n> way a new release going out to other people helps keep you safe, even\n> while you continue to maintain the same definition of money by not\n> upgrading at all)\n>\n> If altcoin maintainers are inconvenienced by tracking bitcoin-core\n> updates, that would be an argument for them to contribute back to their\n> upstream to make their own job easier; either helping with backports,\n> or perhaps contributing to patches like PR#8994 might help.\n>\n> All of those things seem like they'd help not just altcoins but bitcoin\n> investors/traders too, so it's not even a trade-off between classes of\n> bitcoin core users.  And if in the end various altcoins aren't able to\n> keep up with security fixes, that's probably valuable information to\n> provide to the market...\n>\n> Cheers,\n> aj\n>\n> [0] Roughly: BCash, Litecoin, Dash, BitConnect, ZCash, Dogecoin?\n>     I've no idea which of those might have trustworthy devs to work with,\n>     but surely at least a couple do?\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170912/78a88c9e/attachment-0001.html>"
            },
            {
                "author": "Simon Liu",
                "date": "2017-09-12T16:10:18",
                "message_text_only": "It would be a good starting point if the current policy could be\nclarified, so everyone is on the same page, and there is no confusion.\n\n\nOn 09/11/2017 09:49 PM, Sergio Demian Lerner via bitcoin-dev wrote:\n> Historically people have published vulnerabilities in Bitcoin only after\n>>80% of the nodes have upgraded. This seems to be the general (but not\n> publicly stated) policy. If you're a core developer and you know better,\n> please correct me.\n>"
            },
            {
                "author": "Anthony Towns",
                "date": "2017-09-14T05:27:40",
                "message_text_only": "On Tue, Sep 12, 2017 at 09:10:18AM -0700, Simon Liu wrote:\n> It would be a good starting point if the current policy could be\n> clarified, so everyone is on the same page, and there is no confusion.\n\nCollecting various commentary from here and reddit, I think current de\nfacto policy is something like:\n\n * Vulnerabilities should be reported via security at bitcoincore.org [0]\n\n * A critical issue (that can be exploited immediately or is already\n   being exploited causing large harm) will be dealt with by:\n     * a released patch ASAP\n     * wide notification of the need to upgrade (or to disable affected\n       systems)\n     * minimal disclosure of the actual problem, to delay attacks\n   [1] [2]\n\n * A non-critical vulnerability (because it is difficult or expensive to\n   exploit) will be dealt with by:\n     * patch and review undertaken in the ordinary flow of development\n     * backport of a fix or workaround from master to the current\n       released version [2]\n\n * Devs will attempt to ensure that publication of the fix does not\n   reveal the nature of the vulnerability by providing the proposed fix\n   to experienced devs who have not been informed of the vulnerability,\n   telling them that it fixes a vulnerability, and asking them to identify\n   the vulnerability. [2]\n\n * Devs may recommend other bitcoin implementations adopt vulnerability\n   fixes prior to the fix being released and widely deployed, if they\n   can do so without revealing the vulnerability; eg, if the fix has\n   significant performance benefits that would justify its inclusion. [3]\n\n * Prior to a vulnerability becoming public, devs will generally recommend\n   to friendly altcoin devs that they should catch up with fixes. But this\n   is only after the fixes are widely deployed in the bitcoin network. [4]\n\n * Devs will generally not notify altcoin developers who have behaved\n   in a hostile manner (eg, using vulnerabilities to attack others, or\n   who violate embargoes). [5]\n\n * Bitcoin devs won't disclose vulnerability details until >80% of bitcoin\n   nodes have deployed the fixes. Vulnerability discovers are encouraged\n   and requested to follow the same policy. [1] [6]\n\nThose seem like pretty good policies to me, for what it's worth.\n\nI haven't seen anything that indicates bitcoin devs will *ever* encourage\npublic disclosure of vulnerabilities (as opposed to tolerating other\npeople publishing them [6]). So I'm guessing current de facto policy is\nmore along the lines of:\n\n * Where possible, Bitcoin devs will never disclose vulnerabilities\n   publically while affected code may still be in use (including by\n   altcoins).\n\nrather than something like:\n\n * Bitcoin devs will disclose vulnerabilities publically after 99% of the\n   bitcoin network has upgraded [7], and fixes have been released for\n   at least 12 months.\n\n\nInstinctively, I'd say documenting this policy (or whatever it actually\nis) would be good, and having all vulnerabilities get publically released\neventually would also be good; that's certainly the more \"open source\"\napproach. But arguing the other side:\n\n - documenting security policy gives attackers a better handle on where\n   to find weak points; this may be more harm than there is benefit to\n   improving legitimate users' understanding of and confidence in the\n   development process\n\n - the main benefit of public vulnerability disclosure is a better\n   working relationship with security researchers and perhaps better\n   understanding of what sort of bugs happen in practice in general;\n   but if most of your security research is effectively in house [6],\n   maybe those benefits aren't as great as the harm done by revealing\n   even old vulnerabilities to attackers\n\nIf the first of those arguments holds, well, hopefully this message has\negregious errors that no one will correct, or it will quickly get lost\nin this list's archives...\n\nCheers,\naj\n\n[0] http://bitcoincore.org/en/contact\n    referenced from .github/ISSUE_TEMPLATE.md in git\n\n[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/014986.html\n\n[2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/014990.html\n\n[3] https://www.reddit.com/r/btc/comments/6zf1qo/peter_todd_nicely_pulled_away_attention_from_jjs/dmxcw70/\n\n[4] https://www.reddit.com/r/btc/comments/6z827o/chris_jeffrey_jj_discloses_bitcoin_attack_vector/dmxdg83/\n\n[5] https://www.reddit.com/r/btc/comments/6zb3lp/maxwell_admits_core_sat_on_vulnerability/dmv4y7g/\n\n[6] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/014991.html \n\n[7] Per http://luke.dashjr.org/programs/bitcoin/files/charts/branches.html\n    it seems like 1.7% of the network is running known-vulnerable versions\n    0.8 and 0.9; but only 0.37% are running 0.10 or 0.11, so that might argue\n    revealing any vulnerabilities fixed since 0.12.0 would be fine...\n    (bitnodes.21.co doesn't seem to break down anything earlier than 0.12)"
            },
            {
                "author": "Nathan Wilcox",
                "date": "2017-09-22T02:00:31",
                "message_text_only": "[inline responses]\n\n\nOn Thu, Sep 14, 2017 at 2:27 PM, Anthony Towns via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Tue, Sep 12, 2017 at 09:10:18AM -0700, Simon Liu wrote:\n> > It would be a good starting point if the current policy could be\n> > clarified, so everyone is on the same page, and there is no confusion.\n>\n> Collecting various commentary from here and reddit, I think current de\n> facto policy is something like:\n>\n>  * Vulnerabilities should be reported via security at bitcoincore.org [0]\n>\n>  * A critical issue (that can be exploited immediately or is already\n>    being exploited causing large harm) will be dealt with by:\n>      * a released patch ASAP\n>      * wide notification of the need to upgrade (or to disable affected\n>        systems)\n>      * minimal disclosure of the actual problem, to delay attacks\n>    [1] [2]\n>\n>  * A non-critical vulnerability (because it is difficult or expensive to\n>    exploit) will be dealt with by:\n>      * patch and review undertaken in the ordinary flow of development\n>      * backport of a fix or workaround from master to the current\n>        released version [2]\n>\n>  * Devs will attempt to ensure that publication of the fix does not\n>    reveal the nature of the vulnerability by providing the proposed fix\n>    to experienced devs who have not been informed of the vulnerability,\n>    telling them that it fixes a vulnerability, and asking them to identify\n>    the vulnerability. [2]\n>\n>  * Devs may recommend other bitcoin implementations adopt vulnerability\n>    fixes prior to the fix being released and widely deployed, if they\n>    can do so without revealing the vulnerability; eg, if the fix has\n>    significant performance benefits that would justify its inclusion. [3]\n>\n>  * Prior to a vulnerability becoming public, devs will generally recommend\n>    to friendly altcoin devs that they should catch up with fixes. But this\n>    is only after the fixes are widely deployed in the bitcoin network. [4]\n>\n>  * Devs will generally not notify altcoin developers who have behaved\n>    in a hostile manner (eg, using vulnerabilities to attack others, or\n>    who violate embargoes). [5]\n>\n>  * Bitcoin devs won't disclose vulnerability details until >80% of bitcoin\n>    nodes have deployed the fixes. Vulnerability discovers are encouraged\n>    and requested to follow the same policy. [1] [6]\n>\n> Those seem like pretty good policies to me, for what it's worth.\n>\n>\nI advocate a policy like this, except I propose two modifications:\n\n- Point 4 should include *zero or more* altcoin developers, such that those\naltcoins also deploy mitigations as early as Bitcoin. (Call this \"early\naltcoin disclosure\".)\n\n- Disclose of vulnerabilities, by social convention, always explicitly\nnames which altcoin developers were included in my proposed Early Altcoin\nDisclosure and Point 6.\n\nThe rationale is that the policy should allow closer coordination with\naltcoins. If the goal is minimizing economic damage, including altcoins\nearlier may be the better trade-off between inclusiveness and secrecy. At\nthe same time, the policy doesn't establish *which* altcoins, which is a\ntricky choice. However it *does* require disclosure of those relationships,\nwhich provides a form of feedback on the system.\n\nImagine if altcoin X is compromised, and later disclosure occurs that\nreveals that altcoin X was not contacted early, then this *might* indicate\nleaks, maliciousness in the Bitcoin mitigation organization, or it *might*\nbe coincidence or dumb luck. In the other case, if the Bitcoin disclosure\nreveals that X was indeed contacted early, then it probably indicates\nincompetence of the altoin X.\n\nFinally, notice that this kind of loose early disclosure policy can be\nsymmetric. For example, Zcash developers may choose to disclose\nvulnerabilities they discover which affect Bitcoin to Bitcoin developers\n*before* Zcash releases fixes, or before those fixes are widely adopted in\nZcash. We actually have a policy of doing this, since it's obvious that if\nour mitigation process leaks and that's used to attack Bitcoin the\npotential economic damage is very large.\n\n\n\n> I haven't seen anything that indicates bitcoin devs will *ever* encourage\n> public disclosure of vulnerabilities (as opposed to tolerating other\n> people publishing them [6]). So I'm guessing current de facto policy is\n> more along the lines of:\n>\n>  * Where possible, Bitcoin devs will never disclose vulnerabilities\n>    publically while affected code may still be in use (including by\n>    altcoins).\n>\n> rather than something like:\n>\n>  * Bitcoin devs will disclose vulnerabilities publically after 99% of the\n>    bitcoin network has upgraded [7], and fixes have been released for\n>    at least 12 months.\n>\n>\nI advocate for something like the latter case. I'd like to see a timeout on\ndisclosure. There's an endless tail of alt-coins that could be affected,\nand no guarantee all will vigilantly upgrade. Meanwhile, deciding which of\nthem to disclose to confidentially versus which should just receive hints\nto apply new patches is tricky and political.\n\nHaving a global timeout is a reasonable stop-gap. I consider the cost of\nnever disclosing, publicly, a known vulnerbility to be very high, even if\nthe fix is ubiquitously deployed, because it's a loss of security\nknowledge, a precious public good.\n\n\n>\n> Instinctively, I'd say documenting this policy (or whatever it actually\n> is) would be good, and having all vulnerabilities get publically released\n> eventually would also be good; that's certainly the more \"open source\"\n> approach. But arguing the other side:\n>\n>  - documenting security policy gives attackers a better handle on where\n>    to find weak points; this may be more harm than there is benefit to\n>    improving legitimate users' understanding of and confidence in the\n>    development process\n>\n>\nPublishing a policy *might* increase organizational vulnerability, but so\nmight *not publishing* a policy. It seems fairly neutral to me on\nvulnerability impact, whereas the benefit is good for users and developers.\n\n\n\n>  - the main benefit of public vulnerability disclosure is a better\n>    working relationship with security researchers and perhaps better\n>    understanding of what sort of bugs happen in practice in general;\n>    but if most of your security research is effectively in house [6],\n>    maybe those benefits aren't as great as the harm done by revealing\n>    even old vulnerabilities to attackers\n>\n>\nPublishing after a reasonable timeout has many benefits. Many security\nresearchers learn from vulnerability disclosures across many disciplines\nand industries. Future protocol designers of things potentially unrelated\nto blockchain altogether may also learn important lessons.\n\n\nIf the first of those arguments holds, well, hopefully this message has\n> egregious errors that no one will correct, or it will quickly get lost\n> in this list's archives...\n>\n> Cheers,\n> aj\n>\n>\nregards,\nNathan Wilcox\nZcash\n\n\n> [0] http://bitcoincore.org/en/contact\n>     referenced from .github/ISSUE_TEMPLATE.md in git\n>\n> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> 2017-September/014986.html\n>\n> [2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> 2017-September/014990.html\n>\n> [3] https://www.reddit.com/r/btc/comments/6zf1qo/peter_todd_\n> nicely_pulled_away_attention_from_jjs/dmxcw70/\n>\n> [4] https://www.reddit.com/r/btc/comments/6z827o/chris_jeffrey_\n> jj_discloses_bitcoin_attack_vector/dmxdg83/\n>\n> [5] https://www.reddit.com/r/btc/comments/6zb3lp/maxwell_\n> admits_core_sat_on_vulnerability/dmv4y7g/\n>\n> [6] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> 2017-September/014991.html\n>\n> [7] Per http://luke.dashjr.org/programs/bitcoin/files/charts/branches.html\n>     it seems like 1.7% of the network is running known-vulnerable versions\n>     0.8 and 0.9; but only 0.37% are running 0.10 or 0.11, so that might\n> argue\n>     revealing any vulnerabilities fixed since 0.12.0 would be fine...\n>     (bitnodes.21.co doesn't seem to break down anything earlier than 0.12)\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170922/db798f3b/attachment-0001.html>"
            },
            {
                "author": "Sergio Demian Lerner",
                "date": "2017-09-22T19:53:46",
                "message_text_only": "The policy seems good with the exception of this paragraph:\n\n* Bitcoin devs will disclose vulnerabilities publically after 99% of the\n   bitcoin network has upgraded [7], and fixes have been released for\n   at least 12 months.\n\n99% upgrade may never be reached. Some nodes cannot even be categorized. I\nsuggest a number close to 95%.\nIf the 95% of network has upgraded, it means we're pretty secure from the\npoint of view of consensus. It is supposed that from the time the fix has\nbeen released, all other alt-coins will also have released their fixes.\nRemember we must also incentivize security researchers to do the hard and\nsilent research work. Most of them do not hold Bitcoins. They do research\nbecause of other interests, including getting public acknowledgment for\ntheir findings. They'll be frustrated if they have to wait 2 years.\n\nI propose this paragraph to replace the previous one:\n\n* Bitcoin devs will disclose vulnerabilities publically after 95% of the\n   bitcoin network has upgraded [7], and fixes have been released for\n   at least 6 months.\n\nAlso I suggest we track vulnerabilities with standard CVE codes. IS there\nany drawback of this?\n\nregards\n\n\nOn Thu, Sep 21, 2017 at 11:00 PM, Nathan Wilcox via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> [inline responses]\n>\n>\n> On Thu, Sep 14, 2017 at 2:27 PM, Anthony Towns via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> On Tue, Sep 12, 2017 at 09:10:18AM -0700, Simon Liu wrote:\n>> > It would be a good starting point if the current policy could be\n>> > clarified, so everyone is on the same page, and there is no confusion.\n>>\n>> Collecting various commentary from here and reddit, I think current de\n>> facto policy is something like:\n>>\n>>  * Vulnerabilities should be reported via security at bitcoincore.org [0]\n>>\n>>  * A critical issue (that can be exploited immediately or is already\n>>    being exploited causing large harm) will be dealt with by:\n>>      * a released patch ASAP\n>>      * wide notification of the need to upgrade (or to disable affected\n>>        systems)\n>>      * minimal disclosure of the actual problem, to delay attacks\n>>    [1] [2]\n>>\n>>  * A non-critical vulnerability (because it is difficult or expensive to\n>>    exploit) will be dealt with by:\n>>      * patch and review undertaken in the ordinary flow of development\n>>      * backport of a fix or workaround from master to the current\n>>        released version [2]\n>>\n>>  * Devs will attempt to ensure that publication of the fix does not\n>>    reveal the nature of the vulnerability by providing the proposed fix\n>>    to experienced devs who have not been informed of the vulnerability,\n>>    telling them that it fixes a vulnerability, and asking them to identify\n>>    the vulnerability. [2]\n>>\n>>  * Devs may recommend other bitcoin implementations adopt vulnerability\n>>    fixes prior to the fix being released and widely deployed, if they\n>>    can do so without revealing the vulnerability; eg, if the fix has\n>>    significant performance benefits that would justify its inclusion. [3]\n>>\n>>  * Prior to a vulnerability becoming public, devs will generally recommend\n>>    to friendly altcoin devs that they should catch up with fixes. But this\n>>    is only after the fixes are widely deployed in the bitcoin network. [4]\n>>\n>>  * Devs will generally not notify altcoin developers who have behaved\n>>    in a hostile manner (eg, using vulnerabilities to attack others, or\n>>    who violate embargoes). [5]\n>>\n>>  * Bitcoin devs won't disclose vulnerability details until >80% of bitcoin\n>>    nodes have deployed the fixes. Vulnerability discovers are encouraged\n>>    and requested to follow the same policy. [1] [6]\n>>\n>> Those seem like pretty good policies to me, for what it's worth.\n>>\n>>\n> I advocate a policy like this, except I propose two modifications:\n>\n> - Point 4 should include *zero or more* altcoin developers, such that\n> those altcoins also deploy mitigations as early as Bitcoin. (Call this\n> \"early altcoin disclosure\".)\n>\n> - Disclose of vulnerabilities, by social convention, always explicitly\n> names which altcoin developers were included in my proposed Early Altcoin\n> Disclosure and Point 6.\n>\n> The rationale is that the policy should allow closer coordination with\n> altcoins. If the goal is minimizing economic damage, including altcoins\n> earlier may be the better trade-off between inclusiveness and secrecy. At\n> the same time, the policy doesn't establish *which* altcoins, which is a\n> tricky choice. However it *does* require disclosure of those relationships,\n> which provides a form of feedback on the system.\n>\n> Imagine if altcoin X is compromised, and later disclosure occurs that\n> reveals that altcoin X was not contacted early, then this *might* indicate\n> leaks, maliciousness in the Bitcoin mitigation organization, or it *might*\n> be coincidence or dumb luck. In the other case, if the Bitcoin disclosure\n> reveals that X was indeed contacted early, then it probably indicates\n> incompetence of the altoin X.\n>\n> Finally, notice that this kind of loose early disclosure policy can be\n> symmetric. For example, Zcash developers may choose to disclose\n> vulnerabilities they discover which affect Bitcoin to Bitcoin developers\n> *before* Zcash releases fixes, or before those fixes are widely adopted in\n> Zcash. We actually have a policy of doing this, since it's obvious that if\n> our mitigation process leaks and that's used to attack Bitcoin the\n> potential economic damage is very large.\n>\n>\n>\n>> I haven't seen anything that indicates bitcoin devs will *ever* encourage\n>> public disclosure of vulnerabilities (as opposed to tolerating other\n>> people publishing them [6]). So I'm guessing current de facto policy is\n>> more along the lines of:\n>>\n>>  * Where possible, Bitcoin devs will never disclose vulnerabilities\n>>    publically while affected code may still be in use (including by\n>>    altcoins).\n>>\n>> rather than something like:\n>>\n>>  * Bitcoin devs will disclose vulnerabilities publically after 99% of the\n>>    bitcoin network has upgraded [7], and fixes have been released for\n>>    at least 12 months.\n>>\n>>\n> I advocate for something like the latter case. I'd like to see a timeout\n> on disclosure. There's an endless tail of alt-coins that could be affected,\n> and no guarantee all will vigilantly upgrade. Meanwhile, deciding which of\n> them to disclose to confidentially versus which should just receive hints\n> to apply new patches is tricky and political.\n>\n> Having a global timeout is a reasonable stop-gap. I consider the cost of\n> never disclosing, publicly, a known vulnerbility to be very high, even if\n> the fix is ubiquitously deployed, because it's a loss of security\n> knowledge, a precious public good.\n>\n>\n>>\n>> Instinctively, I'd say documenting this policy (or whatever it actually\n>> is) would be good, and having all vulnerabilities get publically released\n>> eventually would also be good; that's certainly the more \"open source\"\n>> approach. But arguing the other side:\n>>\n>>  - documenting security policy gives attackers a better handle on where\n>>    to find weak points; this may be more harm than there is benefit to\n>>    improving legitimate users' understanding of and confidence in the\n>>    development process\n>>\n>>\n> Publishing a policy *might* increase organizational vulnerability, but so\n> might *not publishing* a policy. It seems fairly neutral to me on\n> vulnerability impact, whereas the benefit is good for users and developers.\n>\n>\n>\n>>  - the main benefit of public vulnerability disclosure is a better\n>>    working relationship with security researchers and perhaps better\n>>    understanding of what sort of bugs happen in practice in general;\n>>    but if most of your security research is effectively in house [6],\n>>    maybe those benefits aren't as great as the harm done by revealing\n>>    even old vulnerabilities to attackers\n>>\n>>\n> Publishing after a reasonable timeout has many benefits. Many security\n> researchers learn from vulnerability disclosures across many disciplines\n> and industries. Future protocol designers of things potentially unrelated\n> to blockchain altogether may also learn important lessons.\n>\n>\n> If the first of those arguments holds, well, hopefully this message has\n>> egregious errors that no one will correct, or it will quickly get lost\n>> in this list's archives...\n>>\n>> Cheers,\n>> aj\n>>\n>>\n> regards,\n> Nathan Wilcox\n> Zcash\n>\n>\n>> [0] http://bitcoincore.org/en/contact\n>>     referenced from .github/ISSUE_TEMPLATE.md in git\n>>\n>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017\n>> -September/014986.html\n>>\n>> [2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017\n>> -September/014990.html\n>>\n>> [3] https://www.reddit.com/r/btc/comments/6zf1qo/peter_todd_nice\n>> ly_pulled_away_attention_from_jjs/dmxcw70/\n>>\n>> [4] https://www.reddit.com/r/btc/comments/6z827o/chris_jeffrey_j\n>> j_discloses_bitcoin_attack_vector/dmxdg83/\n>>\n>> [5] https://www.reddit.com/r/btc/comments/6zb3lp/maxwell_admits_\n>> core_sat_on_vulnerability/dmv4y7g/\n>>\n>> [6] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017\n>> -September/014991.html\n>>\n>> [7] Per http://luke.dashjr.org/programs/bitcoin/files/charts/branche\n>> s.html\n>>     it seems like 1.7% of the network is running known-vulnerable versions\n>>     0.8 and 0.9; but only 0.37% are running 0.10 or 0.11, so that might\n>> argue\n>>     revealing any vulnerabilities fixed since 0.12.0 would be fine...\n>>     (bitnodes.21.co doesn't seem to break down anything earlier than\n>> 0.12)\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170922/cdd9e559/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2017-09-12T17:57:32",
                "message_text_only": "On Tue, Sep 12, 2017 at 4:49 AM, Sergio Demian Lerner via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> It also implies that some times a researcher works hard to investigate a\n> vulnerability and later he finds out it was previously reported. It also\n> means that the researcher cannot report to alt-coins which have a different\n> policy.\n\nI agree with your post, but wanted to make a point of clarification on\nthe use of \"can't\".\n\nIf someone wants to report something to the Bitcoin project we're\nobviously at your mercy in how we handle it. If we disagree on the\nhandling approach we may try to talk you into a different position\nbased with a rational judgement based on our experience (or, if\njustified, advice that we're likely to whine about your approach in\npublic). But if you still want to go also report a common issue to\nsomething else with a different approach then you can. Even our\nire/whining can be avoided by a sincere effort to communicate and give\nus an opportunity to mitigate harm.\n\nThat said, as mentioned, we'd encourage otherwise for issues that\nwarrant it-- and I think with cause enough that the reporter will\nagree. So that is a different kind of \"cant\". :)\n\nIn Bitcoin the overwhelming majority of serious issues we've\nencountered have been found by people I'd consider 'inside the\nproject' (frequent regular contributors who aren't seriously involved\nin other things).  That hasn't been so obviously the case for other\nopen source projects that I've been involved with; but Bitcoin is\npretty good from a basic security perspective and finding additional\nissues often requires specialized experience that few people outside\nof the project regulars have (though some, like Sergio, clearly do).\n\nI know through direct experience that both Mozilla and the Chrome\nproject fix _serious_ (like RCE bugs) issues based on internal\ndiscoveries which they do not make public (apparently ever), though\nthey may coordinate with distributors on some of them.   (Some of\nthese experiences are also why I give the advice that you should not\nconsider any computer which has ever run a web browser to be strongly\nsecure...)"
            },
            {
                "author": "Bryan Bishop",
                "date": "2017-09-12T05:18:14",
                "message_text_only": "On Mon, Sep 11, 2017 at 10:37 PM, Anthony Towns via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> All of those things seem like they'd help not just altcoins but bitcoin\n> investors/traders too, so it's not even a trade-off between classes of\n> bitcoin core users.  And if in the end various altcoins aren't able to\n> keep up with security fixes, that's probably valuable information to\n> provide to the market...\n\nI have a reply to your point, but I want to clarify first that I am\nnot trying to provide any sort of criticism of your character, and to\nany extent that my text is misinterpreted that way, that's entirely my\nfault here. Anyway, here goes.\n\nIt's not enough to defend bitcoin and its users from active threats,\nthere is a more general responsibility to defend all kinds of users\nand different software from many kinds of threats in whatever forms,\neven if folks are using stupid and insecure software that you\npersonally don't maintain or contribute to or advocate for. Handling\nknowledge of a vulnerability is a delicate matter and you might be\nreceiving knowledge with more serious direct or indirect impact than\noriginally described.\n\nBesides the moral and ethical reasons to not unduly accelerate the\nexploitation of a vulnerability, there is also a reputational\nstandpoint to consider, in that your position that your own (security)\nwork is credible is actually harmed by showing negative care for other\nworks by being first to publish either insecure software or knowledge\nof a vulnerability. And sometimes the opposite is true: by not\ndisclosing knowledge of how a design is broken to someone inviting its\nreview, you're showing negative care in that way too, such as by\nunintentionally encouraging the implementation of really bad ideas or\nentirely novel misunderstandings of what you once thought were clear\nconcepts. So there is a difficult path to walk and especially in\nsecurity not all may be as it seems; caution is highly recommended.\n\nYes it would be good for \"the market\" to \"get the signal\" that\naltcoins are insecure, and that some altcoin vendors are literally and\nactively malicious entities, but I think everyone needs to take a step\nback here and very carefully consider the color of their hats,\nincluding those who advocate in the name of insecure downstream/forked\nsoftware.\n\nThe downside of the approach I've advocated for is that it requires\nknowledge, thinking and outsmarting the red teams; I am certainly\naware of the allure of the approaches that involve absolutist\nstatements like \"anything weak [including bitcoin if it does have\nweaknesses] deserves to die and be actively exploited\" but it's not\nsomething I am interested in espousing...nor do I think it would be\nhealthy for this community to internalize that perspective. Instead we\nshould continue to work on highly defensible software, and keep\nvigilant in regards to security. In \"the [civilized] garden\" I would\nexpect there to be a general understanding that people collaborate and\nwork together to build highly defensible evolving systems even if\nthere exists knowledge of vulnerabilities. But we shouldn't be\nsurprised when we don't go out of our way to contribute to\nalternative/parasitic systems... and we shouldn't be encouraging each\nother to actively bring about the eschaton by way of mishandling\nknowledge of vulnerabilities...\n\nI know these issues are difficult to get a handle on. Hopefully I've\nprovided some useful perspective.\n\n- Bryan\nhttp://heybryan.org/\n1 512 203 0507"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2017-09-12T17:41:42",
                "message_text_only": "On Tue, Sep 12, 2017 at 3:37 AM, Anthony Towns via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> If you can't pick even a small group that's trustworthy\n\nNo.\n\n> I find it hard to imagine bitcoin's still obscure enough that people\n> aren't tracking git commit logs to use them as inspiration for attacks\n\nFor embargoed fixes we test the specific fixes against experienced\ndevelopers inside the project, handing them the proposed commit and\ninforming them that it fixes a vulnerability and asking them to\nidentify it.\n\nThis does not guarantee that the fix won't leak the issue, but in\nvirtually all cases in the past the issues we've dealt with would not\nbe made worse off being leaked in that way vs just making it public\noutright.\n\nIf we had an issue that would be-- e.g. an RCE that could lead to\nprivate key theft, we would likely handle it differently (e.g. making\na public notice to take sensitive systems offline before attempting\nany fix).\n\n>  I would have thought it'd\n> only be a few months of development time between a fix being proposed\n> as a PR or committed to master and black hats having the ability to\n> exploit it in users who are running older nodes. (Or for that matter,\n> being able to be exploited by otherwise legitimate bitcoin businesses\n> with an agenda to push, a strong financial motive behind that agenda,\n> and a legal team that says they'll get away with it)\n\nHistory does not support your assumptions.\n\n>> 2- Unlike other software, I'm not sure good security for bitcoin is defined by\n>> constant upgrading.  Obviously upgrading has an important benefit, but one of\n>> the security considerations for Bitcoin is knowing that your definition of the\n>> money hasn't changed.  Much harder to know that if you change software.\n>\n> Isn't that just an argument for putting more effort into backporting\n> fixes/workarounds?\n\nNot really.  Any forced change still creates centralization,\ndependence, and an opportunity for insecurity.\n\n> (I don't see how you do that without essentially\n> publically disclosing which patches have a security impact -- \"oh,\n> gosh, this patch gets a backport, I wonder if maybe it has security\n> implications...\")\n\nThat is a concern too, but our bar for backport fixes is low enough\nthat they're often able to include more serious fixes without calling\nattention to them.\n\n> (In so far as bitcoin is a consensus system, there can sometimes be a\n> positive network effect, where having other people upgrade can help your\n> security, even if you don't upgrade; \"herd immunity\" if you will.\n\nThis is true even outside of the consensus critical parts.  In the P2P\nnetwork other people upgrading can be protective.\n\n> If altcoin maintainers are inconvenienced by tracking bitcoin-core\n> updates, that would be an argument for them to contribute back to their\n\nSure, a few have. Most do not because they are either not focused on\nsoftware quality or consider themselves as having an adversarial\nrelationship with Bitcoin.\n\n> keep up with security fixes, that's probably valuable information to\n> provide to the market...\n\nIf you'd like to provide the sort of valuable information to the\nmarket which may get you sued or targeted for harassment of physical\nattack-- feel free. Don't ask the rest of us to do so."
            }
        ],
        "thread_summary": {
            "title": "Responsible disclosure of bugs",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Daniel Stadulis",
                "Bryan Bishop",
                "CryptAxe",
                "Anthony Towns",
                "Simon Liu",
                "Sergio Demian Lerner",
                "Nathan Wilcox",
                "Alex Morcos",
                "Gregory Maxwell",
                "Matt Corallo"
            ],
            "messages_count": 17,
            "total_messages_chars_count": 67256
        }
    },
    {
        "title": "[bitcoin-dev] 2 softforks to cut the blockchain and IBD time",
        "thread_messages": [
            {
                "author": "michele terzi",
                "date": "2017-09-12T22:58:35",
                "message_text_only": "the blockchain is 160Gb and this is literally the biggest problem bitcoin has right now. syncing a new node is a nightmare that discourages a lot of people.\nthis single aspect is what hurts bitcoin's decentralization the most and it is getting worse by the day.\n\nto solve this problem i propose 2 softfork.\n\nboth of them have been partially discussed so you may be already familiar with them. I'll just try to highlight problems and benefits.\n\n\nfirst SF)\na snapshot of the UTXO set plus all the relevant info (like OP_RETURNs) is hashed in the coinbase.\nthis can be repeated automatically every given period of x blocks. I suggest 55k blocks (1 year)\n\nsecond SF)\nafter a given amount of time the UTXO hash is written in the consensus code.\nthis hash becomes the hash of a new genesis block and all the older blocks are chopped away\n\n\nPros:\n\nyou gain a much faster syncing for new nodes.\nfull non pruning nodes need a lot less HD space.\ndropping old history results in more difficult future chainanalysis (at least by small entities)\nfreezing old history in one new genesis block means the chain can no longer be reorged prior to that point\n\nold status\n\ngenesis |----- x ------| newgenesis |----- y ------| now\n\nnew status\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 newgenesis |----- y ------| now\n\nwhile the old chain can be reorged to the genesis block the new chain can be reorged only to the newgenesisblock\n\ncutting the chain has also some other small benefits: without the need to validate old blocks we can clean old no more usefull consensus code\n\n\nCons: \n\na small amount of space is consumed on the blockchain\nevery node needs to perform the calculations\n\nfull nodes with old software can no longer be fired up and sync with the existing network\nfull nodes that went off line prior to the second fork cannot sync back once they turn back on line again.\n\nif these things are concerning (which for me are not) we can just keep online a few archive nodes.\nold clients will sync only from archivial nodes with full history and new full nodes will sync from everywere\n\n\nAddressing security concerns:\n\nbeing able to write a new genesis block means that an evil core has the power to steal/destroy/censor/whatever coins.\n\nthis is possible only in theory, but not in practice. right now devs can misbehave with every softfork, but the community tests and inspects every new release.\n\nthe 2 forks will be tested and inspected as well so they are no more risky than other softforks.\n\nadditionally the process is divided into 2 separate steps and the first step (the critical one) is effectively void without the second (which is substantially delayed) this gives the community additional time to test it and thus is actually more secure than a standard softfork.\nbesides after the first softfork locks in there is no more room for mistakes. either the hashes match or they do not so spotting a misbehaviour is trivially simple\n\nkind regards,Michele\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170912/07a24423/attachment.html>"
            },
            {
                "author": "Tier Nolan",
                "date": "2017-09-13T09:09:52",
                "message_text_only": "On Tue, Sep 12, 2017 at 11:58 PM, michele terzi via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> Pros:\n>\n> you gain a much faster syncing for new nodes.\n> full non pruning nodes need a lot less HD space.\n> dropping old history results in more difficult future chainanalysis (at\n> least by small entities)\n> freezing old history in one new genesis block means the chain can no\n> longer be reorged prior to that point\n>\n\nCurrent nodes allow pruning so you can save disk space that way.  Users\nstill need to download/verify the new blocks though.\n\nUnder your scheme, you don't need to throw the data away.  Nodes can decide\nhow far back that they want to go.\n\n\"Fast\" IBD\n\n- download header chain from genesis (~4MB per year)\n- check headers against \"soft\" checkpoints (every 50k blocks)\n- download the UTXO set of the most recent soft checkpoint (and verify\nagainst hash)\n- download blocks starting from the most recent soft checkpoint\n- node is now ready to use\n- [Optional] Slowly download the remaining blocks\n\nThis requires some new protocol messages to allow requesting and send the\nUTXO set, though the inv and getdata messages could be used.\n\nIf you add a new services bit, NODE_NETWORK_RECENT, then nodes can find\nother nodes that have the most recent blocks.  This indicates that you have\nall blocks since the most recent snapshot.\n\nThe slow download doesn't have to download the blocks in order.  It can\njust check against the header chain.  Once a node has all the blocks, it\nwould switch from NODE_NETWORK_RECENT to NODE_NETWORK.\n\n(Multiple bits could be used to indicate that the node has 2 or more recent\ntime periods).\n\n\"Soft\" checkpoints mean that re-orgs can't cause a network partition.  Each\nsoft checkpoint is a mapping of {block_hash: utxo_hash}.\n\nA re-org of 1 year or more would be devastating so it is probably\nacademic.  Some people may object to centralized checkpointing and soft\ncheckpoints cover that objection.\n\nfull nodes with old software can no longer be fired up and sync with the\n> existing network\n> full nodes that went off line prior to the second fork cannot sync back\n> once they turn back on line again.\n>\n>\nThis is why having archive nodes (and a way to find them) is important.\n\nYou could have a weaker requirement that nodes shouldn't delete blocks\nunless they are at least 3 time periods (~3 years) old.\n\nThe software should have a setting which allows the user to specify maximum\ndisk space.  Disk space is cheap, so it is likely that a reasonable number\nof people will leave that set to infinite.\n\nThis automatically results in lots of archive nodes.  Another setting could\ndecide how many time periods to download.  2-3 seem reasonable as a default\n(or maybe infinite too).\n\n\n> Addressing security concerns:\n>\n> being able to write a new genesis block means that an evil core has the\n> power to steal/destroy/censor/whatever coins.\n>\n> this is possible only in theory, but not in practice. right now devs can\n> misbehave with every softfork, but the community tests and inspects every\n> new release.\n>\n\nSoft forks are inherently backward compatible.  Coins cannot be stolen\nusing a soft fork.  It has nothing to do with inspecting new releases.\n\nIt is possible for a majority of miners to re-write history, but that is\nseparate to a soft fork.\n\nA soft fork can lock coins away.  This effectively destroys the coins, but\ndoesn't steal them.  It could be part of a extortion scheme I guess, but if\na majority of miners did that, then I think Bitcoin has bigger problems.\n\n\n> the 2 forks will be tested and inspected as well so they are no more risky\n> than other softforks.\n>\n>\nFor it to be a soft fork, you need to maintain archive nodes.  That is the\nwhole point.  The old network and the new network rules agree that the new\nnetwork rules are valid (and that miners only mine blocks that are valid\nunder the new rules).  If IBD is impossible for old nodes, then that counts\nas a network split.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170913/c246eebe/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "2 softforks to cut the blockchain and IBD time",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tier Nolan",
                "michele terzi"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 7257
        }
    },
    {
        "title": "[bitcoin-dev] Minutia in CT for Bitcoin. Was: SF proposal: prohibit unspendable outputs with amount=0",
        "thread_messages": [
            {
                "author": "Gregory Maxwell",
                "date": "2017-09-13T09:39:28",
                "message_text_only": "On Wed, Sep 13, 2017 at 9:24 AM, Peter Todd via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> 2) Spending CT-shielded outputs to unshielded outputs\n>\n> Here one or more CT-shielded outputs will be spent. Since their value is zero,\n> we make up the difference by spending one or more outputs from the CT pool,\n> with the change - if any - assigned to a CT-pool output.\n\nCan we solve the problem that pool inputs are gratuitously non-reorg\nsafe, without creating something like a maturity limit for shielded to\nunshielded?\n\nSo far the best I have is this:  Support unshielded coins in shielded\nspace too. So the only time you transition out of the pool is paying\nto a legacy wallet.  If support were phased in (e.g. addresses that\nsay you can pay me in the pool after its enabled), and the pool only\nused long after wallets supported getting payments in it, then this\nwould be pretty rare and a maturity limit wouldn't be a big deal.\n\nCan better be done?"
            },
            {
                "author": "Peter Todd",
                "date": "2017-09-13T10:03:28",
                "message_text_only": "On Wed, Sep 13, 2017 at 09:39:28AM +0000, Gregory Maxwell wrote:\n> On Wed, Sep 13, 2017 at 9:24 AM, Peter Todd via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > 2) Spending CT-shielded outputs to unshielded outputs\n> >\n> > Here one or more CT-shielded outputs will be spent. Since their value is zero,\n> > we make up the difference by spending one or more outputs from the CT pool,\n> > with the change - if any - assigned to a CT-pool output.\n> \n> Can we solve the problem that pool inputs are gratuitously non-reorg\n> safe, without creating something like a maturity limit for shielded to\n> unshielded?\n\nSo to be clear, we have two versions of this problem:\n\n1) CT signatures do *not* sign which pool input they're using\n\nHere, obviously the inputs can be changed at will by miners. An implementation\ncould have the exact CT pool input be something miners add; the CT transactions\nbroadcast on the P2P network wouldn't actually need them.\n\n\n2) CT signatures *do* sign which pool input they're using\n\nWallets would pick the input at random. This is required if you want to have a\ntransaction spending both CT and legacy inputs. This reduces the reorg risk to\ndouble-spends. While double-spends are always a potential problem, the problem\nis somewhat worse here, as even regular wallets are spending inputs that anyone\ncan choose to spend.\n\n\n> So far the best I have is this:  Support unshielded coins in shielded\n> space too. So the only time you transition out of the pool is paying\n> to a legacy wallet.  If support were phased in (e.g. addresses that\n> say you can pay me in the pool after its enabled), and the pool only\n> used long after wallets supported getting payments in it, then this\n> would be pretty rare and a maturity limit wouldn't be a big deal.\n\nSo basically, you're essentially observing that in the event that everyone uses\nCT, this isn't actually a problem; you're allowing everyone to \"use\" CT, by\ntrying to allow even unshielded outputs to \"use\" it.\n\nWhich means by \"unshielded output\", what you *actuall* mean is creating a CT\ntransaction where the output - even though it's a zero-valued CT output - is\nconstructed such that the value is public information.\n\nOr do you mean trying to have non-CT outputs in the pool somehow? I don't think\nthat makes sense, because the whole point of the pool is that the outputs in it\nare anyone-can-spend, and thus any CT transaction may spend them; which CT\ntransaction spends them gives no information about the ownership of the coins.\nThis is incompatible with anything but anyone-can-spend outputs.\n\n> Can better be done?\n\nNote that the order in which outputs in the pool are spent can be\ndeterministic. For example, you could say that each transaction must spend the\noldest outputs in the pool (that sum to the value needed). You could probably\ncome up with a scheme where the outputs that will be spent in the future in the\nevent that the output is spent back to an unshielded output is fixed when the\noutput was created, for example, by picking a random index. While this wouldn't\nprevent all collisions, it'd may be possible to make reorgs relatively safe, by\nconstraining how miners could txids.\n\nSpecifically, you could imagine a scheme where if a given input set can only be\nsatisified by unspent pool outputs with index's >= i, then the miner would need\nto have the ability to mine a conflicting transaction that also happened to\nhave the same pool output set. Given a sufficiently large set of pool outputs,\nthis may be an impractical attack most of the time.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170913/ff9d3b6e/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Minutia in CT for Bitcoin. Was: SF proposal: prohibit unspendable outputs with amount=0",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Gregory Maxwell",
                "Peter Todd"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 4855
        }
    },
    {
        "title": "[bitcoin-dev] hypothetical: Could soft-forks be prevented?",
        "thread_messages": [
            {
                "author": "Dan Libby",
                "date": "2017-09-13T09:50:53",
                "message_text_only": "Hi, I am interested in the possibility of a cryptocurrency software\n(future bitcoin or a future altcoin) that strives to have immutable\nconsensus rules.\n\nThe goal of such a cryptocurrency would not be to have the latest and\ngreatest tech, but rather to be a long-term store of value and to offer\ninvestors great certainty and predictability... something that markets\ntend to like.  And of course, zero consensus rule changes also means\nless chance of new bugs and attack surface remains the same, which is\ngood for security.\n\nOf course, hard-forks are always possible.  But that is a clear split\nand something that people must opt into.  Each party has to make a\nchoice, and inertia is on the side of the status quo.  Whereas\nsoft-forks sort of drag people along with them, even those who oppose\nthe changes and never upgrade.  In my view, that is problematic,\nespecially for a coin with permanent consensus rule immutability as a\ngoal/ethic.\n\nAs I understand it, bitcoin soft-forks always rely on anyone-can-spend\ntransactions.  If those were removed, would it effectively prevent\nsoft-forks, or are there other possible mechanisms?  How important are\nany-one-can spend tx for other uses?\n\nMore generally, do you think it is possible to programmatically\navoid/ban soft-forks, and if so, how would you go about it?"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-09-15T04:01:47",
                "message_text_only": "Good morning Dan,\n\nMy understanding is that it is impossible for soft forks to be prevented.\n\n1.  Anyone-can-spend\n\nThere are a very large number of anyone-can-spend scripts, and it would be very impractical to ban them all.\n\nFor example, the below output script is anyone-can-spend\n\n <random number> OP_TRUE\n\nSo is the below:\n\n  OP_SIZE <random small number> OP_EQUAL\n\nOr:\n\n  OP_1ADD <random number> OP_EQUAL\n\nOr:\n\n  OP_BOOLAND\n\nOr:\n\n  OP_BOOLOR\n\nAnd so on.\n\nSo no, it is not practically possible to ban anyone-can-spend outputs, as there are too many potential scriptPubKey that anyone can spend.\n\nIt is even possible to have an output that requires a proof-of-work, like so:\n\n OP_HASH256 <difficulty target> OP_LESSTHAN\n\nAll the above outputs are disallowed from propagation by IsStandard, but a miner can put them validly in a block, and IsStandard is not consensus code and can be modified.\n\n2.  Soft fork = restrict\n\nIt is possible (although unlikely) for a majority of miners to run soft forking code which the rest of us are not privy to.\n\nFor example, for all we know, miners are already blacklisting spends on Satoshi's coins.  We would not be able to detect this at all, since no transaction that spends Satoshi's coins have been broadcast, ever.  It is thus indistinguishable from a world where Satoshi lost his private keys.  Of course, the world where Satoshi never spent his coins and miners are blacklisting Satoshi's coins, is more complex than the world where Satoshi never spent his coins, so it is more likely that miners are not blacklisting.\n\nBut the principle is there.  We may already be in a softfork whose rules we do not know, and it just so happens that all our transactions today do not violate those rules.  It is impossible for us to know this, but it is very unlikely.\n\nSoft forks apply further restrictions on Bitcoin.  Hard forks do not.  Thus, if everyone else is entering a soft fork and we are oblivious, we do not even know about it.  Whereas, if everyone else is entering a hard fork, we will immediately see (and reject) invalid transactions and blocks.\n\nThus the only way to prevent soft fork is to hard fork against the new soft fork, like Bcash did.\n\nRegards,\nZmnSCPxj\n\n-------- Original Message --------\nSubject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?\nLocal Time: September 13, 2017 5:50 PM\nUTC Time: September 13, 2017 9:50 AM\nFrom: bitcoin-dev at lists.linuxfoundation.org\nTo: Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>\n\nHi, I am interested in the possibility of a cryptocurrency software\n(future bitcoin or a future altcoin) that strives to have immutable\nconsensus rules.\n\nThe goal of such a cryptocurrency would not be to have the latest and\ngreatest tech, but rather to be a long-term store of value and to offer\ninvestors great certainty and predictability... something that markets\ntend to like. And of course, zero consensus rule changes also means\nless chance of new bugs and attack surface remains the same, which is\ngood for security.\n\nOf course, hard-forks are always possible. But that is a clear split\nand something that people must opt into. Each party has to make a\nchoice, and inertia is on the side of the status quo. Whereas\nsoft-forks sort of drag people along with them, even those who oppose\nthe changes and never upgrade. In my view, that is problematic,\nespecially for a coin with permanent consensus rule immutability as a\ngoal/ethic.\n\nAs I understand it, bitcoin soft-forks always rely on anyone-can-spend\ntransactions. If those were removed, would it effectively prevent\nsoft-forks, or are there other possible mechanisms? How important are\nany-one-can spend tx for other uses?\n\nMore generally, do you think it is possible to programmatically\navoid/ban soft-forks, and if so, how would you go about it?\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170915/e6f45267/attachment.html>"
            },
            {
                "author": "Adam Back",
                "date": "2017-09-15T09:14:13",
                "message_text_only": "True however in principle a soft-fork can also be soft-forked out. Eg say a\npublicly known soft-fork done by miners only that user node software did\nnot upgrade for first by opt-in adoption. If there was consensus against by\nusers and ecosystem a node/user flag day soft fork could block it's\neffects. Or if a soft fork was determined to have a major bug.\n\nHowever most types of soft fork are opt-in and so mostly that situation\nseems unlikely.  A censorship soft-fork is harder, that's a standard\nhard-fork to bypass with current fungibility mechanisms.\n\nAdam\n\nOn Sep 15, 2017 08:12, \"ZmnSCPxj via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Dan,\n>\n> My understanding is that it is impossible for soft forks to be prevented.\n>\n> 1.  Anyone-can-spend\n>\n> There are a very large number of anyone-can-spend scripts, and it would be\n> very impractical to ban them all.\n>\n> For example, the below output script is anyone-can-spend\n>\n>  <random number> OP_TRUE\n>\n> So is the below:\n>\n>   OP_SIZE <random small number> OP_EQUAL\n>\n> Or:\n>\n>   OP_1ADD <random number> OP_EQUAL\n>\n> Or:\n>\n>   OP_BOOLAND\n>\n> Or:\n>\n>   OP_BOOLOR\n>\n> And so on.\n>\n> So no, it is not practically possible to ban anyone-can-spend outputs, as\n> there are too many potential scriptPubKey that anyone can spend.\n>\n> It is even possible to have an output that requires a proof-of-work, like\n> so:\n>\n>  OP_HASH256 <difficulty target> OP_LESSTHAN\n>\n> All the above outputs are disallowed from propagation by IsStandard, but a\n> miner can put them validly in a block, and IsStandard is not consensus code\n> and can be modified.\n>\n> 2.  Soft fork = restrict\n>\n> It is possible (although unlikely) for a majority of miners to run soft\n> forking code which the rest of us are not privy to.\n>\n> For example, for all we know, miners are already blacklisting spends on\n> Satoshi's coins.  We would not be able to detect this at all, since no\n> transaction that spends Satoshi's coins have been broadcast, ever.  It is\n> thus indistinguishable from a world where Satoshi lost his private keys.\n> Of course, the world where Satoshi never spent his coins and miners are\n> blacklisting Satoshi's coins, is more complex than the world where Satoshi\n> never spent his coins, so it is more likely that miners are not\n> blacklisting.\n>\n> But the principle is there.  We may already be in a softfork whose rules\n> we do not know, and it just so happens that all our transactions today do\n> not violate those rules.  It is impossible for us to know this, but it is\n> very unlikely.\n>\n> Soft forks apply further restrictions on Bitcoin.  Hard forks do not.\n> Thus, if everyone else is entering a soft fork and we are oblivious, we do\n> not even know about it.  Whereas, if everyone else is entering a hard fork,\n> we will immediately see (and reject) invalid transactions and blocks.\n>\n> Thus the only way to prevent soft fork is to hard fork against the new\n> soft fork, like Bcash did.\n>\n> Regards,\n> ZmnSCPxj\n>\n> -------- Original Message --------\n> Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?\n> Local Time: September 13, 2017 5:50 PM\n> UTC Time: September 13, 2017 9:50 AM\n> From: bitcoin-dev at lists.linuxfoundation.org\n> To: Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>\n>\n> Hi, I am interested in the possibility of a cryptocurrency software\n> (future bitcoin or a future altcoin) that strives to have immutable\n> consensus rules.\n>\n> The goal of such a cryptocurrency would not be to have the latest and\n> greatest tech, but rather to be a long-term store of value and to offer\n> investors great certainty and predictability... something that markets\n> tend to like. And of course, zero consensus rule changes also means\n> less chance of new bugs and attack surface remains the same, which is\n> good for security.\n>\n> Of course, hard-forks are always possible. But that is a clear split\n> and something that people must opt into. Each party has to make a\n> choice, and inertia is on the side of the status quo. Whereas\n> soft-forks sort of drag people along with them, even those who oppose\n> the changes and never upgrade. In my view, that is problematic,\n> especially for a coin with permanent consensus rule immutability as a\n> goal/ethic.\n>\n> As I understand it, bitcoin soft-forks always rely on anyone-can-spend\n> transactions. If those were removed, would it effectively prevent\n> soft-forks, or are there other possible mechanisms? How important are\n> any-one-can spend tx for other uses?\n>\n> More generally, do you think it is possible to programmatically\n> avoid/ban soft-forks, and if so, how would you go about it?\n>\n>\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170915/6bfa793b/attachment.html>"
            },
            {
                "author": "Tier Nolan",
                "date": "2017-09-15T11:47:32",
                "message_text_only": "On Fri, Sep 15, 2017 at 10:14 AM, Adam Back via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> True however in principle a soft-fork can also be soft-forked out. Eg say\n> a publicly known soft-fork done by miners only that user node software did\n> not upgrade for first by opt-in adoption.\n>\n\nIt depends on what software that the general user-base is using (especially\nexchanges).  If a majority of miners have deployed a hidden soft fork, then\nthe soft fork will only last as long as they can maintain their majority.\n\nIf they drop below 50%, then the majority of miners will eventually make\nand then build on a block that is invalid according to their hidden soft\nfork rules.\n\nIf the userbase doesn't support a censorship soft fork, then it will only\nlast as long as a majority of miners support it.  Once the cartel loses its\nmajority, there is a strong incentive for members to disable their soft\nfork rule.  Any that don't will end up mining a lower POW, but valid, chain.\n\nUsers updating their nodes to enforce the soft fork is what makes the soft\nfork irreversible (without a hard fork).\n\n\n> A censorship soft-fork is harder, that's a standard hard-fork to bypass\n> with current fungibility mechanisms.\n>\n\nIt's only a hard fork to reverse if the community is enforcing the soft\nfork.  Forking off a minority of miners doesn't make it a hard fork.\n\n\n>\n> Adam\n>\n> On Sep 15, 2017 08:12, \"ZmnSCPxj via bitcoin-dev\" <bitcoin-dev at lists.\n> linuxfoundation.org> wrote:\n>\n>> Good morning Dan,\n>>\n>> My understanding is that it is impossible for soft forks to be prevented.\n>>\n>> 1.  Anyone-can-spend\n>>\n>> There are a very large number of anyone-can-spend scripts, and it would\n>> be very impractical to ban them all.\n>>\n>> For example, the below output script is anyone-can-spend\n>>\n>>  <random number> OP_TRUE\n>>\n>> So is the below:\n>>\n>>   OP_SIZE <random small number> OP_EQUAL\n>>\n>> Or:\n>>\n>>   OP_1ADD <random number> OP_EQUAL\n>>\n>> Or:\n>>\n>>   OP_BOOLAND\n>>\n>> Or:\n>>\n>>   OP_BOOLOR\n>>\n>> And so on.\n>>\n>> So no, it is not practically possible to ban anyone-can-spend outputs, as\n>> there are too many potential scriptPubKey that anyone can spend.\n>>\n>> It is even possible to have an output that requires a proof-of-work, like\n>> so:\n>>\n>>  OP_HASH256 <difficulty target> OP_LESSTHAN\n>>\n>> All the above outputs are disallowed from propagation by IsStandard, but\n>> a miner can put them validly in a block, and IsStandard is not consensus\n>> code and can be modified.\n>>\n>> 2.  Soft fork = restrict\n>>\n>> It is possible (although unlikely) for a majority of miners to run soft\n>> forking code which the rest of us are not privy to.\n>>\n>> For example, for all we know, miners are already blacklisting spends on\n>> Satoshi's coins.  We would not be able to detect this at all, since no\n>> transaction that spends Satoshi's coins have been broadcast, ever.  It is\n>> thus indistinguishable from a world where Satoshi lost his private keys.\n>> Of course, the world where Satoshi never spent his coins and miners are\n>> blacklisting Satoshi's coins, is more complex than the world where Satoshi\n>> never spent his coins, so it is more likely that miners are not\n>> blacklisting.\n>>\n>> But the principle is there.  We may already be in a softfork whose rules\n>> we do not know, and it just so happens that all our transactions today do\n>> not violate those rules.  It is impossible for us to know this, but it is\n>> very unlikely.\n>>\n>> Soft forks apply further restrictions on Bitcoin.  Hard forks do not.\n>> Thus, if everyone else is entering a soft fork and we are oblivious, we do\n>> not even know about it.  Whereas, if everyone else is entering a hard fork,\n>> we will immediately see (and reject) invalid transactions and blocks.\n>>\n>> Thus the only way to prevent soft fork is to hard fork against the new\n>> soft fork, like Bcash did.\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n>> -------- Original Message --------\n>> Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?\n>> Local Time: September 13, 2017 5:50 PM\n>> UTC Time: September 13, 2017 9:50 AM\n>> From: bitcoin-dev at lists.linuxfoundation.org\n>> To: Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>\n>>\n>> Hi, I am interested in the possibility of a cryptocurrency software\n>> (future bitcoin or a future altcoin) that strives to have immutable\n>> consensus rules.\n>>\n>> The goal of such a cryptocurrency would not be to have the latest and\n>> greatest tech, but rather to be a long-term store of value and to offer\n>> investors great certainty and predictability... something that markets\n>> tend to like. And of course, zero consensus rule changes also means\n>> less chance of new bugs and attack surface remains the same, which is\n>> good for security.\n>>\n>> Of course, hard-forks are always possible. But that is a clear split\n>> and something that people must opt into. Each party has to make a\n>> choice, and inertia is on the side of the status quo. Whereas\n>> soft-forks sort of drag people along with them, even those who oppose\n>> the changes and never upgrade. In my view, that is problematic,\n>> especially for a coin with permanent consensus rule immutability as a\n>> goal/ethic.\n>>\n>> As I understand it, bitcoin soft-forks always rely on anyone-can-spend\n>> transactions. If those were removed, would it effectively prevent\n>> soft-forks, or are there other possible mechanisms? How important are\n>> any-one-can spend tx for other uses?\n>>\n>> More generally, do you think it is possible to programmatically\n>> avoid/ban soft-forks, and if so, how would you go about it?\n>>\n>>\n>>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170915/05615e0f/attachment-0001.html>"
            },
            {
                "author": "Dan Libby",
                "date": "2017-09-15T20:01:48",
                "message_text_only": "On 09/15/2017 02:14 AM, Adam Back wrote:\n> However most types of soft fork are opt-in...\n\nmy concern is that the community can be manipulated via political means.\n marketing, social media, payoffs, fud, etc, etc, etc.  And essentially\ndegrades to tyranny of the majority.\n\n\nSo if there is any way to make opt-in forks impractical/infeasible for\npurpose of network wide consensus rule change, I'd love to hear it."
            },
            {
                "author": "Dan Libby",
                "date": "2017-09-15T19:55:56",
                "message_text_only": "Ok, this is good stuff.  thanks for the thoughtful reply.\n\nRegarding anyone-can-spend:\n\nall of the examples you gave do not satisfy isStandard.  So if our\nhypothetical cryptocurrency were to restrict all transactions to\nisStandard at the consensus layer, would that not effectively prevent\nanyone-can-spend?\n\nOr more generally and with our thinking caps on, what would be the best\nway to prevent anyone-can-spend, if that is our goal?\n\n\nRegarding soft-fork = restrict:\n\nYour example of miners running secret soft-fork code that blacklists\nsatoshi's utxo's is intriguing and somewhat troubling.\n\nI think the main takeaways are that:\n  1) there are other ways to soft-fork besides anyone-can-spend.\n  2) it is impossible to prevent hidden soft-forks.\n\nIs that accurate?\n\nStill, I would put forth the following question:  If anyone-can-spend tx\nwere no longer allowed according to consensus rules (assuming that is\npossible/practical), then could the network still be practically\n\"upgraded\" with new features (eg opcodes) via soft-fork, and if so, what\nwould be the mechanism for backwards compatibility in this scenario?\n\n\nor from another angle:  even if it is impossible to prevent all\nsoft-forks, can you see any way at all to make it logistically\ninfeasible to use soft-forks as a network-wide consensus change mechanism?\n\nand another thought:  as I understand it, bitcoin is presently able to\nadd new opcodes via soft-fork because Satoshi added 10 unused opcodes\nvia hardfork. What will happen when these run out?  Can new opcodes\nstill be added without a hard-fork?\n\n\nnote: I ask these questions with the goal/vision of creating an\nimmutable altcoin or sidechain, not necessarily restricting bitcoin's path.\n\n\n\n\n\nOn 09/14/2017 09:01 PM, ZmnSCPxj wrote:\n> Good morning Dan,\n> \n> My understanding is that it is impossible for soft forks to be prevented.\n> \n> 1.  Anyone-can-spend\n> \n> There are a very large number of anyone-can-spend scripts, and it would\n> be very impractical to ban them all.\n> \n> For example, the below output script is anyone-can-spend\n> \n>  <random number> OP_TRUE\n> \n> So is the below:\n> \n>   OP_SIZE <random small number> OP_EQUAL\n> \n> Or:\n> \n>   OP_1ADD <random number> OP_EQUAL\n> \n> Or:\n> \n>   OP_BOOLAND\n> \n> Or:\n> \n>   OP_BOOLOR\n> \n> And so on.\n> \n> So no, it is not practically possible to ban anyone-can-spend outputs,\n> as there are too many potential scriptPubKey that anyone can spend.\n> \n> It is even possible to have an output that requires a proof-of-work,\n> like so:\n> \n>  OP_HASH256 <difficulty target> OP_LESSTHAN\n> \n> All the above outputs are disallowed from propagation by IsStandard, but\n> a miner can put them validly in a block, and IsStandard is not consensus\n> code and can be modified.\n> \n> 2.  Soft fork = restrict\n> \n> It is possible (although unlikely) for a majority of miners to run soft\n> forking code which the rest of us are not privy to.\n> \n> For example, for all we know, miners are already blacklisting spends on\n> Satoshi's coins.  We would not be able to detect this at all, since no\n> transaction that spends Satoshi's coins have been broadcast, ever.  It\n> is thus indistinguishable from a world where Satoshi lost his private\n> keys.  Of course, the world where Satoshi never spent his coins and\n> miners are blacklisting Satoshi's coins, is more complex than the world\n> where Satoshi never spent his coins, so it is more likely that miners\n> are not blacklisting.\n> \n> But the principle is there.  We may already be in a softfork whose rules\n> we do not know, and it just so happens that all our transactions today\n> do not violate those rules.  It is impossible for us to know this, but\n> it is very unlikely.\n> \n> Soft forks apply further restrictions on Bitcoin.  Hard forks do not. \n> Thus, if everyone else is entering a soft fork and we are oblivious, we\n> do not even know about it.  Whereas, if everyone else is entering a hard\n> fork, we will immediately see (and reject) invalid transactions and blocks.\n> \n> Thus the only way to prevent soft fork is to hard fork against the new\n> soft fork, like Bcash did.\n> \n> Regards,\n> ZmnSCPxj\n> \n> -------- Original Message --------\n> Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?\n> Local Time: September 13, 2017 5:50 PM\n> UTC Time: September 13, 2017 9:50 AM\n> From: bitcoin-dev at lists.linuxfoundation.org\n> To: Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>\n> \n> Hi, I am interested in the possibility of a cryptocurrency software\n> (future bitcoin or a future altcoin) that strives to have immutable\n> consensus rules.\n> \n> The goal of such a cryptocurrency would not be to have the latest and\n> greatest tech, but rather to be a long-term store of value and to offer\n> investors great certainty and predictability... something that markets\n> tend to like. And of course, zero consensus rule changes also means\n> less chance of new bugs and attack surface remains the same, which is\n> good for security.\n> \n> Of course, hard-forks are always possible. But that is a clear split\n> and something that people must opt into. Each party has to make a\n> choice, and inertia is on the side of the status quo. Whereas\n> soft-forks sort of drag people along with them, even those who oppose\n> the changes and never upgrade. In my view, that is problematic,\n> especially for a coin with permanent consensus rule immutability as a\n> goal/ethic.\n> \n> As I understand it, bitcoin soft-forks always rely on anyone-can-spend\n> transactions. If those were removed, would it effectively prevent\n> soft-forks, or are there other possible mechanisms? How important are\n> any-one-can spend tx for other uses?\n> \n> More generally, do you think it is possible to programmatically\n> avoid/ban soft-forks, and if so, how would you go about it?\n> \n> \n> \n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Simone Bronzini",
                "date": "2017-09-15T20:40:12",
                "message_text_only": "Since a soft-fork is a restriction of the consensus rules, I think the\nonly way to have an un-soft-forkable cryptocurrency is creating a\ncryptocurrency where no transaction is valid.\n\nImagine I build a very minimal cryptocurrency where in the transaction\noutput you only indicate the public key to send your coins to and the\namount. One can still soft-fork it by deciding that, from now on, only\neven amounts are valid or only public keys that are a multiple of 10 are\nvalid.\n\n\nOn 15/09/17 21:55, Dan Libby via bitcoin-dev wrote:\n> Ok, this is good stuff.  thanks for the thoughtful reply.\n>\n> Regarding anyone-can-spend:\n>\n> all of the examples you gave do not satisfy isStandard.  So if our\n> hypothetical cryptocurrency were to restrict all transactions to\n> isStandard at the consensus layer, would that not effectively prevent\n> anyone-can-spend?\n>\n> Or more generally and with our thinking caps on, what would be the best\n> way to prevent anyone-can-spend, if that is our goal?\n>\n>\n> Regarding soft-fork = restrict:\n>\n> Your example of miners running secret soft-fork code that blacklists\n> satoshi's utxo's is intriguing and somewhat troubling.\n>\n> I think the main takeaways are that:\n>   1) there are other ways to soft-fork besides anyone-can-spend.\n>   2) it is impossible to prevent hidden soft-forks.\n>\n> Is that accurate?\n>\n> Still, I would put forth the following question:  If anyone-can-spend tx\n> were no longer allowed according to consensus rules (assuming that is\n> possible/practical), then could the network still be practically\n> \"upgraded\" with new features (eg opcodes) via soft-fork, and if so, what\n> would be the mechanism for backwards compatibility in this scenario?\n>\n>\n> or from another angle:  even if it is impossible to prevent all\n> soft-forks, can you see any way at all to make it logistically\n> infeasible to use soft-forks as a network-wide consensus change mechanism?\n>\n> and another thought:  as I understand it, bitcoin is presently able to\n> add new opcodes via soft-fork because Satoshi added 10 unused opcodes\n> via hardfork. What will happen when these run out?  Can new opcodes\n> still be added without a hard-fork?\n>\n>\n> note: I ask these questions with the goal/vision of creating an\n> immutable altcoin or sidechain, not necessarily restricting bitcoin's path.\n>\n>\n>\n>\n>\n> On 09/14/2017 09:01 PM, ZmnSCPxj wrote:\n>> Good morning Dan,\n>>\n>> My understanding is that it is impossible for soft forks to be prevented.\n>>\n>> 1.  Anyone-can-spend\n>>\n>> There are a very large number of anyone-can-spend scripts, and it would\n>> be very impractical to ban them all.\n>>\n>> For example, the below output script is anyone-can-spend\n>>\n>>  <random number> OP_TRUE\n>>\n>> So is the below:\n>>\n>>   OP_SIZE <random small number> OP_EQUAL\n>>\n>> Or:\n>>\n>>   OP_1ADD <random number> OP_EQUAL\n>>\n>> Or:\n>>\n>>   OP_BOOLAND\n>>\n>> Or:\n>>\n>>   OP_BOOLOR\n>>\n>> And so on.\n>>\n>> So no, it is not practically possible to ban anyone-can-spend outputs,\n>> as there are too many potential scriptPubKey that anyone can spend.\n>>\n>> It is even possible to have an output that requires a proof-of-work,\n>> like so:\n>>\n>>  OP_HASH256 <difficulty target> OP_LESSTHAN\n>>\n>> All the above outputs are disallowed from propagation by IsStandard, but\n>> a miner can put them validly in a block, and IsStandard is not consensus\n>> code and can be modified.\n>>\n>> 2.  Soft fork = restrict\n>>\n>> It is possible (although unlikely) for a majority of miners to run soft\n>> forking code which the rest of us are not privy to.\n>>\n>> For example, for all we know, miners are already blacklisting spends on\n>> Satoshi's coins.  We would not be able to detect this at all, since no\n>> transaction that spends Satoshi's coins have been broadcast, ever.  It\n>> is thus indistinguishable from a world where Satoshi lost his private\n>> keys.  Of course, the world where Satoshi never spent his coins and\n>> miners are blacklisting Satoshi's coins, is more complex than the world\n>> where Satoshi never spent his coins, so it is more likely that miners\n>> are not blacklisting.\n>>\n>> But the principle is there.  We may already be in a softfork whose rules\n>> we do not know, and it just so happens that all our transactions today\n>> do not violate those rules.  It is impossible for us to know this, but\n>> it is very unlikely.\n>>\n>> Soft forks apply further restrictions on Bitcoin.  Hard forks do not. \n>> Thus, if everyone else is entering a soft fork and we are oblivious, we\n>> do not even know about it.  Whereas, if everyone else is entering a hard\n>> fork, we will immediately see (and reject) invalid transactions and blocks.\n>>\n>> Thus the only way to prevent soft fork is to hard fork against the new\n>> soft fork, like Bcash did.\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n>> -------- Original Message --------\n>> Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?\n>> Local Time: September 13, 2017 5:50 PM\n>> UTC Time: September 13, 2017 9:50 AM\n>> From: bitcoin-dev at lists.linuxfoundation.org\n>> To: Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>\n>>\n>> Hi, I am interested in the possibility of a cryptocurrency software\n>> (future bitcoin or a future altcoin) that strives to have immutable\n>> consensus rules.\n>>\n>> The goal of such a cryptocurrency would not be to have the latest and\n>> greatest tech, but rather to be a long-term store of value and to offer\n>> investors great certainty and predictability... something that markets\n>> tend to like. And of course, zero consensus rule changes also means\n>> less chance of new bugs and attack surface remains the same, which is\n>> good for security.\n>>\n>> Of course, hard-forks are always possible. But that is a clear split\n>> and something that people must opt into. Each party has to make a\n>> choice, and inertia is on the side of the status quo. Whereas\n>> soft-forks sort of drag people along with them, even those who oppose\n>> the changes and never upgrade. In my view, that is problematic,\n>> especially for a coin with permanent consensus rule immutability as a\n>> goal/ethic.\n>>\n>> As I understand it, bitcoin soft-forks always rely on anyone-can-spend\n>> transactions. If those were removed, would it effectively prevent\n>> soft-forks, or are there other possible mechanisms? How important are\n>> any-one-can spend tx for other uses?\n>>\n>> More generally, do you think it is possible to programmatically\n>> avoid/ban soft-forks, and if so, how would you go about it?\n>>\n>>\n>>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0xB2E60C73.asc\nType: application/pgp-keys\nSize: 15541 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170915/56ee44a1/attachment-0001.bin>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 898 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170915/56ee44a1/attachment-0001.sig>"
            },
            {
                "author": "Dan Libby",
                "date": "2017-09-15T21:48:57",
                "message_text_only": "On 09/15/2017 01:40 PM, Simone Bronzini wrote:\n> Since a soft-fork is a restriction of the consensus rules, I think the\n> only way to have an un-soft-forkable cryptocurrency is creating a\n> cryptocurrency where no transaction is valid.\n> \n> Imagine I build a very minimal cryptocurrency where in the transaction\n> output you only indicate the public key to send your coins to and the\n> amount. One can still soft-fork it by deciding that, from now on, only\n> even amounts are valid or only public keys that are a multiple of 10 are\n> valid.\n\nsure, but in this scenario how would one meaningfully \"upgrade\" the\nfunctionality, eg add a new opcode?  We couldn't, right?  so....\nsuccess!   Preventing new functionality is the primary goal of this\nthought experiment.  I believe that common sense and market incentives\nwould prevent arbitrary tightening of the rules for no good reason..."
            },
            {
                "author": "Andrew Poelstra",
                "date": "2017-09-16T01:42:53",
                "message_text_only": "On Fri, Sep 15, 2017 at 10:40:12PM +0200, Simone Bronzini via bitcoin-dev wrote:\n> Since a soft-fork is a restriction of the consensus rules, I think the\n> only way to have an un-soft-forkable cryptocurrency is creating a\n> cryptocurrency where no transaction is valid.\n> \n\nEven this can be soft-forked to add an extension block that contains transactions :)\n\nUltimately I think the best you can do in this direction is to design for\nmaximal fungibility and/or transaction structures that minimize interaction\nwith the blockchain. This minimizes the surface for transaction censorship,\nwhich is somewhat in the spirit of your goal.\n\n-- \nAndrew Poelstra\nMathematics Department, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\n\"A goose alone, I suppose, can know the loneliness of geese\n who can never find their peace,\n whether north or south or west or east\"\n       --Joanna Newsom\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170916/3fa2bec8/attachment.sig>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-09-16T03:38:23",
                "message_text_only": "Good Morning Dan,\n\nNo.\n\nLet us suppose that IsStandard is applied to outputs, but we support P2SH. Then we could encode those scripts in P2SH. The softfork could require the script preimageto be put elsewhere, such as an OP_RETURN in the same tx, to determine the script that is anyone can spend.\n\nWe could ban P2SH or restrict P2SH to be IsStandard also, but you are now unable to support HTLC (no atomic swap) or LN, unless you specifically add those scripts to IsStandard. And if a better layer 2 comes along or LN is updated to use better scripts, you have to hardfork those in.\n\nEven then, you can still be softforked. Remember that if we pay to a P2PKH, then publish the private key, every output paying to that address is now practically anyone can spend. Then a softfork can implement desired rules in an extensiom block, where money in UTXOs paying to the special publicized \"private\" key are controlled, post softfork, by data in a block that is not published to pre softfork nodes, like witness data is treated in SegWit.\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n> -------- Original Message --------\n> Subject: Re: [bitcoin-dev] hypothetical: Could soft-forks be prevented?\n> Local Time: September 16, 2017 3:55 AM\n> UTC Time: September 15, 2017 7:55 PM\n> From: dan at osc.co.cr\n> To: ZmnSCPxj <ZmnSCPxj at protonmail.com>\n> Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>\n>\n> Ok, this is good stuff. thanks for the thoughtful reply.\n>\n> Regarding anyone-can-spend:\n>\n> all of the examples you gave do not satisfy isStandard. So if our\n> hypothetical cryptocurrency were to restrict all transactions to\n> isStandard at the consensus layer, would that not effectively prevent\n> anyone-can-spend?\n>\n> Or more generally and with our thinking caps on, what would be the best\n> way to prevent anyone-can-spend, if that is our goal?\n>\n> Regarding soft-fork = restrict:\n>\n> Your example of miners running secret soft-fork code that blacklists\n> satoshi\"s utxo\"s is intriguing and somewhat troubling.\n>\n> I think the main takeaways are that:\n> 1) there are other ways to soft-fork besides anyone-can-spend.\n> 2) it is impossible to prevent hidden soft-forks.\n>\n> Is that accurate?\n>\n> Still, I would put forth the following question: If anyone-can-spend tx\n> were no longer allowed according to consensus rules (assuming that is\n> possible/practical), then could the network still be practically\n> \"upgraded\" with new features (eg opcodes) via soft-fork, and if so, what\n> would be the mechanism for backwards compatibility in this scenario?\n>\n> or from another angle: even if it is impossible to prevent all\n> soft-forks, can you see any way at all to make it logistically\n> infeasible to use soft-forks as a network-wide consensus change mechanism?\n>\n> and another thought: as I understand it, bitcoin is presently able to\n> add new opcodes via soft-fork because Satoshi added 10 unused opcodes\n> via hardfork. What will happen when these run out? Can new opcodes\n> still be added without a hard-fork?\n>\n> note: I ask these questions with the goal/vision of creating an\n> immutable altcoin or sidechain, not necessarily restricting bitcoin\"s path.\n>\n> On 09/14/2017 09:01 PM, ZmnSCPxj wrote:\n>> Good morning Dan,\n>>\n>> My understanding is that it is impossible for soft forks to be prevented.\n>>\n>> 1. Anyone-can-spend\n>>\n>> There are a very large number of anyone-can-spend scripts, and it would\n>> be very impractical to ban them all.\n>>\n>> For example, the below output script is anyone-can-spend\n>>\n>> <random number> OP_TRUE\n>>\n>> So is the below:\n>>\n>> OP_SIZE <random small number> OP_EQUAL\n>>\n>> Or:\n>>\n>> OP_1ADD <random number> OP_EQUAL\n>>\n>> Or:\n>>\n>> OP_BOOLAND\n>>\n>> Or:\n>>\n>> OP_BOOLOR\n>>\n>> And so on.\n>>\n>> So no, it is not practically possible to ban anyone-can-spend outputs,\n>> as there are too many potential scriptPubKey that anyone can spend.\n>>\n>> It is even possible to have an output that requires a proof-of-work,\n>> like so:\n>>\n>> OP_HASH256 <difficulty target> OP_LESSTHAN\n>>\n>> All the above outputs are disallowed from propagation by IsStandard, but\n>> a miner can put them validly in a block, and IsStandard is not consensus\n>> code and can be modified.\n>>\n>> 2. Soft fork = restrict\n>>\n>> It is possible (although unlikely) for a majority of miners to run soft\n>> forking code which the rest of us are not privy to.\n>>\n>> For example, for all we know, miners are already blacklisting spends on\n>> Satoshi\"s coins. We would not be able to detect this at all, since no\n>> transaction that spends Satoshi\"s coins have been broadcast, ever. It\n>> is thus indistinguishable from a world where Satoshi lost his private\n>> keys. Of course, the world where Satoshi never spent his coins and\n>> miners are blacklisting Satoshi\"s coins, is more complex than the world\n>> where Satoshi never spent his coins, so it is more likely that miners\n>> are not blacklisting.\n>>\n>> But the principle is there. We may already be in a softfork whose rules\n>> we do not know, and it just so happens that all our transactions today\n>> do not violate those rules. It is impossible for us to know this, but\n>> it is very unlikely.\n>>\n>> Soft forks apply further restrictions on Bitcoin. Hard forks do not.\n>> Thus, if everyone else is entering a soft fork and we are oblivious, we\n>> do not even know about it. Whereas, if everyone else is entering a hard\n>> fork, we will immediately see (and reject) invalid transactions and blocks.\n>>\n>> Thus the only way to prevent soft fork is to hard fork against the new\n>> soft fork, like Bcash did.\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n>> -------- Original Message --------\n>> Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?\n>> Local Time: September 13, 2017 5:50 PM\n>> UTC Time: September 13, 2017 9:50 AM\n>> From: bitcoin-dev at lists.linuxfoundation.org\n>> To: Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>\n>>\n>> Hi, I am interested in the possibility of a cryptocurrency software\n>> (future bitcoin or a future altcoin) that strives to have immutable\n>> consensus rules.\n>>\n>> The goal of such a cryptocurrency would not be to have the latest and\n>> greatest tech, but rather to be a long-term store of value and to offer\n>> investors great certainty and predictability... something that markets\n>> tend to like. And of course, zero consensus rule changes also means\n>> less chance of new bugs and attack surface remains the same, which is\n>> good for security.\n>>\n>> Of course, hard-forks are always possible. But that is a clear split\n>> and something that people must opt into. Each party has to make a\n>> choice, and inertia is on the side of the status quo. Whereas\n>> soft-forks sort of drag people along with them, even those who oppose\n>> the changes and never upgrade. In my view, that is problematic,\n>> especially for a coin with permanent consensus rule immutability as a\n>> goal/ethic.\n>>\n>> As I understand it, bitcoin soft-forks always rely on anyone-can-spend\n>> transactions. If those were removed, would it effectively prevent\n>> soft-forks, or are there other possible mechanisms? How important are\n>> any-one-can spend tx for other uses?\n>>\n>> More generally, do you think it is possible to programmatically\n>> avoid/ban soft-forks, and if so, how would you go about it?\n>>\n>>\n>>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170915/cc89dcfa/attachment-0001.html>"
            },
            {
                "author": "Dan Libby",
                "date": "2017-09-15T20:15:36",
                "message_text_only": "Thanks for this link.  From my reading though, it seems that only\nsoft-forks that attempt to freeze funds are problematic on ethereum.\n\n>From the article:\n> The soft fork creates a new and fundamentally different class of \n> transactions in contrast with those that currently exist within the \n> protocol. Currently, transactions either complete successfully and\n> cause a state transition, or run into an exception, in which case\n> state is reverted but the maximum possible gas is still charged. With\n> the soft fork, transactions which interact with a DAO will not fit\n> within these two classes: they will fail execution but no gas will be\n> charged. This must inevitably be the case in any soft fork that aims\n> to freeze the stolen funds;\n\nSo in the general case ethereum can still soft-fork I think...\n\n\nOn 09/15/2017 04:19 AM, Andrew Quentson wrote:\n> From my understanding, the blockchain can be designed in such a way as\n> to make soft-forks be impossible or at least impractical due to attack\n> vectors.\n> \n> http://hackingdistributed.com/2016/06/28/ethereum-soft-fork-dos-vector/\n> \n> Ethereum, for example, can't soft-fork. They have to always hardfork. \n> \n> On 13 September 2017 at 10:50, Dan Libby via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> \n>     Hi, I am interested in the possibility of a cryptocurrency software\n>     (future bitcoin or a future altcoin) that strives to have immutable\n>     consensus rules.\n> \n>     The goal of such a cryptocurrency would not be to have the latest and\n>     greatest tech, but rather to be a long-term store of value and to offer\n>     investors great certainty and predictability... something that markets\n>     tend to like.  And of course, zero consensus rule changes also means\n>     less chance of new bugs and attack surface remains the same, which is\n>     good for security.\n> \n>     Of course, hard-forks are always possible.  But that is a clear split\n>     and something that people must opt into.  Each party has to make a\n>     choice, and inertia is on the side of the status quo.  Whereas\n>     soft-forks sort of drag people along with them, even those who oppose\n>     the changes and never upgrade.  In my view, that is problematic,\n>     especially for a coin with permanent consensus rule immutability as a\n>     goal/ethic.\n> \n>     As I understand it, bitcoin soft-forks always rely on anyone-can-spend\n>     transactions.  If those were removed, would it effectively prevent\n>     soft-forks, or are there other possible mechanisms?  How important are\n>     any-one-can spend tx for other uses?\n> \n>     More generally, do you think it is possible to programmatically\n>     avoid/ban soft-forks, and if so, how would you go about it?\n> \n> \n> \n> \n> \n>     _______________________________________________\n>     bitcoin-dev mailing list\n>     bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>\n> \n> \n\n\n-- \nDan Libby\n\nOpen Source Consulting S.A.\nSanta Ana, Costa Rica\nhttp://osc.co.cr\nphone: 011 506 2204 7018\nFax: 011 506 2223 7359"
            },
            {
                "author": "Daniel Wilczynski",
                "date": "2017-09-18T06:40:18",
                "message_text_only": "Hi Dan.\n\nWhat might be better aim is to have built in wipeout protection? In\nsoftfork scenario this would protect a majority threatening a minority\nwith a wipeout if they do not opt in to some soft-fork consensus\nchange.\n\n\nThis could be partly done done by having automoated consensus critical\ncheckpoints, for example at 100 blocks deep. Maybe there are better\nways?\n\n\nThis would in effect turn softforks into hardforks.\n\n\n\n\nRegards,\n\n\nDaniel Wilczynski"
            }
        ],
        "thread_summary": {
            "title": "hypothetical: Could soft-forks be prevented?",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Dan Libby",
                "Adam Back",
                "ZmnSCPxj",
                "Tier Nolan",
                "Andrew Poelstra",
                "Simone Bronzini",
                "Daniel Wilczynski"
            ],
            "messages_count": 12,
            "total_messages_chars_count": 44472
        }
    },
    {
        "title": "[bitcoin-dev] SigOps limit.",
        "thread_messages": [
            {
                "author": "Russell O'Connor",
                "date": "2017-09-13T13:24:14",
                "message_text_only": "On Tue, Sep 12, 2017 at 3:57 PM, Mark Friedenbach via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> 4MB of secp256k1 signatures takes 10s to validate on my 5 year old\n> laptop (125,000 signatures, ignoring public keys and other things that\n> would consume space). That's much less than bad blocks that can be\n> constructed using other vulnerabilities.\n\n\nIf there were no sigops limits, I believe the worst case block could have\ncloser to 1,000,000 CHECKSIG operations.  Signature checks are cached so\nwhile repeating the sequence \"2DUP CHECKSIGVERIFY\" does create a lot of\nchecksig operations, the cached values prevent a lot of work being done.\n\nTo defeat the cache one can repeat the sequence \"2DUP CHECKSIG DROP\nCODESEPARATOR\", which will create unique signature validation requests\nevery 4 bytes.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170913/dee1f60d/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "SigOps limit.",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Russell O'Connor"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1005
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Core 0.15.0 released",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2017-09-14T13:20:35",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nBitcoin Core version *0.15.0* is now available from:\n\n  <https://bitcoin.org/bin/bitcoin-core-0.15.0/>\n\nand\n\n  <https://bitcoincore.org/bin/bitcoin-core-0.15.0/>\n\nOr through bittorrent:\n\n    magnet:?xt=urn:btih:e17a5823dd84fe5100386c69e91bc0671e4b4ed2&dn=bitcoin-core-0.15.0&tr=udp%3A%2F%2Ftracker.skyts.net%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.safe.moe%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.piratepublic.com%3A1337%2Fannounce&tr=udp%3A%2F%2Ftracker.pirateparty.gr%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969%2Fannounce\n\nThis is a new major version release, including new features, various bugfixes\nand performance improvements, as well as updated translations.\n\nPlease report bugs using the issue tracker at GitHub:\n\n  <https://github.com/bitcoin/bitcoin/issues>\n\nTo receive security and update notifications, please subscribe to:\n\n  <https://bitcoincore.org/en/list/announcements/join/>\n\nHow to Upgrade\n==============\n\nIf you are running an older version, shut it down. Wait until it has completely\nshut down (which might take a few minutes for older versions), then run the \ninstaller (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)\nor `bitcoind`/`bitcoin-qt` (on Linux).\n\nThe first time you run version 0.15.0, your chainstate database will be converted to a\nnew format, which will take anywhere from a few minutes to half an hour,\ndepending on the speed of your machine.\n\nThe file format of `fee_estimates.dat` changed in version 0.15.0. Hence, a\ndowngrade from version 0.15.0 or upgrade to version 0.15.0 will cause all fee\nestimates to be discarded.\n\nNote that the block database format also changed in version 0.8.0 and there is no\nautomatic upgrade code from before version 0.8 to version 0.15.0. Upgrading\ndirectly from 0.7.x and earlier without redownloading the blockchain is not supported.\nHowever, as usual, old wallet versions are still supported.\n\nDowngrading warning\n- -------------------\n\nThe chainstate database for this release is not compatible with previous\nreleases, so if you run 0.15 and then decide to switch back to any\nolder version, you will need to run the old release with the `-reindex-chainstate`\noption to rebuild the chainstate data structures in the old format.\n\nIf your node has pruning enabled, this will entail re-downloading and\nprocessing the entire blockchain.\n\nCompatibility\n==============\n\nBitcoin Core is extensively tested on multiple operating systems using\nthe Linux kernel, macOS 10.8+, and Windows Vista and later. Windows XP is not supported.\n\nBitcoin Core should also work on most other Unix-like systems but is not\nfrequently tested on them.\n\nNotes for 0.15.0\n================\n\nCurrent SegWit support\n- ----------------------\n\nVersion 0.15.0 supports adding a segregated witness address via the `addwitnessaddress` RPC, but\nplease note that this is a testing/expert RPC, which does not guarantee recovery from backup. Only use\nthis RPC if you know what you are doing. More complete wallet support for segregated witness is coming\nin a next version.\n\nRescanning with encrypted wallets\n- ---------------------------------\n\nAs in previous versions, when using an encrypted HD wallet, the keypool cannot be topped up without unlocking\nthe wallet. This means that currently, in order to recover from a backup of an encrypted HD wallet, the user\nmust unlock the wallet with a really long timeout and manually trigger a rescan, otherwise they risk missing\nsome keys when auto-topup cannot run. Unfortunately there is no `rescan` RPC in this version, that will be\nincluded in a future version, so for now a rescan can be triggered using one of the `import*` commands, using\na dummy address generated by another (trusted) wallet.\n\nNotable changes\n===============\n\nPerformance Improvements\n- ------------------------\n\nVersion 0.15 contains a number of significant performance improvements, which make\nInitial Block Download, startup, transaction and block validation much faster:\n\n- - The chainstate database (which is used for tracking UTXOs) has been changed\n  from a per-transaction model to a per-output model (See [PR 10195](https://github.com/bitcoin/bitcoin/pull/10195)). Advantages of this model\n  are that it:\n    - avoids the CPU overhead of deserializing and serializing the unused outputs;\n    - has more predictable memory usage;\n    - uses simpler code;\n    - is adaptable to various future cache flushing strategies.\n\n  As a result, validating the blockchain during Initial Block Download (IBD) and reindex\n  is ~30-40% faster, uses 10-20% less memory, and flushes to disk far less frequently.\n  The only downside is that the on-disk database is 15% larger. During the conversion from the previous format\n  a few extra gigabytes may be used.\n- - Earlier versions experienced a spike in memory usage while flushing UTXO updates to disk.\n  As a result, only half of the available memory was actually used as cache, and the other half was\n  reserved to accommodate flushing. This is no longer the case (See [PR 10148](https://github.com/bitcoin/bitcoin/pull/10148)), and the entirety of\n  the available cache (see `-dbcache`) is now actually used as cache. This reduces the flushing\n  frequency by a factor 2 or more.\n- - In previous versions, signature validation for transactions has been cached when the\n  transaction is accepted to the mempool. Version 0.15 extends this to cache the entire script\n  validity (See [PR 10192](https://github.com/bitcoin/bitcoin/pull/10192)). This means that if a transaction in a block has already been accepted to the\n  mempool, the scriptSig does not need to be re-evaluated. Empirical tests show that\n  this results in new block validation being 40-50% faster.\n- - LevelDB has been upgraded to version 1.20 (See [PR 10544](https://github.com/bitcoin/bitcoin/pull/10544)). This version contains hardware acceleration for CRC\n  on architectures supporting SSE 4.2. As a result, synchronization and block validation are now faster.\n- - SHA256 hashing has been optimized for architectures supporting SSE 4 (See [PR 10821](https://github.com/bitcoin/bitcoin/pull/10821)). SHA256 is around\n  50% faster on supported hardware, which results in around 5% faster IBD and block\n  validation. In version 0.15, SHA256 hardware optimization is disabled in release builds by\n  default, but can be enabled by using `--enable-experimental-asm` when building.\n- - Refill of the keypool no longer flushes the wallet between each key which resulted in a ~20x speedup in creating a new wallet. Part of this speedup was used to increase the default keypool to 1000 keys to make recovery more robust. (See [PR 10831](https://github.com/bitcoin/bitcoin/pull/10831)).\n\nFee Estimation Improvements\n- ---------------------------\n\nFee estimation has been significantly improved in version 0.15, with more accurate fee estimates used by the wallet and a wider range of options for advanced users of the `estimatesmartfee` and `estimaterawfee` RPCs (See [PR 10199](https://github.com/bitcoin/bitcoin/pull/10199)).\n\n### Changes to internal logic and wallet behavior\n\n- - Internally, estimates are now tracked on 3 different time horizons. This allows for longer targets and means estimates adjust more quickly to changes in conditions.\n- - Estimates can now be *conservative* or *economical*. *Conservative* estimates use longer time horizons to produce an estimate which is less susceptible to rapid changes in fee conditions. *Economical* estimates use shorter time horizons and will be more affected by short-term changes in fee conditions. Economical estimates may be considerably lower during periods of low transaction activity (for example over weekends), but may result in transactions being unconfirmed if prevailing fees increase rapidly.\n- - By default, the wallet will use conservative fee estimates to increase the reliability of transactions being confirmed within the desired target. For transactions that are marked as replaceable, the wallet will use an economical estimate by default, since the fee can be 'bumped' if the fee conditions change rapidly (See [PR 10589](https://github.com/bitcoin/bitcoin/pull/10589)).\n- - Estimates can now be made for confirmation targets up to 1008 blocks (one week).\n- - More data on historical fee rates is stored, leading to more precise fee estimates.\n- - Transactions which leave the mempool due to eviction or other non-confirmed reasons are now taken into account by the fee estimation logic, leading to more accurate fee estimates.\n- - The fee estimation logic will make sure enough data has been gathered to return a meaningful estimate. If there is insufficient data, a fallback default fee is used.\n\n### Changes to fee estimate RPCs\n\n- - The `estimatefee` RPC is now deprecated in favor of using only `estimatesmartfee` (which is the implementation used by the GUI)\n- - The `estimatesmartfee` RPC interface has been changed (See [PR 10707](https://github.com/bitcoin/bitcoin/pull/10707)):\n    - The `nblocks` argument has been renamed to `conf_target` (to be consistent with other RPC methods).\n    - An `estimate_mode` argument has been added. This argument takes one of the following strings: `CONSERVATIVE`, `ECONOMICAL` or `UNSET` (which defaults to `CONSERVATIVE`).\n    - The RPC return object now contains an `errors` member, which returns errors encountered during processing.\n    - If Bitcoin Core has not been running for long enough and has not seen enough blocks or transactions to produce an accurate fee estimation, an error will be returned (previously a value of -1 was used to indicate an error, which could be confused for a feerate).\n- - A new `estimaterawfee` RPC is added to provide raw fee data. External clients can query and use this data in their own fee estimation logic.\n\nMulti-wallet support\n- --------------------\n\nBitcoin Core now supports loading multiple, separate wallets (See [PR 8694](https://github.com/bitcoin/bitcoin/pull/8694), [PR 10849](https://github.com/bitcoin/bitcoin/pull/10849)). The wallets are completely separated, with individual balances, keys and received transactions.\n\nMulti-wallet is enabled by using more than one `-wallet` argument when starting Bitcoin, either on the command line or in the Bitcoin config file.\n\n**In Bitcoin-Qt, only the first wallet will be displayed and accessible for creating and signing transactions.** GUI selectable multiple wallets will be supported in a future version. However, even in 0.15 other loaded wallets will remain synchronized to the node's current tip in the background. This can be useful if running a pruned node, since loading a wallet where the most recent sync is beyond the pruned height results in having to download and revalidate the whole blockchain. Continuing to synchronize all wallets in the background avoids this problem.\n\nBitcoin Core 0.15.0 contains the following changes to the RPC interface and `bitcoin-cli` for multi-wallet:\n\n* When running Bitcoin Core with a single wallet, there are **no** changes to the RPC interface or `bitcoin-cli`. All RPC calls and `bitcoin-cli` commands continue to work as before.\n* When running Bitcoin Core with multi-wallet, all *node-level* RPC methods continue to work as before. HTTP RPC requests should be send to the normal `<RPC IP address>:<RPC port>/` endpoint, and `bitcoin-cli` commands should be run as before. A *node-level* RPC method is any method which does not require access to the wallet.\n* When running Bitcoin Core with multi-wallet, *wallet-level* RPC methods must specify the wallet for which they're intended in every request. HTTP RPC requests should be send to the `<RPC IP address>:<RPC port>/wallet/<wallet name>/` endpoint, for example `127.0.0.1:8332/wallet/wallet1.dat/`. `bitcoin-cli` commands should be run with a `-rpcwallet` option, for example `bitcoin-cli -rpcwallet=wallet1.dat getbalance`.\n* A new *node-level* `listwallets` RPC method is added to display which wallets are currently loaded. The names returned by this method are the same as those used in the HTTP endpoint and for the `rpcwallet` argument.\n\nNote that while multi-wallet is now fully supported, the RPC multi-wallet interface should be considered unstable for version 0.15.0, and there may backwards-incompatible changes in future versions.\n\nReplace-by-fee control in the GUI\n- ---------------------------------\n\nBitcoin Core has supported creating opt-in replace-by-fee (RBF) transactions\nsince version 0.12.0, and since version 0.14.0 has included a `bumpfee` RPC method to\nreplace unconfirmed opt-in RBF transactions with a new transaction that pays\na higher fee.\n\nIn version 0.15, creating an opt-in RBF transaction and replacing the unconfirmed\ntransaction with a higher-fee transaction are both supported in the GUI (See [PR 9592](https://github.com/bitcoin/bitcoin/pull/9592)).\n\nRemoval of Coin Age Priority\n- ----------------------------\n\nIn previous versions of Bitcoin Core, a portion of each block could be reserved for transactions based on the age and value of UTXOs they spent. This concept (Coin Age Priority) is a policy choice by miners, and there are no consensus rules around the inclusion of Coin Age Priority transactions in blocks. In practice, only a few miners continue to use Coin Age Priority for transaction selection in blocks. Bitcoin Core 0.15 removes all remaining support for Coin Age Priority (See [PR 9602](https://github.com/bitcoin/bitcoin/pull/9602)). This has the following implications:\n\n- - The concept of *free transactions* has been removed. High Coin Age Priority transactions would previously be allowed to be relayed even if they didn't attach a miner fee. This is no longer possible since there is no concept of Coin Age Priority. The `-limitfreerelay` and `-relaypriority` options which controlled relay of free transactions have therefore been removed.\n- - The `-sendfreetransactions` option has been removed, since almost all miners do not include transactions which do not attach a transaction fee.\n- - The `-blockprioritysize` option has been removed.\n- - The `estimatepriority` and `estimatesmartpriority` RPCs have been removed.\n- - The `getmempoolancestors`, `getmempooldescendants`, `getmempoolentry` and `getrawmempool` RPCs no longer return `startingpriority` and `currentpriority`.\n- - The `prioritisetransaction` RPC no longer takes a `priority_delta` argument, which is replaced by a `dummy` argument for backwards compatibility with clients using positional arguments. The RPC is still used to change the apparent fee-rate of the transaction by using the `fee_delta` argument.\n- - `-minrelaytxfee` can now be set to 0. If `minrelaytxfee` is set, then fees smaller than `minrelaytxfee` (per kB) are rejected from relaying, mining and transaction creation. This defaults to 1000 satoshi/kB.\n- - The `-printpriority` option has been updated to only output the fee rate and hash of transactions included in a block by the mining code.\n\nMempool Persistence Across Restarts\n- -----------------------------------\n\nVersion 0.14 introduced mempool persistence across restarts (the mempool is saved to a `mempool.dat` file in the data directory prior to shutdown and restores the mempool when the node is restarted). Version 0.15 allows this feature to be switched on or off using the `-persistmempool` command-line option (See [PR 9966](https://github.com/bitcoin/bitcoin/pull/9966)). By default, the option is set to true, and the mempool is saved on shutdown and reloaded on startup. If set to false, the `mempool.dat` file will not be loaded on startup or saved on shutdown.\n\nNew RPC methods\n- ---------------\n\nVersion 0.15 introduces several new RPC methods:\n\n- - `abortrescan` stops current wallet rescan, e.g. when triggered by an `importprivkey` call (See [PR 10208](https://github.com/bitcoin/bitcoin/pull/10208)).\n- - `combinerawtransaction` accepts a JSON array of raw transactions and combines them into a single raw transaction (See [PR 10571](https://github.com/bitcoin/bitcoin/pull/10571)).\n- - `estimaterawfee` returns raw fee data so that customized logic can be implemented to analyze the data and calculate estimates. See [Fee Estimation Improvements](#fee-estimation-improvements) for full details on changes to the fee estimation logic and interface.\n- - `getchaintxstats` returns statistics about the total number and rate of transactions\n  in the chain (See [PR 9733](https://github.com/bitcoin/bitcoin/pull/9733)).\n- - `listwallets` lists wallets which are currently loaded. See the *Multi-wallet* section\n  of these release notes for full details (See [Multi-wallet support](#multi-wallet-support)).\n- - `uptime` returns the total runtime of the `bitcoind` server since its last start (See [PR 10400](https://github.com/bitcoin/bitcoin/pull/10400)).\n\nLow-level RPC changes\n- ---------------------\n\n- - When using Bitcoin Core in multi-wallet mode, RPC requests for wallet methods must specify\n  the wallet that they're intended for. See [Multi-wallet support](#multi-wallet-support) for full details.\n\n- - The new database model no longer stores information about transaction\n  versions of unspent outputs (See [Performance improvements](#performance-improvements)). This means that:\n  - The `gettxout` RPC no longer has a `version` field in the response.\n  - The `gettxoutsetinfo` RPC reports `hash_serialized_2` instead of `hash_serialized`,\n    which does not commit to the transaction versions of unspent outputs, but does\n    commit to the height and coinbase information.\n  - The `getutxos` REST path no longer reports the `txvers` field in JSON format,\n    and always reports 0 for transaction versions in the binary format\n\n- - The `estimatefee` RPC is deprecated. Clients should switch to using the `estimatesmartfee` RPC, which returns better fee estimates. See [Fee Estimation Improvements](#fee-estimation-improvements) for full details on changes to the fee estimation logic and interface.\n\n- - The `gettxoutsetinfo` response now contains `disk_size` and `bogosize` instead of\n  `bytes_serialized`. The first is a more accurate estimate of actual disk usage, but\n  is not deterministic. The second is unrelated to disk usage, but is a\n  database-independent metric of UTXO set size: it counts every UTXO entry as 50 + the\n  length of its scriptPubKey (See [PR 10426](https://github.com/bitcoin/bitcoin/pull/10426)).\n\n- - `signrawtransaction` can no longer be used to combine multiple transactions into a single transaction. Instead, use the new `combinerawtransaction` RPC (See [PR 10571](https://github.com/bitcoin/bitcoin/pull/10571)).\n\n- - `fundrawtransaction` no longer accepts a `reserveChangeKey` option. This option used to allow RPC users to fund a raw transaction using an key from the keypool for the change address without removing it from the available keys in the keypool. The key could then be re-used for a `getnewaddress` call, which could potentially result in confusing or dangerous behaviour (See [PR 10784](https://github.com/bitcoin/bitcoin/pull/10784)).\n\n- - `estimatepriority` and `estimatesmartpriority` have been removed. See [Removal of Coin Age Priority](#removal-of-coin-age-priority).\n\n- - The `listunspent` RPC now takes a `query_options` argument (see [PR 8952](https://github.com/bitcoin/bitcoin/pull/8952)), which is a JSON object\n  containing one or more of the following members:\n  - `minimumAmount` - a number specifying the minimum value of each UTXO\n  - `maximumAmount` - a number specifying the maximum value of each UTXO\n  - `maximumCount` - a number specifying the minimum number of UTXOs\n  - `minimumSumAmount` - a number specifying the minimum sum value of all UTXOs\n\n- - The `getmempoolancestors`, `getmempooldescendants`, `getmempoolentry` and `getrawmempool` RPCs no longer return `startingpriority` and `currentpriority`. See [Removal of Coin Age Priority](#removal-of-coin-age-priority).\n\n- - The `dumpwallet` RPC now returns the full absolute path to the dumped wallet. It\n  used to return no value, even if successful (See [PR 9740](https://github.com/bitcoin/bitcoin/pull/9740)).\n\n- - In the `getpeerinfo` RPC, the return object for each peer now returns an `addrbind` member, which contains the ip address and port of the connection to the peer. This is in addition to the `addrlocal` member which contains the ip address and port of the local node as reported by the peer (See [PR 10478](https://github.com/bitcoin/bitcoin/pull/10478)).\n\n- - The `disconnectnode` RPC can now disconnect a node specified by node ID (as well as by IP address/port). To disconnect a node based on node ID, call the RPC with the new `nodeid` argument (See [PR 10143](https://github.com/bitcoin/bitcoin/pull/10143)).\n\n- - The second argument in `prioritisetransaction` has been renamed from `priority_delta` to `dummy` since Bitcoin Core no longer has a concept of coin age priority. The `dummy` argument has no functional effect, but is retained for positional argument compatibility. See [Removal of Coin Age Priority](#removal-of-coin-age-priority).\n\n- - The `resendwallettransactions` RPC throws an error if the `-walletbroadcast` option is set to false (See [PR 10995](https://github.com/bitcoin/bitcoin/pull/10995)).\n\n- - The second argument in the `submitblock` RPC argument has been renamed from `parameters` to `dummy`. This argument never had any effect, and the renaming is simply to communicate this fact to the user (See [PR 10191](https://github.com/bitcoin/bitcoin/pull/10191))\n  (Clients should, however, use positional arguments for `submitblock` in order to be compatible with BIP 22.)\n\n- - The `verbose` argument of `getblock` has been renamed to `verbosity` and now takes an integer from 0 to 2. Verbose level 0 is equivalent to `verbose=false`. Verbose level 1 is equivalent to `verbose=true`. Verbose level 2 will give the full transaction details of each transaction in the output as given by `getrawtransaction`. The old behavior of using the `verbose` named argument and a boolean value is still maintained for compatibility.\n\n- - Error codes have been updated to be more accurate for the following error cases (See [PR 9853](https://github.com/bitcoin/bitcoin/pull/9853)):\n  - `getblock` now returns RPC_MISC_ERROR if the block can't be found on disk (for\n  example if the block has been pruned). Previously returned RPC_INTERNAL_ERROR.\n  - `pruneblockchain` now returns RPC_MISC_ERROR if the blocks cannot be pruned\n  because the node is not in pruned mode. Previously returned RPC_METHOD_NOT_FOUND.\n  - `pruneblockchain` now returns RPC_INVALID_PARAMETER if the blocks cannot be pruned\n  because the supplied timestamp is too late. Previously returned RPC_INTERNAL_ERROR.\n  - `pruneblockchain` now returns RPC_MISC_ERROR if the blocks cannot be pruned\n  because the blockchain is too short. Previously returned RPC_INTERNAL_ERROR.\n  - `setban` now returns RPC_CLIENT_INVALID_IP_OR_SUBNET if the supplied IP address\n  or subnet is invalid. Previously returned RPC_CLIENT_NODE_ALREADY_ADDED.\n  - `setban` now returns RPC_CLIENT_INVALID_IP_OR_SUBNET if the user tries to unban\n  a node that has not previously been banned. Previously returned RPC_MISC_ERROR.\n  - `removeprunedfunds` now returns RPC_WALLET_ERROR if `bitcoind` is unable to remove\n  the transaction. Previously returned RPC_INTERNAL_ERROR.\n  - `removeprunedfunds` now returns RPC_INVALID_PARAMETER if the transaction does not\n  exist in the wallet. Previously returned RPC_INTERNAL_ERROR.\n  - `fundrawtransaction` now returns RPC_INVALID_ADDRESS_OR_KEY if an invalid change\n  address is provided. Previously returned RPC_INVALID_PARAMETER.\n  - `fundrawtransaction` now returns RPC_WALLET_ERROR if `bitcoind` is unable to create\n  the transaction. The error message provides further details. Previously returned\n  RPC_INTERNAL_ERROR.\n  - `bumpfee` now returns RPC_INVALID_PARAMETER if the provided transaction has\n  descendants in the wallet. Previously returned RPC_MISC_ERROR.\n  - `bumpfee` now returns RPC_INVALID_PARAMETER if the provided transaction has\n  descendants in the mempool. Previously returned RPC_MISC_ERROR.\n  - `bumpfee` now returns RPC_WALLET_ERROR if the provided transaction has\n  has been mined or conflicts with a mined transaction. Previously returned\n  RPC_INVALID_ADDRESS_OR_KEY.\n  - `bumpfee` now returns RPC_WALLET_ERROR if the provided transaction is not\n  BIP 125 replaceable. Previously returned RPC_INVALID_ADDRESS_OR_KEY.\n  - `bumpfee` now returns RPC_WALLET_ERROR if the provided transaction has already\n  been bumped by a different transaction. Previously returned RPC_INVALID_REQUEST.\n  - `bumpfee` now returns RPC_WALLET_ERROR if the provided transaction contains\n  inputs which don't belong to this wallet. Previously returned RPC_INVALID_ADDRESS_OR_KEY.\n  - `bumpfee` now returns RPC_WALLET_ERROR if the provided transaction has multiple change\n  outputs. Previously returned RPC_MISC_ERROR.\n  - `bumpfee` now returns RPC_WALLET_ERROR if the provided transaction has no change\n  output. Previously returned RPC_MISC_ERROR.\n  - `bumpfee` now returns RPC_WALLET_ERROR if the fee is too high. Previously returned\n  RPC_MISC_ERROR.\n  - `bumpfee` now returns RPC_WALLET_ERROR if the fee is too low. Previously returned\n  RPC_MISC_ERROR.\n  - `bumpfee` now returns RPC_WALLET_ERROR if the change output is too small to bump the\n  fee. Previously returned RPC_MISC_ERROR.\n\n0.15.0 Change log\n=================\n\n### RPC and other APIs\n- - #9485 `61a640e` ZMQ example using python3 and asyncio (mcelrath)\n- - #9894 `0496e15` remove 'label' filter for rpc command help (instagibbs)\n- - #9853 `02bd6e9` Fix error codes from various RPCs (jnewbery)\n- - #9842 `598ef9c` Fix RPC failure testing (continuation of #9707) (jnewbery)\n- - #10038 `d34995a` Add mallocinfo mode to `getmemoryinfo` RPC (laanwj)\n- - #9500 `3568b30` [Qt][RPC] Autocomplete commands for 'help' command in debug console (achow101)\n- - #10056 `e6156a0` [zmq] Call va_end() on va_start()ed args (kallewoof)\n- - #10086 `7438cea` Trivial: move rpcserialversion into RPC option group (jlopp)\n- - #10150 `350b224` [rpc] Add logging rpc (jnewbery)\n- - #10208 `393160c` [wallet] Rescan abortability (kallewoof)\n- - #10143 `a987def` [net] Allow disconnectnode RPC to be called with node id (jnewbery)\n- - #10281 `0e8499c` doc: Add RPC interface guidelines (laanwj)\n- - #9733 `d4732f3` Add getchaintxstats RPC (sipa)\n- - #10310 `f4b15e2` [doc] Add hint about getmempoolentry to getrawmempool help (kallewoof)\n- - #8704 `96c850c` [RPC] Transaction details in getblock (achow101)\n- - #8952 `9390845` Add query options to listunspent RPC call (pedrobranco)\n- - #10413 `08ac35a` Fix docs (there's no rpc command setpaytxfee) (RHavar)\n- - #8384 `e317c0d` Add witness data output to TxInError messages (instagibbs)\n- - #9571 `4677151` RPC: getblockchaininfo returns BIP signaling statistics  (pinheadmz)\n- - #10450 `ef2d062` Fix bumpfee rpc \"errors\" return value (ryanofsky)\n- - #10475 `39039b1` [RPC] getmempoolinfo mempoolminfee is a BTC/KB feerate (instagibbs)\n- - #10478 `296928e` rpc: Add listen address to incoming connections in `getpeerinfo` (laanwj)\n- - #10403 `08d0390` Fix importmulti failure to return rescan errors (ryanofsky)\n- - #9740 `9fec4da` Add friendly output to dumpwallet (aideca)\n- - #10426 `16f6c98` Replace bytes_serialized with bogosize (sipa)\n- - #10252 `980deaf` RPC/Mining: Restore API compatibility for prioritisetransaction (luke-jr)\n- - #9672 `46311e7` Opt-into-RBF for RPC & bitcoin-tx (luke-jr)\n- - #10481 `9c248e3` Decodehextx scripts sanity check  (achow101)\n- - #10488 `fa1f106` Note that the prioritizetransaction dummy value is deprecated, and has no meaning (TheBlueMatt)\n- - #9738 `c94b89e` gettxoutproof() should return consistent result (jnewbery)\n- - #10191 `00350bd` [trivial] Rename unused RPC arguments 'dummy' (jnewbery)\n- - #10627 `b62b4c8` fixed listunspent rpc convert parameter (tnakagawa)\n- - #10412 `bef02fb` Improve wallet rescan API (ryanofsky)\n- - #10400 `1680ee0` [RPC] Add an uptime command that displays the amount of time (in seconds) bitcoind has been running (rvelhote)\n- - #10683 `d81bec7` rpc: Move the `generate` RPC call to rpcwallet (laanwj)\n- - #10710 `30bc0f6` REST/RPC example update (Mirobit)\n- - #10747 `9edda0c` [rpc] fix verbose argument for getblock in bitcoin-cli (jnewbery)\n- - #10589 `104f5f2` More economical fee estimates for RBF and RPC options to control (morcos)\n- - #10543 `b27b004` Change API to estimaterawfee (morcos)\n- - #10807 `afd2fca` getbalance example covers at least 6 confirms (instagibbs)\n- - #10707 `75b5643` Better API for estimatesmartfee RPC  (morcos)\n- - #10784 `9e8d6a3` Do not allow users to get keys from keypool without reserving them (TheBlueMatt)\n- - #10857 `d445a2c` [RPC] Add a deprecation warning to getinfo's output (achow101)\n- - #10571 `adf170d` [RPC]Move transaction combining from signrawtransaction to new RPC (achow101)\n- - #10783 `041dad9` [RPC] Various rpc argument fixes (instagibbs)\n- - #9622 `6ef3c7e` [rpc] listsinceblock should include lost transactions when parameter is a reorg'd block (kallewoof)\n- - #10799 `8537187` Prevent user from specifying conflicting parameters to fundrawtx (TheBlueMatt)\n- - #10931 `0b11a07` Fix misleading \"Method not found\" multiwallet errors (ryanofsky)\n- - #10788 `f66c596` [RPC] Fix addwitnessaddress by replacing ismine with producesignature (achow101)\n- - #10999 `627c3c0` Fix amounts formatting in `decoderawtransaction` (laanwj)\n- - #11002 `4268426` [wallet] return correct error code from resendwallettransaction (jnewbery)\n- - #11029 `96a63a3` [RPC] trivial: gettxout no longer shows version of tx (FelixWeis)\n- - #11083 `6c2b008` Fix combinerawtransaction RPC help result section (jonasnick)\n- - #11027 `07164bb` [RPC] Only return hex field once in getrawtransaction (achow101)\n- - #10698 `5af6572` Be consistent in calling transactions \"replaceable\" for Opt-In RBF (TheBlueMatt)\n\n### Block and transaction handling\n- - #9801 `a8c5751` Removed redundant parameter from mempool.PrioritiseTransaction (gubatron)\n- - #9819 `1efc99c` Remove harmless read of unusued priority estimates (morcos)\n- - #9822 `b7547fa` Remove block file location upgrade code (benma)\n- - #9602 `30ff3a2` Remove coin age priority and free transactions - implementation (morcos)\n- - #9548 `47510ad` Remove min reasonable fee (morcos)\n- - #10249 `c73af54` Switch CCoinsMap from boost to std unordered_map (sipa)\n- - #9966 `2a183de` Control mempool persistence using a command line parameter (jnewbery)\n- - #10199 `318ea50` Better fee estimates (morcos)\n- - #10196 `bee3529` Bugfix: PrioritiseTransaction updates the mempool tx counter (sdaftuar)\n- - #10195 `1088b02` Switch chainstate db and cache to per-txout model (sipa)\n- - #10284 `c2ab38b` Always log debug information for fee calculation in CreateTransaction (morcos)\n- - #10503 `efbcf2b` Use REJECT_DUPLICATE for already known and conflicted txn (sipa)\n- - #10537 `b3eb0d6` Few Minor per-utxo assert-semantics re-adds and tweak (TheBlueMatt)\n- - #10626 `8c841a3` doc: Remove outdated minrelaytxfee comment (MarcoFalke)\n- - #10559 `234ffc6` Change semantics of HaveCoinInCache to match HaveCoin (morcos)\n- - #10581 `7878353` Simplify return values of GetCoin/HaveCoin(InCache) (sipa)\n- - #10684 `a381f6a` Remove no longer used mempool.exists(outpoint) (morcos)\n- - #10148 `d4e551a` Use non-atomic flushing with block replay (sipa)\n- - #10685 `30c2130` Clarify CCoinsViewMemPool documentation (TheBlueMatt)\n- - #10558 `90a002e` Address nits from per-utxo change (morcos)\n- - #10706 `6859ad2` Improve wallet fee logic and fix GUI bugs (morcos)\n- - #10526 `754aa02` Force on-the-fly compaction during pertxout upgrade (sipa)\n- - #10985 `d896d5c` Add undocumented -forcecompactdb to force LevelDB compactions (sipa)\n- - #10292 `e4bbd3d` Improved efficiency in COutPoint constructors (mm-s)\n- - #10290 `8d6d43e` Add -stopatheight for benchmarking (sipa)\n\n### P2P protocol and network code\n- - #9726 `7639d38` netbase: Do not print an error on connection timeouts through proxy (laanwj)\n- - #9805 `5b583ef` Add seed.btc.petertodd.org to mainnet DNS seeds (petertodd)\n- - #9861 `22f609f` Trivial: Debug log ambiguity fix for peer addrs (keystrike)\n- - #9774 `90cb2a2` Enable host lookups for -proxy and -onion parameters (jmcorgan)\n- - #9558 `7b585cf` Clarify assumptions made about when BlockCheck is called (TheBlueMatt)\n- - #10135 `e19586a` [p2p] Send the correct error code in reject messages (jnewbery)\n- - #9665 `eab00d9` Use cached [compact] blocks to respond to getdata messages (TheBlueMatt)\n- - #10215 `a077a90` Check interruptNet during dnsseed lookups (TheBlueMatt)\n- - #10234 `faf2dea` [net] listbanned RPC and QT should show correct banned subnets (jnewbery)\n- - #10134 `314ebdf` [qa] Fixes segwit block relay test after inv-direct-fetch was disabled (sdaftuar)\n- - #10351 `3f57c55` removed unused code in INV message (Greg-Griffith)\n- - #10061 `ae78609` [net] Added SetSocketNoDelay() utility function (tjps)\n- - #10408 `28c6e8d` Net: Improvements to Tor control port parser (str4d)\n- - #10460 `5c63d66` Broadcast address every day, not 9 hours (sipa)\n- - #10471 `400fdd0` Denote functions CNode::GetRecvVersion() and CNode::GetRefCount()  as const (pavlosantoniou)\n- - #10345 `67700b3` [P2P] Timeout for headers sync (sdaftuar)\n- - #10564 `8d9f45e` Return early in IsBanned (gmaxwell)\n- - #10587 `de8db47` Net: Fix resource leak in ReadBinaryFile(...) (practicalswift)\n- - #9549 `b33ca14` [net] Avoid possibility of NULL pointer dereference in MarkBlockAsInFlight(...) (practicalswift)\n- - #10446 `2772dc9` net: avoid extra dns query per seed (theuni)\n- - #10824 `9dd6a2b` Avoid unnecessary work in SetNetworkActive (promag)\n- - #10948 `df3a6f4` p2p: Hardcoded seeds update pre-0.15 branch (laanwj)\n- - #10977 `02f4c4a` [net] Fix use of uninitialized value in getnetworkinfo(const JSONRPCRequest&) (practicalswift)\n- - #10982 `c8b62c7` Disconnect network service bits 6 and 8 until Aug 1, 2018 (TheBlueMatt)\n- - #11012 `0e5cff6` Make sure to clean up mapBlockSource if we've already seen the block (theuni)\n\n### Validation\n- - #9725 `67023e9` CValidationInterface Cleanups (TheBlueMatt)\n- - #10178 `2584925` Remove CValidationInterface::UpdatedTransaction (TheBlueMatt)\n- - #10201 `a6548a4` pass Consensus::Params& to functions in validation.cpp and make them static (mariodian)\n- - #10297 `431a548` Simplify DisconnectBlock arguments/return value (sipa)\n- - #10464 `f94b7d5` Introduce static DoWarning (simplify UpdateTip) (jtimon)\n- - #10569 `2e7d8f8` Fix stopatheight (achow101)\n- - #10192 `2935b46` Cache full script execution results in addition to signatures (TheBlueMatt)\n- - #10179 `21ed30a` Give CValidationInterface Support for calling notifications on the CScheduler Thread (TheBlueMatt)\n- - #10557 `66270a4` Make check to distinguish between orphan txs and old txs more efficient (morcos)\n- - #10775 `7c2400c` nCheckDepth chain height fix (romanornr)\n- - #10821 `16240f4` Add SSE4 optimized SHA256 (sipa)\n- - #10854 `04d395e` Avoid using sizes on non-fixed-width types to derive protocol constants (gmaxwell)\n- - #10945 `2a50b11` Update defaultAssumeValid according to release-process.md (gmaxwell)\n- - #10986 `2361208` Update chain transaction statistics (sipa)\n- - #11028 `6bdf4b3` Avoid masking of difficulty adjustment errors by checkpoints (sipa)\n- - #9533 `cb598cf` Allow non-power-of-2 signature cache sizes (sipa)\n- - #9208 `acd9957` Improve DisconnectTip performance (sdaftuar)\n- - #10618 `f90603a` Remove confusing MAX_BLOCK_BASE_SIZE (gmaxwell)\n- - #10758 `bd92424` Fix some chainstate-init-order bugs (TheBlueMatt)\n- - #10550 `b7296bc` Don't return stale data from CCoinsViewCache::Cursor() (ryanofsky)\n- - #10998 `2507fd5` Fix upgrade cancel warnings (TheBlueMatt)\n- - #9868 `cbdb473` Abstract out the command line options for block assembly (sipa)\n\n### Build system\n- - #9727 `5f0556d` Remove fallbacks for boost_filesystem < v3 (laanwj)\n- - #9788 `50a2265` gitian: bump descriptors for master (theuni)\n- - #9794 `7ca2f54` Minor update to qrencode package builder (mitchellcash)\n- - #9514 `2cc0df1` release: Windows signing script (theuni)\n- - #9921 `8b789d8` build: Probe MSG_DONTWAIT in the same way as MSG_NOSIGNAL (laanwj)\n- - #10011 `32d1b34` build: Fix typo s/HAVE_DONTWAIT/HAVE_MSG_DONTWAIT (laanwj)\n- - #9946 `90dd9e6` Fix build errors if spaces in path or parent directory (pinheadmz)\n- - #10136 `81da4c7` build: Disable Wshadow warning (laanwj)\n- - #10166 `64962ae` Ignore Doxyfile generated from Doxyfile.in template (paveljanik)\n- - #10239 `0416ea9` Make Boost use std::atomic internally (sipa)\n- - #10228 `27faa6c` build: regenerate bitcoin-config.h as necessary (theuni)\n- - #10273 `8979f45` [scripts] Minor improvements to `macdeployqtplus` script (chrisgavin)\n- - #10325 `a26280b` 0.15.0 Depends Updates (fanquake)\n- - #10328 `79aeff6` Update contrib/debian to latest Ubuntu PPA upload (TheBlueMatt)\n- - #7522 `d25449f` Bugfix: Only use git for build info if the repository is actually the right one (luke-jr)\n- - #10489 `e654d61` build: silence gcc7's implicit fallthrough warning (theuni)\n- - #10549 `ad1a13e` Avoid printing generic and duplicated \"checking for QT\" during ./configure (drizzt)\n- - #10628 `8465b68` [depends] expat 2.2.1 (fanquake)\n- - #10806 `db825d2` build: verify that the assembler can handle crc32 functions (theuni)\n- - #10766 `b4d03be` Building Environment: Set ARFLAGS to cr (ReneNyffenegger)\n- - #10803 `91edda8` Explicitly search for bdb5.3 (pstratem)\n- - #10855 `81560b0` random: only use getentropy on openbsd (theuni)\n- - #10508 `1caafa6` Run Qt wallet tests on travis (ryanofsky)\n- - #10851 `e222618` depends: fix fontconfig with newer glibc (theuni)\n- - #10971 `88b1e4b` build: fix missing sse42 in depends builds (theuni)\n- - #11097 `129b03f` gitian: quick hack to fix version string in releases (theuni)\n- - #10039 `919aaf6` Fix compile errors with Qt 5.3.2 and Boost 1.55.0 (ryanofsky)\n- - #10168 `7032021` Fix build warning from #error text (jnewbery)\n- - #10301 `318392c` Check if sys/random.h is required for getentropy (jameshilliard)\n\n### GUI\n- - #9724 `1a9fd5c` Qt/Intro: Add explanation of IBD process (luke-jr)\n- - #9834 `b00ba62` qt: clean up initialize/shutdown signals (benma)\n- - #9481 `ce01e62` [Qt] Show more significant warning if we fall back to the default fee (jonasschnelli)\n- - #9974 `b9f930b` Add basic Qt wallet test (ryanofsky)\n- - #9690 `a387d3a` Change 'Clear' button string to 'Reset' (da2x)\n- - #9592 `9c7b7cf` [Qt] Add checkbox in the GUI to opt-in to RBF when creating a transaction (ryanofsky)\n- - #10098 `2b477e6` Make qt wallet test compatible with qt4 (ryanofsky)\n- - #9890 `1fa4ae6` Add a button to open the config file in a text editor (ericshawlinux)\n- - #10156 `51833a1` Fix for issues with startup and multiple monitors on windows (AllanDoensen)\n- - #10177 `de01da7` Changed \"Send\" button default status from true to false (KibbledJiveElkZoo)\n- - #10221 `e96486c` Stop treating coinbase outputs differently in GUI: show them at 1conf (TheBlueMatt)\n- - #10231 `987a6c0` [Qt] Reduce a significant cs_main lock freeze (jonasschnelli)\n- - #10242 `f6f3b58` [qt] Don't call method on null WalletModel object (ryanofsky)\n- - #10093 `a3e756b` [Qt] Don't add arguments of sensitive command to console window (jonasschnelli)\n- - #10362 `95546c8` [GUI] Add OSX keystroke to RPCConsole info (spencerlievens)\n- - #9697 `962cd3f` [Qt] simple fee bumper with user verification (jonasschnelli)\n- - #10390 `e477516` [wallet] remove minimum total fee option (instagibbs)\n- - #10420 `4314544` Add Qt tests for wallet spends & bumpfee (ryanofsky)\n- - #10454 `c1c9a95` Fix broken q4 test build (ryanofsky)\n- - #10449 `64beb13` Overhaul Qt fee bumper (jonasschnelli)\n- - #10582 `7c72fb9` Pass in smart fee slider value to coin control dialog (morcos)\n- - #10673 `4c72cc3` [qt] Avoid potential null pointer dereference in TransactionView::exportClicked() (practicalswift)\n- - #10769 `8fdd23a` [Qt] replace fee slider with a Dropdown, extend conf. targets (jonasschnelli)\n- - #10870 `412b466` [Qt] Use wallet 0 in rpc console if running with multiple wallets (jonasschnelli)\n- - #10988 `a9dd111` qt: Increase BLOCK_CHAIN_SIZE constants (laanwj)\n- - #10644 `e292140` Slightly overhaul NSI pixmaps (jonasschnelli)\n- - #10660 `0c3542e` Allow to cancel the txdb upgrade via splashscreen keypress 'q' (jonasschnelli)\n\n### Wallet\n- - #9359 `f7ec7cf` Add test for CWalletTx::GetImmatureCredit() returning stale values (ryanofsky)\n- - #9576 `56ab672` [wallet] Remove redundant initialization (practicalswift)\n- - #9333 `fa625b0` Document CWalletTx::mapValue entries and remove erase of nonexistent \"version\" entry (ryanofsky)\n- - #9906 `72fb515` Disallow copy constructor CReserveKeys (instagibbs)\n- - #9369 `3178b2c` Factor out CWallet::nTimeSmart computation into a method (ryanofsky)\n- - #9830 `afcd7c0` Add safe flag to listunspent result (NicolasDorier)\n- - #9993 `c49355c` Initialize nRelockTime (pstratem)\n- - #9818 `3d857f3` Save watch only key timestamps when reimporting keys (ryanofsky)\n- - #9294 `f34cdcb` Use internal HD chain for change outputs (hd split) (jonasschnelli)\n- - #10164 `e183ea2` Wallet: reduce excess logic InMempool() (kewde)\n- - #10186 `c9ff4f8` Remove SYNC_TRANSACTION_NOT_IN_BLOCK magic number (jnewbery)\n- - #10226 `64c45aa` wallet: Use boost to more portably ensure -wallet specifies only a filename (luke-jr)\n- - #9827 `c91ca0a` Improve ScanForWalletTransactions return value (ryanofsky)\n- - #9951 `fa1ac28` Wallet database handling abstractions/simplifications (laanwj)\n- - #10265 `c29a0d4` [wallet] [moveonly] Check non-null pindex before potentially referencing (kallewoof)\n- - #10283 `a550f6e` Cleanup: reduce to one GetMinimumFee call signature (morcos)\n- - #10294 `e2b99b1` [Wallet] unset change position when there is no change (instagibbs)\n- - #10115 `d3dce0e` Avoid reading the old hd master key during wallet encryption (TheBlueMatt)\n- - #10341 `18c9deb` rpc/wallet: Workaround older UniValue which returns a std::string temporary for get_str (luke-jr)\n- - #10308 `94e5227` [wallet] Securely erase potentially sensitive keys/values (tjps)\n- - #10257 `ea1fd43` [test] Add test for getmemoryinfo (jimmysong)\n- - #10295 `ce8176d` [qt] Move some WalletModel functions into CWallet (ryanofsky)\n- - #10506 `7cc2c67` Fix bumpfee test after #10449 (ryanofsky)\n- - #10500 `098b01d` Avoid CWalletTx copies in GetAddressBalances and GetAddressGroupings (ryanofsky)\n- - #10455 `0747d33` Simplify feebumper minimum fee code slightly (ryanofsky)\n- - #10522 `2805d60` [wallet] Remove unused variables (practicalswift)\n- - #8694 `177433a` Basic multiwallet support (luke-jr)\n- - #10598 `7a74f88` Supress struct/class mismatch warnings introduced in #10284 (paveljanik)\n- - #9343 `209eef6` Don't create change at dust limit (morcos)\n- - #10744 `ed88e31` Use method name via __func__ macro (darksh1ne)\n- - #10712 `e8b9523` Add change output if necessary to reduce excess fee (morcos)\n- - #10816 `1c011ff` Properly forbid -salvagewallet and -zapwallettxes for multi wallet (morcos)\n- - #10235 `5cfdda2` Track keypool entries as internal vs external in memory (TheBlueMatt)\n- - #10330 `bf0a08b` [wallet] fix zapwallettxes interaction with persistent mempool (jnewbery)\n- - #10831 `0b01935` Batch flushing operations to the walletdb during top up and increase keypool size (gmaxwell)\n- - #10795 `7b6e8bc` No longer ever reuse keypool indexes (TheBlueMatt)\n- - #10849 `bde4f93` Multiwallet: simplest endpoint support (jonasschnelli)\n- - #10817 `9022aa3` Redefine Dust and add a discard_rate (morcos)\n- - #10883 `bf3b742` Rename -usewallet to -rpcwallet (morcos)\n- - #10604 `420238d` [wallet] [tests] Add listwallets RPC, include wallet name in `getwalletinfo` and add multiwallet test (jnewbery)\n- - #10885 `70888a3` Reject invalid wallets (promag)\n- - #10949 `af56397` Clarify help message for -discardfee (morcos)\n- - #10942 `2e857bb` Eliminate fee overpaying edge case when subtracting fee from recipients (morcos)\n- - #10995 `fa64636` Fix resendwallettransactions assert failure if -walletbroadcast=0 (TheBlueMatt)\n- - #11022 `653a46d` Basic keypool topup (jnewbery)\n- - #11081 `9fe1f6b` Add length check for CExtKey deserialization (jonasschnelli, guidovranken)\n- - #11044 `4ef8374` [wallet] Keypool topup cleanups (jnewbery)\n- - #11145 `e51bb71` Fix rounding bug in calculation of minimum change (morcos)\n- - #9605 `779f2f9` Use CScheduler for wallet flushing, remove ThreadFlushWalletDB (TheBlueMatt)\n- - #10108 `4e3efd4` ApproximateBestSubset should take inputs by reference, not value (RHavar)\n\n### Tests and QA\n- - #9744 `8efd1c8` Remove unused module from rpc-tests (34ro)\n- - #9657 `7ff4a53` Improve rpc-tests.py (jnewbery)\n- - #9766 `7146d96` Add --exclude option to rpc-tests.py (jnewbery)\n- - #9577 `d6064a8` Fix docstrings in qa tests (jnewbery)\n- - #9823 `a13a417` qa: Set correct path for binaries in rpc tests (MarcoFalke)\n- - #9847 `6206252` Extra test vector for BIP32 (sipa)\n- - #9350 `88c2ae3` [Trivial] Adding label for amount inside of tx_valid/tx_invalid.json (Christewart)\n- - #9888 `36afd4d` travis: Verify commits only for one target (MarcoFalke)\n- - #9904 `58861ad` test: Fail if InitBlockIndex fails (laanwj)\n- - #9828 `67c5cc1` Avoid -Wshadow warnings in wallet_tests (ryanofsky)\n- - #9832 `48c3429` [qa] assert_start_raises_init_error (NicolasDorier)\n- - #9739 `9d5fcbf` Fix BIP68 activation test (jnewbery)\n- - #9547 `d32581c` bench: Assert that division by zero is unreachable (practicalswift)\n- - #9843 `c78adbf` Fix segwit getblocktemplate test (jnewbery)\n- - #9929 `d5ce14e` tests: Delete unused function _rpchost_to_args (laanwj)\n- - #9555 `19be26a` [test] Avoid reading a potentially uninitialized variable in tx_invalid-test (transaction_tests.cpp) (practicalswift)\n- - #9945 `ac23a7c` Improve logging in bctest.py if there is a formatting mismatch (jnewbery)\n- - #9768 `8910b47` [qa] Add logging to test_framework.py (jnewbery)\n- - #9972 `21833f9` Fix extended rpc tests broken by #9768 (jnewbery)\n- - #9977 `857d1e1` QA: getblocktemplate_longpoll.py should always use >0 fee tx (sdaftuar)\n- - #9970 `3cc13ea` Improve readability of segwit.py, smartfees.py (sdaftuar)\n- - #9497 `2c781fb` CCheckQueue Unit Tests (JeremyRubin)\n- - #10024 `9225de2` [trivial] Use log.info() instead of print() in remaining functional test cases (jnewbery)\n- - #9956 `3192e52` Reorganise qa directory (jnewbery)\n- - #10017 `02d64bd` combine_logs.py - aggregates log files from multiple bitcoinds during functional tests (jnewbery)\n- - #10047 `dfef6b6` [tests] Remove unused variables and imports (practicalswift)\n- - #9701 `a230b05` Make bumpfee tests less fragile (ryanofsky)\n- - #10053 `ca20923` [test] Allow functional test cases to be skipped (jnewbery)\n- - #10052 `a0b1e57` [test] Run extended tests once daily in Travis (jnewbery)\n- - #10069 `1118493` [QA] Fix typo in fundrawtransaction test (NicolasDorier)\n- - #10083 `c044f03` [QA] Renaming rawTx into rawtx (NicolasDorier)\n- - #10073 `b1a4f27` Actually run assumevalid.py (jnewbery)\n- - #9780 `c412fd8` Suppress noisy output from qa tests in Travis (jnewbery)\n- - #10096 `79af9fb` Check that all test scripts in test/functional are being run (jnewbery)\n- - #10076 `5b029aa` [qa] combine_logs: Use ordered list for logfiles (MarcoFalke)\n- - #10107 `f2734c2` Remove unused variable. Remove accidental trailing semicolons in Python code (practicalswift)\n- - #10109 `8ac8041` Remove SingleNodeConnCB (jnewbery)\n- - #10114 `edc62c9` [tests] sync_with_ping should assert that ping hasn't timed out (jnewbery)\n- - #10128 `427d2fd` Speed Up CuckooCache tests (JeremyRubin)\n- - #10072 `12af74b` Remove sources of unreliablility in extended functional tests (jnewbery)\n- - #10077 `ebfd653` [qa] Add setnetworkactive smoke test (MarcoFalke)\n- - #10152 `080d7c7` [trivial] remove unused line in Travis config (jnewbery)\n- - #10159 `df1ca9e` [tests] color test results and sort alphabetically (jnewbery)\n- - #10124 `88799ea` [test] Suppress test logging spam (jnewbery)\n- - #10142 `ed09dd3` Run bitcoin_test-qt under minimal QPA platform (ryanofsky)\n- - #9949 `a27dbc5` [bench] Avoid function call arguments which are pointers to uninitialized values (practicalswift)\n- - #10187 `b44adf9` tests: Fix test_runner return value in case of skipped test (laanwj)\n- - #10197 `d86bb07` [tests] Functional test warnings (jnewbery)\n- - #10219 `9111df9` Tests: Order Python Tests Differently (jimmysong)\n- - #10229 `f3db4c6` Tests: Add test for getdifficulty (jimmysong)\n- - #10224 `2723bcd` [test] Add test for getaddednodeinfo (jimmysong)\n- - #10023 `c530c15` [tests] remove maxblocksinflight.py (functionality covered by other test) (jnewbery)\n- - #10097 `1b25b6d` Move zmq test skipping logic into individual test case (jnewbery)\n- - #10272 `54e2d87` [Tests] Prevent warning: variable 'x' is uninitialized (paveljanik)\n- - #10225 `e0a7e19` [test] Add aborttrescan tests (kallewoof)\n- - #10278 `8254a8a` [test] Add Unit Test for GetListenPort (jimmysong)\n- - #10280 `47535d7` [test] Unit test amount.h/amount.cpp (jimmysong)\n- - #10256 `80c3a73` [test] Add test for gettxout to wallet.py (jimmysong)\n- - #10264 `492d22f` [test] Add tests for getconnectioncount, getnettotals and ping (jimmysong)\n- - #10169 `8f3e384` [tests] Remove func test code duplication (jnewbery)\n- - #10198 `dc8fc0c` [tests] Remove is_network_split from functional test framework (jnewbery)\n- - #10255 `3c5e6c9` [test] Add test for listaddressgroupings (jimmysong)\n- - #10137 `75171f0` Remove unused import. Remove accidental trailing semicolons (practicalswift)\n- - #10307 `83073de` [tests] allow zmq test to be run in out-of-tree builds (jnewbery)\n- - #10344 `e927483` [tests] Fix abandonconflict.py intermittency (jnewbery)\n- - #10318 `170bc2c` [tests] fix wait_for_inv() (jnewbery)\n- - #10171 `fff72de` [tests] Add node methods to test framework (jnewbery)\n- - #10352 `23d78c4` test: Add elapsed time to RPC tracing (laanwj)\n- - #10342 `6a796b2` [tests] Improve mempool_persist test (jnewbery)\n- - #10287 `776ba23` [tests] Update Unit Test for addrman.h/addrman.cpp (jimmysong)\n- - #10365 `7ee5236` [tests] increase timeouts in sendheaders test (jnewbery)\n- - #10361 `f6241b3` qa: disablewallet: Check that wallet is really disabled (MarcoFalke)\n- - #10371 `4b766fc` [tests] Clean up addrman_tests.cpp (jimmysong)\n- - #10253 `87abe20` [test] Add test for getnetworkhashps (jimmysong)\n- - #10376 `8bd16ee` [tests] fix disconnect_ban intermittency (jnewbery)\n- - #10374 `5411997` qa: Warn when specified test is not found (MarcoFalke)\n- - #10405 `0542978` tests: Correct testcase in script_tests.json for large number OP_EQUAL (laanwj)\n- - #10429 `6b99daf` tests: fix spurious addrman test failure (theuni)\n- - #10433 `8e57256` [tests] improve tmpdir structure (jnewbery)\n- - #10415 `217b416` [tests] Speed up fuzzing by ~200x when using afl-fuzz (practicalswift)\n- - #10445 `b4b057a` Add test for empty chain and reorg consistency for gettxoutsetinfo (gmaxwell)\n- - #10423 `1aefc94` [tests] skipped tests should clean up after themselves (jnewbery)\n- - #10359 `329fc1d` [tests] functional tests should call BitcoinTestFramework start/stop node methods (jnewbery)\n- - #10514 `e103b3f` Bugfix: missing == 0 after randrange (sipa)\n- - #10515 `c871f32` [test] Add test for getchaintxstats (jimmysong)\n- - #10509 `bea5b00` Remove xvfb configuration from travis (ryanofsky)\n- - #10535 `30853e1` [qa] fundrawtx: Fix shutdown race (MarcoFalke)\n- - #9909 `300f8e7` tests: Add FindEarliestAtLeast test for edge cases (ryanofsky)\n- - #10331 `75e898c` Share config between util and functional tests (jnewbery)\n- - #10321 `e801084` Use FastRandomContext for all tests (sipa)\n- - #10524 `6c2d81f` [tests] Remove printf(...) (practicalswift)\n- - #10547 `71ab6e5` [tests] Use FastRandomContext instead of boost::random::{mt19937,uniform_int_distribution} (practicalswift)\n- - #10551 `6702617` [Tests] Wallet encryption functional tests (achow101)\n- - #10555 `643fa0b` [tests] various improvements to zmq_test.py (jnewbery)\n- - #10533 `d083bd9` [tests] Use cookie auth instead of rpcuser and rpcpassword (achow101)\n- - #10632 `c68a9a6` qa: Add stopatheight test (MarcoFalke)\n- - #10636 `4bc853b` [qa] util: Check return code after closing bitcoind proc (MarcoFalke)\n- - #10662 `e0a7801` Initialize randomness in benchmarks (achow101)\n- - #10612 `7c87a9c` The young person's guide to the test_framework (jnewbery)\n- - #10659 `acb1153` [qa] blockchain: Pass on closed connection during generate call (MarcoFalke)\n- - #10690 `416af3e` [qa] Bugfix: allow overriding extra_args in ComparisonTestFramework (sdaftuar)\n- - #10556 `65cc7aa` Move stop/start functions from utils.py into BitcoinTestFramework (jnewbery)\n- - #10704 `dd07f47` [tests] nits in dbcrash.py (jnewbery)\n- - #10743 `be82498` [test] don't run dbcrash.py on Travis (jnewbery)\n- - #10761 `d3b5870` [tests] fix replace_by_fee.py (jnewbery)\n- - #10759 `1d4805c` Fix multi_rpc test for hosts that dont default to utf8 (TheBlueMatt)\n- - #10190 `e4f226a` [tests] mining functional tests (including regression test for submitblock) (jnewbery)\n- - #10739 `1fc783f` test: Move variable `state` down where it is used (paveljanik)\n- - #9980 `fee0d80` Fix mem access violation merkleblock (Christewart)\n- - #10893 `0c173a1` [QA] Avoid running multiwallet.py twice (jonasschnelli)\n- - #10927 `9d5e8f9` test: Make sure wallet.backup is created in temp path (laanwj)\n- - #10899 `f29d5db` [test] Qt: Use _putenv_s instead of setenv on Windows builds (brianmcmichael)\n- - #10912 `5c8eb79` [tests] Fix incorrect memory_cleanse(\u2026) call in crypto_tests.cpp (practicalswift)\n- - #11001 `fa8a063` [tests] Test disconnecting unsupported service bits logic (jnewbery)\n- - #10695 `929fd72` [qa] Rewrite BIP65/BIP66 functional tests (sdaftuar)\n- - #10963 `ecd2135` [bench] Restore format state of cout after printing with std::fixed/setprecision (practicalswift)\n- - #11025 `e5d26e4` qa: Fix inv race in example_test (MarcoFalke)\n- - #10765 `2c811e0` Tests: address placement should be deterministic by default (ReneNyffenegger)\n- - #11000 `ac016e1` test: Add resendwallettransactions functional tests (promag)\n- - #11032 `aeb3175` [qa] Fix block message processing error in sendheaders.py (sdaftuar)\n- - #10105 `0b9fb68` [tests] fixup - make all Travis test runs quiet, non just cron job runs (jnewbery)\n- - #10222 `6ce7337` [tests] test_runner - check unicode (jnewbery)\n- - #10327 `35da2ae` [tests] remove import-abort-rescan.py (jnewbery)\n- - #11023 `bf74d37` [tests] Add option to attach a python debugger if functional test fails (jnewbery)\n- - #10565 `8c2098a` [coverage] Remove subtrees and benchmarks from coverage report (achow101)\n\n### Miscellaneous\n- - #9871 `be8ba2c` Add a tree sha512 hash to merge commits (sipa)\n- - #9821 `d19d45a` util: Specific GetOSRandom for Linux/FreeBSD/OpenBSD (laanwj)\n- - #9903 `ba80a68` Docs: add details to -rpcclienttimeout doc (ian-kelling)\n- - #9910 `53c300f` Docs: correct and elaborate -rpcbind doc (ian-kelling)\n- - #9905 `01b7cda` [contrib] gh-merge: Move second sha512 check to the end (MarcoFalke)\n- - #9880 `4df8213` Verify Tree-SHA512s in merge commits, enforce sigs are not SHA1 (TheBlueMatt)\n- - #9932 `00c13ea` Fix verify-commits on travis and always check top commit's tree (TheBlueMatt)\n- - #9952 `6996e06` Add historical release notes for 0.14.0 (laanwj)\n- - #9940 `fa99663` Fix verify-commits on OSX, update for new bad Tree-SHA512, point travis to different keyservers (TheBlueMatt)\n- - #9963 `8040ae6` util: Properly handle errors during log message formatting (laanwj)\n- - #9984 `cce056d` devtools: Make github-merge compute SHA512 from git, instead of worktree (laanwj)\n- - #9995 `8bcf934` [doc] clarify blockchain size and pruning (askmike)\n- - #9734 `0c17afc` Add updating of chainTxData to release process (sipa)\n- - #10063 `530fcbd` add missing spaces so that markdown recognizes headline (flack)\n- - #10085 `db1ae54` Docs: remove 'noconnect' option (jlopp)\n- - #10090 `8e4f7e7` Update bitcoin.conf with example for pruning (coinables)\n- - #9424 `1a5aaab` Change LogAcceptCategory to use uint32_t rather than sets of strings (gmaxwell)\n- - #10036 `fbf36ca` Fix init README format to render correctly on github (jlopp)\n- - #10058 `a2cd0b0` No need to use OpenSSL malloc/free (tjps)\n- - #10123 `471ed00` Allow debug logs to be excluded from specified component (jnewbery)\n- - #10104 `fadf078` linearize script: Option to use RPC cookie (achow101)\n- - #10162 `a3a2160` [trivial] Log calls to getblocktemplate (jnewbery)\n- - #10155 `928695b` build: Deduplicate version numbers (laanwj)\n- - #10211 `a86255b` [doc] Contributor fixes & new \"finding reviewers\" section (kallewoof)\n- - #10250 `1428f30` Fix some empty vector references (sipa)\n- - #10270 `95f5e44` Remove Clang workaround for Boost 1.46 (fanquake)\n- - #10263 `cb007e4` Trivial: fix fee estimate write error log message (CryptAxe)\n- - #9670 `bd9ec0e` contrib: github-merge improvements (laanwj)\n- - #10260 `1d75597` [doc] Minor corrections to osx dependencies (fanquake)\n- - #10189 `750c5a5` devtools/net: add a verifier for scriptable changes. Use it to make CNode::id private (theuni)\n- - #10322 `bc64b5a` Use hardware timestamps in RNG seeding (sipa)\n- - #10381 `7f2b9e0` Shadowing warnings are not enabled by default, update doc accordingly (paveljanik)\n- - #10380 `b6ee855` [doc] Removing comments about dirty entries on txmempool (madeo)\n- - #10383 `d0c37ee` [logging] log system time and mock time (jnewbery)\n- - #10404 `b45a52a` doc: Add logging to FinalizeNode() (sdaftuar)\n- - #10388 `526e839` Output line to debug.log when IsInitialBlockDownload latches to false (morcos)\n- - #10372 `15254e9` Add perf counter data to GetStrongRandBytes state in scheduler (TheBlueMatt)\n- - #10461 `55b72f3` Update style guide (sipa)\n- - #10486 `10e8c0a` devtools: Retry after signing fails in github-merge (laanwj)\n- - #10447 `f259263` Make bitcoind invalid argument error message specific (laanwj)\n- - #10495 `6a38b79` contrib: Update location of seeds.txt (laanwj)\n- - #10469 `b6b150b` Fixing typo in rpcdump.cpp help message (keystrike)\n- - #10451 `27b9931` contrib/init/bitcoind.openrcconf: Don't disable wallet by default (luke-jr)\n- - #10323 `00d3692` Update to latest libsecp256k1 master (sipa)\n- - #10422 `cec9e1e` Fix timestamp in fee estimate debug message (morcos)\n- - #10566 `5d034ee` [docs] Use the \"domain name setup\" image (previously unused) in the gitian docs (practicalswift)\n- - #10534 `a514ac3` Clarify prevector::erase and avoid swap-to-clear (sipa)\n- - #10575 `22ec768` Header include guideline (sipa)\n- - #10480 `fbf5d3b` Improve commit-check-script.sh (sipa)\n- - #10502 `1ad3d4e` scripted-diff: Remove BOOST_FOREACH, Q_FOREACH and PAIRTYPE (jtimon)\n- - #10377 `b63be2c` Use rdrand as entropy source on supported platforms (sipa)\n- - #9895 `228c319` Turn TryCreateDirectory() into TryCreateDirectories() (benma)\n- - #10602 `d76e84a` Make clang-format use C++11 features (e.g. A<A<int>> instead of A<A<int> >) (practicalswift)\n- - #10623 `c38f540` doc: Add 0.14.2 release notes (MarcoFalke)\n- - #10276 `b750b33` contrib/verifybinaries: allow filtering by platform (knocte)\n- - #10248 `01c4b14` Rewrite addrdb with less duplication using CHashVerifier (sipa)\n- - #10577 `232508f` Add an explanation of quickly hashing onto a non-power of two range (gmaxwell)\n- - #10608 `eee398f` Add a comment explaining the use of MAX_BLOCK_BASE_SIZE (gmaxwell)\n- - #10728 `7397af9` fix typo in help text for removeprunedfunds (AkioNak)\n- - #10193 `6dbcc74` scripted-diff: Remove #include <boost/foreach.hpp> (jtimon)\n- - #10676 `379aed0` document script-based return fields for validateaddress (instagibbs)\n- - #10651 `cef4b5c` Verify binaries from bitcoincore.org and bitcoin.org (TheBlueMatt)\n- - #10786 `ca4c545` Add PR description to merge commit in github-merge.py (sipa)\n- - #10812 `c5904e8` [utils] Allow bitcoin-cli's -rpcconnect option to be used with square brackets (jnewbery)\n- - #10842 `3895e25` Fix incorrect Doxygen tag (@ince \u2192 @since). Doxygen parameter name matching (practicalswift)\n- - #10681 `df0793f` add gdb attach process to test README (instagibbs)\n- - #10789 `1124328` Punctuation/grammer fixes in rpcwallet.cpp (stevendlander)\n- - #10655 `78f307b` Properly document target_confirmations in listsinceblock (RHavar)\n- - #10917 `5c003cb` developer-notes: add reference to snake_case and PascalCase (benma)\n- - #11003 `4b5a7ce` Docs: Capitalize bullet points in CONTRIBUTING guide (eklitzke)\n- - #10968 `98aa3f6` Add instructions for parallel gitian builds (coblee)\n- - #11076 `1c4b9b3` 0.15 release-notes nits: fix redundancy, remove accidental parenthesis & fix range style (practicalswift)\n- - #11090 `8f0121c` Update contributor names in release-notes.md (Derek701)\n- - #11056 `cbdd338` disable jni in builds (instagibbs)\n- - #11080 `2b59cfb` doc: Update build-openbsd for 6.1 (laanwj)\n- - #11119 `0a6af47` [doc] build-windows: Mention that only trusty works (MarcoFalke)\n- - #11108 `e8ad101` Changing -txindex requires -reindex, not -reindex-chainstate (TheBlueMatt)\n- - #9792 `342b9bc` FastRandomContext improvements and switch to ChaCha20 (sipa)\n- - #9505 `67ed40e` Prevector Quick Destruct (JeremyRubin)\n- - #10820 `ef37f20` Use cpuid intrinsics instead of asm code (sipa)\n- - #9999 `a328904` [LevelDB] Plug leveldb logs to bitcoin logs (NicolasDorier)\n- - #9693 `c5e9e42` Prevent integer overflow in ReadVarInt (gmaxwell)\n- - #10129 `351d0ad` scheduler: fix sub-second precision with boost < 1.50 (theuni)\n- - #10153 `fade788` logging: Fix off-by-one for shrinkdebugfile default (MarcoFalke)\n- - #10305 `c45da32` Fix potential NPD introduced in b297426c (TheBlueMatt)\n- - #10338 `daf3e7d` Maintain state across GetStrongRandBytes calls (sipa)\n- - #10544 `a4fe077` Update to LevelDB 1.20 (sipa)\n- - #10614 `cafe24f` random: fix crash on some 64bit platforms (theuni)\n- - #10714 `2a09a38` Avoid printing incorrect block indexing time due to uninitialized variable (practicalswift)\n- - #10837 `8bc6d1f` Fix resource leak on error in GetDevURandom (corebob)\n- - #10832 `89bb036` init: Factor out AppInitLockDataDirectory and fix startup core dump issue (laanwj)\n- - #10914 `b995a37` Add missing lock in CScheduler::AreThreadsServicingQueue() (TheBlueMatt)\n- - #10958 `659c096` Update to latest Bitcoin patches for LevelDB (sipa)\n- - #10919 `c1c671f` Fix more init bugs (TheBlueMatt)\n\nCredits\n=======\n\nThanks to everyone who directly contributed to this release:\n\n- - \u30ed\u30cf\u30f3 \u30c0\u30eb\n- - Ahmad Kazi\n- - aideca\n- - Akio Nakamura\n- - Alex Morcos\n- - Allan Doensen\n- - Andres G. Aragoneses\n- - Andrew Chow\n- - Angel Leon\n- - Awemany\n- - Bob McElrath\n- - Brian McMichael\n- - BtcDrak\n- - Charlie Lee\n- - Chris Gavin\n- - Chris Stewart\n- - Cory Fields\n- - CryptAxe\n- - Dag Robole\n- - Daniel Aleksandersen\n- - Daniel Cousens\n- - darksh1ne\n- - Dimitris Tsapakidis\n- - Eric Shaw\n- - Evan Klitzke\n- - fanquake\n- - Felix Weis\n- - flack\n- - Guido Vranken\n- - Greg Griffith\n- - Gregory Maxwell\n- - Gregory Sanders\n- - Ian Kelling\n- - Jack Grigg\n- - James Evans\n- - James Hilliard\n- - Jameson Lopp\n- - Jeremy Rubin\n- - Jimmy Song\n- - Jo\u00e3o Barbosa\n- - Johnathan Corgan\n- - John Newbery\n- - Jonas Schnelli\n- - Jorge Tim\u00f3n\n- - Karl-Johan Alm\n- - kewde\n- - KibbledJiveElkZoo\n- - Kirit Thadaka\n- - kobake\n- - Kyle Honeycutt\n- - Lawrence Nahum\n- - Luke Dashjr\n- - Marco Falke\n- - Marcos Mayorga\n- - Marijn Stollenga\n- - Mario Dian\n- - Mark Friedenbach\n- - Marko Bencun\n- - Masahiko Hyuga\n- - Matt Corallo\n- - Matthew Zipkin\n- - Matthias Grundmann\n- - Michael Goldstein\n- - Michael Rotarius\n- - Mikerah\n- - Mike van Rossum\n- - Mitchell Cash\n- - Nicolas Dorier\n- - Patrick Strateman\n- - Pavel Jan\u00edk\n- - Pavlos Antoniou\n- - Pavol Rusnak\n- - Pedro Branco\n- - Peter Todd\n- - Pieter Wuille\n- - practicalswift\n- - Ren\u00e9 Nyffenegger\n- - Ricardo Velhote\n- - romanornr\n- - Russell Yanofsky\n- - Rusty Russell\n- - Ryan Havar\n- - shaolinfry\n- - Shigeya Suzuki\n- - Simone Madeo\n- - Spencer Lievens\n- - Steven D. Lander\n- - Suhas Daftuar\n- - Takashi Mitsuta\n- - Thomas Snider\n- - Timothy Redaelli\n- - tintinweb\n- - tnaka\n- - Warren Togami\n- - Wladimir J. van der Laan\n\nAs well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).\n\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQEcBAEBCgAGBQJZuoHVAAoJEB5K7WKYbNJdQRoH/2EAaO/tuR/TI8UGRrBYQzUy\nWkEnctcx4XjrTS0FPssxrYKsndHaksgmJObpgUnzdiKbytRRQH/8A0W5izVE4Ojv\nCzUZOX7MTSwyfzPFQRvSCzRANY0bSDgvT+A1TBRmkce/43UDZZma82mMl2vz8wL5\nczKryyFsNzrB2qn6juRZQlUcmGGBZ298YG8SPx/aobIY/9DKDEkPCNnBe8d7XdT0\noAQ52pLmZ56E+QYkn0LYdc32dd4xizpQy7WIJgSQY4r54HWmEFY9ZE21aQjwMOET\ntReNzae4mXh3T0Yja3DgDkQrbgqNuYRtnLWgfmYinwFo+JN5ujDZwNpcP5jnBa0=\n=4llb\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.15.0 released",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Wladimir J. van der Laan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 64688
        }
    },
    {
        "title": "[bitcoin-dev] Fw: Re: Sidechain headers on mainchain (unification of drivechains and spv proofs)",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2017-09-15T04:34:12",
                "message_text_only": "Good morning,\n\nI'm re-sending this message below as it appears to have gotten lost before it reached cc: bitcoin-dev.\n\nPaul even replied to it and the reply reached on-list, so I'm re-sending it as others might have gotten confused about the discussion.\n\nSo far I've come to realize that sidechain-headers-on-mainchain/SHOM/SHM/driveproofs creates a very weak peg, and that only sidechain-only miners can take advantage of this weak peg.  This is because, the fee paid by sidechain-only miners to mainchain miners will approach TRANSFERLIMIT / 288 to protect against theft, and then sidechain miners will be unable to replenish their maincoin stock (to pay for the blind-merge-mine) if they do not transfer *only* their sidecoins earned.\n\nRegards,\nZmnSCPxj\n\n-------- Original Message --------\nSubject: Re: [bitcoin-dev] Sidechain headers on mainchain (unification of drivechains and spv proofs)\nLocal Time: September 8, 2017 10:56 PM\nUTC Time: September 8, 2017 2:56 PM\nFrom: ZmnSCPxj at protonmail.com\nTo: Chris Stewart <chris at suredbits.com>, CryptAxe <cryptaxe at gmail.com>, Paul Sztorc <truthcoin at gmail.com>\nBitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>\n\nGood morning,\n\nChris mentioned the use of OP_WITHDRAWPROOFVERIFY.  I've come to realize\nthat this is actually superior to use OP_WITHDRAWPROOFVERIFY with a\nsidechain-headers-on-mainchain approach.\n\nBriefly, a payment to OP_WITHDRAWPROOFVERIFY is an instruction to transfer\nvalue from the mainchain to a sidechain.  Thus, a payment to\nOP_WITHDRAWPROOFVERIFY includes the sidechain to pay to, and a commitment\nto a sidechain address (or whatever is the equivalent to a sidechain\naddress).\n\nVarious OP_WITHDRAWPROOFVERIFY explanations exist.  Most of them include\nOP_REORGPROOFVERIFY.  With sidechain-headers-on-mainchain, however, there is\nno need for reorg proofs.  This is because, the mainchain can see, in real\ntime, which branch of the sidechain is getting extended.  Thus if someone\nattempts to defraud a sidechain by forking the sidechain to an invalid\nstate, sidechainers can immediately detect this on the mainchain and\nimmediately act to prevent the invalid fork from being advanced.  After\nall, a reorg proof is really just an SPV proof that is longer than some\nprevious SPV proof, that shows that the previous SPV proof is incorrect,\nby showing that the block at the specified height of the WT is not present\non a longer SPV proof.\n\nSince sidechain-headers-on-mainchain implies merge mining of sidechains,\nwith no option to have independent proof-of-work of sidechains, the\nsidechain's entire history is recorded on the mainchain, visible to all\nmainchain nodes.\n\n--\n\nAn advantage of sidechain-headers-on-mainchain is a side-to-side peg without\npassing through the mainchain.\nThat is, a 2-way peg between any two chains, whether side or main.\n\nSidechains supporting side-to-side transfer would require supporting\nOP_WITHDRAWPROOFVERIFY, but not any of the other parts of sidechains.\n\nWe must consider a WT format (withdrawal transaction) that is compatible\nwith an OP_WITHDRAWPROOFVERIFY Bitcoin transaction.\n\n***That is, a lockbox UTXO on one chain is a WT on another chain.***\n\nSidechains need not follow the mainchain format for its normal\ntransactions, only for WT transactions that move coins across chains.\n\nFor this, mainchain should also have its own \"sidechain ID\".  Perhaps a\nsidechain ID of 0 would be appropriate for mainchain, as its status as\nmainchain.\n\nSuppose we have two sidechains, Ess and Tee, both of which support\nside-to-side pegs.\n\nAn Ess fullnode is a Bitcoin fullnode, but an Ess fullnode is not\nnecessarily a Tee fullnode, and vice versa.\n\nA lockbox redemption in sidechain-headers-on-mainchain is simply a spend of\na lockbox, pointing to the sidechain header containing WT, the merkle tree\npath to the WT transaction from the h* commitment of the header, the output\nwhich locks, and so on as per usual OP_WITHDRAWPROOFVERIFY.\n\nThen a sidechain can create tokens from nothing, that are locked in a\nOP_WITHDRAWPROOFVERIFY lockbox; this is the only way to create sidecoin.\nWhen transferring into a sidechain from mainchain, or anywhere, the\nsidechain either creates tokens locked into OP_WITHDRAWPROOFVERIFY, or\nlooks for an existing UTXO with OP_WITHDRAWPROOFVERIFY from the source\nchain and spends them (the latter is preferred as it is fewer\ntransactions and less space on the sideblock, reducing sidechain fees).\n\nOP_WITHDRAWPROOFVERIFY on a sidechain would query the mainchain fullnodes.\nWhatever rules allow lockbox unlocking on mainchain, will also be the same\nrules that allow lockbox unlocking on sidechains.\nA mainchain RPC can even be made to simplify sidechain verification of\nside-to-side pegs, and to ensure that sidechains follow the same consensus\nrules for OP_WITHDRAWPROOFVERIFY.\n\nSo if we want transfer TeeCoin to EssCoin, we spend into a\nOP_WITHDRAWPROOFVERIFY lockbox on Teechain pointing to Esschain (i.e. a\nTee->Ess lockbox).  This lockbox is itself a WT from the point of view of\nEsschain.  On Esschain, we look for an existing Ess->Tee lockbox, or\ncreate a Ess->Tee lockbox of our own for a EssCoin fee.  Then we create a\nspend of the Ess->Tee lockbox on Esschain, wait until spending is\npossible, and then post that transaction on Esschain.\n\nAgain, with sidechain-headers-on-mainchain, reorg proofs are unnecessary,\nsince any invalid chain should be quickly buried by a valid chain,\nunless the economic majority decides that a sidechain is not worth\nprotecting.\n\n--\n\nAll is not well, however.  Remember, on a sidechain, we can create new\nsidecoin for free, provided they are in a lockbox.  Unlocking that\nlockbox would require a valid WT on the chain that the lockbox is\ndedicated to.  However, a lockbox on one chain is a WT on the other\nchain.  We can create a free lockbox on Ess, then use that lockbox as\na WT on Tee, inflating TeeCoin.\n\nInstead, we add an additional parameter, wtFlag, to\nOP_WITHDRAWPROOFVERIFY.\nThis parameter is ignored by OP_WITHDRAWPROOFVERIFY opcode.\n\nHowever, this parameter is used to determine if it is a WT.  Sidechain\nconsensus should require that freely-created lockboxes set this\nparameter to 0, so that a side block that creates free lockboxes where\nthis parameter is non-zero is an invalid side block.  Then a sidechain\nwill only treat a lockbox on another chain as a WT if the wtFlag\nparameter is nonzero.  This way, freely-created lockboxes are not\nvalid WT.  Valid WT must lock actual, already unlocked coins, not\ncreate new locked coins.\n\nOn Bitcoin, of course, this parameter must always be nonzero, since\nfreely-created lockboxes are not allowed on mainchain, as asset\nissuance on mainchain is already fixed.\n\n--\n\nLet us now flesh out how WT and lockboxes look like.  As we mentioned, a\nlockbox on one chain is a WT on the destination chain.  Or to be more\nprecise, what a destination chain sees as a WT, is a lockbox on the source\nchain.\n\nThus, a lockbox is a Bitcoin-formatted transaction output paying to the\nscriptPubKey:\n\n  <sidechain address commitment> <sidechain ID> OP_WITHDRAWPROOFVERIFY\n\n(assuming a softfork, additional OP_DROP operations may occur after\nOP_WITHDRAWPROOFVERIFY)\n\nSuppose the above lockbox is paid to in the Bitcoin mainchain, with the\nsidechain ID being the ID of Esschain.  This is itself a WT transaction\nfrom the point of view of Esschain, on the principle that a lockbox on\none chain is a WT on another chain.\n\nAssuming Esschain is a brand-new sidechain, it has no EssCoins yet.  The\nsidechain allows the arbitrary creation of sidecoin provided the new\nsidecoins are in a lockbox whose sidechain address commitment is 0.  So\nin Esschain, we create the same coins on a UTXO paying to the\nscriptPubKey:\n\n  0 0 OP_WITHDRAWPROOFVERIFY\n\nThe first 0 is the sidechain address commitment, which is 0 since this\noutput was not created by transferring to a sidechain; we\nreuse the sidechain address commitment as the wtFlag.  The\nsecond 0 is the mainchain's ID.  The above is a lockbox from the point of\nview of Esschain.  It is not a WT on mainchain, however, because the\nsidechain address commitment is 0, which we use also as the wtFlag\nparameter.\n\nNow, how does a main-to-side peg work?  After creating the above output on\nEsschain, we now spend the output with the below scriptSig:\n\n  <mainchain output ID> <mainchain WT transaction> <merkle path to WT transaction> <mainchain block hash>\n\nOn Esschain, OP_WITHDRAWPROOFVERIFY then verifies that the mainchain block\nhash is a valid past block of the mainchain, then locates the mainchain\nheader.  It then checks the merkle tree path to the mainchain WT\ntransaction,\nconfirming that the mainchain contains that transaction, and confirms that\nthe\nindicated output is in fact, a payment to an OP_WITHDRAWPROOFVERIFY, which\npushes the Esschain ID, and with a nonzero sidechain address commitment.\n\n(Esschain also needs to ensure that a single WT is not used to unlock\nmultiple lockboxes on Esschain; the easiest way is to add it to a set,\nbut this set cannot be pruned; other ways of ensuring only a WT is only\nused to unlock once might be designed)\n\nOn Esschain, the sidechain does one final check: the transaction that spends\nan OP_WITHDRAWPROOFVERIFY must have an output that pays to the sidechain\naddress committed to, and that output's value must be the same as the value\nlocked in the mainchain.\n\n(for now, I think all lockboxes must have the same fixed amount, for\nsimplicity)\n\nNow suppose we want to convert back our EssCoin to Bitcoin.  We create a\nlockbox on Esschain, paying to the below:\n\n  <bitcoin P2SH address> 0 OP_WITHDRAWPROOFVERIFY\n\nThe bitcoin P2SH address is mainchain address commitment; for simplicity\nwe just use P2SH on mainchain as it can encode any address.  The 0 is the\nmainchain ID.  The above Esschain lockbox is itself a WT from Esschain to\nmainchain.\n\nThen, we look for an unspent lockbox on Esschain whose sidechain ID is the\nEsschain ID.  Note that we can select any lockbox with the correct\nsidechain ID, regardless of the sidechain address commitment it may have.\n\nLocating an appropriate mainchain lockbox for Esschain coins, we then\nprovide the below scriptSig, paying out to the bitcoin P2SH address we\nselected:\n\n  <esschain output ID> <esschain WT tx> <merkle path to WT tx> <esschain block header hash>\n\nOn mainchain, we check that the indicated sidechain block header hash is a\nblock header on the longest chain of Esschain.  We check it has sufficient\ndepth.  Then we check if the merkle path to the WT tx is correct and goes\nto esschain WT tx.  Finally, we check the indicated output ID, and check that\nit is indeed an Esschain lockbox dedicated to mainchain.  Finally, we check\nthat the transaction has an output that spends the lockbox amount to the\nspecified bitcoin P2SH address.\n\n(similarly mainchain nees to ensure that the Esschain WT is only used\nonce)\n\nThe key insight here is that side-to-side pegs are just like side-to-main\npegs.  Suppose instead we want to transfer our coins from Esscoin to\nTeecoin.  We would instead pay to the following lockbox on Esschain:\n\n  <teecoin address commitment> <teechain ID> OP_WITHDRAWPROOFVERIFY\n\nThen a Teechain transaction spending some Tee->Ess lockbox (or a fresh\nlockbox if there are no Tee->Ess lockboxes on Teechain) is created.\nWe proceed as if it were a side-to-main peg, except it is a peg to\nTeechain, either creating or unlocking TeeCoins.  Indeed, mainchain\nfullnodes may even provide an RPC for checking OP_WITHDRAWPROOFVERIFY,\nso as to reduce risk that a sidechain breaks consensus due to buggy\ncode.\n\n--\n\nAll is still not well with side-to-side pegs, however.\n\nSuppose the economic majority decides that Esschain must die.  Perhaps it\nhas some irrecoverable security bug, perhaps it adds features that allow\nEsschain fullnodes to kill baby seals, perhaps a successful theft of\nEsschain lockboxes was performed and Esscoins are now functionally\nworthless.  Killing a sidechain is done by bribing miners to put invalid\nvalues into h*, and thus stealing Bitcoin->Ess lockboxes.\n\nIf Esschain dies, however, and the economic majority is not prepared to keep\nEsschain dead, it is possible to unlock Tee->Ess lockboxes on Teechain.\nUnlocking existing Tee->Ess lockboxes on Teechain is safe, since they\nrepresent coins that were locked into Bitcoin->Tee lockboxes.  However,\nit is still possible to create \"free\" Tee->Ess lockboxes on Teechain, then\nprovide an invalid Tee->Ess WT lockbox on the now-moribund Esschain to\nunlock the free Tee->Ess lockbox on Teechain, inflating TeeCoin value.\nThus in the presence of side-to-side pegs, the death of even one sidechain\nrepresents the death of every other sidechain!\n\nThus, to properly kill Esschain, the economic majority should spam the\nEsschain headers slot with a fixed value, say 0, forever.  This makes it\nvery difficult to create a Tee->Ess WT lockbox on Esschain, as you would\nnow be able to reverse a one-way hash function.\n\nAlternatively, Teechain can softfork so that Tee->Ess lockboxes are no\nlonger creatable or spendable.  However, the death of Esschain requires\nthat all other sidechains, including Youchain, Veechain, Dubyachain, and\nso on, to softfork similarly.\n\nPerhaps both can be done: first the economic majority wanting to kill\nEsschain starts spamming it with invalid spends of Bitcoin->Ess lockboxes,\nthen when all Bitcoin->Ess lockboxes have been stolen, spam it with 0s\nuntil all other sidechains have banned free Ess lockboxes on their chains.\nThen, the economic majority can leave Esschain dead, and a later softfork\nof mainchain prevents Esschain from being extended and allows mainchain\nfullnodes to prune Esschain headers.\n\n--\n\nThieves will still have the same difficulty stealing from sidechains, but\nnow their payoff is increased.  If a thief wants to steal Esschain\nlockboxes, then it is possible to pack an invalid Esschain block full of\ninvalid WT to other chains.  Even chains that don't have lockboxes to\nEsschain can create lockboxes to Esschain for free.  Thus, instead of\nstealing only one lockbox at a time on mainchain, the thief can steal one\nlockbox on mainchain, and on every sidechain that supports side-to-side\npegs, at a time.  The risk/reward ratio may shift drastically in that case.\n\nHowever, this does mean that users of one chain must pay attention to\nattacks on other chains, not just the chain they use.  If Teechain has no\nside-to-side pegs, then Teechain users will not care if Esschain is under\nattack.  But if side-to-side pegs are allowed on Teechain, then Teechain\nusers must also care about Esschain's health, as well as the health of\nevery other sidechain in existence.  Mainchain is protected since free\nlockboxes are not creatable on mainchain.  Each sidechain is not; thus\nthe user of any sidechain must also stand by users of every other\nsidechain, or else they all fall apart.  Of course, this could more\nsimply lead to \"I will not use Teechain even if it would be useful to me,\nbecause if I use Teechain, I have to care about Esschain and Youchain and\nwhatever.\"\n\n--\n\nSide-to-side pegs are useful to allow better liquidity and provide\narbitrage quickly between sidechains, without having to pass through\nmainchain.  Otherwise, Esscoin may be valued slightly lower than Bitcoin,\nthen Teecoin valued slightly higher than Bitcoin, creating a larger\ndifference between Esscoin and Teecoin values than what a full\nside-to-side peg could support.  2-way pegs from mainchain\nto sidechain stabilize sidecoin with respect to maincoin.  Side-to-side\npegs stabilize all sidecoins to all other sidecoins.\n\nSide-to-side pegs are enabled implicitly by sidechain-headers-on-mainchain,\nas all sidechain fullnodes must necessarily be mainchain fullnodes, and\nany mainchain fullnode can judge the validity of any WT from any sidechain\nwithout a miner voting period.\n\nSide-to-side pegs are a generalization of main-to-side and side-to-main\npegs.  A sidechain can simply implement OP_WITHDRAWPROOFVERIFY and allow\nfree lockboxes, and that is sufficient for the sidechain to support\nimports of bitcoin from mainchain and from any other sidechain.\n\nSide-to-side pegs seem to imply that all pegs must have the same bitcoin\nvalue transferred.  What that value must be, is something that may be\ndebated endlessly.\n\nA side-to-side peg is a cut-through of a side-to-main peg from\none sidechain into a main-to-side peg into another sidechain.  If a\nwithdrawal from side-to-main peg would be accepted by mainchain, then\nanother sidechain could, in principle, accept a proof that would\nauthorize a side-to-main peg directly as a side-to-side peg.\n\nSide-to-side pegs make attacks on sidechains more lucrative, as it\nbecomes possible to print sidecoins by successfully attacking a\ndifferent sidechain.\n\nDrivechain cannot implement side-to-side pegs, as WT validity is\nvoted on by mainchain miners, and asking mainchain miners about\nside-to-side pegs requires mainchain miners to be aware of both\nsidechains.  Sidechain-headers-on-mainchain publishes SPV proofs\ncontinuously to the mainchain, and since any sidechain fullnode is\nalso a mainchain fullnode (since sidechains are mergemined), then\nevery sidechain fullnode is automatically capable of accessing\nand verifying SPV proofs for every other sidechain.\n\nHowever, the pegging here seems less flexible than the pegging\nsupported by drivechain.  Drivechain lets pegs be any size, with\nminer voting being the basis of knowing how much money is owned\nby whom.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170915/03659763/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Fw: Re: Sidechain headers on mainchain (unification of drivechains and spv proofs)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 17670
        }
    },
    {
        "title": "[bitcoin-dev] proposal: extend WIF format for segwit",
        "thread_messages": [
            {
                "author": "Thomas Voegtlin",
                "date": "2017-09-15T08:55:37",
                "message_text_only": "The Wallet Import Format (WIF) currently appends a 0x01 byte after the\nraw private key, when that key needs to be used in conjunction with a\ncompressed public key. This allows wallets to associate a single Bitcoin\naddress to a WIF key.\n\nIt would be useful to extend the semantics of that byte, to signal for\nsegwit scripts, because these scripts result in different addresses.\nThat way, a WIF private key can still be associated to a single Bitcoin\naddress.\n\nWhat WIF currently does is:\n\nNothing -> uncompressed pubkey\n0x01    -> compressed pubkeys, non-segwit (can be used in P2PKH or P2SH)\n\nWe could extend it as follows:\n\n0x02 -> segwit script embedded in P2SH (P2WPKH or P2WSH)\n0x03 -> native segwit script (P2WKH or P2WSH)\n\n\nNote 1: This is similar to my {x,y,z}{pub,prv} proposal for bip32\nextended keys. (see other thread)\n\nNote 2: It is probably not useful to use distinct bytes for P2WKH and\nP2WSH, because the P2SH script is not known anyway. We did not do it for\nnon-segwit addresses, I guess we should keep it the way it is.\n\nNote 3: we could also use a bech32 format for the private key, if it is\ngoing to be used with a bech32 address. I am not sure if such a format\nhas been proposed already.\n\nNote 4: my proposal will not result in a user visible change at the\nbeginning of the string, like we have for compressed/uncompressed. This\ncould be improved."
            },
            {
                "author": "Pieter Wuille",
                "date": "2017-09-17T02:29:41",
                "message_text_only": "On Sep 15, 2017 01:56, \"Thomas Voegtlin via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\nNote 3: we could also use a bech32 format for the private key, if it is\ngoing to be used with a bech32 address. I am not sure if such a format\nhas been proposed already.\n\n\nI've been working on an \"extended bech32\" format with 12 character checksum\nrather than 6, for private keys and other things that need stronger\nprotection. It would guarantee correcting 4 errors, where normal bech32 can\nonly detect (but not correct) 4.\n\nThe rationale is that in the case of an address, if an error is detected,\nyou can ask the receiver for a corrected version. As that option doesn't\nexist for private keys you want something stronger.\n\nThis has been a low-priority thing for me, though, and the computation work\nto find a good checksum is significant.\n\nCheers,\n\n-- \nPieter\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170916/e9b7ad89/attachment.html>"
            },
            {
                "author": "Thomas Voegtlin",
                "date": "2017-09-17T08:10:17",
                "message_text_only": "On 17.09.2017 04:29, Pieter Wuille wrote:\n> \n> This has been a low-priority thing for me, though, and the computation work\n> to find a good checksum is significant.\n> \n\nThanks for the info. I guess this means that a bech32 format for private\nkeys is not going to happen soon. Even if such a format was available,\nthe issue would remain for segwit-in-p2sh addresses, which use base58.\n\nThe ambiguity of the WIF format is currently holding me from releasing a\nsegwit-capable version of Electrum. I believe it is not acceptable to\nuse the current WIF format with segwit scripts; that would just create\ntechnological debt, forcing wallets to try all possible scripts. There\nis a good reason why WIF adds a 0x01 byte for compressed pubkeys; it\nmakes it unambiguous.\n\nI see only two options:\n 1. Disable private keys export in Electrum Segwit wallets, until a\ncommon WIF extension has been agreed on.\n 2. Define my own WIF extension for Electrum, and go ahead with it.\n\nDefining my own format does make sense for the xpub/xprv format, because\nElectrum users need to share master public keys across Electrum wallets.\nIt makes much less sense for WIF, though, because WIF is mostly used to\nimport/sweep keys from other wallets.\n\nI would love to know what other wallet developers are going to do,\nespecially Core. Are you going to export private keys used in segwit\nscripts in the current WIF format?"
            },
            {
                "author": "AJ West",
                "date": "2017-09-17T14:42:52",
                "message_text_only": "Hi I have a small interjection about the point on error correction (excuse\nme if it seems elementary). Isn't there an argument to be made where a\nwallet software should never attempt to figure out the 'correct' address,\nor in this case private key? I don't think it's crazy to suggest somebody\ncould import a slightly erroneous WIF, the software gracefully\nerror-corrects any problem, but then the user copies that error onward such\nas in their backup processes like a paper wallet. I always hate to advocate\nagainst a feature, I'm just worried too much error correcting removes the\nburden of exactitude and attention of the user (eg. \"I know I can have up\nto 4 errors\").\n\nI'm pretty sure I read those arguments somewhere in a documentation or\nissue tracker/forum post. Maybe I'm misunderstanding the bigger picture in\nthis particular case, but I was just reminded of that concept (even if it\nonly applies generally).\n\nThanks,\nAJ West\n\nOn Sun, Sep 17, 2017 at 4:10 AM, Thomas Voegtlin via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On 17.09.2017 04:29, Pieter Wuille wrote:\n> >\n> > This has been a low-priority thing for me, though, and the computation\n> work\n> > to find a good checksum is significant.\n> >\n>\n> Thanks for the info. I guess this means that a bech32 format for private\n> keys is not going to happen soon. Even if such a format was available,\n> the issue would remain for segwit-in-p2sh addresses, which use base58.\n>\n> The ambiguity of the WIF format is currently holding me from releasing a\n> segwit-capable version of Electrum. I believe it is not acceptable to\n> use the current WIF format with segwit scripts; that would just create\n> technological debt, forcing wallets to try all possible scripts. There\n> is a good reason why WIF adds a 0x01 byte for compressed pubkeys; it\n> makes it unambiguous.\n>\n> I see only two options:\n>  1. Disable private keys export in Electrum Segwit wallets, until a\n> common WIF extension has been agreed on.\n>  2. Define my own WIF extension for Electrum, and go ahead with it.\n>\n> Defining my own format does make sense for the xpub/xprv format, because\n> Electrum users need to share master public keys across Electrum wallets.\n> It makes much less sense for WIF, though, because WIF is mostly used to\n> import/sweep keys from other wallets.\n>\n> I would love to know what other wallet developers are going to do,\n> especially Core. Are you going to export private keys used in segwit\n> scripts in the current WIF format?\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170917/d9c8062b/attachment.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-09-17T15:36:48",
                "message_text_only": "Bech32 and WIF payload format are mostly orthogonal issues. You can design a new wallet import format now and later switch it to Bech32.\n\n> On Sep 17, 2017, at 7:42 AM, AJ West via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Hi I have a small interjection about the point on error correction (excuse me if it seems elementary). Isn't there an argument to be made where a wallet software should never attempt to figure out the 'correct' address, or in this case private key? I don't think it's crazy to suggest somebody could import a slightly erroneous WIF, the software gracefully error-corrects any problem, but then the user copies that error onward such as in their backup processes like a paper wallet. I always hate to advocate against a feature, I'm just worried too much error correcting removes the burden of exactitude and attention of the user (eg. \"I know I can have up to 4 errors\").\n> \n> I'm pretty sure I read those arguments somewhere in a documentation or issue tracker/forum post. Maybe I'm misunderstanding the bigger picture in this particular case, but I was just reminded of that concept (even if it only applies generally).\n> \n> Thanks,\n> AJ West\n> \n>> On Sun, Sep 17, 2017 at 4:10 AM, Thomas Voegtlin via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> On 17.09.2017 04:29, Pieter Wuille wrote:\n>> >\n>> > This has been a low-priority thing for me, though, and the computation work\n>> > to find a good checksum is significant.\n>> >\n>> \n>> Thanks for the info. I guess this means that a bech32 format for private\n>> keys is not going to happen soon. Even if such a format was available,\n>> the issue would remain for segwit-in-p2sh addresses, which use base58.\n>> \n>> The ambiguity of the WIF format is currently holding me from releasing a\n>> segwit-capable version of Electrum. I believe it is not acceptable to\n>> use the current WIF format with segwit scripts; that would just create\n>> technological debt, forcing wallets to try all possible scripts. There\n>> is a good reason why WIF adds a 0x01 byte for compressed pubkeys; it\n>> makes it unambiguous.\n>> \n>> I see only two options:\n>>  1. Disable private keys export in Electrum Segwit wallets, until a\n>> common WIF extension has been agreed on.\n>>  2. Define my own WIF extension for Electrum, and go ahead with it.\n>> \n>> Defining my own format does make sense for the xpub/xprv format, because\n>> Electrum users need to share master public keys across Electrum wallets.\n>> It makes much less sense for WIF, though, because WIF is mostly used to\n>> import/sweep keys from other wallets.\n>> \n>> I would love to know what other wallet developers are going to do,\n>> especially Core. Are you going to export private keys used in segwit\n>> scripts in the current WIF format?\n>> \n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170917/e911e5c6/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "proposal: extend WIF format for segwit",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Pieter Wuille",
                "AJ West",
                "Thomas Voegtlin",
                "Mark Friedenbach"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 10045
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Knots 0.15.0.knots20170914 released",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2017-09-15T18:04:58",
                "message_text_only": "Bitcoin Knots version *0.15.0.knots20170914* is now available from:\n\n  <https://bitcoinknots.org/files/0.15.x/0.15.0.knots20170914/>\n\nThis is a new major version release, including new features, various bugfixes\nand performance improvements, as well as updated translations.\n\nPlease report bugs using the issue tracker at GitHub:\n\n  <https://github.com/bitcoinknots/bitcoin/issues>\n\nHow to Upgrade\n==============\n\nIf you are running an older version, shut it down. Wait until it has completely\nshut down (which might take a few minutes for older versions), then run the \ninstaller (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)\nor `bitcoind`/`bitcoin-qt` (on Linux).\n\nThe first time you run version 0.15.0, your chainstate database will be converted to a\nnew format, which will take anywhere from a few minutes to half an hour,\ndepending on the speed of your machine.\n\nThe file format of `fee_estimates.dat` changed in version 0.15.0. Hence, a\ndowngrade from version 0.15.0 or upgrade to version 0.15.0 will cause all fee\nestimates to be discarded.\n\nNote that the block database format also changed in version 0.8.0 and there is no\nautomatic upgrade code from before version 0.8 to version 0.15.0. Upgrading\ndirectly from 0.7.x and earlier without redownloading the blockchain is not supported.\nHowever, as usual, old wallet versions are still supported.\n\nDowngrading warning\n-------------------\n\nThe chainstate database for this release is not compatible with previous\nreleases, so if you run 0.15 and then decide to switch back to any\nolder version, you will need to run the old release with the `-reindex-chainstate`\noption to rebuild the chainstate data structures in the old format.\n\nIf your node has pruning enabled, this will entail re-downloading and\nprocessing the entire blockchain.\n\nCompatibility\n==============\n\nBitcoin Knots is supported on multiple operating systems using the Linux kernel,\nmacOS 10.8+, and Windows Vista and later. Windows XP is not supported.\n\nBitcoin Knots should also work on most other Unix-like systems but is not\nfrequently tested on them.\n\nNotable changes\n===============\n\nPerformance Improvements\n------------------------\n\nVersion 0.15 contains a number of significant performance improvements, which make\nInitial Block Download, startup, transaction and block validation much faster:\n\n- The chainstate database (which is used for tracking UTXOs) has been changed\n  from a per-transaction model to a per-output model (See [PR 10195](https://github.com/bitcoin/bitcoin/pull/10195)). Advantages of this \nmodel\n  are that it:\n    - avoids the CPU overhead of deserializing and serializing the unused outputs;\n    - has more predictable memory usage;\n    - uses simpler code;\n    - is adaptable to various future cache flushing strategies.\n\n  As a result, validating the blockchain during Initial Block Download (IBD) and reindex\n  is ~30-40% faster, uses 10-20% less memory, and flushes to disk far less frequently.\n  The only downside is that the on-disk database is 15% larger. During the conversion from the previous format\n  a few extra gigabytes may be used.\n- Earlier versions experienced a spike in memory usage while flushing UTXO updates to disk.\n  As a result, only half of the available memory was actually used as cache, and the other half was\n  reserved to accommodate flushing. This is no longer the case (See [PR 10148](https://github.com/bitcoin/bitcoin/pull/10148)), and the \nentirety of\n  the available cache (see `-dbcache`) is now actually used as cache. This reduces the flushing\n  frequency by a factor 2 or more.\n- In previous versions, signature validation for transactions has been cached when the\n  transaction is accepted to the mempool. Version 0.15 extends this to cache the entire script\n  validity (See [PR 10192](https://github.com/bitcoin/bitcoin/pull/10192)). This means that if a transaction in a block has already been \naccepted to the\n  mempool, the scriptSig does not need to be re-evaluated. Empirical tests show that\n  this results in new block validation being 40-50% faster.\n- LevelDB has been upgraded to version 1.20 (See [PR 10544](https://github.com/bitcoin/bitcoin/pull/10544)). This version contains hardware \nacceleration for CRC\n  on architectures supporting SSE 4.2. As a result, synchronization and block validation are now faster.\n- SHA256 hashing has been optimized for architectures supporting SSE 4 (See [PR 10821](https://github.com/bitcoin/bitcoin/pull/10821)). \nSHA256 is around\n  50% faster on supported hardware, which results in around 5% faster IBD and block\n  validation. In version 0.15, SHA256 hardware optimization is disabled in release builds by\n  default, but can be enabled by using `--enable-experimental-asm` when building.\n- Refill of the keypool no longer flushes the wallet between each key which resulted in a ~20x speedup in creating a new wallet. Part of \nthis speedup was used to increase the default keypool to 1000 keys to make recovery more robust. (See [PR 10831]\n(https://github.com/bitcoin/bitcoin/pull/10831)).\n\nFee Estimation Improvements\n---------------------------\n\nFee estimation has been significantly improved in version 0.15, with more accurate fee estimates used by the wallet and a wider range of \noptions for advanced users of the `estimatesmartfee` and `estimaterawfee` RPCs (See [PR 10199]\n(https://github.com/bitcoin/bitcoin/pull/10199)).\n\n### Changes to internal logic and wallet behavior\n\n- Internally, estimates are now tracked on 3 different time horizons. This allows for longer targets and means estimates adjust more \nquickly to changes in conditions.\n- Estimates can now be *conservative* or *economical*. *Conservative* estimates use longer time horizons to produce an estimate which is \nless susceptible to rapid changes in fee conditions. *Economical* estimates use shorter time horizons and will be more affected by short-\nterm changes in fee conditions. Economical estimates may be considerably lower during periods of low transaction activity (for example over \nweekends), but may result in transactions being unconfirmed if prevailing fees increase rapidly.\n- By default, the wallet will use conservative fee estimates to increase the reliability of transactions being confirmed within the desired \ntarget. For transactions that are marked as replaceable, the wallet will use an economical estimate by default, since the fee can be \n'bumped' if the fee conditions change rapidly (See [PR 10589](https://github.com/bitcoin/bitcoin/pull/10589)).\n- Estimates can now be made for confirmation targets up to 1008 blocks (one week).\n- More data on historical fee rates is stored, leading to more precise fee estimates.\n- Transactions which leave the mempool due to eviction or other non-confirmed reasons are now taken into account by the fee estimation \nlogic, leading to more accurate fee estimates.\n- The fee estimation logic will make sure enough data has been gathered to return a meaningful estimate. If there is insufficient data, a \nfallback default fee is used.\n\n### Changes to fee estimate RPCs\n\n- The `estimatefee` RPC is now deprecated in favor of using only `estimatesmartfee` (which is the implementation used by the GUI)\n- The `estimatesmartfee` RPC interface has been changed (See [PR 10707](https://github.com/bitcoin/bitcoin/pull/10707)):\n    - The `nblocks` argument has been renamed to `conf_target` (to be consistent with other RPC methods).\n    - An `estimate_mode` argument has been added. This argument takes one of the following strings: `CONSERVATIVE`, `ECONOMICAL` or `UNSET` \n(which defaults to `CONSERVATIVE`).\n    - The RPC return object now contains an `errors` member, which returns errors encountered during processing.\n    - If Bitcoin Knots has not been running for long enough and has not seen enough blocks or transactions to produce an accurate fee \nestimation, an error will be returned (previously a value of -1 was used to indicate an error, which could be confused for a feerate).\n- A new `estimaterawfee` RPC is added to provide raw fee data. External clients can query and use this data in their own fee estimation \nlogic.\n\nMulti-wallet endpoint support\n-----------------------------\n\nBitcoin Knots has supported loading multiple, separate wallets since\nv0.13.1.knots20161027. However, due to the RPC API, RPC users could only access\na single wallet at a time - accessing multiple wallets over RPC required the\nuse of multiple RPC users. 0.15.0 adds support for specifying the wallet by\nname using a URI path for the RPC endpoint.\n\nTo do this, HTTP RPC requests should be send to the `<RPC IP address>:<RPC port>/wallet/<wallet name>/` endpoint, for example \n`127.0.0.1:8332/wallet/wallet1.dat/`.\n\n`bitcoin-cli` commands should be run with a `-rpcwallet` option, for example `bitcoin-cli -rpcwallet=wallet1.dat getbalance`.\n\nAdditionally, a new `listwallets` RPC method is added to display which wallets are currently loaded. The names returned by this method are \nthe same as those used in the HTTP endpoint and for the `rpcwallet` argument.\n\nThis new wallet endpoint interface should be considered unstable for version 0.15.0, and there may backwards-incompatible changes in future \nversions.\n\nThe original RPC user based wallet selection continues to work as well, independently from the new endpoint support. `rpcauth` users that \nspecify a specific wallet are prohibited from using endpoints to access others. However, note that (at least in this version) `listwallets` \nwill always list all wallets on the node, even if access to them has been limited!\n\nRemoval of no-fee transactions\n------------------------------\n\nIn previous versions of Bitcoin Knots, transactions without a fee would be allowed to be relayed if the node's memory pool was empty and \nthe age and value of UTXOs they spent (coin age priority) was sufficiently high.\n\nFor a long time now, this has been effectively useless, due to wide adoption of Bitcoin as well as regular spam attacks. Since the code no \nlonger has a purpose, support for no-fee transactions has been removed.\n\nSegwit checkpoint\n-----------------\n\nSince Segwit has activated, this release adds a new checkpoint locking to the first Segwit block. This guarantees no matter what happens, \nyour node will not accept a reorg to attempt theft of Segwit funds. (This isn't a real-world risk anyway, but there's no reason not to \nguarantee it with a checkpoint.)\n\nMempool Persistence Across Restarts\n-----------------------------------\n\nVersion 0.13.1.knots20161212 introduced mempool persistence across restarts (the mempool is saved to a `mempool.dat` file in the data \ndirectory prior to shutdown and restores the mempool when the node is restarted). Version 0.15 allows this feature to be switched on or off \nusing the `-persistmempool` command-line option (See [PR 9966](https://github.com/bitcoin/bitcoin/pull/9966)). By default, the option is \nset to true, and the mempool is saved on shutdown and reloaded on startup. If set to false, the `mempool.dat` file will neither be loaded \non startup nor saved on shutdown.\n\nThe new `savemempool` RPC can be used to trigger an immediate save of the mempool state at any time.\n\nNew RPC methods\n---------------\n\nVersion 0.15 introduces several new RPC methods:\n\n- `abortrescan` stops current wallet rescan, e.g. when triggered by an `importprivkey` call (See [PR 10208]\n(https://github.com/bitcoin/bitcoin/pull/10208)).\n- `combinerawtransaction` accepts a JSON array of raw transactions and combines them into a single raw transaction (See [PR 10571]\n(https://github.com/bitcoin/bitcoin/pull/10571)).\n- `estimaterawfee` returns raw fee data so that customized logic can be implemented to analyze the data and calculate estimates. See [Fee \nEstimation Improvements](#fee-estimation-improvements) for full details on changes to the fee estimation logic and interface.\n- `getchaintxstats` returns statistics about the total number and rate of transactions\n  in the chain (See [PR 9733](https://github.com/bitcoin/bitcoin/pull/9733)).\n- `listwallets` lists wallets which are currently loaded. See the *Multi-wallet* section\n  of these release notes for full details (See [Multi-wallet endpoint support](#multi-wallet-endpoint-support)).\n- `savemempool` causes the memory pool to immediately update `mempool.dat` with its current state.\n- `uptime` returns the total runtime of the `bitcoind` server since its last start (See [PR 10400]\n(https://github.com/bitcoin/bitcoin/pull/10400)).\n- `verifyscript` allows verification of a specific Bitcoin Script, optionally including a full trace of the evaluation.\n\nAdditionally, the `bitcoin-cli` tool now supports a `-getinfo` command line option to fetch information from multiple `get*info` RPC \nmethods. This is intended to replace the deprecated `getinfo` RPC method.\n\nWallet ZeroMQ publishers\n------------------------\n\nThis release includes experimental ZeroMQ publishers for wallet transactions.\n\nSee [the ZMQ documentation](zmq.md) for details.\n\nLow-level RPC changes\n---------------------\n\n- When using Bitcoin Knots in multi-wallet mode, RPC requests for wallet methods may specify\n  the wallet that they're intended for. See [Multi-wallet endpoint support](#multi-wallet-endpoint-support) for full details.\n\n- The `optintorbf` parameter for `createrawtransaction` and `fundrawtransaction` has been renamed to `replaceable` to match `bumpfee`.\n\n- The new database model no longer stores information about transaction\n  versions of unspent outputs (See [Performance improvements](#performance-improvements)). This means that:\n  - The `gettxout` RPC no longer has a `version` field in the response.\n  - The `gettxoutsetinfo` RPC reports `hash_serialized_2` instead of `hash_serialized`,\n    which does not commit to the transaction versions of unspent outputs, but does\n    commit to the height and coinbase information.\n  - The `getutxos` REST path no longer reports the `txvers` field in JSON format,\n    and always reports 0 for transaction versions in the binary format\n\n- The `estimatefee` RPC is deprecated. Clients should switch to using the `estimatesmartfee` RPC, which returns better fee estimates. See \n[Fee Estimation Improvements](#fee-estimation-improvements) for full details on changes to the fee estimation logic and interface.\n\n- The `gettxoutsetinfo` response now contains `disk_size` and `bogosize` instead of\n  `bytes_serialized`. The first is a more accurate estimate of actual disk usage, but\n  is not deterministic. The second is unrelated to disk usage, but is a\n  database-independent metric of UTXO set size: it counts every UTXO entry as 50 + the\n  length of its scriptPubKey (See [PR 10426](https://github.com/bitcoin/bitcoin/pull/10426)).\n\n- `signrawtransaction` can no longer be used to combine multiple transactions into a single transaction. Instead, use the new \n`combinerawtransaction` RPC (See [PR 10571](https://github.com/bitcoin/bitcoin/pull/10571)).\n\n- `fundrawtransaction` no longer accepts a `reserveChangeKey` option. This option used to allow RPC users to fund a raw transaction using \nan key from the keypool for the change address without removing it from the available keys in the keypool. The key could then be re-used \nfor a `getnewaddress` call, which could potentially result in confusing or dangerous behaviour (See [PR 10784]\n(https://github.com/bitcoin/bitcoin/pull/10784)).\n\n- `estimatepriority` and `estimatesmartpriority` have been removed. Estimating coin age priority is no longer supported.\n\n- In the `getpeerinfo` RPC, the return object for each peer now returns an `addrbind` member, which contains the ip address and port of the \nconnection to the peer. This is in addition to the `addrlocal` member which contains the ip address and port of the local node as reported \nby the peer (See [PR 10478](https://github.com/bitcoin/bitcoin/pull/10478)).\n\n- The `resendwallettransactions` RPC throws an error if the `-walletbroadcast` option is set to false (See [PR 10995]\n(https://github.com/bitcoin/bitcoin/pull/10995)).\n\n- The second argument in the `submitblock` RPC argument has been renamed from `parameters` to `dummy`. This argument never had any effect, \nand the renaming is simply to communicate this fact to the user (See [PR 10191](https://github.com/bitcoin/bitcoin/pull/10191))\n  (Clients should, however, use positional arguments for `submitblock` in order to be compatible with BIP 22.)\n\n- Mempool entries returned from RPC now include the hash of the entire transaction as a `wtxid` key.\n\nLow-level p2p changes\n---------------------\n\nSupport for a new kind of inventory item MSG_FILTERED_WITNESS_BLOCK has been added. This extends the functionality of BIP37, used \nidentically to MSG_FILTERED_BLOCK. But whereas MSG_FILTERED_BLOCK returns transactions with no witness data, MSG_FILTERED_WITNESS_BLOCK \nreturns the transactions serialized along with witness data. No merkle proof for witness inclusion in blocks is provided, but clients can \nstill verify the witness is valid (although possibly not the same witness as in the blockchain).\n\nBIP37 has well-known privacy issues and will likely be deprecated in favor of clientside block filtering in future software releases. \nMSG_FILTERED_WITNESS_BLOCK is provided to enable clients that rely on BIP37 to easily add Segregated Witness support immediately until \nbetter sync mechanisms gain widespread use.\n\nWarning: BIP37 leaks private data and witness data is not authenticated. You must use a trusted node to use this mechanism securely.\n\n0.15.0 Change log\n=================\n\n### RPC and other APIs\n- #9485 `61a640e` ZMQ example using python3 and asyncio (mcelrath)\n- #9894 `0496e15` remove 'label' filter for rpc command help (instagibbs)\n- #9853 `02bd6e9` Fix error codes from various RPCs (jnewbery)\n- #9842 `598ef9c` Fix RPC failure testing (continuation of #9707) (jnewbery)\n- #10038 `d34995a` Add mallocinfo mode to `getmemoryinfo` RPC (laanwj)\n- #9500 `3568b30` [Qt][RPC] Autocomplete commands for 'help' command in debug console (achow101)\n- #10056 `e6156a0` [zmq] Call va_end() on va_start()ed args (kallewoof)\n- #10086 `7438cea` Trivial: move rpcserialversion into RPC option group (jlopp)\n- #10150 `350b224` [rpc] Add logging rpc (jnewbery)\n- #10208 `393160c` [wallet] Rescan abortability (kallewoof)\n- #10143 `a987def` [net] Allow disconnectnode RPC to be called with node id (jnewbery)\n- #10281 `0e8499c` doc: Add RPC interface guidelines (laanwj)\n- #9733 `d4732f3` Add getchaintxstats RPC (sipa)\n- #10310 `f4b15e2` [doc] Add hint about getmempoolentry to getrawmempool help (kallewoof)\n- #8704 `96c850c` [RPC] Transaction details in getblock (achow101)\n- #8952 `9390845` Add query options to listunspent RPC call (pedrobranco)\n- #10413 `08ac35a` Fix docs (there's no rpc command setpaytxfee) (RHavar)\n- #8384 `e317c0d` Add witness data output to TxInError messages (instagibbs)\n- #9571 `4677151` RPC: getblockchaininfo returns BIP signaling statistics  (pinheadmz)\n- #10450 `ef2d062` Fix bumpfee rpc \"errors\" return value (ryanofsky)\n- #10475 `39039b1` [RPC] getmempoolinfo mempoolminfee is a BTC/KB feerate (instagibbs)\n- #10478 `296928e` rpc: Add listen address to incoming connections in `getpeerinfo` (laanwj)\n- #10403 `08d0390` Fix importmulti failure to return rescan errors (ryanofsky)\n- #9740 `9fec4da` Add friendly output to dumpwallet (aideca)\n- #10426 `16f6c98` Replace bytes_serialized with bogosize (sipa)\n- #10252 `980deaf` RPC/Mining: Restore API compatibility for prioritisetransaction (luke-jr)\n- #9672 `46311e7` Opt-into-RBF for RPC & bitcoin-tx (luke-jr)\n- #10481 `9c248e3` Decodehextx scripts sanity check  (achow101)\n- #9738 `c94b89e` gettxoutproof() should return consistent result (jnewbery)\n- #10191 `00350bd` [trivial] Rename unused RPC arguments 'dummy' (jnewbery)\n- #10627 `b62b4c8` fixed listunspent rpc convert parameter (tnakagawa)\n- #10412 `bef02fb` Improve wallet rescan API (ryanofsky)\n- #10400 `1680ee0` [RPC] Add an uptime command that displays the amount of time (in seconds) bitcoind has been running (rvelhote)\n- #10683 `d81bec7` rpc: Move the `generate` RPC call to rpcwallet (laanwj)\n- #10710 `30bc0f6` REST/RPC example update (Mirobit)\n- #10747 `9edda0c` [rpc] fix verbose argument for getblock in bitcoin-cli (jnewbery)\n- #10589 `104f5f2` More economical fee estimates for RBF and RPC options to control (morcos)\n- #10543 `b27b004` Change API to estimaterawfee (morcos)\n- #10807 `afd2fca` getbalance example covers at least 6 confirms (instagibbs)\n- #10707 `75b5643` Better API for estimatesmartfee RPC  (morcos)\n- #10784 `9e8d6a3` Do not allow users to get keys from keypool without reserving them (TheBlueMatt)\n- #10857 `d445a2c` [RPC] Add a deprecation warning to getinfo's output (achow101)\n- #10571 `adf170d` [RPC]Move transaction combining from signrawtransaction to new RPC (achow101)\n- #10783 `041dad9` [RPC] Various rpc argument fixes (instagibbs)\n- #9622 `6ef3c7e` [rpc] listsinceblock should include lost transactions when parameter is a reorg'd block (kallewoof)\n- #10799 `8537187` Prevent user from specifying conflicting parameters to fundrawtx (TheBlueMatt)\n- #10931 `0b11a07` Fix misleading \"Method not found\" multiwallet errors (ryanofsky)\n- #10788 `f66c596` [RPC] Fix addwitnessaddress by replacing ismine with producesignature (achow101)\n- #10999 `627c3c0` Fix amounts formatting in `decoderawtransaction` (laanwj)\n- #11002 `4268426` [wallet] return correct error code from resendwallettransaction (jnewbery)\n- #11029 `96a63a3` [RPC] trivial: gettxout no longer shows version of tx (FelixWeis)\n- #11083 `6c2b008` Fix combinerawtransaction RPC help result section (jonasnick)\n- #11027 `07164bb` [RPC] Only return hex field once in getrawtransaction (achow101)\n- #10698 `5af6572` Be consistent in calling transactions \"replaceable\" for Opt-In RBF (TheBlueMatt)\n- n/a    `a92a946` *RPC: prioritisetransaction: Make both deltas optional (luke-jr)\n- #7061 `e893d96` *RPC/Wallet: rescanblockchain: Support inverted height order (luke-jr)\n- #10554 `e700ad2` *ZMQ: add publishers for wallet transactions. (somdoron)\n- n/a    `0afed04` *Add script tracing capabilities to libbitcoinconsensus and a new RPC verifyscript method (luke-jr)\n- #10871 `977d461` *Handle getinfo in bitcoin-cli w/ -getinfo (laanwj, achow101, jnewbery)\n- #10997 `d6f667e` *RPC: Add option -stdinrpcpass to bitcoin-cli to allow RPC password to be read from standard input (jharvell)\n- #11099 `941c2f6` *[RPC][mempool]: Add savemempool RPC (greenaddress)\n- #11203 `e731a14` *rpc: add wtxid to mempool entry output (sdaftuar)\n- #7533 `963da74` *AcceptToMemoryPool: Standardise rejection reason format (luke-jr)\n\n### Block and transaction handling\n- #9801 `a8c5751` Removed redundant parameter from mempool.PrioritiseTransaction (gubatron)\n- #9819 `1efc99c` Remove harmless read of unusued priority estimates (morcos)\n- #9822 `b7547fa` Remove block file location upgrade code (benma)\n- #9602 `30ff3a2` Remove free transactions (but not coin-age priority, in Knots) - implementation (morcos)\n- #9548 `47510ad` Remove min reasonable fee (morcos)\n- #10249 `c73af54` Switch CCoinsMap from boost to std unordered_map (sipa)\n- #9966 `2a183de` Control mempool persistence using a command line parameter (jnewbery)\n- #10199 `318ea50` Better fee estimates (morcos)\n- #10196 `bee3529` Bugfix: PrioritiseTransaction updates the mempool tx counter (sdaftuar)\n- #10195 `1088b02` Switch chainstate db and cache to per-txout model (sipa)\n- #10284 `c2ab38b` Always log debug information for fee calculation in CreateTransaction (morcos)\n- #10503 `efbcf2b` Use REJECT_DUPLICATE for already known and conflicted txn (sipa)\n- #10537 `b3eb0d6` Few Minor per-utxo assert-semantics re-adds and tweak (TheBlueMatt)\n- #10626 `8c841a3` doc: Remove outdated minrelaytxfee comment (MarcoFalke)\n- #10559 `234ffc6` Change semantics of HaveCoinInCache to match HaveCoin (morcos)\n- #10581 `7878353` Simplify return values of GetCoin/HaveCoin(InCache) (sipa)\n- #10684 `a381f6a` Remove no longer used mempool.exists(outpoint) (morcos)\n- #10148 `d4e551a` Use non-atomic flushing with block replay (sipa)\n- #10685 `30c2130` Clarify CCoinsViewMemPool documentation (TheBlueMatt)\n- #10558 `90a002e` Address nits from per-utxo change (morcos)\n- #10706 `6859ad2` Improve wallet fee logic and fix GUI bugs (morcos)\n- #10526 `754aa02` Force on-the-fly compaction during pertxout upgrade (sipa)\n- #10985 `d896d5c` Add undocumented -forcecompactdb to force LevelDB compactions (sipa)\n- #10292 `e4bbd3d` Improved efficiency in COutPoint constructors (mm-s)\n- #10290 `8d6d43e` Add -stopatheight for benchmarking (sipa)\n- #7533 `916f12f` *AcceptToMemoryPool: Replace fLimitFree[=false] with rejectmsg_gratis in ignore_rejects (luke-jr)\n\n### P2P protocol and network code\n- #9726 `7639d38` netbase: Do not print an error on connection timeouts through proxy (laanwj)\n- #9805 `5b583ef` Add seed.btc.petertodd.org to mainnet DNS seeds (petertodd)\n- #9861 `22f609f` Trivial: Debug log ambiguity fix for peer addrs (keystrike)\n- #9774 `90cb2a2` Enable host lookups for -proxy and -onion parameters (jmcorgan)\n- #9558 `7b585cf` Clarify assumptions made about when BlockCheck is called (TheBlueMatt)\n- #10135 `e19586a` [p2p] Send the correct error code in reject messages (jnewbery)\n- #9665 `eab00d9` Use cached [compact] blocks to respond to getdata messages (TheBlueMatt)\n- #10215 `a077a90` Check interruptNet during dnsseed lookups (TheBlueMatt)\n- #10234 `faf2dea` [net] listbanned RPC and QT should show correct banned subnets (jnewbery)\n- #10134 `314ebdf` [qa] Fixes segwit block relay test after inv-direct-fetch was disabled (sdaftuar)\n- #10351 `3f57c55` removed unused code in INV message (Greg-Griffith)\n- #10061 `ae78609` [net] Added SetSocketNoDelay() utility function (tjps)\n- #10408 `28c6e8d` Net: Improvements to Tor control port parser (str4d)\n- #10460 `5c63d66` Broadcast address every day, not 9 hours (sipa)\n- #10471 `400fdd0` Denote functions CNode::GetRecvVersion() and CNode::GetRefCount()  as const (pavlosantoniou)\n- #10345 `67700b3` [P2P] Timeout for headers sync (sdaftuar)\n- #10564 `8d9f45e` Return early in IsBanned (gmaxwell)\n- #10587 `de8db47` Net: Fix resource leak in ReadBinaryFile(...) (practicalswift)\n- #9549 `b33ca14` [net] Avoid possibility of NULL pointer dereference in MarkBlockAsInFlight(...) (practicalswift)\n- #10446 `2772dc9` net: avoid extra dns query per seed (theuni)\n- #10824 `9dd6a2b` Avoid unnecessary work in SetNetworkActive (promag)\n- #10948 `df3a6f4` p2p: Hardcoded seeds update pre-0.15 branch (laanwj)\n- #10977 `02f4c4a` [net] Fix use of uninitialized value in getnetworkinfo(const JSONRPCRequest&) (practicalswift)\n- #10982 `c8b62c7` Disconnect network service bits 6 and 8 until Aug 1, 2018 (TheBlueMatt)\n- #11012 `0e5cff6` Make sure to clean up mapBlockSource if we've already seen the block (theuni)\n- n/a    `bd5b64d` *utilioprio: Add Windows support as ioprio_set_file_idle (luke-jr)\n- #10731 `69577ae` *Escape rather than remove any printable characters in UAs (luke-jr)\n- #10350 `3f388dd` *Handle MSG_FILTERED_WITNESS_BLOCK messages (CodeShark)\n\n### Validation\n- #9725 `67023e9` CValidationInterface Cleanups (TheBlueMatt)\n- #10178 `2584925` Remove CValidationInterface::UpdatedTransaction (TheBlueMatt)\n- #10201 `a6548a4` pass Consensus::Params& to functions in validation.cpp and make them static (mariodian)\n- #10297 `431a548` Simplify DisconnectBlock arguments/return value (sipa)\n- #10464 `f94b7d5` Introduce static DoWarning (simplify UpdateTip) (jtimon)\n- #10569 `2e7d8f8` Fix stopatheight (achow101)\n- #10192 `2935b46` Cache full script execution results in addition to signatures (TheBlueMatt)\n- #10179 `21ed30a` Give CValidationInterface Support for calling notifications on the CScheduler Thread (TheBlueMatt)\n- #10557 `66270a4` Make check to distinguish between orphan txs and old txs more efficient (morcos)\n- #10775 `7c2400c` nCheckDepth chain height fix (romanornr)\n- #10821 `16240f4` Add SSE4 optimized SHA256 (sipa)\n- #10854 `04d395e` Avoid using sizes on non-fixed-width types to derive protocol constants (gmaxwell)\n- #10945 `2a50b11` Update defaultAssumeValid according to release-process.md (gmaxwell)\n- #10986 `2361208` Update chain transaction statistics (sipa)\n- #11028 `6bdf4b3` Avoid masking of difficulty adjustment errors by checkpoints (sipa)\n- #9533 `cb598cf` Allow non-power-of-2 signature cache sizes (sipa)\n- #9208 `acd9957` Improve DisconnectTip performance (sdaftuar)\n- #10618 `f90603a` Remove confusing MAX_BLOCK_BASE_SIZE (gmaxwell)\n- #10758 `bd92424` Fix some chainstate-init-order bugs (TheBlueMatt)\n- #10550 `b7296bc` Don't return stale data from CCoinsViewCache::Cursor() (ryanofsky)\n- #10998 `2507fd5` Fix upgrade cancel warnings (TheBlueMatt)\n- #9868 `cbdb473` Abstract out the command line options for block assembly (sipa)\n- n/a    `08c84c7` *Add a new checkpoint at block 481,824 (luke-jr)\n\n### Build system\n- #9727 `5f0556d` Remove fallbacks for boost_filesystem < v3 (laanwj)\n- #9788 `50a2265` gitian: bump descriptors for master (theuni)\n- #9794 `7ca2f54` Minor update to qrencode package builder (mitchellcash)\n- #9514 `2cc0df1` release: Windows signing script (theuni)\n- #9921 `8b789d8` build: Probe MSG_DONTWAIT in the same way as MSG_NOSIGNAL (laanwj)\n- #10011 `32d1b34` build: Fix typo s/HAVE_DONTWAIT/HAVE_MSG_DONTWAIT (laanwj)\n- #9946 `90dd9e6` Fix build errors if spaces in path or parent directory (pinheadmz)\n- #10136 `81da4c7` build: Disable Wshadow warning (laanwj)\n- #10166 `64962ae` Ignore Doxyfile generated from Doxyfile.in template (paveljanik)\n- #10239 `0416ea9` Make Boost use std::atomic internally (sipa)\n- #10228 `27faa6c` build: regenerate bitcoin-config.h as necessary (theuni)\n- #10273 `8979f45` [scripts] Minor improvements to `macdeployqtplus` script (chrisgavin)\n- #10325 `a26280b` 0.15.0 Depends Updates (fanquake)\n- #10328 `79aeff6` Update contrib/debian to latest Ubuntu PPA upload (TheBlueMatt)\n- #7522 `d25449f` Bugfix: Only use git for build info if the repository is actually the right one (luke-jr)\n- #10489 `e654d61` build: silence gcc7's implicit fallthrough warning (theuni)\n- #10549 `ad1a13e` Avoid printing generic and duplicated \"checking for QT\" during ./configure (drizzt)\n- #10628 `8465b68` [depends] expat 2.2.1 (fanquake)\n- #10806 `db825d2` build: verify that the assembler can handle crc32 functions (theuni)\n- #10766 `b4d03be` Building Environment: Set ARFLAGS to cr (ReneNyffenegger)\n- #10803 `91edda8` Explicitly search for bdb5.3 (pstratem)\n- #10855 `81560b0` random: only use getentropy on openbsd (theuni)\n- #10508 `1caafa6` Run Qt wallet tests on travis (ryanofsky)\n- #10851 `e222618` depends: fix fontconfig with newer glibc (theuni)\n- #10971 `88b1e4b` build: fix missing sse42 in depends builds (theuni)\n- #11097 `129b03f` gitian: quick hack to fix version string in releases (theuni)\n- #10039 `919aaf6` Fix compile errors with Qt 5.3.2 and Boost 1.55.0 (ryanofsky)\n- #10168 `7032021` Fix build warning from #error text (jnewbery)\n- #10301 `318392c` Check if sys/random.h is required for getentropy (jameshilliard)\n- n/a    `699287a` *Move Win32 defines to configure.ac to ensure they are globally defined (luke-jr)\n- n/a    `ad1b260` *nsis-header.bmp: Generate from SVG (luke-jr)\n\n### GUI\n- #9724 `1a9fd5c` Qt/Intro: Add explanation of IBD process (luke-jr)\n- #9834 `b00ba62` qt: clean up initialize/shutdown signals (benma)\n- #9481 `ce01e62` [Qt] Show more significant warning if we fall back to the default fee (jonasschnelli)\n- #9974 `b9f930b` Add basic Qt wallet test (ryanofsky)\n- #9690 `a387d3a` Change 'Clear' button string to 'Reset' (da2x)\n- #9592 `9c7b7cf` [Qt] Add checkbox in the GUI to opt-in to RBF when creating a transaction (ryanofsky)\n- #10098 `2b477e6` Make qt wallet test compatible with qt4 (ryanofsky)\n- #9890 `1fa4ae6` Add a button to open the config file in a text editor (ericshawlinux)\n- #10156 `51833a1` Fix for issues with startup and multiple monitors on windows (AllanDoensen)\n- #10177 `de01da7` Changed \"Send\" button default status from true to false (KibbledJiveElkZoo)\n- #10221 `e96486c` Stop treating coinbase outputs differently in GUI: show them at 1conf (TheBlueMatt)\n- #10231 `987a6c0` [Qt] Reduce a significant cs_main lock freeze (jonasschnelli)\n- #10242 `f6f3b58` [qt] Don't call method on null WalletModel object (ryanofsky)\n- #10093 `a3e756b` [Qt] Don't add arguments of sensitive command to console window (jonasschnelli)\n- #10362 `95546c8` [GUI] Add OSX keystroke to RPCConsole info (spencerlievens)\n- #9697 `962cd3f` [Qt] simple fee bumper with user verification (jonasschnelli)\n- #10390 `e477516` [wallet] remove minimum total fee option (instagibbs)\n- #10420 `4314544` Add Qt tests for wallet spends & bumpfee (ryanofsky)\n- #10454 `c1c9a95` Fix broken q4 test build (ryanofsky)\n- #10449 `64beb13` Overhaul Qt fee bumper (jonasschnelli)\n- #10582 `7c72fb9` Pass in smart fee slider value to coin control dialog (morcos)\n- #10673 `4c72cc3` [qt] Avoid potential null pointer dereference in TransactionView::exportClicked() (practicalswift)\n- #10769 `8fdd23a` [Qt] replace fee slider with a Dropdown, extend conf. targets (jonasschnelli)\n- #10870 `412b466` [Qt] Use wallet 0 in rpc console if running with multiple wallets (jonasschnelli)\n- #10988 `a9dd111` qt: Increase BLOCK_CHAIN_SIZE constants (laanwj)\n- #10644 `e292140` Slightly overhaul NSI pixmaps (jonasschnelli)\n- #10660 `0c3542e` Allow to cancel the txdb upgrade via splashscreen keypress 'q' (jonasschnelli)\n- #11169 `ad55de9` *Make tabs toolbar no longer have a context menu (achow101)\n- #11198 `14ccd4d` *Fix display of package name on 'open config file' tooltip (esotericnonsense)\n- #11206 `819e3dd` *Move \"Hide tray icon\" accelerator to checkbox text where it belongs (polyetilen)\n- #11208 `80b0f37` *Fixing offscreen GUI issue (MeshCollider)\n\n### Wallet\n- #9359 `f7ec7cf` Add test for CWalletTx::GetImmatureCredit() returning stale values (ryanofsky)\n- #9576 `56ab672` [wallet] Remove redundant initialization (practicalswift)\n- #9333 `fa625b0` Document CWalletTx::mapValue entries and remove erase of nonexistent \"version\" entry (ryanofsky)\n- #9906 `72fb515` Disallow copy constructor CReserveKeys (instagibbs)\n- #9369 `3178b2c` Factor out CWallet::nTimeSmart computation into a method (ryanofsky)\n- #9830 `afcd7c0` Add safe flag to listunspent result (NicolasDorier)\n- #9993 `c49355c` Initialize nRelockTime (pstratem)\n- #9818 `3d857f3` Save watch only key timestamps when reimporting keys (ryanofsky)\n- #9294 `f34cdcb` Use internal HD chain for change outputs (hd split) (jonasschnelli)\n- #10164 `e183ea2` Wallet: reduce excess logic InMempool() (kewde)\n- #10186 `c9ff4f8` Remove SYNC_TRANSACTION_NOT_IN_BLOCK magic number (jnewbery)\n- #10226 `64c45aa` wallet: Use boost to more portably ensure -wallet specifies only a filename (luke-jr)\n- #9827 `c91ca0a` Improve ScanForWalletTransactions return value (ryanofsky)\n- #9951 `fa1ac28` Wallet database handling abstractions/simplifications (laanwj)\n- #10265 `c29a0d4` [wallet] [moveonly] Check non-null pindex before potentially referencing (kallewoof)\n- #10283 `a550f6e` Cleanup: reduce to one GetMinimumFee call signature (morcos)\n- #10294 `e2b99b1` [Wallet] unset change position when there is no change (instagibbs)\n- #10115 `d3dce0e` Avoid reading the old hd master key during wallet encryption (TheBlueMatt)\n- #10341 `18c9deb` rpc/wallet: Workaround older UniValue which returns a std::string temporary for get_str (luke-jr)\n- #10308 `94e5227` [wallet] Securely erase potentially sensitive keys/values (tjps)\n- #10257 `ea1fd43` [test] Add test for getmemoryinfo (jimmysong)\n- #10295 `ce8176d` [qt] Move some WalletModel functions into CWallet (ryanofsky)\n- #10506 `7cc2c67` Fix bumpfee test after #10449 (ryanofsky)\n- #10500 `098b01d` Avoid CWalletTx copies in GetAddressBalances and GetAddressGroupings (ryanofsky)\n- #10455 `0747d33` Simplify feebumper minimum fee code slightly (ryanofsky)\n- #10522 `2805d60` [wallet] Remove unused variables (practicalswift)\n- #8694 `177433a` Basic multiwallet support (luke-jr)\n- #10598 `7a74f88` Supress struct/class mismatch warnings introduced in #10284 (paveljanik)\n- #9343 `209eef6` Don't create change at dust limit (morcos)\n- #10744 `ed88e31` Use method name via __func__ macro (darksh1ne)\n- #10712 `e8b9523` Add change output if necessary to reduce excess fee (morcos)\n- #10816 `1c011ff` Properly forbid -salvagewallet and -zapwallettxes for multi wallet (morcos)\n- #10235 `5cfdda2` Track keypool entries as internal vs external in memory (TheBlueMatt)\n- #10330 `bf0a08b` [wallet] fix zapwallettxes interaction with persistent mempool (jnewbery)\n- #10831 `0b01935` Batch flushing operations to the walletdb during top up and increase keypool size (gmaxwell)\n- #10795 `7b6e8bc` No longer ever reuse keypool indexes (TheBlueMatt)\n- #10849 `bde4f93` Multiwallet: simplest endpoint support (jonasschnelli)\n- #10817 `9022aa3` Redefine Dust and add a discard_rate (morcos)\n- #10883 `bf3b742` Rename -usewallet to -rpcwallet (morcos)\n- #10604 `420238d` [wallet] [tests] Add listwallets RPC, include wallet name in `getwalletinfo` and add multiwallet test (jnewbery)\n- #10885 `70888a3` Reject invalid wallets (promag)\n- #10949 `af56397` Clarify help message for -discardfee (morcos)\n- #10942 `2e857bb` Eliminate fee overpaying edge case when subtracting fee from recipients (morcos)\n- #10995 `fa64636` Fix resendwallettransactions assert failure if -walletbroadcast=0 (TheBlueMatt)\n- #11022 `653a46d` Basic keypool topup (jnewbery)\n- #11081 `9fe1f6b` Add length check for CExtKey deserialization (jonasschnelli, guidovranken)\n- #11044 `4ef8374` [wallet] Keypool topup cleanups (jnewbery)\n- #11145 `e51bb71` Fix rounding bug in calculation of minimum change (morcos)\n- #9605 `779f2f9` Use CScheduler for wallet flushing, remove ThreadFlushWalletDB (TheBlueMatt)\n- #10108 `4e3efd4` ApproximateBestSubset should take inputs by reference, not value (RHavar)\n\n### Mining\n\n- n/a   `2421dd2` *coin_age_priority: Ensure nPackagesSelected and nDescendantsUpdated get updated for priority-mined transactions (luke-\njr)\n\n### Tests and QA\n- #9744 `8efd1c8` Remove unused module from rpc-tests (34ro)\n- #9657 `7ff4a53` Improve rpc-tests.py (jnewbery)\n- #9766 `7146d96` Add --exclude option to rpc-tests.py (jnewbery)\n- #9577 `d6064a8` Fix docstrings in qa tests (jnewbery)\n- #9823 `a13a417` qa: Set correct path for binaries in rpc tests (MarcoFalke)\n- #9847 `6206252` Extra test vector for BIP32 (sipa)\n- #9350 `88c2ae3` [Trivial] Adding label for amount inside of tx_valid/tx_invalid.json (Christewart)\n- #9888 `36afd4d` travis: Verify commits only for one target (MarcoFalke)\n- #9904 `58861ad` test: Fail if InitBlockIndex fails (laanwj)\n- #9828 `67c5cc1` Avoid -Wshadow warnings in wallet_tests (ryanofsky)\n- #9832 `48c3429` [qa] assert_start_raises_init_error (NicolasDorier)\n- #9739 `9d5fcbf` Fix BIP68 activation test (jnewbery)\n- #9547 `d32581c` bench: Assert that division by zero is unreachable (practicalswift)\n- #9843 `c78adbf` Fix segwit getblocktemplate test (jnewbery)\n- #9929 `d5ce14e` tests: Delete unused function _rpchost_to_args (laanwj)\n- #9555 `19be26a` [test] Avoid reading a potentially uninitialized variable in tx_invalid-test (transaction_tests.cpp) (practicalswift)\n- #9945 `ac23a7c` Improve logging in bctest.py if there is a formatting mismatch (jnewbery)\n- #9768 `8910b47` [qa] Add logging to test_framework.py (jnewbery)\n- #9972 `21833f9` Fix extended rpc tests broken by #9768 (jnewbery)\n- #9977 `857d1e1` QA: getblocktemplate_longpoll.py should always use >0 fee tx (sdaftuar)\n- #9970 `3cc13ea` Improve readability of segwit.py, smartfees.py (sdaftuar)\n- #9497 `2c781fb` CCheckQueue Unit Tests (JeremyRubin)\n- #10024 `9225de2` [trivial] Use log.info() instead of print() in remaining functional test cases (jnewbery)\n- #9956 `3192e52` Reorganise qa directory (jnewbery)\n- #10017 `02d64bd` combine_logs.py - aggregates log files from multiple bitcoinds during functional tests (jnewbery)\n- #10047 `dfef6b6` [tests] Remove unused variables and imports (practicalswift)\n- #9701 `a230b05` Make bumpfee tests less fragile (ryanofsky)\n- #10053 `ca20923` [test] Allow functional test cases to be skipped (jnewbery)\n- #10052 `a0b1e57` [test] Run extended tests once daily in Travis (jnewbery)\n- #10069 `1118493` [QA] Fix typo in fundrawtransaction test (NicolasDorier)\n- #10083 `c044f03` [QA] Renaming rawTx into rawtx (NicolasDorier)\n- #10073 `b1a4f27` Actually run assumevalid.py (jnewbery)\n- #9780 `c412fd8` Suppress noisy output from qa tests in Travis (jnewbery)\n- #10096 `79af9fb` Check that all test scripts in test/functional are being run (jnewbery)\n- #10076 `5b029aa` [qa] combine_logs: Use ordered list for logfiles (MarcoFalke)\n- #10107 `f2734c2` Remove unused variable. Remove accidental trailing semicolons in Python code (practicalswift)\n- #10109 `8ac8041` Remove SingleNodeConnCB (jnewbery)\n- #10114 `edc62c9` [tests] sync_with_ping should assert that ping hasn't timed out (jnewbery)\n- #10128 `427d2fd` Speed Up CuckooCache tests (JeremyRubin)\n- #10072 `12af74b` Remove sources of unreliablility in extended functional tests (jnewbery)\n- #10077 `ebfd653` [qa] Add setnetworkactive smoke test (MarcoFalke)\n- #10152 `080d7c7` [trivial] remove unused line in Travis config (jnewbery)\n- #10159 `df1ca9e` [tests] color test results and sort alphabetically (jnewbery)\n- #10124 `88799ea` [test] Suppress test logging spam (jnewbery)\n- #10142 `ed09dd3` Run bitcoin_test-qt under minimal QPA platform (ryanofsky)\n- #9949 `a27dbc5` [bench] Avoid function call arguments which are pointers to uninitialized values (practicalswift)\n- #10187 `b44adf9` tests: Fix test_runner return value in case of skipped test (laanwj)\n- #10197 `d86bb07` [tests] Functional test warnings (jnewbery)\n- #10219 `9111df9` Tests: Order Python Tests Differently (jimmysong)\n- #10229 `f3db4c6` Tests: Add test for getdifficulty (jimmysong)\n- #10224 `2723bcd` [test] Add test for getaddednodeinfo (jimmysong)\n- #10023 `c530c15` [tests] remove maxblocksinflight.py (functionality covered by other test) (jnewbery)\n- #10097 `1b25b6d` Move zmq test skipping logic into individual test case (jnewbery)\n- #10272 `54e2d87` [Tests] Prevent warning: variable 'x' is uninitialized (paveljanik)\n- #10225 `e0a7e19` [test] Add aborttrescan tests (kallewoof)\n- #10278 `8254a8a` [test] Add Unit Test for GetListenPort (jimmysong)\n- #10280 `47535d7` [test] Unit test amount.h/amount.cpp (jimmysong)\n- #10256 `80c3a73` [test] Add test for gettxout to wallet.py (jimmysong)\n- #10264 `492d22f` [test] Add tests for getconnectioncount, getnettotals and ping (jimmysong)\n- #10169 `8f3e384` [tests] Remove func test code duplication (jnewbery)\n- #10198 `dc8fc0c` [tests] Remove is_network_split from functional test framework (jnewbery)\n- #10255 `3c5e6c9` [test] Add test for listaddressgroupings (jimmysong)\n- #10137 `75171f0` Remove unused import. Remove accidental trailing semicolons (practicalswift)\n- #10307 `83073de` [tests] allow zmq test to be run in out-of-tree builds (jnewbery)\n- #10344 `e927483` [tests] Fix abandonconflict.py intermittency (jnewbery)\n- #10318 `170bc2c` [tests] fix wait_for_inv() (jnewbery)\n- #10171 `fff72de` [tests] Add node methods to test framework (jnewbery)\n- #10352 `23d78c4` test: Add elapsed time to RPC tracing (laanwj)\n- #10342 `6a796b2` [tests] Improve mempool_persist test (jnewbery)\n- #10287 `776ba23` [tests] Update Unit Test for addrman.h/addrman.cpp (jimmysong)\n- #10365 `7ee5236` [tests] increase timeouts in sendheaders test (jnewbery)\n- #10361 `f6241b3` qa: disablewallet: Check that wallet is really disabled (MarcoFalke)\n- #10371 `4b766fc` [tests] Clean up addrman_tests.cpp (jimmysong)\n- #10253 `87abe20` [test] Add test for getnetworkhashps (jimmysong)\n- #10376 `8bd16ee` [tests] fix disconnect_ban intermittency (jnewbery)\n- #10374 `5411997` qa: Warn when specified test is not found (MarcoFalke)\n- #10405 `0542978` tests: Correct testcase in script_tests.json for large number OP_EQUAL (laanwj)\n- #10429 `6b99daf` tests: fix spurious addrman test failure (theuni)\n- #10433 `8e57256` [tests] improve tmpdir structure (jnewbery)\n- #10415 `217b416` [tests] Speed up fuzzing by ~200x when using afl-fuzz (practicalswift)\n- #10445 `b4b057a` Add test for empty chain and reorg consistency for gettxoutsetinfo (gmaxwell)\n- #10423 `1aefc94` [tests] skipped tests should clean up after themselves (jnewbery)\n- #10359 `329fc1d` [tests] functional tests should call BitcoinTestFramework start/stop node methods (jnewbery)\n- #10514 `e103b3f` Bugfix: missing == 0 after randrange (sipa)\n- #10515 `c871f32` [test] Add test for getchaintxstats (jimmysong)\n- #10509 `bea5b00` Remove xvfb configuration from travis (ryanofsky)\n- #10535 `30853e1` [qa] fundrawtx: Fix shutdown race (MarcoFalke)\n- #9909 `300f8e7` tests: Add FindEarliestAtLeast test for edge cases (ryanofsky)\n- #10331 `75e898c` Share config between util and functional tests (jnewbery)\n- #10321 `e801084` Use FastRandomContext for all tests (sipa)\n- #10524 `6c2d81f` [tests] Remove printf(...) (practicalswift)\n- #10547 `71ab6e5` [tests] Use FastRandomContext instead of boost::random::{mt19937,uniform_int_distribution} (practicalswift)\n- #10551 `6702617` [Tests] Wallet encryption functional tests (achow101)\n- #10555 `643fa0b` [tests] various improvements to zmq_test.py (jnewbery)\n- #10533 `d083bd9` [tests] Use cookie auth instead of rpcuser and rpcpassword (achow101)\n- #10632 `c68a9a6` qa: Add stopatheight test (MarcoFalke)\n- #10636 `4bc853b` [qa] util: Check return code after closing bitcoind proc (MarcoFalke)\n- #10662 `e0a7801` Initialize randomness in benchmarks (achow101)\n- #10612 `7c87a9c` The young person's guide to the test_framework (jnewbery)\n- #10659 `acb1153` [qa] blockchain: Pass on closed connection during generate call (MarcoFalke)\n- #10690 `416af3e` [qa] Bugfix: allow overriding extra_args in ComparisonTestFramework (sdaftuar)\n- #10556 `65cc7aa` Move stop/start functions from utils.py into BitcoinTestFramework (jnewbery)\n- #10704 `dd07f47` [tests] nits in dbcrash.py (jnewbery)\n- #10743 `be82498` [test] don't run dbcrash.py on Travis (jnewbery)\n- #10761 `d3b5870` [tests] fix replace_by_fee.py (jnewbery)\n- #10759 `1d4805c` Fix multi_rpc test for hosts that dont default to utf8 (TheBlueMatt)\n- #10190 `e4f226a` [tests] mining functional tests (including regression test for submitblock) (jnewbery)\n- #10739 `1fc783f` test: Move variable `state` down where it is used (paveljanik)\n- #9980 `fee0d80` Fix mem access violation merkleblock (Christewart)\n- #10893 `0c173a1` [QA] Avoid running multiwallet.py twice (jonasschnelli)\n- #10927 `9d5e8f9` test: Make sure wallet.backup is created in temp path (laanwj)\n- #10899 `f29d5db` [test] Qt: Use _putenv_s instead of setenv on Windows builds (brianmcmichael)\n- #10912 `5c8eb79` [tests] Fix incorrect memory_cleanse(\u2026) call in crypto_tests.cpp (practicalswift)\n- #11001 `fa8a063` [tests] Test disconnecting unsupported service bits logic (jnewbery)\n- #10695 `929fd72` [qa] Rewrite BIP65/BIP66 functional tests (sdaftuar)\n- #10963 `ecd2135` [bench] Restore format state of cout after printing with std::fixed/setprecision (practicalswift)\n- #11025 `e5d26e4` qa: Fix inv race in example_test (MarcoFalke)\n- #10765 `2c811e0` Tests: address placement should be deterministic by default (ReneNyffenegger)\n- #11000 `ac016e1` test: Add resendwallettransactions functional tests (promag)\n- #11032 `aeb3175` [qa] Fix block message processing error in sendheaders.py (sdaftuar)\n- #10105 `0b9fb68` [tests] fixup - make all Travis test runs quiet, non just cron job runs (jnewbery)\n- #10222 `6ce7337` [tests] test_runner - check unicode (jnewbery)\n- #10327 `35da2ae` [tests] remove import-abort-rescan.py (jnewbery)\n- #11023 `bf74d37` [tests] Add option to attach a python debugger if functional test fails (jnewbery)\n- #10565 `8c2098a` [coverage] Remove subtrees and benchmarks from coverage report (achow101)\n- #7061 `21630f8` *Add RPC based rescan test (jonasschnelli)\n- #9152 `d109d58` *QA: Functional test for sweepprivkeys (luke-jr)\n\n### Miscellaneous\n- #9871 `be8ba2c` Add a tree sha512 hash to merge commits (sipa)\n- #9821 `d19d45a` util: Specific GetOSRandom for Linux/FreeBSD/OpenBSD (laanwj)\n- #9903 `ba80a68` Docs: add details to -rpcclienttimeout doc (ian-kelling)\n- #9910 `53c300f` Docs: correct and elaborate -rpcbind doc (ian-kelling)\n- #9905 `01b7cda` [contrib] gh-merge: Move second sha512 check to the end (MarcoFalke)\n- #9880 `4df8213` Verify Tree-SHA512s in merge commits, enforce sigs are not SHA1 (TheBlueMatt)\n- #9932 `00c13ea` Fix verify-commits on travis and always check top commit's tree (TheBlueMatt)\n- #9952 `6996e06` Add historical release notes for 0.14.0 (laanwj)\n- #9940 `fa99663` Fix verify-commits on OSX, update for new bad Tree-SHA512, point travis to different keyservers (TheBlueMatt)\n- #9963 `8040ae6` util: Properly handle errors during log message formatting (laanwj)\n- #9984 `cce056d` devtools: Make github-merge compute SHA512 from git, instead of worktree (laanwj)\n- #9995 `8bcf934` [doc] clarify blockchain size and pruning (askmike)\n- #9734 `0c17afc` Add updating of chainTxData to release process (sipa)\n- #10063 `530fcbd` add missing spaces so that markdown recognizes headline (flack)\n- #10085 `db1ae54` Docs: remove 'noconnect' option (jlopp)\n- #10090 `8e4f7e7` Update bitcoin.conf with example for pruning (coinables)\n- #9424 `1a5aaab` Change LogAcceptCategory to use uint32_t rather than sets of strings (gmaxwell)\n- #10036 `fbf36ca` Fix init README format to render correctly on github (jlopp)\n- #10058 `a2cd0b0` No need to use OpenSSL malloc/free (tjps)\n- #10123 `471ed00` Allow debug logs to be excluded from specified component (jnewbery)\n- #10104 `fadf078` linearize script: Option to use RPC cookie (achow101)\n- #10162 `a3a2160` [trivial] Log calls to getblocktemplate (jnewbery)\n- #10155 `928695b` build: Deduplicate version numbers (laanwj)\n- #10211 `a86255b` [doc] Contributor fixes & new \"finding reviewers\" section (kallewoof)\n- #10250 `1428f30` Fix some empty vector references (sipa)\n- #10270 `95f5e44` Remove Clang workaround for Boost 1.46 (fanquake)\n- #10263 `cb007e4` Trivial: fix fee estimate write error log message (CryptAxe)\n- #9670 `bd9ec0e` contrib: github-merge improvements (laanwj)\n- #10260 `1d75597` [doc] Minor corrections to osx dependencies (fanquake)\n- #10189 `750c5a5` devtools/net: add a verifier for scriptable changes. Use it to make CNode::id private (theuni)\n- #10322 `bc64b5a` Use hardware timestamps in RNG seeding (sipa)\n- #10381 `7f2b9e0` Shadowing warnings are not enabled by default, update doc accordingly (paveljanik)\n- #10380 `b6ee855` [doc] Removing comments about dirty entries on txmempool (madeo)\n- #10383 `d0c37ee` [logging] log system time and mock time (jnewbery)\n- #10404 `b45a52a` doc: Add logging to FinalizeNode() (sdaftuar)\n- #10388 `526e839` Output line to debug.log when IsInitialBlockDownload latches to false (morcos)\n- #10372 `15254e9` Add perf counter data to GetStrongRandBytes state in scheduler (TheBlueMatt)\n- #10461 `55b72f3` Update style guide (sipa)\n- #10486 `10e8c0a` devtools: Retry after signing fails in github-merge (laanwj)\n- #10447 `f259263` Make bitcoind invalid argument error message specific (laanwj)\n- #10495 `6a38b79` contrib: Update location of seeds.txt (laanwj)\n- #10469 `b6b150b` Fixing typo in rpcdump.cpp help message (keystrike)\n- #10451 `27b9931` contrib/init/bitcoind.openrcconf: Don't disable wallet by default (luke-jr)\n- #10323 `00d3692` Update to latest libsecp256k1 master (sipa)\n- #10422 `cec9e1e` Fix timestamp in fee estimate debug message (morcos)\n- #10566 `5d034ee` [docs] Use the \"domain name setup\" image (previously unused) in the gitian docs (practicalswift)\n- #10534 `a514ac3` Clarify prevector::erase and avoid swap-to-clear (sipa)\n- #10575 `22ec768` Header include guideline (sipa)\n- #10480 `fbf5d3b` Improve commit-check-script.sh (sipa)\n- #10502 `1ad3d4e` scripted-diff: Remove BOOST_FOREACH, Q_FOREACH and PAIRTYPE (jtimon)\n- #10377 `b63be2c` Use rdrand as entropy source on supported platforms (sipa)\n- #9895 `228c319` Turn TryCreateDirectory() into TryCreateDirectories() (benma)\n- #10602 `d76e84a` Make clang-format use C++11 features (e.g. A<A<int>> instead of A<A<int> >) (practicalswift)\n- #10623 `c38f540` doc: Add 0.14.2 release notes (MarcoFalke)\n- #10276 `b750b33` contrib/verifybinaries: allow filtering by platform (knocte)\n- #10248 `01c4b14` Rewrite addrdb with less duplication using CHashVerifier (sipa)\n- #10577 `232508f` Add an explanation of quickly hashing onto a non-power of two range (gmaxwell)\n- #10608 `eee398f` Add a comment explaining the use of MAX_BLOCK_BASE_SIZE (gmaxwell)\n- #10728 `7397af9` fix typo in help text for removeprunedfunds (AkioNak)\n- #10193 `6dbcc74` scripted-diff: Remove #include <boost/foreach.hpp> (jtimon)\n- #10676 `379aed0` document script-based return fields for validateaddress (instagibbs)\n- #10651 `cef4b5c` Verify binaries from bitcoincore.org and bitcoin.org (TheBlueMatt)\n- #10786 `ca4c545` Add PR description to merge commit in github-merge.py (sipa)\n- #10812 `c5904e8` [utils] Allow bitcoin-cli's -rpcconnect option to be used with square brackets (jnewbery)\n- #10842 `3895e25` Fix incorrect Doxygen tag (@ince \u2192 @since). Doxygen parameter name matching (practicalswift)\n- #10681 `df0793f` add gdb attach process to test README (instagibbs)\n- #10789 `1124328` Punctuation/grammer fixes in rpcwallet.cpp (stevendlander)\n- #10655 `78f307b` Properly document target_confirmations in listsinceblock (RHavar)\n- #10917 `5c003cb` developer-notes: add reference to snake_case and PascalCase (benma)\n- #11003 `4b5a7ce` Docs: Capitalize bullet points in CONTRIBUTING guide (eklitzke)\n- #10968 `98aa3f6` Add instructions for parallel gitian builds (coblee)\n- #11076 `1c4b9b3` 0.15 release-notes nits: fix redundancy, remove accidental parenthesis & fix range style (practicalswift)\n- #11090 `8f0121c` Update contributor names in release-notes.md (Derek701)\n- #11056 `cbdd338` disable jni in builds (instagibbs)\n- #11080 `2b59cfb` doc: Update build-openbsd for 6.1 (laanwj)\n- #11119 `0a6af47` [doc] build-windows: Mention that only trusty works (MarcoFalke)\n- #11108 `e8ad101` Changing -txindex requires -reindex, not -reindex-chainstate (TheBlueMatt)\n- #9792 `342b9bc` FastRandomContext improvements and switch to ChaCha20 (sipa)\n- #9505 `67ed40e` Prevector Quick Destruct (JeremyRubin)\n- #10820 `ef37f20` Use cpuid intrinsics instead of asm code (sipa)\n- #9999 `a328904` [LevelDB] Plug leveldb logs to bitcoin logs (NicolasDorier)\n- #9693 `c5e9e42` Prevent integer overflow in ReadVarInt (gmaxwell)\n- #10129 `351d0ad` scheduler: fix sub-second precision with boost < 1.50 (theuni)\n- #10153 `fade788` logging: Fix off-by-one for shrinkdebugfile default (MarcoFalke)\n- #10305 `c45da32` Fix potential NPD introduced in b297426c (TheBlueMatt)\n- #10338 `daf3e7d` Maintain state across GetStrongRandBytes calls (sipa)\n- #10544 `a4fe077` Update to LevelDB 1.20 (sipa)\n- #10614 `cafe24f` random: fix crash on some 64bit platforms (theuni)\n- #10714 `2a09a38` Avoid printing incorrect block indexing time due to uninitialized variable (practicalswift)\n- #10837 `8bc6d1f` Fix resource leak on error in GetDevURandom (corebob)\n- #10832 `89bb036` init: Factor out AppInitLockDataDirectory and fix startup core dump issue (laanwj)\n- #10914 `b995a37` Add missing lock in CScheduler::AreThreadsServicingQueue() (TheBlueMatt)\n- #10958 `659c096` Update to latest Bitcoin patches for LevelDB (sipa)\n- #10919 `c1c671f` Fix more init bugs (TheBlueMatt)\n- #7107 `9190a76` *ArgsManager: ForceSetArg with int64_t (luke-jr)\n- #9849 `6091bf1` *CValidationInterface: ValidationInterfaceUnregistering, called when being unregistered (luke-jr)\n- n/a    `c36f8ba` *Bump minimum Windows version to Vista\n- #10729 `2eea64b` *script/interpreter: Wrap EvalScript in a ScriptExecution class (luke-jr)\n- #10730 `7acd5fc` *Move script flag to/from-string logic from tests to script/interpreter (luke-jr)\n\nCredits\n=======\n\nThanks to everyone who directly contributed to this release:\n\n- \u30ed\u30cf\u30f3 \u30c0\u30eb\n- Ahmad Kazi\n- aideca\n- Akio Nakamura\n- Aleksandras Ragovskis\n- Alex Morcos\n- Allan Doensen\n- Andres G. Aragoneses\n- Andrew Chow\n- Angel Leon\n- Awemany\n- Bob McElrath\n- Brian McMichael\n- BtcDrak\n- Charlie Lee\n- Chris Gavin\n- Chris Stewart\n- Cory Fields\n- CryptAxe\n- Dag Robole\n- Daniel Aleksandersen\n- Daniel Cousens\n- Daniel Edgecumbe\n- darksh1ne\n- Dimitris Tsapakidis\n- Doron Somech\n- Eric Lombrozo\n- Eric Shaw\n- Evan Klitzke\n- fanquake\n- Felix Weis\n- flack\n- Guido Vranken\n- Greg Griffith\n- Gregory Maxwell\n- Gregory Sanders\n- Ian Kelling\n- Jack Grigg\n- James Evans\n- James Hilliard\n- Jameson Lopp\n- Jeremy Rubin\n- Jimmy Song\n- Jo\u00e3o Barbosa\n- Joe Harvell\n- Johnathan Corgan\n- John Newbery\n- Jonas Schnelli\n- Jorge Tim\u00f3n\n- Karl-Johan Alm\n- kewde\n- KibbledJiveElkZoo\n- Kirit Thadaka\n- kobake\n- Kyle Honeycutt\n- Lawrence Nahum\n- Luke Dashjr\n- Marco Falke\n- Marcos Mayorga\n- Marijn Stollenga\n- Mario Dian\n- Mark Friedenbach\n- Marko Bencun\n- Masahiko Hyuga\n- Matt Corallo\n- Matthew Zipkin\n- Matthias Grundmann\n- MeshCollider\n- Michael Goldstein\n- Michael Rotarius\n- Mikerah\n- Mike van Rossum\n- Mitchell Cash\n- Nicolas Dorier\n- Patrick Strateman\n- Pavel Jan\u00edk\n- Pavlos Antoniou\n- Pavol Rusnak\n- Pedro Branco\n- Peter Todd\n- Pieter Wuille\n- practicalswift\n- Ren\u00e9 Nyffenegger\n- Ricardo Velhote\n- romanornr\n- Russell Yanofsky\n- Rusty Russell\n- Ryan Havar\n- shaolinfry\n- Shigeya Suzuki\n- Simone Madeo\n- Spencer Lievens\n- Steven D. Lander\n- Suhas Daftuar\n- Takashi Mitsuta\n- Thomas Snider\n- Timothy Redaelli\n- tintinweb\n- tnaka\n- Warren Togami\n- Wladimir J. van der Laan\n\nAs well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 1528 bytes\nDesc: This is a digitally signed message part.\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170915/b7da0bb6/attachment-0001.sig>"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Knots 0.15.0.knots20170914 released",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Luke Dashjr"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 58013
        }
    },
    {
        "title": "[bitcoin-dev] An explanation and justification of the tail-call and MBV approach to MAST",
        "thread_messages": [
            {
                "author": "Mark Friedenbach",
                "date": "2017-09-20T22:51:39",
                "message_text_only": "Over the past few weeks I've been explaining the MERKLEBRANCHVERIFY\nopcode and tail-call execution semantics to a variety of developers,\nand it's come to my attention that the BIPs presentation of the\nconcept is not as clear as it could be. Part of this is the fault of\nstandards documents being standards documents whose first and foremost\nresponsibility is precision, not pedagogy.\n\nI think there's a better way to explain this approach to achieving\nMAST, and it's worked better in the face to face and whiteboard\nconversations I've had. I'm forwarding it to this list in case there\nare others who desire a more clear explanation of what the\nMERKLEBRANCHVERIFY and tail-call BIPs are trying to achieve, and what\nany of it has to do with MAST / Merklized script.\n\nI've written for all audiences so I apologize if it starts of at a\nnewbie level, but I encourage you to skim, not skip as I quickly start\nvarying this beginner material in atypical ways.\n\n\nReview of P2SH\n\nIt's easiest to explain the behavior and purpose of these BIPs by\nstarting with P2SH, which we are generalizing from. BIP 16 (Pay to\nScript Hash) specifies a form of implicit script recursion where a\nredeem script is provided in the scriptSig, and the scriptPubKey is a\nprogram that verifies the redeem script hashes to the committed value,\nwith the following template:\n\n  HASH160 <hash> EQUAL\n\nThis script specifies that the redeem script is pulled from the stack,\nits hash is compared against the expected value, and by fiat it is\ndeclared that the redeem script is then executed with the remaining\nstack items as arguments.\n\nSortof. What actually happens of course is that the above scriptPubKey\ntemplate is never executed, but rather the interpreter sees that it\nmatches this exact template format, and thereby proceeds to carry out\nthe same logic as a hard-coded behavior.\n\n\nGeneralizing P2SH with macro-op fusion\n\nThis template-matching is unfortunate because otherwise we could\nimagine generalizing this approach to cover other use cases beyond\ncommitting to and executing a single redeem script. For example, if we\ninstead said that anytime the script interpreter encountered the\n3-opcode sequence \"HASH160 <20-byte-push> EQUAL\" it switched to\ninterpreting the top element as if it were a script, that would enable\nnot just BIP 16 but also constructs like this:\n\n  IF\n    HASH160 <hash-1> EQUAL\n  ELSE\n    HASH160 <hash-2> EQUAL\n  ENDIF\n\nThis script conditionally executes one of two redeem scripts committed\nto in the scriptPubKey, and at execution only reveals the script that\nis actually used. All an observer learns of the other branch is the\nscript hash. This is a primitive form of MAST!\n\nThe \"if 3-opcode P2SH template is encountered, switch to subscript\"\nrule is a bit difficult to work with however. It's not a true EVAL\nopcode because control never returns back to the top-level script,\nwhich makes some important aspects of the implementation easier, but\nonly at the cost of complexity somewhere else. What if there are\nremaining opcodes in the script, such as the ELSE clause and ENDIF in\nthe script above?  They would never be executed, but does e.g. the\nclosing ENDIF still need to be present? Or what about the standard\npay-to-pubkey-hash \"1Address\" output:\n\n  DUP HASH160 <20-byte-key-hash> EQUALVERIFY CHECKSIG\n\nThat almost looks like the magic P2SH template, except there is an\nEQUALVERIFY instead of an EQUAL. The script interpreter should\nobviously not treat the pubkey of a pay-to-pubkey-hash output as a\nscript and recurse into it, whereas it should for a P2SH style\nscript. But isn't the distinction kinda arbitrary?\n\nAnd of course the elephant in the room is that by choosing not to\nreturn to the original execution context we are no longer talking\nabout a soft-fork. Work out, for example, what will happen with the\nfollowing script:\n\n  [TRUE] HASH160 <hash-of-[TRUE]> EQUAL FALSE\n\n(It returns false on a node that doesn't understand generalized\n3-opcode P2SH recursion, true on a node that does.)\n\n\nImplicit tail-call execution semantics and P2SH\n\nWell there's a better approach than trying to create a macro-op fusion\nfranken-EVAL. We have to run scripts to the end to for any proposal to\nbe a soft-fork, and we want to avoid saving state due to prior\nexperience of that leading to bugs in BIP 12. That narrows our design\nspace to one option: allow recursion only as the final act of a\nscript, as BIP 16 does, but for any script not just a certain\ntemplate. That way we can safely jump into the subscript without\nbothering to save local state because termination of the subscript is\ntermination of the script as a whole. In computer science terms, this\nis known as tail-call execution semantics.\n\nTo illustrate, consider the following scriptPubKey:\n\n  DUP HASH160 <20-byte-hash> EQUALVERIFY\n\nThis script is almost exactly the same as the P2SH template, except\nthat it leaves the redeem script on the stack rather than consuming\nit, thanks to the DUP, while it _does_ consume the boolean value at\nthe end because of the VERIFY. If executed, it leaves a stack exactly\nas it was, which we assume will look like the following::\n\n  <argN> ... <arg1> <redeemScript>\n\nNow a normal script is supposed to finish with just true or false on\nthe stack. Any script that finishes execution with more than a single\nelement on the stack is in violation of the so-called clean-stack rule\nand is considered non-standard -- not relayable and potentially broken\nby future soft-fork upgrades. But so long as at least one bit of\n<redeemScript> is set, it is interpreted as true and the script\ninterpreter would normally interpret a successful validation at this\npoint, albeit with a clean-stack violation.\n\nLet's take advantage of that by changing what the script interpreter\ndoes when a script finishes with multiple items remaining on the stack\nand top-most one evaluates as true -- a state of affairs that would\npass validation under the old rules. Now instead the interpreter\ntreats the top-most item on the stack as a script, and tail-call\nrecurse into it, P2SH-style. In the above example, <redeemScript> is\npopped off the stack and is executed with <arg1> ... <argN> remaining\non the stack as its arguments.\n\nThe above script can be interpreted in English as \"Perform tail-call\nrecursion if and only if the HASH160 of the script on the top of the\nstack exactly matches this 20-byte push.\" Which is, of course, what\nBIP 16 accomplishes with template matching. However the implicit tail\ncall approach allows us to do much more than just P2SH!\n\nFor starters, it turns out that using HASH160 for P2SH was probably a\nbad idea as it reduces the security of a multi-party constructed hash\nto an unacceptable 80 bits. That's why segwit uses 256-bit hashes for\nits pay to script hash format, for 128-bit security. Had we tail call\nsemantics instead of BIP 16, we could have just switched to a new\naddress type that decodes to the following script template instead:\n\n  DUP HASH256 <32-byte-hash> EQUALVERIFY\n\nTa-da, we're back to full 128-bit security with no changes to the\nconsensus code, just a new address version to target this script\ntemplate.\n\n\nMAST with tail-call alone?\nOr: an aside on general recursion\n\nOur IF-ELSE Merklized Abstract Syntax Tree example above, rewritten to\nuse tail-call evaluation, might look like this (there are more compact\nformulations possible, but our purpose here is not code golf):\n\n  IF\n    DUP HASH160 <hash-1> EQUALVERIFY\n  ELSE\n    DUP HASH160 <hash-2> EQUALVERIFY\n  ENDIF\n\nEither execution pathway leaves us with one of the two allowed redeem\nscripts on the top of the stack, and presumably its arguments beneath\nit. We then execute that script via implicit tail-call.\n\nWe could write scripts using IF-ELSE branches or other tricks to\ncommit to more than two possible branches, although this unfortunately\nscales linearly with the number of possible branches. If we allow the\nsubscript itself to do its own tail-call recursion, and its subscript\nand so on, then we could nest these binary branches for a true MAST in\nthe original sense of the term.\n\nHowever in doing so we would have enabled general recursion and\ninherit all the difficulties that come with that. For example, some\ndoofus could use a script that consists of or has the same effect as a\nsingle DUP to cause an infinite loop in the script interpreter. And\nthat's just the tip of the iceberg of problems general recursion can\nbring, which stem generally from resource usage no longer being\ncorrelated with the size of the witness stack, which is the primary\nresource for which there are global limits.\n\nThis is fixable with a gas-like resource accounting scheme, which\nwould affect not just script but also mempool, p2p, and other\nlayers. And there is perhaps an argument for doing so, particularly as\npart of a hard-fork block size increase as more accurate resource\naccounting helps prevent many bad-block attacks and let us set\nadversarial limits closer to measured capacity in the expected/average\nuse case. But that would immensely complicate things beyond what could\nachieve consensus in a reasonably short amount of time, which is a\ngoal of this proposal.\n\nInstead I suggest blocking off general recursion by only allowing the\nscript interpreter to do one tail-call per input. To get log-scaling\nbenefits without deep recursion we introduce instead one new script\nfeature, which we'll cover in the next section. But we do leave the\ndoor open to possible future general recursion, as we will note that\ngoing from one layer of recursion to many would itself be a soft-fork\nfor the same reason that the first tail-call recursion is.\n\n\nMerkle branch verify to the rescue!\n\nIn #bitcoin-wizards and elsewhere there has been a desire for some\ntime to have an opcode that proves that an item was drawn from the set\nused to construct a given Merkle tree. This is not a new idea although\nI'm not aware of any actual proposal made for it until now. The most\nsimple version of the opcode, the version initially proposed, takes\nthree arguments:\n\n  <proof> <leaf-hash> <root-hash> MERKLEBRANCHVERIFY 2DROP DROP\n\n<root-hash> is the 32-byte hash label of the root of the Merkle tree,\ncalculated using a scheme defined in the fast Merkle hash tree BIP.\n\n<leaf-hash> is 32 bytes of data which we are proving is part of the\nMerkle hash tree -- usually the double-SHA256 hash of an item off the\nstack.\n\n<proof> is the path through the Merkle tree including the hashes of\nbranches not taken, which is the information necessary to recalculate\nthe root hash thereby proving that <leaf-hash> is in the Merkle tree.\n\nThe 2DROP and DROP are necessary to remove the 3 arguments from the\nstack, as the opcode cannot consume them since it is soft-forked in.\nThere are two primary motivating applications of Merkle branch verify\n(MBV), which will be covered next.\n\nThe MBV BIP will be extended to support extraction of more than one\nitem from the same Merkle tree, but for the rest of this explanation\nwe assume the current implementation of a single item proof, just for\nsimplicity.\n\n\nMBV and MAST\n\nThis new opcode combines with single tail-call execution semantics to\nallow for a very short and succinct MAST implementation:\n\n  OVER HASH256 <root-hash> MERKLEBRANCHVERIFY 2DROP DROP\n\nThat's it. This script expects an input stack in the following format:\n\n  <argN> ... <arg1> <policyScript> <proof>\n\nAt the end of execution the script has verified that <policyScript> is\npart of the Merkle tree previously committed to, and <proof> is\ndropped from the stack. This leaves the stack ready for a tail-call\nrecursion into <policyScript>.\n\n\nMBV and Key Aggregation\n\nIf the signature scheme supports key aggregation, which it happens\nthat the the new signature aggregation scheme being worked on will\nsupport as a side effect, then there is a very cool and useful\napplication that would be supported as well: tree signatures as\ndescribed by Pieter Wuille[1].  This looks almost exactly the same as\nthe MAST script, but with a CHECKSIG tacked on the end:\n\n  OVER HASH256 <root-hash> MERKLEBRANCHVERIFY 2DROP DROP CHECKSIG\n\nThis script expects an input stack of the following form:\n\n  <sig> <pubkey> <proof>\n\nAnd proves that the pubkey is drawn from the set used to construct the\nMerkle hash tree, and then its signature is checked. While it should\nbe clear this has 1-of-N semantics, what might be less obvious is that\nkey aggregation allows any signature policy expressible as a monotone\nBoolean function (anything constructible with combinations of AND, OR,\nand k-of-N thresholds) to be transformed to a 1-of-N over a set of key\naggregates. So the above script is a generic template able to verify\nany monotone Boolean function over combinations of pubkeys, which\nencompasses quite a number of use cases!\n\n[1] https://blockstream.com/2015/08/24/treesignatures.html\n\n\nAn argument for permission-less innovation\n\nThe driving motivation for the tail-call and MBV proposals, and the\nreason they are presented and considered together is to enable\nMerklized Abstract Syntax Trees. However neither BIP actually defines\na MAST template, except as an example use case of the primitive\nfeatures. This is very much on purpose: it is the opinion of this\nauthor that new bitcoin consensus features should follow the UNIX\nphilosophy as expressed by Peter Salus and Mike Gancarz and\nparaphrased by yours truly:\n\n  * Write features that do one thing and do it well.\n  * Write features to work together.\n  * Simple is beautiful.\n\nBy using modularity and composition of powerful but simple tools like\nMERKLEBRANCHVERIFY and single tail-call recursion to construct MAST we\nenable a complex and desirable feature while minimizing changes to the\nconsensus code, review burden, and acquired technical debt.\n\nThe reusability of the underlying primitives also means that they can\nbe combined with other modular features to support use cases other\nthan vanilla MAST, or reused in series to work around various limits\nthat might otherwise be imposed on a templated form of MAST. At the\nmoment the chief utility of these proposals is the straightforward\nMAST script written above, but as primitives they do allow a few other\nuse cases and also combine well with features in the pipeline or on\nthe drawing board. For example, in addition to MAST you can:\n\n1. Use MERKLEBRANCHVERIFY alone to support honeypot bounties, as\n   discussed in the BIP.\n\n2. Use a series of MERKLEBRANCHVERIFY opcodes to verify a branch with\n   split proofs to stay under script and witness push limitations.\n\n3. Combine MERKLEBRANCHVERIFY with key aggregation to get\n   Wuille-Maxwell tree signatures which support arbitrary signing\n   policies using a single, aggregatable signature.\n\n4. Combine tail-call execution semantics with CHECKSIGFROMSTACK to get\n   delegation and signature-time commitment to subscript policy.\n\n5. Combine MERKLEBRANCHVERIFY with a Merkle proof prefix check opcode\n   and Lamport signature support to get reusable Lamport keys.\n\nI believe these benefits and possible future expansions to be strong\narguments in favor of extending bitcoin in the form of small, modular,\nincremental, and reusable changes that can be combined and used even\nin ways unforeseen even by their creators, creating a platform for\nunrestricted innovation.\n\nThe alternative approach of rigid templates achieves the stated goals,\nperhaps even with slightly better encoding efficiency, but at the cost\nof requiring workaround for each future innovation. P2SH is just such\nan example -- we couldn't even upgrade to 128-bit security without\ndesigning an entirely different implementation because of the\nlimitations of template pattern matching.\n\n\nEfficiency gains from templating\n\nFinally, I need to point out that there is one efficiency gain that a\nproper template-matching implementation has over user-specified\nschemes: reduction of witness data. This is both a practical side\neffect of more efficient serialization that doesn't need to encode\nlogic as opcodes, as well as the fact that since the hashing scheme is\nfixed, one layer of hashes can be removed from the serialization. In\nthe case of MAST, rather than encode the Merkle root hash in the\nredeem script, the hash is propagated upwards and compared against the\nwitness commitment. The amount space saved from adopting a template is\nabout equal to the size of the redeem script, which is approximately\n40 bytes of witness data per MAST input.\n\nThat is arguably significant enough to matter, and in the long term I\nthink we will adopt a MAST template for those efficiency gains. But I\nfeel strongly that since MAST is not a feature in wide use at this\ntime, it is strongly in our interests to deploy MBV, tail-call, as\nwell overhaul the CHECKSIG operator before tackling what we feel an\nideal MAST-supporting witness type would look like, so that with some\nexperience under our belt we can adopt a system that is as simple and\nas succinct as possible while supporting the necessary use cases\nidentified by actual use of the features.\n\nKind regards,\nMark Friedenbach"
            },
            {
                "author": "Andreas M. Antonopoulos",
                "date": "2017-09-21T00:15:37",
                "message_text_only": "This was very helpful at least to me, thank you\n\nI've been struggling to follow the discussion of tail-call execution and\nunderstand the options for implementing MAST. This clarified everything. I\ncan now follow the previous discussions.\n\n\n\n\nOn Sep 20, 2017 18:56, \"Mark Friedenbach via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\nOver the past few weeks I've been explaining the MERKLEBRANCHVERIFY\nopcode and tail-call execution semantics to a variety of developers,\nand it's come to my attention that the BIPs presentation of the\nconcept is not as clear as it could be. Part of this is the fault of\nstandards documents being standards documents whose first and foremost\nresponsibility is precision, not pedagogy.\n\nI think there's a better way to explain this approach to achieving\nMAST, and it's worked better in the face to face and whiteboard\nconversations I've had. I'm forwarding it to this list in case there\nare others who desire a more clear explanation of what the\nMERKLEBRANCHVERIFY and tail-call BIPs are trying to achieve, and what\nany of it has to do with MAST / Merklized script.\n\nI've written for all audiences so I apologize if it starts of at a\nnewbie level, but I encourage you to skim, not skip as I quickly start\nvarying this beginner material in atypical ways.\n\n\nReview of P2SH\n\nIt's easiest to explain the behavior and purpose of these BIPs by\nstarting with P2SH, which we are generalizing from. BIP 16 (Pay to\nScript Hash) specifies a form of implicit script recursion where a\nredeem script is provided in the scriptSig, and the scriptPubKey is a\nprogram that verifies the redeem script hashes to the committed value,\nwith the following template:\n\n  HASH160 <hash> EQUAL\n\nThis script specifies that the redeem script is pulled from the stack,\nits hash is compared against the expected value, and by fiat it is\ndeclared that the redeem script is then executed with the remaining\nstack items as arguments.\n\nSortof. What actually happens of course is that the above scriptPubKey\ntemplate is never executed, but rather the interpreter sees that it\nmatches this exact template format, and thereby proceeds to carry out\nthe same logic as a hard-coded behavior.\n\n\nGeneralizing P2SH with macro-op fusion\n\nThis template-matching is unfortunate because otherwise we could\nimagine generalizing this approach to cover other use cases beyond\ncommitting to and executing a single redeem script. For example, if we\ninstead said that anytime the script interpreter encountered the\n3-opcode sequence \"HASH160 <20-byte-push> EQUAL\" it switched to\ninterpreting the top element as if it were a script, that would enable\nnot just BIP 16 but also constructs like this:\n\n  IF\n    HASH160 <hash-1> EQUAL\n  ELSE\n    HASH160 <hash-2> EQUAL\n  ENDIF\n\nThis script conditionally executes one of two redeem scripts committed\nto in the scriptPubKey, and at execution only reveals the script that\nis actually used. All an observer learns of the other branch is the\nscript hash. This is a primitive form of MAST!\n\nThe \"if 3-opcode P2SH template is encountered, switch to subscript\"\nrule is a bit difficult to work with however. It's not a true EVAL\nopcode because control never returns back to the top-level script,\nwhich makes some important aspects of the implementation easier, but\nonly at the cost of complexity somewhere else. What if there are\nremaining opcodes in the script, such as the ELSE clause and ENDIF in\nthe script above?  They would never be executed, but does e.g. the\nclosing ENDIF still need to be present? Or what about the standard\npay-to-pubkey-hash \"1Address\" output:\n\n  DUP HASH160 <20-byte-key-hash> EQUALVERIFY CHECKSIG\n\nThat almost looks like the magic P2SH template, except there is an\nEQUALVERIFY instead of an EQUAL. The script interpreter should\nobviously not treat the pubkey of a pay-to-pubkey-hash output as a\nscript and recurse into it, whereas it should for a P2SH style\nscript. But isn't the distinction kinda arbitrary?\n\nAnd of course the elephant in the room is that by choosing not to\nreturn to the original execution context we are no longer talking\nabout a soft-fork. Work out, for example, what will happen with the\nfollowing script:\n\n  [TRUE] HASH160 <hash-of-[TRUE]> EQUAL FALSE\n\n(It returns false on a node that doesn't understand generalized\n3-opcode P2SH recursion, true on a node that does.)\n\n\nImplicit tail-call execution semantics and P2SH\n\nWell there's a better approach than trying to create a macro-op fusion\nfranken-EVAL. We have to run scripts to the end to for any proposal to\nbe a soft-fork, and we want to avoid saving state due to prior\nexperience of that leading to bugs in BIP 12. That narrows our design\nspace to one option: allow recursion only as the final act of a\nscript, as BIP 16 does, but for any script not just a certain\ntemplate. That way we can safely jump into the subscript without\nbothering to save local state because termination of the subscript is\ntermination of the script as a whole. In computer science terms, this\nis known as tail-call execution semantics.\n\nTo illustrate, consider the following scriptPubKey:\n\n  DUP HASH160 <20-byte-hash> EQUALVERIFY\n\nThis script is almost exactly the same as the P2SH template, except\nthat it leaves the redeem script on the stack rather than consuming\nit, thanks to the DUP, while it _does_ consume the boolean value at\nthe end because of the VERIFY. If executed, it leaves a stack exactly\nas it was, which we assume will look like the following::\n\n  <argN> ... <arg1> <redeemScript>\n\nNow a normal script is supposed to finish with just true or false on\nthe stack. Any script that finishes execution with more than a single\nelement on the stack is in violation of the so-called clean-stack rule\nand is considered non-standard -- not relayable and potentially broken\nby future soft-fork upgrades. But so long as at least one bit of\n<redeemScript> is set, it is interpreted as true and the script\ninterpreter would normally interpret a successful validation at this\npoint, albeit with a clean-stack violation.\n\nLet's take advantage of that by changing what the script interpreter\ndoes when a script finishes with multiple items remaining on the stack\nand top-most one evaluates as true -- a state of affairs that would\npass validation under the old rules. Now instead the interpreter\ntreats the top-most item on the stack as a script, and tail-call\nrecurse into it, P2SH-style. In the above example, <redeemScript> is\npopped off the stack and is executed with <arg1> ... <argN> remaining\non the stack as its arguments.\n\nThe above script can be interpreted in English as \"Perform tail-call\nrecursion if and only if the HASH160 of the script on the top of the\nstack exactly matches this 20-byte push.\" Which is, of course, what\nBIP 16 accomplishes with template matching. However the implicit tail\ncall approach allows us to do much more than just P2SH!\n\nFor starters, it turns out that using HASH160 for P2SH was probably a\nbad idea as it reduces the security of a multi-party constructed hash\nto an unacceptable 80 bits. That's why segwit uses 256-bit hashes for\nits pay to script hash format, for 128-bit security. Had we tail call\nsemantics instead of BIP 16, we could have just switched to a new\naddress type that decodes to the following script template instead:\n\n  DUP HASH256 <32-byte-hash> EQUALVERIFY\n\nTa-da, we're back to full 128-bit security with no changes to the\nconsensus code, just a new address version to target this script\ntemplate.\n\n\nMAST with tail-call alone?\nOr: an aside on general recursion\n\nOur IF-ELSE Merklized Abstract Syntax Tree example above, rewritten to\nuse tail-call evaluation, might look like this (there are more compact\nformulations possible, but our purpose here is not code golf):\n\n  IF\n    DUP HASH160 <hash-1> EQUALVERIFY\n  ELSE\n    DUP HASH160 <hash-2> EQUALVERIFY\n  ENDIF\n\nEither execution pathway leaves us with one of the two allowed redeem\nscripts on the top of the stack, and presumably its arguments beneath\nit. We then execute that script via implicit tail-call.\n\nWe could write scripts using IF-ELSE branches or other tricks to\ncommit to more than two possible branches, although this unfortunately\nscales linearly with the number of possible branches. If we allow the\nsubscript itself to do its own tail-call recursion, and its subscript\nand so on, then we could nest these binary branches for a true MAST in\nthe original sense of the term.\n\nHowever in doing so we would have enabled general recursion and\ninherit all the difficulties that come with that. For example, some\ndoofus could use a script that consists of or has the same effect as a\nsingle DUP to cause an infinite loop in the script interpreter. And\nthat's just the tip of the iceberg of problems general recursion can\nbring, which stem generally from resource usage no longer being\ncorrelated with the size of the witness stack, which is the primary\nresource for which there are global limits.\n\nThis is fixable with a gas-like resource accounting scheme, which\nwould affect not just script but also mempool, p2p, and other\nlayers. And there is perhaps an argument for doing so, particularly as\npart of a hard-fork block size increase as more accurate resource\naccounting helps prevent many bad-block attacks and let us set\nadversarial limits closer to measured capacity in the expected/average\nuse case. But that would immensely complicate things beyond what could\nachieve consensus in a reasonably short amount of time, which is a\ngoal of this proposal.\n\nInstead I suggest blocking off general recursion by only allowing the\nscript interpreter to do one tail-call per input. To get log-scaling\nbenefits without deep recursion we introduce instead one new script\nfeature, which we'll cover in the next section. But we do leave the\ndoor open to possible future general recursion, as we will note that\ngoing from one layer of recursion to many would itself be a soft-fork\nfor the same reason that the first tail-call recursion is.\n\n\nMerkle branch verify to the rescue!\n\nIn #bitcoin-wizards and elsewhere there has been a desire for some\ntime to have an opcode that proves that an item was drawn from the set\nused to construct a given Merkle tree. This is not a new idea although\nI'm not aware of any actual proposal made for it until now. The most\nsimple version of the opcode, the version initially proposed, takes\nthree arguments:\n\n  <proof> <leaf-hash> <root-hash> MERKLEBRANCHVERIFY 2DROP DROP\n\n<root-hash> is the 32-byte hash label of the root of the Merkle tree,\ncalculated using a scheme defined in the fast Merkle hash tree BIP.\n\n<leaf-hash> is 32 bytes of data which we are proving is part of the\nMerkle hash tree -- usually the double-SHA256 hash of an item off the\nstack.\n\n<proof> is the path through the Merkle tree including the hashes of\nbranches not taken, which is the information necessary to recalculate\nthe root hash thereby proving that <leaf-hash> is in the Merkle tree.\n\nThe 2DROP and DROP are necessary to remove the 3 arguments from the\nstack, as the opcode cannot consume them since it is soft-forked in.\nThere are two primary motivating applications of Merkle branch verify\n(MBV), which will be covered next.\n\nThe MBV BIP will be extended to support extraction of more than one\nitem from the same Merkle tree, but for the rest of this explanation\nwe assume the current implementation of a single item proof, just for\nsimplicity.\n\n\nMBV and MAST\n\nThis new opcode combines with single tail-call execution semantics to\nallow for a very short and succinct MAST implementation:\n\n  OVER HASH256 <root-hash> MERKLEBRANCHVERIFY 2DROP DROP\n\nThat's it. This script expects an input stack in the following format:\n\n  <argN> ... <arg1> <policyScript> <proof>\n\nAt the end of execution the script has verified that <policyScript> is\npart of the Merkle tree previously committed to, and <proof> is\ndropped from the stack. This leaves the stack ready for a tail-call\nrecursion into <policyScript>.\n\n\nMBV and Key Aggregation\n\nIf the signature scheme supports key aggregation, which it happens\nthat the the new signature aggregation scheme being worked on will\nsupport as a side effect, then there is a very cool and useful\napplication that would be supported as well: tree signatures as\ndescribed by Pieter Wuille[1].  This looks almost exactly the same as\nthe MAST script, but with a CHECKSIG tacked on the end:\n\n  OVER HASH256 <root-hash> MERKLEBRANCHVERIFY 2DROP DROP CHECKSIG\n\nThis script expects an input stack of the following form:\n\n  <sig> <pubkey> <proof>\n\nAnd proves that the pubkey is drawn from the set used to construct the\nMerkle hash tree, and then its signature is checked. While it should\nbe clear this has 1-of-N semantics, what might be less obvious is that\nkey aggregation allows any signature policy expressible as a monotone\nBoolean function (anything constructible with combinations of AND, OR,\nand k-of-N thresholds) to be transformed to a 1-of-N over a set of key\naggregates. So the above script is a generic template able to verify\nany monotone Boolean function over combinations of pubkeys, which\nencompasses quite a number of use cases!\n\n[1] https://blockstream.com/2015/08/24/treesignatures.html\n\n\nAn argument for permission-less innovation\n\nThe driving motivation for the tail-call and MBV proposals, and the\nreason they are presented and considered together is to enable\nMerklized Abstract Syntax Trees. However neither BIP actually defines\na MAST template, except as an example use case of the primitive\nfeatures. This is very much on purpose: it is the opinion of this\nauthor that new bitcoin consensus features should follow the UNIX\nphilosophy as expressed by Peter Salus and Mike Gancarz and\nparaphrased by yours truly:\n\n  * Write features that do one thing and do it well.\n  * Write features to work together.\n  * Simple is beautiful.\n\nBy using modularity and composition of powerful but simple tools like\nMERKLEBRANCHVERIFY and single tail-call recursion to construct MAST we\nenable a complex and desirable feature while minimizing changes to the\nconsensus code, review burden, and acquired technical debt.\n\nThe reusability of the underlying primitives also means that they can\nbe combined with other modular features to support use cases other\nthan vanilla MAST, or reused in series to work around various limits\nthat might otherwise be imposed on a templated form of MAST. At the\nmoment the chief utility of these proposals is the straightforward\nMAST script written above, but as primitives they do allow a few other\nuse cases and also combine well with features in the pipeline or on\nthe drawing board. For example, in addition to MAST you can:\n\n1. Use MERKLEBRANCHVERIFY alone to support honeypot bounties, as\n   discussed in the BIP.\n\n2. Use a series of MERKLEBRANCHVERIFY opcodes to verify a branch with\n   split proofs to stay under script and witness push limitations.\n\n3. Combine MERKLEBRANCHVERIFY with key aggregation to get\n   Wuille-Maxwell tree signatures which support arbitrary signing\n   policies using a single, aggregatable signature.\n\n4. Combine tail-call execution semantics with CHECKSIGFROMSTACK to get\n   delegation and signature-time commitment to subscript policy.\n\n5. Combine MERKLEBRANCHVERIFY with a Merkle proof prefix check opcode\n   and Lamport signature support to get reusable Lamport keys.\n\nI believe these benefits and possible future expansions to be strong\narguments in favor of extending bitcoin in the form of small, modular,\nincremental, and reusable changes that can be combined and used even\nin ways unforeseen even by their creators, creating a platform for\nunrestricted innovation.\n\nThe alternative approach of rigid templates achieves the stated goals,\nperhaps even with slightly better encoding efficiency, but at the cost\nof requiring workaround for each future innovation. P2SH is just such\nan example -- we couldn't even upgrade to 128-bit security without\ndesigning an entirely different implementation because of the\nlimitations of template pattern matching.\n\n\nEfficiency gains from templating\n\nFinally, I need to point out that there is one efficiency gain that a\nproper template-matching implementation has over user-specified\nschemes: reduction of witness data. This is both a practical side\neffect of more efficient serialization that doesn't need to encode\nlogic as opcodes, as well as the fact that since the hashing scheme is\nfixed, one layer of hashes can be removed from the serialization. In\nthe case of MAST, rather than encode the Merkle root hash in the\nredeem script, the hash is propagated upwards and compared against the\nwitness commitment. The amount space saved from adopting a template is\nabout equal to the size of the redeem script, which is approximately\n40 bytes of witness data per MAST input.\n\nThat is arguably significant enough to matter, and in the long term I\nthink we will adopt a MAST template for those efficiency gains. But I\nfeel strongly that since MAST is not a feature in wide use at this\ntime, it is strongly in our interests to deploy MBV, tail-call, as\nwell overhaul the CHECKSIG operator before tackling what we feel an\nideal MAST-supporting witness type would look like, so that with some\nexperience under our belt we can adopt a system that is as simple and\nas succinct as possible while supporting the necessary use cases\nidentified by actual use of the features.\n\nKind regards,\nMark Friedenbach\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170920/8a904c22/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "An explanation and justification of the tail-call and MBV approach to MAST",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Andreas M. Antonopoulos",
                "Mark Friedenbach"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 34779
        }
    },
    {
        "title": "[bitcoin-dev] BIP proposal - Dandelion: Privacy Preserving Transaction Propagation",
        "thread_messages": [
            {
                "author": "Giulia Fanti",
                "date": "2017-09-21T02:10:29",
                "message_text_only": "Greetings bitcoin-dev,\n\n  We\u2019re returning to this thread to give an update on the Dandelion project\nafter several months of additional work. (Dandelion is a new\nprivacy-preserving transaction propagation method, which we are proposing\nas a BIP. See the original post in this thread\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-June/014571.html\nfor more background) The feedback on our initial BIP from Greg Maxwell in\nthis thread touched on several important issues affecting the protocol\ndesign, which it has taken us until now to adequately address.\n\nThe focus of this update is a new variant of the Dandelion++ mechanism\npresented earlier. The new variant is called \u201cPer-Incoming-Edge\u201d routing.\nIn a nutshell, while the earlier Dandelion++ variant calls for routing\n*each* stem transaction through a randomly chosen path, Per-Incoming Edge\nrouting causes each transaction from the same source to traverse the same\npseudorandom path. The most important benefit of Per-Incoming-Edge is that\nit prevents \u201cintersection attacks\u201d that result if a client broadcasts\nmultiple transactions over a short period of time. We validate this new\nvariant with new analysis and simulation as explained below.\n\nToday\u2019s update also includes an outline of our next development plans. We\nhave not yet completed a reference implementation, so this update does not\ninclude a new BIP. Instead we\u2019re just outlining the steps we plan to take\nbefore an updated BIP. The new approach also  impacts our implementation\napproach. Since Per-Incoming Edge routing simplifies the handling of orphan\ntransactions, we\u2019re now planning on adopting Greg Maxwell\u2019s suggestion to\nbypass the txMempool for dandelion stem transactions.\n\n======\n\nThe feedback on Dandelion from Greg Maxwell touched on a few important\nissues: (1) robustness to observations over time, aka \u201cintersection\nattacks\u201d, (2) protocol- or implementation-level data leaks, and (3) graph\nlearning.\n\n(1) With time, the adversary may be able to observe many message\ntrajectories, thereby eventually learning the underlying graph structure\nand/or improving its deanonymization estimate for a given estimate of the\ngraph structure. In our original Dandelion BIP, we addressed this by\nchanging the anonymity graph topology from a directed line to a directed\n4-regular graph. (In short, instead of a single outgoing edge for Dandelion\ntransactions, each node selects from  *two* such edges). This topology\nprovides robustness to adversaries who are able to learn the graph, but\nthose results still assume that each node generates only one transaction in\neach \u201cepoch\u201d (time between reshuffling the anonymity graph). Hence a big\nremaining question is to understand the effect of intersection attacks--an\nadversary observing multiple dependent transactions--on deanonymization\nprecision and recall.\n\n(2) The second issue is protocol- or implementation-level behavior that\nwould allow an adversary to actively probe Dandelion to learn more\ninformation than before. As you correctly note, we want to avoid the\nadversary using conflicting transactions to infer which nodes are in the\nstem. This issue is related to issue (1), in that our mechanism for\naddressing intersection attacks will determine what data structures we need\nin the implementation.\n\n(3) The third issue is that an adversary may be able to infer the structure\nof the graph by observing network traffic. We want to prevent this.\n\n----------\n\nIntersection Attacks\n\n----------\n\n\nAn adversary\u2019s ability to launch intersection attacks depends on the\ninternal Dandelion routing policy. Two natural ways to approach routing are\nthe following:\n\n 1. Per-Hop: For each incoming stem transaction, make an independent random\ndecision of (a) whether to transition to \u201cfluff\u201d phase, and (b) if \u201cstem\u201d,\nthen which node should we relay to. This means that two transactions, even\nstarting from the same source, take independent random walks through the\nanonymity graph. This is what our current implementation does.\n\n 2. Per-Inbound-Edge: For each inbound edge e, randomly select one outbound\nedge g, and relay all transactions arriving on edge e to edge g (assuming\nthe transaction remains in stem phase). Each node uses this relay mapping\nfor an entire epoch, which lasts about 10 min. Each source also randomly\nchooses one outbound edge g\u2019 for its own transactions; so if a node\ngenerates 5 transactions, they will all get propagated over edge g\u2019. This\napproach has the property that during an epoch, all transactions from a\nsingle source will take the same path through the stem graph.\n\nWe have simulated and analyzed these two routing protocols, and find that\nper-inbound-edge routing seems to be more robust to intersection attacks.\nFor our simulations we consider the \u201cfirst-spy\u201d estimator --- this means\nthe rule where the attacker simply guesses that the first peer to relay a\ntransaction to a spy node is the real source. Figure 1 (link below)\nillustrates the first-spy precision for per-incoming-edge routing and\nper-transaction routing when each node has *one* transaction. Higher\nprecision means worse anonymity. For comparison, this figure includes\ndiffusion, which is the spreading mechanism currently used. Here \u2018p\u2019\ndenotes the fraction of nodes in the network that are spies. (Recall that\nin our model, we treat the attacker has having control over some fraction\nof random nodes). The turquoise curve (labelled \u2018p\u2019) is shown for\nreference---it does not represent any routing protocol.\n\nhttps://github.com/gfanti/bips/blob/master/per-edge-vs-per-tx.jpg\n\nFirst, note that the first-spy estimator is thought to be significantly\nsuboptimal for diffusion (red line). Prior literature has shown that on\ncertain classes of graphs, there exist estimators that can detect diffusion\nsources with much higher probability than the first-spy estimator. While\nit\u2019s unclear how to apply those algorithms to Bitcoin\u2019s graph, it is likely\nthat strong algorithms exist. Hence the first-spy estimator serves as a\nlower bound on precision for diffusion. On the other hand, we can show\ntheoretically that the first-spy precision for per-tx and per-incoming-edge\nrouting is within a small constant factor of the optimal precision for\nper-incoming-edge routing. Thus, we expect that the green (per-edge) and\nblue (per-tx) lines reflect the near-optimal attack, whereas the red line\n(diffusion) could be much higher in practice.\n\nThe second issue to note is that the blue line (per-tx forwarding) has the\nlowest precision of the three protocols for one tx per node. The green line\n(per-edge forwarding) has higher precision than per-tx forwarding when\nthere are very few spies, but approaches per-tx forwarding as p increases.\nMoreover, it has lower precision than diffusion for p>=0.05.\n\nHowever, the real benefits of per-edge forwarding emerge as nodes start to\ntransmit multiple transactions. Under per-edge forwarding, even if nodes\ntransmit multiple transactions each, those transactions will traverse the\nsame path in the anonymity graph, thereby preventing the adversary from\nlearning any new information from later transactions. Meanwhile, under\nper-tx routing, we find empirically that as nodes generate an increasing\nnumber of transactions, each source generates a unique signature of\nspy-node-observations (we are currently working on a more detailed\nexploration of this question). We expect that such signatures can be used\nto exactly deanonymize users in cases where the adversary learns the\ngraph. Hence\nper-tx forwarding is actually quite fragile to adversaries learning the\ngraph, whereas per-incoming-edge is robust to intersection attacks. This is\none key reason for adopting per-incoming-edge forwarding.\n\nAdopting per-incoming-edge forwarding has another important implication: it\nbecomes easy to enforce the condition that child transactions never enter\nfluff mode before parent transactions. This significantly simplifies orphan\nhandling, and means that adversaries cannot infer that a preceding\ntransaction is still in stem mode just by passively listening to network\ntraffic. We revisit this issue in the next section.\n\n----------\n\nImplementation-Level Metadata Leaks\n\n----------\n\ntl;dr: concept ACK for gmaxwell\u2019s suggestion on a new per-peer data\nstructure instead of mempool\n\nRegardless of which routing policy we choose, it is important that\nimplementations do not leak more information about transactions than they\ndo in our model. It\u2019s especially important that spies do not get an\n\u201coff-path\u201d view of the nodes involved in the stem of a transaction. This\npractically means that implementations must be careful not to expose\nwhether or not a stem transaction was received, to any node except the two\nrandomly chosen ones. (i.e., not to supernodes that may make inbound\nconnections to thousands of nodes).\n\nWe are currently developing a reference implementation for Dandelion++, as\na patch against Bitcoin Core. It requires thoughtful integration to make\nthis patch, and the choice of routing policy informs our approach. We have\nso far considered two main integration approaches, whose main difference is\nwhether or not they reuse the existing *txMempool* data structure to store\nstem mode transactions.\n\nA. Mempool embargo:\n\nThis how is our current implementation works. Stem transactions are only\nrelayed if they are accepted to mempool. Stem transactions are \u201cembargoed\u201d\nby suppressing them from MEMPOOL and INV messages sent from the node. This\nwas the easiest to implement while preserving all of Bitcoin\u2019s existing DoS\nprevention. In particular, it simplifies the handling of orphan\ntransactions, because the AcceptToMempool routine already handles orphan\ntransactions. However, this approach comes with a risk of indirect leakage,\nespecially if some edge case is missed in implementation.\n\nB. Avoid modifying mempool (or any global structure) for stem transactions:\n\nThis is the approach preferred by Greg Maxwell. The main benefit is that it\nis much more clear that there is no indirect leakage, although it makes it\nharder to argue there is no additional DoS concern. We have already taken a\ncouple of steps towards implementing this here:\nhttps://github.com/gfanti/bitcoin/commits/dandelion-nomempool The main idea\nis to avoid duplicating the rules for whether a transaction would be\naccepted into mempool or not, by adding a \u201cdry run\u201d option to the\nAcceptToMempool function. Our implementation of this approach is not yet\nfinished; it still remains to develop the per-peer data structure.\n\nOrphan transactions are important for per-tx routing, because with per-tx\nrouting, the child and the parent might travel along different stems. A\nburst of transactions from a single sender would have to be queued so they\nenter fluff mode sequentially. A lot of our testing (with the included test\nframework) involved ensuring such transactions were handled effectively.\nThis was also the deciding factor for our choice of using Option B \u201cMempool\nEmbargo\u201d above. With Per-incoming Edge routing, however, orphan transaction\nhandling can be simplified, since out-of-order transactions would not be\nsent along stems.\n\nWe therefore plan to re-engineer a much of our reference implementation to:\n\n1) use per-incoming edge routing,\n\n2) simplify handling of orphan transactions,\n\n3) adopt the proposed approach of avoiding the mempool data structure for\nstem transactions.\n\nWe\u2019ll give an update soon on our development progress before updating the\nBIP.\n\n----------\n\nGraph Learning\n\n----------\n\n\nGreg Maxwell also asked:\n\n```\n\nHas any work been given to the fact that dandelion propagation\npotentially making to measure properties of the inter-node connection\ngraph?  e.g.  Say I wish to partition node X by disconnecting all of\nits outbound connections, to do that it would be useful to learn whom\nis connected to X.  I forward a transaction to X, observe the first\nnode to fluff it,  then DOS attack that node to take it offline.  Will\nI need to DOS attack fewer or more nodes  to get all of X's outbounds\nif X supports rapid stem forwarding?\n\n```\n\nIn terms of graph learning, there are two graphs to consider: the anonymity\ngraph (i.e., the stem set of each node), and the main P2P graph. Dandelion\nhas at least as good graph-hiding properties as diffusion for a natural\nclass of attacks (which include the attack described in the comment above).\n\n\nConsider the task of learning the main P2P graph in today\u2019s network (under\ndiffusion spreading). Suppose a supernode is connected to all nodes, and\nwants to learn the 1-hop neighbors of a given target node. The eavesdropper\npasses a transaction to the target, and waits to hear which nodes relay the\ntransaction first. If the target has 8 outbound neighbors, then in each\nexperiment, the supernode will receive 8 independent relay timestamps from\nthe target\u2019s 1-hop neighbors. By repeating this many times, the adversary\ncan infer the 1-hop neighbors as the nodes who relay the transaction with\nthe appropriate mean delay (taking into account the appropriate exponential\nparameters). Eventually, this set will be learned with high certainty.\n\nNow consider the same task if the target is a Dandelion node. Note that the\nsupernode\u2019s probe tx must be relayed as a Dandelion message to observe any\ndifference with the prior experiment. First of all, the target will only\npass the tx to one node in its stem set. Hence, in each experiment, the\nsupernode can learn at most one timestamp from a relevant node, whereas\npreviously it learned eight per experiment. This inherently reduces the\nadversary\u2019s learning rate. Second, if the target\u2019s relay is a Dandelion\nnode and chooses to extend the stem, then the supernode will not receive any\nrelevant timestamp (i.e. a timestamp from a 1-hop neighbor) unless the\nsupernode lies in the relay\u2019s stem set. This happens with a probability\nthat depends on the level of deployment and the number of (seemingly)\ndistinct nodes being run by the supernode, but is strictly smaller than 1.\n\n   _ Hence, the rate at which an attacker can learn the main P2P graph is\nstrictly higher under diffusion (as in Bitcoin Core today) compared to\nusing Dandelion. _\n\nA similar argument can be made for the anonymity graph, which we currently\nimplement as an overlay to the main P2P graph.\n\n=====\n\nResponses to Other Miscellaneous Comments\n\n====\n\n```\n\nAn alternative construction would be that when a stem transaction goes\nout there is a random chance that the stem flag is not set (with\nsuitable adjustment to keep the same expected path length)\n\nFor some reason I believe this would be a superior construction, but I\nam only able to articulate one clear benefit:  It allows non-dandelion\ncapable nodes to take on the role of the last stem hop, which I\nbelieve would improve the anonymity set during the transition phase.\n\n```\n\nAgreed, this is actually what we have implemented.\n\n\n---------\n\nThanks!\n\nGiulia Fanti <gfanti at andrew.cmu.edu>\nAndrew Miller <soc1024 at illinois.edu>\nSurya Bakshi <sbakshi3 at illinois.edu>\nShaileshh Bojja Venkatakrishnan <bjjvnkt2 at illinois.edu>\nPramod Viswanath <pramodv at illinois.edu>\n\n\n\nDate: Tue, 13 Jun 2017 01:00:50 +0000\n> From: Gregory Maxwell <greg at xiph.org>\n> To: Andrew Miller <soc1024 at illinois.edu>\n> Cc: Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: Re: [bitcoin-dev] BIP proposal - Dandelion: Privacy\n>         Preserving Transaction Propagation\n> Message-ID:\n>         <CAAS2fgRAnGMMxKPCaj1SL=z3O2wuGS8nyPrgtGhSpuGgAoVtKg at mail.\n> gmail.com>\n> Content-Type: text/plain; charset=\"UTF-8\"\n>\n> On Mon, Jun 12, 2017 at 2:46 PM, Andrew Miller via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > Dear bitcoin-dev,\n> >    We've put together a preliminary implementation and BIP for\n> > Dandelion, and would love to get your feedback on it. Dandelion is a\n> > privacy-enhancing modification to Bitcoin's transaction propagation\n> > mechanism. Its goal is to obscure the original source IP of each\n> > transaction.\n>\n> I'm glad to see this out now, so I'm not longer invading the git repo\n> uninvited. :)\n>\n> >  - Stronger attacker model: we defend against an attacker that\n> > actively tries to learn which nodes were involved in the stem phase.\n> > Our approach is called \"Mempool Embargo\", meaning a node that receives\n> > a \"stem phase\" transaction behaves as though it never heard of it,\n> > until it receives it again from someone else (or until a random timer\n> > elapsess).\n>\n>\n> The description in the BIP appears inadequate:\n>\n>\n> > That is, Alice will not include the embargoed transaction when\n> responding to MEMPOOL requests, and will not respond to GETDATA requests\n> from another node (Bob) unless Alice previously sent an INV to Bob. The\n> embargo period ends as soon as Alice receives an INV advertising the\n> transaction as being in fluff mode.\n>\n> For example, it's not clear if I can query for the existence of a\n> transaction by sending a conflict.  If this doesn't seem problematic,\n> consider the case where I, communicating with you over some private\n> channel, send you a payment inside a payment protocol message. You\n> announce it to the network and I concurrently send a double spend.\n> Only nodes that were part of the stem will reject my double spend, so\n> I just learned a lot about your network location.\n>\n> It's also appears clear that I can query by sending an inv and\n> noticing that no getdata arrives.  An example attack in the latter is\n> that when I get a stem transaction I rapidly INV interrogate the\n> entire network and by observing who does and doesn't getdata I will\n> likely learn the entire stem path upto permutation.\n>\n> The extra network capacity used by getdata-ing a transaction you\n> already saw via dandelion would be pretty insignificant.\n>\n> I believe the text should be simplified and clarified so just say:\n>\n> \"With the exception of her behavior towards the peer sending in the\n> stem transaction and the peer sending out the transaction Alice's\n> behavior should be indistinguishable from a node which has not seen\n> the transaction at all until she receives it via ordinary forwarding\n> or until after the timeout.\" -- then its up to the implementation to\n> achieve indistinguishably regardless of what other protocol features\n> it uses.\n>\n> > Are there other ways we haven't thought of? We think the alternative\n> > approach (bypassing mempool entirely) seems even harder to get right,\n> > and foregoes existing DoS protection.\n>\n> I think avoiding the is the most sensible way; and from a software\n> maintenance perspective I expect that anything less will end up\n> continually suffering from serious information leaks which are hard to\n> avoid accidentally introducing via other changes.\n>\n> The primary functionality should be straightforward to implement,\n> needing just a flag to determine if a transaction would be accepted to\n> the mempool but for the flag, but which skips actually adding it.\n>\n> Handling chains of unconfirmed stem transactions is made more\n> complicated by this and this deserves careful consideration. I'm not\n> sure if its possible to forward stem children of stem transactions\n> except via the same stem path as the parent without leaking\n> information, it seems unlikely.\n>\n> This approach would mostly take additional complexity from the need to\n> limit the amplification of double spends. I believe this can be\n> resolved by maintaining a per-peer map of the not yet expired vin's\n> consumed by stem fowards sent out via that peer. E.g. vin->{timeout,\n> feerate}.  Then any new forward via that stem-peer is tested against\n> that map and suppressed if it it spends a non-timed-out input and\n> doesn't meet the feerate epsilon for replacement.\n>\n> Use of the orphan map is not indistinguishable as it is used for block\n> propagation, and itself also a maintenance burden to make sure\n> unrelated code is not inadvertently leaking the stem transactions.\n>\n> > After a random number of hops along the stem, the transaction enters the\n> fluff phase,\n>\n> The BIP is a bit under-specified on this transition, I think-- but I\n> know how it works from reading the prior implementation (I have not\n> yet read the new implementation).\n>\n> The way it works (assuming I'm not confused and it hasn't changed) is\n> that when a new stem transaction comes in there is a chance that it is\n> treated as coming in as a normal transaction.\n>\n> An alternative construction would be that when a stem transaction goes\n> out there is a random chance that the stem flag is not set (with\n> suitable adjustment to keep the same expected path length)\n>\n> For some reason I believe this would be a superior construction, but I\n> am only able to articulate one clear benefit:  It allows non-dandelion\n> capable nodes to take on the role of the last stem hop, which I\n> believe would improve the anonymity set during the transition phase.\n>\n> Unrelated:\n>\n> Has any work been given to the fact that dandelion propagation\n> potentially making to measure properties of the inter-node connection\n> graph?  e.g.  Say I wish to partition node X by disconnecting all of\n> its outbound connections, to do that it would be useful to learn whom\n> is connected to X.  I forward a transaction to X, observe the first\n> node to fluff it,  then DOS attack that node to take it offline.  Will\n> I need to DOS attack fewer or more nodes  to get all of X's outbounds\n> if X supports rapid stem forwarding?\n>\n>\n> ------------------------------\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170920/ca00a9c4/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP proposal - Dandelion: Privacy Preserving Transaction Propagation",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Giulia Fanti"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 21828
        }
    },
    {
        "title": "[bitcoin-dev] Sidechains: Mainstake",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2017-09-23T01:49:11",
                "message_text_only": "Good morning bitcoin-dev,\n\nI have yet another sidechain proposal: https://zmnscpxj.github.io/sidechain/mainstake/index.html\n\nI make the below outlandish claims in the above link:\n\n1. While a 51% mainchain miner theft is still possible, it will take even longer than in drivechains (either months of broadcasting intent to steal before the theft, or locking funds that are likely to remain locked after a week-long theft).\n2. A 26% anti-sidechain miner cannot completely block all sidechain withdrawals as they could in drivechains.\n3. Outside of attacks and censorship, the economic majority controls sidechains, without going through miners as \"representatives of the economic majority\".\n4. With sufficient cleverness (stupidity?), proof-of-stake can be made to work.\n\nI hope for your consideration.  I suspect that I have not thought things out completely, and probably missed some significant flaw.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170922/ef4ebaac/attachment.html>"
            },
            {
                "author": "Chris Stewart",
                "date": "2017-09-26T17:51:50",
                "message_text_only": ">For each sidechain ID, for each mainchain block, at most one sidechain\nblock header may be published. In addition, the sidechain block header\npublished on the mainchain blocks may only be published by the stake\nlottery winner from the end of the previous block.\n\nWhat happens if the stake winner disappears? It seems, in your scheme, that\nthis would cause progress to come to a screeching halt.\n\nOur weak mitigation against a mainchain miner >50% attack is weakened\n> further; now the mainchain miner with 51% hashpower need only block the\n> creation of sidechain mainstake UTXOs except its own, and eventually the\n> other mainstake UTXOs will time out and the miner can outright steal\n> costlessly\n\n\nCan we not nest mainstake outputs in p2wsh/p2sh scripts to mitigate this?\nThis means that they cannot block the creation of mainstake utxos -- but I\nguess they would still be able to block the spends of this utxo.\n\nAnother thing that is problematic with using a p2sh output is 'relocking'\nthe stake. Unfortunately if the p2sh script hash's aren't identical I don't\nthink we can guarantee they didn't spend the stake to a non stake output.\nIf the script hash's *are* identical then the miner can censor the\ntransaction that re-locks the output.\n\nPerhaps there is a hybrid that would work, however it depends on what you\nmean by 'creation'. If it is just the *initial* creation of the utxo -- and\nnot subsequent OP_STAKEVERIFY change outputs -- I think this strategy might\nwork. You just won't be able to participate in the lottery while the utxo\nis nested inside the p2sh output initially.\n\nThis also brings back the problem above -- what if a stake winner\ndisappears -- or a miners creates the illusion they disappeared via\ncensorship? I guess a miner would be losing out on transaction fees.\n\n-Chris\n\n\n\nOn Fri, Sep 22, 2017 at 8:49 PM, ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning bitcoin-dev,\n>\n> I have yet another sidechain proposal: https://zmnscpxj.github.io/\n> sidechain/mainstake/index.html\n>\n> I make the below outlandish claims in the above link:\n>\n> 1. While a 51% mainchain miner theft is still possible, it will take even\n> longer than in drivechains (either months of broadcasting intent to steal\n> before the theft, or locking funds that are likely to remain locked after a\n> week-long theft).\n> 2. A 26% anti-sidechain miner cannot completely block all sidechain\n> withdrawals as they could in drivechains.\n> 3. Outside of attacks and censorship, the economic majority controls\n> sidechains, without going through miners as \"representatives of the\n> economic majority\".\n> 4. With sufficient cleverness (stupidity?), proof-of-stake can be made to\n> work.\n>\n> I hope for your consideration.  I suspect that I have not thought things\n> out completely, and probably missed some significant flaw.\n>\n> Regards,\n> ZmnSCPxj\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170926/ceeacc15/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-09-26T22:38:59",
                "message_text_only": "Good morning,\n\n>>For each sidechain ID, for each mainchain block, at most one sidechain block header may be published. In addition, the sidechain block header\n>published on the mainchain blocks may only be published by the stake lottery winner from the end of the previous block.\n>\n>What happens if the stake winner disappears? It seems, in your scheme, that this would cause progress to come to a screeching halt.\n\nThe stake winner is only valid for a specific mainchain block.  If the stake winner is unable to publish a sidechain header on that mainchain block, then the mainchain block contains no sidechain header.  On the next mainchain block, a new stake winner is selected based on the mainchain block header hash of the mainchain block containing no sidechain header, hopefully that will be a different mainstaker.  So the stake winner will only slow down the sidechain temporarily.\n\nBasically, the time to the next mainchain block is the \"timeout\" that the stake winner has to publish its sidechain header.  If we assume that mainchain will operate continuously (because a massive lack of mainchain activity would imply the death of the mainchain anyway) then the sidechain only gets slowed down (no block) if the stake winner does not respond.  Presumably this will not happen if the sidechain has pending transactions, as the stake winner would \"lose its winning ticket\" if it was unable to respond in a timely manner and lose its opportunity to earn sidechain transaction fees.\n\nIf the stake winner has lost keys completely, then the stake has a lock time and after the lock time the stake will no longer be part of the stake lottery, so while it would slow down the sidechain until the lock time, after the lock time it will no longer have an effect.\n\nA passive attack, where a mainstaker just stakes and resets the stake when its lock time arrives, but does not publish any sidechain headers, will slow down the sidechain, but the mainstaker could have been earning sidechain fees if it were participating honestly instead, so the passive mainstaker suffers opportunity cost.\n\n>>Our weak mitigation against a mainchain miner >50% attack is weakened further; now the mainchain miner with 51% hashpower need only block the\n>creation of sidechain mainstake UTXOs except its own, and eventually the other mainstake UTXOs will time out and the miner can outright steal\n>costlessly\n>\n>Can we not nest mainstake outputs in p2wsh/p2sh scripts to mitigate this? This means that they cannot block the creation of mainstake utxos -- but I\n>guess they would still be able to block the spends of this utxo.\n\nThe lottery needs to be executable by the mainchain fullnodes.  Thus the mainchain fullnodes need to be aware of which UTXOs are to be put in the lottery, not just the sidechain fullnodes.  This is why I use scriptPubKey, rather than P2SH redeemScript.  However, this does allow mainchain miners to be aware of which UTXOs are mainstakes also, and allows them to censor these transactions.\n\n>Another thing that is problematic with using a p2sh output is 'relocking' the stake. Unfortunately if the p2sh script hash's aren't identical I don't think we\n>can guarantee they didn't spend the stake to a non stake output. If the script hash's *are* identical then the miner can censor the transaction that\n>re-locks the output.\n>\n>Perhaps there is a hybrid that would work, however it depends on what you mean by 'creation'. If it is just the *initial* creation of the utxo -- and not\n>subsequent OP_STAKEVERIFY change outputs -- I think this strategy might work. You just won't be able to participate in the lottery while the utxo is\n>nested inside the p2sh output initially.\n\nYes, it prevents the lottery from including the UTXO.  As it is not in the lottery, it cannot be a stake winner and cannot publish a sidechain block header until the lock time, when it can now publish openly that it is a stake UTXO using scriptPubKey.  This makes OP_STAKEVERIFY work almost as much as OP_CHECKLOCKTIMEVERIFY when inside a redeemScript.\n\n>This also brings back the problem above -- what if a stake winner disappears -- or a miners creates the illusion they disappeared via censorship? I\n>guess a miner would be losing out on transaction fees.\n\nYes, although the mainchain transaction fees from publishing sidechain block headers will only be marginally higher than the prevailing fee rate of the block.  For a particular block, the stake winner has a monopoly (it is the only one allowed to publish a sidechain header for that block) and does not need to bid with other mainstakers, and can bid the minimum necessary just to get into the mainchain block.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170926/6965d03b/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Sidechains: Mainstake",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Chris Stewart"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 9217
        }
    },
    {
        "title": "[bitcoin-dev] idea post: bitcoin side chain implementation",
        "thread_messages": [
            {
                "author": "Patrick Sharp",
                "date": "2017-09-25T21:53:30",
                "message_text_only": "Hello Devs,\n\nI am Patrick Sharp. I just graduated with a BS is computer science. Forgive\nmy ignorance.\n\nAs per bip-0002 I have scoured each bip available on the wiki to see if\nthese ideas have already been formally proposed and now as per bip-0002\npost these ideas here.\n\nFirst and foremost I acknowledge that these ideas are not original nor new.\n\nSide Chains:\n\nBip-R10 offers a mechanism to assign custody or transfer coins from one\nchain to another. However I did not find a bip that proposed a formal\nbitcoin side chain.\n\nMy proposal\n\n   - They are officially supported, tracked and built by official bitcoin\n   software meaning that they are not an external chain\n   - each chain has an identifier in the block header i.e. main chain: 0,\n   first chain: 1, second chain: 2...\n   - the number of chains including the main chain that exists is always a\n   power of 2, this power will also be included in the block header.\n   - each address is assigned to a chain via chain = (address) mod (number\n   of chains)\n      - to be valid an addresse's next transaction will first send their\n      coins to their chain if they are not already there\n      - if the address they are sending to is outside their chain their\n      transaction will be submitted to both chains and transaction fee will be\n      split between chains\n   - They come into being via a fork or split\n      - every 2016 blocks (upon recalculation of difficulty) if some\n      percentage (lets say 10%) of blocks on any chain are larger than some\n      specified amount (lets say 750 KB) then all chains are called to\nincrement\n      their power value and fork on their block.\n         - miner of chain x creates genesis block for chain x+2^previous\n         power\n         - upon fork, the difficulty of the old chain and the new chain\n         will be half the next difficulty\n      - if every chain has gone 2016 block without surpassing some amount\n      (lets say 250 KB) at least some percentage of the time (lets say 10%) all\n      chains will be called to join, decrement their power and double their\n      difficulty\n         - given miner of chain x, if x not less than 2^new power, chain\n         will be marked dead or sleeping\n         - miners who mine blocks on the chain that was joined (the chain\n         with the smaller identifier) may have to make a block for the sleeping\n         chain if transactions include funds that fully or partially\noriginate from\n         the sleeping chain\n         - dead chain are revived on next split.\n      - each block's reward outside of transaction fees will be the\n      (current bounty / 2^fork power) except obviously for dead blocks who's\n      reward is already included in their joined block\n   - benefits\n      - dynamically scales to any level of usage, no more issues about\n      block size\n      - miners have incentive to keep all difficulties close to parity\n      - if miners are limited by hard drive space they don't have to mine\n      every chain (though they should have trusted peers working on\nother chains\n      to verify transactions that originate off their chains, faulty block will\n      still be unaccepted by the rest of the miners)\n      - though work will still grow linearly with the number of chains due\n      to having to hash each separate header, some of the overhead may remain\n      constant and difficulty and reward will still be balanced.\n      - transactions are pseudo equally distributed between chains.\n      - rewards will be more distributed (doesn't' really matter, except\n      that its beautiful)\n   - cons\n      - because most transactions will be double recorded the non-volatile\n      memory foot print of bitcoin doubles (since miners do not need\nall chains i\n      believe this solution not only overcomes this cost but may decrease the\n      foot print per miner in the long run overall)\n      - transactions will hang in limbo until both chains have picked them\n      up, a forever limboed transaction could result in lost coins, as\nlong as a\n      transaction fee has been included this risk should be mitigated.\n\nI believe this idea is applicable to the entire community. I would like\nyour thoughts and suggestions. I obviously think this is a freaking awesome\nidea. I know it is quite ambitious but it is the next step in evolution\nthat bitcoin needs to take to be a viable competitor to visa.\n\nI come to you to ask if this has any chance of acceptance.\n\n-Patrick\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/515236fc/attachment-0001.html>"
            },
            {
                "author": "CryptAxe",
                "date": "2017-09-25T22:58:52",
                "message_text_only": "Have you taken a look at Elements or Drivechains yet by chance?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/0ce30d83/attachment.html>"
            },
            {
                "author": "Patrick Sharp",
                "date": "2017-09-26T00:07:12",
                "message_text_only": "I shamefully was not aware. However familiarized myself with them.\n\nNon official chains suffer from the fact that few if any miners are going\nto mine them so they lack security on par with the main chain. And more\nover most users aren't going to use them because its not magic.\n\nThat being said think they are and will always be a great place to develop\nand prove out concepts.\n\nIf my ultimate goal is official side chains that include part of the reward\nsuch security is at parity between all chains and that the official\nsoftware automatically enable users to distribute their burden, would my\ncourse of action be to build an external proof-of-concept side chain of\nside chains?\nor do you doubt that official reward splitting chains will ever find their\nway into bitcoin core?\n\nOn Mon, Sep 25, 2017 at 4:58 PM, CryptAxe <cryptaxe at gmail.com> wrote:\n\n> Have you taken a look at Elements or Drivechains yet by chance?\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/89b2b5fa/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-09-26T00:35:39",
                "message_text_only": "Good morning Patrick,\n\n>Non official chains suffer from the fact that few if any miners are going to mine them so they lack security on par with the main chain.\n\nThat is why most sidechain proposals use some kind of merge mining, where a commitment to another chain's block is published on the Bitcoin chain.  Drivechain has \"blind\" merge mining, my recent \"mainstake\" proposal publishses entire sidechain block headers on the mainchain.  These techniques provide security that is nearer to mainchain security.\n\n>And more over most\n>users aren't going to use them because its not magic.\n\nNo technology is magic, so I do not understand this sentence.\n\n>If my ultimate goal is official side chains that include part of the reward such security is at parity between all chains and that the official software\n>automatically enable users to distribute their burden, would my course of action be to build an external proof-of-concept side chain of side chains?\n>or do you doubt that official reward splitting chains will ever find their way into bitcoin core?\n\nI think it would be better to term your system as \"sharding\" rather than \"sidechain\".\n\nIf and when we are able to actually agree upon some kind of sidechain-enabling proposal that is acceptable to the majority of Bitcoin Core developers, then yes, you should make a sidechain that is capable of sharding.  Sharding a distributed ledger while ensuring correct operation is a hard problem; in particular it is almost impossible to protect against double-spending unless you can see all officially-added-to-the-chain transactions.\n\nSee: https://petertodd.org/2015/why-scaling-bitcoin-with-sharding-is-very-hard\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/79852421/attachment-0001.html>"
            },
            {
                "author": "Patrick Sharp",
                "date": "2017-09-26T01:15:09",
                "message_text_only": "By magic I meant that that it happens all by itself without any extra\nconfiguring.\n\nThank you for your responses. I have been enlightened. As ZmnSCPxj has\npointed out lightning network and pruning accomplishes everything I set out\nto accomplish. And sharding is exactly what I had in mind. I will keep this\nin the back of my mind and perhaps even attempt will implement it if it\nstill seems worth doing later.\n\nYou guys are totally awesome!!!\n\nI here by withdraw my proposal for the time being.\n\n-patrick\n\nOn Mon, Sep 25, 2017 at 6:35 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Patrick,\n>\n>\n> >Non official chains suffer from the fact that few if any miners are going\n> to mine them so they lack security on par with the main chain.\n>\n> That is why most sidechain proposals use some kind of merge mining, where\n> a commitment to another chain's block is published on the Bitcoin chain.\n> Drivechain has \"blind\" merge mining, my recent \"mainstake\" proposal\n> publishses entire sidechain block headers on the mainchain.  These\n> techniques provide security that is nearer to mainchain security.\n>\n> >And more over most\n> >users aren't going to use them because its not magic.\n>\n> No technology is magic, so I do not understand this sentence.\n>\n> >If my ultimate goal is official side chains that include part of the\n> reward such security is at parity between all chains and that the official\n> software\n> >automatically enable users to distribute their burden, would my course of\n> action be to build an external proof-of-concept side chain of side chains?\n> >or do you doubt that official reward splitting chains will ever find\n> their way into bitcoin core?\n>\n> I think it would be better to term your system as \"sharding\" rather than\n> \"sidechain\".\n>\n> If and when we are able to actually agree upon some kind of\n> sidechain-enabling proposal that is acceptable to the majority of Bitcoin\n> Core developers, then yes, you should make a sidechain that is capable of\n> sharding.  Sharding a distributed ledger while ensuring correct operation\n> is a hard problem; in particular it is almost impossible to protect against\n> double-spending unless you can see all officially-added-to-the-chain\n> transactions.\n>\n> See: https://petertodd.org/2015/why-scaling-bitcoin-with-\n> sharding-is-very-hard\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/82ac5fc6/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-09-26T00:01:10",
                "message_text_only": "Good morning Patrick,\n\nYour idea seems to focus more on scaling than on what sidechains actually were originally considered for.\n\nSidechains were originally designed to add and prototype new features to Bitcoin.  Increasing the effective block size is not what sidechains were expected to do.\n\nFor scaling, Lightning Network is a superior solution, as it keeps most transactions off-chain.\n\nFeatures are the important thing that sidechains are supposed to add to Bitcoin.\n\n1. Addresses are not how Bitcoin works under-the-hood.  Instead, P2PKH and P2SH addresses represent 2 kinds of standard output scripts.  It is possible in theory (with a lot of endless debate) to add new standard output scripts, some of which may not have an equivalent of an address.\n\n2.  It is easy to game your system.  A miner needs only to send a bunch of transactions from himself to himself to trigger the splitting condition.  It would even be possible to hide this somewhat by generating new public/private key pairs.\n\n3.  The problem with on-chain scaling is not that the code has this 1Mb limit.  The problem with on-chain scaling is delivering all of the block data to the rest of the network.  Crucially, in the case that block data delivery is slow, a larger mining pool with more resources and greater ability to handle larger blocks, will work better than smaller pools or solo miners due to orphan rate/stale rate.  Thus it is in the interest of large mining pools to push for large blocks and more data per second on-chain, in order to further consolidate their power and influence over Bitcoin.  As the censorship-resistance of Bitcoin is dependent on there being many small mining pools, larger blocks destroy censorship-resistance.\n\n4.  Disk space is not a problem.  It never was the problem.  Satoshi even mistakenly thought it was a problem, but it never was and it never will be.  The problem is that the computations on Bitcoin's security assume that blocks are delivered in 0 time.  That is not true in reality, but the reason why 10 minutes was selected as the block rate is to make block delivery time as close to 0 (relative to the average block rate) as possible.  Increasing block size makes block delivery time further from the ideal 0 that is the basis of Bitcon's security.\n\n5.  Mining is a random process and once splits occur, you can never assure that particular chains will synchronize the real-world time of 2016 blocks.  I mean, it would be come possible for one chain to finish in 1 week while another chain is never worked on.  The 2016-blocks schedule is even more likely to misalign in real time when further splits occur.\n\nRegards,\nZmnSCPxj\n\n-------- Original Message --------\nSubject: [bitcoin-dev] idea post: bitcoin side chain implementation\nLocal Time: September 25, 2017 9:53 PM\nUTC Time: September 25, 2017 9:53 PM\nFrom: bitcoin-dev at lists.linuxfoundation.org\nTo: bitcoin-dev at lists.linuxfoundation.org\n\nHello Devs,\n\nI am Patrick Sharp. I just graduated with a BS is computer science. Forgive my ignorance.\n\nAs per bip-0002 I have scoured each bip available on the wiki to see if these ideas have already been formally proposed and now as per bip-0002 post these ideas here.\n\nFirst and foremost I acknowledge that these ideas are not original nor new.\n\nSide Chains:\n\nBip-R10 offers a mechanism to assign custody or transfer coins from one chain to another. However I did not find a bip that proposed a formal bitcoin side chain.\n\nMy proposal\nThey are officially supported, tracked and built by official bitcoin software meaning that they are not an external chain\neach chain has an identifier in the block header i.e. main chain: 0, first chain: 1, second chain: 2...\nthe number of chains including the main chain that exists is always a power of 2, this power will also be included in the block header.\neach address is assigned to a chain via chain = (address) mod (number of chains)\nto be valid an addresse's next transaction will first send their coins to their chain if they are not already there\nif the address they are sending to is outside their chain their transaction will be submitted to both chains and transaction fee will be split between chains\nThey come into being via a fork or split\nevery 2016 blocks (upon recalculation of difficulty) if some percentage (lets say 10%) of blocks on any chain are larger than some specified amount (lets say 750 KB) then all chains are called to increment their power value and fork on their block.\nminer of chain x creates genesis block for chain x+2^previous power\nupon fork, the difficulty of the old chain and the new chain will be half the next difficulty\nif every chain has gone 2016 block without surpassing some amount (lets say 250 KB) at least some percentage of the time (lets say 10%) all chains will be called to join, decrement their power and double their difficulty\ngiven miner of chain x, if x not less than 2^new power, chain will be marked dead or sleeping\nminers who mine blocks on the chain that was joined (the chain with the smaller identifier) may have to make a block for the sleeping chain if transactions include funds that fully or partially originate from the sleeping chain\ndead chain are revived on next split.\neach block's reward outside of transaction fees will be the (current bounty / 2^fork power) except obviously for dead blocks who's reward is already included in their joined block\nbenefits\ndynamically scales to any level of usage, no more issues about block size\nminers have incentive to keep all difficulties close to parity\nif miners are limited by hard drive space they don't have to mine every chain (though they should have trusted peers working on other chains to verify transactions that originate off their chains, faulty block will still be unaccepted by the rest of the miners)\nthough work will still grow linearly with the number of chains due to having to hash each separate header, some of the overhead may remain constant and difficulty and reward will still be balanced.\ntransactions are pseudo equally distributed between chains.\nrewards will be more distributed (doesn't' really matter, except that its beautiful)\ncons\nbecause most transactions will be double recorded the non-volatile memory foot print of bitcoin doubles (since miners do not need all chains i believe this solution not only overcomes this cost but may decrease the foot print per miner in the long run overall)\ntransactions will hang in limbo until both chains have picked them up, a forever limboed transaction could result in lost coins, as long as a transaction fee has been included this risk should be mitigated.\nI believe this idea is applicable to the entire community. I would like your thoughts and suggestions. I obviously think this is a freaking awesome idea. I know it is quite ambitious but it is the next step in evolution that bitcoin needs to take to be a viable competitor to visa.\n\nI come to you to ask if this has any chance of acceptance.\n\n-Patrick\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/4e6eca75/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "idea post: bitcoin side chain implementation",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Patrick Sharp",
                "CryptAxe"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 17542
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Assistance",
        "thread_messages": [
            {
                "author": "Radcliffe, Mark",
                "date": "2017-09-25T21:53:40",
                "message_text_only": "My apologies if this post has been answered, but I am new to the list. I am lawyer trying to understand the licensing of the Bitcoin core and I  will be presenting in a webinar with Black Duck Software on Blockchain on September 28  (in case you are not familiar with them, Black Duck Software assists companies in managing their open source software resources). They have scanned the Bitcoin Core code for the open source licenses used in the codebase.  I am enclosing a summary of the findings. I would be interested in communicating with the individuals who manage this codebase and can provide insight about the project manages contributions because the codebase includes projects with inconsistent licenses (for example, code licensed under the Apache Software License version  2 and GPLv2 cannot work together in some situations). Thanks in advance.\n\nAccording to the scan, the code base includes code licensed under the following licenses:\n\n\nApache License 2.0\n\nBoost Software License 1.0\n\nBSD 2-clause \"Simplified\" License\n\nBSD 3-clause \"New\" or \"Revised\" License\n\nCreative Commons Attribution Share Alike 3.0\n\nExpat License\n\nGNU General Public License v2.0 or later\n\nGNU General Public License v3.0 or later\n\nGNU Lesser General Public License v2.1 or later\n\nLicense for A fast alternative to the modulo reduction\n\nLicense for atomic by Timm Kosse\n\nMIT License\n\nPublic Domain\n\nUniversity of Illinois/NCSA Open Source License\n\n\n\n\n\n\nMark Radcliffe\nPartner\n\nT +1 650.833.2266\nF +1 650.687.1222\nM +1 650.521.5039\nE mark.radcliffe at dlapiper.com <mailto:mark.radcliffe at dlapiper.com>\n\n[DLA Piper Logo]\n\nDLA Piper LLP (US)\n2000 University Avenue\nEast Palo Alto, California 94303-2215\nUnited States\nwww.dlapiper.com <http://www.dlapiper.com>\n\nPlease consider the environment before printing this email.\n\nThe information contained in this email may be confidential and/or legally privileged. It has been sent for the sole use of the intended recipient(s). If the reader of this message is not an intended recipient, you are hereby notified that any unauthorized review, use, disclosure, dissemination, distribution, or copying of this communication, or any of its contents, is strictly prohibited. If you have received this communication in error, please reply to the sender and destroy all copies of the message. To contact us directly, send to postmaster at dlapiper.com. Thank you.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/85b1cd96/attachment.html>"
            },
            {
                "author": "Omar Shibli",
                "date": "2017-09-26T13:12:48",
                "message_text_only": "According to my understanding, Bitcoin protocol is a combination of several\ncomponents (node, miner, wallet..), you can use different licenses for\ndifferent components, as long as the components are well structured and\ninter APIs are well defined and encapsulated, therefore, incompatible\nlicenses could be not an issue.\nPlease note that I'm not legal advisor and this is just my personal opinion.\n\nOn Tue, Sep 26, 2017 at 12:53 AM, Radcliffe, Mark via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> My apologies if this post has been answered, but I am new to the list. I\n> am lawyer trying to understand the licensing of the Bitcoin core and I\n>  will be presenting in a webinar with Black Duck Software on Blockchain on\n> September 28  (in case you are not familiar with them, Black Duck Software\n> assists companies in managing their open source software resources). They\n> have scanned the Bitcoin Core code for the open source licenses used in the\n> codebase.  I am enclosing a summary of the findings. I would be interested\n> in communicating with the individuals who manage this codebase and can\n> provide insight about the project manages contributions because the\n> codebase includes projects with inconsistent licenses (for example, code\n> licensed under the Apache Software License version  2 and GPLv2 cannot work\n> together in some situations). Thanks in advance.\n>\n>\n>\n> According to the scan, the code base includes code licensed under the\n> following licenses:\n>\n>\n>\n> Apache License 2.0\n>\n> Boost Software License 1.0\n>\n> BSD 2-clause \"Simplified\" License\n>\n> BSD 3-clause \"New\" or \"Revised\" License\n>\n> Creative Commons Attribution Share Alike 3.0\n>\n> Expat License\n>\n> GNU General Public License v2.0 or later\n>\n> GNU General Public License v3.0 or later\n>\n> GNU Lesser General Public License v2.1 or later\n>\n> License for A fast alternative to the modulo reduction\n>\n> License for atomic by Timm Kosse\n>\n> MIT License\n>\n> Public Domain\n>\n> University of Illinois/NCSA Open Source License\n>\n>\n>\n>\n>\n>\n>\n>\n>\n> *Mark Radcliffe*\n> Partner\n>\n>\n> *T* +1 650.833.2266 <(650)%20833-2266>\n> *F* +1 650.687.1222 <(650)%20687-1222>\n> *M* +1 650.521.5039 <(650)%20521-5039>\n> *E* mark.radcliffe at dlapiper.com\n>\n>\n>\n> [image: DLA Piper Logo]\n>\n>\n>\n> DLA Piper LLP (US)\n> 2000 University Avenue\n> East Palo Alto, California 94303-2215\n> United States\n> www.dlapiper.com\n>\n>\n> Please consider the environment before printing this email.\n>\n> The information contained in this email may be confidential and/or legally\n> privileged. It has been sent for the sole use of the intended recipient(s).\n> If the reader of this message is not an intended recipient, you are hereby\n> notified that any unauthorized review, use, disclosure, dissemination,\n> distribution, or copying of this communication, or any of its contents, is\n> strictly prohibited. If you have received this communication in error,\n> please reply to the sender and destroy all copies of the message. To\n> contact us directly, send to postmaster at dlapiper.com. Thank you.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170926/a58cc0c2/attachment.html>"
            },
            {
                "author": "Cory Fields",
                "date": "2017-09-27T21:20:26",
                "message_text_only": "Hi Mark\n\nThank you very much for posting the findings. I took a look through our\nrepository and I think I can provide a bit of context.\n\nI'll go through each one, annotating what I've found.\n\n> Apache License 2.0\n\nThis is used by a few java files in the libsecp256k1 project. That library\n(which lives here: https://github.com/bitcoin-core/secp256k1) is a\nsub-module created and maintained by Bitcoin Core developers. The files in\nquestion are bindings that allow other applications to use libsecp256k1\nfrom Java. Bitcoin Core makes no use of them.\n\n> Boost Software License 1.0\n\nThis comes from tinyformat.h. Bitcoin Core indeed uses it.\n\n> BSD 2-clause \"Simplified\" License\n\nI'm unable to find any 2-clause BSD licensed files.\n\n> BSD 3-clause \"New\" or \"Revised\" License\n\nThis comes from leveldb, which is database software used by Bitcoin Core.\nBecause database software version inconsistencies can cause accidental\nforks (this actually happened in 2013), we include these files in our\nrepository and use them rather than linking to arbitrary versions at\nruntime.\n\nThere are a few non-upstream files we use in our leveldb tree to provide\nwindows support. Quoting from src/leveldb/util/env_win.cc:\n  This file contains source that originates from:\n\nhttp://code.google.com/p/leveldbwin/source/browse/trunk/win32_impl_src/env_win32.h\n\nhttp://code.google.com/p/leveldbwin/source/browse/trunk/win32_impl_src/port_win32.cc\n  Those files don't have any explicit license headers but the\n  project (http://code.google.com/p/leveldbwin/) lists the 'New BSD License'\n\n> Creative Commons Attribution Share Alike 3.0\n\nI didn't manage to find any CC-licensed files. The match probably comes\nfrom our gui svg icons, which contain an xml tag with a link to\ncreativecommons.org. This seems to be the default behavior of inkscape,\nwhich was used to create those icons. Any icons that we have not created\nourselves are listed in contrib/debian/copyright (they're all expat/public\ndomain).\n\n> Expat License\n\nSee MIT.\n\n> GNU General Public License v2.0 or later\n\nThe debian folder, which holds the files used to create debian/ubuntu\npackages is licensed gplv2+. These are packaging resources only,\nunnecessary for use of the code.\n\nAdditionally, some gplv2 m4 macros are used to bootstrap the code that is\nused to build the Bitcoin code. These contain the additional exception:\n\n   As a special exception, the respective Autoconf Macro's copyright owner\n   gives unlimited permission to copy, distribute and modify the configure\n   scripts that are the output of Autoconf when processing the Macro. You\n   need not follow the terms of the GNU General Public License when using\n   or distributing such scripts, even though portions of the text of the\n   Macro appear in them. The GNU General Public License (GPL) does govern\n   all other use of the material that constitutes the Autoconf Macro.\n\n> GNU General Public License v3.0 or later\n\nThe macdeploy script, useful for creating DMG files for macOS is gplv3. It\nis not necessary for any other platform, and is only used during the build\nprocess. Additionally, it is not the only way to create DMG files (apple's\nnative tools can be used as well).\n\nAdditionally, config.guess and config.sub are gplv3 scripts used to build\nour buildsystem.\n\n> GNU Lesser General Public License v2.1 or later\n\nauthproxy.py, A python script used in our test suite is licensed lgpl\nv2.1+. It is only necessary for running optional tests during development.\n\n> License for A fast alternative to the modulo reduction\n\nThis references a comment cuckoocache.h. No code from the site is used. The\nlink to the site was added after the code, as the site provides a helpful\nexplanation for the technique used.\n\n> License for atomic by Timm Kosse\n\nAnother m4 file. As explained with the others above, this is a macro which\nbuilds code which builds code. It is used in the build process only.\n\n> MIT License\n\nThe primary and default license for all contributions.\n\n> Public Domain\n\n> University of Illinois/NCSA Open Source License\n\nclang-format-diff.py, a python script optionally used by developers to\nclean up code changes.\n\ntl;dr: Best I can tell, all source files that comprise Bitcoin Core\nbinaries are licensed (excluding the public domain ones) as MIT, BSD, or\nBoost.\n\nIt's also worth repeating Omar's point that many of the files in the\nBitcoin Core repository are used for optional programs/libraries. None of\nthe artwork, for example, is needed for the primary bitcoin daemon.\n\nHope that helps!\n\nRegards,\nCory\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/af791133/attachment.html>"
            },
            {
                "author": "Tim Ruffing",
                "date": "2017-09-27T21:54:09",
                "message_text_only": "On Wed, 2017-09-27 at 17:20 -0400, Cory Fields via bitcoin-dev wrote:\n> > Creative Commons Attribution Share Alike 3.0\n> \n> I didn't manage to find any CC-licensed files. The match probably\n> comes from our gui svg icons, which contain an xml tag with a link to\n> creativecommons.org. This seems to be the default behavior of\n> inkscape, which was used to create those icons. Any icons that we\n> have not created ourselves are listed in contrib/debian/copyright\n> (they're all expat/public domain).\n\nThis is somewhat weird. Back in 2014, most of icons were listed as\n\"CC BY-SA\" (which is the correct license according to the original\nsource):\nhttps://github.com/bitcoin/bitcoin/blob/31aac02446472ec5bfc4676ab190ec9d37056503/doc/assets-attribution.md\n\nHowever the current docs list them as \"Expat\". A mistake?\nhttps://github.com/bitcoin/bitcoin/blob/master/contrib/debian/copyright\n\nAlso, even the old version lists some icons \"based on Stephan Hutchings\nTypicons\" as \"License: MIT\", which could be a violation of CC BY-SA if\nI'm not mistaken.\n\nBest,\nTim"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2017-09-27T22:21:12",
                "message_text_only": "On Wed, Sep 27, 2017 at 9:54 PM, Tim Ruffing via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Also, even the old version lists some icons \"based on Stephan Hutchings\n> Typicons\" as \"License: MIT\", which could be a violation of CC BY-SA if\n> I'm not mistaken.\n\nRelicensed by the copyright holder:\n\nhttps://github.com/bitcoin/bitcoin/commit/dae0a89d4b66f08c83ccc8c20cf37521084b6257\n\n(For future reference, git log -p <file> makes it easy to go find\nwhere some string was last in a file, so you can look at the commit\nthat changed it.)"
            },
            {
                "author": "Tim Ruffing",
                "date": "2017-09-27T22:41:24",
                "message_text_only": "Oh nevermind. I had a look at the history but missed that commit and\nassumed the change was introduced when adding the text to\ncontrib/debian/copyright\n\nTim\n\nOn Wed, 2017-09-27 at 22:21 +0000, Gregory Maxwell wrote:\n> On Wed, Sep 27, 2017 at 9:54 PM, Tim Ruffing via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > Also, even the old version lists some icons \"based on Stephan\n> > Hutchings\n> > Typicons\" as \"License: MIT\", which could be a violation of CC BY-SA \n> > if\n> > I'm not mistaken.\n> \n> Relicensed by the copyright holder:\n> \n> https://github.com/bitcoin/bitcoin/commit/dae0a89d4b66f08c83ccc8c20cf\n> 37521084b6257\n> \n> (For future reference, git log -p <file> makes it easy to go find\n> where some string was last in a file, so you can look at the commit\n> that changed it.)"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2017-09-27T22:06:58",
                "message_text_only": "On Wed, Sep 27, 2017 at 9:20 PM, Cory Fields via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> License for A fast alternative to the modulo reduction\n>\n> This references a comment cuckoocache.h. No code from the site is used. The\n> link to the site was added after the code, as the site provides a helpful\n> explanation for the technique used.\n\nAs the author of that comment: the reference there is unrelated to the\ncode but just a found-on-the-internet explanation for an trivial, old,\nand well known technique (which I've seen in code since at least the\n80s) that manages to sometimes surprise people who aren't familiar\nwith fixed point signal processing.  I wrote and submitted the comment\nafter encountering people confused by our code in another project,\nlong after it was written."
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Assistance",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tim Ruffing",
                "Radcliffe, Mark",
                "Omar Shibli",
                "Gregory Maxwell",
                "Cory Fields"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 13925
        }
    },
    {
        "title": "[bitcoin-dev] idea post: trimming and demurrage",
        "thread_messages": [
            {
                "author": "Patrick Sharp",
                "date": "2017-09-25T21:54:16",
                "message_text_only": "Hello Devs,\n\nI am Patrick Sharp. I just graduated with a BS is computer science. Forgive\nmy ignorance.\n\nAs per bip-0002 I have scoured each bip available on the wiki to see if\nthese ideas have already been formally proposed and now as per bip-0002\npost these ideas here.\n\nFirst and foremost I acknowledge that these ideas are not original nor new.\n\nTrimming and demurrage:\n\nI am fully aware that demurrage is a prohibited change. I hereby contest.\nFor the record I am not a miner, I am just aware of the economics that\ndrive the costs of bitcoin.\n\nWithout the ability to maintain some sort of limit on the maximum length or\nsize of the block chain, block chain is not only unsustainable in the long\nrun but becomes more and more centralized as the block chain becomes more\nand more unwieldy.\n\nTrimming is not a foreign concept. Old block whose transactions are now\nspent hold no real value. Meaningful trimming is expensive and inhibited by\nunspent transactions. Old unspent transactions add unnecessary and unfair\nburden.\n\n   - Old transactions take up real world space that continues incur cost\n   while these transactions they do not continue to contribute to any sort of\n   payment for this cost.\n   - One can assume that anybody with access to their bitcoins has the\n   power to move these bitcoins from one address to another (or at least that\n   the software that holds the keys to their coins can do it for them) and it\n   is not unfair to require them to do so at least once every 5 to 10 years.\n   - Given the incentive to move it or lose it and software that will do it\n      for them, we can assume that any bitcoin not moved is most likey\ntherefore\n      lost.\n      - moving these coins will cost a small transaction fee which is fair\n      as their transactions take up space, they need to contribute\n      - most people who use their coins regularly will not even need to\n      worry about this as their coins are moved to a change address anyway.\n   - one downside is that paper wallets would then have an expiration date,\n   however I do not think that a paper wallet that needs to be recycled every\n   5 to 10 years is a terrible idea.\n\nTherefore I propose that the block chain length be limited to either 2^18\nblocks (slightly less than 5 years) or 2^19 blocks, or slightly less than\n10 years. I propose that each time a block is mined the the oldest block(s)\n(no more than two blocks) beyond this limit is trimmed from the chain and\nthat its unspent transactions are allowed to be included in the reward of\nthe mined block.\n\nThis keeps the block chain from tending towards infinity. This keeps the\ncosts of the miners balanced with the costs of the users.\n\nEven though I believe this idea will have some friction, it is applicable\nto the entire community. It will be hard for some users to give up small\nbenefits that they get at the great cost of miners, however miners run the\ngame and this fair proposal is in in their best interest in two different\nways. I would like your thoughts and suggestions. I obviously think this is\na freaking awesome idea. I know it is quite controversial but it is the\nnext step in evolution that bitcoin needs to take to ensure immortality.\n\nI come to you to ask if this has any chance of acceptance.\n\n-Patrick\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/0d5f1ac1/attachment.html>"
            },
            {
                "author": "Richard Hein",
                "date": "2017-09-25T23:30:23",
                "message_text_only": "It kills Bitcoin as a store of value.  Disk space is not the problem; bandwidth is.  The blockchain won't go to infinity as you suggest, as it is bounded by certain constraints.  It's growth is a function of the transactions in a block, and the number of blocks is linear in growth.  \n\nSent from my iPhone\n\n> On Sep 25, 2017, at 5:54 PM, Patrick Sharp via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Hello Devs,\n> \n> I am Patrick Sharp. I just graduated with a BS is computer science. Forgive my ignorance.\n> \n> As per bip-0002 I have scoured each bip available on the wiki to see if these ideas have already been formally proposed and now as per bip-0002 post these ideas here.\n> \n> First and foremost I acknowledge that these ideas are not original nor new.\n> \n> Trimming and demurrage:\n> \n> I am fully aware that demurrage is a prohibited change. I hereby contest. For the record I am not a miner, I am just aware of the economics that drive the costs of bitcoin.\n> \n> Without the ability to maintain some sort of limit on the maximum length or size of the block chain, block chain is not only unsustainable in the long run but becomes more and more centralized as the block chain becomes more and more unwieldy.\n> \n> Trimming is not a foreign concept. Old block whose transactions are now spent hold no real value. Meaningful trimming is expensive and inhibited by unspent transactions. Old unspent transactions add unnecessary and unfair burden.\n> Old transactions take up real world space that continues incur cost while these transactions they do not continue to contribute to any sort of payment for this cost.\n> One can assume that anybody with access to their bitcoins has the power to move these bitcoins from one address to another (or at least that the software that holds the keys to their coins can do it for them) and it is not unfair to require them to do so at least once every 5 to 10 years.\n> Given the incentive to move it or lose it and software that will do it for them, we can assume that any bitcoin not moved is most likey therefore lost.\n> moving these coins will cost a small transaction fee which is fair as their transactions take up space, they need to contribute\n> most people who use their coins regularly will not even need to worry about this as their coins are moved to a change address anyway.\n> one downside is that paper wallets would then have an expiration date, however I do not think that a paper wallet that needs to be recycled every 5 to 10 years is a terrible idea.\n> Therefore I propose that the block chain length be limited to either 2^18 blocks (slightly less than 5 years) or 2^19 blocks, or slightly less than 10 years. I propose that each time a block is mined the the oldest block(s) (no more than two blocks) beyond this limit is trimmed from the chain and that its unspent transactions are allowed to be included in the reward of the mined block.\n> \n> This keeps the block chain from tending towards infinity. This keeps the costs of the miners balanced with the costs of the users.\n> \n> Even though I believe this idea will have some friction, it is applicable to the entire community. It will be hard for some users to give up small benefits that they get at the great cost of miners, however miners run the game and this fair proposal is in in their best interest in two different ways. I would like your thoughts and suggestions. I obviously think this is a freaking awesome idea. I know it is quite controversial but it is the next step in evolution that bitcoin needs to take to ensure immortality.\n> \n> I come to you to ask if this has any chance of acceptance.\n> \n> -Patrick\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/c08a683e/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-09-25T23:34:32",
                "message_text_only": "Good morning Patrick,\n\nDemurrage is simply impossible.\n\nIn Bitcoin we already have implemented OP_CHECKLOCKTIMEVERIFY.\n\nThis opcode requires that a certain block height or date has passed before the output can be spent.\n\nIt can be used to make an \"in trust for\" address, where you disallow spending of that address.  For example, you may have a child to whom you wish to dedicate some inheritance to, and ensure that the child will not spend it recklessly until they achieve some age (when hopefully they would be more mature), regardless of what happens to you.\n\nIf I made a P2SH address with OP_CHECKLOCKTIMEVERIFY that allows spending 18 years from birth of my child, and then suddenly Bitcoin Core announces demurrage, I would be very angry.\n\nOP_CHECKLOCKTIMEVERIFY cannot be countermanded, and it would be impossible to refresh the UTXO's as required by demurrage, without requiring a hardfork that ignores OP_CHECKLOCKTIMEVERIFY.\n\nIt would be better to put such additional features as demurrage in a sidechain rather than on mainchain.\n\nRegards,\nZmnSCPxj\n\n-------- Original Message --------\nSubject: [bitcoin-dev] idea post: trimming and demurrage\nLocal Time: September 25, 2017 9:54 PM\nUTC Time: September 25, 2017 9:54 PM\nFrom: bitcoin-dev at lists.linuxfoundation.org\nTo: bitcoin-dev at lists.linuxfoundation.org\n\nHello Devs,\n\nI am Patrick Sharp. I just graduated with a BS is computer science. Forgive my ignorance.\n\nAs per bip-0002 I have scoured each bip available on the wiki to see if these ideas have already been formally proposed and now as per bip-0002 post these ideas here.\n\nFirst and foremost I acknowledge that these ideas are not original nor new.\n\nTrimming and demurrage:\n\nI am fully aware that demurrage is a prohibited change. I hereby contest. For the record I am not a miner, I am just aware of the economics that drive the costs of bitcoin.\n\nWithout the ability to maintain some sort of limit on the maximum length or size of the block chain, block chain is not only unsustainable in the long run but becomes more and more centralized as the block chain becomes more and more unwieldy.\n\nTrimming is not a foreign concept. Old block whose transactions are now spent hold no real value. Meaningful trimming is expensive and inhibited by unspent transactions. Old unspent transactions add unnecessary and unfair burden.\nOld transactions take up real world space that continues incur cost while these transactions they do not continue to contribute to any sort of payment for this cost.\nOne can assume that anybody with access to their bitcoins has the power to move these bitcoins from one address to another (or at least that the software that holds the keys to their coins can do it for them) and it is not unfair to require them to do so at least once every 5 to 10 years.\nGiven the incentive to move it or lose it and software that will do it for them, we can assume that any bitcoin not moved is most likey therefore lost.\nmoving these coins will cost a small transaction fee which is fair as their transactions take up space, they need to contribute\nmost people who use their coins regularly will not even need to worry about this as their coins are moved to a change address anyway.\none downside is that paper wallets would then have an expiration date, however I do not think that a paper wallet that needs to be recycled every 5 to 10 years is a terrible idea.\nTherefore I propose that the block chain length be limited to either 2^18 blocks (slightly less than 5 years) or 2^19 blocks, or slightly less than 10 years. I propose that each time a block is mined the the oldest block(s) (no more than two blocks) beyond this limit is trimmed from the chain and that its unspent transactions are allowed to be included in the reward of the mined block.\n\nThis keeps the block chain from tending towards infinity. This keeps the costs of the miners balanced with the costs of the users.\n\nEven though I believe this idea will have some friction, it is applicable to the entire community. It will be hard for some users to give up small benefits that they get at the great cost of miners, however miners run the game and this fair proposal is in in their best interest in two different ways. I would like your thoughts and suggestions. I obviously think this is a freaking awesome idea. I know it is quite controversial but it is the next step in evolution that bitcoin needs to take to ensure immortality.\n\nI come to you to ask if this has any chance of acceptance.\n\n-Patrick\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/619478f6/attachment-0001.html>"
            },
            {
                "author": "Patrick Sharp",
                "date": "2017-09-26T01:33:25",
                "message_text_only": "Thank you for your responses. I have been enlightened. For the time being\nthe combination of the UTXO's and pruning will accomplish what I desire. I\nsuspect that there will come a time when the UTXO database becomes too\nlarge, but I guess that is a problem for another day. If that day ever\ncomes 10 years was just an example, like you said there are reasons to\npreserve value beyond that point, perhaps a human lifetime or two would be\na better choice.\n\nSide question: wouldn't it be a good idea to store the hash of the current\nor previous UTXO's in the block header so that pruned nodes can verify\ntheir UTXO's are accurate without having to check the full chain? and/or\nmaybe include a snap shot of the UTXO's every x blocks?\n\nYou guys are totally awesome!!!\n\nI here by withdraw my proposal for the time being.\n\nOn Mon, Sep 25, 2017 at 5:34 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Patrick,\n>\n> Demurrage is simply impossible.\n>\n> In Bitcoin we already have implemented OP_CHECKLOCKTIMEVERIFY.\n>\n> This opcode requires that a certain block height or date has passed before\n> the output can be spent.\n>\n> It can be used to make an \"in trust for\" address, where you disallow\n> spending of that address.  For example, you may have a child to whom you\n> wish to dedicate some inheritance to, and ensure that the child will not\n> spend it recklessly until they achieve some age (when hopefully they would\n> be more mature), regardless of what happens to you.\n>\n> If I made a P2SH address with OP_CHECKLOCKTIMEVERIFY that allows spending\n> 18 years from birth of my child, and then suddenly Bitcoin Core announces\n> demurrage, I would be very angry.\n>\n> OP_CHECKLOCKTIMEVERIFY cannot be countermanded, and it would be impossible\n> to refresh the UTXO's as required by demurrage, without requiring a\n> hardfork that ignores OP_CHECKLOCKTIMEVERIFY.\n>\n> It would be better to put such additional features as demurrage in a\n> sidechain rather than on mainchain.\n>\n>\n> Regards,\n> ZmnSCPxj\n>\n> -------- Original Message --------\n> Subject: [bitcoin-dev] idea post: trimming and demurrage\n> Local Time: September 25, 2017 9:54 PM\n> UTC Time: September 25, 2017 9:54 PM\n> From: bitcoin-dev at lists.linuxfoundation.org\n> To: bitcoin-dev at lists.linuxfoundation.org\n>\n> Hello Devs,\n>\n> I am Patrick Sharp. I just graduated with a BS is computer science.\n> Forgive my ignorance.\n>\n> As per bip-0002 I have scoured each bip available on the wiki to see if\n> these ideas have already been formally proposed and now as per bip-0002\n> post these ideas here.\n>\n> First and foremost I acknowledge that these ideas are not original nor new.\n>\n> Trimming and demurrage:\n>\n> I am fully aware that demurrage is a prohibited change. I hereby contest.\n> For the record I am not a miner, I am just aware of the economics that\n> drive the costs of bitcoin.\n>\n> Without the ability to maintain some sort of limit on the maximum length\n> or size of the block chain, block chain is not only unsustainable in the\n> long run but becomes more and more centralized as the block chain becomes\n> more and more unwieldy.\n>\n> Trimming is not a foreign concept. Old block whose transactions are now\n> spent hold no real value. Meaningful trimming is expensive and inhibited by\n> unspent transactions. Old unspent transactions add unnecessary and unfair\n> burden.\n> Old transactions take up real world space that continues incur cost while\n> these transactions they do not continue to contribute to any sort of\n> payment for this cost.\n> One can assume that anybody with access to their bitcoins has the power to\n> move these bitcoins from one address to another (or at least that the\n> software that holds the keys to their coins can do it for them) and it is\n> not unfair to require them to do so at least once every 5 to 10 years.\n> Given the incentive to move it or lose it and software that will do it for\n> them, we can assume that any bitcoin not moved is most likey therefore lost.\n> moving these coins will cost a small transaction fee which is fair as\n> their transactions take up space, they need to contribute\n> most people who use their coins regularly will not even need to worry\n> about this as their coins are moved to a change address anyway.\n> one downside is that paper wallets would then have an expiration date,\n> however I do not think that a paper wallet that needs to be recycled every\n> 5 to 10 years is a terrible idea.\n> Therefore I propose that the block chain length be limited to either 2^18\n> blocks (slightly less than 5 years) or 2^19 blocks, or slightly less than\n> 10 years. I propose that each time a block is mined the the oldest block(s)\n> (no more than two blocks) beyond this limit is trimmed from the chain and\n> that its unspent transactions are allowed to be included in the reward of\n> the mined block.\n>\n> This keeps the block chain from tending towards infinity. This keeps the\n> costs of the miners balanced with the costs of the users.\n>\n> Even though I believe this idea will have some friction, it is applicable\n> to the entire community. It will be hard for some users to give up small\n> benefits that they get at the great cost of miners, however miners run the\n> game and this fair proposal is in in their best interest in two different\n> ways. I would like your thoughts and suggestions. I obviously think this is\n> a freaking awesome idea. I know it is quite controversial but it is the\n> next step in evolution that bitcoin needs to take to ensure immortality.\n>\n> I come to you to ask if this has any chance of acceptance.\n>\n> -Patrick\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/fb9f8f5c/attachment-0001.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2017-09-25T22:43:02",
                "message_text_only": "Maybe I missed or did not receive some messages, where was your\ncentralization concern addressed in the discussion?\n\n\nLe 26/09/2017 \u00e0 03:33, Patrick Sharp via bitcoin-dev a \u00e9crit\u00a0:\n> Thank you for your responses. I have been enlightened. For the time\n> being the combination of the UTXO's and\u00a0pruning will accomplish\u00a0what I\n> desire. I suspect that there will come a time when the UTXO database\n> becomes too large, but I guess that is a problem for another day. If\n> that day ever comes 10 years was just an example, like you said there\n> are reasons to preserve value beyond that point, perhaps a human\n> lifetime or two would be a better choice.\n>\n> Side question: wouldn't it be a good idea to store the hash of the\n> current or previous UTXO's in the block header so that pruned nodes\n> can verify their UTXO's are accurate without having to check the full\n> chain? and/or maybe include a snap shot of the UTXO's every x blocks?\n>\n> You guys are totally awesome!!!\n>\n> I here by withdraw my proposal for the time being.\n>\n> On Mon, Sep 25, 2017 at 5:34 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com\n> <mailto:ZmnSCPxj at protonmail.com>> wrote:\n>\n>     Good morning Patrick,\n>\n>     Demurrage is simply impossible.\n>\n>     In Bitcoin we already have implemented OP_CHECKLOCKTIMEVERIFY.\n>\n>     This opcode requires that a certain block height or date has\n>     passed before the output can be spent.\n>\n>     It can be used to make an \"in trust for\" address, where you\n>     disallow spending of that address.\u00a0 For example, you may have a\n>     child to whom you wish to dedicate some inheritance to, and ensure\n>     that the child will not spend it recklessly until they achieve\n>     some age (when hopefully they would be more mature), regardless of\n>     what happens to you.\n>\n>     If I made a P2SH address with OP_CHECKLOCKTIMEVERIFY that allows\n>     spending 18 years from birth of my child, and then suddenly\n>     Bitcoin Core announces demurrage, I would be very angry.\n>\n>     OP_CHECKLOCKTIMEVERIFY cannot be countermanded, and it would be\n>     impossible to refresh the UTXO's as required by demurrage, without\n>     requiring a hardfork that ignores OP_CHECKLOCKTIMEVERIFY.\n>\n>     It would be better to put such additional features as demurrage in\n>     a sidechain rather than on mainchain.\n>\n>\n>     Regards,\n>     ZmnSCPxj\n>\n>     -------- Original Message --------\n>     Subject: [bitcoin-dev] idea post: trimming and demurrage\n>     Local Time: September 25, 2017 9:54 PM\n>     UTC Time: September 25, 2017 9:54 PM\n>     From: bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>     To: bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>\n>     Hello Devs,\n>\n>     I am Patrick Sharp. I just graduated with a BS is computer\n>     science. Forgive my ignorance.\n>\n>     As per bip-0002 I have scoured each bip available on the wiki to\n>     see if these ideas have already been formally proposed and now as\n>     per bip-0002 post these ideas here.\n>\n>     First and foremost I acknowledge that these ideas are not original\n>     nor new.\n>\n>     Trimming and demurrage:\n>\n>     I am fully aware that demurrage is a prohibited change. I hereby\n>     contest. For the record I am not a miner, I am just aware of the\n>     economics that drive the costs of bitcoin.\n>\n>     Without the ability to maintain some sort of limit on the maximum\n>     length or size of the block chain, block chain is not only\n>     unsustainable in the long run but becomes more and more\n>     centralized as the block chain becomes more and more unwieldy.\n>\n>     Trimming is not a foreign concept. Old block whose transactions\n>     are now spent hold no real value. Meaningful trimming is expensive\n>     and inhibited by unspent transactions. Old unspent transactions\n>     add unnecessary and unfair burden.\n>     Old transactions take up real world space that continues incur\n>     cost while these transactions they do not continue to contribute\n>     to any sort of payment for this cost.\n>     One can assume that anybody with access to their bitcoins has the\n>     power to move these bitcoins from one address to another (or at\n>     least that the software that holds the keys to their coins can do\n>     it for them) and it is not unfair to require them to do so at\n>     least once every 5 to 10 years.\n>     Given the incentive to move it or lose it and software that will\n>     do it for them, we can assume that any bitcoin not moved is most\n>     likey therefore lost.\n>     moving these coins will cost a small transaction fee which is fair\n>     as their transactions take up space, they need to contribute\n>     most people who use their coins regularly will not even need to\n>     worry about this as their coins are moved to a change address anyway.\n>     one downside is that paper wallets would then have an expiration\n>     date, however I do not think that a paper wallet that needs to be\n>     recycled every 5 to 10 years is a terrible idea.\n>     Therefore I propose that the block chain length be limited to\n>     either 2^18 blocks (slightly less than 5 years) or 2^19 blocks, or\n>     slightly less than 10 years. I propose that each time a block is\n>     mined the the oldest block(s) (no more than two blocks) beyond\n>     this limit is trimmed from the chain and that its unspent\n>     transactions are allowed to be included in the reward of the mined\n>     block.\n>\n>     This keeps the block chain from tending towards infinity. This\n>     keeps the costs of the miners balanced with the costs of the users.\n>\n>     Even though\u00a0I believe this idea will have some friction, it is\n>     applicable to the entire community. It will be hard for some users\n>     to give up small benefits that they get at the great cost of\n>     miners, however miners run the game and this fair proposal is in\n>     in their best interest in two different ways. I would like your\n>     thoughts and suggestions. I obviously think this is a freaking\n>     awesome idea. I know it is quite controversial\u00a0but it is the next\n>     step in evolution that bitcoin needs to take to ensure immortality.\n>\n>     I come to you to ask if this has any chance of acceptance.\n>\n>     -Patrick\n>\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170926/9fbdd815/attachment.html>"
            },
            {
                "author": "\u0410\u043b\u0435\u043a\u0441\u0435\u0439 \u041c\u0443\u0442\u043e\u0432\u043a\u0438\u043d",
                "date": "2017-09-26T07:10:43",
                "message_text_only": "Lets call it blocktrain instead of blockchain. Because it is fixed amount\nof blocks moving forward on the time axis. Oldest blocks are detached from\nthe tail of that blockTrain and goes to depot.\n\n2017-09-26 4:33 GMT+03:00 Patrick Sharp via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org>:\n\n> Thank you for your responses. I have been enlightened. For the time being\n> the combination of the UTXO's and pruning will accomplish what I desire. I\n> suspect that there will come a time when the UTXO database becomes too\n> large, but I guess that is a problem for another day. If that day ever\n> comes 10 years was just an example, like you said there are reasons to\n> preserve value beyond that point, perhaps a human lifetime or two would be\n> a better choice.\n>\n> Side question: wouldn't it be a good idea to store the hash of the current\n> or previous UTXO's in the block header so that pruned nodes can verify\n> their UTXO's are accurate without having to check the full chain? and/or\n> maybe include a snap shot of the UTXO's every x blocks?\n>\n> You guys are totally awesome!!!\n>\n> I here by withdraw my proposal for the time being.\n>\n> On Mon, Sep 25, 2017 at 5:34 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n>> Good morning Patrick,\n>>\n>> Demurrage is simply impossible.\n>>\n>> In Bitcoin we already have implemented OP_CHECKLOCKTIMEVERIFY.\n>>\n>> This opcode requires that a certain block height or date has passed\n>> before the output can be spent.\n>>\n>> It can be used to make an \"in trust for\" address, where you disallow\n>> spending of that address.  For example, you may have a child to whom you\n>> wish to dedicate some inheritance to, and ensure that the child will not\n>> spend it recklessly until they achieve some age (when hopefully they would\n>> be more mature), regardless of what happens to you.\n>>\n>> If I made a P2SH address with OP_CHECKLOCKTIMEVERIFY that allows spending\n>> 18 years from birth of my child, and then suddenly Bitcoin Core announces\n>> demurrage, I would be very angry.\n>>\n>> OP_CHECKLOCKTIMEVERIFY cannot be countermanded, and it would be\n>> impossible to refresh the UTXO's as required by demurrage, without\n>> requiring a hardfork that ignores OP_CHECKLOCKTIMEVERIFY.\n>>\n>> It would be better to put such additional features as demurrage in a\n>> sidechain rather than on mainchain.\n>>\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n>> -------- Original Message --------\n>> Subject: [bitcoin-dev] idea post: trimming and demurrage\n>> Local Time: September 25, 2017 9:54 PM\n>> UTC Time: September 25, 2017 9:54 PM\n>> From: bitcoin-dev at lists.linuxfoundation.org\n>> To: bitcoin-dev at lists.linuxfoundation.org\n>>\n>> Hello Devs,\n>>\n>> I am Patrick Sharp. I just graduated with a BS is computer science.\n>> Forgive my ignorance.\n>>\n>> As per bip-0002 I have scoured each bip available on the wiki to see if\n>> these ideas have already been formally proposed and now as per bip-0002\n>> post these ideas here.\n>>\n>> First and foremost I acknowledge that these ideas are not original nor\n>> new.\n>>\n>> Trimming and demurrage:\n>>\n>> I am fully aware that demurrage is a prohibited change. I hereby contest.\n>> For the record I am not a miner, I am just aware of the economics that\n>> drive the costs of bitcoin.\n>>\n>> Without the ability to maintain some sort of limit on the maximum length\n>> or size of the block chain, block chain is not only unsustainable in the\n>> long run but becomes more and more centralized as the block chain becomes\n>> more and more unwieldy.\n>>\n>> Trimming is not a foreign concept. Old block whose transactions are now\n>> spent hold no real value. Meaningful trimming is expensive and inhibited by\n>> unspent transactions. Old unspent transactions add unnecessary and unfair\n>> burden.\n>> Old transactions take up real world space that continues incur cost while\n>> these transactions they do not continue to contribute to any sort of\n>> payment for this cost.\n>> One can assume that anybody with access to their bitcoins has the power\n>> to move these bitcoins from one address to another (or at least that the\n>> software that holds the keys to their coins can do it for them) and it is\n>> not unfair to require them to do so at least once every 5 to 10 years.\n>> Given the incentive to move it or lose it and software that will do it\n>> for them, we can assume that any bitcoin not moved is most likey therefore\n>> lost.\n>> moving these coins will cost a small transaction fee which is fair as\n>> their transactions take up space, they need to contribute\n>> most people who use their coins regularly will not even need to worry\n>> about this as their coins are moved to a change address anyway.\n>> one downside is that paper wallets would then have an expiration date,\n>> however I do not think that a paper wallet that needs to be recycled every\n>> 5 to 10 years is a terrible idea.\n>> Therefore I propose that the block chain length be limited to either 2^18\n>> blocks (slightly less than 5 years) or 2^19 blocks, or slightly less than\n>> 10 years. I propose that each time a block is mined the the oldest block(s)\n>> (no more than two blocks) beyond this limit is trimmed from the chain and\n>> that its unspent transactions are allowed to be included in the reward of\n>> the mined block.\n>>\n>> This keeps the block chain from tending towards infinity. This keeps the\n>> costs of the miners balanced with the costs of the users.\n>>\n>> Even though I believe this idea will have some friction, it is applicable\n>> to the entire community. It will be hard for some users to give up small\n>> benefits that they get at the great cost of miners, however miners run the\n>> game and this fair proposal is in in their best interest in two different\n>> ways. I would like your thoughts and suggestions. I obviously think this is\n>> a freaking awesome idea. I know it is quite controversial but it is the\n>> next step in evolution that bitcoin needs to take to ensure immortality.\n>>\n>> I come to you to ask if this has any chance of acceptance.\n>>\n>> -Patrick\n>>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170926/dd090ecd/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-09-26T07:50:42",
                "message_text_only": "Good morning,\n\nThis is called \"UTXO Set Commitments\".\n\nPieter Wuille I think had concrete proposals for the cryptographic primitive to use. Try searching \"Rolling UTXO Set Commitments\".\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n> -------- Original Message --------\n> Subject: Re: [bitcoin-dev] idea post: trimming and demurrage\n> Local Time: September 26, 2017 9:33 AM\n> UTC Time: September 26, 2017 1:33 AM\n> From: psharp.x13 at gmail.com\n> To: ZmnSCPxj <ZmnSCPxj at protonmail.com>\n> bitcoin-dev at lists.linuxfoundation.org <bitcoin-dev at lists.linuxfoundation.org>\n>\n> Thank you for your responses. I have been enlightened. For the time being the combination of the UTXO's and pruning will accomplish what I desire. I suspect that there will come a time when the UTXO database becomes too large, but I guess that is a problem for another day. If that day ever comes 10 years was just an example, like you said there are reasons to preserve value beyond that point, perhaps a human lifetime or two would be a better choice.\n>\n> Side question: wouldn't it be a good idea to store the hash of the current or previous UTXO's in the block header so that pruned nodes can verify their UTXO's are accurate without having to check the full chain? and/or maybe include a snap shot of the UTXO's every x blocks?\n>\n> You guys are totally awesome!!!\n>\n> I here by withdraw my proposal for the time being.\n>\n> On Mon, Sep 25, 2017 at 5:34 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n>> Good morning Patrick,\n>>\n>> Demurrage is simply impossible.\n>>\n>> In Bitcoin we already have implemented OP_CHECKLOCKTIMEVERIFY.\n>>\n>> This opcode requires that a certain block height or date has passed before the output can be spent.\n>>\n>> It can be used to make an \"in trust for\" address, where you disallow spending of that address.  For example, you may have a child to whom you wish to dedicate some inheritance to, and ensure that the child will not spend it recklessly until they achieve some age (when hopefully they would be more mature), regardless of what happens to you.\n>>\n>> If I made a P2SH address with OP_CHECKLOCKTIMEVERIFY that allows spending 18 years from birth of my child, and then suddenly Bitcoin Core announces demurrage, I would be very angry.\n>>\n>> OP_CHECKLOCKTIMEVERIFY cannot be countermanded, and it would be impossible to refresh the UTXO's as required by demurrage, without requiring a hardfork that ignores OP_CHECKLOCKTIMEVERIFY.\n>>\n>> It would be better to put such additional features as demurrage in a sidechain rather than on mainchain.\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n>> -------- Original Message --------\n>> Subject: [bitcoin-dev] idea post: trimming and demurrage\n>> Local Time: September 25, 2017 9:54 PM\n>> UTC Time: September 25, 2017 9:54 PM\n>> From: bitcoin-dev at lists.linuxfoundation.org\n>> To: bitcoin-dev at lists.linuxfoundation.org\n>>\n>> Hello Devs,\n>>\n>> I am Patrick Sharp. I just graduated with a BS is computer science. Forgive my ignorance.\n>>\n>> As per bip-0002 I have scoured each bip available on the wiki to see if these ideas have already been formally proposed and now as per bip-0002 post these ideas here.\n>>\n>> First and foremost I acknowledge that these ideas are not original nor new.\n>>\n>> Trimming and demurrage:\n>>\n>> I am fully aware that demurrage is a prohibited change. I hereby contest. For the record I am not a miner, I am just aware of the economics that drive the costs of bitcoin.\n>>\n>> Without the ability to maintain some sort of limit on the maximum length or size of the block chain, block chain is not only unsustainable in the long run but becomes more and more centralized as the block chain becomes more and more unwieldy.\n>>\n>> Trimming is not a foreign concept. Old block whose transactions are now spent hold no real value. Meaningful trimming is expensive and inhibited by unspent transactions. Old unspent transactions add unnecessary and unfair burden.\n>> Old transactions take up real world space that continues incur cost while these transactions they do not continue to contribute to any sort of payment for this cost.\n>> One can assume that anybody with access to their bitcoins has the power to move these bitcoins from one address to another (or at least that the software that holds the keys to their coins can do it for them) and it is not unfair to require them to do so at least once every 5 to 10 years.\n>> Given the incentive to move it or lose it and software that will do it for them, we can assume that any bitcoin not moved is most likey therefore lost.\n>> moving these coins will cost a small transaction fee which is fair as their transactions take up space, they need to contribute\n>> most people who use their coins regularly will not even need to worry about this as their coins are moved to a change address anyway.\n>> one downside is that paper wallets would then have an expiration date, however I do not think that a paper wallet that needs to be recycled every 5 to 10 years is a terrible idea.\n>> Therefore I propose that the block chain length be limited to either 2^18 blocks (slightly less than 5 years) or 2^19 blocks, or slightly less than 10 years. I propose that each time a block is mined the the oldest block(s) (no more than two blocks) beyond this limit is trimmed from the chain and that its unspent transactions are allowed to be included in the reward of the mined block.\n>>\n>> This keeps the block chain from tending towards infinity. This keeps the costs of the miners balanced with the costs of the users.\n>>\n>> Even though I believe this idea will have some friction, it is applicable to the entire community. It will be hard for some users to give up small benefits that they get at the great cost of miners, however miners run the game and this fair proposal is in in their best interest in two different ways. I would like your thoughts and suggestions. I obviously think this is a freaking awesome idea. I know it is quite controversial but it is the next step in evolution that bitcoin needs to take to ensure immortality.\n>>\n>> I come to you to ask if this has any chance of acceptance.\n>>\n>> -Patrick\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170926/db2421ff/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "idea post: trimming and demurrage",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Patrick Sharp",
                "Richard Hein",
                "Aymeric Vitte",
                "ZmnSCPxj",
                "\u0410\u043b\u0435\u043a\u0441\u0435\u0439 \u041c\u0443\u0442\u043e\u0432\u043a\u0438\u043d"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 37872
        }
    },
    {
        "title": "[bitcoin-dev] Address expiration times should be added to BIP-173",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2017-09-27T16:06:54",
                "message_text_only": "Re-use of old addresses is a major problem, not only for privacy, but also\noperationally: services like exchanges frequently have problems with users\nsending funds to addresses whose private keys have been lost or stolen; there\nare multiple examples of exchanges getting hacked, with users continuing to\nlose funds well after the actual hack has occured due to continuing deposits.\nThis also makes it difficult operationally to rotate private keys. I personally\nhave even lost funds in the past due to people sending me BTC to addresses that\nI gave them long ago for different reasons, rather than asking me for fresh\none.\n\nTo help combat this problem, I suggest that we add a UI-level expiration time\nto the new BIP173 address format. Wallets would be expected to consider\naddresses as invalid as a destination for funds after the expiration time is\nreached.\n\nUnfortunately, this proposal inevitably will raise a lot of UI and terminology\nquestions. Notably, the entire notion of addresses is flawed from a user point\nof view: their experience with them should be more like \"payment codes\", with a\ncode being valid for payment for a short period of time; wallets should not be\ndisplaying addresses as actually associated with specific funds. I suspect\nwe'll see users thinking that an expired address risks the funds themselves;\nsome thought needs to be put into terminology.\n\nBeing just an expiration time, seconds-level resolution is unnecessary, and\nmay give the wrong impression. I'd suggest either:\n\n1) Hour resolution - 2^24 hours = 1914 years\n2) Month resolution - 2^16 months = 5458 years\n\nBoth options have the advantage of working well at the UI level regardless of\ntimezone: the former is sufficiently short that UI's can simply display an\n\"exact\" time (though note different leap second interpretations), while the\nlatter is long enough that rounding off to the nearest day in the local\ntimezone is fine.\n\nSupporting hour-level (or just seconds) precision has the advantage of making\nit easy for services like exchanges to use addresses with relatively short\nvalidity periods, to reduce the risks of losses after a hack. Also, using at\nleast hour-level ensures we don't have any year 2038 problems.\n\nThoughts?\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/7f7c4bfb/attachment.sig>"
            },
            {
                "author": "CryptAxe",
                "date": "2017-09-27T18:15:20",
                "message_text_only": "I think we need something like this. Hour resolution seems like the\ncorrect choice to me.\n\nPlease someone steal whatever code you can from this PR when\nimplementing the UI for BIP173 expiration:\n\nhttps://github.com/bitcoin/bitcoin/pull/9722\n\nI have a rebased version as well if anyone wants it.\n\n\nOn 09/27/2017 09:06 AM, Peter Todd via bitcoin-dev wrote:\n> Re-use of old addresses is a major problem, not only for privacy, but also\n> operationally: services like exchanges frequently have problems with users\n> sending funds to addresses whose private keys have been lost or stolen; there\n> are multiple examples of exchanges getting hacked, with users continuing to\n> lose funds well after the actual hack has occured due to continuing deposits.\n> This also makes it difficult operationally to rotate private keys. I personally\n> have even lost funds in the past due to people sending me BTC to addresses that\n> I gave them long ago for different reasons, rather than asking me for fresh\n> one.\n>\n> To help combat this problem, I suggest that we add a UI-level expiration time\n> to the new BIP173 address format. Wallets would be expected to consider\n> addresses as invalid as a destination for funds after the expiration time is\n> reached.\n>\n> Unfortunately, this proposal inevitably will raise a lot of UI and terminology\n> questions. Notably, the entire notion of addresses is flawed from a user point\n> of view: their experience with them should be more like \"payment codes\", with a\n> code being valid for payment for a short period of time; wallets should not be\n> displaying addresses as actually associated with specific funds. I suspect\n> we'll see users thinking that an expired address risks the funds themselves;\n> some thought needs to be put into terminology.\n>\n> Being just an expiration time, seconds-level resolution is unnecessary, and\n> may give the wrong impression. I'd suggest either:\n>\n> 1) Hour resolution - 2^24 hours = 1914 years\n> 2) Month resolution - 2^16 months = 5458 years\n>\n> Both options have the advantage of working well at the UI level regardless of\n> timezone: the former is sufficiently short that UI's can simply display an\n> \"exact\" time (though note different leap second interpretations), while the\n> latter is long enough that rounding off to the nearest day in the local\n> timezone is fine.\n>\n> Supporting hour-level (or just seconds) precision has the advantage of making\n> it easy for services like exchanges to use addresses with relatively short\n> validity periods, to reduce the risks of losses after a hack. Also, using at\n> least hour-level ensures we don't have any year 2038 problems.\n>\n> Thoughts?\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/e671823a/attachment-0001.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-09-27T19:03:44",
                "message_text_only": "While there is a lot that I would like to comment on, for the moment I will just mention that you should consider using the 17 bit relative time format used in CSV as an offset from the birthdate of the address, a field all addresses should also have.\n\nThis would also mean that addresses cannot last more than a year without user override, which might actually be a plus, but you could also extend the field by a few bits too if that was deemed not acceptable. An address should not be considered valid longer than anticipated lifetime of the underlying cryptosystem in any case, so every address should have an expiry.\n\n> On Sep 27, 2017, at 9:06 AM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Re-use of old addresses is a major problem, not only for privacy, but also\n> operationally: services like exchanges frequently have problems with users\n> sending funds to addresses whose private keys have been lost or stolen; there\n> are multiple examples of exchanges getting hacked, with users continuing to\n> lose funds well after the actual hack has occured due to continuing deposits.\n> This also makes it difficult operationally to rotate private keys. I personally\n> have even lost funds in the past due to people sending me BTC to addresses that\n> I gave them long ago for different reasons, rather than asking me for fresh\n> one.\n> \n> To help combat this problem, I suggest that we add a UI-level expiration time\n> to the new BIP173 address format. Wallets would be expected to consider\n> addresses as invalid as a destination for funds after the expiration time is\n> reached.\n> \n> Unfortunately, this proposal inevitably will raise a lot of UI and terminology\n> questions. Notably, the entire notion of addresses is flawed from a user point\n> of view: their experience with them should be more like \"payment codes\", with a\n> code being valid for payment for a short period of time; wallets should not be\n> displaying addresses as actually associated with specific funds. I suspect\n> we'll see users thinking that an expired address risks the funds themselves;\n> some thought needs to be put into terminology.\n> \n> Being just an expiration time, seconds-level resolution is unnecessary, and\n> may give the wrong impression. I'd suggest either:\n> \n> 1) Hour resolution - 2^24 hours = 1914 years\n> 2) Month resolution - 2^16 months = 5458 years\n> \n> Both options have the advantage of working well at the UI level regardless of\n> timezone: the former is sufficiently short that UI's can simply display an\n> \"exact\" time (though note different leap second interpretations), while the\n> latter is long enough that rounding off to the nearest day in the local\n> timezone is fine.\n> \n> Supporting hour-level (or just seconds) precision has the advantage of making\n> it easy for services like exchanges to use addresses with relatively short\n> validity periods, to reduce the risks of losses after a hack. Also, using at\n> least hour-level ensures we don't have any year 2038 problems.\n> \n> Thoughts?\n> \n> -- \n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Peter Todd",
                "date": "2017-09-27T21:20:18",
                "message_text_only": "On Wed, Sep 27, 2017 at 12:03:44PM -0700, Mark Friedenbach wrote:\n> While there is a lot that I would like to comment on, for the moment I will just mention that you should consider using the 17 bit relative time format used in CSV as an offset from the birthdate of the address, a field all addresses should also have.\n\nWhy should addresses have a birthdate? I don't see why that information would\nbe relevant to the person sending funds, and it could pose a privacy risk.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/b77a85ef/attachment.sig>"
            },
            {
                "author": "Chris Priest",
                "date": "2017-09-27T19:35:33",
                "message_text_only": "A better solution is to just have the sending wallet check to see if the\naddress you are about to send to has been used before. If it's a fresh\naddress, it sends it through without any popup alert. If the address has\nhistory going back a certain amount of time, then a popup comes up and\nnotifies the sender that they are sending to a non-fresh address that may\nno longer be controlled by the receiver anymore.\n\nAlso, an even better idea is to set up an \"address expiration service\".\nWhen you delete a wallet, you first send off an \"expiration notice\" which\nis just a message (signed with the private key) saying \"I am about to\ndelete this address, here is my new address\". When someone tries to send to\nthat address, they first consult the address expiration service, and the\nservice will either tell them \"this address is not expired, proceed\", or\n\"this address has been expired, please send to this other address\ninstead...\". Basically like a 301 redirect, but for addresses. I don't\nthink address expiration should be part of the protocol.\n\nOn Wed, Sep 27, 2017 at 10:06 AM, Peter Todd via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Re-use of old addresses is a major problem, not only for privacy, but also\n> operationally: services like exchanges frequently have problems with users\n> sending funds to addresses whose private keys have been lost or stolen;\n> there\n> are multiple examples of exchanges getting hacked, with users continuing to\n> lose funds well after the actual hack has occured due to continuing\n> deposits.\n> This also makes it difficult operationally to rotate private keys. I\n> personally\n> have even lost funds in the past due to people sending me BTC to addresses\n> that\n> I gave them long ago for different reasons, rather than asking me for fresh\n> one.\n>\n> To help combat this problem, I suggest that we add a UI-level expiration\n> time\n> to the new BIP173 address format. Wallets would be expected to consider\n> addresses as invalid as a destination for funds after the expiration time\n> is\n> reached.\n>\n> Unfortunately, this proposal inevitably will raise a lot of UI and\n> terminology\n> questions. Notably, the entire notion of addresses is flawed from a user\n> point\n> of view: their experience with them should be more like \"payment codes\",\n> with a\n> code being valid for payment for a short period of time; wallets should\n> not be\n> displaying addresses as actually associated with specific funds. I suspect\n> we'll see users thinking that an expired address risks the funds\n> themselves;\n> some thought needs to be put into terminology.\n>\n> Being just an expiration time, seconds-level resolution is unnecessary, and\n> may give the wrong impression. I'd suggest either:\n>\n> 1) Hour resolution - 2^24 hours = 1914 years\n> 2) Month resolution - 2^16 months = 5458 years\n>\n> Both options have the advantage of working well at the UI level regardless\n> of\n> timezone: the former is sufficiently short that UI's can simply display an\n> \"exact\" time (though note different leap second interpretations), while the\n> latter is long enough that rounding off to the nearest day in the local\n> timezone is fine.\n>\n> Supporting hour-level (or just seconds) precision has the advantage of\n> making\n> it easy for services like exchanges to use addresses with relatively short\n> validity periods, to reduce the risks of losses after a hack. Also, using\n> at\n> least hour-level ensures we don't have any year 2038 problems.\n>\n> Thoughts?\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n\n\n-- \nChris Priest\n786-531-5938\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/e853137e/attachment.html>"
            },
            {
                "author": "CryptAxe",
                "date": "2017-09-27T20:11:09",
                "message_text_only": "See https://github.com/bitcoin/bitcoin/pull/9722\n\nWhat still needs to be done is that during the first start up after\nupdating with this popup, the wallet needs to scan for addresses that\nhave been used in the past. That way the popup isn't only shown for\naddresses that are reused after updating.\n\n\nOn 09/27/2017 12:35 PM, Chris Priest via bitcoin-dev wrote:\n> A better solution is to just have the sending wallet check to see if\n> the address you are about to send to has been used before. If it's a\n> fresh address, it sends it through without any popup alert. If the\n> address has history going back a certain amount of time, then a popup\n> comes up and notifies the sender that they are sending to a non-fresh\n> address that may no longer be controlled by the receiver anymore.\n>\n> Also, an even better idea is to set up an \"address expiration\n> service\". When you delete a wallet, you first send off an \"expiration\n> notice\" which is just a message (signed with the private key) saying\n> \"I am about to delete this address, here is my new address\". When\n> someone tries to send to that address, they first consult the address\n> expiration service, and the service will either tell them \"this\n> address is not expired, proceed\", or \"this address has been expired,\n> please send to this other address instead...\". Basically like a 301\n> redirect, but for addresses. I don't think address expiration should\n> be part of the protocol.\n>\n...\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/305de41f/attachment-0001.html>"
            },
            {
                "author": "Nick Pudar",
                "date": "2017-09-27T20:23:33",
                "message_text_only": "As a long term silent reader of this list, I felt compelled to comment on this address expiration topic.  I don't believe that address expiration should be part of the protocol.  I think instead that the \"sending\" feature should by default offer guidance to request a fresh address from the recipient.  Also allow the receiver of funds to be able to generate an \"invoice\" that the sender acts on.\n\n\nI also think that re-directs are fraught with privacy issues.  At the end of the day, the ultimate burden is on the sender (with much self interest from the receiver) that the correct address is being used.\n\n\n________________________________\nFrom: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Chris Priest via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nSent: Wednesday, September 27, 2017 3:35 PM\nTo: Peter Todd; Bitcoin Protocol Discussion\nSubject: Re: [bitcoin-dev] Address expiration times should be added to BIP-173\n\nA better solution is to just have the sending wallet check to see if the address you are about to send to has been used before. If it's a fresh address, it sends it through without any popup alert. If the address has history going back a certain amount of time, then a popup comes up and notifies the sender that they are sending to a non-fresh address that may no longer be controlled by the receiver anymore.\n\nAlso, an even better idea is to set up an \"address expiration service\". When you delete a wallet, you first send off an \"expiration notice\" which is just a message (signed with the private key) saying \"I am about to delete this address, here is my new address\". When someone tries to send to that address, they first consult the address expiration service, and the service will either tell them \"this address is not expired, proceed\", or \"this address has been expired, please send to this other address instead...\". Basically like a 301 redirect, but for addresses. I don't think address expiration should be part of the protocol.\n\nOn Wed, Sep 27, 2017 at 10:06 AM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\nRe-use of old addresses is a major problem, not only for privacy, but also\noperationally: services like exchanges frequently have problems with users\nsending funds to addresses whose private keys have been lost or stolen; there\nare multiple examples of exchanges getting hacked, with users continuing to\nlose funds well after the actual hack has occured due to continuing deposits.\nThis also makes it difficult operationally to rotate private keys. I personally\nhave even lost funds in the past due to people sending me BTC to addresses that\nI gave them long ago for different reasons, rather than asking me for fresh\none.\n\nTo help combat this problem, I suggest that we add a UI-level expiration time\nto the new BIP173 address format. Wallets would be expected to consider\naddresses as invalid as a destination for funds after the expiration time is\nreached.\n\nUnfortunately, this proposal inevitably will raise a lot of UI and terminology\nquestions. Notably, the entire notion of addresses is flawed from a user point\nof view: their experience with them should be more like \"payment codes\", with a\ncode being valid for payment for a short period of time; wallets should not be\ndisplaying addresses as actually associated with specific funds. I suspect\nwe'll see users thinking that an expired address risks the funds themselves;\nsome thought needs to be put into terminology.\n\nBeing just an expiration time, seconds-level resolution is unnecessary, and\nmay give the wrong impression. I'd suggest either:\n\n1) Hour resolution - 2^24 hours = 1914 years\n2) Month resolution - 2^16 months = 5458 years\n\nBoth options have the advantage of working well at the UI level regardless of\ntimezone: the former is sufficiently short that UI's can simply display an\n\"exact\" time (though note different leap second interpretations), while the\nlatter is long enough that rounding off to the nearest day in the local\ntimezone is fine.\n\nSupporting hour-level (or just seconds) precision has the advantage of making\nit easy for services like exchanges to use addresses with relatively short\nvalidity periods, to reduce the risks of losses after a hack. Also, using at\nleast hour-level ensures we don't have any year 2038 problems.\n\nThoughts?\n\n--\nhttps://petertodd.org 'peter'[:-1]@petertodd.org<http://petertodd.org>\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n\n\n\n--\nChris Priest\n786-531-5938\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/317dbefa/attachment.html>"
            },
            {
                "author": "CryptAxe",
                "date": "2017-09-27T20:19:48",
                "message_text_only": "I do agree with you to a degree, but address reuse is actually not even\nsupposed to work (it is a bug). Peter Todd is suggesting only to make\nexpiration a part of a new address format, and we could have a GUI\nwarning (but no protocol change) for the existing formats. What do you\nthink about that?\n\n\nOn 09/27/2017 01:23 PM, Nick Pudar via bitcoin-dev wrote:\n>\n> As a long term silent reader of this list, I felt compelled to comment\n> on this address expiration topic.  I don't believe that address\n> expiration should be part of the protocol.  I think instead that the\n> \"sending\" feature should by default offer guidance to request a fresh\n> address from the recipient.  Also allow the receiver of funds to be\n> able to generate an \"invoice\" that the sender acts on.\n>\n>\n> I also think that re-directs are fraught with privacy issues.  At the\n> end of the day, the ultimate burden is on the sender (with much self\n> interest from the receiver) that the correct address is being used.\n>\n>\n>\n> ------------------------------------------------------------------------\n> *From:* bitcoin-dev-bounces at lists.linuxfoundation.org\n> <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Chris\n> Priest via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> *Sent:* Wednesday, September 27, 2017 3:35 PM\n> *To:* Peter Todd; Bitcoin Protocol Discussion\n> *Subject:* Re: [bitcoin-dev] Address expiration times should be added\n> to BIP-173\n>  \n> A better solution is to just have the sending wallet check to see if\n> the address you are about to send to has been used before. If it's a\n> fresh address, it sends it through without any popup alert. If the\n> address has history going back a certain amount of time, then a popup\n> comes up and notifies the sender that they are sending to a non-fresh\n> address that may no longer be controlled by the receiver anymore.\n>\n> Also, an even better idea is to set up an \"address expiration\n> service\". When you delete a wallet, you first send off an \"expiration\n> notice\" which is just a message (signed with the private key) saying\n> \"I am about to delete this address, here is my new address\". When\n> someone tries to send to that address, they first consult the address\n> expiration service, and the service will either tell them \"this\n> address is not expired, proceed\", or \"this address has been expired,\n> please send to this other address instead...\". Basically like a 301\n> redirect, but for addresses. I don't think address expiration should\n> be part of the protocol.\n>\n> On Wed, Sep 27, 2017 at 10:06 AM, Peter Todd via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>\n>     Re-use of old addresses is a major problem, not only for privacy,\n>     but also\n>     operationally: services like exchanges frequently have problems\n>     with users\n>     sending funds to addresses whose private keys have been lost or\n>     stolen; there\n>     are multiple examples of exchanges getting hacked, with users\n>     continuing to\n>     lose funds well after the actual hack has occured due to\n>     continuing deposits.\n>     This also makes it difficult operationally to rotate private keys.\n>     I personally\n>     have even lost funds in the past due to people sending me BTC to\n>     addresses that\n>     I gave them long ago for different reasons, rather than asking me\n>     for fresh\n>     one.\n>\n>     To help combat this problem, I suggest that we add a UI-level\n>     expiration time\n>     to the new BIP173 address format. Wallets would be expected to\n>     consider\n>     addresses as invalid as a destination for funds after the\n>     expiration time is\n>     reached.\n>\n>     Unfortunately, this proposal inevitably will raise a lot of UI and\n>     terminology\n>     questions. Notably, the entire notion of addresses is flawed from\n>     a user point\n>     of view: their experience with them should be more like \"payment\n>     codes\", with a\n>     code being valid for payment for a short period of time; wallets\n>     should not be\n>     displaying addresses as actually associated with specific funds. I\n>     suspect\n>     we'll see users thinking that an expired address risks the funds\n>     themselves;\n>     some thought needs to be put into terminology.\n>\n>     Being just an expiration time, seconds-level resolution is\n>     unnecessary, and\n>     may give the wrong impression. I'd suggest either:\n>\n>     1) Hour resolution - 2^24 hours = 1914 years\n>     2) Month resolution - 2^16 months = 5458 years\n>\n>     Both options have the advantage of working well at the UI level\n>     regardless of\n>     timezone: the former is sufficiently short that UI's can simply\n>     display an\n>     \"exact\" time (though note different leap second interpretations),\n>     while the\n>     latter is long enough that rounding off to the nearest day in the\n>     local\n>     timezone is fine.\n>\n>     Supporting hour-level (or just seconds) precision has the\n>     advantage of making\n>     it easy for services like exchanges to use addresses with\n>     relatively short\n>     validity periods, to reduce the risks of losses after a hack.\n>     Also, using at\n>     least hour-level ensures we don't have any year 2038 problems.\n>\n>     Thoughts?\n>\n>     --\n>     https://petertodd.org 'peter'[:-1]@petertodd.org\n>     <http://petertodd.org>\n>\n>     _______________________________________________\n>     bitcoin-dev mailing list\n>     bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>\n>\n>\n>\n>\n> -- \n> Chris Priest\n> 786-531-5938\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/c2fbfa44/attachment-0001.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-09-27T21:09:16",
                "message_text_only": "First, there\u2019s been no discussion so far for address expiration to be part of \u201cthe protocol\u201d which usually means consensus rules or p2p. This is purely about wallets and wallet information exchange protocols.\n\nThere\u2019s no way for the sender to know whether an address has been used without a complete copy of the block chain and more indexes than even Bitcoin Core maintains. It\u2019s simply not an option now, let alone as the blockchain grows into the future.\n\n> On Sep 27, 2017, at 1:23 PM, Nick Pudar via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> As a long term silent reader of this list, I felt compelled to comment on this address expiration topic.  I don't believe that address expiration should be part of the protocol.  I think instead that the \"sending\" feature should by default offer guidance to request a fresh address from the recipient.  Also allow the receiver of funds to be able to generate an \"invoice\" that the sender acts on.\n> \n> I also think that re-directs are fraught with privacy issues.  At the end of the day, the ultimate burden is on the sender (with much self interest from the receiver) that the correct address is being used.\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/f8b622f6/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2017-09-27T21:15:50",
                "message_text_only": "On Wed, Sep 27, 2017 at 01:35:33PM -0600, Chris Priest wrote:\n> A better solution is to just have the sending wallet check to see if the\n> address you are about to send to has been used before. If it's a fresh\n\nMy concern is not primarily people re-using addresses, but rather people using\nstale addresses that the recipient would rather not be used anymore. This\nsituation often happens even if the stale address has never been used.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/33226c50/attachment-0001.sig>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2017-09-28T00:22:13",
                "message_text_only": "On Wed, Sep 27, 2017 at 7:35 PM, Chris Priest via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> A better solution is to just have the sending wallet check to see if the\n> address you are about to send to has been used before.\n\nSo every wallet needs all the addresses ever used and a fast index into them?\nThis seems pretty harmful for scalability.\n\n> they first consult the address expiration service,\n\nSo you propose a best practice that requires contacting a service and\ntelling them what addresses you're planning on paying?  This seems\npretty harmful for privacy."
            },
            {
                "author": "Peter Todd",
                "date": "2017-09-27T21:33:07",
                "message_text_only": "On Wed, Sep 27, 2017 at 12:06:54PM -0400, Peter Todd via bitcoin-dev wrote:\n> Being just an expiration time, seconds-level resolution is unnecessary, and\n> may give the wrong impression. I'd suggest either:\n> \n> 1) Hour resolution - 2^24 hours = 1914 years\n> 2) Month resolution - 2^16 months = 5458 years\n\nJust remembered: it's notable how Coinbase has a 10 minute timeout on their\npayment window, which is in effect a 10 minute expiry time for the address.\nPresumably they'd make use of this feature if it existed.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/95cbee53/attachment.sig>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2017-09-28T00:58:30",
                "message_text_only": "On Wed, Sep 27, 2017 at 4:06 PM, Peter Todd via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Re-use of old addresses is a major problem, not only for privacy, but also\n> operationally: services like exchanges frequently have problems with users\n> sending funds to addresses whose private keys have been lost or stolen; there\n\nWhen Pieter and I were working on Bech32 we specifically designed for\nerror correcting codes that had good performance for longer lengths\nthan we technically needed specifically to incorporate things like\ndates and explicit amounts.\n\n(explicit amounts so that typos and bit flips in amounts displayed or\nin memory couldn't result in sending the wrong amount)\n\nBut we also thought that also adding those features at the same time\nwould retard adoption-- both due to debating over the encodings and\nbecause handling would result in different software requirements and\nlayering, so you couldn't just drop them in.\n\nDoubly unfortunately, people have even deployed BIP173 already (prior\nto it even having much peer review or being adopted by its own\nauthors), so I think a rethink now wouldn't be timely (I mean as a\nreplacement to BIP173 rather than an additional format). :(\n\nBut I do support the idea.\n\nOne thing to keep in mind is that address format linked fields are\nmost efficient if they're multiples of 5 bits.  Perhaps use 1 bit to\nindicate an embedded amount and 19 bits of 1 day precision, resulting\nin a 1435 year span.\n\nKeep in mind that high precision of the expiration times is asking the\nsender to have a higher precision of idea of the time, date only is\nkinda nice.  I think shorter expiration times are unlikely to be\nuseful due to clock skew-- you can't assume a signer has any access to\nthe Bitcoin network at all."
            },
            {
                "author": "Peter Todd",
                "date": "2017-09-29T01:50:48",
                "message_text_only": "On Thu, Sep 28, 2017 at 12:58:30AM +0000, Gregory Maxwell wrote:\n> On Wed, Sep 27, 2017 at 4:06 PM, Peter Todd via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > Re-use of old addresses is a major problem, not only for privacy, but also\n> > operationally: services like exchanges frequently have problems with users\n> > sending funds to addresses whose private keys have been lost or stolen; there\n> \n> When Pieter and I were working on Bech32 we specifically designed for\n> error correcting codes that had good performance for longer lengths\n> than we technically needed specifically to incorporate things like\n> dates and explicit amounts.\n> \n> (explicit amounts so that typos and bit flips in amounts displayed or\n> in memory couldn't result in sending the wrong amount)\n> \n> But we also thought that also adding those features at the same time\n> would retard adoption-- both due to debating over the encodings and\n> because handling would result in different software requirements and\n> layering, so you couldn't just drop them in.\n\nNotably, even something as simple as adding a new type of confirmation window\nthat might be needed is a big chance to UI logic.\n\n> Doubly unfortunately, people have even deployed BIP173 already (prior\n> to it even having much peer review or being adopted by its own\n> authors), so I think a rethink now wouldn't be timely (I mean as a\n> replacement to BIP173 rather than an additional format). :(\n\nYeah, I just noticed Pieter Wuille's BIP173-including segwit pull-req - that's\na lot of code that would get touched by this proposal, so it's likely too late\nin the process.\n\n> But I do support the idea.\n> \n> One thing to keep in mind is that address format linked fields are\n> most efficient if they're multiples of 5 bits.  Perhaps use 1 bit to\n> indicate an embedded amount and 19 bits of 1 day precision, resulting\n> in a 1435 year span.\n\nWhat do you mean by \"an embedded amount\"?\n\n> Keep in mind that high precision of the expiration times is asking the\n> sender to have a higher precision of idea of the time, date only is\n> kinda nice.  I think shorter expiration times are unlikely to be\n> useful due to clock skew-- you can't assume a signer has any access to\n> the Bitcoin network at all.\n\nI'm inclined to agree as well. Also, Bitcoin payments themselves are inherently\nimprecise, because blocks aren't found on a regular interval - Coinbase's \"10\nminute\" payment expiry window is odd from that point of view.\n\nHaving said that, you'd want a resolution more precise than what you'd expect\ntimeouts to be set at, to avoid UI \"fencepost\" oddity; if I want to set a 1 day\ntimeout, users shouldn't see either 1 or 2 days depending on exactly which way\nit happened to be rounded that particular time..\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/04ab3f7f/attachment.sig>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2017-09-29T02:06:54",
                "message_text_only": "On Fri, Sep 29, 2017 at 1:50 AM, Peter Todd <pete at petertodd.org> wrote:\n> What do you mean by \"an embedded amount\"?\n\nI ask you to pay 1 Bitcoin to bc1blahblah.\n\n...you make a typo, or a poorly placed cosmic ray switches it in your\nram to bc1blohblahbah.   No problem, it'll get rejected. (even if the\ncosmic ray happens just before signing... if the software is robust\nit'll reencode from the signed transaction and check against the\noriginal input.\n\nBut if instead the typo converts it to 2 Bitcoins or the cosmic ray\nconverts it to 2.34217728... the payment will happily go through,\nassuming your wallet had enough, and you're stuck asking me to refund\nyou the excess.\n\nSure, you can put amounts in URIs and whatnot, but they're not error\nprotected... so there will always be unprotected poritons where a\nglitch can radically change the amount.\n\nIn many cases you know exactly what amount you're asking for when you\ngenerate an address. There isn't any reason the amount couldn't be\ncovered by the addresses checksum in those cases.\n\nThere are a couple ways of doing that... e.g. adding it explicitly,\nwhere the checksum includes it but not the address itself; so it\nerrors out if you get it wrong. But this is unfortunate because it\ncan't tell you the expected amount when its wrong.   Another way would\nbe to embed the amount in the address, and then the software can tell\nyou the amount the address was expecting and not let you proceed until\nthey match."
            },
            {
                "author": "Andreas Schildbach",
                "date": "2017-09-28T10:09:59",
                "message_text_only": "This feels redundant to me; the payment protocol already has an\nexpiration time.\n\n\nOn 09/27/2017 06:06 PM, Peter Todd via bitcoin-dev wrote:\n> Re-use of old addresses is a major problem, not only for privacy, but also\n> operationally: services like exchanges frequently have problems with users\n> sending funds to addresses whose private keys have been lost or stolen; there\n> are multiple examples of exchanges getting hacked, with users continuing to\n> lose funds well after the actual hack has occured due to continuing deposits.\n> This also makes it difficult operationally to rotate private keys. I personally\n> have even lost funds in the past due to people sending me BTC to addresses that\n> I gave them long ago for different reasons, rather than asking me for fresh\n> one.\n> \n> To help combat this problem, I suggest that we add a UI-level expiration time\n> to the new BIP173 address format. Wallets would be expected to consider\n> addresses as invalid as a destination for funds after the expiration time is\n> reached.\n> \n> Unfortunately, this proposal inevitably will raise a lot of UI and terminology\n> questions. Notably, the entire notion of addresses is flawed from a user point\n> of view: their experience with them should be more like \"payment codes\", with a\n> code being valid for payment for a short period of time; wallets should not be\n> displaying addresses as actually associated with specific funds. I suspect\n> we'll see users thinking that an expired address risks the funds themselves;\n> some thought needs to be put into terminology.\n> \n> Being just an expiration time, seconds-level resolution is unnecessary, and\n> may give the wrong impression. I'd suggest either:\n> \n> 1) Hour resolution - 2^24 hours = 1914 years\n> 2) Month resolution - 2^16 months = 5458 years\n> \n> Both options have the advantage of working well at the UI level regardless of\n> timezone: the former is sufficiently short that UI's can simply display an\n> \"exact\" time (though note different leap second interpretations), while the\n> latter is long enough that rounding off to the nearest day in the local\n> timezone is fine.\n> \n> Supporting hour-level (or just seconds) precision has the advantage of making\n> it easy for services like exchanges to use addresses with relatively short\n> validity periods, to reduce the risks of losses after a hack. Also, using at\n> least hour-level ensures we don't have any year 2038 problems.\n> \n> Thoughts?\n> \n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Sjors Provoost",
                "date": "2017-09-28T12:43:05",
                "message_text_only": "Peter Todd wrote:\n\n> \n> Re-use of old addresses is a major problem, not only for privacy, but also\n> operationally: services like exchanges frequently have problems with users\n> sending funds to addresses whose private keys have been lost or stolen;\n\n[...]\n> \n> To help combat this problem, I suggest that we add a UI-level expiration time\n> to the new BIP173 address format. Wallets would be expected to consider\n> addresses as invalid as a destination for funds after the expiration time is\n> reached.\n\n[...]\n\nPerhaps outside the scope of BIP173, but what about baking it into the protocol? That way a transaction that's sent too late, simply won't get confirmed. This removes the need for refund logic or asking a customer to pay just a few extra cents. You could also disallow a second payment.\n\nTwo downsides I can think of:\n* privacy, as differences in expiration policy would be visible on chain\n* miners might be able to game it in their interaction with brokers\n\n> Being just an expiration time, seconds-level resolution is unnecessary, and\n> may give the wrong impression. I'd suggest either:\n> \n> 1) Hour resolution - 2^24 hours = 1914 years\n> 2) Month resolution - 2^16 months = 5458 years\n\nSo that's 4.8 characters for hours, or 3.2 for years, plus checksum space? The shorter the better. Perhaps one or two bits can be used to specify an exponent; a large range seems more useful than high precision. For instance a merchant doesn't care if the customer pays within 10:00:00 minutes or 10:00:01 minutes and you wouldn't care if your address is valid 50 years or 50 years and 3 minutes. This point may be mute if minute level resolution is not practical.\n\n> Both options have the advantage of working well at the UI level regardless of\n> timezone: the former is sufficiently short that UI's can simply display an\n> \"exact\" time (though note different leap second interpretations), while the\n> latter is long enough that rounding off to the nearest day in the local\n> timezone is fine.\n> \n> Supporting hour-level (or just seconds) precision has the advantage of making\n> it easy for services like exchanges to use addresses with relatively short\n> validity periods, to reduce the risks of losses after a hack. Also, using at\n> least hour-level ensures we don't have any year 2038 problems.\n\nGreg Maxwell wrote:\n\n> One thing to keep in mind is that address format linked fields are\n> most efficient if they're multiples of 5 bits.  Perhaps use 1 bit to\n> indicate an embedded amount and 19 bits of 1 day precision, resulting\n> in a 1435 year span.\n\nIs this because 5 bits are one bech32 character (2^5=32) or there is another reason? And does that include the space needed for the checksum?\n\n\nHopefully one day addresses can be abstracted away, because they really aren't what people intuitively think they are, but I don't see that happen on short notice. Until then they shouldn't exhibit \"surprising\" behavior.\n\nEmbedding amounts in an address could confuse people when they reuse it. Wallets would e.g. have to ignore the amount value if they previously sent money, but without changing the address string displayed in the UI.\n\n\n> Keep in mind that high precision of the expiration times is asking the\n> sender to have a higher precision of idea of the time, date only is\n> kinda nice.  I think shorter expiration times are unlikely to be\n> useful due to clock skew-- you can't assume a signer has any access to\n> the Bitcoin network at all.\n\nMany merchant services and exchanges use 10-15 minute expiration though. At the wallet level, all sender and recipient need to agree on is their relative time. Fallback behavior for a signer with no access to time could be to ignore the deadline.\n\nAndreas Schildbach wrote:\n> \n> This feels redundant to me; the payment protocol already has an\n> expiration time.\n\nThe BIP-70 payment protocol has significant overhead and most importantly requires back and forth. Emailing a bitcoin address or printing it on an invoice is much easier, so I would expect people to keep doing that.\n\nSjors\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/48685946/attachment-0001.sig>"
            },
            {
                "author": "Andreas Schildbach",
                "date": "2017-09-28T14:13:48",
                "message_text_only": "On 09/28/2017 02:43 PM, Sjors Provoost via bitcoin-dev wrote:\n\n>> This feels redundant to me; the payment protocol already has an\n>> expiration time.\n> \n> The BIP-70 payment protocol has significant overhead and most importantly requires back and forth. Emailing a bitcoin address or printing it on an invoice is much easier, so I would expect people to keep doing that.\n\nThe payment request message is just as one-way as an address is. It is\nalready being emailed and printed on an invoice, in fact it often acts\nas the invoice.\n\nEven more problematic, if you were to include an expiry date in a\nBIP-173 address and put that into a payment request, wallets wouldn't be\nallowed to parse that expiry date from the script without violating the\nBIP70 spec."
            },
            {
                "author": "Sjors Provoost",
                "date": "2017-09-28T14:41:42",
                "message_text_only": "Op 28 sep. 2017, om 17:13 heeft Andreas Schildbach via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:\n> \n> On 09/28/2017 02:43 PM, Sjors Provoost via bitcoin-dev wrote:\n> \n>>> This feels redundant to me; the payment protocol already has an\n>>> expiration time.\n>> \n>> The BIP-70 payment protocol has significant overhead and most importantly requires back and forth. Emailing a bitcoin address or printing it on an invoice is much easier, so I would expect people to keep doing that.\n> \n> The payment request message is just as one-way as an address is. It is\n> already being emailed and printed on an invoice, in fact it often acts\n> as the invoice.\n\nTrue and the more complicated fields, like a digital signature, are optional. Are you suggesting BIP-70 payment requests should be rendered with bech32? How long would those be if it's just the address and expiration date?\n\n> \n> Even more problematic, if you were to include an expiry date in a\n> BIP-173 address and put that into a payment request, wallets wouldn't be\n> allowed to parse that expiry date from the script without violating the\n> BIP70 spec.\n\nDo tools that generate BIP-70 payment requests generate addresses themselves or are those input manually by a user? In the former case, I assume it could avoid setting the optional expiration date?\n\nIs it not allowed to scan the date even if it then sets the expires field to the same (redundant) value?\n\nSjors\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/9b3fb190/attachment.sig>"
            },
            {
                "author": "Andreas Schildbach",
                "date": "2017-09-28T15:06:56",
                "message_text_only": "On 09/28/2017 04:41 PM, Sjors Provoost via bitcoin-dev wrote:\n\n>> The payment request message is just as one-way as an address is. It is\n>> already being emailed and printed on an invoice, in fact it often acts\n>> as the invoice.\n> \n> True and the more complicated fields, like a digital signature, are optional. Are you suggesting BIP-70 payment requests should be rendered with bech32? How long would those be if it's just the address and expiration date?\n\nI've not yet progressed that far in segwit support, but I can't think of\na reason why not. You can request coins to any script using the payment\nprotocol.\n\nRegarding size, I've had no problems putting (unsigned) payment request\nmessages into QR codes. I doubt paying to a native segwit address will\nchange much in size. Protobuf is very efficient.\n\n\n>> Even more problematic, if you were to include an expiry date in a\n>> BIP-173 address and put that into a payment request, wallets wouldn't be\n>> allowed to parse that expiry date from the script without violating the\n>> BIP70 spec.\n> \n> Do tools that generate BIP-70 payment requests generate addresses themselves or are those input manually by a user? In the former case, I assume it could avoid setting the optional expiration date?\n\nThe BIP70 spec doesn't limit you on this, I guess either does exist.\nHaving two (or more!) optional expiration date adds unnecessary\ncomplexity to the specs and implementations. E.g. what if the two do not\nmatch up?\n\n> Is it not allowed to scan the date even if it then sets the expires field to the same (redundant) value?\n\nWhat do you mean by \"scan the date\"?"
            },
            {
                "author": "Sjors Provoost",
                "date": "2017-09-28T15:45:47",
                "message_text_only": "Op 28 sep. 2017, om 18:06 heeft Andreas Schildbach via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:\n> \n> On 09/28/2017 04:41 PM, Sjors Provoost via bitcoin-dev wrote:\n> \n>>> The payment request message is just as one-way as an address is. It is\n>>> already being emailed and printed on an invoice, in fact it often acts\n>>> as the invoice.\n>> \n>> True and the more complicated fields, like a digital signature, are optional. Are you suggesting BIP-70 payment requests should be rendered with bech32? How long would those be if it's just the address and expiration date?\n> \n> I've not yet progressed that far in segwit support, but I can't think of\n> a reason why not. You can request coins to any script using the payment\n> protocol.\n> \n> Regarding size, I've had no problems putting (unsigned) payment request\n> messages into QR codes. I doubt paying to a native segwit address will\n> change much in size. Protobuf is very efficient.\n\nBech32 is just a replacement for Base58. It's not strictly SegWit related. If I understand correctly the only reason it won't be used for legacy addresses is to prevent confusion:\n\nhttps://www.youtube.com/watch?v=NqiN9VFE4CU\nhttps://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki\n\nRegarding size I'm mostly curious how big it is on a screen or a physical paper, as text, not as a QR code. This would involve deserializing the protobuf and rendering the result in bech32.\n\nI does sound like there's overlap between BIP-70 and BIP-173 that should be resolved.\n\nPerhaps any payment request can be rendered as bech32 and any bech32 address can converted to a payment request. Maybe only for a limited set of fields (address, expiration, amount). This would be a matter of agreeing how the protobuf should be serialized and deserialized. In that case the protobuf would not contain the literal bech32 address as a string, but instead it would contain the underlying data (public key / script hash, network, etc).\n\nSjors\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/c1597496/attachment-0001.sig>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2017-09-28T16:59:26",
                "message_text_only": "On Thursday 28 September 2017 2:13:48 PM Andreas Schildbach via bitcoin-dev \nwrote:\n> On 09/28/2017 02:43 PM, Sjors Provoost via bitcoin-dev wrote:\n> >> This feels redundant to me; the payment protocol already has an\n> >> expiration time.\n> > \n> > The BIP-70 payment protocol has significant overhead and most importantly\n> > requires back and forth. Emailing a bitcoin address or printing it on an\n> > invoice is much easier, so I would expect people to keep doing that.\n> \n> The payment request message is just as one-way as an address is. It is\n> already being emailed and printed on an invoice, in fact it often acts\n> as the invoice.\n> \n> Even more problematic, if you were to include an expiry date in a\n> BIP-173 address and put that into a payment request, wallets wouldn't be\n> allowed to parse that expiry date from the script without violating the\n> BIP70 spec.\n\nPayment requests don't use and don't overlap with addresses. Maybe you could \nhave an argument for serialising BIP70 payment requests in Bech32 as the new \naddress format itself, but it doesn't make sense to talk about putting a \nBech32 address *into* a payment request...\n\nLuke"
            },
            {
                "author": "Peter Todd",
                "date": "2017-09-29T02:18:46",
                "message_text_only": "On Thu, Sep 28, 2017 at 03:43:05PM +0300, Sjors Provoost via bitcoin-dev wrote:\n> Peter Todd wrote:\n> Perhaps outside the scope of BIP173, but what about baking it into the protocol? That way a transaction that's sent too late, simply won't get confirmed. This removes the need for refund logic or asking a customer to pay just a few extra cents. You could also disallow a second payment.\n> \n> Two downsides I can think of:\n> * privacy, as differences in expiration policy would be visible on chain\n> * miners might be able to game it in their interaction with brokers\n\nThis has been discussed many times before; there are *severe* downsides to\nmaking it possible for transactions to become invalid after the fact.\n\n> > Being just an expiration time, seconds-level resolution is unnecessary, and\n> > may give the wrong impression. I'd suggest either:\n> > \n> > 1) Hour resolution - 2^24 hours = 1914 years\n> > 2) Month resolution - 2^16 months = 5458 years\n> \n> So that's 4.8 characters for hours, or 3.2 for years, plus checksum space? The shorter the better. Perhaps one or two bits can be used to specify an exponent; a large range seems more useful than high precision. For instance a merchant doesn't care if the customer pays within 10:00:00 minutes or 10:00:01 minutes and you wouldn't care if your address is valid 50 years or 50 years and 3 minutes. This point may be mute if minute level resolution is not practical.\n\nNote that \"large range\" is a requirement driven by the fact that expiry times\nwill inevitably be specified absolutely, not relatively: when the range runs\nout you need to upgrade the standard. Better to use another character and use a\nrange that won't run out any time soon.\n\nThis wouldn't create a need for more checksum space.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/04fb5921/attachment.sig>"
            },
            {
                "author": "Sjors Provoost",
                "date": "2017-09-29T07:18:06",
                "message_text_only": "Op 29 sep. 2017, om 05:18 heeft Peter Todd <pete at petertodd.org> het volgende geschreven:\n> \n> On Thu, Sep 28, 2017 at 03:43:05PM +0300, Sjors Provoost via bitcoin-dev wrote:\n>> Peter Todd wrote:\n>> Perhaps outside the scope of BIP173, but what about baking it into the protocol? That way a transaction that's sent too late, simply won't get confirmed. This removes the need for refund logic or asking a customer to pay just a few extra cents. You could also disallow a second payment.\n>> \n>> Two downsides I can think of:\n>> * privacy, as differences in expiration policy would be visible on chain\n>> * miners might be able to game it in their interaction with brokers\n> \n> This has been discussed many times before; there are *severe* downsides to\n> making it possible for transactions to become invalid after the fact.\n\nI've heard of that general principe, but I'm having trouble finding a good resource that describes it more precisely.\n\nIs it a peer to peer or mempool issue? E.g a transaction might be accepted into the mempool and relayed at one point in time and suddenly become invalid before they're committed to a block? Or that a node receives a transaction, thinks it's invalid because the address already expired, but then receives an older block later which contains that transaction?\n\nOnce in a block, I don't see how it would become invalid later. But as a miner tries to find a block and updates the timestamp, they would have toss the transaction out at some point.\n\nAnother objection I can think of, is that the soft fork introducing this change would have to use a transaction type that's non-standard at the moment. This would make it difficult for a non-upgraded node to broadcast such a transaction. The recipient would have to know if the sender has upgraded before communicating an address, which sounds impractical at best.\n\n>>> Being just an expiration time, seconds-level resolution is unnecessary, and\n>>> may give the wrong impression. I'd suggest either:\n>>> \n>>> 1) Hour resolution - 2^24 hours = 1914 years\n>>> 2) Month resolution - 2^16 months = 5458 years\n>> \n>> So that's 4.8 characters for hours, or 3.2 for years, plus checksum space? The shorter the better. Perhaps one or two bits can be used to specify an exponent; a large range seems more useful than high precision. For instance a merchant doesn't care if the customer pays within 10:00:00 minutes or 10:00:01 minutes and you wouldn't care if your address is valid 50 years or 50 years and 3 minutes. This point may be mute if minute level resolution is not practical.\n> \n> Note that \"large range\" is a requirement driven by the fact that expiry times\n> will inevitably be specified absolutely, not relatively: when the range runs\n> out you need to upgrade the standard. Better to use another character and use a\n> range that won't run out any time soon.\n> \n> This wouldn't create a need for more checksum space.\n\nYou're right, relative time makes no sense. So it would take 5 characters to get roughly two minute resolution that lasts for 100 years.\n\nSjors\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/47107d36/attachment.sig>"
            },
            {
                "author": "Peter Todd",
                "date": "2017-09-29T01:45:43",
                "message_text_only": "On Thu, Sep 28, 2017 at 12:09:59PM +0200, Andreas Schildbach via bitcoin-dev wrote:\n> This feels redundant to me; the payment protocol already has an\n> expiration time.\n\nI'm well aware. As the payment protocol hasn't caught on - and doesn't fully\noverlap all the usecases that addresses do anyway - I think we should consider\nbringing this important feature to Bitcoin addresses too.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/ad500ed8/attachment.sig>"
            },
            {
                "author": "Andreas Schildbach",
                "date": "2017-09-29T08:44:11",
                "message_text_only": "On 09/29/2017 03:45 AM, Peter Todd via bitcoin-dev wrote:\n> On Thu, Sep 28, 2017 at 12:09:59PM +0200, Andreas Schildbach via bitcoin-dev wrote:\n>> This feels redundant to me; the payment protocol already has an\n>> expiration time.\n> \n> I'm well aware. As the payment protocol hasn't caught on - and doesn't fully\n> overlap all the usecases that addresses do anyway - I think we should consider\n> bringing this important feature to Bitcoin addresses too.\n\nHasn't caught on? It is used for virtually all merchant transactions,\nplus person to person transactions between Bitcoin Wallet users."
            },
            {
                "author": "Peter Todd",
                "date": "2017-09-29T09:55:37",
                "message_text_only": "On Fri, Sep 29, 2017 at 10:44:11AM +0200, Andreas Schildbach via bitcoin-dev wrote:\n> On 09/29/2017 03:45 AM, Peter Todd via bitcoin-dev wrote:\n> > On Thu, Sep 28, 2017 at 12:09:59PM +0200, Andreas Schildbach via bitcoin-dev wrote:\n> >> This feels redundant to me; the payment protocol already has an\n> >> expiration time.\n> > \n> > I'm well aware. As the payment protocol hasn't caught on - and doesn't fully\n> > overlap all the usecases that addresses do anyway - I think we should consider\n> > bringing this important feature to Bitcoin addresses too.\n> \n> Hasn't caught on? It is used for virtually all merchant transactions,\n> plus person to person transactions between Bitcoin Wallet users.\n\n\"Virtually all\"?\n\nI regularly pay with Bitcoin, and I haven't seen the payment protocol used in\nages.\n\nCan you name some users of it?\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/28b4c7ee/attachment.sig>"
            },
            {
                "author": "Andreas Schildbach",
                "date": "2017-09-29T12:45:32",
                "message_text_only": "On 09/29/2017 11:55 AM, Peter Todd via bitcoin-dev wrote:\n\n>>> I'm well aware. As the payment protocol hasn't caught on - and doesn't fully\n>>> overlap all the usecases that addresses do anyway - I think we should consider\n>>> bringing this important feature to Bitcoin addresses too.\n>>\n>> Hasn't caught on? It is used for virtually all merchant transactions,\n>> plus person to person transactions between Bitcoin Wallet users.\n> \n> \"Virtually all\"?\n> \n> I regularly pay with Bitcoin, and I haven't seen the payment protocol used in\n> ages.\n\nI regularly pay with Bitcoin, and I haven't seen the payment protocol\nnot being in use in ages.\n\n> Can you name some users of it?\n\n15+ Mio Coinbase users\n~10 Mio BitPay users\n8 Mio Bitcoin Wallet users\nPlus Bitcoin Core, Electrum, etc (sorry no numbers)\n\nProbably the only usecase for naked addresses is paper wallets, right?\nI'm not sure if paper wallets can expire."
            },
            {
                "author": "Peter Todd",
                "date": "2017-09-29T13:52:03",
                "message_text_only": "On Fri, Sep 29, 2017 at 02:45:32PM +0200, Andreas Schildbach via bitcoin-dev wrote:\n> On 09/29/2017 11:55 AM, Peter Todd via bitcoin-dev wrote:\n> \n> >>> I'm well aware. As the payment protocol hasn't caught on - and doesn't fully\n> >>> overlap all the usecases that addresses do anyway - I think we should consider\n> >>> bringing this important feature to Bitcoin addresses too.\n> >>\n> >> Hasn't caught on? It is used for virtually all merchant transactions,\n> >> plus person to person transactions between Bitcoin Wallet users.\n> > \n> > \"Virtually all\"?\n> > \n> > I regularly pay with Bitcoin, and I haven't seen the payment protocol used in\n> > ages.\n> \n> I regularly pay with Bitcoin, and I haven't seen the payment protocol\n> not being in use in ages.\n> \n> > Can you name some users of it?\n> \n> 15+ Mio Coinbase users\n\nLol, interesting mistake I made w/ Coinbase: my mobile wallets are all setup in\nways that don't support the payment protocol w/ Coinbase, probably because come\nto think of it they were (still are?) rejecting payment protocol requests over\nproxies and Tor. And on my desktop setups payment protocol URLs don't work for\nvarious reasons, and I'd forgotten I'd manually disabled them ages ago.\n\nJust checked and Bitfinex, BTCC, and Shapeshift all don't seem to use the\npayment protocol.\n\nOther than BitPay and Coinbase, do you have an example of a service supporting\nthe payment protocol?\n\n> ~10 Mio BitPay users\n> 8 Mio Bitcoin Wallet users\n> Plus Bitcoin Core, Electrum, etc (sorry no numbers)\n> \n> Probably the only usecase for naked addresses is paper wallets, right?\n> I'm not sure if paper wallets can expire.\n\nUser-to-user payments pretty much always use naked addresses.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/85654673/attachment.sig>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2017-09-29T17:25:18",
                "message_text_only": "On Fri, Sep 29, 2017 at 12:45 PM, Andreas Schildbach via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> 15+ Mio Coinbase users\n\nWho's payment protocol SSL cert was expired for months without even\ngenerating a post on reddit.  Not exactly convincing there.\n\nThe fact that someone supports it doesn't mean its being used."
            }
        ],
        "thread_summary": {
            "title": "Address expiration times should be added to BIP-173",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "CryptAxe",
                "Nick Pudar",
                "Andreas Schildbach",
                "Chris Priest",
                "Peter Todd",
                "Gregory Maxwell",
                "Sjors Provoost",
                "Luke Dashjr",
                "Mark Friedenbach"
            ],
            "messages_count": 30,
            "total_messages_chars_count": 61905
        }
    },
    {
        "title": "[bitcoin-dev] Why the BIP-72 Payment Protocol URI Standard is Insecure Against MITM Attacks",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2017-09-29T02:55:38",
                "message_text_only": "On Thu, Sep 28, 2017 at 03:43:05PM +0300, Sjors Provoost via bitcoin-dev wrote:\n> Andreas Schildbach wrote:\n> > This feels redundant to me; the payment protocol already has an\n> > expiration time.\n> \n> The BIP-70 payment protocol has significant overhead and most importantly requires back and forth. Emailing a bitcoin address or printing it on an invoice is much easier, so I would expect people to keep doing that.\n\nThe BIP-70 payment protocol used via BIP-72 URI's is insecure, as payment qr\ncodes don't cryptographically commit to the identity of the merchant, which\nmeans a MITM attacker can redirect the payment if they can obtain a SSL cert\nthat the wallet accepts.\n\nFor example, if I have a wallet on my phone and go to pay a\nmerchant, a BIP-72 URI will look like the following(1):\n\n    bitcoin:mq7se9wy2egettFxPbmn99cK8v5AFq55Lx?amount=0.11&r=https://merchant.com/pay.php?h%3D2a8628fc2fbe\n\nA wallet following the BIP-72 standard will \"ignore the bitcoin\naddress/amount/label/message in the URI and instead fetch a PaymentRequest\nmessage and then follow the payment protocol, as described in BIP 70.\"\n\nSo my phone will make a second connection - likely on a second network with a\ntotally different set of MITM attackers - to https://merchant.com\n\nIn short, while my browser may have gotten the correct URL with the correct\nBitcoin address, by using the payment protocol my wallet is discarding that\ninformation and giving MITM attackers a second chance at redirecting my payment\nto them. That wallet is also likely using an off-the-shelf SSL library, with\nnothing other than an infrequently updated set of root certificates to use to\nverify the certificate; your browser has access to a whole host of better\ntechnologies, such as HSTS pinning, certificate transparency, and frequently\nupdated root certificate lists with proper revocation (see Symantec).\n\nAs an ad-hoc, unstandardized, extension Android Wallet for Bitcoin at least\nsupports a h= parameter with a hash commitment to what the payment request\nshould be, and will reject the MITM attacker if that hash doesn't match. But\nthat's not actually in the standard itself, and as far as I can tell has never\nbeen made into a BIP.\n\nAs-is BIP-72 is very dangerous and should be depreciated, with a new BIP made\nto replace it.\n\n1) As an aside, it's absolutely hilarious that this URL taken straight from\n   BIP-72 has the merchant using PHP, given its truly terrible track record for\n   security.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/09e0db5f/attachment.sig>"
            },
            {
                "author": "Omar Shibli",
                "date": "2017-09-29T04:21:09",
                "message_text_only": "Thank you for sharing, this is indefinitely valuable.\n\nI think that risk could be mitigated if instead of ignoring the bitcoin\naddress/amount/..., the wallet use this address for integrity checks.\nFurthermore, I think this BIP could be improved by actually applying the\nhomomorphic property and deriving the bitcoin address from merchant pub key\nand the hash itself. that would allow both the customer and merchant to be\nable generate address independently.\n\nOn Fri, Sep 29, 2017 at 5:55 AM, Peter Todd via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Thu, Sep 28, 2017 at 03:43:05PM +0300, Sjors Provoost via bitcoin-dev\n> wrote:\n> > Andreas Schildbach wrote:\n> > > This feels redundant to me; the payment protocol already has an\n> > > expiration time.\n> >\n> > The BIP-70 payment protocol has significant overhead and most\n> importantly requires back and forth. Emailing a bitcoin address or printing\n> it on an invoice is much easier, so I would expect people to keep doing\n> that.\n>\n> The BIP-70 payment protocol used via BIP-72 URI's is insecure, as payment\n> qr\n> codes don't cryptographically commit to the identity of the merchant, which\n> means a MITM attacker can redirect the payment if they can obtain a SSL\n> cert\n> that the wallet accepts.\n>\n> For example, if I have a wallet on my phone and go to pay a\n> merchant, a BIP-72 URI will look like the following(1):\n>\n>     bitcoin:mq7se9wy2egettFxPbmn99cK8v5AFq55Lx?amount=0.11&r=https://\n> merchant.com/pay.php?h%3D2a8628fc2fbe\n>\n> A wallet following the BIP-72 standard will \"ignore the bitcoin\n> address/amount/label/message in the URI and instead fetch a PaymentRequest\n> message and then follow the payment protocol, as described in BIP 70.\"\n>\n> So my phone will make a second connection - likely on a second network\n> with a\n> totally different set of MITM attackers - to https://merchant.com\n>\n> In short, while my browser may have gotten the correct URL with the correct\n> Bitcoin address, by using the payment protocol my wallet is discarding that\n> information and giving MITM attackers a second chance at redirecting my\n> payment\n> to them. That wallet is also likely using an off-the-shelf SSL library,\n> with\n> nothing other than an infrequently updated set of root certificates to use\n> to\n> verify the certificate; your browser has access to a whole host of better\n> technologies, such as HSTS pinning, certificate transparency, and\n> frequently\n> updated root certificate lists with proper revocation (see Symantec).\n>\n> As an ad-hoc, unstandardized, extension Android Wallet for Bitcoin at least\n> supports a h= parameter with a hash commitment to what the payment request\n> should be, and will reject the MITM attacker if that hash doesn't match.\n> But\n> that's not actually in the standard itself, and as far as I can tell has\n> never\n> been made into a BIP.\n>\n> As-is BIP-72 is very dangerous and should be depreciated, with a new BIP\n> made\n> to replace it.\n>\n> 1) As an aside, it's absolutely hilarious that this URL taken straight from\n>    BIP-72 has the merchant using PHP, given its truly terrible track\n> record for\n>    security.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/4137a237/attachment-0001.html>"
            },
            {
                "author": "Tomas",
                "date": "2017-09-29T13:14:03",
                "message_text_only": "On Fri, Sep 29, 2017, at 04:55, Peter Todd via bitcoin-dev wrote:\n> The BIP-70 payment protocol used via BIP-72 URI's is insecure, as payment\n> qr\n> codes don't cryptographically commit to the identity of the merchant,\n> which\n> means a MITM attacker can redirect the payment if they can obtain a SSL\n> cert\n> that the wallet accepts.\n\nBy that reasoning, we also shouldn't go to https://coinbase.com or\nhttps://kraken.com to buy any bitcoins? As a MITM can redirect the site\n_if_ they obtain the coinbase or kraken certificate.\n\nObviously, HTTPS is secured under the assumption that certificates are\nsecure.  \n\nUsing the payment protocol simply means paying to a secure endpoint (eg\nhttps://tomasvdw.nl/pay) instead of an address.\n\n>  That wallet is also likely using an off-the-shelf SSL library,\n> with\n> nothing other than an infrequently updated set of root certificates to\n> use to\n> verify the certificate; your browser has access to a whole host of better\n> technologies, such as HSTS pinning, certificate transparency, and\n> frequently\n> updated root certificate lists with proper revocation (see Symantec).\n\nSo we should not use HTTPS for secure transfer because the\nimplementation may not be good enough? This incorrectly conflates\nimplementation with specification. There is nothing stopping a developer\nfrom using a proper implementation.\n\n> \n> As an ad-hoc, unstandardized, extension Android Wallet for Bitcoin at\n> least\n> supports a h= parameter with a hash commitment to what the payment\n> request\n> should be, and will reject the MITM attacker if that hash doesn't match.\n> But\n> that's not actually in the standard itself, and as far as I can tell has\n> never\n> been made into a BIP.\n\nCurrently it is widely used by merchants, but not yet for light clients\n_receiving_ money. If it becomes more wide spread,   it offers a range\nof advantages as  the bitcoin-address of the URI can and should be\ndeprecated (made impossible with \"h=\"). A payment address just becomes a\nsecure endpoint.\n\nThis means no more address reuse is possible. Also, it drops the need\nfor mempool synchronization among non-miners, solely as a \"notification\"\nmechanism. In addition it means light clients know exactly when a\ntransaction is coming in, so they can efficiently rely on client-side\nfiltering a small set of blocks, improving their privacy.\n\nIn my opinion, the payment protocol is key to scaling.\n\n> As-is BIP-72 is very dangerous and should be depreciated, with a new BIP\n> made\n> to replace it.\n\nSorry, but maybe you  could explain better how secure communication over\nHTTPS is \"very dangerous\"? I think some websites would like to know :)\n\nTomas van der Wansem\nbitcrust"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2017-09-29T17:40:00",
                "message_text_only": "Everybody knows that https is broken and insecure, and everybody knows\nthat it's still better than nothing\n\nJust reacting here because there is worse: you are quoting Kraken, did\nnot check for Coinbase but Kraken is proxying all of its https traffic\nvia Cloudflare, including the API traffic\n\nThis is crazy but that's how things are, that's what everybody is doing,\nthat's what we have\n\nThe https principles are obsolete, the concept of certificates tied to a\ndomain is a complete stupidity, because there are no concept of domains\nin bitcoin for example (and webrtc, Tor, bittorrent, p2p systems, etc)\nand should evolve to something like certificates tied to an entityID\nmanaged by something like a blockchain system, and not a stupid domain or CA\n\nTherefore specifying things for bitcoin \u00e0 la web is not a good idea,\nbrowsers can do far better than standard/usual web, and the \"like\neverybody is doing\" argument is not a valid one\n\n\nLe 29/09/2017 \u00e0 15:14, Tomas via bitcoin-dev a \u00e9crit\u00a0:\n> On Fri, Sep 29, 2017, at 04:55, Peter Todd via bitcoin-dev wrote:\n>> The BIP-70 payment protocol used via BIP-72 URI's is insecure, as payment\n>> qr\n>> codes don't cryptographically commit to the identity of the merchant,\n>> which\n>> means a MITM attacker can redirect the payment if they can obtain a SSL\n>> cert\n>> that the wallet accepts.\n> By that reasoning, we also shouldn't go to https://coinbase.com or\n> https://kraken.com to buy any bitcoins? As a MITM can redirect the site\n> _if_ they obtain the coinbase or kraken certificate.\n>\n> Obviously, HTTPS is secured under the assumption that certificates are\n> secure.  \n>\n> Using the payment protocol simply means paying to a secure endpoint (eg\n> https://tomasvdw.nl/pay) instead of an address.\n>\n>>  That wallet is also likely using an off-the-shelf SSL library,\n>> with\n>> nothing other than an infrequently updated set of root certificates to\n>> use to\n>> verify the certificate; your browser has access to a whole host of better\n>> technologies, such as HSTS pinning, certificate transparency, and\n>> frequently\n>> updated root certificate lists with proper revocation (see Symantec).\n> So we should not use HTTPS for secure transfer because the\n> implementation may not be good enough? This incorrectly conflates\n> implementation with specification. There is nothing stopping a developer\n> from using a proper implementation.\n>\n>> As an ad-hoc, unstandardized, extension Android Wallet for Bitcoin at\n>> least\n>> supports a h= parameter with a hash commitment to what the payment\n>> request\n>> should be, and will reject the MITM attacker if that hash doesn't match.\n>> But\n>> that's not actually in the standard itself, and as far as I can tell has\n>> never\n>> been made into a BIP.\n> Currently it is widely used by merchants, but not yet for light clients\n> _receiving_ money. If it becomes more wide spread,   it offers a range\n> of advantages as  the bitcoin-address of the URI can and should be\n> deprecated (made impossible with \"h=\"). A payment address just becomes a\n> secure endpoint.\n>\n> This means no more address reuse is possible. Also, it drops the need\n> for mempool synchronization among non-miners, solely as a \"notification\"\n> mechanism. In addition it means light clients know exactly when a\n> transaction is coming in, so they can efficiently rely on client-side\n> filtering a small set of blocks, improving their privacy.\n>\n> In my opinion, the payment protocol is key to scaling.\n>\n>> As-is BIP-72 is very dangerous and should be depreciated, with a new BIP\n>> made\n>> to replace it.\n> Sorry, but maybe you  could explain better how secure communication over\n> HTTPS is \"very dangerous\"? I think some websites would like to know :)\n>\n> Tomas van der Wansem\n> bitcrust\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms"
            },
            {
                "author": "Andreas Schildbach",
                "date": "2017-09-30T15:33:01",
                "message_text_only": "Generally agreed. This is why I nack'ed BIP72 years ago when we\ndiscussed about standardization.\n\nHowever, there are many ways to use BIP70 without BIP72. BIP72 is just a\nkludge to biggy-pack the payment protocol onto BIP21. And also, as you\nnote, BIP72 can be easily fixed using a hash parameter.\n\n\nOn 09/29/2017 04:55 AM, Peter Todd via bitcoin-dev wrote:\n> On Thu, Sep 28, 2017 at 03:43:05PM +0300, Sjors Provoost via bitcoin-dev wrote:\n>> Andreas Schildbach wrote:\n>>> This feels redundant to me; the payment protocol already has an\n>>> expiration time.\n>>\n>> The BIP-70 payment protocol has significant overhead and most importantly requires back and forth. Emailing a bitcoin address or printing it on an invoice is much easier, so I would expect people to keep doing that.\n> \n> The BIP-70 payment protocol used via BIP-72 URI's is insecure, as payment qr\n> codes don't cryptographically commit to the identity of the merchant, which\n> means a MITM attacker can redirect the payment if they can obtain a SSL cert\n> that the wallet accepts.\n> \n> For example, if I have a wallet on my phone and go to pay a\n> merchant, a BIP-72 URI will look like the following(1):\n> \n>     bitcoin:mq7se9wy2egettFxPbmn99cK8v5AFq55Lx?amount=0.11&r=https://merchant.com/pay.php?h%3D2a8628fc2fbe\n> \n> A wallet following the BIP-72 standard will \"ignore the bitcoin\n> address/amount/label/message in the URI and instead fetch a PaymentRequest\n> message and then follow the payment protocol, as described in BIP 70.\"\n> \n> So my phone will make a second connection - likely on a second network with a\n> totally different set of MITM attackers - to https://merchant.com\n> \n> In short, while my browser may have gotten the correct URL with the correct\n> Bitcoin address, by using the payment protocol my wallet is discarding that\n> information and giving MITM attackers a second chance at redirecting my payment\n> to them. That wallet is also likely using an off-the-shelf SSL library, with\n> nothing other than an infrequently updated set of root certificates to use to\n> verify the certificate; your browser has access to a whole host of better\n> technologies, such as HSTS pinning, certificate transparency, and frequently\n> updated root certificate lists with proper revocation (see Symantec).\n> \n> As an ad-hoc, unstandardized, extension Android Wallet for Bitcoin at least\n> supports a h= parameter with a hash commitment to what the payment request\n> should be, and will reject the MITM attacker if that hash doesn't match. But\n> that's not actually in the standard itself, and as far as I can tell has never\n> been made into a BIP.\n> \n> As-is BIP-72 is very dangerous and should be depreciated, with a new BIP made\n> to replace it.\n> \n> 1) As an aside, it's absolutely hilarious that this URL taken straight from\n>    BIP-72 has the merchant using PHP, given its truly terrible track record for\n>    security.\n> \n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            }
        ],
        "thread_summary": {
            "title": "Why the BIP-72 Payment Protocol URI Standard is Insecure Against MITM Attacks",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tomas",
                "Andreas Schildbach",
                "Peter Todd",
                "Aymeric Vitte",
                "Omar Shibli"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 16567
        }
    },
    {
        "title": "[bitcoin-dev] Revising BIP 2 to expand editorial authority",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2017-09-27T18:56:26",
                "message_text_only": "Many pull requests to the BIPs repository are spelling corrections or similar, \nwhich are obvious to merge. Currently, the BIP process requires the Author of \nthe affected BIPs to ACK any changes, which seems inefficient and unnecessary \nfor these kind of editorial fixes.\n\nWhat do people think about modifying BIP 2 to allow editors to merge these \nkinds of changes without involving the Authors? Strictly speaking, BIP 2 \nshouldn't be changed now that it is Active, but for such a minor revision, I \nthink an exception is reasonable.\n\nI've prepared a draft PR for BIP 2 here:\n    https://github.com/bitcoin/bips/pull/596\n\nIf you oppose this change, please say so within the next month.\n\nLuke"
            },
            {
                "author": "Bryan Bishop",
                "date": "2017-09-27T19:01:40",
                "message_text_only": "On Wed, Sep 27, 2017 at 1:56 PM, Luke Dashjr via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> What do people think about modifying BIP 2 to allow editors to merge these\n> kinds of changes without involving the Authors? Strictly speaking, BIP 2\n> shouldn't be changed now that it is Active, but for such a minor revision,\n> I\n> think an exception is reasonable.\n>\n\nEven minor revisions can not change the meaning of text. Changing a single\nword can often have a strange impact on the meaning of the text. There\nshould be some amount of care exercised here. Maybe it would be okay as\nlong as edits are mentioned in the changelog at the bottom of each\ndocument, or mention that the primary authors have not reviewed suggested\nchanges, or something as much; otherwise the reader might not be aware to\ncheck revision history to see what's going on.\n\n- Bryan\nhttp://heybryan.org/\n1 512 203 0507\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/f7331b71/attachment.html>"
            },
            {
                "author": "Sjors Provoost",
                "date": "2017-09-27T20:20:54",
                "message_text_only": "Op 27 sep. 2017, om 22:01 heeft Bryan Bishop via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:\n> \n> On Wed, Sep 27, 2017 at 1:56 PM, Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> What do people think about modifying BIP 2 to allow editors to merge these\n> kinds of changes without involving the Authors? Strictly speaking, BIP 2\n> shouldn't be changed now that it is Active, but for such a minor revision, I\n> think an exception is reasonable.\n> \n> Even minor revisions can not change the meaning of text. Changing a single word can often have a strange impact on the meaning of the text. There should be some amount of care exercised here. Maybe it would be okay as long as edits are mentioned in the changelog at the bottom of each document, or mention that the primary authors have not reviewed suggested changes, or something as much; otherwise the reader might not be aware to check revision history to see what's going on.\n\nPerhaps it's enough to @mention authors in the PR and give them a week to object before merging?\n\nSjors\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/2bfcb0e8/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/2bfcb0e8/attachment.sig>"
            },
            {
                "author": "Jean-Paul Kogelman",
                "date": "2017-09-27T21:00:35",
                "message_text_only": "Perhaps having authors consent to certain types of changes when they submit their BIP?\n\n\n> On Sep 27, 2017, at 1:20 PM, Sjors Provoost via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \n>> Op 27 sep. 2017, om 22:01 heeft Bryan Bishop via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:\n>> \n>>> On Wed, Sep 27, 2017 at 1:56 PM, Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>> What do people think about modifying BIP 2 to allow editors to merge these\n>>> kinds of changes without involving the Authors? Strictly speaking, BIP 2\n>>> shouldn't be changed now that it is Active, but for such a minor revision, I\n>>> think an exception is reasonable.\n>> \n>> Even minor revisions can not change the meaning of text. Changing a single word can often have a strange impact on the meaning of the text. There should be some amount of care exercised here. Maybe it would be okay as long as edits are mentioned in the changelog at the bottom of each document, or mention that the primary authors have not reviewed suggested changes, or something as much; otherwise the reader might not be aware to check revision history to see what's going on.\n> \n> Perhaps it's enough to @mention authors in the PR and give them a week to object before merging?\n> \n> Sjors\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/b5952838/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2017-09-28T12:43:19",
                "message_text_only": "Agreed, I think a sign-off mechanism might be desirable. Currently it must\nbe the original author(s) signing off, but we can probably widen that to be\nany 2-3 community members. They'd basically be attesting that the meaning\ndid not change.\n\n- cdecker\n\nOn Wed, Sep 27, 2017 at 9:02 PM Bryan Bishop via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Wed, Sep 27, 2017 at 1:56 PM, Luke Dashjr via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> What do people think about modifying BIP 2 to allow editors to merge these\n>> kinds of changes without involving the Authors? Strictly speaking, BIP 2\n>> shouldn't be changed now that it is Active, but for such a minor\n>> revision, I\n>> think an exception is reasonable.\n>>\n>\n> Even minor revisions can not change the meaning of text. Changing a single\n> word can often have a strange impact on the meaning of the text. There\n> should be some amount of care exercised here. Maybe it would be okay as\n> long as edits are mentioned in the changelog at the bottom of each\n> document, or mention that the primary authors have not reviewed suggested\n> changes, or something as much; otherwise the reader might not be aware to\n> check revision history to see what's going on.\n>\n> - Bryan\n> http://heybryan.org/\n> 1 512 203 0507\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/1651c3ca/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2017-09-29T01:52:00",
                "message_text_only": "On Wed, Sep 27, 2017 at 02:01:40PM -0500, Bryan Bishop via bitcoin-dev wrote:\n> On Wed, Sep 27, 2017 at 1:56 PM, Luke Dashjr via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> > What do people think about modifying BIP 2 to allow editors to merge these\n> > kinds of changes without involving the Authors? Strictly speaking, BIP 2\n> > shouldn't be changed now that it is Active, but for such a minor revision,\n> > I\n> > think an exception is reasonable.\n> >\n> \n> Even minor revisions can not change the meaning of text. Changing a single\n> word can often have a strange impact on the meaning of the text. There\n> should be some amount of care exercised here. Maybe it would be okay as\n> long as edits are mentioned in the changelog at the bottom of each\n> document, or mention that the primary authors have not reviewed suggested\n> changes, or something as much; otherwise the reader might not be aware to\n> check revision history to see what's going on.\n\nAs part of this, we may want to say that the BIP editor should\ncryptographically sign (and ideally timestamp) all their changes as a secondary\nmeasure to make it clear who actually made the change.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/086e86a5/attachment-0001.sig>"
            }
        ],
        "thread_summary": {
            "title": "Revising BIP 2 to expand editorial authority",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Bryan Bishop",
                "Peter Todd",
                "Jean-Paul Kogelman",
                "Luke Dashjr",
                "Sjors Provoost",
                "Christian Decker"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 8300
        }
    },
    {
        "title": "[bitcoin-dev] Rebatable fees & incentive-safe fee markets",
        "thread_messages": [
            {
                "author": "Mark Friedenbach",
                "date": "2017-09-29T01:06:29",
                "message_text_only": "This article by Ron Lavi, Or Sattath, and Aviv Zohar was forwarded to\nme and is of interest to this group:\n\n    \"Redesigning Bitcoin's fee market\"\n    https://arxiv.org/abs/1709.08881\n\nI'll briefly summarize before providing some commentary of my own,\nincluding transformation of the proposed mechanism into a relatively\nsimple soft-fork.  The article points out that bitcoin's auction\nmodel for transaction fees / inclusion in a block is broken in the\nsense that it does not achieve maximum clearing price* and to prevent\nstrategic bidding behavior.\n\n(* Maximum clearing price meaning highest fee the user is willing to\n   pay for the amount of time they had to wait.  In other words, miner\n   income.  While this is a common requirement of academic work on\n   auction protocols, it's not obvious that it provides intrinsic\n   benefit to bitcoin for miners to extract from users the maximum\n   amount of fee the market is willing to support.  However strategic\n   bidding behavior (e.g. RBF and CPFP) does have real network and\n   usability costs, which a more \"correct\" auction model would reduce\n   in some use cases.)\n\nBitcoin is a \"pay your bid\" auction, where the user makes strategic\ncalculations to determine what bid (=fee) is likely to get accepted\nwithin the window of time in which they want confirmation.  This bid\ncan then be adjusted through some combination of RBF or CPFP.\n\nThe authors suggest moving to a \"pay lowest winning bid\" model where\nall transactions pay only the smallest fee rate paid by any\ntransaction in the block, for which the winning strategy is to bid the\nmaximum amount you are willing to pay to get the transaction\nconfirmed:\n\n> Users can then simply set their bids truthfully to exactly the\n> amount they are willing to pay to transact, and do not need to\n> utilize fee estimate mechanisms, do not resort to bid shading and do\n> not need to adjust transaction fees (via replace-by-fee mechanisms)\n> if the mempool grows.\n\n\nUnlike other proposed fixes to the fee model, this is not trivially\nbroken by paying the miner out of band.  If you pay out of band fee\ninstead of regular fee, then your transaction cannot be included with\nother regular fee paying transactions without the miner giving up all\nregular fee income.  Any transaction paying less fee in-band than the\notherwise minimum fee rate needs to also provide ~1Mvbyte * fee rate\ndifference fee to make up for that lost income.  So out of band fee is\nonly realistically considered when it pays on top of a regular feerate\npaying transaction that would have been included in the block anyway.\nAnd what would be the point of that?\n\n\nAs an original contribution, I would like to note that something\nstrongly resembling this proposal could be soft-forked in very easily.\nThe shortest explanation is:\n\n    For scriptPubKey outputs of the form \"<max-42-byte-push>\", where\n    the pushed data evaluates as true, a consensus rule is added that\n    the coinbase must pay any fee in excess of the minimum fee rate\n    for the block to the push value, which is a scriptPubKey.\n\nBeyond fixing the perceived problems of bitcoin's fee auction model\nleading to costly strategic behavior (whether that is a problem is a\ntopic open to debate!), this would have the additional benefits of:\n\n    1. Allowing pre-signed transactions, of payment channel close-out\n       for example, to provide sufficient fee for confirmation without\n       knowledge of future rates or overpaying or trusting a wallet to\n       be online to provide CPFP fee updates.\n\n    2. Allowing explicit fees in multi-party transaction creation\n       protocols where final transaction sizes are not known prior to\n       signing by one or more of the parties, while again not\n       overpaying or trusting on CPFP, etc.\n\n    3. Allowing applications with expensive network access to pay\n       reasonable fees for quick confirmation, without overpaying or\n       querying a trusted fee estimator.  Blockstream Satellite helps\n       here, but rebateable fees provides an alternative option when\n       full block feeds are not available for whatever reason.\n\nUsing a fee rebate would carry a marginal cost of 70-100 vbytes per\ninstance.  This makes it a rather expensive feature, and therefore in\nmy own estimation not something that is likely to be used by most\ntransactions today.  However the cost is less than CPFP, and so I\nexpect that it would be a heavily used feature in things like payment\nchannel refund and uncooperative close-out transactions.\n\n\nHere is a more worked out proposal, suitable for critiquing:\n\n1. A transaction is allowed to specify an _Implicit Fee_, as usual, as\n   well as one or more explicit _Rebateable Fees_.  A rebateable fee\n   is an ouput with a scriptPubKey that consists of a single, minimal,\n   nonzero push of up to 42 bytes.  Note that this is an always-true\n   script that requires no signature to spend.\n\n2. The _Fee Rate_ of a transaction is a fractional number equal to the\n   combined implicit and rebateable fee divided by the size/weight of\n   the transaction.\n\n   (A nontrivial complication of this, which I will punt on for the\n    moment, is how to group transactions for fee rate calculation such\n    that CPFP doesn't bring down the minimum fee rate of the block,\n    but to do so with rules that are both simple, because this is\n    consensus code; and fair, so as to prevent unintended use of a\n    rebate fee by children or siblings.)\n\n3. The smallest fee rate of any non-coinbase transaction (or\n   transaction group) is the _Marginal Fee Rate_ for the block and is\n   included in the witness for the block.\n\n4. The verifier checks that each transaction or transaction grouping\n   provides a fee greater than or equal to the threshold fee rate, and\n   at least one is exactly equal to the marginal rate (which proves\n   the marginal rate is the minimum for the block).\n\nThis establishes the marginal fee rate, which alternatively expressed\nis epsilon less than the fee rate that would have been required to get\ninto the block, assuming there was sufficient space.\n\n5. A per-block _Dust Threshold_ is calculated using the marginal fee\n   rate and reasonable assumptions about transaction size.\n\n6. For each transaction (or transaction group), the _Required Fee_ is\n   calculated to be the marginal fee rate times the size/weight of the\n   transaction.  Implicit fee is applied towards this required fee and\n   added to the _Miner's Fee Tally_.  Any excess implicit fee\n   remaining is added to the _Implicit Fee Tally_.\n\n7. For each transaction (group), the rebateable fees contribute\n   proportionally towards towards meeting the remaining marginal fee\n   requirement, if the implicit fee failed to do so.  Of what's left,\n   one of two things can happen based on how much is remaining:\n\n     A. If greater than or equal to the dust threshold is remaining in\n        a specific rebateable fee, a requirement is added that an\n        output be provided in the coinbase paying the remaining fee to\n        a scriptPubKey equal to the push value (see #1 above).\n\n        (With due consideration for what happens if a script is reused\n         in multiple explicit fees, of course.)\n\n     B. Otherwise, add remaining dust to the implicit fee tally.\n\n8. For the very last transaction in the block, the miner builds a\n   transaction claiming ALL of these explicit fees, and with a single\n   zero-valued null/data output, thereby forwarding the fees on to the\n   coinbase, as far as old clients are concerned.  This is only\n   concerns consensus in that this final transaction does not change\n   any of the previously mentioned tallies.\n\n   (Aside: the zero-valued output is merely required because all\n    transactions must have at least one output. It does however make a\n    great location to put commitments for extensions to the block\n    header, as being on the right-most path of the Merkle tree can\n    mean shorter proofs.)\n\n9. The miner is allowed to claim subsidy + the miner's fee tally + the\n   explicit fee tally for themselves in the coinbase.  The coinbase is\n   also required to contain all rebated fees above the dust threshold.\n\nIn summary, all transactions have the same actual fee rate equal to\nthe minimum fee rate that went into the creation of the block, which\nis basically the marginal fee rate for transaction inclusion.\n\nA variant of this proposal is that instead of giving the implicit fee\ntally to the miner (the excess non-rebateable fees beyond the required\nminimum), it is carried forward from block to block in the final\ntransaction and the miner is allowed to claim some average of past\nfees, thereby smoothing out fees or providing some other incentive.\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 659 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/8d6e3b63/attachment.sig>"
            },
            {
                "author": "Matt Corallo",
                "date": "2017-09-29T01:53:55",
                "message_text_only": "I'm somewhat curious what the authors envisioned the real-world implications of this model to be. While blindly asking users to enter what they're willing to pay always works in theory, I'd imagine in such a world the fee selection UX would be similar to what it is today - users are provided a list of options with feerates and expected confirmation times from which to select. Indeed, in a world where users pay a lower fee if they paid more than necessary fee estimation could be more willing to overshoot and the UX around RBF and CPFP could be simplified greatly, but I'm not actually convinced that it would result in higher overall mining revenue.\n\nThe UX issues with RBF and CPFP, not to mention the UX issues involved in optimizing for quick confirmation are, indeed, quite significant, but I believe them to be solveable with rather striaght-forward changes. Making the market more useable (for higher or lower overall miner revenue) may be a sufficient goal, however, to want to consider something like this.\n\nOn September 28, 2017 9:06:29 PM EDT, Mark Friedenbach via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>This article by Ron Lavi, Or Sattath, and Aviv Zohar was forwarded to\n>me and is of interest to this group:\n>\n>    \"Redesigning Bitcoin's fee market\"\n>    https://arxiv.org/abs/1709.08881\n>\n>I'll briefly summarize before providing some commentary of my own,\n>including transformation of the proposed mechanism into a relatively\n>simple soft-fork.  The article points out that bitcoin's auction\n>model for transaction fees / inclusion in a block is broken in the\n>sense that it does not achieve maximum clearing price* and to prevent\n>strategic bidding behavior.\n>\n>(* Maximum clearing price meaning highest fee the user is willing to\n>   pay for the amount of time they had to wait.  In other words, miner\n>   income.  While this is a common requirement of academic work on\n>   auction protocols, it's not obvious that it provides intrinsic\n>   benefit to bitcoin for miners to extract from users the maximum\n>   amount of fee the market is willing to support.  However strategic\n>   bidding behavior (e.g. RBF and CPFP) does have real network and\n>   usability costs, which a more \"correct\" auction model would reduce\n>   in some use cases.)\n>\n>Bitcoin is a \"pay your bid\" auction, where the user makes strategic\n>calculations to determine what bid (=fee) is likely to get accepted\n>within the window of time in which they want confirmation.  This bid\n>can then be adjusted through some combination of RBF or CPFP.\n>\n>The authors suggest moving to a \"pay lowest winning bid\" model where\n>all transactions pay only the smallest fee rate paid by any\n>transaction in the block, for which the winning strategy is to bid the\n>maximum amount you are willing to pay to get the transaction\n>confirmed:\n>\n>> Users can then simply set their bids truthfully to exactly the\n>> amount they are willing to pay to transact, and do not need to\n>> utilize fee estimate mechanisms, do not resort to bid shading and do\n>> not need to adjust transaction fees (via replace-by-fee mechanisms)\n>> if the mempool grows.\n>\n>\n>Unlike other proposed fixes to the fee model, this is not trivially\n>broken by paying the miner out of band.  If you pay out of band fee\n>instead of regular fee, then your transaction cannot be included with\n>other regular fee paying transactions without the miner giving up all\n>regular fee income.  Any transaction paying less fee in-band than the\n>otherwise minimum fee rate needs to also provide ~1Mvbyte * fee rate\n>difference fee to make up for that lost income.  So out of band fee is\n>only realistically considered when it pays on top of a regular feerate\n>paying transaction that would have been included in the block anyway.\n>And what would be the point of that?\n>\n>\n>As an original contribution, I would like to note that something\n>strongly resembling this proposal could be soft-forked in very easily.\n>The shortest explanation is:\n>\n>    For scriptPubKey outputs of the form \"<max-42-byte-push>\", where\n>    the pushed data evaluates as true, a consensus rule is added that\n>    the coinbase must pay any fee in excess of the minimum fee rate\n>    for the block to the push value, which is a scriptPubKey.\n>\n>Beyond fixing the perceived problems of bitcoin's fee auction model\n>leading to costly strategic behavior (whether that is a problem is a\n>topic open to debate!), this would have the additional benefits of:\n>\n>    1. Allowing pre-signed transactions, of payment channel close-out\n>       for example, to provide sufficient fee for confirmation without\n>       knowledge of future rates or overpaying or trusting a wallet to\n>       be online to provide CPFP fee updates.\n>\n>    2. Allowing explicit fees in multi-party transaction creation\n>       protocols where final transaction sizes are not known prior to\n>       signing by one or more of the parties, while again not\n>       overpaying or trusting on CPFP, etc.\n>\n>    3. Allowing applications with expensive network access to pay\n>       reasonable fees for quick confirmation, without overpaying or\n>       querying a trusted fee estimator.  Blockstream Satellite helps\n>       here, but rebateable fees provides an alternative option when\n>       full block feeds are not available for whatever reason.\n>\n>Using a fee rebate would carry a marginal cost of 70-100 vbytes per\n>instance.  This makes it a rather expensive feature, and therefore in\n>my own estimation not something that is likely to be used by most\n>transactions today.  However the cost is less than CPFP, and so I\n>expect that it would be a heavily used feature in things like payment\n>channel refund and uncooperative close-out transactions.\n>\n>\n>Here is a more worked out proposal, suitable for critiquing:\n>\n>1. A transaction is allowed to specify an _Implicit Fee_, as usual, as\n>   well as one or more explicit _Rebateable Fees_.  A rebateable fee\n>   is an ouput with a scriptPubKey that consists of a single, minimal,\n>   nonzero push of up to 42 bytes.  Note that this is an always-true\n>   script that requires no signature to spend.\n>\n>2. The _Fee Rate_ of a transaction is a fractional number equal to the\n>   combined implicit and rebateable fee divided by the size/weight of\n>   the transaction.\n>\n>   (A nontrivial complication of this, which I will punt on for the\n>    moment, is how to group transactions for fee rate calculation such\n>    that CPFP doesn't bring down the minimum fee rate of the block,\n>    but to do so with rules that are both simple, because this is\n>    consensus code; and fair, so as to prevent unintended use of a\n>    rebate fee by children or siblings.)\n>\n>3. The smallest fee rate of any non-coinbase transaction (or\n>   transaction group) is the _Marginal Fee Rate_ for the block and is\n>   included in the witness for the block.\n>\n>4. The verifier checks that each transaction or transaction grouping\n>   provides a fee greater than or equal to the threshold fee rate, and\n>   at least one is exactly equal to the marginal rate (which proves\n>   the marginal rate is the minimum for the block).\n>\n>This establishes the marginal fee rate, which alternatively expressed\n>is epsilon less than the fee rate that would have been required to get\n>into the block, assuming there was sufficient space.\n>\n>5. A per-block _Dust Threshold_ is calculated using the marginal fee\n>   rate and reasonable assumptions about transaction size.\n>\n>6. For each transaction (or transaction group), the _Required Fee_ is\n>   calculated to be the marginal fee rate times the size/weight of the\n>   transaction.  Implicit fee is applied towards this required fee and\n>   added to the _Miner's Fee Tally_.  Any excess implicit fee\n>   remaining is added to the _Implicit Fee Tally_.\n>\n>7. For each transaction (group), the rebateable fees contribute\n>   proportionally towards towards meeting the remaining marginal fee\n>   requirement, if the implicit fee failed to do so.  Of what's left,\n>   one of two things can happen based on how much is remaining:\n>\n>     A. If greater than or equal to the dust threshold is remaining in\n>        a specific rebateable fee, a requirement is added that an\n>        output be provided in the coinbase paying the remaining fee to\n>        a scriptPubKey equal to the push value (see #1 above).\n>\n>        (With due consideration for what happens if a script is reused\n>         in multiple explicit fees, of course.)\n>\n>     B. Otherwise, add remaining dust to the implicit fee tally.\n>\n>8. For the very last transaction in the block, the miner builds a\n>   transaction claiming ALL of these explicit fees, and with a single\n>   zero-valued null/data output, thereby forwarding the fees on to the\n>   coinbase, as far as old clients are concerned.  This is only\n>   concerns consensus in that this final transaction does not change\n>   any of the previously mentioned tallies.\n>\n>   (Aside: the zero-valued output is merely required because all\n>    transactions must have at least one output. It does however make a\n>    great location to put commitments for extensions to the block\n>    header, as being on the right-most path of the Merkle tree can\n>    mean shorter proofs.)\n>\n>9. The miner is allowed to claim subsidy + the miner's fee tally + the\n>   explicit fee tally for themselves in the coinbase.  The coinbase is\n>   also required to contain all rebated fees above the dust threshold.\n>\n>In summary, all transactions have the same actual fee rate equal to\n>the minimum fee rate that went into the creation of the block, which\n>is basically the marginal fee rate for transaction inclusion.\n>\n>A variant of this proposal is that instead of giving the implicit fee\n>tally to the miner (the excess non-rebateable fees beyond the required\n>minimum), it is carried forward from block to block in the final\n>transaction and the miner is allowed to claim some average of past\n>fees, thereby smoothing out fees or providing some other incentive.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/8028683c/attachment.html>"
            },
            {
                "author": "Nathan Wilcox",
                "date": "2017-09-29T02:09:13",
                "message_text_only": "Happy to see Mark Friedenbach's strawman implementation. Two clarifying\nverifications:\n\nThis implementation would allow old-style implicit fees which would have\nthe same behavior (Pay-Your-Bid). Correct?\n\nIn terms of space costs, rebateable fee txns (or CPFP chains, I'm less\nclear on that complication) add one UTXO 'internally' and new consensus\nrules require one UTXO in the coinbase for the rebate, correct?\n\n\nAs for the paper itself: it doesn't account for high-latency/low-fee usage,\ncorrect? What if I want a transaction to complete anytime in the next N\ndays for as cheap as given some probability of success?\n\nThis has two parts: a. Is there a clear/clean game-theoretic-compatible UX\nfor users? b. would the implementation be simple enough? If either a is\n'no' or b is 'complicated', then the trade-off might not be much better\nthan the status quo.\n\nMaybe for a high enough latency, the answer to a is 'yes' and b. is\n'simple' by this strawman: try a tiny fee, if that doesn't work, try a new\nhigher fee and repeat. Is that good enough?\n\nregards.\nNathan\n\n\nOn Fri, Sep 29, 2017 at 10:53 AM, Matt Corallo via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I'm somewhat curious what the authors envisioned the real-world\n> implications of this model to be. While blindly asking users to enter what\n> they're willing to pay always works in theory, I'd imagine in such a world\n> the fee selection UX would be similar to what it is today - users are\n> provided a list of options with feerates and expected confirmation times\n> from which to select. Indeed, in a world where users pay a lower fee if\n> they paid more than necessary fee estimation could be more willing to\n> overshoot and the UX around RBF and CPFP could be simplified greatly, but\n> I'm not actually convinced that it would result in higher overall mining\n> revenue.\n>\n> The UX issues with RBF and CPFP, not to mention the UX issues involved in\n> optimizing for quick confirmation are, indeed, quite significant, but I\n> believe them to be solveable with rather striaght-forward changes. Making\n> the market more useable (for higher or lower overall miner revenue) may be\n> a sufficient goal, however, to want to consider something like this.\n>\n>\n> On September 28, 2017 9:06:29 PM EDT, Mark Friedenbach via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> This article by Ron Lavi, Or Sattath, and Aviv Zohar was forwarded to\n>> me and is of interest to this group:\n>>\n>>     \"Redesigning Bitcoin's fee market\"\n>>     https://arxiv.org/abs/1709.08881\n>>\n>> I'll briefly summarize before providing some commentary of my own,\n>> including transformation of the proposed mechanism into a relatively\n>> simple soft-fork.  The article points out that bitcoin's auction\n>> model for transaction fees / inclusion in a block is broken in the\n>> sense that it does not achieve maximum clearing price* and to prevent\n>> strategic bidding behavior.\n>>\n>> (* Maximum clearing price meaning highest fee the user is willing to\n>>    pay for the amount of time they had to wait.  In other words, miner\n>>    income.  While this is a common requirement of academic work on\n>>    auction protocols, it's not obvious that it provides intrinsic\n>>    benefit to bitcoin for miners to extract from users the maximum\n>>    amount of fee the market is willing to support.  However strategic\n>>    bidding behavior (e.g. RBF and CPFP) does have real network and\n>>    usability costs, which a more \"correct\" auction model would reduce\n>>    in some use cases.)\n>>\n>> Bitcoin is a \"pay your bid\" auction, where the user makes strategic\n>> calculations to determine what bid (=fee) is likely to get accepted\n>> within the window of time in which they want confirmation.  This bid\n>> can then be adjusted through some combination of RBF or CPFP.\n>>\n>> The authors suggest moving to a \"pay lowest winning bid\" model where\n>> all transactions pay only the smallest fee rate paid by any\n>> transaction in the block, for which the winning strategy is to bid the\n>> maximum amount you are willing to pay to get the transaction\n>> confirmed:\n>>\n>>  Users can then simply set their bids truthfully to exactly the\n>>>  amount they are willing to pay to transact, and do not need to\n>>>  utilize fee estimate mechanisms, do not resort to bid shading and do\n>>>  not need to adjust transaction fees (via replace-by-fee mechanisms)\n>>>  if the mempool grows.\n>>>\n>>\n>>\n>> Unlike other proposed fixes to the fee model, this is not trivially\n>> broken by paying the miner out of band.  If you pay out of band fee\n>> instead of regular fee, then your transaction cannot be included with\n>> other regular fee paying transactions without the miner giving up all\n>> regular fee income.  Any transaction paying less fee in-band than the\n>> otherwise minimum fee rate needs to also provide ~1Mvbyte * fee rate\n>> difference fee to make up for that lost income.  So out of band fee is\n>> only realistically considered when it pays on top of a regular feerate\n>> paying transaction that would have been included in the block anyway.\n>> And what would be the point of that?\n>>\n>>\n>> As an original contribution, I would like to note that something\n>> strongly resembling this proposal could be soft-forked in very easily.\n>> The shortest explanation is:\n>>\n>>     For scriptPubKey outputs of the form \"<max-42-byte-push>\", where\n>>     the pushed data evaluates as true, a consensus rule is added that\n>>     the coinbase must pay any fee in excess of the minimum fee rate\n>>     for the block to the push value, which is a scriptPubKey.\n>>\n>> Beyond fixing the perceived problems of bitcoin's fee auction model\n>> leading to costly strategic behavior (whether that is a problem is a\n>> topic open to debate!), this would have the additional benefits of:\n>>\n>>     1. Allowing pre-signed transactions, of payment channel close-out\n>>        for example, to provide sufficient fee for confirmation without\n>>        knowledge of future rates or overpaying or trusting a wallet to\n>>        be online to provide CPFP fee updates.\n>>\n>>     2. Allowing explicit fees in multi-party transaction creation\n>>        protocols where final transaction sizes are not known prior to\n>>        signing by one or more of the parties, while again not\n>>        overpaying or trusting on CPFP, etc.\n>>\n>>     3. Allowing applications with expensive network access to pay\n>>        reasonable fees for quick confirmation, without overpaying or\n>>        querying a trusted fee estimator.  Blockstream Satellite helps\n>>        here, but rebateable fees provides an alternative option when\n>>        full block feeds are not available for whatever reason.\n>>\n>> Using a fee rebate would carry a marginal cost of 70-100 vbytes per\n>> instance.  This makes it a rather expensive feature, and therefore in\n>> my own estimation not something that is likely to be used by most\n>> transactions today.  However the cost is less than CPFP, and so I\n>> expect that it would be a heavily used feature in things like payment\n>> channel refund and uncooperative close-out transactions.\n>>\n>>\n>> Here is a more worked out proposal, suitable for critiquing:\n>>\n>> 1. A transaction is allowed to specify an _Implicit Fee_, as usual, as\n>>    well as one or more explicit _Rebateable Fees_.  A rebateable fee\n>>    is an ouput with a scriptPubKey that consists of a single, minimal,\n>>    nonzero push of up to 42 bytes.  Note that this is an always-true\n>>    script that requires no signature to spend.\n>>\n>> 2. The _Fee Rate_ of a transaction is a fractional number equal to the\n>>    combined implicit and rebateable fee divided by the size/weight of\n>>    the transaction.\n>>\n>>    (A nontrivial complication of this, which I will punt on for the\n>>     moment, is how to group transactions for fee rate calculation such\n>>     that CPFP doesn't bring down the minimum fee rate of the block,\n>>     but to do so with rules that are both simple, because this is\n>>     consensus code; and fair, so as to prevent unintended use of a\n>>     rebate fee by children or siblings.)\n>>\n>> 3. The smallest fee rate of any non-coinbase transaction (or\n>>    transaction group) is the _Marginal Fee Rate_ for the block and is\n>>    included in the witness for the block.\n>>\n>> 4. The verifier checks that each transaction or transaction grouping\n>>    provides a fee greater than or equal to the threshold fee rate, and\n>>    at least one is exactly equal to the marginal rate (which proves\n>>    the marginal rate is the minimum for the block).\n>>\n>> This establishes the marginal fee rate, which alternatively expressed\n>> is epsilon less than the fee rate that would have been required to get\n>> into the block, assuming there was sufficient space.\n>>\n>> 5. A per-block _Dust Threshold_ is calculated using the marginal fee\n>>    rate and reasonable assumptions about transaction size.\n>>\n>> 6. For each transaction (or transaction group), the _Required Fee_ is\n>>    calculated to be the marginal fee rate times the size/weight of the\n>>    transaction.  Implicit fee is applied towards this required fee and\n>>    added to the _Miner's Fee Tally_.  Any excess implicit fee\n>>    remaining is added to the _Implicit Fee Tally_.\n>>\n>> 7. For each transaction (group), the rebateable fees contribute\n>>    proportionally towards towards meeting the remaining marginal fee\n>>    requirement, if the implicit fee failed to do so.  Of what's left,\n>>    one of two things can happen based on how much is remaining:\n>>\n>>      A. If greater than or equal to the dust threshold is remaining in\n>>         a specific rebateable fee, a requirement is added that an\n>>         output be provided in the coinbase paying the remaining fee to\n>>         a scriptPubKey equal to the push value (see #1 above).\n>>\n>>         (With due consideration for what happens if a script is reused\n>>          in multiple explicit fees, of course.)\n>>\n>>      B. Otherwise, add remaining dust to the implicit fee tally.\n>>\n>> 8. For the very last transaction in the block, the miner builds a\n>>    transaction claiming ALL of these explicit fees, and with a single\n>>    zero-valued null/data output, thereby forwarding the fees on to the\n>>    coinbase, as far as old clients are concerned.  This is only\n>>    concerns consensus in that this final transaction does not change\n>>    any of the previously mentioned tallies.\n>>\n>>    (Aside: the zero-valued output is merely required because all\n>>     transactions must have at least one output. It does however make a\n>>     great location to put commitments for extensions to the block\n>>     header, as being on the right-most path of the Merkle tree can\n>>     mean shorter proofs.)\n>>\n>> 9. The miner is allowed to claim subsidy + the miner's fee tally + the\n>>    explicit fee tally for themselves in the coinbase.  The coinbase is\n>>    also required to contain all rebated fees above the dust threshold.\n>>\n>> In summary, all transactions have the same actual fee rate equal to\n>> the minimum fee rate that went into the creation of the block, which\n>> is basically the marginal fee rate for transaction inclusion.\n>>\n>> A variant of this proposal is that instead of giving the implicit fee\n>> tally to the miner (the excess non-rebateable fees beyond the required\n>> minimum), it is carried forward from block to block in the final\n>> transaction and the miner is allowed to claim some average of past\n>> fees, thereby smoothing out fees or providing some other incentive.\n>>\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/c4b50f5d/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2017-09-29T02:10:33",
                "message_text_only": "On Fri, Sep 29, 2017 at 01:53:55AM +0000, Matt Corallo via bitcoin-dev wrote:\n> I'm somewhat curious what the authors envisioned the real-world implications of this model to be. While blindly asking users to enter what they're willing to pay always works in theory, I'd imagine in such a world the fee selection UX would be similar to what it is today - users are provided a list of options with feerates and expected confirmation times from which to select. Indeed, in a world where users pay a lower fee if they paid more than necessary fee estimation could be more willing to overshoot and the UX around RBF and CPFP could be simplified greatly, but I'm not actually convinced that it would result in higher overall mining revenue.\n\nNote too that the fee users are willing to pay often changes over time.\n\nMy OpenTimestamps service is a perfect example: getting a timestamp confirmed\nwithin 10 minutes of the previous one has little value to me, but if the\nprevious completed timestamp was 24 hours ago I'm willing to pay significantly\nmore money because the time delay is getting significant enough to affect the\ntrustworthyness of the entire service. So the fee selection mechanism is\nnothing more than a RBF-using loop that bumps the fee every time a block gets\nmined w/o confirming my latest transaction.\n\nThis kind of time sensitivity is probably true of a majority of Bitcoin\nuse-cases, with the caveat that often the slope will be negative eventually:\nafter a point in time completing the transaction has no value.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/054c801c/attachment.sig>"
            },
            {
                "author": "Nathan Wilcox",
                "date": "2017-09-29T02:17:05",
                "message_text_only": "On Fri, Sep 29, 2017 at 11:10 AM, Peter Todd via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Fri, Sep 29, 2017 at 01:53:55AM +0000, Matt Corallo via bitcoin-dev\n> wrote:\n> > I'm somewhat curious what the authors envisioned the real-world\n> implications of this model to be. While blindly asking users to enter what\n> they're willing to pay always works in theory, I'd imagine in such a world\n> the fee selection UX would be similar to what it is today - users are\n> provided a list of options with feerates and expected confirmation times\n> from which to select. Indeed, in a world where users pay a lower fee if\n> they paid more than necessary fee estimation could be more willing to\n> overshoot and the UX around RBF and CPFP could be simplified greatly, but\n> I'm not actually convinced that it would result in higher overall mining\n> revenue.\n>\n> Note too that the fee users are willing to pay often changes over time.\n>\n> My OpenTimestamps service is a perfect example: getting a timestamp\n> confirmed\n> within 10 minutes of the previous one has little value to me, but if the\n> previous completed timestamp was 24 hours ago I'm willing to pay\n> significantly\n> more money because the time delay is getting significant enough to affect\n> the\n> trustworthyness of the entire service. So the fee selection mechanism is\n> nothing more than a RBF-using loop that bumps the fee every time a block\n> gets\n> mined w/o confirming my latest transaction.\n>\n> This kind of time sensitivity is probably true of a majority of Bitcoin\n> use-cases, with the caveat that often the slope will be negative\n> eventually:\n> after a point in time completing the transaction has no value.\n>\n>\nWouldn't this RBF loop behave pretty much the same in the Monopolistic\nPrice Mechanism? (I haven't grokked RSOP yet.)\n\nIn fact, so long as RBF works, isn't it possible to raise Pay-Your-Bid fees\nand Monopolistic Price fees over time to express the time curve preference?\n\n\n\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/a7352e52/attachment.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-09-29T03:30:27",
                "message_text_only": "Only if your keys are online and the transaction is self-signed. It wouldn\u2019t let you pre-sign a transaction for a third party to broadcast and have it clear at just the market rate in the future. Like a payment channel refund, for example.\n\n> On Sep 28, 2017, at 7:17 PM, Nathan Wilcox via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \n> \n>> On Fri, Sep 29, 2017 at 11:10 AM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> On Fri, Sep 29, 2017 at 01:53:55AM +0000, Matt Corallo via bitcoin-dev wrote:\n>> > I'm somewhat curious what the authors envisioned the real-world implications of this model to be. While blindly asking users to enter what they're willing to pay always works in theory, I'd imagine in such a world the fee selection UX would be similar to what it is today - users are provided a list of options with feerates and expected confirmation times from which to select. Indeed, in a world where users pay a lower fee if they paid more than necessary fee estimation could be more willing to overshoot and the UX around RBF and CPFP could be simplified greatly, but I'm not actually convinced that it would result in higher overall mining revenue.\n>> \n>> Note too that the fee users are willing to pay often changes over time.\n>> \n>> My OpenTimestamps service is a perfect example: getting a timestamp confirmed\n>> within 10 minutes of the previous one has little value to me, but if the\n>> previous completed timestamp was 24 hours ago I'm willing to pay significantly\n>> more money because the time delay is getting significant enough to affect the\n>> trustworthyness of the entire service. So the fee selection mechanism is\n>> nothing more than a RBF-using loop that bumps the fee every time a block gets\n>> mined w/o confirming my latest transaction.\n>> \n>> This kind of time sensitivity is probably true of a majority of Bitcoin\n>> use-cases, with the caveat that often the slope will be negative eventually:\n>> after a point in time completing the transaction has no value.\n>> \n> \n> Wouldn't this RBF loop behave pretty much the same in the Monopolistic Price Mechanism? (I haven't grokked RSOP yet.)\n> \n> In fact, so long as RBF works, isn't it possible to raise Pay-Your-Bid fees and Monopolistic Price fees over time to express the time curve preference?\n> \n>  \n>> --\n>> https://petertodd.org 'peter'[:-1]@petertodd.org\n>> \n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/acc90653/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2017-09-29T02:02:27",
                "message_text_only": "On Thu, Sep 28, 2017 at 06:06:29PM -0700, Mark Friedenbach via bitcoin-dev wrote:\n> Unlike other proposed fixes to the fee model, this is not trivially\n> broken by paying the miner out of band.  If you pay out of band fee\n> instead of regular fee, then your transaction cannot be included with\n> other regular fee paying transactions without the miner giving up all\n> regular fee income.  Any transaction paying less fee in-band than the\n> otherwise minimum fee rate needs to also provide ~1Mvbyte * fee rate\n> difference fee to make up for that lost income.  So out of band fee is\n> only realistically considered when it pays on top of a regular feerate\n> paying transaction that would have been included in the block anyway.\n> And what would be the point of that?\n\nThis proposed fix is itself broken, because the miner can easily include *only*\ntransactions paying out-of-band, at which point the fee can be anything.\nEqually, miners can provide fee *rebates*, forcing up prices for everyone else\nwhile still allowing them to make deals.\n\nAlso, remember that you can pay fees via anyone-can-spend outputs, as miners\nhave full ability to control what transactions end up spending those outputs.\n\nThe fact these countermeasures are all likely to be implemented - all of which\nharm the overall ecosystem by reducing visibility of fees and making it harder\nto compete with centralized miners - makes me very dubious about that proposal.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/84259421/attachment.sig>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-09-29T02:45:02",
                "message_text_only": "> On Sep 28, 2017, at 7:02 PM, Peter Todd <pete at petertodd.org> wrote:\n> \n>> On Thu, Sep 28, 2017 at 06:06:29PM -0700, Mark Friedenbach via bitcoin-dev wrote:\n>> Unlike other proposed fixes to the fee model, this is not trivially\n>> broken by paying the miner out of band.  If you pay out of band fee\n>> instead of regular fee, then your transaction cannot be included with\n>> other regular fee paying transactions without the miner giving up all\n>> regular fee income.  Any transaction paying less fee in-band than the\n>> otherwise minimum fee rate needs to also provide ~1Mvbyte * fee rate\n>> difference fee to make up for that lost income.  So out of band fee is\n>> only realistically considered when it pays on top of a regular feerate\n>> paying transaction that would have been included in the block anyway.\n>> And what would be the point of that?\n> \n> This proposed fix is itself broken, because the miner can easily include *only*\n> transactions paying out-of-band, at which point the fee can be anything.\n\nAnd in doing so either reduce the claimable income from other transactions (miner won\u2019t do that), or require paying more non-rebateable fee than is needed to get in the block (why would the user do that?)\n\nThis is specifically addressed in the text you quoted. \n\n> Equally, miners can provide fee *rebates*, forcing up prices for everyone else\n> while still allowing them to make deals.\n\nDiscounted by the fact rebates would not be honored by other miners. The rebate would have to be higher than what they could get from straight fee collection, making it less profitable than doing nothing. \n\n> Also, remember that you can pay fees via anyone-can-spend outputs, as miners\n> have full ability to control what transactions end up spending those outputs.\n\nYou\u2019d still have to pay the minimum fee rate of the other transactions or you\u2019d bring down the miners income. Otherwise this is nearly the same cost as the rebate fee, since they both involve explicit outputs claimed by the miner, but the rebate goes back to you. So why would you not want to do that instead?\n\nA different way of looking at this proposal is that it creates a penalty for out of band payments."
            },
            {
                "author": "Anthony Towns",
                "date": "2017-09-29T04:45:56",
                "message_text_only": "On Thu, Sep 28, 2017 at 06:06:29PM -0700, Mark Friedenbach via bitcoin-dev wrote:\n> Unlike other proposed fixes to the fee model, this is not trivially\n> broken by paying the miner out of band.\n\nI think CPFP allows this to break: a miner getting paid out of band\nwould just make the block look like:\n\n    (1) 100kB of 5s/byte transactions\n    (2) 850kB of 35s/byte transactions\n    (3) 50kB of 95s/byte transactions, miner paying themselves\n\nAs long as every transaction in (1) has an output spent in (3), that seems\nlike it would be perfectly legitimate for CPFP. \n\nI think it would be cheaper overall than the fee refund transactions\nas well. People making arrangements with miners directly would have to\npay for block space to cover:\n\n   out:\n     30-40B dest address\n     30-40B change address\n     10B    cpfp link\n   in:\n     36B    cpfp txid\n\nthen to actual spend their change:\n\n   in:\n     36B+70B txid+idx + witness for change\n\nfor a total of 142-162B plus 70B witness, as well as some sort of out of\nband payment to the miner (paying fees directly to miners via a lightning\nchannel, comes to mind). \n\nIf I understand your suggestion correctly, it would look like:\n\n   coinbase:\n     30-40B fee overflow payment back to transactor\n\n   out:\n     30-40B dest address\n     30-40B change address\n     30-40B fee-overflow output marker\n\nand to spend their change:\n\n   in:\n     36B+70B txid+idx + witness for change\n     36B+70B txid+idx + witness for fee overflow\n\nfor a total of 192-232B plus 140B witness; so that's 40%-50% more block\nweight used. The fee overflow would probably be pretty small amounts,\nas well, so kind of annoying to actually collect.\n\nIf you end up with two change addresses per tx generally, that also seems\nlike it might it annoyingly easy to link your transactions together\n(unless fees end up getting coinjoined or run through satoshidice or\nsomething). If you end up sending lots of fee overflows to a single\naddress, that links your txes too of course.\n\n\nA miner might be willing to do that in order to charge a two-part tariff:\nie, a very high \"subscription\" fee that's paid once a year or similar,\nalong with very low per-tx fees. The only reason I can think of why\nsomeone would buy a subscription is if the miner's effectively a monopoly\nand submitting transactions via the p2p network isn't reliable enough;\nthe whole point of a two-part tariff is to be as expensive as each user\ncan bear, so it won't ever be any cheaper.\n\n\nFWIW, I think reliability-based-price-discrimination might allow higher\nmining revenue via having txes with differing fee rates in the same\nblock: eg if people are happy to pay 100s/byte for confirmation within\n30 minutes, and likewise willing to pay 10s/byte for confirmation within\n3 hours, and there aren't enough transactions of either type to hit the\nblock size limit, then a monopoly miner / mining cartel would do better\nby accepting 100s/byte txes at any time, while accepting 10s/byte txes\nin any given block, but only with about a 1-in-7 chance for any given tx.\n\nLooking at estimatefee.com, there's currently apparently ~200kB of 82s/B\nor more transactions, while to fill a 1MB block you'd have to go all the\nway down to 2.1s/B -- so if you have to charge all txes at the marginal\nfee rate, that's 200kB at 82s/B for 0.16 BTC rather than 1MB at 2.1s/B\nfor 0.021 BTC.\n\n\nI think ideally, it would probably be better to let the block weight\nlimit adjust to deal with high-frequency components to changes in demand,\nand have fee rates adjust more slowly to address the long-term trends\nin changes to demand: if fee rates only adjust slowly, then they're\n(by definition) easily predictable and you don't *have* to have much\nconcern about getting them wrong. (You'd still need to add the correct\nfee at the time you want to publish a pre-signed transaction that was\nvery old, but CPFP isn't too bad at that).\n\nCheers,\naj"
            },
            {
                "author": "Peter Todd",
                "date": "2017-09-29T03:02:25",
                "message_text_only": "On Thu, Sep 28, 2017 at 07:45:02PM -0700, Mark Friedenbach wrote:\n> \n> \n> > On Sep 28, 2017, at 7:02 PM, Peter Todd <pete at petertodd.org> wrote:\n> > \n> >> On Thu, Sep 28, 2017 at 06:06:29PM -0700, Mark Friedenbach via bitcoin-dev wrote:\n> >> Unlike other proposed fixes to the fee model, this is not trivially\n> >> broken by paying the miner out of band.  If you pay out of band fee\n> >> instead of regular fee, then your transaction cannot be included with\n> >> other regular fee paying transactions without the miner giving up all\n> >> regular fee income.  Any transaction paying less fee in-band than the\n> >> otherwise minimum fee rate needs to also provide ~1Mvbyte * fee rate\n> >> difference fee to make up for that lost income.  So out of band fee is\n> >> only realistically considered when it pays on top of a regular feerate\n> >> paying transaction that would have been included in the block anyway.\n> >> And what would be the point of that?\n> > \n> > This proposed fix is itself broken, because the miner can easily include *only*\n> > transactions paying out-of-band, at which point the fee can be anything.\n> \n> And in doing so either reduce the claimable income from other transactions (miner won\u2019t do that), or require paying more non-rebateable fee than is needed to get in the block (why would the user do that?)\n> \n> This is specifically addressed in the text you quoted. \n\nI specifically outlined a scenario where that text isn't relevant: *all*\ntransaction in a block can be paying out of band.\n\n> > Equally, miners can provide fee *rebates*, forcing up prices for everyone else\n> > while still allowing them to make deals.\n> \n> Discounted by the fact rebates would not be honored by other miners. The rebate would have to be higher than what they could get from straight fee collection, making it less profitable than doing nothing. \n\nYou're making the incorrect assumption that all transactions have to be\nbroadcast publicly; they don't.\n\n> > Also, remember that you can pay fees via anyone-can-spend outputs, as miners\n> > have full ability to control what transactions end up spending those outputs.\n> \n> You\u2019d still have to pay the minimum fee rate of the other transactions or you\u2019d bring down the miners income. Otherwise this is nearly the same cost as the rebate fee, since they both involve explicit outputs claimed by the miner, but the rebate goes back to you. So why would you not want to do that instead?\n> \n> A different way of looking at this proposal is that it creates a penalty for out of band payments. \n\nIt certainly does not. It simply adds another level of complexity and overhead\nto the out-of-band payment situation, which is not desirable. If we can't\neliminate out of band payments entirely, we do not want to make the playing\nfield of them even more unbalanced than it already is.\n\nThis is a typical academic proposal that only considers first order effects\nwhile ignoring second order effects.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/830d78cd/attachment.sig>"
            },
            {
                "author": "Daniele Pinna",
                "date": "2017-09-29T10:43:22",
                "message_text_only": "Maybe I'm getting this wrong but wouldn't this scheme imply that a miner is\nincentivized to limit the amount of transactions in a block to capture the\nmaximum fee of the ones included?\n\nAs an example, mined blocks currently carry ~0.8 btc in fees right now. If\nI were to submit a transaction paying 1 btc in maximal money fees, then the\nminer would be incentivized to include my transaction alone to avoid that\nlower fee paying transactions reduce the amount of fees he can earn from my\ntransaction alone. This would mean that I could literally clog the network\nby paying 1btc every ten minutes.\n\nAm I missing something?\n\nDaniele\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/5ecfcff9/attachment.html>"
            },
            {
                "author": "Alex Morcos",
                "date": "2017-09-29T12:50:20",
                "message_text_only": "I had the same concern, or a miner could fill the remainder of the block\nwith their own high fee paying transactions if blocks were required to be\nfull.\n\nOn Fri, Sep 29, 2017 at 7:55 AM Daniele Pinna via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Maybe I'm getting this wrong but wouldn't this scheme imply that a miner\n> is incentivized to limit the amount of transactions in a block to capture\n> the maximum fee of the ones included?\n>\n> As an example, mined blocks currently carry ~0.8 btc in fees right now. If\n> I were to submit a transaction paying 1 btc in maximal money fees, then the\n> miner would be incentivized to include my transaction alone to avoid that\n> lower fee paying transactions reduce the amount of fees he can earn from my\n> transaction alone. This would mean that I could literally clog the network\n> by paying 1btc every ten minutes.\n>\n> Am I missing something?\n>\n> Daniele\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/7873796c/attachment.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-09-29T15:22:14",
                "message_text_only": "This is correct. Under assumptions of a continuous mempool model however this should be considered the outlier behavior, other than a little bit of empty space at the end, now and then. A maximum fee rate calculated as a filter over past block rates could constrain this outlier behavior from ever happening too.\n\n> On Sep 29, 2017, at 3:43 AM, Daniele Pinna <daniele.pinna at gmail.com> wrote:\n> \n> Maybe I'm getting this wrong but wouldn't this scheme imply that a miner is incentivized to limit the amount of transactions in a block to capture the maximum fee of the ones included?\n> \n> As an example, mined blocks currently carry ~0.8 btc in fees right now. If I were to submit a transaction paying 1 btc in maximal money fees, then the miner would be incentivized to include my transaction alone to avoid that lower fee paying transactions reduce the amount of fees he can earn from my transaction alone. This would mean that I could literally clog the network by paying 1btc every ten minutes.\n> \n> Am I missing something?\n> \n> Daniele"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2017-09-30T03:53:00",
                "message_text_only": "I really don't see how this \"outlier behaviour\" can be prevented. I think\nit would be the norm even with your proposed \"fix\". Perhaps I'm missing\nsomething too.\n\nOn 29 Sep 2017 5:24 pm, \"Mark Friedenbach via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> This is correct. Under assumptions of a continuous mempool model however\n> this should be considered the outlier behavior, other than a little bit of\n> empty space at the end, now and then. A maximum fee rate calculated as a\n> filter over past block rates could constrain this outlier behavior from\n> ever happening too.\n>\n> > On Sep 29, 2017, at 3:43 AM, Daniele Pinna <daniele.pinna at gmail.com>\n> wrote:\n> >\n> > Maybe I'm getting this wrong but wouldn't this scheme imply that a miner\n> is incentivized to limit the amount of transactions in a block to capture\n> the maximum fee of the ones included?\n> >\n> > As an example, mined blocks currently carry ~0.8 btc in fees right now.\n> If I were to submit a transaction paying 1 btc in maximal money fees, then\n> the miner would be incentivized to include my transaction alone to avoid\n> that lower fee paying transactions reduce the amount of fees he can earn\n> from my transaction alone. This would mean that I could literally clog the\n> network by paying 1btc every ten minutes.\n> >\n> > Am I missing something?\n> >\n> > Daniele\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170930/809576bf/attachment.html>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2017-09-30T03:55:58",
                "message_text_only": "Gmaxwell I think what's new is that in this case, with a single tx you\nwould take out all txs with fee below 1 btc. With current rules, you would\nonly remove enoguh txs for that one to fit, not empty the whole block and\nmine only a block with that single tx.\n\nOn 30 Sep 2017 5:53 am, \"Jorge Tim\u00f3n\" <jtimon at jtimon.cc> wrote:\n\n> I really don't see how this \"outlier behaviour\" can be prevented. I think\n> it would be the norm even with your proposed \"fix\". Perhaps I'm missing\n> something too.\n>\n> On 29 Sep 2017 5:24 pm, \"Mark Friedenbach via bitcoin-dev\" <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> This is correct. Under assumptions of a continuous mempool model however\n>> this should be considered the outlier behavior, other than a little bit of\n>> empty space at the end, now and then. A maximum fee rate calculated as a\n>> filter over past block rates could constrain this outlier behavior from\n>> ever happening too.\n>>\n>> > On Sep 29, 2017, at 3:43 AM, Daniele Pinna <daniele.pinna at gmail.com>\n>> wrote:\n>> >\n>> > Maybe I'm getting this wrong but wouldn't this scheme imply that a\n>> miner is incentivized to limit the amount of transactions in a block to\n>> capture the maximum fee of the ones included?\n>> >\n>> > As an example, mined blocks currently carry ~0.8 btc in fees right now.\n>> If I were to submit a transaction paying 1 btc in maximal money fees, then\n>> the miner would be incentivized to include my transaction alone to avoid\n>> that lower fee paying transactions reduce the amount of fees he can earn\n>> from my transaction alone. This would mean that I could literally clog the\n>> network by paying 1btc every ten minutes.\n>> >\n>> > Am I missing something?\n>> >\n>> > Daniele\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170930/23101914/attachment-0001.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2017-09-30T08:54:57",
                "message_text_only": "On Sat, Sep 30, 2017 at 3:55 AM, Jorge Tim\u00f3n via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Gmaxwell I think what's new is that in this case, with a single tx you would\n> take out all txs with fee below 1 btc. With current rules, you would only\n> remove enoguh txs for that one to fit, not empty the whole block and mine\n> only a block with that single tx.\n\nI think this is not relevant: By paying the same amount you can delay\nthe same transactions today.\n\nThe difference is that your 'attack' wastes less capacity-- it can be\na simple 150 weight txn rather than a collection that add up to almost\n4 million weight; but it costs exactly the same.  To the extent that\nthis difference matters at all, I think it's an improvement.\n\nThe only argument that I see for it not being one is that it's easier\nto do accidentally.  But part of the purpose of this alternative\nmarket is to achieve an equilibrium other than the ultrabloating one;\nso yes, you're going to find outcomes where the blocks are not\nmaximally full.\n\nI wonder how the economics would respond if there is a PI controller\non the maximum size, so that 'lost space' in single blocks with bogon\nfee transactions could be recovered if doing so didn't change the\nmedium timescale total. I think the paper's analysis assumes there is\nno limit, but that is impractical for technical reasons (e.g. making\nit impossible to budget communications and storage capacity for\nnodes...)."
            },
            {
                "author": "Gregory Maxwell",
                "date": "2017-09-30T00:47:54",
                "message_text_only": "On Fri, Sep 29, 2017 at 10:43 AM, Daniele Pinna via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> As an example, mined blocks currently carry ~0.8 btc in fees right now. If I\n> were to submit a transaction paying 1 btc in maximal money fees, then the\n> miner would be incentivized to include my transaction alone to avoid that\n> lower fee paying transactions reduce the amount of fees he can earn from my\n> transaction alone. This would mean that I could literally clog the network\n> by paying 1btc every ten minutes.\n\nIf I'm not mistaken that is is nothing new or interesting: You can\ndelay some transaction by paying more than it offered by every block\nyou delay it from. E.g. if the next full block would pay 0.8 BTC in\nfees, you just need to make transactions paying more than that. But\nyou'll pay it for each delay and the people you push out only pay once\n(when they are successful), so it gets awfully expensive fast.\n\n(Arguably the monopoly price model is better because outbidding party\ndoesn't need to bloat the chain to do their thing; arguable its\nsomewhat worse because its harder to do by accident.)\n\nMy thought on this was the same as PT's initial: miners and users can\narrange OOB payments (and/or coinjoin rebates) and bypass this. I\ndon't see why it wouldn't be in their individual best interest to do\nso, and if they do that would likely be a centralizing effect."
            }
        ],
        "thread_summary": {
            "title": "Rebatable fees & incentive-safe fee markets",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Peter Todd",
                "Daniele Pinna",
                "Nathan Wilcox",
                "Jorge Tim\u00f3n",
                "Alex Morcos",
                "Gregory Maxwell",
                "Matt Corallo",
                "Mark Friedenbach"
            ],
            "messages_count": 17,
            "total_messages_chars_count": 59232
        }
    },
    {
        "title": "[bitcoin-dev] Paper Wallet support in bitcoin-core",
        "thread_messages": [
            {
                "author": "Dan Libby",
                "date": "2017-09-29T17:29:17",
                "message_text_only": "Hi,\n\nI'm writing to suggest and discuss the addition of paper wallet\nfunctionality in bitcoin-core software, starting with a single new RPC\ncall: genExternalAddress [type].\n\n-- rationale --\n\nbitcoin-core is the most trusted and most secure bitcoin implementation.\n\nYet today (unless I've missed something) paper wallet generation\nrequires use of third party software, or even a website such as\nbitaddress.org.  This requires placing trust in an additional body of\ncode from a less-trusted and less peer-reviewed source.  Ideally, one\nwould personally audit this code for one's self, but in practice that\nrarely happens.\n\nIn the case of a website generator, the code must be audited again each\ntime it is downloaded.  I cannot in good faith recommend to anyone to\nuse such third party tools for wallet generation.\n\nI *would* recommend for others to trust a paper wallet that uses\naddress(es) generated by bitcoin-core itself.\n\nAt least for me, this requirement to audit (or implicitly trust) a\nsecondary body of bitcoin code places an additional hurdle or\ndisincentive on the use of paper wallets, or indeed private keys\ngenerated outside of bitcoin-core for any purpose.\n\nUnfortunately, one cannot simply use getnewaddress, getaccountaddress,\nor getrawchangeaddress for this purpose, because the associated private\nkeys are added to the bitcoin-core wallet and cannot be removed... or in\nthe case of hd-wallets are deterministically derived.\n\nAs such, I'm throwing out the following half-baked proposal as a\nstarting point for discussion:\n\n\n-----\n\n    genexternaladdress ( \"type\" )\n\n    Returns a new Bitcoin address and private key for receiving\n    payments. This key/address is intended for external usage such as\n    paper wallets and will not be used by internal wallet nor written to\n    disk.\n\n    Arguments:\n    1. \"type\"        (string, optional) one of: p2pkh, p2sh-p2wpkh\n                                        default: p2sh-p2wpkh\n\n    Result:\n    {\n        \"privKey\"    (string) The private key in wif format.\n        \"address\"    (string) The address in p2pkh or p2sh-p2wpkh\n                              format.\n    }\n\n\n    Examples:\n    > bitcoin-cli genexternaladdress\n\n\n----\n\nThis API is simple to implement and use.  It provides enough\nfunctionality for any moderately skilled developer to create their own\npaper wallet creation script using any scripting language, or even for\nadvanced users to perform using bitcoin-cli or debug console.\n\nIf consensus here is in favor of including such an API, I will be happy\nto take a crack at implementing it and submitting a pull request.\n\nIf anyone has reasons why it is a BAD IDEA to include such an RPC call\nin bitcoind, I'm curious to hear it.\n\nAlso, I welcome suggestions for a better name, or maybe there could be\nsome improvements to the param(s), such as calling p2sh-p2wpkh \"segwit\"\ninstead.\n\n\n---- further work ----\n\n\nFurther steps could be taken in this direction, but are not necessary\nfor a useful first-step.  In particular:\n\n1. an RPC call to generate an external HD wallet seed.\n2. an RPC call to generate N key/address pairs from a given seed.\n3. GUI functionality in bitcoin-qt to facilitate easy paper wallet\ngeneration (and printing?) for end-users, complete with nice graphics,\nqr codes, etc."
            },
            {
                "author": "Andrew Johnson",
                "date": "2017-09-29T18:07:26",
                "message_text_only": "One consideration of exposing this in QT is that it may encourage users to\ngenerate paper wallets(which are generally used and recommended for cold\nstorage) from online machines, rendering them moreso lukewarm rather than\ncold, since the keys weren't generated in an air-gapped environment.  When\nusing bitaddress.org locally(we *are *all only using it locally and not\ndirectly from the online webpage, right? ;) ) you've at least made the\neffort to seek out the repo, clone it locally, and use it on an offline\nmachine and not retain any data from that session.\n\nIf we include this as a function in the reference implementation, how many\npeople are going to be making paper wallets with the intention of cold\nstorage on a machine that's potentially compromised?  As\nadoption(hopefully) continues to increase the number of less than tech\nsavvy people using bitcoin will increase.\n\nI'd suggest that any UI in QT include some sort of a modal dialog that\ninforms the user that this is not a secure cold storage address unless it\nwas created on an offline machine and printed on a non-networked printer,\nand the prompt must be accepted and dismissed before the wallet will\nprovide the requested keys.\n\n\nOn Fri, Sep 29, 2017 at 12:29 PM, Dan Libby via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi,\n>\n> I'm writing to suggest and discuss the addition of paper wallet\n> functionality in bitcoin-core software, starting with a single new RPC\n> call: genExternalAddress [type].\n>\n> -- rationale --\n>\n> bitcoin-core is the most trusted and most secure bitcoin implementation.\n>\n> Yet today (unless I've missed something) paper wallet generation\n> requires use of third party software, or even a website such as\n> bitaddress.org.  This requires placing trust in an additional body of\n> code from a less-trusted and less peer-reviewed source.  Ideally, one\n> would personally audit this code for one's self, but in practice that\n> rarely happens.\n>\n> In the case of a website generator, the code must be audited again each\n> time it is downloaded.  I cannot in good faith recommend to anyone to\n> use such third party tools for wallet generation.\n>\n> I *would* recommend for others to trust a paper wallet that uses\n> address(es) generated by bitcoin-core itself.\n>\n> At least for me, this requirement to audit (or implicitly trust) a\n> secondary body of bitcoin code places an additional hurdle or\n> disincentive on the use of paper wallets, or indeed private keys\n> generated outside of bitcoin-core for any purpose.\n>\n> Unfortunately, one cannot simply use getnewaddress, getaccountaddress,\n> or getrawchangeaddress for this purpose, because the associated private\n> keys are added to the bitcoin-core wallet and cannot be removed... or in\n> the case of hd-wallets are deterministically derived.\n>\n> As such, I'm throwing out the following half-baked proposal as a\n> starting point for discussion:\n>\n>\n> -----\n>\n>     genexternaladdress ( \"type\" )\n>\n>     Returns a new Bitcoin address and private key for receiving\n>     payments. This key/address is intended for external usage such as\n>     paper wallets and will not be used by internal wallet nor written to\n>     disk.\n>\n>     Arguments:\n>     1. \"type\"        (string, optional) one of: p2pkh, p2sh-p2wpkh\n>                                         default: p2sh-p2wpkh\n>\n>     Result:\n>     {\n>         \"privKey\"    (string) The private key in wif format.\n>         \"address\"    (string) The address in p2pkh or p2sh-p2wpkh\n>                               format.\n>     }\n>\n>\n>     Examples:\n>     > bitcoin-cli genexternaladdress\n>\n>\n> ----\n>\n> This API is simple to implement and use.  It provides enough\n> functionality for any moderately skilled developer to create their own\n> paper wallet creation script using any scripting language, or even for\n> advanced users to perform using bitcoin-cli or debug console.\n>\n> If consensus here is in favor of including such an API, I will be happy\n> to take a crack at implementing it and submitting a pull request.\n>\n> If anyone has reasons why it is a BAD IDEA to include such an RPC call\n> in bitcoind, I'm curious to hear it.\n>\n> Also, I welcome suggestions for a better name, or maybe there could be\n> some improvements to the param(s), such as calling p2sh-p2wpkh \"segwit\"\n> instead.\n>\n>\n> ---- further work ----\n>\n>\n> Further steps could be taken in this direction, but are not necessary\n> for a useful first-step.  In particular:\n>\n> 1. an RPC call to generate an external HD wallet seed.\n> 2. an RPC call to generate N key/address pairs from a given seed.\n> 3. GUI functionality in bitcoin-qt to facilitate easy paper wallet\n> generation (and printing?) for end-users, complete with nice graphics,\n> qr codes, etc.\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n\n-- \nAndrew Johnson\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/07c1fa76/attachment.html>"
            },
            {
                "author": "Dan Libby",
                "date": "2017-09-29T19:34:57",
                "message_text_only": "On 09/29/2017 11:07 AM, Andrew Johnson wrote:\n> One consideration of exposing this in QT is that it may encourage users\n> to generate paper wallets(which are generally used and recommended for\n> cold storage) from online machines, rendering them moreso lukewarm\n> rather than cold, since the keys weren't generated in an air-gapped\n> environment.\u00a0 \n\ntrue that.  Though there's nothing stopping a diligent person from\ninstalling bitcoin-core on a dedicated offline machine.  The blockchain\nwouldn't need to be synced at all for key generation purposes.\n\n> When using bitaddress.org <http://bitaddress.org>\n> locally(we\u00a0/are /all only\u00a0using it locally and not directly from the\n> online webpage, right? ;) )\u00a0you've at least made the effort to seek out\n> the repo, clone it locally, and use it on an offline machine and not\n> retain any data from that session.\n\nyeah, so I noticed this issue about Paper Wallet generation not being\npossible with bitcoin-core exactly because I was recommending to a\nnon-technical user to use paper wallets, but then I also had to point\nout that really bitaddress code should be downloaded, audited, etc,\nbefore use.  Things that are actually impossible for a non-technical user.\n\nSo I figured that instead I would make a simple script for them that\nwould use bitcoin-core to generate the addresses... and that's when it\ndawned on me that it won't actually work with present day RPCs that are\nall tied to internal wallet.\n\nhence, this proposal.\n\n> I'd suggest that any UI in QT include some sort of a modal dialog that\n> informs the user that this is not a secure cold storage address unless\n> it was created on an offline machine and printed on a non-networked\n> printer, and the prompt must be accepted and dismissed before the wallet\n> will provide the requested keys.\n\nyes, agreed."
            },
            {
                "author": "Sjors Provoost",
                "date": "2017-09-29T20:21:48",
                "message_text_only": "A 12-24 word BIP39 mnemonic is easy to write down and has the benefit of not needing to trust a printer.\n\nHowever without also supporting BIP43/44/49 this would probably cause confusion. Supporting these would be a larger project as well. Although widely used, the standards are still Proposed / Draft. There's  might be room for improvement [0].\n\nSjors\n\n[0] https://github.com/satoshilabs/slips/issues/103\n\n> Op 29 sep. 2017, om 20:07 heeft Andrew Johnson via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:\n> \n> One consideration of exposing this in QT is that it may encourage users to generate paper wallets(which are generally used and recommended for cold storage) from online machines, rendering them moreso lukewarm rather than cold, since the keys weren't generated in an air-gapped environment.  When using bitaddress.org <http://bitaddress.org/> locally(we are all only using it locally and not directly from the online webpage, right? ;) ) you've at least made the effort to seek out the repo, clone it locally, and use it on an offline machine and not retain any data from that session.\n> \n> If we include this as a function in the reference implementation, how many people are going to be making paper wallets with the intention of cold storage on a machine that's potentially compromised?  As adoption(hopefully) continues to increase the number of less than tech savvy people using bitcoin will increase.\n> \n> I'd suggest that any UI in QT include some sort of a modal dialog that informs the user that this is not a secure cold storage address unless it was created on an offline machine and printed on a non-networked printer, and the prompt must be accepted and dismissed before the wallet will provide the requested keys.\n> \n> \n> On Fri, Sep 29, 2017 at 12:29 PM, Dan Libby via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> Hi,\n> \n> I'm writing to suggest and discuss the addition of paper wallet\n> functionality in bitcoin-core software, starting with a single new RPC\n> call: genExternalAddress [type].\n> \n> -- rationale --\n> \n> bitcoin-core is the most trusted and most secure bitcoin implementation.\n> \n> Yet today (unless I've missed something) paper wallet generation\n> requires use of third party software, or even a website such as\n> bitaddress.org <http://bitaddress.org/>.  This requires placing trust in an additional body of\n> code from a less-trusted and less peer-reviewed source.  Ideally, one\n> would personally audit this code for one's self, but in practice that\n> rarely happens.\n> \n> In the case of a website generator, the code must be audited again each\n> time it is downloaded.  I cannot in good faith recommend to anyone to\n> use such third party tools for wallet generation.\n> \n> I *would* recommend for others to trust a paper wallet that uses\n> address(es) generated by bitcoin-core itself.\n> \n> At least for me, this requirement to audit (or implicitly trust) a\n> secondary body of bitcoin code places an additional hurdle or\n> disincentive on the use of paper wallets, or indeed private keys\n> generated outside of bitcoin-core for any purpose.\n> \n> Unfortunately, one cannot simply use getnewaddress, getaccountaddress,\n> or getrawchangeaddress for this purpose, because the associated private\n> keys are added to the bitcoin-core wallet and cannot be removed... or in\n> the case of hd-wallets are deterministically derived.\n> \n> As such, I'm throwing out the following half-baked proposal as a\n> starting point for discussion:\n> \n> \n> -----\n> \n>     genexternaladdress ( \"type\" )\n> \n>     Returns a new Bitcoin address and private key for receiving\n>     payments. This key/address is intended for external usage such as\n>     paper wallets and will not be used by internal wallet nor written to\n>     disk.\n> \n>     Arguments:\n>     1. \"type\"        (string, optional) one of: p2pkh, p2sh-p2wpkh\n>                                         default: p2sh-p2wpkh\n> \n>     Result:\n>     {\n>         \"privKey\"    (string) The private key in wif format.\n>         \"address\"    (string) The address in p2pkh or p2sh-p2wpkh\n>                               format.\n>     }\n> \n> \n>     Examples:\n>     > bitcoin-cli genexternaladdress\n> \n> \n> ----\n> \n> This API is simple to implement and use.  It provides enough\n> functionality for any moderately skilled developer to create their own\n> paper wallet creation script using any scripting language, or even for\n> advanced users to perform using bitcoin-cli or debug console.\n> \n> If consensus here is in favor of including such an API, I will be happy\n> to take a crack at implementing it and submitting a pull request.\n> \n> If anyone has reasons why it is a BAD IDEA to include such an RPC call\n> in bitcoind, I'm curious to hear it.\n> \n> Also, I welcome suggestions for a better name, or maybe there could be\n> some improvements to the param(s), such as calling p2sh-p2wpkh \"segwit\"\n> instead.\n> \n> \n> ---- further work ----\n> \n> \n> Further steps could be taken in this direction, but are not necessary\n> for a useful first-step.  In particular:\n> \n> 1. an RPC call to generate an external HD wallet seed.\n> 2. an RPC call to generate N key/address pairs from a given seed.\n> 3. GUI functionality in bitcoin-qt to facilitate easy paper wallet\n> generation (and printing?) for end-users, complete with nice graphics,\n> qr codes, etc.\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/3a74a284/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/3a74a284/attachment-0001.sig>"
            },
            {
                "author": "Dan Libby",
                "date": "2017-09-29T20:13:59",
                "message_text_only": "One additional thought:\n\nIt should be useful to also define a multi-sig generation RPC.\n\nThis would facilitate multi-sig paper wallets stored in different\nphysical locations, amongst other use-cases.\n\nSomething like:\n\n-----\n\n    genexternalmultisigaddress ( \"m\", \"n\", \"type\" )\n\n    Returns a new Bitcoin address and n number of private key(s).\n    This address and associated keys is intended for external usage such\n    as paper wallets and will not be used by internal wallet nor written\n    to disk.\n\n    Arguments:\n    1. \"m\"           (integer, required) The number of required signers\n                                         to send funds.\n    2. \"n\"           (integer, required) The number of authorized\n                                         signers\n    3. \"type\"        (string, optional)  one of: p2sh-p2pkh, p2sh-p2wpkh\n                                         default: p2sh-p2wpkh\n\n    Result:\n    {\n        \"address\",   (string) The address in p2pkh or p2sh-p2wpkh\n                              format.\n        \"privkeys\": [\n            (string) The private key in wif format.\n        ]\n    }\n\n\n    Examples:\n    > bitcoin-cli genexternalmultisigaddress 2 3\n\n-----\n\n\n\nOn 09/29/2017 10:29 AM, Dan Libby via bitcoin-dev wrote:\n> Hi,\n> \n> I'm writing to suggest and discuss the addition of paper wallet\n> functionality in bitcoin-core software, starting with a single new RPC\n> call: genExternalAddress [type].\n> \n> -- rationale --\n> \n> bitcoin-core is the most trusted and most secure bitcoin implementation.\n> \n> Yet today (unless I've missed something) paper wallet generation\n> requires use of third party software, or even a website such as\n> bitaddress.org.  This requires placing trust in an additional body of\n> code from a less-trusted and less peer-reviewed source.  Ideally, one\n> would personally audit this code for one's self, but in practice that\n> rarely happens.\n> \n> In the case of a website generator, the code must be audited again each\n> time it is downloaded.  I cannot in good faith recommend to anyone to\n> use such third party tools for wallet generation.\n> \n> I *would* recommend for others to trust a paper wallet that uses\n> address(es) generated by bitcoin-core itself.\n> \n> At least for me, this requirement to audit (or implicitly trust) a\n> secondary body of bitcoin code places an additional hurdle or\n> disincentive on the use of paper wallets, or indeed private keys\n> generated outside of bitcoin-core for any purpose.\n> \n> Unfortunately, one cannot simply use getnewaddress, getaccountaddress,\n> or getrawchangeaddress for this purpose, because the associated private\n> keys are added to the bitcoin-core wallet and cannot be removed... or in\n> the case of hd-wallets are deterministically derived."
            },
            {
                "author": "Jonas Schnelli",
                "date": "2017-09-30T04:49:52",
                "message_text_only": "> Hi,\n> \n> I'm writing to suggest and discuss the addition of paper wallet\n> functionality in bitcoin-core software, starting with a single new RPC\n> call: genExternalAddress [type].\n> \n\nAFAIK, client implementations such as your proposal are off-topic for this ML.\nBetter use bitcoin-core-dev (ML or IRC) or Github (bitcoin/bitcoin) for such proposals.\n\n\n> On 09/29/2017 02:03 PM, Luke Dashjr wrote:\n> Paper wallets are a safety hazard, insecure, and generally not advisable.\n> \n\nI have to agree with Luke.\nAnd I would also extend those concerns to BIP39 plaintext paper backups.\n\nIMO, private keys should be generated and used (signing) on a trusted, minimal and offline hardware/os. They should never leave the device over the channel used for the signing I/O. Users should have no way to view or export the private keys (expect for the seed backup). Backups should be encrypted (whoever finds the paper backup should need a second factor to decrypt) and the restore process should be footgun-safe (especially the lost-passphrase deadlock).\n\n\n/jonas\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/4a7078c9/attachment.sig>"
            },
            {
                "author": "Dan Libby",
                "date": "2017-09-30T07:06:42",
                "message_text_only": "On 09/29/2017 09:49 PM, Jonas Schnelli wrote:\n\n> AFAIK, client implementations such as your proposal are off-topic for this ML.\n> Better use bitcoin-core-dev (ML or IRC) or Github (bitcoin/bitcoin) for such proposals.\n\nok, thanks.  I will take the proposal there.\n\n> I have to agree with Luke.\n\nthanks for your feedback.\n\n> And I would also extend those concerns to BIP39 plaintext paper backups.\n> \n> IMO, private keys should be generated and used (signing) on a trusted, minimal and offline hardware/os.\n\nuhh.... do you apply this logic to the bitcoin-core wallet itself?\nbecause clearly it generates keys and is intended to be used for signing\nin online environments.  Lots of real-world use-cases depend on that today.\n\nSo if existing bitcoin-core wallet behavior is \"ok\" in any context then\nhow is it any worse for it to generate a key/address that will not be\nstored in the internal wallet, and the user may do with it as they wish?\n That is all my proposed RPC call does and unlike the existing RPC calls\nit never even stores the key or address to disk.  It is also useful when\nrun on an offline hardware device, such as a laptop connected to an\nnon-networked printer.\n\nFurther, you mention the word trust.  That's the crux of the matter.  As\na full node operator, I've already placed my trust in the bitcoin-core\ndevelopers and dev/release practices.  Why exactly should I trust the\nsoftware in this minimal offline hardware/os you mention if it is NOT\nbitcoin core?  And even if open source software, does that not at least\ndouble my workload/expense to audit theat software in addition to\nbitcoin-core?\n\n> Users should have no way to view or export the private keys (expect for \n> the seed backup).\n\nI suppose that in your view then, dumpprivkey and dumpwallet RPCs should\nbe removed from bitcoin-core to fit this paradigm?\n\n(Personally I actively avoid wallet software that takes this view and\ntreat users like children, preventing individuals direct access to the\nkeys for their own funds, which disempowers and sometimes results in a\nform of lockin)\n\n> Backups should be encrypted (whoever finds the paper backup should need a second factor to decrypt) and the restore process should be footgun-safe (especially the lost-passphrase deadlock).\n\nThis is more relevant to an application layer above the 2 RPC calls I\nproposed. Encryption could be implemented (or not) by whichever software\ncalls the proposed RPC apis.  And further the APIs can be called for\nuse-cases beyond just paper wallets."
            },
            {
                "author": "Jonas Schnelli",
                "date": "2017-09-30T21:14:44",
                "message_text_only": "> \n> uhh.... do you apply this logic to the bitcoin-core wallet itself?\n> because clearly it generates keys and is intended to be used for signing\n> in online environments.  Lots of real-world use-cases depend on that today.\n\nThe current Bitcoin Core wallet setup is not as ideal as it could be.\nAn good example is, that the wallet and the full node (the p2p logic on 8333) do share the same process (same memory space).\nAFAIK a lot of users use Core in watch-only mode and do the signing offline (offline / through HWWs).\nAlthough, Core has currently no direct support for offline signing (expect the rawtx API which are pretty expert-ish).\n\nThe Core development process goes into that direction but it takes time due to the strict and extremely important code quality insurance.\n\n> \n> So if existing bitcoin-core wallet behavior is \"ok\" in any context then\n> how is it any worse for it to generate a key/address that will not be\n> stored in the internal wallet, and the user may do with it as they wish?\n> That is all my proposed RPC call does and unlike the existing RPC calls\n> it never even stores the key or address to disk.  It is also useful when\n> run on an offline hardware device, such as a laptop connected to an\n> non-networked printer.\n\nIMO we should make it better not worse.\nPaper wallets delude to do address reuse, the spending-procedure is unclear, and very likely insecure.\nA quick photo-snapshot by an attack may result in a full compromised key.\nPrinter buffers, etc. are also something to worry here.\n\n> Further, you mention the word trust.  That's the crux of the matter.  As\n> a full node operator, I've already placed my trust in the bitcoin-core\n> developers and dev/release practices.  Why exactly should I trust the\n> software in this minimal offline hardware/os you mention if it is NOT\n> bitcoin core?  And even if open source software, does that not at least\n> double my workload/expense to audit theat software in addition to\n> bitcoin-core?\n\nI think Bitcoin Core does a great job there. But not sure about other security layers are outside of Core.\nEspecially your operating system.\nThe reason why we see a growing demand in hardware wallets is probably because people no longer trust in current available operating systems as well as current used desktop/laptop CPUs (like Intel wit it\u2019s MME, etc.).\n\n> \n>> Users should have no way to view or export the private keys (expect for\n>> the seed backup).\n> \n> I suppose that in your view then, dumpprivkey and dumpwallet RPCs should\n> be removed from bitcoin-core to fit this paradigm?\n\nYes. That actually something we are considering (especially if we would allow BIP44 or other HD public key derivation forms).\nAlso, we heard of \"support sessions\u201c on IRC where attackers told victims they must enter \u201edumpprivkey\u201c in the Console and give them the output in order \u201eto fix the problem\u201c.\n\n> (Personally I actively avoid wallet software that takes this view and\n> treat users like children, preventing individuals direct access to the\n> keys for their own funds, which disempowers and sometimes results in a\n> form of lockin)\n\nI dislike that as well \u2013 in general. But I guess most users like self-protection. Also, the user layer is attackable. If _you_ can access the private-keys, an attacker can do also. What most users want is a key-safe that only signs transactions which they could verify beforehand in a safe environment, and not a way to export private keys or something else that can touch the keys.\n\n\n>> They should never leave the device over the channel used for the signing I/O. Users should have no way to view or export the private keys (expect for the seed backup). Backups should be encrypted (whoever finds the paper backup should need a second factor to decrypt) and the restore process should be footgun-safe (especially the lost-passphrase deadlock).\n> \n> Is there really nothing existing yet to address all of this?\n\nThe answer is probably: No (for now). But working towards this should be the focus.\n\n\n---\n/jonas\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170930/c2a58417/attachment.sig>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2017-09-30T23:51:12",
                "message_text_only": "By \"all of this\" I meant the other issues that I mentioned too \"would\neverybody even here say that they feel very comfortable with their keys?\nThat if something happen to them there is no pb for the family or\ntrusted parties to retrieve the keys? That this process is secured in\ncase the trusted parties are finally untrusted? etc\", I am extending the\nproblematic while the very basic concerns are still unsolved\n\nThen I don't agree with the fact that users should not have the control\nof their keys, but if I try to summarize, your suggestions probably lead\nto the fact that the \"wallet\" part should be outside of bitcoin-qt, in a\nsimple offline module (assuming that you can trust the simple sw + the\nos + the hw +the cpu, but ok, the pb is the same with a hw wallet),\nwhich I think is a good idea\n\nThat's why I made a module some time ago, supposed to be \"bitcoin\ntransactions made simple\", you do your transactions offline, check them,\nand send them to the network via qt, the web or other, it's working but\nis not online on github because unfinished, and unfinished because\nnothing is simple and it's unlikely that normal people can use this for\nnow, unfortunately you need to be a bit online to make your transaction,\nfetch the output you want to spend or get the info, then associate the\nright key, calculate the fees, that's not simple, that's why it's\ndifferent from a standard wallet, but probably a good way\n\nSmall sw a bit like a credit card finally, and people know they must not\ndisclose their code(s) in case they are asked on IRC or elsewhere\n\n\n\nLe 30/09/2017 \u00e0 23:14, Jonas Schnelli via bitcoin-dev a \u00e9crit\u00a0:\n>> uhh.... do you apply this logic to the bitcoin-core wallet itself?\n>> because clearly it generates keys and is intended to be used for signing\n>> in online environments.  Lots of real-world use-cases depend on that today.\n> The current Bitcoin Core wallet setup is not as ideal as it could be.\n> An good example is, that the wallet and the full node (the p2p logic on 8333) do share the same process (same memory space).\n> AFAIK a lot of users use Core in watch-only mode and do the signing offline (offline / through HWWs).\n> Although, Core has currently no direct support for offline signing (expect the rawtx API which are pretty expert-ish).\n>\n> The Core development process goes into that direction but it takes time due to the strict and extremely important code quality insurance.\n>\n>> So if existing bitcoin-core wallet behavior is \"ok\" in any context then\n>> how is it any worse for it to generate a key/address that will not be\n>> stored in the internal wallet, and the user may do with it as they wish?\n>> That is all my proposed RPC call does and unlike the existing RPC calls\n>> it never even stores the key or address to disk.  It is also useful when\n>> run on an offline hardware device, such as a laptop connected to an\n>> non-networked printer.\n> IMO we should make it better not worse.\n> Paper wallets delude to do address reuse, the spending-procedure is unclear, and very likely insecure.\n> A quick photo-snapshot by an attack may result in a full compromised key.\n> Printer buffers, etc. are also something to worry here.\n>\n>> Further, you mention the word trust.  That's the crux of the matter.  As\n>> a full node operator, I've already placed my trust in the bitcoin-core\n>> developers and dev/release practices.  Why exactly should I trust the\n>> software in this minimal offline hardware/os you mention if it is NOT\n>> bitcoin core?  And even if open source software, does that not at least\n>> double my workload/expense to audit theat software in addition to\n>> bitcoin-core?\n> I think Bitcoin Core does a great job there. But not sure about other security layers are outside of Core.\n> Especially your operating system.\n> The reason why we see a growing demand in hardware wallets is probably because people no longer trust in current available operating systems as well as current used desktop/laptop CPUs (like Intel wit it\u2019s MME, etc.).\n>\n>>> Users should have no way to view or export the private keys (expect for\n>>> the seed backup).\n>> I suppose that in your view then, dumpprivkey and dumpwallet RPCs should\n>> be removed from bitcoin-core to fit this paradigm?\n> Yes. That actually something we are considering (especially if we would allow BIP44 or other HD public key derivation forms).\n> Also, we heard of \"support sessions\u201c on IRC where attackers told victims they must enter \u201edumpprivkey\u201c in the Console and give them the output in order \u201eto fix the problem\u201c.\n>\n>> (Personally I actively avoid wallet software that takes this view and\n>> treat users like children, preventing individuals direct access to the\n>> keys for their own funds, which disempowers and sometimes results in a\n>> form of lockin)\n> I dislike that as well \u2013 in general. But I guess most users like self-protection. Also, the user layer is attackable. If _you_ can access the private-keys, an attacker can do also. What most users want is a key-safe that only signs transactions which they could verify beforehand in a safe environment, and not a way to export private keys or something else that can touch the keys.\n>\n>\n>>> They should never leave the device over the channel used for the signing I/O. Users should have no way to view or export the private keys (expect for the seed backup). Backups should be encrypted (whoever finds the paper backup should need a second factor to decrypt) and the restore process should be footgun-safe (especially the lost-passphrase deadlock).\n>> Is there really nothing existing yet to address all of this?\n> The answer is probably: No (for now). But working towards this should be the focus.\n>\n>\n> ---\n> /jonas\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171001/47634345/attachment-0001.html>"
            },
            {
                "author": "Sjors Provoost",
                "date": "2017-09-30T07:36:46",
                "message_text_only": "> Op 30 sep. 2017, om 06:49 heeft Jonas Schnelli via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:\n> \n>> On 09/29/2017 02:03 PM, Luke Dashjr wrote:\n>> Paper wallets are a safety hazard, insecure, and generally not advisable.\n>> \n> \n> I have to agree with Luke.\n> And I would also extend those concerns to BIP39 plaintext paper backups.\n> \n> IMO, private keys should be generated and used (signing) on a trusted, minimal and offline hardware/os. They should never leave the device over the channel used for the signing I/O. Users should have no way to view or export the private keys (expect for the seed backup). Backups should be encrypted (whoever finds the paper backup should need a second factor to decrypt) and the restore process should be footgun-safe (especially the lost-passphrase deadlock).\n\nI believe BIP39 does an excellent job at reducing the amount of bitcoin permanently lost. Stolen funds can at least in theory be retrieved at some future date. There's a trade-off between having a backup process that is secure and one that people actually use. I don't know the right answer, and tend to agree it's better left to individual wallets to decide.\n\nSjors\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170930/d70b17b5/attachment-0001.sig>"
            },
            {
                "author": "Adam Ritter",
                "date": "2017-09-30T09:35:05",
                "message_text_only": "I'm happy to help with secure paper wallet support. Bitcoin core is already\nused offline by the Glacier Protocol, though there's no official offline\nsupport.\n\nI extended the Glacier Protocol with an extra password derivation function.\nI used Scrypt with 2GB RAM requirement, though maybe using Argon2id V1.3\nwould be better.\n\nAlso I'd prefer using BIP45 Multisig HD Wallets over a multisig address, as\nin the current Glacier Protocol implementation the redeem key is public\nbecause of the test withdrawal transaction.\n\nOn Sat, Sep 30, 2017 at 6:49 AM, Jonas Schnelli via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> > Hi,\n> >\n> > I'm writing to suggest and discuss the addition of paper wallet\n> > functionality in bitcoin-core software, starting with a single new RPC\n> > call: genExternalAddress [type].\n> >\n>\n> AFAIK, client implementations such as your proposal are off-topic for this\n> ML.\n> Better use bitcoin-core-dev (ML or IRC) or Github (bitcoin/bitcoin) for\n> such proposals.\n>\n>\n> > On 09/29/2017 02:03 PM, Luke Dashjr wrote:\n> > Paper wallets are a safety hazard, insecure, and generally not advisable.\n> >\n>\n> I have to agree with Luke.\n> And I would also extend those concerns to BIP39 plaintext paper backups.\n>\n> IMO, private keys should be generated and used (signing) on a trusted,\n> minimal and offline hardware/os. They should never leave the device over\n> the channel used for the signing I/O. Users should have no way to view or\n> export the private keys (expect for the seed backup). Backups should be\n> encrypted (whoever finds the paper backup should need a second factor to\n> decrypt) and the restore process should be footgun-safe (especially the\n> lost-passphrase deadlock).\n>\n>\n> /jonas\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170930/8ad1e451/attachment.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2017-09-30T11:10:45",
                "message_text_only": "I am not sure that this discussion is really off topic for this list,\nthis is a real issue, would everybody even here say that they feel very\ncomfortable with their keys? That if something happen to them there is\nno pb for the family or trusted parties to retrieve the keys? That this\nprocess is secured in case the trusted parties are finally untrusted? etc\n\nI don't think so, if experts are not comfortable then how can we expect\nnon experts people to manage this? (except going to a wallet sw asking\nthem all the info, even online, crazy but they just don't know)\n\nComments below\n\n\nLe 30/09/2017 \u00e0 06:49, Jonas Schnelli via bitcoin-dev a \u00e9crit\u00a0:\n\n> And I would also extend those concerns to BIP39 plaintext paper backups.\n\nPersonnaly I don't see also the advantage of proposals such as BIP39 versus backing up a seed \n\n> IMO, private keys should be generated and used (signing) on a trusted, minimal and offline hardware/os.\n\nThis is the intent of https://github.com/Ayms/bitcoin-wallets and\nhttps://github.com/Ayms/zcash-wallets\n\nBut even myself can get confused, where did I put the backup seed? But\nremember you did not backup the seed but the first derivation step and\nyou mixed it secretely, so nobody can reconstitute it except you,\nwell... what did I do exactly? What version is my real wallet? What is\nthe encryption key? How did I do last time to add the key in qt? etc\n\n>  They should never leave the device over the channel used for the signing I/O. Users should have no way to view or export the private keys (expect for the seed backup). Backups should be encrypted (whoever finds the paper backup should need a second factor to decrypt) and the restore process should be footgun-safe (especially the lost-passphrase deadlock).\n\nIs there really nothing existing yet to address all of this?\n\n\n-- \nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms"
            },
            {
                "author": "Dan Libby",
                "date": "2017-09-29T22:13:47",
                "message_text_only": "It seems to me that the same statement can be made for *any* key storage\nmechanism depending on one's security/threat model, including\nbitcoin-core's internal wallet storage.  There certainly are cases where\na paper (or metal) offline wallet makes a lot of sense, particularly for\nlong-term offline storage... something that electronic media pretty much\nsucks at.\n\nThough if you care to elaborate I'd be interested to learn of your\nspecific critiques, if you have any beyond the generic statements here:\nhttps://en.bitcoin.it/wiki/Paper_wallet\n\nRegardless, the APIs I've proposed have uses beyond paper wallets.  It\ncan also be used by third party wallets, or any number of reasons that\nindividuals or devs might have to generate keys.\n\n\n\nOn 09/29/2017 02:03 PM, Luke Dashjr wrote:\n> Paper wallets are a safety hazard, insecure, and generally not advisable.\n> \n> \n> On Friday 29 September 2017 5:29:17 PM Dan Libby via bitcoin-dev wrote:\n>> Hi,\n>>\n>> I'm writing to suggest and discuss the addition of paper wallet\n>> functionality in bitcoin-core software, starting with a single new RPC\n>> call: genExternalAddress [type].\n>>\n>> -- rationale --\n>>\n>> bitcoin-core is the most trusted and most secure bitcoin implementation.\n>>\n>> Yet today (unless I've missed something) paper wallet generation\n>> requires use of third party software, or even a website such as\n>> bitaddress.org.  This requires placing trust in an additional body of\n>> code from a less-trusted and less peer-reviewed source.  Ideally, one\n>> would personally audit this code for one's self, but in practice that\n>> rarely happens.\n>>\n>> In the case of a website generator, the code must be audited again each\n>> time it is downloaded.  I cannot in good faith recommend to anyone to\n>> use such third party tools for wallet generation.\n>>\n>> I *would* recommend for others to trust a paper wallet that uses\n>> address(es) generated by bitcoin-core itself.\n>>\n>> At least for me, this requirement to audit (or implicitly trust) a\n>> secondary body of bitcoin code places an additional hurdle or\n>> disincentive on the use of paper wallets, or indeed private keys\n>> generated outside of bitcoin-core for any purpose.\n>>\n>> Unfortunately, one cannot simply use getnewaddress, getaccountaddress,\n>> or getrawchangeaddress for this purpose, because the associated private\n>> keys are added to the bitcoin-core wallet and cannot be removed... or in\n>> the case of hd-wallets are deterministically derived.\n>>\n>> As such, I'm throwing out the following half-baked proposal as a\n>> starting point for discussion:\n>>\n>>\n>> -----\n>>\n>>     genexternaladdress ( \"type\" )\n>>\n>>     Returns a new Bitcoin address and private key for receiving\n>>     payments. This key/address is intended for external usage such as\n>>     paper wallets and will not be used by internal wallet nor written to\n>>     disk.\n>>\n>>     Arguments:\n>>     1. \"type\"        (string, optional) one of: p2pkh, p2sh-p2wpkh\n>>                                         default: p2sh-p2wpkh\n>>\n>>     Result:\n>>     {\n>>         \"privKey\"    (string) The private key in wif format.\n>>         \"address\"    (string) The address in p2pkh or p2sh-p2wpkh\n>>                               format.\n>>     }\n>>\n>>     Examples:\n>>     > bitcoin-cli genexternaladdress\n>>\n>> ----\n>>\n>> This API is simple to implement and use.  It provides enough\n>> functionality for any moderately skilled developer to create their own\n>> paper wallet creation script using any scripting language, or even for\n>> advanced users to perform using bitcoin-cli or debug console.\n>>\n>> If consensus here is in favor of including such an API, I will be happy\n>> to take a crack at implementing it and submitting a pull request.\n>>\n>> If anyone has reasons why it is a BAD IDEA to include such an RPC call\n>> in bitcoind, I'm curious to hear it.\n>>\n>> Also, I welcome suggestions for a better name, or maybe there could be\n>> some improvements to the param(s), such as calling p2sh-p2wpkh \"segwit\"\n>> instead.\n>>\n>>\n>> ---- further work ----\n>>\n>>\n>> Further steps could be taken in this direction, but are not necessary\n>> for a useful first-step.  In particular:\n>>\n>> 1. an RPC call to generate an external HD wallet seed.\n>> 2. an RPC call to generate N key/address pairs from a given seed.\n>> 3. GUI functionality in bitcoin-qt to facilitate easy paper wallet\n>> generation (and printing?) for end-users, complete with nice graphics,\n>> qr codes, etc.\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n\n-- \nDan Libby\n\nOpen Source Consulting S.A.\nSanta Ana, Costa Rica\nhttp://osc.co.cr\nphone: 011 506 2204 7018\nFax: 011 506 2223 7359"
            },
            {
                "author": "Dan Libby",
                "date": "2017-09-29T22:19:46",
                "message_text_only": "Anyway, I'll count that as a NAK from Luke.  what do others here think?\n\nI wish to guage if I were to submit a functional pull request for one or\nboth of these RPC calls, if would it be likely to be accepted.\n\nIf so I'm happy to contribute my time, otherwise...\n\nOn 09/29/2017 03:13 PM, Dan Libby wrote:\n> It seems to me that the same statement can be made for *any* key storage\n> mechanism depending on one's security/threat model, including\n> bitcoin-core's internal wallet storage.  There certainly are cases where\n> a paper (or metal) offline wallet makes a lot of sense, particularly for\n> long-term offline storage... something that electronic media pretty much\n> sucks at.\n> \n> Though if you care to elaborate I'd be interested to learn of your\n> specific critiques, if you have any beyond the generic statements here:\n> https://en.bitcoin.it/wiki/Paper_wallet\n> \n> Regardless, the APIs I've proposed have uses beyond paper wallets.  It\n> can also be used by third party wallets, or any number of reasons that\n> individuals or devs might have to generate keys.\n> \n> \n> \n> On 09/29/2017 02:03 PM, Luke Dashjr wrote:\n>> Paper wallets are a safety hazard, insecure, and generally not advisable.\n>>\n>>\n>> On Friday 29 September 2017 5:29:17 PM Dan Libby via bitcoin-dev wrote:\n>>> Hi,\n>>>\n>>> I'm writing to suggest and discuss the addition of paper wallet\n>>> functionality in bitcoin-core software, starting with a single new RPC\n>>> call: genExternalAddress [type].\n>>>\n>>> -- rationale --\n>>>\n>>> bitcoin-core is the most trusted and most secure bitcoin implementation.\n>>>\n>>> Yet today (unless I've missed something) paper wallet generation\n>>> requires use of third party software, or even a website such as\n>>> bitaddress.org.  This requires placing trust in an additional body of\n>>> code from a less-trusted and less peer-reviewed source.  Ideally, one\n>>> would personally audit this code for one's self, but in practice that\n>>> rarely happens.\n>>>\n>>> In the case of a website generator, the code must be audited again each\n>>> time it is downloaded.  I cannot in good faith recommend to anyone to\n>>> use such third party tools for wallet generation.\n>>>\n>>> I *would* recommend for others to trust a paper wallet that uses\n>>> address(es) generated by bitcoin-core itself.\n>>>\n>>> At least for me, this requirement to audit (or implicitly trust) a\n>>> secondary body of bitcoin code places an additional hurdle or\n>>> disincentive on the use of paper wallets, or indeed private keys\n>>> generated outside of bitcoin-core for any purpose.\n>>>\n>>> Unfortunately, one cannot simply use getnewaddress, getaccountaddress,\n>>> or getrawchangeaddress for this purpose, because the associated private\n>>> keys are added to the bitcoin-core wallet and cannot be removed... or in\n>>> the case of hd-wallets are deterministically derived.\n>>>\n>>> As such, I'm throwing out the following half-baked proposal as a\n>>> starting point for discussion:\n>>>\n>>>\n>>> -----\n>>>\n>>>     genexternaladdress ( \"type\" )\n>>>\n>>>     Returns a new Bitcoin address and private key for receiving\n>>>     payments. This key/address is intended for external usage such as\n>>>     paper wallets and will not be used by internal wallet nor written to\n>>>     disk.\n>>>\n>>>     Arguments:\n>>>     1. \"type\"        (string, optional) one of: p2pkh, p2sh-p2wpkh\n>>>                                         default: p2sh-p2wpkh\n>>>\n>>>     Result:\n>>>     {\n>>>         \"privKey\"    (string) The private key in wif format.\n>>>         \"address\"    (string) The address in p2pkh or p2sh-p2wpkh\n>>>                               format.\n>>>     }\n>>>\n>>>     Examples:\n>>>     > bitcoin-cli genexternaladdress\n>>>\n>>> ----\n>>>\n>>> This API is simple to implement and use.  It provides enough\n>>> functionality for any moderately skilled developer to create their own\n>>> paper wallet creation script using any scripting language, or even for\n>>> advanced users to perform using bitcoin-cli or debug console.\n>>>\n>>> If consensus here is in favor of including such an API, I will be happy\n>>> to take a crack at implementing it and submitting a pull request.\n>>>\n>>> If anyone has reasons why it is a BAD IDEA to include such an RPC call\n>>> in bitcoind, I'm curious to hear it.\n>>>\n>>> Also, I welcome suggestions for a better name, or maybe there could be\n>>> some improvements to the param(s), such as calling p2sh-p2wpkh \"segwit\"\n>>> instead.\n>>>\n>>>\n>>> ---- further work ----\n>>>\n>>>\n>>> Further steps could be taken in this direction, but are not necessary\n>>> for a useful first-step.  In particular:\n>>>\n>>> 1. an RPC call to generate an external HD wallet seed.\n>>> 2. an RPC call to generate N key/address pairs from a given seed.\n>>> 3. GUI functionality in bitcoin-qt to facilitate easy paper wallet\n>>> generation (and printing?) for end-users, complete with nice graphics,\n>>> qr codes, etc.\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> \n\n\n-- \nDan Libby\n\nOpen Source Consulting S.A.\nSanta Ana, Costa Rica\nhttp://osc.co.cr\nphone: 011 506 2204 7018\nFax: 011 506 2223 7359"
            }
        ],
        "thread_summary": {
            "title": "Paper Wallet support in bitcoin-core",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Adam Ritter",
                "Andrew Johnson",
                "Dan Libby",
                "Aymeric Vitte",
                "Sjors Provoost",
                "Jonas Schnelli"
            ],
            "messages_count": 14,
            "total_messages_chars_count": 49599
        }
    }
]