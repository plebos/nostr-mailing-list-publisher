[
    {
        "title": "[bitcoin-dev] ScalingBitcoin 2015: Retarget - Call For Proposals Now Open",
        "thread_messages": [
            {
                "author": "Matt Corallo",
                "date": "2016-09-01T00:56:08",
                "message_text_only": "Hi all,\n\nFor those who missed it, the deadline for submissions has been extended\nto Sept 9th so be sure to submit before then! We will be doing rolling\nacceptance this time around to try to get most responses out before the\n23rd.\n\nBecause a few folks seemed to have some confusion, the definition of\n\"scaling\" here is pretty broad - while we definitely will have a lot of\ntalks on the usual tx-volume-throughput things, the topics of interest\nalso include things like fungibility. The full list from the site (for\ninspiration purposes, this is by no means exhaustive) is:\n\nImproving Bitcoin throughput\nLayer 2 ideas (i.e. payment channels, etc.)\nSecurity and privacy\nIncentives and fee structures\nTesting, simulation, and modeling\nNetwork resilience and latency\nFungibility\nAnti-spam measures\nBlock size proposals\nMining concerns\n\nThanks,\nMatt\n\nOn 08/02/16 01:49, Pindar Wong via bitcoin-dev wrote:\n> Dear All,\n> \n> The Call for Proposals (CFP) for 'Scaling Bitcoin 2016: Retarget' is now\n> open. \n> \n> Please see https://scalingbitcoin.org for details.\n> \n> *Important Dates*\n> \n> Sept 2nd - Deadline for submissions to the CFP\n> Sept 23rd - Deadline for applicant acceptance notification\n> \n> See you in Milan! (October 8th and 9th)\n> \n> Ciao! :)\n> \n> p.\n> \n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            }
        ],
        "thread_summary": {
            "title": "ScalingBitcoin 2015: Retarget - Call For Proposals Now Open",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Matt Corallo"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1452
        }
    },
    {
        "title": "[bitcoin-dev] Attack by modifying non-segwit transactions after segwit is accepted ?",
        "thread_messages": [
            {
                "author": "Johnson Lau",
                "date": "2016-09-01T11:29:29",
                "message_text_only": "Thank you so much for taking time to actually review the codes. I hope you will keep raising questions when you feel something might be wrong. This is how things supposed to work and we should not be affected by some forum discussions.\n\n> On August 26, 2016 at 9:16 AM Sergio Demian Lerner <sergio.d.lerner at gmail.com> wrote:\n> \n>     Because there was a discussion on reddit about this topic, I want to clarify that Johnson Lau explained how a check in the code prevents this attack.\n>     So there is no real attack.\n> \n>     Also note that the subject of this thread has a question mark, which means that I'm asking the community for clarification, not asserting the existence of a vulnerability.\n> \n>     The segwit code is complex, and some key parts of the consensus code are spread over the source files (such as state.CorruptionPossible() relation to DoS banning, IsNull() check in witness program serialization, etc.).\n> \n>     Thanks again Johnson for your clarifications.\n> \n> \n>     On Wed, Aug 24, 2016 at 10:49 PM, Johnson Lau <jl2012 at xbt.hk mailto:jl2012 at xbt.hk > wrote:\n> \n>         > > \n> >         Adding witness data to a non-segwit script is invalid by consensus:\n> > \n> >         https://github.com/bitcoin/bitcoin/blob/d612837814020ae832499d18e6ee5eb919a87907/src/script/interpreter.cpp#L1467 https://github.com/bitcoin/bitcoin/blob/d612837814020ae832499d18e6ee5eb919a87907/src/script/interpreter.cpp#L1467\n> > \n> > \n> >         This PR will detect such violation early and ban the peer:\n> > \n> >         https://github.com/bitcoin/bitcoin/pull/8499 https://github.com/bitcoin/bitcoin/pull/8499\n> > \n> >          \n> > \n> > \n> >         Another approach is to run the scripts of all incoming transactions. That's not too bad as you have already fetched the utxos which is a major part of validation.\n> > \n> >     > \n> \n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160901/9910d4f0/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Attack by modifying non-segwit transactions after segwit is accepted ?",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Johnson Lau"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2030
        }
    },
    {
        "title": "[bitcoin-dev] New BIP: Dealing with OP_IF and OP_NOTIF malleability in P2WSH",
        "thread_messages": [
            {
                "author": "Johnson Lau",
                "date": "2016-09-01T11:39:51",
                "message_text_only": "Restriction for segwit OP_IF argument as a policy has got a few concept ACK. I would like to have more people to ACK or NACK, especially the real users of OP_IF. I think Lightning network would use that at lot.\n\nPull request: https://github.com/bitcoin/bitcoin/pull/8526\n\nmore related discussion could be found at https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-August/013036.html\n\nIt does have impact if your script uses the combination of \"OP_SIZE OP_IF\" or \"OP_DEPTH OP_IF\". With this policy/softfork, you need to use  \"OP_SIZE OP_0NOTEQUAL OP_IF\" or \"OP_DEPTH OP_0NOTEQUAL OP_IF\", or reconstruct your scripts.\n\n> \n>     On August 16, 2016 at 1:53 PM Johnson Lau via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n>     -----BEGIN PGP SIGNED MESSAGE-----\n>     Hash: SHA512\n> \n>     A new BIP is prepared to deal with OP_IF and OP_NOTIF malleability in P2WSH:\n>     https://github.com/jl2012/bips/blob/minimalif/bip-minimalif.mediawiki\n>     https://github.com/bitcoin/bitcoin/pull/8526\n> \n>     BIP: x\n>     Title: Dealing with OP_IF and OP_NOTIF malleability in P2WSH\n>     Author: Johnson Lau <jl2012 at xbt.hk>\n>     Status: Draft\n>     Type: Standards Track\n>     Created: 2016-08-17\n> \n>     Abstract\n> \n>     This document specifies proposed changes to the Bitcoin script validity rules in order to make transaction malleability related to OP_IF and OP_NOTIF impossible in pay-to-witness-script-hash (P2WSH) scripts.\n> \n>     Motivation\n> \n>     OP_IF and OP_NOTIF are flow control codes in the Bitcoin script system. The programme flow is decided by whether the top stake value is True or False. However, this behaviour opens a source of malleability as a third party may replace a True (False) stack item with any other True (False) value without invalidating the transaction.\n> \n>     The proposed rules apply only to pay-to-witness-script-hash (P2WSH) scripts described in BIP141, which has not been activated on the Bitcoin mainnet as of writing. To ensure OP_IF and OP_NOTIF transactions created before the introduction of this BIP will still be accepted by the network, the new rules are not applied to non-segregated witness scripts.\n> \n>     Specification\n> \n>     In P2WSH, the argument for OP_IF and OP_NOTIF MUST be exactly an empty vector or 0x01, or the script evaluation fails immediately.\n> \n>     This is deployed using BIP9 after segregated witness (BIP141) is activated. Details TBD.\n> \n>     Compatibility\n> \n>     This is a softfork on top of BIP141. The rules are enforced as a relay policy by the reference client since the first release of BIP141 (v0.13.1). To avoid risks of fund loss, users MUST NOT create P2WSH scripts that are incompatible with this BIP. An OP_0NOTEQUAL may be used before OP_IF or OP_NOTIF to imitate the original behaviour (which may also re-enable the malleability vector depending on the exact script).\n> \n>     Implementation\n> \n>     https://github.com/bitcoin/bitcoin/pull/8526\n> \n>     Copyright\n> \n>     This work is placed in the public domain.\n>     -----BEGIN PGP SIGNATURE-----\n>     Comment: GPGTools - https://gpgtools.org\n> \n>     iQGcBAEBCgAGBQJXs1LgAAoJEO6eVSA0viTSrJQL/A/womJKgi4FuyBTL9oykCss\n>     aBMNN9+SLtmuH7SBgEUGZ8TFxa2st+6RP6Imu+Vvn4O5sXQl3DIXV+X38X93sUYk\n>     wrjdpvdpqFFYJezPDESz6pR/6bZ1ES0aO2QqX578/8sqr8GO6L388s66vJeIGj4n\n>     0LWW8sdEypMuV3HUG/9FFdUNHgiVX1U0sS1rT3P4aN30JYtb7PQpd7r8KTMta7Rt\n>     L1VOZB+W3m2m2YZ9gB7IRmMfzzNm2QXRTPIZXt2x3mYDBuMkp+zEd5+ogA4sBpgP\n>     wp2+l/aos686v0w8QYiNUX2+9Qpe7+238qUpw75d2XJYmLzdotWFvmp4g1hP+awX\n>     HEfwe4BUM+El17LjrHkNeMWNJXMlhTtXb2i0XMj8tU5lZVHep4WpQ+LEahrNlsUl\n>     FdFsi3q8HeWh8JsGaNCL41Bgbg/rKb5hUXyF6hTRHa//E6llOrpXRnsloKgBLv8c\n>     QezgKTAPwwgdjcS6Ek0AqgLp7bCFRijCduYH9i9uaQ==\n>     =lLIZ\n>     -----END PGP SIGNATURE-----\n> \n>     _______________________________________________\n>     bitcoin-dev mailing list\n>     bitcoin-dev at lists.linuxfoundation.org\n>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160901/8e47cd9f/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-09-05T01:32:19",
                "message_text_only": "Johnson Lau via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nwrites:\n> Restriction for segwit OP_IF argument as a policy has got a few concept ACK. I would like to have more people to ACK or NACK, especially the real users of OP_IF. I think Lightning network would use that at lot.\n\nMy current scripts use OP_IF and OP_NOTIF only after OP_EQUAL, except\nfor one place where they use OP_EQUAL ... OP_EQUAL... OP_ADD OP_IF\n(where the two OP_EQUALs are comparing against different hashes, so only\n0 or 1 of the two OP_EQUAL can return 1).\n\nSo there's no effect either way on the c-lightning implementation, at\nleast.\n\nThanks!\nRusty."
            },
            {
                "author": "Russell O'Connor",
                "date": "2016-09-05T14:55:10",
                "message_text_only": "For sake of example, suppose we have a marginal fee rate of 50 satoshis per\nbyte.  At that rate reducing the size of the witness data by 1 byte is\napproximately equivalent from a miner and relayer's perspective as a\nreplace by fee that increases the fee by 50 satoshis.  In both cases miners\nget an extra potential of 50 satoshis in revenue.\n\nSo in this sense replacing witness data with smaller witness data can pay\nfor its own relay cost as much as RBF can simply by requiring that the\nsmaller witness be smaller enough to cover the same RBF threshold.\n\nOn Tue, Aug 16, 2016 at 6:39 PM, Pieter Wuille <pieter.wuille at gmail.com>\nwrote:\n\n> On Aug 17, 2016 00:36, \"Russell O'Connor\" <roconnor at blockstream.io> wrote:\n>\n> > Can I already do something similar with replace by fee, or are there\n> limits on that?\n>\n> BIP125 and mempool eviction both require the replacing transaction to have\n> higher fee, to compensate for the cost of relaying the replaced\n> transaction(s).\n>\n> --\n> Pieter\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160905/27c7324f/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "New BIP: Dealing with OP_IF and OP_NOTIF malleability in P2WSH",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Russell O'Connor",
                "Johnson Lau"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 5996
        }
    },
    {
        "title": "[bitcoin-dev] New BIP: Dealing with dummy stack element malleability",
        "thread_messages": [
            {
                "author": "Johnson Lau",
                "date": "2016-09-02T04:40:58",
                "message_text_only": "https://github.com/bitcoin/bips/pull/440\nhttps://github.com/bitcoin/bitcoin/pull/8636\nThis document specifies proposed changes to the Bitcoin transaction validity rules to fix the malleability of extra stack element for OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY.\n\nThe original plan was to do the LOW_S and NULLDUMMY (BIP146) together with segwit in 0.13.1. However, as we discovered some undocumented behavior in LOW_S, we may want to deploy the LOW_S softfork in a later release. https://github.com/bitcoin/bitcoin/pull/8533#issuecomment-243973512\n\nI will edit the BIP146 later.\n\n  BIP: ?\n  Title: Dealing with dummy stack element malleability\n  Author: Johnson Lau <jl2012 at xbt.hk>\n  Status: Draft\n  Type: Standards Track\n  Created: 2016-09-02\n\nAbstract\n\nThis document specifies proposed changes to the Bitcoin transaction validity rules to fix the malleability of extra stack element for OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY.\n\nMotivation\n\nSignature malleability refers to the ability of any relay node on the network to transform the signature in transactions, with no access to the relevant private keys required. For non-segregated witness transactions, signature malleability will change the txid and invalidate any unconfirmed child transactions. Although the txid of segregated witness (BIP141) transactions is not third party malleable, this malleability vector will change the wtxid and may reduce the efficiency of compact block relay (BIP152).\n\nA design flaw in OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY makes them consuming an extra stack element (\"dummy element\") after signature validation. The dummy element is not inspected in any manner, and could be replaced by any value without invalidating the script. This document specifies a new rule to fix this signature malleability.\n\nSpecification\n\nTo fix the dummy element malleability, a new consensus rule (\"NULLDUMMY\") is deployed to require that the dummy element MUST be the empty byte array. Anything else makes the script evaluate to false immediately. The NULLDUMMY rule applies to OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY in pre-segregated scripts, and also pay-to-witness-script-hash scripts described in BIP141.\n\nDeployment\n\nThis BIP will be deployed by \"version bits\" BIP9 using the same parameters for BIP141 and BIP143, with the name \"segwit\" and using bit 1.\n\nFor Bitcoin mainnet, the BIP9 starttime is midnight TBD UTC (Epoch timestamp TBD) and BIP9 timeout is midnight TBD UTC (Epoch timestamp TBD).\n\nFor Bitcoin testnet, the BIP9 starttime is midnight 1 May 2016 UTC (Epoch timestamp 1462060800) and BIP9 timeout is midnight 1 May 2017 UTC (Epoch timestamp 1493596800).\n\nCompatibility\n\nThe reference client has produced compatible signatures from the beginning, and the NULLDUMMY rule has been enforced as relay policy by the reference client since v0.10.0. There has been no transactions violating the requirement being added to the chain since at least August 2015. In addition, every non-compliant signature can trivially be converted into a compliant one, so there is no loss of functionality by this requirement.\n\nImplementation\n\nAn implementation for the reference client is available at https://github.com/bitcoin/bitcoin/pull/8636\n\nAcknowledgements\n\nThis document is extracted from the previous BIP62 proposal, which was composed by Pieter Wuille and had input from various people.\n\nCopyright\n\nThis document is placed in the public domain."
            },
            {
                "author": "Peter Todd",
                "date": "2016-09-02T05:47:14",
                "message_text_only": "On Fri, Sep 02, 2016 at 12:40:58AM -0400, Johnson Lau via bitcoin-dev wrote:\n> Deployment\n> \n> This BIP will be deployed by \"version bits\" BIP9 using the same parameters for BIP141 and BIP143, with the name \"segwit\" and using bit 1.\n> \n> For Bitcoin mainnet, the BIP9 starttime is midnight TBD UTC (Epoch timestamp TBD) and BIP9 timeout is midnight TBD UTC (Epoch timestamp TBD).\n> \n> For Bitcoin testnet, the BIP9 starttime is midnight 1 May 2016 UTC (Epoch timestamp 1462060800) and BIP9 timeout is midnight 1 May 2017 UTC (Epoch timestamp 1493596800).\n> \n> Compatibility\n> \n> The reference client has produced compatible signatures from the beginning, and the NULLDUMMY rule has been enforced as relay policy by the reference client since v0.10.0. There has been no transactions violating the requirement being added to the chain since at least August 2015. In addition, every non-compliant signature can trivially be converted into a compliant one, so there is no loss of functionality by this requirement.\n\nThis should say \"for all scriptPubKey types in actual use, non-compliant\nsignatures can trivially be converted into compliant ones\"\n\nYou can of course create a scriptPubKey where that's not possible, but\nfortunately no-one appears to do that.\n\n\nAlso, as original author of NULLDUMMY, thanks for finally making it into a\nsoft-fork!\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160902/1a8b627a/attachment.sig>"
            },
            {
                "author": "Tom Harding",
                "date": "2016-09-02T17:10:40",
                "message_text_only": "On 9/1/2016 9:40 PM, Johnson Lau via bitcoin-dev wrote:\n> This BIP will be deployed by \"version bits\" BIP9 using the same parameters for BIP141 and BIP143, with the name \"segwit\" and using bit 1.\n>\n\nThis fix has value outside of segwit.  Why bundle the two together? \nShouldn't miners have to opportunity to vote on them independently?"
            },
            {
                "author": "Johnson Lau",
                "date": "2016-09-04T12:29:37",
                "message_text_only": "Although it is technically possible to bundle 2 independent softforks in one release, it increases the burden of testing and maintenance. We need to test and prepare for 4 scenarios: both not activated, only NULLDUMMY activated, only SEGWIT activated, and both activated.\n\nAlso, as we learnt from BIP66, softfork activation could be risky. It is evident that today a non-negligible percentage of miners are hard-coding the block version number. This increases the risks of softfork transition as miners may not enforce what they are signaling (btw this is also happening on testnet) Making 2 independently softforks would double the risks, and I believe NULLDUMMY alone is not worth the risks.\n \n> On September 2, 2016 at 1:10 PM Tom Harding via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \n> On 9/1/2016 9:40 PM, Johnson Lau via bitcoin-dev wrote:\n> > This BIP will be deployed by \"version bits\" BIP9 using the same parameters for BIP141 and BIP143, with the name \"segwit\" and using bit 1.\n> >\n> \n> This fix has value outside of segwit.  Why bundle the two together? \n> Shouldn't miners have to opportunity to vote on them independently?\n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "New BIP: Dealing with dummy stack element malleability",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Peter Todd",
                "Tom Harding",
                "Johnson Lau"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 6804
        }
    },
    {
        "title": "[bitcoin-dev] New BIP: Low S values signatures",
        "thread_messages": [
            {
                "author": "Johnson Lau",
                "date": "2016-09-02T08:28:14",
                "message_text_only": "https://github.com/bitcoin/bips/pull/441\n\nThe BIP146 is revised the second time:\n\n1. NULLDUMMY is removed from BIP146 and becomes another softfork that will implement at the same time as segwit\u00a0https://github.com/bitcoin/bips/pull/440\n\n2. A new rule, namely NULLFAIL, is added to require empty signature(s) when a CHECK(MULTI)SIG returns a FALSE\n\n3. NULLFAIL will be implemented as a policy rule in 0.13.1. However, the softfork won't be deployed in 0.13.1.\n\nAs we discovered some undocumented behavior in LOW_S, we may want to deploy the LOW_S softfork in a later release.\u00a0The newly added NULLFAIL rules should cover all the special cases.\u00a0https://github.com/bitcoin/bitcoin/pull/8533#issuecomment-243973512\n\n--------\nBIP: 146\n  Title: Dealing with signature encoding malleability\n  Author: Johnson Lau <jl2012 at xbt.hk>\n          Pieter Wuille <pieter.wuille at gmail.com>\n  Status: Draft\n  Type: Standards Track\n  Created: 2016-08-16\n\nAbstract\n\nThis document specifies proposed changes to the Bitcoin transaction validity rules to fix signature malleability related to ECDSA signature encoding.\n\nMotivation\n\nSignature malleability refers to the ability of any relay node on the network to transform the signature in transactions, with no access to the relevant private keys required. For non-segregated witness transactions, signature malleability will change the txid and invalidate any unconfirmed child transactions. Although the txid of segregated witness (BIP141) transactions is not third party malleable, this malleability vector will change the wtxid and may reduce the efficiency of compact block relay (BIP152).\n\nSince the enforcement of Strict DER signatures (BIP66), there are 2 remaining known sources of malleability in ECDSA signatures:\n\nInherent ECDSA signature malleability: ECDSA signatures are inherently malleable as taking the negative of the number S inside (modulo the curve order) does not invalidate it.\nMalleability of failing signature: If a signature failed to validate in OP_CHECKSIG or OP_CHECKMULTISIG, a FALSE would be returned to the stack and the script evaluation would continue. The failing signature may take any value, as long as it follows all the rules described in BIP66.\nThis document specifies new rules to fix the aforesaid signature malleability.\nSpecification\n\nTo fix signature malleability, the following new rules are applied:\n\nLOW_S\n\nWe require that the S value inside ECDSA signatures is at most the curve order divided by 2 (essentially restricting this value to its lower half range). Every signature passed to OP_CHECKSIG[1], OP_CHECKSIGVERIFY, OP_CHECKMULTISIG, or OP_CHECKMULTISIGVERIFY, to which ECDSA verification is applied, MUST use a S value between 0x1 and 0x7FFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 5D576E73 57A4501D DFE92F46 681B20A0 (inclusive) with strict DER encoding (see BIP66).\n\nIf a signature passing to ECDSA verification does not pass the Low S value check and is not an empty byte array, the entire script evaluates to false immediately.\n\nA high S value in signature could be trivially replaced by S' = 0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141 - S.\n\nNULLFAIL\n\nIf an OP_CHECKSIG is trying to return a FALSE value to the stack, we require that the relevant signature must be an empty byte array.\n\nIf an OP_CHECKMULTISIG is trying to return a FALSE value to the stack, we require that all signatures passing to this OP_CHECKMULTISIG must be empty byte arrays, even the processing of some signatures might have been skipped due to early termination of the signature verification.\n\nOtherwise, the entire script evaluates to false immediately.\n\nExamples\n\nThe following examples combine the LOW_S and NULLFAIL rules.\n\nNotation:\n\n  CO       : curve order = 0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141\n  HCO      : half curve order = CO / 2 = 0x7FFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 5D576E73 57A4501D DFE92F46 681B20A0\n  P1, P2   : valid, serialized, public keys\n  S1L, S2L : valid low S value signatures using respective keys P1 and P2 (1 \u2264 S \u2264 HCO)\n  S1H, S2H : signatures with high S value (otherwise valid) using respective keys P1 and P2 (HCO < S < CO)\n  F        : any BIP66-compliant non-empty byte array but not a valid signature\n\nThese scripts will return a TRUE to the stack as before:\n\n  S1L P1 CHECKSIG\n  0 S1L S2L 2 P1 P2 2 CHECKMULTISIG\n\nThese scripts will return a FALSE to the stack as before:\n\n  0 P1 CHECKSIG\n  0 0 0 2 P1 P2 2 CHECKMULTISIG\n\nThese previously TRUE scripts will fail immediately under the new rules:\n\n  S1H P1 CHECKSIG\n  0 S1H S2L 2 P1 P2 2 CHECKMULTISIG\n  0 S1L S2H 2 P1 P2 2 CHECKMULTISIG\n  0 S1H S2H 2 P1 P2 2 CHECKMULTISIG\nThese previously FALSE scripts will fail immediately under the new rules:\n\n  F P1 CHECKSIG\n  0 S2L S1L 2 P1 P2 2 CHECKMULTISIG\n  0 S1L F   2 P1 P2 2 CHECKMULTISIG\n  0 F   S2L 2 P1 P2 2 CHECKMULTISIG\n  0 S1L 0   2 P1 P2 2 CHECKMULTISIG\n  0 0   S2L 2 P1 P2 2 CHECKMULTISIG\n  0 F   0   2 P1 P2 2 CHECKMULTISIG\n  0 0   F   2 P1 P2 2 CHECKMULTISIG\n\nDeployment\n\nThis BIP will be deployed by \"version bits\" BIP9. Details TBD.\n\nFor Bitcoin mainnet, the BIP9 starttime will be midnight TBD UTC (Epoch timestamp TBD) and BIP9 timeout will be midnight TBD UTC (Epoch timestamp TBD).\n\nFor Bitcoin testnet, the BIP9 starttime will be midnight TBD UTC (Epoch timestamp TBD) and BIP9 timeout will be midnight TBD UTC (Epoch timestamp TBD).\n\nCompatibility\n\nThe reference client has produced LOW_S compatible signatures since v0.9.0, and the LOW_S rule has been enforced as relay policy by the reference client since v0.11.1. As of August 2016, very few transactions violating the requirement are being added to the chain. For all scriptPubKey types in actual use, non-compliant signatures can trivially be converted into compliant ones, so there is no loss of functionality by these requirements.\n\nScripts with failing OP_CHECKSIG or OP_CHECKMULTISIG rarely happen on the chain. The NULLFAIL rule has been enforced as relay policy by the reference client since v0.13.1.\n\nUsers MUST pay extra attention to these new rules when designing exotic scripts.\n\nImplementation\n\nImplementations for the reference client is available at:\n\nhttps://github.com/bitcoin/bitcoin/blob/35fe0393f216aa6020fc929272118eade5628636/src/script/interpreter.cpp#L185\n\nand\n\nhttps://github.com/bitcoin/bitcoin/pull/8634\n\nFootnotes\n\n^ Including pay-to-witness-public-key-hash (P2WPKH) described in BIP141\nAcknowledgements\n\nThis document is extracted from the previous BIP62 proposal which had input from various people.\n\nCopyright\n\nThis document is placed in the public domain.\n\n--------\n\n> On August 17, 2016 at 8:43 AM Johnson Lau via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> The BIP146 has been updated to include NULLDUMMY* as part of the softfork:\n> \n> https://github.com/bitcoin/bips/pull/435\n> \n> NULLDUMMY is a trivial softfork to fix malleability related to the extra stack element consumed by CHECKMULTISIG(VERIFY). It\u00a0is probably more important than LOW_S since without that an attacker may replace the stack element with any value.\n\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "New BIP: Low S values signatures",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Johnson Lau"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 7294
        }
    },
    {
        "title": "[bitcoin-dev] [cont'd] Derivation scheme for P2WPKH-nested-in-P2SH based accounts",
        "thread_messages": [
            {
                "author": "Daniel Weigl",
                "date": "2016-09-07T09:42:24",
                "message_text_only": "Hello again,\n\nsorry, got a bit derailed on that proposal.\nBut now I think its time to work on it again.\n\n- Any objections to get a BIP-number for it? \n\tIf not, can I get one, so I can finish up the test vectors.\n\tCurrent version: https://github.com/DanielWeigl/bips/blob/master/bip-p2sh-accounts.mediawiki \n\n- I decided against extending it for future P2WPKH addresses\n\tI think that should be a separate account on its own, to reduce implementation work \n\tfor future wallets, that only want/need to implement P2WPKH accounts. And to keep it simple.\n\tWas someone working on the P2WPKH address format in the meantime? (ie. alternative for [2])\n\n- We will also need a extension to the BIP32 serialization format[1]\n\tIt should be possible to export/import a xPriv/xPub key across compatible wallets, and they\n\tshould be able without guesswork, fuzzy checks or asking the user to import the correct account type.\n\tThinking about some flexible tag-based backwards compatible extensions - but thats a different BIP in itself.\n\n\nCheers,\nDaniel\n\n\n[1] https://github.com/DanielWeigl/bips/blob/master/bip-0032.mediawiki#Serialization_format\n[2] https://github.com/bitcoin/bips/blob/master/bip-0142.mediawiki\n\nOn 2016-06-14 17:41, Daniel Weigl via bitcoin-dev wrote:\n> Hi List,\n> \n> Following up to the discussion last month ( https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012695.html ), ive prepared a proposal for a BIP here:\n> \t\n> \thttps://github.com/DanielWeigl/bips/blob/master/bip-p2sh-accounts.mediawiki\n> \n> \n> Any comments on it? Does anyone working on a BIP44 compliant wallet implement something different?\n> If there are no objection, id also like to request a number for it.\n> \n> Thx,\n> Daniel\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            }
        ],
        "thread_summary": {
            "title": "Derivation scheme for P2WPKH-nested-in-P2SH based accounts",
            "categories": [
                "bitcoin-dev",
                "cont'd"
            ],
            "authors": [
                "Daniel Weigl"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1900
        }
    },
    {
        "title": "[bitcoin-dev] Completing the retirement of the alert system",
        "thread_messages": [
            {
                "author": "Gregory Maxwell",
                "date": "2016-09-10T00:42:30",
                "message_text_only": "The alert system was a centralized facility to allow trusted parties\nto send messages to be displayed in wallet software (and, very early\non, actually remotely trigger the software to stop transacting).\n\nIt has been removed completely in Bitcoin Core after being disabled for a while.\n\nWhile the system had some potential uses, there were a number of\nproblems with it.\n\nThe alert system was a frequent source of misunderstanding about the\nsecurity model and 'effective governance', for example a years ago a\nBitcoinJ developer wanted it to be used to control fee levels on the\nnetwork and few months back one of Bloq's staff was pushing for a\nscheme where \"the developers\" would use it to remotely change the\ndifficulty-- apparently with no idea how abhorrent others would find\nit.\n\nThe system also had a problem of not being scalable to different\nsoftware vendors-- it didn't really make sense that core would have\nthat facility but armory had to do something different (nor would it\nreally make sense to constantly have to maintain some list of keys in\nthe node software).\n\nIt also had the problem of being unaccountable. No one can tell which\nof the key holders created a message. This creates a risk of misuse\nwith a false origin to attack someone's reputation.\n\nFinally, there is good reason to believe that the key has been\ncompromised-- It was provided to MTGox by a developer and MTGox's\nsystems' were compromised and later their CEO's equipment taken by the\nJapanese police.\n\nIn any case, it's gone now in Core and most other current software--\nand I think it's time to fully deactivate it.\n\nI've spent some time going around the internet looking for all\nsoftware that contains this key (which included a few altcoins) and\nasked them to remove it. I will continue to do that.\n\nOne of the facilities in the alert system is that you can send a\nmaximum sequence alert which cannot be overridden and displays only a\nstatic key compromise text message and blocks all other alerts. I plan\nto send a triggering alert in the not-distant future (exact time to be\nannounced well in advance) feedback on timing would be welcome.\n\nThere are likely a few production systems that automatically shut down\nwhen there is an alert, so this risks some small one-time disruption\nof those services-- but none worse than if an alert were sent to\nadvise about a new system upgrade.\n\nAt some point after that, I would then plan to disclose this private\nkey in public, eliminating any further potential of reputation attacks\nand diminishing the risk of misunderstanding the key as some special\ntrusted source of authority.\n\nCheers,"
            },
            {
                "author": "Eric Voskuil",
                "date": "2016-09-10T00:54:28",
                "message_text_only": "ACK\n\nlibbitcoin defines the message and includes the public key but only for completeness and reference purposes. It has never been used in the node.\n\ne\n\n> On Sep 9, 2016, at 5:42 PM, Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> The alert system was a centralized facility to allow trusted parties\n> to send messages to be displayed in wallet software (and, very early\n> on, actually remotely trigger the software to stop transacting).\n> \n> It has been removed completely in Bitcoin Core after being disabled for a while.\n> \n> While the system had some potential uses, there were a number of\n> problems with it.\n> \n> The alert system was a frequent source of misunderstanding about the\n> security model and 'effective governance', for example a years ago a\n> BitcoinJ developer wanted it to be used to control fee levels on the\n> network and few months back one of Bloq's staff was pushing for a\n> scheme where \"the developers\" would use it to remotely change the\n> difficulty-- apparently with no idea how abhorrent others would find\n> it.\n> \n> The system also had a problem of not being scalable to different\n> software vendors-- it didn't really make sense that core would have\n> that facility but armory had to do something different (nor would it\n> really make sense to constantly have to maintain some list of keys in\n> the node software).\n> \n> It also had the problem of being unaccountable. No one can tell which\n> of the key holders created a message. This creates a risk of misuse\n> with a false origin to attack someone's reputation.\n> \n> Finally, there is good reason to believe that the key has been\n> compromised-- It was provided to MTGox by a developer and MTGox's\n> systems' were compromised and later their CEO's equipment taken by the\n> Japanese police.\n> \n> In any case, it's gone now in Core and most other current software--\n> and I think it's time to fully deactivate it.\n> \n> I've spent some time going around the internet looking for all\n> software that contains this key (which included a few altcoins) and\n> asked them to remove it. I will continue to do that.\n> \n> One of the facilities in the alert system is that you can send a\n> maximum sequence alert which cannot be overridden and displays only a\n> static key compromise text message and blocks all other alerts. I plan\n> to send a triggering alert in the not-distant future (exact time to be\n> announced well in advance) feedback on timing would be welcome.\n> \n> There are likely a few production systems that automatically shut down\n> when there is an alert, so this risks some small one-time disruption\n> of those services-- but none worse than if an alert were sent to\n> advise about a new system upgrade.\n> \n> At some point after that, I would then plan to disclose this private\n> key in public, eliminating any further potential of reputation attacks\n> and diminishing the risk of misunderstanding the key as some special\n> trusted source of authority.\n> \n> Cheers,\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Peter Todd",
                "date": "2016-09-10T00:58:02",
                "message_text_only": "On Sat, Sep 10, 2016 at 12:42:30AM +0000, Gregory Maxwell via bitcoin-dev wrote:\n> The alert system was a centralized facility to allow trusted parties\n> to send messages to be displayed in wallet software (and, very early\n> on, actually remotely trigger the software to stop transacting).\n\n<snip>\n\n> One of the facilities in the alert system is that you can send a\n> maximum sequence alert which cannot be overridden and displays only a\n> static key compromise text message and blocks all other alerts. I plan\n> to send a triggering alert in the not-distant future (exact time to be\n> announced well in advance) feedback on timing would be welcome.\n> \n> There are likely a few production systems that automatically shut down\n> when there is an alert, so this risks some small one-time disruption\n> of those services-- but none worse than if an alert were sent to\n> advise about a new system upgrade.\n> \n> At some point after that, I would then plan to disclose this private\n> key in public, eliminating any further potential of reputation attacks\n> and diminishing the risk of misunderstanding the key as some special\n> trusted source of authority.\n\nACK\n\nGood to do this sooner rather than later, as alert propagation on the P2P\nnetwork is going to continue to get less reliable as nodes upgrade to software\nthat has removed alert functionality; better that the final alert key\nretirement message is reliably seen by the remaining software out there in a\npredictable way than this be something that happens unpredictably.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160910/972d0258/attachment.sig>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2016-09-10T01:48:40",
                "message_text_only": "On Sat, Sep 10, 2016 at 12:58 AM, Peter Todd <pete at petertodd.org> wrote:\n> Good to do this sooner rather than later, as alert propagation on the P2P\n> network is going to continue to get less reliable as nodes upgrade to software\n\nYes, this was one of my motivations for doing this soon.\n\nIt would only require about 2 LOC to have Bitcoin Core vomit out a\nblob containing the final alert to any old protocol version peers that\nconnect.  I don't know how other people would feel about that, but I\nwouldn't mind implementing it, and it would greatly improve the\nlikelihood that they continue to to get once propagation of it is\ngone. This could be left in the codebase for a couple years or until\nother changes made those old versions p2p incompatible for other\nreasons."
            },
            {
                "author": "Peter Todd",
                "date": "2016-09-10T02:19:06",
                "message_text_only": "On Sat, Sep 10, 2016 at 01:48:40AM +0000, Gregory Maxwell wrote:\n> On Sat, Sep 10, 2016 at 12:58 AM, Peter Todd <pete at petertodd.org> wrote:\n> > Good to do this sooner rather than later, as alert propagation on the P2P\n> > network is going to continue to get less reliable as nodes upgrade to software\n> \n> Yes, this was one of my motivations for doing this soon.\n> \n> It would only require about 2 LOC to have Bitcoin Core vomit out a\n> blob containing the final alert to any old protocol version peers that\n> connect.  I don't know how other people would feel about that, but I\n> wouldn't mind implementing it, and it would greatly improve the\n> likelihood that they continue to to get once propagation of it is\n> gone. This could be left in the codebase for a couple years or until\n> other changes made those old versions p2p incompatible for other\n> reasons.\n\nI think that's a good idea, and it's a simple way to document that final alert\nas well.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160910/3071c2e5/attachment.sig>"
            },
            {
                "author": "Andrew C",
                "date": "2016-09-10T01:31:16",
                "message_text_only": "ACK\n\nArmory used to contain code for handling these alerts but that was\nremoved after the PR removing alerts from Bitcoin Core was merged.\n\n\nOn 9/9/2016 8:42 PM, Gregory Maxwell via bitcoin-dev wrote:\n> The alert system was a centralized facility to allow trusted parties\n> to send messages to be displayed in wallet software (and, very early\n> on, actually remotely trigger the software to stop transacting).\n>\n> It has been removed completely in Bitcoin Core after being disabled for a while.\n>\n> While the system had some potential uses, there were a number of\n> problems with it.\n>\n> The alert system was a frequent source of misunderstanding about the\n> security model and 'effective governance', for example a years ago a\n> BitcoinJ developer wanted it to be used to control fee levels on the\n> network and few months back one of Bloq's staff was pushing for a\n> scheme where \"the developers\" would use it to remotely change the\n> difficulty-- apparently with no idea how abhorrent others would find\n> it.\n>\n> The system also had a problem of not being scalable to different\n> software vendors-- it didn't really make sense that core would have\n> that facility but armory had to do something different (nor would it\n> really make sense to constantly have to maintain some list of keys in\n> the node software).\n>\n> It also had the problem of being unaccountable. No one can tell which\n> of the key holders created a message. This creates a risk of misuse\n> with a false origin to attack someone's reputation.\n>\n> Finally, there is good reason to believe that the key has been\n> compromised-- It was provided to MTGox by a developer and MTGox's\n> systems' were compromised and later their CEO's equipment taken by the\n> Japanese police.\n>\n> In any case, it's gone now in Core and most other current software--\n> and I think it's time to fully deactivate it.\n>\n> I've spent some time going around the internet looking for all\n> software that contains this key (which included a few altcoins) and\n> asked them to remove it. I will continue to do that.\n>\n> One of the facilities in the alert system is that you can send a\n> maximum sequence alert which cannot be overridden and displays only a\n> static key compromise text message and blocks all other alerts. I plan\n> to send a triggering alert in the not-distant future (exact time to be\n> announced well in advance) feedback on timing would be welcome.\n>\n> There are likely a few production systems that automatically shut down\n> when there is an alert, so this risks some small one-time disruption\n> of those services-- but none worse than if an alert were sent to\n> advise about a new system upgrade.\n>\n> At some point after that, I would then plan to disclose this private\n> key in public, eliminating any further potential of reputation attacks\n> and diminishing the risk of misunderstanding the key as some special\n> trusted source of authority.\n>\n> Cheers,\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Wladimir J. van der Laan",
                "date": "2016-09-10T05:51:17",
                "message_text_only": "On Sat, Sep 10, 2016 at 12:42:30AM +0000, Gregory Maxwell via bitcoin-dev wrote:\n> The alert system was a centralized facility to allow trusted parties\n> to send messages to be displayed in wallet software (and, very early\n> on, actually remotely trigger the software to stop transacting).\n> \n> It has been removed completely in Bitcoin Core after being disabled for a while.\n\nAs it has been disabled in relevant software I think it's mostly symbolic at\nthis point, but yes, it makes sense to 'officially' retire the key. Let's\npin the date and make it widely known.\n\nDoing this in organized fashion is much better than the whodunit that would\nundoubtly follow when the key would simply leak, which could happen at any\ntime, as no one can know who it has spread to over all those years.\n\nRe: timing, I'd say leave three months grace time after this announcement for\naltcoins and such that may have accidentally have copied it to remove it, then\nat the beginning of 2017 broadcast the final alert.\n\nAfter that it's neutered, it's up to each of us that has the key to reveal it\nor not or when. It's a historical curiosity then.\n\nWladimir"
            },
            {
                "author": "Johnson Lau",
                "date": "2016-09-10T09:41:21",
                "message_text_only": "Concept ACK.\n\nFor the details of executing the plan, I think the following is less disruptive:\n\n1. Send a message with (max sequence - 1), notifying all nodes that the key will be retired on or before a date. People with systems relying on this key should either upgrade or ignore the revocation message. We don't know the actual date because the key is shared by many people.\n\nWith the max - 1 sequence, no message except the max sequence revocation message may override this message. \n\n2. Send the revocation message at the pre-announced time, if no one have done that before\n\n3. After a few months or so, publish the private key.\n\n >  \n > One of the facilities in the alert system is that you can send a \n > maximum sequence alert which cannot be overridden and displays only a \n > static key compromise text message and blocks all other alerts. I plan \n > to send a triggering alert in the not-distant future (exact time to be \n > announced well in advance) feedback on timing would be welcome. \n >  \n > There are likely a few production systems that automatically shut down \n > when there is an alert, so this risks some small one-time disruption \n > of those services-- but none worse than if an alert were sent to \n > advise about a new system upgrade. \n >  \n > At some point after that, I would then plan to disclose this private \n > key in public, eliminating any further potential of reputation attacks \n > and diminishing the risk of misunderstanding the key as some special \n > trusted source of authority. \n >  \n > Cheers, \n > _______________________________________________ \n > bitcoin-dev mailing list \n > bitcoin-dev at lists.linuxfoundation.org \n > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev \n >"
            },
            {
                "author": "Andrew C",
                "date": "2016-09-10T13:23:44",
                "message_text_only": "On 9/10/2016 5:41 AM, Johnson Lau via bitcoin-dev wrote:\n> 3. After a few months or so, publish the private key.\nWhy wait a few months? Why not just publish the key a few days after the\nfinal alert?"
            },
            {
                "author": "Johnson Lau",
                "date": "2016-09-10T14:57:35",
                "message_text_only": "We need to make sure the revocation message is widely distributed before making the private key public\n\n\n ---- On Sat, 10 Sep 2016 21:23:37 +0800 Andrew C <achow101 at gmail.com> wrote ---- \n > On 9/10/2016 5:41 AM, Johnson Lau via bitcoin-dev wrote: \n > > 3. After a few months or so, publish the private key. \n > Why wait a few months? Why not just publish the key a few days after the \n > final alert? \n >"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2016-09-10T15:36:38",
                "message_text_only": "On Sat, Sep 10, 2016 at 1:23 PM, Andrew C via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> On 9/10/2016 5:41 AM, Johnson Lau via bitcoin-dev wrote:\n>> 3. After a few months or so, publish the private key.\n> Why wait a few months? Why not just publish the key a few days after the\n> final alert?\n\nBecause if you were offline at the time of the final alert, the alert\nyou may see instead is \"Urgent security problem! Upgrade to\nUltraBitcoin NOW! http://scamsite.info/\", among other similar reasons."
            }
        ],
        "thread_summary": {
            "title": "Completing the retirement of the alert system",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Eric Voskuil",
                "Peter Todd",
                "Johnson Lau",
                "Andrew C",
                "Gregory Maxwell",
                "Wladimir J. van der Laan"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 16793
        }
    },
    {
        "title": "[bitcoin-dev] Proposed segwit related consensus and policy rules in Bitcoin Core 0.13.1",
        "thread_messages": [
            {
                "author": "Johnson Lau",
                "date": "2016-09-10T09:29:50",
                "message_text_only": "There are several opening pull requests for segwit related consensus and policy rules. This email summarize and explain the rationale.\n\nAs a general warning, people must not assume that a script spendable in pre-segwit system would also be spendable as a segwit script. They share much similarity but there are also notable differences, such as BIP143 and those proposals listed below. In any case, test your segwit system on testnet with the standard rules turned on, and a small amount of money after segwit is activated on mainnet.\n\n*******************\nScript Malleability fixes: Segwit (BIP141) fixes the most nasty malleability in Bitcoin: transaction ID malleability. However, due to the flexibility of scripting system, it is still possible for a relay node to insert arbitrary data to the witness without invalidating the transaction. Although segwit makes such attacks much harmless, this could still be annoying as people may write data to the blockchain at others costs.\n\nNULLDUMMY, MINIMALIF, NULLFAIL are fixing this type of problem. NULLDUMMY has been implemented as a policy for more than a year and a softfork is proposed in the upcoming 0.13.1. MINIMALIF and NULLFAIL are both new policy proposed for 0.13.1, and may become softforks in the future. Script designers must pay attention to these potential softforks to avoid creation of unspendable scripts.\n\nConsensus:\nBIP147 \"NULLDUMMY\" softfork (for both segwit and pre-segwit scripts)\nPR: https://github.com/bitcoin/bitcoin/pull/8636\nRelated discussion: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-September/013096.html\n\nPolicy:\n\"MINIMALIF\" Minimal OP_IF/NOTIF argument (segwit scripts only)\nPR: https://github.com/bitcoin/bitcoin/pull/8526\nRelated discussion: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-August/013014.html\n\nPolicy:\n\"NULLFAIL\" Null signature for failed CHECK(MULTI)SIG (for both segwit and pre-segwit scripts)\nPR: https://github.com/bitcoin/bitcoin/pull/8634\nRelated discussion: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-September/013098.html\n\n*******************\n\nPolicy: Resources limit for P2WSH\nPR: https://github.com/bitcoin/bitcoin/pull/8499\n\nFor P2WSH, a policy limit is proposed with witnessScript <= 3600 bytes, witness stack item size <= 80 bytes, and witness stack items <= 100\n\n3600 bytes witnessScript and 100 stack items are adequate for a n-of-100 multisig using 100 OP_CHECKSIG, 99 OP_ADD, and 1 OP_EQUAL. Before segwit, the biggest standard mutlisig is n-of-15 with P2SH.\n\nThe max size for ECDSA signature is 73 bytes and nothing (except hashing opcodes) should use more than that with the current scripting language.\n\nThis is to prevent abuse of witness space, and reduce the risks of DoS attack with some unknown special and big scripts.\n\nThe consensus limits described in BIP141 are not changed, as witnessScript <= 10000 bytes and  witness stack item size <= 520 bytes. (There is also an implied limit for witness stack items of 412, see the inline comments in #8499)\n\n*******************\n\nPolicy: Public key must be compressed (segwit only)\nPR: https://github.com/bitcoin/bitcoin/pull/8499\n\nIt is proposed that only compressed keys (33 bytes starting with 0x02 or 0x03) are allowed in segwit scripts.\n\nThis is a policy only and non-compressed keys are still valid in a block. A softfork based on this may be proposed with further risks and benefits analysis\n\nWe can't have such policy or softfork in non-segwit scripts since there are many UTXOs being stored that way. Since segwit is a completely new script system, there is no strong reasons to support non-compressed keys.\n\nWallet developers must pay attention to this policy and must not assume that existing P2PKH hashes or P2SH scripts are spendable in segwit.\n\nThe RPC command addwitnessaddress will refuse to return a segwit address if the given key/multi-sig is unknown or is not compressed.\n\ncreatewitnessaddress will return an address for whatever scripts given, without checking the validity at all. (even an OP_RETURN is provided, it will still return a P2WSH address). We may need to give a warning, or simply remove this command.\n\n*******************\n\nDoS protection: Banning peers for sending certain types of consensus invalid witness\nPR: https://github.com/bitcoin/bitcoin/pull/8499\n\nPeers sending certain types of invalid witness will be banned before fee and SigOp policy are checked. Those are all based on explicit or implicit consensus rules, and will protect P2WPKH and canonical multisigs against the DoS issues described in #8279. The rest of P2WSH scripts will be covered by #8525 by not storing witness txs in rejection cache.\n\n*******************\n\nDoS protection:  Mandatory softfork flags for segwit txs\nPR: https://github.com/bitcoin/bitcoin/pull/8499\n\nSince all segwit-aware nodes must be aware of all existing softforks, including BIP66, 65, 112, 141, and 143, the verification flags for these BIPs will be mandatory for transactions with non-empty witness.  Wallets relaying witness transactions violating these rules will be banned (even if the violation happens in a non-segwit input)."
            }
        ],
        "thread_summary": {
            "title": "Proposed segwit related consensus and policy rules in Bitcoin Core 0.13.1",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Johnson Lau"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5132
        }
    },
    {
        "title": "[bitcoin-dev] Simple tx ID malleability fix, opcode proposal: OP_TXHASHVERIFY",
        "thread_messages": [
            {
                "author": "Rune K. Svendsen",
                "date": "2016-09-17T20:45:17",
                "message_text_only": "I would really like to be able to create transactions that are immune to\ntransaction ID malleability now, so I have been thinking of the simplest\nsolution possible, in order to get a BIP through without too much trouble.\n\nAn opcode we could call OP_TXHASHVERIFY could be introduced. It would be\ndefined to work only if added to a scriptSig as the very first operation,\nand would abort if the hash of the transaction **with all OP_TXHASHVERIFY\noperations (including stack push) removed** does not match what has been\npushed on the stack.\n\nSo, in order to produce a transaction with one or more inputs protected\nagainst tx ID malleability, one would:\n\n1. Calculate tx ID of the tx: TX_HASH\n2. For each input you wish to protect, add \"0x32 $TX_HASH OP_TXHASHVERIFY\"\nto the beginning of the scriptSig\n\nWhen evaluating OP_TXHASHVERIFY, we make a copy of the tx in question, and\nremove the \"0x32 <32 bytes> OP_TXHASHVERIFY\" sequence from the beginning of\nall scriptSigs (if present), and abort if the tx copy hash does not match\nthe top stack item.\n\nThis is a very simple solution that only adds 34 bytes per input, and when\nsomething better becomes available (eg. Segwit), we will stop using this.\nBut in the meantime it's very valuable to be able to not worry about tx ID\nmalleability.\n\nPlease let me know what you think.\n\n\n\n            /Rune\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160917/3a30a98c/attachment.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2016-09-17T21:10:26",
                "message_text_only": "On Saturday, September 17, 2016 8:45:17 PM Rune K. Svendsen via bitcoin-dev \nwrote:\n> I would really like to be able to create transactions that are immune to\n> transaction ID malleability now, so I have been thinking of the simplest\n> solution possible, in order to get a BIP through without too much trouble.\n> \n> An opcode we could call OP_TXHASHVERIFY could be introduced. It would be\n> defined to work only if added to a scriptSig as the very first operation,\n> and would abort if the hash of the transaction **with all OP_TXHASHVERIFY\n> operations (including stack push) removed** does not match what has been\n> pushed on the stack.\n> \n> So, in order to produce a transaction with one or more inputs protected\n> against tx ID malleability, one would:\n> \n> 1. Calculate tx ID of the tx: TX_HASH\n> 2. For each input you wish to protect, add \"0x32 $TX_HASH OP_TXHASHVERIFY\"\n> to the beginning of the scriptSig\n> \n> When evaluating OP_TXHASHVERIFY, we make a copy of the tx in question, and\n> remove the \"0x32 <32 bytes> OP_TXHASHVERIFY\" sequence from the beginning of\n> all scriptSigs (if present), and abort if the tx copy hash does not match\n> the top stack item.\n> \n> This is a very simple solution that only adds 34 bytes per input, and when\n> something better becomes available (eg. Segwit), we will stop using this.\n> But in the meantime it's very valuable to be able to not worry about tx ID\n> malleability.\n> \n> Please let me know what you think.\n\nFirst of all, this is likely to be more trouble than segwit to deploy (mainly \njust because SegWit is already implemented and tested).\n\nSecondly, it wouldn't fix your problem: anyone malleating the transaction \nwould simply update the hash before this opcode...\n\nLuke"
            },
            {
                "author": "Rune K. Svendsen",
                "date": "2016-09-17T21:14:30",
                "message_text_only": "I hadn't thought of that... There is a solution, I think, but it makes the\noperation less simple.\n\nIf a transaction contains at least two OP_TXHASHVERIFY-protected inputs,\nsigned without ANYONECANPAY, their signatures would cover the other\ninput's OP_TXHASHVERIFY hash, right?\n\n\n            /Rune\n\n\nOn Sat, Sep 17, 2016 at 10:56 PM, Matt Corallo <lf-lists at mattcorallo.com>\nwrote:\n\n> (removing the list)\n>\n> Because the tx hash in your construction is not signed, someone wishing to\n> maleate a transaction may do so by also updating the hash in the scriptSig.\n>\n> Matt\n>\n> On September 17, 2016 4:45:17 PM EDT, \"Rune K. Svendsen via bitcoin-dev\" <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> I would really like to be able to create transactions that are immune to\n>> transaction ID malleability now, so I have been thinking of the simplest\n>> solution possible, in order to get a BIP through without too much trouble.\n>>\n>> An opcode we could call OP_TXHASHVERIFY could be introduced. It would be\n>> defined to work only if added to a scriptSig as the very first operation,\n>> and would abort if the hash of the transaction **with all OP_TXHASHVERIFY\n>> operations (including stack push) removed** does not match what has been\n>> pushed on the stack.\n>>\n>> So, in order to produce a transaction with one or more inputs protected\n>> against tx ID malleability, one would:\n>>\n>> 1. Calculate tx ID of the tx: TX_HASH\n>> 2. For each input you wish to protect, add \"0x32 $TX_HASH\n>> OP_TXHASHVERIFY\" to the beginning of the scriptSig\n>>\n>> When evaluating OP_TXHASHVERIFY, we make a copy of the tx in question,\n>> and remove the \"0x32 <32 bytes> OP_TXHASHVERIFY\" sequence from the\n>> beginning of all scriptSigs (if present), and abort if the tx copy hash\n>> does not match the top stack item.\n>>\n>> This is a very simple solution that only adds 34 bytes per input, and\n>> when something better becomes available (eg. Segwit), we will stop using\n>> this. But in the meantime it's very valuable to be able to not worry about\n>> tx ID malleability.\n>>\n>> Please let me know what you think.\n>>\n>>\n>>\n>>             /Rune\n>>\n>> ------------------------------\n>>\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160917/c90dd12a/attachment.html>"
            },
            {
                "author": "Nick ODell",
                "date": "2016-09-17T22:34:43",
                "message_text_only": "Then you have a new problem. Hash1 must contain Hash2 and the\ntransaction, but Hash2 must contain Hash1 and the transaction. A\ncircular dependency.\n\n--Nick\n\nOn Sat, Sep 17, 2016 at 3:14 PM, Rune K. Svendsen via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> I hadn't thought of that... There is a solution, I think, but it makes the\n> operation less simple.\n>\n> If a transaction contains at least two OP_TXHASHVERIFY-protected inputs,\n> signed without ANYONECANPAY, their signatures would cover the other input's\n> OP_TXHASHVERIFY hash, right?\n>\n>\n>             /Rune\n>\n>\n> On Sat, Sep 17, 2016 at 10:56 PM, Matt Corallo <lf-lists at mattcorallo.com>\n> wrote:\n>>\n>> (removing the list)\n>>\n>> Because the tx hash in your construction is not signed, someone wishing to\n>> maleate a transaction may do so by also updating the hash in the scriptSig.\n>>\n>> Matt\n>>\n>> On September 17, 2016 4:45:17 PM EDT, \"Rune K. Svendsen via bitcoin-dev\"\n>> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>> I would really like to be able to create transactions that are immune to\n>>> transaction ID malleability now, so I have been thinking of the simplest\n>>> solution possible, in order to get a BIP through without too much trouble.\n>>>\n>>> An opcode we could call OP_TXHASHVERIFY could be introduced. It would be\n>>> defined to work only if added to a scriptSig as the very first operation,\n>>> and would abort if the hash of the transaction **with all OP_TXHASHVERIFY\n>>> operations (including stack push) removed** does not match what has been\n>>> pushed on the stack.\n>>>\n>>> So, in order to produce a transaction with one or more inputs protected\n>>> against tx ID malleability, one would:\n>>>\n>>> 1. Calculate tx ID of the tx: TX_HASH\n>>> 2. For each input you wish to protect, add \"0x32 $TX_HASH\n>>> OP_TXHASHVERIFY\" to the beginning of the scriptSig\n>>>\n>>> When evaluating OP_TXHASHVERIFY, we make a copy of the tx in question,\n>>> and remove the \"0x32 <32 bytes> OP_TXHASHVERIFY\" sequence from the beginning\n>>> of all scriptSigs (if present), and abort if the tx copy hash does not match\n>>> the top stack item.\n>>>\n>>> This is a very simple solution that only adds 34 bytes per input, and\n>>> when something better becomes available (eg. Segwit), we will stop using\n>>> this. But in the meantime it's very valuable to be able to not worry about\n>>> tx ID malleability.\n>>>\n>>> Please let me know what you think.\n>>>\n>>>\n>>>\n>>>             /Rune\n>>>\n>>> ________________________________\n>>>\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            }
        ],
        "thread_summary": {
            "title": "Simple tx ID malleability fix, opcode proposal: OP_TXHASHVERIFY",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Nick ODell",
                "Luke Dashjr",
                "Rune K. Svendsen"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 8589
        }
    },
    {
        "title": "[bitcoin-dev] Interpreting nTime for the purpose of Bitcoin-attested timestamps",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2016-09-18T04:20:01",
                "message_text_only": "As part of my recent work(1) on OpenTimestamps I've been putting some thought\ntowards how to interpret the nTime fields in block headers, for the purpose of\ntimestamping. I'd like to get some peer review on the following scheme I've\ncome up with.\n\n\n# Motivation\n\nWe want to use the Bitcoin blockchain to provide evidence (the \"attestation\")\nthat a message M existed prior to some point in time T. Exactly how we do this\nis beyond the scope of this post, but suffice to say we show that some block\nheader b cryptographically commits to the message, e.g. via a commitment\noperation path proof, as implemented by OpenTimestamps.\n\nA valid timestamp is simply one where T is a point in time where the message\ndid in fact exist. Of course, if a timestamp for time T is valid, all\nsubsequent T+d are also valid; such timestamps are simply more conservative\nversions of the same statement.\n\nA naively approach - as is implemented by most (all?) existing Bitcoin\ntimestamping schemes - is to assume that the block header's nTime field was\nperfectly accurate, and thus M exists prior to the block's nTime. But that\ndoesn't take into account malicious miners, who may backdate their blocks.\n\n\n# Threat Model\n\nWe assume miners are divided into two categories:\n\n1) Dishonest Miners --- These miners are actively conspiring to create invalid\ntimestamps for time's prior to when the message existed. A dishonest miner will\nset the nTime field in blocks they create to the minimum possible value.\n\n2) Honest Miners --- These miners set nTime in blocks they create to\napproximately the current true time. An honest miner may use techniques such as\nnTime-rolling. Additionally, all honest miners may be simultaneously affected\nby systematic misconfigurations.\n\n\n## nTime Rolling\n\nPrior to BIP113, reducing a block's nTime from the work given by a pool by even\na second could easily render it invalid, as the pool may have included\nnLockTime'd transactions in the block. Thus hashing software was designed to\nonly roll nTime in the forward direction, not reverse, even though rolling\ncould be done in the reverse direction, up to the limit of the median-time-past\n+ 1.\n\nThe Stratum mining protocol doesn't even have a way to tell clients what the\nminimum allowed time is, just a single field, nTime, which is defined as \"the\ncurrent time\". Thus Stratum hashers will only ever increase nTime, which can\nnever result in an invalid timestamp if the original, unrolled, nTime would\nhave been a valid timestamp.\n\nThe getblocktemplate protocol does support telling hashers the minimum time via\nthe mintime field, which Bitcoin Core sets to the median-time-past. Regardless,\nit appears that the pools supporting GBT (Eligius) return a much tighter limit\non mintime than the median-time-past, just 180 seconds, and as of writing,\ndon't actually declare that the ntime field is mutable anyway.\n\nFrom an implementation point of view, relying on being able to roll nTime\nbackwards is unwise anyway, as the amount you can roll it back may be minimal\n(e.g. if multiple blocks were recently found).\n\nSince all miners have an incentive for time to move forward to keep difficulty\ndown it's reasonable to assume that the above observed behavior will continue,\nand nTime rolling in the reverse direction will be a minimal effect; we'll\nassume no miner rolls nTime backwards more than 1 hour.\n\n\n## Systematic Errors\n\n1) Botched daylight savings time changes --- While internal clocks should be\nunaffected by timezone changes, it's plausible that some kind of mistake\nrelated to daylight savings could result in the time being set incorrectly +- 1\nhour. For example, multiple large miners might manually set their clocks, based\non an incorrect understanding of what time it was.\n\n2) Broken NTP servers --- It's reasonable to assume that many miners are using\nNTP to set their clocks, and it's plausible that they're using the same NTP\nservers. Of course, a broken NTP server could return any time at all! The\nBitcoin protocol considers blocks to be valid if nTime is set up to 2 hours in\nthe future (from the perspective of the local node) so we'll say instead that\nwe expect systematic NTP errors to be corrected with high probability if\nthey're more than 2 hours in magnitude - more than that and the Bitcoin network\nis broken in a very visible way anyway.\n\nThus, we'll assume honest miners always create blocks with nTime greater than\nthe true time minus two hours, which accounts for both likely daylight savings\ntime misconfigurations, and likely NTP server misconfigurations. Additionally,\ntwo hours is greater than any expected effects from nTime rolling.\n\n\n# Proposed Algorithm\n\nFor a timestamp anchored at a block of height x we'll define the time T it\nrepresents as:\n\n    T = max(block[i].nTime for i in {x, ..., x + N-1}) + max_offset\n\nIn short, T is the maximum nTime out of the N blocks that confirmed the\ntimestamp, including first block that actually committed the timestamp;\nmax_offset is the maximum nTime offset we expect from a block created by an\nhonest miner, discussed above.\n\nThe dishonest miners can successfully create an invalid timestamp iff all N\nblocks are found by them; if any block is found by an honest miner, the nTime\nfield will be set correctly. Of course T may not be the minimum possible value,\nbut the timestamp will be at least valid.\n\nSo how big should N be? Let q be the ratio of dishonest miners to total hashing\npower. The probability that all N blocks are found by dishonest miners is q^N,\nand thus the probability P that at least one block is found by an honest miner\nis:\n\n    P = 1 - q^N  =>  N = log(1 - P)/log(q)\n\nIf the dishonest miners have q>0.5, the situation is hopeless, as they can\nreject blocks from honest miners entirely; the only limit on them setting nTime\nis the median-time-past rule, which only requires blocks timestamps to\nincrement by one second per block (steady state). Thus we'll assume q=0.5, the\nworst possible case where a Bitcoin timestamp can still be meaningful evidence:\n\n    P = 97%      => N = 5\n    P = 99%      => N = 7\n    P = 99.9%    => N = 10\n    P = 99.99%   => N = 14\n    P = 99.999%  => N = 17\n    P = 99.9999% => N = 20\n\nThe reliability for the higher N is higher than the actual reliability of\nBitcoin itself. On the other hand, there's no known instance where miners have\never created blocks with nTime's significantly less than true time on a wide\nscale; even in the well-known cases where the Bitcoin network has temporarily\nfailed due to forks, timestamps produced during those times would be valid, if\ndelayed by a few hours.\n\nSimilarly, if we assume a lower q, say a single \"rogue\" 20% mining pool, we\nget:\n\n    q = 0.20, P = 99.99% => N = 6\n\nAnother way to think about the choice of N is to compare its contribution to\nhow conservative the timestamp is - T as compared to the true time - to the\neffect of the max-honest-miner-offset we choose earlier. For example, 98% of\nthe time at least 6 blocks will be found within 2 hours, which means that if we\npick N=7, 98% of the time the conservatism added by N will be less than the\ncontribution of the max offset.\n\n\n# UI Considerations\n\nOne problem with the above algorithm is that it will frequently return\ntimestamps in the future, from the perspective of the user. A user who sees a\nmessage like the following at 2:00 pm, immediately after their timestamp\nconfirms, is understandably going to be confused:\n\n   Bitcoin: 99% chance that <f> existed prior to 4:00 pm, Jan 1st 2016\n\nA reasonable approach to this problem might just to refrain from displaying\ntimestamps at all until the local time is after the timestamp; the UI could\ndescribe the timestamp as \"Not yet confirmed\"\n\nIt may also be reasonable to round the timestamp up to the nearest day when\ndisplaying it. However what timezone to use is a tricky issue; people rarely\nexpect to see timezones specified alongside dates.\n\nOf course, in some cases a less conservative approach to interpreting the\ntimestamp is reasonable; those users however should be reading and\nunderstanding the calculations in this post!\n\n\n# References\n\n1) https://petertodd.org/2016/opentimestamps-announcement\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160918/4552f035/attachment-0001.sig>"
            },
            {
                "author": "Tom Harding",
                "date": "2016-09-19T16:13:40",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n \nOn 9/17/2016 9:20 PM, Peter Todd via bitcoin-dev wrote:\n> The probability that all N blocks are found by dishonest miners is q^N,\n\nThat's the probability that dishonest miners find N blocks in a row\nimmediately.  What you want is the probability that they can build a\nchain N blocks long, taking the random-walk into account.\n\nSo use Satoshi's formula from bitcoin.pdf, section 11.  The results are\nremarkably different.  In particular, q=.5 is totally insecure, since\nfor any N, both factions are guaranteed to eventually possess a chain of\nlength N anchored at x at some point during the wild reorg melee.\n\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n \niQIcBAEBAgAGBQJX4A60AAoJEG/AI00/Ca/qLmEP/0fg+XJQNexTTrS/aPqcIY00\nKStPNIruJD4QA9zgyx4K3fCst85/L9rsmv/9Xo6tyn8oneAMjjVY57mTG3smhiXA\nQfu9/tG0AHneRxEpRNDA/x4IwCrr1xACOaO26gEqs9zVIszIVQq4z3Vc54gj39VD\n9Jpc0653RVqHhJFT4ozZkAzg2CcPMHOxi45ufBtScaJO2AwtcLvtVYaC1BE9itDM\nwDdAS175jq+LlV20Igaf/s4Cc9G3LWnrNqzVCPBr/ua4U60ZO+r3nLr9gYtYNR0H\n37xgktNZA8D/YI8gjYZ5p11bIqCs4lRyI5LP3Rvh/+5zQu4hdi25HMoUMys/lw4c\nABuUVLaCa2r7pH7QczUx4jWJslaHlZ4M6tMUJ7bGZpVcPmA8FOk0j+DLTfUmYVYi\nEqc5cf2Z+PEc9kBmvsxQ351WjT7fq3OtZCcMH5dhpGv4NMuVBwQ38Dh3Pz8rhBPe\npIXMUPkmdWdczjoACpjOHbhYffCI7zCvsypydnImF7FReohWPFSKdaeoSHxotHzb\ncy2EWZS2IM009qY3+jF1j3uj4bJfPSlgLgfUE23Bmvsp9PJi9W+FARbKJKxr6HaB\nvvMg6rMfU8uWElQqz19ixI55PUDmtugwXccyWvhcr0ueN1P6fpNxF36Q9zwS6/+D\n4orUC+rp1yNTeddvaYDv\n=HS6r\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Peter Todd",
                "date": "2016-09-19T17:56:15",
                "message_text_only": "On Mon, Sep 19, 2016 at 09:13:40AM -0700, Tom Harding via bitcoin-dev wrote:\n> \n> On 9/17/2016 9:20 PM, Peter Todd via bitcoin-dev wrote:\n> > The probability that all N blocks are found by dishonest miners is q^N,\n> \n> That's the probability that dishonest miners find N blocks in a row\n> immediately.  What you want is the probability that they can build a\n> chain N blocks long, taking the random-walk into account.\n> \n> So use Satoshi's formula from bitcoin.pdf, section 11.  The results are\n> remarkably different.  In particular, q=.5 is totally insecure, since\n> for any N, both factions are guaranteed to eventually possess a chain of\n> length N anchored at x at some point during the wild reorg melee.\n\nAh! That's a good point; my analysis only applies to the case where you're\nassuming the dishonest miners aren't willing to lose revenue from the attack by\nmining a less-work chain with blocks that won't end up in the main chain. I\nshould state that assumption more clearly.\n\nIf the dishonest miners are willing to spend money to create an invalid\ntimestamp the analysis is quite different. In OpenTimestamps a timestamp\ndoesn't contain the actual block headers - just a block height - so verifiers\nare expected to have a working Bitcoin node. If that Bitcoin node is in sync\nwith the most-work work chain there's no risk: the blocks created by the\ndishonest miners won't be part of the most-work chain, and validation of the\ntimestamp will fail.\n\nIn the case where the verifier is not in sync with the most-work chain, an\nattacker can sybil attack the verifier's node and cause them to think that the\nblocks committing the invalid timestamp are in fact the most-work chain. This\ncase is no different than a payee being sybil attacked, so we can use the same\nanalysis we would in that circumstance.\n\nThis also means that timestamps definitely shouldn't contain the block headers\nof the blocks allegedly confirming them - that's an extremely weak proof given\nthe relative ease of creating a block, particularly when you take into account\nthat the same block could be used to create an unlimited number of fake\ntimestamps. OpenTimestamps doesn't do this, but it wouldn't hurt to make this\npoint 100% clear.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160919/13014793/attachment.sig>"
            },
            {
                "author": "Tom Harding",
                "date": "2016-09-19T19:53:46",
                "message_text_only": "On 9/19/2016 10:56 AM, Peter Todd wrote:\n> I should state that assumption more clearly.\n\nGlad to get you thinking, and I need to change my suggestion.  The\ncatch-up formula is not applicable because it doesn't limit how long the\ndishonest miners have to catch up.\n\nInstead you want the probability that the honest miners can build a\nchain N blocks long before the dishonest miners do the same, which is\n\nCDF[Erlang(N, q) - Erlang(N, 1 - q), 0]\n\nI have some apparatus for doing this numerically without simulation if\nyou're interested.\n\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160919/8277554b/attachment.sig>"
            },
            {
                "author": "Peter Todd",
                "date": "2016-09-18T16:05:24",
                "message_text_only": "On Sun, Sep 18, 2016 at 03:45:40PM +0200, Jannes Faber wrote:\n> Would you not also have to consider (all) earlier blocks?\n> \n> T = max(block[i].nTime for i in {x-100, ..., x, ..., x + N-1}) + max_offset\n> \n> In case one or more previous blocks have an nTime considerably in the\n> future and blocks>= x have honest nTimes (or before true time).\n> \n> Maybe not strictly for the goal you were describing here (conservative\n> estimate) but rather to prevent distinct timestamp events seeming to have\n> happened in the wrong order?\n\nWell that's the thing: timestamps are simply proofs that something existed\nprior to some time, nothing more, nothing less.\n\nSo it doesn't make sense for there to be any notion of the \"wrong order\" in a\ntimestamp proof; the proof either is or is not valid, but that has nothing to\ndo with other proofs. Additionally, the architecture of OpenTimestamps doesn't\nand can't make any 100% guarantees about the apparent order of timestamps,\nbecause it's always possible for an earlier timestamp to end up committed in\nthe blockchain after a later timestamp gets committed. It's not all that likely\nof an event, but it is possible.\n\nIf you don't want that to be possible, you're going to need a dedicated chain\nof transactions for your particular purpose, which adds a lot of complexity,\ncost, and makes it much harder to achieve the same level of availability for\nthe service as a whole.\n\nRemember that for many use-cases the user experience is that there's two or\nmore claimed dates, and OpenTimestamps simply verifies that those dates are\nplausible. Take for example, timestamped git commits:\n\n    commit 536411e73b8c23dc2fdfd78052c893f578444926\n    ots: Got 2 attestation(s) from cache\n    ots: Success! Bitcoin attests data existed as of Thu Sep 15 01:07:08 2016 EDT\n    ots: Good timestamp\n    gpg: Signature made Thu 15 Sep 2016 12:10:25 AM EDT\n    gpg:                using RSA key 6399011044E8AFB2\n    gpg: Good signature from \"Peter Todd <pete at petertodd.org>\"\n    gpg:                 aka \"[jpeg image of size 5220]\"\n    Author: Peter Todd <pete at petertodd.org>\n    Date:   Thu Sep 15 00:10:20 2016 -0400\n\n        Release v0.2.0\n\nHere we have the date on the git commit, another date a few seconds later for\nthe PGP signature, and a third date an hour later for the Bitcoin timestamp,\nattesting to the fact that the two other dates for that one git commit are\nplausible.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160918/c8314fe2/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Interpreting nTime for the purpose of Bitcoin-attested timestamps",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tom Harding",
                "Peter Todd"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 16064
        }
    },
    {
        "title": "[bitcoin-dev] Requesting BIP assignment; Flexible Transactions.",
        "thread_messages": [
            {
                "author": "Tom",
                "date": "2016-09-20T17:15:45",
                "message_text_only": "As the title suggests, I would like to formally request the assignment of a \nBIP number for my FT spec.\n\nThank you!\n\n\nSource; \n\nhttps://github.com/zander/bips/blob/FlexTrans/bip-9999.mediawiki\n\n<pre>\n  BIP: ??\n  Title: Flexible Transactions\n  Author: Tom Zander <tomz at freedommail.ch>\n  Status: Draft\n  Type: Standards Track\n  Created: 2016-07-27\n</pre>\n\n==Abstract==\n\nThis BIP describes the next step in making Bitcoin's most basic element,\nthe transaction, more flexible and easier to extend. At the same time this\nfixes all known cases of malleability and resolves significant amounts of\ntechnical debt.\n\n==Summary==\n\nFlexible Transactions uses the fact that the first 4 bytes in a transaction\ndetermine the version and that the majority of the clients use a\nnon-consensus rule (a policy) to not accept transaction version numbers\nother than those specifically defined by Bitcoin.\nThis BIP chooses a new version number, 4, and defines that the data\nfollowing the bytes for the version is in a format called Compact Message\nFormat (CMF). CMF is a flexible, token based format where each token is a\ncombination of a name, a format and a value. Because the name is added we\ncan skip unused tokens and we can freely add new tokens in a simple manner\nin future. Soft fork upgrades will become much easier and cleaner this\nway.\n\nThis protocol upgrade cleans up past soft fork changes like BIP68 which\nreuse existing fields and do them in a much better to maintain and easier\nto parse system. It creates the building blocks to allow new features to be\nadded much cleaner in the future.\n\nIt also shows to be possible to remove signatures from transactions with\nminimal upgrades of software and still maintain a coherent transaction\nhistory. Tests show that this can reduce space usage to about 75%.\n\n==Motivation==\n\nToken based file-formats are not new, systems like XML and HTMl use a\nsimilar system to allow future growth and they have been quite successful\nfor decades in part because of this property.\n\nBitcoin needs a similar way of making the transaction future-proof because\nre-purposing not used fields for new features is not good for creating\nmaintainable code.\n\nNext to that this protocol upgrade will re-order the data-fields which\nallows us to cleanly fix the malleability issue which means that future\ntechnologies like Lightning Network will depend on this BIP being deployed.\n\nAt the same time, due to this re-ordering of data fields, it becomes very\neasy to remove signatures from a transaction without breaking its tx-id,\nwhich is great for future pruning features.\n\n\n=== Tokens ===\n\nIn the compact message format we define tokens and in this specification we\ndefine how these tokens are named, where they can be placed and which are\noptional.  To refer to XML, this specification would be the schema of\na transaction.\n\nCMF tokens are triplets of name, format (like PositiveInteger) and value.\nNames in this scope are defined much like an enumeration where the actual\ninteger value (id, below) is equally important to the written name.\nIf any token found that is not covered in the next table will make the\ntransaction that contains it invalid.\n\n{| class=\"wikitable\"\n|-\n! Name !! id !! Format !! Default Value !! Description\n|-\n|TxEnd         ||  0 ||BoolTrue ||  Required    ||A marker that is the last \nbyte in the txid calculation\n|-\n|TxInPrevHash  ||  1 ||ByteArray||  Required    ||TxId we are spending\n|-\n|TxPrevIndex   ||  2 ||Integer  ||      0       ||Index in prev tx we are \nspending (applied to previous TxInPrevHash)\n|-\n|TxInScript    ||  3 ||ByteArray||  Required    ||The 'input' part of the \nscript\n|-\n|TxOutValue    ||  4 ||Integer  ||  Required    ||Amount of satoshi to \ntransfer\n|-\n|TxOutScript   ||  5 ||ByteArray||  Required    ||The 'output' part of the \nscript\n|-\n|LockByBlock   ||  6 ||Integer  ||  Optional    ||BIP68 replacement\n|-\n|LockByTime    ||  7 ||Integer  ||  Optional    ||BIP68 replacement\n|-\n|ScriptVersion ||  8 ||Integer  ||      2       ||Defines script version for \noutputs following\n|-\n|NOP_1x        || 1x || . ||  Optional    ||Values that will be ignored by \nanyone parsing the transaction\n|}\n\n\n=== Scripting changes ===\n\nIn the current version of Bitcoin-script, version 1, there are various\nopcodes that are used to validate the cryptographic proofs that users have\nto provide in order to spend outputs.\n\nThe OP_CHECKSIG is the most well known and, as its name implies, it\nvalidates a signature.\nIn the new version of 'script' (version 2) the data that is signed is\nchanged to be equivalent to the transaction-id. This is a massive\nsimplification and also the only change between version 1 and version 2 of\nscript.\n\n=== Serialization order===\n\nThe tokens defined above have to be serialized in a certain order for the\ntransaction to be well-formatted.  Not serializing transactions in the\norder specified would allow multiple interpretations of the data which\ncan't be allowed.\nThere is still some flexibility and for that reason it is important for\nimplementors to remember that the actual serialized data is used for the\ncalculation of the transaction-id. Reading and writing it may give you a\ndifferent output and when the txid changes, the signatures will break.\n\nAt a macro-level the transaction has these segments. The order of the\nsegments can not be changed, but you can skip segments.\n\n{| class=\"wikitable\"\n!Segment !! Description\n|-\n|   Inputs   || Details about inputs.\n|-\n|  Outputs   || Details and scripts for outputs\n|-\n| Additional || For future expansion\n|-\n| Signatures || The scripts for the inputs\n|-\n|   TxEnd    || End of the transaction\n|}\n\nThe TxId is calculated by taking the serialized transaction without the\nSignatures and the TxEnd and hashing that.\n\n\n{| class=\"wikitable\"\n!Segment !! Tags !! Description\n|-\n|Inputs||TxInPrevHash and TxInPrevIndex||Index can be skipped, but in any \ninput the PrevHash always has to come first\n|-\n|Outputs||TxOutScript, TxOutValue||Order is not relevant\n|-\n|Additional||LockByBlock  LockByTime NOP_1x\n|-\n|Signatures||TxInScript||Exactly the same amount as there are inputs\n|-\n|TxEnd||TxEnd\n|}\n\nTxEnd is there to allow a parser to know when one transaction in a stream\nhas ended, allowing the next to be parsed.\n\nNotice that the token ScriptVersion is currently not allowed because we\ndon't have any valid value to give it. But if we introduce a new script\nversion it would be placed in the outputs segment.\n\n=== Script v2 ===\n\nThe default value of ScriptVersion is number 2, as opposed to the version 1\nof script that the is in use today.  The version 2 is mostly identical\nto version one, including upgrades made to it over the years and in the \nfuture. The only exception is that the OP_CHECKSIG is made dramatically\nsimpler.  The input-type for OP_CHECKSIG is now no longer configurable, it is\nalways '1' and the content that will be signed is the txid.\n\nTODO: does check-multisig need its own mention?\n\n\n=== Block-malleability ===\n\nThe effect of leaving the signatures out of the calculation of the\ntransaction-id implies that the signatures are also not used for the\ncalculation of the merkle tree.  This means that changes in signatures\nwould not be detectable. Except naturally by the fact that missing or\nbroken signatures breaks full validation. But it is important to detect\nmodifications to such signatures outside of validating all transactions.\n\nFor this reason the merkle tree is extended to include (append) the hash of\nthe v4 transactions (and those alone) where the hash is taken over a\ndata-blob that is build up from:\n\n1. the tx-id\n2. the CMF-tokens 'TxInScript'\n\n\n=== Future extensibility ===\n\nThe NOP_1x wildcard used in the table explaining tokens is actually a list\nof 10 values that currently are specified as NOP (no-operation) tags.\n\nAny implementation that supports the v4 transaction format should ignore\nthis field in a transaction. Interpreting and using the transaction as if\nthat field was not present at all.\n\nFuture software may use these fields to decorate a transaction with\nadditional data or features. Transaction generating software should not\ntrivially use these tokens for their own usage without cooperation and\ncommunication with the rest of the Bitcoin ecosystem as miners certainly\nhave the option to reject transactions that use unknown-to-them tokens.\n\n\n==Reference Implementation==\n\nBitcoin Classic includes this in its beta releases and a reference\nimplementation can be found at;\n\nhttps://github.com/bitcoinclassic/bitcoinclassic/pull/186\n\n\n==Deployment==\n\nTo be determined\n\n==References==\n\n[https://github.com/bitcoinclassic/documentation/blob/master/spec/compactmessageformat.md] \nCMF"
            },
            {
                "author": "Luke Dashjr",
                "date": "2016-09-20T21:31:47",
                "message_text_only": "On Tuesday, September 20, 2016 5:15:45 PM Tom via bitcoin-dev wrote:\n> As the title suggests, I would like to formally request the assignment of a\n> BIP number for my FT spec.\n\nPlease open a pull request on the bitcoin/bips repo after this has been \ndiscussed a bit on the ML.\n\nNote that at least a basic backwards compatibility section is required for \nassignment, especially since this appears to be a hard-fork proposal (if it is \nmeant as a soft-fork, please explain how that would work).\n\n> ==Motivation==\n> \n> Token based file-formats are not new, systems like XML and HTMl use a\n> similar system to allow future growth and they have been quite successful\n> for decades in part because of this property.\n\nThere is already a binary-safe format called EBML. Why not use that as the \nbasis for this BIP?\n\n> Next to that this protocol upgrade will re-order the data-fields which\n> allows us to cleanly fix the malleability issue which means that future\n> technologies like Lightning Network will depend on this BIP being deployed.\n\nNote this won't fix malleability entirely, only third-party malleability (much \nlike segwit). The sender can always modify the transaction with more \ninputs/outputs.\n\n> |TxEnd         ||  0 ||BoolTrue ||  Required    ||A marker that is the last\n> byte in the txid calculation\n\nThe last byte in the txid calculation, or the last byte of the entire \ntransaction?\n\nIt seems from the later comments, that it is the end of the transaction as a \nwhole. Yet a separator between the txid and non-txid data would probably be \nvaluable, rather than hard-coding txid to skip signature types (which may be \nunknown to old nodes, when extended).\n\n> The OP_CHECKSIG is the most well known and, as its name implies, it\n> validates a signature.\n> In the new version of 'script' (version 2) the data that is signed is\n> changed to be equivalent to the transaction-id. This is a massive\n> simplification and also the only change between version 1 and version 2 of\n> script.\n\nThis seems to be a major regression. What is the replacement for \nSIGHASH_SINGLE and SIGHASH_ANYONECANPAY?\n\nWhen revising OP_CHECKSIG, it would also be nice to add the ability to use \n*only* a hash of the prevout's scriptPubKey in the input, so that *when* the \nprevtx is malleated, the spending one remains valid. (This use case is \ncurrently not supported.)\n\n> === Serialization order===\n> \n> The tokens defined above have to be serialized in a certain order for the\n> transaction to be well-formatted.  Not serializing transactions in the\n> order specified would allow multiple interpretations of the data which\n> can't be allowed.\n\nWhat happens if nodes encounter a different order in a block?\n\n> Notice that the token ScriptVersion is currently not allowed because we\n> don't have any valid value to give it. But if we introduce a new script\n> version it would be placed in the outputs segment.\n\nWhat happens if I put ScriptVersion=1 here?\n\n> === Script v2 ===\n> \n> TODO: does check-multisig need its own mention?\n\nDoes multisig still require a dummy item on the stack?\n\n> === Block-malleability ===\n> \n> For this reason the merkle tree is extended to include (append) the hash of\n> the v4 transactions (and those alone) where the hash is taken over a\n> data-blob that is build up from:\n\nHow should nodes know where in the merkle-tree the txids end, and the v4hashes \nbegin?\n\nLuke"
            },
            {
                "author": "Tom",
                "date": "2016-09-21T09:32:30",
                "message_text_only": "On Tuesday 20 Sep 2016 21:31:47 Luke Dashjr wrote:\n> On Tuesday, September 20, 2016 5:15:45 PM Tom via bitcoin-dev wrote:\n> > As the title suggests, I would like to formally request the assignment of\n> > a\n> > BIP number for my FT spec.\n> \n> Please open a pull request on the bitcoin/bips repo after this has been\n> discussed a bit on the ML.\n\n> It seems from the later comments, that it is the end of the transaction as a\n> whole. Yet a separator between the txid and non-txid data would probably be\n> valuable, rather than hard-coding txid to skip signature types (which may\n> be unknown to old nodes, when extended).\n> \n> > The OP_CHECKSIG is the most well known and, as its name implies, it\n> > validates a signature.\n> > In the new version of 'script' (version 2) the data that is signed is\n> > changed to be equivalent to the transaction-id. This is a massive\n> > simplification and also the only change between version 1 and version 2 of\n> > script.\n> \n> This seems to be a major regression. What is the replacement for\n> SIGHASH_SINGLE and SIGHASH_ANYONECANPAY?\n\nHow is this a regression? Can you explain what functionality is lost please?\n\n> When revising OP_CHECKSIG, it would also be nice to add the ability to use\n> *only* a hash of the prevout's scriptPubKey in the input, so that *when* the\n> prevtx is malleated, the spending one remains valid. (This use case is\n> currently not supported.)\n\nMaybe for the next version of script :)\n \n> > Notice that the token ScriptVersion is currently not allowed\n> What happens if I put ScriptVersion=1 here?\n\nThe transaction is invalid...\n \n> > === Block-malleability ===\n> > \n> > For this reason the merkle tree is extended to include (append) the hash\n> > of\n> > the v4 transactions (and those alone) where the hash is taken over a\n> \n> > data-blob that is build up from:\n>\n> How should nodes know where in the merkle-tree the txids end, and the\n> v4hashes begin?\n\nBecause the txid based ones are not going away. So the number of transactions \nin the block can be used to determine when the pure tx-id segment stops and \nwhen the v4 hashes begin.  Then its up to the client to rebuild the tree from \nthat list based on the larger input set to get the same root-node.\n\nI clarified many little things on my clone of the bips, check there if you \nwant to see the details."
            },
            {
                "author": "Peter Todd",
                "date": "2016-09-20T21:56:44",
                "message_text_only": "On Tue, Sep 20, 2016 at 07:15:45PM +0200, Tom via bitcoin-dev wrote:\n> === Serialization order===\n> \n> The tokens defined above have to be serialized in a certain order for the\n> transaction to be well-formatted.  Not serializing transactions in the\n> order specified would allow multiple interpretations of the data which\n> can't be allowed.\n\nIf the order of the tokens is fixed, the tokens themselves are redundant\ninformation when tokens are required; when tokens may be omitted, a simple\n\"Some/None\" flag to mark whether or not the optional data has been omitted is\nappropriate.\n\n\nAlso, if you're going to break compatibility with all existing software, it\nmakes sense to use a format that extends the merkle tree down into the\ntransaction inputs and outputs.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160920/04780272/attachment.sig>"
            },
            {
                "author": "Tom",
                "date": "2016-09-21T09:32:33",
                "message_text_only": "Thanks for your email Peter!\n\nOn Tuesday 20 Sep 2016 17:56:44 Peter Todd wrote:\n> On Tue, Sep 20, 2016 at 07:15:45PM +0200, Tom via bitcoin-dev wrote:\n> > === Serialization order===\n> > \n> > The tokens defined above have to be serialized in a certain order for the\n> > transaction to be well-formatted.  Not serializing transactions in the\n> > order specified would allow multiple interpretations of the data which\n> > can't be allowed.\n> \n> If the order of the tokens is fixed, the tokens themselves are redundant\n> information when tokens are required; when tokens may be omitted, a simple\n> \"Some/None\" flag to mark whether or not the optional data has been omitted\n> is appropriate.\n\nThis is addressed in the spec; \nhttps://github.com/bitcoinclassic/documentation/blob/master/spec/transactionv4.md\n\n\u00abThe way towards that flexibility is to use a generic concept made popular\nvarious decades ago with the XML format. The idea is that we give each\nfield a name and this means that new fields can be added or optional fields\ncan be omitted from individual transactions\u00bb\n\n\n> Also, if you're going to break compatibility with all existing software, it\n> makes sense to use a format that extends the merkle tree down into the\n> transaction inputs and outputs.\n\nPlease argue your case.\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: This is a digitally signed message part.\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160921/613bee38/attachment-0001.sig>"
            },
            {
                "author": "Peter Todd",
                "date": "2016-09-22T18:26:18",
                "message_text_only": "On Wed, Sep 21, 2016 at 11:32:33AM +0200, Tom wrote:\n> Thanks for your email Peter!\n> \n> On Tuesday 20 Sep 2016 17:56:44 Peter Todd wrote:\n> > On Tue, Sep 20, 2016 at 07:15:45PM +0200, Tom via bitcoin-dev wrote:\n> > > === Serialization order===\n> > > \n> > > The tokens defined above have to be serialized in a certain order for the\n> > > transaction to be well-formatted.  Not serializing transactions in the\n> > > order specified would allow multiple interpretations of the data which\n> > > can't be allowed.\n> > \n> > If the order of the tokens is fixed, the tokens themselves are redundant\n> > information when tokens are required; when tokens may be omitted, a simple\n> > \"Some/None\" flag to mark whether or not the optional data has been omitted\n> > is appropriate.\n> \n> This is addressed in the spec; \n> https://github.com/bitcoinclassic/documentation/blob/master/spec/transactionv4.md\n> \n> \u00abThe way towards that flexibility is to use a generic concept made popular\n> various decades ago with the XML format. The idea is that we give each\n> field a name and this means that new fields can be added or optional fields\n> can be omitted from individual transactions\u00bb\n\nThat argument is not applicable to required fields: the code to get the fields\nfrom the extensible format is every bit as complex as the very simple code\nrequired to deserialize/serialize objects in the current system.\n\nIn any case your BIP needs to give some explicit examples of hypothetical\nupgrades in the future, how they'd take advantage of this, and what the code to\ndo so would look like.\n\n> > Also, if you're going to break compatibility with all existing software, it\n> > makes sense to use a format that extends the merkle tree down into the\n> > transaction inputs and outputs.\n> \n> Please argue your case.\n\nSee my arguments re: segwit a few months ago, e.g. the hardware wallet txin\nproof use-case.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160922/00bc0bdd/attachment.sig>"
            },
            {
                "author": "Tom",
                "date": "2016-09-22T18:47:50",
                "message_text_only": "On Thursday, 22 September 2016 14:26:18 CEST Peter Todd wrote:\n> > \u00abThe way towards that flexibility is to use a generic concept made\n> > popular various decades ago with the XML format. The idea is that we\n> > give each field a name and this means that new fields can be added or\n> > optional fields can be omitted from individual transactions\u00bb\n> \n> That argument is not applicable to required fields: \n\nThe argument that optional fields can be omitted is not applicable to \nrequired fields, you are correct. That should be rather obvious because \nrequired fields are not optional fields.\n\n> the code to get the\n> fields from the extensible format is every bit as complex as the very\n> simple code required to deserialize/serialize objects in the current\n> system.\n\nProbably a tiny bit more complex as the current format assumes a lot more.\n\nYou may have misread my email because there was no argument made towards \ncomplexity. The argument was towards flexibility.\n\n> In any case your BIP needs to give some explicit examples of hypothetical\n> upgrades in the future, how they'd take advantage of this, and what the\n> code to do so would look like.\n\nWhy?\n\n> > > Also, if you're going to break compatibility with all existing\n> > > software, it makes sense to use a format that extends the merkle\n> > > tree down into the transaction inputs and outputs.\n> > \n> > Please argue your case.\n> \n> See my arguments re: segwit a few months ago, e.g. the hardware wallet\n> txin proof use-case.\n\nPlease consider that I'm not going to search for something based on a vague \nreference like that, if you want to convince me you could you at least \nprovide a URL?\nYou want me to see the value of your idea, I think you should at least \nprovide the argument. Isn't that fair?\n\nThanks for your email Peter, would love you to put a bit more time into \nunderstanding flexible transactions and we can have a proper discussion \nabout it."
            },
            {
                "author": "Andreas Schildbach",
                "date": "2016-09-21T12:00:23",
                "message_text_only": "Just glancing over your BIP, I wonder if we should use Protobuf. It uses\nthis \"flexible\" format already and is quite compact/binary. We use\nProtobuf already for the payment protocol, and there is very good tool\nsupport."
            },
            {
                "author": "Tom",
                "date": "2016-09-21T12:58:02",
                "message_text_only": "On Wednesday 21 Sep 2016 14:00:23 Andreas Schildbach via bitcoin-dev wrote:\n> Just glancing over your BIP, I wonder if we should use Protobuf. It uses\n> this \"flexible\" format already and is quite compact/binary. We use\n> Protobuf already for the payment protocol, and there is very good tool\n> support.\n\nThere is a lot of overlap between different binary formats. Looking through \nthe on-the-wire protocol you'll see that my spec is very similar. Practically \nall the advantages of protobuf are present in CMF. I can write you a java \nparser if you want, it should be easy to port from Qt/C++ code :)\nhttps://github.com/bitcoinclassic/transactions\n\nCMF: \nhttps://github.com/bitcoinclassic/documentation/blob/master/spec/compactmessageformat.md\n\nThere is no tool support needed, just one or two classes. Which personally I \nthink is an advantage.\n\n\nSome advantages of CMF over protobuf from the top of my head;\n\n* It reuses the var-int parsing that Bitcoin uses (which is itself slightly \ndifferent from others).\n\n* zero-copy support (not relevant for this bip, though).\n\n* Additional values addition (i.e. adding new data) is .. tricky in protobuf.\nhttps://developers.google.com/protocol-buffers/docs/proto#updating\n\n* In my experience parsing a message manually (like a SOX parser) is much \nbetter in reporting errors and detecting wrong usages than auto-generated code \n(but personally I'm not much a fan of auto-generated APIs) at all...\n\n* Generated parsing/writing code will not be as fast as we can make it.\n\n* CMF is more compact (uses less bytes) for its messages.\n\n\nProtobuf is something I've used before and I think we can do better. I think \nthat CMF together with some support classes can do this better."
            },
            {
                "author": "Gregory Maxwell",
                "date": "2016-09-21T18:01:30",
                "message_text_only": "On Tue, Sep 20, 2016 at 5:15 PM, Tom via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> BIP number for my FT spec.\n\nThis document does not appear to be concretely specified enough to\nreview or implement from it.\n\nFor example, it does not specify the serialization of \"integer\" (is it\na 32 bit word in network byte order or?) nor does it specify how the\npresence of the optional fields are signaled nor the cardinality of\nthe inputs or outputs. For clearly variable length elements\n('bytearray') no mention is made of their length encoding. etc.\n\nWithout information like this, I don't see how someone could\nrealistically begin reviewing this proposal.\n\nThe motivation seems unclear to me as well: The scheme is described as\n'flexible' but it appears to remove flexibility from the existing\nsystem. The \"schema\" appears to be hardcoded and never communicated.\nIf the goal is to simply have a more compact on the wire\nrepresentation, this could be done without changing the serialization\nused for hashing or the serialization used for costing."
            },
            {
                "author": "Tom",
                "date": "2016-09-22T08:56:31",
                "message_text_only": "On Wednesday 21 Sep 2016 18:01:30 Gregory Maxwell via bitcoin-dev wrote:\n> On Tue, Sep 20, 2016 at 5:15 PM, Tom via bitcoin-dev\n> \n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > BIP number for my FT spec.\n> \n> This document does not appear to be concretely specified enough to\n> review or implement from it.\n> \n> For example, it does not specify the serialization of \"integer\"\n\nIt refers to the external specification which is linked at the bottom.\nIn that spec you'll see that \"Integer\" is the standard var-int that Bitcoin \nhas used for years.\n\n> nor does it specify how the\n> presence of the optional fields are signaled \n\nHow does one signals an optional field except of in the spec? Thats the job of \na specification.\n\n> nor the cardinality of\n> the inputs or outputs. \n\nDid you miss this in the 3rd table ?  I suggest clicking on the github bips \nrepo link as tables are not easy to read in mediawiki plain format that the \nemail contained.\n\n> For clearly variable length elements\n> ('bytearray') no mention is made of their length encoding. etc.\n\nAlso in the external CMF spec.\n \n> Without information like this, I don't see how someone could\n> realistically begin reviewing this proposal.\n\nI agree, that would be bad. Luckily that you just missed the link :)\nHere it is;\nhttps://github.com/bitcoinclassic/documentation/blob/master/spec/compactmessageformat.md\n\n> The motivation seems unclear to me as well: The scheme is described as\n> 'flexible' but it appears to remove flexibility from the existing\n> system. The \"schema\" appears to be hardcoded and never communicated.\n\nBeing hardcoded and never communicated is what the current format does to. How \ndoes that \"remove flexibility\".\n\nAlso read my reply to Peter Todd on why this is flexible.\n\n> If the goal is to simply have {snip}\n\nIt is not.\n\nThanks for asking, I understand that the CMF spec is useful to see as well. \nHopefully you can now review it properly since I linked to it above.\n\nCheers!"
            },
            {
                "author": "Christian Decker",
                "date": "2016-09-22T11:10:49",
                "message_text_only": "On Thu, Sep 22, 2016 at 10:56:31AM +0200, Tom via bitcoin-dev wrote:\n> On Wednesday 21 Sep 2016 18:01:30 Gregory Maxwell via bitcoin-dev wrote:\n> > On Tue, Sep 20, 2016 at 5:15 PM, Tom via bitcoin-dev\n> > \n> > <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > > BIP number for my FT spec.\n> > \n> > This document does not appear to be concretely specified enough to\n> > review or implement from it.\n> > \n> > For example, it does not specify the serialization of \"integer\"\n> \n> It refers to the external specification which is linked at the bottom.\n> In that spec you'll see that \"Integer\" is the standard var-int that Bitcoin \n> has used for years.\n\nI think BIPs should be self-contained, or rely on previous BIPs,\nwhenever possible. Referencing an external formatting document should\nbe avoided and requiring readers to reverse engineer a reference\nimplementation doesn't seem too user friendly either. Publishing a BIP\nwith CMF would certainly help, and completing this spec with the\ndetails that are missing, or only \"defined\" in the implementation,\nwould be better.\n\n> > nor does it specify how the\n> > presence of the optional fields are signaled \n> \n> How does one signals an optional field except of in the spec? Thats the job of \n> a specification.\n\nSo the presence is signaled by encountering the tag, which contains\nboth token type and name-reference. The encoder and decoder operations\ncould be described better.\n\n> > nor the cardinality of\n> > the inputs or outputs. \n> \n> Did you miss this in the 3rd table ?  I suggest clicking on the github bips \n> repo link as tables are not easy to read in mediawiki plain format that the \n> email contained.\n\nMinor nit: that table is not well-formed. As was pointed out in the\nnormalized transaction ID BIP, your proposal only addresses\nthird-party malleability, since signers can simply change the\ntransaction and re-sign it. This is evident from the fact that inputs\nand outputs do not have a canonical order and it would appear that\ntokens can be re-ordered in segments. Dependencies of tokens inside a\nsegment are also rather alarming (TxInPrevHash <-> TxInPrevIndex,\nTxOutScript <-> TxOutValue).\n\nFinally, allowing miners to reject transactions with unknown fields\nmakes the OP_NOPs unusable since they'd result in forks: non-upgraded\nnodes would reject blocks from upgraded nodes.\n\nRegards,\nChristian"
            },
            {
                "author": "Tom",
                "date": "2016-09-22T12:09:38",
                "message_text_only": "On Thursday 22 Sep 2016 13:10:49 Christian Decker via bitcoin-dev wrote:\n> On Thu, Sep 22, 2016 at 10:56:31AM +0200, Tom via bitcoin-dev wrote:\n> > On Wednesday 21 Sep 2016 18:01:30 Gregory Maxwell via bitcoin-dev wrote:\n> > > On Tue, Sep 20, 2016 at 5:15 PM, Tom via bitcoin-dev\n> > > \n> > > <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > > > BIP number for my FT spec.\n> > > \n> > > This document does not appear to be concretely specified enough to\n> > > review or implement from it.\n> > > \n> > > For example, it does not specify the serialization of \"integer\"\n> > \n> > It refers to the external specification which is linked at the bottom.\n> > In that spec you'll see that \"Integer\" is the standard var-int that\n> > Bitcoin\n> > has used for years.\n> \n> I think BIPs should be self-contained, or rely on previous BIPs,\n> whenever possible. Referencing an external formatting document should\n> be avoided \n\nIf luke-jr thinks I should submit CMF as a BIP, I can certainly do that.\nLuke, what do you think?\n\nI don't have a preference either way.\n\n> > > nor does it specify how the\n> > > presence of the optional fields are signaled\n> > \n> > How does one signals an optional field except of in the spec? Thats the\n> > job of a specification.\n> \n> So the presence is signaled by encountering the tag, which contains\n> both token type and name-reference. The encoder and decoder operations\n> could be described better.\n\nI'm sorry, I'm not following you here. Is there a question?\n\n\n> > > nor the cardinality of\n> > > the inputs or outputs.\n> > \n> > Did you miss this in the 3rd table ?  I suggest clicking on the github\n> > bips\n> > repo link as tables are not easy to read in mediawiki plain format that\n> > the\n> > email contained.\n> \n> Minor nit: that table is not well-formed.\n\nI am not very well versed in mediawiki tables, and I found github has some \nincompatibilities too.\nThe markdown one looks better;\nhttps://github.com/bitcoinclassic/documentation/blob/master/spec/transactionv4.md\n\n> As was pointed out in the\n> normalized transaction ID BIP, your proposal only addresses\n> third-party malleability, since signers can simply change the\n> transaction and re-sign it.\n\nI have to disagree. That is not malleability. Creating a new document and re-\nsigning it is not changing anything. Its re-creating. Something that the owner \nof the coin has every right to do.\n\n> This is evident from the fact that inputs\n> and outputs do not have a canonical order and it would appear that\n> tokens can be re-ordered in segments. \n\nSorry, what is evident? You seem to imply that it is uncommon that you can \ncreate two transactions of similar intent but using different bytes.\nYou would be wrong with this implication as this is very common. You can just \nalter the order of the inputs, for instance.\n\nI am unable to see what the point is you are trying to make. Is there a \nquestion or a suggestion for improvement here?\n\n> Dependencies of tokens inside a\n> segment are also rather alarming (TxInPrevHash <-> TxInPrevIndex,\n> TxOutScript <-> TxOutValue).\n\nMaybe you missed this line; \n  \u00abTxInPrevHash and TxInPrevIndex\n   Index can be skipped, but in any input the PrevHash always has\n   to come first\u00bb\n\nIf you still see something alarming, let me know.\nYou can look at the code in Bitcoin Classic and notice that it really isn't \nanything complicated or worrying.\n\n\n> Finally, allowing miners to reject transactions with unknown fields\n> makes the OP_NOPs unusable \n\nHmm, it looks like you are mixing terminology and abstraction-levels.  OP_NOP \nis a field from script and there is no discussion about any rejection based on \nscript in this BIP at all.\n\nRejection of transactions is done on there being unrecognised tokens in the \ntransaction formatting itself.\n\nThank you for your email to my BIP, I hope you got the answers you were \nlooking for :)"
            },
            {
                "author": "Christian Decker",
                "date": "2016-09-23T11:42:36",
                "message_text_only": "On Thu, Sep 22, 2016 at 02:09:38PM +0200, Tom via bitcoin-dev wrote:\n> On Thursday 22 Sep 2016 13:10:49 Christian Decker via bitcoin-dev wrote:\n> > \n> > I think BIPs should be self-contained, or rely on previous BIPs,\n> > whenever possible. Referencing an external formatting document should\n> > be avoided \n> \n> If luke-jr thinks I should submit CMF as a BIP, I can certainly do that.\n> Luke, what do you think?\n> \n> I don't have a preference either way.\n> \n> > \n> > So the presence is signaled by encountering the tag, which contains\n> > both token type and name-reference. The encoder and decoder operations\n> > could be described better.\n> \n> I'm sorry, I'm not following you here. Is there a question?\n\nNope, just clarifying how presence or absence is indicated :-)\n\n> > \n> > Minor nit: that table is not well-formed.\n> \n> I am not very well versed in mediawiki tables, and I found github has some \n> incompatibilities too.\n> The markdown one looks better;\n> https://github.com/bitcoinclassic/documentation/blob/master/spec/transactionv4.md\n\nIt's just some rows have 3 columns, others have 2. It's a minor nit\nreally.\n\n> > As was pointed out in the\n> > normalized transaction ID BIP, your proposal only addresses\n> > third-party malleability, since signers can simply change the\n> > transaction and re-sign it.\n> \n> I have to disagree. That is not malleability. Creating a new document and re-\n> signing it is not changing anything. Its re-creating. Something that the owner \n> of the coin has every right to do.\n\nSame thing I was arguing back then, however Luke pointed out that\nmalleability just refers to the possibility of modifying a transaction\nafter the fact. Always referring to \"third-party malleability\" avoids\nthis ambiguity.\n\n> > This is evident from the fact that inputs\n> > and outputs do not have a canonical order and it would appear that\n> > tokens can be re-ordered in segments. \n> \n> Sorry, what is evident? You seem to imply that it is uncommon that you can \n> create two transactions of similar intent but using different bytes.\n> You would be wrong with this implication as this is very common. You can just \n> alter the order of the inputs, for instance.\n> \n> I am unable to see what the point is you are trying to make. Is there a \n> question or a suggestion for improvement here?\n> \n> > Dependencies of tokens inside a\n> > segment are also rather alarming (TxInPrevHash <-> TxInPrevIndex,\n> > TxOutScript <-> TxOutValue).\n> \n> Maybe you missed this line; \n>   \u00abTxInPrevHash and TxInPrevIndex\n>    Index can be skipped, but in any input the PrevHash always has\n>    to come first\u00bb\n\nNope, that is exactly the kind of dependency I was talking\nabout. Instead of nesting a construct like the current transactions\ndo, you rely on the order of tokens to imply that they belong\ntogether.\n\n> If you still see something alarming, let me know.\n> You can look at the code in Bitcoin Classic and notice that it really isn't \n> anything complicated or worrying.\n> \n> \n> > Finally, allowing miners to reject transactions with unknown fields\n> > makes the OP_NOPs unusable \n> \n> Hmm, it looks like you are mixing terminology and abstraction-levels.  OP_NOP \n> is a field from script and there is no discussion about any rejection based on \n> script in this BIP at all.\n> \n> Rejection of transactions is done on there being unrecognised tokens in the \n> transaction formatting itself.\n\nAh, thanks for clearing that up. However, the problem persists, if we\nadd new fields that a non-upgraded node doesn't know about and it\nrejects transactions containing it, we'll have a hard-fork. It should\nprobably not reject transactions with unknown fields if the\ntransaction is included in a block.\n\n> Thank you for your email to my BIP, I hope you got the answers you were \n> looking for :)\n\nCheers,\nChristian"
            },
            {
                "author": "Tom",
                "date": "2016-09-23T13:17:52",
                "message_text_only": "On Friday, 23 September 2016 13:42:36 CEST Christian Decker via bitcoin-dev wrote:\n> > I have to disagree. That is not malleability. Creating a new document\n> > and re- signing it is not changing anything. Its re-creating.\n> > Something that the owner of the coin has every right to do.\n> Same thing I was arguing back then, however Luke pointed out that\n> malleability just refers to the possibility of modifying a transaction\n> after the fact.\n\nI am not a fan of redefining dictionary words. I'll stick to the \nuniversally excepted one, thanks.\n\n> Nope, that is exactly the kind of dependency I was talking\n> about. Instead of nesting a construct like the current transactions\n> do, you rely on the order of tokens to imply that they belong\n> together.\n\n\n> if we\n> add new fields that a non-upgraded node doesn't know about and it\n> rejects transactions containing it, we'll have a hard-fork. It should\n> probably not reject transactions with unknown fields if the\n> transaction is included in a block.\n\nThis is addressed here;\nhttps://github.com/bitcoin/bips/blob/master/bip-0134.mediawiki#future-extensibility"
            },
            {
                "author": "Tom",
                "date": "2016-09-22T08:47:03",
                "message_text_only": "On Wednesday 21 Sep 2016 18:45:55 adiabat via bitcoin-dev wrote:\n> Hi-\n> \n> One concern is that this doesn't seem compatible with Lightning as\n> currently written.  Most relevant is that non-cooperative channel close\n> transactions in Lightning use OP_CHECKSEQUENCEVERIFY, which references the\n> sequence field of the txin; if the txin doesn't have a sequence number,\n> OP_CHECKSEQUENCEVERIFY can't work.\n> \n> LockByBlock and LockByTime aren't described and there doesn't seem to be\n> code for them in the PR (186).  If there's a way to make OP_CLTV and OP_CSV\n> work with this new format, please let us know, thanks!\n\nLockByBlock and LockByTime are still TODOs because I didn't have time to go\nin-dept into how BIP68 does the encoding.\nThe intent is that these tags, while loading, will set the sequence integer in \nthe txin as the old version does. And while saving we do the reverse.\n\nIn other words; the lack of sequence number in the saved format doesn't affect \nthe in-memory format of the transaction. The in-memory version is the one that \nscript will operate on.\n\nThis means that there is no change in how CSV will work before and after on \nany level other than serialisation.\n\nFlexible Transactions is definitely meant to support the Lightning Network, so \nany problems you find is something we should solve before it ships.\n\nThanks for your email!"
            },
            {
                "author": "Peter Todd",
                "date": "2016-09-22T18:27:29",
                "message_text_only": "On Thu, Sep 22, 2016 at 10:47:03AM +0200, Tom via bitcoin-dev wrote:\n> On Wednesday 21 Sep 2016 18:45:55 adiabat via bitcoin-dev wrote:\n> > Hi-\n> > \n> > One concern is that this doesn't seem compatible with Lightning as\n> > currently written.  Most relevant is that non-cooperative channel close\n> > transactions in Lightning use OP_CHECKSEQUENCEVERIFY, which references the\n> > sequence field of the txin; if the txin doesn't have a sequence number,\n> > OP_CHECKSEQUENCEVERIFY can't work.\n> > \n> > LockByBlock and LockByTime aren't described and there doesn't seem to be\n> > code for them in the PR (186).  If there's a way to make OP_CLTV and OP_CSV\n> > work with this new format, please let us know, thanks!\n> \n> LockByBlock and LockByTime are still TODOs because I didn't have time to go\n> in-dept into how BIP68 does the encoding.\n> The intent is that these tags, while loading, will set the sequence integer in \n> the txin as the old version does. And while saving we do the reverse.\n> \n> In other words; the lack of sequence number in the saved format doesn't affect \n> the in-memory format of the transaction. The in-memory version is the one that \n> script will operate on.\n> \n> This means that there is no change in how CSV will work before and after on \n> any level other than serialisation.\n\nCSV uses per-input sequence numbers; you only have a per-tx equivalent.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160922/e0b97186/attachment.sig>"
            },
            {
                "author": "Tom",
                "date": "2016-09-22T18:37:29",
                "message_text_only": "On Thursday, 22 September 2016 14:27:29 CEST Peter Todd wrote:\n> CSV uses per-input sequence numbers; you only have a per-tx equivalent.\n\nI think you misunderstand tagged systems at a very basic level.  You think \nthat html can only use a bold tag <b> once in a document? Thats equivalent \nto what you are saying.\n\nYour comment is rather embarrassing, I have to point out. You may want to \nread a bit more before you comment more."
            },
            {
                "author": "Jonas Schnelli",
                "date": "2016-09-22T19:59:12",
                "message_text_only": "Hi Tom\n\n> I think you misunderstand tagged systems at a very basic level.  You think \n> that html can only use a bold tag <b> once in a document? Thats equivalent \n> to what you are saying.\n\nWould the \"additional\" segment contain the same amount of\nnSequence-equivalent token as the number of inputs in the \"inputs\" segment?\nWhat if you only want to add a per-input-token in the additional segment\nfor a certain input (assume last input)?\nI guess the fundamental difference to html is the possible nesting.\n\nHowever, I think that should be mentioned/specified in the BIP.\n\n</jonas>\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160922/70a1092a/attachment-0001.sig>"
            },
            {
                "author": "Tom",
                "date": "2016-09-22T20:07:33",
                "message_text_only": "On Thursday, 22 September 2016 21:59:12 CEST Jonas Schnelli via bitcoin-dev \nwrote:\n> Hi Tom\n> \n> > I think you misunderstand tagged systems at a very basic level.  You\n> > think that html can only use a bold tag <b> once in a document? Thats\n> > equivalent to what you are saying.\n> \n> Would the \"additional\" segment contain the same amount of\n> nSequence-equivalent token as the number of inputs in the \"inputs\"\n> segment?\n\nAt this point I don't know what it should look like, I have not had time to \nlook deeply into BIP68.  Is this what you would suggest it to look like?\nI rather figured spending limitations would be assigned to an output, not \nan input.\n\n> However, I think that should be mentioned/specified in the BIP.\n\nIt can be, and likely should be.  This BIP doesn't pretend to be finished \nyet.\n\nI welcome any and all discussion about this, it only serves to make the end \nresult stronger!"
            },
            {
                "author": "Christian Decker",
                "date": "2016-09-23T11:55:50",
                "message_text_only": "On Thu, Sep 22, 2016 at 08:37:29PM +0200, Tom via bitcoin-dev wrote:\n> On Thursday, 22 September 2016 14:27:29 CEST Peter Todd wrote:\n> > CSV uses per-input sequence numbers; you only have a per-tx equivalent.\n> \n> I think you misunderstand tagged systems at a very basic level.  You think \n> that html can only use a bold tag <b> once in a document? Thats equivalent \n> to what you are saying.\n> \n> Your comment is rather embarrassing, I have to point out. You may want to \n> read a bit more before you comment more.\n\nNot sure if the comparison to XML and HTML holds: the lack of closing\ntags makes the meaning of individual tokens ambiguous, like I pointed\nout before. The use of segments gives at most two levels of nesting,\nso any relationship among tokens in the same segment has to rely on\ntheir relative position, which could result in ambiguities, like\nwhether a tag refers to a single input or the transaction as a whole.\n\nCheers,\nChristian"
            },
            {
                "author": "Tom",
                "date": "2016-09-23T13:13:10",
                "message_text_only": "On Friday, 23 September 2016 13:55:50 CEST Christian Decker via bitcoin-dev \nwrote: \n> Not sure if the comparison to XML and HTML holds: the lack of closing\n> tags makes the meaning of individual tokens ambiguous, like I pointed\n> out before. The use of segments gives at most two levels of nesting,\n> so any relationship among tokens in the same segment has to rely on\n> their relative position, which could result in ambiguities, like\n> whether a tag refers to a single input or the transaction as a whole.\n\n\nPractically all tagged formats make ordering a requirement, so indeed this \nis relevant, and not unique.\n\nFor instance if you write;\n  <div> Some line </br>Another line</br>3rd line</div>\nyou can get a good idea of how ordering is relevant. You can reuse any item \nmany times.\n\nWhenever there is a possible confusion the specification specifically \nexplains which order to use.\n\nI'm not sure what you mean with the idea this;\n\n>  The use of segments gives at most two levels of nesting\n\nIt looks like you assume there is some opening and closing tags, since \notherwise there would be no nesting.\nSuch tags are not intended, nor documented.\n\n> so any relationship among tokens in the same segment has to rely on\n> their relative position, which could result in ambiguities, like\n> whether a tag refers to a single input or the transaction as a whole.\n\nI quoted parts of the spec in your previous email stating the same thing, \nbut I'll repeat here.\nAny place that has any sort of possibility to be ambiguous is specified \nspecifically to have an order.  This makes writing and parsing easier.\n\nSince you wrote two emails now with the same issue, and I addressed it \ntwice, I would urge you to write out some examples which may be confusing \nand if you find that the spec is indeed missing requirements then please \nshare it with us.  I did this some time ago and it helps understanding the \nideas by having actual explicit examples.  I am not aware of any sort of \nambiguities that the spec allows.\n\nCheers!"
            }
        ],
        "thread_summary": {
            "title": "Requesting BIP assignment; Flexible Transactions.",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tom",
                "Andreas Schildbach",
                "Peter Todd",
                "Gregory Maxwell",
                "Luke Dashjr",
                "Jonas Schnelli",
                "Christian Decker"
            ],
            "messages_count": 22,
            "total_messages_chars_count": 45505
        }
    },
    {
        "title": "[bitcoin-dev] On-going work: Coin Selection Simulation",
        "thread_messages": [
            {
                "author": "Murch",
                "date": "2016-09-21T12:58:25",
                "message_text_only": "Hi,\n\nI'm currently compiling my Master's thesis about Coin Selection and my\npresentation proposal to Scaling Bitcoin has been accepted.\n\nFor my thesis, I have analyzed the Coin Selection problem, created a\nframework to simulate wallet behavior on basis of a sequence of\npayments, and have re-implemented multiple coin selection strategies of\nprominent Bitcoin wallets (Bitcoin Core, Mycelium, Breadwallet, and\nAndroid Wallet for Bitcoin).\n\nAs the Scaling Bitcoin site suggests that research should be made\navailable to this mailing list, I would like to invite you to have a\nlook at:\n\nhttp://murch.one/wp-content/uploads/2016/09/CoinSelection.pdf\n\nThe PDF (176 kB) contains a two page description of my on-going work,\nincluding preliminary simulation results, and three figures showing the\nsimulated wallets' UTXO compositions at the end of the simulation.\n\nI can provide further information as requested, and would welcome any\nfeedback.\n\n\u2192\u2192 If anyone has another sequence of incoming and outgoing payment\namounts at hand that I could run my simulation on, I'd love to hear\nabout it.\n\nRegards\n\nMurch\n\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160921/56ec5d2a/attachment.sig>"
            },
            {
                "author": "Andreas Schildbach",
                "date": "2016-09-21T15:02:56",
                "message_text_only": "On 09/21/2016 02:58 PM, Murch via bitcoin-dev wrote:\n\n> Android Wallet for Bitcoin\n\nThe correct name is Bitcoin Wallet, or Bitcoin Wallet for Android (if\nyou want to refer to the Android version)."
            },
            {
                "author": "Chris Priest",
                "date": "2016-09-21T22:40:57",
                "message_text_only": ">From my experience working with coin selection algorithms, there are\nthree \"goals\" to it:\n\n1. Minimize cost\n2. Maximize privacy\n3. Minimize UTXO footprint\n\nYou can build a coin selection algorithm that achieves 1 and 3, but\nwill sacrifice 2. If you want coin selectin to maximize your privacy,\nit will happen at the expense of UTXO footprint and fees. Minimizing\ncost usually also minimizes UTXO footprint but not always. To\ncompletely minimize UTXO footprint, you sacrifice a bit on cost, and a\nlot on privacy.\n\nOn 9/21/16, Andreas Schildbach via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> On 09/21/2016 02:58 PM, Murch via bitcoin-dev wrote:\n>\n>> Android Wallet for Bitcoin\n>\n> The correct name is Bitcoin Wallet, or Bitcoin Wallet for Android (if\n> you want to refer to the Android version).\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Daniel Weigl",
                "date": "2016-09-22T09:33:18",
                "message_text_only": "Hi,\n\nIs your simulation code available somewhere?\n\nI was just wondering why mycelium generates a very big UTXO set for <1000sat, because change outputs will never be smaller than \n5460sat (=TransactionUtils.MINIMUM_OUTPUT_VALUE). If the change would be lower, it simply is skipped and added to the miner fee:\n\t-> https://github.com/mycelium-com/wallet/blob/master/public/bitlib/src/main/java/com/mrd/bitlib/StandardTransactionBuilder.java#L334\n\nDoes your simulation account for that?\n\nIt might also be that the small UTXO came from external tx and we never spend them, bec. of pruning/privacy. Not sure how we could optimize that.\n\nCheers,\nDaniel\n\nOn 2016-09-21 14:58, Murch via bitcoin-dev wrote:\n> Hi,\n> \n> I'm currently compiling my Master's thesis about Coin Selection and my\n> presentation proposal to Scaling Bitcoin has been accepted.\n> \n> For my thesis, I have analyzed the Coin Selection problem, created a\n> framework to simulate wallet behavior on basis of a sequence of\n> payments, and have re-implemented multiple coin selection strategies of\n> prominent Bitcoin wallets (Bitcoin Core, Mycelium, Breadwallet, and\n> Android Wallet for Bitcoin).\n> \n> As the Scaling Bitcoin site suggests that research should be made\n> available to this mailing list, I would like to invite you to have a\n> look at:\n> \n> http://murch.one/wp-content/uploads/2016/09/CoinSelection.pdf\n> \n> The PDF (176 kB) contains a two page description of my on-going work,\n> including preliminary simulation results, and three figures showing the\n> simulated wallets' UTXO compositions at the end of the simulation.\n> \n> I can provide further information as requested, and would welcome any\n> feedback.\n> \n> \u2192\u2192 If anyone has another sequence of incoming and outgoing payment\n> amounts at hand that I could run my simulation on, I'd love to hear\n> about it.\n> \n> Regards\n> \n> Murch\n> \n> \n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Murch",
                "date": "2016-09-23T09:11:58",
                "message_text_only": "Hi Daniel,\n\nThank you for your mail.\nMy simulation of the Mycelium coin selection does add small change\noutputs to the fee, but I did get your boundary wrong.\nInstead of the 5460, I dropped at the dust boundary which calculates to\n4440 in my simulation. Therefore, I think that the results in the table\nmight be slightly too big, but likely indicative of the actual Mycelium\nbehavior.\nI've corrected the boundary in my simulation now and will update my\nsimulation results before Scaling Bitcoin. Thank you very much for your\ncorrection.\n\nSorry, the simulation code has not been published yet, I plan to do that\naround Scaling Bitcoin or after I turn in my thesis (End of October). I\nwill let you know when I do.\n\nIt is my understanding that Mycelium doesn't create small change outputs\nbut rather hardly ever spends them when received.\n\nYou're probably more familiar with the code base (I think you work for\nMycelium?), so please correct me when I'm wrong:\nMycelium appears to select UTXO in a FIFO approach, but, after the\nselection, prunes by removing the smallest selected UTXO until the\nexcess beyond the spending target is minimized. This post-selection step\nseems the likely reason for Mycelium's small UTXO build-up. (Bitcoin\nCore intermittenly used post-selection pruning also, and apparently this\ndid cause a similar increase in UTXO set size then.)\n\nI assume that this will also cause Mycelium to create a huge transaction\nevery once in a while when this build-up is enough to fund a transaction\nwithout a bigger UTXO being selected.\n\nAs to how it may be mitigated: BreadWallet uses a very similar FIFO\napproach, but doesn't prune. My simulation result indicates that their\naverage UTXO set is much smaller. This has the downside that users could\nbe spammed with small transaction outputs that they then would pay for\nspending.\nA balanced approach between these two approaches might be that instead\nof pruning all small inputs, a few of the small inputs could be allowed\nto be selected to slowly drain low-value UTXO out of the wallet by\nspending them over time. In order to avoid the privacy issues such as\ne.g. always spending the oldest UTXO, it would for example be possible\nto implement this as a 75% probability to prune an unnecessary output.\n\nRegards\nMurch\n\nAm 22.09.2016 um 11:33 schrieb Daniel Weigl via bitcoin-dev:\n> Hi,\n> \n> Is your simulation code available somewhere?\n> \n> I was just wondering why mycelium generates a very big UTXO set for <1000sat, because change outputs will never be smaller than \n> 5460sat (=TransactionUtils.MINIMUM_OUTPUT_VALUE). If the change would be lower, it simply is skipped and added to the miner fee:\n> \t-> https://github.com/mycelium-com/wallet/blob/master/public/bitlib/src/main/java/com/mrd/bitlib/StandardTransactionBuilder.java#L334\n> \n> Does your simulation account for that?\n> \n> It might also be that the small UTXO came from external tx and we never spend them, bec. of pruning/privacy. Not sure how we could optimize that.\n> \n> Cheers,\n> Daniel\n> \n> On 2016-09-21 14:58, Murch via bitcoin-dev wrote:\n>> Hi,\n>>\n>> I'm currently compiling my Master's thesis about Coin Selection and my\n>> presentation proposal to Scaling Bitcoin has been accepted.\n>>\n>> For my thesis, I have analyzed the Coin Selection problem, created a\n>> framework to simulate wallet behavior on basis of a sequence of\n>> payments, and have re-implemented multiple coin selection strategies of\n>> prominent Bitcoin wallets (Bitcoin Core, Mycelium, Breadwallet, and\n>> Android Wallet for Bitcoin).\n>>\n>> As the Scaling Bitcoin site suggests that research should be made\n>> available to this mailing list, I would like to invite you to have a\n>> look at:\n>>\n>> http://murch.one/wp-content/uploads/2016/09/CoinSelection.pdf\n>>\n>> The PDF (176 kB) contains a two page description of my on-going work,\n>> including preliminary simulation results, and three figures showing the\n>> simulated wallets' UTXO compositions at the end of the simulation.\n>>\n>> I can provide further information as requested, and would welcome any\n>> feedback.\n>>\n>> \u2192\u2192 If anyone has another sequence of incoming and outgoing payment\n>> amounts at hand that I could run my simulation on, I'd love to hear\n>> about it.\n>>\n>> Regards\n>>\n>> Murch\n>>\n>>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Daniel Weigl",
                "date": "2016-09-23T09:35:22",
                "message_text_only": "Hello Murch,\n\n> I've corrected the boundary in my simulation now and will update my\n> simulation results before Scaling Bitcoin. Thank you very much for your\n> correction.\n\nOkay, if you already had included this logic I guess it wont change the\nresult that much if the cut off is 4440 or 5460sat. \nBut Im curious to see the new results.\n\n\n> It is my understanding that Mycelium doesn't create small change outputs\n> but rather hardly ever spends them when received.\n..\n> so please correct me when I'm wrong:\n> Mycelium appears to select UTXO in a FIFO approach, but, after the\n> selection, prunes by removing the smallest selected UTXO until the\n> excess beyond the spending target is minimized. This post-selection step\n> seems the likely reason for Mycelium's small UTXO build-up. (Bitcoin\n> Core intermittenly used post-selection pruning also, and apparently this\n> did cause a similar increase in UTXO set size then.)\n\nYes, you are correct - we added this pruning step about 2y ago to\nimprove privacy for the user on average. Every transaction\nonly links only so much inputs together as really necessary to fund \nthe transaction.\n\nOur idea is to have the user the option (either global or per account or\nper transaction) to choose between \"maximize privacy\" or \"minimize fees\"\n(or even maybe \"minimize UTXO\", if the become more expensive in the future)\nThat will the change the behaviour of the coin selector.\n\nThx for your work, also looking forward to see the code and maybe play with \nit a bit to test for different payment behaviours and coin selections.\n\nCheers,\nDaniel\n\n\nOn 2016-09-23 11:11, Murch wrote:\n> Hi Daniel,\n> \n> Thank you for your mail.\n> My simulation of the Mycelium coin selection does add small change\n> outputs to the fee, but I did get your boundary wrong.\n> Instead of the 5460, I dropped at the dust boundary which calculates to\n> 4440 in my simulation. Therefore, I think that the results in the table\n> might be slightly too big, but likely indicative of the actual Mycelium\n> behavior.\n> I've corrected the boundary in my simulation now and will update my\n> simulation results before Scaling Bitcoin. Thank you very much for your\n> correction.\n> \n> Sorry, the simulation code has not been published yet, I plan to do that\n> around Scaling Bitcoin or after I turn in my thesis (End of October). I\n> will let you know when I do.\n> \n> It is my understanding that Mycelium doesn't create small change outputs\n> but rather hardly ever spends them when received.\n> \n> You're probably more familiar with the code base (I think you work for\n> Mycelium?), so please correct me when I'm wrong:\n> Mycelium appears to select UTXO in a FIFO approach, but, after the\n> selection, prunes by removing the smallest selected UTXO until the\n> excess beyond the spending target is minimized. This post-selection step\n> seems the likely reason for Mycelium's small UTXO build-up. (Bitcoin\n> Core intermittenly used post-selection pruning also, and apparently this\n> did cause a similar increase in UTXO set size then.)\n> \n> I assume that this will also cause Mycelium to create a huge transaction\n> every once in a while when this build-up is enough to fund a transaction\n> without a bigger UTXO being selected.\n> \n> As to how it may be mitigated: BreadWallet uses a very similar FIFO\n> approach, but doesn't prune. My simulation result indicates that their\n> average UTXO set is much smaller. This has the downside that users could\n> be spammed with small transaction outputs that they then would pay for\n> spending.\n> A balanced approach between these two approaches might be that instead\n> of pruning all small inputs, a few of the small inputs could be allowed\n> to be selected to slowly drain low-value UTXO out of the wallet by\n> spending them over time. In order to avoid the privacy issues such as\n> e.g. always spending the oldest UTXO, it would for example be possible\n> to implement this as a 75% probability to prune an unnecessary output.\n> \n> Regards\n> Murch\n> \n> Am 22.09.2016 um 11:33 schrieb Daniel Weigl via bitcoin-dev:\n>> Hi,\n>>\n>> Is your simulation code available somewhere?\n>>\n>> I was just wondering why mycelium generates a very big UTXO set for <1000sat, because change outputs will never be smaller than \n>> 5460sat (=TransactionUtils.MINIMUM_OUTPUT_VALUE). If the change would be lower, it simply is skipped and added to the miner fee:\n>> \t-> https://github.com/mycelium-com/wallet/blob/master/public/bitlib/src/main/java/com/mrd/bitlib/StandardTransactionBuilder.java#L334\n>>\n>> Does your simulation account for that?\n>>\n>> It might also be that the small UTXO came from external tx and we never spend them, bec. of pruning/privacy. Not sure how we could optimize that.\n>>\n>> Cheers,\n>> Daniel\n>>\n>> On 2016-09-21 14:58, Murch via bitcoin-dev wrote:\n>>> Hi,\n>>>\n>>> I'm currently compiling my Master's thesis about Coin Selection and my\n>>> presentation proposal to Scaling Bitcoin has been accepted.\n>>>\n>>> For my thesis, I have analyzed the Coin Selection problem, created a\n>>> framework to simulate wallet behavior on basis of a sequence of\n>>> payments, and have re-implemented multiple coin selection strategies of\n>>> prominent Bitcoin wallets (Bitcoin Core, Mycelium, Breadwallet, and\n>>> Android Wallet for Bitcoin).\n>>>\n>>> As the Scaling Bitcoin site suggests that research should be made\n>>> available to this mailing list, I would like to invite you to have a\n>>> look at:\n>>>\n>>> http://murch.one/wp-content/uploads/2016/09/CoinSelection.pdf\n>>>\n>>> The PDF (176 kB) contains a two page description of my on-going work,\n>>> including preliminary simulation results, and three figures showing the\n>>> simulated wallets' UTXO compositions at the end of the simulation.\n>>>\n>>> I can provide further information as requested, and would welcome any\n>>> feedback.\n>>>\n>>> \u2192\u2192 If anyone has another sequence of incoming and outgoing payment\n>>> amounts at hand that I could run my simulation on, I'd love to hear\n>>> about it.\n>>>\n>>> Regards\n>>>\n>>> Murch\n>>>\n>>>\n>>>\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>"
            }
        ],
        "thread_summary": {
            "title": "On-going work: Coin Selection Simulation",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Chris Priest",
                "Daniel Weigl",
                "Murch",
                "Andreas Schildbach"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 15697
        }
    },
    {
        "title": "[bitcoin-dev]  Requesting BIP assignment; Flexible Transactions.",
        "thread_messages": [
            {
                "author": "adiabat",
                "date": "2016-09-21T22:45:55",
                "message_text_only": "Hi-\n\nOne concern is that this doesn't seem compatible with Lightning as\ncurrently written.  Most relevant is that non-cooperative channel close\ntransactions in Lightning use OP_CHECKSEQUENCEVERIFY, which references the\nsequence field of the txin; if the txin doesn't have a sequence number,\nOP_CHECKSEQUENCEVERIFY can't work.\n\nLockByBlock and LockByTime aren't described and there doesn't seem to be\ncode for them in the PR (186).  If there's a way to make OP_CLTV and OP_CSV\nwork with this new format, please let us know, thanks!\n\n-Tadge\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160921/48d7af14/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Requesting BIP assignment; Flexible Transactions.",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "adiabat"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 721
        }
    },
    {
        "title": "[bitcoin-dev] BIP draft: OP_CHECKBLOCKATHEIGHT",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2016-09-23T09:57:01",
                "message_text_only": "This BIP describes a new opcode (OP_CHECKBLOCKATHEIGHT) for the Bitcoin \nscripting system to address reissuing bitcoin transactions when the coins they \nspend have been conflicted/double-spent.\n\nhttps://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki\n\nDoes this seem like a good idea/approach?\n\nLuke"
            },
            {
                "author": "Russell O'Connor",
                "date": "2016-09-23T13:43:15",
                "message_text_only": "I believe Bitcoin currently enjoys the property that during an \"innocent\"\nre-org, i.e. a reorg in which no affected transactions are being double\nspent, all affected transactions can always eventually get replayed, so\nlong as the re-org depth is less than 100.\n\nMy concern with this proposed operation is that it would destroy this\nproperty.\n\nOn Fri, Sep 23, 2016 at 5:57 AM, Luke Dashjr via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> This BIP describes a new opcode (OP_CHECKBLOCKATHEIGHT) for the Bitcoin\n> scripting system to address reissuing bitcoin transactions when the coins\n> they\n> spend have been conflicted/double-spent.\n>\n> https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki\n>\n> Does this seem like a good idea/approach?\n>\n> Luke\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160923/21649e63/attachment.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2016-09-23T22:20:39",
                "message_text_only": "In the innocent use case of this opcode, a double-spend has already occurred, \nand this should be a strict improvement. In the non-innocent abuse of this \nopcode, I don't see that it's any worse than simply double-spending.\n\nWould this proposal be better or otherwise more acceptable, if a specified \nheight more recent than 100 blocks deep causes the script to fail? This would \nincrease delays in recovering the double-spend situation of course... but less \nthan 24h.\n\nLuke\n\n\nOn Friday, September 23, 2016 1:43:15 PM Russell O'Connor wrote:\n> I believe Bitcoin currently enjoys the property that during an \"innocent\"\n> re-org, i.e. a reorg in which no affected transactions are being double\n> spent, all affected transactions can always eventually get replayed, so\n> long as the re-org depth is less than 100.\n> \n> My concern with this proposed operation is that it would destroy this\n> property.\n> \n> On Fri, Sep 23, 2016 at 5:57 AM, Luke Dashjr via bitcoin-dev <\n> \n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > This BIP describes a new opcode (OP_CHECKBLOCKATHEIGHT) for the Bitcoin\n> > scripting system to address reissuing bitcoin transactions when the coins\n> > they\n> > spend have been conflicted/double-spent.\n> > \n> > https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki\n> > \n> > Does this seem like a good idea/approach?\n> > \n> > Luke\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2016-09-23T23:43:49",
                "message_text_only": "On Fri, Sep 23, 2016 at 10:20 PM, Luke Dashjr via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> In the innocent use case of this opcode, a double-spend has already occurred,\n> and this should be a strict improvement. In the non-innocent abuse of this\n> opcode, I don't see that it's any worse than simply double-spending.\n\nThere is a fungibility hit... right now, absent double spends (and\nprivacy issues), every coin you might get paid is equal.\n\nWith this script feature as described, you could get paid a coin which\nhas one of these in its recent past, pinning the block immediately\nbefore it. A reorg long enough to remove that block-- due to an\nattack, or an ordinary block race, or some kind of consensus glitch\n(like we had in March 2013 or around the activation of BIP65)-- is\n_guaranteed_ to invalidate those coins, even without any double spend.\n\nIf the scheme doesn't do as I suggest and prevent over-eager usage\n(perhaps 100 is too much, I just decided to match coinbases); then it\nshould probably have a consensus enforced explicit \"maximum survivable\nreorg\" that is traced along with the outputs, so that someone who\nreceived exposed coins could handle it sensibly.\n\nJust for plain engineering reasons, I still think it is important to\nnow allow overly short back references. If the reference has to be a\nfew blocks back we don't need to worry about short forks breaking\npropagation, and simple mempool handling like purging all CBAH\ntransactions on a large reorg would work fine.  It need not be so long\nas to implicate Petertodd's concern that you could only use it where\nit wouldn't matter.  (Though I also disagree that a depth of 100\nachieves that, consider persistent chain forks)."
            },
            {
                "author": "Tom",
                "date": "2016-09-23T14:37:39",
                "message_text_only": "On Friday 23 Sep 2016 09:57:01 Luke Dashjr via bitcoin-dev wrote:\n> This BIP describes a new opcode (OP_CHECKBLOCKATHEIGHT) for the Bitcoin\n> scripting system to address reissuing bitcoin transactions when the coins\n> they spend have been conflicted/double-spent.\n> \n> https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki\n\n\nCan you walk us through a real live usecase which this solves?  I read it and \nI think I understand it, but I can't see the attack every giving the attacker \nany benefit (or the attacked losing anything)."
            },
            {
                "author": "Luke Dashjr",
                "date": "2016-09-23T22:34:41",
                "message_text_only": "Joe sends Alice 5 BTC (UTXO 0).\nFred sends Alice 4 BTC (UTXO 1).\nAlice sends Bob 4 BTC using UTXO 1 (creating UTXO 2).\nFred double-spends UTXO 1 with UTXO 1-B. This invalidates Alice's transfer to \nBob.\nAlice has UTXO 0 which she can send to Bob (UTXO 3), but if she does so, it is \npossible that UTXO 0 could be mined, and then both UTXO 2 and UTXO 3 which \nwould result in her giving Bob a total of 8 BTC rather than merely 4 BTC.\nEven if Alice waits until Fred's UTXO 1-B confirms 10 blocks deep, it is not \nimpossible for a reorganization to reverse those 10 blocks and confirm UTXO 1 \nagain.\nUsing OP_CHECKBLOCKATHEIGHT, however, Alice can create UTXO 3 such that it is \nvalid only in the blockchain where Fred's UTXO 1-B has confirmed. This way, if \nthat block is reorganized out, UTXO 3 is invalid, and either Bob receives only \nthe original UTXO 2, or Alice can create a UTXO 3-B which is valid in the \nreorganized blockchain if it again confirms the UTXO 1-B double-spend.\n\nLuke\n\nOn Friday, September 23, 2016 2:37:39 PM Tom via bitcoin-dev wrote:\n> On Friday 23 Sep 2016 09:57:01 Luke Dashjr via bitcoin-dev wrote:\n> > This BIP describes a new opcode (OP_CHECKBLOCKATHEIGHT) for the Bitcoin\n> > scripting system to address reissuing bitcoin transactions when the coins\n> > they spend have been conflicted/double-spent.\n> > \n> > https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki\n> \n> Can you walk us through a real live usecase which this solves?  I read it\n> and I think I understand it, but I can't see the attack every giving the\n> attacker any benefit (or the attacked losing anything).\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Dave Scotese",
                "date": "2016-09-24T00:08:24",
                "message_text_only": "If Alice knows enough to see that she needs CHECKBLOCKATHEIGHT to avoid\npaying Bob twice, then she also knows that Fred owes her 4BTC.  If Bob\ncomplains about getting paid faster, Alice can let him know that Fred\nessentially stole his coins and that when she is certain he (and she) can't\nget them back, she will send a different four coins to Bob.  If she can\nestablish trust with Bob (She'd trust Bob to pay her back if he gets back\nthe coins Fred stole), then she can pay him again.  Bob could also make a\ntransaction to send the first input from Alice back to her (since he\ndoesn't have those coins anyway), sign it, and send that to her.  She can\nthen keep it instead of having to use the new opcode.\n\nOr she can let her wallet use the new opcode so that the logic is built in,\nif we add this opcode.  Wallet makers who want to help solve this problem\ncan either implement the new opcode, or they can offer people like Bob the\nability to refund orphaned transactions so that they can be duplicated in\nthe valid chain without any risk to the original sender.\n\nWith the opcode, Alice can solve the problem by herself.  Without it, Bob\ncan solve it for Alice.\n\nWhile the opcode adds complexity, it enables victims of double-spends to\npay untrusted creditors (Bob) without the risk that orphaned chains create\nof paying them twice.  I'm not sure the added complexity is worth the\nreward. The reward is to protect Bitcoiners (Alice) from people we'd call\n\"untrusted creditors\" (Bob) and I think that might be a mistake.  Getting a\nrefund transaction signed and sent back to Alice is similar to how the LN\nwill work (where wallets hold transactions that they don't broadcast).\n\nAm I understanding this correctly?\n\nOn Fri, Sep 23, 2016 at 3:34 PM, Luke Dashjr via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Joe sends Alice 5 BTC (UTXO 0).\n> Fred sends Alice 4 BTC (UTXO 1).\n> Alice sends Bob 4 BTC using UTXO 1 (creating UTXO 2).\n> Fred double-spends UTXO 1 with UTXO 1-B. This invalidates Alice's transfer\n> to\n> Bob.\n> Alice has UTXO 0 which she can send to Bob (UTXO 3), but if she does so,\n> it is\n> possible that UTXO 0 could be mined, and then both UTXO 2 and UTXO 3 which\n> would result in her giving Bob a total of 8 BTC rather than merely 4 BTC.\n> Even if Alice waits until Fred's UTXO 1-B confirms 10 blocks deep, it is\n> not\n> impossible for a reorganization to reverse those 10 blocks and confirm\n> UTXO 1\n> again.\n> Using OP_CHECKBLOCKATHEIGHT, however, Alice can create UTXO 3 such that it\n> is\n> valid only in the blockchain where Fred's UTXO 1-B has confirmed. This\n> way, if\n> that block is reorganized out, UTXO 3 is invalid, and either Bob receives\n> only\n> the original UTXO 2, or Alice can create a UTXO 3-B which is valid in the\n> reorganized blockchain if it again confirms the UTXO 1-B double-spend.\n>\n> Luke\n>\n> On Friday, September 23, 2016 2:37:39 PM Tom via bitcoin-dev wrote:\n> > On Friday 23 Sep 2016 09:57:01 Luke Dashjr via bitcoin-dev wrote:\n> > > This BIP describes a new opcode (OP_CHECKBLOCKATHEIGHT) for the Bitcoin\n> > > scripting system to address reissuing bitcoin transactions when the\n> coins\n> > > they spend have been conflicted/double-spent.\n> > >\n> > > https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki\n> >\n> > Can you walk us through a real live usecase which this solves?  I read it\n> > and I think I understand it, but I can't see the attack every giving the\n> > attacker any benefit (or the attacked losing anything).\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n\n-- \nI like to provide some work at no charge to prove my value. Do you need a\ntechie?\nI own Litmocracy <http://www.litmocracy.com> and Meme Racing\n<http://www.memeracing.net> (in alpha).\nI'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which\nnow accepts Bitcoin.\nI also code for The Dollar Vigilante <http://dollarvigilante.com/>.\n\"He ought to find it more profitable to play by the rules\" - Satoshi\nNakamoto\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160923/a0d9fa2b/attachment-0001.html>"
            },
            {
                "author": "Tom",
                "date": "2016-09-24T09:37:52",
                "message_text_only": "Thank you Luke, this makes it clearer.\n\nIt doesn't change that this scenario is an attack that doesn't give the \nattacker any benefit and the attacked doesn't loose anything either (as \nDave pointed out).\n\nThis is a completely academical problem that assumes so many stupid \nmistakes from software and from people that its very unlikely. On top of \nthat it assumes a rather lengthy 51% attack in concert with this already \nextremely unlikely usecase.\n\nIn the scenario you assume stupid people and then you solve it by requiring \nthe victim to suddenly be super smart and use a solution specifically \ndesigned for this super unlikely usecase that probably will never actually \nhappen...\n\nI don't buy it.\n\nOn Friday, 23 September 2016 22:34:41 CEST Luke Dashjr wrote:\n> Joe sends Alice 5 BTC (UTXO 0).\n> Fred sends Alice 4 BTC (UTXO 1).\n> Alice sends Bob 4 BTC using UTXO 1 (creating UTXO 2).\n> Fred double-spends UTXO 1 with UTXO 1-B. This invalidates Alice's\n> transfer to Bob.\n> Alice has UTXO 0 which she can send to Bob (UTXO 3), but if she does so,\n> it is possible that UTXO 0 could be mined, and then both UTXO 2 and UTXO\n> 3 which would result in her giving Bob a total of 8 BTC rather than\n> merely 4 BTC. Even if Alice waits until Fred's UTXO 1-B confirms 10\n> blocks deep, it is not impossible for a reorganization to reverse those\n> 10 blocks and confirm UTXO 1 again.\n> Using OP_CHECKBLOCKATHEIGHT, however, Alice can create UTXO 3 such that\n> it is valid only in the blockchain where Fred's UTXO 1-B has confirmed.\n> This way, if that block is reorganized out, UTXO 3 is invalid, and\n> either Bob receives only the original UTXO 2, or Alice can create a UTXO\n> 3-B which is valid in the reorganized blockchain if it again confirms\n> the UTXO 1-B double-spend.\n> \n> Luke\n> \n> On Friday, September 23, 2016 2:37:39 PM Tom via bitcoin-dev wrote:\n> > On Friday 23 Sep 2016 09:57:01 Luke Dashjr via bitcoin-dev wrote:\n> > > This BIP describes a new opcode (OP_CHECKBLOCKATHEIGHT) for the\n> > > Bitcoin\n> > > scripting system to address reissuing bitcoin transactions when the\n> > > coins they spend have been conflicted/double-spent.\n> > > \n> > > https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki\n> > \n> > Can you walk us through a real live usecase which this solves?  I read\n> > it and I think I understand it, but I can't see the attack every\n> > giving the attacker any benefit (or the attacked losing anything).\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Peter Todd",
                "date": "2016-09-23T16:18:17",
                "message_text_only": "On Fri, Sep 23, 2016 at 09:57:01AM +0000, Luke Dashjr via bitcoin-dev wrote:\n> This BIP describes a new opcode (OP_CHECKBLOCKATHEIGHT) for the Bitcoin \n> scripting system to address reissuing bitcoin transactions when the coins they \n> spend have been conflicted/double-spent.\n> \n> https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki\n> \n> Does this seem like a good idea/approach?\n\nYour BIP is a bit confusing: you say \"In some circumstances, users may wish to\nspend received bitcoins before they have confirmed on the blockchain\", but what\nyou're really referring to isn't spending unconfirmed outputs - which\nOP_CHECKBLOCKATHEIGHT can't protect - but rather spending outputs with a small\nnumber of confirmations.\n\nIn the existing ecosystem, if multi-block reorgs were a regular event Bitcoin\nwould be in a lot of trouble; since they're rare, advising wallet authors to\nsimply refuse to make transactions for some time after such a reorg may be a\nbetter solution. After all, a multi-block reorg is a strong indication that\nthere's somehting very wrong with the network, and it'd be safer to stop using\nBitcoin for awhile until things settle down.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160923/abc32eea/attachment.sig>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2016-09-23T18:57:57",
                "message_text_only": "On Fri, Sep 23, 2016 at 1:43 PM, Russell O'Connor via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> I believe Bitcoin currently enjoys the property that during an \"innocent\"\n> re-org, i.e. a reorg in which no affected transactions are being double\n> spent, all affected transactions can always eventually get replayed, so long\n> as the re-org depth is less than 100.\n\n> My concern with this proposed operation is that it would destroy this\n> property.\n\nThe reorg safety impact of this proposal could be eliminated and the\nmempool handling complexity greatly reduced if the transaction was\nrequired to be locktimed at least 100 blocks after the block its\nreferencing.\n\nThis would also resolve a rather severe DOS weakness that the spec has\nwith the suggestion that nodes would relay this rule without\nvalidating it. With the depth restriction nodes could relay one (or a\ncouple) blocks early without creating a situation where someone can\nconsume relay resources with near zero odds of paying a fee for them.\n\nIrritatingly, applications of this rule would really want to be\napplied at signing time (like locktime is), not as part of a\nscriptpubkey. With it part of a scriptpubkey two moves are required. I\nthink solving this is important.\n\nFWIW, this scheme more has been proposed before for another reason--\neffectively allowing users to 'vote against' long reorgs by making\nsure their transactions can't be included in them. Though for that\napplication it was only needed to use 32 bits of the block hash."
            },
            {
                "author": "Peter Todd",
                "date": "2016-09-23T20:02:23",
                "message_text_only": "On Fri, Sep 23, 2016 at 06:57:57PM +0000, Gregory Maxwell via bitcoin-dev wrote:\n> On Fri, Sep 23, 2016 at 1:43 PM, Russell O'Connor via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > I believe Bitcoin currently enjoys the property that during an \"innocent\"\n> > re-org, i.e. a reorg in which no affected transactions are being double\n> > spent, all affected transactions can always eventually get replayed, so long\n> > as the re-org depth is less than 100.\n> \n> > My concern with this proposed operation is that it would destroy this\n> > property.\n> \n> The reorg safety impact of this proposal could be eliminated and the\n> mempool handling complexity greatly reduced if the transaction was\n> required to be locktimed at least 100 blocks after the block its\n> referencing.\n\nHowever, by doing that we'd also make the functionality not all that useful for\nthis application; by the time you waited 100 blocks for the tx to be minable,\nthe chance of a reorg happening is low enough that I can't imagine many - if\nany - wallets would bother using the opcode in the first place, and would\ninstead just rely on the fact that a reorg that deep which resulted in the\ndouble-spent transaction ending up back in the chain is very unlikely.\n\nSpecifically I'm referring to the following scenario:\n\n1) Alice pays Bob with tx1a\n2) tx1a gets N confirmations, where N is some small number of confirmations.\n2) Bob pays Charlie from tx1a's output in tx2a\n3) A reorg eliminates the block that tx1a existed, and a conflicting tx1b is\n   mined instead, making tx1a and tx2a invalid.\n4) Bob pays Charlie again with tx2b, whose inputs do not conflict with tx2a\n5) Another reorg eliminates tx1b, allowing tx1a, tx2a, and tx2b to all be\n   mined.\n6) Charlie has now been paid twice.\n\nSince you need _two_ reorgs for this scenario to be applicable, it's much\neasier to just wait for tx1b to be confirmed suffiently deeply in the chain\nthat a reorg undoing it - thus allowing tx1a and tx2a to exist - is\nsufficiently unlikely; 100 blocks is a lot more than  most wallets are going to\nconsider \"sufficiently unlikely\", so the featureu just won't get used (assuming\nwallets even bother to handle this case of course!).\n\nUnfortunately I think this is an inherent catch-22 of the idea.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160923/db03fdfb/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "BIP draft: OP_CHECKBLOCKATHEIGHT",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tom",
                "Peter Todd",
                "Russell O'Connor",
                "Dave Scotese",
                "Luke Dashjr",
                "Gregory Maxwell"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 19831
        }
    },
    {
        "title": "[bitcoin-dev] Proposed BIP-1 change removing OPL licensing option.",
        "thread_messages": [
            {
                "author": "Gregory Maxwell",
                "date": "2016-09-24T00:21:16",
                "message_text_only": "I've proposed a revision to BIP-1 that removes the option to license\nthe work under the OPL:  https://github.com/bitcoin/bips/pull/446\n\nThe OPL contains troublesome terms where the licensor can elect to\nprohibit print publication of the work as well as the creation of\nmodified versions without their approval.\n\n\"Distribution of substantively modified versions of this document is\nprohibited without the explicit permission of the copyright holder.\"\n\"Distribution of the work or derivative of the work in any standard\n(paper) book form is prohibited unless prior permission is obtained\nfrom the copyright holder.\"\n\nAdditionally, even without these optional clauses the specific\nconstruction of this licenses' attribution requirements are\nrestrictive enough that Debian does not consider it acceptable for\nworks included in their distribution\n(https://lists.debian.org/debian-legal/2004/03/msg00226.html).\n\nI can't find any discussion that indicates anyone involved with the\nproject was aware of these clauses at the time this text was added...\nand I believe they are strongly incompatible with having a\ntransparent, public, collaborative process for the development of\nstandard for interoperablity. I certainly wasn't aware of it, and\nwould have argued against it if I was.\n\nMoreover, the project that created this license has recommended people\nuse creative commons licenses instead since 2007.\n\nThe only BIPs that have availed themselves of this are BIP145 (which\nis dual licensed under the permissive 2-clause BSD, which I wouldn't\nobject to adding as an option-- and which doesn't active the\nobjectionable clauses) and the recently assigned BIP134."
            },
            {
                "author": "Peter Todd",
                "date": "2016-09-26T18:41:36",
                "message_text_only": "On Sat, Sep 24, 2016 at 12:21:16AM +0000, Gregory Maxwell via bitcoin-dev wrote:\n> I've proposed a revision to BIP-1 that removes the option to license\n> the work under the OPL:  https://github.com/bitcoin/bips/pull/446\n> \n> The OPL contains troublesome terms where the licensor can elect to\n> prohibit print publication of the work as well as the creation of\n> modified versions without their approval.\n> \n> \"Distribution of substantively modified versions of this document is\n> prohibited without the explicit permission of the copyright holder.\"\n> \"Distribution of the work or derivative of the work in any standard\n> (paper) book form is prohibited unless prior permission is obtained\n> from the copyright holder.\"\n> \n> Additionally, even without these optional clauses the specific\n> construction of this licenses' attribution requirements are\n> restrictive enough that Debian does not consider it acceptable for\n> works included in their distribution\n> (https://lists.debian.org/debian-legal/2004/03/msg00226.html).\n> \n> I can't find any discussion that indicates anyone involved with the\n> project was aware of these clauses at the time this text was added...\n> and I believe they are strongly incompatible with having a\n> transparent, public, collaborative process for the development of\n> standard for interoperablity. I certainly wasn't aware of it, and\n> would have argued against it if I was.\n> \n> Moreover, the project that created this license has recommended people\n> use creative commons licenses instead since 2007.\n> \n> The only BIPs that have availed themselves of this are BIP145 (which\n> is dual licensed under the permissive 2-clause BSD, which I wouldn't\n> object to adding as an option-- and which doesn't active the\n> objectionable clauses) and the recently assigned BIP134.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\nACK\n\nNote how the OPL is significantly more restrictive than the Bitcoin Core\nlicense; not good if we can't ship documentation with the code.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160926/0d42c6b1/attachment.sig>"
            },
            {
                "author": "Tom",
                "date": "2016-09-27T09:51:40",
                "message_text_only": "On Monday 26 Sep 2016 14:41:36 Peter Todd via bitcoin-dev wrote:\n> Note how the OPL is significantly more restrictive than the Bitcoin Core\n> license; not good if we can't ship documentation with the code.\n\nDocumentation and code can have different licenses, the sole existence of \nvarious documentation licenses attests to that point.\nShipping your docs under a separate licence has never been a problem before, \nso you don't have to worry that you can't ship documentation with code.\n\nThat said, I wrote my suggestion in reply to Luke's BIP2 revival which is a \nmore formal suggestion of a solution. Maybe you can ACK that one instead?\n\nLast, in preparation of acceptance of BIP2 I changed the licence of my BIP to \nbe dual-licensed.  Now its also available under a Creative Commons license.\n\nHave a nice day!"
            },
            {
                "author": "Peter Todd",
                "date": "2016-09-27T19:17:07",
                "message_text_only": "On Tue, Sep 27, 2016 at 11:51:40AM +0200, Tom via bitcoin-dev wrote:\n> On Monday 26 Sep 2016 14:41:36 Peter Todd via bitcoin-dev wrote:\n> > Note how the OPL is significantly more restrictive than the Bitcoin Core\n> > license; not good if we can't ship documentation with the code.\n> \n> Documentation and code can have different licenses, the sole existence of \n> various documentation licenses attests to that point.\n> Shipping your docs under a separate licence has never been a problem before, \n> so you don't have to worry that you can't ship documentation with code.\n\nThe issue isn't that the licenses are different, it's that the OPL is\nsignificantly more restrictive (with the additional clauses that you opted\ninto).\n\nIndeed, using a different license for documentation is common advise, although\nif the documentation also includes example code you may want to dual-license\nthe documentation with a code-oriented license as well if the documentation\nlicense isn't maximally permissive.\n\n> That said, I wrote my suggestion in reply to Luke's BIP2 revival which is a \n> more formal suggestion of a solution. Maybe you can ACK that one instead?\n>\n> Last, in preparation of acceptance of BIP2 I changed the licence of my BIP to \n> be dual-licensed.  Now its also available under a Creative Commons license.\n\nThanks, CC-BY-SA is a perfectly good license for that purpose.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160927/bcbb4c51/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Proposed BIP-1 change removing OPL licensing option.",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tom",
                "Gregory Maxwell",
                "Peter Todd"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 6625
        }
    },
    {
        "title": "[bitcoin-dev] BIP 2 revival and rework",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2016-09-24T06:36:00",
                "message_text_only": "I've revived BIP 2 (from Deferred Status) and given it some updates. Most \nnotably, I have reworked it to be a *replacement* for BIP 1 rather than an \naddendum.\n\nhttps://github.com/luke-jr/bips/blob/bip0002_squash/bip-0002.mediawiki\n\nPlease review it. If things go well, hopefully we can get this done by \nChristmas. ;)\n\nOther recent changes include:\n* OPL will no longer be an acceptable license. Many in the community feel that \nprohibiting publication is unacceptable for BIPs, and I haven't heard any \narguments in favour of allowing it.\n* Accepted Status has been renamed to Proposed. The name \"Accepted\" seems a \nconstant source of confusion since it requires only action from the author.\n* Non-image auxiliary files are permitted in the bip-XXXX subdirectory. This \nwas already the norm despite BIP 1.\n* Email addresses are now required for authors. The Travis script has been \nenforcing this for months now already.\n* The Post-History header may be provided as a link instead of a simple date. \nA few BIPs were already doing this.\n* Markdown format is no longer permitted for BIPs. I don't see the point in \nallowing multiple formats, and so far we've been fine with just MediaWiki.\n* The Resolution header has been dropped, as it is not applicable to a \ndecentralised system where no authority exists to make final decisions.\n\nOther changes already in the previous draft of BIP 2:\n* An implementation is now required (when applicable) before BIPs can proceed \nto Proposed Status.\n* BIP Comments are newly introduced.\n* The License preamble headers have been added.\n\nThanks,\n\nLuke"
            },
            {
                "author": "Tom",
                "date": "2016-09-24T09:41:57",
                "message_text_only": "On Saturday, 24 September 2016 06:36:00 CEST Luke Dashjr via bitcoin-dev \nwrote:\n> * OPL will no longer be an acceptable license. Many in the community feel\n> that prohibiting publication is unacceptable for BIPs, and I haven't\n> heard any arguments in favour of allowing it.\n\nMy suggestion would be that we replace OPL as an allowed license with one \nor two Creative Commons licenses. Following the suggestion from the OPL \ncreators themselves.\nAccording to Wikipedia;\n\n> Open Publication License was created by the Open Content Project in 1999 \n> as public copyright license for documents. The license was superseded\n> in 2003/2007 by the Creative commons licenses.\n\nI'd suggest saying that \"Share alike\" is required and \"Attribution\" is \noptional.\n\nExecutive summary; give the user the choice (next to public domain) between \nCCO and BY-SA\nsee;\nhttps://en.wikipedia.org/wiki/\nCreative_Commons_license#Seven_regularly_used_licenses"
            }
        ],
        "thread_summary": {
            "title": "BIP 2 revival and rework",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tom",
                "Luke Dashjr"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2521
        }
    },
    {
        "title": "[bitcoin-dev] New BIP: Limiting excessive SignatureHash operation",
        "thread_messages": [
            {
                "author": "Johnson Lau",
                "date": "2016-09-30T10:57:53",
                "message_text_only": "A new BIP is proposed to prevent excessive O(n^2) SignatureHash operation.\n\nhttps://github.com/jl2012/bips/blob/sighash/bip-sighash.mediawiki\nhttps://github.com/bitcoin/bitcoin/pull/8755 (Tight estimation)\nhttps://github.com/bitcoin/bitcoin/pull/8756 (Loose estimation)\n\nTwo methods of sighash size estimation are proposed, with different tradeoff. The tight estimation is more permissive (disabling less txs) but require disabling of OP_CODESEPARATOR, FindAndDelete, and unusual nHashType. The loose estimation is less permissive (may disable more big and strange txs) but does not depend on further policy/consensus rules. With either type of estimation, normal standard txs (<100kB, P2PK, P2PKH, canonical bare or P2SH multisig) are totally unaffected by this BIP.\n\n  BIP: ?\n  Title: Limiting excessive SignatureHash operation\n  Author: Johnson Lau <jl2012 at xbt.hk>\n  Status: Draft\n  Type: Standards Track\n  Created: 2016-09-21\n\n\nAbstract\n\nThis proposal defines a new type of block-level resources limit, with several (optional) script restrictions, to prevent excessive SignatureHash operation.\n\nIntroduction\n\nThere are 4 ECDSA signature verification codes in the Bitcoin script system: CHECKSIG, CHECKSIGVERIFY, CHECKMULTISIG, CHECKMULTISIGVERIFY (\u201csigops\u201d). According to the SIGHASH type, a transaction digest (sighash) is generated with a double SHA256 of a serialized subset of the transaction, with a function called SignatureHash, and the signature is verified against this sighash with a given public key. Due to a design weakness, the amount of data hashing in SignatureHash is proportional to the size of the transaction. Therefore, data hashing grows in O(n2) as the number of sigops in a transaction increases. While a 1 MB block would normally take 2 seconds to verify with an average computer in 2015, a 1 MB transaction with 5569 sigops may take 25 seconds to verify. [1][2][3]\n\nBIP143 fixes this problem by introducing a new SignatureHash algorithm in segregated witness transactions. However, it would not be able and is not intended to fix the problem of pre-segregated witness transactions. This document proposes a new type of block-level resources limit to prevent excessive SignatureHash operation. However, the calculation of sighash is a complicated process involving several consensus-critical procedures, including the use of OP_CODESEPARATOR, the FindAndDelete function, and the interpretation of nHashType. A correct limitation should be made based on the effects of these procedures.\n\nSpecification\n\nTransaction hashable size\n\nTransaction hashable size (TxHashableSize) is defined as the size of a transaction, which:\n\nis serialized without witness data (BIP144), and\nhas scriptSig in all inputs replaced by zero-size script\nTxHashableSize is an estimation of the amount of data hashed with a SIGHASH_ALL. Without counting the size of scriptCode and nHashType, it always underestimates the size. However, the difference is negligible since it grows linearly with the number of sigops.\nint64_t GetTransactionHashableSize(const CTransaction& tx)\n{\n    int64_t size = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS);\n    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n        int64_t scriptSigSize = tx.vin[i].scriptSig.size();\n        size -= scriptSigSize;\n        // If the scriptSig size is larger than 252, 2 bytes compactSize encoding is deducted.\n        if (scriptSigSize > 252)\n            size -= 2;\n        /*\n         * Theoretically, 4 bytes should be deducted if the scriptSig is larger than 65535 bytes,\n         * and 8 bytes should be deducted if it is larger than 4294967295 bytes.\n         * However, scriptSig larger than 10000 bytes is invalid so it is not needed.\n         */\n    }\n    return size;\n}\nSignatureHash equivalent operation\n\nSignatureHash equivalent operation (SigHashOp) is defined as the maximum possible number of times which a sigop would perform SignatureHash at the TxHashableSize. Depends on whether some extra restrictions in script use are enforced, there are 2 ways to estimate the SigHashOp:\n\nLoose estimation: A loose SigHashOp estimation does not depend on any extra script restrictions. It assumes that SignatureHash is performed not more than once for every ECDSA signature passing to a sigop. It looks for all sigops in a transaction (even in an unexecuted conditional branch), in scriptSig, in scriptPubKey of the outputs being spent, and in redeemScript of P2SH transactions. Each OP_CHECKSIG or CHECKSIGVERIFY is counted as 1 SigHashOp. Each OP_CHECKMULTISIG or CHECKMULTISIGVERIFY is counted as 20 SigHashOp, unless all the following conditions are satisfied:\n\nThe OP_CHECKMULTISIG or CHECKMULTISIGVERIFY is immediately preceded by a value push as OP_n (1 \u2264 n \u2264 16), denoting the number of public keys (n).\nThe n opcodes preceding the OP_n must be push type (i.e. 0x00 \u2264 opcode \u2264 0x60), as the public key(s)\nThe opcodes preceding the public key(s) is a OP_m, with 1 \u2264 m \u2264 16 and m \u2264 n, denoting the number of signatures (m)\nIf all these conditions are met, the OP_CHECKMULTISIG or CHECKMULTISIGVERIFY is counted as m SigHashOp.\nSigHashOp of a transaction is the sum of SigHashOp of each of its inputs.\n\nunsigned int CScript::GetSigHashOpCount() const\n{\n    unsigned int n = 0;\n    const_iterator pc = begin();\n    std::vector<opcodetype> pushOpcodes;\n    while (pc < end())\n    {\n        opcodetype opcode;\n        if (!GetOp(pc, opcode))\n            break; // The script is invalid\n        if (opcode == OP_CHECKSIG || opcode == OP_CHECKSIGVERIFY)\n            n++;\n        else if (opcode == OP_CHECKMULTISIG || opcode == OP_CHECKMULTISIGVERIFY) {\n            unsigned int nKey = 0;\n            unsigned int nSig = 0;\n            // We assume a CHECKMULTISIG will hash the transaction for 20 times, unless it is in some canonical form.\n            n += 20;\n            // The number of keys must be k = 1 to 16 denoted by OP_k\n            if (pushOpcodes.size() >= 3 && pushOpcodes.back() >= OP_1 && pushOpcodes.back() <= OP_16) {\n                nKey = DecodeOP_N(pushOpcodes.back());\n                // All the k + 2 opcodes before the CHECKMULTISIG must be push only\n                if (pushOpcodes.size() >= nKey + 2) {\n                    opcodetype nSigCode = pushOpcodes.at(pushOpcodes.size() - nKey - 2);\n                    // The number of signatures must be k = 1 to 16 denoted by OP_k, and not larger than number of keys\n                    if (nSigCode >= OP_1 && nSigCode <= OP_16) {\n                        nSig = DecodeOP_N(nSigCode);\n                        if (nSig <= nKey)\n                            // We use the number of signatures as the SigOpCount of this CHECKMULTISIG\n                            n = n - 20 + nSig;\n                    }\n                }\n            }\n        }\n\n        if (opcode <= OP_16)\n            pushOpcodes.push_back(opcode);\n        else\n            pushOpcodes.clear();\n    }\n    return n;\n}\nTight estimation: An tight SigHashOp estimation depends on these extra consensus rules for pre-segregated witness scripts:\n\nnHashType is confined to only 6 types: 0x01 for SIGHASH_ALL, 0x02 for SIGHASH_NONE, 0x03 for SIGHASH_SINGLE, 0x81 for SIGHASH_ALL|SIGHASH_ANYONECANPAY, 0x82 for SIGHASH_NONE|SIGHASH_ANYONECANPAY, and 0x83 for SIGHASH_SINGLE|SIGHASH_ANYONECANPAY. A signature with other nHashType is invalid.\nScript with OP_CODESEPARATOR, even in an unexecuted conditional branch, is invalid.\nScript that involves non-zero FindAndDelete results is invalid.\nIt also assumes that SignatureHash is performed not more than once in each script for each nHashType.\nSigHashOp is counted in the same way as the loose estimation. However, if the SigHashOp for a script is found to be larger than 3, it is counted as only 3 SigHashOp.[4] The SigHashOp of a transaction is the sum of SigHashOp of each of its inputs.\n\nSigHashOp of the generating transaction is defined to be 0.\n\nSignatureHash size\n\nSignatureHash size (SigHashSize) of a transaction is the product of TxHashableSize and SigHashOp.\n\nSigHashSize of a block is the sum of SigHashSize of all transactions in the block.\n\nConsensus and policy limits for SigHashSize\n\nA new consensus rule is enforced to require that SigHashSize of a block MUST NOT be larger than 500,000,000 (500MB). Consequently, SigHashSize of a valid transaction MUST NOT be larger than 500MB.\n\nA new relay and mempool policy is recommended to reject any unconfirmed transaction that has a SigHashSize to Transaction weight ratio larger than 90. This policy limit is equivalent to 36MB SigHashSize for a 100kB non-segregated witness transaction, or 360MB for a full block of such transactions.\n\nRationale\n\nStatic analysis\n\nThis proposal employs a static analysis approach to estimate SigHashSize of transactions and blocks. This allows early rejection of violating transactions and blocks without executing the scripts at all. Despite that the size of scriptCode and nHashType are not considered in the estimation, the difference is negligible comparing with size of the main transaction body, since the overheads grows linearly with the number of sigops, which is mostly restricted by the 80,000 sigop limit (BIP141). [5]\n\nLoose SigHashOp estimation\n\nThe loose SigHashOp estimation assumes that SignatureHash is performed not more than once for every ECDSA signature passing to a sigop. This assumption is obviously correct for OP_CHECKSIG and CHECKSIGVERIFY since they would never perform SignatureHash more than once, while no SignatureHash would be performed if they happen in an unexecuted conditional branch, or if the signature is an empty vector. This assumption is also correct for OP_CHECKMULTISIG and CHECKMULTISIGVERIFY with appropriate code refactoring. While a signature may be verified against multiple public keys, the sighash for this signature must remain unchanged across the whole operation and therefore could be reused. Therefore, SigHashOp of a OP_CHECKMULTISIG and CHECKMULTISIGVERIFY is equal to the number of signatures.\n\nTight SigHashOp estimation with extra script restrictions\n\nThe tight SigHashOp estimation is based on more assumptions. It assumes that the scriptCode serialized within SignatureHash is a constant value for all sigops in an transaction input. For this assumption to be true, we must disable any process that may modify the scriptCode, which are OP_CODESEPARATOR and FindAndDelete. Transactions involving OP_CODESEPARATOR and FindAndDelete are extremely rare in the main network, and arguably all of those were performed for testing purpose. Removal of these operations would have next to no functional loss, significantly simply the consensus-critical logic, and reduce the risks of unintentional consensus forks. [6]\n\nThe tight SigHashOp estimation also assumes that only 6 nHashType are allowed. This is a relay policy in reference implementation since v0.?, and transactions with violating signatures are extremely rare in the main network. However, at consensus level, SigHashOp could be any value from 0 to 255, and a SIGHASH type could be encoded in multiple ways. For example, there are 116 ways to denote SIGHASH_ALL. Since nHashType is serialized inside SignatureHash, the sighash produced by different nHashType are not the same, even if all of them were SIGHASH_ALL.\n\nWith all these extra consensus rules implemented, we could be assured that SignatureHash is performed not more than once in each script for each nHashType, due to the invariability of scriptCode. The 6 nHashType limitation further guarantees that each script, with whatever number of sigops, would never perform SignatureHash for more than approximately 3 times of TxHashableSize (excluding some linearly growing overhead), as shown below:\n\nTxHashableSize could be divided into 3 parts: size of inputs, size of outputs, and size of overhead including nVersion, nLockTime, and maybe some CompactSize encoding. The size of overhead grows linearly with the number of sigops, and is negligible.\nSIGHASH_ALL would hash all inputs and outputs of the transaction.\nSIGHASH_NONE would hash all inputs of the transaction, but no output is hashed.\nSIGHASH_SINGLE would hash all inputs of the transaction. It also hashes the scriptPubKey of output with matching index, and all outputs with lower indexes with empty scriptPubKey. With the famous Gauss summation formula, it could be shown that if a transaction has the same number of inputs and outputs, and all inputs use a SIGHASH_SINGLE, the worst case would be hashing approximately 50% of all outputs of the transaction.\nnHashType with SIGHASH_ANYONECANPAY would hash only one input, which scales linearly and is negligible. Therefore,\nSIGHASH_ALL|SIGHASH_ANYONECANPAY would hash all outputs.\nSIGHASH_NONE|SIGHASH_ANYONECANPAY is negligible.\nSIGHASH_SINGLE|SIGHASH_ANYONECANPAY would hash approximately 50% of all outputs in the worst case.\nBy adding up the effects of 6 nHashType, it could be shown that the total amount of data hashed would be equal to 3 times of input size and 3 times of output size. Therefore, in the worst case, a script may perform SignatureHash for up to approximately 3 times of TxHashableSize.\nSigHashSize policy limit\n\nA policy limit for SigHashSize to Transaction weight ratio is recommended as 90, which is equivalent to 36MB SigHashSize for a 100kB non-segregated witness transaction. This limit is chosen based on the concept of normal transaction.\n\nA transaction is normal if each SigHashOp consumes at least 70 bytes of space in scriptSig on average. According to BIP66, the maximum size of an ECDSA signature is 73 bytes, which should consume 74 bytes of scriptSig space including the push opcode. Using the low S value, the maximum signature size becomes 72 bytes. It could be shown that with 99.6% of chance, a randomly generated low S signature would be at least 69 bytes (consuming 70 bytes of space in scriptSig).\n\nIn actual use, the scriptSig size associated to a SigHashOp is often much more than 70 bytes. For example, pay-to-public-key-hash transactions and OP_CHECKMULTISIG inside P2SH would consume extra scriptSig space with their public keys. In such cases, more than 100 bytes of scriptSig would be consumed by a SigHashOp.\n\nIf a transaction is performing many SigHashOp with disproportionately small scriptSig, very likely it employed some strange scripts, such as using OP_DUP to copy a signature.\n\nThe size of scriptSig is important in determining the SigHashSize limit, since it is deducted from the transaction size for the TxHashableSize. Comparing 2 transactions of the same size, the one with more SigHashOp may have smaller SigHashSize due to the smaller TxHashableSize. With the 100kB standard transaction size limit, it could be shown that the maximum SigHashSize happens when there are 714 SigHashOp, consuming at least 714 * 70 = 49.98kB of scriptSig. With the resulting TxHashableSize = 100 - 49.98 = 50.02kB, the SigHashSize is 50.02kB * 714 = 35.7MB, which is just below the recommended policy limit.\n\nDespite the limit is determined based on normal transactions, abnormal transactions may still be accepted as long as they are not too big. For example, if the transaction size is 10kB, a transaction may remain standard with the recommended policy limit even if each SigHashOp is associated with only 7 bytes of scriptSig.\n\nSigHashSize consensus limit\n\nThe consensus limit of 500MB SigHashSize per block is based on the policy limit of SigHashSize to Transaction weight ratio. It is set above the policy limit, to make sure that a miner enforcing the policy limit would never produce a block violating the consensus rules. The 500MB limit is compromise between avoiding loss of functionality (as it may disable some very big transactions) and the harm of intentional or unintentional sighash attack initiated by a miner.\n\nDeployment\n\nThis is a softfork to be deployed with BIP9.\n\nBackward compatibility\n\nImpact of the recommended policy limit\n\nNo matter the loose or the tight SigHashOp estimation is employed, this softfork with recommended policy limit should be completely transparent to users of normal standard transactions, including pay-to-public-key, pay-to-public-key-hash, and P2SH m-of-n OP_CHECKMULTISIG with 1 \u2264 m \u2264 n \u2264 15. A complete scan up to block 430368 showed that the transaction 7b587808a7f6b135ef91011be9b42fcbb0892da50963822e47a5827ced8653ce was the normal standard transaction with highest SigHashSize to weight ratio. With a ratio of 80.1, it is still well below the policy limit of 90. Should this policy had been deployed since genesis block, all normal standard transactions should still have been accepted.\n\nIf the loose estimation had been employed, a few abnormal standard transactions would have been rejected by policy, but were still valid by consensus. This is a full list of the affected transactions:\n\n    bea1c2b87fee95a203c5b5d9f3e5d0f472385c34cb5af02d0560aab973169683\n    24b16a13c972522241b65fbb83d09d4bc02ceb33487f41d1f2f620b047307179\n    53666009e036171b1aee099bc9cd3cb551969a53315410d13ad5390b8b4f3bd0\n    ffc178be118bc2f9eaf016d1c942aec18441a6c5ec17c9d92d1da7962f0479f6\n    2f1654561297114e434c4aea5ca715e4e3f10be0be8c1c9db2b6f68ea76dae09\n    62fc8d091a7c597783981f00b889d72d24ad5e3e224dbe1c2a317aabef89217e\n    d939315b180d3d73b5e316eb57a18f8137a3f5943aef21a811660d25f1080a3f\n    8a6bfaa78828a81147e4848372d491aa4e9048631982a670ad3a61402a4ec327\n    02cc78789cc070125817189ec378daa750355c8b22bbce982ed96aa549facb1f\n    b97a16ae2e8ae2a804ed7965373b42055f811653f4628e4bef999145d4b593bc\n    c51ffaf08188859669571f897f119b6d39ea48a9334212f554bf4927401b71f3\n    324456fe9ec97a380effba0a0205a226e380790b93e7366d39f2a416a44d2a34\nThese transactions all used a large number of sigops, and obviously were made for testing purpose. However, they would have gone through if the tight estimation had been used.\n\nImpact of the block-level consensus limit\n\nWith the block-level consensus limit of 500MB SigHashSize, transactions with SigHashSize above 500MB would also become invalid. Up to block 430368, 49 transactions would have become invalid with this limit (with either loose or tight estimation):\n\n    Transaction ID                                                       SigHashSize\n    9c667c64fcbb484b44dcce638f69130bbf1a4dd0fbb4423f58ceff92af4219ec\t 2,215,084,200\n    9fdbcf0ef9d8d00f66e47917f67cc5d78aec1ac786e2abb8d2facb4e4790aad6\t 2,215,076,850\n    5d8875ed1707cfee2221741b3144e575aec4e0d6412eeffe1e0fa07335f61311\t 1,271,892,772\n    cb550c9a1c63498f7ecb7bafc6f915318f16bb54069ff6257b4e069b97b367c8\t 1,271,892,772\n    14dd70e399f1d88efdb1c1ed799da731e3250d318bfdadc18073092aa7fd02c2\t 1,271,892,772\n    a684223716324923178a55737db81383c28f055b844d8196c988c70ee7075a9a\t 1,271,892,772\n    bb41a757f405890fb0f5856228e23b715702d714d59bf2b1feb70d8b2b4e3e08\t 1,271,820,375\n    5b0a05f12f33d2dc1507e5c18ceea6bb368afc51f00890965efcc3cb4025997d\t 1,091,954,040\n    bb75a8d10cfbe88bb6aba7b28be497ea83f41767f4ee26217e311c615ea0132f\t 1,025,295,000\n    5e640a7861695fa660343abde52cfe10b5a97dd8fc6ad3c5e4b2b4bb1c8c3dd9\t 1,025,295,000\n    dd49dc50b54b4bc1232e4b68cfdd3d349e49d3d7fe817d1041fff6dd583a6eaf\t 1,025,230,000\n    3d724f03e8bcc9e2e3ea79ebe4c6cffca86d85e510742cd6d3ac29d420787a34\t 1,025,210,000\n    8bcf8e8d8265922956bda9b651d2a0e993072c9dca306f3a132dcdb95c7cee6e\t 1,025,210,000\n    54bf51be42ff45cdf8217b07bb233466e18d23fd66483b12449cd9b99c3a0545       995,042,075\n    6bb39576292c69016d0e0c1fe7871640aab12dd95874d67c46cf3424822f8dfd\t   988,589,147\n    d38417fcc27d3422fe05f76f6e658202d7fa394d0c9f5b419fef97610c3c49f1\t   923,884,836\n    66b614e736c884c1a064f7b0d6a9b0abd97e7bb73ac7e4b1b92b493d558a0711\t   902,501,490\n    d985c42bcd704aac88b9152aede1cca9bbb6baee55c8577f84c42d600cfec8e4\t   898,372,800\n    e32477636e47e1da5fb49090a3a87a3b8ff637d069a70cd5b41595da225e65b4\t   893,548,487\n    bf40393fedc45a1b347957124ef9bb8ae6a44feecee10ef2cc78064fabf8125f\t   891,859,369\n    1d93bfe18bc05b13169837b6bc868a92da3c87938531d6f3b58eee4b8822ecbf\t   888,420,676\n    79e30d460594694231f163dd79a69808904819e2f39bf3e31b7ddc4baa030a04\t   877,542,875\n    4eba5deb2bbf3abf067f524484763287911e8d68fb54fa09e1287cf6cd6d1276\t   874,353,609\n    c3f2c2df5388b79949c01d66e83d8bc3b9ccd4f85dbd91465a16fb8e21bf8e1b\t   869,060,209\n    446c0a1d563c93285e93f085192340a82c9aef7a543d41a86b65e215794845ef\t   833,655,283\n    e0c5e2dc3a39e733cf1bdb1a55bbcb3c2469f283becf2f99a0de771ec48f6278\t   802,433,929\n    2e7c454cfc348aa220f53b5ba21a55efa3d36353265f085e34053c4efa575fda\t   789,067,716\n    01d23d32bccc04b8ca5a934be16da08ae6a760ccaad2f62dc2f337eee7643517\t   785,833,449\n    9f8cc4496cff3216608c2f2177ab360bd2d4f58cae6490d5bc23312cf30e72e0\t   775,457,104\n    1e700d8ce85b17d713cad1a8cae932d26740e7c8ab09d2201ddfe9d1acb4706c\t   757,230,231\n    9db4e0838c55ef20c5eff271fc3bf09a404fff68f9cdad7df8eae732500b983d\t   756,319,396\n    763e13f873afa5f24cd33fc570a178c65e0a79c05c88c147335834fc9e8f837b\t   734,988,489\n    b8ba939da1babf863746175b59cbfb3b967354f04db41bd13cb11da58e43d2a8\t   732,906,849\n    f62f2c6a16b5da61eaae36d30d43bb8dd8932cd89b40d83623fa185b671c67f9\t   723,659,859\n    6e278c0ca05bf8e0317f991dae8a9efa141b5a310a4c18838b4e082e356ef649\t   703,394,401\n    e3de81a5817a3c825cf44fbf8185e15d446393615568966a6e3fc22cba609c7d\t   697,632,336\n    b5ca68205e6d55e87bd6163b28467da737227c6cbcc91cb9f6dc7b400163a12b\t   665,208,049\n    9c972a02db30f9ee91cc02b30733d70d4e2d759b5d3c73b240e5026a8a2640c4\t   653,370,601\n    02313ac62ca8f03930cdc5d2e437fabc05aea60a31ace18a39678c90b45d32bd\t   622,323,625\n    e245f6c3c6b02dc81ea1b6694735565cc535f603708783be027d0e6a94ac3bd5\t   609,926,656\n    1cf52f9ef89fa43bb4f042cbd4f80e9f090061e466cbe14c6b7ba525df0e572e\t   607,214,327\n    461308024d89ea4231911df4ef24e65e60af2a9204c8282a6b67f4214c1714e7\t   606,137,296\n    fa5a58f787f569f5b8fab9dadb2447161fac45b36fb6c2c0f548ed0209b60663\t   589,853,184\n    905df97982a2904d6d1b3dfc272435a24d705f4c7e1fc4052798b9904ad5e597\t   546,737,250\n    d85ce71f583095a76fb17b5bb2a1cbf369e2a2867ca38103aa310cbb2aaf2921\t   546,737,250\n    1b604a075075197c82d33555ea48ae27e3d2724bc4c3f31650eff79692971fb7\t   531,511,200\n    ba31c8833b7417fec9a84536f32fcb52d432acb66d99b9be6f3899686a269b2b\t   531,511,200\n    92f217ec13ab309240adc0798804b3418666344a5cbfff73fb7be8192dad5261\t   509,443,536\n    22e861ee83c3d23a4823a3786460119425d8183783068f7ec519646592fac8c2\t   506,268,969\nExtra consensus rules required by tight SigHashOp estimation\n\nTransactions in the main network, up to block 430368, that would have been affected by the extra consensus rules are listed below:\n\nTransactions with OP_CODESEPARATOR:\n\n    eb3b82c0884e3efa6d8b0be55b4915eb20be124c9766245bcc7f34fdac32bccb\n    055707ce7fea7b9776fdc70413f65ceec413d46344424ab01acd5138767db137\n    6d36bc17e947ce00bb6f12f8e7a56a1585c5a36188ffa2b05e10b4743273a74b\n    bc179baab547b7d7c1d5d8d6f8b0cc6318eaa4b0dd0a093ad6ac7f5a1cb6b3ba\n    4d932e00d5e20e31211136651f1665309a11908e438bb4c30799154d26812491\n    0157f2eec7bf856d66714856182a146998910dc6fa576bec200a9fa8039459e7\n    ddd070541bf2fddaa5e08a9d93126f73211fe15291beb897c762908949420ad9\n    d4a27d10404d87ee0b8a05fb700e55f9f83f80a59ebf87af2fbf87e5c9546177\n    492cdb3c95c1fe0c597d8dc847adb5459d403ea083f4b5e706300d437c84748f\n    b3e977a2c48145255d84e1c82d4ea07522528991d50ead1cf3a783559d9733e3\nTransactions with non-zero FindAndDelete results:\n\n    5df1375ffe61ac35ca178ebb0cab9ea26dedbd0e96005dfcee7e379fa513232f\n    ded7ff51d89a4e1ec48162aee5a96447214d93dfb3837946af2301a28f65dbea\n    307b173ef009b970c1a0dd67166a8ce3e91fc5551b8950d2d17f1fe0eaa07358\nTransactions with abnormal nHashType:\n\n    c99c49da4c38af669dea436d3e73780dfdb6c1ecf9958baa52960e8baee30e73\n    0ad07700151caa994c0bc3087ad79821adf071978b34b8b3f0838582e45ef305\n    7c451f68e15303ab3e28450405cfa70f2c2cc9fa29e92cb2d8ed6ca6edb13645\n    a6c116351836d9cc223321ba4b38d68c8f0db53661f8c2229acabbc269c1b2c8\n    f5efee46ccfa4191ccd9d9f645e2f5d09bbe195f95ef5608e992d6794cd653cd\n    904bda3a7d3e3b8402793334a75fb1ce5a6ff5cf1c2d3bcbd7bd25872d0e8c1e\n    8ac76995ce4ac10dd02aa819e7e6535854a2271e44f908570f71bc418ffe3f02\n    e218970e8f810be99d60aa66262a1d382bc4b1a26a69af07ac47d622885db1a7\n    ba4f9786bb34571bd147448ab3c303ae4228b9c22c89e58cc50e26ff7538bf80\n    38df010716e13254fb5fc16065c1cf62ee2aeaed2fad79973f8a76ba91da36da\nReference Implementation\n\nPolicy only:\n\nhttps://github.com/bitcoin/bitcoin/pull/8755 (Tight estimation)\nhttps://github.com/bitcoin/bitcoin/pull/8756 (Loose estimation)\nReferences\n\n^ CVE-2013-2292\n^ New Bitcoin vulnerability: A transaction that takes at least 3 minutes to verify\n^ The Megatransaction: Why Does It Take 25 Seconds?\n^ It should be noted that since sigops may exist in both scriptSig (non-standard and extremely rare) and scriptPubKey, in theory an input may have up to 6 SigHashOp\n^ Not totally, since it does not count the sigops inside the scriptPubKey of the outputs being spent, while inappropriately counting sigops in scriptPubKey of the current transaction.\n^ https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-November/006878.html\nCopyright\n\nThis document is placed in the public domain."
            }
        ],
        "thread_summary": {
            "title": "New BIP: Limiting excessive SignatureHash operation",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Johnson Lau"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 25106
        }
    }
]