[
    {
        "title": "[bitcoin-dev] Floating-Point Nakamoto Consensus",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2020-10-01T01:36:35",
                "message_text_only": "Good morning Mike,\n\n> ZmnSCPxj,\n>\n> The growing tare in growing disagreement continues to divide mining capacity while the network waits for formation of future blocks - you'll never get to complete\u00a0consensus\u00a0unless three is a way to avoid ambiguity in\u00a0disagreement,\u00a0which you have not addressed.\u00a0 The topic of my discussion is an exploitable condition, your three block plan does not add up.\n>\n> I wrote the exploit before I wrote the paper. It is telling that still no one here has refenced the threat model, which is the largest section of the entire 8 page paper.\u00a0 The security came before the introduction of FPNC because security\u00a0fundamentals\u00a0is what drives the necessity for the solution.\n>\n> The text you are reading right now was delivered using the mailing list manager\u00a0Majordomo2, which I shelled in 2011 and got a severity metric and an alert in the DHS newsletter. Correct me if I am wrong, but I bet that just of my exploits has probably\u00a0popped more shells than everyone on this thread combined.\u00a0\u00a0 Cryptography?\u00a0 Sure, I'll brag about the time I hacked Square Inc. This is actually my current favorite crypto exploit\u00a0\u2014 it was the time I used DKIM signature-malleability to conduct a replay-attack that allowed an adversary to replay another user's transactions an unlimited number of times. After receiving\u00a0a normal payment from another Square user you could empty their account.\u00a0 This was reported ethically and it was a mutual joy to work with such a great team.\u00a0 Now it is not just impact, but I am also getting the feeling that I have collected more CVEs, all this is to say that I'm not new to difficult vendors.\n\nArgument screens off authority, thus, even if I have no CVEs under this pseudonym, argument must still be weighted more highly than any authority you may claim.\n\n> To be blunt; some of you on this thread are behaving like a virgin\u00a0reading a trashy love novel and failing to see the point \u2014 Just because you aren't excited, doesn't mean that it isn't hot.\n>\n> The exploit described in this paper was delivered to the Bitcoin-core security team on August 4 at 9:36 PM PST.\u00a0 The industry standard of 90 days gives you until November 2nd. Now clearly, we need more time. However,\u00a0if the consensus is a rejection, then there shouldn't be any concerns with a sensible 90-day disclosure policy.\u00a0\n\nI am not a member of this security team, and they may have better information and arguments than I do, in which case, I would defer to them if they are willing to openly discuss it and I find their arguments compelling.\n\nThe attack you describe is:\n\n* Not fixable by floating-point Nakamoto consensus, as such a powerful adversary can just as easily prevent propagation of a higher-score block.\n* Broken by even a single, manually-created connection between both sides of the chain-split.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-10-01T06:47:01",
                "message_text_only": "Good morning Mike,\n\nThat is better than implied name-calling and refusing to lay out your argument in detail.\nIt is still sub-optimal since you are still being insulting by labeling me as \"reactionary\", when you could have just laid out the exact same argument ***in the first place*** without being unnecessarily inflammatory, but this is significantly better than your previous behavior.\n\nI also strongly prefer to discuss this openly on the mailing list.\n\n> Consider for one moment when the words I\u00a0have said are correct. Take this moment\u00a0to see the world from someone else's eyes, and do not be reactionary - just be.\n>\n> Good.\n>\n> Consider a threat model, where nodes are unable to form new connections,\u00a0unless the attacker allows it to happen. The point of threat modeling is not to question if it is possible, but rather to plan on failure because we live in a world where failure happens. Now if you are in a world of limited visibility, and a presented solution has no intrinsic\u00a0value other than it's length - then you create a node that is gullible.\u00a0An adversary that controls\u00a0connections can lie that a new solution was ever even found or selectivally slow the formation of this side of the disagreement, and probably other\u00a0bad things too.\u00a0 \u00a0That sucks, and no one is saying that there is a complete solution to this problem and we are all here to help.\n>\n> You are absolutely\u00a0correct - the eclipse effect is never going to be perfect. Which is your point,\u00a0and it's accurate. Imperfections in the node's visibility\u00a0allow for a more-fit\u00a0solution\u00a0to leak out, and ultimately an identical consensus to form - so long as there is some measure to judge the fitness of two disagreements of identical length.\n\nThis is the point at which I think your argument fails.\n\nYou are expecting:\n\n* That the attacker is powerful enough to split the network.\n* That the attacker is adept enough that it can split the network such that mining hashpower is *exactly* split in half.\n* That the universe is in an eldritch state such that at the exact time one side of the chain split finds a block, the other side of the chain split *also* finds a block.\n\nThis leads to a metastable state, where both chain splits have diverged and yet are at the exact same block height, and it is true that this state can be maintained indefinitely, with no 100% assurance it will disappear.\n\nYet this is a [***metastable***](https://en.wikipedia.org/wiki/Metastability) state, as I have mentioned.\nSince block discovery is random, inevitably, even if the chain splits are exactly equal in mining hashpower, by random one or the other will win the next block earlier than the other, precisely due to the random nature of mining, and if even a single direct connection were manually made between the chain splits, this would collapse the losing chain split and it will be reorganized out without requiring floating-point Nakamoto.\n\nThis is different if the coin had non-random block production, but fortunately in Bitcoin we use proof-of-work.\n\nThe confluence of too many things (powerful attacker, exact hashpower split, perfect metastability) is necessary for this state --- and your solution to this state --- to actually ***matter*** in practice.\nI estimate that it is far more likely my meat avatar will be destroyed in a hit-and-run accident tomorrow than such a state actually occurring, and I do not bother worrying about my meat avatar being destroyed by a hit-and-run accident tomorrow.\n\nAnd in Bitcoin, leaving things alone is generally more important, because change is always a risk, as it may introduce *other*, more dangerous attacks that we have not thought of.\nI would suggest deferring to those in the security team, as they may have more information than is available to you or me.\n\n>\u00a0 This minor change of adding a fitness test to solve disagreements is intended to diminish the influence of delayed message passing, and yes there are multiple solutions to this problem, absolutely, but bringing this fact up just derails the important parts of the conversation.\u00a0\n>\n> By the client having limited visibility, then non-voting nodes who simply pass messages *are* given a say in the election process, and that is a problem.\u00a0 \u00a0Any attacker can more easily control\u00a0when a message arrives than a good fitness value.\u00a0 \u00a0The old 2013 solution was about naming one side a looser, but that doesn't really help.\u00a0 It isn't just about calling one solution a winner and a loser. We need to make sure that all descendants\u00a0of weak solutions are also going to be weak - and that my friend is the basis for a genetic algorithm.\n>\n> -Michael Brooks\u00a0\n> (my real name)\n\nDo you think emphasizing that this is your real name ***matters*** compared to actual technical arguments?\n\n>\n> On Wed, Sep 30, 2020 at 6:45 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> > Good morning Mike,\n> >\n> > > You are incorrect.\u00a0\n> >\n> > You make no argument to back this claim, so I will now refuse to engage with you.\n> >\n> > Regards,\n> > ZmnSCPxj\n> >\n> > >\n> > > On Wed, Sep 30, 2020, 6:36 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> > >\n> > > > Good morning Mike,\n> > > >\n> > > > > ZmnSCPxj,\n> > > > >\n> > > > > The growing tare in growing disagreement continues to divide mining capacity while the network waits for formation of future blocks - you'll never get to complete\u00a0consensus\u00a0unless three is a way to avoid ambiguity in\u00a0disagreement,\u00a0which you have not addressed.\u00a0 The topic of my discussion is an exploitable condition, your three block plan does not add up.\n> > > > >\n> > > > > I wrote the exploit before I wrote the paper. It is telling that still no one here has refenced the threat model, which is the largest section of the entire 8 page paper.\u00a0 The security came before the introduction of FPNC because security\u00a0fundamentals\u00a0is what drives the necessity for the solution.\n> > > > >\n> > > > > The text you are reading right now was delivered using the mailing list manager\u00a0Majordomo2, which I shelled in 2011 and got a severity metric and an alert in the DHS newsletter. Correct me if I am wrong, but I bet that just of my exploits has probably\u00a0popped more shells than everyone on this thread combined.\u00a0\u00a0 Cryptography?\u00a0 Sure, I'll brag about the time I hacked Square Inc. This is actually my current favorite crypto exploit\u00a0\u2014 it was the time I used DKIM signature-malleability to conduct a replay-attack that allowed an adversary to replay another user's transactions an unlimited number of times. After receiving\u00a0a normal payment from another Square user you could empty their account.\u00a0 This was reported ethically and it was a mutual joy to work with such a great team.\u00a0 Now it is not just impact, but I am also getting the feeling that I have collected more CVEs, all this is to say that I'm not new to difficult vendors.\n> > > >\n> > > > Argument screens off authority, thus, even if I have no CVEs under this pseudonym, argument must still be weighted more highly than any authority you may claim.\n> > > >\n> > > > > To be blunt; some of you on this thread are behaving like a virgin\u00a0reading a trashy love novel and failing to see the point \u2014 Just because you aren't excited, doesn't mean that it isn't hot.\n> > > > >\n> > > > > The exploit described in this paper was delivered to the Bitcoin-core security team on August 4 at 9:36 PM PST.\u00a0 The industry standard of 90 days gives you until November 2nd. Now clearly, we need more time. However,\u00a0if the consensus is a rejection, then there shouldn't be any concerns with a sensible 90-day disclosure policy.\u00a0\n> > > >\n> > > > I am not a member of this security team, and they may have better information and arguments than I do, in which case, I would defer to them if they are willing to openly discuss it and I find their arguments compelling.\n> > > >\n> > > > The attack you describe is:\n> > > >\n> > > > * Not fixable by floating-point Nakamoto consensus, as such a powerful adversary can just as easily prevent propagation of a higher-score block.\n> > > > * Broken by even a single, manually-created connection between both sides of the chain-split.\n> > > >\n> > > > Regards,\n> > > > ZmnSCPxj\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Mike Brooks",
                "date": "2020-10-04T15:58:58",
                "message_text_only": "Good Morning ZmnSCPxj ,\n\nIt is cheaper and easier to delay messages, or preempt the spreading of\nmessages, than it is to produce a better fitness score. Whether it be\nthrough pre-emption or an eclipse - an adversary can influence the size of\nboth sides of the disagreement, which is a strange feature for any network\nto have.  \"First seen\" is a factor of time, time is an attacker-controlled\nelement, and this dependence on time creates a race-condition.\n\nMy original statement is that it is cheaper to introduce a large number of\nnon-voting nodes, than it is compeate on mining power -  holds true.  It\ndoesn't have to be perfect to be a shortcut, an adversary can perform the\nsame kind of impact as 51% attack - so long as they have a sufficient\nnumber of non-voting nodes.   My language here is referring to the original\npaper which makes reference to non-voting nodes and that the electorate\nmust only be made by computational effort. However, a sufficient number of\nnon-voting nodes who diligently pass messages, hold the keys to the kingdom.\n\n\n> This is the point at which I think your argument fails.\n>\n> You are expecting:\n>\n> * That the attacker is powerful enough to split the network.\n> * That the attacker is adept enough that it can split the network such\n> that mining hashpower is *exactly* split in half.\n> * That the universe is in an eldritch state such that at the exact time\n> one side of the chain split finds a block, the other side of the chain\n> split *also* finds a block.\n>\n\n* Power is relative, my only comment is that message passing is cheaper\nthan mining - and that this proposed attack is somewhat better than 51%\nmining attack.\n* Assuming all adversaries are crippled will not produce a very good threat\nmodel.\n* Both sides need to be more or less equal - in practice I don't think this\nneeds to be exact, and only needs to be held open long enough to trick\nvalidators.  It can and will be unstable, but still exploitable.\n\nThis leads to a metastable state, where both chain splits have diverged and\n> yet are at the exact same block height, and it is true that this state can\n> be maintained indefinitely, with no 100% assurance it will disappear.\n>\n> Yet this is a [***metastable***](\n> https://en.wikipedia.org/wiki/Metastability) state, as I have mentioned.\n> Since block discovery is random, inevitably, even if the chain splits are\n> exactly equal in mining hashpower, by random one or the other will win the\n> next block earlier than the other, precisely due to the random nature of\n> mining, and if even a single direct connection were manually made between\n> the chain splits, this would collapse the losing chain split and it will be\n> reorganized out without requiring floating-point Nakamoto.\n>\n\nMr Nakamoto is assuming normal network conditions - if a majority of\nmessages are passed by malicious nodes, then this conjecture no longer\nholds.  If the majority are dishonest, and non-voting, then the rules\nchange.\n\n\n> And in Bitcoin, leaving things alone is generally more important, because\n> change is always a risk, as it may introduce *other*, more dangerous\n> attacks that we have not thought of.\n> I would suggest deferring to those in the security team, as they may have\n> more information than is available to you or me.\n\n\nOffline, we had discussed that there is currently an active\nmalicious-mining campaign being conducted against the Bitcoin network.\nLarge mining pools will delay the broadcast of a block that they have\nformed in order to have a slight advantage on the formation of the next\nblock.   Currently, there is an economic incentive for the formation of\ndisagreement and it is being actively exploited.   FPNC means that blocks\nbelow the 1/2 cut-off are greatly incentivised to be broadcast as quickly\nas possible, and blocks above the cutt-off could be held onto a little\nlonger.  This withholding attack is already taking place because there is\nan economic incentive.  Although no proposed solution can prevent it\ncompletely,  seeing that this bad thing would happen 1/2 as often - I see\nthis as an absolute win.\n\n-Michael\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201004/09298415/attachment-0001.html>"
            },
            {
                "author": "Larry Ruane",
                "date": "2020-10-01T16:42:27",
                "message_text_only": "Hello Mike and others,\n\nI just want to plug the open-source POW network mining simulator I recently\nwrote: https://github.com/LarryRuane/minesim\n\nIt simulates Bitcoin's existing POW (of course), but probably would be easy\nto modify to correspond to variations such as the one being proposed here.\nSometimes simulating an algorithm can lead to insights beyond what's\npossible using only abstract reasoning.\n\nLarry Ruane\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201001/b36963e0/attachment.html>"
            },
            {
                "author": "Mike Brooks",
                "date": "2020-10-01T19:26:01",
                "message_text_only": "Hey Larry,\n\nGreat project, and great youtube video.   Expect a PR from me.\n\n... If you actively ping nodes that are running a weaker block, you could\ninform them of the new block, there could be a mechanism to\neradicate dissent.\n\n-Mike\n\n\nOn Thu, Oct 1, 2020 at 9:43 AM Larry Ruane <larryruane at gmail.com> wrote:\n\n> Hello Mike and others,\n>\n> I just want to plug the open-source POW network mining simulator I\n> recently wrote: https://github.com/LarryRuane/minesim\n>\n> It simulates Bitcoin's existing POW (of course), but probably would be\n> easy to modify to correspond to variations such as the one being proposed\n> here. Sometimes simulating an algorithm can lead to insights beyond what's\n> possible using only abstract reasoning.\n>\n> Larry Ruane\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201001/83b186ac/attachment.html>"
            },
            {
                "author": "Bob McElrath",
                "date": "2020-10-08T18:43:00",
                "message_text_only": "A diversion on statistics:\n\nThere are two quantities available for consensus:\n    t   target difficulty\n    h   block hash where h < t\n>From these we can form two quantities that might be used in consensus:\n    w   work    = log(sum(1/t_i))\n    f   fitness = log(sum(1/h_i))   (term used by authors)\n\n(The original authors do not specify mathematically how they obtain their\nnumbers -- but it doesn't really matter, fundamentally, they want to use the\nblock hash h instead of t) Bitcoin introduces some constants in the above sums\nwhich I omit for clarity.\n\nThe main point here is that the work w is an unbiased statistical estimator for\nthe number of sha256d computations performed by the network. It is truly a\nmeasurement of \"work\". The fitness f is a *biased* estimator for exactly the\nsame thing, and other than introducing statistical bias, provides no additional\ninformation of any value.\n\nThe fundamental question of FPNC as I understand it is: should we introduce the\nhistoric block hash h as a consensus-critical parameter?\n\nThe answer is a strict no: This quantity f (fitness) is purely random, and does\nnot in any way favor the \"honest\" chain, nor can it identify it. Between two\ncompeting chains, the amount of bias on one chain vs. the other is purely random\nand does *not* reflect more work done by one side or the other. Nor can it have\nany knowledge of things like network splits.\n\nAt constant difficulty assuming two competing chains with exactly the same\nnumber of blocks and amount of hashpower, this bias will oscillate, sometimes\nfavoring one side, sometimes favoring the other. Unlike work, this bias is not\ncumulative. Each side will over time converge to having the same amount of bias\nfrom any biased estimator such as f constructed from the hashes h. Just because\none side had an abnormally small hash doesn't mean the other side won't have a\nsimilar abnormally low hash. The expectation value for the amount of bias is\nequal on both sides.\n\nTherefore, hard NACK on using h in this way and FPNP. At best it introduces\nunecessary randomness into the chain selection process, at worst it proves a new\ngame to be played by miners. As a consensus critical change, it's also\nincredibly risky to push through without some very serious advantage, which this\ndoes not have.\n\n--\nCheers, Bob McElrath\n\n\"For every complex problem, there is a solution that is simple, neat, and wrong.\"\n    -- H. L. Mencken"
            },
            {
                "author": "Mike Brooks",
                "date": "2020-10-10T00:59:31",
                "message_text_only": "Hey Bob McElarth,\n\nI appreciate this discussion.  The issues with chain thrashing was\nexplicitly addressed with heredity, I saw this problem, and there is an\nelegant solution here.\n\nSorry that summation process wasn't made clear in the paper, I'll be sure\nto go back and improve this.   Here is a full implementation which should\nresolve the confusion around the summation of fitness scores:\n   https://github.com/bitcoin/bitcoin/pull/19665/files\n\nThere is however a minor mistake in the code and in the paper.  We have\nchanged our position a bit after Franck Royer's post on this thread.   I\nthink generally optimizing for lower value is a better approach as this\nresolves the procession of difficulty when producing blocks across an epoch\ndivide.  Optimizing for a higher non-zero value would place a non-zero at\nthe most significant octet, which is avoided by optimizing for a lower\noverall numeric value of the solution.  Or, put another way; the lowest\nbase10 numeric summation of both chains starting at the point of their\ndisagreement.\n\nThe main point here is that the work w is an unbiased statistical estimator\n> for\n> the number of sha256d computations performed by the network. It is truly a\n> measurement of \"work\". The fitness f is a *biased* estimator for exactly\n> the\n> same thing, and other than introducing statistical bias, provides no\n> additional\n> information of any value.\n>\n\nFPNC is an extension of the same measure of work, any criticism of\nzero-prefix in base16 should also be a criticism of zero-prefix in base2 or\nany other base.  A change in base should not affect the bias, and\noptimizing for a lower value in big-endian has a continuous difficulty\ncurve. So long as sha2564 remains ideal no bias will be introduced.\n\nThe fundamental question of FPNC as I understand it is: should we introduce\n> the\n> historic block hash h as a consensus-critical parameter?\n>\n> The answer is a strict no: This quantity f (fitness) is purely random, and\n> does\n> not in any way favor the \"honest\" chain, nor can it identify it. Between\n> two\n> competing chains, the amount of bias on one chain vs. the other is purely\n> random\n> and does *not* reflect more work done by one side or the other. Nor can it\n> have\n> any knowledge of things like network splits.\n>\n\nA zero-prefix has the direct effort of lowering the big-endian base16 value\nof the hash, and with each epoch the numeric value of the solution is\nfurther decreased. A floating-point evaluation introduces the concept that\nno two blocks can ever be of equal value unless they are in fact the same\nhash value.  We are in full agreement with the statement you made above,\nthere is nothing intrinsic about the honest chain vs any other chain \u2014\nnodes are acting on an empirical evaluation.  It should only take 10-20\nseconds of propagation for every node on the global network to see every\nsolution block, if we remove ambiguity and make sure that no two blocks are\nthe same value, since all nodes see all solutions they should all choose\nthe same highest-value solution.\n\n\n> At constant difficulty assuming two competing chains with exactly the same\n> number of blocks and amount of hashpower, this bias will oscillate,\n> sometimes\n> favoring one side, sometimes favoring the other. Unlike work, this bias is\n> not\n> cumulative. Each side will over time converge to having the same amount of\n> bias\n> from any biased estimator such as f constructed from the hashes h. Just\n> because\n> one side had an abnormally small hash doesn't mean the other side won't\n> have a\n> similar abnormally low hash. The expectation value for the amount of bias\n> is\n> equal on both sides.\n\n\nAh!  Yes!  Thank you so much for bringing this up.  This is the single most\nimportant part of the entire soltuion, and I am so happy to have this\ndiscussion.   If this solution was simply labeling one side a winner and\nanother side a loser, then there is no incentive for mining efforts to\nmigrate, and with the incentives of sunken cost into mining would be enough\nto keep nodes from switching.  So If the solution was simply a label then\nyour statement above would be correct...  However, this exact situation was\ntaken into consideration.\n\nIn the current protocol clients always choose the chain of greatest value,\nbecause trying mine a full block behind would require more than 50% of the\nnetwork power to \"catch up.\"  No miner in their right mind would choose to\nbe behind the network.   If this evaluation is made on the floating-point\nscale, as in not whole numbers and not whole blocks \u2014 then the exact same\nproperties of behind still come into play.  No miner chooses to mine from\nN-1 blocks, because they would be behind, just as no miner would choose to\nmine from a N-0.5 block.   The threat of generating a loser block from a\nloser parent outweighs any other incentive.  The heredity of block fitness\ncreates convergence on the most valuable chain.  When looking at the\nelectorate over time, more miners will choose to mine with the higher-value\ncoinbase - thus eroding support for the computational effort needed to\nsustain the disagreement.  No thrashing will happen, because no miner has\nincentives for this to happen.\n\nNodes on the network cannot know the history of a block or why it was\nproduced,  but through an empirical measure of value we can have a protocol\nthat avoids ambiguity in the block selection process and prevents\ndisagreement from forming.   Ambiguity in block selection is also\nexploitable, through pre-emption one solution can dominate a \"first seen\"\nsystem, and any dissent can be silenced with DoS.  But using\nresource-consumption attacks and the exploitation of a race-condition to\ngain an edge isn't helpful if there isn't a disagreement to shape. The\ndisagreement here is powerful miners trying to prove each other wrong, but\nif they had a more accurate measure of value \u2014 there would be no reason to\never disagree.\n\nAll the best,\nMichael\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201009/f3e82efc/attachment-0001.html>"
            },
            {
                "author": "Mike Brooks",
                "date": "2020-10-10T01:26:07",
                "message_text_only": "James,\n\nFPNC and NC will always select the highest-work chain, I am suggesting that\nby adding more bits of precision we avoid confusion.\n\nPart 2 -> Using a genetic algorithm that passes fitness with heredity to\nresolve disagreements has never been introduced to this mailing list.  This\nhard-nack is null and void.\n\nBest Regards,\nMichael\n\nOn Tue, Sep 29, 2020 at 12:30 AM LORD HIS EXCELLENCY JAMES HRMH via\nbitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good Afternoon,\n>\n> Re: [bitcoin-dev] Floating-Point Nakamoto Consensus\n>\n> I note that the discussion thread for this proposal has previously\n> received HARD_NAK\n>\n> I note in the whitepaper the following basic introduction of need:\n> >As a result anode will simply adopt the first solution seen, creating a\n> kind of race condition.\n>\n> The said race condition, it is not noted, is 'self-resolving' with the\n> network adopting the longest chain with the highest proof of work as any\n> contentious tip is built on. This is the proper reason for waiting for two\n> confirmations for a transaction as a minimum proof of its inclusion in the\n> blockchain (without fraud), and for waiting for six confirmations before\n> considering that a transaction is 'final'.\n>\n> I take it that your work is intended to allow the network to decide\n> immediately without waiting for a chain to be further extended, in that\n> case, the solution should be as noted elsewhere to accept the higher proof\n> of work with the greater precision proof. When comparing two competing\n> blocks there is an indirect reference to a higher proof of work due to the\n> greater precision in the block hash, although the answer could have been\n> arrived with fewer attempts. As it is, the total proof of work is not\n> directly calculated but is evaluated as the chain with more blocks being\n> the chain with more proof-of-work, whereas in the cases two blocks are\n> received as alternates extending the same chain tip there is currently no\n> method of comparison to determine which of the blocks, and the correct tip\n> is not chosen without further proof-of-work to extend a tip. Resolving this\n> reduces the network expense of reorganisation in ordinary conditions but in\n> the case of a network-split resolves nothing.\n>\n> KING JAMES HRMH\n> Great British Empire\n>\n> Regards,\n> The Australian\n> LORD HIS EXCELLENCY JAMES HRMH (& HMRH)\n> of Hougun Manor & Glencoe & British Empire\n> MR. Damian A. James Williamson\n> Wills\n>\n> et al.\n>\n>\n> Willtech\n> www.willtech.com.au\n> www.go-overt.com\n> and other projects\n>\n> earn.com/willtech\n> linkedin.com/in/damianwilliamson\n>\n>\n> m. 0487135719\n> f. 61261470192\n>\n>\n> ----\n> ------------------------------\n> *From:* bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> on\n> behalf of Mike Brooks via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org>\n> *Sent:* Friday, 25 September 2020 5:40 AM\n> *To:* bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> *Subject:* [bitcoin-dev] Floating-Point Nakamoto Consensus\n>\n>   Hey Everyone,\n>\n>  A lot of work has gone into this paper, and the current revision has been\n> well received and there is a lot of excitement on this side to be sharing\n> it with you today. There are so few people that truly understand this\n> topic, but we are all pulling in the same direction to make Bitcoin better\n> and it shows.  It is wildly underrated that future proofing was never\n> really a consideration in the initial design - but here we are a decade\n> later with amazing solutions like SegWit which gives us a real\n> future-proofing framework.  The fact that future-proofing was added to\n> Bitcoin with a softfork gives me goosebumps. I'd just like to take the time\n> to thank the people who worked on SegWit and it is an appreciation that\n> comes up in conversation of how difficult and necessary that process\n> was, and this appreciation may not be vocalized to the great people who\n> worked on it. The fact that Bitcoin keeps improving and is able to respond\n> to new threats is nothing short of amazing - thank you everyone for a great\n> project.\n>\n> This current proposal really has nothing to do with SegWit - but it is an\n> update that will make the network a little better for the future, and we\n> hope you enjoy the paper.\n>\n> PDF:\n>\n> https://github.com/in-st/Floating-Point-Nakamoto-Consensus/blob/master/Floating-Point%20Nakamoto%20Consensus.pdf\n>\n> Pull Request:\n> https://github.com/bitcoin/bitcoin/pull/19665/files\n>\n> ---\n>\n>\n> Floating-Point Nakamoto Consensus\n>\n> Abstract \u2014 It has been shown that Nakamoto Consensus is very useful in\n> the formation of long-term global agreement \u2014 and has issues with\n> short-term disagreement which can lead to re-organization (\u201cor-org\u201d) of the\n> blockchain.  A malicious miner with knowledge of a specific kind of\n> denial-of-service (DoS) vulnerability can gain an unfair advantage in the\n> current Bitcoin network, and can be used to undermine the security\n> guarantees that developers rely upon.  Floating-Point Nakamoto consensu\n> makes it more expensive to replace an already mined block vs. creation of a\n> new block, and by resolving ambiguity of competition solutions it helps\n> achieve global consumers more quickly.  A floating-point fitness test\n> strongly incentivises the correct network behavior, and prevents\n> disagreement from ever forming in the first place.\n> Introduction\n>\n> The Bitcoin protocol was created to provide a decentralized consensus on a\n> fully distributed p2p network.  A problem arises when more than one\n> proof-of-work is presented as the next solution block in the blockchain.\n> Two solutions of the same height are seen as authoritative equals which is\n> the basis of a growing disagreement. A node will adopt the first solution\n> seen, as both solutions propagate across the network a race condition of\n> disagreement is formed. This race condition can be controlled by byzentiene\n> fault injection commonly referred to as an \u201ceclipsing\u201d attack.  When two\n> segments of the network disagree it creates a moment of weakness in which\n> less than 51% of the network\u2019s computational resources are required to keep\n> the network balanced against itself.\n> Nakamoto Consensus\n>\n> Nakamoto Consensus is the process of proving computational resources in\n> order to determine eligibility to participate in the decision making\n> process.  If the outcome of an election were based on one node (or\n> one-IP-address-one-vote), then representation could be subverted by anyone\n> able to allocate many IPs. A consensus is only formed when the prevailing\n> decision has the greatest proof-of-work effort invested in it. In order for\n> a Nakamoto Consensus to operate, the network must ensure that incentives\n> are aligned such that the resources needed to subvert a proof-of-work based\n> consensus outweigh the resources gained through its exploitation. In this\n> consensus model, the proof-of-work requirements for the creation of the\n> next valid solution has the exact same cost as replacing the current\n> solution. There is no penalty for dishonesty, and this has worked well in\n> practice because the majority of the nodes on the network are honest and\n> transparent, which is a substantial barrier for a single dishonest node to\n> overcome.\n>\n> A minimal network peer-to-peer structure is required to support Nakamoto\n> Conesus, and for our purposes this is entirely decentralized. Messages are\n> broadcast on a best-effort basis, and nodes can leave and rejoin the\n> network at will, accepting the longest proof-of-work chain as proof of what\n> happened while they were gone.  This design makes no guarantees that the\n> peers connected do not misrepresent the network or so called \u201cdishonest\n> nodes.\u201d Without a central authority or central view - all peers depend on\n> the data provided by neighboring peers - therefore a dishonest node can\n> continue until a peer is able to make contact an honest node.\n> Security\n>\n> In this threat model let us assume a malicious miner possesses knowledge\n> of an unpatched DoS vulnerability (\u201c0-day\u201d) which will strictly prevent\n> honest nodes from communicating to new members of the network - a so-called\n> \u201ctotal eclipse.\u201d  The kind of DoS vulnerability needed to conduct an\n> eclipse does not need to consume all CPU or computaitly ability of target\n> nodes - but rather prevent target nodes from forming new connections that\n> would undermine the eclipsing effect. These kinds of DoS vulnerabilities\n> are somewhat less substional than actually knocking a powerful-mining node\n> offline.  This class of attacks are valuable to an adversary because in\n> order for an honest node to prove that a dishonest node is lying - they\n> would need to form a connection to a segment of the network that isn\u2019t\n> entirely suppressed. Let us assume a defense-in-depth strategy and plan on\n> this kind of failure.\n>\n> Let us now consider that the C++ Bitcoind has a finite number of worker\n> threads and a finite number of connections that can be serviced by these\n> workers.  When a rude client occupies all connections - then a pidgin-hole\n> principle comes into play. If a network's maximum capacity for connection\n> handlers \u2018k\u2019, is the sum of all available worker threads for all nodes in\n> the network, establishing \u2018k+1\u2019 connections by the pidgin-hole principle\n> will prevent any new connections from being formed by honest nodes -\n> thereby creating a perfect eclipse for any new miners joining the network\n> would only be able to form connections with dishonest nodes.\n>\n> Now let\u2019s assume a dishonest node is modified in two ways - it increases\n> the maximum connection handles to hundreds of thousands instead of the\n> current value which is about 10. Then this node is modified to ignore any\n> solution blocks found by honest nodes - thus forcing the dishonest side of\n> the network to keep searching for a competitive-solution to split the\n> network in two sides that disagree about which tip of the chain to use.\n> Any new solution propagates through nodes one hop at a time. This\n> propagation can be predicted and shaped by dishonest non-voting nodes that\n> are being used to pass messages for honest nodes.\n>\n> At this point an attacker can expedite the transmission of one solution,\n> while slowing another. If ever a competing proof-of-work is broadcasted to\n> the network, the adversary will use their network influence to split\n> knowledge of the proof-of-work as close to \u00bd as possible. If the network\n> eclipse is perfect then an adversary can leverage an eigen-vector of\n> computational effort to keep the disagreement in balance for as long as it\n> is needed. No mechanism is stopping the attacker from adding additional\n> computation resources or adjusting the eclipsing effect to make sure the\n> system is in balance.   As long as two sides of the network are perfectly\n> in disagreement and generating new blocks - the attacker has intentionally\n> created a hard-fork against the will of the network architects and\n> operators. The disagreement needs to be kept open until the adversary\u2019s\n> transactions have been validated on the honest chain - at which point the\n> attacker will add more nodes to the dishonest chain to make sure it is the\n> ultimate winner - thus replacing out the honest chain with the one\n> generated by dishonest miners.\n>\n> This attack is convenient from the adversary\u2019s perspective,  Bitcoin being\n> a broadcast network advertises the IP addresses of all active nodes - and\n> Shodan and the internet scanning project can find all passive nodes\n> responding on TCP 8333.  This should illuminate all honest nodes on the\n> network, and even honest nodes that are trying to obscure themselves by not\n> announcing their presence.  This means that the attacker doesn\u2019t need to\n> know exactly which node is used by a targeted exchange - if the attacker\n> has subdued all nodes then the targeted exchange must be operating a node\n> within this set of targeted honest nodes.\n>\n> During a split in the blockchain, each side of the network will honor a\n> separate merkel-tree formation and therefore a separate ledger of\n> transactions. An adversary will then broadcast currency deposits to public\n> exchanges, but only on the weaker side, leaving the stronger side with no\n> transaction from the adversary. Any exchange that confirms one of these\n> deposits is relying upon nodes that have been entirely eclipsed so that\n> they cannot see the competing chain - at this point anyone looking to\n> confirm a transaction is vulnerable to a double-spend. With this currency\n> deposited on a chain that will become ephemeral, the attacker can wire out\n> the account balance on a different blockchain - such as Tether which is an\n> erc20 token on the Ethereum network which would be unaffected by this\n> attack.  When the weaker chain collapses, the transaction that the exchange\n> acted upon is no longer codified in Bitcoin blockchain's global ledger, and\n> will be replaced with a version of the that did not contain these deposits.\n>\n> Nakamoto Consensus holds no guarantees that it\u2019s process is\n> deterministic.  In the short term, we can observe that the Nakamoto\n> Consensus is empirically non-deterministic which is evident by\n> re-organizations (re-org) as a method of resolving disagreements within the\n> network.   During a reorganization a blockchain network is at its weakest\n> point, and a 51% attack to take the network becomes unnecessary. An\n> adversary who can eclipse honest hosts on the network can use this as a\n> means of byzantine fault-injection to disrupt the normal flow of messages\n> on the network which creates disagreement between miners.\n>\n> DeFi (Decentralized Finance) and smart-contract obligations depend on\n> network stability and determinism.  Failure to pay contracts, such as what\n> happened on \u201cblack thursday\u201d resulted in secured loans accidentally falling\n> into redemption.  The transactions used by a smart contract are intended to\n> be completed quickly and the outcome is irreversible.  However, if the\n> blockchain network has split then a contract may fire and have it\u2019s\n> side-effects execute only to have the transaction on the ledger to be\n> replaced.  Another example is that a hard-fork might cause the payer of a\n> smart contract to default - as the transaction that they broadcasted ended\n> up being on the weaker chain that lost. Some smart contracts, such as\n> collateral backed loans have a redemption clause which would force the\n> borrower on the loan to lose their deposit entirely.\n>\n> With two sides of the network balanced against each other - an attacker\n> has split the blockchain and this hard-fork can last for as long as the\n> attacker is able to exert the computational power to ensure that\n> proof-of-work blocks are regularly found on both sides of the network.  The\n> amount of resources needed to balance the network against itself is far\n> less than a 51% attack - thereby undermining the security guarantees needed\n> for a decentralized untrusted payment network to function.  An adversary\n> with a sufficiently large network of dishonest bots could use this to take\n> a tally of which miners are participating in which side of the network\n> split. This will create an attacker-controlled hard fork of the network\n> with two mutually exclusive merkle trees. Whereby the duration of this\n> split is arbitrary, and the decision in which chain to collapse is up to\n> the individual with the most IP address, not the most computation.\n>\n> In Satoshi Nakamoto\u2019s original paper it was stated that the electorate\n> should be represented by computational effort in the form of a\n> proof-of-work, and only these nodes can participate in the consues\n> process.  However, the electorate can be misled by non-voting nodes which\n> can reshape the network to benefit an individual adversary.\n> Chain Fitness\n>\n> Any solution to byzantine fault-injection or the intentional formation of\n> disagreements must be fully decentralized. A blockchain is allowed to split\n> because there is ambiguity in the Nakamoto proof-of-work, which creates the\n> environment for a race-condition to form. To resolve this, Floating-Point\n> Nakamoto Consensus makes it increasingly more expensive to replace the\n> current winning block. This added cost comes from a method of disagreement\n> resolution where not every solution block is the same value, and a more-fit\n> solution is always chosen over a weaker solution. Any adversary attempting\n> to have a weaker chain to win out would have to overcome a kind of\n> relay-race, whereby the winning team\u2019s strength is carried forward and the\n> loser will have to work harder and harder to maintain the disagreement.  In\n> most cases Floating-Point Nakamoto Consensus will prevent a re-org\n> blockchain from ever going past a single block thereby expediting the\n> formation of a global consensus.  Floating-Point Nakamoto Consensus cements\n> the lead of the winner and to greatly incentivize the network to adopt the\n> dominant chain no matter how many valid solutions are advertised, or what\n> order they arrive.\n>\n> The first step in Floating-Point Nakamoto Consensus is that all nodes in\n> the network should continue to conduct traditional Nakamoto Consensus and\n> the formation of new blocks is dictated by the same zero-prefix\n> proof-of-work requirements.  If at any point there are two solution blocks\n> advertised for the same height - then a floating-point fitness value is\n> calculated and the solution with the higher fitness value is the winner\n> which is then propagated to all neighbors. Any time two solutions are\n> advertised then a re-org is inevitable and it is in the best interest of\n> all miners to adopt the most-fit block, failing to do so risks wasting\n> resources on a mining of a block that would be discarded.  To make sure\n> that incentives are aligned, any zero-prefix proof of work could be the\n> next solution, but now in order to replace the current winning solution an\n> adversary would need a zero-prefix block that is also more fit that the\n> current solution - which is much more computationally expensive to produce.\n>\n> Any changes to the current tip of the blockchain must be avoided as much\n> as possible. To avoid thrashing between two or more competitive solutions,\n> each replacement can only be done if it is more fit, thereby proving that\n> it has an increased expense.  If at any point two solutions of the same\n> height are found it means that eventually some node will have to replace\n> their tip - and it is better to have it done as quickly as possible so that\n> consensus is maintained.\n>\n> In order to have a purely decentralized solution, this kind of agreement\n> must be empirically derived from the existing proof-of-work so that it is\n> universally and identically verifiable by all nodes on the network.\n> Additionally, this fitness-test evaluation needs to ensure that no two\n> competing solutions can be numerically equivalent.\n>\n> Let us suppose that two or more valid solutions will be proposed for the\n> same block.  To weigh the value of a given solution, let's consider a\n> solution for block 639254, in which the following hash was proposed:\n>\n>     00000000000000000008e33faa94d30cc73aa4fd819e58ce55970e7db82e10f8\n>\n> There are 19 zeros, and the remaining hash in base 16 starts with 9e3 and\n> ends with f8.  This can value can be represented in floating point as:\n>\n>     19.847052573336114130069196154809453027792121882588614904\n>\n> To simplify further lets give this block a single whole number to\n> represent one complete solution, and use a rounded floating-point value to\n> represent some fraction of additional work exerted by the miner.\n>\n>    1.847\n>\n> Now let us suppose that a few minutes later another solution is advertised\n> to the network shown in base16 below:\n>\n>     000000000000000000028285ed9bd2c774136af8e8b90ca1bbb0caa36544fbc2\n>\n> The solution above also has 19 prefixed zeros, and is being broadcast for\n> the same blockheight value of 639254 - and a fitness score of 1.282.  With\n> Nakamoto Consensus both of these solutions would be equivalent and a given\n> node would adopt the one that it received first.  In Floating-Post Nakamoto\n> Consensus, we compare the fitness scores and keep the highest.  In this\n> case no matter what happens - some nodes will have to change their tip and\n> a fitness test makes sure this happens immediately.\n>\n> With both solutions circulating in the network - any node who has received\n> both proof-of-works should know 1.847 is the current highest value, and\n> shouldn\u2019t need to validate any lower-valued solution.  In fact this fitness\n> value has a high degree of confidence that it won\u2019t be unseated by a larger\n> value - being able to produce a proof-of-work with 19 0\u2019s and a decimal\n> component greater than 0.847 is non-trivial.  As time passes any nodes that\n> received a proof-of-work with a value 1.204 - their view of the network\n> should erode as these nodes adopt the 1.847 version of the blockchain.\n>\n> All nodes are incentivized to support the solution with the highest\n> fitness value - irregardless of which order these proof-of-work were\n> validated. Miners are incentivized to support the dominant chain which\n> helps preserve the global consensus.\n>\n> Let us assume that the underlying cryptographic hash-function used to\n> generate a proof-of-work is an ideal primitive, and therefore a node cannot\n> force the outcome of the non-zero component of their proof-of-work.\n> Additionally if we assume an ideal cipher then the fitness of all possible\n> solutions is gaussian-random. With these assumptions then on average a new\n> solution would split the keyspace of remaining solutions in half.  Given\n> that the work needed to form a  new block remains a constant at 19 blocks\n> for this period - it is cheaper to produce a N+1 block that has any\n> floating point value as this is guaranteed to be adopted by all nodes if it\n> is the first solution.  To leverage a chain replacement on nodes conducting\n> Floating-Point Nakamoto Consensus a malicious miner would have to expend\n> significantly more resources.\n>\n> Each successive n+1 solution variant of the same block-height must\n> therefore on average consume half of the remaining finite keyspace.\n> Resulting in a the n+1 value not only needed to overcome the 19 zero\n> prefix, but also the non-zero fitness test.   It is possible for an\n> adversary to waste their time making a 19 where n+1 was not greater, at\n> which point the entire network will have had a chance to move on with the\n> next solution.  With inductive reasoning, we can see that a demissiniong\n> keyspace increases the amount of work needed to find a solution that also\n> meets this new criteria.\n>\n> Now let us assume a heavily-fragmented network where some nodes have\n> gotten one or both of the solutions.  In the case of nodes that received\n> the proof-of-work solution with a fitness of 1.847, they will be happily\n> mining on this version of the blockchain. The nodes that have gotten both\n> 1.847 and .240 will still be mining for the 1.847 domainite version,\n> ensuring a dominant chain.  However, we must assume some parts of the\n> network never got the message about 1.847 proof of work, and instead\n> continued to mine using a value of 1.240 as the previous block.   Now,\n> let\u2019s say this group of isolated miners manages to present a new\n> conflicting proof-of-work solution for 639255:\n>\n>      000000000000000000058d8ebeb076584bb5853c80111bc06b5ada35463091a6\n>\n> The above base16 block has a fitness score of 1.532  The fitness value for\n> the previous block 639254 is added together:\n>\n>      2.772 = 1.240 + 1.532\n>\n> In this specific case, no other solution has been broadcast for block\n> height 639255 - putting the weaker branch in the lead.  If the weaker\n> branch is sufficiently lucky, and finds a solution before the dominant\n> branch then this solution will have a higher overall fitness score, and\n> this solution will propagate as it has the higher value.  This is also\n> important for transactions on the network as they benefit from using the\n> most recently formed block - which will have the highest local fitness\n> score at the time of its discovery.  At this junction, the weaker branch\n> has an opportunity to prevail enterally thus ending the split.\n>\n> Now let us return to the DoS threat model and explore the worst-case\n> scenario created by byzantine fault injection. Let us assume that both the\n> weaker group and the dominant group have produced competing proof-of-work\n> solutions for blocks 639254 and 639255 respectively.  Let\u2019s assume that the\n> dominant group that went with the 1.847 fitness score - also produces a\n> solution with a similar fitness value and advertises the following solution\n> to the network:\n>\n> 0000000000000000000455207e375bf1dac0d483a7442239f1ef2c70d050c113\n>\n> 19.414973649464574877549198290879237036867705594421756179\n>\n> or\n>\n> 3.262 = 1.847 + 1.415\n>\n> A total of 3.262 is still dominant over the lesser 2.772 - in order to\n> overcome this - the 2nd winning block needs to make up for all of the\n> losses in the previous block.  In this scenario, in order for the weaker\n> chain to supplant the dominant chain it must overcome a -0.49 point\n> deficit. In traditional Nakamoto Consensus the nodes would see both forks\n> as authoritative equals which creates a divide in mining capacity while two\n> groups of miners search for the next block.  In Floating-Point Nakamoto\n> Consensus any nodes receiving both forks, would prefer to mine on the chain\n> with an overall fitness score of +3.262 - making it even harder for the\n> weaker chain to find miners to compete in any future disagreement, thereby\n> eroding support for the weaker chain. This kind of comparison requires an\n> empirical method for determining fitness by miners following the same same\n> system of rules will insure a self-fulfilled outcome.  After all nodes\n> adopt the dominant chain normal Nakamoto Consuess can resume without having\n> to take into consideration block fitness. This example shows how\n> disagreement can be resolved more quickly if the network has a mechanism to\n> resolve ambiguity and de-incentivise dissent.\n> Soft Fork\n>\n> Blockchain networks that would like to improve the consensus generation\n> method by adding a fitness test should be able to do so using a \u201cSoft Fork\u201d\n> otherwise known as a compatible software update.  By contrast a \u201cHard-Fork\u201d\n> is a separate incompatible network that does not form the same consensus.\n> Floating-Point Nakamoto Consensus can be implemented as a soft-fork because\n> both patched, and non-patched nodes can co-exist and non-patched nodes will\n> benefit from a kind of herd immunity in overall network stability.  This is\n> because once a small number of nodes start following the same rules then\n> they will become the deciding factor in which chain is chosen.  Clients\n> that are using only traditional Nakamoto Consensus will still agree with\n> new clients over the total chain length. Miners that adopt the new strategy\n> early, will be less likely to lose out on mining invalid solutions.\n> Conclusion\n>\n> Floating-Point Nakamoto consensus allows the network to form a consensus\n> more quickly by avoiding ambiguity allowing for determinism to take hold.\n> Bitcoin has become an essential utility, and attacks against our networks\n> must be avoided and adapting, patching and protecting the network is a\n> constant effort. An organized attack against a cryptocurrency network will\n> undermine the guarantees that blockchain developers are depending on.\n>\n> Any blockchain using Nakamoto Consensus can be modified to use a fitness\n> constraint such as the one used by a Floating-Point Nakamoto Consensus.  An\n> example implementation has been written and submitted as a PR to the\n> bitcoin core which is free to be adapted by other networks.\n>\n>\n>\n>\n>\n> A complete implementation of Floating-Point Nakamoto consensus is in the\n> following pull request:\n>\n> https://github.com/bitcoin/bitcoin/pull/19665/files\n>\n> Paper:\n>\n> https://github.com/in-st/Floating-Point-Nakamoto-Consensus\n>\n> https://in.st.capital\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201009/634f09de/attachment-0001.html>"
            },
            {
                "author": "yanmaani at cock.li",
                "date": "2020-10-15T16:02:09",
                "message_text_only": "What if a miner mines a block that has a very high block reward (i.e. \nconfirmed a juicy transaction), while at the same time having a floating \npoint fitness very close to the minimum?\n\nFor the sake of argument, let's say the block reward is 6.50 (4% more \nthan average), the fitness is 1.001, and the orphan rate is 0.3%.\n\nWith Nakamoto consensus, the miners would (allegedly) find it in their \nbest interest to work on that block, since it was first. It's a problem \nwhen they don't, but the system basically works right now.\n\nWith FPNC, the miners have two equally valid options:\n1) Attempt to create a block building on top of that block (reward: \n6.25)\n2) Attempt to replace (reward: 6.50)\n\nIf they do (1), their probability of success given a matching hash is \n(100 - orphan rate)%, which is very close to 100%.\nIf they do the second, their probability of success given a hit is (100 \n- percentile(1.001)), which also is very close to 100%.\n\nOption 1 has EV of .997 * 1 * 6.25 = 6.25.\nOption 2 has EV of (1 - quantile(1.001)) * 1.04 * 6.25, which is surely \nabove 6.25. I don't know how to calculate the quantile, but it's \nobvious.\n\nWith the block subsidy getting lower and lower as time goes on, the \nprobability of this happening goes up.\n\nDon't we want miners to always keep the chain going forward? Your \nproposal incentivizes reorgs.\n\nOn 2020-10-10 01:26, Mike Brooks via bitcoin-dev wrote:\n> James,\n> \n> FPNC and NC will always select the highest-work chain, I am suggesting\n> that by adding more bits of precision we avoid confusion.\n> \n> Part 2 -> Using a genetic algorithm that passes fitness with heredity\n> to resolve disagreements has never been introduced to this mailing\n> list.  This hard-nack is null and void.\n> \n> Best Regards,\n> Michael\n> \n> On Tue, Sep 29, 2020 at 12:30 AM LORD HIS EXCELLENCY JAMES HRMH via\n> bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n>> Good Afternoon,\n>> \n>> Re: [bitcoin-dev] Floating-Point Nakamoto Consensus\n>> \n>> I note that the discussion thread for this proposal has previously\n>> received HARD_NAK\n>> \n>> I note in the whitepaper the following basic introduction of need:\n>> \n>>> As a result anode will simply adopt the first solution seen,\n>> creating a kind of race condition.\n>> \n>> The said race condition, it is not noted, is 'self-resolving' with\n>> the network adopting the longest chain with the highest proof of\n>> work as any contentious tip is built on. This is the proper reason\n>> for waiting for two confirmations for a transaction as a minimum\n>> proof of its inclusion in the blockchain (without fraud), and for\n>> waiting for six confirmations before considering that a transaction\n>> is 'final'.\n>> \n>> I take it that your work is intended to allow the network to decide\n>> immediately without waiting for a chain to be further extended, in\n>> that case, the solution should be as noted elsewhere to accept the\n>> higher proof of work with the greater precision proof. When\n>> comparing two competing blocks there is an indirect reference to a\n>> higher proof of work due to the greater precision in the block hash,\n>> although the answer could have been arrived with fewer attempts. As\n>> it is, the total proof of work is not directly calculated but is\n>> evaluated as the chain with more blocks being the chain with more\n>> proof-of-work, whereas in the cases two blocks are received as\n>> alternates extending the same chain tip there is currently no method\n>> of comparison to determine which of the blocks, and the correct tip\n>> is not chosen without further proof-of-work to extend a tip.\n>> Resolving this reduces the network expense of reorganisation in\n>> ordinary conditions but in the case of a network-split resolves\n>> nothing.\n>> \n>> KING JAMES HRMH\n>> Great British Empire\n>> \n>> Regards,\n>> The Australian\n>> LORD HIS EXCELLENCY JAMES HRMH (& HMRH)\n>> of Hougun Manor & Glencoe & British Empire\n>> MR. Damian A. James Williamson\n>> Wills\n>> \n>> et al.\n>> \n>> Willtech\n>> www.willtech.com.au [1]\n>> www.go-overt.com [2]\n>> and other projects\n>> \n>> earn.com/willtech [3]\n>> linkedin.com/in/damianwilliamson [4]\n>> \n>> m. 0487135719\n>> f. 61261470192\n>> \n>> ----\n>> \n>> -------------------------\n>> \n>> From: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> on\n>> behalf of Mike Brooks via bitcoin-dev\n>> <bitcoin-dev at lists.linuxfoundation.org>\n>> Sent: Friday, 25 September 2020 5:40 AM\n>> To: bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n>> Subject: [bitcoin-dev] Floating-Point Nakamoto Consensus\n>> \n>> Hey Everyone,\n>> \n>> A lot of work has gone into this paper, and the current revision\n>> has been well received and there is a lot of excitement on this side\n>> to be sharing it with you today. There are so few people that truly\n>> understand this topic, but we are all pulling in the same direction\n>> to make Bitcoin better and it shows.  It is wildly underrated that\n>> future proofing was never really a consideration in the initial\n>> design - but here we are a decade later with amazing solutions like\n>> SegWit which gives us a real future-proofing framework.  The fact\n>> that future-proofing was added to Bitcoin with a softfork gives me\n>> goosebumps. I'd just like to take the time to thank the people who\n>> worked on SegWit and it is an appreciation that comes up in\n>> conversation of how difficult and necessary that process was, and\n>> this appreciation may not be vocalized to the great people who\n>> worked on it. The fact that Bitcoin keeps improving and is able to\n>> respond to new threats is nothing short of amazing - thank you\n>> everyone for a great project.\n>> \n>> This current proposal really has nothing to do with SegWit - but it\n>> is an update that will make the network a little better for the\n>> future, and we hope you enjoy the paper.\n>> \n>> PDF:...\n>> CONCLUSION\n>> \n>> Floating-Point Nakamoto consensus allows the network to form a\n>> consensus more quickly by avoiding ambiguity allowing for\n>> determinism to take hold. Bitcoin has become an essential utility,\n>> and attacks against our networks must be avoided and adapting,\n>> patching and protecting the network is a constant effort. An\n>> organized attack against a cryptocurrency network will undermine the\n>> guarantees that blockchain developers are depending on.\n>> Any blockchain using Nakamoto Consensus can be modified to use a\n>> fitness constraint such as the one used by a Floating-Point Nakamoto\n>> Consensus.  An example implementation has been written and submitted\n>> as a PR to the bitcoin core which is free to be adapted by other\n>> networks.\n>> \n>> A complete implementation of Floating-Point Nakamoto consensus is in\n>> the following pull request:\n>> \n>> https://github.com/bitcoin/bitcoin/pull/19665/files [5]\n>> Paper:\n>> \n>> https://github.com/in-st/Floating-Point-Nakamoto-Consensus [6]\n>> \n>> https://in.st.capital [7]\n>> \n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> \n> Links:\n> ------\n> [1] http://www.willtech.com.au\n> [2] http://www.go-overt.com\n> [3] http://earn.com/willtech\n> [4] http://linkedin.com/in/damianwilliamson\n> [5] https://github.com/bitcoin/bitcoin/pull/19665/files\n> [6] https://github.com/in-st/Floating-Point-Nakamoto-Consensus\n> [7] https://in.st.capital/\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "Floating-Point Nakamoto Consensus",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Mike Brooks",
                "ZmnSCPxj",
                "yanmaani at cock.li",
                "Larry Ruane",
                "Bob McElrath"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 61430
        }
    },
    {
        "title": "[bitcoin-dev] Message signing (again)",
        "thread_messages": [
            {
                "author": "Karl-Johan Alm",
                "date": "2020-10-01T08:56:15",
                "message_text_only": "Hello,\n\nI have updated the signmessage proposal (BIP-322) to use the same\napproach as signet uses, which brings out of the box support for psbt\nand such, and removes the need for a custom signer and validator\n(well, sort of anyway).\n\nIn the process, I've also replaced the concatenation approach\n(hash(\"Bitcoin Signed Message || <message>\")) with a\nBIP340-tagged-hash approach (h/t @ajtowns).\n\nNot much remains of the old BIP, so I am tentatively submitting this\nas a replacement proposal. I'd be totally fine with submitting this as\nan updated BIP-322 though, if people prefer that.\n\nPull request is here:\n\nhttps://github.com/bitcoin/bips/pull/1003\n\nViewable version:\n\nhttps://github.com/bitcoin/bips/blob/ce60832ef41301105a95c15dcd854d8ecbc53e00/bip-signmessage-redone.mediawiki\n\nInline version:\n\n<pre>\nBIP: ????\nLayer: Applications\nTitle: Generic Signed Message Format\nAuthor: Karl-Johan Alm <karljohan-alm at garage.co.jp>\nComments-Summary: No comments yet.\nComments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\nStatus: Draft\nType: Standards Track\nCreated: 2020-10-01\nLicense: CC0-1.0\nReplaces: 322\n</pre>\n\n== Abstract ==\n\nA standard for interoperable generic signed messages based on the\nBitcoin Script format.\n\n== Background ==\n\n* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n* <code>P</code> wants to prove that they own the private key\n<code>k</code> associated with a given address <code>A</code> (which\nin turn is derived from the pubkey <code>kG</code>).\n* Let <code>V</code> generate a message <code>M</code> and hand this\nto <code>P</code>.\n* <code>P</code> generates a signature <code>S</code> by signing the\nmessage <code>M</code> using <code>k</code>. Given <code>S</code>,\n<code>V</code> can prove that <code>P</code> has the private key\nassociated with <code>A</code>.\n\nThe astute reader will notice that the above is missing a critical\npart, namely the pubkey <code>kG</code>, without which the verifier\ncannot actually verify the message. The current message signing\nstandard solves this via a cryptographic trick, wherein the signature\n<code>S</code> above is a special \"recoverable signature\" type. Given\nthe message <code>M</code> and the signature <code>S</code>, it is\nthen possible to recover the pubkey <code>kG</code>. The system thus\nderives the address for the pubkey <code>kG</code>, and if it does not\nmatch <code>A</code>, the proof is deemed invalid.\n\nWhile this is a neat trick, it unnecessarily restricts and complicates\nthe message signing mechanism; for instance, it is currently not\npossible to sign a message for a P2SH address, because there is no\npubkey to recover from the resulting signature.\n\n== Motivation ==\n\nThe current message signing standard only works for P2PKH (1...)\naddresses. By extending it to use a Bitcoin Script based approach, it\ncould be made more generic without causing a too big burden on\nimplementers, who most likely have access to Bitcoin Script\ninterpreters already.\n\n== Specification ==\n\nThis BIP follows the specification of BIP-325 challenges and solutions.\n\nLet there be two virtual transactions to_spend and to_sign.\n\nThe \"to_spend\" transaction is:\n\nnVersion = 0\nnLockTime = 0\nvin[0].prevout.hash = 0000...000\nvin[0].prevout.n = 0xFFFFFFFF\nvin[0].nSequence = 0\nvin[0].scriptSig = OP_0 PUSH32[ message_hash ]\nvin[0].scriptWitness = []\nvout[0].nValue = 0\nvout[0].scriptPubKey = message_challenge\n\nwhere message_hash is a BIP340-tagged hash of the message, i.e.\nsha256_tag(m), where tag = \"BIP????-signed-message\", and\nmessage_challenge is the to be proven (public) key script.\n\nThe \"to_sign\" transaction is:\n\nnVersion = 0\nnLockTime = 0\nvin[0].prevout.hash = to_spend.txid\nvin[0].prevout.n = 0\nvin[0].nSequence = 0\nvout[0].nValue = 0\nvout[0].scriptPubKey = message_signature\n\nIt may include other inputs, to facilitate a proof of funds.\n\nA message signature is considered valid, inconclusive, or invalid\nbased on whether the to_sign transaction is a valid spend of the\nto_spend transaction or not, according to the following steps (also\nsee Consensus and standard flags section further down):\n\n1. Valid, if it is a successful spend according to the current\nconsensus rules (sometimes called \"policy\").\n2. Inconclusive, if it is a successful spend according to consensus\nrules, but NOT according to policy rules\n3. Invalid, if it is not a successful spend according to consensus rules\n\nA proof is the base64-encoding of the message_signature as is. A\nvalidator takes the to be proven pubkey and the proof and transforms\nit to virtual transactions as described above.\n\n== Legacy format ==\n\nThe legacy format is restricted to the legacy P2PKH address format.\n\nAny other input (i.e. non-P2PKH address format) must be signed using\nthe new format described above.\n\n=== Signing ===\n\nGiven the P2PKH address <code>a</code> and the message <code>m</code>,\nand the pubkey-hash function <code>pkh(P) =\nripemd160(sha256(P))</code>:\n\n# let <code>p</code> be the pubkey-hash <code>pkh(P)</code> for the\npubkey <code>P</code>, contained in <code>a</code>\n# let <code>x</code> be the private key associated with <code>P</code>\nso that <code>pkh(xG) = p</code>\n# let <code>digest</code> be <code>SHA56d(\"Bitcoin Signed Message:\\n\"||m)</code>\n# create a compact signature <code>sig</code> (aka \"recoverable ECDSA\nsignature\") using <code>x</code> on <code>digest</code>\n\nThe resulting proof is <code>sig</code>, serialized using the base64 encoding.\n\n=== Verifying ===\n\nGiven the P2PKH address <code>a</code>, the message <code>m</code>,\nthe compact signature <code>sig</code>, and the pubkey-hash function\n<code>pkh(P) = ripemd160(sha256(P))</code>:\n\n# let <code>p</code> be the pubkey-hash <code>pkh(P)</code> for the\npubkey <code>P</code>, contained in <code>a</code>\n# let <code>digest</code> be <code>SHA56d(\"Bitcoin Signed Message:\\n\"||m)</code>\n# attempt pubkey recovery for <code>digest</code> using the signature\n<code>sig</code> and store the resulting pubkey into <code>Q</code>\n## fail verification if pubkey recovery above fails\n# let <code>q</code> be the pubkey-hash <code>pkh(Q)</code> for the\npubkey <code>Q</code>\n# if <code>p == q</code>, the proof is valid, otherwise it is invalid\n\n== Compatibility ==\n\nThis specification is backwards compatible with the legacy\nsignmessage/verifymessage specification through the special case as\ndescribed above.\n\n== Reference implementation ==\n\nTODO\n\n== Acknowledgements ==\n\nThanks to David Harding, Jim Posen, Kalle Rosenbaum, Pieter Wuille,\nand many others for their feedback on the specification.\n\n== References ==\n\n# Original mailing list thread:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015818.html\n\n== Copyright ==\n\nThis document is licensed under the Creative Commons CC0 1.0 Universal license.\n\n== Consensus and standard flags ==\n\nEach flag is associated with some type of enforced rule (most often a\nsoft fork). There are two sets of flags: consensus flags (which result\nin a block being rejected, if violated), and policy flags (which\nresult in a transaction being accepted only if it is contained within\nan actual block, and rejected otherwise, if violated). The policy\nflags are a super-set of the consensus flags.\n\nThis BIP specifies that a proof that validates for both rulesets is\nvalid, a proof that validates for consensus rules, but not for policy\nrules, is \"inconclusive\", and a proof that does not validate for\nconsensus rules is \"invalid\" (regardless of policy rule validation).\n\nThe ruleset sometimes changes. This BIP does not intend to be\ncomplete, nor does it indicate enforcement of rules, it simply lists\nthe rules as they stand at the point of writing.\n\n=== Consensus rules ===\n\n* P2SH: evaluate P2SH\n([https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki\nBIP16]) subscripts\n* DERSIG: enforce strict DER\n([https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki\nBIP66]) compliance\n* NULLDUMMY: enforce NULLDUMMY\n([https://github.com/bitcoin/bips/blob/master/bip-0147.mediawiki\nBIP147])\n* CHECKLOCKTIMEVERIFY: enable CHECKLOCKTIMEVERIFY\n([https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki\nBIP65])\n* CHECKSEQUENCEVERIFY: enable CHECKSEQUENCEVERIFY\n([https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki\nBIP112])\n* WITNESS: enable WITNESS\n([https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki\nBIP141])\n\n=== Policy rules ===\n\nAll of the above, plus (subject to change):\n\n* STRICTENC: non-strict DER signature or undefined hashtype\n* MINIMALDATA: require minimal encodings for all push operations\n* DISCOURAGE_UPGRADABLE_NOPS: discourage use of NOPs reserved for upgrades\n* CLEANSTACK: require that only a single stack element remains after evaluation\n* MINIMALIF: Segwit script only: require the argument of OP_IF/NOTIF\nto be exactly 0x01 or empty vector\n* NULLFAIL: signature(s) must be empty vector if a CHECK(MULTI)SIG\noperation failed\n* LOW_S: signature with S > order/2 in a checksig operation\n* DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM: v1-16 witness programs are\nnon-standard (i.e. forbidden)\n* WITNESS_PUBKEYTYPE: public keys in segregated witness scripts must\nbe compressed\n* CONST_SCRIPTCODE: OP_CODESEPARATOR and FindAndDelete fail any\nnon-segwit scripts\n\n== Test vectors ==\n\nTODO"
            }
        ],
        "thread_summary": {
            "title": "Message signing (again)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Karl-Johan Alm"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 9241
        }
    },
    {
        "title": "[bitcoin-dev] A thought experiment on bitcoin for payroll privacy",
        "thread_messages": [
            {
                "author": "Mr. Lee Chiffre",
                "date": "2020-10-03T05:21:17",
                "message_text_only": "Lets pretend that I have a company. I'll call it cut throat industries. We\nare a box cutter testing firm. HR pays the employees biweekly Fridays. In\nthe current way. Cut throat industries pays a single transaction with the\ncompany's  treasury as the input and each employee payroll as an output.\nThere is no address reuse because HR has a xpub provided by each employee\nfor their payroll wallet. I have 120 employees.\n\nThe problem\n\nThe concern is the competition of my precious company and employees seeing\nour worth and amount in our treasury account. This also exposes how many\nemployees we have and an idea of what the average payroll is. One of my\nemployees is Frank. Frank gets paid then a couple days later he buys some\nrandom thing that should not be talked about from a coworker. The coworker\ncan observe Franks input and know what Frank makes. There is another time\nwhere cut throat industries is in a temporary financial clamp down. To\nsave money my company is not giving bonuses for the rest of the fiscal\nyear. But one employee of mine has done a very good job at cutting and I\nwas afraid he was going to leave my agency if I did not make an exception\nfor him. So I gave him a raise but not others. Employees notice that one\nof the 120 biweekly outputs is higher than usual. So they know someone got\na raise.\n\nProblem summary\n\nI am paranoid because I run a company with my finances transparent to my\ncompetition and my employees. And my employees are starting to get\nconcerned because their income is transparent to everyone also. These\nemployees are dangerous and professional cutters. I don't want to upset\nthem. What can I do to use bitcoin with privacy to eliminate these\nconcerns? Lightning network is not much an option because they do not have\ninbound balance to get paid. I cannot front up funds of my own to give\nthem inbound balance because it would consume all of my treasury to lock\nup funds. So it seems that I have to do payroll on chain. What do I do?\n\n-- \nlee.chiffre at secmail.pro\nPGP 97F0C3AE985A191DA0556BCAA82529E2025BDE35"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-10-03T22:24:58",
                "message_text_only": "Good morning Mr. Lee,\n\n> Lightning network is not much an option because they do not have\n> inbound balance to get paid.\n\nWhy not?\nYour company can open a channel with each employee that has insufficient inbound liquidity.\nThe employee is incentivized to reveal their node to your company so you can open a channel to them, since otherwise they would be unable to receive their salary.\nYour alternative is as you say: openly-visible salaries and throat-cutters who might decide to cut your throat.\n\nLet us say your company receives its income stream over Lightning.\nLet us say you hire a new throat-cutter, with a bi-weekly salary of 0.042 BTC.\nYou ask the new hire if his or her Lightning node has that capacity.\n\nIf not, you take some of your onchain Lightning funds, swap out say 0.043 BTC on Lightning Loop or Boltz Exchange or some other offchain-to-onchain swap.\nYou use those swapped onchain funds to create a fresh channel to the new hire.\n\nIf you are onboarding by batches (which your HR is likely to want to do, so they can give the onboarding employee seminars in groups) then you can save onchain fees by using C-Lightning `multifundchannel` as well.\n\nThe occasional bonus can be a bit tricky, but similarly the employee can use Lightning Loop or Boltz Exchange or some other alternative to free up capacity for the bonus (and they have an incentive to do so, as they want to get the bonus).\nPermanent raises can justify permanently increasing the size of the channel with the employee.\n\nEven if the employee leaves your employ, that is no justification to close the channel with her or his node.\nYou can earn forwarding fees from his or her new employer or income source.\n\nBecause of the onion routing, it is hard for you to learn what the employee spends on, and in the future when they leave your employ, it is hard for you to figure out her or his new employer.\n\nIf the employee is a saver, they can accumulate their funds, thus reducing their incoming capacity below their biweekly salary.\nIf so, he or she can use an offchain-to-onchain swap, again, to move their accumulated savings to onchain cold storage.\n\nThis is not perfect of course, if you run multiple nodes you can try correlating payments by timing and amount (and prior to payment points i.e. today, you can correlate by payment hashes).\nBut this is still much better than the onchain situation, as you describe.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-10-05T02:41:14",
                "message_text_only": "Good morning Mr. Lee,\n\n\n> Permanent raises can justify permanently increasing the size of the channel with the employee.\n\nOn reflection, this is a bad idea.\n\nSuppose I am a cut-throat employee and I want to have an idea of the bi-weekly salary of another employee.\n\nI make some stupid bet, and lose, with the other employee.\nI offer to pay the loss of my bet via Lightning, and the other employee, in all innocence, issues a Lightning invoice to me.\n\nThe Lightning invoice contains the actual node ID of the other employee.\nAnd since I also have a channel with the cut-throat company, I know as well the node ID of the cut-throat company.\n\nI can then look at the gossiped channels and see the size of the channel between the cut-throat company and the other employee, and from there, guess that this is the bi-weekly salary of that employee.\n\nOn the other hand --- once the employee has *any* funds at all, they can similarly take an offchain-to-onchain swap, and then use the funds to create another channel to another part of the network.\nThe other employee as well can arrange incoming funds on that other channel by using offchain-to-onchain swaps to their cold storage.\nThus, as an employee gets promoted and pulls a larger bi-weekly salary, the channel with the cut-throat company becomes less and less an indicator of their *actual* bi-weekly salary, and there is still some deniability on the exact size of the salary.\n\nAt the same time, even if I know the node of the other employee, the size of all its channels is also still not a very accurate indicator of their salary at the throat-cutting company.\nFor example, it could be a family node, and the other employee and all her or his spouses arrange to have their salaries paid to that node.\nOr the other employee can also run a neck-reconstruction business on the side, and also use the same node.\n(Nodelets for the win?)\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-10-06T04:10:52",
                "message_text_only": "Good morning Mr. Lee, and list,\n\n> I can then look at the gossiped channels and see the size of the channel between the cut-throat company and the other employee, and from there, guess that this is the bi-weekly salary of that employee.\n\n\nThis can be made an argument against always publishing all channels, so let me propose something.\n\nThe key identifying information in an invoice is the routehint and the node ID itself.\n\nThere are already many competing proposals by which short-channel-ids in routehints can be obscured.\nThey are primarily proposed for unpublished channels, but nothing in those proposals prevents them from being used for published channels.\n\nThe destination node ID is never explicitly put in the onion, only implied by the short-channel-id in order to save space.\nHowever, the destination node ID *is* used to encrypt the final hop in the onion.\nSo the receiver node can keep around a small number of throwaway keypairs (or get those by HD) and use a throwaway to sign the invoice, and when it is unable to decode by its normal node ID, try using one of the throwaway keypairs.\n\nWith both of the above, what remains is the feerate settings in the invoice.\nIf the company node gives different feerates per channel, it is still possible to identify which channel is *actually* referred to in the invoice.\nWhat the receiver node can do would be to give a small random increase in feerate, which basically overpays the company node, but obscures as well *which* channel is actually in the invoice.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-10-04T03:45:14",
                "message_text_only": "Good Morning Mr. Lee,\n\n> I cannot front up funds of my own to give\n> them inbound balance because it would consume all of my treasury to lock\n> up funds.\n\nThis is not a reasonable assumption!\n\nSuppose you have a new hire that you have agreed to pay 0.042BTC every 2 weeks.\n\nOn the *first* payday of the new hire, you *have* to have *at least* 0.042BTC in your treasury, somehow.\n\nIf not, you are unable to pay the new hire, full stop, and you are doomed to bankruptcy and your problems will disappear soon once your cut-throat new hire cuts your throat for not paying her or him.\n\nIf you *do* have at least 0.042BTC in your treasury, you *can* make the channel with the new hire and pay the salary via the new channel.\n\nAt *every* payday, you need to have at least the salary of your entire employee base available, otherwise you would be unable to pay at least some of your employees and you will quickly find yourself with your throat cut.\n\n\n\n\nNow, let us talk about *topology*.\n\nLet us reduce this to a pointless topology that is the *worst possible topology* for Lightning usage, and show that by golly, Lightning will still work.\n\nSuppose your company only has this one big channel with the network.\nLet us reduce your company to only having this single new hire throat-cutter (we will show later that without loss of generality this will still work even if you have thousands of throat-cutters internationally).\n\nNow, as mentioned, on the first payday of your throat-cutter, you *have* to have at least the 0.042 salary you promised.\nIf you have been receiving payments for your throat-cutting business on the big channel, that means the 0.042 BTC is in that single big channel.\n\nYou can then use an offchain-to-onchain swap service like Boltz or Loop and put the money onchain.\nThen you can create the new channel to your new hire and pay the promised salary to the throat-cutter.\n\nNow, you have no more funds in either of your channels, the to-network big channel, and the to-employee channel.\nSo you are not locking up any of *your* funds, only the funds of your employee.\n\nNow, as your business operates, you will receive money in your to-network big channel.\nThe rate at which you receive money for services rendered *has to* be larger than 0.042/2weeks on average, *otherwise* you are not earning enough to pay your throat-cutter by the time of the *next* payday (much less your other operating expenses, such as knife-sharpening, corpse disposal, dealing with the families of the deceased, etc.).\nIf you are not earning at a high enough rate to pay your employee by the next payday, your employee will not be paid and will solve your problems by cutting your throat.\n\nBut what that means is that the employee salary of the *previous* payday is not locked, either!\nBecause you are receiving funds on your big to-network channel continuously, the employee can now spend the funds \"locked\" in the to-employee channel, sending out to the rest of the network.\nThis uses up the money you have been earning and moving the funds to the to-employee channel, but if you are running a lucrative business, that is perfectly fine, since you should, by the next payday, have earned enough, and then some, to pay the employee on the next payday.\n\nOf course there will be times when business is a little slow and you get less than 0.042/2weeks.\nIn that case, a wise business manager will reserve some funds for a rainy day when business is a little slow, meaning you will still have some funds you can put into your to-network big channel for other expenses, even as your employee uses capacity there to actually spend their salary.\n\nIt all balances out.\nYou only need to keep enough in your channels to cover your continuous operational expenses, and employee salaries *are* operational expenses.\n\n\nSuppose you now want to hire *another* throat-cutter.\nYou would only do that if business is booming, or in other words, if you have accumulated enough money in your treasury to justify hiring yet another employee.\n\nBy induction, this will work regardless if you have 1 employee, or 1 million.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Thomas Hartman",
                "date": "2020-10-04T14:07:05",
                "message_text_only": "\"big to-network channel\"\n\nnit: should this be \"big from-network channel\" ?\n\nthanks for this explanation.\n\nOn Sat, Oct 3, 2020 at 11:45 PM ZmnSCPxj via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Good Morning Mr. Lee,\n>\n> > I cannot front up funds of my own to give\n> > them inbound balance because it would consume all of my treasury to lock\n> > up funds.\n>\n> This is not a reasonable assumption!\n>\n> Suppose you have a new hire that you have agreed to pay 0.042BTC every 2 weeks.\n>\n> On the *first* payday of the new hire, you *have* to have *at least* 0.042BTC in your treasury, somehow.\n>\n> If not, you are unable to pay the new hire, full stop, and you are doomed to bankruptcy and your problems will disappear soon once your cut-throat new hire cuts your throat for not paying her or him.\n>\n> If you *do* have at least 0.042BTC in your treasury, you *can* make the channel with the new hire and pay the salary via the new channel.\n>\n> At *every* payday, you need to have at least the salary of your entire employee base available, otherwise you would be unable to pay at least some of your employees and you will quickly find yourself with your throat cut.\n>\n>\n>\n>\n> Now, let us talk about *topology*.\n>\n> Let us reduce this to a pointless topology that is the *worst possible topology* for Lightning usage, and show that by golly, Lightning will still work.\n>\n> Suppose your company only has this one big channel with the network.\n> Let us reduce your company to only having this single new hire throat-cutter (we will show later that without loss of generality this will still work even if you have thousands of throat-cutters internationally).\n>\n> Now, as mentioned, on the first payday of your throat-cutter, you *have* to have at least the 0.042 salary you promised.\n> If you have been receiving payments for your throat-cutting business on the big channel, that means the 0.042 BTC is in that single big channel.\n>\n> You can then use an offchain-to-onchain swap service like Boltz or Loop and put the money onchain.\n> Then you can create the new channel to your new hire and pay the promised salary to the throat-cutter.\n>\n> Now, you have no more funds in either of your channels, the to-network big channel, and the to-employee channel.\n> So you are not locking up any of *your* funds, only the funds of your employee.\n>\n> Now, as your business operates, you will receive money in your to-network big channel.\n> The rate at which you receive money for services rendered *has to* be larger than 0.042/2weeks on average, *otherwise* you are not earning enough to pay your throat-cutter by the time of the *next* payday (much less your other operating expenses, such as knife-sharpening, corpse disposal, dealing with the families of the deceased, etc.).\n> If you are not earning at a high enough rate to pay your employee by the next payday, your employee will not be paid and will solve your problems by cutting your throat.\n>\n> But what that means is that the employee salary of the *previous* payday is not locked, either!\n> Because you are receiving funds on your big to-network channel continuously, the employee can now spend the funds \"locked\" in the to-employee channel, sending out to the rest of the network.\n> This uses up the money you have been earning and moving the funds to the to-employee channel, but if you are running a lucrative business, that is perfectly fine, since you should, by the next payday, have earned enough, and then some, to pay the employee on the next payday.\n>\n> Of course there will be times when business is a little slow and you get less than 0.042/2weeks.\n> In that case, a wise business manager will reserve some funds for a rainy day when business is a little slow, meaning you will still have some funds you can put into your to-network big channel for other expenses, even as your employee uses capacity there to actually spend their salary.\n>\n> It all balances out.\n> You only need to keep enough in your channels to cover your continuous operational expenses, and employee salaries *are* operational expenses.\n>\n>\n> Suppose you now want to hire *another* throat-cutter.\n> You would only do that if business is booming, or in other words, if you have accumulated enough money in your treasury to justify hiring yet another employee.\n>\n> By induction, this will work regardless if you have 1 employee, or 1 million.\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-10-04T14:24:59",
                "message_text_only": "Good morning Thomas,\n\n> \"big to-network channel\"\n>\n> nit: should this be \"big from-network channel\" ?\n\nAs Lightning Network channels are bidirectional, it would be more properly \"to/from-network\", but that is cumbersome.\n\"to-network\" is shorter by two characters than \"from-network\", and would be true as well (since the channel is bidirectional, it is both a \"to-network\" and \"from-network\" channel), thus preferred.\n\n\n>\n> thanks for this explanation.\n\nYou are welcome.\n\nRegards,\nZmnSCPxj\n\n> On Sat, Oct 3, 2020 at 11:45 PM ZmnSCPxj via bitcoin-dev\n> bitcoin-dev at lists.linuxfoundation.org wrote:\n>\n> > Good Morning Mr. Lee,\n> >\n> > > I cannot front up funds of my own to give\n> > > them inbound balance because it would consume all of my treasury to lock\n> > > up funds.\n> >\n> > This is not a reasonable assumption!\n> > Suppose you have a new hire that you have agreed to pay 0.042BTC every 2 weeks.\n> > On the first payday of the new hire, you have to have at least 0.042BTC in your treasury, somehow.\n> > If not, you are unable to pay the new hire, full stop, and you are doomed to bankruptcy and your problems will disappear soon once your cut-throat new hire cuts your throat for not paying her or him.\n> > If you do have at least 0.042BTC in your treasury, you can make the channel with the new hire and pay the salary via the new channel.\n> > At every payday, you need to have at least the salary of your entire employee base available, otherwise you would be unable to pay at least some of your employees and you will quickly find yourself with your throat cut.\n> > Now, let us talk about topology.\n> > Let us reduce this to a pointless topology that is the worst possible topology for Lightning usage, and show that by golly, Lightning will still work.\n> > Suppose your company only has this one big channel with the network.\n> > Let us reduce your company to only having this single new hire throat-cutter (we will show later that without loss of generality this will still work even if you have thousands of throat-cutters internationally).\n> > Now, as mentioned, on the first payday of your throat-cutter, you have to have at least the 0.042 salary you promised.\n> > If you have been receiving payments for your throat-cutting business on the big channel, that means the 0.042 BTC is in that single big channel.\n> > You can then use an offchain-to-onchain swap service like Boltz or Loop and put the money onchain.\n> > Then you can create the new channel to your new hire and pay the promised salary to the throat-cutter.\n> > Now, you have no more funds in either of your channels, the to-network big channel, and the to-employee channel.\n> > So you are not locking up any of your funds, only the funds of your employee.\n> > Now, as your business operates, you will receive money in your to-network big channel.\n> > The rate at which you receive money for services rendered has to be larger than 0.042/2weeks on average, otherwise you are not earning enough to pay your throat-cutter by the time of the next payday (much less your other operating expenses, such as knife-sharpening, corpse disposal, dealing with the families of the deceased, etc.).\n> > If you are not earning at a high enough rate to pay your employee by the next payday, your employee will not be paid and will solve your problems by cutting your throat.\n> > But what that means is that the employee salary of the previous payday is not locked, either!\n> > Because you are receiving funds on your big to-network channel continuously, the employee can now spend the funds \"locked\" in the to-employee channel, sending out to the rest of the network.\n> > This uses up the money you have been earning and moving the funds to the to-employee channel, but if you are running a lucrative business, that is perfectly fine, since you should, by the next payday, have earned enough, and then some, to pay the employee on the next payday.\n> > Of course there will be times when business is a little slow and you get less than 0.042/2weeks.\n> > In that case, a wise business manager will reserve some funds for a rainy day when business is a little slow, meaning you will still have some funds you can put into your to-network big channel for other expenses, even as your employee uses capacity there to actually spend their salary.\n> > It all balances out.\n> > You only need to keep enough in your channels to cover your continuous operational expenses, and employee salaries are operational expenses.\n> > Suppose you now want to hire another throat-cutter.\n> > You would only do that if business is booming, or in other words, if you have accumulated enough money in your treasury to justify hiring yet another employee.\n> > By induction, this will work regardless if you have 1 employee, or 1 million.\n> > Regards,\n> > ZmnSCPxj\n> >\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "A thought experiment on bitcoin for payroll privacy",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Thomas Hartman",
                "Mr. Lee Chiffre"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 21563
        }
    },
    {
        "title": "[bitcoin-dev] Detailed protocol design for routed multi-transaction CoinSwap appendium",
        "thread_messages": [
            {
                "author": "Chris Belcher",
                "date": "2020-10-03T10:36:22",
                "message_text_only": "Hello list,\n\nThis email is an appendium or modification of the earlier CoinSwap\nprotocol published on this list. It is intended to fix the problems\nfound in review. (Original email quoted here too)\n\n\nOn 11/08/2020 13:05, Chris Belcher via bitcoin-dev wrote:\n> I'm currently working on implementing CoinSwap (see my other email\n> \"Design for a CoinSwap implementation for massively improving Bitcoin\n> privacy and fungibility\").\n> \n> CoinSwaps are special because they look just like regular bitcoin\n> transactions, so they improve the privacy even for people who do not use\n> them. Once CoinSwap is deployed, anyone attempting surveillance of\n> bitcoin transactions will be forced to ask themselves the question: how\n> do we know this transaction wasn't a CoinSwap?\n> \n> This email contains a detailed design of the first protocol version. It\n> makes use of the building blocks of multi-transaction CoinSwaps, routed\n> CoinSwaps, liquidity market, private key handover, and fidelity bonds.\n> It does not include PayJoin-with-CoinSwap, but that's in the plan to be\n> added later.\n> \n> == Routed CoinSwap ==\n> \n> Diagram of CoinSwaps in the route:\n> \n>     Alice ====> Bob ====> Charlie ====> Alice\n> \n> Where (====>) means one CoinSwap. Alice gives coins to Bob, who gives\n> coins to Charlie, who gives coins to Alice. Alice is the market taker\n> and she starts with the hash preimage. She chooses the CoinSwap amount\n> and chooses who the makers will be.\n> \n> This design has one market taker and two market makers in its route, but\n> it can easily be extended to any number of makers.\n> \n> == Multiple transactions ==\n> \n> Each single CoinSwap is made up of multiple transactions to avoid amount\n> correlation\n> \n>           (a0 BTC) --->     (b0 BTC) --->         (c0 BTC) --->\n>     Alice (a1 BTC) ---> Bob (b1 BTC) ---> Charlie (c1 BTC) ---> Alice\n>           (a2 BTC) --->     (b2 BTC) --->         (c2 BTC) --->\n> \n> The arrow (--->) represent funding transactions. The money gets paid to\n> a 2-of-2 multisig but after the CoinSwap protocol and private key\n> handover is done they will be controlled by the next party in the route.\n> \n> This example has 6 regular-sized transactions which use approximately\n> the same amount of block space as a single JoinMarket coinjoin with 6\n> parties (1 taker, 5 makers). Yet the privacy provided by this one\n> CoinSwap would be far far greater. It would not have to be repeated in\n> the way that Equal-Output CoinJoins must be.\n> \n> == Direct connections to Alice ===\n> \n> Only Alice, the taker, knows the entire route, Bob and Charlie just know\n> their previous and next transactions. Bob and Charlie do not have direct\n> connections with each other, only with Alice.\n> \n> Diagram of Tor connections:\n> \n>     Bob      Charlie\n>      |       /\n>      |      /\n>      |     /\n>       Alice\n> \n> When Bob and Charlie communicate, they are actually sending and\n> receiving messages via Alice who relays them to Charlie or Bob. This\n> helps hide whether the previous or next counterparty in a CoinSwap route\n> is a maker or taker.\n> \n> This doesn't have security issues even in the final steps where private\n> keys are handed over, because those private keys are always for 2-of-2\n> multisig and so on their own are never enough to steal money.\n> \n> \n> === Miner fees ===\n> \n> Makers have no incentive to pay any miner fees. They only do\n> transactions which earn them an income and are willing to wait a very\n> long time for that to happen. By contrast takers want to create\n> transactions far more urgently. In JoinMarket we coded a protocol where\n> the maker could contribute to miner fees, but the market price offered\n> of that trended towards zero. So the reality is that takers will pay all\n> the miner fees. Also because makers don't know the taker's time\n> preference they don't know how much they should pay in miner fees.\n> \n> The taker will have to set limits on how large the maker's transactions\n> are, otherwise makers could abuse this by having the taker consolidate\n> maker's UTXOs for free.\n> \n> == Funding transaction definitions ==\n> \n> Funding transactions are those which pay into the 2-of-2 multisig addresses.\n> \n> Definitions:\n> I = initial coinswap amount sent by Alice = a0 + a1 + a2\n> (WA, WB, WC) = Total value of UTXOs being spent by Alice, Bob, Charlie\n>                respectively. Could be called \"wallet Alice\", \"wallet\n>                Bob\", etc\n> (B, C) = Coinswap fees paid by Alice and earned by Bob and Charlie.\n> (M1, M2, M3) = Miner fees of the first, second, third, etc sets of\n>                funding transactions. Alice will choose what these are\n>                since she's paying.\n> multisig(A+B) = A 2of2 multisig output with private keys held by A and B\n> \n> The value in square parentheses refers to the bitcoin amount.\n> \n> Alice funding txes\n>   [WA btc] ---> multisig (Alice+Bob) [I btc]\n>                 change [WA-M1-I btc]\n> Bob funding txes\n>   [WB btc] ---> multisig (Bob+Charlie) [I-M2-B btc]\n>                 change [WB-I+B btc]\n> Charlie funding txes\n>   [WC btc] ---> multisig (Charlie+Alice) [(I-M2-B)-M3-C btc]\n>                 change [WC-(I-M2-B)+C btc]\n> \n> Here we've drawn these transactions as single transactions, but they are\n> actually multiple transactions where the outputs add up some value (e.g.\n> add up to I in Alice's transactions.)\n> \n> === Table of balances before and after a successful CoinSwap ===\n> \n> If a CoinSwap is successful then all the multisig outputs in the funding\n> transactions will become controlled unilaterally by one party. We can\n> calculate how the balances of each party change.\n> \n> Party   | Before | After\n> --------|--------|-------------------------------------------\n> Alice   | WA     | WA-M1-I + (I-M2-B)-M3-C  = WA-M1-M2-M3-B-C\n> Bob     | WB     | WB-I+B + I               = WB+B\n> Charlie | WC     | WC-(I-M2-B)+C + I-M2-B   = WC+C\n> \n> After a successful coinswap, we see Alice's balance goes down by the\n> miner fees and the coinswap fees. Bob's and Charlie's balance goes up by\n> their coinswap fees.\n> \n> == Contract transaction definitions ==\n> \n> Contract transactions are those which may spend from the 2-of-2 multisig\n> outputs, they transfer the coins into a contract where the coins can be\n> spent either by waiting for a timeout or providing a hash preimage\n> value. Ideally contract transactions will never be broadcast but their\n> existence keeps all parties honest.\n> \n> M~ is miner fees, which we treat as a random variable, and ultimately\n> set by whichever pre-signed RBF tx get mined. When we talk about _the_\n> contract tx, we actually mean perhaps 20-30 transactions which only\n> differ by the miner fee and have RBF enabled, so they can be broadcasted\n> in sequence to get the contract transaction mined regardless of the\n> demand for block space.\n> \n> (Alice+timelock_A OR Bob+hash) = Is an output which can be spent\n>                                  either with Alice's private key\n>                                  after waiting for a relative\n>                                  timelock_A, or by Bob's private key by\n>                                  revealing a hash preimage value\n> \n> Alice contract tx:\n>     multisig (Alice+Bob) ---> (Alice+timelock_A OR Bob+hash)\n>     [I btc]                   [I-M~ btc]\n> Bob contract tx:\n>     multisig (Bob+Charlie) ---> (Bob+timelock_B OR Charlie+hash)\n>     [I-M2-B btc]                [I-M2-B-M~ btc]\n> Charlie contract tx:\n>     multisig (Charlie+Alice)  ---> (Charlie+timelock_C OR Alice+hash)\n>     [(I-M2-B)-M3-C btc]            [(I-M2-B)-M3-C-M~ btc]\n> \n> \n> === Table of balances before/after CoinSwap using contracts transactions ===\n> \n> In this case the parties had to get their money back by broadcasting and\n> mining the contract transactions and waiting for timeouts.\n> \n> Party   | Before | After\n> --------|--------|--------------------------------------------\n> Alice   | WA     | WA-M1-I + I-M~                   = WA-M1-M~\n> Bob     | WB     | WB-I+B + I-M2-B-M~               = WB-M2-M~\n> Charlie | WC     | WC-(I-M2-B)+C + (I-M2-B)-M3-C-M~ = WC-M3-M~\n> \n> In the timeout failure case, every party pays for their own miner fees.\n> And nobody earns or spends any coinswap fees. So even for a market maker\n> its possible for their wallet balance to go down sometimes, although as\n> we shall see there are anti-DOS features which make this unlikely to\n> happen often.\n> \n> A possible attack by a malicious Alice is that she chooses M1 to be very\n> low (e.g. 1 sat/vbyte) and sets M2 and M3 to be very high (e.g. 1000\n> sat/vb) and then intentionally aborts, forcing the makers to lose much\n> more money in miner fees than the attacker. The attack can be used to\n> waste away Bob's and Charlie's coins on miner fees at little cost to the\n> malicious taker Alice. So to defend against this attack Bob and Charlie\n> must refuse to sign a contract transaction if the corresponding funding\n> transaction pays miner fees greater than Alice's funding transaction.\n> \n> \n> There can also be a failure case where each party gets their money using\n> hash preimage values instead of timeouts. Note that each party has to\n> sweep the output before the timeout expires, so that will cost an\n> additional miner fee M~.\n> \n> Party   | Before | After\n> --------|--------|------------------------------------------------------\n> Alice   | WA     | WA-M1-I + (I-M2-B)-M3-C-M~ - M~ = WA-M1-M2-M3-B-C-2M~\n> Bob     | WB     | WB-I+B + I-M~ - M~              = WB+B-2M~\n> Charlie | WC     | WC-(I-M2-B)+C + I-M2-B-M~ - M~  = WC+C-2M~\n> \n> In this situation the makers Bob and Charlie earn their CoinSwap fees,\n> but they pay an additional miner fee twice. Alice pays for all the\n> funding transaction miner fees, and the CoinSwap fees, and two\n> additional miner fees. And she had her privacy damaged because the\n> entire world saw on the blockchain the contract script.\n> \n> Using the timelock path is like a refund, everyone's coin just comes\n> back to them. Using the preimage is like the CoinSwap transaction\n> happened, with the coins being sent ahead one hop. Again note that if\n> the preimage is used then coinswap fees are paid.\n> \n> === Staggered timelocks ===\n> \n> The timelocks are staggered so that if Alice uses the preimage to take\n> coins then the right people will also learn the preimage and have enough\n> time to be able to get their coins back too. Alice starts with knowledge\n> of the hash preimage so she must have a longest timelock.\n> \n> == EC tweak to reduce one round trip ==\n> \n> When two parties are agreeing on a 2-of-2 multisig address, they need to\n> agree on their public keys. We can avoid one round trip by using the EC\n> tweak trick.\n> \n> When Alice, the taker, downloads the entire offer book for the liquidity\n> market, the offers will also contain a EC public key. Alice can tweak\n> this to generate a brand new public key for which the maker knows the\n> private key. This public key will be one of the keys in the 2-of-2\n> multisig. This feature removes one round trip from the protocol.\n> \n>     q = EC privkey generated by maker\n>     Q = q.G = EC pubkey published by maker\n> \n>     p = nonce generated by taker\n>     P = p.G = nonce point calculated by taker\n> \n>     R = Q + P = pubkey used in bitcoin transaction\n>       = (q + p).G\n> \n> Taker sends unsigned transaction which pays to multisig using pubkey Q,\n> and also sends nonce p. The maker can use nonce p to calculate (q + p)\n> which is the private key of pubkey R.\n> \n> Taker doesnt know the privkey because they are unable to find q because\n> of the ECDLP.\n> \n> Any eavesdropper can see the nonce p and easily calculate the point R\n> too but Tor communication is encrypted so this isnt a concern.\n> \n> None of the makers in the route know each other's Q values, so Alice the\n> taker will generate a nonce p on their behalf and send it over. I\n> believe this cant be used for any kind of attack, because the signing\n> maker will always check that the nonce results in the public key\n> included in the transaction they're signing, and they'll never sign a\n> transaction not in their interests.\n> \n> \n> == Protocol ==\n> \n> This section is the most important part of this document.\n> \n> Definitions:\n> fund = all funding txes (remember in this multi-tx protocol there can be\n>        multiple txes which together make up the funding)\n> A htlc = all htlc contract txes (fully signed) belonging to party A\n> A unsign htcl = all unsigned htlc contract txes belonging to party A\n>                 including the nonce point p used to calculate the\n>                 maker's pubkey.\n> p = nonce point p used in the tweak EC protocol for calculating the\n>     maker's pubkey\n> A htlc B/2 = Bob's signature for the 2of2 multisig of the Alice htlc\n>              contract tx\n> privA(A+B) = private key generated by Alice in the output\n>              multisig (Alice+Bob)\n> \n> \n>  | Alice           | Bob             | Charlie         |\n>  |=================|=================|=================|\n> 0. A unsign htlc ---->               |                 |\n> 1.               <---- A htlc B/2    |                 |\n> 2. ***** BROADCAST AND MINE ALICE FUNDING TXES ******  |\n> 3. A fund+htlc+p ---->               |                 |\n> 4.                 | B unsign htlc ---->               |\n> 5.                 |               <---- B htlc C/2    |\n> 6. ******* BROADCAST AND MINE BOB FUNDING TXES ******* |\n> 7.                 | B fund+htlc+p ---->               |\n> 8.               <---------------------- C unsign htlc |\n> 9.    C htlc A/2 ---------------------->               |\n> A. ***** BROADCAST AND MINE CHARLIE FUNDING TXES ***** |\n> B.               <---------------------- C fund+htlc+p |\n> C. hash preimage ---------------------->               |\n> D. hash preimage ---->               |                 |\n> E.    privA(A+B) ---->               |                 |\n> F.                 |    privB(B+C) ---->               |\n> G.               <---------------------- privC(C+A)    |\n> \n> == Protocol notes ==\n> 0-2 are the steps which setup Alice's funding tx and her contract tx for\n>     possible refund\n> 4-5 same as 0-2 but for Bob\n> 8-9 same as 0-2 but for Charlie\n> 3,7 is proof to the next party that the previous party has already\n>     committed miner fees to getting a transaction mined, and therefore\n>     this isnt a DOS attack. The step also reveals the fully-signed\n>     contract transaction which the party can use to get their money back\n>     with a preimage.\n> C-G is revealing the hash preimage to all, and handing over the private\n>     keys\n> \n> \n> == Analysis of aborts ==\n> \n> We will now discuss aborts, which happen when one party halts the\n> protocol and doesnt continue. Perhaps they had a power cut, their\n> internet broke, or they're a malicious attacker wanting to waste time\n> and money. The other party may try to reestablish a connection for some\n> time, but eventually must give up.\n> \n> Number refers to the step number where the abort happened\n> e.g. step 1 means that the party aborted instead of the action happening\n> on protocol step 1.\n> \n> The party name refers to what that party does\n> e.g. Party1: aborts, Party2/Party3: does a thing in reaction\n> \n> 0. Alice: aborts. Bob/Charlie: do nothing, they havent lost any time or\n>    money\n> 1. Bob: aborts. Alice: lost no time or money, try with another Bob.\n>    Charlie: do nothing\n> 2-3. same as 0.\n> 4. Bob: aborts. Charlie: do nothing. Alice: broadcasts her contract tx\n>    and waits for the timeout, loses time and money on miner fees, she'll\n>    never coinswap with Bob's fidelity bond again.\n> 5. Charlie: aborts. Alice/Bob: lose nothing, find another Charlie to\n>    coinswap with.\n> 6. same as 4.\n> 7. similar to 4 but Alice MIGHT not blacklist Bob's fidelity bond,\n>    because Bob will also have to broadcast his contract tx and will also\n>    lose time and money.\n> 8. Charlie: aborts. Bob: broadcast his contract transaction and wait for\n>    the timeout to get his money back, also broadcast Alice's contract\n>    transaction in retaliation. Alice: waits for the timeout on her htlc\n>    tx that Bob broadcasted, will never do a coinswap with Charlie's\n>    fidelity bond again.\n> 9. Alice: aborts. Charlie: do nothing, no money or time lost. Bob:\n>    broadcast bob contract tx and wait for timeout to get money back,\n>    comforted by the knowledge that when Alice comes back online she'll\n>    have to do the same thing and waste the same amount of time and\n>    money.\n> A-B. same as 8.\n> C-E. Alice: aborts. Bob/Charlie: all broadcast their contract txes and\n>      wait for the timeout to get their money back, or if Charlie knows\n>      the preimage he uses it to get the money immediately, which Bob can\n>      read from the blockchain and also use.\n> F. Bob: aborts. Alice: broadcast Charlie htlc tx and use preimage to get\n>    money immediately, Alice blacklists Bob's fidelity bond. Charlie:\n>    broadcast Bob htlc and use preimage to get money immediately.\n> G. Charlie: aborts. Alice: broadcast Charlie htlc and use preimage to\n>    get money immediately, Alice blacklists Charlie's fidelity bond. Bob:\n>    does nothing, already has his privkey.\n> \n> ==== Retaliation as DOS-resistance ====\n> \n> In some situations (e.g. step 8.) if one maker in the coinswap route is\n> the victim of a DOS they will retaliate by DOSing the previous maker in\n> the route. This may seem unnecessary and unfair (after all why waste\n> even more time and block space) but is actually the best way to resist\n> DOS because it produces a concrete cost every time a DOS happens.\n> \n> \n> == Analysis of deviations ==\n> \n> This section discusses what happens if one party deviates from the\n> protocol by doing something else, for example broadcasting a htlc\n> contract tx when they shouldnt have.\n> \n> The party name refers to what that party does, followed by other party's\n> reactions to it.\n> e.g. Party1: does a thing, Party2/Party3: does a thing in reaction\n> \n> If multiple deviations are possible in a step then they are numbered\n> e.g. A1 A2 A2 etc\n> \n> \n> 0-2. Alice/Bob/Charlie: nothing else is possible except following the\n>      protocol or aborting\n> 3. Alice: broadcasts one or more of the A htlc txes. Bob/Charlie/Dennis:\n>    do nothing, they havent lost any time or money.\n> 4-6. Bob/Charlie: nothing else is possible except following the protocol\n>      or aborting.\n> 7. Bob: broadcasts one or more of the B htlc txes, Alice: broadcasts all\n>    her own A htlc txes and waits for the timeout to get her money back.\n>    Charlie: do nothing\n> 8. Charlie: nothing else is possible except following the protocol or\n>    aborting.\n> 9. Alice: broadcasts one or more of the A htlc txes. Bob: broadcasts all\n>    his own A htlc txes and waits for the timeout.\n> A. same as 8.\n> B. Charlie: broadcasts one or more of the C htlc txes, Alice/Bob:\n>    broadcasts all their own htlc txes and waits for the timeout to get\n>    their money back.\n> C-E1. Alice: broadcasts all of C htlc txes and uses her knowledge of the\n>       preimage hash to take the money immediately. Charlie: broadcasts\n>       all of B htlc txes and reading the hash value from the blockchain,\n>       uses it to take the money from B htlc immediately. Bob: broadcasts\n>       all of A htlc txes, and reading hash from the blockchain, uses it\n>       to take the money from A htlc immediately.\n> C-E2. Alice: broadcast her own A htlc txes, and after a timeout take the\n>       money. Bob: broadcast his own B htlc txes and after the timeout\n>       take their money. Charlie: broadcast his own C htlc txes and after\n>       the timeout take their money.\n> F1. Bob: broadcast one or more of A htcl txes and use the hash preimage\n>     to get the money immediately. He already knows both privkeys of the\n>     multisig so this is pointless and just damages privacy and wastes\n>     miner fees. Alice: blacklist Bob's fidelity bond.\n> F2. Bob: broadcast one or more of the C htlc txes. Charlie: use preimage\n>     to get his money immediately. Bob's actions were pointless. Alice:\n>     cant tell whether Bob or Charlie actually broadcasted, so blacklist\n>     both fidelity bonds.\n> G1. Charlie: broadcast one or more of B htcl txes and use the hash\n>     preimage to get the money immediately. He already knows both\n>     privkeys of the multisig so this is pointless and just damages\n>     privacy and wastes miner fees. Alice: cant tell whether Bob or\n>     Charlie actually broadcasted, so blacklist both fidelity bonds.\n> G2. Charlie: broadcast one or more of the A htlc txes. Alice: broadcast\n>     the remaining A htlc txes and use preimage to get her money\n>     immediately. Charlies's actions were pointless. Alice: blacklist\n>     Charlie's fidelity bond.\n> \n> The multisig outputs of the funding transactions can stay unspent\n> indefinitely. However the parties must always be watching the network\n> and ready to respond with their own sweep using a preimage. This is\n> because the other party still possesses a fully-signed contract tx. The\n> parties respond in the same way as in steps C-E1, F2 and G2. Alice's\n> reaction of blacklisting both fidelity bonds might not be the right way,\n> because one maker could use it to get another one blacklisted (as well\n> as themselves).\n> \n> \n> == Conclusion ==\n> \n> This document describes the first version of the protocol which\n> implements multi-transaction Coinswap, routed Coinswap, fidelity bonds,\n> a liquidity market and private key handover. I describe the protocol and\n> also analyze aborts of the protocols and deviations from the protocol.\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n\n== Miner fees ==\nRBF is used on contract transactions as before, so each contract\ntransaction actually has many different versions each with a different\nminer fee.\n\nA possible vulnerability of using RBF is transaction pinning (see\nhttps://bitcoinops.org/en/topics/transaction-pinning/). We solve this\nissue by encumbering hashlock outputs with `1 OP_CSV`, so that it is not\npossible to do CPFP on a contract transaction.\n\nAnother possible vulnerability (called post-coinswap-fee-burning) is\nthat after a successful CoinSwap, the party which no longer controls the\ncoins can still broadcast a high-fee RBF contract transaction in order\nto burn coins to miner fees. This might be used by a malicious taker to\nwaste away the balance of a maker (the malicious taker might be another\nmaker who in the liquidity market is in competition with the victim\nmaker, and is using this exploit to attack their competitor).\n\n=== Collateral payments ===\nThe post-coinswap-theft-attempt is an attack done after a CoinSwap is\nfinished. It works by the sender broadcasting their contract transaction\nof the coins which no longer belong to him, they hope that the timeout\nwill expire and that they can sweep the coins. Their theft attempt is\nvery unlikely to actually succeed because of multiple redundant\nwatchtowers who will immediately spend the coins with the hashlock\nbranch, but the thief still might try because the attempt is essentially\nriskless and costless.\n\nCollateral payments are used to avoid this problem by making the theft\nattempt not costless. (Although the cost is best kept very small,\ncorresponding to the risk of success being very low). (see\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018151.html)\n\nPost-coinswap-theft-attempts are already not costless for the taker,\nbecause broadcasting the contract transactions damages privacy, which\nthe taker by construction wants to improve and has actually already paid\nfor. Privacy is reduced either by revealing the contract on-chain or by\nreducing anonymity sets by having the coins spent immediately or very\nsoon). Therefore takers dont require collateral payments in this\nprotocol and this allows a taker to fully-spend their entire wallet in\none set of CoinSwaps (i.e. a sweep transaction with no change).\n\nCollateral payments also solve the vulnerability of\npost-coinswap-fee-burning for maker-maker CoinSwaps, because the miner\nfee is taken from the collateral input and single-sig change, and not\nfrom the CoinSwap contract.\n\n==== Post-CoinSwap-fee-burning for takers ====\nCollateral payments stop the post-coinswap-fee-burning attack but only\nfor makers, as takers dont use collateral payments.\n\nHowever takers are unique in the way that takers pay CoinSwap fees. So\nfor a taker to attack a maker via post-coinswap-fee-burning they first\nneed to pay CoinSwap fees. So we just have makers refuse to sign RBF\ntransactions paying a fee higher than the CoinSwap fee they earn. (Or\nperhaps a constant factor, for example a maker imposes the condition\nthat the RBF miner fee can only be 5x or 10x the CoinSwap fee).\n\n\n== Funding transaction definitions ==\nSame as in the v1 design doc.\n\n\n== Contract transaction definitions ==\nIn the v1 design each party in a CoinSwap possessed the _same_ contract\ntransaction. This is no longer the case, and each party might know\nslightly different versions, perhaps differing by miner fees or whether\na collateral payment is used.\n\nAs before the value in square parentheses refers to bitcoin amount. The\nvalue in the round parentheses refers to script.\n\nContract transactions have this notation based on who knows them:\n    contract tx for the Alice-Bob multisig, known only to Alice\n  = contract tx Alice-Bob/Alice\n  = contract tx AB/A\n\n=== Contract txes known by receiver ===\nThese are contract transactions known by the receiver of coins from the\nmultisig. They are pretty much the same as in v1, except with added `1\nOP_CSV` to the hashlock (not included here for clarity).\n\nAlice-Bob/Bob contract tx:\n    multisig (Alice+Bob) ---> (Alice+timelock_A OR Bob+hash)\n    [I btc]                   [I-M~ btc]\n\nBob-Charlie/Charlie contract tx:\n    multisig (Bob+Charlie) ---> (Bob+timelock_B OR Charlie+hash)\n    [I-M2-B btc]                [I-M2-B-M~ btc]\n\nCharlie-Alice/Alice contract tx:\n    multisig (Charlie+Alice) ---> (Charlie+timelock_C OR Alice+hash)\n    [(I-M2-B)-M3-C btc]           [(I-M2-B)-M3-C-M~ btc]\n\n=== Table of balances before and after a coinswap resolved with contract\ntxes known to recievers ===\nIf a CoinSwap is resolved with contract txes known to receivers, then\nthat means the parties had to get their money back by broadcasting and\nmining the contract transactions, and spending the output using their\nknowledge of the hash preimage. Each party has to spend the output\nbefore the timeout expires, so that costs an additional miner fee M~.\n\nParty   | Before | After\n--------|--------|-------------------------------------------\nAlice   | WA     | WA-M1-I + (I-M2-B)-M3-C-M~ - M~ = WA-M1-M2-M3-B-C-2M~\nBob     | WB     | WB-I+B + I-M~ - M~              = WB+B-2M~\nCharlie | WC     | WC-(I-M2-B)+C + I-M2-B-M~ - M~  = WC+C-2M~\n\nThe makers earn their CoinSwap fees but pay an additional miner fee\ntwice, so they are incentivized to avoid this outcome compared to the\nsuccess case where they just earn their fees. Alice is incentivized to\navoid this outcome because she would pay for miner fees and coinswap\nfees, and not get any privacy in return.\n\n=== Contract txes known by the sender ===\nThe maker's contract transaction must include a collateral payment.\n\ndefinitions:\n    Jb, Jc = value of a maker's (Bob, Charlie) collateral input\n    K = collateral amount, which a maker loses if he broadcasts his\ncontract tx but doesnt get the money using the hash preimage\n\nAlice-Bob/Alice contract tx:\n    multisig (Alice+Bob) ---> (Alice+timelock_A OR Bob+hash)\n             [I btc]          [I-M~ btc]\n\nBob-Charlie/Bob contract tx:\n    multisig  (Bob+Charlie) ---> (Bob+timelock_B OR Charlie+hash)\n              [I-M2-B btc]       [I-M2-B+K btc]\n    singlesig (Bob)              (Bob)\n              [Jb btc]           [Jb-K-M~ btc]\n\nCharlie-Alice/Charlie contract tx:\n    multisig  (Charlie+Alice)     ---> (Charlie+timelockC OR Alice+hash)\n              [(I-M2-B)-M3-C btc]      [(I-M2-B)-M3-C+K btc]\n    singlesig (Charlie)                (Charlie)\n              [Jc btc]                 [Jc-K-M~ btc]\n\n=== Table of balances before and after a coinswap resolved with contract\ntxes known to senders ===\nIf a coinswap is resolved with contract txes known to senders, then that\nmeans the parties had to get their money back by broadcasting and mining\nthe contract transactions, and spending the output by waiting for the\ntimeout.\n\nParty   |Before | After\n--------|-------|-------------------------------------------\nAlice   | WA    |WA-M1-I + I-M~                            = WA-M1-M~\nBob     | WB+Jb |WB-I+B + I-M2-B+K + Jb-K-M~               = WB+Jb-M2-M~\nCharlie | WC+Jc |WC-(I-M2-B)+C + (I-M2-B)-M3-C+K + Jc-K-M~ = WC+Jc-M3-M~\n\nEveryone gets their money back and pays for their own miner fees. And\nthe CoinSwap didn't happen, which is crappy considering money was lost\nin miner fees but part of the point of fidelity bonds is to stop this\nhappening too much.\n\n=== Table of balances before and after a successful CoinSwap but with\none post-CoinSwap-theft-attempt ===\nHere the CoinSwap has succeeded but one maker (Bob in this case) does a\npost-coinswap-theft-attempt, which fails, because the next party\n(Charlie) uses the hash preimage to spend the coins. Most coins can\nremain unspent on-chain because of private-key-handover, but the\nBob-Charlie/Bob contract transaction was broadcast and mined.\n\nParty   | Before | After\n--------|--------|-------------------------------------------\nAlice   | WA     | WA-M1-I + (I-M2-B)-M3-C  = WA-M1-M2-M3-B-C\nBob     | WB+Jb  | WB-I+B + Jb-K-M~ + I     = WB+Jb+B-K-M~\nCharlie | WC     | WC-(I-M2-B)+C + I-M2-B+K = WC+C+K\n\nAs we see, Alice's outcome is the same as in the success case. Compared\nto the success case, Bob loses K bitcoins and an extra miner fee while\nCharlie gains K bitcoins.\n\nLooking at these equations, I realize that the incentives against\npost-coinswap-theft-attempt still work even if we set K = 0, because the\nextra miner fee paid by Bob could be enough disincentive.\n\n\n== Protocol ==\nDefinitions:\n    A fund = Alice's funding tx\n    AB/A us htlc = unsigned contract tx for the A-B multisig, where the\n        fully-signed version is only meant to be known by A\n    AB/A htlc B/2 = Bob's signature for contract tx for the A-B\n        multisig, where the fully-signed version is only meant to be\n        known by A\n    p = nonce point p used in the tweak EC protocol for calculating the\n        maker's pubkey, used to avoid one round trip\n    privA(A+B) = private key generated by Alice in the A-B multisig\n\n | Alice           | Bob             | Charlie         |\n |=================|=================|=================|\n0.  AB/A us htlc ---->               |                 |\n1.               <---- AB/A htlc B/2 |                 |\n2.    ***** BROADCAST AND MINE ALICE FUNDING TX *****  |\n3.    A fund + p ---->               |                 |\n4.               <---- AB/B us htlc  |                 |\n5. AB/B htlc A/2 ---->               |                 |\n6.                 |  BC/B us htlc ---->               |\n7.                 |               <---- BC/B htlc C/2 |\n8.    ***** BROADCAST AND MINE BOB FUNDING TX *****    |\n9.                 |    B fund + p ---->               |\nA.                 |               <---- BC/C us htlc  |\nB.                 | BC/C htlc B/2 ---->               |\nC.               <---------------------- CA/C us htlc  |\nD. CA/C htlc A/2 ---------------------->               |\nE.   ***** BROADCAST AND MINE CHARLIE FUNDING TX ***** |\nF.               <---------------------- C fund + p    |\nG.  CA/A us htlc ---------------------->               |\nH.               <---------------------- CA/A htlc C/2 |\nI. hash preimage ---------------------->               |\nJ. hash preimage ---->               |                 |\nK.    privA(A+B) ---->               |                 |\nL.                 |    privB(B+C) ---->               |\nM.               <---------------------- privC(C+A)    |\n\n=== Protocol notes ===\n0-2. Alice sets up her funding tx and contract tx for possible refund\n     with timeout\n3.   Alice convinces Bob that their multisig is funded, and therefore\n     this whole thing isnt a DOS\n4-5. Bob obtains his contract tx for the A-B multisig\n6-8. Same as 0-2 but for Bob\n9.   Same as 3. but for Bob/Charlie\nA-B. Same as 4-5 but for Charlie\nC-E. Same as 0-2 and 6-8 but for Charlie\nF.   Same as 3 and 9 but for Charlie/Alice\nG-H. Same as 4-5 or A-B but for Alice\nH.   After this step every party's coins are locked up in multisig, and\n     they can all get the coins back after the timeout, or if they know\n     the hash preimage they can get different coins immediately.\nI-J. Reveal preimages to everyone, making the coins do an off-chain hop\n     ahead by one step.\nK-M. Reveal private keys to each other. The incentive to do this is to\n     save on miner fees, and improve privacy.\n\n=== Analysis of aborts ===\nAborts are when one party halts the protocol (i.e. they had a power cut,\nor they are a DOS attacker). Here we analyze how the other parties react.\n\nAs in v1, the number refers to the step number where the abort happened.\n\n0. Alice: aborts. Bob/Charlie: do nothing, they havent lost any time or\n   money.\n1. Bob: aborts. Alice: lost no time or money, try with another Bob.\n   Charlie: do nothing\n2-3. Same as 0.\n4. Bob: aborts. Charlie: do nothing. Alice: broadcasts contract tx AB/A\n   and waits for the timeout, loses time and money on miner fees, she'll\n   never coinswap with Bob's fidelity bond again.\n5. Same as 0.\n6. Same as 4.\n7. Charlie: aborts. Alice/Bob: lose nothing, find another Charlie to\n   coinswap with.\n8. Same as 4.\n9. Similar to 4 but Alice MIGHT not blacklist Bob's fidelity bond,\n   because Bob will also have to broadcast his contract tx BC/B and will\n   also lose time and money. Alice could take Bob's collateral from\n   transaction BC/B, but the value K is small and Alice must spend time\n   and miner fees on her funding transaction, so this isn't a way to DOS\n   for free.\nA. Charlie: aborts. Bob: broadcast his contract tx BC/B and wait for the\n   timeout to get his money back, also broadcast Alice's contract\n   transaction AB/B in retaliation. Alice: waits for the timeout on her\n   contract tx that Bob broadcasted, will never do a coinswap with\n   Charlie's fidelity bond again.\nB. Same as 9.\nC. Same as A.\nD. Alice: aborts. Charlie: do nothing, no money or time lost. Bob:\n   broadcast BC/B contract tx and wait for timeout to get money back,\n   comforted by the knowledge that when Alice comes back online she'll\n   have to do the same thing and waste the same amount of time and\n   money.\nE. Same as A.\nF. Similar to A. but Alice MIGHT not blacklist Charlie's fidelity bond,\n   because Charlie will also have to broadcast his contract tx CA/C and\n   will also lose time and money.\nG. Alice: aborts. Bob/Charlie: all broadcast their contract txes and\n   wait for the timeout to get their money back.\nH. Same as F.\nI-K. Similar to G, but if Charlie knows the hash preimage he can use his\n     contract tx to get the money immediately instead of waiting for the\n     timeout. Bob can read that preimage from the blockchain and use it\n     to also get his money immediately.\nL. Bob: aborts. Alice: hopefully get Charlie's privkey, but if not then\n   broadcast CA/A and use preimage to get money immediately, and never\n   coinswap with Bob's fidelity bond again. Charlie: broadcast BC/C and\n   use preimage to get money immediately.\nM. Charlie: aborts. Alice: broadcast CA/A and use preimage to get money\n   immediately, and never coinswap with Charlie's fidelity bond again.\n   Bob: do nothing, already has Alice's privkey.\n\n== Analysis of deviations ==\n\nDeviations are when one party does something other than what's in the\nprotocol, for example broadcasting a contract transaction when they\nshouldnt have.\n\nThe party name refers to what that party does, followed by other party's\nreactions to it.\ne.g. Party1: does a thing, Party2/Party3: does a thing in reaction.\n\nIf multiple deviations are possible in a step then they are numbered.\ne.g. 5(1) 5(2) 5(3)\n\n\n0-2. Alice/Bob/Charlie: nothing else is possible except following the\nprotocol\n     or aborting.\n3. Alice: broadcasts one or more of the AB/A contract txes. Bob/Charlie:\n   do nothing, they havent lost any time or money.\n4. Bob/Charlie: nothing else is possible except following the protocol\n   or aborting.\n5. Same as 3.\n6. Bob: broadcasts one or more of the AB/B contract txes. Alice:\n   broadcasts the remaining contract txes and waits for the timeout to\n   get her money back, and never coinswaps with Bob's fidelity bond\n   again. Charlie: do nothing.\n7. Charlie: nothing else is possible except following the protocol or\n   aborting.\n8. Same as 6.\n9(1). Same as 6.\n9(2). Bob: broadcast BC/B contract txes. Alice: broadcast her AB/A\n      contract tx and wait for the timeout to get her money back, and\n      never coinswaps with Bob's fidelity bond again. Charlie: do\n      nothing.\nA. Charlie: broadcast BC/C contract tx. Bob: wait for the timeout to get\n   his money back, also broadcast Alice's contract transaction AB/B in\n   retaliation. Alice: waits for the timeout on her contract tx that Bob\n   broadcasted, will never do a coinswap with Charlie's fidelity bond\n   again.\nB. Same as 9(1). and 9(2).\nC. Same as A.\nD. Alice: broadcast AB/A contract tx. Bob: broadcast his own BC/B\n   contract tx and wait for the timeout to get his money back. Charlie:\n   do nothing\nE. Same as A.\nF. Charlie: broadcast CA/C contract tx. Alice: broadcast her AB/A\n   contract tx and wait for the timeout to get her money back, never do\n   a coinswap with Charlie's fidelity bond again. Bob: broadcast his\n   BC/B contract tx and wait for the timeout to get his money back.\nG. Same as D. except Charlie must also broadcast his CA/C contract tx\n   and wait for the timeout.\nH. Same as F.\nI-K(1). Alice: broadcast AB/A contract txes. Bob: broadcast BC/B\n        contract txes and wait for the timeout, or use the hash preimage\n        if he knows it. Charlie: broadcast CA/A contract txes and wait\n        for timeout, or use hash preimage if known.\nI-K(2). Alice: broadcast CA/A contract txes. Bob: broadcast AB/B and\n        wait for the timeout, or use the hash preimage if its known.\n        Charlie: broadcast BC/C and wait for timeout, or use the hash\n        preimage if known.\nI-K(3). Alice: broadcast both AB/A and CA/A contract txes. Bob:\n        broadcast BC/B contract tx and wait for the timeout, or use the\n        hash preimage if its known. Charlie: broadcast BC/C if Bob\n        hasn't broadcast his, and wait for the timeout, or use the hash\n        preimage if known.\nL. Similar to I-K(n), Bob can broadcast one or both the sets of contract\n   txes he knows. The other parties broadcast the remaining ones and\n   either use the timeout or hash preimage value. Alice bans Bob's\n   fidelity bond.\nM. Same as L. but Charlie broadcasting. Alice bans Charlie's fidelity\n   bond.\n\n\nUnlike the v1 protocol, each CoinSwap party knows a different version of\nthe contract transactions, so the taker Alice always knows which maker\nbroadcast a certain set of contract transactions, and so can always ban\nthe correct fidelity bond.\n\n\n== Conclusion ==\nThis document modifies the earlier version 1 detailed protocol design\nfor multi-transaction CoinSwap. It has each CoinSwap party knowing a\nslightly different version of the contract transactions. It also uses\ncollateral payments. These features are both used to fix attacks found\nduring review of the v1 protocol."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-10-03T13:31:58",
                "message_text_only": "Good morning Chris,\n\n>\n> Looking at these equations, I realize that the incentives against\n> post-coinswap-theft-attempt still work even if we set K = 0, because the\n> extra miner fee paid by Bob could be enough disincentive.\n\nThis made me pause for a moment, but on reflection, is correct.\n\nThe important difference here relative to v1 is that the mining fee for the collateralized contract transaction is deducted from the `Jb` input provided by Bob.\n\n\n>     Unlike the v1 protocol, each CoinSwap party knows a different version of\n>     the contract transactions, so the taker Alice always knows which maker\n>     broadcast a certain set of contract transactions, and so can always ban\n>     the correct fidelity bond.\n\nGreat observation, and an excellent property to have.\n\nWill go think about this more.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Detailed protocol design for routed multi-transaction CoinSwap appendium",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Chris Belcher",
                "ZmnSCPxj"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 40564
        }
    },
    {
        "title": "[bitcoin-dev] Preferential Treatment in AttemptToEvictConnection()",
        "thread_messages": [
            {
                "author": "Mike Brooks",
                "date": "2020-10-03T23:06:19",
                "message_text_only": "Hey Everyone,\n\nA lot of pressure rides on AttemptToEvictConnection() because it is used to\nlimit the impact of eclipsing attacks. With continued centralization, fair\nconnection formation becomes a bigger concern. I am curious how other\nmembers of the community feel about the preferential treatment and odd\ncomments found in AttemptToEvictConnection().  In short, the concern is\nthat an adversary which intends on providing the useful service of\ndata-arbitrage will have preferential treatment in the formation of the\nnetwork.\n\nhttps://github.com/bitcoin/bitcoin/blame/df2129a2349b1877049f250551f49a4592e73765/src/net.cpp#L946-L981\n\nLine 948:\n// An attacker cannot predict which netgroups will be protected\n->\nPerhaps not, but the attacker can have more netgroups than node slots, this\ncan be optimized for. Simply being in different places does not mean the\nnodes are honest or safe. This is probably a good check to have, but it\nshould not say an \"attacker cannot\", as this is misleading.\n\nLine 952:\n// An attacker cannot manipulate this metric without physically moving\nnodes closer to the target.\n ->\nYes, that is exactly what the attacker will do. An attacker can run\ntcp-traceroute on the network to find where miners clump up, and run a\nmalicious message-relay in a nearby datacenter. With a financial motive it\nis cheaper to run a low-cost message relay than a mining node.\n\n\nLine 955:\n// Protect 4 nodes that most recently sent us novel transactions accepted\ninto our mempool. Add recently accepted blocks and txn to\nAttemptToEvictConnection.\n// An attacker cannot manipulate this metric without performing useful work\n.->\nIf an honest node sees an novel transaction from a new incoming connection,\nit will be less likely to remove it. A dishonest centralized-service can\npreemptively send novel-transactions as part of the handshake for new\nhosts, this will improve the odds of the connection staying open and\ncutting contact with an honest node.\n\n\nline 962:\n// Protect 4 nodes that most recently sent us novel blocks.\n// An attacker cannot manipulate this metric without performing useful work.\n->\nThis code has the assumption that an adversary will play by the rules. An\nattacker will manipluate this metric with the data-arbitrage of novel\nblocks. An attacker can move newly created blocks from the source (large\nmining pools) to all parts of the network which can be used to garner value\nwithin the connection pool of new hosts.\n\n\nAll of the above checks, except for the one starting on 948 is subject to a\nrace condition.\n\nAll the best,\nMichael\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201003/c719d565/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Preferential Treatment in AttemptToEvictConnection()",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Mike Brooks"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2742
        }
    },
    {
        "title": "[bitcoin-dev] Is BIP32's chain code needed?",
        "thread_messages": [
            {
                "author": "Lloyd Fournier",
                "date": "2020-10-05T02:49:48",
                "message_text_only": "Hi Leonardo,\n\nI can't tell you what the BIP32 author was thinking but if I put\nmyself in their shoes these are the reasons I might have done it this\nway:\n\n1. Use HMAC rather than normal SHA2 -- this is just best practice for\nkey derivation (even though I don't think it would make a difference\nto security if you are strictly following the spec).\n2. Use 512-bit rather than 256-bit -- Probably something to do with\n(1) -- since I'm using an HMAC I've gotta put something as the key. I\ndon't want re-use the 256-bits for the secp256k1 secret key for this\nsince an integer mod q is not the same as 256 random bits (or I don't\nwant to have to make the argument in the design doc that it actually\nis; plus what if someone starts using this for different curve and I'm\nnot around to tell them no). So I split the 512-bits and use the last\n256bits as the key for the child derivation.\n\nI don't think there is any fundamental flaw with what you suggest (I\nam doing something similar for a project).  I guess the issues you\npointed out with the scheme were probably not on the author's mind. To\nme they don't seem too severe but I haven't spent much time developing\nwallets.\n\nLL\n\nOn Wed, Sep 30, 2020 at 4:02 AM Leonardo Comandini via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Hi all,\n>\n> BIP32 [1] says: \"In order to prevent these from depending solely on the key\n> itself, we extend both private and public keys first with an extra 256 bits of\n> entropy. This extension, called the chain code...\".\n>\n> My argument is that the chain code is not needed.\n> To support such claim, I'll show a schematic of BIP32 operations to be compared\n> with an alternative proposal and discuss the differences.\n>\n> I have two main questions:\n> - Is this claim false?\n> - Has anyone shared this idea before?\n>\n> ## BIP32 schematic\n>\n> Let `G` be the secp256k1 generator.\n> Let `i` be the child index.\n> Let `(p, P=pG)` and `(p_i, P_i=p_iG)` be the parent and i-th child keypairs\n> respectively.\n> Let `c` and `c_i` be the corresponding chain codes.\n> Let `h1, h2, h3, h4` be hash functions so that the formulae below match the\n> definitions given in BIP32 [2].\n> Define private and public child derivation as follow:\n>\n>     p_i(p, c, i) = (i < 2^31)  p + h1(c, pG, i)\n>                    (i >= 2^31) p + h2(c, p, i)\n>\n>     c_i(p, c, i) = (i < 2^31)  h3(c, pG, i)\n>                    (i >= 2^31) h4(c, p, i)\n>\n>     P_i(P, c, i) = (i < 2^31)  P + h1(c, P, i)G\n>                    (i >= 2^31) not possible\n>\n>     c_i(P, c, i) = (i < 2^31)  h3(c, P, i)\n>                    (i >= 2^31) not possible\n>\n> The above formula for unhardened public derivation resembles a pay-to-contract\n> [3] scheme.\n>\n> ## Alternative proposal\n>\n> Let `h` be an adequately strong hash function which converts its output to\n> integer.\n> Consider the following derivation scheme:\n>\n>     p_i(p, i) = (i < 2^31)  p + h(pG, i)\n>                 (i >= 2^31) h(p, i)\n>\n>     P_i(P, i) = (i < 2^31)  P + h(P, i)G\n>                 (i >= 2^31) not possible\n>\n> Which is basically the above one without the chaincode.\n>\n> ## Considerations\n>\n> I claim that this has the same properties as BIP32 [4]:\n> - The problem of finding `p` given `p_i, i` relies on brute-forcing `h` in the\n>   same way the analogous problem relies on brute-forcing `h2` in BIP32.\n> - The problem of determining whether `{p_i, i}_i=1..n` are derived from a common\n>   parent `p` relies on brute-forcing `h` in the same way the analogous problem\n>   relies on brute-forcing `h2` in BIP32.\n> - Given `i < 2^31, p_i, P`, an attacker can find `p`. This is analogous to\n>   BIP32, where the parent extended pubkey is needed (`P, c`). One could argue\n>   that `c` is never published on the blockchain, while `P` may be. On the other\n>   hand most wallets either use hardened derivation (so the attack does not work)\n>   or derive scriptpubkeys from keys at the same depth (so the parent key is\n>   never published on the blockchain).\n>   Anyway, if the parent public key is kept as secret as BIP32 extended keys are,\n>   then the situation is analogous to BIP32's.\n>\n> _If_ these claims are correct, the proposed derivation scheme has two main\n> advantages:\n>\n> 1) Shorter backups for public and private derivable keys\n>\n> Backups are especially relevant for output descriptors. For instance, when using\n> a NofM multisig, each participant must backup M-1 exteneded public keys and its\n> extended private key, which can be included in an output descriptor. Using the\n> proposed derivation reduces the backup size by `~M*32` bytes.\n>\n> 2) User-friendly backup for child keys\n>\n> Most wallets use user-friendly backups, such as BIP39 [5] mnemonics. They map\n> 16-32 bytes of entropy to 12-24 words. However BIP32 exteneded keys are at least\n> 64(65) bytes (key and chain code), so they cannot be mapped back to a\n> mnemonic.\n>\n> A common wallet setup is (`->` one-way derivation, `<->` two-way mapping):\n>\n>     entropy (16-32 bytes) <-> user-friendly backup\n>       -> BIP32 extended key (64-65 bytes)\n>          -> BIP32 extended child keys (64-65 bytes)\n>\n> With the proposed derivation, it would be possible to have:\n>\n>     derivable private key (32 bytes) <-> user-friendly backup\n>       -> derivable public key (33 bytes) <-> user-friendly backup\n>       -> derivable child keys (32-33 bytes) <-> user-friendly backup\n>\n> This would allow having mnemonics for subaccount keys.\n>\n> ## References\n>\n> [1] https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n>\n> [2] h1, h2, h3 and h4 can be defined as follows\n>\n>     Ip(c, p, i) = (i >= 2^31) HMAC-SHA512(c, 0x00 || ser256(p) || ser32(i))\n>                   (i < 2^31)  HMAC-SHA512(c, pG || ser32(i))\n>\n>     IP(c, P, i) = (i >= 2^31) not possible\n>                   (i < 2^31)  HMAC-SHA512(c, P || ser32(i))\n>\n>     h1(c, P, i) = parse256(IP(c, P, i)[:32])\n>     h2(c, p, i) = parse256(Ip(c, p, i)[:32])\n>     h3(c, P, i) = IP(c, P, i)[32:]\n>     h4(c, p, i) = Ip(c, p, i)[32:]\n>\n> [3] https://blockstream.com/sidechains.pdf Appendix A\n>\n> [4] https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#security\n>\n> [5] https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n>\n>\n> --\n> Leonardo\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Christopher Allen",
                "date": "2020-10-05T20:34:48",
                "message_text_only": "Leondardo,\n\nThere are a lot of sub-topics related to your questions that deserve at\nleast some response.\n\nI was not involved deeply in bitcoin when BIPs 32/38/39/44/45 emerged, but\nthey were not without some strong differences of opinion and controversy,\nsome of which are reflected in challenges today. Part of the problem is\nthat bitcoin core itself didn't adopt these for a very long time after the\nvarious wallet companies had them broadly deployed, so I don't believe that\nthese BIPs have quite the rigor that other BIPs have. Plus some entire\nsub-topics are missing like a proposed BIP 48 that describes multisig paths\nfor hardware keys.\n\nI encourage you to look back both on the PRs for those BIPs, and also\narchives of this list. Unfortunately, I don't have a curated list of the\n\"best\" of these \u2014 maybe a project for a future Blockchain Commons intern.\n\nThat being said, one particular focus in your question was on how to you\nturn a master seed into the master key (m/0). Part of the conflict at the\ntime was a number of vendors wanted to avoid the 256 bits of entropy and\nfelt 128 bits were good enough.  A compromise was born of that, that even\ntoday not all agree with. However, the proposed scheme was \"good enough\".\n\nToday, I feel that how a master seed (entropy that has been turned into a\n128 or 256 bit seed and that which is stored in hardware on a\nledger/trezor) is turned into the 512 byte master key for m/0 really needs\nto be preserved, unless someone finds something cryptographically unsafe\nabout it. Why? Interoperability and avoiding vendor lock-in.\n\nAn example of this is the recent proposal from Satoshi Labs for SLIP-39. We\nimplemented it, but discovered that in practice the same seed restored\nthrough BIP39 recovery would result in a different master key than SLIP39\nrecovery. This is because the Trezor team is one of the parties that were\nunhappy with the compromise back in the BIP32 days, and thus they've\ndecided that as long as they are replacing BIP39 they would \"fix\" the\nmethod of creation of the master seed.\n\nSatoshi Labs has some rationale for these changes, but we (Blockchain\nCommons and a small community of airgapped wallet developers), felt that\nthe interoperability and lock-in risks were too high. Once you used SLIP39\nto create accounts, you must stick with SLIP39. This means you can only\nrestore seeds to wallets that support SLIP39, and most have chosen not to.\n\nSo we worked on instead a very closely related specification called SSKR\nthat also does Shamir, but uses the same seed->master key technique that\nBIP32 does. This means that you can restore your SSRK shards back to a\nseed, then move them to another device that only supports BIP39. This\nprevents lock-in into a singular or small subset of wallet vendors. Our\ncurrent research spec is\nhttps://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2020-011-sskr.md\nand reference code for sskr is at\nhttps://github.com/BlockchainCommons/bc-seedtool-cli and we hope to offer\nit as a BIP in future months. There is a small GitHub community discussing\nthis and other emerging airgapped and multisig standards at\nhttps://github.com/BlockchainCommons/Airgapped-Wallet-Community/discussions\n\nThere is a similar problem with seed mnemonics Lightning Labs\nimplementations, which needed to offer metadata in addition to the seed.\nThis means their mnemonics are also incompatible and also have potential\nlock-in and interoperability issues. You can't use their seeds with\nC-Lightining. So we are puzzling through how to meet their needs for\nmetadata (and other parties in the multsig ecosystem were seed storage is\nnot enough and some metadata is needed), yet maximize round-trip\ninteroperability with multiple wallet vendors, and tools for conversion to\nlegacy formats like our seedtool.\n\nSo though at first glance your math seems correct and there are other,\npotentially better ways to derive in a hierarchical fashion additional\nkeys, I'd be worried that it would suffer the interoperability and\npotential lock-in that we are seeing with SLIP-39 and LND.\n\n\u2014 Christopher Allen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201005/8d92b63e/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2020-10-16T21:41:07",
                "message_text_only": "On Tuesday, September 29, 2020 10:34 AM, Leonardo Comandini via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi all,\n>\n> BIP32 [1] says: \"In order to prevent these from depending solely on the key\n> itself, we extend both private and public keys first with an extra 256 bits of\n> entropy. This extension, called the chain code...\".\n>\n> My argument is that the chain code is not needed.\n> To support such claim, I'll show a schematic of BIP32 operations to be compared\n> with an alternative proposal and discuss the differences.\n>\n> I have two main questions:\n> - Is this claim false?\n> - Has anyone shared this idea before?\n\nHi Leonardo,\n\nIt's been a while but I can comment on the history of how the chaincode ended up being in there.\n\nThe most direct reason is that BIP32 was inspired by Alan Reiner's Armory software, which had\na different homomorphic key derivation scheme, but included something called a chaincode to\nenable multiple \"chains\" of keys to be derived from the same keypair. More information about\nthat scheme is here: https://bitcointalk.org/index.php?topic=205999.msg2155696#msg2155696\n\nBIP32 made two improvements to this:\n* Allow efficient random access into the derived keys (Armory's scheme required iterating the\nderivation function to get consecutive subkeys - which is probably where the name \"chain\"\nin chaincode comes from)\n* Permit hierarchical derivation, by also constructing a sub-\"chaincode\" along with every subkey.\n\nIf I recall correctly, there was at least one argument at the time about whether the chaincode was\nnecessary at all. My rationale for keeping it was:\n* xpubs are not as secret as private keys, but they do demand more protection than just public keys\n(for both privacy reasons, and due to the fact that revealing an xpub + child xprv is ReallyBad(tm)).\nFor that reason, it seems nice that an xpub consists of more than just a public key, as revealing\nthe public key in it means the protection above remains. I don't think there is anything fundamental\nhere; just a distinct encoding for xpubs and pubkeys might have accomplished the same, but this\nfelt safer.\n* Repeated hashing \"felt\" dangerous, as it reduces entropy at every step, so it'd go below 256 bits.\nWith a chaincode to maintain extra entropy this is prevented. In retrospect, this is a bogus\nargument, as it's only a relevant point for information-theoretical security (which means we wouldn't\nbe able to use ECC in the first place), and even then, it's only a minimal effect.\n\nSo in short, from a cryptographic point of view, I think that indeed, the chaincode is not needed. It\nprobably has some qualitative advantage in practice, but not very much.\n\nCheers,\n\n--\nPieter\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201016/ebd8144d/attachment.html>"
            },
            {
                "author": "Adam Back",
                "date": "2020-10-17T09:14:59",
                "message_text_only": "Another advantage of random access from BIP 32 vs iterated chain is\nthat if there is a bit-flip or corruption, you don't destroy access to\nall future addresses, but only burn one utxo.  Empirically not an\nentirely theoretical issue.\n\nI think the only thing i'd care about is bloating up the number of\ncharacters to backup, if the codes are all derived it doesn't matter\ntoo much.  I tend to think of 128-bits as enough given that is the\nsecurity target of ECDSA, so long as reasonable key-stretching\nalgorithms are used that don't interact badly with the key use, which\nseems a very reasonable assumption for PBKF2 and ECDSA.\n\nAgree the iterated hashing argument does not seem a practical concern\n- eg BIP 39 uses PBKDF2 uses 2048 iterated hash invocations.  I\nsuppose it's strictly true that as the hash is deterministic and not a\nbijection (not a permutation), there are collisions and if you iterate\nenough unreachable states can be eliminated.  But because the domain\nis so large as to be practically unenumerable it won't creates a brute\nforce short-cut\n\nAdam\n\nOn Sat, 17 Oct 2020 at 01:35, Pieter Wuille via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> On Tuesday, September 29, 2020 10:34 AM, Leonardo Comandini via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Hi all,\n>\n> BIP32 [1] says: \"In order to prevent these from depending solely on the key\n> itself, we extend both private and public keys first with an extra 256 bits of\n> entropy. This extension, called the chain code...\".\n>\n> My argument is that the chain code is not needed.\n> To support such claim, I'll show a schematic of BIP32 operations to be compared\n> with an alternative proposal and discuss the differences.\n>\n> I have two main questions:\n> - Is this claim false?\n> - Has anyone shared this idea before?\n>\n>\n> Hi Leonardo,\n>\n> It's been a while but I can comment on the history of how the chaincode ended up being in there.\n>\n> The most direct reason is that BIP32 was inspired by Alan Reiner's Armory software, which had\n> a different homomorphic key derivation scheme, but included something called a chaincode to\n> enable multiple \"chains\" of keys to be derived from the same keypair. More information about\n> that scheme is here: https://bitcointalk.org/index.php?topic=205999.msg2155696#msg2155696\n>\n> BIP32 made two improvements to this:\n> * Allow efficient random access into the derived keys (Armory's scheme required iterating the\n>   derivation function to get consecutive subkeys - which is probably where the name \"chain\"\n>   in chaincode comes from)\n> * Permit hierarchical derivation, by also constructing a sub-\"chaincode\" along with every subkey.\n>\n> If I recall correctly, there was at least one argument at the time about whether the chaincode was\n> necessary at all. My rationale for keeping it was:\n> * xpubs are not as secret as private keys, but they do demand more protection than just public keys\n>   (for both privacy reasons, and due to the fact that revealing an xpub + child xprv is ReallyBad(tm)).\n>   For that reason, it seems nice that an xpub consists of more than just a public key, as revealing\n>   the public key in it means the protection above remains. I don't think there is anything fundamental\n>   here; just a distinct encoding for xpubs and pubkeys might have accomplished the same, but this\n>   felt safer.\n> * Repeated hashing \"felt\" dangerous, as it reduces entropy at every step, so it'd go below 256 bits.\n>   With a chaincode to maintain extra entropy this is prevented. In retrospect, this is a bogus\n>   argument, as it's only a relevant point for information-theoretical security (which means we wouldn't\n>   be able to use ECC in the first place), and even then, it's only a minimal effect.\n>\n> So in short, from a cryptographic point of view, I think that indeed, the chaincode is not needed. It\n> probably has some qualitative advantage in practice, but not very much.\n>\n> Cheers,\n>\n> --\n> Pieter\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "Is BIP32's chain code needed?",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Adam Back",
                "Pieter Wuille",
                "Lloyd Fournier",
                "Christopher Allen"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 17721
        }
    },
    {
        "title": "[bitcoin-dev] Progress on bech32 for future Segwit Versions (BIP-173)",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2020-10-08T00:21:10",
                "message_text_only": "Hi all,\n\n        I propose an alternative to length restrictions suggested by\nRussell in https://github.com/bitcoin/bips/pull/945: use the\nhttps://gist.github.com/sipa/a9845b37c1b298a7301c33a04090b2eb variant,\nunless the first byte is 0.\n\nHere's a summary of each proposal:\n\nLength restrictions (future segwits must be 10, 13, 16, 20, 23, 26, 29,\n32, 36, or 40 bytes)\n  1. Backwards compatible for v1 etc; old code it still works.\n  2. Restricts future segwit versions, may require new encoding if we\n     want a diff length (or waste chainspace if we need to have a padded\n     version for compat).\n    \nChecksum change based on first byte:\n  1. Backwards incompatible for v1 etc; only succeeds 1 in a billion.\n  2. Weakens guarantees against typos in first two data-part letters to\n     1 in a billion.[1]\n\nI prefer the second because it forces upgrades, since it breaks so\nclearly.  And unfortunately we do need to upgrade, because the length\nextension bug means it's unwise to accept non-v0 addresses.\n\n(Note non-v0 segwit didn't relay before v0.19.0 anyway, so many places\nmay already be restricting to v0 segwit).\n\nThe sooner a decision is reached on this, the sooner we can begin\nupgrading software for a taproot world.\n\nThanks,\nRusty.\nPS. Lightning uses bech32 over longer lengths, but the checksum is less critical; we'd prefer to follow whatever\nbitcoin chooses.\n\n[1] Technically less for non-v0: you have a 1 in 8 chance of a typo in the second letter changing the checksum\n     algorithm, so it's 1 in 8 billion."
            },
            {
                "author": "David A. Harding",
                "date": "2020-10-08T14:59:38",
                "message_text_only": "On Thu, Oct 08, 2020 at 10:51:10AM +1030, Rusty Russell via bitcoin-dev wrote:\n> Hi all,\n> \n>         I propose an alternative to length restrictions suggested by\n> Russell in https://github.com/bitcoin/bips/pull/945 : use the\n> https://gist.github.com/sipa/a9845b37c1b298a7301c33a04090b2eb variant,\n> unless the first byte is 0.\n> \n> Here's a summary of each proposal:\n> \n> Length restrictions (future segwits must be 10, 13, 16, 20, 23, 26, 29,\n> 32, 36, or 40 bytes)\n>   1. Backwards compatible for v1 etc; old code it still works.\n>   2. Restricts future segwit versions, may require new encoding if we\n>      want a diff length (or waste chainspace if we need to have a padded\n>      version for compat).\n>     \n> Checksum change based on first byte:\n>   1. Backwards incompatible for v1 etc; only succeeds 1 in a billion.\n>   2. Weakens guarantees against typos in first two data-part letters to\n>      1 in a billion.[1]\n\nExcellent summary!\n\n> I prefer the second because it forces upgrades, since it breaks so\n> clearly.  And unfortunately we do need to upgrade, because the length\n> extension bug means it's unwise to accept non-v0 addresses.\n\nI don't think the second option forces upgrades.  It just creates\nanother opt-in address format that means we'll spend another several\nyears with every wallet having two address buttons, one for a \"segwit\naddress\" (v0) and one for a \"taproot address\" (v1).  Or maybe three\nbuttons, with the third being a \"taproot-in-a-segwit-address\" (v1\nwitness program using the original bech32 encoding).\n\nIt took a lot of community effort to get widespread support for bech32\naddresses.  Rather than go through that again, I'd prefer we use the\nbackwards compatible proposal from BIPs PR#945 and, if we want to\nmaximize safety, consensus restrict v1 witness program size, e.g. reject\ntransactions with scriptPubKeys paying v1 witness programs that aren't\nexactly 32 bytes.\n\nHopefully by the time we want to use segwit v2, most software will have\nimplemented length limits and so we won't need any additional consensus\nrestrictions from then on forward.\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201008/9c2d4fda/attachment.sig>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2020-10-08T15:21:47",
                "message_text_only": "On Thu, Oct 8, 2020 at 11:00 AM David A. Harding via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Rather than go through that again, I'd prefer we use the\n> backwards compatible proposal from BIPs PR#945 and, if we want to\n> maximize safety, consensus restrict v1 witness program size, e.g. reject\n> transactions with scriptPubKeys paying v1 witness programs that aren't\n> exactly 32 bytes.\n>\n\nAdding some kind of relay policy rule would be easier than a consensus\nrule, and maybe effective enough.  (This comment is not intended to endorse\nany one proposal over another.)\n\n\n> Hopefully by the time we want to use segwit v2, most software will have\n> implemented length limits and so we won't need any additional consensus\n> restrictions from then on forward.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201008/e79a6702/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2020-10-15T01:40:30",
                "message_text_only": "\"David A. Harding\" <dave at dtrt.org> writes:\n> On Thu, Oct 08, 2020 at 10:51:10AM +1030, Rusty Russell via bitcoin-dev wrote:\n>> Hi all,\n>> \n>>         I propose an alternative to length restrictions suggested by\n>> Russell in https://github.com/bitcoin/bips/pull/945 : use the\n>> https://gist.github.com/sipa/a9845b37c1b298a7301c33a04090b2eb variant,\n>> unless the first byte is 0.\n>> \n>> Here's a summary of each proposal:\n>> \n>> Length restrictions (future segwits must be 10, 13, 16, 20, 23, 26, 29,\n>> 32, 36, or 40 bytes)\n>>   1. Backwards compatible for v1 etc; old code it still works.\n>>   2. Restricts future segwit versions, may require new encoding if we\n>>      want a diff length (or waste chainspace if we need to have a padded\n>>      version for compat).\n>>     \n>> Checksum change based on first byte:\n>>   1. Backwards incompatible for v1 etc; only succeeds 1 in a billion.\n>>   2. Weakens guarantees against typos in first two data-part letters to\n>>      1 in a billion.[1]\n>\n> Excellent summary!\n>\n>> I prefer the second because it forces upgrades, since it breaks so\n>> clearly.  And unfortunately we do need to upgrade, because the length\n>> extension bug means it's unwise to accept non-v0 addresses.\n>\n> I don't think the second option forces upgrades.  It just creates\n> another opt-in address format that means we'll spend another several\n> years with every wallet having two address buttons, one for a \"segwit\n> address\" (v0) and one for a \"taproot address\" (v1).  Or maybe three\n> buttons, with the third being a \"taproot-in-a-segwit-address\" (v1\n> witness program using the original bech32 encoding).\n\nIf we go for option 2, v1 (generated from bitcoin core) will simply fail\nthe first time you try test it.  So it will force an upgrade.  There\nare fewer places generating addresses than accepting them, so this\nseems the most likely scenario.\n\nOTOH, with option 1, anyone accepting v1 addresses today is going to\nbecome a liability once v1 addresses start being generated.\n\n> It took a lot of community effort to get widespread support for bech32\n> addresses.  Rather than go through that again, I'd prefer we use the\n> backwards compatible proposal from BIPs PR#945 and, if we want to\n> maximize safety, consensus restrict v1 witness program size, e.g. reject\n> transactions with scriptPubKeys paying v1 witness programs that aren't\n> exactly 32 bytes.\n\nYes, I too wish we weren't here.  :(\n\nDeferring a hard decision is not useful unless we expect things to be\neasier in future, and I only see it getting harder as time passes and\nuserbases grow.\n\nThe good news it that the change is fairly simple and the reference\nimplementations are widely used so change is not actually that hard\nonce the decision is made.\n\n> Hopefully by the time we want to use segwit v2, most software will have\n> implemented length limits and so we won't need any additional consensus\n> restrictions from then on forward.\n\nIf we are prepared to commit to restrictions on future addresses.\n\nWe don't know enough to do that, however, so I'm reluctant; I worry that\na future scheme where we could save (e.g.) 2 bytes will impractical due\nto our encoding restrictions, resulting in unnecessary onchain bloat.\n\nCheers,\nRusty."
            },
            {
                "author": "Pieter Wuille",
                "date": "2020-10-16T21:09:04",
                "message_text_only": "Hi Rusty,\n\nthanks for starting this thread. We definitely should make a decision around\nthis soon.\n\n\nOn Wednesday, October 14, 2020 6:40 PM, Rusty Russell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > > Here's a summary of each proposal:\n> > > Length restrictions (future segwits must be 10, 13, 16, 20, 23, 26, 29,\n> > > 32, 36, or 40 bytes)\n> > >\n> > > 1.  Backwards compatible for v1 etc; old code it still works.\n> > > 2.  Restricts future segwit versions, may require new encoding if we\n> > >     want a diff length (or waste chainspace if we need to have a padded\n> > >     version for compat).\n> > >\n> > > Checksum change based on first byte:\n> > >\n> > > 1.  Backwards incompatible for v1 etc; only succeeds 1 in a billion.\n> > > 2.  Weakens guarantees against typos in first two data-part letters to\n> > >     1 in a billion.[1]\n> > >\n\n> If we go for option 2, v1 (generated from bitcoin core) will simply fail\n> the first time you try test it. So it will force an upgrade. There\n> are fewer places generating addresses than accepting them, so this\n> seems the most likely scenario.\n>\n> OTOH, with option 1, anyone accepting v1 addresses today is going to\n> become a liability once v1 addresses start being generated.\n\nToday, no witness v1 receivers exist. So it seems to me the only question\nis what software/infrastructure exist that supports sending to witness v1,\nand whether they (and their userbase) are more or less likely to upgrade\nbefore receivers appear than those that don't.\n\nClearly if only actively developed software currently supports sending to\nv1 right now, then the question of forward compatibility is moot, and I'd\nagree the cleanliness of option 2 is preferable.\n\nDoes anyone have an up-to-date overview of where to-future-witness sending\nis supported? I know Bitcoin Core does.\n\n> > It took a lot of community effort to get widespread support for bech32\n> > addresses. Rather than go through that again, I'd prefer we use the\n> > backwards compatible proposal from BIPs PR#945 and, if we want to\n> > maximize safety, consensus restrict v1 witness program size, e.g. reject\n> > transactions with scriptPubKeys paying v1 witness programs that aren't\n> > exactly 32 bytes.\n>\n> Yes, I too wish we weren't here. :(\n>\n> Deferring a hard decision is not useful unless we expect things to be\n> easier in future, and I only see it getting harder as time passes and\n> userbases grow.\n\nPossibly, but in the past I think there has existed a pattern where adoption\nof new technology is at least partially based on certain infrastructure\nand codebases going out of business and/or being replaced with newer ones,\nrather than improvements to existing ones.\n\nIf that effect is significant, option 1 may be preferable: it means less\ncompatibility issues in the short term, and longer term all that may be\nrequired is fixing the spec, and waiting long enough for old/unmaintained code\nto be replaced.\n\nAs for how long: new witness version/length combinations are only rarely needed,\nand there are 14 length=32 ones left to pick. We'll likely want to use those\nfirst anyway, as it's the cheapest option with 128-bit collision resistance.\nAssuming future constructions have something like BIP341's leaf versioning, new\nwitness version/length combinations are only required for:\n\n* Changes to the commitment structure of script execution (e.g. Graftroot,\n  different hash function for Merkle trees, ...)\n* Upgrades to new signing cryptography (EC curve change, PQC, ...).\n* Changes to signatures outside of a commitment structure (e.g. new sighash\n  modes for the keypath in BIP341, or cross-input aggregation for them).\n\nand in general, not for things like new script opcodes, or even for fairly\ninvasive redesigns of the script language itself.\n\n> The good news it that the change is fairly simple and the reference\n> implementations are widely used so change is not actually that hard\n> once the decision is made.\n\nIndeed. Whatever observations we had about adoption of base58 -> bech32 may not\napply because the change to a different checksum is fairly trivial compared to\nthat. Still, presence of production codebases that just don't update at all\nmay complicate this.\n\n> > Hopefully by the time we want to use segwit v2, most software will have\n> > implemented length limits and so we won't need any additional consensus\n> > restrictions from then on forward.\n>\n> If we are prepared to commit to restrictions on future addresses.\n>\n> We don't know enough to do that, however, so I'm reluctant; I worry that\n> a future scheme where we could save (e.g.) 2 bytes will impractical due\n> to our encoding restrictions, resulting in unnecessary onchain bloat.\n\nI'm opposed to consensus-invalidating certain length/version combinations, if\nthat's what you're suggesting, and I don't think there is a need for it.\n\nTL;DR: what codebases/services/infrastructure exists today that supports\nsending to witness v1 BIP173 addresses?\n\nCheers,\n\n--\nPieter"
            },
            {
                "author": "Rusty Russell",
                "date": "2020-10-19T00:49:17",
                "message_text_only": "Pieter Wuille <bitcoin-dev at wuille.net> writes:\n> Today, no witness v1 receivers exist. So it seems to me the only question\n> is what software/infrastructure exist that supports sending to witness v1,\n> and whether they (and their userbase) are more or less likely to upgrade\n> before receivers appear than those that don't.\n>\n> Clearly if only actively developed software currently supports sending to\n> v1 right now, then the question of forward compatibility is moot, and I'd\n> agree the cleanliness of option 2 is preferable.\n\nIf software supports v1 today and doesn't get upgraded, and we persue\noption 1 then a trailing typo can make trouble.  Not directly lose money\n(since the tx won't get propagated), but for most systems (e.g. hosted\nwallets) someone has to go in and figure out the error and fix it up.\n\nOption 2 means they're likely to fix their systems the first time\nsomeone tries a v1 send, not the first time someone makes a trailing\ntypo (which might be years).\n\n> Does anyone have an up-to-date overview of where to-future-witness sending\n> is supported? I know Bitcoin Core does.\n\nAnecdata: c-lightning doesn't allow withdraw to segwit > 0.  It seems\nthat the contributor John Barboza (CC'd) assumed that future versions\nshould be invalid:\n\n\tif (bip173) {\n\t\tbool witness_ok = false;\n\t\tif (witness_version == 0 && (witness_program_len == 20 ||\n\t\t\t\t\t     witness_program_len == 32)) {\n\t\t\twitness_ok = true;\n\t\t}\n\t\t/* Insert other witness versions here. */\n\n>> Deferring a hard decision is not useful unless we expect things to be\n>> easier in future, and I only see it getting harder as time passes and\n>> userbases grow.\n>\n> Possibly, but in the past I think there has existed a pattern where adoption\n> of new technology is at least partially based on certain infrastructure\n> and codebases going out of business and/or being replaced with newer ones,\n> rather than improvements to existing ones.\n>\n> If that effect is significant, option 1 may be preferable: it means less\n> compatibility issues in the short term, and longer term all that may be\n> required is fixing the spec, and waiting long enough for old/unmaintained code\n> to be replaced.\n\nHmm, I'd rather cleanly break zombie infra, since they're exactly the\nkind that won't/cant fix the case where someone trailing-typos?\n\n> As for how long: new witness version/length combinations are only rarely needed,\n> and there are 14 length=32 ones left to pick. We'll likely want to use those\n> first anyway, as it's the cheapest option with 128-bit collision resistance.\n> Assuming future constructions have something like BIP341's leaf versioning, new\n> witness version/length combinations are only required for:\n>\n> * Changes to the commitment structure of script execution (e.g. Graftroot,\n>   different hash function for Merkle trees, ...)\n> * Upgrades to new signing cryptography (EC curve change, PQC, ...).\n> * Changes to signatures outside of a commitment structure (e.g. new sighash\n>   modes for the keypath in BIP341, or cross-input aggregation for them).\n>\n> and in general, not for things like new script opcodes, or even for fairly\n> invasive redesigns of the script language itself.\n\nHmm, good point.  These can all be done with version bumps.\n\nThe only use for extra bytes I can see is per-UTXO flags, but even then\nI can't see why you'd need to know them until their spent (in which case\nyou stash the flag in the input, not the output).\n\nAnd fewer bytes seems bad for fungibility, since multisig would be\ndangerous.\n\nBut the future keeps surprising me, so I'm still hesitant.\n\n>> The good news it that the change is fairly simple and the reference\n>> implementations are widely used so change is not actually that hard\n>> once the decision is made.\n>\n> Indeed. Whatever observations we had about adoption of base58 -> bech32 may not\n> apply because the change to a different checksum is fairly trivial compared to\n> that. Still, presence of production codebases that just don't update at all\n> may complicate this.\n>\n>> > Hopefully by the time we want to use segwit v2, most software will have\n>> > implemented length limits and so we won't need any additional consensus\n>> > restrictions from then on forward.\n>>\n>> If we are prepared to commit to restrictions on future addresses.\n>>\n>> We don't know enough to do that, however, so I'm reluctant; I worry that\n>> a future scheme where we could save (e.g.) 2 bytes will impractical due\n>> to our encoding restrictions, resulting in unnecessary onchain bloat.\n>\n> I'm opposed to consensus-invalidating certain length/version combinations, if\n> that's what you're suggesting, and I don't think there is a need for it.\n\nThis *seems* to leave the option of later removing size restrictions,\nbut I think this is an illusion.  Upgrading will only get harder over\ntime: we would instead opt for some kind of backward compatiblity hack\n(i.e. 33 byte address, but you can optionally add 3 zero pad bytes)\nwhich *will* have consensus effect.\n\n> TL;DR: what codebases/services/infrastructure exists today that supports\n> sending to witness v1 BIP173 addresses?\n\nOK, time to waste some money!\n\nCan you provide a mainnet v1 address, and I'll try to spam it from as\nmany things as I can find.  If we're really lucky, you can collect it\npost-fork and donate it to charity.  Or a miner can steal it pre-fork :)\n\nThanks!\nRusty."
            },
            {
                "author": "Pieter Wuille",
                "date": "2020-10-19T22:55:50",
                "message_text_only": "On Sunday, October 18, 2020 5:49 PM, Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n> Pieter Wuille bitcoin-dev at wuille.net writes:\n>\n> > Today, no witness v1 receivers exist. So it seems to me the only question\n> > is what software/infrastructure exist that supports sending to witness v1,\n> > and whether they (and their userbase) are more or less likely to upgrade\n> > before receivers appear than those that don't.\n> > Clearly if only actively developed software currently supports sending to\n> > v1 right now, then the question of forward compatibility is moot, and I'd\n> > agree the cleanliness of option 2 is preferable.\n>\n> If software supports v1 today and doesn't get upgraded, and we persue\n> option 1 then a trailing typo can make trouble. Not directly lose money\n> (since the tx won't get propagated), but for most systems (e.g. hosted\n> wallets) someone has to go in and figure out the error and fix it up.\n\nIt depends. As is, they'd be relayed even as sending to future witness versions\nor lengths is standard. If option 1 is chosen there may be reasons to add\nsafeguards using relay policy, though.\n\n> Option 2 means they're likely to fix their systems the first time\n> someone tries a v1 send, not the first time someone makes a trailing\n> typo (which might be years).\n\nPossibly, but it's also possible that it won't get fixed at all, and instead\nreceiver software just has to wait a few years longer before being able to start\ngiving out v1 addresses and have a reasonable chance the sender supports it.\n\nYou're right though that protecting old sender software from being protected\nagainst the insertion bug is a good argument in favor of Option 2.\n\nStrictly speaking it also has an issue, as the error detection properties aren't\nguaranteed for new-scheme-address + intended-detected-error interpreted as\nold-scheme-address (in particular, you can make 4 substitution errors in\na new-scheme address and have it be a valid old-scheme address). This is much\nless of an issue than the insertion bug that remains present with Option 1 in\nold senders.\n\n> > As for how long: new witness version/length combinations are only rarely needed,\n> > and there are 14 length=32 ones left to pick. We'll likely want to use those\n> > first anyway, as it's the cheapest option with 128-bit collision resistance.\n> > Assuming future constructions have something like BIP341's leaf versioning, new\n> > witness version/length combinations are only required for:\n> >\n> > -   Changes to the commitment structure of script execution (e.g. Graftroot,\n> >     different hash function for Merkle trees, ...)\n> >\n> > -   Upgrades to new signing cryptography (EC curve change, PQC, ...).\n> > -   Changes to signatures outside of a commitment structure (e.g. new sighash\n> >     modes for the keypath in BIP341, or cross-input aggregation for them).\n> >\n> >\n> > and in general, not for things like new script opcodes, or even for fairly\n> > invasive redesigns of the script language itself.\n>\n> Hmm, good point. These can all be done with version bumps.\n>\n> The only use for extra bytes I can see is per-UTXO flags, but even then\n> I can't see why you'd need to know them until their spent (in which case\n> you stash the flag in the input, not the output).\n>\n> And fewer bytes seems bad for fungibility, since multisig would be\n> dangerous.\n>\n> But the future keeps surprising me, so I'm still hesitant.\n\nOf course, our thinking here may change significantly over time - still, I expect\nit'll be years before something other than 32-byte addresses is desired.\n\n> > TL;DR: what codebases/services/infrastructure exists today that supports\n> > sending to witness v1 BIP173 addresses?\n>\n> OK, time to waste some money!\n>\n> Can you provide a mainnet v1 address, and I'll try to spam it from as\n> many things as I can find. If we're really lucky, you can collect it\n> post-fork and donate it to charity. Or a miner can steal it pre-fork :)\n\nHere is a BIP341 witness v1 address, corresponding to just the generator as\ninner public key (using TapTweak(pubkey) as tweak, as suggested by the BIP):\n\nbc1pmfr3p9 YOU j00pfxjh WILL 0zmgp99y8zf LOSE tmd3s5pmedqhy MONEY ptwy6lm87hf5ss52r5n8\n\n\nCheers,\n\n--\nPieter"
            },
            {
                "author": "Rusty Russell",
                "date": "2020-10-20T00:42:06",
                "message_text_only": "Pieter Wuille <bitcoin-dev at wuille.net> writes:\n> Here is a BIP341 witness v1 address, corresponding to just the generator as\n> inner public key (using TapTweak(pubkey) as tweak, as suggested by the BIP):\n>\n> bc1pmfr3p9 YOU j00pfxjh WILL 0zmgp99y8zf LOSE tmd3s5pmedqhy MONEY ptwy6lm87hf5ss52r5n8\n\nHere are my initial results:\n\nRejects\n-------\n\nc-lightning: \"Could not parse destination address, destination should be a valid address\"\nPhoenix: \"Invalid data.  Please try again.\"\n\nAccepts\n-------\nGreen: ef1662fd2eb736612afb1b60e3efabfdf700b1c4822733d9dbe1bfee607a5b9b\nblockchain.info: 64b0fcb22d57b3c920fee1a97b9facec5b128d9c895a49c7d321292fb4156c21\n\nWill keep exploring (and others are welcome to try too!)\n\nCheers,\nRusty."
            },
            {
                "author": "Rusty Russell",
                "date": "2020-10-20T03:31:45",
                "message_text_only": "Rusty Russell <rusty at rustcorp.com.au> writes:\n> Accepts\n> -------\n> Green: ef1662fd2eb736612afb1b60e3efabfdf700b1c4822733d9dbe1bfee607a5b9b\n> blockchain.info: 64b0fcb22d57b3c920fee1a97b9facec5b128d9c895a49c7d321292fb4156c21\n\nPEBKAC.  Pasted wrong address.  Here are correct results:\n\nRejects\n-------\nc-lightning: \"Could not parse destination address, destination should be a valid address\"\nPhoenix: \"Invalid data.  Please try again.\"\nblockchain.info: \"Your Bitcoin transaction failed to send. Please try again.\"\n\nAccepts\n-------\nGreen: 9e4ab6617a2983439181a304f0b4647b63f51af08fdd84b0676221beb71a8f21\n\nCheers,\nRusty."
            },
            {
                "author": "Riccardo Casatta",
                "date": "2020-10-20T09:21:43",
                "message_text_only": "Here is a mainnet tx done with aqua wallet, which is based on rust-bitcoin\nhttps://blockstream.info/tx/b48a59fa9e036e997ba733904f631b1a64f5274be646698e49fd542141ca9404?expand\n\nI am not sure about the scriptpubkey starting with 51 so I opened this\nhttps://github.com/rust-bitcoin/rust-bitcoin/pull/504\n\n\nIl giorno mar 20 ott 2020 alle ore 05:32 Rusty Russell via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> ha scritto:\n>\n> Rusty Russell <rusty at rustcorp.com.au> writes:\n> > Accepts\n> > -------\n> > Green: ef1662fd2eb736612afb1b60e3efabfdf700b1c4822733d9dbe1bfee607a5b9b\n> > blockchain.info:\n64b0fcb22d57b3c920fee1a97b9facec5b128d9c895a49c7d321292fb4156c21\n>\n> PEBKAC.  Pasted wrong address.  Here are correct results:\n>\n> Rejects\n> -------\n> c-lightning: \"Could not parse destination address, destination should be\na valid address\"\n> Phoenix: \"Invalid data.  Please try again.\"\n> blockchain.info: \"Your Bitcoin transaction failed to send. Please try\nagain.\"\n>\n> Accepts\n> -------\n> Green: 9e4ab6617a2983439181a304f0b4647b63f51af08fdd84b0676221beb71a8f21\n>\n> Cheers,\n> Rusty.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n\n\n--\nRiccardo Casatta - @RCasatta\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201020/2e59c55b/attachment.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2020-10-20T10:29:52",
                "message_text_only": "On Tue, Oct 20, 2020 at 11:12:06AM +1030, Rusty Russell wrote:\n> Here are my initial results:\n\nA while ago, around the Bitcoin Core 0.19.0 release that enabled\nrelaying v1+ segwit addresses, Mike Schmidt was working on the Optech\nCompatibility Matrix[1] and tested a variety of software and services\nwith a v1 address using the original BIP341 specification (33 byte\npubkeys; we now use 32 byte keys).  Here's a summary of his results,\nposted with his permission:\n\n- abra: Bech32 not supported.\n\n- binance: Does not pass front end javascript validation\n\n- bitgo: Error occurs during sending process, after validation.\n\n- bitmex: Bech32 not supported.\n\n- bitrefill: Address does not pass validation.\n\n- bitstamp: Address text input doesn\u2019t allow bech32 addresses due to\n  character limits.\n\n- blockchain.info: Error occurs during sending process, after\n  validation.\n\n- brd: Allows sending workflow to complete in the UI. Transaction stays\n  as pending in the transaction list.\n\n- casa: Fails on signing attempt.\n\n- coinbase: Fails address validation client side in the UI.\n\n- conio: Server error 500 while attemping to send.\n\n- copay: Allows v1 address to be entered in the UI. Fails during\n  broadcast.\n\n- edge: Allows sending workflow to complete. Transaction stays in\n  pending state. Appears to causes issues with the balance calculation\n  as well as ability to send subsequent transactions.\n\n- electrum: Error message during broadcasting of transaction.\n\n- green: Fails on validation of the address.\n\n- jaxx: Fails on validation of the address.\n\n- ledger live: Fails when transaction is sent to the hardwave device for\n  signing.\n\n- mycelium: Fails during address validation.\n\n- purse: Transaction can be created and broadcast, relayed by peers\n  compatible with Bitcoin Core v0.19.0.1 or above.\n\n- river: Transaction can be created and broadcast, relayed by peers\n  compatible with Bitcoin Core v0.19.0.1 or above.\n\n- samourai: Fails on broadcast of transaction to the network.\n\n- trezor: Fails on validation of the address.\n\n- wasabi: Fails on validation of the address.\n\n- xapo: Xapo allows users to create segwit v1 transactions in the UI.\n  However, the transaction gets stuck as pending for an indeterminate\n  period of time\n\nI would guess that some of the failures / stuck transactions might now\nbe successes if the backend infrastructure has upgraded to Bitcoin Core\n>= 0.19.\n\n-Dave\n\n[1] https://bitcoinops.org/en/compatibility/\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201020/e35b6eb1/attachment.sig>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2020-10-20T20:12:25",
                "message_text_only": "On Tuesday, October 20, 2020 3:29 AM, David A. Harding <dave at dtrt.org> wrote:\n\n\n> I would guess that some of the failures / stuck transactions might now be successes if the backend infrastructure has upgraded to Bitcoin Core > = 0.19.\n\nYeah, it would be good to re-test them since a ~year has passed since the 0.19.0 release.\n\nCheers,\n\n--\nPieter"
            },
            {
                "author": "Mike Schmidt",
                "date": "2020-10-20T23:52:07",
                "message_text_only": "I am happy to re-test the services Harding listed previously for v1 send\nsupport next week.\n\nSuggestions of additional services that would be valuable to test are\nwelcome as well.\n\nMike\n\n\nOn Tue, Oct 20, 2020 at 3:38 PM Pieter Wuille via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Tuesday, October 20, 2020 3:29 AM, David A. Harding <dave at dtrt.org>\n> wrote:\n>\n>\n> > I would guess that some of the failures / stuck transactions might now\n> be successes if the backend infrastructure has upgraded to Bitcoin Core > =\n> 0.19.\n>\n> Yeah, it would be good to re-test them since a ~year has passed since the\n> 0.19.0 release.\n>\n> Cheers,\n>\n> --\n> Pieter\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201020/a59ef2b0/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2020-10-21T04:51:34",
                "message_text_only": "Mike Schmidt via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nwrites:\n> I am happy to re-test the services Harding listed previously for v1 send\n> support next week.\n>\n> Suggestions of additional services that would be valuable to test are\n> welcome as well.\n\nThanks!  I am a little disappointed that I won't get to ask Bitcoin\nTwitter to send tips to Pieter[1] though...\n\nI would like to hear from the services who currently support v1+ (who\nthus *would* have to change their software) whether they have a\ntechnical preference for option 1 or 2.\n\nCheers,\nRusty.\n[1] Or just maybe, tips to some random miner..."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-10-21T03:05:35",
                "message_text_only": "> Anecdata: c-lightning doesn't allow withdraw to segwit > 0. It seems\n> that the contributor John Barboza (CC'd) assumed that future versions\n> should be invalid:\n>\n> if (bip173) {\n> bool witness_ok = false;\n> if (witness_version == 0 && (witness_program_len == 20 ||\n> witness_program_len == 32)) {\n> witness_ok = true;\n> }\n> /* Insert other witness versions here. */\n\nI believe this is actually my code, which was later refactored by John Barboza when we were standardizing the `param` system.\n\nThis was intended only as a simple precaution against creating non-standard transaction, and not an assumption that future versions should be invalid.\nThe intent is that further `else if` branches would be added for newer witness versions and whatever length restrictions they may have, as the `/* Insert other witness versions here.  */` comment implies.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Rusty Russell",
                "date": "2020-10-21T04:39:32",
                "message_text_only": "ZmnSCPxj <ZmnSCPxj at protonmail.com> writes:\n> I believe this is actually my code, which was later refactored by John Barboza when we were standardizing the `param` system.\n\nAh, sorry!\n\n> This was intended only as a simple precaution against creating non-standard transaction, and not an assumption that future versions should be invalid.\n> The intent is that further `else if` branches would be added for newer witness versions and whatever length restrictions they may have, as the `/* Insert other witness versions here.  */` comment implies.\n\nYes, I mentioned it here because I've found this to be a common\nmisconception; the *idea* was that application's segwit code would not\nhave to be reworked for future upgrades, but that information propagated\npoorly.\n\n(Just as well, because of overly strict standardness rules, the overflow\nbug, and now the proposed validation changes, turns out this lack of\nforward compat is a feature!)\n\nThanks!\nRusty."
            },
            {
                "author": "Pieter Wuille",
                "date": "2020-10-28T00:20:40",
                "message_text_only": "On Wednesday, October 7, 2020 5:21 PM, Rusty Russell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I propose an alternative to length restrictions suggested by\n> Russell in https://github.com/bitcoin/bips/pull/945: use the\n> https://gist.github.com/sipa/a9845b37c1b298a7301c33a04090b2eb variant,\n> unless the first byte is 0.\n\nHi all,\n\nstarting a slight side-thread here.\n\nThe discussion here made me realize that as we're introducing (at some point) a new checksum scheme, we don't just care about the new scheme's own error detection capabilities, but also about the probability that a new style address + errors is incorrectly accepted as an old style address.\n\n\nClearly these properties are less of a priority than just the new-style + error being misinterpreted as a new-style address, as problems will only occur when entering a new address with errors in old software that supports the old scheme (which this thread shows, is not very common). Still, all other things being equal, it can't hurt to see if some choices are better than others.\n\nhttps://gist.github.com/sipa/a9845b37c1b298a7301c33a04090b2eb suggested the use of constant M = 0x3FFFFFFF. It turns out this is slightly suboptimal in two ways:\n\n* It's possible to take a new-style address with that constant, make 3 substitution errors, and obtain an old-style address.\n* If a new-style address ends with '7', inserting 'g78u' just before it will result in a valid old-style address (ignoring length constraints).\n\nI don't think either of these is serious, but it's possible to improve upon them:\n\n* Guaranteeing that 4 substitution errors are always detected while switching schemes seems impossible, but a constant can be picked that guarantees 3 errors always are.\n* Insertion/deletion errors can be restricted to patterns that require 6 fixed characters (which, assuming uniformly random characters, implies a probability of 2^-30).\n\nIt seems M=0x3ffeffff has both these properties.\n\nI'm going to do some more analysis (swapping, and insertion/erasure near the start), and then update my gist, but so far it seems this is a strictly (albeit only slightly) better choice.\n\nCheers,\n\n--\nPieter"
            }
        ],
        "thread_summary": {
            "title": "Progress on bech32 for future Segwit Versions (BIP-173)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Rusty Russell",
                "David A. Harding",
                "Riccardo Casatta",
                "Russell O'Connor",
                "ZmnSCPxj",
                "Mike Schmidt",
                "Pieter Wuille"
            ],
            "messages_count": 17,
            "total_messages_chars_count": 34189
        }
    },
    {
        "title": "[bitcoin-dev] Progress on Miner Withholding - FPNC",
        "thread_messages": [
            {
                "author": "Mike Brooks",
                "date": "2020-10-08T04:04:08",
                "message_text_only": "Hello Everyone,\n\nBelow is a novel discussion on block-withholding attacks and FPNC. These\nare two very simple changes being proposed here that will\ndramatically impact the network for the better.\n\nBut first of all, I'd like to say that the idea for FPNC came out of a\nconversation with ZmnSCPxj's in regards to re-org stability.  When I had\nproposed blockchain pointers with the PubRef opcode, he took the time to\nexplain to me concerns around re-orgs and why it is a bigger problem than I\ninitially had thought \u2014 and I greatly appreciate this detail.   After\ntouching base with ZmnSCPxj and Greg Maxwell there is an overwhelming view\nthat the current problems that face the network outweigh any theoretical\nones.\n\nCurrently the elephant in the room is the miner withholding attack. There\nis an unintended incentive to hold onto blocks because keeping knowledge of\nthis coinbase private gives a greedy miner more time to calculate the next\nblock.  Major mining pools are actively employing this strategy because\nwinning two blocks in a row has a much greater payoff than common robbery.\nThis unfair advantage happens each time a new block is found, and provides\na kind of home-field advantage for large pools, and contributes to a more\ncentralized network. This odd feature of the bitcoin protocol provides a\nmaterial incentive to delay transactions and encourages the formation of\ndisagreements. In a sense, withholding is a deception of the computational\npower of a miner, and by extension a deception of their influence within\nthe electorate.  In effect, other miners are forced to work harder, and\nwhen they are successful in finding a 2nd solution of the same height \u2014 no\none benefits. Disagreement on the bitcoin network is not good for the\nenvironment, or for the users, or for honest miners, but is ideal for\ndishonest miners looking for an advantage.\n\nCurrently, there is no way to resolve disagreements of the same block\nheight in Bitcoin protocol.  Floating-point Nakamoto Consensus (\nhttps://github.com/in-st/Floating-Point-Nakamoto-Consensus/blob/master/Floating-Point%20Nakamoto%20Consensus.pdf)\naddress ambiguity in the consensus formation process so that disagreements\ncan be empirically resolved without wasted effort. With FPNC every block\nhas a non-zero element which provides the basis for a floating-point\nfitness value. Nodes are already incentivised to choose the solution that\nrepresents the most amount of work, FPNC allows for this same calculation\nto happen for two solutions of the same height. With FPNC the higher\nfitness-value carries forward, and all children of this higher value block\nwill be stronger from having a higher fitness value, this is to make sure\nthat  winning blocks stay as the winner.  If a rogue client chooses to mine\na low value disagreement, they will have to make-up the difference in\nfitness score with their next solution \u2014 This is the genetic\nalgorithm supported by FPNC which ensures that the child blocks from a\nloser will also be losers.\n\nUsing FPNC as a method of disagreement resolution enables two features that\nprovide better incentives over \"first seen.\" For one,  FPNC introduces risk\ninto holding onto low-value solutions, which de-incentivises 1/2 of all\nwithholding attacks.  Additionally, FPNC can be used to increase the rate\nof block formation which will reduce the amount of time that a miner can\nhold onto private blocks.\n\nWith FPNC, a node will only accept the highest-value chain.  With the added\nthreat of another miner finding a higher-FPNC value solution, any\nunscrupulous miner who has mined a low-value block (less than 50% value) is\ngreatly incentives to broadcast out this block before a more valuable\nsolution is found.  It is important to note that replacing a low-FPNC value\nblock is more expensive than simply finding a new block, so even if the\nlowest value is broadcast it is the winner, until proven otherwise.  These\ngreedy miners are holding onto 100% of solution blocks - but FPNC creates a\nclass of block that isn't incentivised on holding. The threat of being\nreplaced by a fair disagreement-resolution process, keeps all miners honest.\n\nWith 1/2 of the blocks being withheld, and 1/2 not being\nbroadcast immediately, you could eventually identify malicious miners based\non this timing difference. With the current system it isn't as clear, but\nwith a split incentive you the network can observe unfair treatment of\nhigh-valued blocks.  FPNC makes the silent process of withholding into one\nthat must show a value-bias, and this unethical behavior can be\nobserved and acted upon.\n\nThe question that is on everyone's mind: Does FPNC create new bad\nincentives? No, it only limits the bad incentives that already exist in the\nprotocol.\n->\nAny miner holding onto a high FPNC-value block would have a slight\nadvantage only for the immediate next block.  The hopes of generating\nfuture blocks and armed with a slight advantage, would need at-least 50%\nprocessing power to maintain. At-least 50% is needed because the miners on\nthe private chain would have out-race the network as a whole.  This means\nthat getting three in a row is time boxed with FPNC.  Whereas \"first seen\"\ngives dishonesty a home-field advantage every time.\n\nThe bitcoin protocol uses a mining difficulty that depends on a\nzero-prefix. As a result, this difficulty function consists of discrete\njumps that grow exponentially, and there are some very good reasons not to\nrely on this construct.   Instead of zeros, a range of floating-point\nvalues, or fractional parts of whole numbers can be used as the difficulty\ncut-off, where any solution more difficult than the cut-off is still\naccepted. Because the proof-of-work is no longer dependent on an arbitrary\n0, moving to an floating-point value range would allow block-formation to\nbe on an arbitrary time-schedule, which could be made slower or faster.\nThe amount of time that a block can be withheld is proportional to the\namount of time it takes to generate,  therefore a faster block formation\ntime inturn limits the amount of time that a block can be withheld.   If\nblock formation is on average 30 seconds to 1 minute, then the amount of\ntime a miner can impact the network is capped at seconds instead of\nminutes.   Although it doesn't stop withholding attacks, speeding up the\ndramatically limits the amount of time that any attacker can withhold a\nblock, thus mitigating the impact of malignant miners.  Speeding up block\nformation time while keeping inflation targets the same adds value to users\nof the network.\n\nCurrently on the BItcoin network, any malicious miner performing a\nwithholding attack does not need to be at the mercy of network conditions,\nand would be more successful if they preemptively spread their delayed\nsolution. With an artificially-increased connection capacity a node can\ngain a visibility advantage on the bitcoin network.  When this greedy miner\nsees that a competing miner has released a block \u2014 then the greedy miner\ncan pre-empt the spread of their delayed solution and beat out any honest\nsolution.  A miner using pre-emption to artificially spread their side of\nthe consensus can ensure the adoption of their block because honest miners\nare dependent on natural topography of the network to spread their messages\n\u2014 a topography which is not optimized for speed. It isn't that the attacker\nis all powerful, it is that p2p networks have an inherent higher-latency\nthan centralized systems.  A miner can have a pre-computed map of the\nbitcoin network and then reach out and inform each node of the delayed\nblock before the honest block has a chance to arrive.  Thus shaping the\ndisagreement in the favor of the malicious miner.  So long as a malicious\nminer has sufficient visibility, they unlock a luxury of\nsubjecating would-be dissent and guaranteeing that their solution is the\none that always wins.\n\nAn attacker cannot choose their FPNC fitness value, but they can choose\nwhen their block arrives and to whom. The \"first seen\" approach to block\nadoption pressures malicious miners into a race of message propagation that\nconvinces undecided nodes to work for the dishonest chain. The\nrace-condition in block arrival is fundamentally resolved because the order\nin which blocks arrive doesn't influence the block's FPNC value. Therefore\nhaving clear disagreement resolution with FPNC removes a feature of the\nnetwork that can be leveraged to make sure that a block-withholding attack\nsupplants honest blocks.\n\nBy clarifying the rules in which blocks will be replaced  \u2014 fewer\ndisagreements will form. Without having a form of disagreement resolution\nand leaving the process up to time, then nodes can be deputized by\nmalicious miners and aid in the mining of withheld blocks.\n\nAll the best,\n-Michael\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201007/98ade96a/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2020-10-08T00:12:47",
                "message_text_only": "On Wednesday, October 7, 2020 1:31 PM, Mike Brooks via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> But first of all, I'd like to say that the idea for FPNC came out of a conversation with ZmnSCPxj's in regards to re-org stability. When I had proposed blockchain pointers with the PubRef opcode, he took the time to explain to me concerns around re-orgs and why it is a bigger problem than I initially had thought \u2014 and I greatly appreciate this detail. After touching base with ZmnSCPxj and Greg Maxwell there is an overwhelming view that the current problems that face the network outweigh any theoretical ones.\n\nGreg Maxwell isn't on this list, but assuming this is about the conversion you've had on Bitcoin Core's security disclosure list, I believe this is a misrepresentation. The discussion has been mostly around a DoS attack report which turned out to be a mistake.\n\nCheers,\n\n--\nPieter\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201008/25f3733d/attachment.html>"
            },
            {
                "author": "Mike Brooks",
                "date": "2020-10-09T00:16:40",
                "message_text_only": "Pieter,\n\nYou are correct.\n\nAnd also, I did prove what I set out to prove. The code provided privately\nto the security team will in fact consume 99% of the CPU, which means it\ndoes have an effect on the electorate.  It is true the node still\nstubbornly passes messages, but I would argue that this is still very much\na problem that would concern operators, and perhaps the threshold for a\npatch is much too high.  A layered security system like what is found in\nbitcoin necessitates an attack chain.  The `getdata` message is an implicit\ninformation disclosure that allows for the identification of dissenting\nnodes.   As ZmnSCPxj pointed out, block mixing will give preemption at most\n67% of the network, and the remaining dissenting nodes can be quelled by\nmaxing out their processing power.  All of this can be used together to\nmake sure that a withheld block becomes the prevailing solution.\n\nFPNC rebalances incentives to serve the interests of the network, and\nfundamentally resolves a class of abuses that reshape the electorate.  FPNC\nwill produce a more deceliterized and fair network than \"first seen.\"\n\nCheers,\nMike\n\nOn Wed, Oct 7, 2020 at 5:12 PM Pieter Wuille <bitcoin-dev at wuille.net> wrote:\n\n> On Wednesday, October 7, 2020 1:31 PM, Mike Brooks via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> But first of all, I'd like to say that the idea for FPNC came out of a\n> conversation with ZmnSCPxj's in regards to re-org stability.  When I had\n> proposed blockchain pointers with the PubRef opcode, he took the time to\n> explain to me concerns around re-orgs and why it is a bigger problem than I\n> initially had thought \u2014 and I greatly appreciate this detail.   After\n> touching base with ZmnSCPxj and Greg Maxwell there is an overwhelming view\n> that the current problems that face the network outweigh any theoretical\n> ones.\n>\n>\n> Greg Maxwell isn't on this list, but assuming this is about the conversion\n> you've had on Bitcoin Core's security disclosure list, I believe this is a\n> misrepresentation. The discussion has been mostly around a DoS attack\n> report which turned out to be a mistake.\n>\n> Cheers,\n>\n> --\n> Pieter\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201008/2296c46d/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-10-08T01:39:45",
                "message_text_only": "Good morning all,\n\n>\n> Below is a novel discussion\u00a0on block-withholding\u00a0attacks and FPNC. These are\u00a0two very simple changes being proposed here that will dramatically\u00a0impact the network for the better.\n>\n> But first of all, I'd like to say that the idea for FPNC came out of a conversation\u00a0with ZmnSCPxj's in regards to\u00a0re-org stability.\u00a0 When I had proposed blockchain pointers with the PubRef opcode, he took the time to explain to me concerns around re-orgs and why it is a bigger problem than I initially had thought\u00a0\u2014 and I greatly appreciate this detail.\u00a0 \u00a0After touching base with ZmnSCPxj and Greg Maxwell there is an overwhelming view that the current problems that face the network outweigh any theoretical ones.\n>\n> Currently the elephant in the room is the miner withholding attack.\u00a0There is an unintended incentive to hold onto blocks because keeping knowledge of this coinbase private gives a greedy miner more time to calculate the next block.\u00a0 Major mining pools are actively employing this strategy because winning two blocks in a row has a much greater payoff than common robbery. This unfair advantage\u00a0happens each time a\u00a0new block is found, and provides a kind of home-field advantage for large pools, and contributes to a more centralized network. This odd feature of the bitcoin protocol provides a material incentive to delay transactions and encourages the formation of disagreements. In a sense, withholding is a deception of the computational power of a miner, and by extension a deception of their influence within the electorate.\u00a0 In effect, other miners are forced to work harder,\u00a0and when they are successful in finding a 2nd solution of the same height\u00a0\u2014 no one benefits. Disagreement on the bitcoin network is not good for the environment, or for the users, or for honest miners, but is ideal for dishonest miners looking for an advantage.\n\nThis is my understanding:\n\nThe selfish mining attack described above was already presented and known about **many years** ago, with the solution presented here: https://www.cs.cornell.edu/~ie53/publications/btcProcFC.pdf\n\nThe solution was later determined to actually raise the needed threshhold to 33%, not 25% in the paper.\n\nThat solution is what is used in the network today.\n\nImplementing floating-point Nakamoto Consensus removes the solution presented in the paper, and therefore risks reintroducing the selfish mining attack.\n\nTherefore, floating-point Nakamoto Consensus is a hard NAK.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "\u00d6nder G\u00fcrcan",
                "date": "2020-10-08T09:18:59",
                "message_text_only": "Hello all,\n\nBy the way, is this FPNC is similar to the way the current (or recent) code of Ethereum that is selecting branches based on the difficulty of the crypto puzzles solved to obtain the blocks of this branch without comparing the sizes of the subtrees?\n\nAny ideas?\n\nBest,\n\n\u00d6nder\n\n\n> On 8 Oct 2020, at 03:39, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Good morning all,\n> \n>> \n>> Below is a novel discussion on block-withholding attacks and FPNC. These are two very simple changes being proposed here that will dramatically impact the network for the better.\n>> \n>> But first of all, I'd like to say that the idea for FPNC came out of a conversation with ZmnSCPxj's in regards to re-org stability.  When I had proposed blockchain pointers with the PubRef opcode, he took the time to explain to me concerns around re-orgs and why it is a bigger problem than I initially had thought \u2014 and I greatly appreciate this detail.   After touching base with ZmnSCPxj and Greg Maxwell there is an overwhelming view that the current problems that face the network outweigh any theoretical ones.\n>> \n>> Currently the elephant in the room is the miner withholding attack. There is an unintended incentive to hold onto blocks because keeping knowledge of this coinbase private gives a greedy miner more time to calculate the next block.  Major mining pools are actively employing this strategy because winning two blocks in a row has a much greater payoff than common robbery. This unfair advantage happens each time a new block is found, and provides a kind of home-field advantage for large pools, and contributes to a more centralized network. This odd feature of the bitcoin protocol provides a material incentive to delay transactions and encourages the formation of disagreements. In a sense, withholding is a deception of the computational power of a miner, and by extension a deception of their influence within the electorate.  In effect, other miners are forced to work harder, and when they are successful in finding a 2nd solution of the same height \u2014 no one benefits. Disagreement on the bitcoin network is not good for the environment, or for the users, or for honest miners, but is ideal for dishonest miners looking for an advantage.\n> \n> This is my understanding:\n> \n> The selfish mining attack described above was already presented and known about **many years** ago, with the solution presented here: https://www.cs.cornell.edu/~ie53/publications/btcProcFC.pdf\n> \n> The solution was later determined to actually raise the needed threshhold to 33%, not 25% in the paper.\n> \n> That solution is what is used in the network today.\n> \n> Implementing floating-point Nakamoto Consensus removes the solution presented in the paper, and therefore risks reintroducing the selfish mining attack.\n> \n> Therefore, floating-point Nakamoto Consensus is a hard NAK.\n> \n> \n> Regards,\n> ZmnSCPxj\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Mike Brooks",
                "date": "2020-10-08T23:05:05",
                "message_text_only": "Very interesting,\n\nBlock mixing did not resolve the selfish mining that is currently observed\non the network.  This mitigation was only intended to limit the maximum\nimpact of waiting for a 2nd block to be produced.\n\nRebalancing the selfish-mining incentives with FPNC and a faster block\ncreation time is the single best thing we can do to decentralize mining\nefforts.  It will also produce a better network.\n\n\n\nOn Wed, Oct 7, 2020 at 6:40 PM ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning all,\n>\n> >\n> > Below is a novel discussion on block-withholding attacks and FPNC. These\n> are two very simple changes being proposed here that will\n> dramatically impact the network for the better.\n> >\n> > But first of all, I'd like to say that the idea for FPNC came out of a\n> conversation with ZmnSCPxj's in regards to re-org stability.  When I had\n> proposed blockchain pointers with the PubRef opcode, he took the time to\n> explain to me concerns around re-orgs and why it is a bigger problem than I\n> initially had thought \u2014 and I greatly appreciate this detail.   After\n> touching base with ZmnSCPxj and Greg Maxwell there is an overwhelming view\n> that the current problems that face the network outweigh any theoretical\n> ones.\n> >\n> > Currently the elephant in the room is the miner withholding\n> attack. There is an unintended incentive to hold onto blocks because\n> keeping knowledge of this coinbase private gives a greedy miner more time\n> to calculate the next block.  Major mining pools are actively employing\n> this strategy because winning two blocks in a row has a much greater payoff\n> than common robbery. This unfair advantage happens each time a new block is\n> found, and provides a kind of home-field advantage for large pools, and\n> contributes to a more centralized network. This odd feature of the bitcoin\n> protocol provides a material incentive to delay transactions and encourages\n> the formation of disagreements. In a sense, withholding is a deception of\n> the computational power of a miner, and by extension a deception of their\n> influence within the electorate.  In effect, other miners are forced to\n> work harder, and when they are successful in finding a 2nd solution of the\n> same height \u2014 no one benefits. Disagreement on the bitcoin network is not\n> good for the environment, or for the users, or for honest miners, but is\n> ideal for dishonest miners looking for an advantage.\n>\n> This is my understanding:\n>\n> The selfish mining attack described above was already presented and known\n> about **many years** ago, with the solution presented here:\n> https://www.cs.cornell.edu/~ie53/publications/btcProcFC.pdf\n>\n> The solution was later determined to actually raise the needed threshhold\n> to 33%, not 25% in the paper.\n>\n> That solution is what is used in the network today.\n>\n> Implementing floating-point Nakamoto Consensus removes the solution\n> presented in the paper, and therefore risks reintroducing the selfish\n> mining attack.\n>\n> Therefore, floating-point Nakamoto Consensus is a hard NAK.\n>\n>\n> Regards,\n> ZmnSCPxj\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201008/cbcd37ee/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Progress on Miner Withholding - FPNC",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Mike Brooks",
                "Pieter Wuille",
                "\u00d6nder G\u00fcrcan"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 21467
        }
    },
    {
        "title": "[bitcoin-dev] RFC BIP-0002: Defer, not reject.",
        "thread_messages": [
            {
                "author": "\u30a2\u30eb\u30e0\u3000\u30ab\u30fc\u30eb\u30e8\u30cf\u30f3",
                "date": "2020-10-13T10:06:09",
                "message_text_only": "Hello,\n\nI am making a minor proposed change to BIP-0002\n\nhttps://github.com/bitcoin/bips/pull/1012\n\nI propose that we change the 3-year-rule to allow anyone to change the\nstatus of a BIP to \"Deferred\", rather than \"Rejected\".\n\nRejecting a BIP already has ambiguous meaning in BIP-0002 as it\nstands, with \"hard\" rejects:\n\n> The BIP editor will not unreasonably reject a BIP. Reasons for rejecting BIPs include duplication of effort, disregard for formatting rules, being too unfocused or too broad, being technically unsound, not providing proper motivation or addressing backwards compatibility, or not in keeping with the Bitcoin philosophy.\n\nand \"soft\" rejects:\n\n> BIPs should be changed from Draft or Proposed status, to Rejected status, upon request by any person, if they have not made progress in three years. Such a BIP may be changed to Draft status if the champion provides revisions that meaningfully address public criticism of the proposal, or to Proposed status if it meets the criteria required as described in the previous paragraph.\n\nMy proposal is that we disambiguate the second into \"deferred\" instead.\n\nAlternatively, we add a new status e.g. \"Inactive\"."
            }
        ],
        "thread_summary": {
            "title": "RFC BIP-0002: Defer, not reject.",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "\u30a2\u30eb\u30e0\u3000\u30ab\u30fc\u30eb\u30e8\u30cf\u30f3"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1174
        }
    },
    {
        "title": "[bitcoin-dev] Suggestion: Solve year 2106 problem by taking timestamps mod 2^32",
        "thread_messages": [
            {
                "author": "Pieter Wuille",
                "date": "2020-10-16T21:58:20",
                "message_text_only": "On Saturday, September 19, 2020 5:36 AM, yanmaani--- via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Currently, Bitcoin's timestamp rules are as follows:\n>\n> 1.  The block timestamp may not be lower than the median of the last 11\n>     blocks'\n>\n> 2.  The block timestamp may not be greater than the current time plus two\n>     hours\n>\n> 3.  The block timestamp may not be greater than 2^32 (Sun, 07 Feb 2106\n>     06:28:16 +0000)\n>\n>     Thus, Bitcoin will \"die\" on or about 2106-02-07, when there is no\n>     timestamp below 2^32 that exceeds the median of the last 11 blocks.\n>\n>     If the rules were changed to the following, this problem would be\n>     solved:\n>\n> 4.  The block timestamp plus k*2^32 may not be lower than the median of\n>     the last 11 blocks'\n>\n> 5.  The block timestamp plus k*2^32 may not be greater than the current\n>     time plus two hours\n>\n> 6.  k is an integer, whose value must be the same for the calculations of\n>     Rule 1 and Rule 2\n\nI believe that is equivalent to: we treat block headers (as abstract data\nstructure) as having a 64-bit timestamp, which have the requirement that\nthe difference between the timestamp and the median timestamp of the past 11\nblocks is at least one and at most 2^32 (I don't think we need to support\nless than 6 blocks per 136 years).\n\nOn serialization, only the lower 32 bit are encoded. On deserialization,\nthe higher 32 bits are set equal to that of the median of the past 11 blocks.\nIf that violates the rule above, set it one higher.\n\nThat's in line of how I'd expect this will eventually be addressed. There is\nno rush, of course.\n\n>     What do you think of this idea? Is it worth a BIP?\n\nProbably, at some point.\n\nCheers,\n\n--\nPieter"
            }
        ],
        "thread_summary": {
            "title": "Suggestion: Solve year 2106 problem by taking timestamps mod 2^32",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Pieter Wuille"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1733
        }
    },
    {
        "title": "[bitcoin-dev] BIP draft: BIP32 Path Templates",
        "thread_messages": [
            {
                "author": "Dmitry Petukhov",
                "date": "2020-10-26T13:04:56",
                "message_text_only": "I have added a Python reference implementation of BIP32 path templates,\nthat is also compatible with micropython:\n\nhttps://github.com/dgpv/bip32_template_python_implementation\n\nThe FSM formal spec has received a small corrections since the\nannouncement, and the reference implementations (C and this new python\nimplementation) are tested even more thoroughly now.\n\nI submitted a PR to the bips repo:\nhttps://github.com/bitcoin/bips/pull/1025, any comments welcome.\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: not available\nType: application/pgp-signature\nSize: 833 bytes\nDesc: \u00d0\u00a6\u00d0\u00b8\u00d1\u201e\u00d1\u20ac\u00d0\u00be\u00d0\u00b2\u00d0\u00b0\u00d1\u008f \u00d0\u00bf\u00d0\u00be\u00d0\u00b4\u00d0\u00bf\u00d0\u00b8\u00d1\u0081\u00d1\u0152 OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201026/5fc70a17/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "BIP draft: BIP32 Path Templates",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Dmitry Petukhov"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 763
        }
    },
    {
        "title": "[bitcoin-dev] bips.txt format for all Bitcoin projects",
        "thread_messages": [
            {
                "author": "Prayank",
                "date": "2020-10-26T19:03:21",
                "message_text_only": "Hello Everyone,\n\nWhat?\n\nCan we request all Bitcoin projects to create a file 'bips.txt' with a format that describes all the BIPs used in the project?\n\nHow?\n\nThe file can be uploaded to the root of website used for the project. For example: BTCPay can have this file at:\u00a0\u00a0https://btcpayserver.org/bips.txt in below format:\n\nBIP78\nhttps://docs.btcpayserver.org/Payjoin/\n\nBIP Number:\nDetails:\n\nBIP Number\nDetails:\n\nWhy?\n\nBitcoin Improvement Proposals play an important role in Bitcoin and this will make it easier for users, other devs, journalists, researchers, crawlers etc. to understand all BIPs used in different Bitcoin Projects, their implementation and importance.\u00a0\n\nEvery BIP with details is mentioned here already:\u00a0https://github.com/bitcoin/bips\u00a0however I don't think all the devs who initially start researching about Bitcoin or the users really understand their importance, usage etc. So I am also trying to create BIPs gallery which has basic images for each BIP right now and later will include a page to have\u00a0video links, usage, issues, history, other helpful links etc. later for each.\n\nThe discussion started with this question on stackexchange:\u00a0https://bitcoin.stackexchange.com/questions/98543/any-website-that-explains-most-of-the-bips-in-a-different-way-that-newbies-can-u/ <https://bitcoin.stackexchange.com/questions/98543/any-website-that-explains-most-of-the-bips-in-a-different-way-that-newbies-can-u/98544#98544>\n\nWebsite that I am working on:\u00a0https://bips.gallery/\u00a0\nGithub repository for it:\u00a0https://github.com/prayank23/BIPsGallery\n\n--\nPrayank\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201026/b0694bf5/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "bips.txt format for all Bitcoin projects",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Prayank"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1759
        }
    }
]