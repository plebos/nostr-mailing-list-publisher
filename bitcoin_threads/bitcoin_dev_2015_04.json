[
    {
        "title": "[Bitcoin-development] \"network disruption as a service\" and proof of local storage",
        "thread_messages": [
            {
                "author": "Sergio Lerner",
                "date": "2015-04-01T02:34:56",
                "message_text_only": "Matt is right:  the goal is to prove digital copies of a public file.\nNothing more, nothing less.\n\nRegarding the IP, I don't claim that every machine should provide the\nprotocol. Mobiles phones shouldn't. But machines that what to be\nprioritized in some way or that want to be rewarded for hosting a node\nshould use a fixed IP. That's the cost of prioritization/reward. The\nprotocol could be a service bit, advertised in the version message.\n\nMy response to your comment below:\n\nOn 27/03/2015 03:40 p.m., Jeremy Spilman wrote:\n>\n> It would be extremely impressive to achieve a reliable mechanism for discerning a local copy exists under these constraints, particularly without false positives and false negatives, and without imposing very substantial one-time encoding costs, e.g. on par with doubling the verification cost. \nI see it differently. The asymmetric-time protocol is quite reliable. If\ncan be made to have almost no false positives/false negatives (not\nconsidering rare communication problems, such as congestion and packet\nloss for more than 5 seconds).\nThese are my back-of-the-envelope calculations:\nBitcoind takes approximately 1 second to serve a 1 Mb block (seek time,\nbut mostly transfer time)\nThen decryption of a block can take 150 msec without problem (15%\noverhead). The last N blocks could be cached so they don't need to be\ndecrypted to be sent.\nIn 150 msec a PC can decrypt a 1MB of data split over 1024-bit blocks\ndecrypted by modexp 3 (0.2 msec for 3 bigint multiplications), so a full\nblock can be decrypted.\nEncrypting such block would take approximately 15 seconds (which is much\nless than the 10 minutes available to encrypt each block)\nThen the protocol works with a security margin of approximately 50x.\nA communication problem during 5 seconds would be needed to disturb a\nprotocol of that takes 100 msec for the prover.\n\nRegards,\n Sergio."
            }
        ],
        "thread_summary": {
            "title": "\"network disruption as a service\" and proof of local storage",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Sergio Lerner"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1876
        }
    },
    {
        "title": "[Bitcoin-development] Bitcoin Core 0.10.1 release candidate 1 available",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2015-04-02T08:11:24",
                "message_text_only": "Binaries for bitcoin Core version 0.10.1rc1 are now available from:\n\n  https://bitcoin.org/bin/0.10.1/test\n\nSource code can be found in github under the tag\n\n  https://github.com/bitcoin/bitcoin/tree/v0.10.1rc1\n\nThis is a release candidate for a minor version release, bringing bug fixes and\ntranslation updates. Release candidates are test runs for releases, when no critical\nproblems are found the release candidate will be tagged as 0.10.1.\n\nPlease report bugs using the issue tracker at github:\n\n  https://github.com/bitcoin/bitcoin/issues\n\nUpgrading and downgrading\n=========================\n\nHow to Upgrade\n--------------\n\nIf you are running an older version, shut it down. Wait until it has completely\nshut down (which might take a few minutes for older versions), then run the\ninstaller (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\nbitcoind/bitcoin-qt (on Linux).\n\nDowngrade warning\n------------------\n\nBecause release 0.10.0 and later makes use of headers-first synchronization and\nparallel block download (see further), the block files and databases are not\nbackwards-compatible with pre-0.10 versions of Bitcoin Core or other software:\n\n* Blocks will be stored on disk out of order (in the order they are\nreceived, really), which makes it incompatible with some tools or\nother programs. Reindexing using earlier versions will also not work\nanymore as a result of this.\n\n* The block index database will now hold headers for which no block is\nstored on disk, which earlier versions won't support.\n\nIf you want to be able to downgrade smoothly, make a backup of your entire data\ndirectory. Without this your node will need start syncing (or importing from\nbootstrap.dat) anew afterwards. It is possible that the data from a completely\nsynchronised 0.10 node may be usable in older versions as-is, but this is not\nsupported and may break as soon as the older version attempts to reindex.\n\nThis does not affect wallet forward or backward compatibility.\n\nNotable changes\n===============\n\nThis is a minor release and hence there are no notable changes.\nFor the notable changes in 0.10 refer to the release notes for the\n0.10.0 release at https://github.com/bitcoin/bitcoin/blob/v0.10.0/doc/release-notes.md\n\n0.10.1 Change log\n=================\n\nDetailed release notes follow. This overview includes changes that affect external\nbehavior, not code moves, refactors or string updates.\n\nRPC:\n- `7f502be` fix crash: createmultisig and addmultisigaddress\n\nBlock (database) and transaction handling:\n- `1d2cdd2` Fix InvalidateBlock to add chainActive.Tip to setBlockIndexCandidates\n- `c91c660` fix InvalidateBlock to repopulate setBlockIndexCandidates\n- `002c8a2` fix possible block db breakage during re-index\n- `a1f425b` Add (optional) consistency check for the block chain data structures\n\nP2P protocol and network code:\n- `78f64ef` don't trickle for whitelisted nodes\n- `ca301bf` Reduce fingerprinting through timestamps in 'addr' messages.\n- `200f293` Ignore getaddr messages on Outbound connections.\n- `d5d8998` Limit message sizes before transfer\n- `aeb9279` Better fingerprinting protection for non-main-chain getdatas.\n- `cf0218f` Make addrman's bucket placement deterministic (countermeasure 1 against eclipse attacks, see http://cs-people.bu.edu/heilman/eclipse/)\n- `0c6f334` Always use a 50% chance to choose between tried and new entries (countermeasure 2 against eclipse attacks)\n- `214154e` Do not bias outgoing connections towards fresh addresses (countermeasure 2 against eclipse attacks)\n- `aa587d4` Scale up addrman (countermeasure 6 against eclipse attacks)\n\nValidation:\n- `d148f62` Acquire CCheckQueue's lock to avoid race condition\n\nBuild system:\n- `8752b5c` 0.10 fix for crashes on OSX 10.6\n\nWallet:\n- N/A\n\nGUI:\n- `2c08406` some mac specifiy cleanup (memory handling, unnecessary code)\n- `81145a6` fix OSX dock icon window reopening\n- `786cf72` fix a issue where \"command line options\"-action overwrite \"Preference\"-action (on OSX)\n\nTests:\n- `1117378` add RPC test for InvalidateBlock\n\nMiscellaneous:\n- `c9e022b` Initialization: set Boost path locale in main thread\n- `23126a0` Sanitize command strings before logging them.\n\nCredits\n=======\n\nThanks to everyone who contributed to this release:\n\n- Alex Morcos\n- Cory Fields\n- dexX7\n- fsb4000\n- Gregory Maxwell\n- Ivan Pustogarov\n- Jonas Schnelli\n- Pieter Wuille\n- Ruben de Vries\n- Suhas Daftuar\n- Wladimir J. van der Laan\n\nAs well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/)."
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.10.1 release candidate 1 available",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Wladimir J. van der Laan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 4521
        }
    },
    {
        "title": "[Bitcoin-development]  PAPER: New algorithm for the discrete logarithm problem on elliptic curves",
        "thread_messages": [
            {
                "author": "Jean-Paul Kogelman",
                "date": "2015-04-07T21:32:52",
                "message_text_only": "FYI,\n\nhttps://eprint.iacr.org/2015/310.pdf\n\njp\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150407/f1e62e19/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "PAPER: New algorithm for the discrete logarithm problem on elliptic curves",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jean-Paul Kogelman"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 229
        }
    },
    {
        "title": "[Bitcoin-development] PAPER: New algorithm for the discrete logarithm problem on elliptic curves",
        "thread_messages": [
            {
                "author": "Gregory Maxwell",
                "date": "2015-04-07T21:37:15",
                "message_text_only": "On Tue, Apr 7, 2015 at 9:32 PM, Jean-Paul Kogelman\n<jeanpaulkogelman at me.com> wrote:\n> https://eprint.iacr.org/2015/310.pdf\n\nhttp://www.reddit.com/r/Bitcoin/comments/31rcuo/new_algorithm_for_the_discrete_logarithm_problem/cq4b52u"
            },
            {
                "author": "Brian Hoffman",
                "date": "2015-04-07T22:15:36",
                "message_text_only": "That was easy.\n\n\n> On Apr 7, 2015, at 5:49 PM, Jean-Paul Kogelman <jeanpaulkogelman at me.com> wrote:\n> \n> Ok, false alarm. :)\n> \n> Sorry for the spam.\n> \n>> On Apr 07, 2015, at 02:37 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n>> \n> \n>> On Tue, Apr 7, 2015 at 9:32 PM, Jean-Paul Kogelman\n>> <jeanpaulkogelman at me.com> wrote:\n>>> https://eprint.iacr.org/2015/310.pdf\n>> \n>> http://www.reddit.com/r/Bitcoin/comments/31rcuo/new_algorithm_for_the_discrete_logarithm_problem/cq4b52u\n> ------------------------------------------------------------------------------\n> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT\n> Develop your own process in accordance with the BPMN 2 standard\n> Learn Process modeling best practices with Bonita BPM through live exercises\n> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_\n> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150407/c89e1df3/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "PAPER: New algorithm for the discrete logarithm problem on elliptic curves",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Brian Hoffman",
                "Gregory Maxwell"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1540
        }
    },
    {
        "title": "[Bitcoin-development]  Re:  PAPER: New algorithm for the discrete logarithm problem on elliptic curves",
        "thread_messages": [
            {
                "author": "Jean-Paul Kogelman",
                "date": "2015-04-07T21:49:06",
                "message_text_only": "Ok, false alarm. :)\n\nSorry for the spam.\n\nOn Apr 07, 2015, at 02:37 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n\nOn Tue, Apr 7, 2015 at 9:32 PM, Jean-Paul Kogelman\n<jeanpaulkogelman at me.com> wrote:\nhttps://eprint.iacr.org/2015/310.pdf\n\nhttp://www.reddit.com/r/Bitcoin/comments/31rcuo/new_algorithm_for_the_discrete_logarithm_problem/cq4b52u\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150407/40e2d52d/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Re:  PAPER: New algorithm for the discrete logarithm problem on elliptic curves",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jean-Paul Kogelman"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 532
        }
    },
    {
        "title": "[Bitcoin-development] Request For Discussion / BIP number - Multi-Currency Hierarchy For Use In Multisignature Deterministic Wallets",
        "thread_messages": [
            {
                "author": "Kefkius",
                "date": "2015-04-08T07:05:43",
                "message_text_only": "I have a potential BIP, \"Multi-Currency Hierarchy For Use In\nMultisignature Deterministic Wallets.\" I'm requesting discussion on it,\nand possibly assignment of a BIP number.\n\nIt's located in this github gist:\nhttps://gist.github.com/Kefkius/1aa02945e532f8739023"
            },
            {
                "author": "William Swanson",
                "date": "2015-04-08T07:46:43",
                "message_text_only": "It's not really clear why this is better than BIP 44 as it already\nstands. You have the same fields, but they are just in a different\norder. Couldn't you just use the existing BIP 44 hierarchy, but add\nthe convention that \"wallet/account N\" is the same wallet in each\nsupported currency?\n\nFor example, if I have a wallet called \"business expenses\", which\nhappens to be wallet m / 44' / 0' / 5', for Bitcoin, then the same\nwallet would be m / 44' / 3' / 5' for Dogecoin, and m / 44' / 2' / 5'\nfor Litecoin.\n\nI am trying to think of examples where your proposal is better than\nBIP 44, but I can't think of any. Even backup recovery works fine. I\nassume that your idea is to continue iterating over the different\nwallet indices as long as you are finding funds in *any* currency.\nWell, you can still do that with BIP 44. The fields are in a different\norder, but that doesn't affect the algorithm in any way.\n\nMaybe you have some deeper insight I'm not seeing, but if so, you need\nto clearly explain that in your motivation section. The current\nexplanation, \"This limits the possible implementations of\nmulti-currency, multisignature wallets,\" is pretty vauge. Also, there\nis nothing in this spec that addresses the multisignature use-case.\nThe BIP 45 spec does a lot of extra work to make multisignature work\nsmoothly.\n\nI'm not trying to criticize your proposal. I'm just trying to\nunderstand what it's trying to accomplish.\n\n-William Swanson\n\n\nOn Wed, Apr 8, 2015 at 12:05 AM, Kefkius <kefkius at maza.club> wrote:\n> I have a potential BIP, \"Multi-Currency Hierarchy For Use In\n> Multisignature Deterministic Wallets.\" I'm requesting discussion on it,\n> and possibly assignment of a BIP number.\n>\n> It's located in this github gist:\n> https://gist.github.com/Kefkius/1aa02945e532f8739023\n>\n> ------------------------------------------------------------------------------\n> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT\n> Develop your own process in accordance with the BPMN 2 standard\n> Learn Process modeling best practices with Bonita BPM through live exercises\n> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_\n> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "\u6728\u30ce\u4e0b\u3058\u3087\u306a",
                "date": "2015-04-08T16:28:42",
                "message_text_only": "William,\n\nI believe the reasoning for this is stated in the Coin Type section.\n\n\"Public derivation is used so that cosigners need only know one of each\nother's public keys, rather than needing to distribute public keys for each\ncoin.\"\n\nBIP44 has a coin level, but it's a private derived level, so cosigners\nwould not be able to generate multiple crypto currencies of each others'\nwithout giving each other n xpubs where n is the number of currencies\nshared. This new proposal basically sticks coin type on the public\nderivation side of things so that I could generate litecoin or darkcoin\nmultisigs without your permission...\n\nKefkius,\n\nThis BIP seems like a good fit for multi-currency wallets based on\nmultisig. So kudos for putting it in writing.\n\nHowever, I don't know if this is really a BIP thing. It's not improving\nBitcoin (Bitcoin Improvement Proposal... remember?), in fact, by definition\nit is improving altcoin usability.\n\nFor that reason alone I will say I disagree for a BIP for this.\n- Jona\n\n\n2015-04-08 16:46 GMT+09:00 William Swanson <swansontec at gmail.com>:\n>\n> It's not really clear why this is better than BIP 44 as it already\n> stands. You have the same fields, but they are just in a different\n> order. Couldn't you just use the existing BIP 44 hierarchy, but add\n> the convention that \"wallet/account N\" is the same wallet in each\n> supported currency?\n>\n> For example, if I have a wallet called \"business expenses\", which\n> happens to be wallet m / 44' / 0' / 5', for Bitcoin, then the same\n> wallet would be m / 44' / 3' / 5' for Dogecoin, and m / 44' / 2' / 5'\n> for Litecoin.\n>\n> I am trying to think of examples where your proposal is better than\n> BIP 44, but I can't think of any. Even backup recovery works fine. I\n> assume that your idea is to continue iterating over the different\n> wallet indices as long as you are finding funds in *any* currency.\n> Well, you can still do that with BIP 44. The fields are in a different\n> order, but that doesn't affect the algorithm in any way.\n>\n> Maybe you have some deeper insight I'm not seeing, but if so, you need\n> to clearly explain that in your motivation section. The current\n> explanation, \"This limits the possible implementations of\n> multi-currency, multisignature wallets,\" is pretty vauge. Also, there\n> is nothing in this spec that addresses the multisignature use-case.\n> The BIP 45 spec does a lot of extra work to make multisignature work\n> smoothly.\n>\n> I'm not trying to criticize your proposal. I'm just trying to\n> understand what it's trying to accomplish.\n>\n> -William Swanson\n>\n>\n> On Wed, Apr 8, 2015 at 12:05 AM, Kefkius <kefkius at maza.club> wrote:\n> > I have a potential BIP, \"Multi-Currency Hierarchy For Use In\n> > Multisignature Deterministic Wallets.\" I'm requesting discussion on it,\n> > and possibly assignment of a BIP number.\n> >\n> > It's located in this github gist:\n> > https://gist.github.com/Kefkius/1aa02945e532f8739023\n> >\n> >\n------------------------------------------------------------------------------\n> > BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT\n> > Develop your own process in accordance with the BPMN 2 standard\n> > Learn Process modeling best practices with Bonita BPM through live\nexercises\n> > http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual-\nevent?utm_\n> > source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF\n> > _______________________________________________\n> > Bitcoin-development mailing list\n> > Bitcoin-development at lists.sourceforge.net\n> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n------------------------------------------------------------------------------\n> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT\n> Develop your own process in accordance with the BPMN 2 standard\n> Learn Process modeling best practices with Bonita BPM through live\nexercises\n> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual-\nevent?utm_\n> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n\n\n\n--\n-----BEGIN PGP PUBLIC KEY BLOCK-----\nComment: http://openpgpjs.org\n\nxsBNBFTmJ8oBB/9rd+7XLxZG/x/KnhkVK2WBG8ySx91fs+qQfHIK1JrakSV3\nx6x0cK3XLClASLLDomm7Od3Q/fMFzdwCEqj6z60T8wgKxsjWYSGL3mq8ucdv\niBjC3wGauk5dQKtT7tkCFyQQbX/uMsBM4ccGBICoDmIJlwJIj7fAZVqGxGOM\nbO1RhYb4dbQA2qxYP7wSsHJ6/ZNAXyEphOj6blUzdqO0exAbCOZWWF+E/1SC\nEuKO4RmL7Imdep7uc2Qze1UpJCZx7ASHl2IZ4UD0G3Qr3pI6/jvNlaqCTa3U\n3/YeJwEubFsd0AVy0zs809RcKKgX3W1q+hVDTeWinem9RiOG/vT+Eec/ABEB\nAAHNI2tpbm9zaGl0YSA8a2lub3NoaXRham9uYUBnbWFpbC5jb20+wsByBBAB\nCAAmBQJU5ifRBgsJCAcDAgkQRB9iZ30dlisEFQgCCgMWAgECGwMCHgEAAC6Z\nB/9otobf0ASHYdlUBeIPXdDopyjQhR2RiZGYaS0VZ5zzHYLDDMW6ZIYm5CjO\nFc09ETLGKFxH2RcCOK2dzwz+KRU4xqOrt/l5gyd50cFE1nOhUN9+/XaPgrou\nWhyT9xLeGit7Xqhht93z2+VanTtJAG6lWbAZLIZAMGMuLX6sJDCO0GiO5zxa\n02Q2D3kh5GL57A5+oVOna12JBRaIA5eBGKVCp3KToT/z48pxBe3WAmLo0zXr\nhEgTSzssfb2zTwtB3Ogoedj+cU2bHJvJ8upS/jMr3TcdguySmxJlGpocVC/e\nqxq12Njv+LiETOrD8atGmXCnA+nFNljBkz+l6ADl93jHzsBNBFTmJ9EBCACu\nQq9ZnP+aLU/Rt6clAfiHfTFBsJvLKsdIKeE6qHzsU1E7A7bGQKTtLEnhCCQE\nW+OQP+sgbOWowIdH9PpwLJ3Op+NhvLlMxRvbT36LwCmBL0yD7bMqxxmmVj8n\nvlMMRSe4wDSIG19Oy7701imnHZPm/pnPlneg/Meu/UffpcDWYBbAFX8nrXPY\nvkVULcI/qTcCxW/+S9fwoXjQhWHaiJJ6y3cYOSitN31W9zgcMvLwLX3JgDxE\nflkwq/M+ZkfCYnS3GAPEt8GkVKy2eHtCJuNkGFlCAmKMX0yWzHRAkqOMN5KP\nLFbkKY2GQl13ztWp82QYJZpj5af6dmyUosurn6AZABEBAAHCwF8EGAEIABMF\nAlTmJ9QJEEQfYmd9HZYrAhsMAABKbgf/Ulu5JAk4fXgH0DtkMmdkFiKEFdkW\n0Wkw7Vhd5eZ4NzeP9kOkD01OGweT9hqzwhfT2CNXCGxh4UnvEM1ZMFypIKdq\n0XpLLJMrDOQO021UjAa56vHZPAVmAM01z5VzHJ7ekjgwrgMLmVkm0jWKEKaO\nn/MW7CyphG7QcZ6cJX2f6uJcekBlZRw9TNYRnojMjkutlOVhYJ3J78nc/k0p\nkcgV63GB6D7wHRF4TVe4xIBqKpbBhhN+ISwFN1z+gx3lfyRMSmiTSrGdKEQe\nXSIQKG8XZQZUDhLNkqPS+7EMV1g7+lOfT4GhLL68dUXDa1e9YxGH6zkpVECw\nSpe3vsHZr6CqFg==\n=/vUJ\n-----END PGP PUBLIC KEY BLOCK-----\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150409/a0f5b1a6/attachment.html>"
            },
            {
                "author": "William Swanson",
                "date": "2015-04-08T16:41:00",
                "message_text_only": "Oops, sorry I missed that.\n\nSince that's the reason this proposal exists, I would consider putting\nit right up top where people can see it. Also, since this proposal is\nspecifically designed for multi-sig, I would look at what BIP45 is\ndoing and maybe incorporate a \"cosigner_index\" branch. Otherwise, this\nidea seems like a reasonable way to organize a wallet.\n\n-William\n\nOn Wed, Apr 8, 2015 at 9:28 AM, \u6728\u30ce\u4e0b\u3058\u3087\u306a <kinoshitajona at gmail.com> wrote:\n> William,\n>\n> I believe the reasoning for this is stated in the Coin Type section.\n>\n> \"Public derivation is used so that cosigners need only know one of each\n> other's public keys, rather than needing to distribute public keys for each\n> coin.\"\n>\n> BIP44 has a coin level, but it's a private derived level, so cosigners would\n> not be able to generate multiple crypto currencies of each others' without\n> giving each other n xpubs where n is the number of currencies shared. This\n> new proposal basically sticks coin type on the public derivation side of\n> things so that I could generate litecoin or darkcoin multisigs without your\n> permission...\n>\n> Kefkius,\n>\n> This BIP seems like a good fit for multi-currency wallets based on multisig.\n> So kudos for putting it in writing.\n>\n> However, I don't know if this is really a BIP thing. It's not improving\n> Bitcoin (Bitcoin Improvement Proposal... remember?), in fact, by definition\n> it is improving altcoin usability.\n>\n> For that reason alone I will say I disagree for a BIP for this.\n> - Jona\n>\n>\n> 2015-04-08 16:46 GMT+09:00 William Swanson <swansontec at gmail.com>:\n>>\n>> It's not really clear why this is better than BIP 44 as it already\n>> stands. You have the same fields, but they are just in a different\n>> order. Couldn't you just use the existing BIP 44 hierarchy, but add\n>> the convention that \"wallet/account N\" is the same wallet in each\n>> supported currency?\n>>\n>> For example, if I have a wallet called \"business expenses\", which\n>> happens to be wallet m / 44' / 0' / 5', for Bitcoin, then the same\n>> wallet would be m / 44' / 3' / 5' for Dogecoin, and m / 44' / 2' / 5'\n>> for Litecoin.\n>>\n>> I am trying to think of examples where your proposal is better than\n>> BIP 44, but I can't think of any. Even backup recovery works fine. I\n>> assume that your idea is to continue iterating over the different\n>> wallet indices as long as you are finding funds in *any* currency.\n>> Well, you can still do that with BIP 44. The fields are in a different\n>> order, but that doesn't affect the algorithm in any way.\n>>\n>> Maybe you have some deeper insight I'm not seeing, but if so, you need\n>> to clearly explain that in your motivation section. The current\n>> explanation, \"This limits the possible implementations of\n>> multi-currency, multisignature wallets,\" is pretty vauge. Also, there\n>> is nothing in this spec that addresses the multisignature use-case.\n>> The BIP 45 spec does a lot of extra work to make multisignature work\n>> smoothly.\n>>\n>> I'm not trying to criticize your proposal. I'm just trying to\n>> understand what it's trying to accomplish.\n>>\n>> -William Swanson\n>>\n>>\n>> On Wed, Apr 8, 2015 at 12:05 AM, Kefkius <kefkius at maza.club> wrote:\n>> > I have a potential BIP, \"Multi-Currency Hierarchy For Use In\n>> > Multisignature Deterministic Wallets.\" I'm requesting discussion on it,\n>> > and possibly assignment of a BIP number.\n>> >\n>> > It's located in this github gist:\n>> > https://gist.github.com/Kefkius/1aa02945e532f8739023"
            },
            {
                "author": "Kefkius",
                "date": "2015-04-09T20:16:41",
                "message_text_only": "William,\n\nI've amended the proposal's \"Motivation\" section slightly for\nclarification. I'm not sure how a \"cosigner_index\" branch would benefit\nthis proposal. Granted, I don't fully understand the benefits of the\n\"cosigner_index\" branch in BIP-0045. From what I understand, the\n\"wallet\" branch of my proposal seems to accomplish a similar goal.\n\nJona,\n\nYour explanation is correct. As for this being appropriate as a BIP, I\nagree that it's an arguable point to say it improves Bitcoin. However,\nthis proposal exists because of BIP-0044, which also describes a\nmulti-currency hierarchy. For that reason, I think this is an\nappropriate proposal.\n\nThank you both for your feedback.\n\nOn 04/08/2015 12:41 PM, William Swanson wrote:\n> Oops, sorry I missed that.\n>\n> Since that's the reason this proposal exists, I would consider putting\n> it right up top where people can see it. Also, since this proposal is\n> specifically designed for multi-sig, I would look at what BIP45 is\n> doing and maybe incorporate a \"cosigner_index\" branch. Otherwise, this\n> idea seems like a reasonable way to organize a wallet.\n>\n> -William\n>\n> On Wed, Apr 8, 2015 at 9:28 AM, \u6728\u30ce\u4e0b\u3058\u3087\u306a <kinoshitajona at gmail.com> wrote:\n>> William,\n>>\n>> I believe the reasoning for this is stated in the Coin Type section.\n>>\n>> \"Public derivation is used so that cosigners need only know one of each\n>> other's public keys, rather than needing to distribute public keys for each\n>> coin.\"\n>>\n>> BIP44 has a coin level, but it's a private derived level, so cosigners would\n>> not be able to generate multiple crypto currencies of each others' without\n>> giving each other n xpubs where n is the number of currencies shared. This\n>> new proposal basically sticks coin type on the public derivation side of\n>> things so that I could generate litecoin or darkcoin multisigs without your\n>> permission...\n>>\n>> Kefkius,\n>>\n>> This BIP seems like a good fit for multi-currency wallets based on multisig.\n>> So kudos for putting it in writing.\n>>\n>> However, I don't know if this is really a BIP thing. It's not improving\n>> Bitcoin (Bitcoin Improvement Proposal... remember?), in fact, by definition\n>> it is improving altcoin usability.\n>>\n>> For that reason alone I will say I disagree for a BIP for this.\n>> - Jona\n>>\n>>\n>> 2015-04-08 16:46 GMT+09:00 William Swanson <swansontec at gmail.com>:\n>>> It's not really clear why this is better than BIP 44 as it already\n>>> stands. You have the same fields, but they are just in a different\n>>> order. Couldn't you just use the existing BIP 44 hierarchy, but add\n>>> the convention that \"wallet/account N\" is the same wallet in each\n>>> supported currency?\n>>>\n>>> For example, if I have a wallet called \"business expenses\", which\n>>> happens to be wallet m / 44' / 0' / 5', for Bitcoin, then the same\n>>> wallet would be m / 44' / 3' / 5' for Dogecoin, and m / 44' / 2' / 5'\n>>> for Litecoin.\n>>>\n>>> I am trying to think of examples where your proposal is better than\n>>> BIP 44, but I can't think of any. Even backup recovery works fine. I\n>>> assume that your idea is to continue iterating over the different\n>>> wallet indices as long as you are finding funds in *any* currency.\n>>> Well, you can still do that with BIP 44. The fields are in a different\n>>> order, but that doesn't affect the algorithm in any way.\n>>>\n>>> Maybe you have some deeper insight I'm not seeing, but if so, you need\n>>> to clearly explain that in your motivation section. The current\n>>> explanation, \"This limits the possible implementations of\n>>> multi-currency, multisignature wallets,\" is pretty vauge. Also, there\n>>> is nothing in this spec that addresses the multisignature use-case.\n>>> The BIP 45 spec does a lot of extra work to make multisignature work\n>>> smoothly.\n>>>\n>>> I'm not trying to criticize your proposal. I'm just trying to\n>>> understand what it's trying to accomplish.\n>>>\n>>> -William Swanson\n>>>\n>>>\n>>> On Wed, Apr 8, 2015 at 12:05 AM, Kefkius <kefkius at maza.club> wrote:\n>>>> I have a potential BIP, \"Multi-Currency Hierarchy For Use In\n>>>> Multisignature Deterministic Wallets.\" I'm requesting discussion on it,\n>>>> and possibly assignment of a BIP number.\n>>>>\n>>>> It's located in this github gist:\n>>>> https://gist.github.com/Kefkius/1aa02945e532f8739023\n> ------------------------------------------------------------------------------\n> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT\n> Develop your own process in accordance with the BPMN 2 standard\n> Learn Process modeling best practices with Bonita BPM through live exercises\n> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_\n> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "William Swanson",
                "date": "2015-04-09T22:24:11",
                "message_text_only": "On Thu, Apr 9, 2015 at 1:16 PM, Kefkius <kefkius at maza.club> wrote:\n> I've amended the proposal's \"Motivation\" section slightly for\n> clarification. I'm not sure how a \"cosigner_index\" branch would benefit\n> this proposal. Granted, I don't fully understand the benefits of the\n> \"cosigner_index\" branch in BIP-0045. From what I understand, the\n> \"wallet\" branch of my proposal seems to accomplish a similar goal.\n\nSuppose Alice and Bob share a multi-sig wallet. Alice would like to\naccept payment from Mallory, and Bob would like to accept payment from\nMaude. So, they would each like to create a separate payment address.\nIf Alice and Bob both generate the same address, the incoming funds\nwould be mixed together (bad), and Mallory and Maude might learn about\nthe relationship between Alice and Bob (also bad).\n\nUnfortunately, Alice and Bob are in a place where they can't\ncommunicate (maybe Bob has no cell service). There is no way for Bob\nto send a message like \"I'm making a request on address_index N,\nAlice, please use a different index for your request.\"\n\nThe cosigner_index solves this. When they set up the wallet, Alice and\nBob agree to always use a different value for the cosigner_index. That\nway, addresses from Alice will never overlap with addresses from Bob,\nsince they are on different branches. Doing it this way adds privacy\nand doesn't cost anything.\n\nWith this added in, your path would be:\n\nm / purpose' / wallet' / coin_type / cosigner_index / change / address_index\n\nXPUB's generated from your wallet would then be compatible with XPUB's\ngenerated by other multi-sig wallets like CoPay, since the\n(cosigner_index / change / address_index) structure stays the same.\n\n-William Swanson"
            },
            {
                "author": "Alan Reiner",
                "date": "2015-04-09T22:37:23",
                "message_text_only": "BTW, I had originally proposed a \"no-collision\" scheme for\nmulti-signature wallets, which doesn't require modifying the key tree\nstructure at all, except for adding new internal and external chains\n(2*N chains).  All siblings watch all chains, but only generate\nreceiving and change addresses on their two chains. \n\nThe original document is here, which might be educational for the\npurposes of understand precisely the problem that needs a solution (and\nmine is a different solution than BIP45).\n\nhttps://www.dropbox.com/s/58poxi60d8nfj5w/MultisigWalletNoCollide.pdf\n\nI prefer not adding even more levels to the key tree, and (IMO) it makes\nmore sense to add more chains to the wallet instead of adding a new tree\nlevel (as it allows for a simpler tree in the event that you don't need\nseparate cosigners).  But I suspect that there's a certain momentum\nbehind the cosigner-index method already in BIP45?  Just throwing it out\nthere.\n\n-Alan\n\n\n\nOn 04/09/2015 06:24 PM, William Swanson wrote:\n> On Thu, Apr 9, 2015 at 1:16 PM, Kefkius <kefkius at maza.club> wrote:\n>> I've amended the proposal's \"Motivation\" section slightly for\n>> clarification. I'm not sure how a \"cosigner_index\" branch would benefit\n>> this proposal. Granted, I don't fully understand the benefits of the\n>> \"cosigner_index\" branch in BIP-0045. From what I understand, the\n>> \"wallet\" branch of my proposal seems to accomplish a similar goal.\n> Suppose Alice and Bob share a multi-sig wallet. Alice would like to\n> accept payment from Mallory, and Bob would like to accept payment from\n> Maude. So, they would each like to create a separate payment address.\n> If Alice and Bob both generate the same address, the incoming funds\n> would be mixed together (bad), and Mallory and Maude might learn about\n> the relationship between Alice and Bob (also bad).\n>\n> Unfortunately, Alice and Bob are in a place where they can't\n> communicate (maybe Bob has no cell service). There is no way for Bob\n> to send a message like \"I'm making a request on address_index N,\n> Alice, please use a different index for your request.\"\n>\n> The cosigner_index solves this. When they set up the wallet, Alice and\n> Bob agree to always use a different value for the cosigner_index. That\n> way, addresses from Alice will never overlap with addresses from Bob,\n> since they are on different branches. Doing it this way adds privacy\n> and doesn't cost anything.\n>\n> With this added in, your path would be:\n>\n> m / purpose' / wallet' / coin_type / cosigner_index / change / address_index\n>\n> XPUB's generated from your wallet would then be compatible with XPUB's\n> generated by other multi-sig wallets like CoPay, since the\n> (cosigner_index / change / address_index) structure stays the same.\n>\n> -William Swanson\n>\n> ------------------------------------------------------------------------------\n> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT\n> Develop your own process in accordance with the BPMN 2 standard\n> Learn Process modeling best practices with Bonita BPM through live exercises\n> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_\n> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "William Swanson",
                "date": "2015-04-10T02:02:32",
                "message_text_only": "Hello Alan,\nYour scheme is basically the same as the BIP45 scheme, except that you\nhave collapsed the \"cosigner_index\" and \"change\" fields into a single\nfield with the formula:\n\n    combined = 2*cosigner_index + change\n\nThis removes one level from the hierarchy, but ultimately produces the\nsame number and type of chains as BIP45 (just addressed differently).\n\nI kinda like the BIP45's approach of giving each field has its own\ndedicated purpose. What is the motivation behind flattening the\nhierarchy?\n\nI ask because the wallet I work on, Airbitz, will be adding multi-sig\nat some point in the future, and we need to figure out what kind of HD\ntree structure we will be using. Our ideal structure would basically\nbe BIP 44 plus some \"no-collision\" logic:\n\n    m / purpose' / coin_type' / wallet' / cosigner_index / change /\naddress_index\n\nI feel like interoperability with Copay would be worth the extra HD\nbranch. Assuming Kefkius adds similar no-collision logic, his proposal\nis pretty close to our ideal:\n\n    m / purpose' / wallet' / coin_type / cosigner_index / change / address_index\n\nOf course, I am open to hearing your thoughts on this as well.\n\n-William\n\nOn Thu, Apr 9, 2015 at 3:37 PM, Alan Reiner <etotheipi at gmail.com> wrote:\n> BTW, I had originally proposed a \"no-collision\" scheme for\n> multi-signature wallets, which doesn't require modifying the key tree\n> structure at all, except for adding new internal and external chains\n> (2*N chains).  All siblings watch all chains, but only generate\n> receiving and change addresses on their two chains.\n>\n> The original document is here, which might be educational for the\n> purposes of understand precisely the problem that needs a solution (and\n> mine is a different solution than BIP45).\n>\n> https://www.dropbox.com/s/58poxi60d8nfj5w/MultisigWalletNoCollide.pdf\n>\n> I prefer not adding even more levels to the key tree, and (IMO) it makes\n> more sense to add more chains to the wallet instead of adding a new tree\n> level (as it allows for a simpler tree in the event that you don't need\n> separate cosigners).  But I suspect that there's a certain momentum\n> behind the cosigner-index method already in BIP45?  Just throwing it out\n> there."
            },
            {
                "author": "Alan Reiner",
                "date": "2015-04-10T02:26:19",
                "message_text_only": "The motivation was that I came up with it before BIP 45 existed, but\nwasn't vocal enough about it because Armory didn't have BIP32 Multisig\ntrees implemented yet, so I didn't have a strong mental focus or\ndetermination around it.  If there's momentum behind BIP45, we should\nuse it.  I wanted to share the document because it was also created to\nbe educational on the topic of \"multisig address generation collisions\"\nas being disucussed in this thread.\n \nThough we just put in BIP44 with my modification into our new wallet\nformat (in the works), and if I was to adopt this I'd like to simply\nmerge the two.  \n\n    M / purpose' / coin' / account' / *cosigner* / change*0or1* / address\n\nFor reference my proposal (and the way I implemented it before BIP45\nexisted) is just BIP44 but with 2*N change branches instead of 2:\n\n    M / purpose' / coin' / account' / change*2N* / address\n\nOur new code has the goal of being able to easily reconfigure your BIP32\ntree for your specific application.  But for the default\nfree-public-download software, it would be nice to have a standard\neveryone agrees to.  BIP44 vs original-BIP32 doesn't really matter since\nyou only transfer the account branches, but this particular decision\nwith how the consigners avoid \"collisions\" does affect it. \n\n-Alan\n\n\nOn 04/09/2015 10:02 PM, William Swanson wrote:\n> Hello Alan,\n> Your scheme is basically the same as the BIP45 scheme, except that you\n> have collapsed the \"cosigner_index\" and \"change\" fields into a single\n> field with the formula:\n>\n>     combined = 2*cosigner_index + change\n>\n> This removes one level from the hierarchy, but ultimately produces the\n> same number and type of chains as BIP45 (just addressed differently).\n>\n> I kinda like the BIP45's approach of giving each field has its own\n> dedicated purpose. What is the motivation behind flattening the\n> hierarchy?\n>\n> I ask because the wallet I work on, Airbitz, will be adding multi-sig\n> at some point in the future, and we need to figure out what kind of HD\n> tree structure we will be using. Our ideal structure would basically\n> be BIP 44 plus some \"no-collision\" logic:\n>\n>     m / purpose' / coin_type' / wallet' / cosigner_index / change /\n> address_index\n>\n> I feel like interoperability with Copay would be worth the extra HD\n> branch. Assuming Kefkius adds similar no-collision logic, his proposal\n> is pretty close to our ideal:\n>\n>     m / purpose' / wallet' / coin_type / cosigner_index / change / address_index\n>\n> Of course, I am open to hearing your thoughts on this as well.\n>\n> -William\n>\n> On Thu, Apr 9, 2015 at 3:37 PM, Alan Reiner <etotheipi at gmail.com> wrote:\n>> BTW, I had originally proposed a \"no-collision\" scheme for\n>> multi-signature wallets, which doesn't require modifying the key tree\n>> structure at all, except for adding new internal and external chains\n>> (2*N chains).  All siblings watch all chains, but only generate\n>> receiving and change addresses on their two chains.\n>>\n>> The original document is here, which might be educational for the\n>> purposes of understand precisely the problem that needs a solution (and\n>> mine is a different solution than BIP45).\n>>\n>> https://www.dropbox.com/s/58poxi60d8nfj5w/MultisigWalletNoCollide.pdf\n>>\n>> I prefer not adding even more levels to the key tree, and (IMO) it makes\n>> more sense to add more chains to the wallet instead of adding a new tree\n>> level (as it allows for a simpler tree in the event that you don't need\n>> separate cosigners).  But I suspect that there's a certain momentum\n>> behind the cosigner-index method already in BIP45?  Just throwing it out\n>> there.\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150409/752836a9/attachment.html>"
            },
            {
                "author": "Vertoe Qhor",
                "date": "2015-04-16T13:11:01",
                "message_text_only": "I'm supporting this proposal and since I'm already using the Encompass\nwallet software I would like to highlight that this use case is not only\npractical but has already a working reference implementation.\n\nThe only donwside I see is that it means we get yet another HD wallet\ndefinition.\n\nIs there anything else what would speak against assigning a BIP number\nto this proposal? This would allow kefkius and his team to use the\nstandard in Encompass and share it with other software packages which\nmight be interested in using deterministic cross-currency wallets.\n\nOn 04/09/2015 10:16 PM, Kefkius wrote:\n> William,\n>\n> I've amended the proposal's \"Motivation\" section slightly for\n> clarification. I'm not sure how a \"cosigner_index\" branch would benefit\n> this proposal. Granted, I don't fully understand the benefits of the\n> \"cosigner_index\" branch in BIP-0045. From what I understand, the\n> \"wallet\" branch of my proposal seems to accomplish a similar goal.\n>\n> Jona,\n>\n> Your explanation is correct. As for this being appropriate as a BIP, I\n> agree that it's an arguable point to say it improves Bitcoin. However,\n> this proposal exists because of BIP-0044, which also describes a\n> multi-currency hierarchy. For that reason, I think this is an\n> appropriate proposal.\n>\n> Thank you both for your feedback.\n>\n> On 04/08/2015 12:41 PM, William Swanson wrote:\n>> Oops, sorry I missed that.\n>>\n>> Since that's the reason this proposal exists, I would consider putting\n>> it right up top where people can see it. Also, since this proposal is\n>> specifically designed for multi-sig, I would look at what BIP45 is\n>> doing and maybe incorporate a \"cosigner_index\" branch. Otherwise, this\n>> idea seems like a reasonable way to organize a wallet.\n>>\n>> -William\n>>\n>> On Wed, Apr 8, 2015 at 9:28 AM, \u6728\u30ce\u4e0b\u3058\u3087\u306a <kinoshitajona at gmail.com> wrote:\n>>> William,\n>>>\n>>> I believe the reasoning for this is stated in the Coin Type section.\n>>>\n>>> \"Public derivation is used so that cosigners need only know one of each\n>>> other's public keys, rather than needing to distribute public keys for each\n>>> coin.\"\n>>>\n>>> BIP44 has a coin level, but it's a private derived level, so cosigners would\n>>> not be able to generate multiple crypto currencies of each others' without\n>>> giving each other n xpubs where n is the number of currencies shared. This\n>>> new proposal basically sticks coin type on the public derivation side of\n>>> things so that I could generate litecoin or darkcoin multisigs without your\n>>> permission...\n>>>\n>>> Kefkius,\n>>>\n>>> This BIP seems like a good fit for multi-currency wallets based on multisig.\n>>> So kudos for putting it in writing.\n>>>\n>>> However, I don't know if this is really a BIP thing. It's not improving\n>>> Bitcoin (Bitcoin Improvement Proposal... remember?), in fact, by definition\n>>> it is improving altcoin usability.\n>>>\n>>> For that reason alone I will say I disagree for a BIP for this.\n>>> - Jona\n>>>\n>>>\n>>> 2015-04-08 16:46 GMT+09:00 William Swanson <swansontec at gmail.com>:\n>>>> It's not really clear why this is better than BIP 44 as it already\n>>>> stands. You have the same fields, but they are just in a different\n>>>> order. Couldn't you just use the existing BIP 44 hierarchy, but add\n>>>> the convention that \"wallet/account N\" is the same wallet in each\n>>>> supported currency?\n>>>>\n>>>> For example, if I have a wallet called \"business expenses\", which\n>>>> happens to be wallet m / 44' / 0' / 5', for Bitcoin, then the same\n>>>> wallet would be m / 44' / 3' / 5' for Dogecoin, and m / 44' / 2' / 5'\n>>>> for Litecoin.\n>>>>\n>>>> I am trying to think of examples where your proposal is better than\n>>>> BIP 44, but I can't think of any. Even backup recovery works fine. I\n>>>> assume that your idea is to continue iterating over the different\n>>>> wallet indices as long as you are finding funds in *any* currency.\n>>>> Well, you can still do that with BIP 44. The fields are in a different\n>>>> order, but that doesn't affect the algorithm in any way.\n>>>>\n>>>> Maybe you have some deeper insight I'm not seeing, but if so, you need\n>>>> to clearly explain that in your motivation section. The current\n>>>> explanation, \"This limits the possible implementations of\n>>>> multi-currency, multisignature wallets,\" is pretty vauge. Also, there\n>>>> is nothing in this spec that addresses the multisignature use-case.\n>>>> The BIP 45 spec does a lot of extra work to make multisignature work\n>>>> smoothly.\n>>>>\n>>>> I'm not trying to criticize your proposal. I'm just trying to\n>>>> understand what it's trying to accomplish.\n>>>>\n>>>> -William Swanson\n>>>>\n>>>>\n>>>> On Wed, Apr 8, 2015 at 12:05 AM, Kefkius <kefkius at maza.club> wrote:\n>>>>> I have a potential BIP, \"Multi-Currency Hierarchy For Use In\n>>>>> Multisignature Deterministic Wallets.\" I'm requesting discussion on it,\n>>>>> and possibly assignment of a BIP number.\n>>>>>\n>>>>> It's located in this github gist:\n>>>>> https://gist.github.com/Kefkius/1aa02945e532f8739023\n>> ------------------------------------------------------------------------------\n>> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT\n>> Develop your own process in accordance with the BPMN 2 standard\n>> Learn Process modeling best practices with Bonita BPM through live exercises\n>> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_\n>> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n> ------------------------------------------------------------------------------\n> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT\n> Develop your own process in accordance with the BPMN 2 standard\n> Learn Process modeling best practices with Bonita BPM through live exercises\n> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_\n> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            }
        ],
        "thread_summary": {
            "title": "Request For Discussion / BIP number - Multi-Currency Hierarchy For Use In Multisignature Deterministic Wallets",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "William Swanson",
                "\u6728\u30ce\u4e0b\u3058\u3087\u306a",
                "Alan Reiner",
                "Vertoe Qhor",
                "Kefkius"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 34622
        }
    },
    {
        "title": "[Bitcoin-development] Build your own nHashType",
        "thread_messages": [
            {
                "author": "Stephen Morse",
                "date": "2015-04-08T19:50:02",
                "message_text_only": "Seeking feedback on a proposal that will allow a transaction signer to\nexplicitly specify what is to be serialized for the signature hash. The\nbasic idea is to make the nHashType general enough that we won't need a new\nsighash flag every time a new use case comes up.\n\nIf implemented into bitcoin (via a soft fork), this would make malleability\nalmost a non-issue (the TXID referenced by inputs just need to be updated\nprevious TX changes) and would enable hardware wallets to securely sign\nwithout needing to download/process each transaction it spends from.\n\nPlease let me know your thoughts.\n\nhttps://github.com/scmorse/bitcoin-misc/blob/master/sighash_proposal.md\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150408/268ef2b5/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2015-04-09T11:29:43",
                "message_text_only": "Hi Stephen,\n\nIt's an interesting idea. I'm not sure that all the combinations make\nsense. Excluding the connected output script or value but still signing the\nprev tx hash appears pointless: the script cannot change anyway, and you\nstill need to know what it is to actually calculate the inputs to it, so\nwhat is the point of this?\n\nI also worry that quite a few of these combinations could be unexpectedly\ndangerous. If you don't sign the prevout hash or value and combine it with\na regular pay-to-address output then you've effectively written a blank\ncheque that can be used by anyone, to claim any money ever sent to that\naddress ... no? And then any p2p node or miner could do so, making the\ntransaction pretty useless.\n\nThat isn't inherently a problem as long as people understand which\ncombinations have what effects or cannot be used for various reasons. But\nit would need good documentation and careful thought to explore each\npossibility people might use.\n\nI'll leave the soft fork business to one side for now. I think any change\nin CHECKSIG or new version of it would likely be ready around the same time\nas the hard fork we need for changing the block size limit anyway, and it's\nmuch cleaner to do it that way.\n\nThe most important change that we need in sighash calculation, IMO, is\nensuring that you don't have to hash data over and over again without a\ngood reason. The current sighash definition is unfortunate because it's\npossible to make small transactions that involve hashing huge amounts of\ndata. It's not clear to me that your proposal fixes that: ideally there\nwould be one exactly one sighash for one transaction no matter how many\nchecksigs are involved in verifying it.\n\nthanks,\n-mike\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150409/4579e124/attachment.html>"
            },
            {
                "author": "Stephen Morse",
                "date": "2015-04-09T14:10:43",
                "message_text_only": "Hi Mike,\n\nHi Stephen,\n>\n> It's an interesting idea. I'm not sure that all the combinations make\n> sense. Excluding the connected output script or value but still signing the\n> prev tx hash appears pointless: the script cannot change anyway, and you\n> still need to know what it is to actually calculate the inputs to it, so\n> what is the point of this?\n>\n\nThat's a good point, maybe SIGHASH_WITHOUT_PREV_SCRIPTPUBKEY and\nSIGHASH_WITHOUT_PREV_VALUE should be assumed false, since you need the data\nanyway. That gets the total number of flags down to 17. If we eliminate\nSIGHASH_WITHOUT_TX_VERSION (I can't think of any good reason for this one),\nthen we're down to a 2-byte nHashType. SIGHASH_SIGN_STACK_ELEMENT could\nalso be removed, I'm not convinced of the usefulness of that one either.\n\n\n>\n> I also worry that quite a few of these combinations could be unexpectedly\n> dangerous. If you don't sign the prevout hash or value and combine it with\n> a regular pay-to-address output then you've effectively written a blank\n> cheque that can be used by anyone, to claim any money ever sent to that\n> address ... no? And then any p2p\n>\nnode or miner could do so, making the transaction pretty useless.\n>\n> That isn't inherently a problem as long as people understand which\n> combinations have what effects or cannot be used for various reasons. But\n> it would need good documentation and careful thought to explore each\n> possibility people might use.\n>\n\nI don't think it's quite a blank check, but it would enable replay attacks\nin the form of sending the money to the same place it was sent before if an\naddress ever receives coins again. Almost like auto-forwarding addresses.\nIf, in addition, you signed with just that input and no outputs as well,\nthen you're basically forfeiting your rights to any coins sent to that\naddress.\n\nIt allows for some dangerous combinations, but we already have some\ndangerous nHashTypes. e.g. SIGHASH_NONE | SIGHASH_ANYONECANPAY. Good\ndocumentation and careful developers shouldn't have any issues if they use\na standard set of sighash flag combinations for their standard use cases.\nBut developers that need special combinations can now use them, so long as\nthey are careful and think things through.\n\n\n>\n> I'll leave the soft fork business to one side for now. I think any change\n> in CHECKSIG or new version of it would likely be ready around the same time\n> as the hard fork we need for changing the block size limit anyway, and it's\n> much cleaner to do it that way.\n>\n> The most important change that we need in sighash calculation, IMO, is\n> ensuring that you don't have to hash data over and over again without a\n> good reason. The current sighash definition is unfortunate because it's\n> possible to make small transactions that involve hashing huge amounts of\n> data. It's not clear to me that your proposal fixes that: ideally there\n> would be one exactly one sighash for one transaction no matter how many\n> checksigs are involved in verifying it.\n>\n>\nIt's hard, though, because there is different data needs to be signed for\neach input. Although, I suppose if you signed your input with\nSIGHASH_WITHOUT_PREV_SCRIPTPUBKEY, SIGHASH_WITHOUT_PREV_VALUE, and the\nequivalent of SIGHASH_ALL, then the hash that needs to be signed would be\nthe same for all of your inputs. Strangely enough, I think we might have\njust found use cases for the flags that we had nearly dismissed.\n\nAnother possibility would be to put the previous scriptPubKey and previous\noutput value at the END of the serialized transaction, so that you could\nmake use of some sort of a signature hash midstate. But that feels a little\nmessy. It sort of makes sense to have a base serialization for a\ntransaction and then append it with whatever input/output specific\ninformation you have, but still, messy.\n\nIs hashing transaction data once for each input really a huge bottleneck,\nthough? Do mobile devices have an issue with this?\n\nBest,\nStephen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150409/8fc6b376/attachment.html>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2015-04-09T14:22:52",
                "message_text_only": "On Thu, Apr 9, 2015 at 7:10 AM, Stephen Morse <stephencalebmorse at gmail.com>\nwrote:\n\n> Is hashing transaction data once for each input really a huge bottleneck,\n> though? Do mobile devices have an issue with this?\n>\n\n\nThink about what slow transaction verification speed means.  Slower\npropagation across the network.  More work per node.  Greater opportunity\nfor algorithmic attacks, races and other shenanigans by attackers.\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150409/dbb8cb15/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2015-04-09T17:28:09",
                "message_text_only": "On Thu, Apr 09, 2015 at 07:22:52AM -0700, Jeff Garzik wrote:\n> On Thu, Apr 9, 2015 at 7:10 AM, Stephen Morse <stephencalebmorse at gmail.com>\n> wrote:\n> \n> > Is hashing transaction data once for each input really a huge bottleneck,\n> > though? Do mobile devices have an issue with this?\n> >\n> \n> \n> Think about what slow transaction verification speed means.  Slower\n> propagation across the network.  More work per node.  Greater opportunity\n> for algorithmic attacks, races and other shenanigans by attackers.\n\nKeep in mind though we can always make part of the soft-fork be to make\nthe hash operations in the new CHECKSIG mechanism consume sigops.\n\nFor the OP: Have you looked at how CODESEPARATOR allows the signature to\nsign code to run as part of verifying the signature? E.g. my signature\ncan say \"valid if you run these additional opcodes and they return true\"\nwhere those additional opcodes take the transaction, hash it in the\ndefined way, and verify that the ECC signature correctly signs that\nhash and the hash of the additional opcodes. For instance in this case\nmaking a signature that's only valid if the tx fee is less than the\ndefined amount would be a matter of GET_FEE <max fee + 1> LESSTHAN VERIFY\n\nThis can be a much more general mechanism with easy to test modular\nopcodes; for the consensus-critical codebase this can result in a much\neasier and simpler to test CHECKSIG facility than a dozen new flags.\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000006975f442f50caa4fcc18e165746b3c77b641b75635afecb\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 650 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150409/3b1563d4/attachment.sig>"
            },
            {
                "author": "Stephen Morse",
                "date": "2015-04-10T02:56:20",
                "message_text_only": "Regarding the re-hashing the transaction data once per input being a\nbottleneck, I was mistakenly only thinking about this from the point of\nview of the signer. Full nodes have to check all transactions' inputs,\nwhich is much more costly, as the link Gavin posted shows.\n\nOn Thu, Apr 9, 2015 at 10:45 AM, Mike Hearn <mike at plan99.net> wrote:\n>\n> Right, good point. I wonder if this sort of auto forwarding could even be\n> a useful feature. I can't think of one right now.\n>\n\nI can think of a few convoluted use cases, but not any good ones. People\nhave definitely looked for this feature before, though, just look at this\nBitcoin SE post\n<http://bitcoin.stackexchange.com/questions/1495/is-there-a-way-to-automatically-send-bitcoins-from-one-wallet-to-another>.\nI think there are better ways to handle key management than\nauto-forwarding, though. Anyone looking for this feature probably just\nwasn't aware that there are better solutions.\n\nOn Thu, Apr 9, 2015 at 10:45 AM, Mike Hearn <mike at plan99.net> wrote:\n>\n> Yes but is that fundamental or is there a way to avoid it? That's what I'm\n> getting at.\n>\n\nIn the bitcointalk article referenced, Sergio actually gave us the answer:\n\n> Hash(Tx,previn-index) = Hash ( Hash(outputs) || Hash\n(Inputs-with-script-cleared) || <previn-index> )\n>   (for SIGHASH_ALL)\n>   This way the values \"Hash(outputs)\" and\n\"Hash(Inputs-with-script-cleared)\" can be cached and reused.\n\nBasically, just re-order the way stuff is serialized. Put the stuff that is\nnearly always signed at the beginning, and vice versa. I'll see if I can\nupdate the proposal to make this optimization possible. What I suspect,\nthough, is that with all the new controls, blocks with ordinary\ntransactions will verify faster, but an attacker could still create a very\nCPU intensive block by signing inputs with a wide variety of nHashTypes and\nthen signing the last one with the equivalent of SIGHASH_ALL. I don't think\nthat's a big limitation, though, the attack is already somewhat possible,\nand would be very hard to do, and doesn't really gain the attacker anything\n(other than infamy).\n\nOn Thu, Apr 9, 2015 at 1:28 PM, Peter Todd <pete at petertodd.org> wrote:\n\n> For the OP: Have you looked at how CODESEPARATOR allows the signature to\n> sign code to run as part of verifying the signature? E.g. my signature\n> can say \"valid if you run these additional opcodes and they return true\"\n> where those additional opcodes take the transaction, hash it in the\n> defined way, and verify that the ECC signature correctly signs that\n> hash and the hash of the additional opcodes. For instance in this case\n> making a signature that's only valid if the tx fee is less than the\n> defined amount would be a matter of GET_FEE <max fee + 1> LESSTHAN VERIFY\n>\n\nI've never been able to really see a good use case for OP_CODESEPARATOR,\nand I'm not sure I completely have my head wrapped around what you're\nproposing. From this\n<http://bitcoin.stackexchange.com/questions/34013/what-is-op-codeseparator-used-for>\n and this\n<https://bitcointalk.org/index.php?topic=52949.msg631255#msg631255>,\nthough, it seems like OP_CODESEPARATOR cannot really be made useful unless\nyou already have a way to sign without hashing the TXIDs referenced by your\ninput, in which case you need to modify the nHashType.\n\nBest,\nStephen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150409/f55fb600/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2015-04-18T23:33:52",
                "message_text_only": "On Thu, Apr 09, 2015 at 10:56:20PM -0400, Stephen Morse wrote:\n> On Thu, Apr 9, 2015 at 1:28 PM, Peter Todd <pete at petertodd.org> wrote:\n> \n> > For the OP: Have you looked at how CODESEPARATOR allows the signature to\n> > sign code to run as part of verifying the signature? E.g. my signature\n> > can say \"valid if you run these additional opcodes and they return true\"\n> > where those additional opcodes take the transaction, hash it in the\n> > defined way, and verify that the ECC signature correctly signs that\n> > hash and the hash of the additional opcodes. For instance in this case\n> > making a signature that's only valid if the tx fee is less than the\n> > defined amount would be a matter of GET_FEE <max fee + 1> LESSTHAN VERIFY\n> >\n> \n> I've never been able to really see a good use case for OP_CODESEPARATOR,\n> and I'm not sure I completely have my head wrapped around what you're\n> proposing. From this\n> <http://bitcoin.stackexchange.com/questions/34013/what-is-op-codeseparator-used-for>\n>  and this\n> <https://bitcointalk.org/index.php?topic=52949.msg631255#msg631255>,\n> though, it seems like OP_CODESEPARATOR cannot really be made useful unless\n> you already have a way to sign without hashing the TXIDs referenced by your\n> input, in which case you need to modify the nHashType.\n\nI wrote up how to do this on #bitcoin-wizards, Dec 9th 2014:\n\n17:13 < petertodd> hearn: even now you can use OP_CODESEPARATOR to\nimplement efficient payword schemes\n17:14 < petertodd> hearn: early on you could have used it to do some\nreally useful after-the-fact signing delegation by wrapping a IF ENDIF\naround the CODESEPARATOR introduced into the middle of the\nscriptSig/scriptPubKey pair - shame we got rid of that without thinking\nthe design through\n17:15 < petertodd> hearn: e.g. \"create a signature that delegates\nsigning authority to another pubkey\"\n17:15 < petertodd> probably all 100% accidental... but a nice accident\n17:16 < hearn> it's probably for the best. i can imagine such things\nbeing a surprise for implementations not expecting them. a script 2.0\neffort that incorporates lots of neat features but still lets script 1.0\nwork would be nice to have, one day\n17:17 < petertodd> satoshi belived in 1 implementation, and by putting\nCODESEPARATOR into the scriptSig/scriptPubKey concatenation you had to\nopt-in to making that feature possible to use in any particular\nscriptPubKey\n17:17 < petertodd> w/o the mis-matched ENDIF you can't pull off that\ntrick because you can't turn CODESEPARATOR off\n17:19 < petertodd> to be explicit: scriptPubKey: ENDIF <pubkey>\nCHECKSIG, then the normal case is scriptSig: <signature> 1 IF\n17:19 < petertodd> they concatenate to  <signature> 1 IF ENDIF <pubkey>\nCHECKSIG, CODESEPARATOR is evaluated, and the signature is evaluated on\nthe script ENDIF <pubkey> CHECKSIG\n17:20 < petertodd> to delegate signing authority after the fact sign a\nsignature on the script <pubkey2> 0 IF ENDIF <pubkey> CHECKSIG\n17:21 < petertodd> (remember that CODESEPARATORS are removed by\nSignatureHash())\n17:22 < petertodd> oops, I mean: <pubkey2> CHECKSIGVERIFY 0 IF ENDIF\n<pubkey> CHECKSIG\n17:22 < petertodd> anyway, to finally spend it, create another signature\nwith pubkey2 signing the script <pubkey2> CHECKSIGVERIFY 0 IF ENDIF\n<pubkey> CHECKSIG again, and finally spend it with the scriptSig:\n<pubkey-sig> <pubkey2-sig> CODESEPARATOR <pubkey2> 0 IF\n17:24 < petertodd> after concatenation the script: <pubkey-sig>\n<pubkey2-sig> CODESEPARATOR <pubkey2> 0 IF CODESEPARATOR ENDIF <pubkey>\nCHECKSIG is evaluated, the inner signature satisfies, and the outer\nsignature is satisfied only if the scriptPubKey was essentially changed\nafter the fact to also require the inner, second, pubkey2 to be\nsatisfied\n17:26 < petertodd> a nice use-case would, forinstance, have been to have\na signing robot be able to create signatures offline for a given txout\nwith SIGHASH_SINGLE such that you had a spending limit enforced, and\nexactly who was then allowed to spend the funds - say a department of a\ncompany - could be picked after the fact without re-spending the txout\n17:33 < petertodd> gmaxwell: re: script validation state, a good model\nwould be to have the tx input to EvalScript() essentially be a\nCMerkleTx, and the prevout scriptPubKey be the prevout CTxOut (*maybe*\nthe prevout tx itself... bit dubious there...)\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000000e7980aab9c096c46e7f34c43a661c5cb2ea71525ebb8af7\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 650 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150418/c061fc49/attachment.sig>"
            },
            {
                "author": "Mike Hearn",
                "date": "2015-04-09T14:45:35",
                "message_text_only": ">\n> I don't think it's quite a blank check, but it would enable replay attacks\n> in the form of sending the money to the same place it was sent before if an\n> address ever receives coins again.\n>\n\nRight, good point. I wonder if this sort of auto forwarding could even be a\nuseful feature. I can't think of one right now.\n\n\n> It's hard, though, because there is different data needs to be signed for\n> each input.\n>\n\nYes but is that fundamental or is there a way to avoid it? That's what I'm\ngetting at.\n\n\n> Another possibility would be to put the previous scriptPubKey and previous\n> output value at the END of the serialized transaction, so that you could\n> make use of some sort of a signature hash midstate.\n>\n\nInteresting idea! I don't agree it's messy. If anything it should be\nsimpler than what we have today - the need to edit a transaction *in the\nmiddle* means that sighash computation involves constantly reserializing a\ntransaction before it even gets to be hashed.\n\n\n> Is hashing transaction data once for each input really a huge bottleneck,\n> though? Do mobile devices have an issue with this?\n>\n\nConsider what happens with very large transactions, like a big assurance\ncontract that might have thousands of inputs and be multiple megabytes in\nsize. Obviously such large transactions cannot happen today, but there is\nuser demand for giant contracts (or at least, users tell me there is,\nwhether they'd actually do it for real is a bit unclear).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150409/faa89170/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2015-04-15T03:34:50",
                "message_text_only": "On Wed, Apr 8, 2015 at 7:50 PM, Stephen Morse\n<stephencalebmorse at gmail.com> wrote:\n> Seeking feedback on a proposal that will allow a transaction signer to\n> explicitly specify what is to be serialized for the signature hash. The\n> basic idea is to make the nHashType general enough that we won't need a new\n> sighash flag every time a new use case comes up.\n>\n> If implemented into bitcoin (via a soft fork), this would make malleability\n> almost a non-issue (the TXID referenced by inputs just need to be updated\n> previous TX changes) and would enable hardware wallets to securely sign\n> without needing to download/process each transaction it spends from.\n\nI'm not sure if I'm super fond of that particular non-programmatic but\nmany options approach; It sort of has the problem that there are\nrelatively few useful options that don't rapidly extend into a choose\nyour own adventure with too many options to count; so you take a\ncomplexity penalty perhaps without a matching functionality payoff.\n\nbut thats not why I'm commenting...\n\nI wonder if anyone noticed that any sighash masking that eliminates\nthe txin txid enables covenants?\n\nCovenants are payments which constrain their future payments (like\ndeed covenants), I've written about them in the past\nhttps://bitcointalk.org/index.php?topic=278122.0  ... they can\nsometimes be pretty useful but are also potentially a irritating hit\nto fungibility, at least if used stupidly.\n\nthe approach here is that you make the scriptpubkey contain \"[push:\n0x30, 0x06, 0x02, 0x01, 0x04, 0x02, 0x01, 0x04, flags] [push pubkey\nresulting from pubkey recovery] OP_CHECKSIG\"  and set the flags to\nmatch only the things you want to enforce in the spending transaction\nhash them up and recover the EC public point.   You can think of that\nconstruct as giving a you a OP_MASKED_TRANSACTION_HASH_EQUALS  ... the\nrecovered pubkey is just a kind of message hash, though a weird and\nexpensive to compute one.\n\nI don't currently see how to get a perpetual covenant out of it-- e.g.\na coin that anyone can spend, but only to its same scriptpubkey, (the\nobvious way requires the ability to be able to checksig stuff on the\nstack) though I wouldn't be shocked if it were possible with a\nsufficiently complex sighash flag and nothing else."
            }
        ],
        "thread_summary": {
            "title": "Build your own nHashType",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Stephen Morse",
                "Mike Hearn",
                "Peter Todd",
                "Gregory Maxwell"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 21516
        }
    },
    {
        "title": "[Bitcoin-development] Double spending and replace by fee",
        "thread_messages": [
            {
                "author": "Adrian Macneil",
                "date": "2015-04-09T06:28:08",
                "message_text_only": "Fwiw, Coinbase relies on the current first-seen mempool behaviour. Wide adoption of RBF (without a suitable replacement available) would make it extremely difficult to pitch bitcoin as a viable alternative to credit cards payments to large merchants.\n\nAdrian\n\n> On Mar 28, 2015, at 7:22 AM, Peter Todd <pete at petertodd.org> wrote:\n> \n> Signed PGP part\n> Would you so us all a favor and make a list of companies *actually* relying on \"first-seen\" mempool behaviour. Because I've been having a hard time actually finding anyone who does who hasn't given up on it. Not very useful to talk about attacks against hypothetical defences.\n> \n> On 28 March 2015 09:58:53 GMT-04:00, Mike Hearn <mike at plan99.net> wrote:\n> >I've written a couple of blog posts on replace by fee and double\n> >spending\n> >mitigations. They sum up the last few years (!) worth of discussions on\n> >this list and elsewhere, from my own perspective.\n> >\n> >I make no claim to be comprehensive or unbiased but I keep being asked\n> >about these topics so figured I'd just write up my thoughts once so I\n> >can\n> >send links instead of answers :) And then so can anyone who happens to\n> >agree.\n> >\n> >(1) Replace by fee scorched earth, a counter argument:\n> >\n> >https://medium.com/@octskyward/replace-by-fee-43edd9a1dd6d\n> >\n> >This article lays out the case against RBF-SE and argues it is harmful\n> >to\n> >Bitcoin.\n> >\n> >(2) Double spending and how to make it harder:\n> >\n> >https://medium.com/@octskyward/double-spending-in-bitcoin-be0f1d1e8008\n> >\n> >This article summarises a couple of double spending incidents against\n> >merchants and then discusses the following techniques:\n> >\n> >   1. Risk analysis of transactions\n> >   2. Payment channels\n> >   3. Countersigning by a trusted third party\n> >   4. Remote attestation\n> >   5. ID verification\n> >   6. Waiting for confirmations\n> >   7. Punishment of double spending blocks\n> >\n> >I hope the material is useful / interesting.\n> >\n> >\n> >------------------------------------------------------------------------\n> >\n> >------------------------------------------------------------------------------\n> >Dive into the World of Parallel Programming The Go Parallel Website,\n> >sponsored\n> >by Intel and developed in partnership with Slashdot Media, is your hub\n> >for all\n> >things parallel software development, from weekly thought leadership\n> >blogs to\n> >news, videos, case studies, tutorials and more. Take a look and join\n> >the\n> >conversation now. http://goparallel.sourceforge.net/\n> >\n> >------------------------------------------------------------------------\n> >\n> >_______________________________________________\n> >Bitcoin-development mailing list\n> >Bitcoin-development at lists.sourceforge.net\n> >https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> \n> \n> \n> ------------------------------------------------------------------------------\n> Dive into the World of Parallel Programming The Go Parallel Website, sponsored\n> by Intel and developed in partnership with Slashdot Media, is your hub for all\n> things parallel software development, from weekly thought leadership blogs to\n> news, videos, case studies, tutorials and more. Take a look and join the\n> conversation now. http://goparallel.sourceforge.net/\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 801 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150408/35a58f48/attachment.sig>"
            },
            {
                "author": "Peter Todd",
                "date": "2015-04-21T11:37:14",
                "message_text_only": "On Wed, Apr 08, 2015 at 11:28:08PM -0700, Adrian Macneil wrote:\n> Fwiw, Coinbase relies on the current first-seen mempool behaviour. Wide adoption of RBF (without a suitable replacement available) would make it extremely difficult to pitch bitcoin as a viable alternative to credit cards payments to large merchants.\n\nSome questions:\n\n1) Are you contractually obliged to accept zeroconf transactions with\n   existing customers?\n\nI keep hearing rumors of this, but would like some confirmation. In\nparticular, it would be good to know if you have the option of turning\nzeroconf off at all, contractually speaking.\n\n\n2) What are your double-spend losses to date?\n\n3) Are you actively marketing zeroconf guarantees to new customers?\n\nYou're API is a bit unclear as to what exactly those guarantees are;\nlooks like they only apply if a merchant has \"convert to fiat\" turned\non.\n\n\n4) What are your short, medium, and long term plans to move away from\n   dependency on \"first-seen\" mempool policy?\n\ne.g. hub-and-spoke payment channels, Lightning network, off-chain, etc.\n\n\n5) What is your plan for new Bitcoin Core releases that break zeroconf\n   via changed tx acceptance rules?\n\nBasically every release we've ever made has added a zeroconf exploit due\nto different tx acceptance rules. (e.g. my 95% success rate last summer)\n\n\n6) What are your plans for Bitcoin Core releases that fundementally\n   break zeroconf?\n\nFor instance changes like limiting the mempool size create zeroconf\nvulnerabilities that can't be avoided in many situations. Yet they may\nalso be unavoidably needed for, for instance, DoS protection. Will you\noppose these improvements?\n\n\n7) If a mining pool adopts adopted policy that broke zeroconf, e.g.\n   replace-by-fee, would you take any action?\n\n8) Would you take legal action against a mining pool for adopting\n   replace-by-fee publicly?\n\n9) Would you take action against a mining pool who is mining\n   double-spends without explanation?\n\ne.g. one that claims not to be running non-Bitcoin Core policy, but\nkeeps on mining double-spends.\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000000089abd68efc18c03d2a294295f3706a13966613a3ff3b390\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 650 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150421/af46a460/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Double spending and replace by fee",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Adrian Macneil",
                "Peter Todd"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 6199
        }
    },
    {
        "title": "[Bitcoin-development] DevCore London",
        "thread_messages": [
            {
                "author": "Mike Hearn",
                "date": "2015-04-09T20:23:52",
                "message_text_only": "Next week on April 15th Gavin, Wladimir, Corey and myself will be at\nDevCore London:\n\n   https://everyeventgives.com/event/devcore-london\n\nIf you're in town why not come along?\n\nIt's often the case that conferences can be just talking shops, without\nmuch meat for real developers. So in the afternoon I'll be doing two things:\n\n   1. Running a hackathon/workshop type event. The theme is contracts, but\n   we can hack on whatever you all feel like.\n\n   2. My \"talk\" will actually be a live coding event. Writing contracts\n   apps has become a lot easier in the past few years, and to prove it to you\n   I will write a decentralised cross-platform Tor supporting document\n   timestamping app that uses OP_RETURN outputs and has a nice GUI ..... in 30\n   minutes, on stage.\n\n   Don't think it can be done? Turn up and see for yourself.\n\nSee you there!\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150409/3b14e689/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "DevCore London",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Mike Hearn"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1032
        }
    },
    {
        "title": "[Bitcoin-development] Some interviews from Amsterdam 2014",
        "thread_messages": [
            {
                "author": "Michael Wechner",
                "date": "2015-04-09T20:31:02",
                "message_text_only": "Greetings\n\nI did four interviews at the bitcoin conference Amsterdam 2014 with\n\n- Gavin Andresen\n- Peter Surda\n- Patrick Byrne\n- Stefan Thomas\n\nwhich I have finally published at\n\nhttps://www.youtube.com/user/WYONAPICTURES\n\nHope you like them :-)\n\nThanks\n\nMichael"
            }
        ],
        "thread_summary": {
            "title": "Some interviews from Amsterdam 2014",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Michael Wechner"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 262
        }
    },
    {
        "title": "[Bitcoin-development] Bitcoin Core 0.10.1 release candidate 2 available",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2015-04-10T08:46:50",
                "message_text_only": "Hello,\n\nI've just uploaded Bitcoin Core 0.10.1rc2 executables to:\n\nhttps://bitcoin.org/bin/bitcoin-core-0.10.1/test/\n\nThe source code can be found in git under the tag 'v0.10.1rc2'\n\nThe only change in comparison to rc1 is a fix by Gavin Andresen:\n\n- `1c62e84` Keep mempool consistent during block-reorgs\n\nThanks to everyone that participated in the gitian build process,\n\nWladimir"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.10.1 release candidate 2 available",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Wladimir J. van der Laan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 380
        }
    },
    {
        "title": "[Bitcoin-development] Deprecating Bitcoin Core's regtest-specific `setgenerate` behaviour",
        "thread_messages": [
            {
                "author": "Pieter Wuille",
                "date": "2015-04-12T14:26:12",
                "message_text_only": "Hello everyone,\n\nBitcoin Core's `setgenerate` RPC call has had a special meaning for\n-regtest (namely instantaneously mining a number of blocks, instead of\nstarting a background CPU miner).\n\nWe're planning to deprecate that overloaded behaviour, and replace it with\na separate RPC call `generate`. Is there any software or user who would\nneed compatibility with the old behaviour? We're generally very\nconservative in changing RPC behaviour, but as this is not related to any\nproduction functionality, we may as well just switch it.\n\nNote that the bitcoin.org developer documentation will need to be updated.\n\n-- \nPieter\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150412/98b98d45/attachment.html>"
            },
            {
                "author": "Sean Gilligan",
                "date": "2015-04-12T22:36:12",
                "message_text_only": "I would recommend adding the new method and deprecating (as in warning\nagainst using) the old one for one major release. Then removing it\naltogether in the following major release.\n\nI have written a Java RPC client and Groovy/Spock functional tests\n<https://github.com/msgilligan/bitcoin-spock> that use the current call.\nA separate `generate` or `generateblocks` call is a great idea.\n\nHowever, I try to keep my tests compatible with the current stable and\nunstable versions of Bitcoin Core (and the Omni Core fork) and would\nhave to write code that checks the RPC server version (or checks for the\npresence of the new call, falling back to the old one) to support the\nuse cases that I need to support. Not a huge deal, but I'm probably not\nthe only one.\n\n-- Sean\n\n\nOn 4/12/15 7:26 AM, Pieter Wuille wrote:\n> Hello everyone,\n>\n> Bitcoin Core's `setgenerate` RPC call has had a special meaning for\n> -regtest (namely instantaneously mining a number of blocks, instead of\n> starting a background CPU miner).\n>\n> We're planning to deprecate that overloaded behaviour, and replace it\n> with a separate RPC call `generate`. Is there any software or user who\n> would need compatibility with the old behaviour? We're generally very\n> conservative in changing RPC behaviour, but as this is not related to\n> any production functionality, we may as well just switch it.\n>\n> Note that the bitcoin.org <http://bitcoin.org> developer documentation\n> will need to be updated.\n>\n> -- \n> Pieter\n>\n>\n>\n> ------------------------------------------------------------------------------\n> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT\n> Develop your own process in accordance with the BPMN 2 standard\n> Learn Process modeling best practices with Bonita BPM through live exercises\n> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_\n> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150412/a9b2679a/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Deprecating Bitcoin Core's regtest-specific `setgenerate` behaviour",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Sean Gilligan",
                "Pieter Wuille"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3115
        }
    },
    {
        "title": "[Bitcoin-development] 75%/95% threshold for transaction versions",
        "thread_messages": [
            {
                "author": "s7r",
                "date": "2015-04-15T23:43:01",
                "message_text_only": "Hi,\n\nWould it be wise to add a consensus rule like the one we have for blocks,\n\n(if > 75% from last 1000 blocks are version 'n' mark version 'n' as\nstandard for blocks and if > 95% from the last 1000 blocks are version\n'n' mark previous block versions as invalid)\n\nbut for transaction versions? In simple terms, if > 75% from all the\ntransactions in the latest 1000 blocks are version 'n', mark all\nprevious transaction versions as non-standard and if > 95% from all the\ntransactions in the latest 1000 blocks are version 'n' mark all previous\ntransaction versions as invalid.\n\nAt this moment, the standard in consensus is v1, but nothing is enforced\nin the network related to transaction versions.\n\nRegarding BIP62, as it can be read here [0] it is said that it requires\nv2 transactions. It is also said that transaction version 2 will be\nskipped and jump directly to v3, for an even version for transactions\nand blocks (?). Might as well add the rule for invalidating previous\ntransaction versions if the majority updates - could this break anything\nor affect functionality in any way?\n\nBIP62 adds a newer transaction version which is optional and does not\nmark previous v1 as non-standard or invalid. This means bitcoin core\nwill treat both v1 and v2/v3 transactions as standard and relay/mine\nthem with the same priority, regardless of the tx version?\n\n\nThanks.\n\n[0]\nhttps://bitcoin.stackexchange.com/questions/35904/how-much-of-bip-62-dealing-with-malleability-has-been-implemented"
            },
            {
                "author": "Allen Piscitello",
                "date": "2015-04-16T02:04:09",
                "message_text_only": "If I had a time locked signed transaction where I threw away the key, this\nwould potentially invalidate my transaction.\n\nWhat is the point of such a rule?\n\nOn Wed, Apr 15, 2015 at 6:43 PM, s7r <s7r at sky-ip.org> wrote:\n\n> Hi,\n>\n> Would it be wise to add a consensus rule like the one we have for blocks,\n>\n> (if > 75% from last 1000 blocks are version 'n' mark version 'n' as\n> standard for blocks and if > 95% from the last 1000 blocks are version\n> 'n' mark previous block versions as invalid)\n>\n> but for transaction versions? In simple terms, if > 75% from all the\n> transactions in the latest 1000 blocks are version 'n', mark all\n> previous transaction versions as non-standard and if > 95% from all the\n> transactions in the latest 1000 blocks are version 'n' mark all previous\n> transaction versions as invalid.\n>\n> At this moment, the standard in consensus is v1, but nothing is enforced\n> in the network related to transaction versions.\n>\n> Regarding BIP62, as it can be read here [0] it is said that it requires\n> v2 transactions. It is also said that transaction version 2 will be\n> skipped and jump directly to v3, for an even version for transactions\n> and blocks (?). Might as well add the rule for invalidating previous\n> transaction versions if the majority updates - could this break anything\n> or affect functionality in any way?\n>\n> BIP62 adds a newer transaction version which is optional and does not\n> mark previous v1 as non-standard or invalid. This means bitcoin core\n> will treat both v1 and v2/v3 transactions as standard and relay/mine\n> them with the same priority, regardless of the tx version?\n>\n>\n> Thanks.\n>\n> [0]\n>\n> https://bitcoin.stackexchange.com/questions/35904/how-much-of-bip-62-dealing-with-malleability-has-been-implemented\n>\n>\n> ------------------------------------------------------------------------------\n> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT\n> Develop your own process in accordance with the BPMN 2 standard\n> Learn Process modeling best practices with Bonita BPM through live\n> exercises\n> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual-\n> event?utm_\n> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150415/b16356ea/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2015-04-16T05:22:00",
                "message_text_only": "On Apr 16, 2015 1:46 AM, \"s7r\" <s7r at sky-ip.org> wrote:\n> but for transaction versions? In simple terms, if > 75% from all the\n> transactions in the latest 1000 blocks are version 'n', mark all\n> previous transaction versions as non-standard and if > 95% from all the\n> transactions in the latest 1000 blocks are version 'n' mark all previous\n> transaction versions as invalid.\n\nWhat problem are you trying to solve?\n\nThe reason why BIP62 (as specified, it is just a draft) does not make v1\ntransactions invalid is because it is opt-in. The creator of a transaction\nneeds to agree to protect it from malleability, and this subjects him to\nextra rules in the creation.\n\nForcing v3 transactions would require every piece of wallet software to be\nchanged.\n\n-- \nPieter\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150415/a603225e/attachment.html>"
            },
            {
                "author": "s7r",
                "date": "2015-04-16T16:12:35",
                "message_text_only": "Hi Pieter,\n\nThanks for your reply. I agree. Allen has a good point in the previous\nemail too, so the suggestion might not fix anything and complicate things.\n\nThe problem I am trying to solve is making all transactions\nnon-malleable by default. I guess there is a very good reason why BIP62\nwill not touch v1 anyway.\n\nI am trying to build a bitcoin contract which will relay on 3 things:\n- coinjoin / txes with inputs from multiple users which are signed by\nall users after they are merged together (every user is sure his coins\nwill not be spent without the other users to spend anything, as per\nagreed contract);\n- pre-signed txes with nLockTime 'n' weeks. These txes will be signed\nbefore the inputs being spent are broadcasted/confirmed, using the txid\nprovided by the user before broadcasting it. Malleability hurts here.\n- P2SH\n\nIn simple terms, how malleable transactions really are in the network at\nthis moment? Who can alter a txid without invalidating the tx? Just the\nparties who sign it? The miners? Anyone in the network? This is a little\nbit unclear to me.\n\nAnother thing I would like to confirm, the 3 pieces of the bitcoin\nprotocol mentioned above will be supported in _any_ future transaction\nversion or block version, regardless what changes are made or features\nadded to bitcoin core? The contract needs to be built and left unchanged\nfor a very very long period of time...\n\n\nOn 4/16/2015 8:22 AM, Pieter Wuille wrote:\n> \n> On Apr 16, 2015 1:46 AM, \"s7r\" <s7r at sky-ip.org <mailto:s7r at sky-ip.org>>\n> wrote:\n>> but for transaction versions? In simple terms, if > 75% from all the\n>> transactions in the latest 1000 blocks are version 'n', mark all\n>> previous transaction versions as non-standard and if > 95% from all the\n>> transactions in the latest 1000 blocks are version 'n' mark all previous\n>> transaction versions as invalid.\n> \n> What problem are you trying to solve?\n> \n> The reason why BIP62 (as specified, it is just a draft) does not make v1\n> transactions invalid is because it is opt-in. The creator of a\n> transaction needs to agree to protect it from malleability, and this\n> subjects him to extra rules in the creation.\n> \n> Forcing v3 transactions would require every piece of wallet software to\n> be changed.\n> \n> -- \n> Pieter\n>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2015-04-16T17:34:31",
                "message_text_only": "At this moment anyone can alter the txid. Assume transactions are 100%\nmalleable.\nOn Apr 16, 2015 9:13 AM, \"s7r\" <s7r at sky-ip.org> wrote:\n\n> Hi Pieter,\n>\n> Thanks for your reply. I agree. Allen has a good point in the previous\n> email too, so the suggestion might not fix anything and complicate things.\n>\n> The problem I am trying to solve is making all transactions\n> non-malleable by default. I guess there is a very good reason why BIP62\n> will not touch v1 anyway.\n>\n> I am trying to build a bitcoin contract which will relay on 3 things:\n> - coinjoin / txes with inputs from multiple users which are signed by\n> all users after they are merged together (every user is sure his coins\n> will not be spent without the other users to spend anything, as per\n> agreed contract);\n> - pre-signed txes with nLockTime 'n' weeks. These txes will be signed\n> before the inputs being spent are broadcasted/confirmed, using the txid\n> provided by the user before broadcasting it. Malleability hurts here.\n> - P2SH\n>\n> In simple terms, how malleable transactions really are in the network at\n> this moment? Who can alter a txid without invalidating the tx? Just the\n> parties who sign it? The miners? Anyone in the network? This is a little\n> bit unclear to me.\n>\n> Another thing I would like to confirm, the 3 pieces of the bitcoin\n> protocol mentioned above will be supported in _any_ future transaction\n> version or block version, regardless what changes are made or features\n> added to bitcoin core? The contract needs to be built and left unchanged\n> for a very very long period of time...\n>\n>\n> On 4/16/2015 8:22 AM, Pieter Wuille wrote:\n> >\n> > On Apr 16, 2015 1:46 AM, \"s7r\" <s7r at sky-ip.org <mailto:s7r at sky-ip.org>>\n> > wrote:\n> >> but for transaction versions? In simple terms, if > 75% from all the\n> >> transactions in the latest 1000 blocks are version 'n', mark all\n> >> previous transaction versions as non-standard and if > 95% from all the\n> >> transactions in the latest 1000 blocks are version 'n' mark all previous\n> >> transaction versions as invalid.\n> >\n> > What problem are you trying to solve?\n> >\n> > The reason why BIP62 (as specified, it is just a draft) does not make v1\n> > transactions invalid is because it is opt-in. The creator of a\n> > transaction needs to agree to protect it from malleability, and this\n> > subjects him to extra rules in the creation.\n> >\n> > Forcing v3 transactions would require every piece of wallet software to\n> > be changed.\n> >\n> > --\n> > Pieter\n> >\n>\n>\n> ------------------------------------------------------------------------------\n> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT\n> Develop your own process in accordance with the BPMN 2 standard\n> Learn Process modeling best practices with Bonita BPM through live\n> exercises\n> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual-\n> event?utm_\n> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150416/17968d0a/attachment.html>"
            },
            {
                "author": "s7r",
                "date": "2015-04-16T23:17:53",
                "message_text_only": "On 4/16/2015 8:34 PM, Mark Friedenbach wrote:\n> At this moment anyone can alter the txid. Assume transactions are 100%\n> malleable.\n> \n\nAnyone can alter the txid - more details needed. The number of altered\ntxids in practice is not so high in order to make us believe anyone can\ndo it easily. It is obvious that all current bitcoin transactions are\nmalleable, but not by anyone and not that easy. At least I like to think so.\n\n>From your answer I understand that right now if I create a transaction\n(tx1) and broadcast it, you can alter its txid at your will, without any\nmining power and/or access to my private keys so I would end up not\nrecognizing my own transaction and probably my change too (if my systems\nrely hardly on txid)?\n\n> On Apr 16, 2015 9:13 AM, \"s7r\" <s7r at sky-ip.org <mailto:s7r at sky-ip.org>>\n> wrote:\n> \n>     Hi Pieter,\n> \n>     Thanks for your reply. I agree. Allen has a good point in the previous\n>     email too, so the suggestion might not fix anything and complicate\n>     things.\n> \n>     The problem I am trying to solve is making all transactions\n>     non-malleable by default. I guess there is a very good reason why BIP62\n>     will not touch v1 anyway.\n> \n>     I am trying to build a bitcoin contract which will relay on 3 things:\n>     - coinjoin / txes with inputs from multiple users which are signed by\n>     all users after they are merged together (every user is sure his coins\n>     will not be spent without the other users to spend anything, as per\n>     agreed contract);\n>     - pre-signed txes with nLockTime 'n' weeks. These txes will be signed\n>     before the inputs being spent are broadcasted/confirmed, using the txid\n>     provided by the user before broadcasting it. Malleability hurts here.\n>     - P2SH\n> \n>     In simple terms, how malleable transactions really are in the network at\n>     this moment? Who can alter a txid without invalidating the tx? Just the\n>     parties who sign it? The miners? Anyone in the network? This is a little\n>     bit unclear to me.\n> \n>     Another thing I would like to confirm, the 3 pieces of the bitcoin\n>     protocol mentioned above will be supported in _any_ future transaction\n>     version or block version, regardless what changes are made or features\n>     added to bitcoin core? The contract needs to be built and left unchanged\n>     for a very very long period of time...\n> \n> \n>     On 4/16/2015 8:22 AM, Pieter Wuille wrote:\n>     >\n>     > On Apr 16, 2015 1:46 AM, \"s7r\" <s7r at sky-ip.org\n>     <mailto:s7r at sky-ip.org> <mailto:s7r at sky-ip.org <mailto:s7r at sky-ip.org>>>\n>     > wrote:\n>     >> but for transaction versions? In simple terms, if > 75% from all the\n>     >> transactions in the latest 1000 blocks are version 'n', mark all\n>     >> previous transaction versions as non-standard and if > 95% from\n>     all the\n>     >> transactions in the latest 1000 blocks are version 'n' mark all\n>     previous\n>     >> transaction versions as invalid.\n>     >\n>     > What problem are you trying to solve?\n>     >\n>     > The reason why BIP62 (as specified, it is just a draft) does not\n>     make v1\n>     > transactions invalid is because it is opt-in. The creator of a\n>     > transaction needs to agree to protect it from malleability, and this\n>     > subjects him to extra rules in the creation.\n>     >\n>     > Forcing v3 transactions would require every piece of wallet\n>     software to\n>     > be changed.\n>     >\n>     > --\n>     > Pieter\n>     >\n> \n>     ------------------------------------------------------------------------------\n>     BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT\n>     Develop your own process in accordance with the BPMN 2 standard\n>     Learn Process modeling best practices with Bonita BPM through live\n>     exercises\n>     http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual-\n>     event?utm_\n>     source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF\n>     _______________________________________________\n>     Bitcoin-development mailing list\n>     Bitcoin-development at lists.sourceforge.net\n>     <mailto:Bitcoin-development at lists.sourceforge.net>\n>     https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2015-04-17T09:02:19",
                "message_text_only": "> Anyone can alter the txid - more details needed. The number of altered\n> txids in practice is not so high in order to make us believe anyone can\n> do it easily. It is obvious that all current bitcoin transactions are\n> malleable, but not by anyone and not that easy. At least I like to think\nso.\n\nDon't assume that because it does not (frequently) happen, that it cannot\nhappen. Large amounts of malleated transactions have happened in the past.\nEspecially if you build a system depends on non-malleability for its\nsecurity, you may at some point have an attacker who has financial gain\nfrom malleation.\n\n> >From your answer I understand that right now if I create a transaction\n> (tx1) and broadcast it, you can alter its txid at your will, without any\n> mining power and/or access to my private keys so I would end up not\n> recognizing my own transaction and probably my change too (if my systems\n> rely hardly on txid)?\n\nIn theory, yes, anyone can alter the txid without invalidating it, without\nmining power and without access to the sender's private keys.\n\nAll it requires is seeing a transaction on the network, doing a trivial\nmodification to it, and rebroadcasting it quickly. If the modifies version\ngets mined, you're out of luck. Having mining power helps of course.\n\nAfter BIP62, you will, as a sender, optionally be able to protect others\nfrom malleating. You're always able to re-sign yourself.\n\n-- \nPieter\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150417/0f221669/attachment.html>"
            },
            {
                "author": "s7r",
                "date": "2015-04-18T14:49:53",
                "message_text_only": "Understood. That is unfortunate, but not the end of the world. If you\ncould please give feedback also to these last comments / questions:\n\nHow far are we at this moment from BIP62? Can an user send a\nnon-malleable tx now, if enforces some additional rules?\n\nAs for the security of the system, it does not fully rely on txids being\nnon malleable, but see this quote from my previous email:\n\n[QUOTE]\nI am trying to build a bitcoin contract which will relay on 3 things:\n- coinjoin / txes with inputs from multiple users which are signed by\nall users after they are merged together (every user is sure his coins\nwill not be spent without the other users to spend anything, as per\nagreed contract);\n- pre-signed txes with nLockTime 'n' weeks. These txes will be signed\nbefore the inputs being spent are broadcasted/confirmed, using the txid\nprovided by the user before broadcasting it. Malleability hurts here.\n- P2SH\n\nAnother thing I would like to confirm, the 3 pieces of the bitcoin\nprotocol mentioned above will be supported in _any_ future transaction\nversion or block version, regardless what changes are made or features\nadded to bitcoin core? The contract needs to be built and left unchanged\nfor a very very long period of time...\n[/END QUOTE]\n\nCan you comment on the quote please?\n\nSo, basically transaction malleability could affect the system in the\nway that a pre-signed tx which offers the insurance and which is sent to\nthe user before the user sends the coins (spending user's coins back to\nhim after a certain period of time) could be invalidated. The insurance\ntx signature will still be good, but invalid overall since the input\n(txid) being spent does not exist (was altered / modified). The coins\nwon't be stolen or lost, but a new tx needs to be signed with the\naltered (new) txid, for the system to work.\n\nSo, an user creates a transaction TX1 sending the coins to the server\nbut does not broadcast it. Instead, he provides the txid of TX1 to the\nserver. Server generates another transaction TX2 which spends TX1 back\nto the user, with an nLockTime. User checks and if everything ok\nbroadcasts TX1. In case the txid of TX1 will be altered/modified, TX2\nwill become invalid (since it will be spending an inexistent input), and\nthe server will need to re-create and sign TX2 with the new\n(altered/modified) txid of TX1, as per agreed contract. Should the\nserver disappear after user broadcasts TX1 and before the\naltered/modified txid of TX1 gets confirmed, user's coins are forever\nlocked. It is true that no third party can benefit from this type of\nattack, only the user will result with coins locked, but it is something\nwhich could be used by competition to make a service useless / annoying\n/ too complicated or less safe to use.\n\nHow could I mitigate this?\n\nThanks you for your time and help.\n\nOn 4/17/2015 12:02 PM, Pieter Wuille wrote:\n>> Anyone can alter the txid - more details needed. The number of altered\n>> txids in practice is not so high in order to make us believe anyone can\n>> do it easily. It is obvious that all current bitcoin transactions are\n>> malleable, but not by anyone and not that easy. At least I like to\n> think so.\n> \n> Don't assume that because it does not (frequently) happen, that it\n> cannot happen. Large amounts of malleated transactions have happened in\n> the past. Especially if you build a system depends on non-malleability\n> for its security, you may at some point have an attacker who has\n> financial gain from malleation.\n> \n>> >From your answer I understand that right now if I create a transaction\n>> (tx1) and broadcast it, you can alter its txid at your will, without any\n>> mining power and/or access to my private keys so I would end up not\n>> recognizing my own transaction and probably my change too (if my systems\n>> rely hardly on txid)?\n> \n> In theory, yes, anyone can alter the txid without invalidating it,\n> without mining power and without access to the sender's private keys.\n> \n> All it requires is seeing a transaction on the network, doing a trivial\n> modification to it, and rebroadcasting it quickly. If the modifies\n> version gets mined, you're out of luck. Having mining power helps of course.\n> \n> After BIP62, you will, as a sender, optionally be able to protect others\n> from malleating. You're always able to re-sign yourself.\n> \n> -- \n> Pieter\n>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2015-04-24T08:55:57",
                "message_text_only": "s7r you may be interested in this video explaining several aspects of\nmalleability: https://www.youtube.com/watch?v=jyDE-aFqJTs\nIt is pre BIP62, but I believe it is very relevant and will hopefully\nclear some of your doubts.\nThe signer of TX1 will always be able to change the signature and thus\nthe tx ID.\n\nOn Sat, Apr 18, 2015 at 4:49 PM, s7r <s7r at sky-ip.org> wrote:\n> Understood. That is unfortunate, but not the end of the world. If you\n> could please give feedback also to these last comments / questions:\n>\n> How far are we at this moment from BIP62? Can an user send a\n> non-malleable tx now, if enforces some additional rules?\n>\n> As for the security of the system, it does not fully rely on txids being\n> non malleable, but see this quote from my previous email:\n>\n> [QUOTE]\n> I am trying to build a bitcoin contract which will relay on 3 things:\n> - coinjoin / txes with inputs from multiple users which are signed by\n> all users after they are merged together (every user is sure his coins\n> will not be spent without the other users to spend anything, as per\n> agreed contract);\n> - pre-signed txes with nLockTime 'n' weeks. These txes will be signed\n> before the inputs being spent are broadcasted/confirmed, using the txid\n> provided by the user before broadcasting it. Malleability hurts here.\n> - P2SH\n>\n> Another thing I would like to confirm, the 3 pieces of the bitcoin\n> protocol mentioned above will be supported in _any_ future transaction\n> version or block version, regardless what changes are made or features\n> added to bitcoin core? The contract needs to be built and left unchanged\n> for a very very long period of time...\n> [/END QUOTE]\n>\n> Can you comment on the quote please?\n>\n> So, basically transaction malleability could affect the system in the\n> way that a pre-signed tx which offers the insurance and which is sent to\n> the user before the user sends the coins (spending user's coins back to\n> him after a certain period of time) could be invalidated. The insurance\n> tx signature will still be good, but invalid overall since the input\n> (txid) being spent does not exist (was altered / modified). The coins\n> won't be stolen or lost, but a new tx needs to be signed with the\n> altered (new) txid, for the system to work.\n>\n> So, an user creates a transaction TX1 sending the coins to the server\n> but does not broadcast it. Instead, he provides the txid of TX1 to the\n> server. Server generates another transaction TX2 which spends TX1 back\n> to the user, with an nLockTime. User checks and if everything ok\n> broadcasts TX1. In case the txid of TX1 will be altered/modified, TX2\n> will become invalid (since it will be spending an inexistent input), and\n> the server will need to re-create and sign TX2 with the new\n> (altered/modified) txid of TX1, as per agreed contract. Should the\n> server disappear after user broadcasts TX1 and before the\n> altered/modified txid of TX1 gets confirmed, user's coins are forever\n> locked. It is true that no third party can benefit from this type of\n> attack, only the user will result with coins locked, but it is something\n> which could be used by competition to make a service useless / annoying\n> / too complicated or less safe to use.\n>\n> How could I mitigate this?\n>\n> Thanks you for your time and help.\n>\n> On 4/17/2015 12:02 PM, Pieter Wuille wrote:\n>>> Anyone can alter the txid - more details needed. The number of altered\n>>> txids in practice is not so high in order to make us believe anyone can\n>>> do it easily. It is obvious that all current bitcoin transactions are\n>>> malleable, but not by anyone and not that easy. At least I like to\n>> think so.\n>>\n>> Don't assume that because it does not (frequently) happen, that it\n>> cannot happen. Large amounts of malleated transactions have happened in\n>> the past. Especially if you build a system depends on non-malleability\n>> for its security, you may at some point have an attacker who has\n>> financial gain from malleation.\n>>\n>>> >From your answer I understand that right now if I create a transaction\n>>> (tx1) and broadcast it, you can alter its txid at your will, without any\n>>> mining power and/or access to my private keys so I would end up not\n>>> recognizing my own transaction and probably my change too (if my systems\n>>> rely hardly on txid)?\n>>\n>> In theory, yes, anyone can alter the txid without invalidating it,\n>> without mining power and without access to the sender's private keys.\n>>\n>> All it requires is seeing a transaction on the network, doing a trivial\n>> modification to it, and rebroadcasting it quickly. If the modifies\n>> version gets mined, you're out of luck. Having mining power helps of course.\n>>\n>> After BIP62, you will, as a sender, optionally be able to protect others\n>> from malleating. You're always able to re-sign yourself.\n>>\n>> --\n>> Pieter\n>>\n>\n> ------------------------------------------------------------------------------\n> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT\n> Develop your own process in accordance with the BPMN 2 standard\n> Learn Process modeling best practices with Bonita BPM through live exercises\n> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_\n> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "William Swanson",
                "date": "2015-04-24T19:58:45",
                "message_text_only": "On Thu, Apr 16, 2015 at 9:12 AM, s7r <s7r at sky-ip.org> wrote:\n> Thanks for your reply. I agree. Allen has a good point in the previous\n> email too, so the suggestion might not fix anything and complicate things.\n\nThe BIP 62 approach to malleability isn't the only option. Another\napproach is to sign the transaction in such a way that the input\ntxid's are allowed to change without invalidating the signatures. That\nway, if malleability happens, you just adjust you transaction to match\nand re-broadcast. That proposal is here:\n\nhttps://github.com/scmorse/bitcoin-misc/blob/master/sighash_proposal.md\n\nThe \"Build your own nHashType\" thread on this mailing list contains\nthe discussion.\n\nI personally prefer this solution, since it nails the problem\ncompletely with one simple and obvious change. The BIP 62 approach is\nmore like a game of wac-a-mole.\n\n-William"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2015-04-24T20:16:57",
                "message_text_only": "On Fri, Apr 24, 2015 at 7:58 PM, William Swanson <swansontec at gmail.com> wrote:\n> On Thu, Apr 16, 2015 at 9:12 AM, s7r <s7r at sky-ip.org> wrote:\n>> Thanks for your reply. I agree. Allen has a good point in the previous\n>> email too, so the suggestion might not fix anything and complicate things.\n>\n> The BIP 62 approach to malleability isn't the only option. Another\n> approach is to sign the transaction in such a way that the input\n> txid's are allowed to change without invalidating the signatures. That\n> way, if malleability happens, you just adjust you transaction to match\n> and re-broadcast. That proposal is here:\n\nThis is not a free choice. There are several concerns, from mild to\nsevere, that arise when you do not sign enough.\n\nIn particular not covering the ID allows for transaction replay which\ncan result in monetary losses far more severe than any possible\nmishandling of malleability could result in. Byzantine attackers can\ncostlessly replay your old transactions any time anyone reuses an\naddress, even accidentally (which cannot be easily prevented since\nthey can race).\n\nOther fun effects also show up like being able to backwards compute\nsignatures to result in a kind of limited covenant- coins which can\nonly be spent a particular way which has some implications for\nfungibility. (See here for a discussion in general of covenants:\nhttps://bitcointalk.org/index.php?topic=278122.0)\n\nThere are no free lunches;  the proposal linked to there is itself a\ngame of wack-a-mole with assorted masking flags; many of which we have\nno notion of if they're useful for any particular application(s); and\nit doesn't provide tools to address the replay issue; and in order to\n'improve' malleability via that mechanism you must always mask out the\ninputs completely; meaning you'd always be exposed to replay and not\njust in specialized 'contract' applications where \"there won't be\naddress reuse\" could be a strong assumption enforced by the\napplication."
            },
            {
                "author": "Stephen Morse",
                "date": "2015-04-25T15:40:37",
                "message_text_only": "Hi Gregory,\n\nIn particular not covering the ID allows for transaction replay which\n> can result in monetary losses far more severe than any possible\n> mishandling of malleability could result in. Byzantine attackers can\n> costlessly replay your old transactions any time anyone reuses an\n> address, even accidentally (which cannot be easily prevented since\n> they can race).\n>\n\nWith the SIGHASH_WITHOUT_PREV_VALUE flag, signatures have to explicitly\nspecify that they are to be signed without the previous UTXO's\nvalue/amount. This means that, at worst, replay attacks can send the money\nto the same place it was sent before (which in many cases is likely not be\na loss of funds), and only if the amount sent to the reused address is the\nexact same as it was before. I don't think this is worse than an attacker\nbeing able to mutate their transaction and extort a merchant who accepts\nzero-conf transactions. Anyway, not signing the input ID wouldn't exactly\nbe the norm, there would be a defined set of flags for standard use cases.\nNot signing the input TXID would only be used in specialized cases, such as\nsetting up micropayment channels.\n\n\n> There are no free lunches;  the proposal linked to there is itself a\n> game of wack-a-mole with assorted masking flags;\n\n\nI agree that it is also a bit of wac-a-mole, but the defined space of\nissues is possibly more limited here. There are only X number of things\nthat can be signed/not signed in a transaction, and the 'Build your own\nnHashType' proposal enables you to fully specify which of those are being\nsigned. If you don't want to get burned by not fully signing your\ntransactions, then don't use the non-standard sighash flags.\n\nmany of which we have\n> no notion of if they're useful for any particular application(s);\n\n\nA few of the flags, indeed, may not ever be useful. But we can't predict\nthe future, and I think it's better to build in a more flexible solution\nnow than to wish we had more flexible nHashTypes later.\n\nTo the original point of this thread, hopefully the suggested proposal\nwon't be necessary as wallets will upgrade to use version 3 transactions\nand the rules associated with them over time.\n\nBest,\nStephen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150425/7e76a1b7/attachment.html>"
            },
            {
                "author": "s7r",
                "date": "2015-04-26T00:01:10",
                "message_text_only": "Thank you all for your comments. The youtube video was indeed very\neducative and nice to watch.\n\nIt's true that malleability is not the end of the world, but it is\nannoying for contracts and micropayment channels, especially refunds\nspending the fund tx before it is even in the blockchain, relying solely\non its txid.\n\nBIP62 is good for preventing 3rd parties (non signers) to mutate txids,\nbut cannot do anything against 2nd parties (signers). I think we can\nsolve both by using NORMALIZEDTXID - wouldn't this be simpler and easier\nto implement? Why are we talking about P3SH when we can just upgrade\nP2SH to support additional OP codes? I saw that there have been talks\nabout a hard fork for increasing the block size, might as well take the\nopportunity and fix this for good, by implementing BIP62, NORMALIZEDTXID\nas well as BIP65. Couldn't all these be part of P2SH?\n\nOn 4/25/2015 6:40 PM, Stephen Morse wrote:\n> Hi Gregory,\n> \n>     In particular not covering the ID allows for transaction replay which\n>     can result in monetary losses far more severe than any possible\n>     mishandling of malleability could result in. Byzantine attackers can\n>     costlessly replay your old transactions any time anyone reuses an\n>     address, even accidentally (which cannot be easily prevented since\n>     they can race).\n> \n> \n> With the SIGHASH_WITHOUT_PREV_VALUE flag, signatures have to explicitly\n> specify that they are to be signed without the previous UTXO's\n> value/amount. This means that, at worst, replay attacks can send the\n> money to the same place it was sent before (which in many cases is\n> likely not be a loss of funds), and only if the amount sent to the\n> reused address is the exact same as it was before. I don't think this is\n> worse than an attacker being able to mutate their transaction and extort\n> a merchant who accepts zero-conf transactions. Anyway, not signing the\n> input ID wouldn't exactly be the norm, there would be a defined set of\n> flags for standard use cases. Not signing the input TXID would only be\n> used in specialized cases, such as setting up micropayment channels. \n>  \n> \n>     There are no free lunches;  the proposal linked to there is itself a\n>     game of wack-a-mole with assorted masking flags; \n> \n> \n> I agree that it is also a bit of wac-a-mole, but the defined space of\n> issues is possibly more limited here. There are only X number of things\n> that can be signed/not signed in a transaction, and the 'Build your own\n> nHashType' proposal enables you to fully specify which of those are\n> being signed. If you don't want to get burned by not fully signing your\n> transactions, then don't use the non-standard sighash flags.\n> \n>     many of which we have\n>     no notion of if they're useful for any particular application(s); \n> \n> \n> A few of the flags, indeed, may not ever be useful. But we can't predict\n> the future, and I think it's better to build in a more flexible solution\n> now than to wish we had more flexible nHashTypes later.\n> \n> To the original point of this thread, hopefully the suggested proposal\n> won't be necessary as wallets will upgrade to use version 3 transactions\n> and the rules associated with them over time. \n> \n> Best,\n> Stephen\n> \n> \n> ------------------------------------------------------------------------------\n> One dashboard for servers and applications across Physical-Virtual-Cloud \n> Widest out-of-the-box monitoring support with 50+ applications\n> Performance metrics, stats and reports that give you Actionable Insights\n> Deep dive visibility with transaction tracing using APM Insight.\n> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y\n> \n> \n> \n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Joseph Poon",
                "date": "2015-04-26T06:51:37",
                "message_text_only": "On Sun, Apr 26, 2015 at 03:01:10AM +0300, s7r wrote:\n> It's true that malleability is not the end of the world, but it is\n> annoying for contracts and micropayment channels, especially refunds\n> spending the fund tx before it is even in the blockchain, relying\n> solely on its txid.\n\nAgreed, needing the transaction to be signed & broadcastable before the\nrefunds can be generated is similar to paying for a contract before the\nterms have been decided.\n\n>  I think we can solve both by using NORMALIZEDTXID - wouldn't this be\n>  simpler and easier to implement? \n\nThe current problem is that SIGHASH_NORMALIZED_TXID as presently\ndiscussed implies stripping the sigScript, which is not sufficient for\nthe Lightning Network.\n\nThe currently discussed SIGHASH_NORMALIZED_TXID does not permit chained\ntransactions 2 levels deep, which is necessary for Lightning as well.\nThe path from the Commitment -> HTLC -> Refund requires up to 3 levels\ndeep of transactions. \n\nSuppose TxA -> TxB -> TxC -> TxD. All outputs are 2-of-2 multisig. TxA\nhas already entered into the blockchain, the rest have not yet been\nbroadcast. If TxB spends from TxA, it doesn't need new sighash flags, it\njust does a plain SIGHASH_ALL. However, TxC needs\nSIGHASH_NORMALIZED_TXID due to malleability risks.\nSIGHASH_NORMALIZED_TXID works for TxC because the sigScript can change,\nbut because TxA's txid has already entered the blockchain, the parent's\ninput txids cannot change (with high degrees of certainty).\n\nHowever, with TxD, the txid of TxB may be different, which will result\nin an invalid transaction if SIGHASH_NORMALIZED_TXID only strips the\nsigScript when obtaining the normalized txid of TxC. The reason for this\nis TxC's input txid of TxB has changed (TxC's input 0 txid of TxB)!\n\nTherefore, a functional SIGHASH_NORMALIZED which permits chained\ntransactions requires the parent transaction's sigScript *AND* txid to\nbe stripped when determining the parent's normalized txid. Similar to\nOP_CHECKSIG, a part of the normalized TXID includes each input's\nscriptPubKey, e.g. TxC's normalized TXID includes TxB's scriptPubKey\noutput which it is spending, so when TxD signs TxC's normalized TXID, it\nincludes TxB's output (this is a cheap way of increasing uniqueness but\nis not an absolute necessity if it's too difficult). All this data\nshould be immediately available when validating the transaction and\nappending it to the UTXO set.\n\nIf the txid and sigScript are removed when building the normalized input\ntxid as part of the spend/signature, it should be possible for chained\ntransactions to work. However, this isn't absolute security against\nreplay attacks. If there are two spends with all inputs having the same\nvalues *AND* the same scriptPubKeys per input, then it can be replayed.\nThe odds of this occurring seems like a sort of uncanny valley of risks;\nit's low enough that it shouldn't ever happen which may result in a lack\nof documentation, so when it does happen it'll be a big surprise. So,\neven if this \"safer\" method becomes a softfork, perhaps great care\nshould be taken before making this a default method of spending when the\nsighash flag is not an absolute necessity (i.e. \"don't do it!\" I'm all\nin favor of giving this a scary name so developers won't inadvertently\nthink \"hey, normalization sounds like a good thing to do\").\n\nThat said, it should cover an overwhelming majority of potential\nreplays, it's nearly impossible to create a \"duplicate\" replayable tx of\nsomeone *else's* send, since the poteintally \"replayable\" transaction\nsigns the sigScript of the redeemed output.\n\nAs a side note, SIGHASH_NORMALIZED does not permit spending from any\ntransaction, which is desirable for the Lightning Network (HTLCs may\npersist in new Commitment Transactions). However, this is merely a \"nice\nto have\" and is not an absolute necessity, there is no significant loss\nof functionality, merely some slight slowdown from significantly more\nsignatures. For Lightning in particular, the effect would probably be\nbatching Commitment Transactions (e.g. 1 mass update per second per\nchannel), with the only major discernable penalty is an order of\nmagnitude greater storage of signatures.\n\nAdditionally, I think it was Mark Friedenbach who brought up that\nSIGHASH_NORMALIZED creates significant complexities with the need for an\nadditional hash with every UTXO (almost doubling the UTXO set size), and\nwith nodes which already have UTXO pruning enabled, it'll require\ndownloading the entire blockchain. I'm not sure if this problem is\ninsurmountable or not, but if a normalized sighash becomes the most\nideal candidate for a malleability soft-fork, then sooner may be better\nthan later as more nodes start using the pruning patch.\n\n\n> Why are we talking about P3SH when we can just upgrade\n> P2SH to support additional OP codes? \n\nAssuming you mean the current P2SH scriptPubKey format, it's not\npossible to do so while making it a soft fork. If you use OP_EQUAL,\ncurrent nodes will treat \"P3SH\" transactions as P2SH ones.\n\nI'm in favor of keeping P3SH conservative. It's possible to have your\ncake and eat it too, by enabling script versions within P3SH.\n\nIf you create P3SH as:\n\nOP_DUP <20-byte hash> OP_EQUALVERIFY\n\nThe redeemScript has the first byte as a version number, and there is\nalso an OP_TRUE pushed right before the redeemScript. The scriptSig\nwould look something like:\n\n<sigs...> OP_TRUE <3 redeemScript>\n\nWhen executing the script, the last item on the stack verifies against\nthe hash, then the redeemScript is copied/read, the 3 is popped off\n(first byte unsigned int), the OP_TRUE is popped off the stack, and the\nscript then executes P3SH \"version 3\" (again, it is the first byte, NOT\nan opcode). Any non-known version will return everything as true and not\ncontinue with execution of the script, to permit future soft-forks. The\nOP_TRUE is to ensure there is a OP_TRUE left on the stack just in case\nfor older nodes as this is an EQUALVERIFY.\n\nThis works because the address, 20-byte hash, has the 3 version number\nas part of the hash, so it is the recipient who determines the version\nnumber. For future soft-forks, it's incredibly flexible, just make the\nversion byte to 4. Prior addresses work the same, and it's not possible\nto accidentally send it using different scripting versions. Perhaps this\ncan make things upgradeable enough that a malleability sighash flag can\ngo in sooner rather than later.\n\n-- \nJoseph Poon"
            },
            {
                "author": "Joseph Poon",
                "date": "2015-04-26T16:48:03",
                "message_text_only": "On Sat, Apr 25, 2015 at 11:51:37PM -0700, Joseph Poon wrote:\n> signs the sigScript of the redeemed output.\n\nErr, typo, I meant:\n... signs the *scriptPubKey* of the redeemed output.\n\n-- \nJoseph Poon"
            },
            {
                "author": "Stephen Morse",
                "date": "2015-04-25T14:32:36",
                "message_text_only": "Hi William,\n\nI personally prefer this solution, since it nails the problem\n> completely with one simple and obvious change. The BIP 62 approach is\n> more like a game of wac-a-mole.\n>\n\nThe two are complementary, not competing. BIP62 prevents *non-signers* from\nmutating the transactions, which is very important. The 'Build your own\nnHashType' proposal enables chained transactions even in the face of\n*signers* mutating the transaction. I believe that integrating both will\nlead to the best defense against transaction malleability, and will enable\nmore complicated uses of chained transactions (such as micropayment\nchannels).\n\nBest,\nStephen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150425/155f2e23/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2015-04-27T19:21:12",
                "message_text_only": "On Sat, Apr 25, 2015 at 10:32:36AM -0400, Stephen Morse wrote:\n> Hi William,\n> \n> I personally prefer this solution, since it nails the problem\n> > completely with one simple and obvious change. The BIP 62 approach is\n> > more like a game of wac-a-mole.\n> >\n> \n> The two are complementary, not competing. BIP62 prevents *non-signers* from\n> mutating the transactions, which is very important.\n\nI strongly disagree.\n\nThere are exactly two cases where mutation matters to normal wallets:\n\n1) Spending unconfirmed change. This can be more efficiently done by\n   double-spending the first tx with a second that pays both recipients.\n\n2) Large reorganizations. Making mutation impossible makes it more\n   likely that after a large reorg all previously confirmed transactions\n   will make it back to the blockchain succesfully.\n\nMeanwhile, the \"whack-a-mole\" aspect of BIP62 is worrying - it's very\nlikely we'll miss a case. Even right now there are edge cases without\ngood solutions, like how in a multisig environment any of the key\nholders can mutate transactions. Building wallets that make strong\nassumptions about malleability and fail if those assumptions turn out to\nbe wrong is poor engineering.\n\n> The 'Build your own\n> nHashType' proposal enables chained transactions even in the face of\n> *signers* mutating the transaction. I believe that integrating both will\n> lead to the best defense against transaction malleability, and will enable\n> more complicated uses of chained transactions (such as micropayment\n> channels).\n\nWhile I think there are better ways to do 'Build your own nHashType'\nthan what was recently proposed, I strongly agree that for protocols\nthat really, truly, need malleability resistance it's far better to use\na purpose-built signature hashing algorithm.\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000000e7980aab9c096c46e7f34c43a661c5cb2ea71525ebb8af7\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 650 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150427/4375115d/attachment.sig>"
            },
            {
                "author": "Oleg Andreev",
                "date": "2015-04-28T10:17:27",
                "message_text_only": "> On 27 Apr 2015, at 21:21, Peter Todd <pete at petertodd.org> wrote:\n> \n> Even right now there are edge cases without\n> good solutions, like how in a multisig environment any of the key\n> holders can mutate transactions.\n\nCan't we add requirement for RFC6979 signatures to mitigate this? Of course, multiple signers can still mutate transaction by choosing a different set (but not the order, thankfully) of signatures. Or when a single signer has multiple participating keys.\n\nIn some interesting to me scenarios mutation by signer is not critical: it is mutation by non-signers that creates a problem. Do you know of any edge cases when non-signers can mutate transactions which are not covered by BIP62? What would be a more robust approach than \"whack-a-mole\" to work around mutability? (Normalized tx ids?)"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2015-04-24T08:58:11",
                "message_text_only": "Oh, no, sorry, it also covers bip62.\n\nOn Fri, Apr 24, 2015 at 10:55 AM, Jorge Tim\u00f3n <jtimon at jtimon.cc> wrote:\n> s7r you may be interested in this video explaining several aspects of\n> malleability: https://www.youtube.com/watch?v=jyDE-aFqJTs\n> It is pre BIP62, but I believe it is very relevant and will hopefully\n> clear some of your doubts.\n> The signer of TX1 will always be able to change the signature and thus\n> the tx ID.\n>\n> On Sat, Apr 18, 2015 at 4:49 PM, s7r <s7r at sky-ip.org> wrote:\n>> Understood. That is unfortunate, but not the end of the world. If you\n>> could please give feedback also to these last comments / questions:\n>>\n>> How far are we at this moment from BIP62? Can an user send a\n>> non-malleable tx now, if enforces some additional rules?\n>>\n>> As for the security of the system, it does not fully rely on txids being\n>> non malleable, but see this quote from my previous email:\n>>\n>> [QUOTE]\n>> I am trying to build a bitcoin contract which will relay on 3 things:\n>> - coinjoin / txes with inputs from multiple users which are signed by\n>> all users after they are merged together (every user is sure his coins\n>> will not be spent without the other users to spend anything, as per\n>> agreed contract);\n>> - pre-signed txes with nLockTime 'n' weeks. These txes will be signed\n>> before the inputs being spent are broadcasted/confirmed, using the txid\n>> provided by the user before broadcasting it. Malleability hurts here.\n>> - P2SH\n>>\n>> Another thing I would like to confirm, the 3 pieces of the bitcoin\n>> protocol mentioned above will be supported in _any_ future transaction\n>> version or block version, regardless what changes are made or features\n>> added to bitcoin core? The contract needs to be built and left unchanged\n>> for a very very long period of time...\n>> [/END QUOTE]\n>>\n>> Can you comment on the quote please?\n>>\n>> So, basically transaction malleability could affect the system in the\n>> way that a pre-signed tx which offers the insurance and which is sent to\n>> the user before the user sends the coins (spending user's coins back to\n>> him after a certain period of time) could be invalidated. The insurance\n>> tx signature will still be good, but invalid overall since the input\n>> (txid) being spent does not exist (was altered / modified). The coins\n>> won't be stolen or lost, but a new tx needs to be signed with the\n>> altered (new) txid, for the system to work.\n>>\n>> So, an user creates a transaction TX1 sending the coins to the server\n>> but does not broadcast it. Instead, he provides the txid of TX1 to the\n>> server. Server generates another transaction TX2 which spends TX1 back\n>> to the user, with an nLockTime. User checks and if everything ok\n>> broadcasts TX1. In case the txid of TX1 will be altered/modified, TX2\n>> will become invalid (since it will be spending an inexistent input), and\n>> the server will need to re-create and sign TX2 with the new\n>> (altered/modified) txid of TX1, as per agreed contract. Should the\n>> server disappear after user broadcasts TX1 and before the\n>> altered/modified txid of TX1 gets confirmed, user's coins are forever\n>> locked. It is true that no third party can benefit from this type of\n>> attack, only the user will result with coins locked, but it is something\n>> which could be used by competition to make a service useless / annoying\n>> / too complicated or less safe to use.\n>>\n>> How could I mitigate this?\n>>\n>> Thanks you for your time and help.\n>>\n>> On 4/17/2015 12:02 PM, Pieter Wuille wrote:\n>>>> Anyone can alter the txid - more details needed. The number of altered\n>>>> txids in practice is not so high in order to make us believe anyone can\n>>>> do it easily. It is obvious that all current bitcoin transactions are\n>>>> malleable, but not by anyone and not that easy. At least I like to\n>>> think so.\n>>>\n>>> Don't assume that because it does not (frequently) happen, that it\n>>> cannot happen. Large amounts of malleated transactions have happened in\n>>> the past. Especially if you build a system depends on non-malleability\n>>> for its security, you may at some point have an attacker who has\n>>> financial gain from malleation.\n>>>\n>>>> >From your answer I understand that right now if I create a transaction\n>>>> (tx1) and broadcast it, you can alter its txid at your will, without any\n>>>> mining power and/or access to my private keys so I would end up not\n>>>> recognizing my own transaction and probably my change too (if my systems\n>>>> rely hardly on txid)?\n>>>\n>>> In theory, yes, anyone can alter the txid without invalidating it,\n>>> without mining power and without access to the sender's private keys.\n>>>\n>>> All it requires is seeing a transaction on the network, doing a trivial\n>>> modification to it, and rebroadcasting it quickly. If the modifies\n>>> version gets mined, you're out of luck. Having mining power helps of course.\n>>>\n>>> After BIP62, you will, as a sender, optionally be able to protect others\n>>> from malleating. You're always able to re-sign yourself.\n>>>\n>>> --\n>>> Pieter\n>>>\n>>\n>> ------------------------------------------------------------------------------\n>> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT\n>> Develop your own process in accordance with the BPMN 2 standard\n>> Learn Process modeling best practices with Bonita BPM through live exercises\n>> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_\n>> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            }
        ],
        "thread_summary": {
            "title": "75%/95% threshold for transaction versions",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "William Swanson",
                "Stephen Morse",
                "s7r",
                "Oleg Andreev",
                "Pieter Wuille",
                "Peter Todd",
                "Jorge Tim\u00f3n",
                "Gregory Maxwell",
                "Mark Friedenbach",
                "Allen Piscitello",
                "Joseph Poon"
            ],
            "messages_count": 19,
            "total_messages_chars_count": 51498
        }
    },
    {
        "title": "[Bitcoin-development] Where do I start?",
        "thread_messages": [
            {
                "author": "gabe appleton",
                "date": "2015-04-16T02:14:12",
                "message_text_only": "Background: I'm a CS student quickly approaching his research project, and\nI'd like to do something meaningful with it.\n\nEssentially, I'd like to know what issues someone up for their bachelor's\ndegree might actually be able to help on, and where I can start. Obviously\nI'm not going to be able to just dive into a 6-year-running project without\nsome prior research, so I'm looking for a start.\n\nWhat are some current things that are lacking in Bitcoin core? Or am I\nbetter off making something else for the ecosystem?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150415/56a2d99c/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2015-04-16T12:33:56",
                "message_text_only": "Hey Gabe,\n\nThat's diving into the deep end for sure! :)\n\n> What are some current things that are lacking in Bitcoin core? Or am I\n> better off making something else for the ecosystem?\n>\nThat depends on your interests.\n\nMany of the highest priority tasks in Bitcoin Core are rather complicated,\nunfortunately, even for people with experience. You can consult the issue\ntracker to get a feel for it.\n\nAlternatively, there are lots of wallet apps out there and plenty of more\nstraightforward projects on them. However they may have less of a research\nflavour.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150416/28c1c233/attachment.html>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2015-04-30T08:08:20",
                "message_text_only": "As Mike says it depends on your interests. But one thing that is almost\nalways welcomed is improving the tests, and it is unlikely that it\nconflicts with other people's PRs (unless they're changing that part of the\ncode and need to update those tests. Improving documentation is also good\nand you can do that while reading the code. Usually I just start cloning,\ncompiling and changing things as I read, \"if I understand this correctly,\nthis change should not break the tests, if I understand this, this other\nchange should break the build\", etc.\nBut again, is up to you.\nOn Apr 16, 2015 2:34 PM, \"Mike Hearn\" <mike at plan99.net> wrote:\n\n> Hey Gabe,\n>\n> That's diving into the deep end for sure! :)\n>\n>> What are some current things that are lacking in Bitcoin core? Or am I\n>> better off making something else for the ecosystem?\n>>\n> That depends on your interests.\n>\n> Many of the highest priority tasks in Bitcoin Core are rather complicated,\n> unfortunately, even for people with experience. You can consult the issue\n> tracker to get a feel for it.\n>\n> Alternatively, there are lots of wallet apps out there and plenty of more\n> straightforward projects on them. However they may have less of a research\n> flavour.\n>\n>\n> ------------------------------------------------------------------------------\n> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT\n> Develop your own process in accordance with the BPMN 2 standard\n> Learn Process modeling best practices with Bonita BPM through live\n> exercises\n> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual-\n> event?utm_\n> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150430/7c3c16d2/attachment.html>"
            },
            {
                "author": "Telephone Lemien",
                "date": "2015-04-30T09:35:50",
                "message_text_only": "Hello,\nI'm a beginner in Bitcoin and I want to know, what are things those allo me\nto understand Bitcoin protocol and make progress in java to become a good\ndevelopper.\nPlease tell me how I can begin.\nBest regards\n\n2015-04-30 10:08 GMT+02:00 Jorge Tim\u00f3n <jtimon at jtimon.cc>:\n\n> As Mike says it depends on your interests. But one thing that is almost\n> always welcomed is improving the tests, and it is unlikely that it\n> conflicts with other people's PRs (unless they're changing that part of the\n> code and need to update those tests. Improving documentation is also good\n> and you can do that while reading the code. Usually I just start cloning,\n> compiling and changing things as I read, \"if I understand this correctly,\n> this change should not break the tests, if I understand this, this other\n> change should break the build\", etc.\n> But again, is up to you.\n> On Apr 16, 2015 2:34 PM, \"Mike Hearn\" <mike at plan99.net> wrote:\n>\n>> Hey Gabe,\n>>\n>> That's diving into the deep end for sure! :)\n>>\n>>> What are some current things that are lacking in Bitcoin core? Or am I\n>>> better off making something else for the ecosystem?\n>>>\n>> That depends on your interests.\n>>\n>> Many of the highest priority tasks in Bitcoin Core are rather\n>> complicated, unfortunately, even for people with experience. You can\n>> consult the issue tracker to get a feel for it.\n>>\n>> Alternatively, there are lots of wallet apps out there and plenty of more\n>> straightforward projects on them. However they may have less of a research\n>> flavour.\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT\n>> Develop your own process in accordance with the BPMN 2 standard\n>> Learn Process modeling best practices with Bonita BPM through live\n>> exercises\n>> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual-\n>> event?utm_\n>> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>>\n>\n> ------------------------------------------------------------------------------\n> One dashboard for servers and applications across Physical-Virtual-Cloud\n> Widest out-of-the-box monitoring support with 50+ applications\n> Performance metrics, stats and reports that give you Actionable Insights\n> Deep dive visibility with transaction tracing using APM Insight.\n> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150430/b9fb571c/attachment.html>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2015-04-30T10:28:05",
                "message_text_only": "Well, if you're interested in learning java while learning bitcoin,\nprobably you should be looking at https://github.com/bitcoinj/bitcoinj\nor one of its related project (like the android bitcoin wallet based\non it).\nThere's a getting sterted page: https://bitcoinj.github.io/#getting-started\n\nThese links my be useful too:\n\nhttps://bitcoin.org/en/bitcoin-for-developers\nhttps://bitcoin.org/en/developer-documentation\n\n\nOn Thu, Apr 30, 2015 at 11:35 AM, Telephone Lemien\n<lemientelephone at gmail.com> wrote:\n> Hello,\n> I'm a beginner in Bitcoin and I want to know, what are things those allo me\n> to understand Bitcoin protocol and make progress in java to become a good\n> developper.\n> Please tell me how I can begin.\n> Best regards\n>\n> 2015-04-30 10:08 GMT+02:00 Jorge Tim\u00f3n <jtimon at jtimon.cc>:\n>>\n>> As Mike says it depends on your interests. But one thing that is almost\n>> always welcomed is improving the tests, and it is unlikely that it conflicts\n>> with other people's PRs (unless they're changing that part of the code and\n>> need to update those tests. Improving documentation is also good and you can\n>> do that while reading the code. Usually I just start cloning, compiling and\n>> changing things as I read, \"if I understand this correctly, this change\n>> should not break the tests, if I understand this, this other change should\n>> break the build\", etc.\n>> But again, is up to you.\n>>\n>> On Apr 16, 2015 2:34 PM, \"Mike Hearn\" <mike at plan99.net> wrote:\n>>>\n>>> Hey Gabe,\n>>>\n>>> That's diving into the deep end for sure! :)\n>>>>\n>>>> What are some current things that are lacking in Bitcoin core? Or am I\n>>>> better off making something else for the ecosystem?\n>>>\n>>> That depends on your interests.\n>>>\n>>> Many of the highest priority tasks in Bitcoin Core are rather\n>>> complicated, unfortunately, even for people with experience. You can consult\n>>> the issue tracker to get a feel for it.\n>>>\n>>> Alternatively, there are lots of wallet apps out there and plenty of more\n>>> straightforward projects on them. However they may have less of a research\n>>> flavour.\n>>>\n>>>\n>>> ------------------------------------------------------------------------------\n>>> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT\n>>> Develop your own process in accordance with the BPMN 2 standard\n>>> Learn Process modeling best practices with Bonita BPM through live\n>>> exercises\n>>> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual-\n>>> event?utm_\n>>> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF\n>>> _______________________________________________\n>>> Bitcoin-development mailing list\n>>> Bitcoin-development at lists.sourceforge.net\n>>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>>\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> One dashboard for servers and applications across Physical-Virtual-Cloud\n>> Widest out-of-the-box monitoring support with 50+ applications\n>> Performance metrics, stats and reports that give you Actionable Insights\n>> Deep dive visibility with transaction tracing using APM Insight.\n>> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>"
            },
            {
                "author": "Thomas Kerin",
                "date": "2015-04-30T15:50:34",
                "message_text_only": "When dealing with any of the libraries or API's it's helps to know\nwhat's going on under the hood. I find these pages to be invaluable.\n\nhttps://en.bitcoin.it/wiki/Transactions\nhttps://en.bitcoin.it/wiki/Protocol_specification\nhttps://en.bitcoin.it/wiki/Script\n\nOn 30/04/15 11:28, Jorge Tim\u00f3n wrote:\n> Well, if you're interested in learning java while learning bitcoin,\n> probably you should be looking at https://github.com/bitcoinj/bitcoinj\n> or one of its related project (like the android bitcoin wallet based\n> on it).\n> There's a getting sterted page: https://bitcoinj.github.io/#getting-started\n>\n> These links my be useful too:\n>\n> https://bitcoin.org/en/bitcoin-for-developers\n> https://bitcoin.org/en/developer-documentation\n>\n>\n> On Thu, Apr 30, 2015 at 11:35 AM, Telephone Lemien\n> <lemientelephone at gmail.com> wrote:\n>> Hello,\n>> I'm a beginner in Bitcoin and I want to know, what are things those allo me\n>> to understand Bitcoin protocol and make progress in java to become a good\n>> developper.\n>> Please tell me how I can begin.\n>> Best regards\n>>\n>> 2015-04-30 10:08 GMT+02:00 Jorge Tim\u00f3n <jtimon at jtimon.cc>:\n>>> As Mike says it depends on your interests. But one thing that is almost\n>>> always welcomed is improving the tests, and it is unlikely that it conflicts\n>>> with other people's PRs (unless they're changing that part of the code and\n>>> need to update those tests. Improving documentation is also good and you can\n>>> do that while reading the code. Usually I just start cloning, compiling and\n>>> changing things as I read, \"if I understand this correctly, this change\n>>> should not break the tests, if I understand this, this other change should\n>>> break the build\", etc.\n>>> But again, is up to you.\n>>>\n>>> On Apr 16, 2015 2:34 PM, \"Mike Hearn\" <mike at plan99.net> wrote:\n>>>> Hey Gabe,\n>>>>\n>>>> That's diving into the deep end for sure! :)\n>>>>> What are some current things that are lacking in Bitcoin core? Or am I\n>>>>> better off making something else for the ecosystem?\n>>>> That depends on your interests.\n>>>>\n>>>> Many of the highest priority tasks in Bitcoin Core are rather\n>>>> complicated, unfortunately, even for people with experience. You can consult\n>>>> the issue tracker to get a feel for it.\n>>>>\n>>>> Alternatively, there are lots of wallet apps out there and plenty of more\n>>>> straightforward projects on them. However they may have less of a research\n>>>> flavour.\n>>>>\n>>>>\n>>>> ------------------------------------------------------------------------------\n>>>> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT\n>>>> Develop your own process in accordance with the BPMN 2 standard\n>>>> Learn Process modeling best practices with Bonita BPM through live\n>>>> exercises\n>>>> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual-\n>>>> event?utm_\n>>>> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF\n>>>> _______________________________________________\n>>>> Bitcoin-development mailing list\n>>>> Bitcoin-development at lists.sourceforge.net\n>>>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>>>\n>>>\n>>> ------------------------------------------------------------------------------\n>>> One dashboard for servers and applications across Physical-Virtual-Cloud\n>>> Widest out-of-the-box monitoring support with 50+ applications\n>>> Performance metrics, stats and reports that give you Actionable Insights\n>>> Deep dive visibility with transaction tracing using APM Insight.\n>>> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y\n>>> _______________________________________________\n>>> Bitcoin-development mailing list\n>>> Bitcoin-development at lists.sourceforge.net\n>>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>>\n> ------------------------------------------------------------------------------\n> One dashboard for servers and applications across Physical-Virtual-Cloud \n> Widest out-of-the-box monitoring support with 50+ applications\n> Performance metrics, stats and reports that give you Actionable Insights\n> Deep dive visibility with transaction tracing using APM Insight.\n> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n-- \nThomas Kerin\n------------------------------------------------------------------------\n\nMy PGP key can be found here <http://pgp.mit.edu/pks/lookup?op=get&search=0x3F0D2F83A2966155>\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150430/8e0c1ee5/attachment.html>"
            },
            {
                "author": "Thy Shizzle",
                "date": "2015-04-16T03:42:36",
                "message_text_only": "Zero conf :D\n________________________________\nFrom: gabe appleton<mailto:gappleto97 at gmail.com>\nSent: \u200e16/\u200e04/\u200e2015 12:15 PM\nTo: bitcoin-development at lists.sourceforge.net<mailto:bitcoin-development at lists.sourceforge.net>\nSubject: [Bitcoin-development] Where do I start?\n\nBackground: I'm a CS student quickly approaching his research project, and\nI'd like to do something meaningful with it.\n\nEssentially, I'd like to know what issues someone up for their bachelor's\ndegree might actually be able to help on, and where I can start. Obviously\nI'm not going to be able to just dive into a 6-year-running project without\nsome prior research, so I'm looking for a start.\n\nWhat are some current things that are lacking in Bitcoin core? Or am I\nbetter off making something else for the ecosystem?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150416/ea93eee5/attachment.html>\n-------------- next part --------------\n------------------------------------------------------------------------------\nBPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT\nDevelop your own process in accordance with the BPMN 2 standard\nLearn Process modeling best practices with Bonita BPM through live exercises\nhttp://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_\nsource=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF\n-------------- next part --------------\n_______________________________________________\nBitcoin-development mailing list\nBitcoin-development at lists.sourceforge.net\nhttps://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            }
        ],
        "thread_summary": {
            "title": "Where do I start?",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Thomas Kerin",
                "Mike Hearn",
                "gabe appleton",
                "Telephone Lemien",
                "Jorge Tim\u00f3n",
                "Thy Shizzle"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 16360
        }
    },
    {
        "title": "[Bitcoin-development] Bitcoin Core 0.10.1 release candidate 3 available",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2015-04-21T07:22:41",
                "message_text_only": "I've just uploaded Bitcoin Core 0.10.1rc3 executables to:\n\nhttps://bitcoin.org/bin/bitcoin-core-0.10.1/test/\n\nThe source code can be found in git under the tag 'v0.10.1rc3' on the `0.10` branch.\n\nNew in this RC is another batch of bug fixes,\n\n- `eae305f` Fix missing lock in submitblock\n- `57d1f46` Fix CheckBlockIndex for reindex\n- `bac6fca` Set nSequenceId when a block is fully linked\n- `139cd81` Cap nAttempts penalty at 8 and switch to pow instead of a division loop\n- `323de27` `7494e09` `df45564` Various initialization setup environment locale fixes\n\nFull (preliminary) release notes for 0.10.1 can be found at https://github.com/bitcoin/bitcoin/blob/v0.10.1rc3/doc/release-notes.md \n\nThanks to everyone that participated in development or in the gitian build process. I sincerely hope that this can be the final release candidate for 0.10.1,\n\nWladimir"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.10.1 release candidate 3 available",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Wladimir J. van der Laan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 860
        }
    },
    {
        "title": "[Bitcoin-development] Relative CHECKLOCKTIMEVERIFY (was CLTV proposal)",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2015-04-21T07:59:12",
                "message_text_only": "On Mon, Mar 16, 2015 at 10:22:13PM +0000, Matt Corallo wrote:\n> In building some CLTV-based contracts, it is often also useful to have a\n> method of requiring, instead of locktime-is-at-least-N,\n> locktime-is-at-least-N-plus-the-height-of-my-input. ie you could imagine\n> an OP_RELATIVECHECKLOCKTIMEVERIFY that reads (does not pop) the top\n> stack element, adds the height of the output being spent and then has\n> identical semantics to CLTV.\n\nDepending on what you mean by \"identical\" this isn't actually reorg\nsafe. For instance consider this implementation:\n\n    nLockTime = stack[-1] + prevout.nHeight\n    if (nLockTime > txTo.nLockTime):\n        return False\n\nUsed with this scriptPubKey:\n\n    10 RCLTV DROP <pubkey> CHECKSIG\n\nIf I create that output in tx1 which is mined at height 42 I can spend\nit in a tx2 at height > 42+10 by setting tx2's nLockTime to >42+10, for\ninstance 53. However if a reorg happens and tx1 ends up at height 43\nafter the reorg I'm stuck - tx2's nLockTime is set at 42.\n\nThus RCTLV is only reorg safe if the height is compared against the\nactual block height of the block containing the spending transaction,\nnot the spending transaction's nLockTime.\n\n> A slightly different API (and different name) was described by maaku at\n> http://www.reddit.com/r/Bitcoin/comments/2z2l91/time_to_lobby_bitcoins_core_devs_sf_bitcoin_devs/cpgc154\n> which does a better job of saving softfork-available opcode space.\n> \n> There are two major drawbacks to adding such an operation, however.\n> \n> 1) More transaction information is exposed inside the script (prior to\n> CLTV we only had the sigchecking operation exposed, with a CLTV and\n> RCLTV/OP_CHECK_MATURITY_VERIFY we expose two more functions).\n> \n> 2) Bitcoin Core's mempool invariant of \"all transactions in the mempool\n> could be thrown into one overside block and aside from block size, it\n> would be valid\" becomes harder to enforce. Currently, during reorgs,\n> coinbase spends need checked (specifically, anything spending THE\n> coinbase 100 blocks ago needs checked) and locktime transactions need\n> checked. With such a new operation, any script which used this new\n> opcode during its execution would need to be re-evaluated during reorgs.\n\nYup, definitely kinda ugly.\n\nIf the above style of RCTLV was used, one possibility might be to make\nthe relative locktime difference be required to be at least 100 blocks,\nsame as the coinbase maturity, and just accept that it's probably not\ngoing to cause any problems, but could in an extremely big reorg. But\nre-orgs that big might be big enough that we're screwed anyway...\n\nWith the 100 block rule, during a sufficiently large reorg that\ncoinbases become unavailble, simply disconnect entire blocks - all\ntxouts created by them.\n\n> I think both of these requirements are reasonable and not particularly\n> cumbersome, and the value of such an operation is quite nice for some\n> protocols (including settings setting up a contest interval in a\n> sidechain data validation operation).\n\nSo to be clear, right now the minimal interface to script execution is\nsimply:\n\n    int bitcoinconsensus_verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen,\n                                       const unsigned char *txTo        , unsigned int txToLen,\n                                       unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err);\n\nWhere scriptPubKey is derived from the unspent coin in the UTXO set and\ntxTo is the transaction containing the script that is being executed.\nThe UTXO set itself currently contains CCoins entries, one for each\ntransaction with unspent outputs, which basically contain:\n\n    nVersion - tx nVersion\n    nHeight  - Height of the block the transaction is contained in.\n    vout     - Unspent CTxOut's of the transaction.\n\nThe block nTime isn't directly available through the UTXO set, although\nit can be found in the block headers. This does require nodes to have\nthe block headers, but at 4MB/year growth it's reasonable to assume the\nUTXO set will grow faster.\n\nScript execution does not have direct access to the current block\nheight/block time, however it does have indirect access via nLockTime.\n\nThus we have a few possibilities:\n\n1) RCLTV against nLockTime\n\nNeeds a minimum age > COINBASE_MATURITY to be safe.\n\n\n2) RCLTV against current block height/time\n\nCompletely reorg safe.\n\n\n3) GET_TXOUT_HEIGHT/TIME <diff> ADD CLTV\n\nTo be reorg safe GET_TXOUT_HEIGHT/TIME must fail if minimum age <\nCOINBASE_MATURITY. This can be implemented by comparing against\nnLockTime.\n\n\nAll three possibilities require us to make information about the\nprevout's height/time available to VerifyScript(). The only question is\nif we want VerifyScript() to also take the current block height/time - I\nsee no reason why it can't. As for the mempool, keeping track of what\ntransactions made use of these opcodes so they can be reevaluated if\ntheir prevouts are re-organised seems fine to me.\n\n\nAbsolute CLTV\n=============\n\nIf we are going to make the block height/time available to\nVerifyScript() to implement RCLTV, should absolute CLTV should continue\nto have the proposed behavior of checking against nLockTime? If we go\nwith RCLTV against current block height/time, I'm going to vote no,\nbecause doing so needlessly limits it to only being able to compare\nagainst a block height or a block time in a single transaction.\nSimilarly it can complicate multi-party signatures in some\ncircumstances, as all parties must agree on a common nLockTime.\n\n\nTime-based locks\n================\n\nDo we want to support them at all? May cause incentive issues with\nmining, see #bitcoin-wizards discussion, Jul 17th 2013:\n\nhttps://download.wpsoftware.net/bitcoin/wizards/2013/07/13-07-17.log\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000000015e09479548c5b63b99a62d31b019e6479f195bf0cbd935\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 650 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150421/c66bedbc/attachment.sig>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2015-04-26T11:35:33",
                "message_text_only": "On Tue, Apr 21, 2015 at 9:59 AM, Peter Todd <pete at petertodd.org> wrote:\n> Thus we have a few possibilities:\n>\n> 1) RCLTV against nLockTime\n>\n> Needs a minimum age > COINBASE_MATURITY to be safe.\n>\n>\n> 2) RCLTV against current block height/time\n>\n> Completely reorg safe.\n\nYes, can we call this one OP_MATURITY to distinguish it from RCLTV?\n\n> 3) GET_TXOUT_HEIGHT/TIME <diff> ADD CLTV\n>\n> To be reorg safe GET_TXOUT_HEIGHT/TIME must fail if minimum age <\n> COINBASE_MATURITY. This can be implemented by comparing against\n> nLockTime.\n\nMhmm, interesting.\n\n> All three possibilities require us to make information about the\n> prevout's height/time available to VerifyScript(). The only question is\n> if we want VerifyScript() to also take the current block height/time - I\n> see no reason why it can't. As for the mempool, keeping track of what\n> transactions made use of these opcodes so they can be reevaluated if\n> their prevouts are re-organised seems fine to me.\n\nI'm totally fine with changing the interface to:\n\n     int bitcoinconsensus_verify_script(const unsigned char\n*scriptPubKey, unsigned int scriptPubKeyLen,\n                                        const unsigned char *txTo\n  , unsigned int txToLen, unsigned nHeight,\n                                        unsigned int nIn, unsigned int\nflags, bitcoinconsensus_error* err);\n\nI prefer op_maturity over RCLTV and there are also gains for absolute\nCLTV as you explain later.\nWhen you validate the script inputs of a transaction you already have\na height, either the real final nHeight in ConnectBlock and the miner,\nor nSpendHeight in AcceptToMemoryPool.\nThe costs are meaningless in my opinion, specially when we will\nalready have to change the interface to add libsecp256k1's context.\n\nI'm infinitely more worried about the other assumption that the 3\nsolutions are already making.\nChanging to\n\n     int bitcoinconsensus_verify_script(const unsigned char\n*scriptPubKey, unsigned int scriptPubKeyLen,\n                                        const unsigned char *txTo\n  , unsigned int txToLen, const CCoinsViewCache& inputs,\n                                        unsigned int nIn, unsigned int\nflags, bitcoinconsensus_error* err);\n\nIs simply not possible because CCoinsViewCache is a C++.\nYou could solve it in a similar way in which you could solve that\ndependency for VerifyTransaction.\nFor example:\n\ntypedef const CTxOut& (*TxOutputGetter)(const uint256& txid, uint32_t n);\n\n      int bitcoinconsensus_verify_script(const unsigned char\n*scriptPubKey, unsigned int scriptPubKeyLen,\n                                        const unsigned char *txTo\n  , unsigned int txToLen, TxOutputGetter utxoGetter,\n                                        unsigned int nIn, unsigned int\nflags, bitcoinconsensus_error* err);\n\nOf course, this is assuming that CTxOut becomes a C struct instead of\na C++ class and little things like that.\nIn terms of code encapsulation, this is still 100 times uglier than\nadding the nHeight so if we're doing it, yes, please, let's do both.\n\nThere's another possibility that could keep the utxo out of Script verification:\n\nclass CTxIn\n{\npublic:\n    COutPoint prevout;\n    CScript scriptSig;\n    uint32_t nSequence;\n}\n\ncould turn into:\n\nclass CTxIn\n{\npublic:\n    COutPoint prevout;\n    CScript scriptSig;\n    uint32_t nHeight;\n}\n\nAnd a new softfork rule could enforce that all new CTxIn set nHeight\nto the correct height in which its corresponding prevout got into the\nchain.\nThat would remove the need for the TxOutputGetter param in\nbitcoinconsensus_verify_script, but unfortunately it is not reorg safe\n(apart from other ugly implementation details).\n\nSo, in summary, I think the new interface has to be something along these lines:\n\n      int bitcoinconsensus_verify_script(const unsigned char\n*scriptPubKey, unsigned int scriptPubKeyLen,\n                                        const unsigned char *txTo,\nunsigned int nIn,\n                                        unsigned int txToLen,\nTxOutputGetter utxoGetter, unsigned nHeight, secp256k1_context_t *ctx\n                                        unsigned int flags,\nbitcoinconsensus_error* err);\n\n> Time-based locks\n> ================\n>\n> Do we want to support them at all? May cause incentive issues with\n> mining, see #bitcoin-wizards discussion, Jul 17th 2013:\n>\n> https://download.wpsoftware.net/bitcoin/wizards/2013/07/13-07-17.log\n\nI'm totally fine not supporting time-based locks for the new operators.\nRemoving them from the regular nLockTime could be more complicated but\nI wouldn't mind either.\nEvery time I think of a contract or protocol that involves time, I do\nit in terms of block heights.\nI would prefer to change all my clocks to work in blocks instead of\nminutes over changing nHeights for timestamps in any of those\ncontracts.\n\n> --\n> 'peter'[:-1]@petertodd.org\n> 0000000000000000015e09479548c5b63b99a62d31b019e6479f195bf0cbd935\n>\n> ------------------------------------------------------------------------------\n> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT\n> Develop your own process in accordance with the BPMN 2 standard\n> Learn Process modeling best practices with Bonita BPM through live exercises\n> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_\n> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2015-04-26T12:20:04",
                "message_text_only": "On Sun, Apr 26, 2015 at 1:35 PM, Jorge Tim\u00f3n <jtimon at jtimon.cc> wrote:\n> There's another possibility that could keep the utxo out of Script verification:\n>\n> class CTxIn\n> {\n> public:\n>     COutPoint prevout;\n>     CScript scriptSig;\n>     uint32_t nSequence;\n> }\n>\n> could turn into:\n>\n> class CTxIn\n> {\n> public:\n>     COutPoint prevout;\n>     CScript scriptSig;\n>     uint32_t nHeight;\n> }\n>\n> And a new softfork rule could enforce that all new CTxIn set nHeight\n> to the correct height in which its corresponding prevout got into the\n> chain.\n> That would remove the need for the TxOutputGetter param in\n> bitcoinconsensus_verify_script, but unfortunately it is not reorg safe\n> (apart from other ugly implementation details).\n\nWait, wait, this can be made reorg-safe and more backards compatible.\nThe new validation rule at the tx validation level (currently in\nmain::CheckInputs()) would be\n\nfor (unsigned int i = 0; i < tx.vin.size(); i++) {\n// ...\n            if (tx.vin.nHeight + 100 > tx.nLockTime)\n                return state.Invalid(false, REJECT_INVALID,\n\"bad-txns-vin-height-reorg-unsafe\");\n            if (coins->nHeight > tx.vin.nHeight)\n                return state.Invalid(false, REJECT_INVALID,\n\"bad-txns-vin-height-false\");\n// ...\n}\n\nExisting transactions that have used the deprecated CTxIn::nSequence\nfor something else will be fine if they've used low nSequences.\nThe only concern would be breaking some colored coins kernels, but\nthere's many others implemented that don't rely on CTxIn::nSequence.\n\nTransactions that want to use OP_MATURITY just have to set the\ncorresponding CTxIn::nHeight and CTransaction::nLockTime properly.\nThis way op_maturity wouldn't require anything from the utxo and the\nfinal interface could be:\n\n int bitcoinconsensus_verify_script(const unsigned char* scriptPubKey,\nunsigned int scriptPubKeyLen,\n                                        const unsigned char* txTo,\nunsigned int txToLen,\n                                        unsigned int nIn, unsigned int nHeight,\n                                        unsigned int flags,\nsecp256k1_context_t* ctx,\n                                        bitcoinconsensus_error* err);"
            },
            {
                "author": "Peter Todd",
                "date": "2015-04-27T19:35:26",
                "message_text_only": "On Sun, Apr 26, 2015 at 02:20:04PM +0200, Jorge Tim\u00f3n wrote:\n> On Sun, Apr 26, 2015 at 1:35 PM, Jorge Tim\u00f3n <jtimon at jtimon.cc> wrote:\n> > And a new softfork rule could enforce that all new CTxIn set nHeight\n> > to the correct height in which its corresponding prevout got into the\n> > chain.\n> > That would remove the need for the TxOutputGetter param in\n> > bitcoinconsensus_verify_script, but unfortunately it is not reorg safe\n> > (apart from other ugly implementation details).\n> \n> Wait, wait, this can be made reorg-safe and more backards compatible.\n> The new validation rule at the tx validation level (currently in\n> main::CheckInputs()) would be\n\n<snip>\n\nSo, seems to me that RCLTV opens up a whole rats nest of design\ndecisions and compromises that CLTV doesn't. Yet CLTV itself is a big\nstep forward, it's been implemented on Viacoin for the past few months\nwith no issues found, and has an extremely simple and easy to audit\nimplementation.\n\nI think I'm going to argue we implement it as-is in a soft-fork. Pieter\nWuille's been working on a new way to handle soft-fork upgrades in the\nblock nVersion field, so this would be a good opportunity to add\nsomething simple and well tested, and also make sure the new nVersion\nsoft-fork mechanism works. Equally, doing both at the same time ensures\nwe don't burn yet another version bit.\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000000e7980aab9c096c46e7f34c43a661c5cb2ea71525ebb8af7\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 650 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150427/1dcaa3c3/attachment.sig>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2015-04-28T07:44:14",
                "message_text_only": "Even if it's new and has not received any feedback, I think my solution to\nop_maturity is quite clean.\nBut anyway, yes, the non-relative cltv is much simpler in design and\ndoesn't have to wait for the other. On the other hand, I would upgrade it\nto absolute cltv like you suggested and take the current height as a\nparameter to verifyScript instead of using the nLockTime as reference.\nIf we know we're going to use it for rcltv/op_maturity, better put add soon\nrather than later, specially if that will give us a more powerful cltv.\nIf we don't want that height param, we can leave it out of for op_maturity\ntoo, but that's the wingle decision about rcltv/maturity that affects cltv\nso better solve that first.\nOn Apr 27, 2015 9:35 PM, \"Peter Todd\" <pete at petertodd.org> wrote:\n\n> On Sun, Apr 26, 2015 at 02:20:04PM +0200, Jorge Tim\u00f3n wrote:\n> > On Sun, Apr 26, 2015 at 1:35 PM, Jorge Tim\u00f3n <jtimon at jtimon.cc> wrote:\n> > > And a new softfork rule could enforce that all new CTxIn set nHeight\n> > > to the correct height in which its corresponding prevout got into the\n> > > chain.\n> > > That would remove the need for the TxOutputGetter param in\n> > > bitcoinconsensus_verify_script, but unfortunately it is not reorg safe\n> > > (apart from other ugly implementation details).\n> >\n> > Wait, wait, this can be made reorg-safe and more backards compatible.\n> > The new validation rule at the tx validation level (currently in\n> > main::CheckInputs()) would be\n>\n> <snip>\n>\n> So, seems to me that RCLTV opens up a whole rats nest of design\n> decisions and compromises that CLTV doesn't. Yet CLTV itself is a big\n> step forward, it's been implemented on Viacoin for the past few months\n> with no issues found, and has an extremely simple and easy to audit\n> implementation.\n>\n> I think I'm going to argue we implement it as-is in a soft-fork. Pieter\n> Wuille's been working on a new way to handle soft-fork upgrades in the\n> block nVersion field, so this would be a good opportunity to add\n> something simple and well tested, and also make sure the new nVersion\n> soft-fork mechanism works. Equally, doing both at the same time ensures\n> we don't burn yet another version bit.\n>\n> --\n> 'peter'[:-1]@petertodd.org\n> 00000000000000000e7980aab9c096c46e7f34c43a661c5cb2ea71525ebb8af7\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150428/ff9127d7/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Relative CHECKLOCKTIMEVERIFY (was CLTV proposal)",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jorge Tim\u00f3n",
                "Peter Todd"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 18019
        }
    },
    {
        "title": "[Bitcoin-development] Proof of Payment",
        "thread_messages": [
            {
                "author": "Kalle Rosenbaum",
                "date": "2015-04-22T20:03:47",
                "message_text_only": "Hi again\n\nI've built a proof-of-concept for Proof of Payment. It's available at\nhttp://www.rosenbaum.se:8080. The site contains links to the source code\nfor both the server and a Mycelium fork as well as pre-built apk:s.\n\nI'm still very interested in feedback on this, so please let me know what\nyou think.\n\nStuff that has come up so far, and my answers:\n\n* Some people think it's too complicated. I disagree. Using transactions as\nthe data structure actually makes it simple to implement both on the server\nand in wallets. Just use existing wallet software to sign and verify PoPs.\n\n* Other ideas on Proof of Payment use a single key from the proven\ntransaction, for example the first key from the first input of the\ntransaction. This is problematic when multisig and other P2SH transactions\nare used. I also think that it's necessary to use *all* credentials used\nfor the transaction. Otherwise we wouldn't be sure that the sender actually\nhave all the needed credentials.\n\n* Another suggestion is that a payment request from BIP70 is used as proof.\nThat is possible, but it's reusable which makes it inappropriate to send\nover networks; If it is stolen somewhere, anyone can use it as many times\nthey like. As stated in BIP70, the payment request is suitable for dispute\nresolution, more like a receipt. On the other hand, I think that PoP would\nfit nicely into the workflow of BIP70: a) Read a url for the PoP request,\nb) get the (possibly signed) PoP request. c) send the PoP through http POST\nto the URL in the PoP request, d) profit!\n\n* A thought of my own: The txid used in the PoP output is not strictly\nnecessary. It's more of a convenience for the verifier of the PoP. Without\nit, the verifier would need to lookup the transaction based on the inputs\nof the PoP,\n\nRegards,\nKalle Rosenbaum\n\n2015-03-14 19:16 GMT+01:00 Kalle Rosenbaum <kalle at rosenbaum.se>:\n\n> Den 14 mar 2015 00:59 skrev \"Patrick Mccorry (PGR)\" <\n> patrick.mccorry at newcastle.ac.uk>:\n> >\n> > That all seems more complicated than it needs to be - the service you\n> are paying knows that it had received a payment from some public key Q\n> (regardless of script type, as all scripts require a public key).\n>\n> The service knows it had received a payment from Q1, Q2,...,Qn. A tx may\n> have multiple inputs and each input may have several public keys.\n>\n> >\n> > So I want to rent a movie, they send me a challenge and I respond with a\n> zero knowledge proof to demonstrate that I am the owner of Q, and as they\n> know that Q made a payment - then there is a proof of payment - as this is\n> provided by the time stamped transaction on the blockchain - in this sense\n> you are bootstrapping trust from the blockchain.\n> >\n>\n> Ok. Without knowing much about zero knowledge proof, i guess you'd need a\n> challenge/response for each of the keys Q1,..,Qn. If we settle on only a\n> single key, what key from what input should we use? One input may be a\n> multisig (2 of 3) input. Is it ok to settle on only one of the multisig\n> keys? Probably not. I'd say that we need 2 of 3 signatures (just as in a\n> bitcoin transaction), and not necessarily the same two that made the\n> payment.\n>\n> > For all of your scenarios, a simple challenge-response scheme would\n> work. Adding an op_return makes the payment transaction worse as it is now\n> distinguishable on the blockchain - you want use information that is\n> already available on that transaction.\n>\n> I'm not sure I follow. Do you mean that it's a problem that the PoP itself\n> reveals what transaction I'm proving? Well, maybe it is a problem under\n> some circumstances. The least you can do to protect yourself from revealing\n> information to third party is to communicate over secure channels. Could\n> you please elaborate on this?\n>\n> Anyway, if both the client and the server knows what transaction to prove\n> (ad-sign example) you are right that the tx info is kind of redundant. But\n> if we don't send the tx hints from server to client, the client user must\n> manually select the transaction to prove which makes the user experience\n> worse.\n>\n> Thank you very much for your comments,\n>\n> /Kalle\n>\n> >\n> > Sent from my iPhone\n> >\n> > On 13 Mar 2015, at 19:58, Kalle Rosenbaum <kalle at rosenbaum.se> wrote:\n> >\n> >> Hi all,\n> >>\n> >> I've been thinking about how a person can prove that she has made a\n> payment. I came up with an idea I call Proof of Payment (PoP) and I would\n> highly appreciate your comments. Has something like this been discussed\n> somewhere before?\n> >>\n> >> Use cases\n> >>\n> >> There are several scenarios in which it would be useful to prove that\n> you have paid for something. For example:\n> >> A pre-paid hotel room where your PoP functions as a key to the door.\n> >> An online video rental service where you pay for a video and watch it\n> on any device.\n> >> An ad-sign where you pay in advance for e.g. 2-weeks exclusivity.\n> During this period you can upload new content to the sign whenever you like\n> using PoP.\n> >> A lottery where all participants pay to the same address, and the\n> winner of the T-shirt is selected among the transactions to that address.\n> You exchange the T-shirt for a PoP for the winning transaction.\n> >>\n> >> These use cases can be achieved without any personal information (no\n> accounts, no e-mails, etc) being involved.\n> >>\n> >> Desirable properties:\n> >> A PoP should be generated on demand.\n> >> It should only be usable once to avoid issues due to theft.\n> >> It should be able to create a PoP for any payment, regardless of script\n> type (P2SH, P2PKH, etc.).\n> >> Current methods of proving a payment, as I know of:\n> >> BIP0070, The PaymentRequest together with the transactions fulfilling\n> the payment makes some sort of proof. However, it does not meet 1 or 2 and\n> it obviously only meets 3 if the payment is made through BIP0070. Also,\n> there's no standard way to request/provide the proof.\n> >> Signing messages, chosen by the entity that the proof is provided to,\n> with the private keys used to sign the transaction. This could meet 1 and 2\n> but probably not 3. This is not standardized either.\n> >> Proof of Payment, the data structure\n> >>\n> >> A proof of payment for a transaction T, PoP(T), is used to prove that\n> one has ownership of the credentials needed to unlock all the inputs of T.\n> It has the exact same structure as a bitcoin transaction with the same\n> inputs as T and with a single OP_RETURN output:\n> >>\n> >> OP_RETURN PoP <txid> <nonce>\n> >>\n> >> | Field     | Size [B] | Description                        |\n> >> |-----------|----------|------------------------------------|\n> >> | PoP       | 3        | Literal identifying this as a PoP  |\n> >> | <txid>    | 32       | The transaction to Prove           |\n> >> | <nonce>   | 5        | Unsigned integer                   |\n> >>\n> >> The PoP is signed using the same signing process that is used for\n> bitcoin transactions. The purpose of the nonce is to make it harder to use\n> a stolen PoP. Once the PoP has reached the destination, that PoP is useless\n> since the destination will generate a new nonce for every PoP.\n> >>\n> >> Proof of Payment, the process\n> >> A proof of payment request is sent from the server to the wallet. The\n> request contains:\n> >> a random nonce\n> >> a destination where to send the PoP, for example a https URL\n> >> data hinting the wallet which transaction to create a proof for. For\n> example:\n> >> txid, if known by the server\n> >> PaymentRequest.PaymentDetails.merchant_data (in case of a BIP0070\n> payment)\n> >> amount\n> >> label, message or other information from a BIP0021 URL\n> >> The wallet identifies the transaction T, if possible. Otherwise asks\n> the user to select among the ones that fit the hints in 1.3.\n> >> The wallet checks that T is on the blockchain, meaning all the inputs\n> are spent.\n> >> The wallet creates an unsigned PoP (UPoP) for T, and asks the user to\n> sign it.\n> >> The user confirms\n> >> The UPoP(T) is signed by the wallet, creating PoP(T).\n> >> The PoP is sent to the destination in 1.2.\n> >> The server receiving the PoP validates it and responds with \u201cvalid\u201d or\n> \u201cinvalid\u201d\n> >> The wallet displays the response in some way to the user.\n> >> Remarks:\n> >> The method of transferring the PoP request at step 1 is not very well\n> thought through, but I think we can extend BIP0021 to cater for this. For\n> example read a URI, representing a PoP request, using QR code or NFC. A\n> more advanced approach would be to extend BIP0070.\n> >> The nonce must be randomly generated by the server for every new PoP\n> request.\n> >> Validating a PoP\n> >>\n> >> The server needs to validate the PoP and reply with \u201cvalid\u201d or\n> \u201cinvalid\u201d. That process is outlined below:\n> >> Check the format of the PoP. It must pass normal transaction checks,\n> except for the inputs being already spent.\n> >> Check the output script. It must conform to the OP_RETURN output format\n> outlined above.\n> >> Check that the nonce is the same as the one you requested.\n> >> Check that the txid in the output is the transaction you actually want\n> proof for. If you don\u2019t know what transaction you want proof for, check\n> that the transaction actually pays for the product/service you deliver (in\n> the video rental case, find the transaction among all payments for that\n> specific video).\n> >> Check that the inputs of the PoP are exactly the same as in transaction\n> T.\n> >> Check the signatures of all the inputs, as would be done on a normal\n> transaction.\n> >> If the signatures are valid, the PoP is valid.\n> >> Security issues\n> >> Someone can intercept the PoP-request and change the destination so\n> that the user sends the PoP to the bad actor.\n> >> Someone can intercept the PoP-request and change for example the txid\n> to trick the user to sign a PoP for another transaction than the intended.\n> This can of course be avoided by actually looking at the UPoP before\n> signing it. The bad actor could also set hints for a transaction that the\n> user didn\u2019t make, resulting in a broken service.\n> >> Someone can steal a PoP and try to use the service hoping to get a\n> matching nonce. Probability per try: 1/(2^40). The server should have\n> mechanism for detecting a brute force attack of this kind, or at least slow\n> down the process by delaying the PoP request by some 100 ms or so.\n> >> Even if a wallet has no funds it might still be valuable as a generator\n> for PoPs. This makes it important to keep the security of the wallet after\n> it has been emptied.\n> >> The first two issues are the same as for traditional bitcoin payments.\n> They could be mitigated by using secure connections and possibly also\n> extending BIP0070 to support PoPs.\n> >>\n> >> Further work\n> >> Figure out how to make use of, and extend, BIP0070 for the purpose of\n> PoPs\n> >> Define an extension for BIP0021 to support PoP requests (something\n> along the lines of BIP0072)\n> >> Implement a proof-of-concept\n> >> Possibly propose BIPs for the different parts.\n> >> Looking forward to reading your comments\n> >> Regards,\n> >> Kalle Rosenbaum\n> >>\n> >>\n> ------------------------------------------------------------------------------\n> >> Dive into the World of Parallel Programming The Go Parallel Website,\n> sponsored\n> >> by Intel and developed in partnership with Slashdot Media, is your hub\n> for all\n> >> things parallel software development, from weekly thought leadership\n> blogs to\n> >> news, videos, case studies, tutorials and more. Take a look and join\n> the\n> >> conversation now. http://goparallel.sourceforge.net/\n> >>\n> >> _______________________________________________\n> >> Bitcoin-development mailing list\n> >> Bitcoin-development at lists.sourceforge.net\n> >> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150422/c92cc146/attachment.html>"
            },
            {
                "author": "Tom Harding",
                "date": "2015-04-27T00:50:22",
                "message_text_only": "On 4/22/2015 1:03 PM, Kalle Rosenbaum wrote:\n>\n> I've built a proof-of-concept for Proof of Payment. It's available at\n> http://www.rosenbaum.se:8080. The site contains links to the source\n> code for both the server and a Mycelium fork as well as pre-built apk:s.\n>\n>\n>     >> There are several scenarios in which it would be useful to\n>     prove that you have paid for something. For example:\n>     >> A pre-paid hotel room where your PoP functions as a key to the\n>     door.\n>     >> An online video rental service where you pay for a video and\n>     watch it on any device.\n>     >> An ad-sign where you pay in advance for e.g. 2-weeks\n>     exclusivity. During this period you can upload new content to the\n>     sign whenever you like using PoP.\n>     >> A lottery where all participants pay to the same address, and\n>     the winner of the T-shirt is selected among the transactions to\n>     that address. You exchange the T-shirt for a PoP for the winning\n>     transaction.\n>\n\nKalle,\n\nYou propose a standard format for proving that wallet-controlled funds\nCOULD HAVE BEEN spent as they were in a real transaction.  Standardized\nPoP would give wallets a new way to communicate with the outside world.\n\nPoP could allow payment and delivery to be separated in time in a\nstandard way, without relying on a mechanism external to bitcoin's\ncryptosystem, and enable standardized real-world scenarios where sender\n!= beneficiary, and/or receiver != provider.\n\nPayment:\nsender -> receiver\n\nDelivery:\nbeneficiary <- provider\n\nSome more use cases might be:\nWaiting in comfort:\n - Send a payment ahead of time, then wander over and collect the goods\nafter X confirmations.\n\nAuthorized pickup :\n - Hot wallet software used by related people could facilitate the use\nof 1 of N multisig funds.  Any one of the N wallets could collect goods\nand services purchased by any of the others.\n\nNon-monetary gifts:\n - Sender exports spent keys to a beneficiary, enabling PoP to work as a\ngift claim\n\nContingent services:\n - Without Bob's permission, a 3rd party conditions action on a payment\nmade from Alice to Bob.  For example, if you donated at least .02 BTC to\nDorian, you (or combining scenarios, any of your N authorized family\nmembers), can come to my dinner party.\n\nI tried out your demo wallet and service and it worked as advertised.\n\nCould the same standard also be used to prove that a transaction COULD\nBE created?  To generalize the concept beyond actual payments, you could\ncall it something like proof of payment potential.\n\nWhy not make these proofs permanently INVALID transactions, to remove\nany possibility of their being mined and spending everything to fees\nwhen used in this way, and also in cases involving reorganizations?\n\nI agree that PoP seems complementary to BIP70."
            },
            {
                "author": "Kalle Rosenbaum",
                "date": "2015-04-27T12:35:27",
                "message_text_only": ">\n> Some more use cases might be:\n> Waiting in comfort:\n>  - Send a payment ahead of time, then wander over and collect the goods\n> after X confirmations.\n>\n> Authorized pickup :\n>  - Hot wallet software used by related people could facilitate the use\n> of 1 of N multisig funds.  Any one of the N wallets could collect goods\n> and services purchased by any of the others.\n\nI like this one, because it shows the power of reusing the transaction data\nstructure.\n\n>\n> Non-monetary gifts:\n>  - Sender exports spent keys to a beneficiary, enabling PoP to work as a\n> gift claim\n>\n> Contingent services:\n>  - Without Bob's permission, a 3rd party conditions action on a payment\n> made from Alice to Bob.  For example, if you donated at least .02 BTC to\n> Dorian, you (or combining scenarios, any of your N authorized family\n> members), can come to my dinner party.\n\nThis is an interesting one.\n\n>\n> I tried out your demo wallet and service and it worked as advertised.\n>\n> Could the same standard also be used to prove that a transaction COULD\n> BE created?  To generalize the concept beyond actual payments, you could\n> call it something like proof of payment potential.\n\nI guess it's possible, but we'd have to remove the txid from the output,\nsince there is none. This is a way of saying \"I'm in control of these\naddresses\". The other party/parties can then verify the funds on the\nblockchain and watch those addresses for changes. Maybe there are some\ninteresting use cases here. Ideas?\n\n>\n> Why not make these proofs permanently INVALID transactions, to remove\n> any possibility of their being mined and spending everything to fees\n> when used in this way, and also in cases involving reorganizations?\n\nYes. Initially I thought it would be enough that the funds are already\nspent, but I think you're right here. Reorgs could be a problem. Worse, you\nalso might want to prove 0-confirmation transactions, in which case it's a\nhuge security problem. Someone might intercept the PoP and publish it on\nthe bitcoin network, spending all the funds. But I still would like wallets\nto be able to build/verify PoPs with little or no modifications. Could we\npossibly change the version number on the PoP to something other than 1?\nMaybe 2^4-1? Or a really high lock_time, but it would not make it invalid,\njust delayed. Any suggestions here?\n\n>\n> I agree that PoP seems complementary to BIP70.\n>\n>\n\nThank you very much for your comments!\n\n/Kalle\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150427/66ecb226/attachment.html>"
            },
            {
                "author": "Kalle Rosenbaum",
                "date": "2015-04-27T12:41:51",
                "message_text_only": "\"Or a really high lock_time, but it would not make it invalid, just\ndelayed.\"\n\nOk, this was a bad idea, since nodes would have to keep it in memory.\nPlease disregard that idea...\n\nKalle\n\nDen 27 apr 2015 14:35 skrev \"Kalle Rosenbaum\" <kalle at rosenbaum.se>:\n>\n> >\n> > Some more use cases might be:\n> > Waiting in comfort:\n> >  - Send a payment ahead of time, then wander over and collect the goods\n> > after X confirmations.\n> >\n> > Authorized pickup :\n> >  - Hot wallet software used by related people could facilitate the use\n> > of 1 of N multisig funds.  Any one of the N wallets could collect goods\n> > and services purchased by any of the others.\n>\n> I like this one, because it shows the power of reusing the transaction\ndata structure.\n>\n> >\n> > Non-monetary gifts:\n> >  - Sender exports spent keys to a beneficiary, enabling PoP to work as a\n> > gift claim\n> >\n> > Contingent services:\n> >  - Without Bob's permission, a 3rd party conditions action on a payment\n> > made from Alice to Bob.  For example, if you donated at least .02 BTC to\n> > Dorian, you (or combining scenarios, any of your N authorized family\n> > members), can come to my dinner party.\n>\n> This is an interesting one.\n>\n> >\n> > I tried out your demo wallet and service and it worked as advertised.\n> >\n> > Could the same standard also be used to prove that a transaction COULD\n> > BE created?  To generalize the concept beyond actual payments, you could\n> > call it something like proof of payment potential.\n>\n> I guess it's possible, but we'd have to remove the txid from the output,\nsince there is none. This is a way of saying \"I'm in control of these\naddresses\". The other party/parties can then verify the funds on the\nblockchain and watch those addresses for changes. Maybe there are some\ninteresting use cases here. Ideas?\n>\n> >\n> > Why not make these proofs permanently INVALID transactions, to remove\n> > any possibility of their being mined and spending everything to fees\n> > when used in this way, and also in cases involving reorganizations?\n>\n> Yes. Initially I thought it would be enough that the funds are already\nspent, but I think you're right here. Reorgs could be a problem. Worse, you\nalso might want to prove 0-confirmation transactions, in which case it's a\nhuge security problem. Someone might intercept the PoP and publish it on\nthe bitcoin network, spending all the funds. But I still would like wallets\nto be able to build/verify PoPs with little or no modifications. Could we\npossibly change the version number on the PoP to something other than 1?\nMaybe 2^4-1? Or a really high lock_time, but it would not make it invalid,\njust delayed. Any suggestions here?\n>\n> >\n> > I agree that PoP seems complementary to BIP70.\n> >\n> >\n>\n> Thank you very much for your comments!\n>\n> /Kalle\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150427/2b7d51b6/attachment.html>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2015-04-28T07:23:53",
                "message_text_only": "So at the low level, how does a \"proof of payment\" differ from just proving\nthat a given transaction is in a given block (what SPV nodes take as proof\nof payment today)?\nOn Apr 27, 2015 2:42 PM, \"Kalle Rosenbaum\" <kalle at rosenbaum.se> wrote:\n\n> \"Or a really high lock_time, but it would not make it invalid, just\n> delayed.\"\n>\n> Ok, this was a bad idea, since nodes would have to keep it in memory.\n> Please disregard that idea...\n>\n> Kalle\n>\n> Den 27 apr 2015 14:35 skrev \"Kalle Rosenbaum\" <kalle at rosenbaum.se>:\n> >\n> > >\n> > > Some more use cases might be:\n> > > Waiting in comfort:\n> > >  - Send a payment ahead of time, then wander over and collect the goods\n> > > after X confirmations.\n> > >\n> > > Authorized pickup :\n> > >  - Hot wallet software used by related people could facilitate the use\n> > > of 1 of N multisig funds.  Any one of the N wallets could collect goods\n> > > and services purchased by any of the others.\n> >\n> > I like this one, because it shows the power of reusing the transaction\n> data structure.\n> >\n> > >\n> > > Non-monetary gifts:\n> > >  - Sender exports spent keys to a beneficiary, enabling PoP to work as\n> a\n> > > gift claim\n> > >\n> > > Contingent services:\n> > >  - Without Bob's permission, a 3rd party conditions action on a payment\n> > > made from Alice to Bob.  For example, if you donated at least .02 BTC\n> to\n> > > Dorian, you (or combining scenarios, any of your N authorized family\n> > > members), can come to my dinner party.\n> >\n> > This is an interesting one.\n> >\n> > >\n> > > I tried out your demo wallet and service and it worked as advertised.\n> > >\n> > > Could the same standard also be used to prove that a transaction COULD\n> > > BE created?  To generalize the concept beyond actual payments, you\n> could\n> > > call it something like proof of payment potential.\n> >\n> > I guess it's possible, but we'd have to remove the txid from the output,\n> since there is none. This is a way of saying \"I'm in control of these\n> addresses\". The other party/parties can then verify the funds on the\n> blockchain and watch those addresses for changes. Maybe there are some\n> interesting use cases here. Ideas?\n> >\n> > >\n> > > Why not make these proofs permanently INVALID transactions, to remove\n> > > any possibility of their being mined and spending everything to fees\n> > > when used in this way, and also in cases involving reorganizations?\n> >\n> > Yes. Initially I thought it would be enough that the funds are already\n> spent, but I think you're right here. Reorgs could be a problem. Worse, you\n> also might want to prove 0-confirmation transactions, in which case it's a\n> huge security problem. Someone might intercept the PoP and publish it on\n> the bitcoin network, spending all the funds. But I still would like wallets\n> to be able to build/verify PoPs with little or no modifications. Could we\n> possibly change the version number on the PoP to something other than 1?\n> Maybe 2^4-1? Or a really high lock_time, but it would not make it invalid,\n> just delayed. Any suggestions here?\n> >\n> > >\n> > > I agree that PoP seems complementary to BIP70.\n> > >\n> > >\n> >\n> > Thank you very much for your comments!\n> >\n> > /Kalle\n>\n>\n> ------------------------------------------------------------------------------\n> One dashboard for servers and applications across Physical-Virtual-Cloud\n> Widest out-of-the-box monitoring support with 50+ applications\n> Performance metrics, stats and reports that give you Actionable Insights\n> Deep dive visibility with transaction tracing using APM Insight.\n> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150428/9bf79c5d/attachment.html>"
            },
            {
                "author": "Kalle Rosenbaum",
                "date": "2015-04-28T12:41:40",
                "message_text_only": "Hi Jorge,\n\nI don't think I understand the question. Proof of Payment is used to prove\nthat you have the credentials needed for a certain transaction. It does not\ncare where in the blockchain the transaction is. Or if it's in the\nblockchain at all.\n\n/Kalle\n\nSo at the low level, how does a \"proof of payment\" differ from just proving\nthat a given transaction is in a given block (what SPV nodes take as proof\nof payment today)?\nOn Apr 27, 2015 2:42 PM, \"Kalle Rosenbaum\" <kalle at rosenbaum.se> wrote:\n\n> \"Or a really high lock_time, but it would not make it invalid, just\n> delayed.\"\n>\n> Ok, this was a bad idea, since nodes would have to keep it in memory.\n> Please disregard that idea...\n>\n> Kalle\n>\n> Den 27 apr 2015 14:35 skrev \"Kalle Rosenbaum\" <kalle at rosenbaum.se>:\n> >\n> > >\n> > > Some more use cases might be:\n> > > Waiting in comfort:\n> > >  - Send a payment ahead of time, then wander over and collect the goods\n> > > after X confirmations.\n> > >\n> > > Authorized pickup :\n> > >  - Hot wallet software used by related people could facilitate the use\n> > > of 1 of N multisig funds.  Any one of the N wallets could collect goods\n> > > and services purchased by any of the others.\n> >\n> > I like this one, because it shows the power of reusing the transaction\n> data structure.\n> >\n> > >\n> > > Non-monetary gifts:\n> > >  - Sender exports spent keys to a beneficiary, enabling PoP to work as\n> a\n> > > gift claim\n> > >\n> > > Contingent services:\n> > >  - Without Bob's permission, a 3rd party conditions action on a payment\n> > > made from Alice to Bob.  For example, if you donated at least .02 BTC\n> to\n> > > Dorian, you (or combining scenarios, any of your N authorized family\n> > > members), can come to my dinner party.\n> >\n> > This is an interesting one.\n> >\n> > >\n> > > I tried out your demo wallet and service and it worked as advertised.\n> > >\n> > > Could the same standard also be used to prove that a transaction COULD\n> > > BE created?  To generalize the concept beyond actual payments, you\n> could\n> > > call it something like proof of payment potential.\n> >\n> > I guess it's possible, but we'd have to remove the txid from the output,\n> since there is none. This is a way of saying \"I'm in control of these\n> addresses\". The other party/parties can then verify the funds on the\n> blockchain and watch those addresses for changes. Maybe there are some\n> interesting use cases here. Ideas?\n> >\n> > >\n> > > Why not make these proofs permanently INVALID transactions, to remove\n> > > any possibility of their being mined and spending everything to fees\n> > > when used in this way, and also in cases involving reorganizations?\n> >\n> > Yes. Initially I thought it would be enough that the funds are already\n> spent, but I think you're right here. Reorgs could be a problem. Worse, you\n> also might want to prove 0-confirmation transactions, in which case it's a\n> huge security problem. Someone might intercept the PoP and publish it on\n> the bitcoin network, spending all the funds. But I still would like wallets\n> to be able to build/verify PoPs with little or no modifications. Could we\n> possibly change the version number on the PoP to something other than 1?\n> Maybe 2^4-1? Or a really high lock_time, but it would not make it invalid,\n> just delayed. Any suggestions here?\n> >\n> > >\n> > > I agree that PoP seems complementary to BIP70.\n> > >\n> > >\n> >\n> > Thank you very much for your comments!\n> >\n> > /Kalle\n>\n>\n> ------------------------------------------------------------------------------\n> One dashboard for servers and applications across Physical-Virtual-Cloud\n> Widest out-of-the-box monitoring support with 50+ applications\n> Performance metrics, stats and reports that give you Actionable Insights\n> Deep dive visibility with transaction tracing using APM Insight.\n> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150428/01883ab9/attachment.html>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2015-04-28T12:53:58",
                "message_text_only": "Forget it, sorry, I misunderstood the proposal entirely, re-reading\nwith more care...\n\nOn Tue, Apr 28, 2015 at 2:41 PM, Kalle Rosenbaum <kalle at rosenbaum.se> wrote:\n> Hi Jorge,\n>\n> I don't think I understand the question. Proof of Payment is used to prove\n> that you have the credentials needed for a certain transaction. It does not\n> care where in the blockchain the transaction is. Or if it's in the\n> blockchain at all.\n>\n> /Kalle\n>\n> So at the low level, how does a \"proof of payment\" differ from just proving\n> that a given transaction is in a given block (what SPV nodes take as proof\n> of payment today)?\n>\n> On Apr 27, 2015 2:42 PM, \"Kalle Rosenbaum\" <kalle at rosenbaum.se> wrote:\n>>\n>> \"Or a really high lock_time, but it would not make it invalid, just\n>> delayed.\"\n>>\n>> Ok, this was a bad idea, since nodes would have to keep it in memory.\n>> Please disregard that idea...\n>>\n>> Kalle\n>>\n>> Den 27 apr 2015 14:35 skrev \"Kalle Rosenbaum\" <kalle at rosenbaum.se>:\n>> >\n>> > >\n>> > > Some more use cases might be:\n>> > > Waiting in comfort:\n>> > >  - Send a payment ahead of time, then wander over and collect the\n>> > > goods\n>> > > after X confirmations.\n>> > >\n>> > > Authorized pickup :\n>> > >  - Hot wallet software used by related people could facilitate the use\n>> > > of 1 of N multisig funds.  Any one of the N wallets could collect\n>> > > goods\n>> > > and services purchased by any of the others.\n>> >\n>> > I like this one, because it shows the power of reusing the transaction\n>> > data structure.\n>> >\n>> > >\n>> > > Non-monetary gifts:\n>> > >  - Sender exports spent keys to a beneficiary, enabling PoP to work as\n>> > > a\n>> > > gift claim\n>> > >\n>> > > Contingent services:\n>> > >  - Without Bob's permission, a 3rd party conditions action on a\n>> > > payment\n>> > > made from Alice to Bob.  For example, if you donated at least .02 BTC\n>> > > to\n>> > > Dorian, you (or combining scenarios, any of your N authorized family\n>> > > members), can come to my dinner party.\n>> >\n>> > This is an interesting one.\n>> >\n>> > >\n>> > > I tried out your demo wallet and service and it worked as advertised.\n>> > >\n>> > > Could the same standard also be used to prove that a transaction COULD\n>> > > BE created?  To generalize the concept beyond actual payments, you\n>> > > could\n>> > > call it something like proof of payment potential.\n>> >\n>> > I guess it's possible, but we'd have to remove the txid from the output,\n>> > since there is none. This is a way of saying \"I'm in control of these\n>> > addresses\". The other party/parties can then verify the funds on the\n>> > blockchain and watch those addresses for changes. Maybe there are some\n>> > interesting use cases here. Ideas?\n>> >\n>> > >\n>> > > Why not make these proofs permanently INVALID transactions, to remove\n>> > > any possibility of their being mined and spending everything to fees\n>> > > when used in this way, and also in cases involving reorganizations?\n>> >\n>> > Yes. Initially I thought it would be enough that the funds are already\n>> > spent, but I think you're right here. Reorgs could be a problem. Worse, you\n>> > also might want to prove 0-confirmation transactions, in which case it's a\n>> > huge security problem. Someone might intercept the PoP and publish it on the\n>> > bitcoin network, spending all the funds. But I still would like wallets to\n>> > be able to build/verify PoPs with little or no modifications. Could we\n>> > possibly change the version number on the PoP to something other than 1?\n>> > Maybe 2^4-1? Or a really high lock_time, but it would not make it invalid,\n>> > just delayed. Any suggestions here?\n>> >\n>> > >\n>> > > I agree that PoP seems complementary to BIP70.\n>> > >\n>> > >\n>> >\n>> > Thank you very much for your comments!\n>> >\n>> > /Kalle\n>>\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> One dashboard for servers and applications across Physical-Virtual-Cloud\n>> Widest out-of-the-box monitoring support with 50+ applications\n>> Performance metrics, stats and reports that give you Actionable Insights\n>> Deep dive visibility with transaction tracing using APM Insight.\n>> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>"
            },
            {
                "author": "Kalle Rosenbaum",
                "date": "2015-04-23T14:39:15",
                "message_text_only": "Hi Martin,\n\nThank you very much for your comments. See my answers inline:\n\nDen 23 apr 2015 03:28 skrev \"Martin Lie\" <martin at datamagi.no>:\n>\n> Hej, Kalle.\n>\n> I love the idea of standardised PoPs, including a protocol for\nrequesting/sending them as an extension of BIP-70.\n>\n\nMe too!\n\n>\n> A couple of comments:\n>\n> 1. You admit that the txid is just a convenience and not strictly\nnecessary. Perhaps this should be reflected in the sequence of bits/bytes\nin the record you're proposing, e.g. \"OP_RETURN POP_LITERAL <nonce> <txid>\"?\n>\n\nI was thinking that txid should be mandatory just as the nonce so the order\nwas arbitrarily chosen. I think you may be right that it's more intuitive\nto put txid last if it's not mandatory in a future version. It makes sense\nto swap order. I'll put that on my todo list.\n\n> 2. Building on #1, perhaps there could be other identifying information\nthan a txid? Perhaps a txid field shouldn't be \"hardcoded\" into the\nstandard at all?\n>\n> How about taking the same approach as BIP-43 (and others) and use a\nprefix that determines how the rest of the records should be interpreted,\ni.e. a \"type\" (or \"purpose\" or \"version\" or whatever you'd like to call it)\nfield. This would allow for different purposes/versions of a PoP, including\nas of now unforeseen ones.\n>\n> The new structure would then be:\n> OP_RETURN POP_PREFIX POP_TYPE POP_NONCE POP_PAYLOAD\n>\n> POP_PREFIX (? bytes): I'll leave it up to you to specify the exact bits\n(and length) of the POP_PREFIX, but if your literal is used, it'd be 3\nbytes: 0x506f50.\n>\n> Literals in Bitcoin protocols generally seem to be of the \"binary\" sort\nas opposed to human-readable text, so perhaps the devs wouldn't ACK\nsomething as \"wasteful\" as using 3 bytes just to identify it as a PoP\nrecord? Obviously, this is a small detail that can be changed at short\nnotice, but as with all standards - once people start using it, you're\nmostly stuck with what you have. ;)\n>\n\nYes, maybe we could drop POP_PREFIX altogether. The server is expecting a\npop and can therefore just assume it's a pop. No need to explicitly write\nthat inside the pop. Can you think of a scenario where it is actually\nneeded. Keeping the POP_PREFIX makes sense only if other transaction-like\ndata structures with OP_RETURN appears in the same contexts as pops. What\ndo you think?\n\n> POP_TYPE: (1 byte): 0x01 for your \"standard\" version, which would mean\nthat the payload contains a txid.\n>\n\nThis is a good idea. Todo!\n\n> POP_NONCE: (4 bytes): \"2^32 re-uses should be enough for everyone\", no? ;)\n>\n\nEuhm, well, I don't know... The bigger the better. If we drop POP_PREFIX we\ncould allow for 2 bytes version and 6 bytes nonce. Or 1 byte version and 7\nbytes nonce.\n\n> POP_PAYLOAD (32+ bytes): The contents of which is determined by POP_TYPE,\ne.g. a txid or possibly extra nonce data. Or perhaps some text that makes\nthe purpose or context of this PoP human-readable? (This could then be\nstored by wallets in order to show a list of what kind of proofs you've\nsent.)\n>\n\nFor now I think I'll stick to \"txid is mandatory\".\n\n>\n> 3. I noticed that your post-OP_RETURN structure included exactly 40\nbytes. Is that due to the 40-byte limitation on OP_RETURN's \"data\"? Are you\naware that it will be increased to 80 bytes? Cf. https://\n<https://github.com/bitcoin/bitcoin/pull/5286>github.com\n<https://github.com/bitcoin/bitcoin/pull/5286>/\n<https://github.com/bitcoin/bitcoin/pull/5286>bitcoin\n<https://github.com/bitcoin/bitcoin/pull/5286>/\n<https://github.com/bitcoin/bitcoin/pull/5286>bitcoin\n<https://github.com/bitcoin/bitcoin/pull/5286>/pull/5286\n<https://github.com/bitcoin/bitcoin/pull/5286>\n>\n\nYes, I deliberately limited the data to 40 bytes for that reason. With\nversioning, this may change in the future.\n\n> :)\n>\n>\n> Vennlig hilsen\n> Martin Lie\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150423/22c25248/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Proof of Payment",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Kalle Rosenbaum",
                "Jorge Tim\u00f3n",
                "Tom Harding"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 36912
        }
    },
    {
        "title": "[Bitcoin-development] Reusable payment codes",
        "thread_messages": [
            {
                "author": "Justus Ranvier",
                "date": "2015-04-24T20:00:46",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\n\nHash: SHA1\n\n\nhttps://github.com/justusranvier/rfc/blob/payment_code/bips/bip-pc01.mediawiki\n\n\nThis link contains an RFC for a new type of Bitcoin address called a\n\"payment code\"\n\n\nPayment codes are SPV-friendly alternatives to DarkWallet-style stealth\naddresses which provide useful features such as positively identifying\nsenders to recipients and automatically providing for transaction refunds.\n\n\nPayment codes can be publicly advertised and associated with a real-life\nidentity without causing a loss of financial privacy.\n\n\nCompared to stealth addresses, payment codes require less blockchain data\nstorage.\n\n\nPayment codes require 65 bytes of OP_RETURN data per sender-recipient pair,\nwhile stealth addresses require 40 bytes per transaction.\n\n\n-----BEGIN PGP SIGNATURE-----\n\nVersion: GnuPG v1\n\n\niQIcBAEBAgAGBQJVOqCRAAoJECpf2nDq2eYjluEP/RVJk+miDIihY4ilIvUbKvMd\n\nJLLqHr7Q1dlZyMIG/UqVWdoP5hzg/16B+q2iAB9jXozPnrDp0mggBh6rIGroevAa\n\nKqfrs+Rrog1w9auhd67LWORDqav6YIrjTJIxdLxe11IEiq5rWbHPNUEDMzdEmHbz\n\nQfTH7KWAP2BasO5ETXcfu6BcccrXZ3XOKLON2h3NGD/cEDizY+uT2k3QN54z+KxG\n\nNB9scKbzVvsJwkyBrgbV+As9H3k6PnFsojYgAaE9gkp7D2+ahjzUiOH5rv6TbbYR\n\no2X5MOiTY2/YZEqZPG7IR03ZAgeLVCvXXysjPOfzUKbmTF4w849sm8BuhixzDXHo\n\n2V/HHKoGclIohcODBCWi0tVQXshZt4QkCNJBW5o3nL6Nn2YOp6hmw8YKAHnw3E7h\n\n/wIgk5f+NOLl/iIxoAxAdavEj5P6N4ic+OB6MAjnhEilWfBvCIpqWLGNvrtOhEa9\n\nEnPHcgb4ILBu4OionJhsNpJ/O95C0OEypMm25MIS+rQcV4Uxe5IOS2OuT/GreLET\n\nn/7Y0mJbqYbLBjVsfS+DNjvsgyJl5AxhcMrdVyXJjSYVcCoRhcoX5Ceidd+YkbHI\n\nOMs5f63tM1Rgi/WY4Ct80SD5EbULZuu8j1KJ9HPGuMt081JSBH+L5isiKuazPeO+\n\nSGApMBd4Q89fKzL2djae\n\n=Dypr\n\n-----END PGP SIGNATURE-----\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150424/4954b46c/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2015-04-24T20:58:39",
                "message_text_only": "On Fri, Apr 24, 2015 at 8:00 PM, Justus Ranvier\n<justus.ranvier at monetas.net> wrote:\n> https://github.com/justusranvier/rfc/blob/payment_code/bips/bip-pc01.mediawiki\n>\n> This link contains an RFC for a new type of Bitcoin address called a\n> \"payment code\"\n>\n> Payment codes are SPV-friendly alternatives to DarkWallet-style stealth\n> addresses which provide useful features such as positively identifying\n> senders to recipients and automatically providing for transaction refunds.\n\nSo this requires making dust payments to a constantly reused address\nin order to (ab)use the blockchain as a messaging layer.\n\nIndeed, this is more SPV compatible; but it seems likely to me that\n_in practice_ it would almost completely undermine the privacy the\nidea hoped to provide; because you'd have an observable linkage to a\nhighly reused address.\n\nIt would also more than double the data sent for the application where\n'stealth addresses' are most important: one-time anonymous donations\n(in other contexts; you have two way communication between the\nparticipants, and so you can just given them a one off address without\nsingling in the public network.)\n\n> Alice selects the first exposed public key of the first input of the transaction\n\nSo this creates strong \"binding\" that we would really strongly like to\navoid in the network; basically what this says is that \"You can only\npay to person X if you use scheme Y for your own Bitcoins\"-- who says\nany of your inputs have a ECDH pubkey at all? Of if they do, who says\nits one that you have access to the private key for for use in this\nscheme (e.g. it could be in a HSM that only signs according to a\npolicy).   We should avoid creating txout features that restrict what\nkind of scriptPubkey the sender can use, or otherwise we'll never be\nable to deploy new signature features. (We can see how long P2SH took\nto gain adoption because some wallets refused to implement sending to\nit, even though doing so was trivial).\n\nThis kind of binding was intentionally designed out of the stealth\naddress proposal;  I think this scheme can be made to work without any\nincrease in size by reusing the payment code as the ephemeral public\nkey (or actually being substantially smaller e.g. use the shared\nsecret as the chain code, but I should give it more thought)\n\nAlso, SPV wallets do not need to have access to the public keys being\nspent by a particular transaction they learn about; providing that\naccess is fundamentally expensive and pushes things back towards\ncentralization.\n\n> in uncompressed DER format\n\nThis is fundamentally more expensive to compute; please don't specify\n\"uncompressed\".\n\nThis appears incompatible with multisignature; which is unfortunate.\n\nI do very much like the fact that this scheme establishes a shared\nchain once and then doesn't need to reestablish; this was one of the\nimprovements I wanted for the stealth address.\n\nI'm disappointed that there isn't any thought given to solving the\nscanning privacy without forcing non-private pure-overhead messaging\ntransactions on heavily reused addresses. Are you aware of the IBE\napproach that allows someone to request a third party scan for them\nwith block by block control over their delegation of scanning?"
            },
            {
                "author": "Brian Deery",
                "date": "2015-04-27T14:53:59",
                "message_text_only": "Hi Justus:\n\nCC'ing mailing list because more bloom filter and HD wallet experts there\ncan chime in for some of these thoughts.  I refined some ideas we went over\nearlier.\n\nHere are some critiques/worries about the payment codes.\n\nWith identities explicitly tied to a payment code, bloom filter clients can\nhave identities tied to them.\n\n1. There will be a 1:1 relationship between a payment code owner and their\nidentity.  Presumably the payment code would be strongly and publicly tied\nto the identity.  This makes the notification address strongly tied to the\nuser.  An SPV client connecting to a full node who has a list of\nnotification address can tie an identity to a bloom filter and connecting\nIP.\n\n2. The client can use a bloom filter with a higher false positive rate.  An\nactive attacker can counter that by sending several payment codes to an\nindividual user.  The user would then add to their bloom filter all the\nshared addresses between them and the attacker.  Even with a high false\npositive filter, always matching all the attacker's payment codes would\nstrongly tie the user to the filter.\n\n\n\nHere are some data savings and privacy addition ideas:\n\n65 bytes -> 0 bytes extra.\n\n1. Can you choose only even or odd DER encoding?  That would save you 1\nbyte.  This would probably throw out 50% of possible addresses though.\n2. Can the chain code be fixed or derived from the x value?  Could the\nchain value be the x value itself?  (The main question is can a\ndeterministic public seed be represented as a single 32 bit number?  Maybe\nthe chain code can be a constant.  Maybe it is ok since subsequent pubkeys\nare derived from this.  I only know enough crypto to be dangerous.) That\nwould save you 32 bytes.  Someone who understands HD wallets would be\nbetter to look at this one.  it would probably be a non-standard derivation.\n\nThat leaves you with 32 bytes to communicate to bootstrap the channel.\n\n3: Since you are already looking at the pubkey of the transaction sending\nthe notification transaction, then you are assuming control of the sending\nmechanism.  If you can be sure to use a disposable bitcoin address to send\nthe notification, then 1 more savings might be possible.  Also assuming the\nabove two points are possible.\n\nCan you encode the \"x value\" into the signature's R value?  This would\nbasically make this transaction look like a standard bitcoin transaction\nand gets rid of the op_return completely.\n\n\n\nI still like the idea of a common meeting point, a la bitmessage.  The\nreceiver of the payment code would trial-decode all payment codes sent to a\ncommon pre-specified dead drop address (perhaps a charity address).  \"to\nsend me money, first donate to this charity of my choice.\"  This trades off\nmore work on the receivers part to get some privacy as to the number of\npeople interacting with that receiver.\n\n\n-cheers\n-Brian Deery\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150427/ead7a570/attachment.html>"
            },
            {
                "author": "Justus Ranvier",
                "date": "2015-04-27T15:54:36",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nOn 04/27/2015 02:53 PM, Brian Deery wrote:\n> 1. There will be a 1:1 relationship between a payment code owner\n> and their identity.  Presumably the payment code would be strongly\n> and publicly tied to the identity.  This makes the notification\n> address strongly tied to the user.  An SPV client connecting to a\n> full node who has a list of notification address can tie an\n> identity to a bloom filter and connecting IP.\n\nSPV clients that connect exclusively to hidden services through Tor\ncould mitigate this, especially if those clients broadcast their\ntransactions through different peers than the ones they use for\nchecking their balance.\n\nMaybe they should even go the opposite way in terms of the false\npositive rate.\n\nA client could create a filter that *only* matches their notification\naddress and use that filter with a selected peer.\n\nAll the rest of their addresses would be contained in a different\nfilter that is never sent to the same full node which is watching\ntheir notification address.\n\n> 2. The client can use a bloom filter with a higher false positive\n> rate.  An active attacker can counter that by sending several\n> payment codes to an individual user.  The user would then add to\n> their bloom filter all the shared addresses between them and the\n> attacker.  Even with a high false positive filter, always matching\n> all the attacker's payment codes would strongly tie the user to the\n> filter.\n\nI'm not sure this problem is solvable in general.\n\nAny entity which has sent bitcoins to a known user could use that\nknowledge to attempt to find their bloom filter (if they use one).\n\nI think that for SPV to have any privacy at all clients need to get a\nlot smarter about how they use bloom filters overall, such as by\nconnecting to more than one peer, only putting a subset of their\naddresses in a single filter, and temporally varying the addresses\nwhich they watch.\n\n\n- -- \nJustus Ranvier                   | Monetas <http://monetas.net/>\n<mailto:justus at monetas.net>      | Public key ID : C3F7BB2638450DB5\n                                 | BM-2cTepVtZ6AyJAs2Y8LpcvZB8KbdaWLwKqc\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAEBAgAGBQJVPlu8AAoJECpf2nDq2eYj/cAP/iL9qlIkk/jz2N3mT4dIdrSn\nrQ+m7dHOSeucUhePrjdM79VzDUQWGmewdi5a1e8wCL2PCBeq/7mapEpHrvWu3xUU\ng0qtCa6CbSceW5pO1/BGnKpt298wrBIueeweR3/BPum90RrXT+T/ssQvjGvlY4Jg\nADFeH4axalmCkc87OsJhsEbAAbP9i/u96rItV9ECpOET9pRxp4PzNT/7nz/x5n+q\nLm/vuWy1yoWLUjXiAmXWJVzPs8+Pzf1liy3SEzkam156kUwTj/CqjI/uhf7heSx2\nFYSswBc/R1fga7eu++Bm449KUTmyTnnEIT4109A1w18fidY2Dg6PpKYp5CGug96t\naHit1hqLfc8HpNUVWLrBrHsC7riy+QGta4Ie7fAl9SvFcNturkXBFxZLO8f34WMb\nHFuWkcCAgZcS3hb1ShmyodMjnOWvHQo/dXAoUc+zI8yuiH9wAD6T4LOTkSwCjvvv\n9y4Ia4Mr6v6oHQpUM8ddCMU4AyAYvZXFb68SsnWMZCCio3Ff9wqp2d690oSq36G7\njdjmxot7LrPMnJjNKwTl2jndDTB9Huh9sjWyE9gGBkkIib1purOYtucDsY3h6z7i\n5ppG1KTph+xaOLMEvyJZyDNvPhrQGk1ll1kMoD2k7P/5OGV7QwQ0IxpoAqZ1uxJG\n44rCXd7P+2R+Bza9qHSH\n=d2l3\n-----END PGP SIGNATURE-----\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0xEAD9E623.asc\nType: application/pgp-keys\nSize: 18399 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150427/5ec2884a/attachment.bin>"
            },
            {
                "author": "Mike Hearn",
                "date": "2015-04-27T16:46:33",
                "message_text_only": ">\n> 1. There will be a 1:1 relationship between a payment code owner and their\n> identity.\n>\n\nBear in mind, the spec defines \"identity\" to mean:\n\n     *Identity is a particular extended public/private key pair. *\n\nSo that's not quite what is meant normally by identity. It's not a\ngovernment / real name identity or an email address or phone number kind of\nidentity.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150427/ab8b6e42/attachment.html>"
            },
            {
                "author": "Justus Ranvier",
                "date": "2015-04-27T17:02:36",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nOn 04/27/2015 04:46 PM, Mike Hearn wrote:\n> So that's not quite what is meant normally by identity. It's not a \n> government / real name identity or an email address or phone number\n> kind of identity.\n\nI expect that mappings would begin to develop between payment codes\nand government / real name identities, at least as far as that\nbusinesses which are required to collect that kind of information\nwould associate it with the payment code(s) known to be used by their\ncustomers for their own use.\n\nI proposed payment codes in this form because I'd rather see that kind\nof mapping be limited to the application layer and kept away from the\nblockchain/network layer.\n\nEven if it makes certain kind of application-layer distasteful\nbehavior easier, it's a good trade if doing so can simultaneously\nprovide resistance to graph analysis and make transaction-level\ncensorship more difficult.\n\n- -- \nJustus Ranvier                   | Monetas <http://monetas.net/>\n<mailto:justus at monetas.net>      | Public key ID : C3F7BB2638450DB5\n                                 | BM-2cTepVtZ6AyJAs2Y8LpcvZB8KbdaWLwKqc\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAEBAgAGBQJVPmusAAoJECpf2nDq2eYjhxIP/3Jw9f6kcEsdFTXouQ5+D5gb\nMjM8AW7EEA6KXj2PqrPv/H/brorW9/Ugcc8KweCjEdJAKOJV/Bl6sP5ydSZT6pmj\nA0IFIkbdxKLY9JC3BbmVHuiAFrsL1u2EX5arUC3WNAWeWlVEmAL92cSlAka4BBxy\nP/wh8xN0b4hsgA602Y4Btkv2fBHLQI9NMxW3AsujP3/S78mSxwKQZz4lYAMCowu8\nNL/3toaFhrUsdHsH301jNAnxEEOodMVGmgjg/ZSdvWeHwdsE2J8Q9AJqiFDswjU5\nq2kZuKmuJ6EXcGDlhelUuUpfHO34qS3/dyTydcqFrYB6eynZ8nV6S1SHaSlDEM10\nb95+EpfIENtYdgAqJxwfbqpibpSEIW7cxCAopF0sSbQ2qv8rwRrcIah7KeARCrc0\ne+HDcyLhYkrWrlK28vVmIxkEiQ/nmkTu9dOfoVJgXxcVl9AkiHGjo7QICOZHqfRB\nTOupk9UUHMmdfZC5vpj9rd+VSXJJEF19ZbGF1QsFSMuxjKTb9jAy7Dk6U/9/xK9Q\n+mH6QHhKzNKb8GsiowZJq3bF2mEYqmh/BPyQ06gfDLM4yvlTb+k4R6brFzm7tkWG\n49hREmHK9w/wZXnH0lMCqMHRY/YqQF5bR3ujq7pB0WHLvbvDoSvyWvGQ9cVrRA24\nASb47sR77R1LlZntoSyy\n=b7HG\n-----END PGP SIGNATURE-----\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0xEAD9E623.asc\nType: application/pgp-keys\nSize: 18399 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150427/4683ab4b/attachment.bin>"
            },
            {
                "author": "Justus Ranvier",
                "date": "2015-04-28T13:53:07",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nThe notification transactions are a pain point when it comes to\nprivacy, and yet they must exist in order to to ensure that nobody can\nlose their money as long as they back up their wallet seed.\n\nThey could be treated as a backup, however, that clients would not\nnormally rely upon\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAEBAgAGBQJVP5DDAAoJECpf2nDq2eYjdLsQAJ/nZKFavcJnCMUQ8hKp6dRq\n2+7bAVIWYHuOV6sv/hvG2NaP3u24NYZ/Ji0oD3UAmkJxw9lsZuowwBBs+YAs6JAW\nKHTl3QtwBh0IP/V90JOZ5Yn72YWXDsNbqy7R3JhEDKOu2wVeiLqWZ2EDgGwiZ0/k\naXFJbcVZEKttWYCNoZi0yRMH+S9gbi0LgOwvK9mRzF9IRz07SM1iKQeKPsW1X1UM\nKNeikFROMS7dHTO5HRGyFcTSwhUf8RJq2kea+4sJtj8Vlb5rURuJanL3Fav+ZZjr\nRWYubLp9EUrDMm9bciygL8+MKPas8hedHSW2JhjkshWYC/NoCXLBT6SGrrbj2SKL\nzGGeLYknjwgLTCstKSQlXW3J/xcSFwBztr//o95SwRoIKI7jpuOE6cPfUZVEuTsU\nZm7IWuRw/1MMDF89gCtDkBJcX2mTARjiii1Hg0+7vCv6Q/fVgTNUvWEKeNtCNZjh\nwOiwd4eP1gY4CwX68c+8CfF+NOSXImJTspZJvDQcTge1/bQJNOBn+cMYxjBcJsqL\nZUOvkWJqwiFERW7vjMhOVpqIyO38UluwsWgp7nlMl/npfv0ZDIrOqZrswHSTqfdc\nP8gSaqvpc6cMaLL/ijvOtORkVB9ZlLmlTv6mIYWHeKEf6PjIOZEb2B75zPHFAvrz\nTKLxjvWgvSJ4l5PrkCFA\n=1Id2\n-----END PGP SIGNATURE-----\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0xEAD9E623.asc\nType: application/pgp-keys\nSize: 18399 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150428/c1551c94/attachment.bin>"
            },
            {
                "author": "Justus Ranvier",
                "date": "2015-04-29T23:44:15",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nOn 04/27/2015 02:53 PM, Brian Deery wrote:\n\n> 1. There will be a 1:1 relationship between a payment code owner\n> and their identity.  Presumably the payment code would be strongly\n> and publicly tied to the identity.  This makes the notification\n> address strongly tied to the user.  An SPV client connecting to a\n> full node who has a list of notification address can tie an\n> identity to a bloom filter and connecting IP.\n\nI've updated the proposal to provide for alternate methods of\nnotification that can be used *in addition to* notification transactions.\n\nThis frees the sender from constantly monitoring an address known to\nbe associated with their identity, although they should check it\nperiodically since not all senders will be capable of using every type\nof alternate notification method.\n\nI defined a Bitmessage notification method as an example; more can be\nadded if required.\n\nhttps://github.com/justusranvier/rfc/blob/payment_code/bips/bip-pc01.mediawiki\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAEBAgAGBQJVQWzPAAoJECpf2nDq2eYj8uAP/RsP050K9z8oDGy0KO+zjFwM\niNzlsQaPY8kmR2k2oLXJp1n4QZIQAZly+vxjBZnOWXwAhrBcvnhNBvqdigwZYg3B\noGyvGvArzkve86Ke1WF1hZEAvml3cmQ5jxYKMlwhzRPcHq2kwznw+5jRuTbf1JbE\nPxY5pOfnZ9ADVF5FkLR2KwBNvGA83Cle01hKd0eB6Omlb6azKDBXUqfzPPpB4lmp\nA8D0P3zkayzBYIiybUExfPJHUthd5wXL/TLwFkysPV7SnJE64C6Q2StD4wUtNQRS\nLDOw37RwhMx2Oz2YH3Ywi6w5tqYQP4LEWBuFb+LOqqphpV/FpFDl/Uznos00pz61\nV9x2wrfg+MQnYk5/VIjPQxqvRsiu8yg4c2x0v+KIIMsuXKEPRFxaSS3DoaWUa1Jy\n+WDobHndIDw1TDqctP8LIiZ7zbWNYKJ4HgUaacHvTiA7TrJXi1KHo2b1pmnTbKhv\nfdHbjzd8UiMED6qeyrz1gGhjC2uSTwjZAmbBkCJccOGsrILoV1fifUW+de8qsBMH\n6w6RiDwfeY2fHJHBS6O2Nhfk3OE5JaCWvy727ZXEq8lQ6dW0GOZvXg7INaktLagC\ntqvg85J5eCm7X8xQ33vgx8q2xt+IriMI2UnTILtb2H8XSiMRQSP7XfWDMfVGu4pb\nxbGZKbNS4WS+2FFKM4DK\n=6l99\n-----END PGP SIGNATURE-----\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0xEAD9E623.asc\nType: application/pgp-keys\nSize: 18399 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150429/878dfe29/attachment.bin>"
            }
        ],
        "thread_summary": {
            "title": "Reusable payment codes",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Brian Deery",
                "Mike Hearn",
                "Gregory Maxwell",
                "Justus Ranvier"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 17633
        }
    },
    {
        "title": "[Bitcoin-development] Fwd:  Reusable payment codes",
        "thread_messages": [
            {
                "author": "Justus Ranvier",
                "date": "2015-04-25T00:20:59",
                "message_text_only": "On Fri, Apr 24, 2015 at 10:58 PM, Gregory Maxwell <gmaxwell at gmail.com>\nwrote:\n\n> So this requires making dust payments to a constantly reused address\n> in order to (ab)use the blockchain as a messaging layer.\n>\n> Indeed, this is more SPV compatible; but it seems likely to me that\n> _in practice_ it would almost completely undermine the privacy the\n> idea hoped to provide; because you'd have an observable linkage to a\n> highly reused address.\n>\n\nI agree that the output associated with notification transactions would\nrequire special handling to avoid privacy leaks. At a minimum they'd\nrequire mixing or being donated to miners as a transaction fee.\n\n\n>\n> It would also more than double the data sent for the application where\n> 'stealth addresses' are most important: one-time anonymous donations\n> (in other contexts; you have two way communication between the\n> participants, and so you can just given them a one off address without\n> singling in the public network.)\n>\n\nCommunication is only one way, except for the case in which the recipient\nwants to send a refund. Assuming no refund and only a single anonymous\ndonation in the lifetime of the sender's identity, payment codes would\nrequire 65 bytes vs 40 bytes for stealth addresses.\n\nAs soon as the sender sends more than one donation to the same recipient,\npayment codes show an space advantage over stealth addresses.\n\nThis kind of binding was intentionally designed out of the stealth\n>\naddress proposal;  I think this scheme can be made to work without any\n> increase in size by reusing the payment code as the ephemeral public\n> key (or actually being substantially smaller e.g. use the shared\n> secret as the chain code, but I should give it more thought)\n>\n\nWith 97 byte standard OP_RETURN values the ephemeral public\nkey could be appended to the chain code, but that's undesirable for other\nreasons.\n\nThis is fundamentally more expensive to compute; please don't specify\n> \"uncompressed\".\n>\n\nTaking the SHA512 of something less than 512 bits seemed wrong.\n\n\n> This appears incompatible with multisignature; which is unfortunate.\n>\n\nI agree. I could not find a straightforward way to express a multisignature\npayment code in less than 80 bytes.\n\n\n> I'm disappointed that there isn't any thought given to solving the\n> scanning privacy without forcing non-private pure-overhead messaging\n> transactions on heavily reused addresses. Are you aware of the IBE\n> approach that allows someone to request a third party scan for them\n> with block by block control over their delegation of scanning?\n>\n\nI suspect this is a case where we just can't have all the features we want.\n\nIn this proposal I optimized for non-reliance on third party services and a\nguaranteed ability to recover spendable funds from a seed backup.\n\nGaining those two features resulted in some tradeoffs as you noted, but I\nthink there are enough benefits to make them worthwhile.\n\nIn particular, payment codes could be the basis for a Heartbleed-free\npayment protocol that can positively identify customers and automatically\nprovide refund capabilities in a merchant-customer relationship. A merchant\nonly requires one payment code which they can safely use for all their\ncustomers, meaning they only ever need to associate 65 bytes with their\nidentity to allow customers to make sure they are paying the right entity.\n\nExchanges could restrict bitcoin withdrawals to a single payment code known\nto be associated with their identified customer. This would make thefts\neasier (without involving address reuse as in locking withdrawals to a\nsingle P2PKH address).\n\nIn some jurisdictions the ability to prove that withdrawals are sent to a\npositively-identified party, rather than arbitrary third parties, might\nmove some Bitcoin businesses out of money transmitter territory into less\nonerous regulatory situations.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150425/c29abbbd/attachment.html>"
            },
            {
                "author": "Justus Ranvier",
                "date": "2015-04-25T00:21:20",
                "message_text_only": "I have pushed an updated version of the proposal which incorporates some of\nthe received feedback and adds a note about the consequences of sharing a\npayment code-enabled walled on multiple devices:\n\nhttps://github.com/justusranvier/rfc/blob/payment_code/bips/bip-pc01.mediawiki\n\nhttps://github.com/justusranvier/rfc/commit/8c4d3429012eb15847c4ae68f212c8b2dcd1b521\n\nOn Sat, Apr 25, 2015 at 12:21 AM, Justus Ranvier <justus.ranvier at monetas.net\n> wrote:\n\n>\n>\n> On Fri, Apr 24, 2015 at 10:58 PM, Gregory Maxwell <gmaxwell at gmail.com>\n> wrote:\n>\n>> So this requires making dust payments to a constantly reused address\n>> in order to (ab)use the blockchain as a messaging layer.\n>>\n>> Indeed, this is more SPV compatible; but it seems likely to me that\n>> _in practice_ it would almost completely undermine the privacy the\n>> idea hoped to provide; because you'd have an observable linkage to a\n>> highly reused address.\n>>\n>\n> I agree that the output associated with notification transactions would\n> require special handling to avoid privacy leaks. At a minimum they'd\n> require mixing or being donated to miners as a transaction fee.\n>\n>\n>>\n>> It would also more than double the data sent for the application where\n>> 'stealth addresses' are most important: one-time anonymous donations\n>> (in other contexts; you have two way communication between the\n>> participants, and so you can just given them a one off address without\n>> singling in the public network.)\n>>\n>\n> Communication is only one way, except for the case in which the recipient\n> wants to send a refund. Assuming no refund and only a single anonymous\n> donation in the lifetime of the sender's identity, payment codes would\n> require 65 bytes vs 40 bytes for stealth addresses.\n>\n> As soon as the sender sends more than one donation to the same recipient,\n> payment codes show an space advantage over stealth addresses.\n>\n> This kind of binding was intentionally designed out of the stealth\n>>\n> address proposal;  I think this scheme can be made to work without any\n>> increase in size by reusing the payment code as the ephemeral public\n>> key (or actually being substantially smaller e.g. use the shared\n>> secret as the chain code, but I should give it more thought)\n>>\n>\n> With 97 byte standard OP_RETURN values the ephemeral public\n> key could be appended to the chain code, but that's undesirable for other\n> reasons.\n>\n> This is fundamentally more expensive to compute; please don't specify\n>> \"uncompressed\".\n>>\n>\n> Taking the SHA512 of something less than 512 bits seemed wrong.\n>\n>\n>> This appears incompatible with multisignature; which is unfortunate.\n>>\n>\n> I agree. I could not find a straightforward way to express a\n> multisignature payment code in less than 80 bytes.\n>\n>\n>> I'm disappointed that there isn't any thought given to solving the\n>> scanning privacy without forcing non-private pure-overhead messaging\n>> transactions on heavily reused addresses. Are you aware of the IBE\n>> approach that allows someone to request a third party scan for them\n>> with block by block control over their delegation of scanning?\n>>\n>\n> I suspect this is a case where we just can't have all the features we want.\n>\n> In this proposal I optimized for non-reliance on third party services and\n> a guaranteed ability to recover spendable funds from a seed backup.\n>\n> Gaining those two features resulted in some tradeoffs as you noted, but I\n> think there are enough benefits to make them worthwhile.\n>\n> In particular, payment codes could be the basis for a Heartbleed-free\n> payment protocol that can positively identify customers and automatically\n> provide refund capabilities in a merchant-customer relationship. A merchant\n> only requires one payment code which they can safely use for all their\n> customers, meaning they only ever need to associate 65 bytes with their\n> identity to allow customers to make sure they are paying the right entity.\n>\n> Exchanges could restrict bitcoin withdrawals to a single payment code\n> known to be associated with their identified customer. This would make\n> thefts easier (without involving address reuse as in locking withdrawals to\n> a single P2PKH address).\n>\n> In some jurisdictions the ability to prove that withdrawals are sent to a\n> positively-identified party, rather than arbitrary third parties, might\n> move some Bitcoin businesses out of money transmitter territory into less\n> onerous regulatory situations.\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150425/1536c9c0/attachment.html>"
            },
            {
                "author": "Justus Ranvier",
                "date": "2015-04-25T00:22:30",
                "message_text_only": "Taking the hash of the secret would then require an extra step to make sure\nthe hash is valid for secp256k1.\n\nUsing the x value directly avoids the need for that check.\n\nOn Fri, Apr 24, 2015 at 10:35 PM, Patrick Mccorry (PGR) <\npatrick.mccorry at newcastle.ac.uk> wrote:\n\n>  When computing the diffie Hellman secret - why do you choose the x\n> co-ordinate instead of the hash of the secret which is standard practice\n> for stealth addresses\n>\n> Sent from my iPhone\n>\n> On 24 Apr 2015, at 21:27, Justus Ranvier <justus.ranvier at monetas.net>\n> wrote:\n>\n>   -----BEGIN PGP SIGNED MESSAGE-----\n>\n> Hash: SHA1\n>\n>\n>\n> https://github.com/justusranvier/rfc/blob/payment_code/bips/bip-pc01.mediawiki\n>\n>\n>  This link contains an RFC for a new type of Bitcoin address called a\n> \"payment code\"\n>\n>\n>  Payment codes are SPV-friendly alternatives to DarkWallet-style stealth\n> addresses which provide useful features such as positively identifying\n> senders to recipients and automatically providing for transaction refunds.\n>\n>\n>  Payment codes can be publicly advertised and associated with a real-life\n> identity without causing a loss of financial privacy.\n>\n>\n>  Compared to stealth addresses, payment codes require less blockchain\n> data storage.\n>\n>\n>  Payment codes require 65 bytes of OP_RETURN data per sender-recipient\n> pair, while stealth addresses require 40 bytes per transaction.\n>\n>\n>  -----BEGIN PGP SIGNATURE-----\n>\n> Version: GnuPG v1\n>\n>\n>  iQIcBAEBAgAGBQJVOqCRAAoJECpf2nDq2eYjluEP/RVJk+miDIihY4ilIvUbKvMd\n>\n> JLLqHr7Q1dlZyMIG/UqVWdoP5hzg/16B+q2iAB9jXozPnrDp0mggBh6rIGroevAa\n>\n> Kqfrs+Rrog1w9auhd67LWORDqav6YIrjTJIxdLxe11IEiq5rWbHPNUEDMzdEmHbz\n>\n> QfTH7KWAP2BasO5ETXcfu6BcccrXZ3XOKLON2h3NGD/cEDizY+uT2k3QN54z+KxG\n>\n> NB9scKbzVvsJwkyBrgbV+As9H3k6PnFsojYgAaE9gkp7D2+ahjzUiOH5rv6TbbYR\n>\n> o2X5MOiTY2/YZEqZPG7IR03ZAgeLVCvXXysjPOfzUKbmTF4w849sm8BuhixzDXHo\n>\n> 2V/HHKoGclIohcODBCWi0tVQXshZt4QkCNJBW5o3nL6Nn2YOp6hmw8YKAHnw3E7h\n>\n> /wIgk5f+NOLl/iIxoAxAdavEj5P6N4ic+OB6MAjnhEilWfBvCIpqWLGNvrtOhEa9\n>\n> EnPHcgb4ILBu4OionJhsNpJ/O95C0OEypMm25MIS+rQcV4Uxe5IOS2OuT/GreLET\n>\n> n/7Y0mJbqYbLBjVsfS+DNjvsgyJl5AxhcMrdVyXJjSYVcCoRhcoX5Ceidd+YkbHI\n>\n> OMs5f63tM1Rgi/WY4Ct80SD5EbULZuu8j1KJ9HPGuMt081JSBH+L5isiKuazPeO+\n>\n> SGApMBd4Q89fKzL2djae\n>\n> =Dypr\n>\n> -----END PGP SIGNATURE-----\n>\n>\n> ------------------------------------------------------------------------------\n> One dashboard for servers and applications across Physical-Virtual-Cloud\n> Widest out-of-the-box monitoring support with 50+ applications\n> Performance metrics, stats and reports that give you Actionable Insights\n> Deep dive visibility with transaction tracing using APM Insight.\n> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y\n>\n>  _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150425/40b3ed26/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Fwd:  Reusable payment codes",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Justus Ranvier"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 11749
        }
    },
    {
        "title": "[Bitcoin-development] Fwd: Reusable payment codes",
        "thread_messages": [
            {
                "author": "Justus Ranvier",
                "date": "2015-04-25T02:34:13",
                "message_text_only": "On Sat, Apr 25, 2015 at 3:30 AM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n\n> On Sat, Apr 25, 2015 at 12:22 AM, Justus Ranvier\n> <justus.ranvier at monetas.net> wrote:\n> > Taking the hash of the secret would then require an extra step to make\n> sure\n> > the hash is valid for secp256k1.\n>\n> The x value may not be a valid member of the group, effectively the\n> same as with a hash. Its also very unequally distributed, as only\n> about half the possible values are points on the curve.\n\n\nack\n\n\n> > With 97 byte standard OP_RETURN values the ephemeral public\n> > key could be appended to the chain code, but that's undesirable for\n> other reasons.\n>\n> Can you elaborate?  Storing a ~33 byte (deterministically generated)\n> ephemeral key should be all that is required. Everything else,\n> including the chain code could be derived from it. What reason do you\n> have to include additional data?\n>\n\nThe goal of the notification transaction is to send the same payment code\nto every recipient, but obscure the identity of the sender of the\nnotification transaction from third party blockchain observers.\n\nThe shared secret is used for that purpose, and the sender's public key\nused for ECDH can't be one derived from the payment code since the\nrecipient doesn't yet know the payment code.\n\nThe notification transaction needs to communicate the 65 byte payment code\nalong with one ephemeral public key used for ECDH. If that ephemeral key is\nnot located in a signature script, it has to be somewhere else (such as in\nthe same OP_RETURN output as the payment code.)\n\n\n> > Taking the SHA512 of something less than 512 bits seemed wrong.\n>\n> Why should it?  Adding the Y does not increase the entropy at all.  As\n> an aside, I think this can be reformulated to only need 256 bits of\n> output, and then the need for yet-another-hash-function could be\n> avoided in some cases.\n>\n\nAlready fixed in\nhttps://github.com/justusranvier/rfc/commit/8c4d3429012eb15847c4ae68f212c8b2dcd1b521\nbut it would be good to get confirmation of whether the way I fixed it is\nvalid.\n\n> In this proposal I optimized for non-reliance on third party services\n>\n> The requirement for inputs is a guaranteed dependency on third party\n> services; so if thats whats being optimized for here it must go (well,\n> I think it must go for the reason of avoiding blocking users from\n> using other schemes to control their coins too..).\n>\n\nI'm not sure what you mean by \"the requirement for inputs is a guaranteed\ndependency on third party\nservices\"\n\nAt the proposal currently stands, an SPV wallet will have no trouble\nsending or receiving notification transactions without access to a third\nparty service. The recipient just needs to see the transactions associated\nwith its notification address.\n\nThe point about restricting the types of scripts used as inputs is valid,\nbut I think workarounds are available. If nothing else, the sender can make\na suitable input using it's own (suitably mixed) coins first.\n\n> I agree. I could not find a straightforward way to express a\n> multisignature payment code in less than 80 bytes.\n>\n> A prior stealth address proposal here handled them fine with only a\n> single ephemeral point in the op_return. It does result in a longer\n> address (is that what you're referring to with '80 bytes'?)\n>\n\nI considered defining an additional path level for deterministic m-of-n\nmultisig and adding a few bytes to the payment code to express those\nparameters, but thought it would be too limiting since it would preclude\nmultisig with truly independent keys. It is a thing that could be done,\nhowever.\n\n> Exchanges could restrict bitcoin withdrawals to a single payment code\n> known to be associated with their identified customer.\n> > In some jurisdictions the ability to prove that withdrawals are sent to\n> a positively-identified party, rather than arbitrary third parties, might\n> move some Bitcoin businesses out of money transmitter territory into less\n> onerous regulatory situations.\n>\n> But this mandates horrible key management practices, reliance on a\n> single \"hardcoded\" private key which you cannot change; even if it\n> might be compromised or lost to the wind. It's less horrible than\n> sticking to a single address because it doesn't wedge privacy, I\n> agree; but care should be taken that a tortured dance for confused\n> regulatory cargo-cult reasons doesn't mandate people not engage in\n> sound practices like periodic key rotation. :)\n>\n\nCold storage is still available (if admittedly less convenient than in\ntraditional wallets).\n\nI would expect exchanges in practice to allow for payment codes to be\nchanged, just with non-trivial waiting periods and plenty of human\noverview. It would be an infrequent event compared to the frequency of\nwithdrawals.\n\nVarious schemes which use public key authentication instead of passwords\nfor web site authentication could be used to continually verify that the\nuser hasn't lost access to the key.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150425/acb86657/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2015-04-26T12:58:03",
                "message_text_only": "Could you maybe write a short bit of text comparing this approach to\nextending BIP70 and combining it with a simple Subspace style\nstore-and-forward network?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150426/7e1035ab/attachment.html>"
            },
            {
                "author": "Justus Ranvier",
                "date": "2015-04-26T14:50:00",
                "message_text_only": "Payment codes establish the identity of the payer and allow for simpler\nmethods for identifying the payee, and automatically provide the payee with\nthe information they need to send a refund.\n\nIf merchants and customers were using payment codes, they would not need\nthe BIP70 equivalents.\n\nI think the best way to explain payment codes is that they add the missing\n\"from address\" to transactions which users want, but we've had to tell them\nthey can't have.\n\nA payment code behaves much more like an email address than a traditional\nBitcoin address.\n\nOn Sun, Apr 26, 2015 at 2:58 PM, Mike Hearn <mike at plan99.net> wrote:\n\n> Could you maybe write a short bit of text comparing this approach to\n> extending BIP70 and combining it with a simple Subspace style\n> store-and-forward network?\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150426/880a3f4a/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Fwd: Reusable payment codes",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Mike Hearn",
                "Justus Ranvier"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 6438
        }
    },
    {
        "title": "[Bitcoin-development] Bitcoin Core 0.10.1 released",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2015-04-27T06:40:10",
                "message_text_only": "Bitcoin Core version 0.10.1 is now available from:\n\n  <https://bitcoin.org/bin/bitcoin-core-0.10.1/>\n\nThe distribution is also available as torrent:\n\n   https://bitcoin.org/bin/bitcoin-core-0.10.1/bitcoin-0.10.1.torrent\n\n   magnet:?xt=urn:btih:b6f8da60aaf2007cd6db631637951ae673e31044&dn=bitcoin-core-0.10.1&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.publicbt.com%3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.ccc.de%3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&tr=udp%3A%2F%2Fopen.demonii.com%3A1337&ws=https%3A%2F%2Fbitcoin.org%2Fbin%2F\n\nThe source code can be found in git under the tag `v0.10.1`, or in `bitcoin-0.10.1.tar.gz` in the distribution.\n\nThis is a new minor version release, bringing bug fixes and translation \nupdates. It is recommended to upgrade to this version.\n\nPlease report bugs using the issue tracker at github:\n\n  <https://github.com/bitcoin/bitcoin/issues>\n\nUpgrading and downgrading\n=========================\n\nHow to Upgrade\n--------------\n\nIf you are running an older version, shut it down. Wait until it has completely\nshut down (which might take a few minutes for older versions), then run the\ninstaller (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\nbitcoind/bitcoin-qt (on Linux).\n\nDowngrade warning\n------------------\n\nBecause release 0.10.0 and later makes use of headers-first synchronization and\nparallel block download (see further), the block files and databases are not\nbackwards-compatible with pre-0.10 versions of Bitcoin Core or other software:\n\n* Blocks will be stored on disk out of order (in the order they are\nreceived, really), which makes it incompatible with some tools or\nother programs. Reindexing using earlier versions will also not work\nanymore as a result of this.\n\n* The block index database will now hold headers for which no block is\nstored on disk, which earlier versions won't support.\n\nIf you want to be able to downgrade smoothly, make a backup of your entire data\ndirectory. Without this your node will need start syncing (or importing from\nbootstrap.dat) anew afterwards. It is possible that the data from a completely\nsynchronised 0.10 node may be usable in older versions as-is, but this is not\nsupported and may break as soon as the older version attempts to reindex.\n\nThis does not affect wallet forward or backward compatibility.\n\nNotable changes\n===============\n\nThis is a minor release and hence there are no notable changes.\nFor the notable changes in 0.10, refer to the release notes for the\n0.10.0 release at https://github.com/bitcoin/bitcoin/blob/v0.10.0/doc/release-notes.md\n\n0.10.1 Change log\n=================\n\nDetailed release notes follow. This overview includes changes that affect external\nbehavior, not code moves, refactors or string updates.\n\nRPC:\n- `7f502be` fix crash: createmultisig and addmultisigaddress\n- `eae305f` Fix missing lock in submitblock\n\nBlock (database) and transaction handling:\n- `1d2cdd2` Fix InvalidateBlock to add chainActive.Tip to setBlockIndexCandidates\n- `c91c660` fix InvalidateBlock to repopulate setBlockIndexCandidates\n- `002c8a2` fix possible block db breakage during re-index\n- `a1f425b` Add (optional) consistency check for the block chain data structures\n- `1c62e84` Keep mempool consistent during block-reorgs\n- `57d1f46` Fix CheckBlockIndex for reindex\n- `bac6fca` Set nSequenceId when a block is fully linked\n\nP2P protocol and network code:\n- `78f64ef` don't trickle for whitelisted nodes\n- `ca301bf` Reduce fingerprinting through timestamps in 'addr' messages.\n- `200f293` Ignore getaddr messages on Outbound connections.\n- `d5d8998` Limit message sizes before transfer\n- `aeb9279` Better fingerprinting protection for non-main-chain getdatas.\n- `cf0218f` Make addrman's bucket placement deterministic (countermeasure 1 against eclipse attacks, see http://cs-people.bu.edu/heilman/eclipse/)\n- `0c6f334` Always use a 50% chance to choose between tried and new entries (countermeasure 2 against eclipse attacks)\n- `214154e` Do not bias outgoing connections towards fresh addresses (countermeasure 2 against eclipse attacks)\n- `aa587d4` Scale up addrman (countermeasure 6 against eclipse attacks)\n- `139cd81` Cap nAttempts penalty at 8 and switch to pow instead of a division loop\n\nValidation:\n- `d148f62` Acquire CCheckQueue's lock to avoid race condition\n\nBuild system:\n- `8752b5c` 0.10 fix for crashes on OSX 10.6\n\nWallet:\n- N/A\n\nGUI:\n- `2c08406` some mac specifiy cleanup (memory handling, unnecessary code)\n- `81145a6` fix OSX dock icon window reopening\n- `786cf72` fix a issue where \"command line options\"-action overwrite \"Preference\"-action (on OSX)\n\nTests:\n- `1117378` add RPC test for InvalidateBlock\n\nMiscellaneous:\n- `c9e022b` Initialization: set Boost path locale in main thread\n- `23126a0` Sanitize command strings before logging them.\n- `323de27` Initialization: setup environment before starting QT tests\n- `7494e09` Initialization: setup environment before starting tests\n- `df45564` Initialization: set fallback locale as environment variable\n\nCredits\n=======\n\nThanks to everyone who directly contributed to this release:\n\n- Alex Morcos\n- Cory Fields\n- dexX7\n- fsb4000\n- Gavin Andresen\n- Gregory Maxwell\n- Ivan Pustogarov\n- Jonas Schnelli\n- Matt Corallo\n- mrbandrews\n- Pieter Wuille\n- Ruben de Vries\n- Suhas Daftuar\n- Wladimir J. van der Laan\n\nAnd all those who contributed additional code review and/or security research:\n- 21E14\n- Alison Kendler\n- Aviv Zohar\n- Ethan Heilman\n- Evil-Knievel\n- fanquake\n- Jeff Garzik\n- Jonas Nick\n- Luke Dashjr\n- Patrick Strateman\n- Philip Kaufmann\n- Sergio Demian Lerner\n- Sharon Goldberg\n\nAs well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/)."
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.10.1 released",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Wladimir J. van der Laan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5739
        }
    },
    {
        "title": "[Bitcoin-development] Bitcoin core 0.11 planning",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2015-04-28T07:44:16",
                "message_text_only": "Hello all,\n\nThe release window for 0.11 is nearing, I'd propose the following schedule:\n\n2015-05-01  Soft translation string freeze\n            Open Transifex translations for 0.11\n            Finalize and close translation for 0.9\n\n2015-05-15  Feature freeze, string freeze\n\n2015-06-01  Split off 0.11 branch\n            Tag and release 0.11.0rc1\n            Start merging for 0.12 on master branch \n\n2015-07-01  Release 0.11.0 final (aim)\n\nIn contrast to former releases, which were protracted for months, let's try to be more strict about the dates. Of course it is always possible for last-minute critical issues to interfere with the planning. The release will not be held up for features, though, and anything that will not make it to 0.11 will be postponed to next release scheduled for end of the year.\n\nWladimir"
            },
            {
                "author": "Peter Todd",
                "date": "2015-04-28T10:49:41",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nI'll point out that at this rate the soonest we'll see CHECKLOCKTIMEVERIFY implemented on Bitcoin will be something like summer 2016, a year and a half after it got adopted on Viacoin. (and a few other alts whose names I forget)\n\nRight now the shortest path to adoption would be to release a v0.12 with just a CLTV soft-fork as soon as the BIP66 softfork triggers. While there's been proposal to change the way the upgrade mechanism triggers to a multiple parallel fork scheme, that is quite complex, stateful, and will need lots of review, probably a few months worth; faster would be to continue with the existing mechanism.\n\nIMO the main reason to accelerate CLTV is scalability. The only viable scalability improvements possible in the short/medium term that don't entirely rely on trusting third parties are payment channel based. While we have a working payment channel scheme - Jeremy Spilman's refund tx based system - it is fairly complex, needs good and immediate backups, and is susceptible to tx malleability. CLTV fixes those issues robustly. Of course, payment channel schemes can start off with Spilman's scheme first and go to CLTV later, but that is a lot of extra code to be written and later depreciated - I'm sure many authors are dubious about going down that path.\n\nThoughts?\n\n\nOn 28 April 2015 03:44:16 GMT-04:00, \"Wladimir J. van der Laan\" <laanwj at gmail.com> wrote:\n>Hello all,\n>\n>The release window for 0.11 is nearing, I'd propose the following\n>schedule:\n>\n>2015-05-01  Soft translation string freeze\n>            Open Transifex translations for 0.11\n>            Finalize and close translation for 0.9\n>\n>2015-05-15  Feature freeze, string freeze\n>\n>2015-06-01  Split off 0.11 branch\n>            Tag and release 0.11.0rc1\n>            Start merging for 0.12 on master branch\n>\n>2015-07-01  Release 0.11.0 final (aim)\n>\n>In contrast to former releases, which were protracted for months, let's\n>try to be more strict about the dates. Of course it is always possible\n>for last-minute critical issues to interfere with the planning. The\n>release will not be held up for features, though, and anything that\n>will not make it to 0.11 will be postponed to next release scheduled\n>for end of the year.\n>\n>Wladimir\n-----BEGIN PGP SIGNATURE-----\n\niQE9BAEBCAAnIBxQZXRlciBUb2RkIDxwZXRlQHBldGVydG9kZC5vcmc+BQJVP2Wy\nAAoJEMCF8hzn9LncqOcH/3rDFbgWprqTfk8dKWAItRcY6ZyiQ+dNrqNgymaNP5Ig\nMNKaTmWYyZRH6PW13JOv72ArXia+D82Mp5reTaLIb3TV5uef2biruOCaH9eI8Uv5\ni2PCBLw3uqZIZZ5Qr/7nlp2CaBQIGDK3fg3jx10UyWpg4BxkKP2mLJibMG8l3JcK\nMoi/kh6lvwySpT8NYtZfXax+5AQ2oLXiSzbFF8P0ioI9fJYaoVCAyS5VEE4KsZnV\nthOaoPAWoK+spEYKFrjvyXnQXFe6m+KPfRPU3WKYSFhI7m8MW6bKxEnD0Lffo6qU\nYS6jsE3A0LoKs4kD73ivHcMeXDhO6LXyPAu8zQtgGr8=\n=Z/GT\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Pieter Wuille",
                "date": "2015-04-28T11:01:00",
                "message_text_only": "As softforks almost certainly require backports to older releases and other\nsoftware anyway, I don't think they should necessarily be bound to Bitcoin\nCore major releases. If they don't require large code changes, we can\neasily do them in minor releases too.\nOn Apr 28, 2015 12:51 PM, \"Peter Todd\" <pete at petertodd.org> wrote:\n\n> -----BEGIN PGP SIGNED MESSAGE-----\n> Hash: SHA256\n>\n> I'll point out that at this rate the soonest we'll see CHECKLOCKTIMEVERIFY\n> implemented on Bitcoin will be something like summer 2016, a year and a\n> half after it got adopted on Viacoin. (and a few other alts whose names I\n> forget)\n>\n> Right now the shortest path to adoption would be to release a v0.12 with\n> just a CLTV soft-fork as soon as the BIP66 softfork triggers. While there's\n> been proposal to change the way the upgrade mechanism triggers to a\n> multiple parallel fork scheme, that is quite complex, stateful, and will\n> need lots of review, probably a few months worth; faster would be to\n> continue with the existing mechanism.\n>\n> IMO the main reason to accelerate CLTV is scalability. The only viable\n> scalability improvements possible in the short/medium term that don't\n> entirely rely on trusting third parties are payment channel based. While we\n> have a working payment channel scheme - Jeremy Spilman's refund tx based\n> system - it is fairly complex, needs good and immediate backups, and is\n> susceptible to tx malleability. CLTV fixes those issues robustly. Of\n> course, payment channel schemes can start off with Spilman's scheme first\n> and go to CLTV later, but that is a lot of extra code to be written and\n> later depreciated - I'm sure many authors are dubious about going down that\n> path.\n>\n> Thoughts?\n>\n>\n> On 28 April 2015 03:44:16 GMT-04:00, \"Wladimir J. van der Laan\" <\n> laanwj at gmail.com> wrote:\n> >Hello all,\n> >\n> >The release window for 0.11 is nearing, I'd propose the following\n> >schedule:\n> >\n> >2015-05-01  Soft translation string freeze\n> >            Open Transifex translations for 0.11\n> >            Finalize and close translation for 0.9\n> >\n> >2015-05-15  Feature freeze, string freeze\n> >\n> >2015-06-01  Split off 0.11 branch\n> >            Tag and release 0.11.0rc1\n> >            Start merging for 0.12 on master branch\n> >\n> >2015-07-01  Release 0.11.0 final (aim)\n> >\n> >In contrast to former releases, which were protracted for months, let's\n> >try to be more strict about the dates. Of course it is always possible\n> >for last-minute critical issues to interfere with the planning. The\n> >release will not be held up for features, though, and anything that\n> >will not make it to 0.11 will be postponed to next release scheduled\n> >for end of the year.\n> >\n> >Wladimir\n> -----BEGIN PGP SIGNATURE-----\n>\n> iQE9BAEBCAAnIBxQZXRlciBUb2RkIDxwZXRlQHBldGVydG9kZC5vcmc+BQJVP2Wy\n> AAoJEMCF8hzn9LncqOcH/3rDFbgWprqTfk8dKWAItRcY6ZyiQ+dNrqNgymaNP5Ig\n> MNKaTmWYyZRH6PW13JOv72ArXia+D82Mp5reTaLIb3TV5uef2biruOCaH9eI8Uv5\n> i2PCBLw3uqZIZZ5Qr/7nlp2CaBQIGDK3fg3jx10UyWpg4BxkKP2mLJibMG8l3JcK\n> Moi/kh6lvwySpT8NYtZfXax+5AQ2oLXiSzbFF8P0ioI9fJYaoVCAyS5VEE4KsZnV\n> thOaoPAWoK+spEYKFrjvyXnQXFe6m+KPfRPU3WKYSFhI7m8MW6bKxEnD0Lffo6qU\n> YS6jsE3A0LoKs4kD73ivHcMeXDhO6LXyPAu8zQtgGr8=\n> =Z/GT\n> -----END PGP SIGNATURE-----\n>\n>\n>\n> ------------------------------------------------------------------------------\n> One dashboard for servers and applications across Physical-Virtual-Cloud\n> Widest out-of-the-box monitoring support with 50+ applications\n> Performance metrics, stats and reports that give you Actionable Insights\n> Deep dive visibility with transaction tracing using APM Insight.\n> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150428/1f3dd52d/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2015-04-28T13:42:38",
                "message_text_only": "On Tue, Apr 28, 2015 at 04:01:00AM -0700, Pieter Wuille wrote:\n> As softforks almost certainly require backports to older releases and other\n> software anyway, I don't think they should necessarily be bound to Bitcoin\n> Core major releases. If they don't require large code changes, we can\n> easily do them in minor releases too.\n\nThe code changes for absolute CLTV are quite small, and easily ported to\nany Bitcoin Core version.\n\nWhat's the oldest version you think we need backports for?\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000000e7980aab9c096c46e7f34c43a661c5cb2ea71525ebb8af7\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 650 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150428/f5b63150/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin core 0.11 planning",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Peter Todd",
                "Pieter Wuille",
                "Wladimir J. van der Laan"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 8524
        }
    },
    {
        "title": "[Bitcoin-development] Looking for a good bitcoin script decompiler in Python",
        "thread_messages": [
            {
                "author": "Braun Brelin",
                "date": "2015-04-29T17:12:08",
                "message_text_only": "Hi all,\n\nI'm trying to find a good python script that will take the hash of the\nlocking and\nunlocking tx scripts and output the actual op codes.\n\nAny ideas where to look?\n\nThanks,\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150429/d96e280f/attachment.html>"
            },
            {
                "author": "Richard Moore",
                "date": "2015-04-29T22:16:36",
                "message_text_only": "I have a library, pycoind (https://github.com/ricmoo/pycoind <https://github.com/ricmoo/pycoind>) you might find useful.\n\n\n>>> import pycoind\n\n>>> str(pycoind.script.Tokenizer('76a9143f320f852a51643d3ffbaa1f49bfe521dd97764a88ac'.decode('hex')))\n'OP_DUP OP_HASH160 3f320f852a51643d3ffbaa1f49bfe521dd97764a OP_EQUALVERIFY OP_CHECKSIG'\n\n\n\n\n> On Apr 29, 2015, at 1:12 PM, Braun Brelin <bbrelin at gmail.com> wrote:\n> \n> Hi all, \n> \n> I'm trying to find a good python script that will take the hash of the locking and \n> unlocking tx scripts and output the actual op codes.  \n> \n> Any ideas where to look?  \n> \n> Thanks,\n> \n> \n> ------------------------------------------------------------------------------\n> One dashboard for servers and applications across Physical-Virtual-Cloud \n> Widest out-of-the-box monitoring support with 50+ applications\n> Performance metrics, stats and reports that give you Actionable Insights\n> Deep dive visibility with transaction tracing using APM Insight.\n> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y_______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8><(((\u00ba>\n\nRichard Moore ~ Founder\nGenetic Mistakes Software inc.\nphone: (778) 882-6125\nemail: ricmoo at geneticmistakes.com <mailto:ricmoo at geneticmistakes.com>\nwww: http://GeneticMistakes.com <http://geneticmistakes.com/>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150429/72422ca0/attachment.html>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2015-04-29T23:27:19",
                "message_text_only": "python-bitcoinlib supports script parsing and execution.\n\n\nOn Wed, Apr 29, 2015 at 6:16 PM, Richard Moore <me at ricmoo.com> wrote:\n\n> I have a library, pycoind (https://github.com/ricmoo/pycoind) you might\n> find useful.\n>\n>\n> >>> import pycoind\n>\n> >>>\n> str(pycoind.script.Tokenizer('76a9143f320f852a51643d3ffbaa1f49bfe521dd97764a88ac'.decode('hex')))\n> 'OP_DUP OP_HASH160 3f320f852a51643d3ffbaa1f49bfe521dd97764a OP_EQUALVERIFY\n> OP_CHECKSIG'\n>\n>\n>\n>\n> On Apr 29, 2015, at 1:12 PM, Braun Brelin <bbrelin at gmail.com> wrote:\n>\n> Hi all,\n>\n> I'm trying to find a good python script that will take the hash of the\n> locking and\n> unlocking tx scripts and output the actual op codes.\n>\n> Any ideas where to look?\n>\n> Thanks,\n>\n>\n>\n> ------------------------------------------------------------------------------\n> One dashboard for servers and applications across Physical-Virtual-Cloud\n> Widest out-of-the-box monitoring support with 50+ applications\n> Performance metrics, stats and reports that give you Actionable Insights\n> Deep dive visibility with transaction tracing using APM Insight.\n>\n> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y_______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n> .\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8><(((\u00ba>\n>\n> Richard Moore ~ Founder\n> Genetic Mistakes Software inc.\n> phone: (778) 882-6125\n> email: ricmoo at geneticmistakes.com\n> www: http://GeneticMistakes.com\n>\n>\n>\n> ------------------------------------------------------------------------------\n> One dashboard for servers and applications across Physical-Virtual-Cloud\n> Widest out-of-the-box monitoring support with 50+ applications\n> Performance metrics, stats and reports that give you Actionable Insights\n> Deep dive visibility with transaction tracing using APM Insight.\n> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150429/b3dc9157/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Looking for a good bitcoin script decompiler in Python",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Braun Brelin",
                "Richard Moore",
                "Jeff Garzik"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 4538
        }
    }
]