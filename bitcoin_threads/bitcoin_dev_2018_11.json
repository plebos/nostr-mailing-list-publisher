[
    {
        "title": "[bitcoin-dev] draft proposal: change forwarding (improved fungibility through wallet interoperability)",
        "thread_messages": [
            {
                "author": "Yuval Kogman",
                "date": "2018-11-06T15:50:38",
                "message_text_only": "Hello,\n\nI would like to propose a method based on BIP32 (and optionally BIP44) for\nimproving fungibility and on chain privacy with wallets for which this is\nnot a primary concern, requiring minimal changes to allow such wallets to\nsafely forward change outputs to more specialized wallets. This is intended\nto complement more comprehensive proposals such as BIP79.\n\nNote that this draft is still incomplete, there are open questions about\nthe particular format to use. In its current form it proposes two viable\noptions (and two more are included completeness) and though I have a slight\npreference for the first option, I remain undecided given the tradeoffs,\nand so I am writing the mailing list to solicit inputs/criticism.\n\nhttps://gist.github.com/nothingmuch/652f3a98089a0600637eadab738b2d6a\n\nThanks to SirMeow, Adam Ficsor, and Adam Gibson for reviewing earlier\nversions and providing valuable feedback and suggestions.\n\nRegards,\nYuval\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181106/3f05c79a/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "draft proposal: change forwarding (improved fungibility through wallet interoperability)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Yuval Kogman"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1124
        }
    },
    {
        "title": "[bitcoin-dev]  BIP- & SLIP-0039 -- better multi-language support",
        "thread_messages": [
            {
                "author": "Weiji Guo",
                "date": "2018-11-06T16:16:41",
                "message_text_only": "Hello everyone,\n\nI just realized that BIP-0039 is language dependent. I was assuming the\nother way till I looked closer. The way the seed is derived from a BIP-0039\nentropy, as is shown below, depends on which language to generate the\nmnemonic sentence:\n\n   Entropy <=> Mnemonic Sentence => PBKDF2 => BIP-0032 Seed\n\nTherefore when a user choose a non-English mnemonic code he or she is stuck\nwith that language. Meanwhile only a few native languages are supported.\n\nSLIP-0039 does not solve this issue in a user friendly way by providing\nonly an English wordlist. That's understandable as it aims to provide SSS\ncapability. However those users who do not speak English or recognize\nEnglish words will suffer.\n\nWhat I am trying to bring to attention of the community is that, no matter\nif we make a new version of BIP-0039, or a new BIP (with SSS support), or\nto enhance SLIP-0039, we really need to address this language issue.\n\nHere are what I propose:\n\n1. The mnemonic code should be only a representation of underlying entropy\nor (pre) master secret, seed, whatever. In this way, the same seed/secret\ncould be displayed in English or in Chinese or other languages. Then there\ncould be 3rd party conversion tools to support translations in case any\nwallet software or device does not support all specified languages. Now it\nlooks like:\n\n   Mnemonic Sentence <=> Entropy => PBKDF2 => BIP-0032 Seed\n\n2. Given that only 8 languages are supported in BIP-0039, we should allow\nthe seed/secret to be represented in decimal numbers, each ranging from 0\nto 2047. So those who cannot find a native language support yet having\ndifficulty coping words in other languages could choose to just use numbers.\n\nSo far I don't have a preference how this should be implemented. I'd like\nto hear from community first.\n\nThanks,\n\nWeiji Guo\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181107/88677440/attachment.html>"
            },
            {
                "author": "Weiji Guo",
                "date": "2018-11-22T17:25:07",
                "message_text_only": "Hi Everyone,\n\nThank you very much in this thanks giving day for the detailed and well\nthought out responses. :)\n\nSteven Hatzakis via bitcoin-dev <bitcoin-dev at\nlists.linuxfoundation.org\n<https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>>:\n\n>* *Option 2*: Perhaps a revision is needed to how the BIP39 seed is\n*>* generated in the first place, such as by hashing the entropy instead of the\n*>* words. Any thoughts on how viable that could be where the initial entropy\n*>* is fed into the PBKDF2 function and not the words?*\n\nIf we go this direction, I'd suggest that we pull Shamir's Secret Sharing\ninto the game. Trezor's\nSLIP-0039 proposal is great and has many security aspects already covered.\nHowever, it does\nnot allow any language other than English and Trezor team clearly stated\nthat no other language\nwill be supported.\n\nWhile I really want to keep the language independent design. So in the\nrevision, I'd like to see\na language id (allocated to each one having a defined wordlist) in the SSS\nshare, as well as\nshare id, threshold, index, share value, checksum etc.\n\nRegarding checksum scheme, SLIP-0039 proposals a 3-word Reed-Solomon\ndesign. It has a very\ngood error checking capability but not very good at providing hints to\nerror recovery. Trezor team\nopposes to the idea of providing hints to users regarding how to fix an\nerror. This could lead to\ndifficulties for some vendors, and in small probability, confusions to\nusers (when there is a 2-word\nerror)\n\nI do agree with Trezor team that it should be users' responsibility to\nrecover from a detected error.\nHowever, there is a better way than solely rely on checksum. That is, as in\nour revision, we can\nsupport mnemonic in multiple languages simultaneously, why don't we use two\nlanguages, or one\nlanguage + numbers to check each other? In Steven's example (language id,\nshare id, etc. skipped)\nwe could record a SSS share (assuming it is one of the shares just for the\nsake of example) like:\n\n>* *In English*: minimum fee sure ticket faculty banana gate purse caught\n*>* valley globe shift\n*>* *In Spanish*: mercado faja soledad tarea evadir aries gafas peine bu\u0301ho\n*>* tumor gerente reja*\n\nOr\n\n>* *In English*: minimum fee sure ticket faculty banana gate purse caught\n*>* valley globe shift*\n\n>* Word Indexes: 1128, 676, 1744, 1805, 653, 145, 770, 1396, 291, 1927,\n794, 1582*\n\n\nThen software will have to check checksum as well as to check if words\nmatch each other. For\nexample, \"minimum\"'s index value in English wordlist should equal to \"\n*mercado*\"'s in Spanish,\nor should equal to 1128.\n\nIf any error is detected, combining the checksum value and dual-encoding\ninformation, it is much\neasier to figure out which word was handprinted incorrectly.\n\nBTW, it is very error prone to handprint. Some study suggests about 0.9%\nper word rate. See\nhttp://panko.shidler.hawaii.edu/HumanErr/Basic.htm\n\nHotopf [1980]\n\nW sample (written exam). Per word\n\n0.9%\n\nIt is important to have an error recovery mechanism easy to understand and\nimplement.\n\nThanks,\nWeiji\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181123/883b184a/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP- & SLIP-0039 -- better multi-language support",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Weiji Guo"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 5229
        }
    },
    {
        "title": "[bitcoin-dev] Considering starting a toy full-node implementation. Any advice?",
        "thread_messages": [
            {
                "author": "rze",
                "date": "2018-11-06T21:21:11",
                "message_text_only": "Hello,\n\nI'm considering to start developing a toy full validating node implementation (no wallet, no mining) for educational purposes.\n\nSome questions:\n\n1) which resource do you suggest for as a reference for the protocol?\n2) which part do you suggest to start with?\n3) I was thinking to use btcd as a reference since I'm not familiar with C++ (bitcoind)\n4) are there any other general advice or tips for such endeavours?\n\nThanks in advance."
            },
            {
                "author": "\u0410\u0440\u0442\u0451\u043c \u041b\u0438\u0442\u0432\u0438\u043d\u043e\u0432\u0438\u0447",
                "date": "2018-11-07T13:20:00",
                "message_text_only": "Hi there.\n\nBeen there, done that.\n\n-Don't try to set big goals at once.\nStart small and aim for small steps, i.e. by connecting to nodes, then\ngetting some data from them, then downloading blocks, then parsing\nblocks, then building an UTXO set, etc.\nMy first long term goal was to simply compute the balance of an address.\n\n-Expect to work with huge and varied sets of data.\nYou'll have to build and use tens of Gb of indexes, for example.\nEarly transactions also have all sorts of non-standard scripts, and\ntestnet have all sorts of weird non-standard scripts, so plan\naccordingly.\n\n-Don't write off making a wallet or mining.\nThe latter is easy to do on CPU on testnet and learning to make valid\nblocks helps a lot in understanding how things work.\nA wallet, on the other hand, gives you good understanding of keys and\ntransactions, especially if you want to try doing all the EC math\nyourself.\nI also wrote things to be generic between several forks and chains,\nlike Litecoin, Doge, Zcash and a bunch of now-dead alts - there is so\nlittle difference between many of them that all it takes is a\nparameter or two. Helps with perspective.\nNaturally, stay away from mainnets and real money if you do your own\nwallet and crypto.\n\n-Don't get too excited when you'd see exploitable signatures.\nAll of them were plundered years ago, and by now no one makes mistakes\nlike that.\nAlso, there are plenty of bots which are constantly scanning the chain\nfor weak keys and signatures, any new ones will be gone in a few\nseconds.\n\n-Expect cthulhus. There used to be plenty of artwork and puzzles in\nthe early blockchain.\nHere is a short write up with a few of the things i found: https www\ndot ribbonfarm dot\ncom/2017/07/20/the-ominouslier-roar-of-the-bitcoin-wave/\n\n\nFor references, good ones i found and used were:\nhttps bitcoin dot org/en/developer-reference\nhttps en dot bitcoin dot it/wiki/Protocol_documentation\nAlso, BIPs contain a lot of specific details: https github dot com/bitcoin/bips\nThat should get you started, and by the time you get into the devilish\ndetails you'll have to look at the code for reference.\n\nNo idea about 3), haven't looked at it.\n\nGood luck and have fun.\n-Artem\n\n\u0441\u0440, 7 \u043d\u043e\u044f\u0431. 2018 \u0433. \u0432 15:01, <bitcoin-dev-request at lists.linuxfoundation.org>:\n>\n> Date: Tue, 6 Nov 2018 23:21:11 +0200\n> From: rze <rzeqeu at gmail.com>\n> To: bitcoin-dev at lists.linuxfoundation.org\n> Subject: [bitcoin-dev] Considering starting a toy full-node implementation. Any advice?\n>\n> Hello,\n>\n> I'm considering to start developing a toy full validating node implementation (no wallet, no mining) for educational purposes.\n>\n> Some questions:\n>\n> 1) which resource do you suggest for as a reference for the protocol?\n> 2) which part do you suggest to start with?\n> 3) I was thinking to use btcd as a reference since I'm not familiar with C++ (bitcoind)\n> 4) are there any other general advice or tips for such endeavours?\n>\n> Thanks in advance.\n>"
            },
            {
                "author": "John C. Vernaleo",
                "date": "2018-11-07T16:19:26",
                "message_text_only": "One point on the dataset issue that I learned early on in the btcd days:\nyou will be downloading the blockchain over and over again and that is not \ngood for an ssd or even worse an sd card.  I broke more than one sd card \nmaking sure btcd worked on a raspberry pi.\n\n-------------------------------------------------------\nJohn C. Vernaleo, Ph.D.\nwww.netpurgatory.com\njohn at netpurgatory.com\n-------------------------------------------------------\n\nOn Wed, 7 Nov 2018, \u0410\u0440\u0442\u0451\u043c \u041b\u0438\u0442\u0432\u0438\u043d\u043e\u0432\u0438\u0447 via bitcoin-dev wrote:\n\n> Hi there.\n>\n> Been there, done that.\n>\n> -Don't try to set big goals at once.\n> Start small and aim for small steps, i.e. by connecting to nodes, then\n> getting some data from them, then downloading blocks, then parsing\n> blocks, then building an UTXO set, etc.\n> My first long term goal was to simply compute the balance of an address.\n>\n> -Expect to work with huge and varied sets of data.\n> You'll have to build and use tens of Gb of indexes, for example.\n> Early transactions also have all sorts of non-standard scripts, and\n> testnet have all sorts of weird non-standard scripts, so plan\n> accordingly.\n>\n> -Don't write off making a wallet or mining.\n> The latter is easy to do on CPU on testnet and learning to make valid\n> blocks helps a lot in understanding how things work.\n> A wallet, on the other hand, gives you good understanding of keys and\n> transactions, especially if you want to try doing all the EC math\n> yourself.\n> I also wrote things to be generic between several forks and chains,\n> like Litecoin, Doge, Zcash and a bunch of now-dead alts - there is so\n> little difference between many of them that all it takes is a\n> parameter or two. Helps with perspective.\n> Naturally, stay away from mainnets and real money if you do your own\n> wallet and crypto.\n>\n> -Don't get too excited when you'd see exploitable signatures.\n> All of them were plundered years ago, and by now no one makes mistakes\n> like that.\n> Also, there are plenty of bots which are constantly scanning the chain\n> for weak keys and signatures, any new ones will be gone in a few\n> seconds.\n>\n> -Expect cthulhus. There used to be plenty of artwork and puzzles in\n> the early blockchain.\n> Here is a short write up with a few of the things i found: https www\n> dot ribbonfarm dot\n> com/2017/07/20/the-ominouslier-roar-of-the-bitcoin-wave/\n>\n>\n> For references, good ones i found and used were:\n> https bitcoin dot org/en/developer-reference\n> https en dot bitcoin dot it/wiki/Protocol_documentation\n> Also, BIPs contain a lot of specific details: https github dot com/bitcoin/bips\n> That should get you started, and by the time you get into the devilish\n> details you'll have to look at the code for reference.\n>\n> No idea about 3), haven't looked at it.\n>\n> Good luck and have fun.\n> -Artem\n>\n> \u0441\u0440, 7 \u043d\u043e\u044f\u0431. 2018 \u0433. \u0432 15:01, <bitcoin-dev-request at lists.linuxfoundation.org>:\n>>\n>> Date: Tue, 6 Nov 2018 23:21:11 +0200\n>> From: rze <rzeqeu at gmail.com>\n>> To: bitcoin-dev at lists.linuxfoundation.org\n>> Subject: [bitcoin-dev] Considering starting a toy full-node implementation. Any advice?\n>>\n>> Hello,\n>>\n>> I'm considering to start developing a toy full validating node implementation (no wallet, no mining) for educational purposes.\n>>\n>> Some questions:\n>>\n>> 1) which resource do you suggest for as a reference for the protocol?\n>> 2) which part do you suggest to start with?\n>> 3) I was thinking to use btcd as a reference since I'm not familiar with C++ (bitcoind)\n>> 4) are there any other general advice or tips for such endeavours?\n>>\n>> Thanks in advance.\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "Considering starting a toy full-node implementation. Any advice?",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "\u0410\u0440\u0442\u0451\u043c \u041b\u0438\u0442\u0432\u0438\u043d\u043e\u0432\u0438\u0447",
                "rze",
                "John C. Vernaleo"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 7143
        }
    },
    {
        "title": "[bitcoin-dev] BIP Proposal - Address Paste Improvement",
        "thread_messages": [
            {
                "author": "Adam Ficsor",
                "date": "2018-11-07T14:09:53",
                "message_text_only": "BIP: ?\nLayer: Applications\nTitle: Address Paste Improvement\nAuthor: nopara73 <adam.ficsor73 at gmail.com>, David Molnar <\nmolnardavid84 at gmail.com>\nType: Standard Track\nCreated: 2018-11-07\n\nAbstract. End-users often copy-paste addresses. This BIP aims to facilitate\nthe user experience regarding this process.\n\nMotivation. Some services already implemented autopaste functions, which is\ndone as follows: the user clicks to the address box and a Bitcoin address\nautomatically gets pasted from the clipboard. Depending on the\nimplementation, this could be either annoying or not permissive enough if\nit completely replaces the possibility of manually entering a Bitcoin\naddress.\n\nThe BIP Proposal can be found here:\nhttps://gist.github.com/nopara73/322dbd263a5c45267da87cffc36de6f6\n\nAn implementation will soon follow in Wasabi Wallet.\n\nRegards,\nnopara73\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181107/65afea63/attachment.html>"
            },
            {
                "author": "Andreas Schildbach",
                "date": "2018-11-07T21:28:54",
                "message_text_only": "Copying addresses to the clipboard should be discouraged, rather than\nsupported.\n\nIt is an inherently insecure mechanism. Regardless of the OS used, any\napplication can monitor the clipboard for Bitcoin addresses and replace\nany address with their own, usually without any specific permission or\nconfirmation by the user. Effectively this steals Bitcoins if the user\ndoesn't compare addresses manually.\n\nThis is a real risk, as this kind of malware has already been seen.\n\nNever copy & paste Bitcoin addresses!\n\n\nOn 07/11/2018 15.09, Adam Ficsor via bitcoin-dev wrote:\n> BIP: ?\n> Layer: Applications\n> Title: Address Paste Improvement\n> Author: nopara73 <adam.ficsor73 at gmail.com\n> <mailto:adam.ficsor73 at gmail.com>>, David Molnar <molnardavid84 at gmail.com\n> <mailto:molnardavid84 at gmail.com>>\n> Type: Standard Track\n> Created: 2018-11-07\n> \u00a0\u00a0\n> Abstract. End-users often copy-paste addresses. This BIP aims to\n> facilitate the user experience regarding this process.\u00a0 \u00a0\u00a0\n> \n> Motivation. Some services already implemented autopaste functions, which\n> is done as follows: the user clicks to the address box and a Bitcoin\n> address automatically gets pasted from the clipboard. Depending on the\n> implementation, this could be either annoying or not permissive enough\n> if it completely replaces the possibility of manually entering a Bitcoin\n> address.\n> \n> The BIP Proposal can be found\n> here:\u00a0https://gist.github.com/nopara73/322dbd263a5c45267da87cffc36de6f6\n> \n> An implementation will soon follow in Wasabi Wallet.\n> \n> Regards,\n> nopara73\n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2018-11-08T08:11:30",
                "message_text_only": "> Copying addresses to the clipboard should be discouraged, rather than\n> supported.\n\nDo you know any reasonably convenient mechanism for end user to\ntransfer an address from, say, a web page to the wallet address\ninput field ?\n\nThe clipboard is just a low-hanging fruit for malware, anyway. It just\nthe most easy point to replace an address. If the computer is\ncompromized, malware can edit the web page in the memory of the browser\nprocess, for example. If it shown as QR code, malware can decode,\ndetect that it is an address, and replace the image of QR code.\n\nI think that the only way to protect from this is to add some form of\nauthentication for an address - 2fa (transfer checksum via second\nchannel), visual fingerprints for addresses, that will are hard to\ndetect (and hence, replace) for malware, signing the destination address\nwith the key of an address that is already known and checking the\nsignature, etc.\n\nThe problem will be to come up with an address authentication procedure\nthat will be convenient for users and widely supported, as a result."
            },
            {
                "author": "Andreas Schildbach",
                "date": "2018-11-08T15:28:41",
                "message_text_only": "On 08/11/2018 09.11, Dmitry Petukhov via bitcoin-dev wrote:\n\n>> Copying addresses to the clipboard should be discouraged, rather than\n>> supported.\n> \n> Do you know any reasonably convenient mechanism for end user to\n> transfer an address from, say, a web page to the wallet address\n> input field ?\n\n- QR code scanning of a Bitcoin URI\n- On Android: A \"bitcoin:\" URI intent or a BIP70 payment message intent\n- On desktop OSes there are similar mechanisms to launch Apps from the\nbrowser (e.g. for mailto: links)\n\n> The clipboard is just a low-hanging fruit for malware, anyway. It just\n> the most easy point to replace an address. If the computer is\n> compromized, malware can edit the web page in the memory of the browser\n> process, for example. If it shown as QR code, malware can decode,\n> detect that it is an address, and replace the image of QR code.\n\nFor editing the clipboard your computer doesn't need to be compromised!\n*Any* app can do it, without special permission.\n\n> I think that the only way to protect from this is to add some form of\n> authentication for an address - 2fa (transfer checksum via second\n> channel), visual fingerprints for addresses, that will are hard to\n> detect (and hence, replace) for malware, signing the destination address\n> with the key of an address that is already known and checking the\n> signature, etc.\n\nFor cases where the payee is a well-known entity the BIP70 payment\nprotocol has authentication via certificates. That doesn't work for the\n\"the person in front of you is the only trust anchor you have\" usecase\nthough."
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2018-11-08T18:00:04",
                "message_text_only": "> > Do you know any reasonably convenient mechanism for end user to\n> > transfer an address from, say, a web page to the wallet address\n> > input field ?  \n> \n> - QR code scanning of a Bitcoin URI\n> - On Android: A \"bitcoin:\" URI intent or a BIP70 payment message\n> intent\n> - On desktop OSes there are similar mechanisms to launch Apps from the\n> browser (e.g. for mailto: links)\n\nThis works if the author of the web page thought about this, and\ncreated appropriate liks/qr codes. In many cases, addresses are\njust presented for users as text, to copy.\n\nPeople also send addresses in message apps and emails. Maybe if\napplications start to autodetect bitcoin addresses and convert them to\nbitcoin: links, there will be less need to copy-paste. But I suspect\nthat this feature will not be quickly adopted by applications.\n\n> For cases where the payee is a well-known entity the BIP70 payment\n> protocol has authentication via certificates. That doesn't work for\n> the \"the person in front of you is the only trust anchor you have\"\n> usecase though.\n\nThere are also BIP75 and BIP47 that may help, but the number of wallets\nthat support these protocols is small (I think in part because of\nrelative complexity of these protocols)."
            },
            {
                "author": "Adam Ficsor",
                "date": "2018-11-12T03:23:53",
                "message_text_only": "Thank you for all your comments. To sum up:\n\n- There were no comments related to the implementation details.\n- There are concerns about this may incentivize users to use copypaste\nfunctionality extensively.\n- A counter argument was made that crypto hijackers use the clipboard,\nbecause that is the most convenient thing to hijack, not because they can\nonly hijack that and, if Bitcoin users would move to other ways of\nspecifying destinations, that may end up being just as an issue, too.\n- The rest of the conversation was about crypto hijackers, which I think is\noff topic in this thread.\n\nFinally I'd like to note, there's already a work in progress implementation\nin Wasabi: https://github.com/zkSNACKs/WalletWasabi/pull/825\n\nOn Fri, Nov 9, 2018 at 1:14 AM Dmitry Petukhov via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> > > Do you know any reasonably convenient mechanism for end user to\n> > > transfer an address from, say, a web page to the wallet address\n> > > input field ?\n> >\n> > - QR code scanning of a Bitcoin URI\n> > - On Android: A \"bitcoin:\" URI intent or a BIP70 payment message\n> > intent\n> > - On desktop OSes there are similar mechanisms to launch Apps from the\n> > browser (e.g. for mailto: links)\n>\n> This works if the author of the web page thought about this, and\n> created appropriate liks/qr codes. In many cases, addresses are\n> just presented for users as text, to copy.\n>\n> People also send addresses in message apps and emails. Maybe if\n> applications start to autodetect bitcoin addresses and convert them to\n> bitcoin: links, there will be less need to copy-paste. But I suspect\n> that this feature will not be quickly adopted by applications.\n>\n> > For cases where the payee is a well-known entity the BIP70 payment\n> > protocol has authentication via certificates. That doesn't work for\n> > the \"the person in front of you is the only trust anchor you have\"\n> > usecase though.\n>\n> There are also BIP75 and BIP47 that may help, but the number of wallets\n> that support these protocols is small (I think in part because of\n> relative complexity of these protocols).\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n-- \nBest,\n\u00c1d\u00e1m\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181112/2c148c33/attachment.html>"
            },
            {
                "author": "Moral Agent",
                "date": "2018-11-08T17:43:36",
                "message_text_only": ">The problem will be to come up with an address authentication\nprocedure that will be convenient for users and widely supported, as a\nresult.\n\nYou could locally hash the destination address and from the hash derive a\nBIP39 style list of 12 words for visual comparison. I would advise against\nusing color or graphics -- the brain is too good at \"snapping\" to an\nexpected perception when it is running in graphics mode instead of symbolic\nmode.\n\n\nOn Thu, Nov 8, 2018 at 4:41 AM Dmitry Petukhov via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> > Copying addresses to the clipboard should be discouraged, rather than\n> > supported.\n>\n> Do you know any reasonably convenient mechanism for end user to\n> transfer an address from, say, a web page to the wallet address\n> input field ?\n>\n> The clipboard is just a low-hanging fruit for malware, anyway. It just\n> the most easy point to replace an address. If the computer is\n> compromized, malware can edit the web page in the memory of the browser\n> process, for example. If it shown as QR code, malware can decode,\n> detect that it is an address, and replace the image of QR code.\n>\n> I think that the only way to protect from this is to add some form of\n> authentication for an address - 2fa (transfer checksum via second\n> channel), visual fingerprints for addresses, that will are hard to\n> detect (and hence, replace) for malware, signing the destination address\n> with the key of an address that is already known and checking the\n> signature, etc.\n>\n> The problem will be to come up with an address authentication procedure\n> that will be convenient for users and widely supported, as a result.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181108/2123a8e6/attachment.html>"
            },
            {
                "author": "Jeffrey Paul",
                "date": "2018-11-08T17:12:17",
                "message_text_only": "> On Nov 7, 2018, at 13:28, Andreas Schildbach via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Copying addresses to the clipboard should be discouraged, rather than\n> supported.\n> \n> It is an inherently insecure mechanism. Regardless of the OS used, any\n> application can monitor the clipboard for Bitcoin addresses and replace\n> any address with their own, usually without any specific permission or\n> confirmation by the user. Effectively this steals Bitcoins if the user\n> doesn't compare addresses manually.\n> \n> This is a real risk, as this kind of malware has already been seen.\n\nOne can also make the argument that if the user's clipboard is able to be read/modified, then their working environment is already compromised and that the responsibility is already not upon specific application software, but the user or OS.\n\nDown here in the real world, an application that does not support copying and pasting of addresses is not an application that is very useful (to say the least) to many people who want to manage their own wallet, though I understand your desire to avoid such.  Perhaps offering alternatives such as supporting signed BIP70 payment requests is what you mean to do.\n\nThat said, I still think working around specific malware threats and vectors isn't the application's job, especially when doing so for a tiny, tiny fraction of users that have malware outweighs the needs of the 95%+ that need to support the \"I have an address on my clipboard I need to pay\" case.\n\nBest,\n-jp\n\n-- \nJeffrey Paul\n+1 312 361 0355\n+49 176 8058 2122 (signal)"
            }
        ],
        "thread_summary": {
            "title": "BIP Proposal - Address Paste Improvement",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Andreas Schildbach",
                "Adam Ficsor",
                "Jeffrey Paul",
                "Moral Agent",
                "Dmitry Petukhov"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 12772
        }
    },
    {
        "title": "[bitcoin-dev] BIP- & SLIP-0039 -- better multi-language support",
        "thread_messages": [
            {
                "author": "SomberNight",
                "date": "2018-11-08T10:37:50",
                "message_text_only": "Do you specifically want to support changing the language of seed\nwords, while keeping the bip32 root seed they generate unchanged?\nWhat is the usecase for this?\n\nYou mention that BIP39 already supports a few different languages.\nWhile this is true, many (I would guess most!) wallets only\nsupport the English wordlist.\nThere are doubts even from the authors of the BIP whether it was\na good idea in the first place to support multiple languages [0].\nI don't find this surprising as it seems bad design to have to fix and\nmaintain a wordlist for every language as the checksum depends on it.\nThe supported wordlists are effectively a part of the specification,\nand every new list would just make that specification larger.\n\nIf changing the language of seeds is not a requirement, then look\ninto Electrum seeds. They are language/wordlist agnostic.\n\nMnemonic Sentence => PBKDF2 => BIP-0032 Seed\n\nThe bip32 seed is derived by hashing the normalized mnemonic, and the\nchecksum is derived the same way but by using a different cheaper\nhash (single round of HMAC-SHA512; generation grinds until it matches\na pattern) [1]. For example, \"9dk\" is a valid segwit electrum seed.\n\n\n[0]: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-January/015507.html\n[1]: http://docs.electrum.org/en/latest/seedphrase.html\n\n\n> Date: Wed, 7 Nov 2018 00:16:41 +0800\n> From: Weiji Guo weiji.g at gmail.com\n> Subject: [bitcoin-dev] BIP- & SLIP-0039 -- better multi-language\n> support\n>\n> Hello everyone,\n>\n> I just realized that BIP-0039 is language dependent. I was assuming the\n> other way till I looked closer. The way the seed is derived from a BIP-0039\n> entropy, as is shown below, depends on which language to generate the\n> mnemonic sentence:\n>\n> Entropy <=> Mnemonic Sentence => PBKDF2 => BIP-0032 Seed\n>\n> Therefore when a user choose a non-English mnemonic code he or she is stuck\n> with that language. Meanwhile only a few native languages are supported.\n>\n> SLIP-0039 does not solve this issue in a user friendly way by providing\n> only an English wordlist. That's understandable as it aims to provide SSS\n> capability. However those users who do not speak English or recognize\n> English words will suffer.\n>\n> What I am trying to bring to attention of the community is that, no matter\n> if we make a new version of BIP-0039, or a new BIP (with SSS support), or\n> to enhance SLIP-0039, we really need to address this language issue.\n>\n> Here are what I propose:\n>\n> 1.  The mnemonic code should be only a representation of underlying entropy\n>     or (pre) master secret, seed, whatever. In this way, the same seed/secret\n>     could be displayed in English or in Chinese or other languages. Then there\n>     could be 3rd party conversion tools to support translations in case any\n>     wallet software or device does not support all specified languages. Now it\n>     looks like:\n>\n>     Mnemonic Sentence <=> Entropy => PBKDF2 => BIP-0032 Seed\n>\n>\n> 2. Given that only 8 languages are supported in BIP-0039, we should allow\n> the seed/secret to be represented in decimal numbers, each ranging from 0\n> to 2047. So those who cannot find a native language support yet having\n> difficulty coping words in other languages could choose to just use numbers.\n>\n> So far I don't have a preference how this should be implemented. I'd like\n> to hear from community first."
            },
            {
                "author": "Jonathan Underwood",
                "date": "2018-11-09T05:17:30",
                "message_text_only": ">  as it seems bad design to have to fix and maintain a wordlist for every\nlanguage as the checksum depends on it.\n\n>From BIP39:\n\n> The conversion of the mnemonic sentence to a binary seed is completely\nindependent from generating the sentence. This results in rather simple\ncode; there are no constraints on sentence structure and clients are free\nto implement their own wordlists or even whole sentence generators,\nallowing for flexibility in wordlists for typo detection or other purposes.\n>\n> Although using a mnemonic not generated by the algorithm described in\n\"Generating the mnemonic\" section is possible, this is not advised and\nsoftware must compute a checksum for the mnemonic sentence using a wordlist\nand issue a warning if it is invalid.\n\nSo BIP39 states \"no constraints on sentence structure and clients are free\nto implement their own wordlists or even whole sentence generators\" and yet\nat the same time one paragraph later \"this is not advised and software must\ncompute a checksum for the mnemonic sentence using a wordlist and issue a\nwarning if it is invalid\"...\n\nMy interpretation of this:\n\n1. ChecksumCheck function attempts to 1. find the wordlist 2. calculate the\nchecksum.\n2. If it fails to find the wordlist, return false\n3. If the checksum doesn't match return false\n4. If ChecksumCheck returns false, \"issue a warning\" but do not block seed\ngeneration. \"We couldn't check if your phrase is correct... you're on your\nown\"\n\n99.99% of implementing apps interpretation: (remember, error handling for\nuserspace is not done by the BIP39 library, but the app that uses it)\n\n1. Run ChecksumCheck\n2. If False, hard fail, do not allow seed generation.\n\nIf more apps would implement to the word of the BIP39 spec, multiple\nlanguages make sense, but since reality is no one follows the spec (/the\nspec is way too open to interpretation) then expecting every app to load\nevery language is unreasonable.\n\nElectrum actually handles BIP39 recovery the way the BIP specifies. I can\nrestore random strings if I want, and it warns me, and I can ignore it if I\nwish.\n\n\nAnywho. The BIP39 multi-language feature is crucial for non-English\nspeakers especially from Asia. Maybe northern Europeans have no problem\nwith English word spelling, but watching a normal Japanese person write\ndown their English mnemonic is painful.\n\nOne letter at a time, worried they wrote it wrong... still make mistakes...\nlose money because of it.\n\nWhereas users of Copay etc. that support Japanese wordlist write down their\nseed easily, and I have never heard of a Japanese newbie complaining about\n\"but I'm writing it just how I have it written down\" about their Japanese\nseed... only English.\n\nNot trying to give anyone a hard time, just telling the facts: lack of\nlocalized words for recovery phrase causes more money loss than supporting\nit. (When push comes to shove, at the very least Electrum will always\nsupport their recovery because it lets you hash anything)\n\nThis is all anecdotal of course. Just sharing my experience evangelizing in\nJapan.\n\nThanks,\nJon\n\n\n2018\u5e7411\u67088\u65e5(\u6728) 21:16 SomberNight via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org>:\n\n> Do you specifically want to support changing the language of seed\n> words, while keeping the bip32 root seed they generate unchanged?\n> What is the usecase for this?\n>\n> You mention that BIP39 already supports a few different languages.\n> While this is true, many (I would guess most!) wallets only\n> support the English wordlist.\n> There are doubts even from the authors of the BIP whether it was\n> a good idea in the first place to support multiple languages [0].\n> I don't find this surprising as it seems bad design to have to fix and\n> maintain a wordlist for every language as the checksum depends on it.\n> The supported wordlists are effectively a part of the specification,\n> and every new list would just make that specification larger.\n>\n> If changing the language of seeds is not a requirement, then look\n> into Electrum seeds. They are language/wordlist agnostic.\n>\n> Mnemonic Sentence => PBKDF2 => BIP-0032 Seed\n>\n> The bip32 seed is derived by hashing the normalized mnemonic, and the\n> checksum is derived the same way but by using a different cheaper\n> hash (single round of HMAC-SHA512; generation grinds until it matches\n> a pattern) [1]. For example, \"9dk\" is a valid segwit electrum seed.\n>\n>\n> [0]:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-January/015507.html\n> [1]: http://docs.electrum.org/en/latest/seedphrase.html\n>\n>\n> > Date: Wed, 7 Nov 2018 00:16:41 +0800\n> > From: Weiji Guo weiji.g at gmail.com\n> > Subject: [bitcoin-dev] BIP- & SLIP-0039 -- better multi-language\n> > support\n> >\n> > Hello everyone,\n> >\n> > I just realized that BIP-0039 is language dependent. I was assuming the\n> > other way till I looked closer. The way the seed is derived from a\n> BIP-0039\n> > entropy, as is shown below, depends on which language to generate the\n> > mnemonic sentence:\n> >\n> > Entropy <=> Mnemonic Sentence => PBKDF2 => BIP-0032 Seed\n> >\n> > Therefore when a user choose a non-English mnemonic code he or she is\n> stuck\n> > with that language. Meanwhile only a few native languages are supported.\n> >\n> > SLIP-0039 does not solve this issue in a user friendly way by providing\n> > only an English wordlist. That's understandable as it aims to provide SSS\n> > capability. However those users who do not speak English or recognize\n> > English words will suffer.\n> >\n> > What I am trying to bring to attention of the community is that, no\n> matter\n> > if we make a new version of BIP-0039, or a new BIP (with SSS support), or\n> > to enhance SLIP-0039, we really need to address this language issue.\n> >\n> > Here are what I propose:\n> >\n> > 1.  The mnemonic code should be only a representation of underlying\n> entropy\n> >     or (pre) master secret, seed, whatever. In this way, the same\n> seed/secret\n> >     could be displayed in English or in Chinese or other languages. Then\n> there\n> >     could be 3rd party conversion tools to support translations in case\n> any\n> >     wallet software or device does not support all specified languages.\n> Now it\n> >     looks like:\n> >\n> >     Mnemonic Sentence <=> Entropy => PBKDF2 => BIP-0032 Seed\n> >\n> >\n> > 2. Given that only 8 languages are supported in BIP-0039, we should allow\n> > the seed/secret to be represented in decimal numbers, each ranging from 0\n> > to 2047. So those who cannot find a native language support yet having\n> > difficulty coping words in other languages could choose to just use\n> numbers.\n> >\n> > So far I don't have a preference how this should be implemented. I'd like\n> > to hear from community first.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n-- \n-----------------\nJonathan Underwood\n\u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n-----------------\n\n\u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n\n\u6307\u7d0b: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181109/f93c2a37/attachment-0001.html>"
            },
            {
                "author": "Neill Miller",
                "date": "2018-11-16T14:03:35",
                "message_text_only": "On Fri, Nov 09, 2018 at 02:17:30PM +0900, Jonathan Underwood via bitcoin-dev wrote:\n> If more apps would implement to the word of the BIP39 spec, multiple\n> languages make sense, but since reality is no one follows the spec (/the\n> spec is way too open to interpretation) then expecting every app to load\n> every language is unreasonable.\n> \n> Electrum actually handles BIP39 recovery the way the BIP specifies. I can\n> restore random strings if I want, and it warns me, and I can ignore it if I\n> wish.\n\nElectrum mnemonics are not based on BIP39, which is why it can do\nthis.\n\n-Neill."
            },
            {
                "author": "Jonathan Underwood",
                "date": "2018-11-16T14:05:50",
                "message_text_only": "Nope.\n\nThis is how Electrum treats BIP39 restoring as well, try it out.\n\n-Jon\n\n2018\u5e7411\u670816\u65e5(\u91d1) 23:04\u3001Neill Miller \u3055\u3093\uff08neillm at thecodefactory.org\uff09\u306e\u30e1\u30c3\u30bb\u30fc\u30b8:\n\n> On Fri, Nov 09, 2018 at 02:17:30PM +0900, Jonathan Underwood via\n> bitcoin-dev wrote:\n> > If more apps would implement to the word of the BIP39 spec, multiple\n> > languages make sense, but since reality is no one follows the spec (/the\n> > spec is way too open to interpretation) then expecting every app to load\n> > every language is unreasonable.\n> >\n> > Electrum actually handles BIP39 recovery the way the BIP specifies. I can\n> > restore random strings if I want, and it warns me, and I can ignore it\n> if I\n> > wish.\n>\n> Electrum mnemonics are not based on BIP39, which is why it can do\n> this.\n>\n> -Neill.\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181116/545faa2c/attachment.html>"
            },
            {
                "author": "Neill Miller",
                "date": "2018-11-16T14:15:10",
                "message_text_only": "Ah, ok.  I've worked with the non-BIP39 Electrum mnemonics, which have\nthis behaviour, but haven't tried the BIP39 support within it.\n\nThanks,\n-Neill.\n\nOn Fri, Nov 16, 2018 at 11:05:50PM +0900, Jonathan Underwood wrote:\n> Nope.\n> \n> This is how Electrum treats BIP39 restoring as well, try it out.\n> \n> -Jon\n> \n> 2018\u5e7411\u670816\u65e5(\u91d1) 23:04\u3001Neill Miller \u3055\u3093\uff08neillm at thecodefactory.org\uff09\u306e\u30e1\u30c3\u30bb\u30fc\u30b8:\n> \n> > On Fri, Nov 09, 2018 at 02:17:30PM +0900, Jonathan Underwood via\n> > bitcoin-dev wrote:\n> > > If more apps would implement to the word of the BIP39 spec, multiple\n> > > languages make sense, but since reality is no one follows the spec (/the\n> > > spec is way too open to interpretation) then expecting every app to load\n> > > every language is unreasonable.\n> > >\n> > > Electrum actually handles BIP39 recovery the way the BIP specifies. I can\n> > > restore random strings if I want, and it warns me, and I can ignore it\n> > if I\n> > > wish.\n> >\n> > Electrum mnemonics are not based on BIP39, which is why it can do\n> > this.\n> >\n> > -Neill.\n> >\n> >"
            },
            {
                "author": "Steven Hatzakis",
                "date": "2018-11-19T19:54:01",
                "message_text_only": "Hi Weiji, and Everyone,\n\nI think this is an important topic so sharing my two cents in case in\nhelps: It makes sense for users to know that they can't merely just\ntranslate a word from one language into another and expect the same\nunderlying entropy to be mapped, as the wordlists are not the same (i.e.\nwords differ at the same index values across languages).\n\nHowever, while the words for each language cannot translate directly to\ntheir equivalent in another language, in terms of entropy (bits), the\nunderlying entropy is, in fact, the same, when comparing mnemonics\ngenerated across languages (see English/Spanish comparison below) when\nsourced from the same initial entropy.\n\nImportantly, the entropy is a pre-image of the resulting mnemonic and\ndoesn't change as the language changes, where the only changes are to the\nresulting words which depend on the language chosen, for a given entropy\nstring. Ideally, the wallet/software should deal with these nuances, I\ndon't think the protocol needs any revision (except for how the BIP39 seed\nis derived, perhaps), even if someone made up their own wordlist, as long\nas the wallet/software has a copy of it to map those words to the\nunderlying index values, it's *those underlying index values and the\nentropy they map too is what really matters**. *\n\nI fully support the idea for users to back up this pre-image (initial\nentropy) as it can also be used to check the validity of the mnemonic and\ncheck that it mapped correctly, see Ian Coleman's BIP39 tool which shows\nindex values, a feature that I proposed last year and was since\nimplemented. Below is an example of how two mnemonics generated with the\nsame entropy will produce different BIP39 seeds.\n\n* Example initial entropy of 128 bits +4 bit checksum derived from hash of\nbyte array: *\n\n10001101000 01010100100 11011010000 11100001101 01010001101 00010010001\n01100000010 10101110100 00100100011 11110000111 01100011010 1100010 (+1110\nchecksum)\n\n*In English*: minimum fee sure ticket faculty banana gate purse caught\nvalley globe shift\n\nThe same initial entropy above (all 132 bits) produces this mnemonic:\n\n*In Spanish*: mercado faja soledad tarea evadir aries gafas peine bu\u0301ho\ntumor gerente reja\n\nAnd the underlying index values below are the same for both the English and\nSpanish mnemonics above:\n\nWord Indexes: 1128, 676, 1744, 1805, 653, 145, 770, 1396, 291, 1927, 794,\n1582\n\n*ISSUE AT HAND*:  While the initial entropy is the same, and word indexes\nthe same for a given entropy, (i.e. same pre-image), the resulting BIP39\nseed is not the same when comparing the above English mnemonic with its\nSpanish counterpart:\n\n   - *English BIP39 seed:*\n   ce7618075099c89e986f18dc495daa3be190450ed07bef77d4334a54dbc1cd7e205797ffed2615ac0999a5d691f65bf316e2cdbfd2c9d7d90b03e77ff1e6a6f5\n   - *Spanish BIP39 seed*:\n   9f164de0fb09af51b5831886e424d6d2479d49b5e5a1b28f5c09467ea36089b144cd94bb9b636b3c27ccff96a8958e5b7ce43cf1dea81423fc66fa7fef0aea2c\n\n\n*Option 1:* Without changing anything in terms of the entropy\ngeneration/mapping process in the BIP39 spec, the wallet/client-side\nsoftware would ideally recognize the language and show the corresponding\nindex value per wordlist, and reverse-calculate the entropy and then re-map\nit to the language selected.\n\n*Option 2*: Perhaps a revision is needed to how the BIP39 seed is generated\nin the first place, such as by hashing the entropy instead of the words.\nAny thoughts on how viable that could be where the initial entropy is fed\ninto the PBKDF2 function and not the words?\n\n*Closing thoughts and tiny checksum nitpick: *\n\n      - The multiple BIP39 seeds per language lend some similarities to\nBIP44 multi-account, so perhaps this can be an advantage, depends on how it\nis applied in UI/UX's (compared to having one BIP39 seed regardless of\nlanguage, for a given initial entropy).\n      - There is perhaps an opportunity to add greater detail to the BIP39\nspec in terms of standards/best-practices for computing checksum values, as\nsome software may be hashing bits, versus hashing bytes, or hashing the\nentropy as a hex string, etc.. for a given entropy, which will result in\ndifferent checksum values for the same \"valid\" mnemonic, that might not be\n\"valid\" in another wallet which may format the data differently before\nhashing to compute the checksum.\n\n\nBest regards,\n\nSteven Hatzakis\n\n_______________\n[bitcoin-dev] BIP- & SLIP-0039 -- better multi-language support*Weiji\nGuo* weiji.g\nat gmail.com\n<bitcoin-dev%40lists.linuxfoundation.org?Subject=Re:%20Re%3A%20%5Bbitcoin-dev%5D%20%20BIP-%20%26%20SLIP-0039%20--%20better%20multi-language%20support&In-Reply-To=%3CCA%2Bydi%3DLM%2Bq-9WKewb%3D65tWCqM1cPMoWEeWq5XAxdqg4rz%3DZJ6g%40mail.gmail.com%3E>\n*Tue Nov 6 16:16:41 UTC 2018*\n\n\n   - Previous message: [bitcoin-dev] draft proposal: change forwarding\n   (improved fungibility through wallet interoperability)\n   <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016469.html>\n   - Next message: [bitcoin-dev] Considering starting a toy full-node\n   implementation. Any advice?\n   <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016470.html>\n   - *Messages sorted by:* [ date ]\n   <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/date.html#16468>\n    [ thread ]\n   <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/thread.html#16468>\n    [ subject ]\n   <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/subject.html#16468>\n    [ author ]\n   <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/author.html#16468>\n\n------------------------------\n\nHello everyone,\n\nI just realized that BIP-0039 is language dependent. I was assuming the\nother way till I looked closer. The way the seed is derived from a BIP-0039\nentropy, as is shown below, depends on which language to generate the\nmnemonic sentence:\n\n   Entropy <=> Mnemonic Sentence => PBKDF2 => BIP-0032 Seed\n\nTherefore when a user choose a non-English mnemonic code he or she is stuck\nwith that language. Meanwhile only a few native languages are supported.\n\nSLIP-0039 does not solve this issue in a user friendly way by providing\nonly an English wordlist. That's understandable as it aims to provide SSS\ncapability. However those users who do not speak English or recognize\nEnglish words will suffer.\n\nWhat I am trying to bring to attention of the community is that, no matter\nif we make a new version of BIP-0039, or a new BIP (with SSS support), or\nto enhance SLIP-0039, we really need to address this language issue.\n\nHere are what I propose:\n\n1. The mnemonic code should be only a representation of underlying entropy\nor (pre) master secret, seed, whatever. In this way, the same seed/secret\ncould be displayed in English or in Chinese or other languages. Then there\ncould be 3rd party conversion tools to support translations in case any\nwallet software or device does not support all specified languages. Now it\nlooks like:\n\n   Mnemonic Sentence <=> Entropy => PBKDF2 => BIP-0032 Seed\n\n2. Given that only 8 languages are supported in BIP-0039, we should allow\nthe seed/secret to be represented in decimal numbers, each ranging from 0\nto 2047. So those who cannot find a native language support yet having\ndifficulty coping words in other languages could choose to just use numbers.\n\nSo far I don't have a preference how this should be implemented. I'd like\nto hear from community first.\n\nThanks,\n\nWeiji Guo\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181107/88677440/attachment.html>\n\n------------------------------\n\n\n   - Previous message: [bitcoin-dev] draft proposal: change forwarding\n   (improved fungibility through wallet interoperability)\n   <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016469.html>\n   - Next message: [bitcoin-dev] Considering starting a toy full-node\n   implementation. Any advice?\n   <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016470.html>\n   - *Messages sorted by:* [ date ]\n   <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/date.html#16468>\n    [ thread ]\n   <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/thread.html#16468>\n    [ subject ]\n   <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/subject.html#16468>\n    [ author ]\n   <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/author.html#16468>\n\n------------------------------\nMore information about the bitcoin-dev mailing list\n<https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181119/1363e304/attachment.html>"
            },
            {
                "author": "Natanael",
                "date": "2018-11-20T01:51:44",
                "message_text_only": "Den m\u00e5n 19 nov. 2018 21:21 skrev Steven Hatzakis via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org>:\n\n> Hi Weiji, and Everyone,\n>\n> I think this is an important topic so sharing my two cents in case in\n> helps: It makes sense for users to know that they can't merely just\n> translate a word from one language into another and expect the same\n> underlying entropy to be mapped, as the wordlists are not the same (i.e.\n> words differ at the same index values across languages).\n>\n> However, while the words for each language cannot translate directly to\n> their equivalent in another language, in terms of entropy (bits), the\n> underlying entropy is, in fact, the same, when comparing mnemonics\n> generated across languages (see English/Spanish comparison below) when\n> sourced from the same initial entropy.\n>\n> Importantly, the entropy is a pre-image of the resulting mnemonic and\n> doesn't change as the language changes, where the only changes are to the\n> resulting words which depend on the language chosen, for a given entropy\n> string. Ideally, the wallet/software should deal with these nuances, I\n> don't think the protocol needs any revision (except for how the BIP39 seed\n> is derived, perhaps), even if someone made up their own wordlist, as long\n> as the wallet/software has a copy of it to map those words to the\n> underlying index values, it's *those underlying index values and the\n> entropy they map too is what really matters**. *\n>\n> I fully support the idea for users to back up this pre-image (initial\n> entropy) as it can also be used to check the validity of the mnemonic and\n> check that it mapped correctly, see Ian Coleman's BIP39 tool which shows\n> index values, a feature that I proposed last year and was since\n> implemented. Below is an example of how two mnemonics generated with the\n> same entropy will produce different BIP39 seeds.\n>\n> * Example initial entropy of 128 bits +4 bit checksum derived from hash of\n> byte array: *\n>\n> 10001101000 01010100100 11011010000 11100001101 01010001101 00010010001\n> 01100000010 10101110100 00100100011 11110000111 01100011010 1100010 (+1110\n> checksum)\n>\n> *In English*: minimum fee sure ticket faculty banana gate purse caught\n> valley globe shift\n>\n> The same initial entropy above (all 132 bits) produces this mnemonic:\n>\n> *In Spanish*: mercado faja soledad tarea evadir aries gafas peine bu\u0301ho\n> tumor gerente reja\n>\n> And the underlying index values below are the same for both the English\n> and Spanish mnemonics above:\n>\n> Word Indexes: 1128, 676, 1744, 1805, 653, 145, 770, 1396, 291, 1927, 794,\n> 1582\n>\n> *ISSUE AT HAND*:  While the initial entropy is the same, and word indexes\n> the same for a given entropy, (i.e. same pre-image), the resulting BIP39\n> seed is not the same when comparing the above English mnemonic with its\n> Spanish counterpart:\n>\n>    - *English BIP39 seed:*\n>    ce7618075099c89e986f18dc495daa3be190450ed07bef77d4334a54dbc1cd7e205797ffed2615ac0999a5d691f65bf316e2cdbfd2c9d7d90b03e77ff1e6a6f5\n>    - *Spanish BIP39 seed*:\n>    9f164de0fb09af51b5831886e424d6d2479d49b5e5a1b28f5c09467ea36089b144cd94bb9b636b3c27ccff96a8958e5b7ce43cf1dea81423fc66fa7fef0aea2c\n>\n>\n> *Option 1:* Without changing anything in terms of the entropy\n> generation/mapping process in the BIP39 spec, the wallet/client-side\n> software would ideally recognize the language and show the corresponding\n> index value per wordlist, and reverse-calculate the entropy and then re-map\n> it to the language selected.\n>\n> *Option 2*: Perhaps a revision is needed to how the BIP39 seed is\n> generated in the first place, such as by hashing the entropy instead of the\n> words. Any thoughts on how viable that could be where the initial entropy\n> is fed into the PBKDF2 function and not the words?\n>\n> *Closing thoughts and tiny checksum nitpick: *\n>\n>       - The multiple BIP39 seeds per language lend some similarities to\n> BIP44 multi-account, so perhaps this can be an advantage, depends on how it\n> is applied in UI/UX's (compared to having one BIP39 seed regardless of\n> language, for a given initial entropy).\n>       - There is perhaps an opportunity to add greater detail to the BIP39\n> spec in terms of standards/best-practices for computing checksum values, as\n> some software may be hashing bits, versus hashing bytes, or hashing the\n> entropy as a hex string, etc.. for a given entropy, which will result in\n> different checksum values for the same \"valid\" mnemonic, that might not be\n> \"valid\" in another wallet which may format the data differently before\n> hashing to compute the checksum.\n>\n\nThis probably wouldn't work as a drop-in replacement, but having the\nidentifier of the chosen wordlist be part of the mnemonic might work?\nPerhaps the raw seed would then be [hash of chosen dictionary]+[sequence of\nword indexes].\n\nThe user experience then involves always selecting a dictionary by name. I\nalso suggest maintaining an official list of named dictionaries.\n\nThe purpose of including the dictionary in the seed is so that if you use\nthe last word as a checksum, you also can verify that the dictionary\nselection is correct as well as the word sequence.\n\nThis allows substitution of words to other languages by manually specifying\na different input dictionary, but you would then have to remember both the\nseed language and the translated language so you can specify both\ncorrectly.\n\nThe user experience here matches your option 1, while the implementation\nmatches option 2.\n\nIf you remove specification of the seed's original language, you would need\nauto detection during entry when the raw seed is just the index. I do not\nrecommend trying that, especially if any language would end up with\nmultiple competing dictionaries. Even more so if there's many related\nlanguages which might collide (like all the Latin languages, or even US vs\nUK English...).\n\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181120/f6a48b42/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP- & SLIP-0039 -- better multi-language support",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Neill Miller",
                "Natanael",
                "Steven Hatzakis",
                "SomberNight",
                "Jonathan Underwood"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 28046
        }
    },
    {
        "title": "[bitcoin-dev] bitcoin-dev Digest, Vol 42, Issue 4",
        "thread_messages": [
            {
                "author": "Weiji Guo",
                "date": "2018-11-09T08:20:21",
                "message_text_only": "> Do you specifically want to support changing the language of seed\nwords, while keeping the bip32 root seed they generate unchanged?\nWhat is the usecase for this?\n\nYes and no. Yes that the inter-operability will be much better if the\nsame seed could be recorded as in English and in other languages\nas well. There could be a standalone 3rd party tool to convert\nmnemonic sentences from one language to another so wallets\ndo not have to support all languages. This, in reality, does not make\nany wallet more complicated or increase any dev costs.\n\nNo that I don't think anyone would switch language for fun.\n\nAnd I think the symmetric function in SLIP-0039 is a good\nidea to help with migration the existing wallets. So this will look like:\n\nChinese\nEnglish\nJapanese                      <=> entropy <=> sym. KDF <==> BIP32 seed\n......\nDecimal numbers\n\n>If changing the language of seeds is not a requirement, then look\ninto Electrum seeds. They are language/wordlist agnostic.\n\nSo, changing the language is not a requirement. However, the current BIP-39\nmakes the seed dependent on the language. And I'd like to see it changed.\nThe change will not further complicates the wallets as we can rely on 3rd\nconversion tools to handle different languages.\n\nOne additional benefit multiple language support could bring up is, we can\nwrite down the mnemonic sentence in two or more different languages\nsimultaneously, as a way to do checksum each other.\n\nRegarding Jon's comments:\n>lack of localized words for recovery phrase causes more money loss than\nsupporting it.\n\nThis also worries me.\n\nThink of the situation that one day, crypto currencies are all over the\nworld.\nEveryone has some coins. Among them many just cannot handle English.\nWe must provide a way for them to master their crypto assets. Therefore,\nas Jon had stressed, it is very important to support multiple languages.\nI really don't like it if only English could be used.\n\nAnd then think of those who do not have a native language wordlist. Allowing\nrepresenting the seed in decimal numbers will be helpful.\n\nThanks,\nWeiji\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181109/8f432b2e/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "bitcoin-dev Digest, Vol 42, Issue 4",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Weiji Guo"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2267
        }
    },
    {
        "title": "[bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT",
        "thread_messages": [
            {
                "author": "Pieter Wuille",
                "date": "2018-11-19T22:37:57",
                "message_text_only": "Hello everyone,\n\nFor future segwit versions, I think it would be good add a few things\nto the sighash by default that were overlooked in BIP143:\n* Committing to the absolute transaction fee (in addition to just the\namount being spent in each input) would categorically remove concerns\nabout wallets lying about fees to HW devices or airgapped signers.\n* Committing to the scriptPubKey (in addition to the scriptCode) would\nprevent lying to devices about the type of output being spent, even\nwhen the scriptCode is correct. As a reminder, the scriptCode is the\nactually executed script (which is the redeemscript in non-segwit\nP2SH, and the witnesscript in P2WSH/P2WPKH).\n\nAs this implies additional information that may not be desirable to\ncommit to in all circumstances, it makes sense to make these optional.\nThis obviously interacts with SIGHASH_NOINPUT, which really adds two\ndifferent ways of rebinding signatures to inputs:\n* Changing the prevout (so that the txid doesn't need to be known when\nthe signature is created)\n* Changing the script (so that the exact scriptPubKey/redeemScript/...\ndoesn't need to be known when the signature is created)\n\nOf course, the second implies the first, but do all use cases require\nboth being able to change the prevout and (arbitrarily) changing the\nscriptPubKey? While BIP118 correctly points out this is secure if the\nsame keys are only used in scripts with which binding is to be\npermitted, I feel it would be preferable if signatures/scripts would\nexplicitly state what can change. One way to accomplish this is by\nindicating exactly what in a script is subject to change.\n\nHere is a combined proposal:\n* Three new sighash flags are added: SIGHASH_NOINPUT, SIGHASH_NOFEE,\nand SIGHASH_SCRIPTMASK.\n* A new opcode OP_MASK is added, which acts as a NOP during execution.\n* The sighash is computed like in BIP143, but:\n  * If SIGHASH_SCRIPTMASK is present, for every OP_MASK in scriptCode\nthe subsequent opcode/push is removed.\n  * The scriptPubKey being spent is added to the sighash, unless\nSIGHASH_SCRIPTMASK is set.\n  * The transaction fee is added to the sighash, unless SIGHASH_NOFEE is set.\n  * hashPrevouts, hashSequence, and outpoint are set to null when\nSIGHASH_NOINPUT is set (like BIP118, but not for scriptCode).\n\nSo my question is whether anyone can see ways in which this introduces\nredundant flexibility, or misses obvious use cases?\n\nCheers,\n\n-- \nPieter"
            },
            {
                "author": "Anthony Towns",
                "date": "2018-11-20T20:29:04",
                "message_text_only": "On Mon, Nov 19, 2018 at 02:37:57PM -0800, Pieter Wuille via bitcoin-dev wrote:\n> Here is a combined proposal:\n> * Three new sighash flags are added: SIGHASH_NOINPUT, SIGHASH_NOFEE,\n> and SIGHASH_SCRIPTMASK.\n> * A new opcode OP_MASK is added, which acts as a NOP during execution.\n> * The sighash is computed like in BIP143, but:\n>   * If SIGHASH_SCRIPTMASK is present, for every OP_MASK in scriptCode\n> the subsequent opcode/push is removed.\n>   * The scriptPubKey being spent is added to the sighash, unless\n> SIGHASH_SCRIPTMASK is set.\n>   * The transaction fee is added to the sighash, unless SIGHASH_NOFEE is set.\n>   * hashPrevouts, hashSequence, and outpoint are set to null when\n> SIGHASH_NOINPUT is set (like BIP118, but not for scriptCode).\n\nCurrent flags are {ALL, NONE, SINGLE} and ANYONECANPAY, and the BIP143\ntx digest consists of the hash of:\n\n  1 nVersion\n  4 outpoint\n  5 input scriptCode\n  6 input's outpoint value\n  7 input's nSeq\n  9 nLocktime\n 10 sighash\n\n  2 hashPrevOuts (commits to 4,5,6; unless ANYONECANPAY)\n  3 hashSequence (commits to 7; only if ALL and not ANYONECANPAY)\n  8 hashOutputs\n       - NONE: 0\n       - SINGLE: {value,scriptPubKey} for corresponding output\n       - otherwise: {value,scriptPubKey} for all outputs\n\nThe fee is committed to by hashPrevOuts and hashOutputs, which means\nNOFEE is only potentially useful if ANYONECANPAY or NONE or SINGLE is set.\n\nFor NOINPUT, (2),(3),(4) are cleared, and SCRIPTMASK (which munges (5))\nis only useful given NOINPUT, since (4) indirectly commits to (5). \n\nGiven this implementation, NOINPUT effectively implies ANYONECANPAY,\nI think. (I think that is also true of BIP 118's NOINPUT spec)\n\nDoes it make sense to treat this as two classes of options, affecting\nthe input and output side:\n\n  output: (pick one, using bits 0,1)\n    * NONE -- don't care where the money goes\n    * SINGLE -- want this output\n    * ALL -- want exactly this set of outputs\n\n  input: (pick one, using bits 4,5)\n    * PARTIALSCRIPT -- spending from some tx with roughly this script (and\n                       maybe others; SCRIPTMASK|NOINPUT|ANYONECANPAY)\n    * KNOWNSCRIPT -- spending from some tx with exactly this script (and\n                     maybe others; NOINPUT|ANYONECANPAY)\n    * KNOWNTX -- spending from this tx (and maybe others; ANYONECANPAY)\n    * ALL_INPUTS -- spending from exactly these txes\n\n  combo: (flag, bit 6)\n    * NOFEE -- don't commit to the fee\n\nI think NONE without NOFEE doesn't make much sense, and\nNOFEE|ALL|ALL_INPUTS would also be pretty weird. Might make sense to\nwarn/error on signing when asking for those combinations, and maybe even\nto fail on validating them.\n\n(Does it make sense to keep SIGHASH_NONE? I guess SIGHASH_NONE|ALL_INPUTS\ncould be useful if you just use sigs on one of the other inputs to commit\nto a useful output)\n\nFWIW, OP_MASK seems a bit complicated to me. How would you mask a script\nthat looks like:\n\n   OP_MASK IF <p> ENDIF <q> ...\n\nor:\n\n   IF OP_MASK ENDIF <p> ...\n\nI guess if you make the rule be \"for every OP_MASK in scriptCode the\n*immediately* subsequent opcode/push is removed (if present)\" it would\nbe fine though -- that would make OP_MASK in both the above not have\nany effect. (Maybe a more explicit name like \"MASK_PUSH_FOR_SIGHASH\"\nor something might be good?)\n\nI don't have a reason why, but committing to the scriptCode feels to me\nlike it reduces the \"hackiness\" of NOINPUT a lot.\n\nCheers,\naj"
            },
            {
                "author": "Christian Decker",
                "date": "2018-11-21T11:20:44",
                "message_text_only": "Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nwrites:\n> Given this implementation, NOINPUT effectively implies ANYONECANPAY,\n> I think. (I think that is also true of BIP 118's NOINPUT spec)\n\nI mentioned this in my reply to Pieter, but this may not be true if we\nremove the blanking of the `hashSequence` field. Anyonecanpay would\nallow changing the number of inputs in an arbitrary fashion, while\n`noinput` without the blanking would (in a weird roundabout way) still\ncommit to the number of inputs. Maybe we want to make that more explicit\nby also hashing the number of inputs? But I can't think of a good\nusecase for keeping that, with noinput.\n\nCheers,\nChristian"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-11-21T17:55:22",
                "message_text_only": "If we sign the txids of all inputs, we should also explicitly commit to their values. Only this could fully eliminate any possible way to lie about input value to hardware wallets\n\n> Does it make sense to keep SIGHASH_NONE?\nSIGHASH_NONE should be kept. ANYONECANPAY|NONE allows donation of dust UTXOs to miners\n\n> I think NONE without NOFEE doesn't make much sense\u2026\u2026.\nWe might refuse to sign weird combinations like NOFEE|ALLINPUT|ALLOUTPUT. But to keep the consensus logic simple, we should just validate it as usual.\n\n> OP_MASK seems a bit complicated to me. \u2026...\nYes, it looks complicated to me, and it improves security only in some avoidable edge cases in SIGHASH_NOINPUT:\n\nThe common case: the exact masked script or address is reused. OP_MASK can\u2019t prevent signature replay since the masked script is the same.\n\nThe avoidable case: the same public key is reused in different script templates. OP_MASK may prevent signature replay is the masked script is not the same.\n\nThe latter case is totally avoidable since one could and should use a different public key for different script.\n\nIt could be made much simpler as NOINPUT with/without SCRIPT. This again is only helpful in the avoidable case above, but it doesn\u2019t bring too much complexity.\n\n> I don't have a reason why, but committing to the scriptCode feels to me like it reduces the \"hackiness\" of NOINPUT a lot.\nOP_MASK is designed to preserve the hackiness, while provide some sort of replay protection (only in avoidable cases). However, I\u2019m not sure who would actually need NOINPUT with KNOWNSCRIPT\n\n> On 21 Nov 2018, at 4:29 AM, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> On Mon, Nov 19, 2018 at 02:37:57PM -0800, Pieter Wuille via bitcoin-dev wrote:\n>> Here is a combined proposal:\n>> * Three new sighash flags are added: SIGHASH_NOINPUT, SIGHASH_NOFEE,\n>> and SIGHASH_SCRIPTMASK.\n>> * A new opcode OP_MASK is added, which acts as a NOP during execution.\n>> * The sighash is computed like in BIP143, but:\n>>  * If SIGHASH_SCRIPTMASK is present, for every OP_MASK in scriptCode\n>> the subsequent opcode/push is removed.\n>>  * The scriptPubKey being spent is added to the sighash, unless\n>> SIGHASH_SCRIPTMASK is set.\n>>  * The transaction fee is added to the sighash, unless SIGHASH_NOFEE is set.\n>>  * hashPrevouts, hashSequence, and outpoint are set to null when\n>> SIGHASH_NOINPUT is set (like BIP118, but not for scriptCode).\n> \n> Current flags are {ALL, NONE, SINGLE} and ANYONECANPAY, and the BIP143\n> tx digest consists of the hash of:\n> \n>  1 nVersion\n>  4 outpoint\n>  5 input scriptCode\n>  6 input's outpoint value\n>  7 input's nSeq\n>  9 nLocktime\n> 10 sighash\n> \n>  2 hashPrevOuts (commits to 4,5,6; unless ANYONECANPAY)\n>  3 hashSequence (commits to 7; only if ALL and not ANYONECANPAY)\n>  8 hashOutputs\n>       - NONE: 0\n>       - SINGLE: {value,scriptPubKey} for corresponding output\n>       - otherwise: {value,scriptPubKey} for all outputs\n> \n> The fee is committed to by hashPrevOuts and hashOutputs, which means\n> NOFEE is only potentially useful if ANYONECANPAY or NONE or SINGLE is set.\n> \n> For NOINPUT, (2),(3),(4) are cleared, and SCRIPTMASK (which munges (5))\n> is only useful given NOINPUT, since (4) indirectly commits to (5). \n> \n> Given this implementation, NOINPUT effectively implies ANYONECANPAY,\n> I think. (I think that is also true of BIP 118's NOINPUT spec)\n> \n> Does it make sense to treat this as two classes of options, affecting\n> the input and output side:\n> \n>  output: (pick one, using bits 0,1)\n>    * NONE -- don't care where the money goes\n>    * SINGLE -- want this output\n>    * ALL -- want exactly this set of outputs\n> \n>  input: (pick one, using bits 4,5)\n>    * PARTIALSCRIPT -- spending from some tx with roughly this script (and\n>                       maybe others; SCRIPTMASK|NOINPUT|ANYONECANPAY)\n>    * KNOWNSCRIPT -- spending from some tx with exactly this script (and\n>                     maybe others; NOINPUT|ANYONECANPAY)\n>    * KNOWNTX -- spending from this tx (and maybe others; ANYONECANPAY)\n>    * ALL_INPUTS -- spending from exactly these txes\n> \n>  combo: (flag, bit 6)\n>    * NOFEE -- don't commit to the fee\n> \n> I think NONE without NOFEE doesn't make much sense, and\n> NOFEE|ALL|ALL_INPUTS would also be pretty weird. Might make sense to\n> warn/error on signing when asking for those combinations, and maybe even\n> to fail on validating them.\n> \n> (Does it make sense to keep SIGHASH_NONE? I guess SIGHASH_NONE|ALL_INPUTS\n> could be useful if you just use sigs on one of the other inputs to commit\n> to a useful output)\n> \n> FWIW, OP_MASK seems a bit complicated to me. How would you mask a script\n> that looks like:\n> \n>   OP_MASK IF <p> ENDIF <q> ...\n> \n> or:\n> \n>   IF OP_MASK ENDIF <p> ...\n> \n> I guess if you make the rule be \"for every OP_MASK in scriptCode the\n> *immediately* subsequent opcode/push is removed (if present)\" it would\n> be fine though -- that would make OP_MASK in both the above not have\n> any effect. (Maybe a more explicit name like \"MASK_PUSH_FOR_SIGHASH\"\n> or something might be good?)\n> \n> I don't have a reason why, but committing to the scriptCode feels to me\n> like it reduces the \"hackiness\" of NOINPUT a lot.\n> \n> Cheers,\n> aj\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Christian Decker",
                "date": "2018-11-21T11:15:44",
                "message_text_only": "Hi Pieter,\n\ngreat proposal, I think this may address some of the (perceived)\ndownsides of BIP118, by committing to the script when possible\n(always?). One minor thing that I noticed a while ago and that I meant\nto fix on BIP118 is that `hashSequence` does not need to be blanked for\neltoo to work (since where it is needed we also use `sighash_single`),\nso I'm tempted to remove that redundant blanking. It may not make a lot\nof difference but it'd limit the ability to change the number of inputs\nto a NOINPUT transaction (this now being the only field that commits to\nthe set of inputs).\n\nAs for your proposal, I really like the `sighash_scriptmask` proposal,\nand committing to the fees (with the `nofee` escape hatch) also works\nseems also a nice fix. My one concern is that introducing a new opcode\nto mask things in the sighash looks like a similar layering violation as\n`codeseparator` was, but that's just a minor issue imho.\n\nCheers,\nChristian\n\nPieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nwrites:\n> Hello everyone,\n>\n> For future segwit versions, I think it would be good add a few things\n> to the sighash by default that were overlooked in BIP143:\n> * Committing to the absolute transaction fee (in addition to just the\n> amount being spent in each input) would categorically remove concerns\n> about wallets lying about fees to HW devices or airgapped signers.\n> * Committing to the scriptPubKey (in addition to the scriptCode) would\n> prevent lying to devices about the type of output being spent, even\n> when the scriptCode is correct. As a reminder, the scriptCode is the\n> actually executed script (which is the redeemscript in non-segwit\n> P2SH, and the witnesscript in P2WSH/P2WPKH).\n>\n> As this implies additional information that may not be desirable to\n> commit to in all circumstances, it makes sense to make these optional.\n> This obviously interacts with SIGHASH_NOINPUT, which really adds two\n> different ways of rebinding signatures to inputs:\n> * Changing the prevout (so that the txid doesn't need to be known when\n> the signature is created)\n> * Changing the script (so that the exact scriptPubKey/redeemScript/...\n> doesn't need to be known when the signature is created)\n>\n> Of course, the second implies the first, but do all use cases require\n> both being able to change the prevout and (arbitrarily) changing the\n> scriptPubKey? While BIP118 correctly points out this is secure if the\n> same keys are only used in scripts with which binding is to be\n> permitted, I feel it would be preferable if signatures/scripts would\n> explicitly state what can change. One way to accomplish this is by\n> indicating exactly what in a script is subject to change.\n>\n> Here is a combined proposal:\n> * Three new sighash flags are added: SIGHASH_NOINPUT, SIGHASH_NOFEE,\n> and SIGHASH_SCRIPTMASK.\n> * A new opcode OP_MASK is added, which acts as a NOP during execution.\n> * The sighash is computed like in BIP143, but:\n>   * If SIGHASH_SCRIPTMASK is present, for every OP_MASK in scriptCode\n> the subsequent opcode/push is removed.\n>   * The scriptPubKey being spent is added to the sighash, unless\n> SIGHASH_SCRIPTMASK is set.\n>   * The transaction fee is added to the sighash, unless SIGHASH_NOFEE is set.\n>   * hashPrevouts, hashSequence, and outpoint are set to null when\n> SIGHASH_NOINPUT is set (like BIP118, but not for scriptCode).\n>\n> So my question is whether anyone can see ways in which this introduces\n> redundant flexibility, or misses obvious use cases?\n>\n> Cheers,\n>\n> -- \n> Pieter\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Anthony Towns",
                "date": "2018-11-23T06:04:04",
                "message_text_only": "On Wed, Nov 21, 2018 at 12:15:44PM +0100, Christian Decker via bitcoin-dev wrote:\n> One minor thing that I noticed a while ago and that I meant\n> to fix on BIP118 is that `hashSequence` does not need to be blanked for\n> eltoo to work (since where it is needed we also use `sighash_single`),\n> so I'm tempted to remove that redundant blanking. It may not make a lot\n> of difference but it'd limit the ability to change the number of inputs\n> to a NOINPUT transaction (this now being the only field that commits to\n> the set of inputs).\n\nCommiting to just the sequence numbers seems really weird to me; it\nonly really prevents you from adding inputs, since you could still\nreplace any input that was meant to be there by almost any arbitrary\nother transaction...\n\nI could see this *maybe* making sense if you at least committed to the\nvalues of each input's outpoint; since that would be an actual constraint?\n\nI don't think you can commit to anything else about the other inputs:\n\n   -- txids of the other transactions wouldn't work if you had other\n      NOINPUT txes, and would introduce O(N^2) validation cost if someone\n      signed every input with NOINPUT but committed to the txids of\n      every other input\n\n   -- scriptPubKeys wouldn't really work for eltoo-like constructions\n      that want to vary the scripts but apply the same sig, but might\n      work sometimes?\n\n   -- witness scripts for the other inputs could be unknown at your\n      signing time, or arbitrarily large and thus a pain to have to send\n      to a hardware wallet\n\nJust treating NOINPUT as a subset of ANYONECANPAY seems simpler to\nme though...\n\n> As for your proposal, I really like the `sighash_scriptmask` proposal,\n> and committing to the fees (with the `nofee` escape hatch) also works\n> seems also a nice fix. My one concern is that introducing a new opcode\n> to mask things in the sighash looks like a similar layering violation as\n> `codeseparator` was, but that's just a minor issue imho.\n\nI think OP_MASK is okay as far as layering goes, if you just think of it\nas a (set of) multibyte \"OP_MASKED_PUSH\" opcode(s). So when you\npseudocode a script like:\n\n    <n> OP_CSV OP_DROP <p> OP_CHECKSIG\n\nand then decide <n> needs to be masked, you rewrite it as:\n\n    [n] OP_CSV OP_DROP <p> OP_CHECKSIG\n\nindicating n is masked, and don't worry about the exact bytes that will\nencode the push, anymore than you currently worry about whether it's\nOP_0, OP_1..16, <1..75>+1..75-bytes, PUSHDATA[1,2,3]+n+n-bytes.\n\nAs long as OP_MASK only applies to a PUSH and it's an error for OP_MASK\nnot to be immediately followed by that PUSH, I think that all works\nout fine.\n\nCheers,\naj"
            },
            {
                "author": "Christian Decker",
                "date": "2018-11-23T09:40:20",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> Commiting to just the sequence numbers seems really weird to me; it\n> only really prevents you from adding inputs, since you could still\n> replace any input that was meant to be there by almost any arbitrary\n> other transaction...\n\nIt's a really roundabout way of committing to the inputs, I\nagree. I'm actually wondering if it makes sense to correct that\nadditional blanked field in BIP118 at all since it seems there is no\nreal use-case for NOINPUT that doesn't involve blanking the\n`hashSequence` as well.\n\n> I could see this *maybe* making sense if you at least committed to the\n> values of each input's outpoint; since that would be an actual constraint?\n\nBIP118 still commits to the value of the input being spent, i.e.,\n6. value is not being blanked in the current proposal. This is on\npurpose since we commit to the outputs, not committing to the input\nvalues could end up with unexpected fees.\n\n>> As for your proposal, I really like the `sighash_scriptmask` proposal,\n>> and committing to the fees (with the `nofee` escape hatch) also works\n>> seems also a nice fix. My one concern is that introducing a new opcode\n>> to mask things in the sighash looks like a similar layering violation as\n>> `codeseparator` was, but that's just a minor issue imho.\n>\n> I think OP_MASK is okay as far as layering goes, if you just think of it\n> as a (set of) multibyte \"OP_MASKED_PUSH\" opcode(s). So when you\n> pseudocode a script like:\n>\n>     <n> OP_CSV OP_DROP <p> OP_CHECKSIG\n>\n> and then decide <n> needs to be masked, you rewrite it as:\n>\n>     [n] OP_CSV OP_DROP <p> OP_CHECKSIG\n>\n> indicating n is masked, and don't worry about the exact bytes that will\n> encode the push, anymore than you currently worry about whether it's\n> OP_0, OP_1..16, <1..75>+1..75-bytes, PUSHDATA[1,2,3]+n+n-bytes.\n>\n> As long as OP_MASK only applies to a PUSH and it's an error for OP_MASK\n> not to be immediately followed by that PUSH, I think that all works\n> out fine.\n\nAgreed, that makes more sense :-)"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-11-24T08:13:46",
                "message_text_only": "> On 23 Nov 2018, at 5:40 PM, Christian Decker via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Anthony Towns <aj at erisian.com.au> writes:\n>> Commiting to just the sequence numbers seems really weird to me; it\n>> only really prevents you from adding inputs, since you could still\n>> replace any input that was meant to be there by almost any arbitrary\n>> other transaction...\n> \n> It's a really roundabout way of committing to the inputs, I\n> agree. I'm actually wondering if it makes sense to correct that\n> additional blanked field in BIP118 at all since it seems there is no\n> real use-case for NOINPUT that doesn't involve blanking the\n> `hashSequence` as well.\n\nI think we just make it as simple as this: Always commit to sequence of the same input. Commit to hashSequence if and only if all inputs and all outputs are signed.\n\nThe next-generation SIGHASH will introduce not only NOINPUT, but also signing of fees, previous scriptPubKey, and all input values, etc. So it won\u2019t be a simple hack over BIP143. BIP118 might be better changed to be an informational BIP, focus on the rationale and examples of NOINPUT, and be cross-referenced with the consensus BIP."
            },
            {
                "author": "Russell O'Connor",
                "date": "2018-11-21T17:07:30",
                "message_text_only": "On Mon, Nov 19, 2018 at 10:22 PM Pieter Wuille via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> So my question is whether anyone can see ways in which this introduces\n> redundant flexibility, or misses obvious use cases?\n>\n\nHopefully my comment is on-topic for this thread:\n\nGiven that we want to move away from OP_CODESEPARATOR, because each call to\nthis operation effectively takes O(script-size) time, we need a replacement\nfor the functionality it currently provides.  While perhaps the original\nmotivation for OP_CODESEPARTOR is surrounded in mystery, it currently can\nbe used (or perhaps abused) for the task of creating signature that covers,\nnot only which input is being signed, but which specific branch within that\ninput Script code is being signed for.\n\nFor example, one can place an OP_CODESEPARATOR within each branch of an IF\nblock, or by placing an OP_CODESEPARATOR before each OP_CHECKSIG\noperation.  By doing so, signatures created for one clause cannot be used\nas signatures for another clause.  Since different clauses in Bitcoin\nScript may be enforcing different conditions (such as different time-locks,\nhash-locks, etc), it is useful to be able to sign in such a way that your\nsignature is only valid when the conditions for a particular branch are\nsatisfied.  In complex Scripts, it may not be practical or possible to use\ndifferent public keys for every different clause. (In practice, you will be\nable to get away with fewer OP_CODESEPARATORS than one in every IF block).\n\nOne suggestion I heard (I think I heard it from Pieter) to achieve the\nabove is to add an internal counter that increments on every control flow\noperator, OP_IF, OP_NOTIF, OP_ELSE, OP_ENDIF, and have the signature cover\nthe value of this counter.  Equivalently we divide every Bitcoin Script\nprogram into blocks deliminated by these control flow operator and have the\nsignature cover the index of the block that the OP_CHECKSIG occurs within.\nMore specifically, we will want a SigHash flag to enables/disable the\nsignature covering this counter.\n\nThere are many different ways one might go about replacing the remaining\nuseful behaviour of OP_CODESEPARATOR than the one I gave above. I would be\nhappy with any solution.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181121/785d31a4/attachment-0001.html>"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-11-22T14:28:35",
                "message_text_only": "With MAST in taproot, OP_IF etc become mostly redundant, with worse privacy. To maximise fungibility, we should encourage people to use MAST, instead of improve the functionality of OP_IF and further complicate the protocol.\n\n\n> On 22 Nov 2018, at 1:07 AM, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> On Mon, Nov 19, 2018 at 10:22 PM Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> So my question is whether anyone can see ways in which this introduces\n> redundant flexibility, or misses obvious use cases?\n> \n> Hopefully my comment is on-topic for this thread:\n> \n> Given that we want to move away from OP_CODESEPARATOR, because each call to this operation effectively takes O(script-size) time, we need a replacement for the functionality it currently provides.  While perhaps the original motivation for OP_CODESEPARTOR is surrounded in mystery, it currently can be used (or perhaps abused) for the task of creating signature that covers, not only which input is being signed, but which specific branch within that input Script code is being signed for.\n> \n> For example, one can place an OP_CODESEPARATOR within each branch of an IF block, or by placing an OP_CODESEPARATOR before each OP_CHECKSIG operation.  By doing so, signatures created for one clause cannot be used as signatures for another clause.  Since different clauses in Bitcoin Script may be enforcing different conditions (such as different time-locks, hash-locks, etc), it is useful to be able to sign in such a way that your signature is only valid when the conditions for a particular branch are satisfied.  In complex Scripts, it may not be practical or possible to use different public keys for every different clause. (In practice, you will be able to get away with fewer OP_CODESEPARATORS than one in every IF block).\n> \n> One suggestion I heard (I think I heard it from Pieter) to achieve the above is to add an internal counter that increments on every control flow operator, OP_IF, OP_NOTIF, OP_ELSE, OP_ENDIF, and have the signature cover the value of this counter.  Equivalently we divide every Bitcoin Script program into blocks deliminated by these control flow operator and have the signature cover the index of the block that the OP_CHECKSIG occurs within.  More specifically, we will want a SigHash flag to enables/disable the signature covering this counter.\n> \n> There are many different ways one might go about replacing the remaining useful behaviour of OP_CODESEPARATOR than the one I gave above. I would be happy with any solution.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181122/5414fe4f/attachment-0001.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2018-11-22T16:23:54",
                "message_text_only": "I see, so your suggestion is that a sequence of OP_IF ... OP_ENDIF can be\nreplaced by a Merklized Script tree of that depth in practice.\n\nI'm concerned that at script creation time it takes exponential time to\ncomplete a Merkle root of depth 'n'.  Can anyone provide benchmarks or\nestimates of how long it takes to compute a Merkle root of a full tree of\nvarious depths on typical consumer hardware?  I would guess things stop\nbecoming practical at a depth of 20-30.\n\nOn Thu, Nov 22, 2018 at 9:28 AM Johnson Lau <jl2012 at xbt.hk> wrote:\n\n> With MAST in taproot, OP_IF etc become mostly redundant, with worse\n> privacy. To maximise fungibility, we should encourage people to use MAST,\n> instead of improve the functionality of OP_IF and further complicate the\n> protocol.\n>\n>\n> On 22 Nov 2018, at 1:07 AM, Russell O'Connor via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> On Mon, Nov 19, 2018 at 10:22 PM Pieter Wuille via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> So my question is whether anyone can see ways in which this introduces\n>> redundant flexibility, or misses obvious use cases?\n>>\n>\n> Hopefully my comment is on-topic for this thread:\n>\n> Given that we want to move away from OP_CODESEPARATOR, because each call\n> to this operation effectively takes O(script-size) time, we need a\n> replacement for the functionality it currently provides.  While perhaps the\n> original motivation for OP_CODESEPARTOR is surrounded in mystery, it\n> currently can be used (or perhaps abused) for the task of creating\n> signature that covers, not only which input is being signed, but which\n> specific branch within that input Script code is being signed for.\n>\n> For example, one can place an OP_CODESEPARATOR within each branch of an IF\n> block, or by placing an OP_CODESEPARATOR before each OP_CHECKSIG\n> operation.  By doing so, signatures created for one clause cannot be used\n> as signatures for another clause.  Since different clauses in Bitcoin\n> Script may be enforcing different conditions (such as different time-locks,\n> hash-locks, etc), it is useful to be able to sign in such a way that your\n> signature is only valid when the conditions for a particular branch are\n> satisfied.  In complex Scripts, it may not be practical or possible to use\n> different public keys for every different clause. (In practice, you will be\n> able to get away with fewer OP_CODESEPARATORS than one in every IF block).\n>\n> One suggestion I heard (I think I heard it from Pieter) to achieve the\n> above is to add an internal counter that increments on every control flow\n> operator, OP_IF, OP_NOTIF, OP_ELSE, OP_ENDIF, and have the signature cover\n> the value of this counter.  Equivalently we divide every Bitcoin Script\n> program into blocks deliminated by these control flow operator and have the\n> signature cover the index of the block that the OP_CHECKSIG occurs within.\n> More specifically, we will want a SigHash flag to enables/disable the\n> signature covering this counter.\n>\n> There are many different ways one might go about replacing the remaining\n> useful behaviour of OP_CODESEPARATOR than the one I gave above. I would be\n> happy with any solution.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181122/e50caccd/attachment-0001.html>"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-11-22T20:52:54",
                "message_text_only": "Assuming a script size of 128 bytes (including SHA256 padding), 2^20 scripts is 134MB. Double it to 268MB for the merkle branch hashes. With roughly 100MB/s, this should take 2.5s (or 42min for 30 levels). However, memory use is not considered.\n\n>each call to this operation effectively takes O(script-size) time\nI\u2019m not sure if this is correct. Actually, CTransactionSignatureSerializer() scans every script for OP_CODESEPARATOR. Scripts with and without OP_CODESEPARATOR should take exactly the same O(script-size) time (see https://github.com/bitcoin/bitcoin/pull/14786)\nAlso, this is no longer a concern under segwit (BIP143), which CTransactionSignatureSerializer() is not used. Actually, OP_CODESEPARATOR under segwit is way simpler than the proposed OP_MASK. If one finds OP_MASK acceptable, there should be no reason to reject OP_CODESEPARATOR.\n\n>One suggestion I heard (I think I heard it from Pieter) to achieve the above is to add an internal counter that increments on every control flow operator,\u2026\u2026...\nIf I have to choose among OP_CODESEPARATOR and \u201cflow operator counting\u201d, I\u2019d rather choose OP_CODESEPARATOR. At least we don\u2019t need to add more lines to the consensus code, just for something that is mostly archivable with MAST.\n\n\n> On 23 Nov 2018, at 12:23 AM, Russell O'Connor <roconnor at blockstream.io> wrote:\n> \n> I see, so your suggestion is that a sequence of OP_IF ... OP_ENDIF can be replaced by a Merklized Script tree of that depth in practice.\n> \n> I'm concerned that at script creation time it takes exponential time to complete a Merkle root of depth 'n'.  Can anyone provide benchmarks or estimates of how long it takes to compute a Merkle root of a full tree of various depths on typical consumer hardware?  I would guess things stop becoming practical at a depth of 20-30.\n> \n> On Thu, Nov 22, 2018 at 9:28 AM Johnson Lau <jl2012 at xbt.hk> wrote:\n> With MAST in taproot, OP_IF etc become mostly redundant, with worse privacy. To maximise fungibility, we should encourage people to use MAST, instead of improve the functionality of OP_IF and further complicate the protocol.\n> \n> \n>> On 22 Nov 2018, at 1:07 AM, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> \n>> On Mon, Nov 19, 2018 at 10:22 PM Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> So my question is whether anyone can see ways in which this introduces\n>> redundant flexibility, or misses obvious use cases?\n>> \n>> Hopefully my comment is on-topic for this thread:\n>> \n>> Given that we want to move away from OP_CODESEPARATOR, because each call to this operation effectively takes O(script-size) time, we need a replacement for the functionality it currently provides.  While perhaps the original motivation for OP_CODESEPARTOR is surrounded in mystery, it currently can be used (or perhaps abused) for the task of creating signature that covers, not only which input is being signed, but which specific branch within that input Script code is being signed for.\n>> \n>> For example, one can place an OP_CODESEPARATOR within each branch of an IF block, or by placing an OP_CODESEPARATOR before each OP_CHECKSIG operation.  By doing so, signatures created for one clause cannot be used as signatures for another clause.  Since different clauses in Bitcoin Script may be enforcing different conditions (such as different time-locks, hash-locks, etc), it is useful to be able to sign in such a way that your signature is only valid when the conditions for a particular branch are satisfied.  In complex Scripts, it may not be practical or possible to use different public keys for every different clause. (In practice, you will be able to get away with fewer OP_CODESEPARATORS than one in every IF block).\n>> \n>> One suggestion I heard (I think I heard it from Pieter) to achieve the above is to add an internal counter that increments on every control flow operator, OP_IF, OP_NOTIF, OP_ELSE, OP_ENDIF, and have the signature cover the value of this counter.  Equivalently we divide every Bitcoin Script program into blocks deliminated by these control flow operator and have the signature cover the index of the block that the OP_CHECKSIG occurs within.  More specifically, we will want a SigHash flag to enables/disable the signature covering this counter.\n>> \n>> There are many different ways one might go about replacing the remaining useful behaviour of OP_CODESEPARATOR than the one I gave above. I would be happy with any solution.\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2018-11-22T22:10:11",
                "message_text_only": "On Thu, Nov 22, 2018 at 3:53 PM Johnson Lau <jl2012 at xbt.hk> wrote:\n\n> Assuming a script size of 128 bytes (including SHA256 padding), 2^20\n> scripts is 134MB. Double it to 268MB for the merkle branch hashes. With\n> roughly 100MB/s, this should take 2.5s (or 42min for 30 levels). However,\n> memory use is not considered.\n>\n> >each call to this operation effectively takes O(script-size) time\n> I\u2019m not sure if this is correct. Actually,\n> CTransactionSignatureSerializer() scans every script for OP_CODESEPARATOR.\n> Scripts with and without OP_CODESEPARATOR should take exactly the same\n> O(script-size) time (see https://github.com/bitcoin/bitcoin/pull/14786)\n> Also, this is no longer a concern under segwit (BIP143), which\n> CTransactionSignatureSerializer() is not used. Actually, OP_CODESEPARATOR\n> under segwit is way simpler than the proposed OP_MASK. If one finds OP_MASK\n> acceptable, there should be no reason to reject OP_CODESEPARATOR.\n>\n\nEven still, each call to OP_CODESEPARATOR / OP_CHECKSIG pair requires\nrecomputing a new #5. scriptCode from BIP 143, and hence computes a new\ntransaction digest.  I understood that this issue was the main motivation\nfor wanting to deprecate OP_CODESEPARATOR and remove it from later versions\nof script.\n\nHowever, given that we are looking at a combinatorial explosion in SIGHASH\nflag combinations already, coupled with existing SigOp limitations, maybe\nthe cost of recomputing scriptCode with OP_CODESEPARATOR isn't such a big\ndeal.\n\nAnd even if we choose remove the behavior of OP_CODESEPARATOR in new\nversions of Script, it seems more than 30 layers of sequential OP_IFs can\nbe MASTified, so there is no need to use OP_CODESEPARATOR within that limit.\n\n>One suggestion I heard (I think I heard it from Pieter) to achieve the\nabove is to add an internal counter that increments on every control flow\noperator,\u2026\u2026...\n\n> If I have to choose among OP_CODESEPARATOR and \u201cflow operator counting\u201d,\n> I\u2019d rather choose OP_CODESEPARATOR. At least we don\u2019t need to add more\n> lines to the consensus code, just for something that is mostly archivable\n> with MAST.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181122/e7761aed/attachment.html>"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-11-23T10:47:10",
                "message_text_only": ">Even still, each call to OP_CODESEPARATOR / OP_CHECKSIG pair requires recomputing a new #5. scriptCode from BIP 143, and hence computes a new transaction digest.\n\nIn the existing sighash (i.e. legacy and BIP143), there are 6 canonical SIGHASH types: 1, 2, 3, 0x81, 0x82, 0x83. In consensus, however, all 256 types are valid and distinct. An adversarial miner could use non-standard sighash types to nullify any attempt to cache sighash values (i.e. you have to compute a new tx digest for every OP_CHECKSIG, even without using OP_CODESEPARATOR).\n\nThe only way to prevent this is reject OP_CODESEPARATOR, FindAndDelete(), and non-standard SIGHASH with a softfork. However, this doesn\u2019t work in the next-generation SIGHASH, as tens of standard sighash types will exist. And, more importantly, sighash cache is no longer necessary in segwit, with the legacy O(n^2) hash bug being fixed.\n\nIn summary, sighash cache is not necessary nor efficient in the next-generation SIGHASH, and is not a sufficient reason to remove OP_CODESEPARATOR, especially when people find OP_CODESEPARATOR useful in some way.\n\nBut just to be clear, I think OP_CODESEPARATOR should be deprecated in legacy scripts. There is a general negative sentiment against OP_CODESEPARATOR but I think we need to evaluate case by case.\n\n> On 23 Nov 2018, at 6:10 AM, Russell O'Connor <roconnor at blockstream.io> wrote:\n> \n> \n> \n> On Thu, Nov 22, 2018 at 3:53 PM Johnson Lau <jl2012 at xbt.hk <mailto:jl2012 at xbt.hk>> wrote:\n> Assuming a script size of 128 bytes (including SHA256 padding), 2^20 scripts is 134MB. Double it to 268MB for the merkle branch hashes. With roughly 100MB/s, this should take 2.5s (or 42min for 30 levels). However, memory use is not considered.\n> \n> >each call to this operation effectively takes O(script-size) time\n> I\u2019m not sure if this is correct. Actually, CTransactionSignatureSerializer() scans every script for OP_CODESEPARATOR. Scripts with and without OP_CODESEPARATOR should take exactly the same O(script-size) time (see https://github.com/bitcoin/bitcoin/pull/14786 <https://github.com/bitcoin/bitcoin/pull/14786>)\n> Also, this is no longer a concern under segwit (BIP143), which CTransactionSignatureSerializer() is not used. Actually, OP_CODESEPARATOR under segwit is way simpler than the proposed OP_MASK. If one finds OP_MASK acceptable, there should be no reason to reject OP_CODESEPARATOR.\n> \n> Even still, each call to OP_CODESEPARATOR / OP_CHECKSIG pair requires recomputing a new #5. scriptCode from BIP 143, and hence computes a new transaction digest.  I understood that this issue was the main motivation for wanting to deprecate OP_CODESEPARATOR and remove it from later versions of script.\n> \n> However, given that we are looking at a combinatorial explosion in SIGHASH flag combinations already, coupled with existing SigOp limitations, maybe the cost of recomputing scriptCode with OP_CODESEPARATOR isn't such a big deal.\n> \n> And even if we choose remove the behavior of OP_CODESEPARATOR in new versions of Script, it seems more than 30 layers of sequential OP_IFs can be MASTified, so there is no need to use OP_CODESEPARATOR within that limit.\n> \n> >One suggestion I heard (I think I heard it from Pieter) to achieve the above is to add an internal counter that increments on every control flow operator,\u2026\u2026...\n> If I have to choose among OP_CODESEPARATOR and \u201cflow operator counting\u201d, I\u2019d rather choose OP_CODESEPARATOR. At least we don\u2019t need to add more lines to the consensus code, just for something that is mostly archivable with MAST.\n> \n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181123/0c20c6f7/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2018-11-23T05:03:30",
                "message_text_only": "On Wed, Nov 21, 2018 at 12:07:30PM -0500, Russell O'Connor via bitcoin-dev wrote:\n> Given that we want to move away from OP_CODESEPARATOR, because each call to\n> this operation effectively takes O(script-size) time, we need a replacement for\n> the functionality it currently provides.\u00a0 While perhaps the original motivation\n> for OP_CODESEPARTOR is surrounded in mystery, it currently can be used (or\n> perhaps abused) for the task of creating signature that covers, not only which\n> input is being signed, but which specific branch within that input Script code\n> is being signed for.\n\nWould it be sufficient to sign the position within the script of the\nlast OP_CODESEPARATOR? That is, if your script is:\n\n   DUP DUP CHECKSIG CODESEP CHECKSIG CODESEP CHECKSIG\n\nwith the idea being that it can be spent by providing any pub key and\nthree different signatures by that key, with the first sig committing\nto a \"codesep position\" of 0, the second a \"codesep position\" of 4,\nand the third a \"codesep position\" of 6? In each case, the signature\nalso commits to the full (possibly masked) script as well.\n\nI think that covers all the behaviour you can currently achieve with\nCODESEP (which is pretty limited since every sig effectively commits\nto the full redeem script, and you can't commit to subsets of the\nsignature/witness), and it keeps the things you can do with the various\nfeatures a bit orthogonal:\n\n NOINPUT -- lets the sig apply to different transactions\n OP_MASK -- lets the different txes have variations in the script the\n            sig applies to\n CODESEP -- lets you require different sigs for different parts of a\n            single script\n MAST[0] -- provides alternative scripts, doesn't affect sigs\n IF/etc  -- provides control flow within a script, doesn't affect sigs\n\nCheers,\naj\n\n[0] (I think I'm going to claim \"MAST\" stands for \"merkelized alternative\n     script tree\" these days, since they're not \"abstract syntax trees\")"
            },
            {
                "author": "Russell O'Connor",
                "date": "2018-11-23T20:18:13",
                "message_text_only": "On Fri, Nov 23, 2018 at 12:03 AM Anthony Towns <aj at erisian.com.au> wrote:\n\n> On Wed, Nov 21, 2018 at 12:07:30PM -0500, Russell O'Connor via bitcoin-dev\n> wrote:\n> > Given that we want to move away from OP_CODESEPARATOR, because each call\n> to\n> > this operation effectively takes O(script-size) time, we need a\n> replacement for\n> > the functionality it currently provides.  While perhaps the original\n> motivation\n> > for OP_CODESEPARTOR is surrounded in mystery, it currently can be used\n> (or\n> > perhaps abused) for the task of creating signature that covers, not only\n> which\n> > input is being signed, but which specific branch within that input\n> Script code\n> > is being signed for.\n>\n> Would it be sufficient to sign the position within the script of the\n> last OP_CODESEPARATOR? That is, if your script is:\n>\n> I think that covers all the behaviour you can currently achieve with\n> CODESEP (which is pretty limited since every sig effectively commits\n> to the full redeem script, and you can't commit to subsets of the\n> signature/witness), and it keeps the things you can do with the various\n> features a bit orthogonal:\n>\n\nThanks for bringing this up.  I was thinking the same thing as well, that\nyes that should be sufficient to cover the semantics of OP_CODESEPARATOR.\nThough to be more precise you would sign the position of the last\n_executed_ OP_CODESEPARATOR.\n\nThat said, while I agree the above is a superior realization of the\nOP_CODESEPARATOR, given that we are probably going to support\nOP_CODESEPARATOR inside legacy P2SH scripts indefinitely, it is probably\nbetter to keep the existing akward implementation of OP_CODESEPARATOR in\nfuture versions of Script.  (At least until we decide to stop mangling the\nScript consensus code with more and more flag combinations and decide it is\nbetter to cut and paste code for new versions of Script to help ensure we\ndon't make consensus changes to legacy behaviour).\n\n\n> [0] (I think I'm going to claim \"MAST\" stands for \"merkelized alternative\n>      script tree\" these days, since they're not \"abstract syntax trees\")\n>\n\n:thumbs-up:\n\nSorry for hijacking the thread about OP_MASK and friends.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181123/d6f9489a/attachment-0001.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2018-11-28T03:41:02",
                "message_text_only": "On Mon, 19 Nov 2018 at 14:37, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n> Here is a combined proposal:\n> * Three new sighash flags are added: SIGHASH_NOINPUT, SIGHASH_NOFEE, and SIGHASH_SCRIPTMASK.\n> * A new opcode OP_MASK is added, which acts as a NOP during execution.\n> * The sighash is computed like in BIP143, but:\n>   * If SIGHASH_SCRIPTMASK is present, for every OP_MASK in scriptCode the subsequent opcode/push is removed.\n>   * The scriptPubKey being spent is added to the sighash, unless SIGHASH_SCRIPTMASK is set.\n>   * The transaction fee is added to the sighash, unless SIGHASH_NOFEE is set.\n>   * hashPrevouts, hashSequence, and outpoint are set to null when SIGHASH_NOINPUT is set (like BIP118, but not for scriptCode).\n\nThanks for all the input so far. Going over the suggestions and other ideas:\n\n* OP_MASK should be required to be followed by a push, as suggested by\nAnthony Towns. The alternative would permit substituting arbitrary\nopcodes for masked pushes, which is at least very hard to reason\nabout. This would effectively turn it into a multi-byte OP_MASKEDPUSH\nopcode.\n\n* It's probably better to sign the amounts of all inputs, as suggested\nby Johnson Lau. As that would cause default sighashes to sign all\ninput and output amounts, is there still a need to sign the tx fee\nexplicitly? Or in other words, are there situations where changing the\nset of inputs or outputs after signing is desired, but the net\ndifference between them cannot change? If not, that would remove the\nneed for NOFEE.\n\n* Do we need to keep the rule that sequence values of other inputs are\nonly signed with default sighash? It feels cleaner to always sign the\nsequence values of all inputs that are included in the sighash anyway\n(so all of them, unless ANYONECANPAY or NOINPUT, which would make it\nsign only the current input's sequence value). If NOINPUT also blanks\nthe sequence values (as currently specified by BIP118), and all input\namounts are signed, that would make amounts/sequence values always be\ntreated identically.\n\n* If MASK implies NOINPUT, and NOINPUT implies ANYONECANPAY, the 3 of\nthem can be encoded in just 2 bits using the\nPARTIALSCRIPT/KNOWNSCRIPT/KNOWNTX/ALL_INPUTS encoding Anthony Towns\nsuggested.\n\n* Regarding the discussion about preventing signatures from being\nrebound to a different script(path)/checksig:\n  * With MAST there is indeed less need for this, but at least\nsingle-tree MAST constructions cannot replace all script branches (a\nscript with 40 IF/THEN/ELSE constructions may have 2^40 different\nexecution paths, for which computing a Merkle tree is intractable).\n  * Just signing the opcode position of the CHECKSIG operator isn't\nenough for all cases either. For example, you could have a complex\nnested set of branches that puts a number of pubkeys on the stack, and\nthen a CHECKMULTISIG after the last ENDIF to verify all of them. In\nsuch a situation, if the same key can occur in multiple combinations,\nyou still may want to prevent a signature generated for one\ncombination from being rebindable to the same key in another\ncombination. I believe that signing the opcode position plus the\ntrue/false condition of all previous(?) IF statements is probably\nsufficient to achieve that, but it would also introduce unnecessary\ncomplexity for signers in most cases (see next point).\n  * Thinking about signing code, adding these sort of execution trace\ncommitments to the sighash means they need to know which checksig\noperator etc. they are signing for. I believe that in practice for\nexample HW devices will just whatever position the wallet indicated,\nrather than verifying it corresponds with a particular intended code\npath. Preventing rebinding isn't very useful if an attacker can make\nyou bind to the wrong thing regardless, so I'm not convinced this is\neven worth having by default.\n  * An alternative (not sure who suggested it) is to simply make every\nCHECKSIG sign the opcode position of the last executed CODESEPARATOR\n(and remove the earlier cut-of-scriptCode effect of CODESEPARATOR).\nThis gives a simple (but somewhat limited) way for scripts that need\nto prevent certain kinds of cross-execution-trace rebinding.\n\nA few misc ideas:\n* (Taken from https://github.com/jl2012/bips/blob/sighash2/bip-sighash2.mediawiki)\nFor a default sign-everything sighash, the sighash byte can be\ndropped.\n* For the commitments to the scriptPubKey and scriptCode, an\nintermediary hash should be used (so the data included in the sighash\nincludes a hash of those, rather than the script directly). This\nprevents a blow up in hashing time for large scripts with many\ndifferent sighash types in its signatures.\n* When masking the scriptCode, the push opcode immediately following\nOP_MASKEDPUSH can be replaced by OP_VERIF (which will never collide\nwith any real script, as OP_VERIF makes a script invalid even when\noccurring in an unexecuted branch).\n* Sighashes (and really all new hashes that are introduced) should be\nprefixed with a fixed 64-byte array as \"tag\", chosen to not collide\nwith any existing use of SHA256 in Bitcoin, to prevent signatures from\nbeing re-interpretable as something else. Picking 64 bytes as tag size\nmeans it can be efficiently implemented as just a modified SHA256 IV.\n\nSo a combined proposal:\n* All existing sighash flags, plus NOINPUT and MASK\n(ANYONECANPAY/NOINPUT/MASK are encoded in 2 bits).\n* A new opcode called OP_MASKEDPUSH, whose only runtime behaviour is\nfailing if not immediately followed by a push, or when appearing as\nlast opcode in the script.\n* Signatures are 64 plus an optional sighash byte. A missing sighash\nbyte implies ALL, and ALL cannot be specified explicitly.\n* The sighash is computed from the following:\n  * A 64-byte constant tag\n  * Data about the spending transaction:\n    * The transaction version number\n    * The hash of txins' prevouts+amounts+sequences (or nothing if ANYONECANPAY)\n    * The hash of all txouts (or just the corresponding txout if\nSINGLE; nothing if NONE)\n    * The transaction locktime\n  * Data about the output being spent:\n    * The prevout (or nothing if NOINPUT)\n    * The amount\n    * The sequence number\n    * The hash of the scriptPubKey (or nothing if MASK)\n  * Data about the script being executed:\n    * The hash of the scriptCode (after masking out, if MASK is set)\n    * The opcode number of the last executed OP_CODESEPARATOR (or\n0xFFFFFFFF if none)\n  * The sighash mode\n\nCheers,\n\n-- \nPieter"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-11-28T08:31:48",
                "message_text_only": "> On 28 Nov 2018, at 11:41 AM, Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> So a combined proposal:\n> * All existing sighash flags, plus NOINPUT and MASK\n> (ANYONECANPAY/NOINPUT/MASK are encoded in 2 bits).\n> * A new opcode called OP_MASKEDPUSH, whose only runtime behaviour is\n> failing if not immediately followed by a push, or when appearing as\n> last opcode in the script.\n\nI suggest to use the place of OP_RESERVED (0x50) as OP_MASKEDPUSH. The reason is 0x50 is not counted towards the 201 opcode limit, so people could mask as many pushes as needed.\n\nIn a new script version, of course, we could make any opcode not being counted. But that would just create another special case in the EvalScript() code.\n\n(Or, maybe we should limit the use of OP_MASKEDPUSH? I think this is open for discussion.)\n\n> * Signatures are 64 plus an optional sighash byte. A missing sighash\n> byte implies ALL, and ALL cannot be specified explicitly.\n> * The sighash is computed from the following:\n>  * A 64-byte constant tag\n>  * Data about the spending transaction:\n>    * The transaction version number\n>    * The hash of txins' prevouts+amounts+sequences (or nothing if ANYONECANPAY)\n\nDo you want to make it 1 hash or 3 hashes? With 3 hashes, it could share hashPrevouts and hashSequence with BIP143. Making everything 1 hash will only result in redundent hashing for each input\n\n>    * The hash of all txouts (or just the corresponding txout if\n> SINGLE; nothing if NONE)\n\nStarting from this sighash version, I think we should forbid the use of SINGLE without a matching output. Also, the undefined output type should also be invalid.\n\n>    * The transaction locktime\n>  * Data about the output being spent:\n>    * The prevout (or nothing if NOINPUT)\n>    * The amount\n>    * The sequence number\n>    * The hash of the scriptPubKey (or nothing if MASK)\n\nI think we should just use the scriptPubKey, since sPK is fixed size (23-byte for p2sh and 35-byte for native segwit).\n\nIn order to distinguish p2sh and native segwit for MASKED NOINPUT, you also need to commit to an additional 1-bit value\n\n>  * Data about the script being executed:\n>    * The hash of the scriptCode (after masking out, if MASK is set)\n\nFor direct key-spending (i.e. not taprooted script), I suggest to set the H(scriptCode) to zero, for the following reasons:\n1) Since we have already committed to sPK, which is already a *direct* hash of scriptCode, it is redundant to do it again.\n2) This could save one SHA256 compression for direct key-spending, which is probably 90% of all cases\n3) This allows hardware wallet to tell whether they are using direct-spending path or taproot script path\n\nSince we may want 3) anyway, we don\u2019t need to commit to another 1-bit value if we simply set H(scriptCode) to zero\n\nWe should also ban MASKED NOINPUT for direct-spending, which doesn\u2019t make sense. And it is not safe since both H(scriptCode) and sPK are empty.\n\n>    * The opcode number of the last executed OP_CODESEPARATOR (or\n> 0xFFFFFFFF if none)\n>  * The sighash mode\n\nThis proposal will only use 4 out of the 8 sighash bits. Do we want to make those 4 unused bits invalid, or ignored? Leaving at least 1 bit valid but ignored (\u201cbit-x\"), and 1 bit invalid (\u201cbit-y\u201d), will allow opt-in/out hardfork replay-protection, for example:\n\n* default signatures are those with both bit-x and bit-y unset.\n* If we want to make default signatures replayable across chains, the new fork should reject signatures with bit-x, and accept sigs with or without bit-y. In this case, defaults sigs are valid for both chains. Sigs with bit-x is valid only for original chain, and sigs with bit-y is valid only for new chain.\n* If we want to make default signatures non-replayabble, the new fork should reject all default sigs, but accept sigs with either bit-x or bit-y set. In this case, default sig is valid only for original chain. Sigs with bit-x is valid for both chains, and sigs with bit-y is valid only for new chain.\n\nReplayability is sometimes desirable, for example, an LN opened before a fork should be able to be settled on both chains\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181128/40369e53/attachment-0001.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2018-11-29T17:00:09",
                "message_text_only": "Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nwrites:\n\n> On Mon, 19 Nov 2018 at 14:37, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n> * It's probably better to sign the amounts of all inputs, as suggested\n> by Johnson Lau. As that would cause default sighashes to sign all\n> input and output amounts, is there still a need to sign the tx fee\n> explicitly? Or in other words, are there situations where changing the\n> set of inputs or outputs after signing is desired, but the net\n> difference between them cannot change? If not, that would remove the\n> need for NOFEE.\n\nSo the final proposal would be to append a new `hashValues` field to the\nhashed representation, with `hashValues` just being the double SHA256 of\nall values? In that case SINGLE needs to blank that hash, otherwise we'd\nbe committing to all inputs again.\n\nOnce we have that detail, we can start thinking about what it means to\ncommit to the fee vs. committing to the values. Since the fee is given\nby the output values and the input values we only need to consider the\ncases in which they can be modified.\n\n - NOINPUT (as in BIP118) commits to the value (and I can't think of a\n   usecase where we'd want to change that), and that transparently\n   extends to all other inputs.\n - For ANYONECANPAY can't really commit to a fee anyway so ANYONECANPAY\n   would likely imply NOFEE.\n - With NONE all bets are off anyway, so no need to consider that :-)\n - SINGLE is a bit special, and for value commitments it reduces to the\n   current commitment to its own value, for fee commitment it's hard to\n   see a use of that commitment at all afaik (I think the combination\n   SINGLE|NOFEE would always be used).\n\n> * Do we need to keep the rule that sequence values of other inputs are\n> only signed with default sighash? It feels cleaner to always sign the\n> sequence values of all inputs that are included in the sighash anyway\n> (so all of them, unless ANYONECANPAY or NOINPUT, which would make it\n> sign only the current input's sequence value). If NOINPUT also blanks\n> the sequence values (as currently specified by BIP118), and all input\n> amounts are signed, that would make amounts/sequence values always be\n> treated identically.\n\nSingle cannot commit to other the sequence of other inputs, otherwise\nwe're breaking SINGLE completely. As mentioned before NOINPUT doesn't\nneed to blank `hashSequence`, but I'm happy to make it match if that\nmakes implementations handle fewer cases.\n\n> * If MASK implies NOINPUT, and NOINPUT implies ANYONECANPAY, the 3 of\n> them can be encoded in just 2 bits using the\n> PARTIALSCRIPT/KNOWNSCRIPT/KNOWNTX/ALL_INPUTS encoding Anthony Towns\n> suggested.\n\nSo we'd end up enumerating the combinations rather than having\nindependent bits for each of them? This might save us storage bits, but\nit'd also result in uglier code imho, not a strong feeling but might\ncome back to haunt us if we ever come up with something new :-)\n\n> So a combined proposal:\n> * All existing sighash flags, plus NOINPUT and MASK\n> (ANYONECANPAY/NOINPUT/MASK are encoded in 2 bits).\n> * A new opcode called OP_MASKEDPUSH, whose only runtime behaviour is\n> failing if not immediately followed by a push, or when appearing as\n> last opcode in the script.\n> * Signatures are 64 plus an optional sighash byte. A missing sighash\n> byte implies ALL, and ALL cannot be specified explicitly.\n> * The sighash is computed from the following:\n>   * A 64-byte constant tag\n>   * Data about the spending transaction:\n>     * The transaction version number\n>     * The hash of txins' prevouts+amounts+sequences (or nothing if ANYONECANPAY)\n\nThis needs to be partially blanked for SINGLE as well, otherwise we\nbreak SINGLE.\n\n>     * The hash of all txouts (or just the corresponding txout if\n> SINGLE; nothing if NONE)\n>     * The transaction locktime\n>   * Data about the output being spent:\n>     * The prevout (or nothing if NOINPUT)\n>     * The amount\n>     * The sequence number\n\nI assume the sequence number here refers to the input being signed, not\nthe sequence number of the transaction output being spent :-) Might be\neasier if we consider 3 parts: the spending transaction, the input being\nsigned, and the output (or TX) being spent.\n\nCheers,\nChristian"
            },
            {
                "author": "Christian Decker",
                "date": "2018-11-29T18:29:10",
                "message_text_only": "I'd like to retract my comments regarding SINGLE.\n\nI was contacted in private and it was pointed out to me that I was\nconfusing `sighash_single` with `sighash_single|sighash_anyonecanpay`. I\nappreciate the correction and would like to avoid creating confusion\nwith my previous comments, hence the retraction :-)\n\nCheers,\nChristian"
            },
            {
                "author": "Bob McElrath",
                "date": "2018-11-28T00:54:16",
                "message_text_only": "I have been working on an experimental wallet that implements Bitcoin\nCovenants/Vaults following a blog post I wrote about 2 years ago, using\n\"Pay-to-Timelock Signed Transaction\" (P2TST).  (Also mentioned recently by\nkanzure in a talk somewheres...)  The idea is that you deposit to an address for\nwhich you don't know the private key.  Instead you construct a second\ntransaction sending that to a timelocked staging address for which you DO have\nthe privkey (it also has an IF/ELSE condition with a second spending condition\nfor use in case of theft attempt).  In order to do this you either have to\ndelete the privkey of the deposit address (a difficult proposition to know it's\nactually been deleted), but instead one can construct a signature directly using\na RNG, and use the SIGHASH to compute the corresponding pubkey via ECDSA\nrecover, from which you compute the corresponding address.  In this way your\nwallet is a set of P2TST transactions and a corresponding privkey, with a (set\nof) emergency keys.\n\nThis interacts with NOINPUT in the following way: if the input to the\ntransaction commits to the pubkey in any way, you have a circular dependency on\nthe pubkey that could only be satisfied by breaking a hash function.  This\noccurs with standard sighash's which commit to the txid, which in turn commit to\nthe address, which commits to the pubkey, so this construction of\ncovenants/vaults requires NOINPUT.\n\nAFAICT sipa's proposal is compatible with the above vaulted construction by\nusing SIGHASH_NOINPUT | SIGHASH_SCRIPTMASK to remove the\nscriptPubKey/redeemScript from the sighash.  Putting the\nscriptPubKey/redeemScript in the sighash introduces the same circular\ndependency, but SIGHASH_SCRIPTMASK removes it.\n\nOne would probably want to provide the fee from a separate wallet so as to be\nable to account for fluctuating fee pressures when the unvaulting occurs a long\ntime after vaulting.  Thus you'd want to use SIGHASH_SINGLE so that a fee-wallet\ncan add fees (or for composability of P2TSTs), and SIGHASH_NOFEE as well.\n\nP.S. Also very excited to combine the above idea with Taproot/Graftroot/g'Root.\n\n--\nCheers, Bob McElrath\n\n\"For every complex problem, there is a solution that is simple, neat, and wrong.\"\n    -- H. L. Mencken"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-11-28T08:40:34",
                "message_text_only": "This is incompatible with bip-schnorr, which intentionally disallow such use by always committing to the public key: https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki\n\nWith the recent fake Satoshi signature drama, and other potential ways to misuse and abuse, I think this is a better way to go, which unfortunately might disallow some legitimate applications.\n\nCovenants could be made using OP_CHECKSIGFROMSTACK (https://fc17.ifca.ai/bitcoin/papers/bitcoin17-final28.pdf) or OP_PUSHTXDATA (https://github.com/jl2012/bips/blob/vault/bip-0ZZZ.mediawiki). I think this is the next step following the taproot soft fork\n\n> On 28 Nov 2018, at 8:54 AM, Bob McElrath via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> I have been working on an experimental wallet that implements Bitcoin\n> Covenants/Vaults following a blog post I wrote about 2 years ago, using\n> \"Pay-to-Timelock Signed Transaction\" (P2TST).  (Also mentioned recently by\n> kanzure in a talk somewheres...)  The idea is that you deposit to an address for\n> which you don't know the private key.  Instead you construct a second\n> transaction sending that to a timelocked staging address for which you DO have\n> the privkey (it also has an IF/ELSE condition with a second spending condition\n> for use in case of theft attempt).  In order to do this you either have to\n> delete the privkey of the deposit address (a difficult proposition to know it's\n> actually been deleted), but instead one can construct a signature directly using\n> a RNG, and use the SIGHASH to compute the corresponding pubkey via ECDSA\n> recover, from which you compute the corresponding address.  In this way your\n> wallet is a set of P2TST transactions and a corresponding privkey, with a (set\n> of) emergency keys.\n> \n> This interacts with NOINPUT in the following way: if the input to the\n> transaction commits to the pubkey in any way, you have a circular dependency on\n> the pubkey that could only be satisfied by breaking a hash function.  This\n> occurs with standard sighash's which commit to the txid, which in turn commit to\n> the address, which commits to the pubkey, so this construction of\n> covenants/vaults requires NOINPUT.\n> \n> AFAICT sipa's proposal is compatible with the above vaulted construction by\n> using SIGHASH_NOINPUT | SIGHASH_SCRIPTMASK to remove the\n> scriptPubKey/redeemScript from the sighash.  Putting the\n> scriptPubKey/redeemScript in the sighash introduces the same circular\n> dependency, but SIGHASH_SCRIPTMASK removes it.\n> \n> One would probably want to provide the fee from a separate wallet so as to be\n> able to account for fluctuating fee pressures when the unvaulting occurs a long\n> time after vaulting.  Thus you'd want to use SIGHASH_SINGLE so that a fee-wallet\n> can add fees (or for composability of P2TSTs), and SIGHASH_NOFEE as well.\n> \n> P.S. Also very excited to combine the above idea with Taproot/Graftroot/g'Root.\n> \n> --\n> Cheers, Bob McElrath\n> \n> \"For every complex problem, there is a solution that is simple, neat, and wrong.\"\n>    -- H. L. Mencken \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Bob McElrath",
                "date": "2018-11-28T14:04:13",
                "message_text_only": "We are also prototyping the OP_CHECKSIGFROMSTACK mechanism using Liquid/Elements.\n\nGiven uncertainty about which features will actually be deployed on mainnet,\nwe're exploring all possibilities so as to provide feedback about the \"best\" way\nto implement a covenant/vault, also including the OP_CHECKOUTPUTVERIFY\noriginally proposed by Eyal et al. That's 3 ways to implement a covenant/vault,\nif there's others I'd be happy to hear about it.  ;-)  Thanks for the\nOP_PUSHTXDATA ref, I'm reading now...  Personally I think the\nOP_CHECKSIGFROMSTACK is probably the most elegant mechanism.\n\nThanks for the feedback!\n\nJohnson Lau [jl2012 at xbt.hk] wrote:\n> This is incompatible with bip-schnorr, which intentionally disallow such use by always committing to the public key: https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki\n> \n> With the recent fake Satoshi signature drama, and other potential ways to misuse and abuse, I think this is a better way to go, which unfortunately might disallow some legitimate applications.\n> \n> Covenants could be made using OP_CHECKSIGFROMSTACK (https://fc17.ifca.ai/bitcoin/papers/bitcoin17-final28.pdf) or OP_PUSHTXDATA (https://github.com/jl2012/bips/blob/vault/bip-0ZZZ.mediawiki). I think this is the next step following the taproot soft fork\n> \n> > On 28 Nov 2018, at 8:54 AM, Bob McElrath via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > \n> > I have been working on an experimental wallet that implements Bitcoin\n> > Covenants/Vaults following a blog post I wrote about 2 years ago, using\n> > \"Pay-to-Timelock Signed Transaction\" (P2TST).  (Also mentioned recently by\n> > kanzure in a talk somewheres...)  The idea is that you deposit to an address for\n> > which you don't know the private key.  Instead you construct a second\n> > transaction sending that to a timelocked staging address for which you DO have\n> > the privkey (it also has an IF/ELSE condition with a second spending condition\n> > for use in case of theft attempt).  In order to do this you either have to\n> > delete the privkey of the deposit address (a difficult proposition to know it's\n> > actually been deleted), but instead one can construct a signature directly using\n> > a RNG, and use the SIGHASH to compute the corresponding pubkey via ECDSA\n> > recover, from which you compute the corresponding address.  In this way your\n> > wallet is a set of P2TST transactions and a corresponding privkey, with a (set\n> > of) emergency keys.\n> > \n> > This interacts with NOINPUT in the following way: if the input to the\n> > transaction commits to the pubkey in any way, you have a circular dependency on\n> > the pubkey that could only be satisfied by breaking a hash function.  This\n> > occurs with standard sighash's which commit to the txid, which in turn commit to\n> > the address, which commits to the pubkey, so this construction of\n> > covenants/vaults requires NOINPUT.\n> > \n> > AFAICT sipa's proposal is compatible with the above vaulted construction by\n> > using SIGHASH_NOINPUT | SIGHASH_SCRIPTMASK to remove the\n> > scriptPubKey/redeemScript from the sighash.  Putting the\n> > scriptPubKey/redeemScript in the sighash introduces the same circular\n> > dependency, but SIGHASH_SCRIPTMASK removes it.\n> > \n> > One would probably want to provide the fee from a separate wallet so as to be\n> > able to account for fluctuating fee pressures when the unvaulting occurs a long\n> > time after vaulting.  Thus you'd want to use SIGHASH_SINGLE so that a fee-wallet\n> > can add fees (or for composability of P2TSTs), and SIGHASH_NOFEE as well.\n> > \n> > P.S. Also very excited to combine the above idea with Taproot/Graftroot/g'Root.\n> > \n> > --\n> > Cheers, Bob McElrath\n> > \n> > \"For every complex problem, there is a solution that is simple, neat, and wrong.\"\n> >    -- H. L. Mencken \n> > \n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> \n> \n> \n> !DSPAM:5bfe5494217527839717631!\n--\nCheers, Bob McElrath\n\n\"For every complex problem, there is a solution that is simple, neat, and wrong.\"\n    -- H. L. Mencken"
            }
        ],
        "thread_summary": {
            "title": "Safer sighashes and more granular SIGHASH_NOINPUT",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Johnson Lau",
                "Russell O'Connor",
                "Bob McElrath",
                "Pieter Wuille",
                "Christian Decker"
            ],
            "messages_count": 23,
            "total_messages_chars_count": 70673
        }
    },
    {
        "title": "[bitcoin-dev] Multi party Schnorr Rust implementation",
        "thread_messages": [
            {
                "author": "Omer Shlomovits",
                "date": "2018-11-27T17:52:51",
                "message_text_only": "Hello all,\n\nI am working for the past few months with collaborators (in cc) on\nproviding Rust reference implementations to existing multi party schemes\nfor Schnorr signatures [1]. This includes aggregated signatures,\naccountable signatures (which for n out of n are multi-signatures) and\nthreshold signatures (wip).\nThe project can be found here:\nhttps://github.com/KZen-networks/multi-party-schnorr .\nWe aim that if the protocol is run in a configuration of a single party it\nwill be bip-schnorr [2] compliant.\n\nHope you'll find it useful :)\nQuestions, suggestions and pull requests are welcome!\n\n\n[1] https://github.com/KZen-networks/multi-party-schnorr/tree/master/papers\n[2] https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181127/4f353499/attachment.html>"
            },
            {
                "author": "Devrandom",
                "date": "2018-11-28T06:33:30",
                "message_text_only": "Hi Omer,\n\nAre there any candidates for non-interactive threshold signatures?\nInteractive signatures are not very suitable for air-gapped use cases.\n\nOn Tue, Nov 27, 2018 at 11:18 AM Omer Shlomovits via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello all,\n>\n> I am working for the past few months with collaborators (in cc) on\n> providing Rust reference implementations to existing multi party schemes\n> for Schnorr signatures [1]. This includes aggregated signatures,\n> accountable signatures (which for n out of n are multi-signatures) and\n> threshold signatures (wip).\n> The project can be found here:\n> https://github.com/KZen-networks/multi-party-schnorr .\n> We aim that if the protocol is run in a configuration of a single party it\n> will be bip-schnorr [2] compliant.\n>\n> Hope you'll find it useful :)\n> Questions, suggestions and pull requests are welcome!\n>\n>\n> [1]\n> https://github.com/KZen-networks/multi-party-schnorr/tree/master/papers\n> [2] https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181127/9bf84f7f/attachment.html>"
            },
            {
                "author": "Omer Shlomovits",
                "date": "2018-11-28T08:13:08",
                "message_text_only": "Hi,\n\nAFAIK, There is no way to do threshold signatures non-interactively for the\ngeneral case of t out of n. Even if you are willing to maintain additional\ndata structure on top of the standard and change verification algorithm\n(see for example appendix B in [1] where they use bitmaps).\n\nThe best way that I came up with so far (which I plan to implement in the\nlibrary) is to take SS01 paper [2], this also the paper cited in\nbip-schnorr [3], and to replace Pedersen VSS with Feldman VSS (Feldman VSS\nimplementation can be found in [4] ). Basically taking the DKG from GG18\nwithout paillier and the dlog pok (threshold ecdsa paper [5]) and use it\nfor the threshold schnorr DKG and for the ephemeral key distributed\ngeneration. This will cause the lost of Robustness but will be more\nefficient.\n\nGenerally speaking - the purpose of using threshold security is to replace\nhw security. The assumption is that you would rather trust that no more\nthan t out of n different machines will get corrupted at same time than to\ntrust one secure hardware. Maybe that relax a bit the demand for using air\ngapped devices?\n\n\n[1] https://docs.zilliqa.com/whitepaper.pdf\n[2]\nhttps://github.com/KZen-networks/multi-party-schnorr/blob/master/papers/provably_secure_distributed_schnorr_signatures_and_a_threshold_scheme.pdf\n[3]\nhttps://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki#multisignatures-and-threshold-signatures\n[4]\nhttps://github.com/KZen-networks/curv/tree/master/src/cryptographic_primitives/secret_sharing\n[5] http://stevengoldfeder.com/papers/GG18.pdf\n\nOn Wed, Nov 28, 2018 at 8:33 AM Devrandom <c1.bitcoin at niftybox.net> wrote:\n\n> Hi Omer,\n>\n> Are there any candidates for non-interactive threshold signatures?\n> Interactive signatures are not very suitable for air-gapped use cases.\n>\n> On Tue, Nov 27, 2018 at 11:18 AM Omer Shlomovits via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hello all,\n>>\n>> I am working for the past few months with collaborators (in cc) on\n>> providing Rust reference implementations to existing multi party schemes\n>> for Schnorr signatures [1]. This includes aggregated signatures,\n>> accountable signatures (which for n out of n are multi-signatures) and\n>> threshold signatures (wip).\n>> The project can be found here:\n>> https://github.com/KZen-networks/multi-party-schnorr .\n>> We aim that if the protocol is run in a configuration of a single party\n>> it will be bip-schnorr [2] compliant.\n>>\n>> Hope you'll find it useful :)\n>> Questions, suggestions and pull requests are welcome!\n>>\n>>\n>> [1]\n>> https://github.com/KZen-networks/multi-party-schnorr/tree/master/papers\n>> [2] https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181128/0f4074bd/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2018-11-28T10:49:46",
                "message_text_only": "On Tue, Nov 27, 2018 at 10:33:30PM -0800, Devrandom via bitcoin-dev wrote:\n> Are there any candidates for non-interactive threshold signatures?\u00a0 Interactive\n> signatures are not very suitable for air-gapped use cases.\n\nI think you can work around this to some extent by \"batching\" signing\nrequests.\n\n(Background:\n\nFor interactive multisignatures (threshold or not), the protocol is:\n\n   produce secret nonce r, calculate public nonce R=r*G\n   everyone shares H(R)\n   everyone shares R, checks received values match received hashes\n   everyone calculates s=r+H(R',P',m)*p, shares s\n\nFor deterministic nonces, you generate r=H(p,m) based on the message\nbeing signed and your private key, so can only start this process when\nyou start signing, and the sharing rounds mean interactivity.\n\n)\n\nBut you don't strictly need deterministic nonces, you just have to never\nuse the same nonce with a different message. If you arrange to do that\nby keeping some state instead, you can calculate nonces in advance:\n\nphase 1:\n    produce secret nonces r1..r1024, calculate R1..R1024\n    share H(R1)..H(R1024)\n\nphase 2:\n    store other parties hashes, eg as H1..H1024\n    share R1..R1024\n\nphase 3:\n    check received nonces match, ie H(R1)=H1, etc\n\nphase 4:\n    request to sign msg m, with nonce n\n    if nonce n has already been used, abort\n    mark nonce n as having being used\n    lookup other signer's nonces n and sum them to get R'\n    calculate s = rn + H(R',P',m)*p\n    share s\n\nThat way you could do phases 1-3 once, and then do 1024 signatures during\nthe month on whatever your current timetable is.\n\nYou could also combine these phases, so when you get a signing request you:\n\n   * receive msg to sign m, n=4; everyone else's R4, H(R5)\n\n   * check  H(R4) = previously received \"H(R4)\"\n   * calculate R4' by summing up your and everyone's R4s\n   * bump state to n=5\n   * do the signature...\n\n   * send sig=(s,R4), R5, H(R6)\n\nwhich would let you have an untrusted app that does the coordination and\nshares the nonces and nonce-hashes, and getting all the needed air-gapped\ncommunication in a single round. (This is effectively doing phase 3 and\n4 for the current signature, phase 2 for the next signature, and phase\n1 for the signature after that all in one round of communication)\n\nThat seems almost as good as true non-interactivity to me, if your signing\nhardware is capable of securely storing (and updating) a few kB of state\n(which is probably not quite as easy as it sounds).\n\nCheers,\naj"
            },
            {
                "author": "Jonas Nick",
                "date": "2018-11-28T16:43:12",
                "message_text_only": "> For deterministic nonces, you generate r=H(p,m) based on the message\n> being signed and your private key, so can only start this process when\n> you start signing, and the sharing rounds mean interactivity.\n\nIt's not your point but it should be noted that this is not secure unless all\nother signers give you zero knowledge proof that they've generated their nonce\nin the same way. Otherwise, if your asked to sign the same message you'll use\nthe same nonce for two different challenges. In your example you'd compute\ns=r+H(R',P',m)*p and s'=r+H(R'',P',m)*p from which an observer can compute the\nsecret key p.\n\nOn 11/28/18 10:49 AM, Anthony Towns via bitcoin-dev wrote:\n> On Tue, Nov 27, 2018 at 10:33:30PM -0800, Devrandom via bitcoin-dev wrote:\n>> Are there any candidates for non-interactive threshold signatures?\u00a0 Interactive\n>> signatures are not very suitable for air-gapped use cases.\n> \n> I think you can work around this to some extent by \"batching\" signing\n> requests.\n> \n> (Background:\n> \n> For interactive multisignatures (threshold or not), the protocol is:\n> \n>    produce secret nonce r, calculate public nonce R=r*G\n>    everyone shares H(R)\n>    everyone shares R, checks received values match received hashes\n>    everyone calculates s=r+H(R',P',m)*p, shares s\n> \n> For deterministic nonces, you generate r=H(p,m) based on the message\n> being signed and your private key, so can only start this process when\n> you start signing, and the sharing rounds mean interactivity.\n> \n> )\n> \n> But you don't strictly need deterministic nonces, you just have to never\n> use the same nonce with a different message. If you arrange to do that\n> by keeping some state instead, you can calculate nonces in advance:\n> \n> phase 1:\n>     produce secret nonces r1..r1024, calculate R1..R1024\n>     share H(R1)..H(R1024)\n> \n> phase 2:\n>     store other parties hashes, eg as H1..H1024\n>     share R1..R1024\n> \n> phase 3:\n>     check received nonces match, ie H(R1)=H1, etc\n> \n> phase 4:\n>     request to sign msg m, with nonce n\n>     if nonce n has already been used, abort\n>     mark nonce n as having being used\n>     lookup other signer's nonces n and sum them to get R'\n>     calculate s = rn + H(R',P',m)*p\n>     share s\n> \n> That way you could do phases 1-3 once, and then do 1024 signatures during\n> the month on whatever your current timetable is.\n> \n> You could also combine these phases, so when you get a signing request you:\n> \n>    * receive msg to sign m, n=4; everyone else's R4, H(R5)\n> \n>    * check  H(R4) = previously received \"H(R4)\"\n>    * calculate R4' by summing up your and everyone's R4s\n>    * bump state to n=5\n>    * do the signature...\n> \n>    * send sig=(s,R4), R5, H(R6)\n> \n> which would let you have an untrusted app that does the coordination and\n> shares the nonces and nonce-hashes, and getting all the needed air-gapped\n> communication in a single round. (This is effectively doing phase 3 and\n> 4 for the current signature, phase 2 for the next signature, and phase\n> 1 for the signature after that all in one round of communication)\n> \n> That seems almost as good as true non-interactivity to me, if your signing\n> hardware is capable of securely storing (and updating) a few kB of state\n> (which is probably not quite as easy as it sounds).\n> \n> Cheers,\n> aj\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            }
        ],
        "thread_summary": {
            "title": "Multi party Schnorr Rust implementation",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Jonas Nick",
                "Anthony Towns",
                "Devrandom",
                "Omer Shlomovits"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 11423
        }
    },
    {
        "title": "[bitcoin-dev] CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)",
        "thread_messages": [
            {
                "author": "Matt Corallo",
                "date": "2018-11-29T19:37:54",
                "message_text_only": "(cross-posted to both lists to make lightning-dev folks aware, please \ntake lightning-dev off CC when responding).\n\nAs I'm sure everyone is aware, Lightning (and other similar systems) \nwork by exchanging pre-signed transactions for future broadcast. Of \ncourse in many cases this requires either (a) predicting what the \nfeerate required for timely confirmation will be at some (or, really, \nany) point in the future, or (b) utilizing CPFP and dependent \ntransaction relay to allow parties to broadcast low-feerate transactions \nwith children created at broadcast-time to increase the effective \nfeerate. Ideally transactions could be constructed to allow for \nafter-the-fact addition of inputs to increase fee without CPFP but it is \nnot always possible to do so.\n\nOption (a) is rather obviously intractible, and implementation \ncomplexity has led to channel failures in lightning in practice (as both \nsides must agree on a reasonable-in-the-future feerate). Option (b) is a \nmuch more natural choice (assuming some form of as-yet-unimplemented \npackage relay on the P2P network) but is made difficult due to \ncomplexity around RBF/CPFP anti-DoS rules.\n\nFor example, if we take a simplified lightning design with pre-signed \ncommitment transaction A with one 0-value anyone-can-spend output \navailable for use as a CPFP output, a counterparty can prevent \nconfirmation of/significantly increase the fee cost of confirming A by \nchaining a large-but-only-moderate-feerate transaction off of this \nanyone-can-spend output. This transaction, B, will have a large absolute \nfee while making the package (A, B) have a low-ish feerate, placing it \nsolidly at the bottom of the mempool but without significant risk of it \ngetting evicted during memory limiting. This large absolute fee forces a \ncounterparty which wishes to have the commitment transaction confirm to \nincrease on this absolute fee in order to meet RBF rules.\n\nFor this reason (and many other similar attacks utilizing the package \nsize limits), in discussing the security model around CPFP, we've \ngenerally considered it too-difficulty-to-prevent third parties which \nare able to spend an output of a transaction from delaying its \nconfirmation, at least until/unless the prevailing feerates decline and \nsome of the mempool backlog gets confirmed.\n\nYou'll note, however, that this attack doesn't have to be permanent to \nwork - Lightning's (and other contracting/payment channel systems') \nsecurity model assumes the ability to get such commitment transactions \nconfirmed in a timely manner, as otherwise HTLCs may time out and \ncounterparties can claim the timeout-refund before we can claim the HTLC \nusing the hash-preimage.\n\nTo partially-address the CPFP security model considerations, a next step \nmight involve tweaking Lightning's commitment transaction to have two \nsmall-value outputs which are immediately spendable, one by each channel \nparticipant, allowing them to chain children off without allowng \nunrelated third-parties to chain children. Obviously this does not \naddress the specific attack so we need a small tweak to the anti-DoS \nCPFP rules in Bitcoin Core/BIP 125:\n\nThe last transaction which is added to a package of dependent \ntransactions in the mempool must:\n  * Have no more than one unconfirmed parent,\n  * Be of size no greater than 1K in virtual size.\n(for implementation sanity, this would effectively reduce all mempool \npackage size limits by 1 1K-virtual-size transaction, and the last would \nbe \"allowed to violate the limits\" as long as it meets the above criteria).\n\nFor contracting applications like lightning, this means that as long as \nthe transaction we wish to confirm (in this case the commitment transaction)\n  * Has only two immediately-spendable (ie non-CSV) outputs,\n  * where each immediately-spendable output is only spendable by one \ncounterparty,\n  * and is no larger than MAX_PACKAGE_VIRTUAL_SIZE - 1001 Vsize,\neach counterparty will always be able to independantly CPFP the \ntransaction in question. ie because if the \"malicious\" (ie \ntransaction-delaying) party bradcasts A with a child, it can never meet \nthe \"last transaction\" carve-out as its transaction cannot both meet the \npackage limit and have only one unconfirmed ancestor. Thus, the \nnon-delaying counterparty can always independently add its own CPFP \ntransaction, increasing the (A, Tx2) package feerate and confirming A \nwithout having to concern themselves with the (A, Tx1) package.\n\nAs an alternative proposal, at various points there have been \ndiscussions around solving the \"RBF-pinning\" problem by allowing \ntransactors to mark their transactions as \"likely-to-be-RBF'ed\", which \ncould enable a relay policy where children of such transactions would be \nrejected unless the resulting package would be \"near the top of the \nmempool\". This would theoretically imply such attacks are not possible \nto pull off consistently, as any \"transaction-delaying\" channel \nparticipant will have to place the package containing A at an effective \nfeerate which makes confirmation to occur soon with some likelihood. It \nis, however, possible to pull off this attack with low probability in \ncase of feerate spikes right after broadcast.\n\nNote that this clearly relies on some form of package relay, which comes \nwith its own challenges, but I'll start a separate thread on that.\n\nSee-also: lightning-dev thread about the changes to lightning spec \nrequired to incorporate this: \nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001643.html\n\nMatt"
            },
            {
                "author": "Russell O'Connor",
                "date": "2018-11-30T17:38:04",
                "message_text_only": "On Fri, Nov 30, 2018 at 9:50 AM Matt Corallo via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> To partially-address the CPFP security model considerations, a next step\n> might involve tweaking Lightning's commitment transaction to have two\n> small-value outputs which are immediately spendable, one by each channel\n> participant, allowing them to chain children off without allowng\n> unrelated third-parties to chain children. Obviously this does not\n> address the specific attack so we need a small tweak to the anti-DoS\n> CPFP rules in Bitcoin Core/BIP 125:\n>\n\nIt seems to me that this two-output scheme does address the specific attack\nwithout tweaking the RBF rules of BIP 125, since you are not doing an RBF\nat all.\n\nSuppose we have a 1k-vbyte unconfirmed transaction, TX0, with outputs Z, A,\nand B, where A and B are small outputs controlled by the participants Alice\nand Bob respectively, with a 1ksat fee, yielding a fee rate of 1sat/vbyte.\nSomeone, maybe Alice, attempts to pin the transaction, maliciously or not,\nby attaching a 10k-vbyte transaction, TX1, to either output Z or output A,\nwith a fee of 21ksats.  This brings the fee rate for the TX0-TX1 package to\n2sat/vbyte, being 11k-vbyte total size with 22ksats in total fees.\n\nNow Bob wants to CPFP to increase the effective fee rate of TX0 to\n3sats/vbyte using output B.  He attaches a 1k-vbyte transaction, TX2, to\noutput B with a fee of 5ksats.  This ought to create a new TX0-TX2 package\nwith a 3sat/vbyte fee rate, being 2k-vbyte total size with 6ksats in total\nfees.  TX1 has now been excluded from the package containing TX0. But TX1\nhasn't been replaced, so the RBF rules from BIP125 don't apply.  TX1 is\nstill a valid unconfirmed transaction operating at a fee rate of\n2.1sats/vbyte.\n\nThat said, I'm not an expert on how packages and package fee rates are\ncalculated in Bitcoin Core, so I am speculating a bit.  And, because I'm\ntalking with Matt, it's more likely that I'm mistaken.  AFAIK, any rules\nabout CPFP's behaviour in Bitcoin Core is undocumented.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181130/95ecf9e6/attachment-0001.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2018-11-30T19:33:56",
                "message_text_only": "Hmm, you may be correct that this doesn't (striclty speaking) imply a \nchange to the BIP 125 itself, though the high-level protocol here is \nlikely of interest to the list, as well as likely to generate feedback. \nNote that in your example, output Z must be CSV-delayed (ie you cannot \nconstruct a packeg using that output as it must be spent in a different \nblock than TX0 is confirmed in) in order for the proposal to be secure \nas otherwise Alice could use output A to pin the transaction, and then \n\"use up\" the proposed \"last-transaction\" rule by spending output Z, \nleaving Bob unable to spend output B without meeting the (expensive) RBF \ncriteria.\n\nIt was further pointed out to me that while the original mail states \nthat this relies on package relay, this isn't really entirely true. The \nstatus quo today may leave a commitment transaction unable to be \nbroadcast if feerates spike much higher than the feerate negotiated at \nthe time of construction. Under this proposal this is not changed, it is \nonly the implementation proposal which implies the commitment \ntransaction feerate negotiation will simply be replaced with a \n1sat/vbyte constant which relies on some form of package relay.\n\nMatt\n\nOn 11/30/18 5:38 PM, Russell O'Connor wrote:\n> On Fri, Nov 30, 2018 at 9:50 AM Matt Corallo via bitcoin-dev \n> <bitcoin-dev at lists.linuxfoundation.org \n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> \n>     To partially-address the CPFP security model considerations, a next\n>     step\n>     might involve tweaking Lightning's commitment transaction to have two\n>     small-value outputs which are immediately spendable, one by each\n>     channel\n>     participant, allowing them to chain children off without allowng\n>     unrelated third-parties to chain children. Obviously this does not\n>     address the specific attack so we need a small tweak to the anti-DoS\n>     CPFP rules in Bitcoin Core/BIP 125:\n> \n> \n> It seems to me that this two-output scheme does address the specific \n> attack without tweaking the RBF rules of BIP 125, since you are not \n> doing an RBF at all.\n> \n> Suppose we have a 1k-vbyte unconfirmed transaction, TX0, with outputs Z, \n> A, and B, where A and B are small outputs controlled by the participants \n> Alice and Bob respectively, with a 1ksat fee, yielding a fee rate of \n> 1sat/vbyte.\n> Someone, maybe Alice, attempts to pin the transaction, maliciously or \n> not, by attaching a 10k-vbyte transaction, TX1, to either output Z or \n> output A, with a fee of 21ksats.\u00a0 This brings the fee rate for the \n> TX0-TX1 package to 2sat/vbyte, being 11k-vbyte total size with 22ksats \n> in total fees.\n> \n> Now Bob wants to CPFP to increase the effective fee rate of TX0 to \n> 3sats/vbyte using output B.\u00a0 He attaches a 1k-vbyte transaction, TX2, to \n> output B with a fee of 5ksats.\u00a0 This ought to create a new TX0-TX2 \n> package with a 3sat/vbyte fee rate, being 2k-vbyte total size with \n> 6ksats in total fees.\u00a0 TX1 has now been excluded from the package \n> containing TX0. But TX1 hasn't been replaced, so the RBF rules from \n> BIP125 don't apply.\u00a0 TX1 is still a valid unconfirmed transaction \n> operating at a fee rate of 2.1sats/vbyte.\n> \n> That said, I'm not an expert on how packages and package fee rates are \n> calculated in Bitcoin Core, so I am speculating a bit.\u00a0 And, because I'm \n> talking with Matt, it's more likely that I'm mistaken.\u00a0 AFAIK, any rules \n> about CPFP's behaviour in Bitcoin Core is undocumented.\n>"
            }
        ],
        "thread_summary": {
            "title": "CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Russell O'Connor",
                "Matt Corallo"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 11272
        }
    }
]