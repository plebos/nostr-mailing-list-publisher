[
    {
        "title": "[bitcoin-dev] BIP37: 'getdata' request for filtered blocks is answered with 'merkleblock's even if no filter is set",
        "thread_messages": [
            {
                "author": "Sebastian Falbesoner",
                "date": "2020-04-02T15:26:40",
                "message_text_only": "Hi all,\n\nwhile experimenting with the functional test for BIP37 bloom filters\n(/test/functional/p2p_filter.py) I noticed that there is an odd behaviour\ndiverging from the specification.\n\nAccording to BIP37, 'getdata' commands with a request for filtered\nblocks via type\nMSG_FILTERED_BLOCK in the 'inv' submessage are only responded to if a filter is\nset:\n\n> The getdata command is extended to allow a new type in the inv submessage. The\n> type field can now be MSG_FILTERED_BLOCK (== 3) rather than MSG_BLOCK. If no\n> filter has been set on the connection, a request for filtered blocks is\n> ignored.  If a filter has been set, a merkleblock message is returned for the\n> requested block hash.\n\n(see https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki#Extensions_to_existing_messages)\n\nWhen no BIP37 is set and we request a filtered block, there should be no\nresponse from the node, but what indeed happens is that we always get a\n'merkleblock' message in reply.\n\nThe cause of this is that from a code point of view there is always a default\nfilter set that matches everything, which was introduced with commit\n37c6389c5a0ca63ae3573440ecdfe95d28ad8f07. The behaviour first appeared in\nrelease v0.8.4.\n\nAny suggestion on how we should cope with this issue? Even if this wouldn't be a\nproblem for the clients (Andreas Schildbach already pointed out that it could\nbe, though, and suggests that the connection should be dropped to clients that\nrequest filtered block if there was no filter set -- see issue-link below), I\nwant to point out that this leads to a few \"dead code\"-spots in the code base.\nWhenever there is a check if a filter is set, the corresponding else-branch is\nnever executed.\n\nMore details on how to reproduce this issue and where the relevant code parts\nare can be found on the corresponding github issue #18483:\nhttps://github.com/bitcoin/bitcoin/issues/18483\n\nGreetings,\nSebastian"
            }
        ],
        "thread_summary": {
            "title": "BIP37: 'getdata' request for filtered blocks is answered with 'merkleblock's even if no filter is set",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Sebastian Falbesoner"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1910
        }
    },
    {
        "title": "[bitcoin-dev] Statechain implementations",
        "thread_messages": [
            {
                "author": "Tom Trevethan",
                "date": "2020-04-02T22:56:17",
                "message_text_only": "Thanks for all of the input and comments - I do now think that the\ndecrementing nSequence relative locktime backup system with kick-off\ntransaction is the way to go, including a fee penalty via CPFP to\ndisincentivise DoS, as suggested.\nI have started a more detailed document specifying the proposed protocol in\nmore detail:\nhttps://github.com/commerceblock/mercury/blob/master/statechains.md which\nincludes improvements to the transfer mechanism (and an explanation of how\nthis can be used to transfer/novate positions in DLCs). Always happy to get\nmore feedback or PRs.\n\nTom\n\nOn Tue, Mar 31, 2020 at 12:41 PM Tom Trevethan <tom at commerceblock.com>\nwrote:\n\n> Hi David,\n>\n> Just for clarity, I left nChain over 2 years ago (having worked there\n> since 2016). While there, I (along with other researchers) were given free\n> rein to work on any ideas we wanted to. I had been interested in the\n> scaling of Bitcoin off-chain, and this was one of several things I spent\n> time on (including things like sidechains, pegs and threshold signatures).\n> This patent application came out of an idea I had to transfer ownership of\n> UTXOs off-chain that has some similarities to the statechains proposal,\n> which has shown there is interest and demand for this type of system.\n>\n> Although I think the existence of this application is something to be\n> mindful of, there are several important things to note:\n>\n> 1. Although there are similarities, the current ideas are significantly\n> different to those in the application.\n> 2. The key transfer protocol as described in the application is not secure\n> (for several reasons, including as discussed above, by Albert and Bob etc.)\n> - and a different mechanism is required.\n> 3. Decrementing timelocks (as suggested in the application) are prior art\n> (Decker-Wattenhofer 2015), and in any case any implementation will most\n> likely use an 'invalidation tree' relative locktime backup mechanism for\n> open-ended UTXOs.\n> 4. The patent application has not been granted (it was made in May 2017)\n> and the international search report rejected it on the grounds of prior\n> art.\n>\n> Tom\n>\n> On Tue, Mar 31, 2020 at 11:36 AM David A. Harding <dave at dtrt.org> wrote:\n>\n>> On Wed, Mar 25, 2020 at 01:52:10PM +0000, Tom Trevethan via bitcoin-dev\n>> wrote:\n>> > Hi all,\n>> >\n>> > We are starting to work on an implementation of the statechains concept\n>> (\n>> >\n>> https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39\n>> ),\n>> >\n>> > [...]\n>> > There are two main modifications we are looking at:\n>> > [...]\n>> >\n>> > 2. Replacing the 2-of-2 multisig output (paying to statechain entity SE\n>> key\n>> > and transitory key) with a single P2(W)PKH output where the public key\n>> > shared between the SE and the current owner. The SE and the current\n>> owner\n>> > can then sign with a 2-of-2 ECDSA MPC.\n>>\n>> Dr. Trevethan,\n>>\n>> Would you be able to explain how your proposal to use statechains with\n>> 2P-ECDSA relates to your patent assigned to nChain Holdings for \"Secure\n>> off-chain blockchain transactions\"?[1]\n>>\n>>     [1] https://patents.google.com/patent/US20200074464A1\n>>\n>> Here are some excerpts from the application that caught my attention in\n>> the context of statechains in general and your proposal to this list in\n>> particular:\n>>\n>> > an exchange platform that is trusted to implement and operate the\n>> > transaction protocol, without requiring an on-chain transaction. The\n>> > off-chain transactions enable one computer system to generate multiple\n>> > transactions that are recordable to a blockchain in different\n>> > circumstances\n>> >\n>> > [...]\n>> >\n>> > at least some of the off-chain transactions are valid for recording on\n>> > the blockchain even in the event of a catastrophic failure of the\n>> > exchange (e.g., exchange going permanently off-line or loosing key\n>> > shares).\n>> >\n>> > [...]\n>> >\n>> > there may be provided a computer readable storage medium including a\n>> > two-party elliptic curve digital signature algorithm (two-party ECDSA)\n>> > script comprising computer executable instructions which, when\n>> > executed, configure a processor to perform functions of a two-party\n>> > elliptic curve digital signature algorithm described herein.\n>> >\n>> > [...]\n>> >\n>> > In this instance the malicious actor would then also have to collude\n>> > with a previous owner of the funds to recreate the full key. Because\n>> > an attack requires either the simultaneous theft of both exchange and\n>> > depositor keys or collusion with previous legitimate owners of funds,\n>> > the opportunities for a malicious attacker to compromise the exchange\n>> > platform are limited.\n>>\n>> Thank you,\n>>\n>> -Dave\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200402/a630d677/attachment.html>"
            },
            {
                "author": "Nadav Kohen",
                "date": "2020-04-03T16:37:15",
                "message_text_only": "Hey all,\n\nSo my main concern with the proposal as written is that the Statechain\nEntity (SE) can untraceably scam its users with the following attack:\n\n1) Buy the utxo (have it transferred to a key it knows), this first step\ncan be skipped if the utxo was created by the SE.\n2) Transfer the UTXO to someone else, let it be for however long\n3) When it wishes to steal the UTXO, the SE now knows its own shard s_n and\nit  knows the full private key, x, from when it owned the UTXO (and had\nboth shards), and so it can compute x/s_n = the current users shard. It can\nthen sign for the current user, and forge a state transition to a key it\nowns before spending the UTXO on chain.\n\nThe main problem here is that the user who had their funds stolen cannot\nprove to anyone that this has happened since the attack compromises their\nkey.\nThat said, I think this problem is easily fixed by adding a new user key to\nthe protocol with which they must sign in order for the transfer to be\nconsidered valid on the state chain. This way, if the SE wishes to steal\nthe funds (which they still can), at least it is traceable/provable that\nthis SE is not trustworthy as there is no evidence of a valid transfer for\nthe funds that have been stolen.\n\nBest,\nNadav\n\nOn Thu, Apr 2, 2020 at 7:22 PM Tom Trevethan via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Thanks for all of the input and comments - I do now think that the\n> decrementing nSequence relative locktime backup system with kick-off\n> transaction is the way to go, including a fee penalty via CPFP to\n> disincentivise DoS, as suggested.\n> I have started a more detailed document specifying the proposed protocol\n> in more detail:\n> https://github.com/commerceblock/mercury/blob/master/statechains.md which\n> includes improvements to the transfer mechanism (and an explanation of how\n> this can be used to transfer/novate positions in DLCs). Always happy to get\n> more feedback or PRs.\n>\n> Tom\n>\n> On Tue, Mar 31, 2020 at 12:41 PM Tom Trevethan <tom at commerceblock.com>\n> wrote:\n>\n>> Hi David,\n>>\n>> Just for clarity, I left nChain over 2 years ago (having worked there\n>> since 2016). While there, I (along with other researchers) were given free\n>> rein to work on any ideas we wanted to. I had been interested in the\n>> scaling of Bitcoin off-chain, and this was one of several things I spent\n>> time on (including things like sidechains, pegs and threshold signatures).\n>> This patent application came out of an idea I had to transfer ownership of\n>> UTXOs off-chain that has some similarities to the statechains proposal,\n>> which has shown there is interest and demand for this type of system.\n>>\n>> Although I think the existence of this application is something to be\n>> mindful of, there are several important things to note:\n>>\n>> 1. Although there are similarities, the current ideas are significantly\n>> different to those in the application.\n>> 2. The key transfer protocol as described in the application is not\n>> secure (for several reasons, including as discussed above, by Albert and\n>> Bob etc.) - and a different mechanism is required.\n>> 3. Decrementing timelocks (as suggested in the application) are prior art\n>> (Decker-Wattenhofer 2015), and in any case any implementation will most\n>> likely use an 'invalidation tree' relative locktime backup mechanism for\n>> open-ended UTXOs.\n>> 4. The patent application has not been granted (it was made in May 2017)\n>> and the international search report rejected it on the grounds of prior\n>> art.\n>>\n>> Tom\n>>\n>> On Tue, Mar 31, 2020 at 11:36 AM David A. Harding <dave at dtrt.org> wrote:\n>>\n>>> On Wed, Mar 25, 2020 at 01:52:10PM +0000, Tom Trevethan via bitcoin-dev\n>>> wrote:\n>>> > Hi all,\n>>> >\n>>> > We are starting to work on an implementation of the statechains\n>>> concept (\n>>> >\n>>> https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39\n>>> ),\n>>> >\n>>> > [...]\n>>> > There are two main modifications we are looking at:\n>>> > [...]\n>>> >\n>>> > 2. Replacing the 2-of-2 multisig output (paying to statechain entity\n>>> SE key\n>>> > and transitory key) with a single P2(W)PKH output where the public key\n>>> > shared between the SE and the current owner. The SE and the current\n>>> owner\n>>> > can then sign with a 2-of-2 ECDSA MPC.\n>>>\n>>> Dr. Trevethan,\n>>>\n>>> Would you be able to explain how your proposal to use statechains with\n>>> 2P-ECDSA relates to your patent assigned to nChain Holdings for \"Secure\n>>> off-chain blockchain transactions\"?[1]\n>>>\n>>>     [1] https://patents.google.com/patent/US20200074464A1\n>>>\n>>> Here are some excerpts from the application that caught my attention in\n>>> the context of statechains in general and your proposal to this list in\n>>> particular:\n>>>\n>>> > an exchange platform that is trusted to implement and operate the\n>>> > transaction protocol, without requiring an on-chain transaction. The\n>>> > off-chain transactions enable one computer system to generate multiple\n>>> > transactions that are recordable to a blockchain in different\n>>> > circumstances\n>>> >\n>>> > [...]\n>>> >\n>>> > at least some of the off-chain transactions are valid for recording on\n>>> > the blockchain even in the event of a catastrophic failure of the\n>>> > exchange (e.g., exchange going permanently off-line or loosing key\n>>> > shares).\n>>> >\n>>> > [...]\n>>> >\n>>> > there may be provided a computer readable storage medium including a\n>>> > two-party elliptic curve digital signature algorithm (two-party ECDSA)\n>>> > script comprising computer executable instructions which, when\n>>> > executed, configure a processor to perform functions of a two-party\n>>> > elliptic curve digital signature algorithm described herein.\n>>> >\n>>> > [...]\n>>> >\n>>> > In this instance the malicious actor would then also have to collude\n>>> > with a previous owner of the funds to recreate the full key. Because\n>>> > an attack requires either the simultaneous theft of both exchange and\n>>> > depositor keys or collusion with previous legitimate owners of funds,\n>>> > the opportunities for a malicious attacker to compromise the exchange\n>>> > platform are limited.\n>>>\n>>> Thank you,\n>>>\n>>> -Dave\n>>>\n>> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200403/3f6ecd26/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-04T12:07:28",
                "message_text_only": "Good morning Nadav,\n\nIndeed.\n\nIt seems to me that practical deployments of statechains requires the statechain operator to be a trusted federation, possibly a k-of-n.\nThis is slightly better than a federated sidechain because the money can always be reclaimed on the blockchain layer very quickly in case of a loss of trust in the federation.\nIf the k-of-n is arranged in such a way that the signers can be identified (such as by use of old `OP_CHECKMULTISIG` or some combination of the proposed `OP_CHECKSIGADD`) then it has the same \"auditability\", i.e. you can identify the pseudonyms of the members who cheated (which is not worth much, as getting a new pseudonym is trivial).\n\nIt is helpful to remember that a k-of-n federation can only be trusted if you have full trust in at least (n - k + 1) members of the federation.\n\nRegards,\nZmnSCPxj\n\n> Hey all,\n>\n> So my main concern with the proposal as written is that the Statechain Entity (SE) can untraceably\u00a0scam its users with the following attack:\n> 1) Buy the utxo (have it transferred to a key it knows), this first step can be skipped if the utxo was created by the SE.\n> 2) Transfer the UTXO to someone else, let it be for however long\n> 3) When it wishes to steal the UTXO, the SE now knows its own shard s_n and it\u00a0 knows the full private key, x, from when it owned the UTXO (and had both shards), and so it can compute x/s_n = the current users shard. It can then sign for the current user, and forge a state transition to a key it owns before spending the UTXO on chain.\n>\n> The main problem here is that the user who had their funds stolen cannot prove to anyone that this has happened since the attack compromises their key.\n> That said, I think this problem is easily fixed by adding a new user key to the protocol with which they must sign in order for the transfer to be considered valid on the state chain. This way, if the SE wishes to steal the funds (which they still can), at least it is traceable/provable that this SE is not trustworthy as there is no evidence of a valid transfer for the funds that have been stolen.\n>\n> Best,\n> Nadav\n>\n> On Thu, Apr 2, 2020 at 7:22 PM Tom Trevethan via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > Thanks for all of the input and comments - I do now think that the decrementing nSequence relative locktime backup system with kick-off transaction is the way to go, including a fee penalty via CPFP to disincentivise\u00a0DoS, as suggested.\u00a0\n> > I have started a more detailed document specifying the proposed protocol in more detail:\u00a0https://github.com/commerceblock/mercury/blob/master/statechains.md\u00a0which includes improvements to the transfer\u00a0mechanism (and an explanation of how this can be used to transfer/novate positions in DLCs). Always happy to get more feedback or PRs.\u00a0\n> >\n> > Tom\n> >\n> > On Tue, Mar 31, 2020 at 12:41 PM Tom Trevethan <tom at commerceblock.com> wrote:\n> >\n> > > Hi David,\n> > >\n> > > Just for clarity, I left nChain over 2 years ago (having worked there since 2016). While there, I (along with other researchers) were given free rein to work on any ideas we wanted to. I had been interested in the scaling of Bitcoin off-chain, and this was one of several things I spent time on (including things like sidechains,\u00a0pegs and threshold signatures). This patent application came out of an idea I had to transfer ownership of UTXOs off-chain that has some similarities to the statechains proposal, which has shown there is interest and demand for this type of system.\u00a0\n> > >\n> > > Although I think the existence of this application is something to be mindful of, there are several important things to note:\n> > >\n> > > 1. Although there are similarities, the current ideas are significantly different to those in the application.\u00a0\n> > > 2. The key transfer protocol as described in the application is not secure (for several reasons, including as discussed above, by Albert and Bob etc.) - and a different mechanism is required.\u00a0\n> > > 3. Decrementing timelocks (as suggested in the application) are prior art (Decker-Wattenhofer 2015), and in any case any implementation will most likely use an 'invalidation tree' relative locktime backup mechanism for open-ended UTXOs.\u00a0\n> > > 4. The patent application has not been granted (it was made in May 2017) and the international search report rejected it on the grounds of prior art.\u00a0\n> > >\n> > > Tom\n> > >\n> > > On Tue, Mar 31, 2020 at 11:36 AM David A. Harding <dave at dtrt.org> wrote:\n> > >\n> > > > On Wed, Mar 25, 2020 at 01:52:10PM +0000, Tom Trevethan via bitcoin-dev wrote:\n> > > > > Hi all,\n> > > > >\n> > > > > We are starting to work on an implementation of the statechains concept (\n> > > > > https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39),\n> > > > >\n> > > > > [...]\n> > > > > There are two main modifications we are looking at:\n> > > > > [...]\n> > > > >\n> > > > > 2. Replacing the 2-of-2 multisig output (paying to statechain entity SE key\n> > > > > and transitory key) with a single P2(W)PKH output where the public key\n> > > > > shared between the SE and the current owner. The SE and the current owner\n> > > > > can then sign with a 2-of-2 ECDSA MPC.\n> > > >\n> > > > Dr. Trevethan,\n> > > >\n> > > > Would you be able to explain how your proposal to use statechains with\n> > > > 2P-ECDSA relates to your patent assigned to nChain Holdings for \"Secure\n> > > > off-chain blockchain transactions\"?[1]\u00a0\n> > > >\n> > > > \u00a0 \u00a0 [1] https://patents.google.com/patent/US20200074464A1\n> > > >\n> > > > Here are some excerpts from the application that caught my attention in\n> > > > the context of statechains in general and your proposal to this list in\n> > > > particular:\n> > > >\n> > > > > an exchange platform that is trusted to implement and operate the\n> > > > > transaction protocol, without requiring an on-chain transaction. The\n> > > > > off-chain transactions enable one computer system to generate multiple\n> > > > > transactions that are recordable to a blockchain in different\n> > > > > circumstances\n> > > > >\n> > > > > [...]\n> > > > >\n> > > > > at least some of the off-chain transactions are valid for recording on\n> > > > > the blockchain even in the event of a catastrophic failure of the\n> > > > > exchange (e.g., exchange going permanently off-line or loosing key\n> > > > > shares).\n> > > > >\n> > > > > [...]\n> > > > >\n> > > > > there may be provided a computer readable storage medium including a\n> > > > > two-party elliptic curve digital signature algorithm (two-party ECDSA)\n> > > > > script comprising computer executable instructions which, when\n> > > > > executed, configure a processor to perform functions of a two-party\n> > > > > elliptic curve digital signature algorithm described herein.\n> > > > >\n> > > > > [...]\n> > > > >\n> > > > > In this instance the malicious actor would then also have to collude\n> > > > > with a previous owner of the funds to recreate the full key. Because\n> > > > > an attack requires either the simultaneous theft of both exchange and\n> > > > > depositor keys or collusion with previous legitimate owners of funds,\n> > > > > the opportunities for a malicious attacker to compromise the exchange\n> > > > > platform are limited.\n> > > >\n> > > > Thank you,\n> > > >\n> > > > -Dave\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Bob McElrath",
                "date": "2020-04-05T14:17:17",
                "message_text_only": "Note that this attack requires collaboration with the current UTXO owner.\nGenerally if there's some form of address/payment request, the current holder is\ntrying to transfer the UXTO to some other (non-statechain) entity, and he knows\nthe target of the transfer, and participates in the protocol to authorize it.\nThe current holder must obtain the target pubkey for the transfer out-of-band\nwith respect to the SE, or the SE can MITM that.\n\nIt's a stated security assumption that the sender or receiver do not collude\nwith the SE. If either do, then your attack is generally possible and all bets\nare off. So what you've described is simply the SE colluding with the receiver.\nThe receiver will *already* receive the UTXO, so the receiver here is assisting\nthe SE in stealing his (the receiver's) funds, or the SE has done a MITM on the\ntransfer.  Various improvements including blind signing, a SE-federation, etc\nare valuable to consider to mitigate this. But the SE must be prevented, one way\nor another, from \"buying the UTXO\". The SE cannot be allowed to be both operator\nof the SE and a customer of it, as this clearly violates the no-receiver\ncollusion principle.\n\n\"Adding a new user key\" doesn't change the situation. There's already a user key\ninvolved, and the user has already acquiesced to the transfer. Acquiescing with\ntwo keys doesn't change anything.\n\nAs far as proving and tracing the fraud, this is where \"single use seals\" come\nin. Each SE transfer can involve an \"opening\" of a seal, followed by a \"close\"\nwhen it is transferred, creating a linear history of ownership. If the SE\nobtains the full private key x, one way or another, the spend of that UTXO will\nfall outside this seal-based history, and proof of fraud will be evident. It\nwon't be possible to determine *which* of the old owners collaborated with the\nSE, but it gives clear proof that the SE is not to be trusted. A customer might\ndemand that a seal-based system be in use as an independent entity from the SE,\nto audit the honesty of the SE. The seal system does not require any of the keys\nrequired for transfer. See https://mainstay.xyz as a potential implementation.\nThere are lots of reasons this might required as an AML solution for some\nbusinesses anyway.\n\nNadav Kohen via bitcoin-dev [bitcoin-dev at lists.linuxfoundation.org] wrote:\n> Hey all,\n> \n> So my main concern with the proposal as written is that the Statechain Entity\n> (SE) can untraceably\u00a0scam its users with the following attack:\n> \n> 1) Buy the utxo (have it transferred to a key it knows), this first step can be\n> skipped if the utxo was created by the SE.\n> 2) Transfer the UTXO to someone else, let it be for however long\n> 3) When it wishes to steal the UTXO, the SE now knows its own shard s_n and it\u00a0\n> knows the full private key, x, from when it owned the UTXO (and had both\n> shards), and so it can compute x/s_n = the current users shard. It can then\n> sign for the current user, and forge a state transition to a key it owns before\n> spending the UTXO on chain.\n> \n> The main problem here is that the user who had their funds stolen cannot prove\n> to anyone that this has happened since the attack compromises their key.\n> That said, I think this problem is easily fixed by adding a new user key to the\n> protocol with which they must sign in order for the transfer to be considered\n> valid on the state chain. This way, if the SE wishes to steal the funds (which\n> they still can), at least it is traceable/provable that this SE is not\n> trustworthy as there is no evidence of a valid transfer for the funds that have\n> been stolen.\n> \n> Best,\n> Nadav\n> \n> On Thu, Apr 2, 2020 at 7:22 PM Tom Trevethan via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n>     Thanks for all of the input and comments - I do now think that the\n>     decrementing nSequence relative locktime backup system with kick-off\n>     transaction is the way to go, including a fee penalty via CPFP to\n>     disincentivise\u00a0DoS, as suggested.\u00a0\n>     I have started a more detailed document specifying the proposed protocol in\n>     more detail:\u00a0https://github.com/commerceblock/mercury/blob/master/\n>     statechains.md\u00a0which includes improvements to the transfer\u00a0mechanism (and\n>     an explanation of how this can be used to transfer/novate positions in\n>     DLCs). Always happy to get more feedback or PRs.\u00a0\n> \n>     Tom\n> \n>     On Tue, Mar 31, 2020 at 12:41 PM Tom Trevethan <tom at commerceblock.com>\n>     wrote:\n> \n>         Hi David,\n> \n>         Just for clarity, I left nChain over 2 years ago (having worked there\n>         since 2016). While there, I (along with other researchers) were given\n>         free rein to work on any ideas we wanted to. I had been interested in\n>         the scaling of Bitcoin off-chain, and this was one of several things I\n>         spent time on (including things like sidechains,\u00a0pegs and threshold\n>         signatures). This patent application came out of an idea I had to\n>         transfer ownership of UTXOs off-chain that has some similarities to the\n>         statechains proposal, which has shown there is interest and demand for\n>         this type of system.\u00a0\n> \n>         Although I think the existence of this application is something to be\n>         mindful of, there are several important things to note:\n> \n>         1. Although there are similarities, the current ideas are significantly\n>         different to those in the application.\u00a0\n>         2. The key transfer protocol as described in the application is not\n>         secure (for several reasons, including as discussed above, by Albert\n>         and Bob etc.) - and a different mechanism is required.\u00a0\n>         3. Decrementing timelocks (as suggested in the application) are prior\n>         art (Decker-Wattenhofer 2015), and in any case any implementation will\n>         most likely use an 'invalidation tree' relative locktime backup\n>         mechanism for open-ended UTXOs.\u00a0\n>         4. The patent application has not been granted (it was made in May\n>         2017) and the international search report rejected it on the grounds of\n>         prior art.\u00a0\n> \n>         Tom\n> \n>         On Tue, Mar 31, 2020 at 11:36 AM David A. Harding <dave at dtrt.org>\n>         wrote:\n> \n>             On Wed, Mar 25, 2020 at 01:52:10PM +0000, Tom Trevethan via\n>             bitcoin-dev wrote:\n>             > Hi all,\n>             >\n>             > We are starting to work on an implementation of the statechains\n>             concept (\n>             > https://medium.com/@RubenSomsen/\n>             statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39),\n>             >\n>             > [...]\n>             > There are two main modifications we are looking at:\n>             > [...]\n>             >\n>             > 2. Replacing the 2-of-2 multisig output (paying to statechain\n>             entity SE key\n>             > and transitory key) with a single P2(W)PKH output where the\n>             public key\n>             > shared between the SE and the current owner. The SE and the\n>             current owner\n>             > can then sign with a 2-of-2 ECDSA MPC.\n> \n>             Dr. Trevethan,\n> \n>             Would you be able to explain how your proposal to use statechains\n>             with\n>             2P-ECDSA relates to your patent assigned to nChain Holdings for\n>             \"Secure\n>             off-chain blockchain transactions\"?[1]\u00a0\n> \n>             \u00a0 \u00a0 [1] https://patents.google.com/patent/US20200074464A1\n> \n>             Here are some excerpts from the application that caught my\n>             attention in\n>             the context of statechains in general and your proposal to this\n>             list in\n>             particular:\n> \n>             > an exchange platform that is trusted to implement and operate the\n>             > transaction protocol, without requiring an on-chain transaction.\n>             The\n>             > off-chain transactions enable one computer system to generate\n>             multiple\n>             > transactions that are recordable to a blockchain in different\n>             > circumstances\n>             >\n>             > [...]\n>             >\n>             > at least some of the off-chain transactions are valid for\n>             recording on\n>             > the blockchain even in the event of a catastrophic failure of the\n>             > exchange (e.g., exchange going permanently off-line or loosing\n>             key\n>             > shares).\n>             >\n>             > [...]\n>             >\n>             > there may be provided a computer readable storage medium\n>             including a\n>             > two-party elliptic curve digital signature algorithm (two-party\n>             ECDSA)\n>             > script comprising computer executable instructions which, when\n>             > executed, configure a processor to perform functions of a\n>             two-party\n>             > elliptic curve digital signature algorithm described herein.\n>             >\n>             > [...]\n>             >\n>             > In this instance the malicious actor would then also have to\n>             collude\n>             > with a previous owner of the funds to recreate the full key.\n>             Because\n>             > an attack requires either the simultaneous theft of both exchange\n>             and\n>             > depositor keys or collusion with previous legitimate owners of\n>             funds,\n>             > the opportunities for a malicious attacker to compromise the\n>             exchange\n>             > platform are limited.\n> \n>             Thank you,\n> \n>             -Dave\n> \n>     _______________________________________________\n>     bitcoin-dev mailing list\n>     bitcoin-dev at lists.linuxfoundation.org\n>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> !DSPAM:5e87670a231323960034969!\n\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> \n> !DSPAM:5e87670a231323960034969!\n\n--\nCheers, Bob McElrath\n\n\"For every complex problem, there is a solution that is simple, neat, and wrong.\"\n    -- H. L. Mencken \n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 181 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200405/6199c0fd/attachment.sig>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-05T18:24:39",
                "message_text_only": "Good morning Bob,\n\n\n> Note that this attack requires collaboration with the current UTXO owner.\n> Generally if there's some form of address/payment request, the current holder is\n> trying to transfer the UXTO to some other (non-statechain) entity, and he knows\n> the target of the transfer, and participates in the protocol to authorize it.\n> The current holder must obtain the target pubkey for the transfer out-of-band\n> with respect to the SE, or the SE can MITM that.\n>\n> It's a stated security assumption that the sender or receiver do not collude\n> with the SE. If either do, then your attack is generally possible and all bets\n> are off. So what you've described is simply the SE colluding with the receiver.\n> The receiver will already receive the UTXO, so the receiver here is assisting\n> the SE in stealing his (the receiver's) funds, or the SE has done a MITM on the\n> transfer. Various improvements including blind signing, a SE-federation, etc\n> are valuable to consider to mitigate this. But the SE must be prevented, one way\n> or another, from \"buying the UTXO\". The SE cannot be allowed to be both operator\n> of the SE and a customer of it, as this clearly violates the no-receiver\n> collusion principle.\n>\n> \"Adding a new user key\" doesn't change the situation. There's already a user key\n> involved, and the user has already acquiesced to the transfer. Acquiescing with\n> two keys doesn't change anything.\n\nThe point is not that acquiescing with two keys is possible.\nInstead, the point is that any past owner of the coin can collude with the statechain authority (who, in the new scheme, must be trusted to delete old keys), or anyone who manages to get backups of the statechain authority keys (such as by digging for backups in a landfill), in order to steal the onchain funds, regardless of who the current owner is, within the statechain.\n\nThus an amount of trust must still be put in the statechain authority.\n\nSo I think the security assumptions should be that:\n\n* The statechain authority really does delete keys and does not make backups.\n* No *past* or *current* owner of the coin colludes with the statechain authority.\n  * I think saying merely \"sender\" is not sufficient to capture the actual security assumption here.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Tom Trevethan",
                "date": "2020-04-05T21:25:51",
                "message_text_only": "Hi Bob and Nadav,\n\nThere seems to be no way to prevent a malicious SE from stealing an\noutput from the current owner by either colluding with (or being) a\nprevious owner. But with a proof-of-publication (i.e. the statechain) it is\npossible for the current owner to have a proof that the SE has stolen from\nthem. It seems to me that the statechain itself provides two functions: 1.\nProof that an output has only a single owner at any time (preventing the SE\nfrom double-spending) and 2. a way for the current owner to prove their\nownership, and require their permission to change ownership. 1. can just be\na publication by the SE, but 2. requires that the output is transferred to\na public key of the owner, and only via a signature of the previous owner\n(in this way the SE cannot re-assign ownership unilaterally). Therefore I\nthink Nadav is right, and this needs to be a key that the SE can never know\n(even if they are malicious), but which can be used to prove ownership, and\nin turn prove fraud on the part of the SE.\n\nI don't think that this should be too much of an issue: any wallet will\nhave to use new keys for each output and transfer anyway. The statechain\nkey (used for the ownership proof) and the output key share can be on\ndifferent hardened HD paths (following on from a path derived from the\noutpoint of the UTXO, similar to the method in BIP175).\n\nTom\n\n\n\nOn Sun, Apr 5, 2020 at 3:17 PM Bob McElrath <bob at mcelrath.org> wrote:\n\n> Note that this attack requires collaboration with the current UTXO owner.\n> Generally if there's some form of address/payment request, the current\n> holder is\n> trying to transfer the UXTO to some other (non-statechain) entity, and he\n> knows\n> the target of the transfer, and participates in the protocol to authorize\n> it.\n> The current holder must obtain the target pubkey for the transfer\n> out-of-band\n> with respect to the SE, or the SE can MITM that.\n>\n> It's a stated security assumption that the sender or receiver do not\n> collude\n> with the SE. If either do, then your attack is generally possible and all\n> bets\n> are off. So what you've described is simply the SE colluding with the\n> receiver.\n> The receiver will *already* receive the UTXO, so the receiver here is\n> assisting\n> the SE in stealing his (the receiver's) funds, or the SE has done a MITM\n> on the\n> transfer.  Various improvements including blind signing, a SE-federation,\n> etc\n> are valuable to consider to mitigate this. But the SE must be prevented,\n> one way\n> or another, from \"buying the UTXO\". The SE cannot be allowed to be both\n> operator\n> of the SE and a customer of it, as this clearly violates the no-receiver\n> collusion principle.\n>\n> \"Adding a new user key\" doesn't change the situation. There's already a\n> user key\n> involved, and the user has already acquiesced to the transfer. Acquiescing\n> with\n> two keys doesn't change anything.\n>\n> As far as proving and tracing the fraud, this is where \"single use seals\"\n> come\n> in. Each SE transfer can involve an \"opening\" of a seal, followed by a\n> \"close\"\n> when it is transferred, creating a linear history of ownership. If the SE\n> obtains the full private key x, one way or another, the spend of that UTXO\n> will\n> fall outside this seal-based history, and proof of fraud will be evident.\n> It\n> won't be possible to determine *which* of the old owners collaborated with\n> the\n> SE, but it gives clear proof that the SE is not to be trusted. A customer\n> might\n> demand that a seal-based system be in use as an independent entity from\n> the SE,\n> to audit the honesty of the SE. The seal system does not require any of\n> the keys\n> required for transfer. See https://mainstay.xyz as a potential\n> implementation.\n> There are lots of reasons this might required as an AML solution for some\n> businesses anyway.\n>\n> Nadav Kohen via bitcoin-dev [bitcoin-dev at lists.linuxfoundation.org] wrote:\n> > Hey all,\n> >\n> > So my main concern with the proposal as written is that the Statechain\n> Entity\n> > (SE) can untraceably scam its users with the following attack:\n> >\n> > 1) Buy the utxo (have it transferred to a key it knows), this first step\n> can be\n> > skipped if the utxo was created by the SE.\n> > 2) Transfer the UTXO to someone else, let it be for however long\n> > 3) When it wishes to steal the UTXO, the SE now knows its own shard s_n\n> and it\n> > knows the full private key, x, from when it owned the UTXO (and had both\n> > shards), and so it can compute x/s_n = the current users shard. It can\n> then\n> > sign for the current user, and forge a state transition to a key it owns\n> before\n> > spending the UTXO on chain.\n> >\n> > The main problem here is that the user who had their funds stolen cannot\n> prove\n> > to anyone that this has happened since the attack compromises their key.\n> > That said, I think this problem is easily fixed by adding a new user key\n> to the\n> > protocol with which they must sign in order for the transfer to be\n> considered\n> > valid on the state chain. This way, if the SE wishes to steal the funds\n> (which\n> > they still can), at least it is traceable/provable that this SE is not\n> > trustworthy as there is no evidence of a valid transfer for the funds\n> that have\n> > been stolen.\n> >\n> > Best,\n> > Nadav\n> >\n> > On Thu, Apr 2, 2020 at 7:22 PM Tom Trevethan via bitcoin-dev <\n> > bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> >     Thanks for all of the input and comments - I do now think that the\n> >     decrementing nSequence relative locktime backup system with kick-off\n> >     transaction is the way to go, including a fee penalty via CPFP to\n> >     disincentivise DoS, as suggested.\n> >     I have started a more detailed document specifying the proposed\n> protocol in\n> >     more detail: https://github.com/commerceblock/mercury/blob/master/\n> >     statechains.md which includes improvements to the transfer mechanism\n> (and\n> >     an explanation of how this can be used to transfer/novate positions\n> in\n> >     DLCs). Always happy to get more feedback or PRs.\n> >\n> >     Tom\n> >\n> >     On Tue, Mar 31, 2020 at 12:41 PM Tom Trevethan <\n> tom at commerceblock.com>\n> >     wrote:\n> >\n> >         Hi David,\n> >\n> >         Just for clarity, I left nChain over 2 years ago (having worked\n> there\n> >         since 2016). While there, I (along with other researchers) were\n> given\n> >         free rein to work on any ideas we wanted to. I had been\n> interested in\n> >         the scaling of Bitcoin off-chain, and this was one of several\n> things I\n> >         spent time on (including things like sidechains, pegs and\n> threshold\n> >         signatures). This patent application came out of an idea I had to\n> >         transfer ownership of UTXOs off-chain that has some similarities\n> to the\n> >         statechains proposal, which has shown there is interest and\n> demand for\n> >         this type of system.\n> >\n> >         Although I think the existence of this application is something\n> to be\n> >         mindful of, there are several important things to note:\n> >\n> >         1. Although there are similarities, the current ideas are\n> significantly\n> >         different to those in the application.\n> >         2. The key transfer protocol as described in the application is\n> not\n> >         secure (for several reasons, including as discussed above, by\n> Albert\n> >         and Bob etc.) - and a different mechanism is required.\n> >         3. Decrementing timelocks (as suggested in the application) are\n> prior\n> >         art (Decker-Wattenhofer 2015), and in any case any\n> implementation will\n> >         most likely use an 'invalidation tree' relative locktime backup\n> >         mechanism for open-ended UTXOs.\n> >         4. The patent application has not been granted (it was made in\n> May\n> >         2017) and the international search report rejected it on the\n> grounds of\n> >         prior art.\n> >\n> >         Tom\n> >\n> >         On Tue, Mar 31, 2020 at 11:36 AM David A. Harding <dave at dtrt.org\n> >\n> >         wrote:\n> >\n> >             On Wed, Mar 25, 2020 at 01:52:10PM +0000, Tom Trevethan via\n> >             bitcoin-dev wrote:\n> >             > Hi all,\n> >             >\n> >             > We are starting to work on an implementation of the\n> statechains\n> >             concept (\n> >             > https://medium.com/@RubenSomsen/\n> >\n>  statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39),\n> >             >\n> >             > [...]\n> >             > There are two main modifications we are looking at:\n> >             > [...]\n> >             >\n> >             > 2. Replacing the 2-of-2 multisig output (paying to\n> statechain\n> >             entity SE key\n> >             > and transitory key) with a single P2(W)PKH output where the\n> >             public key\n> >             > shared between the SE and the current owner. The SE and the\n> >             current owner\n> >             > can then sign with a 2-of-2 ECDSA MPC.\n> >\n> >             Dr. Trevethan,\n> >\n> >             Would you be able to explain how your proposal to use\n> statechains\n> >             with\n> >             2P-ECDSA relates to your patent assigned to nChain Holdings\n> for\n> >             \"Secure\n> >             off-chain blockchain transactions\"?[1]\n> >\n> >                 [1] https://patents.google.com/patent/US20200074464A1\n> >\n> >             Here are some excerpts from the application that caught my\n> >             attention in\n> >             the context of statechains in general and your proposal to\n> this\n> >             list in\n> >             particular:\n> >\n> >             > an exchange platform that is trusted to implement and\n> operate the\n> >             > transaction protocol, without requiring an on-chain\n> transaction.\n> >             The\n> >             > off-chain transactions enable one computer system to\n> generate\n> >             multiple\n> >             > transactions that are recordable to a blockchain in\n> different\n> >             > circumstances\n> >             >\n> >             > [...]\n> >             >\n> >             > at least some of the off-chain transactions are valid for\n> >             recording on\n> >             > the blockchain even in the event of a catastrophic failure\n> of the\n> >             > exchange (e.g., exchange going permanently off-line or\n> loosing\n> >             key\n> >             > shares).\n> >             >\n> >             > [...]\n> >             >\n> >             > there may be provided a computer readable storage medium\n> >             including a\n> >             > two-party elliptic curve digital signature algorithm\n> (two-party\n> >             ECDSA)\n> >             > script comprising computer executable instructions which,\n> when\n> >             > executed, configure a processor to perform functions of a\n> >             two-party\n> >             > elliptic curve digital signature algorithm described\n> herein.\n> >             >\n> >             > [...]\n> >             >\n> >             > In this instance the malicious actor would then also have\n> to\n> >             collude\n> >             > with a previous owner of the funds to recreate the full\n> key.\n> >             Because\n> >             > an attack requires either the simultaneous theft of both\n> exchange\n> >             and\n> >             > depositor keys or collusion with previous legitimate\n> owners of\n> >             funds,\n> >             > the opportunities for a malicious attacker to compromise\n> the\n> >             exchange\n> >             > platform are limited.\n> >\n> >             Thank you,\n> >\n> >             -Dave\n> >\n> >     _______________________________________________\n> >     bitcoin-dev mailing list\n> >     bitcoin-dev at lists.linuxfoundation.org\n> >     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n> > !DSPAM:5e87670a231323960034969!\n>\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n> >\n> > !DSPAM:5e87670a231323960034969!\n>\n> --\n> Cheers, Bob McElrath\n>\n> \"For every complex problem, there is a solution that is simple, neat, and\n> wrong.\"\n>     -- H. L. Mencken\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200405/1cb30267/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Statechain implementations",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Tom Trevethan",
                "Nadav Kohen",
                "Bob McElrath"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 44168
        }
    },
    {
        "title": "[bitcoin-dev] Deterministic Entropy From BIP32 Keychains",
        "thread_messages": [
            {
                "author": "Rodolfo Novak",
                "date": "2020-04-06T17:36:17",
                "message_text_only": "Hello,\n\nWe are planning on implementing the [Deterministic Entropy From BIP32 Keychains](https://gist.github.com/ethankosakovsky/268c52f018b94bea29a6e809381c05d6) BIP on Coldcard.\n\nIs there a BIP number planned to be assigned and is there any review of this BIP yet?\n\nRegards,\n\n\n\u211d.\n\nRodolfo Novak  ||  Coinkite Inc.  ||  GPG: B444CDDA\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200406/f1ab4174/attachment.sig>"
            },
            {
                "author": "Adam Back",
                "date": "2020-04-06T20:02:00",
                "message_text_only": "I looked at it and consider the crypto choices reasonable and reusing\nexisting bitcoin dependencies in library crypto building blocks\nmostly.\n\nFor myself i think the use-case of having an offline seed manager that\ncan be backed up once, and support multiple wallets, including ones\ncreated after the backup improves a practical and under-addressed\nproblem for many users and businesses.\n\nThe fact that the interface between an offline seed manager and a\nhardware or software wallet can be a bip39 mnemonic seed is convenient\nand an improvement over using custom derivation paths for practical\nuse given the complexity of custom paths and variable support for them\nin wallets.\n\nAdam\n\nOn Mon, 6 Apr 2020 at 20:43, Rodolfo Novak via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Hello,\n>\n> We are planning on implementing the [Deterministic Entropy From BIP32 Keychains](https://gist.github.com/ethankosakovsky/268c52f018b94bea29a6e809381c05d6) BIP on Coldcard.\n>\n> Is there a BIP number planned to be assigned and is there any review of this BIP yet?\n>\n> Regards,\n>\n>\n> \u211d.\n>\n> Rodolfo Novak  ||  Coinkite Inc.  ||  GPG: B444CDDA\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Christopher Allen",
                "date": "2020-04-06T21:45:37",
                "message_text_only": "Although I believe that there needs to be a review by a cryptographic\nengineering expert (ideally Pieter Wuille, who may have to hold his nose to\ngive it a pragmatic review) and I believe such a review will likely some\nsuggest some improvements, I do think something in this area should be done.\n\nFor instance with the offline tool #LetheKit\nhttps://github.com/BlockchainCommons/bc-lethe-kit, you could go to your\nvault, input your BIP39 from an offline titanium key or SLIP39 Shamir\nshards, and then derive a child key in BIP39 form that can be delivered via\nQR from the air-gapped LetheKit to another device you take away.\n\n\u2014 Christopher Allen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200406/2956c78b/attachment.html>"
            },
            {
                "author": "Ethan Kosakovsky",
                "date": "2020-04-11T00:09:51",
                "message_text_only": "Yes, I plan to submit as a BIP. I was just letting it sit for a while for others to consider.\n\nI was also considering to split the BIP into two. One for the the entropy derivation, and the Applications section would be another BIP. This would be akin to how BIP32 is the basis for derivation schemes like BIP39, and BIP44, BIP49 etc.\n\nEthan\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Tuesday, April 7, 2020 1:36 AM, Rodolfo Novak <rodolfo at coinkite.com> wrote:\n\n> Hello,\n>\n> We are planning on implementing the Deterministic Entropy From BIP32 Keychains BIP on Coldcard.\n>\n> Is there a BIP number planned to be assigned and is there any review of this BIP yet?\n>\n> Regards,\n>\n> \u211d.\n>\n> Rodolfo Novak || Coinkite Inc. || GPG: B444CDDA"
            },
            {
                "author": "Ethan Kosakovsky",
                "date": "2020-04-16T17:53:38",
                "message_text_only": "I have opened a BIP PR at https://github.com/bitcoin/bips/pull/910\n\nand also created a Python library with test vectors referenced in the BIP text. I am still unsure if I should or shouldnt split the BIP's \"Applications\" into a separate BIP or leave in the current BIP.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Monday, April 6, 2020 5:36 PM, Rodolfo Novak <rodolfo at coinkite.com> wrote:\n\n> Hello,\n>\n> We are planning on implementing the Deterministic Entropy From BIP32 Keychains BIP on Coldcard.\n>\n> Is there a BIP number planned to be assigned and is there any review of this BIP yet?\n>\n> Regards,\n>\n> \u211d.\n>\n> Rodolfo Novak || Coinkite Inc. || GPG: B444CDDA"
            }
        ],
        "thread_summary": {
            "title": "Deterministic Entropy From BIP32 Keychains",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Adam Back",
                "Rodolfo Novak",
                "Christopher Allen",
                "Ethan Kosakovsky"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 4150
        }
    },
    {
        "title": "[bitcoin-dev] On-chain vaults prototype",
        "thread_messages": [
            {
                "author": "Bryan Bishop",
                "date": "2020-04-13T15:50:00",
                "message_text_only": "Hi,\n\nHigh-security protection against theft depends on multisig and timelocks,\nbut more tools are possible. Last year I discussed one method where\nwould-be attackers are discouraged by specially designed vault covenants\n[1] allowing re-vaulting transactions, where a watchtower can override a\nproposed delayed-spend transaction during a public observation delay\nperiod. Splitting coins into multiple timelocked UTXOs can give a user time\nto react to theft of a much smaller portion of the total amount.\n\nIf better and better cold storage designs can be shared openly, reviewed,\nand used easily, this can increase security for all bitcoin users. When the\nunderstanding among the general public includes \"bitcoin is extremely\nvaluable\" then it becomes more urgent that the understanding in the general\npublic also includes \"bitcoin cold storage security is impenetrable\".\n\nToday I would like to announce the release of an open-source prototype for\non-chain bitcoin vaults using pre-signed transactions and secure key\ndeletion. I am hoping for feedback and discussion around these concepts. To\nbe very clear, this is a prototype and not fit for production use.\n\nhttps://github.com/kanzure/python-vaults\n\nDuring the delay period, this design allows initiation of a recovery or\nclawback which triggers funds being moved to deeper cold storage.\n\nReviewers: Generally interested in your feedback about the concept. My hope\nis that the prototype and its source code helps answer some questions about\nhow this might work. I would suggest to also pay close attention to the\nscript templates for both outputs and witnesses.\n\nAlso included is an implementation of this same bitcoin vault using bip119\nOP_CHECKTEMPLATEVERIFY.\n\nI have also been working with Spencer Hommel, Jacob Swambo, and Bob\nMcElrath on two related manuscripts, one addressing the topic of bitcoin\ncovenants and the other addressing the topic of vaults based on pre-signed\ntransactions. As part of that project, there is a separate vault\nimplementation that is already available on Fidelity's github account [2].\nA more bare bones implementation of python vaults can be found at [3].\nAlso, Kevin Loaec has an unrelated implementation using pre-signed\ntransactions.\n\nThank you,\n\n- Bryan\n\n[1]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017231.html\n[2] https://github.com/fmr-llc/Vault-mbed\n[3] https://github.com/JSwambo/bitcoin-vault\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200413/0e1cf9c0/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "On-chain vaults prototype",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Bryan Bishop"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2597
        }
    },
    {
        "title": "[bitcoin-dev] RBF Pinning with Counterparties and Competing Interest",
        "thread_messages": [
            {
                "author": "Matt Corallo",
                "date": "2020-04-21T02:43:14",
                "message_text_only": "[Hi bitcoin-dev, in lightning-land we recently discovered some quite frustrating issues which I thought may merit\nbroader discussion]\n\nWhile reviewing the new anchor outputs spec [1] last week, I discovered it introduced a rather nasty ability for a user\nto use RBF Pinning to steal in-flight HTLCs which are being enforced on-chain. Sadly, Antoine pointed out that this is\nan issue in today's light as well, though see [2] for qualifications. After some back-and-forth with a few other\nlightning folks, it seems clear that there is no easy+sane fix (and the practicality of exploitation today seems\nincredibly low), so soliciting ideas publicly may be the best step forward.\n\nI've included lots of background for those who aren't super comfortable with lightning's current design, but if you\nalready know it well, you can skip at least background 1 & 2.\n\nBackground - Lightning's Transactions (you can skip this)\n=====================================\n\nAs many of you likely know, lightning today does all its update mechanics through:\n a) a 2-of-2 multisig output, locking in the channel,\n b) a \"commitment transaction\", which spends that output: i) back to its owners, ii) to \"HTLC outputs\",\n c) HTLC transactions which spend the relevant commitment transaction HTLC outputs.\n\nThis somewhat awkward third layer of transactions is required to allow HTLC timeouts to be significantly lower than the\ntime window during which a counterparty may be punished for broadcasting a revoked state. That is to say, you want to\n\"lock-in\" the resolution of an HTLC output (ie by providing the hash lock preimage on-chain) by a fixed block height\n(likely a few hours from the HTLC creation), but the punishment mechanism needs to occur based on a sequence height\n(possibly a day or more after transaction broadcast).\n\nAs Bitcoin has no covanents, this must occur using pre-signed transactions - namely \"HTLC-Success\" and \"HTLC-Timeout\"\ntransactions, which finalize the resolution of an HTLC, but have a sequence-lock for some time during which the funds\nmay be taken if they had previously been revoked. To avoid needless delays, if the counterparty which did *not*\nbroadcast the commitment transaction wishes to claim the HTLC value, they may do so immediately (as there is no reason\nto punish the non-broadcaster for having *not* broadcasted a revoked state). Thus, we have four possible HTLC\nresolutions depending on the combination of which side broadcast the HTLC and which side sent the HTLC (ie who can claim\nit vs who can claim it after time-out):\n\n 1) pre-signed HTLC-Success transaction, providing the preimage in the witness and sent to an output which is sequence-\n    locked for some time to provide the non-broadcasting side the opportunity to take the funds,\n 2) pre-signed HTLC-Timeout transaction, time-locked to N, providing no preimage, but with a similar sequence lock and\n    output as above,\n 3) non-pre-signed HTLC claim, providing the preimage in the witness and unencumbered by the broadcaster's signature,\n 4) non-pre-signed HTLC timeout, OP_CLTV to N, and similarly unencumbered.\n\nBackground 2 - RBF Pinning (you can skip this)\n==========================\n\nBitcoin Core's general policy on RBF transactions is that if a counterparty (either to the transaction, eg in lightning,\nor not, eg a P2P node which sees the transaction early) can modify a transaction, especially if they can add an input or\noutput, they can prevent it from confirming in a world where there exists a mempool (ie in a world where Bitcoin works).\nWhile this is somewhat unintuitive, there are any number of good anti-DoS reasons for this, eg:\n * (ok, this is a bad reason, but) a child transaction could be marked 'non-RBF', which would mean allowing the parent\n   be RBF'd would violate the assumptions those who look at the RBF opt-in marking make,\n * a parent may be very large, but low feerate - this requires the RBF attempt to \"pay for its own relay\" and include a\n   large absolute fee just to get into the mempool,\n * one of the various package size limits is at its maximum, and depending on the structure of the package the\n   computational complexity of calculation evictions may be more than we want to do for a given transaction.\n\nBackground 3 - \"The RBF Carve-Out\" (you can skip this)\n==================================\n\nIn today's lightning, we have a negotiation of what we expect the future feerate to be when one party goes to close the\nchannel. All the pre-signed transactions above are constructed with this fee-rate in mind, and, given they are all\npre-signed, adding additional fee to them is not generally an option. This is obviously a very maddening prediction\ngame, especially when the security consequences for negotiating a value which is wrong may allow your counterparty to\nbroadcast and time out HTLCs which you otherwise have the preimage for. To remove this quirk, we came up with an idea a\nyear or two back now called \"anchor outputs\" (aka the RBF carve-out for those in Bitcoin-land) - a neat trick to allow\nboth counterparties to add fees to a transaction which is being broadcast without getting into the quagmire that is RBF\npinning. Specifically, we added a rule to Bitcoin Core which allows for transactions which have a narrow structure to be\nCPFP'd trivially by either counterparty, irrespective of what the other counterparty does! In order to meet this\nstructure, the commitment transaction (b) must have two (potentially-)additional outputs, each which only one side can\nspend, and every other output must have a CSV lock associated with it. This is great and there is (finally) movement to\ndeploy this.\n\nRBF Pinning HTLC Transactions (aka \"Oh, wait, I can steal funds, how, now?\")\n=============================\n\nYou'll note that in the discussion of RBF pinning we were pretty broad, and that that discussion seems to in fact cover\nour HTLC outputs, at least when spent via (3) or (4). It does, and in fact this is a pretty severe issue in today's\nlightning protocol [2]. A lightning counterparty (C, who received the HTLC from B, who received it from A) today could,\nif B broadcasts the commitment transaction, spend an HTLC using the preimage with a low-fee, RBF-disabled transaction.\nAfter a few blocks, A could claim the HTLC from B via the timeout mechanism, and then after a few days, C could get the\nHTLC-claiming transaction mined via some out-of-band agreement with a small miner. This leaves B short the HTLC value.\n\nYou'll note that B would be just fine if they had a way to safely monitor the global mempool, and while this seems like\na prudent mitigation for lightning implementations to deploy today, it is itself a quagmire of complexity, especially\nwhen you consider differences in relay policy during an upgrade cycle and how those may effect propagation through the\nP2P network. Further, this is a really obnoxious assumption to hoist onto lightning nodes - having an active full node\nwith an in-sync mempool is a lot more CPU, bandwidth, and complexity than most lightning users were expecting to face.\n\nIt seems highly likely we could come up with some kind of variant of of the RBF Carve-Out to solve this problem, though\nprobably much more specific to this particular transaction structure - imagine a rule which allowed B to RBF C's low-fee\nHTLC claim transaction, without ever seeing it. This could be accomplished by locking down the transaction types in (3)\nand (4) by pre-signing them (just, like (1) and (2)) and then using some kind of policy rule to allow only the addition\nof additional confirmed inputs and one (small) output. This would mean that B knows that either C's transaction has high\nfee, or B's reasonably-higher-fee transaction will meet the RBF rules and replace C's maliciousness.\n\nWhile the original RBF Carve-Out was a little awkward, its structure was sufficiently generic that other off-chain\nprotocols could reasonably (need to) take advantage of it, however a rule to address this issue seems like it would need\nto be highly tailored to lightning, which doesn't seem acceptable (there appears to be a way to shoehorn the existing\ncarve-out, but it results in a ton of extra on-chain volume).\n\nStrategies involving full-RBF for transactions not at the top of the mempool, (slow-)full-mempool-sync allowing\nmempool-total-fee decreases and relaxations of the RBF rules would be welcome, but without a ton of legwork to include\nthings like package relay I'm not convinced they would suffice. This of course doesn't even account for the possibility\nof similar issues given rely policy differences.\n\nPS For Lightning-Dev Folks (aka \"An Alternative Anchor Proposal\")\n==========================\n\nGiven the anchor outputs proposal seeks to expand lightning's security in a world where Bitcoin is running at\nsteady-state and the mempool reliably has transactions in it, not fixing this issue seems to render the whole exercise\nsomewhat useless (not to mention that the current design makes this attack more obvious and provides several alternative\npaths to exploitation).\n\nAn alternative, albeit not ideal anchor outputs proposal is as follows:\n\n * Instead of making the HTLC output spending more free-form with SIGHASH_ANYONECAN_PAY|SIGHASH_SINGLE, we clearly need\n   to go the other direction - all HTLC output spends need to be pre-signed.\n * Sadly, and this really hurts from an on-chain-tx-size perspective, we have to include anchor outputs in the HTLC\n   transactions (intuitively I think all of them, but at least HTLC-fulfilling transactions definitely).\n * Our poor B, being exploited, above, will attempt to spend their anchor output with a CPFP even if they aren't sure C\n   has broadcast the HTLC-Success transaction! This is fine as B already knows the txid, and just wants to learn whats\n   in the witness (assuming there is one).\n\nFor those from bitcoin-dev still reading who are thinking \"blah, you clearly don't need anything else, you have a\nsolution!\" we're talking about extra outputs out the wazoo for hopefully-unnecessary edge cases involving transactions\nentering the mempool which a user wants to avoid confirming! This severely cuts into the lowest-value HTLCs which can be\nsent \"safely\" and adds a significant social cost of extra low-value, possibly-uneconomical outputs in the chain.\n\nStill, lacking a better idea, and with a strong desire to make lightning's security more practical in a world where\nBitcoin miners are paid to operate, we should probably start considering moving forward with this.\n\nThanks for reading,\nMatt\n\n[1] https://github.com/lightningnetwork/lightning-rfc/pull/688\n\n[2] I'll note that while it is a \"severe issue\", given the general issues with fee-prediction described in background 3,\nits pretty hard to argue its really in the scope of the security model of lightning today. If there were an easy fix to\nit, we'd have deployed it by now in response to private discussion, but, sadly, there is not."
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2020-04-22T04:13:34",
                "message_text_only": "Hi Matt,\n\n\n> While this is somewhat unintuitive, there are any number of good anti-DoS\n> reasons for this, eg:\n\nNone of these really strikes me as \"good\" reasons for this limitation, which\nis at the root of this issue, and will also plague any more complex Bitcoin\ncontracts which rely on nested trees of transaction to confirm (CTV, Duplex,\nchannel factories, etc). Regarding the various (seemingly arbitrary) package\nlimits it's likely the case that any issues w.r.t computational complexity\nthat may arise when trying to calculate evictions can be ameliorated with\nbetter choice of internal data structures.\n\nIn the end, the simplest heuristic (accept the higher fee rate package) side\nsteps all these issues and is also the most economically rationale from a\nminer's perspective. Why would one prefer a higher absolute fee package\n(which could be very large) over another package with a higher total _fee\nrate_?\n\n> You'll note that B would be just fine if they had a way to safely monitor\nthe\n> global mempool, and while this seems like a prudent mitigation for\n> lightning implementations to deploy today, it is itself a quagmire of\n> complexity\n\nIs it really all that complex? Assuming we're talking about just watching\nfor a certain script template (the HTLC scipt) in the mempool to be able to\npull a pre-image as soon as possible. Early versions of lnd used the mempool\nfor commitment broadcast detection (which turned out to be a bad idea so we\nremoved it), but at a glance I don't see why watching the mempool is so\ncomplex.\n\n> Further, this is a really obnoxious assumption to hoist onto lightning\n> nodes - having an active full node with an in-sync mempool is a lot more\n> CPU, bandwidth, and complexity than most lightning users were expecting to\n> face.\n\nThis would only be a requirement for Lightning nodes that seek to be a part\nof the public routing network with a desire to _forward_ HTLCs. This isn't\ndoesn't affect laptops or mobile phones which likely mostly have private\nchannels and don't participate in HTLC forwarding. I think it's pretty\nreasonable to expect a \"proper\" routing node on the network to be backed by\na full-node. The bandwidth concern is valid, but we'd need concrete numbers\nthat compare the bandwidth over head of mempool awareness (assuming the\nlatest and greatest mempool syncing) compared with the overhead of the\nchannel update gossip and gossip queries over head which LN nodes face today\nas is to see how much worse off they really would be.\n\nAs detailed a bit below, if nodes watch the mempool, then this class of\nattack assuming the anchor output format as described in the open\nlightning-rfc PR is mitigated. At a glance, watching the mempool seems like\na far less involved process compared to modifying the state machine as its\ndefined today. By watching the mempool and implementing the changes in\n#lightning-rfc/688, then this issue can be mitigated _today_. lnd 0.10\ndoesn't yet watch the mempool (but does include anchors [1]), but unless I'm\nmissing something it should be pretty straight forward to add which mor or\nless\nresolves this issue all together.\n\n> not fixing this issue seems to render the whole exercise somewhat useless\n\nDepends on if one considers watching the mempool a fix. But even with that a\nbase version of anchors still resolves a number of issues including:\neliminating the commitment fee guessing game, allowing users to pay less on\nforce close, being able to coalesce 2nd level HTLC transactions with the\nsame CLTV expiry, and actually being able to reliably enforce multi-hop HTLC\nresolution.\n\n> Instead of making the HTLC output spending more free-form with\n> SIGHASH_ANYONECAN_PAY|SIGHASH_SINGLE, we clearly need to go the other\n> direction - all HTLC output spends need to be pre-signed.\n\nI'm not sure this is actually immediately workable (need to think about it\nmore). To see why, remember that the commit_sig message includes HTLC\nsignatures for the _remote_ party's commitment transaction, so they can\nspend the HTLCs if they broadcast their version of the commitment (force\nclose). If we don't somehow also _gain_ signatures (our new HTLC signatures)\nallowing us to spend HTLCs on _their_ version of the commitment, then if\nthey broadcast that commitment (without revoking), then we're unable to\nredeem any of those HTLCs at all, possibly losing money.\n\nIn an attempt to counteract this, we might say ok, the revoke message also\nnow includes HTLC signatures for their new commitment allowing us to spend\nour HTLCs. This resolves things in a weaker security model, but doesn't\naddress the issue generally, as after they receive the commit_sig, they can\nbroadcast immediately, again leaving us without a way to redeem our HTLCs.\n\nI'd need to think about it more, but it seems that following this path would\nrequire an overhaul in the channel state machine to make presenting a new\ncommitment actually take at least _two phases_ (at least a full round trip).\nThe first phase would tender the commitment, but render them unable to\nbroadcast it. The second phase would then <insert something something\nscriptless scripts here> enter a new sub-protocol which upon conclusion,\ngives the commitment proposer valid HTLC signatures, and gives the responder\nwhat they need to be able to broadcast their commitment and claim their\nHTCLs in an atomic manner.\n\n-- Laolu\n\n[1]: https://github.com/lightningnetwork/lnd/pull/3821\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200421/6cae2a06/attachment-0001.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2020-04-22T11:51:30",
                "message_text_only": "On Tue, Apr 21, 2020 at 09:13:34PM -0700, Olaoluwa Osuntokun wrote:\n> On Mon, Apr 20, 2020 at 10:43:14PM -0400, Matt Corallo via Lightning-dev wrote:\n> > While this is somewhat unintuitive, there are any number of good anti-DoS\n> > reasons for this, eg:\n> \n> None of these really strikes me as \"good\" reasons for this limitation\n> [...]\n> In the end, the simplest heuristic (accept the higher fee rate\n> package) side steps all these issues and is also the most economically\n> rationale from a miner's perspective. \n\nI think it's important to remember than mempool behavior affects not\njust miners but also relay nodes.  Miner costs, such as bandwidth usage,\ncan be directly offset by their earned block rewards, so miners can be\nmuch more tolerant of wasted bandwidth than relay nodes who receive no\ndirect financial compensation for the processing and relay of\nunconfirmed transactions.[1]\n\n> Why would one prefer a higher absolute fee package (which could be\n> very large) over another package with a higher total _fee rate_?\n\nTo avoid the excessive wasting of bandwidth.  Bitcoin Core's defaults\nrequire each replacement pay a feerate of 10 nBTC/vbyte over an existing\ntransaction or package, and the defaults also allow transactions or\npackages up to 100,000 vbytes in size (~400,000 bytes).  So, without\nenforcement of BIP125 rule 3, an attacker starting at the minimum\ndefault relay fee also of 10 nBTC/vbyte could do the following:\n\n- Create a ~400,000 bytes tx with feerate of 10 nBTC/vbyte (1 mBTC total\n  fee)\n\n- Replace that transaction with 400,000 new bytes at a feerate of 20\n  nBTC/vbyte (2 mBTC total fee)\n\n- Perform 998 additional replacements, each increasing the feerate by 10\n  nBTC/vbyte and the total fee by 1 mBTC, using a total of 400 megabytes\n  (including the original transaction and first replacement) to\n  ultimately produce a transaction with a feerate of 10,000 nBTC/vbyte\n  (1 BTC total fee)\n\n- Perform one final replacement of the latest 400,000 byte transaction\n  with a ~200-byte (~150 vbyte) 1-in, 1-out P2WPKH transaction that pays\n  a feerate of 10,010 nBTC/vbyte (1.5 mBTC total fee)\n\nAssuming 50,000 active relay nodes and today's BTC price of ~$7,000\nUSD/BTC, the above scenario would allow an attacker to waste a\ncollective 20 terabytes of network bandwidth for a total fee cost of\n$10.50.  And, of course, the attacker could run multiple attacks of this\nsort in parallel, quickly swamping the network.\n\nTo use the above concrete example to repeat the point made at the\nbeginning of this email: miners might be willing to accept the waste of\n400 MB of bandwidth in order to gain a $10.50 fee, but I think very few\nrelay nodes could function for long under an onslaught of such behavior.\n\n-Dave\n\n[1] The reward to relay nodes of maintaining the public relay network is\n    that it helps protect against miner centralization.  If there was no\n    public relay network, users would need to submit transactions\n    directly to miners or via a privately-controlled relay network.\n    Users desiring timely confirmation (and operators of private relay\n    networks) would have a large incentive to get transactions to the\n    largest miners but only a small incentive to get the transaction to\n    the smaller miners, increasing the economies of scale in mining and\n    furthering centralization.\n\n    Although users of Bitcoin benefit by reducing mining centralization\n    pressure, I don't think we can expect most users to be willing to\n    bear large costs in defense of benefits which are largely intangible\n    (until they're gone), so we must try to keep the cost of operating a\n    relay node within a reasonable margin of the cost of operating a\n    minimal-bandwidth blocks-only node.\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200422/cbf63335/attachment.sig>"
            },
            {
                "author": "Rusty Russell",
                "date": "2020-04-27T21:26:19",
                "message_text_only": "\"David A. Harding via bitcoin-dev\" <bitcoin-dev at lists.linuxfoundation.org> writes:\n> To avoid the excessive wasting of bandwidth.  Bitcoin Core's defaults\n> require each replacement pay a feerate of 10 nBTC/vbyte over an existing\n> transaction or package, and the defaults also allow transactions or\n> packages up to 100,000 vbytes in size (~400,000 bytes).  So, without\n> enforcement of BIP125 rule 3, an attacker starting at the minimum\n> default relay fee also of 10 nBTC/vbyte could do the following:\n>\n> - Create a ~400,000 bytes tx with feerate of 10 nBTC/vbyte (1 mBTC total\n>   fee)\n>\n> - Replace that transaction with 400,000 new bytes at a feerate of 20\n>   nBTC/vbyte (2 mBTC total fee)\n>\n> - Perform 998 additional replacements, each increasing the feerate by 10\n>   nBTC/vbyte and the total fee by 1 mBTC, using a total of 400 megabytes\n>   (including the original transaction and first replacement) to\n>   ultimately produce a transaction with a feerate of 10,000 nBTC/vbyte\n>   (1 BTC total fee)\n>\n> - Perform one final replacement of the latest 400,000 byte transaction\n>   with a ~200-byte (~150 vbyte) 1-in, 1-out P2WPKH transaction that pays\n>   a feerate of 10,010 nBTC/vbyte (1.5 mBTC total fee)\n\nTo be fair, if the feerate you want is 100x the minimum permitted, you\ncan always use 100x as much bandwidth as necessary without extra cost.\nIf everyone (or some major tx producers) were to do that, it would suck.\n\nTo fix this properly, you really need to agressively delay processing\n(thus propagation) of transactions which aren't likely to be in the next\n(few?) blocks.  This is a more miner incentive compatible scheme.\n\nHowever, I realize this is a complete rewrite of bitcoind's logic, and\nI'm not volunteering to do it!\n\nCheers,\nRusty,"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-04-22T16:50:46",
                "message_text_only": "A few replies inline.\n\nOn 4/22/20 12:13 AM, Olaoluwa Osuntokun wrote:\n> Hi Matt,\n> \n> \n>> While this is somewhat unintuitive, there are any number of good anti-DoS\n>> reasons for this, eg:\n> \n> None of these really strikes me as \"good\" reasons for this limitation, which\n> is at the root of this issue, and will also plague any more complex Bitcoin\n> contracts which rely on nested trees of transaction to confirm (CTV, Duplex,\n> channel factories, etc). Regarding the various (seemingly arbitrary) package\n> limits it's likely the case that any issues w.r.t computational complexity\n> that may arise when trying to calculate evictions can be ameliorated with\n> better choice of internal data structures.\n> \n> In the end, the simplest heuristic (accept the higher fee rate package) side\n> steps all these issues and is also the most economically rationale from a\n> miner's perspective. Why would one prefer a higher absolute fee package\n> (which could be very large) over another package with a higher total _fee\n> rate_?\n\nThis seems like a somewhat unnecessary drive-by insult of a project you don't contribute to, but feel free to start with\na concrete suggestion here :).\n\n>> You'll note that B would be just fine if they had a way to safely monitor the\n>> global mempool, and while this seems like a prudent mitigation for\n>> lightning implementations to deploy today, it is itself a quagmire of\n>> complexity\n> \n> Is it really all that complex? Assuming we're talking about just watching\n> for a certain script template (the HTLC scipt) in the mempool to be able to\n> pull a pre-image as soon as possible. Early versions of lnd used the mempool\n> for commitment broadcast detection (which turned out to be a bad idea so we\n> removed it), but at a glance I don't see why watching the mempool is so\n> complex.\n\nBecause watching your own mempool is not guaranteed to work, and during upgrade cycles that include changes to the\npolicy rules an attacker could exploit your upgraded/non-upgraded status to perform the same attack.\n\n>> Further, this is a really obnoxious assumption to hoist onto lightning\n>> nodes - having an active full node with an in-sync mempool is a lot more\n>> CPU, bandwidth, and complexity than most lightning users were expecting to\n>> face.\n> \n> This would only be a requirement for Lightning nodes that seek to be a part\n> of the public routing network with a desire to _forward_ HTLCs. This isn't\n> doesn't affect laptops or mobile phones which likely mostly have private\n> channels and don't participate in HTLC forwarding. I think it's pretty\n> reasonable to expect a \"proper\" routing node on the network to be backed by\n> a full-node. The bandwidth concern is valid, but we'd need concrete numbers\n> that compare the bandwidth over head of mempool awareness (assuming the\n> latest and greatest mempool syncing) compared with the overhead of the\n> channel update gossip and gossip queries over head which LN nodes face today\n> as is to see how much worse off they really would be.\n\nIf mempool-watching were practical, maybe, though there are a number of folks who are talking about designing\npartially-offline local lightning hubs which would be rendered impractical.\n\n> As detailed a bit below, if nodes watch the mempool, then this class of\n> attack assuming the anchor output format as described in the open\n> lightning-rfc PR is mitigated. At a glance, watching the mempool seems like\n> a far less involved process compared to modifying the state machine as its\n> defined today. By watching the mempool and implementing the changes in\n> #lightning-rfc/688, then this issue can be mitigated _today_. lnd 0.10\n> doesn't yet watch the mempool (but does include anchors [1]), but unless I'm\n> missing something it should be pretty straight forward to add which mor or less\n> resolves this issue all together.\n> \n>> not fixing this issue seems to render the whole exercise somewhat useless\n> \n> Depends on if one considers watching the mempool a fix. But even with that a\n> base version of anchors still resolves a number of issues including:\n> eliminating the commitment fee guessing game, allowing users to pay less on\n> force close, being able to coalesce 2nd level HTLC transactions with the\n> same CLTV expiry, and actually being able to reliably enforce multi-hop HTLC\n> resolution.\n> \n>> Instead of making the HTLC output spending more free-form with\n>> SIGHASH_ANYONECAN_PAY|SIGHASH_SINGLE, we clearly need to go the other\n>> direction - all HTLC output spends need to be pre-signed.\n> \n> I'm not sure this is actually immediately workable (need to think about it\n> more). To see why, remember that the commit_sig message includes HTLC\n> signatures for the _remote_ party's commitment transaction, so they can\n> spend the HTLCs if they broadcast their version of the commitment (force\n> close). If we don't somehow also _gain_ signatures (our new HTLC signatures)\n> allowing us to spend HTLCs on _their_ version of the commitment, then if\n> they broadcast that commitment (without revoking), then we're unable to\n> redeem any of those HTLCs at all, possibly losing money.\n\nHmm, maybe the proposal wasn't clear. The idea isn't to add signatures to braodcasted transactions, but instead to CPFP\na maybe-broadcasted transaction by sending a transaction which spends it and seeing if it is accepted. You only need to\nknow the transaction's exact format (ie txid, which we do, since we sent a signature for it long ago) to do this, you\ndon't have to actually *have* the fully-signed transaction (and you don't).\n\n> In an attempt to counteract this, we might say ok, the revoke message also\n> now includes HTLC signatures for their new commitment allowing us to spend\n> our HTLCs. This resolves things in a weaker security model, but doesn't\n> address the issue generally, as after they receive the commit_sig, they can\n> broadcast immediately, again leaving us without a way to redeem our HTLCs.\n> \n> I'd need to think about it more, but it seems that following this path would\n> require an overhaul in the channel state machine to make presenting a new\n> commitment actually take at least _two phases_ (at least a full round trip).\n> The first phase would tender the commitment, but render them unable to\n> broadcast it. The second phase would then <insert something something\n> scriptless scripts here> enter a new sub-protocol which upon conclusion,\n> gives the commitment proposer valid HTLC signatures, and gives the responder\n> what they need to be able to broadcast their commitment and claim their\n> HTCLs in an atomic manner.\n> \n> -- Laolu\n> \n> [1]: https://github.com/lightningnetwork/lnd/pull/3821"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2020-04-22T23:13:01",
                "message_text_only": "> This seems like a somewhat unnecessary drive-by insult of a project you\n> don't contribute to, but feel free to start with a concrete suggestion\n> here :).\n\nThis wasn't intended as an insult at all. I'm simply saying if there's\nconcern about worst case eviction/replacement, optimizations likely exist.\nOther developers that are interested in more complex multi-transaction\ncontracts have realized this as well, and there're various open PRs that\nattempt to propose such optimizations [1].\n\n> Hmm, maybe the proposal wasn't clear. The idea isn't to add signatures to\n> braodcasted transactions, but instead to CPFP a maybe-broadcasted\n> transaction by sending a transaction which spends it and seeing if it is\n> accepted\n\nSorry I still don't follow. By \"we clearly need to go the other direction -\nall HTLC output spends need to be pre-signed.\", you don't mean that the HTLC\nspends of the non-broadcaster also need to be an off-chain 2-of-2 multi-sig\ncovenant? If the other party isn't restricted w.r.t _how_ they can spend the\noutput (non-rbf'd, ect), then I don't see how that addresses anything.\n\nAlso see my mail elsewhere in the thread that the other party is actually\nforced to spend their HTLC output using an RBF-replaceable transaction. With\nthat, I think we're all good here? In the end both sides have the ability to\nraise the fee rate of their spending transactions with the highest winning.\nAs long as one of them confirms within the CLTV-delta, then everyone is\nmade whole.\n\n\n[1]: https://github.com/bitcoin/bitcoin/pull/18191\n\n\nOn Wed, Apr 22, 2020 at 9:50 AM Matt Corallo <lf-lists at mattcorallo.com>\nwrote:\n\n> A few replies inline.\n>\n> On 4/22/20 12:13 AM, Olaoluwa Osuntokun wrote:\n> > Hi Matt,\n> >\n> >\n> >> While this is somewhat unintuitive, there are any number of good\n> anti-DoS\n> >> reasons for this, eg:\n> >\n> > None of these really strikes me as \"good\" reasons for this limitation,\n> which\n> > is at the root of this issue, and will also plague any more complex\n> Bitcoin\n> > contracts which rely on nested trees of transaction to confirm (CTV,\n> Duplex,\n> > channel factories, etc). Regarding the various (seemingly arbitrary)\n> package\n> > limits it's likely the case that any issues w.r.t computational\n> complexity\n> > that may arise when trying to calculate evictions can be ameliorated with\n> > better choice of internal data structures.\n> >\n> > In the end, the simplest heuristic (accept the higher fee rate package)\n> side\n> > steps all these issues and is also the most economically rationale from a\n> > miner's perspective. Why would one prefer a higher absolute fee package\n> > (which could be very large) over another package with a higher total _fee\n> > rate_?\n>\n> This seems like a somewhat unnecessary drive-by insult of a project you\n> don't contribute to, but feel free to start with\n> a concrete suggestion here :).\n>\n> >> You'll note that B would be just fine if they had a way to safely\n> monitor the\n> >> global mempool, and while this seems like a prudent mitigation for\n> >> lightning implementations to deploy today, it is itself a quagmire of\n> >> complexity\n> >\n> > Is it really all that complex? Assuming we're talking about just watching\n> > for a certain script template (the HTLC scipt) in the mempool to be able\n> to\n> > pull a pre-image as soon as possible. Early versions of lnd used the\n> mempool\n> > for commitment broadcast detection (which turned out to be a bad idea so\n> we\n> > removed it), but at a glance I don't see why watching the mempool is so\n> > complex.\n>\n> Because watching your own mempool is not guaranteed to work, and during\n> upgrade cycles that include changes to the\n> policy rules an attacker could exploit your upgraded/non-upgraded status\n> to perform the same attack.\n>\n> >> Further, this is a really obnoxious assumption to hoist onto lightning\n> >> nodes - having an active full node with an in-sync mempool is a lot more\n> >> CPU, bandwidth, and complexity than most lightning users were expecting\n> to\n> >> face.\n> >\n> > This would only be a requirement for Lightning nodes that seek to be a\n> part\n> > of the public routing network with a desire to _forward_ HTLCs. This\n> isn't\n> > doesn't affect laptops or mobile phones which likely mostly have private\n> > channels and don't participate in HTLC forwarding. I think it's pretty\n> > reasonable to expect a \"proper\" routing node on the network to be backed\n> by\n> > a full-node. The bandwidth concern is valid, but we'd need concrete\n> numbers\n> > that compare the bandwidth over head of mempool awareness (assuming the\n> > latest and greatest mempool syncing) compared with the overhead of the\n> > channel update gossip and gossip queries over head which LN nodes face\n> today\n> > as is to see how much worse off they really would be.\n>\n> If mempool-watching were practical, maybe, though there are a number of\n> folks who are talking about designing\n> partially-offline local lightning hubs which would be rendered impractical.\n>\n> > As detailed a bit below, if nodes watch the mempool, then this class of\n> > attack assuming the anchor output format as described in the open\n> > lightning-rfc PR is mitigated. At a glance, watching the mempool seems\n> like\n> > a far less involved process compared to modifying the state machine as\n> its\n> > defined today. By watching the mempool and implementing the changes in\n> > #lightning-rfc/688, then this issue can be mitigated _today_. lnd 0.10\n> > doesn't yet watch the mempool (but does include anchors [1]), but unless\n> I'm\n> > missing something it should be pretty straight forward to add which mor\n> or less\n> > resolves this issue all together.\n> >\n> >> not fixing this issue seems to render the whole exercise somewhat\n> useless\n> >\n> > Depends on if one considers watching the mempool a fix. But even with\n> that a\n> > base version of anchors still resolves a number of issues including:\n> > eliminating the commitment fee guessing game, allowing users to pay less\n> on\n> > force close, being able to coalesce 2nd level HTLC transactions with the\n> > same CLTV expiry, and actually being able to reliably enforce multi-hop\n> HTLC\n> > resolution.\n> >\n> >> Instead of making the HTLC output spending more free-form with\n> >> SIGHASH_ANYONECAN_PAY|SIGHASH_SINGLE, we clearly need to go the other\n> >> direction - all HTLC output spends need to be pre-signed.\n> >\n> > I'm not sure this is actually immediately workable (need to think about\n> it\n> > more). To see why, remember that the commit_sig message includes HTLC\n> > signatures for the _remote_ party's commitment transaction, so they can\n> > spend the HTLCs if they broadcast their version of the commitment (force\n> > close). If we don't somehow also _gain_ signatures (our new HTLC\n> signatures)\n> > allowing us to spend HTLCs on _their_ version of the commitment, then if\n> > they broadcast that commitment (without revoking), then we're unable to\n> > redeem any of those HTLCs at all, possibly losing money.\n>\n> Hmm, maybe the proposal wasn't clear. The idea isn't to add signatures to\n> braodcasted transactions, but instead to CPFP\n> a maybe-broadcasted transaction by sending a transaction which spends it\n> and seeing if it is accepted. You only need to\n> know the transaction's exact format (ie txid, which we do, since we sent a\n> signature for it long ago) to do this, you\n> don't have to actually *have* the fully-signed transaction (and you don't).\n>\n> > In an attempt to counteract this, we might say ok, the revoke message\n> also\n> > now includes HTLC signatures for their new commitment allowing us to\n> spend\n> > our HTLCs. This resolves things in a weaker security model, but doesn't\n> > address the issue generally, as after they receive the commit_sig, they\n> can\n> > broadcast immediately, again leaving us without a way to redeem our\n> HTLCs.\n> >\n> > I'd need to think about it more, but it seems that following this path\n> would\n> > require an overhaul in the channel state machine to make presenting a new\n> > commitment actually take at least _two phases_ (at least a full round\n> trip).\n> > The first phase would tender the commitment, but render them unable to\n> > broadcast it. The second phase would then <insert something something\n> > scriptless scripts here> enter a new sub-protocol which upon conclusion,\n> > gives the commitment proposer valid HTLC signatures, and gives the\n> responder\n> > what they need to be able to broadcast their commitment and claim their\n> > HTCLs in an atomic manner.\n> >\n> > -- Laolu\n> >\n> > [1]: https://github.com/lightningnetwork/lnd/pull/3821\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200422/2392c438/attachment-0001.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-04-22T23:20:03",
                "message_text_only": "> On Apr 22, 2020, at 16:13, Olaoluwa Osuntokun <laolu32 at gmail.com> wrote:\n> \n> > Hmm, maybe the proposal wasn't clear. The idea isn't to add signatures to\n> > braodcasted transactions, but instead to CPFP a maybe-broadcasted\n> > transaction by sending a transaction which spends it and seeing if it is\n> > accepted\n> \n> Sorry I still don't follow. By \"we clearly need to go the other direction -\n> all HTLC output spends need to be pre-signed.\", you don't mean that the HTLC\n> spends of the non-broadcaster also need to be an off-chain 2-of-2 multi-sig\n> covenant? If the other party isn't restricted w.r.t _how_ they can spend the\n> output (non-rbf'd, ect), then I don't see how that addresses anything.\n\nIndeed, that is what I\u2019m suggesting. Anchor output and all. One thing we could think about is only turning it on over a certain threshold, and having a separate \u201conly-kinda-enforceable-on-chain-HTLC-in-flight\u201d limit.\n\n> Also see my mail elsewhere in the thread that the other party is actually\n> forced to spend their HTLC output using an RBF-replaceable transaction. With\n> that, I think we're all good here? In the end both sides have the ability to\n> raise the fee rate of their spending transactions with the highest winning.\n> As long as one of them confirms within the CLTV-delta, then everyone is\n> made whole.\n\nIt does seem like my cached recollection of RBF opt-in was incorrect but please re-read the intro email. There are a bunch of ways of doing pinning - just opting into RBF isn\u2019t even close to enough.\n\n> [1]: https://github.com/bitcoin/bitcoin/pull/18191\n> \n> \n>> On Wed, Apr 22, 2020 at 9:50 AM Matt Corallo <lf-lists at mattcorallo.com> wrote:\n>> A few replies inline.\n>> \n>> On 4/22/20 12:13 AM, Olaoluwa Osuntokun wrote:\n>> > Hi Matt,\n>> > \n>> > \n>> >> While this is somewhat unintuitive, there are any number of good anti-DoS\n>> >> reasons for this, eg:\n>> > \n>> > None of these really strikes me as \"good\" reasons for this limitation, which\n>> > is at the root of this issue, and will also plague any more complex Bitcoin\n>> > contracts which rely on nested trees of transaction to confirm (CTV, Duplex,\n>> > channel factories, etc). Regarding the various (seemingly arbitrary) package\n>> > limits it's likely the case that any issues w.r.t computational complexity\n>> > that may arise when trying to calculate evictions can be ameliorated with\n>> > better choice of internal data structures.\n>> > \n>> > In the end, the simplest heuristic (accept the higher fee rate package) side\n>> > steps all these issues and is also the most economically rationale from a\n>> > miner's perspective. Why would one prefer a higher absolute fee package\n>> > (which could be very large) over another package with a higher total _fee\n>> > rate_?\n>> \n>> This seems like a somewhat unnecessary drive-by insult of a project you don't contribute to, but feel free to start with\n>> a concrete suggestion here :).\n>> \n>> >> You'll note that B would be just fine if they had a way to safely monitor the\n>> >> global mempool, and while this seems like a prudent mitigation for\n>> >> lightning implementations to deploy today, it is itself a quagmire of\n>> >> complexity\n>> > \n>> > Is it really all that complex? Assuming we're talking about just watching\n>> > for a certain script template (the HTLC scipt) in the mempool to be able to\n>> > pull a pre-image as soon as possible. Early versions of lnd used the mempool\n>> > for commitment broadcast detection (which turned out to be a bad idea so we\n>> > removed it), but at a glance I don't see why watching the mempool is so\n>> > complex.\n>> \n>> Because watching your own mempool is not guaranteed to work, and during upgrade cycles that include changes to the\n>> policy rules an attacker could exploit your upgraded/non-upgraded status to perform the same attack.\n>> \n>> >> Further, this is a really obnoxious assumption to hoist onto lightning\n>> >> nodes - having an active full node with an in-sync mempool is a lot more\n>> >> CPU, bandwidth, and complexity than most lightning users were expecting to\n>> >> face.\n>> > \n>> > This would only be a requirement for Lightning nodes that seek to be a part\n>> > of the public routing network with a desire to _forward_ HTLCs. This isn't\n>> > doesn't affect laptops or mobile phones which likely mostly have private\n>> > channels and don't participate in HTLC forwarding. I think it's pretty\n>> > reasonable to expect a \"proper\" routing node on the network to be backed by\n>> > a full-node. The bandwidth concern is valid, but we'd need concrete numbers\n>> > that compare the bandwidth over head of mempool awareness (assuming the\n>> > latest and greatest mempool syncing) compared with the overhead of the\n>> > channel update gossip and gossip queries over head which LN nodes face today\n>> > as is to see how much worse off they really would be.\n>> \n>> If mempool-watching were practical, maybe, though there are a number of folks who are talking about designing\n>> partially-offline local lightning hubs which would be rendered impractical.\n>> \n>> > As detailed a bit below, if nodes watch the mempool, then this class of\n>> > attack assuming the anchor output format as described in the open\n>> > lightning-rfc PR is mitigated. At a glance, watching the mempool seems like\n>> > a far less involved process compared to modifying the state machine as its\n>> > defined today. By watching the mempool and implementing the changes in\n>> > #lightning-rfc/688, then this issue can be mitigated _today_. lnd 0.10\n>> > doesn't yet watch the mempool (but does include anchors [1]), but unless I'm\n>> > missing something it should be pretty straight forward to add which mor or less\n>> > resolves this issue all together.\n>> > \n>> >> not fixing this issue seems to render the whole exercise somewhat useless\n>> > \n>> > Depends on if one considers watching the mempool a fix. But even with that a\n>> > base version of anchors still resolves a number of issues including:\n>> > eliminating the commitment fee guessing game, allowing users to pay less on\n>> > force close, being able to coalesce 2nd level HTLC transactions with the\n>> > same CLTV expiry, and actually being able to reliably enforce multi-hop HTLC\n>> > resolution.\n>> > \n>> >> Instead of making the HTLC output spending more free-form with\n>> >> SIGHASH_ANYONECAN_PAY|SIGHASH_SINGLE, we clearly need to go the other\n>> >> direction - all HTLC output spends need to be pre-signed.\n>> > \n>> > I'm not sure this is actually immediately workable (need to think about it\n>> > more). To see why, remember that the commit_sig message includes HTLC\n>> > signatures for the _remote_ party's commitment transaction, so they can\n>> > spend the HTLCs if they broadcast their version of the commitment (force\n>> > close). If we don't somehow also _gain_ signatures (our new HTLC signatures)\n>> > allowing us to spend HTLCs on _their_ version of the commitment, then if\n>> > they broadcast that commitment (without revoking), then we're unable to\n>> > redeem any of those HTLCs at all, possibly losing money.\n>> \n>> Hmm, maybe the proposal wasn't clear. The idea isn't to add signatures to braodcasted transactions, but instead to CPFP\n>> a maybe-broadcasted transaction by sending a transaction which spends it and seeing if it is accepted. You only need to\n>> know the transaction's exact format (ie txid, which we do, since we sent a signature for it long ago) to do this, you\n>> don't have to actually *have* the fully-signed transaction (and you don't).\n>> \n>> > In an attempt to counteract this, we might say ok, the revoke message also\n>> > now includes HTLC signatures for their new commitment allowing us to spend\n>> > our HTLCs. This resolves things in a weaker security model, but doesn't\n>> > address the issue generally, as after they receive the commit_sig, they can\n>> > broadcast immediately, again leaving us without a way to redeem our HTLCs.\n>> > \n>> > I'd need to think about it more, but it seems that following this path would\n>> > require an overhaul in the channel state machine to make presenting a new\n>> > commitment actually take at least _two phases_ (at least a full round trip).\n>> > The first phase would tender the commitment, but render them unable to\n>> > broadcast it. The second phase would then <insert something something\n>> > scriptless scripts here> enter a new sub-protocol which upon conclusion,\n>> > gives the commitment proposer valid HTLC signatures, and gives the responder\n>> > what they need to be able to broadcast their commitment and claim their\n>> > HTCLs in an atomic manner.\n>> > \n>> > -- Laolu\n>> > \n>> > [1]: https://github.com/lightningnetwork/lnd/pull/3821\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200422/428e7a28/attachment.html>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2020-04-22T23:27:49",
                "message_text_only": "> Indeed, that is what I\u2019m suggesting\n\nGotcha, if this is indeed what you're suggesting (all HTLC spends are now\n2-of-2 multi-sig), then I think the modifications to the state machine I\nsketched out in an earlier email are required. An exact construction which\nachieves the requirements of \"you can't broadcast until you have a secret\nwhich I can obtain from the htlc sig for your commitment transaction, and my\nsecret is revealed with another swap\", appears to be an open problem, atm.\n\nEven if they're restricted in this fashion (must be a 1-in-1 out,\nsighashall, fees are pre agreed upon), they can still spend that with a CPFP\n(while still unconfirmed in the mempool) and create another heavy tree,\nwhich puts us right back at the same bidding war scenario?\n\n> There are a bunch of ways of doing pinning - just opting into RBF isn\u2019t\n> even close to enough.\n\nMhmm, there're other ways of doing pinning. But with anchors as is defined\nin that spec PR, they're forced to spend with an RBF-replaceable\ntransaction, which means the party wishing to time things out can enter into\na bidding war. If the party trying to impeded things participates in this\nprogressive absolute fee increase, it's likely that the war terminates\nwith _one_ of them getting into the block, which seems to resolve\neverything?\n\n-- Laolu\n\n\nOn Wed, Apr 22, 2020 at 4:20 PM Matt Corallo <lf-lists at mattcorallo.com>\nwrote:\n\n>\n>\n> On Apr 22, 2020, at 16:13, Olaoluwa Osuntokun <laolu32 at gmail.com> wrote:\n>\n>\n> > Hmm, maybe the proposal wasn't clear. The idea isn't to add signatures to\n> > braodcasted transactions, but instead to CPFP a maybe-broadcasted\n> > transaction by sending a transaction which spends it and seeing if it is\n> > accepted\n>\n> Sorry I still don't follow. By \"we clearly need to go the other direction -\n> all HTLC output spends need to be pre-signed.\", you don't mean that the\n> HTLC\n> spends of the non-broadcaster also need to be an off-chain 2-of-2 multi-sig\n> covenant? If the other party isn't restricted w.r.t _how_ they can spend\n> the\n> output (non-rbf'd, ect), then I don't see how that addresses anything.\n>\n>\n> Indeed, that is what I\u2019m suggesting. Anchor output and all. One thing we\n> could think about is only turning it on over a certain threshold, and\n> having a separate \u201conly-kinda-enforceable-on-chain-HTLC-in-flight\u201d limit.\n>\n> Also see my mail elsewhere in the thread that the other party is actually\n> forced to spend their HTLC output using an RBF-replaceable transaction.\n> With\n> that, I think we're all good here? In the end both sides have the ability\n> to\n> raise the fee rate of their spending transactions with the highest winning.\n> As long as one of them confirms within the CLTV-delta, then everyone is\n> made whole.\n>\n>\n> It does seem like my cached recollection of RBF opt-in was incorrect but\n> please re-read the intro email. There are a bunch of ways of doing pinning\n> - just opting into RBF isn\u2019t even close to enough.\n>\n> [1]: https://github.com/bitcoin/bitcoin/pull/18191\n>\n>\n> On Wed, Apr 22, 2020 at 9:50 AM Matt Corallo <lf-lists at mattcorallo.com>\n> wrote:\n>\n>> A few replies inline.\n>>\n>> On 4/22/20 12:13 AM, Olaoluwa Osuntokun wrote:\n>> > Hi Matt,\n>> >\n>> >\n>> >> While this is somewhat unintuitive, there are any number of good\n>> anti-DoS\n>> >> reasons for this, eg:\n>> >\n>> > None of these really strikes me as \"good\" reasons for this limitation,\n>> which\n>> > is at the root of this issue, and will also plague any more complex\n>> Bitcoin\n>> > contracts which rely on nested trees of transaction to confirm (CTV,\n>> Duplex,\n>> > channel factories, etc). Regarding the various (seemingly arbitrary)\n>> package\n>> > limits it's likely the case that any issues w.r.t computational\n>> complexity\n>> > that may arise when trying to calculate evictions can be ameliorated\n>> with\n>> > better choice of internal data structures.\n>> >\n>> > In the end, the simplest heuristic (accept the higher fee rate package)\n>> side\n>> > steps all these issues and is also the most economically rationale from\n>> a\n>> > miner's perspective. Why would one prefer a higher absolute fee package\n>> > (which could be very large) over another package with a higher total\n>> _fee\n>> > rate_?\n>>\n>> This seems like a somewhat unnecessary drive-by insult of a project you\n>> don't contribute to, but feel free to start with\n>> a concrete suggestion here :).\n>>\n>> >> You'll note that B would be just fine if they had a way to safely\n>> monitor the\n>> >> global mempool, and while this seems like a prudent mitigation for\n>> >> lightning implementations to deploy today, it is itself a quagmire of\n>> >> complexity\n>> >\n>> > Is it really all that complex? Assuming we're talking about just\n>> watching\n>> > for a certain script template (the HTLC scipt) in the mempool to be\n>> able to\n>> > pull a pre-image as soon as possible. Early versions of lnd used the\n>> mempool\n>> > for commitment broadcast detection (which turned out to be a bad idea\n>> so we\n>> > removed it), but at a glance I don't see why watching the mempool is so\n>> > complex.\n>>\n>> Because watching your own mempool is not guaranteed to work, and during\n>> upgrade cycles that include changes to the\n>> policy rules an attacker could exploit your upgraded/non-upgraded status\n>> to perform the same attack.\n>>\n>> >> Further, this is a really obnoxious assumption to hoist onto lightning\n>> >> nodes - having an active full node with an in-sync mempool is a lot\n>> more\n>> >> CPU, bandwidth, and complexity than most lightning users were\n>> expecting to\n>> >> face.\n>> >\n>> > This would only be a requirement for Lightning nodes that seek to be a\n>> part\n>> > of the public routing network with a desire to _forward_ HTLCs. This\n>> isn't\n>> > doesn't affect laptops or mobile phones which likely mostly have private\n>> > channels and don't participate in HTLC forwarding. I think it's pretty\n>> > reasonable to expect a \"proper\" routing node on the network to be\n>> backed by\n>> > a full-node. The bandwidth concern is valid, but we'd need concrete\n>> numbers\n>> > that compare the bandwidth over head of mempool awareness (assuming the\n>> > latest and greatest mempool syncing) compared with the overhead of the\n>> > channel update gossip and gossip queries over head which LN nodes face\n>> today\n>> > as is to see how much worse off they really would be.\n>>\n>> If mempool-watching were practical, maybe, though there are a number of\n>> folks who are talking about designing\n>> partially-offline local lightning hubs which would be rendered\n>> impractical.\n>>\n>> > As detailed a bit below, if nodes watch the mempool, then this class of\n>> > attack assuming the anchor output format as described in the open\n>> > lightning-rfc PR is mitigated. At a glance, watching the mempool seems\n>> like\n>> > a far less involved process compared to modifying the state machine as\n>> its\n>> > defined today. By watching the mempool and implementing the changes in\n>> > #lightning-rfc/688, then this issue can be mitigated _today_. lnd 0.10\n>> > doesn't yet watch the mempool (but does include anchors [1]), but\n>> unless I'm\n>> > missing something it should be pretty straight forward to add which mor\n>> or less\n>> > resolves this issue all together.\n>> >\n>> >> not fixing this issue seems to render the whole exercise somewhat\n>> useless\n>> >\n>> > Depends on if one considers watching the mempool a fix. But even with\n>> that a\n>> > base version of anchors still resolves a number of issues including:\n>> > eliminating the commitment fee guessing game, allowing users to pay\n>> less on\n>> > force close, being able to coalesce 2nd level HTLC transactions with the\n>> > same CLTV expiry, and actually being able to reliably enforce multi-hop\n>> HTLC\n>> > resolution.\n>> >\n>> >> Instead of making the HTLC output spending more free-form with\n>> >> SIGHASH_ANYONECAN_PAY|SIGHASH_SINGLE, we clearly need to go the other\n>> >> direction - all HTLC output spends need to be pre-signed.\n>> >\n>> > I'm not sure this is actually immediately workable (need to think about\n>> it\n>> > more). To see why, remember that the commit_sig message includes HTLC\n>> > signatures for the _remote_ party's commitment transaction, so they can\n>> > spend the HTLCs if they broadcast their version of the commitment (force\n>> > close). If we don't somehow also _gain_ signatures (our new HTLC\n>> signatures)\n>> > allowing us to spend HTLCs on _their_ version of the commitment, then if\n>> > they broadcast that commitment (without revoking), then we're unable to\n>> > redeem any of those HTLCs at all, possibly losing money.\n>>\n>> Hmm, maybe the proposal wasn't clear. The idea isn't to add signatures to\n>> braodcasted transactions, but instead to CPFP\n>> a maybe-broadcasted transaction by sending a transaction which spends it\n>> and seeing if it is accepted. You only need to\n>> know the transaction's exact format (ie txid, which we do, since we sent\n>> a signature for it long ago) to do this, you\n>> don't have to actually *have* the fully-signed transaction (and you\n>> don't).\n>>\n>> > In an attempt to counteract this, we might say ok, the revoke message\n>> also\n>> > now includes HTLC signatures for their new commitment allowing us to\n>> spend\n>> > our HTLCs. This resolves things in a weaker security model, but doesn't\n>> > address the issue generally, as after they receive the commit_sig, they\n>> can\n>> > broadcast immediately, again leaving us without a way to redeem our\n>> HTLCs.\n>> >\n>> > I'd need to think about it more, but it seems that following this path\n>> would\n>> > require an overhaul in the channel state machine to make presenting a\n>> new\n>> > commitment actually take at least _two phases_ (at least a full round\n>> trip).\n>> > The first phase would tender the commitment, but render them unable to\n>> > broadcast it. The second phase would then <insert something something\n>> > scriptless scripts here> enter a new sub-protocol which upon conclusion,\n>> > gives the commitment proposer valid HTLC signatures, and gives the\n>> responder\n>> > what they need to be able to broadcast their commitment and claim their\n>> > HTCLs in an atomic manner.\n>> >\n>> > -- Laolu\n>> >\n>> > [1]: https://github.com/lightningnetwork/lnd/pull/3821\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200422/ec41b541/attachment-0001.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-04-23T01:10:47",
                "message_text_only": "On 4/22/20 7:27 PM, Olaoluwa Osuntokun wrote:\n> \n>> Indeed, that is what I\u2019m suggesting\n> \n> Gotcha, if this is indeed what you're suggesting (all HTLC spends are now\n> 2-of-2 multi-sig), then I think the modifications to the state machine I\n> sketched out in an earlier email are required. An exact construction which\n> achieves the requirements of \"you can't broadcast until you have a secret\n> which I can obtain from the htlc sig for your commitment transaction, and my\n> secret is revealed with another swap\", appears to be an open problem, atm.\n\nHmm, indeed, it does seem to require a change to the state machine, but I don't think a very interesting one. Because B\nproviding A an HTLC signature spending a commitment transaction B will broadcast does not allow A to actually broadcast\nsaid HTLC transaction, B can be rather liberal with it. Indeed, however, it would require that B provide such a\nsignature before A can send the commitment_signed that exists today.\n\n> Even if they're restricted in this fashion (must be a 1-in-1 out,\n> sighashall, fees are pre agreed upon), they can still spend that with a CPFP\n> (while still unconfirmed in the mempool) and create another heavy tree,\n> which puts us right back at the same bidding war scenario?\n\nRight, you'd have to use anchor outputs just like we do on the commitment transaction :).\n\n>> There are a bunch of ways of doing pinning - just opting into RBF isn\u2019t\n>> even close to enough.\n> \n> Mhmm, there're other ways of doing pinning. But with anchors as is defined\n> in that spec PR, they're forced to spend with an RBF-replaceable\n> transaction, which means the party wishing to time things out can enter into\n> a bidding war. If the party trying to impeded things participates in this\n> progressive absolute fee increase, it's likely that the war terminates\n> with _one_ of them getting into the block, which seems to resolve\n> everything?\n\nNo? Even if we assume there are no tricks that you can play with, eg, the package limits duri eviction, which I'd be\nsurprised about, the \"absolute fee/feerate\" thing still screws you. The attacker here gets to hold something at the\nbottom of the mempool and the poor honest party is going to have to pay an absurd (likely more than the HTLC value) fee\njust to get it unstuck, whereas the attacker never would have had to pay said fee.\n\n> -- Laolung\n> \n> \n> On Wed, Apr 22, 2020 at 4:20 PM Matt Corallo <lf-lists at mattcorallo.com <mailto:lf-lists at mattcorallo.com>> wrote:\n> \n> \n> \n>>     On Apr 22, 2020, at 16:13, Olaoluwa Osuntokun <laolu32 at gmail.com <mailto:laolu32 at gmail.com>> wrote:\n>>\n>>     > Hmm, maybe the proposal wasn't clear. The idea isn't to add signatures to\n>>     > braodcasted transactions, but instead to CPFP a maybe-broadcasted\n>>     > transaction by sending a transaction which spends it and seeing if it is\n>>     > accepted\n>>\n>>     Sorry I still don't follow. By \"we clearly need to go the other direction -\n>>     all HTLC output spends need to be pre-signed.\", you don't mean that the HTLC\n>>     spends of the non-broadcaster also need to be an off-chain 2-of-2 multi-sig\n>>     covenant? If the other party isn't restricted w.r.t _how_ they can spend the\n>>     output (non-rbf'd, ect), then I don't see how that addresses anything.\n> \n>     Indeed, that is what I\u2019m suggesting. Anchor output and all. One thing we could think about is only turning it on\n>     over a certain threshold, and having a separate \u201conly-kinda-enforceable-on-chain-HTLC-in-flight\u201d limit.\n> \n>>     Also see my mail elsewhere in the thread that the other party is actually\n>>     forced to spend their HTLC output using an RBF-replaceable transaction. With\n>>     that, I think we're all good here? In the end both sides have the ability to\n>>     raise the fee rate of their spending transactions with the highest winning.\n>>     As long as one of them confirms within the CLTV-delta, then everyone is\n>>     made whole.\n> \n>     It does seem like my cached recollection of RBF opt-in was incorrect but please re-read the intro email. There are a\n>     bunch of ways of doing pinning - just opting into RBF isn\u2019t even close to enough.\n> \n>>     [1]: https://github.com/bitcoin/bitcoin/pull/18191\n>>\n>>\n>>     On Wed, Apr 22, 2020 at 9:50 AM Matt Corallo <lf-lists at mattcorallo.com <mailto:lf-lists at mattcorallo.com>> wrote:\n>>\n>>         A few replies inline.\n>>\n>>         On 4/22/20 12:13 AM, Olaoluwa Osuntokun wrote:\n>>         > Hi Matt,\n>>         >\n>>         >\n>>         >> While this is somewhat unintuitive, there are any number of good anti-DoS\n>>         >> reasons for this, eg:\n>>         >\n>>         > None of these really strikes me as \"good\" reasons for this limitation, which\n>>         > is at the root of this issue, and will also plague any more complex Bitcoin\n>>         > contracts which rely on nested trees of transaction to confirm (CTV, Duplex,\n>>         > channel factories, etc). Regarding the various (seemingly arbitrary) package\n>>         > limits it's likely the case that any issues w.r.t computational complexity\n>>         > that may arise when trying to calculate evictions can be ameliorated with\n>>         > better choice of internal data structures.\n>>         >\n>>         > In the end, the simplest heuristic (accept the higher fee rate package) side\n>>         > steps all these issues and is also the most economically rationale from a\n>>         > miner's perspective. Why would one prefer a higher absolute fee package\n>>         > (which could be very large) over another package with a higher total _fee\n>>         > rate_?\n>>\n>>         This seems like a somewhat unnecessary drive-by insult of a project you don't contribute to, but feel free to\n>>         start with\n>>         a concrete suggestion here :).\n>>\n>>         >> You'll note that B would be just fine if they had a way to safely monitor the\n>>         >> global mempool, and while this seems like a prudent mitigation for\n>>         >> lightning implementations to deploy today, it is itself a quagmire of\n>>         >> complexity\n>>         >\n>>         > Is it really all that complex? Assuming we're talking about just watching\n>>         > for a certain script template (the HTLC scipt) in the mempool to be able to\n>>         > pull a pre-image as soon as possible. Early versions of lnd used the mempool\n>>         > for commitment broadcast detection (which turned out to be a bad idea so we\n>>         > removed it), but at a glance I don't see why watching the mempool is so\n>>         > complex.\n>>\n>>         Because watching your own mempool is not guaranteed to work, and during upgrade cycles that include changes to the\n>>         policy rules an attacker could exploit your upgraded/non-upgraded status to perform the same attack.\n>>\n>>         >> Further, this is a really obnoxious assumption to hoist onto lightning\n>>         >> nodes - having an active full node with an in-sync mempool is a lot more\n>>         >> CPU, bandwidth, and complexity than most lightning users were expecting to\n>>         >> face.\n>>         >\n>>         > This would only be a requirement for Lightning nodes that seek to be a part\n>>         > of the public routing network with a desire to _forward_ HTLCs. This isn't\n>>         > doesn't affect laptops or mobile phones which likely mostly have private\n>>         > channels and don't participate in HTLC forwarding. I think it's pretty\n>>         > reasonable to expect a \"proper\" routing node on the network to be backed by\n>>         > a full-node. The bandwidth concern is valid, but we'd need concrete numbers\n>>         > that compare the bandwidth over head of mempool awareness (assuming the\n>>         > latest and greatest mempool syncing) compared with the overhead of the\n>>         > channel update gossip and gossip queries over head which LN nodes face today\n>>         > as is to see how much worse off they really would be.\n>>\n>>         If mempool-watching were practical, maybe, though there are a number of folks who are talking about designing\n>>         partially-offline local lightning hubs which would be rendered impractical.\n>>\n>>         > As detailed a bit below, if nodes watch the mempool, then this class of\n>>         > attack assuming the anchor output format as described in the open\n>>         > lightning-rfc PR is mitigated. At a glance, watching the mempool seems like\n>>         > a far less involved process compared to modifying the state machine as its\n>>         > defined today. By watching the mempool and implementing the changes in\n>>         > #lightning-rfc/688, then this issue can be mitigated _today_. lnd 0.10\n>>         > doesn't yet watch the mempool (but does include anchors [1]), but unless I'm\n>>         > missing something it should be pretty straight forward to add which mor or less\n>>         > resolves this issue all together.\n>>         >\n>>         >> not fixing this issue seems to render the whole exercise somewhat useless\n>>         >\n>>         > Depends on if one considers watching the mempool a fix. But even with that a\n>>         > base version of anchors still resolves a number of issues including:\n>>         > eliminating the commitment fee guessing game, allowing users to pay less on\n>>         > force close, being able to coalesce 2nd level HTLC transactions with the\n>>         > same CLTV expiry, and actually being able to reliably enforce multi-hop HTLC\n>>         > resolution.\n>>         >\n>>         >> Instead of making the HTLC output spending more free-form with\n>>         >> SIGHASH_ANYONECAN_PAY|SIGHASH_SINGLE, we clearly need to go the other\n>>         >> direction - all HTLC output spends need to be pre-signed.\n>>         >\n>>         > I'm not sure this is actually immediately workable (need to think about it\n>>         > more). To see why, remember that the commit_sig message includes HTLC\n>>         > signatures for the _remote_ party's commitment transaction, so they can\n>>         > spend the HTLCs if they broadcast their version of the commitment (force\n>>         > close). If we don't somehow also _gain_ signatures (our new HTLC signatures)\n>>         > allowing us to spend HTLCs on _their_ version of the commitment, then if\n>>         > they broadcast that commitment (without revoking), then we're unable to\n>>         > redeem any of those HTLCs at all, possibly losing money.\n>>\n>>         Hmm, maybe the proposal wasn't clear. The idea isn't to add signatures to braodcasted transactions, but\n>>         instead to CPFP\n>>         a maybe-broadcasted transaction by sending a transaction which spends it and seeing if it is accepted. You\n>>         only need to\n>>         know the transaction's exact format (ie txid, which we do, since we sent a signature for it long ago) to do\n>>         this, you\n>>         don't have to actually *have* the fully-signed transaction (and you don't).\n>>\n>>         > In an attempt to counteract this, we might say ok, the revoke message also\n>>         > now includes HTLC signatures for their new commitment allowing us to spend\n>>         > our HTLCs. This resolves things in a weaker security model, but doesn't\n>>         > address the issue generally, as after they receive the commit_sig, they can\n>>         > broadcast immediately, again leaving us without a way to redeem our HTLCs.\n>>         >\n>>         > I'd need to think about it more, but it seems that following this path would\n>>         > require an overhaul in the channel state machine to make presenting a new\n>>         > commitment actually take at least _two phases_ (at least a full round trip).\n>>         > The first phase would tender the commitment, but render them unable to\n>>         > broadcast it. The second phase would then <insert something something\n>>         > scriptless scripts here> enter a new sub-protocol which upon conclusion,\n>>         > gives the commitment proposer valid HTLC signatures, and gives the responder\n>>         > what they need to be able to broadcast their commitment and claim their\n>>         > HTCLs in an atomic manner.\n>>         >\n>>         > -- Laolu\n>>         >\n>>         > [1]: https://github.com/lightningnetwork/lnd/pull/3821\n>>"
            },
            {
                "author": "Jeremy",
                "date": "2020-04-23T01:18:05",
                "message_text_only": "Hi everyone,\n\nSorry to just be getting to a response here. Hadn't noticed it till now.\n\n*(Plug: If anyone or their organizations would like to assist in funding\nthe work described below for a group of developers, I've been working to\nput resources together for funding the above for a few months now, and I\nthink it would be high leverage towards seeing this through. There are a\nlot of unsexy tasks to do  that aren't coming up with a solution\n(e.g.,writing a myriad of Mempool stress test scenarios) that can be a well\ndefined full-time job for someone to do.)*\n\nI've been working on exactly this problem in the mempool for months now.\nI'm deeply familiar with the issues here and the types of pinning possible.\nI think everyone can recognize that with my work on OP_CTV I want nothing\nmore than the mempool to be able to accept whatever long chains we can\nthrow at it, but I'm pretty well steeped at this point in the obstacles to\ndoing that.\n\nI don't think that we should be entertaining further carve outs at the\nmoment, unless it is really trivial. Every new carve out rule added to the\nway that the mempool operates is removing complexity invariants we aim to\npreserve in the mempool in order to keep nodes operational. Many of these\ninvariants are well documented, some are not. I'm happy to go off list for\na more thorough discussion with anyone qualified to have it; this isn't the\nbest venue for that discussion.\n\n>From my point of view the path forward here is to dedicate more development\nresources towards finishing the mempool project I began. You can see the\noutstanding work here: https://github.com/bitcoin/bitcoin/projects/14,\ncontributing review towards moving those PRs forward will greatly improve\nour ability to consider a stopgap carve out measure.\n\nThe current focus of this work is primarily on:\n\n1) Testing Construction to better test & catch regressions or\nvulnerabilities introduced or extant in mempool\n2) Refactoring algorithms in mempool to reduce constant factors &\nasymptotics\n3) Package Relay\n\n\nNone of these fix the exact problem at hand though, but here's part of how\nthey can help us:\n\nIf we finish up the algorithmic refactors I've been working on it seems\nplausible to do a one-off increase of descendants limits to say, 100\ndescendants with no restriction. However, we could use the opportunity to\nuse the 75 descendant increase exclusively for a new carve out, and apply\nsome new stricter rules in that extra space. There are a few anti-pinning\ncountermeasures that you can apply in that space that you would not\ngenerally want in the mempool. An example of one is that any new\ntransaction must pay more feerate and absolute fee than every child in that\nspace. Or that only the highest fee paying branch of the excess\ntransactions are mineable, no others. Another would be disabling RBF past\nthat watermark. In all likelihood, different subsystems interacting with\nthe mempool will require a different set of restrictions each with the\ncurrent architecture, I don't think there's a magic bullet.\n\nPackage relay is a promising approach for a future pinning solution as\nthere are opportunities to attach to packages compact proofs of improved\nfee efficiency for pinned transactions. But the ground work for package\nrelay needs to come first. This is theoretically possible with our current\narchitecture of the mempool and can probably address much of the pinning\nconcerns by replacing pinning with more rational eviction policies.\n\nLonger term I've been working on plans and designs to completely re-do the\nmempool's architecture to make it behave for arbitrary cases. It's possible\nto one day lift all preemptively enforced (e.g., before acceptance)\ndescendants limits, which can solve this problem for good. There is more\nthan one potentially good solution here, and a conjunction of them can be\nused as they affect independent sub systems. But this work will probably\ntake years to complete to the point where restrictions can realistically be\nlifted.\n\nIf developers would like to coordinate resources around completing this\nwork and making more regular progress on it I'm happy to help point people\nto specific tasks that need to be done in order to accelerate this and help\nserialize the work so that we can not get into rebase hell.\n\nOriginally I had the plug at the top as a closing note, but I figured\npeople might miss it.\n\nBest,\n\nJeremy\n\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200422/a1e156ab/attachment-0001.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2020-04-22T18:24:54",
                "message_text_only": "On Mon, Apr 20, 2020 at 10:43:14PM -0400, Matt Corallo via Lightning-dev wrote:\n> A lightning counterparty (C, who received the HTLC from B, who\n> received it from A) today could, if B broadcasts the commitment\n> transaction, spend an HTLC using the preimage with a low-fee,\n> RBF-disabled transaction.  After a few blocks, A could claim the HTLC\n> from B via the timeout mechanism, and then after a few days, C could\n> get the HTLC-claiming transaction mined via some out-of-band agreement\n> with a small miner. This leaves B short the HTLC value.\n\nIIUC, the main problem is honest Bob will broadcast a transaction\nwithout realizing it conflicts with a pinned transaction that's already\nin most node's mempools.  If Bob knew about the pinned transaction and\ncould get a copy of it, he'd be fine.\n\nIn that case, would it be worth re-implementing something like a BIP61\nreject message but with an extension that returns the txids of any\nconflicts?  For example, when Bob connects to a bunch of Bitcoin nodes\nand sends his conflicting transaction, the nodes would reply with\nsomething like \"rejected: code 123: conflicts with txid 0123...cdef\".\nBob could then reply with a a getdata('tx', '0123...cdef') to get the\npinned transaction, parse out its preimage, and resolve the HTLC.\n\nThis approach isn't perfect (if it even makes sense at all---I could be\nmisunderstanding the problem) because one of the problems that caused\nBIP61 to be disabled in Bitcoin Core was its unreliability, but I think\nif Bob had at least one honest peer that had the pinned transaction in\nits mempool and which implemented reject-with-conflicting-txid, Bob\nmight be ok.\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200422/aa4c89f0/attachment.sig>"
            },
            {
                "author": "Antoine Riard",
                "date": "2020-04-22T19:03:29",
                "message_text_only": "> In that case, would it be worth re-implementing something like a BIP61\nreject message but with an extension that returns the txids of any\nconflicts?\n\nThat's an interesting idea, but an attacker can create a local conflict in\nyour mempool\nand then send the preimage tx to make hit recentRejects until next tip so\nwhen the rejection code with conflict is received transaction isn't going\nto be fetched.\nOf course you can make an exception for this, but seems a DoS vector...\n\nAnd also if you have a private full-node and connect only to 8 outbounds,\nan attacker\ncan do a bit of tx-relay topology discovery and blind your tx-relay peers\ntoo...\n\nI think p2p/mempool hardening measures will only make attack harder but not\nerase it, we\nshould avoid tie too much the security model of Lightning on a given p2p\ntopology. If you don't\ndo manual peering (whitelist,addnode), this one may change without\nvisibility (like stale tip).\n\n\n\nLe mer. 22 avr. 2020 \u00e0 14:25, David A. Harding via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> On Mon, Apr 20, 2020 at 10:43:14PM -0400, Matt Corallo via Lightning-dev\n> wrote:\n> > A lightning counterparty (C, who received the HTLC from B, who\n> > received it from A) today could, if B broadcasts the commitment\n> > transaction, spend an HTLC using the preimage with a low-fee,\n> > RBF-disabled transaction.  After a few blocks, A could claim the HTLC\n> > from B via the timeout mechanism, and then after a few days, C could\n> > get the HTLC-claiming transaction mined via some out-of-band agreement\n> > with a small miner. This leaves B short the HTLC value.\n>\n> IIUC, the main problem is honest Bob will broadcast a transaction\n> without realizing it conflicts with a pinned transaction that's already\n> in most node's mempools.  If Bob knew about the pinned transaction and\n> could get a copy of it, he'd be fine.\n>\n> In that case, would it be worth re-implementing something like a BIP61\n> reject message but with an extension that returns the txids of any\n> conflicts?  For example, when Bob connects to a bunch of Bitcoin nodes\n> and sends his conflicting transaction, the nodes would reply with\n> something like \"rejected: code 123: conflicts with txid 0123...cdef\".\n> Bob could then reply with a a getdata('tx', '0123...cdef') to get the\n> pinned transaction, parse out its preimage, and resolve the HTLC.\n>\n> This approach isn't perfect (if it even makes sense at all---I could be\n> misunderstanding the problem) because one of the problems that caused\n> BIP61 to be disabled in Bitcoin Core was its unreliability, but I think\n> if Bob had at least one honest peer that had the pinned transaction in\n> its mempool and which implemented reject-with-conflicting-txid, Bob\n> might be ok.\n>\n> -Dave\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200422/a2b185a9/attachment.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2020-04-22T20:28:13",
                "message_text_only": "On Wed, Apr 22, 2020 at 03:03:29PM -0400, Antoine Riard wrote:\n> > In that case, would it be worth re-implementing something like a BIP61\n> reject message but with an extension that returns the txids of any\n> conflicts?\n> \n> That's an interesting idea, but an attacker can create a local conflict in\n> your mempool\n\nYou don't need a mempool to send a transaction.  You can just open\nconnections to random Bitcoin nodes directly and try sending your\ntransaction.  That's what a lite client is going to do anyway.  If the\npinned transaction is in the mempools of a significant number of Bitcoin\nnodes, then it should take just a few random connections to find one of\nthose nodes, learn about the conflict, and download the pinned\ntransaction.\n\nIf that's not acceptable, you could find some other way to poll a\nsignificant number of people with mempools, e.g. BIP35 mempool messages\nor reusing the payment hash in a bunch of 1 msat probes to LN nodes who\nopt-in to scanning their bitcoind's mempools for a corresponding\npreimage.\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200422/2f72c33e/attachment-0001.sig>"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-04-22T22:53:37",
                "message_text_only": "\ufeffHmm, that's an interesting suggestion, it definitely raises the bar for attack execution rather significantly. Because lightning (and other second-layer systems) already relies heavily on uncensored access to blockchain data, its reasonable to extend the \"if you don't have enough blocks, aggressively query various sources to find new blocks, or, really just do it always\" solution to \"also send relevant transactions while we're at it\".\n\nSadly, unlike for block data, there is no consensus mechanism for nodes to ensure the transactions in their mempools are the same as others. Thus, if you focus on sending the pinning transaction to miner nodes directly (which isn't trivial, but also not nearly as hard as it sounds), you could still pull off the attack. However, to do it now, you'd need to\nwait for your counterparty to broadcast the corresponding timeout transaction (once it is confirmable, and can thus get into mempools), turning the whole thing into a mempool-acceptance race. Luckily there isn\u2019t much cost to *trying*, though it\u2019s less likely you\u2019ll succeed.\n\nThere are also practical design issues - if you\u2019re claiming multiple HTLC output in a single transaction the node would need to provide reject messages for each input which is conflicted, something which we\u2019d need to think hard about the DoS implications of.\n\nIn any case, while it\u2019s definitely better than nothing, it\u2019s unclear if it\u2019s really the kind of thing I\u2019d want to rely on for my own funds.\n\nMatt\n\n\n> On 4/22/20 2:24 PM, David A. Harding wrote:\n>> On Mon, Apr 20, 2020 at 10:43:14PM -0400, Matt Corallo via Lightning-dev wrote:\n>> A lightning counterparty (C, who received the HTLC from B, who\n>> received it from A) today could, if B broadcasts the commitment\n>> transaction, spend an HTLC using the preimage with a low-fee,\n>> RBF-disabled transaction.  After a few blocks, A could claim the HTLC\n>> from B via the timeout mechanism, and then after a few days, C could\n>> get the HTLC-claiming transaction mined via some out-of-band agreement\n>> with a small miner. This leaves B short the HTLC value.\n> \n> IIUC, the main problem is honest Bob will broadcast a transaction\n> without realizing it conflicts with a pinned transaction that's already\n> in most node's mempools.  If Bob knew about the pinned transaction and\n> could get a copy of it, he'd be fine.\n> \n> In that case, would it be worth re-implementing something like a BIP61\n> reject message but with an extension that returns the txids of any\n> conflicts?  For example, when Bob connects to a bunch of Bitcoin nodes\n> and sends his conflicting transaction, the nodes would reply with\n> something like \"rejected: code 123: conflicts with txid 0123...cdef\".\n> Bob could then reply with a a getdata('tx', '0123...cdef') to get the\n> pinned transaction, parse out its preimage, and resolve the HTLC.\n> \n> This approach isn't perfect (if it even makes sense at all---I could be\n> misunderstanding the problem) because one of the problems that caused\n> BIP61 to be disabled in Bitcoin Core was its unreliability, but I think\n> if Bob had at least one honest peer that had the pinned transaction in\n> its mempool and which implemented reject-with-conflicting-txid, Bob\n> might be ok.\n> \n> -Dave"
            },
            {
                "author": "David A. Harding",
                "date": "2020-04-23T09:59:57",
                "message_text_only": "On Wed, Apr 22, 2020 at 03:53:37PM -0700, Matt Corallo wrote:\n> if you focus on sending the pinning transaction to miner nodes\n> directly (which isn't trivial, but also not nearly as hard as it\n> sounds), you could still pull off the attack. \n\nIf the problem is that miners might have information not available to\nthe network in general, you could just bribe them for that knowledge.\nE.g. as Bob's refund deadline approaches and he begins to suspect that\nmempool shenanigans are preventing his refund transaction from\nconfirming, he takes a confirmed P2WPKH UTXO he's been saving for use in\nCPFP fee bumps and spends part of its value (say 1 mBTC) to the\nfollowing scriptPubKey[1],\n\n    OP_SHA256 <hash_whose_preimage_bob_wants> OP_EQUAL\n\nAssuming the feerate and the bribe amount are reasonable, any miner who\nknows the preimage is incentivized to include Bob's transaction and a\nchild transation spending from it in their next block.  That child\ntransaction will include the preimage, which Bob will see when he\nprocesses the block.\n\nIf any non-miner knows the preimage, they can also create that child\ntransaction.  The non-miner probably can't profit from this---miners can\njust rewrite the child transaction to pay themselves since there's no\nkey-based security---but the non-miner can at least pat themselves on\nthe back for being a good Summaritan.  Again Bob will learn the preimage\nonce the child transaction is included in a block, or earlier if his\nwallet is monitoring for relays of spends from his parent transaction.\n\nMoreover, Bob can first create a bribe via LN and, in that case, things\nare even better.  As Bob's deadline approaches, he uses one of his\nstill-working channels to send a bunch of max-length (20 hops?) probes\nthat reuse the earlier HTLC's <hash>.  If any hop along the path knows\nthe preimage, they can immediately claim the probe amount (and any\nrouting fees that were allocated to subsequent hops).  This not only\ngives smaller miners with LN nodes an equal chance of claiming the\nprobe-bribe as larger miners, but it also allows non-miners to profit\nfrom learning the preimage from miners.\n\nThat last part is useful because even if, as in your example, the\nadversary is able to send one version of the transaction just to miners\n(with the preimage) and another conflicting version to all relay nodes\n(without the preimage), miners will naturally attempt to relay the\npreimage version of the transaction to other users; if some of those\nusers run modified nodes that write all 32-byte witness data blobs to a\ndatabase---even if the transaction is ultimately rejected as a\nconflict---then targetted relay to miners may not be effective at\npreventing Bob from learning the preimage.\n\nObviously all of the above requires people run additional software to\nkeep track of potential preimages[2] and then compare them to hash\ncandidates, plus it requires additional complexity in LN clients, so I\ncan easily understand why it might be less desirable than the protocol\nchanges under discussion in other parts of this thread.  Still, with\nlots of effort already being put into watchtowers and other\nenforcement-assistance services, I wonder if this problem can be largely\naddressed in the same general way.\n\n-Dave\n\n[1] Requires a change to standard relay and mining policy.\n[2] Pretty easy, e.g.\n\n    bitcoin-cli getrawmempool \\\n    | jq -r .[] \\\n    | while read txid ; do\n      bitcoin-cli getrawtransaction $txid true | jq .vout[].scriptPubKey.asm\n    done \\\n    | grep -o '\\<[0-9a-f]\\{64\\}\\>'\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200423/9a20bfd7/attachment-0001.sig>"
            }
        ],
        "thread_summary": {
            "title": "RBF Pinning with Counterparties and Competing Interest",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Jeremy",
                "Antoine Riard",
                "David A. Harding",
                "Olaoluwa Osuntokun",
                "Matt Corallo"
            ],
            "messages_count": 15,
            "total_messages_chars_count": 87183
        }
    },
    {
        "title": "[bitcoin-dev] [Lightning-dev] RBF Pinning with Counterparties and Competing Interest",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-22T04:12:59",
                "message_text_only": "Good morning Matt, and list,\n\n\n\n>     RBF Pinning HTLC Transactions (aka \"Oh, wait, I can steal funds, how, now?\")\n>     =============================\n>\n>     You'll note that in the discussion of RBF pinning we were pretty broad, and that that discussion seems to in fact cover\n>     our HTLC outputs, at least when spent via (3) or (4). It does, and in fact this is a pretty severe issue in today's\n>     lightning protocol [2]. A lightning counterparty (C, who received the HTLC from B, who received it from A) today could,\n>     if B broadcasts the commitment transaction, spend an HTLC using the preimage with a low-fee, RBF-disabled transaction.\n>     After a few blocks, A could claim the HTLC from B via the timeout mechanism, and then after a few days, C could get the\n>     HTLC-claiming transaction mined via some out-of-band agreement with a small miner. This leaves B short the HTLC value.\n\nMy (cached) understanding is that, since RBF is signalled using `nSequence`, any `OP_CHECKSEQUENCEVERIFY` also automatically imposes the requirement \"must be RBF-enabled\", including `<0> OP_CHECKSEQUENCEVERIFY`.\nAdding that clause (2 bytes in witness if my math is correct) to the hashlock branch may be sufficient to prevent C from making an RBF-disabled transaction.\n\nBut then you mention out-of-band agreements with miners, which basically means the transaction might not be in the mempool at all, in which case the vulnerability is not really about RBF or relay, but sheer economics.\n\nThe payment is A->B->C, and the HTLC A->B must have a larger timeout (L + 1) than the HTLC B->C (L), in abstract non-block units.\nThe vulnerability you are describing means that the current time must now be L + 1 or greater (\"A could claim the HTLC from B via the timeout mechanism\", meaning the A->B HTLC has timed out already).\n\nIf so, then the B->C transaction has already timed out in the past and can be claimed in two ways, either via B timeout branch or C hashlock branch.\nThis sets up a game where B and C bid to miners to get their version of reality committed onchain.\n(We can neglect out-of-band agreements here; miners have the incentive to publicly leak such agreements so that other potential bidders can offer even higher fees for their versions of that transaction.)\n\nBefore L+1, C has no incentive to bid, since placing any bid at all will leak the preimage, which B can then turn around and use to spend from A, and A and C cannot steal from B.\n\nThus, B should ensure that *before* L+1, the HTLC-Timeout has been committed onchain, which outright prevents this bidding war from even starting.\n\nThe issue then is that B is using a pre-signed HTLC-timeout, which is needed since it is its commitment tx that was broadcast.\nThis prevents B from RBF-ing the HTLC-Timeout transaction.\n\nSo what is needed is to allow B to add fees to HTLC-Timeout:\n\n* We can add an RBF carve-out output to HTLC-Timeout, at the cost of more blockspace.\n* With `SIGHASH_NOINPUT` we can make the C-side signature `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side signature for a higher-fee version of HTLC-Timeout (assuming my cached understanding of `SIGHASH_NOINPUT` still holds).\n\nWith this, B can exponentially increase the fee as L+1 approaches.\nIf B can get HTLC-Timeout confirmed before L+1, then C cannot steal the HTLC value at all, since the UTXO it could steal from has already been spent.\n\nIn particular, it does not seem to me that it is necessary to change the hashlock-branch transaction of C at all, since this mechanism is enough to sidestep the issue (as I understand it).\nBut it does point to a need to make HTLC-Timeout (and possibly symmetrically, HTLC-Success) also fee-bumpable.\n\nNote as well that this does not require a mempool: B can run in `blocksonly` mode and as each block comes in from L to L+1, if HTLC-Timeout is not confirmed, feebump HTLC-Timeout.\nIn particular, HTLC-Timeout comes into play only if B broadcast its own commitment transaction, and B *should* be aware that it did so --- there is still no need for mempool monitoring here.\n\n\nNow, of course this only delays the war.\nLet us now consider what C can do to ensure that the bidding war will happen eventually.\n\n* C can bribe a miner to prevent HTLC-Timeout from confirming between L and L+1.\n  * Or in other words, this is a censorship attack.\n    * The Bitcoin censorship-resistance model is that censored transactions can be fee-bumped, which attracts non-censoring miners to try their luck at mining and evict the censoring miner.\n      * Thus, letting B bump the fee on HTLC-Timeout is precisely the mechanism we need.\n      * This sets up a bidding war between C requesting miners to censor, vs. B requesting miners to confirm, but that only sets the stage for a second bidding war later between C and B, thus C is at a disadvantage: it has to bribe miners to censor continuously from L to L+1 *and* additional bribe miners to confirm its transaction after L+1, whereas B can offer its bribe as being something that miners can claim now without waiting after L+1.\n\n\n\nThe issue of course is the additional output that bloats the UTXO set and requires another transaction to claim later.\nAnd if we have `SIGHASH_NOINPUT`, it seems to me that Decker-Russell-Osuntokun sidesteps this issue as well, as any timed-out HTLC can be claimed with a fee-bumpable transaction directly without RBF-carve-out.\n(As well, it seems to me that, if both nodes support doing so, a Poon-Dryja channel can be upgraded, without onchain activity, to a Decker-Russell-Osuntokun channel: sign a transaction spending the funding tx to a txo that has been set up as Decker-Russell-Osuntokun, do not broadcast that transaction, then revoke the latest Poon-Dryja commitment transactions, then switch the mechanism over to Decker-Russell-Osuntokun; you still need to monitor for previous Poon-Dryja commitment transactions, but HTLCs now sidestep the issue under discussion here.)\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2020-04-22T04:18:29",
                "message_text_only": "> So what is needed is to allow B to add fees to HTLC-Timeout:\n\nIndeed, anchors as defined in #lightning-rfc/688 allows this.\n\n>  * With `SIGHASH_NOINPUT` we can make the C-side signature\n>  `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n>  signature for a higher-fee version of HTLC-Timeout (assuming my cached\n>  understanding of `SIGHASH_NOINPUT` still holds).\n\nno_input isn't needed. With simply single+anyone can pay, then B can attach\na new input+output pair to increase the fees on their HTLC redemption\ntransaction. As you mention, they now enter into a race against this\nmalicious ndoe to bump up their fees in order to win over the other party.\n\nIf the malicious node uses a non-RBF signalled transaction to sweep their\nHTLC, then we enter into another level of race, but this time on the mempool\npropagation level. However, if there exists a relay path to a miner running\nfull RBF, then B's higher fee rate spend will win over.\n\n-- Laolu\n\nOn Tue, Apr 21, 2020 at 9:13 PM ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Matt, and list,\n>\n>\n>\n> >     RBF Pinning HTLC Transactions (aka \"Oh, wait, I can steal funds,\n> how, now?\")\n> >     =============================\n> >\n> >     You'll note that in the discussion of RBF pinning we were pretty\n> broad, and that that discussion seems to in fact cover\n> >     our HTLC outputs, at least when spent via (3) or (4). It does, and\n> in fact this is a pretty severe issue in today's\n> >     lightning protocol [2]. A lightning counterparty (C, who received\n> the HTLC from B, who received it from A) today could,\n> >     if B broadcasts the commitment transaction, spend an HTLC using the\n> preimage with a low-fee, RBF-disabled transaction.\n> >     After a few blocks, A could claim the HTLC from B via the timeout\n> mechanism, and then after a few days, C could get the\n> >     HTLC-claiming transaction mined via some out-of-band agreement with\n> a small miner. This leaves B short the HTLC value.\n>\n> My (cached) understanding is that, since RBF is signalled using\n> `nSequence`, any `OP_CHECKSEQUENCEVERIFY` also automatically imposes the\n> requirement \"must be RBF-enabled\", including `<0> OP_CHECKSEQUENCEVERIFY`.\n> Adding that clause (2 bytes in witness if my math is correct) to the\n> hashlock branch may be sufficient to prevent C from making an RBF-disabled\n> transaction.\n>\n> But then you mention out-of-band agreements with miners, which basically\n> means the transaction might not be in the mempool at all, in which case the\n> vulnerability is not really about RBF or relay, but sheer economics.\n>\n> The payment is A->B->C, and the HTLC A->B must have a larger timeout (L +\n> 1) than the HTLC B->C (L), in abstract non-block units.\n> The vulnerability you are describing means that the current time must now\n> be L + 1 or greater (\"A could claim the HTLC from B via the timeout\n> mechanism\", meaning the A->B HTLC has timed out already).\n>\n> If so, then the B->C transaction has already timed out in the past and can\n> be claimed in two ways, either via B timeout branch or C hashlock branch.\n> This sets up a game where B and C bid to miners to get their version of\n> reality committed onchain.\n> (We can neglect out-of-band agreements here; miners have the incentive to\n> publicly leak such agreements so that other potential bidders can offer\n> even higher fees for their versions of that transaction.)\n>\n> Before L+1, C has no incentive to bid, since placing any bid at all will\n> leak the preimage, which B can then turn around and use to spend from A,\n> and A and C cannot steal from B.\n>\n> Thus, B should ensure that *before* L+1, the HTLC-Timeout has been\n> committed onchain, which outright prevents this bidding war from even\n> starting.\n>\n> The issue then is that B is using a pre-signed HTLC-timeout, which is\n> needed since it is its commitment tx that was broadcast.\n> This prevents B from RBF-ing the HTLC-Timeout transaction.\n>\n> So what is needed is to allow B to add fees to HTLC-Timeout:\n>\n> * We can add an RBF carve-out output to HTLC-Timeout, at the cost of more\n> blockspace.\n> * With `SIGHASH_NOINPUT` we can make the C-side signature\n> `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n> signature for a higher-fee version of HTLC-Timeout (assuming my cached\n> understanding of `SIGHASH_NOINPUT` still holds).\n>\n> With this, B can exponentially increase the fee as L+1 approaches.\n> If B can get HTLC-Timeout confirmed before L+1, then C cannot steal the\n> HTLC value at all, since the UTXO it could steal from has already been\n> spent.\n>\n> In particular, it does not seem to me that it is necessary to change the\n> hashlock-branch transaction of C at all, since this mechanism is enough to\n> sidestep the issue (as I understand it).\n> But it does point to a need to make HTLC-Timeout (and possibly\n> symmetrically, HTLC-Success) also fee-bumpable.\n>\n> Note as well that this does not require a mempool: B can run in\n> `blocksonly` mode and as each block comes in from L to L+1, if HTLC-Timeout\n> is not confirmed, feebump HTLC-Timeout.\n> In particular, HTLC-Timeout comes into play only if B broadcast its own\n> commitment transaction, and B *should* be aware that it did so --- there is\n> still no need for mempool monitoring here.\n>\n>\n> Now, of course this only delays the war.\n> Let us now consider what C can do to ensure that the bidding war will\n> happen eventually.\n>\n> * C can bribe a miner to prevent HTLC-Timeout from confirming between L\n> and L+1.\n>   * Or in other words, this is a censorship attack.\n>     * The Bitcoin censorship-resistance model is that censored\n> transactions can be fee-bumped, which attracts non-censoring miners to try\n> their luck at mining and evict the censoring miner.\n>       * Thus, letting B bump the fee on HTLC-Timeout is precisely the\n> mechanism we need.\n>       * This sets up a bidding war between C requesting miners to censor,\n> vs. B requesting miners to confirm, but that only sets the stage for a\n> second bidding war later between C and B, thus C is at a disadvantage: it\n> has to bribe miners to censor continuously from L to L+1 *and* additional\n> bribe miners to confirm its transaction after L+1, whereas B can offer its\n> bribe as being something that miners can claim now without waiting after\n> L+1.\n>\n>\n>\n> The issue of course is the additional output that bloats the UTXO set and\n> requires another transaction to claim later.\n> And if we have `SIGHASH_NOINPUT`, it seems to me that\n> Decker-Russell-Osuntokun sidesteps this issue as well, as any timed-out\n> HTLC can be claimed with a fee-bumpable transaction directly without\n> RBF-carve-out.\n> (As well, it seems to me that, if both nodes support doing so, a\n> Poon-Dryja channel can be upgraded, without onchain activity, to a\n> Decker-Russell-Osuntokun channel: sign a transaction spending the funding\n> tx to a txo that has been set up as Decker-Russell-Osuntokun, do not\n> broadcast that transaction, then revoke the latest Poon-Dryja commitment\n> transactions, then switch the mechanism over to Decker-Russell-Osuntokun;\n> you still need to monitor for previous Poon-Dryja commitment transactions,\n> but HTLCs now sidestep the issue under discussion here.)\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200421/fd98ca19/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-22T06:08:06",
                "message_text_only": "Good morning Laolu, Matt, and list,\n\n\n> > \u00a0* With `SIGHASH_NOINPUT` we can make the C-side signature\n> > \u00a0`SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n> > \u00a0signature for a higher-fee version of HTLC-Timeout (assuming my cached\n> > \u00a0understanding of `SIGHASH_NOINPUT` still holds).\n>\n> no_input isn't needed. With simply single+anyone can pay, then B can attach\n> a new input+output pair to increase the fees on their HTLC redemption\n> transaction. As you mention, they now enter into a race against this\n> malicious ndoe to bump up their fees in order to win over the other party.\n\nRight, right, that works as well.\n\n>\n> If the malicious node uses a non-RBF signalled transaction to sweep their\n> HTLC, then we enter into another level of race, but this time on the mempool\n> propagation level. However, if there exists a relay path to a miner running\n> full RBF, then B's higher fee rate spend will win over.\n\nHmm.\n\nSo basically:\n\n* B has no mempool, because it wants to reduce its costs and etc.\n* C broadcasts a non-RBF claim tx with low fee before A->B locktime (L+1).\n* B does not notice this tx because:\n  1.  The tx is too low fee to be put in a block.\n  2.  B has no mempool so it cannot see the tx being propagated over the P2P network.\n* B tries to broadcast higher-fee HTLC-timeout, but fails because it cannot replace a non-RBF tx.\n* After L+1, C contacts the miners off-band and offers fee payment by other means.\n\nIt seems to me that, if my cached understanding that `<0> OP_CHECKSEQUENCEVERIFY` is sufficient to require RBF-flagging, then adding that to the hashlock branch (2 witness bytes, 0.5 weight) would be a pretty low-weight mitigation against this attack.\n\nSo I think the combination below gives us good size:\n\n* The HTLC-Timeout signature from C is flagged with `OP_SINGLE|OP_ANYONECANPAY`.\n  * Normally, the HTLC-Timeout still deducts the fee from the value of the UTXO being spent.\n  * However, if B notices that the L+1 timeout is approaching, it can fee-bump HTLC-Timeout with some onchain funds, recreating its own signature but reusing the (still valid) C signature.\n* The hashlock branch in this case includes `<0> OP_CHECKSEQUENCEVERIFY`, preventing C from broadcasting a low-fee claim tx.\n\nThis has the advantages:\n\n* B does not need a mempool still and can run in `blocksonly`.\n* The normal path is still the same as current behavior, we \"only\" add a new path where if the L+1 timeout is approaching we fee-bump the HTLC-Timeout.\n* Costs are pretty low:\n  * No need for extra RBF carve-out txo.\n  * Just two additional witness bytes in the hashlock branch.\n* No mempool rule changes needed, can be done with the P2P network of today.\n  * Probably still resilient even with future changes in mempool rules, as long as typical RBF behaviors still remain.\n\nIs my understanding correct?\n\nRegards,\nZmnSCPxj\n\n>\n> -- Laolu\n>\n> On Tue, Apr 21, 2020 at 9:13 PM ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > Good morning Matt, and list,\n> >\n> > >\u00a0 \u00a0 \u00a0RBF Pinning HTLC Transactions (aka \"Oh, wait, I can steal funds, how, now?\")\n> > >\u00a0 \u00a0 \u00a0=============================\n> > >\n> > >\u00a0 \u00a0 \u00a0You'll note that in the discussion of RBF pinning we were pretty broad, and that that discussion seems to in fact cover\n> > >\u00a0 \u00a0 \u00a0our HTLC outputs, at least when spent via (3) or (4). It does, and in fact this is a pretty severe issue in today's\n> > >\u00a0 \u00a0 \u00a0lightning protocol [2]. A lightning counterparty (C, who received the HTLC from B, who received it from A) today could,\n> > >\u00a0 \u00a0 \u00a0if B broadcasts the commitment transaction, spend an HTLC using the preimage with a low-fee, RBF-disabled transaction.\n> > >\u00a0 \u00a0 \u00a0After a few blocks, A could claim the HTLC from B via the timeout mechanism, and then after a few days, C could get the\n> > >\u00a0 \u00a0 \u00a0HTLC-claiming transaction mined via some out-of-band agreement with a small miner. This leaves B short the HTLC value.\n> >\n> > My (cached) understanding is that, since RBF is signalled using `nSequence`, any `OP_CHECKSEQUENCEVERIFY` also automatically imposes the requirement \"must be RBF-enabled\", including `<0> OP_CHECKSEQUENCEVERIFY`.\n> > Adding that clause (2 bytes in witness if my math is correct) to the hashlock branch may be sufficient to prevent C from making an RBF-disabled transaction.\n> >\n> > But then you mention out-of-band agreements with miners, which basically means the transaction might not be in the mempool at all, in which case the vulnerability is not really about RBF or relay, but sheer economics.\n> >\n> > The payment is A->B->C, and the HTLC A->B must have a larger timeout (L + 1) than the HTLC B->C (L), in abstract non-block units.\n> > The vulnerability you are describing means that the current time must now be L + 1 or greater (\"A could claim the HTLC from B via the timeout mechanism\", meaning the A->B HTLC has timed out already).\n> >\n> > If so, then the B->C transaction has already timed out in the past and can be claimed in two ways, either via B timeout branch or C hashlock branch.\n> > This sets up a game where B and C bid to miners to get their version of reality committed onchain.\n> > (We can neglect out-of-band agreements here; miners have the incentive to publicly leak such agreements so that other potential bidders can offer even higher fees for their versions of that transaction.)\n> >\n> > Before L+1, C has no incentive to bid, since placing any bid at all will leak the preimage, which B can then turn around and use to spend from A, and A and C cannot steal from B.\n> >\n> > Thus, B should ensure that *before* L+1, the HTLC-Timeout has been committed onchain, which outright prevents this bidding war from even starting.\n> >\n> > The issue then is that B is using a pre-signed HTLC-timeout, which is needed since it is its commitment tx that was broadcast.\n> > This prevents B from RBF-ing the HTLC-Timeout transaction.\n> >\n> > So what is needed is to allow B to add fees to HTLC-Timeout:\n> >\n> > * We can add an RBF carve-out output to HTLC-Timeout, at the cost of more blockspace.\n> > * With `SIGHASH_NOINPUT` we can make the C-side signature `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side signature for a higher-fee version of HTLC-Timeout (assuming my cached understanding of `SIGHASH_NOINPUT` still holds).\n> >\n> > With this, B can exponentially increase the fee as L+1 approaches.\n> > If B can get HTLC-Timeout confirmed before L+1, then C cannot steal the HTLC value at all, since the UTXO it could steal from has already been spent.\n> >\n> > In particular, it does not seem to me that it is necessary to change the hashlock-branch transaction of C at all, since this mechanism is enough to sidestep the issue (as I understand it).\n> > But it does point to a need to make HTLC-Timeout (and possibly symmetrically, HTLC-Success) also fee-bumpable.\n> >\n> > Note as well that this does not require a mempool: B can run in `blocksonly` mode and as each block comes in from L to L+1, if HTLC-Timeout is not confirmed, feebump HTLC-Timeout.\n> > In particular, HTLC-Timeout comes into play only if B broadcast its own commitment transaction, and B *should* be aware that it did so --- there is still no need for mempool monitoring here.\n> >\n> > Now, of course this only delays the war.\n> > Let us now consider what C can do to ensure that the bidding war will happen eventually.\n> >\n> > * C can bribe a miner to prevent HTLC-Timeout from confirming between L and L+1.\n> > \u00a0 * Or in other words, this is a censorship attack.\n> > \u00a0 \u00a0 * The Bitcoin censorship-resistance model is that censored transactions can be fee-bumped, which attracts non-censoring miners to try their luck at mining and evict the censoring miner.\n> > \u00a0 \u00a0 \u00a0 * Thus, letting B bump the fee on HTLC-Timeout is precisely the mechanism we need.\n> > \u00a0 \u00a0 \u00a0 * This sets up a bidding war between C requesting miners to censor, vs. B requesting miners to confirm, but that only sets the stage for a second bidding war later between C and B, thus C is at a disadvantage: it has to bribe miners to censor continuously from L to L+1 *and* additional bribe miners to confirm its transaction after L+1, whereas B can offer its bribe as being something that miners can claim now without waiting after L+1.\n> >\n> > The issue of course is the additional output that bloats the UTXO set and requires another transaction to claim later.\n> > And if we have `SIGHASH_NOINPUT`, it seems to me that Decker-Russell-Osuntokun sidesteps this issue as well, as any timed-out HTLC can be claimed with a fee-bumpable transaction directly without RBF-carve-out.\n> > (As well, it seems to me that, if both nodes support doing so, a Poon-Dryja channel can be upgraded, without onchain activity, to a Decker-Russell-Osuntokun channel: sign a transaction spending the funding tx to a txo that has been set up as Decker-Russell-Osuntokun, do not broadcast that transaction, then revoke the latest Poon-Dryja commitment transactions, then switch the mechanism over to Decker-Russell-Osuntokun; you still need to monitor for previous Poon-Dryja commitment transactions, but HTLCs now sidestep the issue under discussion here.)\n> >\n> > Regards,\n> > ZmnSCPxj\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Antoine Riard",
                "date": "2020-04-22T08:01:23",
                "message_text_only": "Personally, I would have wait a bit before to go public on this, like\nletting some implementations\nincreasing their CLTV deltas, but anyway, it's here now.\n\nMempool-pinning attacks were already discussed on this list [0], but what\nwe found is you\ncan _reverse_ the scenario, where it's not the malicious party delaying\nconfirmation of honest\nparty transactions but malicious deliberately stucking its own transactions\nin the mempool to avoid\nconfirmation of timeout. And therefore gaming inter-link timelock to\nprovoke an unbalanced\nsettlement for the victim (\"aka you pay forward, but don't get pay\nbackward\").\n\nHow much attacks are practical is based on how you can leverage mempool\nrules to pin your own\ntransaction. What you're looking for is a  _mempool-obstruction_ trick, i.e\na way to get honest party\ntransaction being bounce off due to your transaction being already there.\n\nBeyond disabling RBF on your transaction (with current protocol, not anchor\nproposal), there is\ntwo likely candidates:\n* BIP 125 rule 3: \"The replacement transaction pays an absolute fee of at\nleast the sum paid by the original transactions.\"\n* BIP 125 rule 5: \"The number of original transactions to be replaced and\ntheir descendant transactions which will be evicted from the mempool must\nnot exceed a total of 100 transactions.\"\n\nLet's go through whole scenario:\n* Mallory and Eve are colluding\n* Eve and Mallory are opening channels with Alice, Mallory do a bit of\nrebalancing\nto get full incoming capacity, like receiving funds on an onchain address\nthrough another Alice\nlink\n* Eve send a HTLC #1 to Mallory through Alice expirying at block 100\n* Eve send a second HTLC #2 to Mallory through Alice, expirying at block\n110 on outgoing link\n(A<->M), 120 on incoming link (E<->A)\n* Before block 100, without cancellation from Mallory, Alice will\nforce-close channel and broadcast\nher local commitment and HTLC-timeout to get back HTLC #1\n* Alice can't broadcast HTLC-timeout for HTLC #2 as it's only expires at 110\n* Mallory can broadcast its Pinning Preimage Tx on offered HTLC #2 output\non Alice's transaction,\nfeerate is maliciously chosen to get in network mempools but never to\nconfirm. Absolute fee must\nbe higher than HTLC-timeout #2, a fact known to Mallory. There is no p2p\nrace.\n* As Alice doesn't watch the mempool, she is never going to learn the\npreimage to redeeem incoming\nHTLC #2\n* At block 110, Alice is going to broadcast HTLC-timeout #2, feerate may be\nhigher but as absolute\nfee is lower, it's going to be rejected from network mempools as\nreplacement for Pinning Preimage\nTx (BIP 125 rule 3)\n* At block 120, Eve closes channel and HTLC-timeout HTLC #2\n* Mallory can RBF its Pinning Preimage Tx by a high-feerate one and get it\nconfirmed\n\nNew anchor_output proposal, by disabling RBF, forces attacker to bid on the\nabsolute fee. It may\nbe now a risk to loose the fee if Pinning Tx is confirming. You may extend\nyour \"pinning\nlease\" by ejecting your malicious tx, like conflicting or trimming out of\nthe mempool one of its\nparents. And then reannounce your preimage tx with a\nlower-feerate-but-still-high-fee before a\nnew block and a honest HTLC-timeout rebroadcast.\n\nAFAICT, even with anchor_output deployed, even assuming empty mempools,\nsuccess rate and economic\nrationality of attacks is finding such cheap, reliable \"pinning lease\nextension\" trick.\n\nI think any mempool watching mitigation is at best a cat-and-mouse hack.\nContrary to node\nadvancing towards a global blockchain view thanks to PoW, network mempools\ndon't have a convergence\nguarantee. This means,  in a distributed system like bitcoin, node don't\nsee events in the same\norder, Alice may observe tx X, tx Y, tx Z and Bob may observe tx Z, tx X,\ntx Y. And order of events\naffects if a future event is going to be rejected or not, like if tx Z\ndisable-RBF and tx X try to\nreplace Z, Alice accepts X and Bob rejects it. And this divergence may\nperserve until a new block.\n\nPractically, it means an attacker can provoke a local conflict to bounce\noff HTLC preimage tx out\nof your mempool while broadcasting preimage tx without conflict to the rest\nof the network by\ntweaking tx-relay protocol and so easily manipulating order of events for\nevery node. A local\nconflict is easy to provoke, just make tx A double-spent by both\nHTLC-preimage-tx and non-RBF-tx-B.\nAnnounce txA+txB to mempool victim and txA+HTLC-preimage-tx to rest of\nnetwork. When rest of\nnetwork announce HTLC-preimage-tx, it's going to rejected by your mempool.\n\nProvoking local conflict assumes of course _interlayer_ mapping by an\nattacker, i.e mapping your LN\nnode to your full-node(s). Last time, we check, there was 982 match by IP\nfor 4,500 LN/52,000\nfull-node. Mapping heuristics is an ongoing research subject and sadly\nseems affordable.\n\nYes a) you can enable full-RBF on your local node but blinding conflicting\nmay still be with higher\nfeerate as everything is attacker malleable b) you may want to catch tx and\nextract preimage\non the p2p wire, but processing raw transaction would be such a DoS\nvector...\n\nOverall, I think we all agree on the long term direction to get a\nContracting-Protocols-Enhanced\nmempool with a multiparty-safe-API, bundled with package relay deployment.\nEven if there is current\nmove toward this direction, this may take longer than expected as with any\ncritical-safety\ncomponent in Core.\n\nA temporary fix could be to resuscitate old work to ensure peering through\na full-RBF propagation path,\nbut p2p implications are hard to gauge, like wouldn't guarantee p2p\ncensorship resistance of this...\n\nIt's quite a tangled issue, with a good deal of both bitcoin and lightning\nknowledge so feel free\nto verify and double-check more than usual\n\nCheers\n\n[0]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002240.html\n\nLe mer. 22 avr. 2020 \u00e0 02:08, ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> Good morning Laolu, Matt, and list,\n>\n>\n> > >  * With `SIGHASH_NOINPUT` we can make the C-side signature\n> > >  `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n> > >  signature for a higher-fee version of HTLC-Timeout (assuming my cached\n> > >  understanding of `SIGHASH_NOINPUT` still holds).\n> >\n> > no_input isn't needed. With simply single+anyone can pay, then B can\n> attach\n> > a new input+output pair to increase the fees on their HTLC redemption\n> > transaction. As you mention, they now enter into a race against this\n> > malicious ndoe to bump up their fees in order to win over the other\n> party.\n>\n> Right, right, that works as well.\n>\n> >\n> > If the malicious node uses a non-RBF signalled transaction to sweep their\n> > HTLC, then we enter into another level of race, but this time on the\n> mempool\n> > propagation level. However, if there exists a relay path to a miner\n> running\n> > full RBF, then B's higher fee rate spend will win over.\n>\n> Hmm.\n>\n> So basically:\n>\n> * B has no mempool, because it wants to reduce its costs and etc.\n> * C broadcasts a non-RBF claim tx with low fee before A->B locktime (L+1).\n> * B does not notice this tx because:\n>   1.  The tx is too low fee to be put in a block.\n>   2.  B has no mempool so it cannot see the tx being propagated over the\n> P2P network.\n> * B tries to broadcast higher-fee HTLC-timeout, but fails because it\n> cannot replace a non-RBF tx.\n> * After L+1, C contacts the miners off-band and offers fee payment by\n> other means.\n>\n> It seems to me that, if my cached understanding that `<0>\n> OP_CHECKSEQUENCEVERIFY` is sufficient to require RBF-flagging, then adding\n> that to the hashlock branch (2 witness bytes, 0.5 weight) would be a pretty\n> low-weight mitigation against this attack.\n>\n> So I think the combination below gives us good size:\n>\n> * The HTLC-Timeout signature from C is flagged with\n> `OP_SINGLE|OP_ANYONECANPAY`.\n>   * Normally, the HTLC-Timeout still deducts the fee from the value of the\n> UTXO being spent.\n>   * However, if B notices that the L+1 timeout is approaching, it can\n> fee-bump HTLC-Timeout with some onchain funds, recreating its own signature\n> but reusing the (still valid) C signature.\n> * The hashlock branch in this case includes `<0> OP_CHECKSEQUENCEVERIFY`,\n> preventing C from broadcasting a low-fee claim tx.\n>\n> This has the advantages:\n>\n> * B does not need a mempool still and can run in `blocksonly`.\n> * The normal path is still the same as current behavior, we \"only\" add a\n> new path where if the L+1 timeout is approaching we fee-bump the\n> HTLC-Timeout.\n> * Costs are pretty low:\n>   * No need for extra RBF carve-out txo.\n>   * Just two additional witness bytes in the hashlock branch.\n> * No mempool rule changes needed, can be done with the P2P network of\n> today.\n>   * Probably still resilient even with future changes in mempool rules, as\n> long as typical RBF behaviors still remain.\n>\n> Is my understanding correct?\n>\n> Regards,\n> ZmnSCPxj\n>\n> >\n> > -- Laolu\n> >\n> > On Tue, Apr 21, 2020 at 9:13 PM ZmnSCPxj via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> > > Good morning Matt, and list,\n> > >\n> > > >     RBF Pinning HTLC Transactions (aka \"Oh, wait, I can steal funds,\n> how, now?\")\n> > > >     =============================\n> > > >\n> > > >     You'll note that in the discussion of RBF pinning we were pretty\n> broad, and that that discussion seems to in fact cover\n> > > >     our HTLC outputs, at least when spent via (3) or (4). It does,\n> and in fact this is a pretty severe issue in today's\n> > > >     lightning protocol [2]. A lightning counterparty (C, who\n> received the HTLC from B, who received it from A) today could,\n> > > >     if B broadcasts the commitment transaction, spend an HTLC using\n> the preimage with a low-fee, RBF-disabled transaction.\n> > > >     After a few blocks, A could claim the HTLC from B via the\n> timeout mechanism, and then after a few days, C could get the\n> > > >     HTLC-claiming transaction mined via some out-of-band agreement\n> with a small miner. This leaves B short the HTLC value.\n> > >\n> > > My (cached) understanding is that, since RBF is signalled using\n> `nSequence`, any `OP_CHECKSEQUENCEVERIFY` also automatically imposes the\n> requirement \"must be RBF-enabled\", including `<0> OP_CHECKSEQUENCEVERIFY`.\n> > > Adding that clause (2 bytes in witness if my math is correct) to the\n> hashlock branch may be sufficient to prevent C from making an RBF-disabled\n> transaction.\n> > >\n> > > But then you mention out-of-band agreements with miners, which\n> basically means the transaction might not be in the mempool at all, in\n> which case the vulnerability is not really about RBF or relay, but sheer\n> economics.\n> > >\n> > > The payment is A->B->C, and the HTLC A->B must have a larger timeout\n> (L + 1) than the HTLC B->C (L), in abstract non-block units.\n> > > The vulnerability you are describing means that the current time must\n> now be L + 1 or greater (\"A could claim the HTLC from B via the timeout\n> mechanism\", meaning the A->B HTLC has timed out already).\n> > >\n> > > If so, then the B->C transaction has already timed out in the past and\n> can be claimed in two ways, either via B timeout branch or C hashlock\n> branch.\n> > > This sets up a game where B and C bid to miners to get their version\n> of reality committed onchain.\n> > > (We can neglect out-of-band agreements here; miners have the incentive\n> to publicly leak such agreements so that other potential bidders can offer\n> even higher fees for their versions of that transaction.)\n> > >\n> > > Before L+1, C has no incentive to bid, since placing any bid at all\n> will leak the preimage, which B can then turn around and use to spend from\n> A, and A and C cannot steal from B.\n> > >\n> > > Thus, B should ensure that *before* L+1, the HTLC-Timeout has been\n> committed onchain, which outright prevents this bidding war from even\n> starting.\n> > >\n> > > The issue then is that B is using a pre-signed HTLC-timeout, which is\n> needed since it is its commitment tx that was broadcast.\n> > > This prevents B from RBF-ing the HTLC-Timeout transaction.\n> > >\n> > > So what is needed is to allow B to add fees to HTLC-Timeout:\n> > >\n> > > * We can add an RBF carve-out output to HTLC-Timeout, at the cost of\n> more blockspace.\n> > > * With `SIGHASH_NOINPUT` we can make the C-side signature\n> `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n> signature for a higher-fee version of HTLC-Timeout (assuming my cached\n> understanding of `SIGHASH_NOINPUT` still holds).\n> > >\n> > > With this, B can exponentially increase the fee as L+1 approaches.\n> > > If B can get HTLC-Timeout confirmed before L+1, then C cannot steal\n> the HTLC value at all, since the UTXO it could steal from has already been\n> spent.\n> > >\n> > > In particular, it does not seem to me that it is necessary to change\n> the hashlock-branch transaction of C at all, since this mechanism is enough\n> to sidestep the issue (as I understand it).\n> > > But it does point to a need to make HTLC-Timeout (and possibly\n> symmetrically, HTLC-Success) also fee-bumpable.\n> > >\n> > > Note as well that this does not require a mempool: B can run in\n> `blocksonly` mode and as each block comes in from L to L+1, if HTLC-Timeout\n> is not confirmed, feebump HTLC-Timeout.\n> > > In particular, HTLC-Timeout comes into play only if B broadcast its\n> own commitment transaction, and B *should* be aware that it did so ---\n> there is still no need for mempool monitoring here.\n> > >\n> > > Now, of course this only delays the war.\n> > > Let us now consider what C can do to ensure that the bidding war will\n> happen eventually.\n> > >\n> > > * C can bribe a miner to prevent HTLC-Timeout from confirming between\n> L and L+1.\n> > >   * Or in other words, this is a censorship attack.\n> > >     * The Bitcoin censorship-resistance model is that censored\n> transactions can be fee-bumped, which attracts non-censoring miners to try\n> their luck at mining and evict the censoring miner.\n> > >       * Thus, letting B bump the fee on HTLC-Timeout is precisely the\n> mechanism we need.\n> > >       * This sets up a bidding war between C requesting miners to\n> censor, vs. B requesting miners to confirm, but that only sets the stage\n> for a second bidding war later between C and B, thus C is at a\n> disadvantage: it has to bribe miners to censor continuously from L to L+1\n> *and* additional bribe miners to confirm its transaction after L+1, whereas\n> B can offer its bribe as being something that miners can claim now without\n> waiting after L+1.\n> > >\n> > > The issue of course is the additional output that bloats the UTXO set\n> and requires another transaction to claim later.\n> > > And if we have `SIGHASH_NOINPUT`, it seems to me that\n> Decker-Russell-Osuntokun sidesteps this issue as well, as any timed-out\n> HTLC can be claimed with a fee-bumpable transaction directly without\n> RBF-carve-out.\n> > > (As well, it seems to me that, if both nodes support doing so, a\n> Poon-Dryja channel can be upgraded, without onchain activity, to a\n> Decker-Russell-Osuntokun channel: sign a transaction spending the funding\n> tx to a txo that has been set up as Decker-Russell-Osuntokun, do not\n> broadcast that transaction, then revoke the latest Poon-Dryja commitment\n> transactions, then switch the mechanism over to Decker-Russell-Osuntokun;\n> you still need to monitor for previous Poon-Dryja commitment transactions,\n> but HTLCs now sidestep the issue under discussion here.)\n> > >\n> > > Regards,\n> > > ZmnSCPxj\n> > > _______________________________________________\n> > > bitcoin-dev mailing list\n> > > bitcoin-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200422/951291f7/attachment-0001.html>"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2020-04-22T08:55:42",
                "message_text_only": "Hi Antoine and list,\n\nThanks for raising this. There's one step I'd like to understand further:\n\n* Mallory can broadcast its Pinning Preimage Tx on offered HTLC #2 output\n> on Alice's transaction,\n> feerate is maliciously chosen to get in network mempools but never to\n> confirm. Absolute fee must\n> be higher than HTLC-timeout #2, a fact known to Mallory. There is no p2p\n> race.\n>\n\nCan you detail how the \"absolute fee\" is computed here?\nDoesn't that mean that if this had a higher fee than the htlc-timeout, and\nthe htlc-timeout fee was\nchosen to confirm quickly (that's why we have an annoying `update_fee`),\nthe htlc-success will confirm\nquickly (which makes the problem disappear)?\nBecause once the commit tx is confirmed, the \"package\" consists of only the\nhtlc-success, doesn't it?\n\nI think the devil will be in the details here, so it's worth expanding on\nthe fee calculation imho.\n\nThanks!\nBastien\n\nLe mer. 22 avr. 2020 \u00e0 10:01, Antoine Riard <antoine.riard at gmail.com> a\n\u00e9crit :\n\n> Personally, I would have wait a bit before to go public on this, like\n> letting some implementations\n> increasing their CLTV deltas, but anyway, it's here now.\n>\n> Mempool-pinning attacks were already discussed on this list [0], but what\n> we found is you\n> can _reverse_ the scenario, where it's not the malicious party delaying\n> confirmation of honest\n> party transactions but malicious deliberately stucking its own\n> transactions in the mempool to avoid\n> confirmation of timeout. And therefore gaming inter-link timelock to\n> provoke an unbalanced\n> settlement for the victim (\"aka you pay forward, but don't get pay\n> backward\").\n>\n> How much attacks are practical is based on how you can leverage mempool\n> rules to pin your own\n> transaction. What you're looking for is a  _mempool-obstruction_ trick,\n> i.e a way to get honest party\n> transaction being bounce off due to your transaction being already there.\n>\n> Beyond disabling RBF on your transaction (with current protocol, not\n> anchor proposal), there is\n> two likely candidates:\n> * BIP 125 rule 3: \"The replacement transaction pays an absolute fee of at\n> least the sum paid by the original transactions.\"\n> * BIP 125 rule 5: \"The number of original transactions to be replaced and\n> their descendant transactions which will be evicted from the mempool must\n> not exceed a total of 100 transactions.\"\n>\n> Let's go through whole scenario:\n> * Mallory and Eve are colluding\n> * Eve and Mallory are opening channels with Alice, Mallory do a bit of\n> rebalancing\n> to get full incoming capacity, like receiving funds on an onchain address\n> through another Alice\n> link\n> * Eve send a HTLC #1 to Mallory through Alice expirying at block 100\n> * Eve send a second HTLC #2 to Mallory through Alice, expirying at block\n> 110 on outgoing link\n> (A<->M), 120 on incoming link (E<->A)\n> * Before block 100, without cancellation from Mallory, Alice will\n> force-close channel and broadcast\n> her local commitment and HTLC-timeout to get back HTLC #1\n> * Alice can't broadcast HTLC-timeout for HTLC #2 as it's only expires at\n> 110\n> * Mallory can broadcast its Pinning Preimage Tx on offered HTLC #2 output\n> on Alice's transaction,\n> feerate is maliciously chosen to get in network mempools but never to\n> confirm. Absolute fee must\n> be higher than HTLC-timeout #2, a fact known to Mallory. There is no p2p\n> race.\n> * As Alice doesn't watch the mempool, she is never going to learn the\n> preimage to redeeem incoming\n> HTLC #2\n> * At block 110, Alice is going to broadcast HTLC-timeout #2, feerate may\n> be higher but as absolute\n> fee is lower, it's going to be rejected from network mempools as\n> replacement for Pinning Preimage\n> Tx (BIP 125 rule 3)\n> * At block 120, Eve closes channel and HTLC-timeout HTLC #2\n> * Mallory can RBF its Pinning Preimage Tx by a high-feerate one and get it\n> confirmed\n>\n> New anchor_output proposal, by disabling RBF, forces attacker to bid on\n> the absolute fee. It may\n> be now a risk to loose the fee if Pinning Tx is confirming. You may extend\n> your \"pinning\n> lease\" by ejecting your malicious tx, like conflicting or trimming out of\n> the mempool one of its\n> parents. And then reannounce your preimage tx with a\n> lower-feerate-but-still-high-fee before a\n> new block and a honest HTLC-timeout rebroadcast.\n>\n> AFAICT, even with anchor_output deployed, even assuming empty mempools,\n> success rate and economic\n> rationality of attacks is finding such cheap, reliable \"pinning lease\n> extension\" trick.\n>\n> I think any mempool watching mitigation is at best a cat-and-mouse hack.\n> Contrary to node\n> advancing towards a global blockchain view thanks to PoW, network mempools\n> don't have a convergence\n> guarantee. This means,  in a distributed system like bitcoin, node don't\n> see events in the same\n> order, Alice may observe tx X, tx Y, tx Z and Bob may observe tx Z, tx X,\n> tx Y. And order of events\n> affects if a future event is going to be rejected or not, like if tx Z\n> disable-RBF and tx X try to\n> replace Z, Alice accepts X and Bob rejects it. And this divergence may\n> perserve until a new block.\n>\n> Practically, it means an attacker can provoke a local conflict to bounce\n> off HTLC preimage tx out\n> of your mempool while broadcasting preimage tx without conflict to the\n> rest of the network by\n> tweaking tx-relay protocol and so easily manipulating order of events for\n> every node. A local\n> conflict is easy to provoke, just make tx A double-spent by both\n> HTLC-preimage-tx and non-RBF-tx-B.\n> Announce txA+txB to mempool victim and txA+HTLC-preimage-tx to rest of\n> network. When rest of\n> network announce HTLC-preimage-tx, it's going to rejected by your mempool.\n>\n> Provoking local conflict assumes of course _interlayer_ mapping by an\n> attacker, i.e mapping your LN\n> node to your full-node(s). Last time, we check, there was 982 match by IP\n> for 4,500 LN/52,000\n> full-node. Mapping heuristics is an ongoing research subject and sadly\n> seems affordable.\n>\n> Yes a) you can enable full-RBF on your local node but blinding conflicting\n> may still be with higher\n> feerate as everything is attacker malleable b) you may want to catch tx\n> and extract preimage\n> on the p2p wire, but processing raw transaction would be such a DoS\n> vector...\n>\n> Overall, I think we all agree on the long term direction to get a\n> Contracting-Protocols-Enhanced\n> mempool with a multiparty-safe-API, bundled with package relay deployment.\n> Even if there is current\n> move toward this direction, this may take longer than expected as with any\n> critical-safety\n> component in Core.\n>\n> A temporary fix could be to resuscitate old work to ensure peering through\n> a full-RBF propagation path,\n> but p2p implications are hard to gauge, like wouldn't guarantee p2p\n> censorship resistance of this...\n>\n> It's quite a tangled issue, with a good deal of both bitcoin and lightning\n> knowledge so feel free\n> to verify and double-check more than usual\n>\n> Cheers\n>\n> [0]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002240.html\n>\n> Le mer. 22 avr. 2020 \u00e0 02:08, ZmnSCPxj via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n>\n>> Good morning Laolu, Matt, and list,\n>>\n>>\n>> > >  * With `SIGHASH_NOINPUT` we can make the C-side signature\n>> > >  `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n>> > >  signature for a higher-fee version of HTLC-Timeout (assuming my\n>> cached\n>> > >  understanding of `SIGHASH_NOINPUT` still holds).\n>> >\n>> > no_input isn't needed. With simply single+anyone can pay, then B can\n>> attach\n>> > a new input+output pair to increase the fees on their HTLC redemption\n>> > transaction. As you mention, they now enter into a race against this\n>> > malicious ndoe to bump up their fees in order to win over the other\n>> party.\n>>\n>> Right, right, that works as well.\n>>\n>> >\n>> > If the malicious node uses a non-RBF signalled transaction to sweep\n>> their\n>> > HTLC, then we enter into another level of race, but this time on the\n>> mempool\n>> > propagation level. However, if there exists a relay path to a miner\n>> running\n>> > full RBF, then B's higher fee rate spend will win over.\n>>\n>> Hmm.\n>>\n>> So basically:\n>>\n>> * B has no mempool, because it wants to reduce its costs and etc.\n>> * C broadcasts a non-RBF claim tx with low fee before A->B locktime (L+1).\n>> * B does not notice this tx because:\n>>   1.  The tx is too low fee to be put in a block.\n>>   2.  B has no mempool so it cannot see the tx being propagated over the\n>> P2P network.\n>> * B tries to broadcast higher-fee HTLC-timeout, but fails because it\n>> cannot replace a non-RBF tx.\n>> * After L+1, C contacts the miners off-band and offers fee payment by\n>> other means.\n>>\n>> It seems to me that, if my cached understanding that `<0>\n>> OP_CHECKSEQUENCEVERIFY` is sufficient to require RBF-flagging, then adding\n>> that to the hashlock branch (2 witness bytes, 0.5 weight) would be a pretty\n>> low-weight mitigation against this attack.\n>>\n>> So I think the combination below gives us good size:\n>>\n>> * The HTLC-Timeout signature from C is flagged with\n>> `OP_SINGLE|OP_ANYONECANPAY`.\n>>   * Normally, the HTLC-Timeout still deducts the fee from the value of\n>> the UTXO being spent.\n>>   * However, if B notices that the L+1 timeout is approaching, it can\n>> fee-bump HTLC-Timeout with some onchain funds, recreating its own signature\n>> but reusing the (still valid) C signature.\n>> * The hashlock branch in this case includes `<0> OP_CHECKSEQUENCEVERIFY`,\n>> preventing C from broadcasting a low-fee claim tx.\n>>\n>> This has the advantages:\n>>\n>> * B does not need a mempool still and can run in `blocksonly`.\n>> * The normal path is still the same as current behavior, we \"only\" add a\n>> new path where if the L+1 timeout is approaching we fee-bump the\n>> HTLC-Timeout.\n>> * Costs are pretty low:\n>>   * No need for extra RBF carve-out txo.\n>>   * Just two additional witness bytes in the hashlock branch.\n>> * No mempool rule changes needed, can be done with the P2P network of\n>> today.\n>>   * Probably still resilient even with future changes in mempool rules,\n>> as long as typical RBF behaviors still remain.\n>>\n>> Is my understanding correct?\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n>> >\n>> > -- Laolu\n>> >\n>> > On Tue, Apr 21, 2020 at 9:13 PM ZmnSCPxj via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> >\n>> > > Good morning Matt, and list,\n>> > >\n>> > > >     RBF Pinning HTLC Transactions (aka \"Oh, wait, I can steal\n>> funds, how, now?\")\n>> > > >     =============================\n>> > > >\n>> > > >     You'll note that in the discussion of RBF pinning we were\n>> pretty broad, and that that discussion seems to in fact cover\n>> > > >     our HTLC outputs, at least when spent via (3) or (4). It does,\n>> and in fact this is a pretty severe issue in today's\n>> > > >     lightning protocol [2]. A lightning counterparty (C, who\n>> received the HTLC from B, who received it from A) today could,\n>> > > >     if B broadcasts the commitment transaction, spend an HTLC using\n>> the preimage with a low-fee, RBF-disabled transaction.\n>> > > >     After a few blocks, A could claim the HTLC from B via the\n>> timeout mechanism, and then after a few days, C could get the\n>> > > >     HTLC-claiming transaction mined via some out-of-band agreement\n>> with a small miner. This leaves B short the HTLC value.\n>> > >\n>> > > My (cached) understanding is that, since RBF is signalled using\n>> `nSequence`, any `OP_CHECKSEQUENCEVERIFY` also automatically imposes the\n>> requirement \"must be RBF-enabled\", including `<0> OP_CHECKSEQUENCEVERIFY`.\n>> > > Adding that clause (2 bytes in witness if my math is correct) to the\n>> hashlock branch may be sufficient to prevent C from making an RBF-disabled\n>> transaction.\n>> > >\n>> > > But then you mention out-of-band agreements with miners, which\n>> basically means the transaction might not be in the mempool at all, in\n>> which case the vulnerability is not really about RBF or relay, but sheer\n>> economics.\n>> > >\n>> > > The payment is A->B->C, and the HTLC A->B must have a larger timeout\n>> (L + 1) than the HTLC B->C (L), in abstract non-block units.\n>> > > The vulnerability you are describing means that the current time must\n>> now be L + 1 or greater (\"A could claim the HTLC from B via the timeout\n>> mechanism\", meaning the A->B HTLC has timed out already).\n>> > >\n>> > > If so, then the B->C transaction has already timed out in the past\n>> and can be claimed in two ways, either via B timeout branch or C hashlock\n>> branch.\n>> > > This sets up a game where B and C bid to miners to get their version\n>> of reality committed onchain.\n>> > > (We can neglect out-of-band agreements here; miners have the\n>> incentive to publicly leak such agreements so that other potential bidders\n>> can offer even higher fees for their versions of that transaction.)\n>> > >\n>> > > Before L+1, C has no incentive to bid, since placing any bid at all\n>> will leak the preimage, which B can then turn around and use to spend from\n>> A, and A and C cannot steal from B.\n>> > >\n>> > > Thus, B should ensure that *before* L+1, the HTLC-Timeout has been\n>> committed onchain, which outright prevents this bidding war from even\n>> starting.\n>> > >\n>> > > The issue then is that B is using a pre-signed HTLC-timeout, which is\n>> needed since it is its commitment tx that was broadcast.\n>> > > This prevents B from RBF-ing the HTLC-Timeout transaction.\n>> > >\n>> > > So what is needed is to allow B to add fees to HTLC-Timeout:\n>> > >\n>> > > * We can add an RBF carve-out output to HTLC-Timeout, at the cost of\n>> more blockspace.\n>> > > * With `SIGHASH_NOINPUT` we can make the C-side signature\n>> `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n>> signature for a higher-fee version of HTLC-Timeout (assuming my cached\n>> understanding of `SIGHASH_NOINPUT` still holds).\n>> > >\n>> > > With this, B can exponentially increase the fee as L+1 approaches.\n>> > > If B can get HTLC-Timeout confirmed before L+1, then C cannot steal\n>> the HTLC value at all, since the UTXO it could steal from has already been\n>> spent.\n>> > >\n>> > > In particular, it does not seem to me that it is necessary to change\n>> the hashlock-branch transaction of C at all, since this mechanism is enough\n>> to sidestep the issue (as I understand it).\n>> > > But it does point to a need to make HTLC-Timeout (and possibly\n>> symmetrically, HTLC-Success) also fee-bumpable.\n>> > >\n>> > > Note as well that this does not require a mempool: B can run in\n>> `blocksonly` mode and as each block comes in from L to L+1, if HTLC-Timeout\n>> is not confirmed, feebump HTLC-Timeout.\n>> > > In particular, HTLC-Timeout comes into play only if B broadcast its\n>> own commitment transaction, and B *should* be aware that it did so ---\n>> there is still no need for mempool monitoring here.\n>> > >\n>> > > Now, of course this only delays the war.\n>> > > Let us now consider what C can do to ensure that the bidding war will\n>> happen eventually.\n>> > >\n>> > > * C can bribe a miner to prevent HTLC-Timeout from confirming between\n>> L and L+1.\n>> > >   * Or in other words, this is a censorship attack.\n>> > >     * The Bitcoin censorship-resistance model is that censored\n>> transactions can be fee-bumped, which attracts non-censoring miners to try\n>> their luck at mining and evict the censoring miner.\n>> > >       * Thus, letting B bump the fee on HTLC-Timeout is precisely the\n>> mechanism we need.\n>> > >       * This sets up a bidding war between C requesting miners to\n>> censor, vs. B requesting miners to confirm, but that only sets the stage\n>> for a second bidding war later between C and B, thus C is at a\n>> disadvantage: it has to bribe miners to censor continuously from L to L+1\n>> *and* additional bribe miners to confirm its transaction after L+1, whereas\n>> B can offer its bribe as being something that miners can claim now without\n>> waiting after L+1.\n>> > >\n>> > > The issue of course is the additional output that bloats the UTXO set\n>> and requires another transaction to claim later.\n>> > > And if we have `SIGHASH_NOINPUT`, it seems to me that\n>> Decker-Russell-Osuntokun sidesteps this issue as well, as any timed-out\n>> HTLC can be claimed with a fee-bumpable transaction directly without\n>> RBF-carve-out.\n>> > > (As well, it seems to me that, if both nodes support doing so, a\n>> Poon-Dryja channel can be upgraded, without onchain activity, to a\n>> Decker-Russell-Osuntokun channel: sign a transaction spending the funding\n>> tx to a txo that has been set up as Decker-Russell-Osuntokun, do not\n>> broadcast that transaction, then revoke the latest Poon-Dryja commitment\n>> transactions, then switch the mechanism over to Decker-Russell-Osuntokun;\n>> you still need to monitor for previous Poon-Dryja commitment transactions,\n>> but HTLCs now sidestep the issue under discussion here.)\n>> > >\n>> > > Regards,\n>> > > ZmnSCPxj\n>> > > _______________________________________________\n>> > > bitcoin-dev mailing list\n>> > > bitcoin-dev at lists.linuxfoundation.org\n>> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200422/cdacdb19/attachment-0001.html>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2020-04-22T23:05:17",
                "message_text_only": "Hi Z,\n\n> It seems to me that, if my cached understanding that `<0>\n> OP_CHECKSEQUENCEVERIFY` is sufficient to require RBF-flagging, then adding\n> that to the hashlock branch (2 witness bytes, 0.5 weight) would be a\npretty\n> low-weight mitigation against this attack.\n\nI think this works...so they're forced to spend the output with a non-final\nsequence number, meaning it *must* signal RBF. In this case, now it's the\ntimeout-er vs the success-er racing based on fee rate. If the honest party\n(the\none trying to time out the HTLC) bids a fee rate higher (need to also\naccount\nfor the whole absolute fee replacement thing), then things should generally\nwork out in their favor.\n\n-- Laolu\n\n\nOn Tue, Apr 21, 2020 at 11:08 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Laolu, Matt, and list,\n>\n>\n> > >  * With `SIGHASH_NOINPUT` we can make the C-side signature\n> > >  `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n> > >  signature for a higher-fee version of HTLC-Timeout (assuming my cached\n> > >  understanding of `SIGHASH_NOINPUT` still holds).\n> >\n> > no_input isn't needed. With simply single+anyone can pay, then B can\n> attach\n> > a new input+output pair to increase the fees on their HTLC redemption\n> > transaction. As you mention, they now enter into a race against this\n> > malicious ndoe to bump up their fees in order to win over the other\n> party.\n>\n> Right, right, that works as well.\n>\n> >\n> > If the malicious node uses a non-RBF signalled transaction to sweep their\n> > HTLC, then we enter into another level of race, but this time on the\n> mempool\n> > propagation level. However, if there exists a relay path to a miner\n> running\n> > full RBF, then B's higher fee rate spend will win over.\n>\n> Hmm.\n>\n> So basically:\n>\n> * B has no mempool, because it wants to reduce its costs and etc.\n> * C broadcasts a non-RBF claim tx with low fee before A->B locktime (L+1).\n> * B does not notice this tx because:\n>   1.  The tx is too low fee to be put in a block.\n>   2.  B has no mempool so it cannot see the tx being propagated over the\n> P2P network.\n> * B tries to broadcast higher-fee HTLC-timeout, but fails because it\n> cannot replace a non-RBF tx.\n> * After L+1, C contacts the miners off-band and offers fee payment by\n> other means.\n>\n> It seems to me that, if my cached understanding that `<0>\n> OP_CHECKSEQUENCEVERIFY` is sufficient to require RBF-flagging, then adding\n> that to the hashlock branch (2 witness bytes, 0.5 weight) would be a pretty\n> low-weight mitigation against this attack.\n>\n> So I think the combination below gives us good size:\n>\n> * The HTLC-Timeout signature from C is flagged with\n> `OP_SINGLE|OP_ANYONECANPAY`.\n>   * Normally, the HTLC-Timeout still deducts the fee from the value of the\n> UTXO being spent.\n>   * However, if B notices that the L+1 timeout is approaching, it can\n> fee-bump HTLC-Timeout with some onchain funds, recreating its own signature\n> but reusing the (still valid) C signature.\n> * The hashlock branch in this case includes `<0> OP_CHECKSEQUENCEVERIFY`,\n> preventing C from broadcasting a low-fee claim tx.\n>\n> This has the advantages:\n>\n> * B does not need a mempool still and can run in `blocksonly`.\n> * The normal path is still the same as current behavior, we \"only\" add a\n> new path where if the L+1 timeout is approaching we fee-bump the\n> HTLC-Timeout.\n> * Costs are pretty low:\n>   * No need for extra RBF carve-out txo.\n>   * Just two additional witness bytes in the hashlock branch.\n> * No mempool rule changes needed, can be done with the P2P network of\n> today.\n>   * Probably still resilient even with future changes in mempool rules, as\n> long as typical RBF behaviors still remain.\n>\n> Is my understanding correct?\n>\n> Regards,\n> ZmnSCPxj\n>\n> >\n> > -- Laolu\n> >\n> > On Tue, Apr 21, 2020 at 9:13 PM ZmnSCPxj via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> > > Good morning Matt, and list,\n> > >\n> > > >     RBF Pinning HTLC Transactions (aka \"Oh, wait, I can steal funds,\n> how, now?\")\n> > > >     =============================\n> > > >\n> > > >     You'll note that in the discussion of RBF pinning we were pretty\n> broad, and that that discussion seems to in fact cover\n> > > >     our HTLC outputs, at least when spent via (3) or (4). It does,\n> and in fact this is a pretty severe issue in today's\n> > > >     lightning protocol [2]. A lightning counterparty (C, who\n> received the HTLC from B, who received it from A) today could,\n> > > >     if B broadcasts the commitment transaction, spend an HTLC using\n> the preimage with a low-fee, RBF-disabled transaction.\n> > > >     After a few blocks, A could claim the HTLC from B via the\n> timeout mechanism, and then after a few days, C could get the\n> > > >     HTLC-claiming transaction mined via some out-of-band agreement\n> with a small miner. This leaves B short the HTLC value.\n> > >\n> > > My (cached) understanding is that, since RBF is signalled using\n> `nSequence`, any `OP_CHECKSEQUENCEVERIFY` also automatically imposes the\n> requirement \"must be RBF-enabled\", including `<0> OP_CHECKSEQUENCEVERIFY`.\n> > > Adding that clause (2 bytes in witness if my math is correct) to the\n> hashlock branch may be sufficient to prevent C from making an RBF-disabled\n> transaction.\n> > >\n> > > But then you mention out-of-band agreements with miners, which\n> basically means the transaction might not be in the mempool at all, in\n> which case the vulnerability is not really about RBF or relay, but sheer\n> economics.\n> > >\n> > > The payment is A->B->C, and the HTLC A->B must have a larger timeout\n> (L + 1) than the HTLC B->C (L), in abstract non-block units.\n> > > The vulnerability you are describing means that the current time must\n> now be L + 1 or greater (\"A could claim the HTLC from B via the timeout\n> mechanism\", meaning the A->B HTLC has timed out already).\n> > >\n> > > If so, then the B->C transaction has already timed out in the past and\n> can be claimed in two ways, either via B timeout branch or C hashlock\n> branch.\n> > > This sets up a game where B and C bid to miners to get their version\n> of reality committed onchain.\n> > > (We can neglect out-of-band agreements here; miners have the incentive\n> to publicly leak such agreements so that other potential bidders can offer\n> even higher fees for their versions of that transaction.)\n> > >\n> > > Before L+1, C has no incentive to bid, since placing any bid at all\n> will leak the preimage, which B can then turn around and use to spend from\n> A, and A and C cannot steal from B.\n> > >\n> > > Thus, B should ensure that *before* L+1, the HTLC-Timeout has been\n> committed onchain, which outright prevents this bidding war from even\n> starting.\n> > >\n> > > The issue then is that B is using a pre-signed HTLC-timeout, which is\n> needed since it is its commitment tx that was broadcast.\n> > > This prevents B from RBF-ing the HTLC-Timeout transaction.\n> > >\n> > > So what is needed is to allow B to add fees to HTLC-Timeout:\n> > >\n> > > * We can add an RBF carve-out output to HTLC-Timeout, at the cost of\n> more blockspace.\n> > > * With `SIGHASH_NOINPUT` we can make the C-side signature\n> `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n> signature for a higher-fee version of HTLC-Timeout (assuming my cached\n> understanding of `SIGHASH_NOINPUT` still holds).\n> > >\n> > > With this, B can exponentially increase the fee as L+1 approaches.\n> > > If B can get HTLC-Timeout confirmed before L+1, then C cannot steal\n> the HTLC value at all, since the UTXO it could steal from has already been\n> spent.\n> > >\n> > > In particular, it does not seem to me that it is necessary to change\n> the hashlock-branch transaction of C at all, since this mechanism is enough\n> to sidestep the issue (as I understand it).\n> > > But it does point to a need to make HTLC-Timeout (and possibly\n> symmetrically, HTLC-Success) also fee-bumpable.\n> > >\n> > > Note as well that this does not require a mempool: B can run in\n> `blocksonly` mode and as each block comes in from L to L+1, if HTLC-Timeout\n> is not confirmed, feebump HTLC-Timeout.\n> > > In particular, HTLC-Timeout comes into play only if B broadcast its\n> own commitment transaction, and B *should* be aware that it did so ---\n> there is still no need for mempool monitoring here.\n> > >\n> > > Now, of course this only delays the war.\n> > > Let us now consider what C can do to ensure that the bidding war will\n> happen eventually.\n> > >\n> > > * C can bribe a miner to prevent HTLC-Timeout from confirming between\n> L and L+1.\n> > >   * Or in other words, this is a censorship attack.\n> > >     * The Bitcoin censorship-resistance model is that censored\n> transactions can be fee-bumped, which attracts non-censoring miners to try\n> their luck at mining and evict the censoring miner.\n> > >       * Thus, letting B bump the fee on HTLC-Timeout is precisely the\n> mechanism we need.\n> > >       * This sets up a bidding war between C requesting miners to\n> censor, vs. B requesting miners to confirm, but that only sets the stage\n> for a second bidding war later between C and B, thus C is at a\n> disadvantage: it has to bribe miners to censor continuously from L to L+1\n> *and* additional bribe miners to confirm its transaction after L+1, whereas\n> B can offer its bribe as being something that miners can claim now without\n> waiting after L+1.\n> > >\n> > > The issue of course is the additional output that bloats the UTXO set\n> and requires another transaction to claim later.\n> > > And if we have `SIGHASH_NOINPUT`, it seems to me that\n> Decker-Russell-Osuntokun sidesteps this issue as well, as any timed-out\n> HTLC can be claimed with a fee-bumpable transaction directly without\n> RBF-carve-out.\n> > > (As well, it seems to me that, if both nodes support doing so, a\n> Poon-Dryja channel can be upgraded, without onchain activity, to a\n> Decker-Russell-Osuntokun channel: sign a transaction spending the funding\n> tx to a txo that has been set up as Decker-Russell-Osuntokun, do not\n> broadcast that transaction, then revoke the latest Poon-Dryja commitment\n> transactions, then switch the mechanism over to Decker-Russell-Osuntokun;\n> you still need to monitor for previous Poon-Dryja commitment transactions,\n> but HTLCs now sidestep the issue under discussion here.)\n> > >\n> > > Regards,\n> > > ZmnSCPxj\n> > > _______________________________________________\n> > > bitcoin-dev mailing list\n> > > bitcoin-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200422/3fdeb85d/attachment-0001.html>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2020-04-22T23:11:08",
                "message_text_only": "Hi z,\n\nActually, the current anchors proposal already does this, since it enforces\na\nCSV of 1 block before the HTLCs can be spent (the block after\nconfirmation). So\nI think we already do this, meaning the malicious node is already forced to\nuse\nan RBF-replaceable transaction.\n\n-- Laolu\n\n\nOn Wed, Apr 22, 2020 at 4:05 PM Olaoluwa Osuntokun <laolu32 at gmail.com>\nwrote:\n\n> Hi Z,\n>\n> > It seems to me that, if my cached understanding that `<0>\n> > OP_CHECKSEQUENCEVERIFY` is sufficient to require RBF-flagging, then\n> adding\n> > that to the hashlock branch (2 witness bytes, 0.5 weight) would be a\n> pretty\n> > low-weight mitigation against this attack.\n>\n> I think this works...so they're forced to spend the output with a non-final\n> sequence number, meaning it *must* signal RBF. In this case, now it's the\n> timeout-er vs the success-er racing based on fee rate. If the honest party\n> (the\n> one trying to time out the HTLC) bids a fee rate higher (need to also\n> account\n> for the whole absolute fee replacement thing), then things should generally\n> work out in their favor.\n>\n> -- Laolu\n>\n>\n> On Tue, Apr 21, 2020 at 11:08 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n>> Good morning Laolu, Matt, and list,\n>>\n>>\n>> > >  * With `SIGHASH_NOINPUT` we can make the C-side signature\n>> > >  `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n>> > >  signature for a higher-fee version of HTLC-Timeout (assuming my\n>> cached\n>> > >  understanding of `SIGHASH_NOINPUT` still holds).\n>> >\n>> > no_input isn't needed. With simply single+anyone can pay, then B can\n>> attach\n>> > a new input+output pair to increase the fees on their HTLC redemption\n>> > transaction. As you mention, they now enter into a race against this\n>> > malicious ndoe to bump up their fees in order to win over the other\n>> party.\n>>\n>> Right, right, that works as well.\n>>\n>> >\n>> > If the malicious node uses a non-RBF signalled transaction to sweep\n>> their\n>> > HTLC, then we enter into another level of race, but this time on the\n>> mempool\n>> > propagation level. However, if there exists a relay path to a miner\n>> running\n>> > full RBF, then B's higher fee rate spend will win over.\n>>\n>> Hmm.\n>>\n>> So basically:\n>>\n>> * B has no mempool, because it wants to reduce its costs and etc.\n>> * C broadcasts a non-RBF claim tx with low fee before A->B locktime (L+1).\n>> * B does not notice this tx because:\n>>   1.  The tx is too low fee to be put in a block.\n>>   2.  B has no mempool so it cannot see the tx being propagated over the\n>> P2P network.\n>> * B tries to broadcast higher-fee HTLC-timeout, but fails because it\n>> cannot replace a non-RBF tx.\n>> * After L+1, C contacts the miners off-band and offers fee payment by\n>> other means.\n>>\n>> It seems to me that, if my cached understanding that `<0>\n>> OP_CHECKSEQUENCEVERIFY` is sufficient to require RBF-flagging, then adding\n>> that to the hashlock branch (2 witness bytes, 0.5 weight) would be a pretty\n>> low-weight mitigation against this attack.\n>>\n>> So I think the combination below gives us good size:\n>>\n>> * The HTLC-Timeout signature from C is flagged with\n>> `OP_SINGLE|OP_ANYONECANPAY`.\n>>   * Normally, the HTLC-Timeout still deducts the fee from the value of\n>> the UTXO being spent.\n>>   * However, if B notices that the L+1 timeout is approaching, it can\n>> fee-bump HTLC-Timeout with some onchain funds, recreating its own signature\n>> but reusing the (still valid) C signature.\n>> * The hashlock branch in this case includes `<0> OP_CHECKSEQUENCEVERIFY`,\n>> preventing C from broadcasting a low-fee claim tx.\n>>\n>> This has the advantages:\n>>\n>> * B does not need a mempool still and can run in `blocksonly`.\n>> * The normal path is still the same as current behavior, we \"only\" add a\n>> new path where if the L+1 timeout is approaching we fee-bump the\n>> HTLC-Timeout.\n>> * Costs are pretty low:\n>>   * No need for extra RBF carve-out txo.\n>>   * Just two additional witness bytes in the hashlock branch.\n>> * No mempool rule changes needed, can be done with the P2P network of\n>> today.\n>>   * Probably still resilient even with future changes in mempool rules,\n>> as long as typical RBF behaviors still remain.\n>>\n>> Is my understanding correct?\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n>> >\n>> > -- Laolu\n>> >\n>> > On Tue, Apr 21, 2020 at 9:13 PM ZmnSCPxj via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> >\n>> > > Good morning Matt, and list,\n>> > >\n>> > > >     RBF Pinning HTLC Transactions (aka \"Oh, wait, I can steal\n>> funds, how, now?\")\n>> > > >     =============================\n>> > > >\n>> > > >     You'll note that in the discussion of RBF pinning we were\n>> pretty broad, and that that discussion seems to in fact cover\n>> > > >     our HTLC outputs, at least when spent via (3) or (4). It does,\n>> and in fact this is a pretty severe issue in today's\n>> > > >     lightning protocol [2]. A lightning counterparty (C, who\n>> received the HTLC from B, who received it from A) today could,\n>> > > >     if B broadcasts the commitment transaction, spend an HTLC using\n>> the preimage with a low-fee, RBF-disabled transaction.\n>> > > >     After a few blocks, A could claim the HTLC from B via the\n>> timeout mechanism, and then after a few days, C could get the\n>> > > >     HTLC-claiming transaction mined via some out-of-band agreement\n>> with a small miner. This leaves B short the HTLC value.\n>> > >\n>> > > My (cached) understanding is that, since RBF is signalled using\n>> `nSequence`, any `OP_CHECKSEQUENCEVERIFY` also automatically imposes the\n>> requirement \"must be RBF-enabled\", including `<0> OP_CHECKSEQUENCEVERIFY`.\n>> > > Adding that clause (2 bytes in witness if my math is correct) to the\n>> hashlock branch may be sufficient to prevent C from making an RBF-disabled\n>> transaction.\n>> > >\n>> > > But then you mention out-of-band agreements with miners, which\n>> basically means the transaction might not be in the mempool at all, in\n>> which case the vulnerability is not really about RBF or relay, but sheer\n>> economics.\n>> > >\n>> > > The payment is A->B->C, and the HTLC A->B must have a larger timeout\n>> (L + 1) than the HTLC B->C (L), in abstract non-block units.\n>> > > The vulnerability you are describing means that the current time must\n>> now be L + 1 or greater (\"A could claim the HTLC from B via the timeout\n>> mechanism\", meaning the A->B HTLC has timed out already).\n>> > >\n>> > > If so, then the B->C transaction has already timed out in the past\n>> and can be claimed in two ways, either via B timeout branch or C hashlock\n>> branch.\n>> > > This sets up a game where B and C bid to miners to get their version\n>> of reality committed onchain.\n>> > > (We can neglect out-of-band agreements here; miners have the\n>> incentive to publicly leak such agreements so that other potential bidders\n>> can offer even higher fees for their versions of that transaction.)\n>> > >\n>> > > Before L+1, C has no incentive to bid, since placing any bid at all\n>> will leak the preimage, which B can then turn around and use to spend from\n>> A, and A and C cannot steal from B.\n>> > >\n>> > > Thus, B should ensure that *before* L+1, the HTLC-Timeout has been\n>> committed onchain, which outright prevents this bidding war from even\n>> starting.\n>> > >\n>> > > The issue then is that B is using a pre-signed HTLC-timeout, which is\n>> needed since it is its commitment tx that was broadcast.\n>> > > This prevents B from RBF-ing the HTLC-Timeout transaction.\n>> > >\n>> > > So what is needed is to allow B to add fees to HTLC-Timeout:\n>> > >\n>> > > * We can add an RBF carve-out output to HTLC-Timeout, at the cost of\n>> more blockspace.\n>> > > * With `SIGHASH_NOINPUT` we can make the C-side signature\n>> `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n>> signature for a higher-fee version of HTLC-Timeout (assuming my cached\n>> understanding of `SIGHASH_NOINPUT` still holds).\n>> > >\n>> > > With this, B can exponentially increase the fee as L+1 approaches.\n>> > > If B can get HTLC-Timeout confirmed before L+1, then C cannot steal\n>> the HTLC value at all, since the UTXO it could steal from has already been\n>> spent.\n>> > >\n>> > > In particular, it does not seem to me that it is necessary to change\n>> the hashlock-branch transaction of C at all, since this mechanism is enough\n>> to sidestep the issue (as I understand it).\n>> > > But it does point to a need to make HTLC-Timeout (and possibly\n>> symmetrically, HTLC-Success) also fee-bumpable.\n>> > >\n>> > > Note as well that this does not require a mempool: B can run in\n>> `blocksonly` mode and as each block comes in from L to L+1, if HTLC-Timeout\n>> is not confirmed, feebump HTLC-Timeout.\n>> > > In particular, HTLC-Timeout comes into play only if B broadcast its\n>> own commitment transaction, and B *should* be aware that it did so ---\n>> there is still no need for mempool monitoring here.\n>> > >\n>> > > Now, of course this only delays the war.\n>> > > Let us now consider what C can do to ensure that the bidding war will\n>> happen eventually.\n>> > >\n>> > > * C can bribe a miner to prevent HTLC-Timeout from confirming between\n>> L and L+1.\n>> > >   * Or in other words, this is a censorship attack.\n>> > >     * The Bitcoin censorship-resistance model is that censored\n>> transactions can be fee-bumped, which attracts non-censoring miners to try\n>> their luck at mining and evict the censoring miner.\n>> > >       * Thus, letting B bump the fee on HTLC-Timeout is precisely the\n>> mechanism we need.\n>> > >       * This sets up a bidding war between C requesting miners to\n>> censor, vs. B requesting miners to confirm, but that only sets the stage\n>> for a second bidding war later between C and B, thus C is at a\n>> disadvantage: it has to bribe miners to censor continuously from L to L+1\n>> *and* additional bribe miners to confirm its transaction after L+1, whereas\n>> B can offer its bribe as being something that miners can claim now without\n>> waiting after L+1.\n>> > >\n>> > > The issue of course is the additional output that bloats the UTXO set\n>> and requires another transaction to claim later.\n>> > > And if we have `SIGHASH_NOINPUT`, it seems to me that\n>> Decker-Russell-Osuntokun sidesteps this issue as well, as any timed-out\n>> HTLC can be claimed with a fee-bumpable transaction directly without\n>> RBF-carve-out.\n>> > > (As well, it seems to me that, if both nodes support doing so, a\n>> Poon-Dryja channel can be upgraded, without onchain activity, to a\n>> Decker-Russell-Osuntokun channel: sign a transaction spending the funding\n>> tx to a txo that has been set up as Decker-Russell-Osuntokun, do not\n>> broadcast that transaction, then revoke the latest Poon-Dryja commitment\n>> transactions, then switch the mechanism over to Decker-Russell-Osuntokun;\n>> you still need to monitor for previous Poon-Dryja commitment transactions,\n>> but HTLCs now sidestep the issue under discussion here.)\n>> > >\n>> > > Regards,\n>> > > ZmnSCPxj\n>> > > _______________________________________________\n>> > > bitcoin-dev mailing list\n>> > > bitcoin-dev at lists.linuxfoundation.org\n>> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200422/b51b1fe1/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-04-22T16:56:38",
                "message_text_only": "On 4/22/20 12:12 AM, ZmnSCPxj wrote:\n> Good morning Matt, and list,\n> \n> \n> \n>>     RBF Pinning HTLC Transactions (aka \"Oh, wait, I can steal funds, how, now?\")\n>>     =============================\n>>\n>>     You'll note that in the discussion of RBF pinning we were pretty broad, and that that discussion seems to in fact cover\n>>     our HTLC outputs, at least when spent via (3) or (4). It does, and in fact this is a pretty severe issue in today's\n>>     lightning protocol [2]. A lightning counterparty (C, who received the HTLC from B, who received it from A) today could,\n>>     if B broadcasts the commitment transaction, spend an HTLC using the preimage with a low-fee, RBF-disabled transaction.\n>>     After a few blocks, A could claim the HTLC from B via the timeout mechanism, and then after a few days, C could get the\n>>     HTLC-claiming transaction mined via some out-of-band agreement with a small miner. This leaves B short the HTLC value.\n> \n> My (cached) understanding is that, since RBF is signalled using `nSequence`, any `OP_CHECKSEQUENCEVERIFY` also automatically imposes the requirement \"must be RBF-enabled\", including `<0> OP_CHECKSEQUENCEVERIFY`.\n> Adding that clause (2 bytes in witness if my math is correct) to the hashlock branch may be sufficient to prevent C from making an RBF-disabled transaction.\n\nHmm, indeed, though note that (IIRC) you can break this by adding children or parents which are *not* RBF-enabled and\nthen the package may lose the ability to be RBF'd.\n\n> But then you mention out-of-band agreements with miners, which basically means the transaction might not be in the mempool at all, in which case the vulnerability is not really about RBF or relay, but sheer economics.\n\nNo. The whole point of this attack is that you keep a transaction in the mempool but unconfirmed via RBF pinning, which\nprevents an *alternative* transaction from being confirmed. You then have plenty of time to go get it confirmed later.\n\n> The payment is A->B->C, and the HTLC A->B must have a larger timeout (L + 1) than the HTLC B->C (L), in abstract non-block units.\n> The vulnerability you are describing means that the current time must now be L + 1 or greater (\"A could claim the HTLC from B via the timeout mechanism\", meaning the A->B HTLC has timed out already).\n> \n> If so, then the B->C transaction has already timed out in the past and can be claimed in two ways, either via B timeout branch or C hashlock branch.\n> This sets up a game where B and C bid to miners to get their version of reality committed onchain.\n> (We can neglect out-of-band agreements here; miners have the incentive to publicly leak such agreements so that other potential bidders can offer even higher fees for their versions of that transaction.)\n\nRight, I think I didn't explain clearly enough. The point is that, here, B tries to broadcast the timeout transaction\nbut cannot because there is an in-mempool conflict.\n\n> Before L+1, C has no incentive to bid, since placing any bid at all will leak the preimage, which B can then turn around and use to spend from A, and A and C cannot steal from B.\n> \n> Thus, B should ensure that *before* L+1, the HTLC-Timeout has been committed onchain, which outright prevents this bidding war from even starting.\n> \n> The issue then is that B is using a pre-signed HTLC-timeout, which is needed since it is its commitment tx that was broadcast.\n> This prevents B from RBF-ing the HTLC-Timeout transaction.\n> \n> So what is needed is to allow B to add fees to HTLC-Timeout:\n> \n> * We can add an RBF carve-out output to HTLC-Timeout, at the cost of more blockspace.\n> * With `SIGHASH_NOINPUT` we can make the C-side signature `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side signature for a higher-fee version of HTLC-Timeout (assuming my cached understanding of `SIGHASH_NOINPUT` still holds).\n\nThis does not solve the issue because you can add as many fees as you want, as long as the transaction is RBF-pinned,\nthere is not much you can do in an automated fashion.\n\n> With this, B can exponentially increase the fee as L+1 approaches.\n> If B can get HTLC-Timeout confirmed before L+1, then C cannot steal the HTLC value at all, since the UTXO it could steal from has already been spent.\n> \n> In particular, it does not seem to me that it is necessary to change the hashlock-branch transaction of C at all, since this mechanism is enough to sidestep the issue (as I understand it).\n> But it does point to a need to make HTLC-Timeout (and possibly symmetrically, HTLC-Success) also fee-bumpable.\n> \n> Note as well that this does not require a mempool: B can run in `blocksonly` mode and as each block comes in from L to L+1, if HTLC-Timeout is not confirmed, feebump HTLC-Timeout.\n> In particular, HTLC-Timeout comes into play only if B broadcast its own commitment transaction, and B *should* be aware that it did so --- there is still no need for mempool monitoring here.\n> \n> \n> Now, of course this only delays the war.\n> Let us now consider what C can do to ensure that the bidding war will happen eventually.\n> \n> * C can bribe a miner to prevent HTLC-Timeout from confirming between L and L+1.\n>   * Or in other words, this is a censorship attack.\n>     * The Bitcoin censorship-resistance model is that censored transactions can be fee-bumped, which attracts non-censoring miners to try their luck at mining and evict the censoring miner.\n>       * Thus, letting B bump the fee on HTLC-Timeout is precisely the mechanism we need.\n>       * This sets up a bidding war between C requesting miners to censor, vs. B requesting miners to confirm, but that only sets the stage for a second bidding war later between C and B, thus C is at a disadvantage: it has to bribe miners to censor continuously from L to L+1 *and* additional bribe miners to confirm its transaction after L+1, whereas B can offer its bribe as being something that miners can claim now without waiting after L+1.\n> \n> \n> \n> The issue of course is the additional output that bloats the UTXO set and requires another transaction to claim later.\n> And if we have `SIGHASH_NOINPUT`, it seems to me that Decker-Russell-Osuntokun sidesteps this issue as well, as any timed-out HTLC can be claimed with a fee-bumpable transaction directly without RBF-carve-out.\n> (As well, it seems to me that, if both nodes support doing so, a Poon-Dryja channel can be upgraded, without onchain activity, to a Decker-Russell-Osuntokun channel: sign a transaction spending the funding tx to a txo that has been set up as Decker-Russell-Osuntokun, do not broadcast that transaction, then revoke the latest Poon-Dryja commitment transactions, then switch the mechanism over to Decker-Russell-Osuntokun; you still need to monitor for previous Poon-Dryja commitment transactions, but HTLCs now sidestep the issue under discussion here.)\n> \n> Regards,\n> ZmnSCPxj\n>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-23T04:50:09",
                "message_text_only": "Good morning lists et al,\n\nLet me try to summarize things a little:\n\n* Suppose we have a forwarding payment A->B->C.\n* Suppose B does not want to maintain a mempool and is running in `blocksonly` mode to reduce operational costs.\n* C triggers B somehow dropping the B<->C channel, such as by sending an `error` message, which will usually cause the other side to drop the channel onchain using its commitment transaction.\n* The dropped B<->C channel has an HTLC (that was set up during the A->B->C forwarding).\n* The HTLC, being used in a Poon-Dryja channel, actually has the following contract text:\n  * The fund may be claimed by either of these clauses:\n    * C can claim, if C shows the preimage of some hash H (hashlock branch).\n    * B and C must agree, and claim after time L (timelock branch).\n* B holds a signature from C that can claim the timelock branch of the HTLC, for a transaction that spends to an output with an `OP_CHECKSEQUENCEVERIFY`.\n  * The signature is `SIGHASH_ALL`, so the transaction has a fixed feerate.\n* C can \"pin\" the HTLC output by spending using the hashlock branch, and creating a large fee, low fee-rate (tree of) transactions.\n  * As it is a low fee-rate, miners have no incentive to put this in a block, especially if unrelated higher-fee-rate transactions exist that would earn them more money.\n  * Even in a full RBF universe, because of the anti-DoS mempool rules, B cannot evict this pinned transaction by just bidding up the feerate.\n    * A replacing transaction cannot evict alternatives unless its absolute fee is greater than the absolute fee of the alternative.\n    * The pinning transaction has a high fee, but is blockspace-wasteful, so it is:\n      * Undesirable to mine (low feerate).\n      * Difficult to evict (high fee).\n* Thus, B is unable to get its timelock-branch transaction in the mempools of miners.\n* C waits until the A->B HTLC times out, then:\n  * C directly contacts miners with an out-of-band proposal to replace its transaction with an alternative that is much smaller and has a low fee, but much better feerate.\n  * Miners, being economically rational, accept this proposal and include this in a block.\n\nThe proposal by Matt is then:\n\n* The hashlock branch should instead be:\n  * B and C must agree, and show the preimage of some hash H (hashlock branch).\n* Then B and C agree that B provides a signature spending the hashlock branch, to a transaction with the outputs:\n  * Normal payment to C.\n  * Hook output to B, which B can use to CPFP this transaction.\n  * Hook output to C, which C can use to CPFP this transaction.\n* B can still (somehow) not maintain a mempool, by:\n  * B broadcasts its timelock transaction.\n  * B tries to CPFP the above hashlock transaction.\n    * If CPFP succeeds, it means the above hashlock transaction exists and B queries the peer for this transaction, extracting the preimage and claiming the A->B HTLC.\n\nIs that a fair summary?\n\n--\n\nNaively, and remembering I am completely ignorant of the exact details of the mempool rules, it seems to me quite strange that we are allowing an undesirable transaction (tree) into the mempool:\n\n* Undesirable to mine (low fee-rate).\n* Difficult to evict (high fee).\n\nMiners are not interested in low fee-rate transactions, as long as higher fee-rate transactions exist.\nAnd being difficult to evict means miners cannot get alternatives that are more lucrative for them.\n\nThe reason (as I understand it) eviction is purposely made difficult here is to prevent certain DoS attacks on Bitcoin nodes, specifically:\n\n1. Attacker sends a low fee-rate tx as a \"root\" transaction.\n2  Attacker sends thousands of low fee-rate tx that build off the above root.\n3. Attacker sends a slightly higher fee-rate alternative to the root, evicting the above tree of txes.\n4. Attacker sends thousands of low fee-rate tx that build off the latest root.\n5. GOTO 3.\n\nHowever, it seems to me, naively, that \"an ounce of prevention is worth a pound of cure\".\n\nAs I understand it, the mempool is organized already into \"packages\" of transactions, and adding a transaction into the mempool involves extending and merging packages.\nPerhaps the size of a package with low fee-rate (relative to the other packages in the mempool) can be limited, so that mempools drop incoming txes that extend a low-fee-rate tree of transactions.\nThis means an attacker cannot send thousands of low fee-rate tx that build off some low fee-rate root tx in the first place, so it can still be evicted easily later without much impact.\n\nNaively, it seems to me to prevent the DoS attack as well, as at step 2 it would be prevented from sending thousands of low fee-rate tx building off the root.\n\nAs well, as I understand it, this merely tightens the mempool acceptance rules, preventing low fee-rate packages from growing (analogous to a consensus-layer softfork).\nThe \"cannot evict high absolute fee\" rule can be retained, as the low-fee-rate package is prevented from reaching a large size.\n\nWould that be workable as a general solution to solve (what I think is) the root cause of this problem?\n\n(This assumes full RBF, I suppose.)\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-04-23T06:21:50",
                "message_text_only": "Great summary, a few notes inline.\n\n> On Apr 22, 2020, at 21:50, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> \n> \ufeffGood morning lists et al,\n> \n> Let me try to summarize things a little:\n> \n> * Suppose we have a forwarding payment A->B->C.\n> * Suppose B does not want to maintain a mempool and is running in `blocksonly` mode to reduce operational costs.\n\nQuick point of clarification, due to the mempool lacking a consensus system (that\u2019s the whole point, after all :p), there are several reasons to that just running a full node/having a mempool isn\u2019t sufficient.\n\n> * C triggers B somehow dropping the B<->C channel, such as by sending an `error` message, which will usually cause the other side to drop the channel onchain using its commitment transaction.\n> * The dropped B<->C channel has an HTLC (that was set up during the A->B->C forwarding).\n> * The HTLC, being used in a Poon-Dryja channel, actually has the following contract text:\n> * The fund may be claimed by either of these clauses:\n> * C can claim, if C shows the preimage of some hash H (hashlock branch).\n> * B and C must agree, and claim after time L (timelock branch).\n> * B holds a signature from C that can claim the timelock branch of the HTLC, for a transaction that spends to an output with an `OP_CHECKSEQUENCEVERIFY`.\n> * The signature is `SIGHASH_ALL`, so the transaction has a fixed feerate.\n> * C can \"pin\" the HTLC output by spending using the hashlock branch, and creating a large fee, low fee-rate (tree of) transactions.\n\nAnother: this is the simplest example. There are also games around the package size limits if I recall correctly.\n\n> * As it is a low fee-rate, miners have no incentive to put this in a block, especially if unrelated higher-fee-rate transactions exist that would earn them more money.\n> * Even in a full RBF universe, because of the anti-DoS mempool rules, B cannot evict this pinned transaction by just bidding up the feerate.\n> * A replacing transaction cannot evict alternatives unless its absolute fee is greater than the absolute fee of the alternative.\n> * The pinning transaction has a high fee, but is blockspace-wasteful, so it is:\n>   * Undesirable to mine (low feerate).\n>   * Difficult to evict (high fee).\n> * Thus, B is unable to get its timelock-branch transaction in the mempools of miners.\n> * C waits until the A->B HTLC times out, then:\n> * C directly contacts miners with an out-of-band proposal to replace its transaction with an alternative that is much smaller and has a low fee, but much better feerate.\n\nOr they can just wait. For example in today\u2019s mempool it would not be strange for a transaction at 1 sat/vbyte to wait a day but eventually confirm.\n\n> * Miners, being economically rational, accept this proposal and include this in a block.\n> \n> The proposal by Matt is then:\n> \n> * The hashlock branch should instead be:\n> * B and C must agree, and show the preimage of some hash H (hashlock branch).\n> * Then B and C agree that B provides a signature spending the hashlock branch, to a transaction with the outputs:\n> * Normal payment to C.\n> * Hook output to B, which B can use to CPFP this transaction.\n> * Hook output to C, which C can use to CPFP this transaction.\n> * B can still (somehow) not maintain a mempool, by:\n> * B broadcasts its timelock transaction.\n> * B tries to CPFP the above hashlock transaction.\n> * If CPFP succeeds, it means the above hashlock transaction exists and B queries the peer for this transaction, extracting the preimage and claiming the A->B HTLC.\n\nNote that no query is required. The problem has been solved and the preimage-containing transaction should now confirm just fine.\n\n> Is that a fair summary?\n\nYep!\n\n> --\n> \n> Naively, and remembering I am completely ignorant of the exact details of the mempool rules, it seems to me quite strange that we are allowing an undesirable transaction (tree) into the mempool:\n> \n> * Undesirable to mine (low fee-rate).\n> * Difficult to evict (high fee).\n\nAs noted, such transactions today are profit in 10 hours. Just because they\u2019re big doesn\u2019t mean they don\u2019t pay.\n\n> Miners are not interested in low fee-rate transactions, as long as higher fee-rate transactions exist.\n> And being difficult to evict means miners cannot get alternatives that are more lucrative for them.\n> \n> The reason (as I understand it) eviction is purposely made difficult here is to prevent certain DoS attacks on Bitcoin nodes, specifically:\n> \n> 1. Attacker sends a low fee-rate tx as a \"root\" transaction.\n> 2  Attacker sends thousands of low fee-rate tx that build off the above root.\n\nI believe the limit is 25, though the point stands, mostly from a total-size perspective.\n\n> 3. Attacker sends a slightly higher fee-rate alternative to the root, evicting the above tree of txes.\n> 4. Attacker sends thousands of low fee-rate tx that build off the latest root.\n> 5. GOTO 3.\n> \n> However, it seems to me, naively, that \"an ounce of prevention is worth a pound of cure\".\n\nSadly, it\u2019s very very easy for this to be a huge amount of CPU + bandwidth.\n\n> As I understand it, the mempool is organized already into \"packages\" of transactions, and adding a transaction into the mempool involves extending and merging packages.\n> Perhaps the size of a package with low fee-rate (relative to the other packages in the mempool) can be limited, so that mempools drop incoming txes that extend a low-fee-rate tree of transactions.\n> This means an attacker cannot send thousands of low fee-rate tx that build off some low fee-rate root tx in the first place, so it can still be evicted easily later without much impact.\n\nThere have been several proposals before around considering a transactions position in the mempool for various similar criteria. The extreme version being simply heavily rate-limiting transaction relay at low feerates and allowing much more liberal replacement of such packages. It isn\u2019t quite perfect for this issue, though, as it may be easy for the attacker to just fill that rate-limit bucket.\n\n> Naively, it seems to me to prevent the DoS attack as well, as at step 2 it would be prevented from sending thousands of low fee-rate tx building off the root.\n> \n> As well, as I understand it, this merely tightens the mempool acceptance rules, preventing low fee-rate packages from growing (analogous to a consensus-layer softfork).\n> The \"cannot evict high absolute fee\" rule can be retained, as the low-fee-rate package is prevented from reaching a large size.\n> \n> Would that be workable as a general solution to solve (what I think is) the root cause of this problem?\n\nIt\u2019s not clear to me that tightening the acceptance rules wouldn\u2019t break other existing uses. Historically the 25 package size limit has proven to be an issue for users doing (somewhat na\u00efve) centralized wallet withdraws. Sadly many users want that \u201cpayment pending\u201d notification instantly, even if we know it to be somewhat lacking in security. Wallets which have over-compacted their UTXOs are thus stuck making long chains.\n\nTo revive an old discussion, on the original thread proposing the CPFP Carve-Out, I said this:\n\n> As an alternative proposal, at various points there have been discussions around solving the \"RBF-pinning\" problem by allowing transactors to mark their transactions as \"likely-to-be-RBF'ed\", which could enable a relay policy where children of such transactions would be rejected unless the resulting package would be \"near the top of the mempool\". This would theoretically imply such attacks are not possible to pull off consistently, as any \"transaction-delaying\" channel participant will have to place the package containing A at an effective feerate which makes confirmation to occur soon with some likelihood. It is, however, possible to pull off this attack with low probability in case of feerate spikes right after broadcast.\n\nTo which Rusty responded (and I may be paraphrasing here): \u201cFuck Yea\u201d. I\u2019m still not much of a fan of this idea as it introduces too many constants (what is \u201cthe top of the mempool\u201d, anyway?), and it\u2019s unclear to me what you do as the mempool prevailing feerate changes, but it seems more along the lines or what you\u2019re looking for here."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-23T12:46:59",
                "message_text_only": "Good morning Matt,\n\n> > -   C directly contacts miners with an out-of-band proposal to replace its transaction with an alternative that is much smaller and has a low fee, but much better feerate.\n>\n> Or they can just wait. For example in today\u2019s mempool it would not be strange for a transaction at 1 sat/vbyte to wait a day but eventually confirm.\n\nThat introduces the possibility that the entire tree (with high total fee, remember) gets confirmed, so it would be better for C to replace it with an alternative to a different address C still controls, with a slightly better fee rate but smaller (no child transactions) and lower total fee, so an economically-rational C will make that effort (and if there are still other transactions in the mempool, an economically-rational miner will accept this proposal).\n\nBut in any case this is a minor detail and the attack will work either way.\n\n>\n> > -   Miners, being economically rational, accept this proposal and include this in a block.\n> >\n> > The proposal by Matt is then:\n> >\n> > -   The hashlock branch should instead be:\n> > -   B and C must agree, and show the preimage of some hash H (hashlock branch).\n> > -   Then B and C agree that B provides a signature spending the hashlock branch, to a transaction with the outputs:\n> > -   Normal payment to C.\n> > -   Hook output to B, which B can use to CPFP this transaction.\n> > -   Hook output to C, which C can use to CPFP this transaction.\n> > -   B can still (somehow) not maintain a mempool, by:\n> > -   B broadcasts its timelock transaction.\n> > -   B tries to CPFP the above hashlock transaction.\n> > -   If CPFP succeeds, it means the above hashlock transaction exists and B queries the peer for this transaction, extracting the preimage and claiming the A->B HTLC.\n>\n> Note that no query is required. The problem has been solved and the preimage-containing transaction should now confirm just fine.\n\nAh, right, so it gets confirmed and the `blocksonly` B sees it in a block.\n\nEven if C hooks a tree of low-fee transactions on its hook output or normal payment, miners will still be willing to confirm this and the B hook CPFP transaction without, right?\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-04-23T22:47:46",
                "message_text_only": "On 4/23/20 8:46 AM, ZmnSCPxj wrote:\n>>> -   Miners, being economically rational, accept this proposal and include this in a block.\n>>>\n>>> The proposal by Matt is then:\n>>>\n>>> -   The hashlock branch should instead be:\n>>> -   B and C must agree, and show the preimage of some hash H (hashlock branch).\n>>> -   Then B and C agree that B provides a signature spending the hashlock branch, to a transaction with the outputs:\n>>> -   Normal payment to C.\n>>> -   Hook output to B, which B can use to CPFP this transaction.\n>>> -   Hook output to C, which C can use to CPFP this transaction.\n>>> -   B can still (somehow) not maintain a mempool, by:\n>>> -   B broadcasts its timelock transaction.\n>>> -   B tries to CPFP the above hashlock transaction.\n>>> -   If CPFP succeeds, it means the above hashlock transaction exists and B queries the peer for this transaction, extracting the preimage and claiming the A->B HTLC.\n>>\n>> Note that no query is required. The problem has been solved and the preimage-containing transaction should now confirm just fine.\n> \n> Ah, right, so it gets confirmed and the `blocksonly` B sees it in a block.\n> \n> Even if C hooks a tree of low-fee transactions on its hook output or normal payment, miners will still be willing to confirm this and the B hook CPFP transaction without, right?\n\nCorrect, once it makes it into the mempool we can CPFP it and all the regular sub-package CPFP calculation will pick it\nand its descendants up. Of course this relies on it not spending any other unconfirmed inputs."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-23T12:52:57",
                "message_text_only": "Good morning David,\n\nUnfortunately this technique does not look like it is compatible to payment points rather than hashes, and we would really like to upgrade to payment points sooner rather than later.\nNobody but B can recognize the signature as revealing the scalar behind a particular point (the main privacy advantage of using points).\nEven variations on this are not useable with payment points.\n\nRegards,\nZmnSCPxj\n\n> On Wed, Apr 22, 2020 at 03:53:37PM -0700, Matt Corallo wrote:\n>\n> > if you focus on sending the pinning transaction to miner nodes\n> > directly (which isn't trivial, but also not nearly as hard as it\n> > sounds), you could still pull off the attack.\n>\n> If the problem is that miners might have information not available to\n> the network in general, you could just bribe them for that knowledge.\n> E.g. as Bob's refund deadline approaches and he begins to suspect that\n> mempool shenanigans are preventing his refund transaction from\n> confirming, he takes a confirmed P2WPKH UTXO he's been saving for use in\n> CPFP fee bumps and spends part of its value (say 1 mBTC) to the\n> following scriptPubKey[1],\n>\n> OP_SHA256 <hash_whose_preimage_bob_wants> OP_EQUAL\n>\n> Assuming the feerate and the bribe amount are reasonable, any miner who\n> knows the preimage is incentivized to include Bob's transaction and a\n> child transation spending from it in their next block. That child\n> transaction will include the preimage, which Bob will see when he\n> processes the block.\n>\n> If any non-miner knows the preimage, they can also create that child\n> transaction. The non-miner probably can't profit from this---miners can\n> just rewrite the child transaction to pay themselves since there's no\n> key-based security---but the non-miner can at least pat themselves on\n> the back for being a good Summaritan. Again Bob will learn the preimage\n> once the child transaction is included in a block, or earlier if his\n> wallet is monitoring for relays of spends from his parent transaction.\n>\n> Moreover, Bob can first create a bribe via LN and, in that case, things\n> are even better. As Bob's deadline approaches, he uses one of his\n> still-working channels to send a bunch of max-length (20 hops?) probes\n> that reuse the earlier HTLC's <hash>. If any hop along the path knows\n> the preimage, they can immediately claim the probe amount (and any\n> routing fees that were allocated to subsequent hops). This not only\n> gives smaller miners with LN nodes an equal chance of claiming the\n> probe-bribe as larger miners, but it also allows non-miners to profit\n> from learning the preimage from miners.\n>\n> That last part is useful because even if, as in your example, the\n> adversary is able to send one version of the transaction just to miners\n> (with the preimage) and another conflicting version to all relay nodes\n> (without the preimage), miners will naturally attempt to relay the\n> preimage version of the transaction to other users; if some of those\n> users run modified nodes that write all 32-byte witness data blobs to a\n> database---even if the transaction is ultimately rejected as a\n> conflict---then targetted relay to miners may not be effective at\n> preventing Bob from learning the preimage.\n>\n> Obviously all of the above requires people run additional software to\n> keep track of potential preimages[2] and then compare them to hash\n> candidates, plus it requires additional complexity in LN clients, so I\n> can easily understand why it might be less desirable than the protocol\n> changes under discussion in other parts of this thread. Still, with\n> lots of effort already being put into watchtowers and other\n> enforcement-assistance services, I wonder if this problem can be largely\n> addressed in the same general way.\n>\n> -Dave\n>\n> [1] Requires a change to standard relay and mining policy.\n> [2] Pretty easy, e.g.\n>\n> bitcoin-cli getrawmempool \\\n> | jq -r .[] \\\n> | while read txid ; do\n> bitcoin-cli getrawtransaction $txid true | jq .vout[].scriptPubKey.asm\n> done \\\n> | grep -o '\\<[0-9a-f]\\{64\\}\\>'\n>\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "RBF Pinning with Counterparties and Competing Interest",
            "categories": [
                "bitcoin-dev",
                "Lightning-dev"
            ],
            "authors": [
                "Antoine Riard",
                "ZmnSCPxj",
                "Olaoluwa Osuntokun",
                "Bastien TEINTURIER",
                "Matt Corallo"
            ],
            "messages_count": 13,
            "total_messages_chars_count": 106983
        }
    },
    {
        "title": "[bitcoin-dev] Academic research regarding BIP0002",
        "thread_messages": [
            {
                "author": "Shiva Jairam",
                "date": "2020-04-21T20:28:55",
                "message_text_only": "Hi all,\n\nI am doing a project trying to map out BIP002 (https://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki) into a bussiness process model using BPMN2.0.\nThis is a project regarding an academic research for my studies.\nI am by no means an expert in Blockchain nor Bitcoin and have just recently began looking into the technologies.\n\nIs someone willing to review or discuss my model?\nIf this is not the right place to discuss such a topic, pointing in the right direction is much appreciated.\n\n\nKind regards,\nShiva Jairam\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200421/7e9264bc/attachment.html>"
            },
            {
                "author": "nopara73",
                "date": "2020-04-22T11:38:37",
                "message_text_only": "Just a tip: if you'd like to get feedback on your work, then share your\nwork as well, since not many people are willing to commit to helping unless\nthey know how large the work is.\n\nOn Tue, Apr 21, 2020 at 10:51 PM Shiva Jairam via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi all,\n>\n>\n>\n> I am doing a project trying to map out BIP002 (\n> https://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki) into a\n> bussiness process model using BPMN2.0.\n>\n> This is a project regarding an academic research for my studies.\n>\n> I am by no means an expert in Blockchain nor Bitcoin and have just\n> recently began looking into the technologies.\n>\n>\n>\n> Is someone willing to review or discuss my model?\n>\n> If this is not the right place to discuss such a topic, pointing in the\n> right direction is much appreciated.\n>\n>\n>\n>\n>\n> Kind regards,\n>\n> Shiva Jairam\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n-- \nBest,\n\u00c1d\u00e1m\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200422/7036e9e9/attachment.html>"
            },
            {
                "author": "Shiva Jairam",
                "date": "2020-04-22T12:48:56",
                "message_text_only": "Thanks for the tip nopara73.\nI did not want to overwhelm the thread with unnecessary information, but then again it is hard to get feedback with no viewable information.\n\nHere is the link<https://www.dropbox.com/sh/yy99h2bxapowiyg/AAAv7FOmwAsDLCBNi7alD09oa?dl=0> to the concept model I have so far.\n\nFrom: nopara73<mailto:adam.ficsor73 at gmail.com>\nSent: Wednesday, April 22, 2020 1:38 PM\nTo: Shiva Jairam<mailto:shiva.jairam at outlook.com>; Bitcoin Protocol Discussion<mailto:bitcoin-dev at lists.linuxfoundation.org>\nSubject: Re: [bitcoin-dev] Academic research regarding BIP0002\n\nJust a tip: if you'd like to get feedback on your work, then share your work as well, since not many people are willing to commit to helping unless they know how large the work is.\n\nOn Tue, Apr 21, 2020 at 10:51 PM Shiva Jairam via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\nHi all,\n\nI am doing a project trying to map out BIP002 (https://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki) into a bussiness process model using BPMN2.0.\nThis is a project regarding an academic research for my studies.\nI am by no means an expert in Blockchain nor Bitcoin and have just recently began looking into the technologies.\n\nIs someone willing to review or discuss my model?\nIf this is not the right place to discuss such a topic, pointing in the right direction is much appreciated.\n\n\nKind regards,\nShiva Jairam\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n\n--\nBest,\n\u00c1d\u00e1m\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200422/57efeb69/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Academic research regarding BIP0002",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Shiva Jairam",
                "nopara73"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 3867
        }
    },
    {
        "title": "[bitcoin-dev] Fwd: (Semi)Traceless 2-party coinjoin off-chain protocol using schnorr signatures",
        "thread_messages": [
            {
                "author": "German Luna",
                "date": "2020-04-22T18:42:18",
                "message_text_only": "Hello All,\n\n## Objective\n* Make atomic swaps within the same chain possible in a traceless way\n* Achieving traceless same-chain atomic-swaps effectively turns an entire\nchain into a  (P2PKH) mixer by default\n\n## Proposed solution\nSimilar to the way that atomic swaps would work with schnorr signatures\n(i.e. leveraging adaptor signatures), the proposed solution is to use - in\nplace of the secret 't' - a suitably chosen schnorr signature. The end\nresult being that when one counterparty claims their side of the funds, the\nparty can obtain the signature they're missing to claim the funds in the\n(schnorr) multisig that pays them.\nOn-chain, this would appear like two independent transactions, even though\neffectively the two parties have \u201cexchanged\u201d the history attached to the\nUTXOs. Unlike a mixing service, in which all of the histories get merged,\nwith this protocol histories can be pairwise swapped without anybody\u2019s\nknowledge.\n\n## Protocol description\n* Alice and Bob, holding funds at UTXO1 (controlled by Alice) and UTXO2\n(controlled by Bob) wish to swap them.\n* Alice provides Bob with a single public key P_A\n* Bob provides Alice two pubkeys P_B1, P_B2.\n* Bob and Alice construct the P2PKH addresses Addr1 = Hash(P_A+P_B1) [where\nthe UTXO1 funds will be sent to eventually] and Addr2  = Hash(P_A+P_B2)\n[where the UTXO2 funds will be sent to eventually]\n* Bob and Alice exchange time-locked refund transactions for the funding\ntransactions sending the funds to Addr1 and Addr2.\n* Bob and Alice submit the funding transactions (Alice pays to Addr1 from\nUTXO1; Bob pays to Addr2 from UTXO2)\n* Alice sends Bob an adaptor signature: r1 + H(r1 | m)*x_a + r2 + H( r2 |\nm')*x_a\n* Bob verifies the adaptor signature Alice sent contains a valid signature\nfor spending from Addr1 AND another valid signature for spending from\nAddr2. Both signatures from Alice. Bob cannot separate out the two\nsignatures and hence cannot claim any of the funds, provided H( r1 | m) !=\nH( r2 | m') in the signature commitment.\n* Bob now sends Alice the valid signature: r2 + H( r2 | m' )*x_b2\n* Alice can now add her signature to Bob's and get: r2 + H( r2| m'\n)*(x_b2 + x_a) which is a valid signature to spend the funding transaction\nsent to Addr2.\n* Finally, Bob sees Alice claims the fund sent to Addr2 and uses that\nsignature to subtract his own: r2 + H( r2 | m' )*(x_b2 + x_a) - (r2 + H( r2\n| m' )*x_b2) = H( r2 | m ')*x_a\n* Bob takes the original adaptor signature and subtracts the known quantity\nr2+ H( r2 | m' )*x_a, to get a valid signature: r1 + H( r1 | m )*x_a\n* Bob can now add to that valid signature, his own signature and retrieve\nthe funds.\n## Notes\n* It is possible for the counterparty to store copies of the signatures as\nproof that such a join has taken place. But plausible deniability is\navailable upon discarding signatures since the joint private keys (x_a +\nx_b*) are unavailable.\n\nI'm interested in hearing feedback on this idea if possible, and deemed\ninteresting enough.\n\nBest regards,\n-- \nGerm\u00e1n\nMathematician\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200422/1253207d/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-23T17:56:08",
                "message_text_only": "Good morning Germ\u00e1n,\n\nIt looks to me like this is CoinSwap with Schnorr Scriptless Scripts.\n\n* https://joinmarket.me/blog/blog/coinswaps/\n* https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/\n\nI also recently put up an article on extending such a protocol across 3 or more participants:\n\n* https://zmnscpxj.github.io/bitcoin/multiswap.html\n\nRegards,\nZmnSCPxj\n\n> ## Objective\n> * Make atomic swaps within the same chain possible in a traceless way\n> * Achieving traceless same-chain atomic-swaps effectively turns an entire chain into a\u00a0 (P2PKH) mixer by default\n>\n> ## Proposed solution\n> Similar to the way that atomic swaps would work with schnorr signatures (i.e. leveraging adaptor signatures), the proposed solution is to use - in place of the secret 't' - a suitably chosen schnorr signature. The end result being that when one counterparty claims their side of the funds, the party can obtain the signature they're missing to claim the funds in the (schnorr) multisig that pays them.\n> On-chain, this would appear like two independent transactions, even though effectively the two parties have \u201cexchanged\u201d the history attached to the UTXOs. Unlike a mixing service, in which all of the histories get merged, with this protocol histories can be pairwise swapped without anybody\u2019s knowledge.\n>\n> ## Protocol description\n> * Alice and Bob, holding funds at UTXO1 (controlled by Alice) and UTXO2 (controlled by Bob) wish to swap them.\u00a0\n> * Alice provides Bob with a single public key P_A\n> * Bob provides Alice two pubkeys P_B1, P_B2.\n> * Bob and Alice construct the P2PKH addresses Addr1 = Hash(P_A+P_B1) [where the UTXO1 funds will be sent to eventually] and Addr2\u00a0 = Hash(P_A+P_B2) [where the UTXO2 funds will be sent to eventually]\n> * Bob and Alice exchange time-locked refund transactions for the funding transactions sending the funds to Addr1 and Addr2.\n> * Bob and Alice submit the funding transactions (Alice pays to Addr1 from UTXO1; Bob pays to Addr2 from UTXO2)\n> * Alice sends Bob an adaptor signature: r1\u00a0+ H(r1 | m)*x_a\u00a0+ r2\u00a0+ H( r2 | m')*x_a\n> * Bob verifies the adaptor signature Alice sent contains a valid signature for spending from Addr1 AND another valid signature for spending from Addr2. Both signatures from Alice. Bob cannot separate out the two signatures and hence cannot claim any of the funds, provided H( r1 | m) != H( r2 | m') in the signature commitment.\u00a0\n> * Bob now sends Alice the valid signature: r2\u00a0+ H( r2 | m' )*x_b2\n> * Alice can now add her signature to Bob's and get: r2 + H( r2| m' )*(x_b2\u00a0+ x_a) which is a valid signature to spend the funding transaction sent to Addr2.\n> * Finally, Bob sees Alice claims the fund sent to Addr2 and uses that signature to subtract his own: r2 + H( r2 | m' )*(x_b2\u00a0+ x_a) - (r2\u00a0+ H( r2 | m' )*x_b2) = H( r2 | m ')*x_a\n> * Bob takes the original adaptor signature and subtracts the known quantity r2+ H( r2 | m' )*x_a, to get a valid signature: r1\u00a0+ H( r1 | m )*x_a\n> * Bob can now add to that valid signature, his own signature and retrieve the funds.\n> ## Notes\n> * It is possible for the counterparty to store copies of the signatures as proof that such a join has taken place. But plausible deniability is available upon discarding signatures since the joint private keys (x_a\u00a0+ x_b*)\u00a0are unavailable.\n>\n> I'm interested in hearing feedback on this idea if possible, and deemed interesting enough.\n>\n> Best regards,\n> --\n> Germ\u00e1n\n> Mathematician"
            },
            {
                "author": "German Luna",
                "date": "2020-04-23T18:40:06",
                "message_text_only": "Good morning  ZmnSCPxj,\n\nThank you for your excellent feedback!\n\nIndeed, with a little protocol-level sugar so that the coins being swapped\nget paid out of different pubkeys.\nI read your article. Excellent idea on the randomized locktimes! I've still\nto read the details of what S6 amounts to but I'm excited to.\n\nWith regards to trying to tackle the problem of value-based correlations,\nwouldn't it be possible to try to model the solution after the\nequal-sum-subset problem (np complete problem)(\nhttps://www.cs.mcgill.ca/~lyepre/pdf/assignment2-solutions/subsetSumNPCompleteness.pdf\n)?\nThat is, a pair of individuals with a set of UTXOs that both add up to\nsimilar if not equal value perform a swap of similar-(total)value sets. In\nthis way the values of the UTXOs can be broken up essentially at random\n(following some nominal distribution so that it doesn't stand out; e.g.\nhttps://en.wikipedia.org/wiki/Benford%27s_law), but swapped in conjunction\nand decorrelated by using different keys + randomized locktimes.\n\n\nRegards,\nGerm\u00e1n\n\nOn Thu, Apr 23, 2020 at 11:56 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Germ\u00e1n,\n>\n> It looks to me like this is CoinSwap with Schnorr Scriptless Scripts.\n>\n> * https://joinmarket.me/blog/blog/coinswaps/\n> *\n> https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/\n>\n> I also recently put up an article on extending such a protocol across 3 or\n> more participants:\n>\n> * https://zmnscpxj.github.io/bitcoin/multiswap.html\n>\n> Regards,\n> ZmnSCPxj\n>\n> > ## Objective\n> > * Make atomic swaps within the same chain possible in a traceless way\n> > * Achieving traceless same-chain atomic-swaps effectively turns an\n> entire chain into a  (P2PKH) mixer by default\n> >\n> > ## Proposed solution\n> > Similar to the way that atomic swaps would work with schnorr signatures\n> (i.e. leveraging adaptor signatures), the proposed solution is to use - in\n> place of the secret 't' - a suitably chosen schnorr signature. The end\n> result being that when one counterparty claims their side of the funds, the\n> party can obtain the signature they're missing to claim the funds in the\n> (schnorr) multisig that pays them.\n> > On-chain, this would appear like two independent transactions, even\n> though effectively the two parties have \u201cexchanged\u201d the history attached to\n> the UTXOs. Unlike a mixing service, in which all of the histories get\n> merged, with this protocol histories can be pairwise swapped without\n> anybody\u2019s knowledge.\n> >\n> > ## Protocol description\n> > * Alice and Bob, holding funds at UTXO1 (controlled by Alice) and UTXO2\n> (controlled by Bob) wish to swap them.\n> > * Alice provides Bob with a single public key P_A\n> > * Bob provides Alice two pubkeys P_B1, P_B2.\n> > * Bob and Alice construct the P2PKH addresses Addr1 = Hash(P_A+P_B1)\n> [where the UTXO1 funds will be sent to eventually] and Addr2  =\n> Hash(P_A+P_B2) [where the UTXO2 funds will be sent to eventually]\n> > * Bob and Alice exchange time-locked refund transactions for the funding\n> transactions sending the funds to Addr1 and Addr2.\n> > * Bob and Alice submit the funding transactions (Alice pays to Addr1\n> from UTXO1; Bob pays to Addr2 from UTXO2)\n> > * Alice sends Bob an adaptor signature: r1 + H(r1 | m)*x_a + r2 + H( r2\n> | m')*x_a\n> > * Bob verifies the adaptor signature Alice sent contains a valid\n> signature for spending from Addr1 AND another valid signature for spending\n> from Addr2. Both signatures from Alice. Bob cannot separate out the two\n> signatures and hence cannot claim any of the funds, provided H( r1 | m) !=\n> H( r2 | m') in the signature commitment.\n> > * Bob now sends Alice the valid signature: r2 + H( r2 | m' )*x_b2\n> > * Alice can now add her signature to Bob's and get: r2 + H( r2| m'\n> )*(x_b2 + x_a) which is a valid signature to spend the funding transaction\n> sent to Addr2.\n> > * Finally, Bob sees Alice claims the fund sent to Addr2 and uses that\n> signature to subtract his own: r2 + H( r2 | m' )*(x_b2 + x_a) - (r2 + H( r2\n> | m' )*x_b2) = H( r2 | m ')*x_a\n> > * Bob takes the original adaptor signature and subtracts the known\n> quantity r2+ H( r2 | m' )*x_a, to get a valid signature: r1 + H( r1 | m\n> )*x_a\n> > * Bob can now add to that valid signature, his own signature and\n> retrieve the funds.\n> > ## Notes\n> > * It is possible for the counterparty to store copies of the signatures\n> as proof that such a join has taken place. But plausible deniability is\n> available upon discarding signatures since the joint private keys (x_a +\n> x_b*) are unavailable.\n> >\n> > I'm interested in hearing feedback on this idea if possible, and deemed\n> interesting enough.\n> >\n> > Best regards,\n> > --\n> > Germ\u00e1n\n> > Mathematician\n>\n>\n>\n\n-- \nGerm\u00e1n\nMathematician\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200423/dc5c6c2a/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-24T01:34:51",
                "message_text_only": "Good morning Germ\u00e1n,\n\n\n> With regards to trying to tackle the problem of value-based correlations, wouldn't it be possible to try to model the solution after the equal-sum-subset problem (np complete problem)( https://www.cs.mcgill.ca/~lyepre/pdf/assignment2-solutions/subsetSumNPCompleteness.pdf\u00a0 )?\u00a0\n> That is, a pair of individuals with a set of UTXOs that both add up to similar if not equal value perform a swap of similar-(total)value sets. In this way the values of the UTXOs can be broken up essentially at random (following some nominal distribution so that it doesn't stand out; e.g.\u00a0https://en.wikipedia.org/wiki/Benford%27s_law), but swapped\u00a0in conjunction and decorrelated by using different keys\u00a0+ randomized locktimes.\n\nThere are a number of issues to simply modeling this to the subset-sum problem.\n\n* There is a practical limit to the number of UTXOs you would be willing to receive in the swap.\n  * Every UTXO you receive increases the potential fee you have to pay to spend them, meaning you would strongly dislike receiving 100 UTXOs that sum up to 1mBTC.\n  * Thus, a practical blockchain analyst can bound the size of the sets involved, and the problem becomes less than NP in practice.\n* If you have a single UTXO and split it, then swap, anyone looking at the history can conjecture that the split involved is part of a CoinSwap.\n  * The split is now a hint on how the subset sums can be tried.\n* If after the CoinSwap you spend the UTXOs you received in a single transaction, then you just published the solution to the subset sum for your adversary.\n  * This ties in even further to the \"practical limit on the number of UTXOs\".\n    * Because it is not safe to spend the UTXOs from a single CoinSwap together, you want to have fewer, larger UTXOs for more flexibility in spending later.\n\nI believe belcher and waxwing and nopara73 have been working far longer on privacy tech, and you should try to get in contact with them as well, they may know of other issues (or solutions to the above problems).\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "German Luna",
                "date": "2020-04-24T13:42:12",
                "message_text_only": "Good morning ZmnSCPxj,\n\nThe issues you point out are indeed important to note. Thank you for your\nwonderful feedback!\n\n* There is a practical limit to the number of UTXOs you would be willing to\n> receive in the swap.\n>   * Every UTXO you receive increases the potential fee you have to pay to\n> spend them, meaning you would strongly dislike receiving 100 UTXOs that sum\n> up to 1mBTC.\n>\nAbsolutely agree. It wouldn't be particularly nice to have to manage that.\n\n  * Thus, a practical blockchain analyst can bound the size of the sets\n> involved, and the problem becomes less than NP in practice.\n>\nDefinitely, though they first have to consider all subsets of a fixed size\nwith values bounded above by the value of the unknown sum. So the analyst\nhas to search through all fixed size sets (up to the practical bound) whose\nelements are less than a maximum sum. This is a number of choices that is\n(in a crude estimation) exponential (in the size of the UTXO set), and\npolynomial in the number UTXOs below that maximum sum value on-chain which\ncan be pretty big at sufficiently large value-transfers.\n\n* If you have a single UTXO and split it, then swap, anyone looking at the\n> history can conjecture that the split involved is part of a CoinSwap.\n>   * The split is now a hint on how the subset sums can be tried.\n>\nYou're right that anybody could conjecture that it is involved in a\nCoinSwap, however in my proposed protocol the swap would like a (schnorr)\nP2PKH to the chain so you'd have to make that conjecture for every UTXO, so\nit's not much of a hint. Especially so noting that one, both or none of the\noutputs could be part of a swap.\n\n* If after the CoinSwap you spend the UTXOs you received in a single\n> transaction, then you just published the solution to the subset sum for\n> your adversary.\n>   * This ties in even further to the \"practical limit on the number of\n> UTXOs\".\n>     * Because it is not safe to spend the UTXOs from a single CoinSwap\n> together, you want to have fewer, larger UTXOs for more flexibility in\n> spending later.\n>\nYes, this is definitely a weakness and some over-the-top UTXO management\ntechniques (e.g. try to avoid combining different UTXOs in a known set into\nthe same transaction by default, where possible) would be needed or like\nyou say fewer larger UTXOs.\n\nIt's interesting to note one can pick some subset of recent UTXOs and add\nup their output values, and select that as the amount of value transfer to\nexchange in a given operation. Resulting in a bit of added obfuscation as\nthere are now seemingly (at least) 3 utxo sets that add up to similar or\nidentical values, but only two of which are really participating in the\nswap.\n\nI believe belcher and waxwing and nopara73 have been working far longer on\n> privacy tech, and you should try to get in contact with them as well, they\n> may know of other issues (or solutions to the above problems).\n>\nThank you for your input and suggestions! I will reach out to them.\n\n-- \nGerm\u00e1n\nMathematician\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200424/dfd618b8/attachment.html>"
            },
            {
                "author": "Chris Belcher",
                "date": "2020-04-28T13:03:36",
                "message_text_only": "On 24/04/2020 02:34, ZmnSCPxj via bitcoin-dev wrote:\n> Good morning Germ\u00e1n,\n> \n> \n>> With regards to trying to tackle the problem of value-based correlations, wouldn't it be possible to try to model the solution after the equal-sum-subset problem (np complete problem)( https://www.cs.mcgill.ca/~lyepre/pdf/assignment2-solutions/subsetSumNPCompleteness.pdf\u00a0 )?\u00a0\n>> That is, a pair of individuals with a set of UTXOs that both add up to similar if not equal value perform a swap of similar-(total)value sets. In this way the values of the UTXOs can be broken up essentially at random (following some nominal distribution so that it doesn't stand out; e.g.\u00a0https://en.wikipedia.org/wiki/Benford%27s_law), but swapped\u00a0in conjunction and decorrelated by using different keys\u00a0+ randomized locktimes.\n> \n> There are a number of issues to simply modeling this to the subset-sum problem.\n> \n> * There is a practical limit to the number of UTXOs you would be willing to receive in the swap.\n>   * Every UTXO you receive increases the potential fee you have to pay to spend them, meaning you would strongly dislike receiving 100 UTXOs that sum up to 1mBTC.\n>   * Thus, a practical blockchain analyst can bound the size of the sets involved, and the problem becomes less than NP in practice.\n> * If you have a single UTXO and split it, then swap, anyone looking at the history can conjecture that the split involved is part of a CoinSwap.\n>   * The split is now a hint on how the subset sums can be tried.\n> * If after the CoinSwap you spend the UTXOs you received in a single transaction, then you just published the solution to the subset sum for your adversary.\n>   * This ties in even further to the \"practical limit on the number of UTXOs\".\n>     * Because it is not safe to spend the UTXOs from a single CoinSwap together, you want to have fewer, larger UTXOs for more flexibility in spending later.\n> \n> I believe belcher and waxwing and nopara73 have been working far longer on privacy tech, and you should try to get in contact with them as well, they may know of other issues (or solutions to the above problems).\n> \n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n\nHello list,\n\nA couple of thoughts on multi-transaction coinswaps:\n\n* Users should never split up a single UTXO before doing a coinswap,\ninstead they should send the one UTXO to a coinswap address and get back\nmultiple UTXOs.\n\nFor example, this 1-to-3 TXO coinswap (The symbol ----> means bitcoin\ntransaction).\n\n    AliceA (10 BTC) ----> CoinSwap AddressA ----> BobA (10 BTC)\n\n    BobB (3 BTC) ----> CoinSwap AddressB ----> AliceB (6 BTC)\n    BobC (2 BTC) ----> CoinSwap AddressC ----> AliceC (3 BTC)\n    BobD (5 BTC) ----> CoinSwap AddressD ----> AliceD (1 BTC)\n\n\nNote that the Bob-to-Alice set of transactions add up to 10 BTC, the\nentire CoinSwap is swapping the same amount.\n\nOr written another way:\n\n    Alice TXO (10 BTC) ----> Coinswap Protocol ----> Alice TXO1 (6 BTC)\n                                               ----> Alice TXO2 (3 BTC)\n                                               ----> Alice TXO3 (1 BTC)\n\nThis kind of thing could also be used for consolidation of many UTXOs\nwithout necessarily leaking information that the same person owns them.\nFor example, if Alice owns 5 UTXOs:\n\n    Alice TXO1 ----> Coinswap Protocol ----> Alice TXO\n    Alice TXO2 ---->\n    Alice TXO3 ---->\n    Alice TXO4 ---->\n    Alice TXO5 ---->\n\n\n* It's helpful if any CoinSwap app is actually used for spending rather\nthan just mixing back to yourself. That will help avoid the problem of\nusers inadvertently co-spending all their coinswap outputs in the same\ntransaction.\nAn example of Alice paying for a VPN anonymously:\n\n    Alice TXO (10 BTC) ---> Coinswap Protocol ---> VPN Payment (0.1 BTC)\n                                              ---> Change1 (6 BTC)\n                                              ---> Change2 (3 BTC)\n                                              ---> Change3 (0.9 BTC)\n\nIn this case Alice will never accidentally merge all her TXOs together,\nbecause the VPN Payment TXO doesn't belong to her. Also this could\nimprove privacy because unlike in normal transaction the VPN provider\nmight not be able to figure out the lower bound of Alice's balance (10\nBTC in this case).\n\n\n* Multi-transaction CoinSwaps aren't truly an example of a subset-sum\nproblem, but \"sparse subset sum\", a related and easier problem.\n\nThe way its normally formulated, subset sum is about finding a subset\nthat adds up to a target value. But in multi-transaction coinswap\nthere'd only be three or four CoinSwap outputs, so the problem is\nfinding just three or four integers in a big set that add up to the target.\n\nYou could think of it mathematically that the n-choose-k function is\nnear-polynomial when k is near 0 or near n, and the function is\nexponential when k is near n/2.\n\nA more promising way to build privacy is to create a situation where an\nadversary would find a huge amount of false positives which are very\nclose the amount being sent. So even if the adversary has enough\ncomputational power to iterate all the amounts it won't help them much\ndue to the huge number of false positives.\n\n\nRegards\nCB"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-29T07:56:16",
                "message_text_only": "Good morning CB,\n\nI have been thinking about CoinSwap for a good while as well.\n\nHere are some very unorganized thoughts.\n\nIt wold be nice to interoperate with JoinMarket, i.e. have a JoinMarket maker that also provides CoinSwap services using the same UTXOs.\nHowever, this requires us to retain compatibility with the JoinMarket wallet structure, which is divided into mixdepths, with the rule that UTXOs in different mixdepths cannot be spent together in the same onchain UTXO (to move across mixdepths you have to do a send, and sending out is always done by a single CoinJoin round with multiple makers).\n\nI am uncertain what is the best way to handle multitransaction when considering the mixdepth system.\nMy instinct is that if you are doing multitransaction (whether as taker or maker) then each transaction in the swap *has to* come from a different mixdepth.\nThe issue here is:\n\n* If all the UTXOs in the multitransaction swap come from the same mixdepth, then a surveillor who is monitoring that mixdepth gets a good hint in solving the sparse subset sum problem.\n* On the other hand, if all the UTXOs in the multitransaction swap come from different mixdepths, then a surveillor who has solved the sparse subset sum problem now has the hint that the different mixdepths are really owned by the same JoinMarket user.\n\nI am uncertain which tradeoff is better here, though I am inclined to think the latter is better.\n\n\nAttempting to completely detach a market-for-CoinSwap from JoinMarket seems to be impossible to my mind: the protocols are known, implementations open, and someone will inevitably write code for a single piece of software that can operate as both a JoinMarket maker *and* a maker for a market-for-CoinSwap (to increase their market, so to speak), so it might be better to just add CoinSwap to JoinMarket in the first place.\n\n\n> A couple of thoughts on multi-transaction coinswaps:\n>\n> -   Users should never split up a single UTXO before doing a coinswap,\n>     instead they should send the one UTXO to a coinswap address and get back\n>     multiple UTXOs.\n>\n>     For example, this 1-to-3 TXO coinswap (The symbol ----> means bitcoin\n>\n>\n> transaction).\n>\n> AliceA (10 BTC) ----> CoinSwap AddressA ----> BobA (10 BTC)\n>\n> BobB (3 BTC) ----> CoinSwap AddressB ----> AliceB (6 BTC)\n>\n>     BobC (2 BTC) ----> CoinSwap AddressC ----> AliceC (3 BTC)\n>\n>     BobD (5 BTC) ----> CoinSwap AddressD ----> AliceD (1 BTC)\n>\n>\n> Note that the Bob-to-Alice set of transactions add up to 10 BTC, the\n> entire CoinSwap is swapping the same amount.\n>\n> Or written another way:\n>\n> Alice TXO (10 BTC) ----> Coinswap Protocol ----> Alice TXO1 (6 BTC)\n>\n>                                                ----> Alice TXO2 (3 BTC)\n>\n>                                                ----> Alice TXO3 (1 BTC)\n>\n\nAssuming Alice is the taker, and Bob is the maker, then Alice might want a specific coin value (or set of such) that Bob does not have.\nIn that case, Bob will have to split a UTXO it owns.\n\nWe could constrain it so that Bob at least is not allowed to use the change from splitting for the same CoinSwap, e.g. if Bob has only 9 BTC and 1 BTC coins and Alice wants a 6 BTC / 3 BTC / 1 BTC split, then Bob cannot split its own 9 BTC coin then swap.\nOr in terms of mixdepths, Bob can split within a mixdepth but each outgoing UTXO in the same swap should be from different mixdepths.\n\n\n\n> -   It's helpful if any CoinSwap app is actually used for spending rather\n>     than just mixing back to yourself. That will help avoid the problem of\n>     users inadvertently co-spending all their coinswap outputs in the same\n>     transaction.\n>     An example of Alice paying for a VPN anonymously:\n>\n>     Alice TXO (10 BTC) ---> Coinswap Protocol ---> VPN Payment (0.1 BTC)\n>\n>                                                 ---> Change1 (6 BTC)\n>\n>                                                 ---> Change2 (3 BTC)\n>\n>                                                 ---> Change3 (0.9 BTC)\n>\n>\n>\n> In this case Alice will never accidentally merge all her TXOs together,\n> because the VPN Payment TXO doesn't belong to her. Also this could\n> improve privacy because unlike in normal transaction the VPN provider\n> might not be able to figure out the lower bound of Alice's balance (10\n> BTC in this case).\n\nThis is a good idea, akin to the rule in JoinMarket that all outgoing spends are done through a CoinJoin.\n\nOf course, if a surveillor ***does*** solve the sparse subset sum, then the CoinSwap Protocol part looks exactly like a Bitcoin transaction, with a \"main\" paying output and a \"change\" output, and the same techniques that work with current Bitcoin txes work with \"CoinSwap Protocol\" virtual transactions.\n\nIt seems to me that, in a system of makers and takers, even if the maker is really just paying the taker(s) to do CoinSwaps to mix back to itself, it should still \"require\" some output amount that really goes to itself, so that the maker at least does not differentiate between the case that the taker is paying to itself vs the case that the taker is paying someone else via a CoinSwap.\nThat is, the protocol should still require that the taker specify *some* target desired amount, regardless of whether the taker wants to pay a specific value, or the taker wants to just mix its coins.\n\n\n> -   Multi-transaction CoinSwaps aren't truly an example of a subset-sum\n>     problem, but \"sparse subset sum\", a related and easier problem.\n>\n>     The way its normally formulated, subset sum is about finding a subset\n>     that adds up to a target value. But in multi-transaction coinswap\n>     there'd only be three or four CoinSwap outputs, so the problem is\n>     finding just three or four integers in a big set that add up to the target.\n>\n>     You could think of it mathematically that the n-choose-k function is\n>     near-polynomial when k is near 0 or near n, and the function is\n>     exponential when k is near n/2.\n>\n>     A more promising way to build privacy is to create a situation where an\n>     adversary would find a huge amount of false positives which are very\n>     close the amount being sent. So even if the adversary has enough\n>     computational power to iterate all the amounts it won't help them much\n>     due to the huge number of false positives.\n\nWhat are your thoughts on creating such possible situations?\n\nAn idea is to require standard swap amounts, i.e. similar to the standard 100mBTC mixing bin of Wasabi.\n\nAs well, one could randomly select some existing 1-input 1-output txes in the mempool and/or recent blocks, sum them, and swap for the same sum, to force at least one false positive, but the surveillor could protect against this by removing the earliest match (the one it saw in the mempool first, or onchain).\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Chris Belcher",
                "date": "2020-04-29T15:06:01",
                "message_text_only": "Hello ZmnSCPxj,\n\n\nOn 29/04/2020 08:56, ZmnSCPxj wrote:\n> It wold be nice to interoperate with JoinMarket, i.e. have a JoinMarket maker that also provides CoinSwap services using the same UTXOs.\n\nA great benefit of a CoinSwap system is that the transactions are\nsteganographic. If equal-output-coinjoins were involved that benefit\nwould be lost. So it would be better if it didn't happen.\n\n> However, this requires us to retain compatibility with the JoinMarket wallet structure, which is divided into mixdepths, with the rule that UTXOs in different mixdepths cannot be spent together in the same onchain UTXO (to move across mixdepths you have to do a send, and sending out is always done by a single CoinJoin round with multiple makers).\n> I am uncertain what is the best way to handle multitransaction when considering the mixdepth system.\n> My instinct is that if you are doing multitransaction (whether as taker or maker) then each transaction in the swap *has to* come from a different mixdepth.\n> The issue here is:\n> \n> * If all the UTXOs in the multitransaction swap come from the same mixdepth, then a surveillor who is monitoring that mixdepth gets a good hint in solving the sparse subset sum problem.\n> * On the other hand, if all the UTXOs in the multitransaction swap come from different mixdepths, then a surveillor who has solved the sparse subset sum problem now has the hint that the different mixdepths are really owned by the same JoinMarket user.\n> \n> I am uncertain which tradeoff is better here, though I am inclined to think the latter is better.\n\nJoinMarket has many mixdepths (5 by default) because it's\nequal-output-coinjoins easily leak change addresses. CoinSwap\ntransactions don't have this flaw because they're steganographic. Such a\nsystem could also be coded to intentionally break the weaker change\noutput heuristics\n(https://en.bitcoin.it/wiki/Privacy#Change_address_detection).\n\nEqual-output-coinjoins and JoinMarket also have a version of the\ncommon-input-ownership-heuristic (CIOH), because its often possible to\nseparate the inputs into sets of their owners of a equal-output-coinjoin\nusing the input amounts. CoinSwap can be combined with something like\nPayJoin or CoinJoinXT, which would genuinely break the CIOH, so such a\nsystem wouldn't have this flaw either.\n\nFor those reasons I've been thinking a CoinSwap system wouldn't need as\nmany mixdepths, maybe it could use two or even just one.\n\nIf so, then it follows that multi-transaction CoinSwaps can be done by\nhaving UTXOs come from the same mixdepth, as long as the inputs that\nshould be separate are not co-spent in the same transaction.\n\nRemember that a passive surveillor of the blockchain doesn't see\nmixdepths at all, they see addresses and transactions, and must use\nheuristics to try to cluster them together. We can break these heuristics.\n\n\n> Attempting to completely detach a market-for-CoinSwap from JoinMarket seems to be impossible to my mind: the protocols are known, implementations open, and someone will inevitably write code for a single piece of software that can operate as both a JoinMarket maker *and* a maker for a market-for-CoinSwap (to increase their market, so to speak), so it might be better to just add CoinSwap to JoinMarket in the first place.\n\nSomeone who has the ability to write such code should also have the\nawareness to realize that mixing equal-output-coinjoins with coinswaps\ndamages the privacy because it breaks the steganography of coinswaps.\n\nAlso, because CoinSwap is better than equal-output CoinJoin in almost\nevery way, we can expect users (who are takers) to stop using JoinMarket\nand switch over to CoinSwap if the software becomes mature. So such a\nJoinMarket maker won't get many customers, and so there wouldn't be much\npoint writing such maker code.\n\nBut for sure it would be good to reuse code in any eventual\nimplementation. Indeed Waxwing's implementation did:\nhttps://github.com/AdamISZ/CoinSwapCS\n\n> Assuming Alice is the taker, and Bob is the maker, then Alice might want a specific coin value (or set of such) that Bob does not have.\n> In that case, Bob will have to split a UTXO it owns.\n> \n> We could constrain it so that Bob at least is not allowed to use the change from splitting for the same CoinSwap, e.g. if Bob has only 9 BTC and 1 BTC coins and Alice wants a 6 BTC / 3 BTC / 1 BTC split, then Bob cannot split its own 9 BTC coin then swap.\n> Or in terms of mixdepths, Bob can split within a mixdepth but each outgoing UTXO in the same swap should be from different mixdepths.\n\nA good way to do it could be for Alice to tell Bob that she wants 10 BTC\nand let Bob figure out on his own how to get that amount, based on the\namounts he already has. If Alice is making a payment she can provide\nthat amount too, but all the other output amounts can be up to Bob.\n\nBob would often still have to split a UTXO he owns, but see below about\nbreaking change address heuristics.\n\n> Of course, if a surveillor ***does*** solve the sparse subset sum, then the CoinSwap Protocol part looks exactly like a Bitcoin transaction, with a \"main\" paying output and a \"change\" output, and the same techniques that work with current Bitcoin txes work with \"CoinSwap Protocol\" virtual transactions.\n> \n> It seems to me that, in a system of makers and takers, even if the maker is really just paying the taker(s) to do CoinSwaps to mix back to itself, it should still \"require\" some output amount that really goes to itself, so that the maker at least does not differentiate between the case that the taker is paying to itself vs the case that the taker is paying someone else via a CoinSwap.\n> That is, the protocol should still require that the taker specify *some* target desired amount, regardless of whether the taker wants to pay a specific value, or the taker wants to just mix its coins.\n\nIf Bob needs to split a UTXO he'd do that with a change output. And\nbecause we understand change detection heuristics we can intentionally\nbreak them, for example if Bob's UTXO is on a p2sh-p2wpkh address and\nthe CoinSwap address is of that type too (because ECDSA-2P is being\nused) then Bob could make his change output p2wpkh or p2pkh. Then anyone\nusing the script-type-heuristic would think that the CoinSwap address is\nactually change and still belongs to Bob, and that the real change\naddress is actually the payment or CoinSwap address. i.e. the adversary\nwould assume that wallet software only uses one script type, in this\ncase it assumes that Bob's wallet is exclusively p2sh-p2wpkh.\n\n> \n>> -   Multi-transaction CoinSwaps aren't truly an example of a subset-sum\n>>     problem, but \"sparse subset sum\", a related and easier problem.\n>>\n>>     The way its normally formulated, subset sum is about finding a subset\n>>     that adds up to a target value. But in multi-transaction coinswap\n>>     there'd only be three or four CoinSwap outputs, so the problem is\n>>     finding just three or four integers in a big set that add up to the target.\n>>\n>>     You could think of it mathematically that the n-choose-k function is\n>>     near-polynomial when k is near 0 or near n, and the function is\n>>     exponential when k is near n/2.\n>>\n>>     A more promising way to build privacy is to create a situation where an\n>>     adversary would find a huge amount of false positives which are very\n>>     close the amount being sent. So even if the adversary has enough\n>>     computational power to iterate all the amounts it won't help them much\n>>     due to the huge number of false positives.\n> \n> What are your thoughts on creating such possible situations?\n> \n> An idea is to require standard swap amounts, i.e. similar to the standard 100mBTC mixing bin of Wasabi.\n> \n> As well, one could randomly select some existing 1-input 1-output txes in the mempool and/or recent blocks, sum them, and swap for the same sum, to force at least one false positive, but the surveillor could protect against this by removing the earliest match (the one it saw in the mempool first, or onchain).\n\nI think we can get the false positive count up because the n-choose-k\nfunction still gets quite large as k increases.\n\nWe can make a simplified reasonable assumption that outputs on the\nblockchain follow a lognormal distribution. An adversary trying to unmix\na 3-transaction CoinSwap would have to find the sum of every\n3-combination of the relevant outputs. For our case, the sum of three\nlognormal distributions is another lognormal distribution with different\nparameters, it's corresponding frequency distribution would get scaled\nby n-choose-3. This frequency distribution is what the adversary would\nfind when searching, and that distribution would be quite tall because\nof the scaling by n-choose-k. Suppose our CoinSwap is for 4 BTC then the\nadversary would look at their frequency distribution at 4 BTC and find a\npretty big number, i.e. many other combinations of 3 outputs would add\nup to 4 BTC just by chance. That is the false positive rate, and is our\nanonymity set with respect to this attack.\n\nTo work this out precisely we'd need to study the distribution of output\nvalues on the blockchain today, and see how it behaves when summed\ntogether. But the lognormal distribution assumption is probably not too\nfar from the truth, as it appears all the time in economics and finance,\nand there is a clear justification for why. And the scaling by\nn-choose-k would still hold.\n\nAlong with that, some output amounts have very few significant figures\n(e.g. 1 BTC, 0.1 BTC, 0.01 BTC), presumably because the user types just\none number on their keyboard when creating a transaction. We can use\nthat fact to add a bit of privacy by occasionally making one of our\noutputs also be rounded like that."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-30T08:54:28",
                "message_text_only": "Good morning CB,\n\n\n> Equal-output-coinjoins and JoinMarket also have a version of the\n> common-input-ownership-heuristic (CIOH), because its often possible to\n> separate the inputs into sets of their owners of a equal-output-coinjoin\n> using the input amounts. CoinSwap can be combined with something like\n> PayJoin or CoinJoinXT, which would genuinely break the CIOH, so such a\n> system wouldn't have this flaw either.\n>\n> For those reasons I've been thinking a CoinSwap system wouldn't need as\n> many mixdepths, maybe it could use two or even just one.\n\nWould the ZeroLink proposal of separating a receiving (pre-mix) wallet from a sending (post-mix) wallet apply, thus having two implicit mixdepths (the receiving mixdepth and the sending mixdepth)?\nOr would imposing the rule \"all sends must be via CoinSwap\" be sufficient (and follow the ZeroLink rule in spirit)?\n\n> If so, then it follows that multi-transaction CoinSwaps can be done by\n> having UTXOs come from the same mixdepth, as long as the inputs that\n> should be separate are not co-spent in the same transaction.\n\nThis \"as long as the inputs that should be separate are not co-spent\" is precisely what mixdepths protect against, which is why I think *some* kind of mixdepth facility will still matter in CoinSwap.\n\nStill, you have convinced me that, for the purpose of multi-transaction CoinSwap where you do not merge any of your coins, it is immaterial if the sub-transactions come from the same mixdepth or not.\nAnd if you have to merge your coins (for instance, if you are a maker and your customer wants to get a UTXO that is larger than any you have on hand, you have to merge your coins), you just have to ensure they are in the same mixdepth.\n\nOf course, you *could* be proposing some other construct --- perhaps you have some relational entry which says \"you cannot merge coin A and coin B\" which allows you to merge A C D or B C E, but not A B?\n(I imagine this would make coin selection even harder, but I am not a mathematician and there may be some trivial solution to this.)\n\nNow --- if you have two coins that cannot be merged in the same onchain tx, what happens when you swap them in a multi-tx CoinSwap with somebody else?\nThat somebody else does not know that information.\nInstead, that somebody else must always assume that any coins it got from the same CoinSwap operation must not be safely mergeable (though they can still be used in the same swap together).\n\nCoins received via receive addresses would also not be mergeable with any other coins, except coins to the same address (because coins in the same address already leak that they are owned by the same owner).\n\n>\n> Remember that a passive surveillor of the blockchain doesn't see\n> mixdepths at all, they see addresses and transactions, and must use\n> heuristics to try to cluster them together. We can break these heuristics.\n>\n> > Attempting to completely detach a market-for-CoinSwap from JoinMarket seems to be impossible to my mind: the protocols are known, implementations open, and someone will inevitably write code for a single piece of software that can operate as both a JoinMarket maker and a maker for a market-for-CoinSwap (to increase their market, so to speak), so it might be better to just add CoinSwap to JoinMarket in the first place.\n>\n> Someone who has the ability to write such code should also have the\n> awareness to realize that mixing equal-output-coinjoins with coinswaps\n> damages the privacy because it breaks the steganography of coinswaps.\n>\n> Also, because CoinSwap is better than equal-output CoinJoin in almost\n> every way, we can expect users (who are takers) to stop using JoinMarket\n> and switch over to CoinSwap if the software becomes mature. So such a\n> JoinMarket maker won't get many customers, and so there wouldn't be much\n> point writing such maker code.\n\nAn unscrupulous possible maker might not value the privacy of its customers (indeed makers are a privacy attack vector, which requires something like fidelity bonds like you suggested before to protect against), and takers might not want to do possibly-computationally-expensive blockchain analysis to evaluate whether a particular maker values privacy.\nAn unscrupulous maker might thus earn more than a more scrupulous maker can, at least during the transition from JoinMarket to SwapMarket, and get a greater share of the future SwapMarket available liquidity due to their increased earnings during the transition.\n\nAgainst this we should remember that software that does two things is four times as complicated as software that does one thing, so hopefully your projected transition from JoinMarket to SwapMarket will be fast enough that such a combined Join/SwapMarket maker software does not arise fast enough to matter.\n\n\n> But for sure it would be good to reuse code in any eventual\n> implementation. Indeed Waxwing's implementation did:\n> https://github.com/AdamISZ/CoinSwapCS\n>\n> > Assuming Alice is the taker, and Bob is the maker, then Alice might want a specific coin value (or set of such) that Bob does not have.\n> > In that case, Bob will have to split a UTXO it owns.\n> > We could constrain it so that Bob at least is not allowed to use the change from splitting for the same CoinSwap, e.g. if Bob has only 9 BTC and 1 BTC coins and Alice wants a 6 BTC / 3 BTC / 1 BTC split, then Bob cannot split its own 9 BTC coin then swap.\n> > Or in terms of mixdepths, Bob can split within a mixdepth but each outgoing UTXO in the same swap should be from different mixdepths.\n>\n> A good way to do it could be for Alice to tell Bob that she wants 10 BTC\n> and let Bob figure out on his own how to get that amount, based on the\n> amounts he already has. If Alice is making a payment she can provide\n> that amount too, but all the other output amounts can be up to Bob.\n\nThis leaks to Bob whether Alice is making a payment or not; it would be better for the privacy of Alice for Alice to *always* mention *some* \"payment amount\", even if this is not actually a payment and Alice is just mixing for herself prior to storing in cold storage.\nAnd if Alice wants to use a single swap to pay to multiple targets at once, that implies Alice has to have the ability to indicate the outputs it wants to Bob, and it would imply as well that Alice has to obfuscate which of those outputs have amounts that actually *matter* (by always insisting on what the output amounts must be, rather than insisting on N output amounts and letting Bob handle the rest).\n(We *could* constrain it such that Alice can make only one payment per CoinSwap, so that Alice only gives one \"target\" amount and one \"total\" amount, but that implies even bigger blockspace utilization, sigh.)\n\nOtherwise, Bob can get information:\n\n* \"Oh, Alice did not specify any of the outputs, just the total amount, all of my old coins are owned by Alice now.\"\n* \"Oh, Alice specified an exact value for one of the outputs, that one is no longer owned by Alice but the rest are owned by Alice.\"\n* \"Oh, Alice specified exact values for two of the outputs, those two are definitely no longer owned by Alice but the rest are owned by Alice.\"\n\nThe conclusion here is either Alice never specifies any of the outputs --- in which case Alice cannot use a CoinSwap to pay directly to somebody else --- or Alice specifies all of them.\n\nAgain, the maker might be an active surveillor, thus we should reduce information leaks to the maker as much as we can.\n\n>\n> Bob would often still have to split a UTXO he owns, but see below about\n> breaking change address heuristics.\n>\n> > Of course, if a surveillor does solve the sparse subset sum, then the CoinSwap Protocol part looks exactly like a Bitcoin transaction, with a \"main\" paying output and a \"change\" output, and the same techniques that work with current Bitcoin txes work with \"CoinSwap Protocol\" virtual transactions.\n> > It seems to me that, in a system of makers and takers, even if the maker is really just paying the taker(s) to do CoinSwaps to mix back to itself, it should still \"require\" some output amount that really goes to itself, so that the maker at least does not differentiate between the case that the taker is paying to itself vs the case that the taker is paying someone else via a CoinSwap.\n> > That is, the protocol should still require that the taker specify some target desired amount, regardless of whether the taker wants to pay a specific value, or the taker wants to just mix its coins.\n>\n> If Bob needs to split a UTXO he'd do that with a change output. And\n> because we understand change detection heuristics we can intentionally\n> break them, for example if Bob's UTXO is on a p2sh-p2wpkh address and\n> the CoinSwap address is of that type too (because ECDSA-2P is being\n> used) then Bob could make his change output p2wpkh or p2pkh. Then anyone\n> using the script-type-heuristic would think that the CoinSwap address is\n> actually change and still belongs to Bob, and that the real change\n> address is actually the payment or CoinSwap address. i.e. the adversary\n> would assume that wallet software only uses one script type, in this\n> case it assumes that Bob's wallet is exclusively p2sh-p2wpkh.\n>\n> > > -   Multi-transaction CoinSwaps aren't truly an example of a subset-sum\n> > >     problem, but \"sparse subset sum\", a related and easier problem.\n> > >     The way its normally formulated, subset sum is about finding a subset\n> > >     that adds up to a target value. But in multi-transaction coinswap\n> > >     there'd only be three or four CoinSwap outputs, so the problem is\n> > >     finding just three or four integers in a big set that add up to the target.\n> > >     You could think of it mathematically that the n-choose-k function is\n> > >     near-polynomial when k is near 0 or near n, and the function is\n> > >     exponential when k is near n/2.\n> > >     A more promising way to build privacy is to create a situation where an\n> > >     adversary would find a huge amount of false positives which are very\n> > >     close the amount being sent. So even if the adversary has enough\n> > >     computational power to iterate all the amounts it won't help them much\n> > >     due to the huge number of false positives.\n> > >\n> >\n> > What are your thoughts on creating such possible situations?\n> > An idea is to require standard swap amounts, i.e. similar to the standard 100mBTC mixing bin of Wasabi.\n> > As well, one could randomly select some existing 1-input 1-output txes in the mempool and/or recent blocks, sum them, and swap for the same sum, to force at least one false positive, but the surveillor could protect against this by removing the earliest match (the one it saw in the mempool first, or onchain).\n>\n> I think we can get the false positive count up because the n-choose-k\n> function still gets quite large as k increases.\n>\n> We can make a simplified reasonable assumption that outputs on the\n> blockchain follow a lognormal distribution. An adversary trying to unmix\n> a 3-transaction CoinSwap would have to find the sum of every\n> 3-combination of the relevant outputs. For our case, the sum of three\n> lognormal distributions is another lognormal distribution with different\n> parameters, it's corresponding frequency distribution would get scaled\n> by n-choose-3. This frequency distribution is what the adversary would\n> find when searching, and that distribution would be quite tall because\n> of the scaling by n-choose-k. Suppose our CoinSwap is for 4 BTC then the\n> adversary would look at their frequency distribution at 4 BTC and find a\n> pretty big number, i.e. many other combinations of 3 outputs would add\n> up to 4 BTC just by chance. That is the false positive rate, and is our\n> anonymity set with respect to this attack.\n>\n> To work this out precisely we'd need to study the distribution of output\n> values on the blockchain today, and see how it behaves when summed\n> together. But the lognormal distribution assumption is probably not too\n> far from the truth, as it appears all the time in economics and finance,\n> and there is a clear justification for why. And the scaling by\n> n-choose-k would still hold.\n\nOkay, from what little I understand it seems that \"even if sparse subset sum is easier than subset sum, it is still hard, so it probably will not matter in practice\", would that be a fair takeaway?\n\n>\n> Along with that, some output amounts have very few significant figures\n> (e.g. 1 BTC, 0.1 BTC, 0.01 BTC), presumably because the user types just\n> one number on their keyboard when creating a transaction. We can use\n> that fact to add a bit of privacy by occasionally making one of our\n> outputs also be rounded like that.\n\nI agree.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Chris Belcher",
                "date": "2020-04-30T17:18:03",
                "message_text_only": "Hello ZmnSCPxj,\n\nOn 30/04/2020 09:54, ZmnSCPxj wrote:\n> Good morning CB,\n> \n> \n>> Equal-output-coinjoins and JoinMarket also have a version of the\n>> common-input-ownership-heuristic (CIOH), because its often possible to\n>> separate the inputs into sets of their owners of a equal-output-coinjoin\n>> using the input amounts. CoinSwap can be combined with something like\n>> PayJoin or CoinJoinXT, which would genuinely break the CIOH, so such a\n>> system wouldn't have this flaw either.\n>>\n>> For those reasons I've been thinking a CoinSwap system wouldn't need as\n>> many mixdepths, maybe it could use two or even just one.\n> \n> Would the ZeroLink proposal of separating a receiving (pre-mix) wallet from a sending (post-mix) wallet apply, thus having two implicit mixdepths (the receiving mixdepth and the sending mixdepth)?\n> Or would imposing the rule \"all sends must be via CoinSwap\" be sufficient (and follow the ZeroLink rule in spirit)?\n> \n>> If so, then it follows that multi-transaction CoinSwaps can be done by\n>> having UTXOs come from the same mixdepth, as long as the inputs that\n>> should be separate are not co-spent in the same transaction.\n> \n> This \"as long as the inputs that should be separate are not co-spent\" is precisely what mixdepths protect against, which is why I think *some* kind of mixdepth facility will still matter in CoinSwap.\n> \n> Still, you have convinced me that, for the purpose of multi-transaction CoinSwap where you do not merge any of your coins, it is immaterial if the sub-transactions come from the same mixdepth or not.\n> And if you have to merge your coins (for instance, if you are a maker and your customer wants to get a UTXO that is larger than any you have on hand, you have to merge your coins), you just have to ensure they are in the same mixdepth.\n> \n> Of course, you *could* be proposing some other construct --- perhaps you have some relational entry which says \"you cannot merge coin A and coin B\" which allows you to merge A C D or B C E, but not A B?\n> (I imagine this would make coin selection even harder, but I am not a mathematician and there may be some trivial solution to this.)\n> \n> Now --- if you have two coins that cannot be merged in the same onchain tx, what happens when you swap them in a multi-tx CoinSwap with somebody else?\n> That somebody else does not know that information.\n> Instead, that somebody else must always assume that any coins it got from the same CoinSwap operation must not be safely mergeable (though they can still be used in the same swap together).\n> \n> Coins received via receive addresses would also not be mergeable with any other coins, except coins to the same address (because coins in the same address already leak that they are owned by the same owner).\n\nYes I guess you're right. This part about mixdepths requires further\nthought.\n\nCoinSwap can be combined with some kind of CoinJoin (most likely\nsomething similar to PayJoin or CoinJoinXT). That should help with the\nreasoning about co-spending inputs and mixdepths, because other inputs\nthat are not owned by the taker will often be co-spent anyway.\n\nRegarding coins which mustn't be co-spent being coinswapped to somebody\nelse, ideally that coinswap maker will receive coins from unrelated\ntakers too, so will merge their coins along with those as well. Also the\nfact that a coinswap happened means there are two transactions between\nthe taker's-inputs-which-mustnt-be-merged and them actually being merged.\n\nGreat point on the receive addresses coins. Another use case of\nmixdepths is to stop incoming payments from two different sources being\nlinked together.\n\n>>> Assuming Alice is the taker, and Bob is the maker, then Alice might want a specific coin value (or set of such) that Bob does not have.\n>>> In that case, Bob will have to split a UTXO it owns.\n>>> We could constrain it so that Bob at least is not allowed to use the change from splitting for the same CoinSwap, e.g. if Bob has only 9 BTC and 1 BTC coins and Alice wants a 6 BTC / 3 BTC / 1 BTC split, then Bob cannot split its own 9 BTC coin then swap.\n>>> Or in terms of mixdepths, Bob can split within a mixdepth but each outgoing UTXO in the same swap should be from different mixdepths.\n>>\n>> A good way to do it could be for Alice to tell Bob that she wants 10 BTC\n>> and let Bob figure out on his own how to get that amount, based on the\n>> amounts he already has. If Alice is making a payment she can provide\n>> that amount too, but all the other output amounts can be up to Bob.\n> \n> This leaks to Bob whether Alice is making a payment or not; it would be better for the privacy of Alice for Alice to *always* mention *some* \"payment amount\", even if this is not actually a payment and Alice is just mixing for herself prior to storing in cold storage.\n> And if Alice wants to use a single swap to pay to multiple targets at once, that implies Alice has to have the ability to indicate the outputs it wants to Bob, and it would imply as well that Alice has to obfuscate which of those outputs have amounts that actually *matter* (by always insisting on what the output amounts must be, rather than insisting on N output amounts and letting Bob handle the rest).\n> (We *could* constrain it such that Alice can make only one payment per CoinSwap, so that Alice only gives one \"target\" amount and one \"total\" amount, but that implies even bigger blockspace utilization, sigh.)\n> \n> Otherwise, Bob can get information:\n> \n> * \"Oh, Alice did not specify any of the outputs, just the total amount, all of my old coins are owned by Alice now.\"\n> * \"Oh, Alice specified an exact value for one of the outputs, that one is no longer owned by Alice but the rest are owned by Alice.\"\n> * \"Oh, Alice specified exact values for two of the outputs, those two are definitely no longer owned by Alice but the rest are owned by Alice.\"\n> \n> The conclusion here is either Alice never specifies any of the outputs --- in which case Alice cannot use a CoinSwap to pay directly to somebody else --- or Alice specifies all of them.\n> \n> Again, the maker might be an active surveillor, thus we should reduce information leaks to the maker as much as we can.\n\nYep great point.\n\nA benefit of Alice not specifying any amounts is that Bob is able to\nimprove privacy and reduce costs by creating fewer change outputs. A\ndownside is that this leaks Alice's intentions (self-mix vs payment) to Bob.\n\nA solution could be to add randomness. Have Alice randomly specify\npayment amounts with some probability even if she is only self-mixing.\n\nAlthough this doesn't solve everything, because Alice not specifying any\namounts implies self-mixing. But at least specifying some amounts\ndoesn't imply a payment.\n\n>>\n>> Bob would often still have to split a UTXO he owns, but see below about\n>> breaking change address heuristics.\n>>\n>>> Of course, if a surveillor does solve the sparse subset sum, then the CoinSwap Protocol part looks exactly like a Bitcoin transaction, with a \"main\" paying output and a \"change\" output, and the same techniques that work with current Bitcoin txes work with \"CoinSwap Protocol\" virtual transactions.\n>>> It seems to me that, in a system of makers and takers, even if the maker is really just paying the taker(s) to do CoinSwaps to mix back to itself, it should still \"require\" some output amount that really goes to itself, so that the maker at least does not differentiate between the case that the taker is paying to itself vs the case that the taker is paying someone else via a CoinSwap.\n>>> That is, the protocol should still require that the taker specify some target desired amount, regardless of whether the taker wants to pay a specific value, or the taker wants to just mix its coins.\n>>\n>> If Bob needs to split a UTXO he'd do that with a change output. And\n>> because we understand change detection heuristics we can intentionally\n>> break them, for example if Bob's UTXO is on a p2sh-p2wpkh address and\n>> the CoinSwap address is of that type too (because ECDSA-2P is being\n>> used) then Bob could make his change output p2wpkh or p2pkh. Then anyone\n>> using the script-type-heuristic would think that the CoinSwap address is\n>> actually change and still belongs to Bob, and that the real change\n>> address is actually the payment or CoinSwap address. i.e. the adversary\n>> would assume that wallet software only uses one script type, in this\n>> case it assumes that Bob's wallet is exclusively p2sh-p2wpkh.\n>>\n>>>> -   Multi-transaction CoinSwaps aren't truly an example of a subset-sum\n>>>>     problem, but \"sparse subset sum\", a related and easier problem.\n>>>>     The way its normally formulated, subset sum is about finding a subset\n>>>>     that adds up to a target value. But in multi-transaction coinswap\n>>>>     there'd only be three or four CoinSwap outputs, so the problem is\n>>>>     finding just three or four integers in a big set that add up to the target.\n>>>>     You could think of it mathematically that the n-choose-k function is\n>>>>     near-polynomial when k is near 0 or near n, and the function is\n>>>>     exponential when k is near n/2.\n>>>>     A more promising way to build privacy is to create a situation where an\n>>>>     adversary would find a huge amount of false positives which are very\n>>>>     close the amount being sent. So even if the adversary has enough\n>>>>     computational power to iterate all the amounts it won't help them much\n>>>>     due to the huge number of false positives.\n>>>>\n>>>\n>>> What are your thoughts on creating such possible situations?\n>>> An idea is to require standard swap amounts, i.e. similar to the standard 100mBTC mixing bin of Wasabi.\n>>> As well, one could randomly select some existing 1-input 1-output txes in the mempool and/or recent blocks, sum them, and swap for the same sum, to force at least one false positive, but the surveillor could protect against this by removing the earliest match (the one it saw in the mempool first, or onchain).\n>>\n>> I think we can get the false positive count up because the n-choose-k\n>> function still gets quite large as k increases.\n>>\n>> We can make a simplified reasonable assumption that outputs on the\n>> blockchain follow a lognormal distribution. An adversary trying to unmix\n>> a 3-transaction CoinSwap would have to find the sum of every\n>> 3-combination of the relevant outputs. For our case, the sum of three\n>> lognormal distributions is another lognormal distribution with different\n>> parameters, it's corresponding frequency distribution would get scaled\n>> by n-choose-3. This frequency distribution is what the adversary would\n>> find when searching, and that distribution would be quite tall because\n>> of the scaling by n-choose-k. Suppose our CoinSwap is for 4 BTC then the\n>> adversary would look at their frequency distribution at 4 BTC and find a\n>> pretty big number, i.e. many other combinations of 3 outputs would add\n>> up to 4 BTC just by chance. That is the false positive rate, and is our\n>> anonymity set with respect to this attack.\n>>\n>> To work this out precisely we'd need to study the distribution of output\n>> values on the blockchain today, and see how it behaves when summed\n>> together. But the lognormal distribution assumption is probably not too\n>> far from the truth, as it appears all the time in economics and finance,\n>> and there is a clear justification for why. And the scaling by\n>> n-choose-k would still hold.\n> \n> Okay, from what little I understand it seems that \"even if sparse subset sum is easier than subset sum, it is still hard, so it probably will not matter in practice\", would that be a fair takeaway?\n\nNot exactly. Here's another summary:\n\nSuppose Alice has V bitcoins and mixes them with multi-transaction\nCoinSwap, she receives transactions with amounts (w_0, w_1, w_2....)\nwhich add up to V.\n\nPrivacy relying on the (sparse) subset sum problem works by making it\n_computationally infeasible_ for an adversary to search the entire\nblockchain for sets of transactions (w_0, w_1, w_2....) which add up to\nV. I believe aiming for this kind of privacy isn't practical due to\nblock space considerations and others.\n\nPrivacy relying on false positives does not make any search\ncomputationally infeasible, it works by having a large number of other\nsets of transactions (w_0, w_1, w_2....) which add up to V just by\nchance. Then the transactions received by Alice's will have a big crowd\nto hide in. I believe this is practical because the numbers are\nproportional to the n-choose-k function which can still be very large.\n\n\nRegards\nCB"
            }
        ],
        "thread_summary": {
            "title": "Fwd: (Semi)Traceless 2-party coinjoin off-chain protocol using schnorr signatures",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "German Luna",
                "Chris Belcher"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 63953
        }
    },
    {
        "title": "[bitcoin-dev] Revault: a multi-party vault architecture",
        "thread_messages": [
            {
                "author": "darosior",
                "date": "2020-04-24T15:00:16",
                "message_text_only": "Hi all,\n\nKevin Loaec and I have been working on a new multiparty vault architecture and I think it reached the point where we\u2019d welcome some feedback.\n\n\nIntended usage and limitations\n==============================\n\nThe aim is to secure the shared storage of coins without relying on a trusted third party and by disincentivizing theft attempts, while not restricting the usage of the funds for day-to-day operations.\n\nRevault uses N-of-N multisigs and thus does not protect against intentional locking of funds (such as refusal to sign, or key erasure). Therefore it assumes its users (likely companies with already on-going agreements between shareholders) to be able to solve intentional blockage outside the Bitcoin network (such as through legal contracts).\n\n\nThe actual architecture\n=======================\n\nWe called it revault as it relies on pre-signed and revocable (revaultable) transactions.\nThe users pre-sign a transaction chain as the only used way to spend from a vault output.\nThey would have signed a set of transactions to either cancel a spend attempt or lock the funds for some time beforehand. The funds are always better locked for a long time than stolen.\n\n\nThe transactions\n----------------\n\nThe system is composed of mainly 6 transaction types (with N the number of stakeholders) :\n\n- The \u201cvault\u201d transaction which pays to a N-of-N, by which funds are received.\n- The \u201cemergency\u201d transaction, which spends the vault output and pays to a [here goes a\nhigh value]-days timelocked N-of-N (with N differents but statics keys, assumed to be physically stored in hard(/long) to access locations).\n- The \u201cunvault\u201d transaction, which spends the vault output and pays to [either the vault\u2019s N-of-N, or *after X blocks* to a subset of the stakeholders AND a co-signing server].\n- The \u201cunvault emergency\u201d transaction, which spends the unvault output and pays to the\nsame script as the first emergency transaction.\n- The \u201ccancel\u201d transaction, which spends the unvault output and pays back to a new vault utxo.\n- The \u201cspend\u201d transaction, which spends the unvault output and pays to an external address (potentially contained in a list of destinations previously agreed-upon by all the stakeholders).\n\n\nThe process\n-----------\n\nThe stakeholders would exchange the signatures of all the revaulting transactions after the reception of a new vault utxo, and then exchange the signatures of the unvaulting transaction. Before doing so, the coins are not available to be spent.\n\nIn order to spend a vault, the subset of the stakeholders who manages the funds (for example, the traders of an investment fund) would make the cosigning server (which only signs a transaction once) sign the spend transaction.\nThey would then present it to the other watchers which would ACK the spend (if paying to an authorized address), and broadcast the \"unvault\" transaction. Finally, and after X blocks have passed they would be able to broadcast the spend transaction.\nIf a stakeholder's watcher detects an unvaulting transaction without knowing about its child \u201cspend\u201d transaction, it triggers an automatic \u201ccancel\u201d transaction (not encumbered by the timelock).\n\nAt any point -even in the middle of a spend- any of the stakeholder can trigger an emergency transaction if anything nasty is happening.\nAny network watcher noticing the broadcast of an emergency transaction would also broadcast all other vaults\u2019 emergency transactions.\n\nThis network watching and revaulting power can be replicated (watchtowers) to further decrease the reliance on a single machine or internet access.\n\n\nPre-signed transactions fun\n---------------------------\n\nIn order to avoid our security assumptions to be as weak as betting on the value of the feerate in the future, stakeholders exchange SINGLE | ANYONECANPAY signatures for the revaulting transactions and append their own as SIGHASH_ALL before broadcasting.\nThey can add another input (and potentially output) in order to bump the fees before doing so.\n\nWe protect ourselves from the bug by leveraging the fact the revaulting (namely the \"emergency\", \"unvault emergency\", and \"cancel\" transactions) only have *strictly* one input and one output. The change being part of the spend transaction.\n\nIn addition, revaulting transactions may signal for RBF to cover a feerate increase after the broadcast. Anyhow, a significant breathing room can be added to the feerate as these transactions are not intended to be used under normal circumstances.\n\n\nWorth mentioning\n================\n\nThe original draft of this architecture was first designed by Kevin Loaec who was hired by NOIA to do so. It was inspired by Bryan Bishop\u2019s single-party vault architecture (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017229.html), who published a demo implementation of it last week (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html, https://github.com/kanzure/python-vaults).\nKevin and I since detailed and reworked our new architecture together.\n\nA WIP draft / demo / PoC / [enter adjective with \u201cinsecure\u201d meaning] implementation is available at https://github.com/re-vault/revault-demo, which uses 4 stakeholders, 2 or 3 traders (doing the day-to-day moves) a CSV of 6 blocks for the unvault script and a CSV of ~1 month for the emergency scripts.\nThe transactions used are detailed in the doc/ directory of the same repo, and are coded in the revault/transactions/ module.\n\nThe \u201crevault\u201d name was coined by Lea Thiebaut (Lexyon).\n\n\nThanks for reading,\nAntoine / Darosior"
            }
        ],
        "thread_summary": {
            "title": "Revault: a multi-party vault architecture",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "darosior"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5542
        }
    },
    {
        "title": "[bitcoin-dev] PSBT in QR codes",
        "thread_messages": [
            {
                "author": "Riccardo Casatta",
                "date": "2020-04-27T20:11:43",
                "message_text_only": "Hi all,\n\nthere is some discussion happening [1] about how to encode a PSBT in QR\ncodes.\n\nAccording to the specification (page 15 [2]) a version 40 QR code could\ncontain up to 3706 bytes of data, however practical limitation are much\nlower and a PSBT could grow bigger anyway. so the issue is that a PSBT does\nnot fit in 1 QR code.\n\nThere are proposals suggesting animated QR codes but I don't think it's a\ngood idea for the following reasons:\n* they are not easy to print\n* it's not clear, by a human look, how much data it's being transferred,\nthus allowing more space for attacks\n* old hardware may have resource constraint and not being able to scan\n\nThere are proposals suggesting alphanumeric mode for QR codes and a header\n(like message 1 of n) to allow data reconstruction. Main argument for this\nchoices are:\n* use of built-in standard scanner\n* data is copypasteable\n* not a big loose in efficiency comparing to binary with a proper encoding\n* industrial QR code scanner put a \\r at the end of transmission (making\nbinary mode difficult to handle with timeouts or similar)\n\nI don't think alphanumeric with custom headers it's a good idea and I think\nwe should use binary encoding and using the already available mode in QR\ncode specification called \"structured append\" (page 55 [2]). Corresponding\ncounter-points are:\n* since data need to be reconstructed, I would avoid built-in scanner and\nmanual appending of strings anyway.\n* we can keep the already used base64 for copypaste\n* the best of the encoding we already have, bech32, is 10% less efficient\nthan binary and if we want to be more efficient we need to introduce a new\nspecific encoding\n* I don't have a strong counter-point on industrial scanner, however if\nthey use \\r to signal end of transmission they don't support well binary at\nall, why they don't send how many bytes they read?\n\nThere are some doubts about support of structured append in QR code\nlibraries which is not widely supported. While this is true I verified the\nwidely diffused zxing library on Android and Luca Vaccaro verified the\nApple built-in scanner, and both this libraries let's you access to the\nscanned raw bytes, allowing to parse the structured append header.\nFor reference, structured append allows to chain up to 16 qr codes, and\ncontains 1 byte of parity.\n\n[1] https://github.com/cryptoadvance/specter-diy/issues/57\n[2]\nhttps://www.swisseduc.ch/informatik/theoretische_informatik/qr_codes/docs/qr_standard.pdf\n\n\n--\nRiccardo Casatta - @RCasatta\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200427/3e1cdb39/attachment.html>"
            },
            {
                "author": "Christopher Allen",
                "date": "2020-04-28T01:47:26",
                "message_text_only": "On Mon, Apr 27, 2020 at 1:44 PM Riccardo Casatta via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> [1] https://github.com/cryptoadvance/specter-diy/issues/57\n>\n\nSo that we don't overwhelm the specter-diy maintainers with topics outside\nthe scope of their project, we are slowly moving the discussion on this\ntopic to:\n\n        https://github.com/BlockchainCommons/AirgappedSigning/issues/4.\n\nThis is also the repository where I hope we can share examples, prototypes,\netc. until we have some consensus among these wallet developers for a\ncommon QR code compatible format for PSBT to submit as an official BIP.\n\n\u2014 Christopher Allen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200427/aa2ad7f2/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "PSBT in QR codes",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Christopher Allen",
                "Riccardo Casatta"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3513
        }
    },
    {
        "title": "[bitcoin-dev] Sorting outputs of a transaction in alphabetic order to protect privacy",
        "thread_messages": [
            {
                "author": "SatoshiSingh",
                "date": "2020-04-29T06:47:39",
                "message_text_only": "Hi list. I've been a lurker for quite sometime and this is my first post.\n\nThe problem I'm addressing is that generally wallet devs construct the tx with the 2nd output being of the sender as change. This helps chain analysers to identity addresses and invade the users privacy.\n\nI'm suggesting to sort the outputs in alphabetic order (or by pure random order) before broadcasting. This way the chain analyser cannot be sure which output is the change output and will improve privacy a little.\n\nThanks\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200429/db454109/attachment.html>"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2020-04-30T12:14:28",
                "message_text_only": "https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki\n\n--\nBest Regards / S pozdravom,\n\nPavol \"stick\" Rusnak\nCTO, SatoshiLabs\n\nOn Thu, Apr 30, 2020, 10:21 SatoshiSingh via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi list. I've been a lurker for quite sometime and this is my first post.\n>\n> The problem I'm addressing is that generally wallet devs construct the tx\n> with the 2nd output being of the sender as change. This helps chain\n> analysers to identity addresses and invade the users privacy.\n>\n> I'm suggesting to sort the outputs in alphabetic order (or by pure random\n> order) before broadcasting. This way the chain analyser cannot be sure\n> which output is the change output and will improve privacy a little.\n>\n> Thanks_______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200430/48d74736/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Sorting outputs of a transaction in alphabetic order to protect privacy",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Pavol Rusnak",
                "SatoshiSingh"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1815
        }
    },
    {
        "title": "[bitcoin-dev] BIP-341: Committing to all scriptPubKeys in the signature message",
        "thread_messages": [
            {
                "author": "Andrew Kozlik",
                "date": "2020-04-29T14:57:46",
                "message_text_only": "Hi everyone,\n\nIn the current draft of BIP-0341 [1] the signature message commits to the\nscriptPubKey of the output being spent by the input. I propose that the\nsignature message should commit to the scriptPubKeys of *all* transaction\ninputs.\n\nIn certain applications like CoinJoin, a wallet has to deal with\ntransactions containing external inputs. To calculate the actual amount\nthat the user is spending, the wallet needs to reliably determine for each\ninput whether it belongs to the wallet or not. Without such a mechanism an\nadversary can fool the wallet into displaying incorrect information about\nthe amount being spent, which can result in theft of user funds [2].\n\nIn order to ascertain non-ownership of an input which is claimed to be\nexternal, the wallet needs the scriptPubKey of the previous output spent by\nthis input. It must acquire the full transaction being spent and verify its\nhash against that which is given in the outpoint. This is an obstacle in\nthe implementation of lightweight air-gapped wallets and hardware wallets\nin general. If the signature message would commit to the scriptPubKeys of\nall transaction inputs, then the wallet would only need to acquire the\nscriptPubKey of the output being spent without having to acquire and verify\nthe hash of the entire previous transaction. If an attacker would provide\nan incorrect scriptPubKey, then that would cause the wallet to generate an\ninvalid signature message.\n\nNote that committing only to the scriptPubKey of the output being spent is\ninsufficient for this application, because the scriptPubKeys which are\nneeded to ascertain non-ownership of external inputs are precisely the ones\nthat would not be included in any of the signature messages produced by the\nwallet.\n\nThe obvious way to implement this is to add another hash to the signature\nmessage:\nsha_scriptPubKeys (32): the SHA256 of the serialization of all\nscriptPubKeys of the previous outputs spent by this transaction.\n\nCheers,\nAndrew Kozlik\n\n[1]\nhttps://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#common-signature-message\n[2]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-August/014843.html\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200429/34d294c1/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP-341: Committing to all scriptPubKeys in the signature message",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Andrew Kozlik"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2342
        }
    }
]