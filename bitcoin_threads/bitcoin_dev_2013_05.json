[
    {
        "title": "[Bitcoin-development] Service bits for pruned nodes",
        "thread_messages": [
            {
                "author": "Jeff Garzik",
                "date": "2013-05-01T13:46:08",
                "message_text_only": "On Sun, Apr 28, 2013 at 11:51 AM, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n> Hello all,\n>\n> I think it is time to move forward with pruning nodes, i.e. nodes that fully\n> validate and relay blocks and transactions, but which do not keep (all)\n> historic blocks around, and thus cannot be queried for these.\n>\n> The biggest roadblock is making sure new and old nodes that start up are\n> able to find nodes to synchronize from. To help them find peers, I would\n> like to propose adding two extra service bits to the P2P protocol:\n> * NODE_VALIDATE: relay and validate blocks and transactions, but is only\n> guaranteed to answer getdata requests for (recently) relayed blocks and\n> transactions, and mempool transactions.\n> * NODE_BLOCKS_2016: can be queried for the last 2016 blocks, but without\n> guarantee for relaying/validating new blocks and transactions.\n> * NODE_NETWORK (which existed before) will imply NODE_VALIDATE and guarantee\n> availability of all historic blocks.\n\nIn general, I support this, as anybody on IRC knows.\n\nThough it does seem to open the question about snapshotting.\n\nPersonally, it seems important to enable running a fully validating\nnode, that may bootstrap from a UTXO snapshot + all blocks since that\nsnapshot.\n\nNODE_BLOCKS_2016, in particular, is too short.  For users, I've seen\nplenty of use cases in the field where you start a network sync after\na 2-week period.\n\nSet a regular interval for creating a UTXO snapshot, say 3 months\n(6*2016 blocks), and serve all blocks after that snapshot.  For older\nnodes, they would contact an archive node or torrent for >3 month\nblocks, and then download normally <= 3 month blocks (if the archive\nnode didn't serve up to present day).\n\nWhere are we on nailing down a stable, hash-able UTXO serialization?\n\n-- \nJeff Garzik\nexMULTI, Inc.\njgarzik at exmulti.com"
            },
            {
                "author": "Pieter Wuille",
                "date": "2013-05-03T12:30:19",
                "message_text_only": "(generic comment on the discussion that spawned off: ideas about how to\nallow additional protocols for block exchange are certainly interesting,\nand in the long term we should certainly consider that. For now I'd like to\nkeep this about the more immediate way forward with making the P2P protocol\nnot break in the presence of pruning nodes)\n\nOn Sun, Apr 28, 2013 at 6:57 PM, Mike Hearn <mike at plan99.net> wrote:\n\n> That's true. It can be perhaps be represented as \"I keep the last N\n> blocks\" and then most likely for any given node the policy doesn't change\n> all that fast, so if you know the best chain height you can calculate which\n> nodes have what.\n>\n\nYes, I like that better than broadcasting the exact height starting at\nwhich you serve (though I would put that information immediately in the\nversion announcement). I don't think we can rely on the addr broadcasting\nmechanism for fast information exchange anyway. One more problem with this:\nDNS seeds cannot convey this information (neither do they currently convey\nservice bits, but at least those can be indexed separately, and served\nexplicitly through asking for a specific subdomain or so).\n\nSo to summarize:\n* Add a field to addr messages (after protocol number increase) that\nmaintains number of top blocks served)?\n* Add a field to version message to announce the actual first block served?\n* Add service bits to separately enable \"relaying/verifying node\" and\n\"serves (part of) the historic chain\"? My original reason for suggesting\nthis was different, I think better compatibility with DNS seeds may be a\ngood reason for this. You could ask the seed first for a subset that at\nleast serves some part of the historic chain, until you hit a node that has\nenough, and once caught up, ask for nodes that relay.\n\nDisconnecting in case something is requested that isn't served seems like\n>> an acceptable behaviour, yes. A specific message indicating data is pruned\n>> may be more flexible, but more complex to handle too.\n>>\n>\n> Well, old nodes would ignore it and new nodes wouldn't need it?\n>\n\nI'm sure there will be cases where a new node connects based on outdated\ninformation. I'm just stating that I agree with the generic policy of \"if a\nnode requests something it should have known the peer doesn't serve, it is\nfair to be disconnected.\"\n\n\n>  The reason for splitting them is that I think over time these may be\n>> handled by different implementations. You could have stupid\n>> storage/bandwidth nodes that just keep the blockchain around, and others\n>> that validate it. Even if that doesn't happen implementation-wise, I think\n>> these are sufficiently independent functions to start thinking about them\n>> as such.\n>>\n>\n> Maybe so, with a \"last N blocks\" in addr messages though such nodes could\n> just set their advertised history to zero and not have to deal with serving\n> blocks to nodes.\n>\n> If you have a node that serves the chain but doesn't validate it, how does\n> it know what the best chain is? Just whatever the hardest is?\n>\n\nMaybe it validates, maybe it doesn't. What matters is that it doesn't\nguarantee relaying fresh blocks and transactions. Maybe it does validate,\nmaybe it just stores any blocks, and uses a validating node to know what to\nannounce as best chain, or it uses an SPV mechanism to determine that. Or\nit only validates and relays blocks, but not transactions. My point is that\n\"serving historic data\" and \"relaying fresh data\" are separate\nresponsibilities, and there's no need to require them to be combined.\n\n-- \nPieter\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130503/9a6e4327/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-05-03T14:06:29",
                "message_text_only": "> Yes, I like that better than broadcasting the exact height starting at\n> which you serve (though I would put that information immediately in the\n> version announcement). I don't think we can rely on the addr broadcasting\n> mechanism for fast information exchange anyway. One more problem with this:\n> DNS seeds cannot convey this information (neither do they currently convey\n> service bits, but at least those can be indexed separately, and served\n> explicitly through asking for a specific subdomain or so).\n>\n\nThat's true, but we can extend the DNS seeding protocol a little bit - you\ncould query <current-chain-height>.dnsseed.whatever.com and the DNS server\nthen only returns nodes it knows matches your requirement.\n\nThis might complicate existing seeds a bit, and it's a bit of a hack, but\nprotocol-wise it's still possible. Of course if you want to add more\ndimensions it gets uglier fast.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130503/98d57696/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2013-05-03T14:18:01",
                "message_text_only": "On Fri, May 03, 2013 at 04:06:29PM +0200, Mike Hearn wrote:\n> That's true, but we can extend the DNS seeding protocol a little bit - you\n> could query <current-chain-height>.dnsseed.whatever.com and the DNS server\n> then only returns nodes it knows matches your requirement.\n\nIf you're going to take a step like that, the <current-chain-height>\nshould be rounded off, perhaps to some number of bits, or you'll allow\nDNS caching to be defeated.\n\nMake clients check for the largest \"rounded off\" value first, and then\ndrill down if required. Some complexity involved...\n\n> This might complicate existing seeds a bit, and it's a bit of a hack, but\n> protocol-wise it's still possible. Of course if you want to add more\n> dimensions it gets uglier fast.\n\nMaybe I should make my blockheaders-over-dns thing production worthy\nfirst so we can see how many ISP's come at us with pitchforks? :P\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000142de0244ee8fac516e7c0a29da1eafc0d43f2da8b6388b387\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130503/b7a549e8/attachment.sig>"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-05-03T15:02:26",
                "message_text_only": "> If you're going to take a step like that, the <current-chain-height>\n> should be rounded off, perhaps to some number of bits, or you'll allow\n> DNS caching to be defeated.\n>\n\nDon't the seeds already set small times? I'm not sure we want these\nresponses to be cacheable, otherwise there's a risk of a wall of traffic\nsuddenly showing up at one set of nodes if a large ISP caches a response.\n(yes yes, I know, SPV node should be remembering addr broadcasts and such).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130503/6dc99811/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2013-05-03T15:11:57",
                "message_text_only": "On Fri, May 03, 2013 at 05:02:26PM +0200, Mike Hearn wrote:\n> > If you're going to take a step like that, the <current-chain-height>\n> > should be rounded off, perhaps to some number of bits, or you'll allow\n> > DNS caching to be defeated.\n> >\n> \n> Don't the seeds already set small times? I'm not sure we want these\n> responses to be cacheable, otherwise there's a risk of a wall of traffic\n> suddenly showing up at one set of nodes if a large ISP caches a response.\n> (yes yes, I know, SPV node should be remembering addr broadcasts and such).\n\nHmm, on second thought you're probably right for the standard case where\nit's really P2P. On the other hand it kinda limits us in the future if\nseeds have high-bandwidth nodes they can just point clients too, but\nmaybe just assuming the DNS seed might need high bandwidth as well is\nacceptable.\n\nI dunno, given how badly behaved a lot of ISP dns servers are re:\ncaching, maybe we're better off keeping it simple.\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000013bfdf35da40a40c35ccd75e09652ae541d94d26130a695f757\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130503/30c4eca0/attachment.sig>"
            },
            {
                "author": "John Dillon",
                "date": "2013-05-04T18:07:42",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nI think you too should ask yourself why you are putting so much effort into\noptimizing a centralized service, the DNS seeds, rather than putting effort\ninto optimizing the P2P peer discovery instead. DNS seeds are a necessary evil,\none that shouldn't be promoted with additional features beyond simply obtaining\nyour initial set of peers.\n\nAfter all Peter, just like you have implemented alternate block header\ndistribution over twitter, in the future we should have many different means of\npeer discovery. Right now we have DNS seeds, a fixed list, and IRC discovery\nthat does not work because the servers it was pointed too no longer exist. Not\na good place to be.\n\nSome random ideas:\n\nsearch engines - search for \"bitcoin seed address\" or something and try IP's\nfound (twitter is similar)\n\nipv4 scanning - not exactly friendly, but the density of bitcoin nodes is\nprobably getting to the point where a brute force search is feasible\n\nanycast peers - would work best with UDP probably, who has the resources to set\nthis up?\n\n\nIt is probably not worth the effort implementing the above immediately, but it\nis worth the effort to ensure that we don't make the DNS seed system so complex\nand sophisticated that we depend on it.\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.10 (GNU/Linux)\n\niQEcBAEBCAAGBQJRhU44AAoJEEWCsU4mNhiPtssH/1yb/FZRRaZpr3CwkoaOhbhu\npxfRNWgOEOL/mlWKTVgp2812qEnY9DySpJ5DJMjx7/GhSvOtnteza5ts4+pbuWhd\nl6E1R9zAYxX+VOiBxcBtoZNEXDcS+CjMumuBH5S1v+L5jEntOWS9G8DKasjD2WAQ\nDzX8YbOuzIOqasEbr5Hpr9Vfl7ZtW/+q/sPhQ1q3a7n7MaaIZrZicisJw3z7T7+0\nT0yK8vUdYfstTjs0zLzfI5PW9+TG5T0kvj0kXSCjnK723Mfl7SXp6UZx6yebBi6q\ntcTVOPo4hfBWk8XryZxaSNCkDYY6kryy5cb2V+BojVfqLWVKgR3pdZqXqnEKNLo=\n=0XFF\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-05-04T18:55:54",
                "message_text_only": "On Sat, May 4, 2013 at 2:07 PM, John Dillon\n<john.dillon892 at googlemail.com> wrote:\n> After all Peter, just like you have implemented alternate block header\n> distribution over twitter, in the future we should have many different means of\n> peer discovery. Right now we have DNS seeds, a fixed list, and IRC discovery\n> that does not work because the servers it was pointed too no longer exist. Not\n> a good place to be.\n\nLet's not confuse bootstrapping with overall peer discovery.\n\nPeer exchange between P2P nodes is the primary and best method of\nobtaining free peers.\n\nObviously you need to bootstrap into that, though.  DNS seed and fixed\nlist are those bootstrap methods (IRC code was deleted), but are only\nused to limp along until you can contact a real P2P node, at which\npoint peer discovery truly begins.\n\n-- \nJeff Garzik\nexMULTI, Inc.\njgarzik at exmulti.com"
            },
            {
                "author": "John Dillon",
                "date": "2013-05-05T13:12:15",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nSorry I should have used the word bootstrapping there rather than discovery.\nBut again I think that shows my point clearly. Centralized methods like DNS\nshould be used for as little as possible, just simple initial bootstrapping,\nand focus the development efforts towards the non-centralized peer discovery\nmechanisms.\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.10 (GNU/Linux)\n\niQEcBAEBCAAGBQJRhlpyAAoJEEWCsU4mNhiP+NwH/3RY5vBpSYkwKgTmdKHRc/gw\nBJCSV/1MEDECgBTxaRYSzYZyargjsdG50KaIaCq8M1+8DWkBEkH8JFif7UYMlZGM\nWROMP6UjAnP1fJ3B2JChdMgRv1HdXJQDQVcO8UnSJschhX8lZZiUySbaqIPuRuV/\nlI7/JkUZvmnms4+HGiaqwfbPO0k6ytJNKxORrk4TzFnThh4dy9WytElc8JHZOFaQ\nly159X5JuEwh8DLOoUtPhaR6tJaJbJLBEt+QJiGnSktPsJCE8p9+4HQ0kMCQr3Ha\n05EHTZEw+TqEPaA7vFLgA/9tWjK9s1Y6sqLOAYiLp/0wSKzCkBO0C5LWFHsJ/XQ=\n=aCgi\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-05-06T08:19:35",
                "message_text_only": "You are welcome to optimise P2P addr broadcasts or develop better bootstrap\nmechanisms.\n\n\nOn Sun, May 5, 2013 at 3:12 PM, John Dillon\n<john.dillon892 at googlemail.com>wrote:\n\n> -----BEGIN PGP SIGNED MESSAGE-----\n> Hash: SHA256\n>\n> Sorry I should have used the word bootstrapping there rather than\n> discovery.\n> But again I think that shows my point clearly. Centralized methods like DNS\n> should be used for as little as possible, just simple initial\n> bootstrapping,\n> and focus the development efforts towards the non-centralized peer\n> discovery\n> mechanisms.\n> -----BEGIN PGP SIGNATURE-----\n> Version: GnuPG v1.4.10 (GNU/Linux)\n>\n> iQEcBAEBCAAGBQJRhlpyAAoJEEWCsU4mNhiP+NwH/3RY5vBpSYkwKgTmdKHRc/gw\n> BJCSV/1MEDECgBTxaRYSzYZyargjsdG50KaIaCq8M1+8DWkBEkH8JFif7UYMlZGM\n> WROMP6UjAnP1fJ3B2JChdMgRv1HdXJQDQVcO8UnSJschhX8lZZiUySbaqIPuRuV/\n> lI7/JkUZvmnms4+HGiaqwfbPO0k6ytJNKxORrk4TzFnThh4dy9WytElc8JHZOFaQ\n> ly159X5JuEwh8DLOoUtPhaR6tJaJbJLBEt+QJiGnSktPsJCE8p9+4HQ0kMCQr3Ha\n> 05EHTZEw+TqEPaA7vFLgA/9tWjK9s1Y6sqLOAYiLp/0wSKzCkBO0C5LWFHsJ/XQ=\n> =aCgi\n> -----END PGP SIGNATURE-----\n>\n>\n> ------------------------------------------------------------------------------\n> Get 100% visibility into Java/.NET code with AppDynamics Lite\n> It's a free troubleshooting tool designed for production\n> Get down to code-level detail for bottlenecks, with <2% overhead.\n> Download for free and get started troubleshooting in minutes.\n> http://p.sf.net/sfu/appdyn_d2d_ap2\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130506/07b993b5/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2013-05-06T13:13:55",
                "message_text_only": "On Mon, May 06, 2013 at 10:19:35AM +0200, Mike Hearn wrote:\n> You are welcome to optimise P2P addr broadcasts or develop better bootstrap\n> mechanisms.\n\nI think John's actually has a point here. If we're judging the quality of a\nprotocol change by how compatible it is with DNS seeding, then we're clearly not\nusing DNS seeding as seeding anymore (=getting an entry point into the P2P\nnetwork), but as a mechanism for choosing (all) peers.\n\nEventually, I think it makes sense to move to a system where you get seeds from\na DNS (or other mechanism), connect to one or a few of the results, do a getaddr,\nfill your peer IP database with it, and disconnect from the DNS seeded peer.\n\nThis probably means we need to look at ways to optimize current peer exchange,\nbut that's certainly welcome in any case.\n\n-- \nPieter"
            },
            {
                "author": "Ricardo Filipe",
                "date": "2013-05-16T11:26:49",
                "message_text_only": "We would only end up with few copies of the historic data if users\ncould choose what parts of the blockchain to store. Simply store\nchunks randomly, according to users available space, and give priority\nto the \"N most recent\" chunks to have more replicas in the network.\n\nYou don't need bittorrent specifically for a DHT, if publicity is a\nproblem. There are many DHT proposals and implementations, and i bet\none of them should be more suitable to the bitcoin network than\nbittorrent's.\n\n>On Sun, Apr 28, 2013 at 9:29 AM, Mike Hearn <mike at ...> wrote:\n>> I'd imagined that nodes would be able to pick their own ranges to keep\n>> rather than have fixed chosen intervals. \"Everything or two weeks\" is rather\n>\n>X most recent is special for two reasons:  It meshes well with actual demand,\n>and the data is required for reorganization.\n>\n>So whatever we do for historic data, N most recent should be treated specially.\n>\n>But I also agree that its important that <everything> be splittable into ranges\n>because otherwise when having to choose between serving historic data\n>and\u2014 say\u2014 40 GB storage, a great many are going to choose not to serve\n>historic data... and so nodes may be willing to contribute 4-39 GB storage\n>to the network there will be no good way for them to do so and we may end\n>up with too few copies of the historic data available.\n>\n>As can be seen in the graph, once you get past the most recent 4000\n>blocks the probability is fairly uniform... so \"N most recent\" is not a\n>good way to divide load for the older blocks. But simple ranges\u2014 perhaps\n>quantized to groups of 100 or 1000 blocks or something\u2014 would work fine.\n>\n>This doesn't have to come in the first cut, however\u2014 and it needs new\n>addr messages in any case."
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-05-16T15:47:07",
                "message_text_only": "On Thu, May 16, 2013 at 7:26 AM, Ricardo Filipe\n<ricardojdfilipe at gmail.com> wrote:\n> We would only end up with few copies of the historic data if users\n> could choose what parts of the blockchain to store. Simply store\n> chunks randomly, according to users available space, and give priority\n> to the \"N most recent\" chunks to have more replicas in the network.\n>\n> You don't need bittorrent specifically for a DHT, if publicity is a\n> problem. There are many DHT proposals and implementations, and i bet\n> one of them should be more suitable to the bitcoin network than\n> bittorrent's.\n\nThat's just about the worst thing you could do for bitcoin.  DoS one\npart of the DHT, you DoS the entire blockchain by breaking the chain.\n\n-- \nJeff Garzik\nexMULTI, Inc.\njgarzik at exmulti.com"
            },
            {
                "author": "Ricardo Filipe",
                "date": "2013-05-16T16:23:23",
                "message_text_only": "Of course.\nMy proposal was just for the pruned nodes.\nI.e. You would have a majority (maybe not even a majority required) of\nnodes storing the whole blockchain and pruned nodes would store\n\"random\" parts of the blockchain, according to the resources they\nhave, which would be organized as a DHT.\n\n2013/5/16 Jeff Garzik <jgarzik at exmulti.com>:\n> On Thu, May 16, 2013 at 7:26 AM, Ricardo Filipe\n> <ricardojdfilipe at gmail.com> wrote:\n>> We would only end up with few copies of the historic data if users\n>> could choose what parts of the blockchain to store. Simply store\n>> chunks randomly, according to users available space, and give priority\n>> to the \"N most recent\" chunks to have more replicas in the network.\n>>\n>> You don't need bittorrent specifically for a DHT, if publicity is a\n>> problem. There are many DHT proposals and implementations, and i bet\n>> one of them should be more suitable to the bitcoin network than\n>> bittorrent's.\n>\n> That's just about the worst thing you could do for bitcoin.  DoS one\n> part of the DHT, you DoS the entire blockchain by breaking the chain.\n>\n> --\n> Jeff Garzik\n> exMULTI, Inc.\n> jgarzik at exmulti.com"
            }
        ],
        "thread_summary": {
            "title": "Service bits for pruned nodes",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "John Dillon",
                "Mike Hearn",
                "Peter Todd",
                "Ricardo Filipe",
                "Pieter Wuille"
            ],
            "messages_count": 14,
            "total_messages_chars_count": 19702
        }
    },
    {
        "title": "[Bitcoin-development] Fwd: Service bits for pruned nodes",
        "thread_messages": [
            {
                "author": "Andy Parkins",
                "date": "2013-05-01T14:05:03",
                "message_text_only": "On Tuesday 30 April 2013 21:11:47 Jeff Garzik wrote:\n\n> Hardly.  The storage format is bitcoin protocol wire format, plus a\n> tiny header.  It is supported in multiple applications already, and is\n> the most efficient storage format for bitcoin protocol blocks.\n\n\"Most efficient\" for what purpose?  There is more that one might do than just \nduplicate bitcoind exactly.  I can well imagine storing bitcoin blocks parsed \nand separated out into database fields.\n\n> > Wouldn't it be better to add support for more bitcoin-protocol-oriented\n> > HTTP requests?  Then any client can supply the same interface, rather\n> > than being forced to create blkNNNN.dat on the fly?\n> \n> You don't have to create anything on the fly, if you store blocks in\n> their native P2P wire protocol format.\n\nIf.  What if I'm writing a client and don't want to store them the way \nbitcoind has?\n\n> This is a whole new client interface.  It's fun to dream this up, but\n> it is far outside the scope of an efficient HTTP protocol that\n> downloads blocks.\n\nExcept the alternative is no schema at all -- essentially it's just give \naccess to a file on disk.  Well, that hardly needs discussion at all, and it \nhardly needs the involvement of bitcoind, apache could do it right now.\n\n> Your proposal is closer to a full P2P rewrite over HTTP (or a proxy\n> thereof).\n\nI don't think it's a \"rewrite\".  The wire protocol is only a small part of \nwhat bitcoind does.  Adding another thread listening for HTTP requests at the \nsame time as on 8333 for stadnard format.\n\nAnyway -- I've obviously misunderstood what the idea behind a HTTP protocol \nwas, and it's not like I was volunteering to do any of the work ;-)\n\n\n\nAndy\n\n-- \nDr Andy Parkins\nandyparkins at gmail.com"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-05-01T14:26:57",
                "message_text_only": "On Wed, May 1, 2013 at 10:05 AM, Andy Parkins <andyparkins at gmail.com> wrote:\n> On Tuesday 30 April 2013 21:11:47 Jeff Garzik wrote:\n>\n>> Hardly.  The storage format is bitcoin protocol wire format, plus a\n>> tiny header.  It is supported in multiple applications already, and is\n>> the most efficient storage format for bitcoin protocol blocks.\n>\n> \"Most efficient\" for what purpose?  There is more that one might do than just\n> duplicate bitcoind exactly.  I can well imagine storing bitcoin blocks parsed\n> and separated out into database fields.\n[...]\n>> You don't have to create anything on the fly, if you store blocks in\n>> their native P2P wire protocol format.\n>\n> If.  What if I'm writing a client and don't want to store them the way\n> bitcoind has?\n\nThat posits -expanding- blocks from their native form into a larger\nform, and then squashing them back down again upon request.  A lot of\nextra work from the point of view of clients downloading blocks\nthemselves.\n\nBut sure, if you want to do it, yes, it is possible to design an\ninterface like that.\n\n\n>> This is a whole new client interface.  It's fun to dream this up, but\n>> it is far outside the scope of an efficient HTTP protocol that\n>> downloads blocks.\n>\n> Except the alternative is no schema at all -- essentially it's just give\n> access to a file on disk.  Well, that hardly needs discussion at all, and it\n> hardly needs the involvement of bitcoind, apache could do it right now.\n\nCorrect, Apache today could easily serve an HTTP-based layout of\nblkNNNN.dat, plus a tiny JSON metadata file.\n\nThat's not \"no schema\", just a different layout.\n\n>> Your proposal is closer to a full P2P rewrite over HTTP (or a proxy\n>> thereof).\n>\n> I don't think it's a \"rewrite\".  The wire protocol is only a small part of\n> what bitcoind does.  Adding another thread listening for HTTP requests at the\n> same time as on 8333 for stadnard format.\n>\n> Anyway -- I've obviously misunderstood what the idea behind a HTTP protocol\n> was, and it's not like I was volunteering to do any of the work ;-)\n\nIn the context of this thread: distributing and downloading blocks.\nAll current users require the native binary block format.\n\nA generalized HTTP REST query protocol would be a nice addition... it\nis just off-topic for this thread.  On IRC yesterday, we discussed an\nHTTP query interface like you suggested.  It was agreed that it was a\nnice interface, and might be a nice addition to bitcoind.\n\nThat is a separate topic for a separate email thread, though.\n\nAs an example, see the pull request I wrote for an HTTP REST interface\nthat downloads an encrypted wallet backup:\n     https://github.com/bitcoin/bitcoin/pull/1982\n\n-- \nJeff Garzik\nexMULTI, Inc.\njgarzik at exmulti.com"
            },
            {
                "author": "Andy Parkins",
                "date": "2013-05-01T14:34:27",
                "message_text_only": "On Wednesday 01 May 2013 15:26:57 Jeff Garzik wrote:\n\n> A generalized HTTP REST query protocol would be a nice addition... it\n> is just off-topic for this thread.  On IRC yesterday, we discussed an\n> HTTP query interface like you suggested.  It was agreed that it was a\n> nice interface, and might be a nice addition to bitcoind.\n> \n> That is a separate topic for a separate email thread, though.\n> \n> As an example, see the pull request I wrote for an HTTP REST interface\n> that downloads an encrypted wallet backup:\n>      https://github.com/bitcoin/bitcoin/pull/1982\n\nFair enough.\n\nI'm usually behind the state-of-the-art when I suggest things here :-)  I \nshould just trust you guys have already planned everything I might think of.\n\n\nAndy\n\n-- \nDr Andy Parkins\nandyparkins at gmail.com"
            }
        ],
        "thread_summary": {
            "title": "Fwd: Service bits for pruned nodes",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Andy Parkins"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 5255
        }
    },
    {
        "title": "[Bitcoin-development] BIP21 bitcoin URIs and HTML5",
        "thread_messages": [
            {
                "author": "Mike Hearn",
                "date": "2013-05-02T12:53:38",
                "message_text_only": "Chrome has whitelisted bitcoin: URIs for web apps, and Firefox it turns out\ndoesn't use whitelisting at all, so it already works there.\n\nhttps://chromiumcodereview.appspot.com/14531004\n\nI'm hoping this means web wallet developers won't be put off from\nsupporting the payment protocol (that risk is the reason I started this\nwork).\n\nThe next step is to file bugs against WebKit (for Safari/iOS/misc other\nplatforms), and IE, though I don't know if Microsoft uses open bug trackers\nmuch.\n\n\n\nOn Wed, Apr 24, 2013 at 6:37 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n\n> On Wed, Apr 24, 2013 at 7:51 AM, Gavin Andresen <gavinandresen at gmail.com>\n> wrote:\n> >> Ian pointed out some errors in the BIP21 spec. What's the process for\n> >> amending the BIP? Do we need to create a new one and mark the old one as\n> >> replaced, or can we just fix it in place given the relatively exotic\n> nature\n> >> of most of the issues?\n> > Those all sound like bugs in the BIP; I think they should just be fixed,\n> I\n> > don't think we need a new BIP.\n>\n> Yup.  Corrections are fine, esp ones which are not gratuitously\n> incompatible.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130502/1c948143/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP21 bitcoin URIs and HTML5",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Mike Hearn"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1306
        }
    },
    {
        "title": "[Bitcoin-development] Requirement for relay field in version packet (protocol version >= 70001)",
        "thread_messages": [
            {
                "author": "Addy Yeow",
                "date": "2013-05-06T07:56:37",
                "message_text_only": ">From https://en.bitcoin.it/wiki/Protocol_specification#version, is the\nrelay field (bool/1 byte) required in all version packets coming from\nclient with protocol version >= 70001?"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-05-06T08:20:01",
                "message_text_only": "It's expected to be there, yes.\n\n\nOn Mon, May 6, 2013 at 9:56 AM, Addy Yeow <ayeowch at gmail.com> wrote:\n\n> >From https://en.bitcoin.it/wiki/Protocol_specification#version, is the\n> relay field (bool/1 byte) required in all version packets coming from\n> client with protocol version >= 70001?\n>\n>\n> ------------------------------------------------------------------------------\n> Introducing AppDynamics Lite, a free troubleshooting tool for Java/.NET\n> Get 100% visibility into your production application - at no cost.\n> Code-level diagnostics for performance bottlenecks with <2% overhead\n> Download for free and get started troubleshooting in minutes.\n> http://p.sf.net/sfu/appdyn_d2d_ap1\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130506/23240452/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Requirement for relay field in version packet (protocol version >= 70001)",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Addy Yeow",
                "Mike Hearn"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1257
        }
    },
    {
        "title": "[Bitcoin-development] Discovery/addr packets (was: Service bits for pruned nodes)",
        "thread_messages": [
            {
                "author": "Mike Hearn",
                "date": "2013-05-06T14:58:56",
                "message_text_only": "Subject change to reflect that this is off-topic for the old thread.\n\nEventually, I think it makes sense to move to a system where you get seeds\n> from\n> a DNS (or other mechanism), connect to one or a few of the results, do a\n> getaddr,\n> fill your peer IP database with it, and disconnect from the DNS seeded\n> peer.\n\n\nThis obviously makes no difference from a security perspective. If a DNS\nseed is compromised it can feed you nodes that just connect you back to the\nsybil. If you seed from DNS then that's your root of trust.\n\nThe problem with moving away from DNS seeding for bitcoinj clients at least\nis that SPV clients are very sensitive to startup time. It isn't OK to\nspend two minutes trying to connect to lots of long-dead IP addresses if\nyou're wanting to pay your bill in a restaurant. That means either you have\nto spin up a lot of TCP connections in parallel, which I know from bitter\nexperience can cause problems with some crappy wifi routers (they think\nit's a synflood), or you get a known fresh source of IPs like a DNS seed\nresponse and then later on bring up connections to the P2P network from\nthat.\n\nImplementing the latter is complicated - you have to partition your nodes\nso the seed peers are separated from the peers you found via addr\nbroadcasts and seeded peers can't pollute your addr-found peers unless it's\nyour first run.\n\nI've actually not experimented with this for a while. I'm hoping that by\nthe time this gets to the top of my todo list, network nodes will be stable\nenough that actually you can always obtain at least one or two connections\nif you try (say) 30 at once. But I have no idea if we're at that stage yet.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130506/6bb8ec08/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2013-05-06T16:12:16",
                "message_text_only": "On Mon, May 06, 2013 at 04:58:56PM +0200, Mike Hearn wrote:\n\nMore generally, I think this shows clearly how SPV nodes have weaker\nsecurity than constantly operating full nodes, which we knew already, so\nwhy not build a better SPV-specific system instead?\n\nI've noticed on my Android phone how it often takes quite awhile to find\na peer that will actually accept an incoming connection, which isn't\nsurprising really: why should a regular node care about responding to\nSPV nodes quickly?\n\nFor fast startup you would be better served with dedicated nodes that\nare backed by fast hardware and high bandwidth internet connections.\nYou can discourage non-SPV use by refusing to relay full blocks.\n\nYou can have trusted individuals vouch for these special servers with\nSSL certificates so you run less of a risk of connecting to a malicious\none trying to limit what information you see. For the initial\nimplementation, maybe just make a quick SSL accessible service with HTTP\nGET so you don't have to integrate SSL into the network protocol and\nhave a couple of these HTTP GETable servers running. (IE, the trust is\nactually that the SPV seed is honest)\n\nSecurity will be no worse than before - if any one server/seed is honest\nyou're ok - and hopefully better due to the accountability. Obviously\nyou can use the existing bootstrap method in parallel at the same time.\n\n\nWhat's good about partitioning between SPV and full node bootstrapping,\nis the regular DNS seeds can optimize the other way: accept that some\nnodes may turn out to be evil, and limit the damage by returning peers\nfrom the widest pool possible even if some of those peers may be a bit\nslow and unreliable. An attacker can't dominate the results by running a\nsmall number of fast reliable nodes because the results returned comes\nfrom a huge pool, so they are stuck with getting access to lots of IP\naddresses, and maybe in the future we'll have even better methods of\nresisting sybil attacks, and we will be able to implement those methods\neven if they mean initial bootstrapping is slower.\n\n> Subject change to reflect that this is off-topic for the old thread.\n> \n> Eventually, I think it makes sense to move to a system where you get seeds\n> > from\n> > a DNS (or other mechanism), connect to one or a few of the results, do a\n> > getaddr,\n> > fill your peer IP database with it, and disconnect from the DNS seeded\n> > peer.\n> \n> \n> This obviously makes no difference from a security perspective. If a DNS\n> seed is compromised it can feed you nodes that just connect you back to the\n> sybil. If you seed from DNS then that's your root of trust.\n> \n> The problem with moving away from DNS seeding for bitcoinj clients at least\n> is that SPV clients are very sensitive to startup time. It isn't OK to\n> spend two minutes trying to connect to lots of long-dead IP addresses if\n> you're wanting to pay your bill in a restaurant. That means either you have\n> to spin up a lot of TCP connections in parallel, which I know from bitter\n> experience can cause problems with some crappy wifi routers (they think\n> it's a synflood), or you get a known fresh source of IPs like a DNS seed\n> response and then later on bring up connections to the P2P network from\n> that.\n> \n> Implementing the latter is complicated - you have to partition your nodes\n> so the seed peers are separated from the peers you found via addr\n> broadcasts and seeded peers can't pollute your addr-found peers unless it's\n> your first run.\n> \n> I've actually not experimented with this for a while. I'm hoping that by\n> the time this gets to the top of my todo list, network nodes will be stable\n> enough that actually you can always obtain at least one or two connections\n> if you try (say) 30 at once. But I have no idea if we're at that stage yet.\n\n> ------------------------------------------------------------------------------\n> Introducing AppDynamics Lite, a free troubleshooting tool for Java/.NET\n> Get 100% visibility into your production application - at no cost.\n> Code-level diagnostics for performance bottlenecks with <2% overhead\n> Download for free and get started troubleshooting in minutes.\n> http://p.sf.net/sfu/appdyn_d2d_ap1\n\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000002a871dc011fe28fd8fbffe577c02b91d2de09aeca8216644ef\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130506/390a45c9/attachment.sig>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-05-06T16:20:12",
                "message_text_only": "On Mon, May 6, 2013 at 12:12 PM, Peter Todd <pete at petertodd.org> wrote:\n> I've noticed on my Android phone how it often takes quite awhile to find\n> a peer that will actually accept an incoming connection, which isn't\n> surprising really: why should a regular node care about responding to\n> SPV nodes quickly?\n>\n> For fast startup you would be better served with dedicated nodes that\n> are backed by fast hardware and high bandwidth internet connections.\n> You can discourage non-SPV use by refusing to relay full blocks.\n>\n> You can have trusted individuals vouch for these special servers with\n> SSL certificates so you run less of a risk of connecting to a malicious\n> one trying to limit what information you see. For the initial\n> implementation, maybe just make a quick SSL accessible service with HTTP\n> GET so you don't have to integrate SSL into the network protocol and\n> have a couple of these HTTP GETable servers running. (IE, the trust is\n> actually that the SPV seed is honest)\n>\n> Security will be no worse than before - if any one server/seed is honest\n> you're ok - and hopefully better due to the accountability. Obviously\n\nIndeed, the DNS seeds are just servers run by trusted individuals anyway.\n\nIn either case, bitcoinj definitely wants fixing for its over-reliance\non DNS seeds.  This has been noted as a problem for a while.\n\n-- \nJeff Garzik\nexMULTI, Inc.\njgarzik at exmulti.com"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-05-06T16:34:47",
                "message_text_only": "> > I've noticed on my Android phone how it often takes quite awhile to find\n> > a peer that will actually accept an incoming connection, which isn't\n> > surprising really: why should a regular node care about responding to\n> > SPV nodes quickly?\n\nI haven't seen that - remote nodes don't have any special code that\nknows what kind of client is connecting, so if you're seeing delays I\nsuspect the issue is elsewhere. For example a seed that is serving\npeers which are overloaded, or the general delays inherent to bringing\nup a 3G data link from idle (this can take many seconds all by\nitself).\n\nI took out Jeffs seed a few weeks ago in git master because it was\noften serving nodes that were full, so that should speed things up a\nbit. The other seeds all run dynamic crawlers.\n\nThere are lots other ways to optimise performance beyond having fresh\nseeds, for example, the Android app can (and probably will in future)\nsupport putting Bluetooth MAC addresses in the URLs it serves via\nQRcode/NFC. We prototyped it before but didn't finish. That means that\nthe sending side can provide the receiving side with a transaction via\na local Bluetooth socket, which eliminates the need to wait for P2P\nbringup on the send side. In a typical merchant scenario the receive\nside is more likely to have WiFi access and is more likely to be\ntalking to the network frequently, so its list of IPs gathered from\naddr packets would be fresher, and it can do P2P bringup whilst the\nuser is confirming/signing/uploading on the sending side. Overlapping\nthe two buys precious seconds."
            },
            {
                "author": "Peter Todd",
                "date": "2013-05-06T16:37:32",
                "message_text_only": "On Mon, May 06, 2013 at 12:20:12PM -0400, Jeff Garzik wrote:\n> > Security will be no worse than before - if any one server/seed is honest\n> > you're ok - and hopefully better due to the accountability. Obviously\n> \n> Indeed, the DNS seeds are just servers run by trusted individuals anyway.\n\nYup, and lets be really clear here: what I'm saying about existing DNS\nseeds selecting peers from a wider pool isn't to fundementally reduce\nthe trust in those seeds, it's to reduce the amount of effort the people\n*running* the seeds need to expend to return safe results.\n\n> In either case, bitcoinj definitely wants fixing for its over-reliance\n> on DNS seeds.  This has been noted as a problem for a while.\n\nAnyway, DNS returns unsigned data usually - DNSSEC is not widely\nimplemented - so at least an alternative seed system with SSL certs\ncould provide a way of getting results from the seed to you in the first\nplace with a different set of vulnerabilities.  (I'm not going to say\nit's really more secure - your ISP can MITM your connections to those\nremote nodes anyway - but the types of attacks are at least different)\n\nSpeaking of, off-topic for this discussion, but in the future\nnode-to-node communicate should be encrypted and signed, and seeds\nshould have a mechanism to return the pubkey the node will use for\ncommunication. This would protect against your ISP MITM attacking your\ncommunications with every node. Of course, Tor hidden service nodes do\nthis already essentially.\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000001882c602178bd4dc6501ecd65db1e1380224be98c923043c07\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130506/9de37a2b/attachment.sig>"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-05-06T16:47:22",
                "message_text_only": "> Speaking of, off-topic for this discussion, but in the future\n> node-to-node communicate should be encrypted and signed\n\nYes, I'd like to do this. The threat isn't really ISPs which are\nmostly trustable (the worst they normally do outside of places like\nChina is dick about with ads), the big threat is people who use\nuntrusted WiFi without realising and end up thinking they received\nmoney when actually they were just connected to a hotspot running in\nthe attackers pocket. I'm rather expecting that kind of thing to\nhappen in future.\n\nI think we can converge on the best solution with several iterations:\n\nIteration 1) Make it clear in the UI that if the phone is connected to\nWiFi, payments from untrusted people should not be accepted. Currently\nthe Android app merely says the money won't be spendable for a few\nminutes. It needs to communicate the \"may not exist\" aspect more\nclearly. If you're connected via a cell tower, the existing wording is\nfine - it's very unlikely your telco is trying to scam you in a\nperson-to-person transaction, traffic is encrypted and 3G+ connections\nauthenticate the network so you can't be MITMd except by your telco.\nAssuming you have a good list of IPs, of course.\n\nIteration 2) Give nodes keys that appear in addr broadcasts and seed\ndata (whether it be via https or otherwise), and have each node keep a\nrunning hash of all messages sent on a connection so far. Add a new\nprotocol message that asks the node to sign the current accumulated\nhash. Not all messages really need to be signed, eg asking for\nsignatures of blocks is sort of pointless at high difficulty levels\nbecause the structures are self proving and a simple watchdog timer\nthat looks for unusually slow progress is probably enough. If the\nclient keeps the same accumulated hash then when you encounter\nsomething you care about the accuracy of, you can ask for a signature\nover all traffic so far.\n\nIteration 3) Do something about end to end encryption, just delegate\neverything to Tor, or find some other way to obfuscate the origin of a\ntransaction (a mini onion network for example).\n\nLast time I looked, Tor wasn't really usable in library form and\nconnecting to hidden services is really slow. So it'd be an issue to\njust re-use it out of the box, I think."
            },
            {
                "author": "Peter Todd",
                "date": "2013-05-06T17:19:43",
                "message_text_only": "On Mon, May 06, 2013 at 06:47:22PM +0200, Mike Hearn wrote:\n> Iteration 1) Make it clear in the UI that if the phone is connected to\n> WiFi, payments from untrusted people should not be accepted. Currently\n> the Android app merely says the money won't be spendable for a few\n> minutes. It needs to communicate the \"may not exist\" aspect more\n> clearly. If you're connected via a cell tower, the existing wording is\n> fine - it's very unlikely your telco is trying to scam you in a\n> person-to-person transaction, traffic is encrypted and 3G+ connections\n> authenticate the network so you can't be MITMd except by your telco.\n> Assuming you have a good list of IPs, of course.\n\nYou mean scam you with a zero-conf transaction that hasn't actually been\nbroadcast?\n\nYou know how I feel about zero-conf.\n\n> Iteration 2) Give nodes keys that appear in addr broadcasts and seed\n> data (whether it be via https or otherwise), and have each node keep a\n> running hash of all messages sent on a connection so far. Add a new\n> protocol message that asks the node to sign the current accumulated\n> hash. Not all messages really need to be signed, eg asking for\n> signatures of blocks is sort of pointless at high difficulty levels\n> because the structures are self proving and a simple watchdog timer\n> that looks for unusually slow progress is probably enough. If the\n> client keeps the same accumulated hash then when you encounter\n> something you care about the accuracy of, you can ask for a signature\n> over all traffic so far.\n\nWe already depend on OpenSSL, why not just use standard SSL?\n\nDefine a per-node compressed pubkey to pass around, and then do whatever\nis easiest to get the actual SSL up and running. If we have to use that\npubkey to in-turn sign for a secondary RSA key or whatever due to\ncompatibility, no big deal.\n\nDefine a new service bit SSL and if you connect to a SSL supporting node\nswitch to SSL within the same TCP connection.\n\n> Iteration 3) Do something about end to end encryption, just delegate\n> everything to Tor, or find some other way to obfuscate the origin of a\n> transaction (a mini onion network for example).\n\nObfusication probably isn't the hard part, it's SPV bloom filter privacy\nthat is the tough one, but probably a problem better handled by Tor.\n\n> Last time I looked, Tor wasn't really usable in library form and\n> connecting to hidden services is really slow. So it'd be an issue to\n> just re-use it out of the box, I think.\n\nFor phone stuff you should work with The Guardian Project - they've\nimplemented Tor on Android among other things and want to find easier\nways for apps to use it.\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000014671272e3a4dd966bb56d4a9a27751b5cd4dc75dc931660cb5\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130506/5e448ac5/attachment.sig>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-05-06T17:25:32",
                "message_text_only": "On Mon, May 6, 2013 at 1:19 PM, Peter Todd <pete at petertodd.org> wrote:\n> For phone stuff you should work with The Guardian Project - they've\n> implemented Tor on Android among other things and want to find easier\n> ways for apps to use it.\n\nYou know my feelings about Java ;p but for hidden services, there\nreally does need to be a lib for server apps.\n\nA proxy server approach is much more fragile, in certain scenarios,\nthan directly implementing an internal Tor hidden service node, and\nhandling the TLS connections within your own network framework.\n\n-- \nJeff Garzik\nexMULTI, Inc.\njgarzik at exmulti.com"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2013-05-06T17:42:19",
                "message_text_only": "On Mon, May 6, 2013 at 10:19 AM, Peter Todd <pete at petertodd.org> wrote:\n>> running hash of all messages sent on a connection so far. Add a new\n>> protocol message that asks the node to sign the current accumulated\n>> hash.\n> We already depend on OpenSSL, why not just use standard SSL?\n\nSSL doesn't actually provide non-repudiation. We actually want\nnon-repudiation. I want to be able to prove to others that some node\ndeceived me.\n\n(there are a number of other arguments I could make against SSL, but\nthat one is probably sufficient\u2014 or rather, it's an argument that we\nshould have some way of cheaply getting non-reputable signatures\nregardless of the transport)\n\n>> Last time I looked, Tor wasn't really usable in library form and\n>> connecting to hidden services is really slow. So it'd be an issue to\n>> just re-use it out of the box, I think.\n> For phone stuff you should work with The Guardian Project - they've\n> implemented Tor on Android among other things and want to find easier\n> ways for apps to use it.\n\nAlso look into torchat, which bundles a special tor build and runs a\nhidden service.\n\nBecause of services like Blockchain.info attacking the casual privacy\nusers not using their webwallet service I've been thinking that even\nfor clients that don't normally use tor their own transaction\nannouncements should probably be made by bringing up a connection over\ntor and announcing. But thats another matter...\n\nI've switched to running on tor exclusively for my personal node (yay\ndogfooding) and I've found it to connect and sync up very fast most of\nthe time. The biggest slowdown appears to be the our timeout on the\ntor connections is very high and so if it gets unlucky on the first\ncouple attempts it can be minutes before it gets a connection. We're\nshort on onion peers and I sometimes get inbound connections before I\nmanage to get an outbound."
            },
            {
                "author": "Peter Todd",
                "date": "2013-05-06T17:53:31",
                "message_text_only": "On Mon, May 06, 2013 at 10:42:19AM -0700, Gregory Maxwell wrote:\n> On Mon, May 6, 2013 at 10:19 AM, Peter Todd <pete at petertodd.org> wrote:\n> >> running hash of all messages sent on a connection so far. Add a new\n> >> protocol message that asks the node to sign the current accumulated\n> >> hash.\n> > We already depend on OpenSSL, why not just use standard SSL?\n> \n> SSL doesn't actually provide non-repudiation. We actually want\n> non-repudiation. I want to be able to prove to others that some node\n> deceived me.\n\nWe don't have non-repudiation now, why make that a requirement for the\nfirst version? Adding non-repudiation is something that has to happen at\nthe Bitcoin protocol level,(1) so it's orthogonal to using SSL to make sure\nyou're connection isn't being tampered with and is encrypted.\n\n1) Non-repudiation is only useful with fraud proofs, and they will have\nto be thought out for everything the node might claim.\n\n> (there are a number of other arguments I could make against SSL, but\n> that one is probably sufficient\u2014 or rather, it's an argument that we\n> should have some way of cheaply getting non-reputable signatures\n> regardless of the transport)\n\nExactly. Implement an SSL-protected transport, and leave non-repudiation\nand broader issues of node identity as a later, long-term project. Many\nclient won't even want to support all that complexity, but they'll still\nwant to cheaply get the advantages SSL has with regard to MITM\nresistance and privacy with little effort.\n\nAnyway, the concept of a per-node identity keypair is the first step\ntowards non-repudiation, and implementing SSL transport.\n\n> couple attempts it can be minutes before it gets a connection. We're\n> short on onion peers and I sometimes get inbound connections before I\n\nI run a fast node on EC2 that only accepts inbound connections over Tor\nand I regularly have about ~50 inbound peers.\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000042d8b5bc3ca04847f711b82b66f08b7360a565ebd0b131621c\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130506/6c9965dc/attachment.sig>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2013-05-06T18:01:22",
                "message_text_only": "On Mon, May 6, 2013 at 10:53 AM, Peter Todd <pete at petertodd.org> wrote:\n> We don't have non-repudiation now, why make that a requirement for the\n> first version? Adding non-repudiation is something that has to happen at\n> the Bitcoin protocol level,(1) so it's orthogonal to using SSL to make sure\n> you're connection isn't being tampered with and is encrypted.\n\nBecause if you just want bitcoin p2p over SSL... just start up stunnel\non another port. Done. You've still solved nothing about the problem\nof discovery issue.\n\n> 1) Non-repudiation is only useful with fraud proofs, and they will have\n> to be thought out for everything the node might claim.\n\nThat isn't so. If a node is reliably rogue I can go manually gather\nevidence and people can manually take action against it.  Consider the\nDNSseeds, right now fraud proofs really wouldn't matter\u2014 the limited\namount of trust put in those things is based not on \"oh no, nodes will\nignore you in the future if you're bad\", it's based on the ability of\nmisconduct to sully the operator's reputation.\n\nBut without non-repudiation the ability to tie reputation to good\nbehavior is fairly limited especially if they perform targeted\nattacks. \"Wasn't me\"\n\nInstead\u2014 I'd argue that non-repudiation is always useful when there is\ntrust. It's things like fidelity bonds\u2014 a trust generator that depend\non automatic enforcement\u2014 that are only useful with fraud proofs.\n\n> Anyway, the concept of a per-node identity keypair is the first step\n> towards non-repudiation, and implementing SSL transport.\n\nYea, indeed, per-node keys are useful for a bunch of things. Care is\nneeded to avoid problems like deanonymizing use over tor with them."
            },
            {
                "author": "Peter Todd",
                "date": "2013-05-06T18:19:59",
                "message_text_only": "On Mon, May 06, 2013 at 11:01:22AM -0700, Gregory Maxwell wrote:\n> On Mon, May 6, 2013 at 10:53 AM, Peter Todd <pete at petertodd.org> wrote:\n> > We don't have non-repudiation now, why make that a requirement for the\n> > first version? Adding non-repudiation is something that has to happen at\n> > the Bitcoin protocol level,(1) so it's orthogonal to using SSL to make sure\n> > you're connection isn't being tampered with and is encrypted.\n> \n> Because if you just want bitcoin p2p over SSL... just start up stunnel\n> on another port. Done. You've still solved nothing about the problem\n> of discovery issue.\n\nstunnel only works if both sides support it.\n\nre: discovery, the whole reason I brought up SSL was the idea that a\nseed whome you have a secure connection to, like HTTPS or SSL, can\ninclude the peer pubkey along with the peer's IP address, allowing you\nto be sure you've connected to the peer the seed is giving you rather\nthan some other imposter.\n\nEqually it'll let you be sure you've connected to the correct peer the\nsecond time.\n\nFor applications where you *don't* need non-repudiation SSL is already\nimplemented and solves the secure peer communication issue, including\nencryption, in an efficient way without requiring a lot of code\ncomplexity to implement.\n\nSSL could be implemented as a Google Summar of Code project by an\naverage developer, and importantly re-implemented by all the alt-clients\nout there with relatively little work.\n\nIt may even be the case that some usage scenarios do find the CA system\nuseful. I might want to do -addnode ssl://petertodd.org on my Android\nwallet to be sure I've connected to my Bitcoin node rather than some\nMITM ISP imposter. I already have a SSL cert from a CA for petertodd.org\nthat I can use and my Android phone already has a list of CA's I can put\na reasonable amount of trust in.\n\n> > 1) Non-repudiation is only useful with fraud proofs, and they will have\n> > to be thought out for everything the node might claim.\n> \n> That isn't so. If a node is reliably rogue I can go manually gather\n> evidence and people can manually take action against it.  Consider the\n> DNSseeds, right now fraud proofs really wouldn't matter\u2014 the limited\n> amount of trust put in those things is based not on \"oh no, nodes will\n> ignore you in the future if you're bad\", it's based on the ability of\n> misconduct to sully the operator's reputation.\n\nSure, but how will non-repudiation be implemented? By having the node\nsign the messages they send with their pubkey, and as Mike suggests\nlikely doing so in some sort of chained hash or preferably merkle\nmountain range to allow for constructing proofs over multiple messages.\n\nThat has nothing to do with encrypting the transport, and will always be\na lot slower than SSL's symmetric cipher for when you don't need\nnon-repudiation but do want to be sure you've connected to the right\nnode.\n\n> > Anyway, the concept of a per-node identity keypair is the first step\n> > towards non-repudiation, and implementing SSL transport.\n> \n> Yea, indeed, per-node keys are useful for a bunch of things. Care is\n> needed to avoid problems like deanonymizing use over tor with them.\n\nPer-node keys really need to be per listening address by default. In\nfact, I'd argue for creating new keys on startup by default.\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000015ef6fc2fc45adc1de0c344e99a59453bb09ac470a1d02b787d\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130506/f3027df6/attachment.sig>"
            },
            {
                "author": "Adam Back",
                "date": "2013-05-06T18:32:22",
                "message_text_only": "btw with nodes for transport security you might use self-certifying keys. \nReferring to Zooko's triangle, then the key is the node identity.  Similar\nto a bitcion address.  So then just another ECDSA key and use emphemeral\nECDH for transport authenticated with the nodes key.\n\nMaybe there can be some value to reputation to a node - eg it can charge a\nhigher micropayment for its p2p network services, a node with a good\nreptuation could charge a higher micropayment for relaying (though bitcoin\nitself probably doesnt like micropayments as bloating the transaction log).\n\nAnother ZKS era idea I had was to have a gossip protocol for users to find\nout what other people think about the trustworthiness and reliability of\nnodes.  If that info is distributed via gossip over multiple channels and\nnetwork connections over time, and kept in something like a gnutella host\ncache (just a cache of random info with some eg random replacement policy)\nit becomes very hard for a dishonest node to censor evidence of its low\nreputation.\n\nIt is best as Gregory said to be able to directly prove, and punish by\nblock-chain validation, because that is more smart-contract like.  Bisbehave\nand nodes wont connect to you or lose somehow.\n\nBut what exactly could you prove about a node?  You dont really know if a\nnode is an originator for a double spend, it could be relay.  And for\nprivacy and security you cant expect the node to use its coin address\nprivate key.\n\nHmm: maybe one could use a Brands private credential with offline double\nspend detection, with the reputation but not coin address of the node\ndisclosed, and the nodes coin address embedded in the proof.  Each node\ncould be is own CA, providing a ZKP.  If the node ever double spends a coin,\nit loses its reputation as the coin address is revealed.\n\nbtw another old idea was to require proof of the existance of the private\nkey of a high value coin in the double-spend revealed information.  Then\nbasically to get a higher good-behaviour bond, the node ties up more coins,\nand if a node cheats, the first person to discover this collects the\nforfeited good behaviour bond.\n\nAdam\n\nps I have an opensource openSSL based Brands (& Chaum) credential library at\nhttp://www.cypherspace.org/credlb/ I didnt actually implement the ECDL\nversion, just the DL version, but that is not so hard, and its on my todo\nlist.  (There is also a strong RSA assumption version, also not\nimplemented).\n\nOn Mon, May 06, 2013 at 11:01:22AM -0700, Gregory Maxwell wrote:\n>> 1) Non-repudiation is only useful with fraud proofs, and they will have\n>> to be thought out for everything the node might claim.\n>\n>That isn't so. If a node is reliably rogue I can go manually gather\n>evidence and people can manually take action against it.  Consider the\n>DNSseeds, right now fraud proofs really wouldn't matter\u2014 the limited\n>amount of trust put in those things is based not on \"oh no, nodes will\n>ignore you in the future if you're bad\", it's based on the ability of\n>misconduct to sully the operator's reputation.\n>\n>But without non-repudiation the ability to tie reputation to good\n>behavior is fairly limited especially if they perform targeted\n>attacks. \"Wasn't me\"\n>\n>Instead\u2014 I'd argue that non-repudiation is always useful when there is\n>trust. It's things like fidelity bonds\u2014 a trust generator that depend\n>on automatic enforcement\u2014 that are only useful with fraud proofs.\n>\n>> Anyway, the concept of a per-node identity keypair is the first step\n>> towards non-repudiation, and implementing SSL transport.\n>\n>Yea, indeed, per-node keys are useful for a bunch of things. Care is\n>needed to avoid problems like deanonymizing use over tor with them.\n>\n>------------------------------------------------------------------------------\n>Learn Graph Databases - Download FREE O'Reilly Book\n>\"Graph Databases\" is the definitive new guide to graph databases and\n>their applications. This 200-page book is written by three acclaimed\n>leaders in the field. The early access version is available now.\n>Download your free book today! http://p.sf.net/sfu/neotech_d2d_may\n>_______________________________________________\n>Bitcoin-development mailing list\n>Bitcoin-development at lists.sourceforge.net\n>https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Peter Todd",
                "date": "2013-05-06T19:08:57",
                "message_text_only": "On Mon, May 06, 2013 at 08:32:22PM +0200, Adam Back wrote:\n> But what exactly could you prove about a node?  You dont really know if a\n> node is an originator for a double spend, it could be relay.  And for\n> privacy and security you cant expect the node to use its coin address\n> private key.\n\nre: double-spends - punishing relay nodes and miners for them is a very\nbad idea. Ultimately it is the blockchain by which Bitcoin comes to\nconsensus about what transactions belong in the blockchain - to punish\ndouble-spends implies a second consensus mechanism. Anyway it's\nunnecessary: you can hold the actual spender accountable for\ndouble-spends and punish them directly rather than adding a lot of\ncomplexity and dangerous assumptions about propagation to the Bitcoin\ncore network.\n\n\nSome useful things you can hold relay nodes accountable for without a\nlot of complexity:\n\n1) Having a reasonably correct view of the best block. Make the node\nsign a statement including a block hash sequence (the last 3-6 blocks)\nand what it believes the current time is.\n\n2) Accurate knowledge of the blockchain. Sign a statement claiming that\nwhat block hash is for a given chain height. Note that due to reg-orgs\nthis is actually a different statement than #1 and nodes should be\ncareful what they are claiming.\n\n3) Accurate knowledge of the UTXO set. Sign a statement claiming that\na given txid:vout for the current best block hash is in or not in the\nUTXO set.\n\n4) Accurate bloom filtering; same idea as #3\n\n5) Make the node identity expensive to obtain. For instance, construct\nPoW's including the node pubkey somehow, or purchase fidelity bonds for\nthe node's identity. Makes sybil attacks more difficult, among other\nthings.\n\n5) Provide useful propagation/mining services. Sign a txid and\ntimestamp/blockhash-sequence, and hold the node accountable for how long\nit takes the txid to make it into the blockchain. Useful especially for\nminers offering the service of mining your transaction.\n\n\n> Hmm: maybe one could use a Brands private credential with offline double\n> spend detection, with the reputation but not coin address of the node\n> disclosed, and the nodes coin address embedded in the proof.  Each node\n> could be is own CA, providing a ZKP.  If the node ever double spends a coin,\n> it loses its reputation as the coin address is revealed.\n\nBe careful not to mix up the concept of a relay node with someone\nposessing Bitcoins. Node's don't spend coins, people/wallets do.\n\n> ps I have an opensource openSSL based Brands (& Chaum) credential library at\n> http://www.cypherspace.org/credlb/ I didnt actually implement the ECDL\n> version, just the DL version, but that is not so hard, and its on my todo\n> list.  (There is also a strong RSA assumption version, also not\n> implemented).\n\nThat stuff is cool, but we should focus first on simple efforts, like\nSSL transport, that do not require complex cryptography to obtain an\nimprovement in security.\n\nOf course, not to say long-term research is bad, but that's just not\ngoing into the Bitcoin reference client in the near future.\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000124d42390b0db4c125f6be87835c49dc88f1bdeba527b77abc2\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130506/577b4af6/attachment.sig>"
            },
            {
                "author": "Adam Back",
                "date": "2013-05-06T19:50:03",
                "message_text_only": "On Mon, May 06, 2013 at 03:08:57PM -0400, Peter Todd wrote:\n>> Hmm: maybe one could use a Brands private credential with offline double\n>> spend detection, with the reputation but not coin address of the node\n>> disclosed, and the nodes coin address embedded in the proof.  Each node\n>> could be is own CA, providing a ZKP.  If the node ever double spends a coin,\n>> it loses its reputation as the coin address is revealed.\n>\n>Be careful not to mix up the concept of a relay node with someone\n>posessing Bitcoins. Node's don't spend coins, people/wallets do.\n\nMy comment was to say that a good behaviour bond for a relay node could be\nput on an address that is defined as unspendable until such time as an\nauditor can prove the node engaged in the undesired behaviour, at which\npoint the audit receives the payment as part of his proof.  Or until the\nnode ceases to operate.  Its a smart contract.\n\nHowever I added to that, that it is still possible to do that while\npreseving privacy, to point out that it is technically possible, for people\nto be aware of in their mental toolbox, if it helps solve an otherwise\ntricky problem.\n\nSo that would be a privacy preserving smart contract, the parties are\nunknown, and unknowable (with unconditional security even), but still the\nsmart contract executes.  In some sense a privacy preserving smart-contract\nis closer to the real point of Szabo's smart-contract idea because you cant\ntry to renege on the contract in a conventional court - because you cant\nidentify your counter-party.  Bitcoins privacy feature is fairly weak so\nthat is probably often not true.\n\nOf course you'd probably need zerocoin to stand much chance of proving an\naddress private key of an unlinked coin was in the double-spend disclosed\nattribute in the first place, and as we know zerocoin is not that efficient.\n\n> Make the node identity expensive to obtain. For instance, construct PoW's\n> including the node pubkey somehow,\n\nthat could be easily done with the work of creating a vanity address.  eg\naddress containing many leading 0s.\n\nAdam"
            },
            {
                "author": "Peter Todd",
                "date": "2013-05-06T20:43:07",
                "message_text_only": "On Mon, May 06, 2013 at 09:50:03PM +0200, Adam Back wrote:\n> Of course you'd probably need zerocoin to stand much chance of proving an\n> address private key of an unlinked coin was in the double-spend disclosed\n> attribute in the first place, and as we know zerocoin is not that efficient.\n\nSounds like a lot of research potential with many far off possiblities. :)\n\n> >Make the node identity expensive to obtain. For instance, construct PoW's\n> >including the node pubkey somehow,\n> \n> that could be easily done with the work of creating a vanity address.  eg\n> address containing many leading 0s.\n\nBitcoin is interesting because it provides a nice way to determine the\nvalue of a proof-of-work. Lets suppose you have a digest D and want to\ncreate a proof of work for that digest.\n\n1) Select a block B1 that is reasonably deep in the blockchain. (You\ndon't want it getting re-orged out of existence) Six blocks deep is\nprobably plenty.\n\n2) Construct an invalid block header, BP, with SHA256(B1 | D) as the\nprevious block hash. All other fields can be set to whatever is required\nby your hashing unit. (the merkle root would be an option too, but many\nhashing setups can't put arbitrary data into it)\n\n3) Hash until you have found the PoW with the difficulty you want.\n\n4) Timestamp BP in the blockchain, resulting in a merkle path M leading to\na subsequent block B2. (1)\n\n\nNow determining the value of D has a nice compact proof: B1, BP and M\nand B2. Taking the minimum of the difficulties of B1 and B2 (in case\nthey cross a retarget boundry; don't want to create strange incentives)\ndetermine the expected return in Bitcoins from the block reward had the\nhasher solved valid blocks instead and you can determine exactly how\nmuch the proof-of-work was worth, kinda...\n\nThings get a bit complex from here on. First of all there isn't a\ncompact proof that will tell you how much the fees of solving that block\nwould have been worth, and there can't be because miners can easily\nmanipulate the apparent fees of a block in both directions.\n\nAlso as with fidelity bonds (https://en.bitcoin.it/wiki/Fidelity_bonds)\nthe question of which value to use, historic or current, is important\ntoo. If you use the Bitcoin face value increases or decreases of the\nvalue of a Bitcoin are arguably distorting. On the other hand, if you\nuse historical exchange rates, which currency do you use and where do\nyou get trustworthy historical exchange rate data? (2)\n\n\n1) See https://github.com/opentimestamps\n\n2) Which reminds me, I do need to get around to bugging Mt. Gox to PGP\nsign their exchange rate data and timestamp it properly, or do one or\nboth myself. It should be archived at archive.org or something too,\nheck, the blockchain should be too, although timestamping that will\nrequire a bit more work...\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000190ee1bf5262b2557eb69b49d0e14e1d644ec44a8488f7f5181\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130506/d4cb96db/attachment.sig>"
            },
            {
                "author": "Peter Todd",
                "date": "2013-05-06T23:44:11",
                "message_text_only": "On Mon, May 06, 2013 at 04:43:07PM -0400, Peter Todd wrote:\n> Now determining the value of D has a nice compact proof: B1, BP and M\n> and B2. Taking the minimum of the difficulties of B1 and B2 (in case\n> they cross a retarget boundry; don't want to create strange incentives)\n> determine the expected return in Bitcoins from the block reward had the\n> hasher solved valid blocks instead and you can determine exactly how\n> much the proof-of-work was worth, kinda...\n\nOne last thought... suppose you want to make these proof-of-works\ntransferable on the blockchain, as is easily possible with\nannounce/commit fidelity bond sacrifices. The problem is of course\nre-use - you don't want it to be possible to use the same proof-of-work\nfor a different asset.\n\nSo for D use the txid:vout pair of a txout that you can spend, then\nspend it to some output to create the start of the smartcoin/contract\nasset chain. The txout can only be spent once, so the PoW is inherently\nnon-reusable.\n\nThe final proof is a more compact than a fidelity bond proof, just the\nPoW block and a single transaction and existence proof rather than two\nor three. (announce, commit, and commit txin if sacrifice is via fees)\n\n\nUnfortunately PoW schemes do mean you are actually taking away from the\noverall security of the network, and if there was a lot of demand for\nthese things it will lead to the undesirable effect of making it easy to\nrent hashing power. Botnet owners will be happy to have a task that\nrequires even less communication than Bitcoin itself. Finally the\nvarience inherent in them is annoying too. But it's an interesting idea.\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000001358eaf811792b28798a04103b2e47aecf54268736514defd2f\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130506/df6a9aa7/attachment.sig>"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-05-07T09:00:52",
                "message_text_only": "> You mean scam you with a zero-conf transaction that hasn't actually been\n> broadcast?\n\nYeah. Or just scam you at all. It's hard to imagine an organisation as\na big as a mobile carrier engaging in financial scamming (roaming fees\nexcepted).\n\nI've said this before, but I think it's worth repeating. The\ndouble-spend protection the block chain gives you has a sweet spot\nwhere it's really, really valuable (essential even) and then there are\nlots of kinds of transactions on either side of that sweet spot that\ndon't really benefit from it.\n\nObvious/trivial case where you don't need a block chain - Facebook\nbuys Instagram for a gajillion coins. The legal system is plenty good\nenough to ensure the payments are honoured. Another example, when my\nemployer pays me my salary. They aren't going to double spend this\nexcept through some horrible accident that we can get sorted out some\nother way.\n\nAnother case, very small payments. This is Satoshi's bag of crisps\nexample. If the cost/complexity of double spending is higher than what\nthe payment is worth, again, you don't really need the block chain.\nThat's why it's worth optimising unconfirmed transactions to be harder\nto double spend, it optimises (pushes up) that lower bar.\n\nPlace where you really want the chain - largeish sums of money are\nmoving around, but not large enough to justify expensive\ncross-jurisdictional legal action, or where the cost of identity\nverification and all the associated paperwork is just too high. I\nguess most online transactions fall into this bucket today."
            },
            {
                "author": "John Dillon",
                "date": "2013-05-09T00:57:42",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\n> > You mean scam you with a zero-conf transaction that hasn't actually been\n> > broadcast?\n>\n> Yeah. Or just scam you at all. It's hard to imagine an organisation as\n> a big as a mobile carrier engaging in financial scamming (roaming fees\n> excepted).\n\nUnless the government told them too.\n\n> I've said this before, but I think it's worth repeating. The\n> double-spend protection the block chain gives you has a sweet spot\n> where it's really, really valuable (essential even) and then there are\n> lots of kinds of transactions on either side of that sweet spot that\n> don't really benefit from it.\n>\n> Obvious/trivial case where you don't need a block chain - Facebook\n> buys Instagram for a gajillion coins. The legal system is plenty good\n> enough to ensure the payments are honoured. Another example, when my\n> employer pays me my salary. They aren't going to double spend this\n> except through some horrible accident that we can get sorted out some\n> other way.\n\nThe employer example actually shows something important: between a worker and\nan employer double-spending already irrelevant. People get paid after they work\ntheir two weeks not before, so the double-spend is already irrelevant.\n\nHowever when your employer pays you on the blockchain until the transaction\nconfirms for someone else to accept funds from that payment they not only have\nto trust you, but also the employer. Sure they could take it as \"you said you\nwould apy me so it is your responsibility to make that happen\" but that brings\na whole new level of complexity.\n\nA scheme where you vouch for your payments with your identity can benifit from\nbeing able to follow that chain all the way back to the last confirmed\ntransaction, although actually implementing this may be too complex to be\nworthwhile, especially initially.\n\n> Another case, very small payments. This is Satoshi's bag of crisps\n> example. If the cost/complexity of double spending is higher than what\n> the payment is worth, again, you don't really need the block chain.\n> That's why it's worth optimising unconfirmed transactions to be harder\n> to double spend, it optimises (pushes up) that lower bar.\n\nYes. But the issue is how are you going to optmize it? By adding yet more\nrestrictions and limitations on those who chose to run a node or mining\noperation, or by actually fixing the trust issue? We know you can do the\nlatter, so do not sacrifice Bitcoin's core layer in silly attempts to make\ndouble-spends harder. Fundementally Bitcoin has exactly one way of achieving\nconsensus, and that is the blockchain.\n\nIt must be your right to chose what transactins you chose to mine and chose to\nrelay. End of story. Bitcoin is not about imposing regulation on those who\nchoose to use it.\n\n> Place where you really want the chain - largeish sums of money are\n> moving around, but not large enough to justify expensive\n> cross-jurisdictional legal action, or where the cost of identity\n> verification and all the associated paperwork is just too high. I\n> guess most online transactions fall into this bucket today.\n\nIndeed. Especially for the most popular use of Bitcoin as a payment system:\nbuying things PayPal won't let you. In that circumstance the only leverage you\nhave is the protections of the blockchain and the damage you can do to the\nother (often anonymous) parties reputation.\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\n\niQEcBAEBCAAGBQJRivRcAAoJEEWCsU4mNhiPoJcIAL7T/x5gipsCNn/w3EfhZhKo\niukP0Kc3cni/Kb6gJrOlXufIxDrX8QxEhbIIrypFbyg+xHPK8NzSd13ScKNtLgjM\nw2uOI/IkgUh7VLIEZADqLO3TM5S5VDZ/A42yzTIq8MeWxaTBD1JulOc/RbljGu8V\nUrF6ptxu2UXTc0eXcor1lHfJRVteTJAAba5Awa1EAHX8f2c/1FhdrnOZwfLVJIfK\n/nnUgqGKc8l08knC6NnAlP39zbk/FHiZF/keWIFIzhiyXTnqKnqD096tIx6MpPci\nLGafjCoXACpr1XeiSufER/z6WxTvOvCbWRw4MYrbyRkmChqMtc8a7RMEPLXhaMQ=\n=Oh/p\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Adam Back",
                "date": "2013-05-06T18:04:18",
                "message_text_only": "Bitcoin p2p seeding requirements hav some ToR similarities, and we went\nthrough the same security considerations with Zero-Knowledge systems freedom\nnetwork.  Though bitcoins attacker profile and motivation is different - so\nthe defense maybe even more demanding.  At least you have no shortage of\nnodes and perhaps merchant interest and general good-will to lean on.\n\nAt ZKS I proposed we should fix the exit node issue (exit sees where you go\noften in the clear) with an apache mod so the freedom aip tunnel (ToR tunnel\nequiv) could terminate right on the web site.  (ZKS freedom network is long\ndead but some of the ideas I think made it into ToR, eg I hope my end2end\nforward anonymity idea that is implemented in Zach Brown's cebolla.)\n\nAnyway I'd have about DNS being of limited value: bitcoins primary\nvulnerability IMO (so far) is network attacks to induce network splits,\nlocal lower difficulty to a point that a local and artificially isolated\narea of the network can be fooled into accepting an orphan branch as the\none-true block chain, maybe even from node first install time.\n\n(btw I notice most of the binaries and tar balls are not signed, nor served\nfrom SSL - at least for linux).\n\nTherefore as it applies to discover, you want to be able to discover peers\nthrough as many network routes, and even steganographic protocols as\npossible.  eg if a popular web server (say apache, or an apache module) put\na steganographic peer discover relay from its own network area, even for a\nsmall bitcoin fee, that would help a lot.  (Steganographic in the SSL sense\nwould just mean that the peer seed request to /btcseed.cgi would not be\ndistinguishable to someone highly sophisticated on the inside of the router\nall the peers traffic is routed through.  Eg you could easily do this with a\nspecial magic header that overwrites something else or deletes some\nunnecessary header so that the request at least is a standard size, and pad\nthe response to the same size as the site index.html or whatever).  If the\nuser picks a few SSL sites and cross checks (more for high value) a subset\nof peers available on all and uses them as his seed that seems like a better\ndirection.\n\nIn that way an attacker cant control the network without denying service to\npopular SSL sites, which would be a warning sign to users, or having at his\ndisposal a SSL sub-CA cert (like happened with diginotar and gmail).  You\nmay be able to pin CAs for popular sites.  Obviously to the extent you're\nusing SSL you want to generally use EDH for forward-secrecy.  And not RC4 :)\n\nProbably anysite that accepts bitcoin payment will be happy to run such a\nmod-bitcoin.\n\n\nWith ToR, it has a similar bootstrap problem to bitcoin.  So while that may\nhelp it is also passing the buck, not necessarily solving the problem.  And\nas I said I think its possible bitcoin has a higher assurance need in that\nthe attackers motivated my $$ might put more effort in than the odd\ndictatorship trying to pay lip service to preventing people reading pages on\na blacklist.\n\n\nGiven the vulnerability of DNS to poisoning I would not trust it too much. \nI know its just a bootstrap, but ideally you dont want to bootstrap from a\nknown publicly vulnerable protocol - it invites DNS poison net splits\nagainst new users.\n\n\nAlso to the extent that users local clock is under his control (with\nunuthentcated NTP?) he should also treat sudden dramatic changes in luck\n(deviations from 10min interval) as suspicious.  \n\nUnfortunately at present because of the first past the post nature of the\nbitcoin lottery, reduced variance hashcash cannot be used, so its hard to\ninfer too much even from quite significant luck changes.\n\nAdam\n\nOn Mon, May 06, 2013 at 06:47:22PM +0200, Mike Hearn wrote:\n>> Speaking of, off-topic for this discussion, but in the future\n>> node-to-node communicate should be encrypted and signed\n>\n>Yes, I'd like to do this. The threat isn't really ISPs which are\n>mostly trustable (the worst they normally do outside of places like\n>China is dick about with ads), the big threat is people who use\n>untrusted WiFi without realising and end up thinking they received\n>money when actually they were just connected to a hotspot running in\n>the attackers pocket. I'm rather expecting that kind of thing to\n>happen in future.\n>\n>I think we can converge on the best solution with several iterations:\n>\n>Iteration 1) Make it clear in the UI that if the phone is connected to\n>WiFi, payments from untrusted people should not be accepted. Currently\n>the Android app merely says the money won't be spendable for a few\n>minutes. It needs to communicate the \"may not exist\" aspect more\n>clearly. If you're connected via a cell tower, the existing wording is\n>fine - it's very unlikely your telco is trying to scam you in a\n>person-to-person transaction, traffic is encrypted and 3G+ connections\n>authenticate the network so you can't be MITMd except by your telco.\n>Assuming you have a good list of IPs, of course.\n>\n>Iteration 2) Give nodes keys that appear in addr broadcasts and seed\n>data (whether it be via https or otherwise), and have each node keep a\n>running hash of all messages sent on a connection so far. Add a new\n>protocol message that asks the node to sign the current accumulated\n>hash. Not all messages really need to be signed, eg asking for\n>signatures of blocks is sort of pointless at high difficulty levels\n>because the structures are self proving and a simple watchdog timer\n>that looks for unusually slow progress is probably enough. If the\n>client keeps the same accumulated hash then when you encounter\n>something you care about the accuracy of, you can ask for a signature\n>over all traffic so far.\n>\n>Iteration 3) Do something about end to end encryption, just delegate\n>everything to Tor, or find some other way to obfuscate the origin of a\n>transaction (a mini onion network for example).\n>\n>Last time I looked, Tor wasn't really usable in library form and\n>connecting to hidden services is really slow. So it'd be an issue to\n>just re-use it out of the box, I think."
            },
            {
                "author": "Gregory Maxwell",
                "date": "2013-05-06T18:25:50",
                "message_text_only": "On Mon, May 6, 2013 at 11:04 AM, Adam Back <adam at cypherspace.org> wrote:\n> bitcoins primary\n> vulnerability IMO (so far) is network attacks to induce network splits,\n> local lower difficulty to a point that a local and artificially isolated\n> area of the network can be fooled into accepting an orphan branch as the\n> one-true block chain,\n\nUh.  It currently costs about 2016*25*$120 = six million dollars to\nreduce the difficulty in your isolated fork by a factor of 4.\n\nTo reduce it by a factor of 1000 (what would be required to make a\nparallel fork that you could maintain in realtime with a single avalon\ndevice) the cost is  sum(2016*25/4^n*120,n,0,ceil(log4(1000))) or\nabout eight million dollars.\n\nSurely you can think of attacks on Bitcoin which are less expensive\nthan eight million dollars. :P\n\n> maybe even from node first install time.\n\nProtecting against that\u2014 making sure any such attack has to start from\na high difficulty\u2014 is, in my opinion, the biggest continued\njustification for checkpoints.\n\n> (btw I notice most of the binaries and tar balls are not signed, nor served\n> from SSL - at least for linux).\n\nThey are signed.\n\n> With ToR, it has a similar bootstrap problem to bitcoin.  So while that may\n> help it is also passing the buck, not necessarily solving the problem.  And\n\nNo, it doesn't. It has centrally controlled directories that publish\nan official Truth of the Network. Someone can isolate you and thus DOS\nyou, but they can't put you on a fantasy tor network.  But ...\ncenteralized.\n\n> as I said I think its possible bitcoin has a higher assurance need in that\n> the attackers motivated my $$ might put more effort in than the odd\n\nIt does, and we also consider decentralization a core value. But even\nthe tor project would like to decentralize more."
            }
        ],
        "thread_summary": {
            "title": "Discovery/addr packets (was: Service bits for pruned nodes)",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Adam Back",
                "John Dillon",
                "Mike Hearn",
                "Peter Todd",
                "Gregory Maxwell"
            ],
            "messages_count": 21,
            "total_messages_chars_count": 54996
        }
    },
    {
        "title": "[Bitcoin-development] limits of network hacking/netsplits (was: Discovery/addr packets)",
        "thread_messages": [
            {
                "author": "Adam Back",
                "date": "2013-05-06T22:51:46",
                "message_text_only": "On Mon, May 06, 2013 at 11:25:50AM -0700, Gregory Maxwell wrote:\n>On Mon, May 6, 2013 at 11:04 AM, Adam Back <adam at cypherspace.org> wrote:\n>> bitcoins primaryvulnerability IMO (so far) is network attacks to induce\n>> network splits, local lower difficulty to a point that a local and\n>> artificially isolated area of the network can be fooled into accepting an\n>> orphan branch as the one-true block chain,\n>\n>It currently costs about 2016*25*$120 = six million dollars to\n>reduce the difficulty in your isolated fork by a factor of 4.\n\nWell I take your point that you have to produce 2016 blocks, but at a lower\nrate.  But that doesnt directly translate into my cost, I am thinking pure\nnetwork hacking.\n\nMaybe I could hack a pool to co-opt it into my netsplit and do the work for\nme, or segment enough of the network to have some miners in it, and they do\nthe work.\n\nI am just thinking $500k/day worth of relatively perfect crime reward is a\nlot of motivation for hacking networks.  Many routers home and even carrier\nare vulnerable to people armed with cisco source code & 0-days.  The\nnetsplit doesnt have to be geographical, nor even topological, nor even\nparticularly long-lived.\n\nIf you control enough people's network routing at a low enough level, you\ndont even have to stop transactions, nor do any mining work, just stop\nblocks from the netsplit crossing over, and hold that position for say a day\n(if your netsplit has 1/24 of network hash rate in it, so the split gets 6\nconfirmations to reassure the victims) and let the miners do the work.  Do\nenough transactions to do a big cash out (spend differently on the two\nnetsplits).  Obviously a big and human inattentive pool, dark-miner etc is\nthe ideal target to put into the netsplit to increase the power while\ncontrolling less nodes.\n\nMalware could do the same thing for clients, dont forget most are running\nwindows.  Malware could also start a miner if none present.\n\n>> maybe even from node first install time.\n>\n>Protecting against that\u2014 making sure any such attack has to start from\n>a high difficulty\u2014 is, in my opinion, the biggest continued\n>justification for checkpoints.\n\nDo you know if there is any downwards limit on difficulty?  I know it takes\ngoing slow for a long and noticeable time, but I am just curious on the\ntheoretical limit.\n\n>> (btw I notice most of the binaries and tar balls are not signed, nor served\n>> from SSL - at least for linux).\n>\n>They are signed.\n\nI dont see the signatures.\n\nhttp://bitcoin.org/en/download\n\nI see no signatures for linux and none in the tarball.  There are some\npublic keys inside the tarball, thats it.  Also no SSL.  sourceforge support\nSSL so you can download that.  But bitcoin.org doesnt even answer 443, and\nthe source forge link is HTTP.  But even if the sourceforge link was SSL one\nshould not serve an SSL download link from an HTTP page, any more than type\na password into an HTTPS form action on an HTTP page.  The attacker can just\nredirect and the user doesnt know what is legitimate.\n\nConsequently even if there is code signing on the windows exe, the user\ndoesnt know that, nor who they should be signed by, and as they are served\nvia HTTP, its bypassable.\n\nI guess by far the easiest way to attack right now (at least linux users) is\njust to change the binaries to create a user operated netsplit, or just have\nall their wallets empty to you via a mix once the amount gets interesting.\n\n(All attacks hypothetical of course - I'm actually a white-hat type of\nperson).\n\nAdam"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2013-05-06T23:13:15",
                "message_text_only": "On Mon, May 6, 2013 at 3:51 PM, Adam Back <adam at cypherspace.org> wrote:\n> Maybe I could hack a pool to co-opt it into my netsplit and do the work for\n> me, or segment enough of the network to have some miners in it, and they do\n> the work.\n\nOr you can just let it mine honestly and take the Bitcoins. This is\nfast (doesn't require weeks of them somehow not noticing that they're\nisolated), and yields the values I listed as 'costs' if you would have\notherwise been able to use it to mine the difficulty down to 1.  Cost\nis just as much foregone income from the alternative attack you could\nhave done instead.\n\n> nor even topological, nor even\n> particularly long-lived.\n\nAt least for attacks that drive the difficulty down it does.\n\nIf you want to talk about abusing a pool or creating a partition in\norder to create short reorgs\u2014 I agree, those don't have to be long\nlived and you can find many messages where I've written on that\nsubject.\n\nIt's inconsiderate to propose one attack and when I respond to it\nchanging the attack out from under me. :(  I would have responded\nentirely differently if you'd proposed people segmenting the network\nand creating short reorgs instead of mining the difficulty down.\n\n> Do you know if there is any downwards limit on difficulty?  I know it takes\n> going slow for a long and noticeable time, but I am just curious on the\n> theoretical limit.\n\nEvery 2016 blocks can at most lower the difficulty by a factor of 4,\nthats where the log4 (number of 2016 groups needed) and 4^n (factor in\ncost reduction for each group) come from in the formulas I gave\npreviously.\n\n> I dont see the signatures.\n\nhttp://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.8.1/SHA256SUMS.asc/download\n\nThe signatures can't be inside the tarball because they sign the tarball.\n\nSeems like the website redesign managed to hide the signatures pretty\ngood. They're in the release announcements in any case, but that\nshould be fixed.  Even when they were prominently placed, practically\nno one checked them. As a result they are mostly security theater in\npractice :(, \u2014 so\u2014 unfortunately, is SSL: there are many CA's who will\ngive anyone a cert with your name on it who can give them a couple\nhundred bucks and MITM HTTP (not HTTPS!) between the CA's\nauthentication server and your webserver. Bitcoin.org is hosted by\ngithub, even if it had SSL and even if the CA infrastructure weren't a\njoke, the number of ways to compromise that hosting enviroment would\nIMO make SSL mostly a false sense of security.\n\nThe gpg signatures and gitian downloader signatures provide good\nsecurity if actually used, solving the \"getting people to use them\"\nproblem is an open question.\n\nAnd I agree, this stuff is a bigger issue than many other things like\nmining the difficulty down."
            },
            {
                "author": "Petr Praus",
                "date": "2013-05-07T04:48:39",
                "message_text_only": "I think it's worth noting that quite a large portion of Linux users\nprobably get the mainline Bitcoin client from the packages. I think Bitcoin\npackage maintainers are doing mostly a pretty good job :)\n\n\nOn 6 May 2013 18:13, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n\n> On Mon, May 6, 2013 at 3:51 PM, Adam Back <adam at cypherspace.org> wrote:\n> > Maybe I could hack a pool to co-opt it into my netsplit and do the work\n> for\n> > me, or segment enough of the network to have some miners in it, and they\n> do\n> > the work.\n>\n> Or you can just let it mine honestly and take the Bitcoins. This is\n> fast (doesn't require weeks of them somehow not noticing that they're\n> isolated), and yields the values I listed as 'costs' if you would have\n> otherwise been able to use it to mine the difficulty down to 1.  Cost\n> is just as much foregone income from the alternative attack you could\n> have done instead.\n>\n> > nor even topological, nor even\n> > particularly long-lived.\n>\n> At least for attacks that drive the difficulty down it does.\n>\n> If you want to talk about abusing a pool or creating a partition in\n> order to create short reorgs\u2014 I agree, those don't have to be long\n> lived and you can find many messages where I've written on that\n> subject.\n>\n> It's inconsiderate to propose one attack and when I respond to it\n> changing the attack out from under me. :(  I would have responded\n> entirely differently if you'd proposed people segmenting the network\n> and creating short reorgs instead of mining the difficulty down.\n>\n> > Do you know if there is any downwards limit on difficulty?  I know it\n> takes\n> > going slow for a long and noticeable time, but I am just curious on the\n> > theoretical limit.\n>\n> Every 2016 blocks can at most lower the difficulty by a factor of 4,\n> thats where the log4 (number of 2016 groups needed) and 4^n (factor in\n> cost reduction for each group) come from in the formulas I gave\n> previously.\n>\n> > I dont see the signatures.\n>\n>\n> http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.8.1/SHA256SUMS.asc/download\n>\n> The signatures can't be inside the tarball because they sign the tarball.\n>\n> Seems like the website redesign managed to hide the signatures pretty\n> good. They're in the release announcements in any case, but that\n> should be fixed.  Even when they were prominently placed, practically\n> no one checked them. As a result they are mostly security theater in\n> practice :(, \u2014 so\u2014 unfortunately, is SSL: there are many CA's who will\n> give anyone a cert with your name on it who can give them a couple\n> hundred bucks and MITM HTTP (not HTTPS!) between the CA's\n> authentication server and your webserver. Bitcoin.org is hosted by\n> github, even if it had SSL and even if the CA infrastructure weren't a\n> joke, the number of ways to compromise that hosting enviroment would\n> IMO make SSL mostly a false sense of security.\n>\n> The gpg signatures and gitian downloader signatures provide good\n> security if actually used, solving the \"getting people to use them\"\n> problem is an open question.\n>\n> And I agree, this stuff is a bigger issue than many other things like\n> mining the difficulty down.\n>\n>\n> ------------------------------------------------------------------------------\n> Learn Graph Databases - Download FREE O'Reilly Book\n> \"Graph Databases\" is the definitive new guide to graph databases and\n> their applications. This 200-page book is written by three acclaimed\n> leaders in the field. The early access version is available now.\n> Download your free book today! http://p.sf.net/sfu/neotech_d2d_may\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130506/39286b04/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2013-05-07T21:07:50",
                "message_text_only": "I really beg to differ on this one.  If you're an Ubuntu user who is\nbehind only one distro (quantal) you're stuck on version 0.6.2 with no\nupdates since 2012 (yes, that means on May 15th you'll be lost). \n \nFor those still on Debian Squeeze (ie barely out of date), you get\n0.3.24! Yes, 0.3.24 including every issue we've fixed since\n(https://en.bitcoin.it/wiki/Common_Vulnerabilities_and_Exposures) and\nbitcoin is not available in wheezy.\n\nThose are just the two I bothered to look up, but, additionally, nearly\nevery distro I know of links bitcoin against libdb5.1 (latest Ubuntu,\nArch, etc) which means wallets run once with those packages will never\nbe usable an \"official\" Bitcoin build ever again.  I can't necessarily\nfault them for this since 4.8 is quite old, but its certainly not \"doing\nmostly a pretty good job\"\n\nMatt\n\nOn Mon, 2013-05-06 at 23:48 -0500, Petr Praus wrote:\n> I think it's worth noting that quite a large portion of Linux users\n> probably get the mainline Bitcoin client from the packages. I think\n> Bitcoin package maintainers are doing mostly a pretty good job :)"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-05-07T09:17:17",
                "message_text_only": "> Seems like the website redesign managed to hide the signatures pretty\n> good. They're in the release announcements in any case, but that\n> should be fixed.  Even when they were prominently placed, practically\n> no one checked them. As a result they are mostly security theater\n\nSecurity theater indeed - even if people check the signatures, where\ndid they get the identities of the signers/developers from?  Oh right,\nthe same website that served them the binary.\n\nThe signatures are useful for verifying the integrity of our mirrors.\nThe verify-bitcoin.sh script does this. Unfortunately it's not good\nenough. I run it daily and from time to time it fails and says the\nhashes don't match, which I assume means we may have a corrupted\nmirror somewhere or the script itself is flaky. But the output is too\nsparse to investigate. I modified it to print more data and am waiting\nfor it to fail again, unfortunately, I can't make it fail on demand.\n\nAnyway. I've been thinking about this problem a fair bit. It's easier\nto solve on some platforms than on others.\n\nOn Android, the Bitcoin Wallet app is protected by a few things:\n\n1) Once installed, the device will only accept updates that were\nsigned by the same key as the original. So the auto update mechanism\nis secure (including I believe against an attack by the store\noperator, which is usually Google).\n\n2) It appears at the top of the Play Store when you search for\n\"Bitcoin\". Unfortunately the Store is somewhat gameable at the moment,\nbut that's getting fixed and more importantly over the long term, app\nstore operators have the right incentives to crack down on gaming of\nsearch results. This combined with the reviews, ratings and social\nrecommendations of real users provides a series of signals that are\nhard for an attacker/phisher to replicate. You can say to someone \"Go\nget the app called Bitcoin Wallet by Andreas Schildbach from the\nstore\" and the chances they get the right thing, signed by the right\nperson, are very high.\n\n3) I never got around to trying it, but the threshold RSA library I\nobtained is theoretically capable of splitting the RSA keys used to\nprotect updates. I've talked to Andreas about this a little bit, and I\nthink he's open to the idea of splitting the Android signing key so it\nrequires a quorum of developers to release an update. This is Shoup\nthreshold RSA, not a Shamir secret share of the key bits.\n\n4) The OS sandboxes apps from each other. That sandbox doesn't have a\ngreat track record outside of Google-controlled devices because OEMs\nand carriers don't have the right incentives to actually ship OS\nsecurity updates, but it's still a lot better than nothing and\nhopefully over time these issues will get resolved.\n\nAll together this means users on phones and tablets have a somewhat\nconvincing security solution that fights against phishing and malware.\n\nOn MacOS X the binaries are signed under the legal identity of the\nBitcoin Foundation. Jim has started signing MultiBit with his legal\nidentity too (this is required to make Gatekeeper happy on recent\nversions of MacOS). Unsigned binaries will not run by default on 10.8,\nbut anyone with a developer certificate can sign any binary. So whilst\na hacked bitcoin.org or a phishing site can distribute malware, at\nleast on OS X 10.8 it will require the user to override the built in\nsecurity systems, or it will require the malware author to steal a\ndeveloper certificate - probably not very hard but definitely raises\nthe bar.\n\nOn Windows antivirus companies operate what is effectively a form of\nbinary whitelisting. The new MultiBit release triggered AV warnings\nfor a few days until it got enough reputation to stop triggering. The\ngoal of these systems is to fight polymorphic viruses and they\nunderstand code signing. If you reliably sign your binaries, positive\nbinary reputation accrues to your signing identity and not the binary\nitself, so you can release updates and not get harassed.\n\nOn Linux we're actually the most exposed. It has by far the worst\nsituation of all - a culture in which man-in-the-middle attacks by\npackage maintainers are not only common but actively encouraged. The\nDebian OpenSSL fiasco showed the critical danger this can place people\nin. I believe we should have a health warning on the website telling\npeople to only get binaries from us unless they are on a distribution\nthat we are verifying doesn't apply any patches. But that's a ton of\nwork and I long ago burned out on the politics of Linux software\ndistribution."
            },
            {
                "author": "Adam Back",
                "date": "2013-05-07T11:07:40",
                "message_text_only": "Well its a bit more hopeful than that :)\n\nOn Tue, May 07, 2013 at 11:17:17AM +0200, Mike Hearn wrote:\n>> Seems like the website redesign managed to hide the signatures pretty\n>> good.\n>\n>Security theater indeed - even if people check the signatures, where\n>did they get the identities of the signers/developers from?  Oh right,\n>the same website that served them the binary.\n\nIf they are PGP signatures, they can check the PGP WoT; its not that\nhopeless some us eg have our keys in Ross Anderson's PGP Global Trust\nRegister, a PGP and CA key fingerprint book.  \n\nhttp://www.cl.cam.ac.uk/research/security/Trust-Register/index.html\n\nProbably most of the CA keys expired, but many of the PGP keys didnt.  So to\nthe extent that those people take PGP WoT seriously, and the main developers\nnames and email addresses are known and scattered around hundreds of web\nmailing list archives etc there is some trust anchor.\n\n\nAnd even without a PGP WoT connection, if the website had SSL enabled, they\ncan trust the binaries its sending to the extent that it is securely\nmaintained, and to the limit of the CA security weakest link (modulo sub-CA\nmalfeasance, and all the certification domain ownership laxness you or\nsomeone mentioned in another mail).  That there are limitations in it doesnt\nmean you should not avail of the (moderately crummy) state of the art!\n\nAnd that is tied back to the domain itself hwich is very mnemonic and\nreferenced widely in print, tv, websites etc.\n\n>3) I never got around to trying it, but the threshold RSA library I\n>obtained is theoretically capable of splitting the RSA keys used to\n>protect updates. I've talked to Andreas about this a little bit, and I\n>think he's open to the idea of splitting the Android signing key so it\n>requires a quorum of developers to release an update. This is Shoup\n>threshold RSA, not a Shamir secret share of the key bits.\n\nI guess its the least of the concerns but I believe Damgards is better. \nAnother possibility is threshold DSA (which is built using Damgards Paillier\nadditively homomorphic cryptosystem extension) and discrete log schemes are\neasier to setup with zero-trust.  Other simpler discrete log signatures ie\nSchnorr are much easier to work with (threshold DSA is a mite complicated),\nbut NIST tweaked Schnorr to create DSA, and the rest is history.  The trust\nn-1 of n is good enough for signatures because anyway that is above the\nassurance of the signature.\n\n>On Linux we're actually the most exposed. It has by far the worst\n>situation of all - a culture in which man-in-the-middle attacks by\n>package maintainers are not only common but actively encouraged. The\n>Debian OpenSSL fiasco showed the critical danger this can place people\n>in. I believe we should have a health warning on the website telling\n>people to only get binaries from us unless they are on a distribution\n>that we are verifying doesn't apply any patches. But that's a ton of\n>work and I long ago burned out on the politics of Linux software\n>distribution.\n\nWell before I tried the download I had downloaded and compiled a few\nversions from git.  But to get a stable and experience the non-programmer\nview I did first try \"yum install bitcoin\" and then \"yum whatprovides bitcoin\"\non fedora 18 with +rpmfusion and there appeared to be no package!\n\nI didnt find the signature on the source either or I would've checked.\n\n\nOther ways you could get usefully get assurance of the source is multiple\npeople signing the release, with an asserted meaning being - I checked the\npatches that went into this and I see nothing malicious.  It might help if\none or more of the signer were pseudonymous even (eg Satoshi if willing)\nbecause you cant coerce legally, nor physically a pseudonymous person\nbecause you cant find them.  Its a lot of pressure on open secure coding\nprocess when there is $1bil value protected by the integrity of the code. \n(It seems the most likely avenue to bypass that maybe simply the attacker to\njust become a committer and slip the 0-day past the review process.  There\nwere in the past modest-impact and plausible looking mistakes in PGP\ndiscovered after sometime.)\n\nAdam"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-05-07T12:04:16",
                "message_text_only": "> And even without a PGP WoT connection, if the website had SSL enabled, they\n> can trust the binaries its sending to the extent that it is securely\n> maintained\n\nYes, it would be nice to have SSL but that requires finding\nalternative file hosting.\n\n> I guess its the least of the concerns but I believe Damgards is better.\n\nUnfortunately we don't have any choice in what to use. There's no way\non Android to change the signing key after deployment, so we can\neither split the existing key or do nothing.\n\nThere is a quorum-of-developers signing system using gitian and\nreproducible builds, but as noted by Gregory, the problem is that\npeople don't check the signatures (even ignoring the web of trust\naspect which raises the complexity much higher). This sort of thing\nworks best when combined with an auto update engine or other kind of\nsoftware distribution platform."
            }
        ],
        "thread_summary": {
            "title": "limits of network hacking/netsplits (was: Discovery/addr packets)",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Petr Praus",
                "Adam Back",
                "Mike Hearn",
                "Gregory Maxwell",
                "Matt Corallo"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 20886
        }
    },
    {
        "title": "[Bitcoin-development] Cold Signing Payment Requests",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2013-05-06T21:29:59",
                "message_text_only": "On Tue, Apr 30, 2013 at 10:17:23AM -0700, Jeremy Spilman wrote:\n> [Aside] I was reading Peter's fidelitybond writeup for his idea on contract\n> value accounting, and he points to Stephan's post from last September on\n> payer-encoded metadata (\n> https://bitcointalk.org/index.php?topic=108423.msg1178438#msg1178438) which\n> Timo applies here. As a relative newcomer, this is what I am loving most\n> about Bitcoin.\n\nThe widespread disclosure we do is a good thing for sure.\n\nKeep in mind that Bitcoin is brand new technology, and brand new fields\ntend to get lots of people coming in and trying to patent them. Public\ndisclosure, and bitcointalk, the email list, and github all count, is a\nvaluable tool to ward off potential threats in the future if it ever\ncomes to that.\n\nFWIW it might not be a bad idea to see if archive.org would accept some\nof the key documentation like the development section of the forum, the\nemail list archives, and the irc logs. Some issues, especially on the\nforum, with people's ability to edit posts after the fact, but we're\nbreaking new ground here and the history should be archived.\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000f5a3175efc20cdac41f848d47dc7d00debe821ebfa69f91db9\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130506/c1453a1d/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Cold Signing Payment Requests",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Peter Todd"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1491
        }
    },
    {
        "title": "[Bitcoin-development] WebCryto standard to support secp256r1 but not secp256k1",
        "thread_messages": [
            {
                "author": "Melvin Carvalho",
                "date": "2013-05-07T10:18:43",
                "message_text_only": "Looking at the proposed native crypto browser support (should arrive in the\nnext year)\n\nhttp://www.w3.org/TR/WebCryptoAPI/#EcKeyGenParams-dictionary\n\nWe see:\n\nenum NamedCurve {\n  // NIST recommended curve P-256, also known as secp256r1.\n  \"P-256\",\n  // NIST recommended curve P-384, also known as secp384r1.\n  \"P-384\",\n  // NIST recommended curve P-521, also known as secp521r1.\n  \"P-521\"\n};\n\nI wonder if we might be able to get bitcoin's curve in there\n\nFor more background on Koblitz curve used by bitcoin see:\n\nhttps://bitcointalk.org/?topic=2699.0\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130507/0f3dc6b8/attachment.html>"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2013-05-29T12:14:20",
                "message_text_only": "On 7 May 2013 12:18, Melvin Carvalho <melvincarvalho at gmail.com> wrote:\n\n> Looking at the proposed native crypto browser support (should arrive in\n> the next year)\n>\n> http://www.w3.org/TR/WebCryptoAPI/#EcKeyGenParams-dictionary\n>\n> We see:\n>\n> enum NamedCurve {\n>   // NIST recommended curve P-256, also known as secp256r1.\n>   \"P-256\",\n>   // NIST recommended curve P-384, also known as secp384r1.\n>   \"P-384\",\n>   // NIST recommended curve P-521, also known as secp521r1.\n>   \"P-521\"\n> };\n>\n> I wonder if we might be able to get bitcoin's curve in there\n>\n> For more background on Koblitz curve used by bitcoin see:\n>\n> https://bitcointalk.org/?topic=2699.0\n>\n\nHi All\n\nI enuired about this and got the following reply, from the chair of the\ncrypto group:\n\n[[\nJust email public-webcrypto-comments at w3.org. It's a public list. Do\ndefinitely mention your use-cases!\n\nI think there's issues of whether NSS etc. already support it. I think the\nanswer here is \"no\" but David can clarify. The goal is not to get browser\nvendors to write new crypto code, but to expose the crypto code that\nalready exists.\n\nWe still have an open issue about whether \"experimental\" registry for\nidentifiers for say, new curves that aren't in the core spec, will be\nmaintained. So, maybe if browsers don't support it today, it's always\npossible they might want to support it tomorrow given Bitcoin's growth.\n]]\n\nPlease let me know if anyone has a use case for ecdsa in the browser let me\nknow.\n\nOr if anyone would like to write to the public list that's fine\n\nOtherwise I'll just fire off a mail and see what they come back with ...\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130529/f396cd94/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "WebCryto standard to support secp256r1 but not secp256k1",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Melvin Carvalho"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2529
        }
    },
    {
        "title": "[Bitcoin-development] minor bitcoin-qt gripes moving BTC off specific key",
        "thread_messages": [
            {
                "author": "Adam Back",
                "date": "2013-05-07T12:16:41",
                "message_text_only": "Hi\n\nThree minor security/other issues:\n\n1. please a way to unlock the wallet without displaying wallet password in\n   console screen (console unlock wallet, to import priv key); or \n\n2. a button to import a private key (and option to transfer it to another\n   key - if you are not the sole controller the private key)\n\n3. a UX way to transfer BTC off a specific adress (eg choose from\n   address), rather than having to spend the entire wallet onto a new\n   address, just to get BTC off a specific address.  Doing it that way has\n   problems: creates more network traffic/bigger packets, higher fees (if\n   any transactions are young/low confirmation), and generally damages\n   privacy as all your funds end up linked.\n\nStop reading here if thats clear.. below is how those scenarios happened\nwhich I think are common enough.\n\nSo someone sent me a small BTC donation by emailing me the private key, as I\nhad no bitcoin address.  So naturally I need to move the funds off the\nprivate key, or they could spend it under me.\n\nI had another small amount on a self-controlled private key in the wallet\nvia a reddit tip (.05BTC tip payed to self-controlled key became .0498BTC).\n\nSo I went through the debug->console unlock wallet (password in cleartext on\nscreen? yuck), then importpriv key, process and that worked, though not\nparticularly intuitive - could do with an \"import key\" button?\n\nThen I wanted to take the .01 BTC off the private key and the FAQs etc seem\nto suggest that the only way to do it is to spend our entire balance (from\nall keys) onto a new address.  Not exactly what I wanted, but I did it\nanyway and the tx fee goes up from .0001 which I set it to to .0005 because\nthe transaction was young, to avoid network flooding.  Even though\ntransaction I actually wanted to move (on the non self-controlled key had a\nbig heap of confirmations and so could've been .0001 tx fee).\n\nWould be kind of handy to be able to select the key to empty without having\nto empty the entire wallet into a new key...  (Smaller transaction KB on the\nnetwork, less fees for the user, less confusing).\n\nMaybe theres a way to do it, eg via the console again, but I didnt find it;\nand it's surely common enough that it could do with being another button or\nright click option.  eg I could've setup another wallet instance but thats\nrather indirect.\n\nAdam"
            },
            {
                "author": "Gavin Andresen",
                "date": "2013-05-07T12:28:15",
                "message_text_only": "\"sweep private key\" is the missing functionality.\n\nI agree, it would be nice to have.\n\n\nOn Tue, May 7, 2013 at 8:16 AM, Adam Back <adam at cypherspace.org> wrote:\n\n> Hi\n>\n> Three minor security/other issues:\n>\n> 1. please a way to unlock the wallet without displaying wallet password in\n>    console screen (console unlock wallet, to import priv key); or\n>\n> 2. a button to import a private key (and option to transfer it to another\n>    key - if you are not the sole controller the private key)\n>\n> 3. a UX way to transfer BTC off a specific adress (eg choose from\n>    address), rather than having to spend the entire wallet onto a new\n>    address, just to get BTC off a specific address.  Doing it that way has\n>    problems: creates more network traffic/bigger packets, higher fees (if\n>    any transactions are young/low confirmation), and generally damages\n>    privacy as all your funds end up linked.\n>\n-- \n--\nGavin Andresen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130507/b88462f7/attachment.html>"
            },
            {
                "author": "Wladimir",
                "date": "2013-05-07T13:14:08",
                "message_text_only": "On Tue, May 7, 2013 at 2:28 PM, Gavin Andresen <gavinandresen at gmail.com>wrote:\n\n> \"sweep private key\" is the missing functionality.\n>\n> I agree, it would be nice to have.\n>\n>\n> On Tue, May 7, 2013 at 8:16 AM, Adam Back <adam at cypherspace.org> wrote:\n>\n>> Hi\n>>\n>> Three minor security/other issues:\n>>\n>> 1. please a way to unlock the wallet without displaying wallet password in\n>>    console screen (console unlock wallet, to import priv key); or\n>>\n>> 2. a button to import a private key (and option to transfer it to another\n>>    key - if you are not the sole controller the private key)\n>>\n>> 3. a UX way to transfer BTC off a specific adress (eg choose from\n>>    address), rather than having to spend the entire wallet onto a new\n>>    address, just to get BTC off a specific address.  Doing it that way has\n>>    problems: creates more network traffic/bigger packets, higher fees (if\n>>    any transactions are young/low confirmation), and generally damages\n>>    privacy as all your funds end up linked.\n>>\n>\nYes, sweep (send all the coins from this addresses to me) should certainly\nbe added. Maybe even a way to do it periodically, though but that would\nrequire remembering the key.\n\nImporting private keys into the wallet will not be added as a user-friendly\noption, as it is dangerous and potentially confusing.\n\nAs for (1), I think a better solution would to add a list of commands whose\narguments are censored in the console screen and command line history. At\nleast `importprivkey`, `walletpassphrase`, `walletpassphrasechange` should\nlikely be in that list.\n\nWladimir\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130507/ffc4c167/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2013-05-07T13:19:50",
                "message_text_only": "On Tue, May 07, 2013 at 02:16:41PM +0200, Adam Back wrote:\n> Hi\n> \n> Three minor security/other issues:\n> \n> 1. please a way to unlock the wallet without displaying wallet password in\n>    console screen (console unlock wallet, to import priv key); or \n\nI think the general solution here is providing a feature-reach Python RPC client,\nwhich can do things like remember passwords, command history/tab completion,\nperhaps even batch lookups of compound commands (getblock $(getblockhash X, for\nexample, ...). The naive RPC client built into bitcoind is not a good fit for\nmany features, as they can much more efficiently be developed outside of the\ncore binary,\n\n\n> 2. a button to import a private key (and option to transfer it to another\n>    key - if you are not the sole controller the private key)\n\nI'm quite opposed to any per-key fiddling in the GUI. This will inevitably lead\nto (even more) people misunderstanding how wallets work and shooting themself in\nthe foot. I don't mind an expert mode (\"coin control\") that enables such features,\nbut in general, we should for entire-wallet export and import rather than\nindividual keys.\n\nImport & sweep an address is something else, that sounds safe to.\n\n> 3. a UX way to transfer BTC off a specific adress (eg choose from\n>    address), rather than having to spend the entire wallet onto a new\n>    address, just to get BTC off a specific address.  Doing it that way has\n>    problems: creates more network traffic/bigger packets, higher fees (if\n>    any transactions are young/low confirmation), and generally damages\n>    privacy as all your funds end up linked.\n\nThis belongs in coin control, IMHO.\n\n-- \nPieter"
            },
            {
                "author": "Adam Back",
                "date": "2013-05-07T16:06:17",
                "message_text_only": "At ZKS other than freedom network (ToR precursor) we had psueudonyms\nassociated with cookie managers.  The idea was you create pseudonyms for\ndifferent purposes to segregate your online linkability.  \n\n\tmedical\n\tcasual browsing\n\tsocial media\n\tprivate\n\twork\n\ttrue name\n\nSeems to me that people are always going to make mistakes with individual\nkeys, even if the feature were there and accidentally link all their coin\nsources together.  I presume people saw the analysis of the slush related\n25k BTC theft, even seemingly the thief made possible slips while trying\npresumably not to:\n\nhttp://anonymity-in-bitcoin.blogspot.com/2011/07/bitcoin-is-not-anonymous.html\n\nDoes the client have any privacy algorithm (to minimise coin source cross\nlinking) to reach a given payment?\n\neg consider say I use social media, with a screen name; I collect reddit\ntips etc; I pay them out to others, or use them to buy virtual goods\nassociated with the same purpose.  \n\nIt would be rather useful to help people achieve that, there is already the\nability to create addresses, label them.  But I think just for the GUI to\nallow you to control which address the payment is from would be enough, it\ndoesnt seem like such a complicated concept.  And if people dont care, they\nonly need create one address.\n\nTechnically ZKS wasnt anonymous networking like ToR but pseudonymous\nnetworking.  Multiple wallets for different unlinked purposes would be\nsomewhat analogous to ZKS freedom pseudonymous networking & cookie-jar. \nBecause of the pseudonymity in ZKS misbehavers could be blocked by exit\nnodes based on pseudonym.  Of course they can always create a new pseudonym\nbut then they lose their accumulated reputation.  You can even make people\npay for pseudonyms, as I recall users got 5 free pseudonyms but had to pay\nfor more.\n\n(Though I have to admit the concensus after some years at ZKS was most end\nusers didnt understand what a pseudonym was!  They just wanted to be\n\"private\" and have the computer magically solve it for them.)\n\nIf you want to simplify maybe you could consider normal (linked to AML\ntrading accounts, orders for physically delivered goods etc), and \"private\"\nanalogus to the private browsing mode in various browsers.  Maybe beyond 2\nis an advanced feature but still available.\n\nAdam\n\nOn Tue, May 07, 2013 at 03:19:50PM +0200, Pieter Wuille wrote:\n>On Tue, May 07, 2013 at 02:16:41PM +0200, Adam Back wrote:\n>> Hi\n>>\n>> Three minor security/other issues:\n>>\n>> 1. please a way to unlock the wallet without displaying wallet password in\n>>    console screen (console unlock wallet, to import priv key); or\n>\n>I think the general solution here is providing a feature-reach Python RPC client,\n>which can do things like remember passwords, command history/tab completion,\n>perhaps even batch lookups of compound commands (getblock $(getblockhash X, for\n>example, ...). The naive RPC client built into bitcoind is not a good fit for\n>many features, as they can much more efficiently be developed outside of the\n>core binary,\n>\n>\n>> 2. a button to import a private key (and option to transfer it to another\n>>    key - if you are not the sole controller the private key)\n>\n>I'm quite opposed to any per-key fiddling in the GUI. This will inevitably lead\n>to (even more) people misunderstanding how wallets work and shooting themself in\n>the foot. I don't mind an expert mode (\"coin control\") that enables such features,\n>but in general, we should for entire-wallet export and import rather than\n>individual keys.\n>\n>Import & sweep an address is something else, that sounds safe to.\n>\n>> 3. a UX way to transfer BTC off a specific adress (eg choose from\n>>    address), rather than having to spend the entire wallet onto a new\n>>    address, just to get BTC off a specific address.  Doing it that way has\n>>    problems: creates more network traffic/bigger packets, higher fees (if\n>>    any transactions are young/low confirmation), and generally damages\n>>    privacy as all your funds end up linked.\n>\n>This belongs in coin control, IMHO.\n>\n>-- \n>Pieter\n>"
            },
            {
                "author": "Craig B Agricola",
                "date": "2013-05-07T16:44:25",
                "message_text_only": "BTW, Adam, I suspect you might be using the console in the GUI, and that might be\nunder Windows for all I know, but I usually do it this way on the command line\nunder Linux:\n\necho -n \"Password: \";bitcoind walletpassphrase `stty -echo;read p;echo $p;stty echo` 60; echo\n\nThis uses the JSON API to unlock the wallet (for 60 seconds; which is the \"60\"\nat the end), and should work for either the GUI (if you start it with the\n-server flag) or the headless bitcoind.  It keeps the password that you type\noff the console, and also keeps it out of the history file.  The only issue\nwith it is that it will show up in the process tree as an argument of the\ncommand for the period of time that the JSON API is being prepared and sent,\nwhich should be fairly short.  This might be a concern if you are on a\nmulti-user system (you probably shouldn't be doing this anyway), or\nworry that spyware might be monitoring for passwords (though if you are\nworried about spyware, you should already be concerned about keyloggers,\nso...) I doubt this will work (without significant modifications) on\nWindows without Cygwin, though.\n\n -Craig\n\nOn Tue, May 07, 2013 at 02:16:41PM +0200, Adam Back wrote:\n> Hi\n> \n> Three minor security/other issues:\n> \n> 1. please a way to unlock the wallet without displaying wallet password in\n>    console screen (console unlock wallet, to import priv key); or"
            },
            {
                "author": "Jesus Cea",
                "date": "2013-05-10T15:27:34",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nOn 07/05/13 14:16, Adam Back wrote:\n> 3. a UX way to transfer BTC off a specific adress (eg choose from \n> address), rather than having to spend the entire wallet onto a new \n> address, just to get BTC off a specific address.  Doing it that way\n> has problems: creates more network traffic/bigger packets, higher\n> fees (if any transactions are young/low confirmation), and\n> generally damages privacy as all your funds end up linked.\n\n[...]\n\n> Then I wanted to take the .01 BTC off the private key and the FAQs\n> etc seem to suggest that the only way to do it is to spend our\n> entire balance (from all keys) onto a new address.  Not exactly\n> what I wanted, but I did it anyway and the tx fee goes up from\n> .0001 which I set it to to .0005 because the transaction was young,\n> to avoid network flooding.  Even though transaction I actually\n> wanted to move (on the non self-controlled key had a big heap of\n> confirmations and so could've been .0001 tx fee).\n\n\"sendfrom\" in the RPC interface. Difficult to use (I would like to be\nable to use source key, in addition of source \"accounts\") and easy to\nmake mistakes. But doable.\n\nWould be nice to have an \"advanced\" GUI option to chooce source\naccount/key.\n\n- -- \nJes\u00fas Cea Avi\u00f3n                         _/_/      _/_/_/        _/_/_/\njcea at jcea.es - http://www.jcea.es/     _/_/    _/_/  _/_/    _/_/  _/_/\nTwitter: @jcea                        _/_/    _/_/          _/_/_/_/_/\njabber / xmpp:jcea at jabber.org  _/_/  _/_/    _/_/          _/_/  _/_/\n\"Things are not so easy\"      _/_/  _/_/    _/_/  _/_/    _/_/  _/_/\n\"My name is Dump, Core Dump\"   _/_/_/        _/_/_/      _/_/  _/_/\n\"El amor es poner tu felicidad en la felicidad de otro\" - Leibniz\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.10 (GNU/Linux)\nComment: Using GnuPG with Thunderbird - http://www.enigmail.net/\n\niQCVAwUBUY0R5plgi5GaxT1NAQLJ6AQAkWozxNWJdMYbIBKFTxsPErmv3LChAsYm\nbzVIb8ufwV45X0QT3maxz6A/u3yr4wGxu53Vs29dJkM5rgO5JU7akuPs3qvg3ffh\nh593zmqyVimfpXxBppff4vocpKTCJ+1ocB5MydGjgGoH2hJ8dwZNQRHYnMwqCjDf\n2ONQu7nT0pQ=\n=zZVh\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "minor bitcoin-qt gripes moving BTC off specific key",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Craig B Agricola",
                "Wladimir",
                "Adam Back",
                "Gavin Andresen",
                "Pieter Wuille",
                "Jesus Cea"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 14451
        }
    },
    {
        "title": "[Bitcoin-development] For Public Consideration: [Marketcoin | MKC] A P2P Trustless Cryptocoin Exchange",
        "thread_messages": [
            {
                "author": "Max Kaye",
                "date": "2013-05-07T16:37:12",
                "message_text_only": "Hi All, \n\nIf any of you are interested, I've put forward a proposal for a P2P Trustless Cryptocoin Exchange. I don't have anyone around to bounce ideas off; my apologies if there's any gaping logical holes.\n\nYou can find details here:\nhttps://bitcointalk.org/index.php?topic=198032.0\n\nI'd really appreciate any insight any of you have on the matter. (And look forward to hopefully meeting a few of you at the conference).\n\nCheers,\nMax\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130508/0b04c698/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "For Public Consideration: A P2P Trustless Cryptocoin Exchange",
            "categories": [
                "Bitcoin-development",
                "Marketcoin | MKC"
            ],
            "authors": [
                "Max Kaye"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 617
        }
    },
    {
        "title": "[Bitcoin-development] 32 vs 64-bit timestamp fields",
        "thread_messages": [
            {
                "author": "Addy Yeow",
                "date": "2013-05-08T23:39:10",
                "message_text_only": "Hi list,\n\nCan someone explain why do we have 32-bit and 64-bit timestamp fields\ninstead of all being 64-bit?\n\nhttps://en.bitcoin.it/wiki/Protocol_specification\n\nCheers,\nAddy"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-05-08T23:42:55",
                "message_text_only": "On Wed, May 8, 2013 at 7:39 PM, Addy Yeow <ayeowch at gmail.com> wrote:\n> Hi list,\n>\n> Can someone explain why do we have 32-bit and 64-bit timestamp fields\n> instead of all being 64-bit?\n>\n> https://en.bitcoin.it/wiki/Protocol_specification\n\nHysterical raisins.\n\n-- \nJeff Garzik\nexMULTI, Inc.\njgarzik at exmulti.com"
            },
            {
                "author": "Peter Todd",
                "date": "2013-05-08T23:44:22",
                "message_text_only": "On Thu, May 09, 2013 at 09:39:10AM +1000, Addy Yeow wrote:\n> Hi list,\n> \n> Can someone explain why do we have 32-bit and 64-bit timestamp fields\n> instead of all being 64-bit?\n> \n> https://en.bitcoin.it/wiki/Protocol_specification\n\nWho knows?\n\nSatoshi used 32-bits and those fields can't be changed now without every\nsingle Bitcoin user changing all at once. (a \"hard-fork\" change)\n\nWe'll probably need to do one of those eventually for other reasons, so\nwe might as well leave fixing the timestamps until then.\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000002a9a85a940c4da2951c3e91a043a44805fa286b336364d9daa\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130508/06a79d4c/attachment.sig>"
            },
            {
                "author": "John Dillon",
                "date": "2013-05-09T01:00:05",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nOn Wed, May 8, 2013 at 11:44 PM, Peter Todd <pete at petertodd.org> wrote:\n> Who knows?\n>\n> Satoshi used 32-bits and those fields can't be changed now without every\n> single Bitcoin user changing all at once. (a \"hard-fork\" change)\n>\n> We'll probably need to do one of those eventually for other reasons, so\n> we might as well leave fixing the timestamps until then.\n\nPerhaps Satoshi did this delibrately, knowing that at some point a hard-fork\nwould be a good idea, so that we all would have a good excuse to do one?\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\n\niQEcBAEBCAAGBQJRivT1AAoJEEWCsU4mNhiPhxUH/271jtMvNrliZxFTvud282Dc\nsnEieMig1p/HXy6ry1YLp+Q2k4Ya3QFFPlbsqHeTjL+NaJSGOHPBen4lpWahOH+T\nN6TQoOls7BMpQ7Y54Nqy5Qh9GeQnbDGcbQ8fBUfFqAF1Ljs0OBsbJtvC3vZTbYEn\ndwB+7dvPLGKVfz/yrR9wrLhDzoXHbG4C3sefqNnm+fkHHIuTy4nxwtVVMydlzerF\nBwg1oc64dlul7sugBGXo2FjtGrxxkRxWWqj+dPgBnE/bDKIlemw34PtQZ2OK+IUS\nCH7Q0EGBnr7TpXJT5AOMkycd8v9MJ2wNIt4v3YLqyViQ48Q5coxAS0GepcRnbMU=\n=na4H\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-05-09T01:08:34",
                "message_text_only": "On Wed, May 8, 2013 at 9:00 PM, John Dillon\n<john.dillon892 at googlemail.com> wrote:\n> Perhaps Satoshi did this delibrately, knowing that at some point a hard-fork\n> would be a good idea, so that we all would have a good excuse to do one?\n\nGuffaw :)  The year 2038 is so far in the future that it is not really\nrelevant, from that angle.\n\nWe need a hard fork to break the 1MB limit, and Satoshi explicitly\npresumed that would happen sometime in the future.\n\n-- \nJeff Garzik\nexMULTI, Inc.\njgarzik at exmulti.com"
            },
            {
                "author": "Pieter Wuille",
                "date": "2013-05-09T01:13:39",
                "message_text_only": "On Wed, May 08, 2013 at 09:08:34PM -0400, Jeff Garzik wrote:\n> On Wed, May 8, 2013 at 9:00 PM, John Dillon\n> <john.dillon892 at googlemail.com> wrote:\n> > Perhaps Satoshi did this delibrately, knowing that at some point a hard-fork\n> > would be a good idea, so that we all would have a good excuse to do one?\n> \n> Guffaw :)  The year 2038 is so far in the future that it is not really\n> relevant, from that angle.\n\n\"Meh\". I think it's highly unlikely we'll break the block header format, as it\npretty much means invalidating all mining hardware.\n\nThere's also no need: 32 bits is plenty of precision. Hell, even 16 bits would\ndo (assuming there's never more than a 65535s (about 18 hours) gap between two\nblocks). Just assume the \"full\" 64-bit time is the smallest one that makes\nsense, given its lower 32 bits.\n\n-- \nPieter"
            },
            {
                "author": "John Dillon",
                "date": "2013-05-09T01:27:33",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nOn Thu, May 9, 2013 at 1:13 AM, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n> On Wed, May 08, 2013 at 09:08:34PM -0400, Jeff Garzik wrote:\n>> Guffaw :)  The year 2038 is so far in the future that it is not really\n>> relevant, from that angle.\n>\n> \"Meh\". I think it's highly unlikely we'll break the block header format, as it\n> pretty much means invalidating all mining hardware.\n\nDoesn't most mining hardware at the ASCI level start with a SHA256 midstate\ngiven that the nonce is at the end?  Adding further information to the block\nshould be possible at the beginning of the block without major changes to the\nmining hardware.\n\n> There's also no need: 32 bits is plenty of precision. Hell, even 16 bits would\n> do (assuming there's never more than a 65535s (about 18 hours) gap between two\n> blocks). Just assume the \"full\" 64-bit time is the smallest one that makes\n> sense, given its lower 32 bits.\n\nI feel somewhat uncomfortable about the \"after-the-fact\" auditing possible in\nthis scenario. Besides the timestamping provided by the block headers appears\nto be useful in some payment protocols, not to mention in general.\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\n\niQEcBAEBCAAGBQJRivnmAAoJEEWCsU\n4mNhiPUIYH/AlxK4DHvIdq0khNH0nfK65E\nF1ZyYZTGLNHKqrJLCU2kc7zteGadQuccmFsYpmViIr14tzpU7xMImUHpj7fEHO3R\nS/1zy59rx2+VYcevYdwMDTywanjeForRpli93Hz570GfwfG/D7VPejfLo6iq5dOt\nEG5m3Z8F7wNzWBmfBYBHKLrNBJe6iw0qJ2nNiHXcELt6gaqG3C9wI9NAPtQWQKjB\n57h7yTnFCRmjA3HDdCe2s0FVJgRP5cJqz3e62qZrY/BRmw/Vrx8ExuX1LJFqUx3k\n5tg+BxXH4DJbNIojuq9lLl5lWxKOI1iSJJuCAixo/6s/manLFggJv7KtYgzhhjI=\n=BxDb\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Peter Todd",
                "date": "2013-05-09T01:57:31",
                "message_text_only": "On Thu, May 09, 2013 at 01:27:33AM +0000, John Dillon wrote:\n> > There's also no need: 32 bits is plenty of precision. Hell, even 16 bits would\n> > do (assuming there's never more than a 65535s (about 18 hours) gap between two\n> > blocks). Just assume the \"full\" 64-bit time is the smallest one that makes\n> > sense, given its lower 32 bits.\n> \n> I feel somewhat uncomfortable about the \"after-the-fact\" auditing possible in\n> this scenario. Besides the timestamping provided by the block headers appears\n> to be useful in some payment protocols, not to mention in general.\n\nRemember that interpreting the timestamp on a block for the purposes of\ntimestamping is a lot more subtle than it appears at first.\n\nAny node will accept a block with a timestamp no more than two hours\nahead of what it thinks the current time is. That time is adjusted by\nthe median of the timestamps reported by your peers. For instance the\nRPC call getinfo returns, among other things:\n\n{\n    \"timeoffset\" : -1,\n}\n\nThat is saying my node's wall clock time is 1 second behind the median\nreported by it's peers - pretty good!\n\n\nNaively you might think this means block timestamps are accurate to\nwithin 2 hours right? Well, it's not so simple. Nodes will accept any\nblock with any timestamp *after* the median of the last 11 blocks. From\nCBlock::AcceptBlock():\n\n    // Check timestamp against prev\n    if (GetBlockTime() <= pindexPrev->GetMedianTimePast())\n        return state.Invalid(error(\"AcceptBlock() : block's timestamp is too early\"));\n\nSo in theory a miner could prevent that block from moving forward,\nalthough if they do they drive up the difficulty, so all miners have an\nincentive to set the timestamp accurately.\n\nThere are two types of timestamps possible: proofs that data existed\nbefore a time, and proofs that data existed after. With the former type\nthe *later* the proof says the data existed, the more conservative the\nassumptions behind the proof. So simply adding two hours to the block's\ntimestamp is relatively reasonable. (this assumes the attack managed to\nmine a single block, and all nodes have accurate clocks)\n\n\nThe latter type, where you prove data existed after a given time, is a\nmuch more tricky thing to apply. The genesis block is a great example\nwith that famous newspaper headline:\n\n    The Times 03/Jan/2009 Chancellor on brink of second bailout for\n    banks\n\nAs I mentioned in my other (private) email to you a few minutes ago, the\nsig of my emails has the latest block hash in each one. The basic idea\nis called a random beacon; NIST has a good description and a project to\ncreate one:\n\nhttp://www.nist.gov/itl/csd/ct/nist_beacon.cfm\n\nNow technically speaking a random beacon is actually a more\nsophisticated concept than just timestamping, the random beacon's value\nis public and distributed widely, but for timestamping the idea is\nbasically to have an unpredictable number known to have been produced at\na certain time.\n\nSo you know this email was written after block #235235, timestamp\n2013-05-09 01:21:52 right? Not so fast. All you actually know is the PGP\n*signature* was created after that time, because the actual text of the\nemail is independent of the beacon nonce. (dunno if I have the correct\nterminology here FWIW)\n\nFor a blockchain it's easy enough, the blocks naturally depend on a\ngenesis block, but applying the concept more generally is tricky and\napplication dependent; consider for example proving you created a\nkeypair after some data, which might be a useful thing to prove if the\nsecret key was created in some tamperproof hardware that you know has\nleft the factory and is in your possesion. It's easy to see how to do\nthis with ECC: just use the same techniques as in HD wallets to derive\nkeys.\n\nTo use the blockchain as a secure random beacon you need to make two\nassumptions, 50% of the hashing power is controlled by honest miners,\nand those honest miners have accurate clocks. With those assumptions you\ncan work out what is the minimum possible time the block could have been\naccepted by the GetMedianTimePast() function and you are good to go.\n\nWhat do people do in practice? Well look at\nhttp://vog.github.io/bitcoinproof/, they just give the timestamp and\nnothing else. Same for OpenTimestamps. (although I'm adding this email\nto my notes, half the reason it's so detailed...)\n\n\nBack to the block header time... Frankly, the easiest thing to do is\njust have a flag day where blocks after a certain height are considered\nto have a different epoch from the standard 1970 one when computing\ntheir time. Boring, but it works fine and only needs to be updated every\nfew decades.\n\n\nYou're midstate idea is very clever though and could come in handy in\nthe future for different purposes. Eventually we should discuss this\nwith the ASIC manufacturers - if it can be implemented as a firmware or\nFPGA upgrade in the field all the better.\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000010a10e05e172442e0675a818d17b62c1ed041a4572002ca051e\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130508/7266c7bf/attachment.sig>"
            },
            {
                "author": "John Dillon",
                "date": "2013-05-09T02:33:11",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nOn Thu, May 9, 2013 at 1:57 AM, Peter Todd <pete at petertodd.org> wrote:\n> Remember that interpreting the timestamp on a block for the purposes of\n> timestamping is a lot more subtle than it appears at first.\n\nI actually just meant how Pieter Wuille was talking about a blocktime accurate\nto only within 18 hours. :) But it is a nice writeup!\n\nIn any case, for many things simple relative ordering is enough rather than\nabsolute time.\n\n> There are two types of timestamps possible: proofs that data existed\n> before a time, and proofs that data existed after. With the former type\n> the *later* the proof says the data existed, the more conservative the\n> assumptions behind the proof. So simply adding two hours to the block's\n> timestamp is relatively reasonable. (this assumes the attack managed to\n> mine a single block, and all nodes have accurate clocks)\n\nNope. The attacker can make the timestamp on the block they mine as little as\nthe minimum from GetMedianTimePast(), and adding two hours to that number could\neasily be well before true time.\n\nWhat you probably need to do is some sort of median time calculation for the\nblocks around your timestamp. The proof becomes probabalistic based on the % of\nhashing power the attacker controls and in turn depends on if the time they\ncreated their timestamp was of their own choosing.\n\nIE, if you just want to create an inaccurate timestamp, but don't care when,\nyou can just mine blocks and wait until you get lucky. If you need to create an\ninaccurate timestamp *now* the problem is much harder.\n\nBut all this analysis can be developed later, and data timestamped now. :)\n\n> Back to the block header time... Frankly, the easiest thing to do is\n> just have a flag day where blocks after a certain height are considered\n> to have a different epoch from the standard 1970 one when computing\n> their time. Boring, but it works fine and only needs to be updated every\n> few decades.\n\nOh, right, yes, that is a much more simple idea and far less prone to bugs.\n\nMany SPV clients wouldn't even need upgrades if they don't acturally validate\nthe blocks they receive and just look for the biggest PoW.\n\n>\n> You're midstate idea is very clever though and could come in handy in\n> the future for different purposes. Eventually we should discuss this\n> with the ASIC manufacturers - if it can be implemented as a firmware or\n> FPGA upgrade in the field all the better.\n\nYes\n\n\nAnyway, you are being distracted from what we were talking about before, get\nback to work!\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\n\niQEcBAEBCAAGBQJRiwrGAAoJEEWCsU4mNhiPvYAH/3kjlg5diWeyYUJlKPKRpygQ\nXAU8a2D3h9bABacmmhx5yW3AmtV0QqLgKlB76t41JB4O6Jer5FT8tBBwPnjDijtI\nKrBWwPqNhVZiyTSDZQTF6BR1a0DDCZVtOXlpOTj6NL1+hy7NYTYsqxAVzS8QgZUH\nRXt7QTYGrrmMbmm75NdWhK59mbv22UEaDHfDW0qqgSzdb7f1EQv1fou3MfKScQSd\n7OsGU3k5PM+KQ/FGBy+r+07GY5yj85YMooGky0MCjtkOiU/qr+pxfs1uT2R8/512\nTyZxzn1vtgWUEGOUeMCml+bgjUOvOgcIvAarzZmyLyAAY15S/LT8MvAr2RUjAfY=\n=UDyE\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Peter Todd",
                "date": "2013-05-09T02:42:44",
                "message_text_only": "On Thu, May 09, 2013 at 02:33:11AM +0000, John Dillon wrote:\n> On Thu, May 9, 2013 at 1:57 AM, Peter Todd <pete at petertodd.org> wrote:\n> > Remember that interpreting the timestamp on a block for the purposes of\n> > timestamping is a lot more subtle than it appears at first.\n> \n> I actually just meant how Pieter Wuille was talking about a blocktime accurate\n> to only within 18 hours. :) But it is a nice writeup!\n> \n> In any case, for many things simple relative ordering is enough rather than\n> absolute time.\n\nAh, shoot, I just realized we both got missed Pieter's point entirely:\nhe means to change the meaning of the header timestamp to be relative\ntime passed since the last block...\n\nWell, it was a nice writeup! Thanks for the correction re:\nprobabalistic; you are absolutely correct.\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000fb6d0ed7479069edef10b8bc598783e9d94bdb5cf9ae6a5f1c\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130508/49ed01d1/attachment.sig>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2013-05-09T11:12:48",
                "message_text_only": "On Wed, May 08, 2013 at 10:42:44PM -0400, Peter Todd wrote:\n> Ah, shoot, I just realized we both got missed Pieter's point entirely:\n> he means to change the meaning of the header timestamp to be relative\n> time passed since the last block...\n\nNo, though that's also a possibility, but a backward-incompatible one.\n\nWhat I mean is have a well-defined 64-bit timestamp for each block, but\nonly put the lowest 32 bit in the header. Under the condition:\n\n* There is never a gap of more than 136 years between two blocks.\n\nThe actual 64-bit timestamp can be deterministically derived from the\nheader, by prefixing it with the lowest 32-bit value that does not\ncause the result to violate the\nat-least-above-the-median-of-the-previous-11-blocks rule.\n\n-- \nPieter"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-05-09T15:40:51",
                "message_text_only": "2038 issues only apply to use of signed timestamps, I thought we treat\nthis field as unsigned? Is it really a big deal?\n\nOn Thu, May 9, 2013 at 1:12 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n> On Wed, May 08, 2013 at 10:42:44PM -0400, Peter Todd wrote:\n>> Ah, shoot, I just realized we both got missed Pieter's point entirely:\n>> he means to change the meaning of the header timestamp to be relative\n>> time passed since the last block...\n>\n> No, though that's also a possibility, but a backward-incompatible one.\n>\n> What I mean is have a well-defined 64-bit timestamp for each block, but\n> only put the lowest 32 bit in the header. Under the condition:\n>\n> * There is never a gap of more than 136 years between two blocks.\n>\n> The actual 64-bit timestamp can be deterministically derived from the\n> header, by prefixing it with the lowest 32-bit value that does not\n> cause the result to violate the\n> at-least-above-the-median-of-the-previous-11-blocks rule.\n>\n> --\n> Pieter\n>\n> ------------------------------------------------------------------------------\n> Learn Graph Databases - Download FREE O'Reilly Book\n> \"Graph Databases\" is the definitive new guide to graph databases and\n> their applications. This 200-page book is written by three acclaimed\n> leaders in the field. The early access version is available now.\n> Download your free book today! http://p.sf.net/sfu/neotech_d2d_may\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-05-09T15:43:31",
                "message_text_only": "On Thu, May 9, 2013 at 11:40 AM, Mike Hearn <mike at plan99.net> wrote:\n> 2038 issues only apply to use of signed timestamps, I thought we treat\n> this field as unsigned? Is it really a big deal?\n\nNot a big deal at all, no.\n-- \nJeff Garzik\nexMULTI, Inc.\njgarzik at exmulti.com"
            }
        ],
        "thread_summary": {
            "title": "32 vs 64-bit timestamp fields",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Addy Yeow",
                "John Dillon",
                "Mike Hearn",
                "Peter Todd",
                "Pieter Wuille"
            ],
            "messages_count": 13,
            "total_messages_chars_count": 17544
        }
    },
    {
        "title": "[Bitcoin-development] An initial replace-by-fee implementation is now available",
        "thread_messages": [
            {
                "author": "John Dillon",
                "date": "2013-05-09T09:58:50",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nAfter some consultation with affected sites by myself and Peter we have decided\nto release an initial replace-by-fee implementation and setup a server using\nthose rules on testnet. This implementation does not include recursive fee\nevaluation, and is therefore vulnerable to DoS attack, so hopefully that will\ncontinue to allow adoption to proceed gradually. We can-not recommend mining on\nmainnet with it. It does not include an \"undo\" RPC command or an adjust fees,\nand Peter says he has not implemented one yet.  Patches are welcome.\n\nSpecifically there were requests from vulnerable parties, which interestingly\nincluded a site that knew they had bugs related to replacement but not\nfinancial vulnerabilities, to put up a server on testnet to check wallet code.\nThe vulnerable requested to remain undisclosed. An additional consideration was\nthe upcoming anti-dust rules which are yet another example of why zero-conf is\nso much more dangerous to accept than single-conf. Two of the people contacting\nus brought up that issue in fact.\n\nThe code is on github:\n\n    https://github.com/petertodd/bitcoin/tree/replace-by-fee\n\nand a replace-by-fee server operating on testnet is available at\ntestnet-replace-by-fee.bitcoin.petertodd.org To test you will need to use the\nraw transaction API and manually create the replacement transaction. Do note\nthat your wallet will retain the existing one and no mechanism yet exists to\ndelete the old transaction from your wallet. Again, a certain amount of\n\"cludgyness\" to this is intentional to discourage premature non-testing use.\n\n\nRegarding the reward, I've decided Peter will collect the full amount even\nthough the work is not %100 complete (the mempool aspect) due to his concern\nabout staging an implementation properly, working with vulnerable sites, and\noverall genuine interest in the actual issues at hand rather than the reward.\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\n\niQEcBAEBCAAGBQJRi3LeAAoJEEWCsU4mNhiPwscH/2CI0d3h/3jix3iyz2I9I8Sz\n6nbP8eA01l9kzG37cH1rFAbt7C+fL/nardV4U1qmiwC0MN7NPpX6BFn5eQ2PUKbu\n41+AnjgWicB2tnCC07ngboQ1JCeZ+RTfATepuMxEdWFBsc8ZQXs0apWS01FT+TDq\nJ/a7QkhNfTaAQzXyqmLp0TQO7/Z7ysmCftOhtGbfvfhF2o23BuphQiRVA9IOoUuj\nFgb5wrfQqJ8TjvXRXAUQ7SUlzfN9BlPxMkTc6NhbcgIpuq1Kb43mLoDl3s2irH4A\nGtjRtobV5Cfozm1r+8KPtIYEoQoj0PqTjO5YMwD/vTaRfNzdS4Tse5LQLGT6Jug=\n=M1mj\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Adam Back",
                "date": "2013-05-09T11:19:13",
                "message_text_only": "In this thread discussing this idea\n\nhttps://bitcointalk.org/index.php?topic=179612.0 \n\nit is suggested that the approach risks making 0-confirm double-spends\neasier.\n\nI dont see why this should be.  Cant part of the validation of accepting a\nfee revision be that every aspct of the revision except the reward must be\nunchanged, otherwise the revision is considered invalid and discarded?\n\n(ie same payment amount, same input coins, same recipient and same change\naddress.)\n\nAdam\n\nOn Thu, May 09, 2013 at 09:58:50AM +0000, John Dillon wrote:\n>-----BEGIN PGP SIGNED MESSAGE-----\n>Hash: SHA256\n>\n>After some consultation with affected sites by myself and Peter we have decided\n>to release an initial replace-by-fee implementation and setup a server using\n>those rules on testnet. This implementation does not include recursive fee\n>evaluation, and is therefore vulnerable to DoS attack, so hopefully that will\n>continue to allow adoption to proceed gradually. We can-not recommend mining on\n>mainnet with it. It does not include an \"undo\" RPC command or an adjust fees,\n>and Peter says he has not implemented one yet.  Patches are welcome.\n>\n>Specifically there were requests from vulnerable parties, which interestingly\n>included a site that knew they had bugs related to replacement but not\n>financial vulnerabilities, to put up a server on testnet to check wallet code.\n>The vulnerable requested to remain undisclosed. An additional consideration was\n>the upcoming anti-dust rules which are yet another example of why zero-conf is\n>so much more dangerous to accept than single-conf. Two of the people contacting\n>us brought up that issue in fact.\n>\n>The code is on github:\n>\n>    https://github.com/petertodd/bitcoin/tree/replace-by-fee\n>\n>and a replace-by-fee server operating on testnet is available at\n>testnet-replace-by-fee.bitcoin.petertodd.org To test you will need to use the\n>raw transaction API and manually create the replacement transaction. Do note\n>that your wallet will retain the existing one and no mechanism yet exists to\n>delete the old transaction from your wallet. Again, a certain amount of\n>\"cludgyness\" to this is intentional to discourage premature non-testing use.\n>\n>\n>Regarding the reward, I've decided Peter will collect the full amount even\n>though the work is not %100 complete (the mempool aspect) due to his concern\n>about staging an implementation properly, working with vulnerable sites, and\n>overall genuine interest in the actual issues at hand rather than the reward.\n>-----BEGIN PGP SIGNATURE-----\n>Version: GnuPG v1.4.11 (GNU/Linux)\n>\n>iQEcBAEBCAAGBQJRi3LeAAoJEEWCsU4mNhiPwscH/2CI0d3h/3jix3iyz2I9I8Sz\n>6nbP8eA01l9kzG37cH1rFAbt7C+fL/nardV4U1qmiwC0MN7NPpX6BFn5eQ2PUKbu\n>41+AnjgWicB2tnCC07ngboQ1JCeZ+RTfATepuMxEdWFBsc8ZQXs0apWS01FT+TDq\n>J/a7QkhNfTaAQzXyqmLp0TQO7/Z7ysmCftOhtGbfvfhF2o23BuphQiRVA9IOoUuj\n>Fgb5wrfQqJ8TjvXRXAUQ7SUlzfN9BlPxMkTc6NhbcgIpuq1Kb43mLoDl3s2irH4A\n>GtjRtobV5Cfozm1r+8KPtIYEoQoj0PqTjO5YMwD/vTaRfNzdS4Tse5LQLGT6Jug=\n>=M1mj\n>-----END PGP SIGNATURE-----\n>\n>------------------------------------------------------------------------------\n>Learn Graph Databases - Download FREE O'Reilly Book\n>\"Graph Databases\" is the definitive new guide to graph databases and\n>their applications. This 200-page book is written by three acclaimed\n>leaders in the field. The early access version is available now.\n>Download your free book today! http://p.sf.net/sfu/neotech_d2d_may\n>_______________________________________________\n>Bitcoin-development mailing list\n>Bitcoin-development at lists.sourceforge.net\n>https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Peter Todd",
                "date": "2013-05-09T11:46:05",
                "message_text_only": "On Thu, May 09, 2013 at 01:19:13PM +0200, Adam Back wrote:\n> In this thread discussing this idea\n> \n> https://bitcointalk.org/index.php?topic=179612.0 \n> \n> it is suggested that the approach risks making 0-confirm double-spends\n> easier.\n\nThe patch makes the concept of a 0-confirm double-spend obsolete\nbasically. The model is rather than having some vague, insecure, easily\nbroken, de-facto no-replacement rule it replaces it with something very\neasy to reason about: you are bidding for blockchain space, and you can\nadjust your bid after the fact.\n\nThe reality is zero-conf double-spends aren't that big of a problem\nbecause the vast majority of payments have other mechanisms they can use\ninstead of relying on the defacto behavior of dozens of major miners and\nnodes.\n\nLong story short, we're better off if we don't give people a false sense\nof security.\n\n> I dont see why this should be.  Cant part of the validation of accepting a\n> fee revision be that every aspct of the revision except the reward must be\n> unchanged, otherwise the revision is considered invalid and discarded?\n\nA node has no idea which transaction output is change and which one\nisn't; if nodes could distinguish change from payment your privacy would\nbe badly violated.\n\nBy allowing simple replacement without further rules the fee adjustment\nprocess can go on as long as required, without you running out of\nadditional transaction inputs and without causing the transaction to get\nbigger and bigger each time.\n\nIt also allows more interesting use cases, like adding additional\noutputs to a transaction after the fact as more payees become known, or\nif two unrelated parties decide to combine their transactions to save on\nblockchain space and preserve their privacy.\n\nEventually the P2P protocol can have delta compression support, so the\nnetwork bandwidth required to merge two transactions into one will be\nminimal.\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000014c26728a13e351b4dd7a32e99e28d43a960b5ac5f98696ae5b\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130509/ca151224/attachment.sig>"
            },
            {
                "author": "Adam Back",
                "date": "2013-05-09T12:07:23",
                "message_text_only": "I have to say I do not think you want to have it be random as to who gets\npaid (by having conflicting double spends floating around with different\npayee & change addresses all from the same sending address.)  \n\nAbout current defacto no replacement: it is the best bitcoin currently has,\nand it has value, with it you need to do a net-split to attack eg\n1-confirmation, and this proposal weakens it.  Net-splits are possible but\nnot trivial.  This proposal moves them into spec - ie free.\n\nAbout privacy: I think you are going to inherently disclose which is the\nchange address, because you will decrease the change when you increase the\nfee.  There is no coin management in the client, and as far as I saw so far,\nno privacy management of which coins to reduce coin cross linking.  Who's to\nsay the client has 100s of times as many coins as the payment.\n\nIf people dont want to reveal which is change and which payment, they need\nto put a big enough fee up front based on a margin over prevailing fee\nstatistics.\n\nIt would also be better to try to get the fee right first time than to create\nmore traffic revising it due to experience.  Though the ability to revise\nthe fee IFF the best effort fee doesnt work empirically after a couple of\nblocks seems like a good feature.  (But not with revised recipient/change\naddresses.\n\nAlso if the bids are too flexibly different how do you stop both bids being\nprocessed (eg one in a block, the next in the next block).\n\nAdam\n\nOn Thu, May 09, 2013 at 07:46:05AM -0400, Peter Todd wrote:\n>On Thu, May 09, 2013 at 01:19:13PM +0200, Adam Back wrote:\n>> In this thread discussing this idea\n>>\n>> https://bitcointalk.org/index.php?topic=179612.0\n>>\n>> it is suggested that the approach risks making 0-confirm double-spends\n>> easier.\n>\n>The patch makes the concept of a 0-confirm double-spend obsolete\n>basically. The model is rather than having some vague, insecure, easily\n>broken, de-facto no-replacement rule it replaces it with something very\n>easy to reason about: you are bidding for blockchain space, and you can\n>adjust your bid after the fact.\n>\n>The reality is zero-conf double-spends aren't that big of a problem\n>because the vast majority of payments have other mechanisms they can use\n>instead of relying on the defacto behavior of dozens of major miners and\n>nodes.\n>\n>Long story short, we're better off if we don't give people a false sense\n>of security.\n>\n>> I dont see why this should be.  Cant part of the validation of accepting a\n>> fee revision be that every aspct of the revision except the reward must be\n>> unchanged, otherwise the revision is considered invalid and discarded?\n>\n>A node has no idea which transaction output is change and which one\n>isn't; if nodes could distinguish change from payment your privacy would\n>be badly violated.\n>\n>By allowing simple replacement without further rules the fee adjustment\n>process can go on as long as required, without you running out of\n>additional transaction inputs and without causing the transaction to get\n>bigger and bigger each time.\n>\n>It also allows more interesting use cases, like adding additional\n>outputs to a transaction after the fact as more payees become known, or\n>if two unrelated parties decide to combine their transactions to save on\n>blockchain space and preserve their privacy.\n>\n>Eventually the P2P protocol can have delta compression support, so the\n>network bandwidth required to merge two transactions into one will be\n>minimal.\n>\n>-- \n>'peter'[:-1]@petertodd.org\n>000000000000014c26728a13e351b4dd7a32e99e28d43a960b5ac5f98696ae5b"
            },
            {
                "author": "Peter Todd",
                "date": "2013-05-09T12:20:05",
                "message_text_only": "On Thu, May 09, 2013 at 02:07:23PM +0200, Adam Back wrote:\n> I have to say I do not think you want to have it be random as to who gets\n> paid (by having conflicting double spends floating around with different\n> payee & change addresses all from the same sending address.)\n\nIndeed. That's the point of the blockchain, to take all those potential\ninconsistencies and vote on a true transaction history to achieve\nconsensus.\n\n> About current defacto no replacement: it is the best bitcoin currently has,\n> and it has value, with it you need to do a net-split to attack eg\n> 1-confirmation, and this proposal weakens it.  Net-splits are possible but\n> not trivial.  This proposal moves them into spec - ie free.\n\nRight now we don't have double-spend proof propagation, so the\n\"net-split\" attack is actually totally trivial: just broadcast two\ndifferent, mutually incompatible, transactions at the same time. About\nhalf the time the recipient will get the payment, the other half of the\ntime the payment they thought they were going to get is invalidated.\n\nIt's very, very rare for sites to have protection against that;\nblockchain.info's shared-send mixer is one of the few exceptions. But\nthe have access to a whole network monitoring service with connections\nto nodes all over the planet.\n\n> About privacy: I think you are going to inherently disclose which is the\n> change address, because you will decrease the change when you increase the\n> fee.  There is no coin management in the client, and as far as I saw so far,\n> no privacy management of which coins to reduce coin cross linking.  Who's to\n> say the client has 100s of times as many coins as the payment.\n>\n> If people dont want to reveal which is change and which payment, they need\n> to put a big enough fee up front based on a margin over prevailing fee\n> statistics.\n\nIt's not ideal, but it still protects against after-the-fact blockchain\nanalysis.\n\nStatistics is hard - you can't get it right all the time. Besides, what\nhappens when everyone adds a safety margin? Some people can afford to\nwait, so for them starting at a low bid and raises it makes a lot of\nsense.\n\n> Also if the bids are too flexibly different how do you stop both bids being\n> processed (eg one in a block, the next in the next block).\n\nThink about that problem a bit harder. :)\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000220dc3b283e651068535f8e934096cfef35342bc688d8ee578\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130509/09844bd6/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "An initial replace-by-fee implementation is now available",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "John Dillon",
                "Adam Back",
                "Peter Todd"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 14557
        }
    },
    {
        "title": "[Bitcoin-development] 0.8.2rc1 ready for testing",
        "thread_messages": [
            {
                "author": "Gavin Andresen",
                "date": "2013-05-10T15:39:08",
                "message_text_only": "Bitcoin-Qt version 0.8.2 release candidate 1 is now available from:\n  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.8.2/test/\n\nThis is a maintenance release that fixes many bugs and includes\na few small new features.\n\nPlease report bugs using the issue tracker at github:\n  https://github.com/bitcoin/bitcoin/issues\n\n\nHow to Upgrade\n--------------\n\nIf you are running an older version, shut it down. Wait\nuntil it has completely shut down (which might take a few minutes for older\nversions), then run the installer (on Windows) or just copy over\n/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).\n\nIf you are upgrading from version 0.7.2 or earlier, the first time you\nrun 0.8.2 your blockchain files will be re-indexed, which will take\nanywhere from 30 minutes to several hours, depending on the speed of\nyour machine.\n\n0.8.2 Release notes\n===================\n\nFee Policy changes\n------------------\n\nThe default fee for low-priority transactions is lowered from 0.0005 BTC\n(for each 1,000 bytes in the transaction; an average transaction is\nabout 500 bytes) to 0.0001 BTC.\n\nPayments (transaction outputs) of 0.543 times the minimum relay fee\n(0.00005430 BTC) are now considered 'non-standard', because storing them\ncosts the network more than they are worth and spending them will usually\ncost their owner more in transaction fees than they are worth.\n\nNon-standard transactions are not relayed across the network, are not included\nin blocks by most miners, and will not show up in your wallet until they are\nincluded in a block.\n\nThe default fee policy can be overridden using the -mintxfee and -minrelaytxfee\ncommand-line options, but note that we intend to replace the hard-coded fees\nwith code that automatically calculates and suggests appropriate fees in the\n0.9 release and note that if you set a fee policy significantly different from\nthe rest of the network your transactions may never confirm.\n\nBitcoin-Qt changes\n------------------\n\n* New icon and splash screen\n* Improve reporting of synchronization process\n* Remove hardcoded fee recommendations\n* Improve metadata of executable on MacOSX and Windows\n* Move export button to individual tabs instead of toolbar\n* Add \"send coins\" command to context menu in address book\n* Add \"copy txid\" command to copy transaction IDs from transaction overview\n* Save & restore window size and position when showing & hiding window\n* New translations: Arabic (ar), Bosnian (bs), Catalan (ca), Welsh (cy),\n  Esperanto (eo), Interlingua (la), Latvian (lv) and many improvements\n  to current translations\n\nMacOSX:\n* OSX support for click-to-pay (bitcoin:) links\n* Fix GUI disappearing problem on MacOSX (issue #1522)\n\nLinux/Unix:\n* Copy addresses to middle-mouse-button clipboard\n\n\nCommand-line options\n--------------------\n\n* -walletnotify will call a command on receiving transactions that\naffect the wallet.\n* -alertnotify will call a command on receiving an alert from the network.\n* -par now takes a negative number, to leave a certain amount of cores free.\n\nJSON-RPC API changes\n--------------------\n\n* listunspent now lists account and address infromation.\n* getinfo now also returns the time adjustment estimated from your peers.\n* getpeerinfo now returns bytessent, bytesrecv and syncnode.\n* gettxoutsetinfo returns statistics about the unspent transaction\noutput database.\n* gettxout returns information about a specific unspent transaction output.\n\n\nNetworking changes\n------------------\n\n* Significant changes to the networking code, reducing latency and\nmemory consumption.\n* Avoid initial block download stalling.\n* Remove IRC seeding support.\n* Performance tweaks.\n* Added testnet DNS seeds.\n\nWallet compatibility/rescuing\n-----------------------------\n\n* Cases where wallets cannot be opened in another version/installation\nshould be reduced.\n* -salvagewallet now works for encrypted wallets.\n\n\nThanks to everybody who contributed to the 0.8.2 release!\n---------------------------------------------------------\n\nAPerson241\nAndrew Poelstra\nCalvin Owens\nChuck LeDuc D\u00edaz\nColin Dean\nDavid Griffith\nDavid Serrano\nEric Lombrozo\nGavin Andresen\nGregory Maxwell\nJeff Garzik\nJonas Schnelli\nLarry Gilbert\nLuke Dashjr\nMatt Corallo\nMichael Ford\nMike Hearn\nPatrick Brown\nPeter Todd\nPhilip Kaufmann\nPieter Wuille\nRichard Schwab\nRoman Mindalev\nScott Howard\nTariq Bashir\nWladimir J. van der Laan\nfreewil\ngladoscc\nkjj2\nmb300sd"
            }
        ],
        "thread_summary": {
            "title": "0.8.2rc1 ready for testing",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Gavin Andresen"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 4407
        }
    },
    {
        "title": "[Bitcoin-development] 0.8.2rc1 - testnet datadir behavior changed",
        "thread_messages": [
            {
                "author": "Jay F",
                "date": "2013-05-12T06:35:59",
                "message_text_only": "On 5/10/2013 8:39 AM, Gavin Andresen wrote:\n> Bitcoin-Qt version 0.8.2 release candidate 1 is now available from:\n>    http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.8.2/test/\n>\n\nTestnet glitch, something broke...\n\nFired up 0.8.2rc, and .... where's the coins? Where's the blocks?\n\nI get a new empty datadir/testnet3 subdirectory.\n\nbitcoin-qt.exe -datadir=c:\\testnet (with a testnet=1 bitcoin.conf file \noption in that directory) stored wallet/blocks/chainstate in the root \nwith previous versions. Now the root datadir data is ignored (except the \nconfig file) and a new hierarchy was created in subdirectory \n[b]/testnet3[/b].\n\nSo what's happening?\n\nThis looks to be done by https://github.com/bitcoin/bitcoin/issues/2605 \n... after searching the code for the change and then finding the commit.\n\n1 day from opened to committed, released six days later... no changelog.\n\n\nThe datadir previously worked as I expected with both bitcoin-qt and \nbitcoind interacting with no problems, when simply specifying a \ncommand-line datadir, so I don't see the bug.\n\nI can see how the previous behavior might be dangerous if the config \nfile was removed. I just did that, and there's a cool freakout where my \ntestnet wallet balance looks like real BTC and Bitcoin tries to reorg \n67662 blocks starting from the genesis block. After receiving real block \n73354 per debug log, a nice unrecoverable crash:\n\n\"Assertion failed!\"\nFile: src/main.cpp Line 1745\nExpression: pfork != NULL\n\n\nThis needs to be added to the changelog, since dropping in this binary \nwill break testnet stuff if anybody is using Bitcoin this way for their \ntestnet faucet, etc:\n\n\" * testnet data now stored in testnet3 subdirectory, enforced even when \nspecifying datadir on command line (manually move your data first)\""
            },
            {
                "author": "Pieter Wuille",
                "date": "2013-05-12T09:04:09",
                "message_text_only": "On Sun, May 12, 2013 at 8:35 AM, Jay F <jayf at outlook.com> wrote:\n\n> On 5/10/2013 8:39 AM, Gavin Andresen wrote:\n> > Bitcoin-Qt version 0.8.2 release candidate 1 is now available from:\n> >\n> http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.8.2/test/\n> >\n>\n> Testnet glitch, something broke...\n>\n\nI opened   https://github.com/bitcoin/bitcoin/issues/2641 for this issue.\n\n-- \nPieter\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130512/7c294038/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "0.8.2rc1 - testnet datadir behavior changed",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Pieter Wuille",
                "Jay F"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2377
        }
    },
    {
        "title": "[Bitcoin-development] Automated Weekly Testnet Alerts",
        "thread_messages": [
            {
                "author": "bitcoin-list at bluematt.me",
                "date": "2013-05-10T15:49:16",
                "message_text_only": "In order to provide developers with a reasonable way to test their alert-handling code, starting next Thursday, automated weekly alerts will be made on testnet.\nThey will contain the message \"[TEST] This is a test alert broadcast at $TIMESTAMP\" (where $TIMESTAMP is the unix timestamp of initial broadcast), will expire in between 2 and 4 hours and will have varying prioriry.  They will be announced at 13:00 UTC (currently 9am EST).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130510/e1cf1e2c/attachment.html>"
            },
            {
                "author": "Caleb James DeLisle",
                "date": "2013-05-10T18:45:01",
                "message_text_only": "bzzzzzzzzzzzzzzzzzzzzzzt bzzzzzzzzzzzzzzzzzzzzzzzzt bzzzzzzzzzzzzzzzzzzzzzzt\nbzzzzzzzzt bzzzzzzzzzzt bzzzzzzzzzzzt\n\nThis is a test of the emergency broadcast system, if this had been an actual\nemergency, the attention signal you just heard would have been followed by\nofficial information, news or instructions.\n\nbzzzzzzzzt bzzzzzzzzzzt bzzzzzzzzzzzt\n\n\nI'm sorry, I will shut up now.\n\nThanks,\nCaleb\n\n\n\nOn 05/10/2013 11:49 AM, bitcoin-list at bluematt.me wrote:\n> In order to provide developers with a reasonable way to test their alert-handling code, starting next Thursday, automated weekly alerts will be made on testnet.\n> They will contain the message \"[TEST] This is a test alert broadcast at $TIMESTAMP\" (where $TIMESTAMP is the unix timestamp of initial broadcast), will expire in between 2 and 4 hours and will have varying prioriry. They will be announced at 13:00 UTC (currently 9am EST).\n> \n> \n> ------------------------------------------------------------------------------\n> Learn Graph Databases - Download FREE O'Reilly Book\n> \"Graph Databases\" is the definitive new guide to graph databases and \n> their applications. This 200-page book is written by three acclaimed \n> leaders in the field. The early access version is available now. \n> Download your free book today! http://p.sf.net/sfu/neotech_d2d_may\n> \n> \n> \n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            }
        ],
        "thread_summary": {
            "title": "Automated Weekly Testnet Alerts",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "bitcoin-list at bluematt.me",
                "Caleb James DeLisle"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2147
        }
    },
    {
        "title": "[Bitcoin-development] Coinbase TxOut Hashcash",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2013-05-11T04:53:42",
                "message_text_only": "It has been previously(1) proposed that hashcash using the same PoW\nfunction as the Bitcoin block hashing algorithm be used to create\nhashcash whose value is denominated in Bitcoins. This poses two problems\nhowever: widespread use of such hashcash would harm overall network\nsecurity and determining the value of the hashcash requires knowing the\nrevenue miners can gain from transaction fees at a given block height -\na non-computable function. However, with some modifications we can\nextend the idea to directly denominate the hashcash in Bitcoins at the\ncost of a small increase in proof size.\n\nRecall that the fundemental problem is the need to do some work to make\ndigest D have value V, resulting in a proof that can be given to a third\nparty. We want V to be denominated in Bitcoins, and we want the actual\neconomic cost to create P to be as close as possible to the face-value\nV. Finally should computing P result in a valid Bitcoin block header,\nthe creator of the proof should have a strong incentive to publish their\nheader to the P2P network and extend the current best chain.\n\n\n# Proof structure\n\nLets look at the elements of the proof from the block header to the\ndigest.\n\n\n## PoW Block Header\n\nThis must be a valid block header. It is particularly important to\nensure that the header can be linked to the actual blockchain, although\nthe header itself does not need to be a part of the chain, and hence the\nblock hash does not need to meet the difficulty requirements.\n\n\n### Previous Block Headers\n\nThe proof may optionally include one or more previous block headers in\nthe event that the PoW block header's previous block is an orphan.\nUnlike the PoW block header, these block headers MUST meet the\ndifficulty requirements although an implementation MAY skip actually\nchecking the difficulty if a difficulty retarget has not happened or the\nPoW is timestamped. (see below)\n\n\n## Partial Transaction and Merkle Path\n\nThe partial transaction consists of a SHA256 midstate followed by\nexactly one transaction output. The merkle path to the PoW block header\nMUST prove the transaction was the coinbase transaction and not any\nother transaction.\n\n\n## Transaction Output\n\nThe last transaction output must have a scriptPubKey consisting of\nexactly one PUSHDATA op which pushes H(D | N) to the stack. Its value,\nV', is the basis for determining the value of the proof of work. V' must\nsatisfy V' < k*Vi(h) where Vi is the inflation reward for the PoW block\nheight and k < 1 For a number of reasons, including making sure there\nare strong incentives for broadcasting succesful PoW solutions, the\nvalue of k should be chosen fairly conservatively; the author suggests k\n= 1/10 as a ballpark figure. Finally N is some fixed value specific to\nhashcash of this form to ensure the txout proof can-not be reused.\n\nVi can also be calculated as the median of the last n \"anyone-can-spend\"\noutputs seen in coinbases when the value of the inflation reward falls\nlow enough that using the inflation reward is impractical.\n\n\n## Timestamp\n\nIf the proof-of-work is used after a difficulty retarget the PoW needs\nto be timestamped in the block chain with a merkle path leading to a\nvalid block header. The difficulty used for calculating the value of the\nPoW then becomes the minimum of the difficulties of the PoW previous\nblock and the timestamp.\n\n\n# Determining the actual value of the PoW\n\nThe proof proves that work was done to find a valid block header. That\nblock header, had it met the difficulty threshhold, could have created a\nvalid block worth at least the inflationary reward Vi(h) to the miner.\n\nThe coinbase transaction output and merkle path shows that were such a\nblock found, the miner would have then given away V' to whomever managed\nto create a transaction spending it when the coinbase matured. The\ncoinbase takes 100 block to mature, so the chance of any one miner\ncollecting it is proportional to the hashing power they control.(*)\n\n*) As with fidelity bonds we make the assumption that no party controls\nmore than 50% of the hashing power - the assumption underlying Bitcoin's\nsecurity anyway. If this assumption is proven incorrect or\ninsufficiently strong, possibly due to a cartel of miners banding\ntogether to create low-cost PoW's, the output can use the provably\nunspendable/prunable OP_RETURN <digest> scriptPubKey instead with a\nnon-zero value.\n\nWith P(block hash, target), the expected probability of a valid PoW\nbeing found given the work required to create the block hash with the\ngiven difficulty target, we can finally calculate the value of the PoW\nin terms of expected cost: V = P(hash, target) * V'\n\n\n# Pool implementation and 51% attack security\n\nBecause doing the work required to create coinbase txout hashcash is\nsufficient to also create a valid block a pool can safely rent out\nhashing power to create hashcash of this form on demand without making\nit possible to rent large amounts of hashing power directly on short\nnotice. (though some extensions to GetBlockTemplate for hashers\nverifying it may be required)\n\nBecause the anyone-can-spend txout is the basis for the value of the\nhashcash the value remains computable even if transaction fees become a\nlarger proportion of the block reward in the future.\n\nUnlike announce-commit sacrificies(2) proofs with very small values can\nbe easily created; the pool operator can make a trade-off between the\nprofit varience - remember that a block header with a valid PoW\nrepresents a loss - and latency by adjusting the proof of work\ndifficulty and V'.\n\nAs an aside, note how the mechanism of a anyone-can-spend txout in a\ncoinbase can replace the announce portion of an announce-commit\nsacrifice; a coinbase transaction is the only case where a single merkle\npath proves that the transaction output was possible to spend in a\nsubsequent block, but was not yet spent; also an argument for allowing\ncoinbase transaction inputs.\n\n\n# Application: Paying for additional flood-fill bandwidth\n\nAdditional messaging applications built on top of the Bitcoin P2P\nnetwork would be useful, yet there needs to be some general mechanism to\nmake DoS attacks expensive enough that they are impractical. For\ninstance a useful P2P network feature would be a mechanism to propose\ntrust-free coin mixes transaction outputs, propose specific txout sets,\nand finally a mechanism to broadcast valid ANYONECANPAY signatures so\nthe inputs and outputs can become a valid transaction. By separating the\ntxout and signature broadcasts, who is paying for what output is made\nvery difficult to determine.\n\nOf course such a mechanism will likely come under attack by those trying\nto combat anonymity. However with the coinbase txout hashcash mechanism\nthose attackers are forced to either contribute to the security of the\nBitcoin network or incur much higher opporuntity costs for conducting\ntheir attack than honest nodes pay. (remember how the choice of k = 10\nmakes for a large ratio of maximum V' value to Vi(h) inflation reward)\n\nTo reduce amortized proof size one proof can be used for multiple\npayments with Rivest PayWords and similar techniques.\n\n\n# PowPay - Off-chain, anonymous, probabalistic payments\n\nBy setting the special txout to a scriptPubKey spendable by the\nrecipient we can prove to a third party that work was done that with\nprobability P(hash,target) could have resulted in a txout spendable by\nthem of value V' Thus the expected value of the payment is V = P(h,t)*V'\nThe recipient needs to make the proof non-reusable, either by recording\nall proofs submitted, or by requiring a nonce in the scriptPubKey: (*)\n\n    <nonce> DROP {additional ops}\n\n*) Note the implications for the IsStandardInput() test.\n\nBecause the recipient has no way of knowing how the sender paid to have\nthe hashing done on their behalf the source of the funds is unknown to\nthem. Additionally the payment can be of any amount less than a full\nblock reward, and the time varient between actual payments can be\nreduced to, in theory, as little as the block interval itself with 100%\nminer participation.\n\n\n## Maximum Payment amount\n\nUnlike coinbase txout hashcash the maximum value of a PowPay transaction\nis strictly limited by the inflation reward; the trick of calculating\nactual cost by prior sacrifices doesn't work because no honest sacrifice\nis involved. In any case it is desirable for the mechanism to account\nfor a large percentage of total transaction value.\n\nThe issue is that should a valid block be found either the miner must\nstill have a strong incentive to broadcast that block that can be proven\nto the recipient, or the miner must not be the one who controls that\ndecision.\n\nThe latter option is possible by inverting the relationship: now the\nrecipient constructs the block, and the sender simply arranges for a\nvalid PoW to be created - essentially the recipient acts as a mining\npool with an extremely high minimum work, and the sender provides\nhashing power. With the 1MB blocksize the cost to operate the full\nvalidating node required is low and attacks on block propagation are\ndifficult to successfully pull off.\n\n\n### Supporting PowPay volume in excess of inflation reward + tx fees\n\nTo support overall PowPay volumes that are in excess of the inflation\nreward and transaction fees the sender can provide the recipient with\nsigned transaction inputs subject to the constraint that only blocks\nwith PoW's generated by the sender can be used to spend them. For\ninstance a nonce in a well-known place can be provided by the sender and\nincluded in a modified block header. By modifying the block hashing\nalgorithm so that PoW-withholding is not possible - a significantly more\nserious problem in this application - the sender still is forced to send\nall potential solutions to the recipient, including possible winning\nones. Provided that attacking block propagation is difficult the sender\ncan't prevent the reciver from spending their transaction inputs.\n\n\n## Scalability\n\nPowPay can provide much greater scalability than Bitcoin itself, in\nterms of payments per second, however it is still limited in terms of\nactual fund transfers to recipients per second. A naive implementation\nwould give a actual transfer every ten minutes maximum, and a highly\nsophisticated solution 7/second. (albeit probably requiring a hardfork\nto solve PoW withholding and/or use of third parties)\n\nAt the same time the proofs required become large with an increased\nblocksize, and in the case of the inverted \"recipient builds blocks\"\nmode the recipients either incur large costs running full nodes, or\ngreatly disrupt transaction flow for on-chain users by mining blocks\nwith no transactions in them at all. (remember that a recipient who\ntrusts someone else to construct the blocks for them is trusting that\nthird-party to do so correctly)\n\nThe latter is especially problematic because as the blocksize is\nincreased a higher percentage of the cost of mining goes to the overhead\nrequired to run a validating node, rather than hashing, which has the\nperverse effect of decreasing the cost of mining blocks with no\ntransactions in them at all. (or transactions that the miner knows have\nnot been revealed to other miners)\n\nThe analysis of this strange mixed bag of incentives is highly complex.\n\n\n# Paying for mining\n\nTxOut HashCash and PayPow both require the sender to somehow get someone\nto mine on their behalf. The exact nature of these relationships will\nvary and are beyond the scope of this paper.\n\n\n# Eliminating PoW withholding\n\nWhile the above examples have used economic incentives possible within\nthe existing Bitcoin system a structural incentive is possible as well.\nA nonce N is chosen by the party paying for the PoW, such as a pool or\nPowPay recipient, and H(n) is included in the block header.(*) The PoW\nfunction is then modified to consider the PoW valid if the sum of the\nexpected hashes required to find H(B) and H(B | n) exceeds the current\ndifficulty target.\n\n*) Note how the block header can be extended, while remaining fairly compatible\nwith existing ASIC mining hardware, by taking advantage of the fact that\nASIC's use the SHA256 midstate at a starting point for their PoW\ncalculations.(3)\n\n\n\n\n1) \"Re: [Bitcoin-development] Discovery/addr packets (was: Service bits\nfor pruned nodes)\" - 2013-06-06 - Peter Todd <pete at petertodd.org> -\nbitcoin-development email list\n\n2) \"Purchasing fidelity bonds by provably throwing away bitcoins\" -\nhttps://bitcointalk.org/index.php?topic=134827.0 - Peter Todd\n\n3) \"Re: 32 vs 64-bit timestamp fields\" - 2013-06-09 - John Dillon\n<john.dillon892 at gmail.com> - bitcoin-development email list\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000039e49118426bbe6739360d35116e920d6502dcacd8e51bc74c\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130511/70986c05/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Coinbase TxOut Hashcash",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Peter Todd"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 12982
        }
    },
    {
        "title": "[Bitcoin-development] merged mining hashcash & bitcoin (Re: Coinbase TxOut Hashcash)",
        "thread_messages": [
            {
                "author": "Adam Back",
                "date": "2013-05-11T10:22:09",
                "message_text_only": "I didnt quite understand the writeup and the references were ambiguous.\n\nBut if you are talking about bitcoin/hashcash merged mining for email: it is\nsomething I think should possible.  Of course for email the scale means\nbitcoin style flood-fill and direct tiny payments are completely out of the\nquestion, thats why hashcash itself has no communication overhead other than\na header in the mail - its only scalability limit is email itself.\n\nRivest's PayWord for people who dont know the reference in this context is\nthe observation that for a low value micro-payment, you dont mind if you\nonly receive a payment 1 time in k so long as the expected payment is n\nafter receiving n (eg satoshi sized) payments.  Eg like a penny tip jar so\nlong as your expected payment is correct long term (win as often as you\nlose) you dont mind.  And a fair 100% payout lottery can be fun of itself.\n\nSo let say each email client sends in an email header the head of the\nbitcoin hash chain, it has seen via other emails, which can be offline\nverified back to the genesis hash.  Maybe some clients even have bitcoin\ninstalled and ask the bitcoin client for the hash chain head.  The client\nalso generates an address on setup, and sends its bitcoin address in a\nheader.  If you send to a new address you dont know their address, so you\nsend to eg me (Adam;) as a default, or the bitcoin foundation, or an invalid\naddress to destroy the coin - the recipient assumes that is not the sender\nas those address are in the client.  A sender can under-contribute but makes\nno gain.  Under-contributing is fixable if desired (see under-contribute in\namortizable hashcash paper, but using PK decryption with recipients private\nkey x as its non-interactive b'=D(x,share).) \n\nThen clients merge mine involving the recipients bitcoin address (or one of\nthe default addresses).\n\nEven if the merged stamp provdes to be an orphan, even a very old one, its\nvalid in a hashcash anti-spam sense, meeting the same purpose as destroyed\ncoin.\n\nMaybe one can put the bitcoin hash in DNS with a 5min TTL and have mail\nclients read that to reduce scope for stale mining.\n\nIn this way one can merge mine bitcoin & hashcash to the benefit of the\nrecipient (or some beneficiary trusted not to be paying the proceeds to the\nspammer).  And in a way that scales to email scale, and does not involve\ninstalling a bitcoin client in every client, nor mail server.\n\nAdam\n\nOn Sat, May 11, 2013 at 12:53:42AM -0400, Peter Todd wrote:\n>It has been previously(1) proposed that hashcash using the same PoW\n>function as the Bitcoin block hashing algorithm be used to create\n>hashcash whose value is denominated in Bitcoins. This poses two problems\n>however: widespread use of such hashcash would harm overall network\n>security and determining the value of the hashcash requires knowing the\n>revenue miners can gain from transaction fees at a given block height -\n>a non-computable function. However, with some modifications we can\n>extend the idea to directly denominate the hashcash in Bitcoins at the\n>cost of a small increase in proof size.\n>\n>Recall that the fundemental problem is the need to do some work to make\n>digest D have value V, resulting in a proof that can be given to a third\n>party. We want V to be denominated in Bitcoins, and we want the actual\n>economic cost to create P to be as close as possible to the face-value\n>V. Finally should computing P result in a valid Bitcoin block header,\n>the creator of the proof should have a strong incentive to publish their\n>header to the P2P network and extend the current best chain.\n>\n>\n># Proof structure\n>\n>Lets look at the elements of the proof from the block header to the\n>digest.\n>\n>\n>## PoW Block Header\n>\n>This must be a valid block header. It is particularly important to\n>ensure that the header can be linked to the actual blockchain, although\n>the header itself does not need to be a part of the chain, and hence the\n>block hash does not need to meet the difficulty requirements.\n>\n>\n>### Previous Block Headers\n>\n>The proof may optionally include one or more previous block headers in\n>the event that the PoW block header's previous block is an orphan.\n>Unlike the PoW block header, these block headers MUST meet the\n>difficulty requirements although an implementation MAY skip actually\n>checking the difficulty if a difficulty retarget has not happened or the\n>PoW is timestamped. (see below)\n>\n>\n>## Partial Transaction and Merkle Path\n>\n>The partial transaction consists of a SHA256 midstate followed by\n>exactly one transaction output. The merkle path to the PoW block header\n>MUST prove the transaction was the coinbase transaction and not any\n>other transaction.\n>\n>\n>## Transaction Output\n>\n>The last transaction output must have a scriptPubKey consisting of\n>exactly one PUSHDATA op which pushes H(D | N) to the stack. Its value,\n>V', is the basis for determining the value of the proof of work. V' must\n>satisfy V' < k*Vi(h) where Vi is the inflation reward for the PoW block\n>height and k < 1 For a number of reasons, including making sure there\n>are strong incentives for broadcasting succesful PoW solutions, the\n>value of k should be chosen fairly conservatively; the author suggests k\n>= 1/10 as a ballpark figure. Finally N is some fixed value specific to\n>hashcash of this form to ensure the txout proof can-not be reused.\n>\n>Vi can also be calculated as the median of the last n \"anyone-can-spend\"\n>outputs seen in coinbases when the value of the inflation reward falls\n>low enough that using the inflation reward is impractical.\n>\n>\n>## Timestamp\n>\n>If the proof-of-work is used after a difficulty retarget the PoW needs\n>to be timestamped in the block chain with a merkle path leading to a\n>valid block header. The difficulty used for calculating the value of the\n>PoW then becomes the minimum of the difficulties of the PoW previous\n>block and the timestamp.\n>\n>\n># Determining the actual value of the PoW\n>\n>The proof proves that work was done to find a valid block header. That\n>block header, had it met the difficulty threshhold, could have created a\n>valid block worth at least the inflationary reward Vi(h) to the miner.\n>\n>The coinbase transaction output and merkle path shows that were such a\n>block found, the miner would have then given away V' to whomever managed\n>to create a transaction spending it when the coinbase matured. The\n>coinbase takes 100 block to mature, so the chance of any one miner\n>collecting it is proportional to the hashing power they control.(*)\n>\n>*) As with fidelity bonds we make the assumption that no party controls\n>more than 50% of the hashing power - the assumption underlying Bitcoin's\n>security anyway. If this assumption is proven incorrect or\n>insufficiently strong, possibly due to a cartel of miners banding\n>together to create low-cost PoW's, the output can use the provably\n>unspendable/prunable OP_RETURN <digest> scriptPubKey instead with a\n>non-zero value.\n>\n>With P(block hash, target), the expected probability of a valid PoW\n>being found given the work required to create the block hash with the\n>given difficulty target, we can finally calculate the value of the PoW\n>in terms of expected cost: V = P(hash, target) * V'\n>\n>\n># Pool implementation and 51% attack security\n>\n>Because doing the work required to create coinbase txout hashcash is\n>sufficient to also create a valid block a pool can safely rent out\n>hashing power to create hashcash of this form on demand without making\n>it possible to rent large amounts of hashing power directly on short\n>notice. (though some extensions to GetBlockTemplate for hashers\n>verifying it may be required)\n>\n>Because the anyone-can-spend txout is the basis for the value of the\n>hashcash the value remains computable even if transaction fees become a\n>larger proportion of the block reward in the future.\n>\n>Unlike announce-commit sacrificies(2) proofs with very small values can\n>be easily created; the pool operator can make a trade-off between the\n>profit varience - remember that a block header with a valid PoW\n>represents a loss - and latency by adjusting the proof of work\n>difficulty and V'.\n>\n>As an aside, note how the mechanism of a anyone-can-spend txout in a\n>coinbase can replace the announce portion of an announce-commit\n>sacrifice; a coinbase transaction is the only case where a single merkle\n>path proves that the transaction output was possible to spend in a\n>subsequent block, but was not yet spent; also an argument for allowing\n>coinbase transaction inputs.\n>\n>\n># Application: Paying for additional flood-fill bandwidth\n>\n>Additional messaging applications built on top of the Bitcoin P2P\n>network would be useful, yet there needs to be some general mechanism to\n>make DoS attacks expensive enough that they are impractical. For\n>instance a useful P2P network feature would be a mechanism to propose\n>trust-free coin mixes transaction outputs, propose specific txout sets,\n>and finally a mechanism to broadcast valid ANYONECANPAY signatures so\n>the inputs and outputs can become a valid transaction. By separating the\n>txout and signature broadcasts, who is paying for what output is made\n>very difficult to determine.\n>\n>Of course such a mechanism will likely come under attack by those trying\n>to combat anonymity. However with the coinbase txout hashcash mechanism\n>those attackers are forced to either contribute to the security of the\n>Bitcoin network or incur much higher opporuntity costs for conducting\n>their attack than honest nodes pay. (remember how the choice of k = 10\n>makes for a large ratio of maximum V' value to Vi(h) inflation reward)\n>\n>To reduce amortized proof size one proof can be used for multiple\n>payments with Rivest PayWords and similar techniques.\n>\n>\n># PowPay - Off-chain, anonymous, probabalistic payments\n>\n>By setting the special txout to a scriptPubKey spendable by the\n>recipient we can prove to a third party that work was done that with\n>probability P(hash,target) could have resulted in a txout spendable by\n>them of value V' Thus the expected value of the payment is V = P(h,t)*V'\n>The recipient needs to make the proof non-reusable, either by recording\n>all proofs submitted, or by requiring a nonce in the scriptPubKey: (*)\n>\n>    <nonce> DROP {additional ops}\n>\n>*) Note the implications for the IsStandardInput() test.\n>\n>Because the recipient has no way of knowing how the sender paid to have\n>the hashing done on their behalf the source of the funds is unknown to\n>them. Additionally the payment can be of any amount less than a full\n>block reward, and the time varient between actual payments can be\n>reduced to, in theory, as little as the block interval itself with 100%\n>miner participation.\n>\n>\n>## Maximum Payment amount\n>\n>Unlike coinbase txout hashcash the maximum value of a PowPay transaction\n>is strictly limited by the inflation reward; the trick of calculating\n>actual cost by prior sacrifices doesn't work because no honest sacrifice\n>is involved. In any case it is desirable for the mechanism to account\n>for a large percentage of total transaction value.\n>\n>The issue is that should a valid block be found either the miner must\n>still have a strong incentive to broadcast that block that can be proven\n>to the recipient, or the miner must not be the one who controls that\n>decision.\n>\n>The latter option is possible by inverting the relationship: now the\n>recipient constructs the block, and the sender simply arranges for a\n>valid PoW to be created - essentially the recipient acts as a mining\n>pool with an extremely high minimum work, and the sender provides\n>hashing power. With the 1MB blocksize the cost to operate the full\n>validating node required is low and attacks on block propagation are\n>difficult to successfully pull off.\n>\n>\n>### Supporting PowPay volume in excess of inflation reward + tx fees\n>\n>To support overall PowPay volumes that are in excess of the inflation\n>reward and transaction fees the sender can provide the recipient with\n>signed transaction inputs subject to the constraint that only blocks\n>with PoW's generated by the sender can be used to spend them. For\n>instance a nonce in a well-known place can be provided by the sender and\n>included in a modified block header. By modifying the block hashing\n>algorithm so that PoW-withholding is not possible - a significantly more\n>serious problem in this application - the sender still is forced to send\n>all potential solutions to the recipient, including possible winning\n>ones. Provided that attacking block propagation is difficult the sender\n>can't prevent the reciver from spending their transaction inputs.\n>\n>\n>## Scalability\n>\n>PowPay can provide much greater scalability than Bitcoin itself, in\n>terms of payments per second, however it is still limited in terms of\n>actual fund transfers to recipients per second. A naive implementation\n>would give a actual transfer every ten minutes maximum, and a highly\n>sophisticated solution 7/second. (albeit probably requiring a hardfork\n>to solve PoW withholding and/or use of third parties)\n>\n>At the same time the proofs required become large with an increased\n>blocksize, and in the case of the inverted \"recipient builds blocks\"\n>mode the recipients either incur large costs running full nodes, or\n>greatly disrupt transaction flow for on-chain users by mining blocks\n>with no transactions in them at all. (remember that a recipient who\n>trusts someone else to construct the blocks for them is trusting that\n>third-party to do so correctly)\n>\n>The latter is especially problematic because as the blocksize is\n>increased a higher percentage of the cost of mining goes to the overhead\n>required to run a validating node, rather than hashing, which has the\n>perverse effect of decreasing the cost of mining blocks with no\n>transactions in them at all. (or transactions that the miner knows have\n>not been revealed to other miners)\n>\n>The analysis of this strange mixed bag of incentives is highly complex.\n>\n>\n># Paying for mining\n>\n>TxOut HashCash and PayPow both require the sender to somehow get someone\n>to mine on their behalf. The exact nature of these relationships will\n>vary and are beyond the scope of this paper.\n>\n>\n># Eliminating PoW withholding\n>\n>While the above examples have used economic incentives possible within\n>the existing Bitcoin system a structural incentive is possible as well.\n>A nonce N is chosen by the party paying for the PoW, such as a pool or\n>PowPay recipient, and H(n) is included in the block header.(*) The PoW\n>function is then modified to consider the PoW valid if the sum of the\n>expected hashes required to find H(B) and H(B | n) exceeds the current\n>difficulty target.\n>\n>*) Note how the block header can be extended, while remaining fairly compatible\n>with existing ASIC mining hardware, by taking advantage of the fact that\n>ASIC's use the SHA256 midstate at a starting point for their PoW\n>calculations.(3)\n>\n>\n>\n>\n>1) \"Re: [Bitcoin-development] Discovery/addr packets (was: Service bits\n>for pruned nodes)\" - 2013-06-06 - Peter Todd <pete at petertodd.org> -\n>bitcoin-development email list\n>\n>2) \"Purchasing fidelity bonds by provably throwing away bitcoins\" -\n>https://bitcointalk.org/index.php?topic=134827.0 - Peter Todd\n>\n>3) \"Re: 32 vs 64-bit timestamp fields\" - 2013-06-09 - John Dillon\n><john.dillon892 at gmail.com> - bitcoin-development email list\n>\n>-- \n>'peter'[:-1]@petertodd.org\n>0000000000000039e49118426bbe6739360d35116e920d6502dcacd8e51bc74c\n\n\n\n>------------------------------------------------------------------------------\n>Learn Graph Databases - Download FREE O'Reilly Book\n>\"Graph Databases\" is the definitive new guide to graph databases and\n>their applications. This 200-page book is written by three acclaimed\n>leaders in the field. The early access version is available now.\n>Download your free book today! http://p.sf.net/sfu/neotech_d2d_may\n\n>_______________________________________________\n>Bitcoin-development mailing list\n>Bitcoin-development at lists.sourceforge.net\n>https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "John Dillon",
                "date": "2013-05-13T07:31:21",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nOn Sat, May 11, 2013 at 10:22 AM, Adam Back <adam at cypherspace.org> wrote:\n> I didnt quite understand the writeup and the references were ambiguous.\n\nNo you didn't. :)\n\nWhat is special about what Peter is proposing is that it is *not* merge-mining.\nYou see, merge-mining is essentially where you use one PoW for two purposes,\ntwo different blockchains. So you are getting more value from just one unit of\nwork.\n\nBut Peter's coinbase hashcash protocol carefully ensures that the act of mining\nthe hashcash is guaranteed to cost the miner at least some well-defined amount,\nand that amount can be easily calculated by considering the probability that a\nblock could have been found with the effort required to generate the proof of\nwork, and the amount of value the miner would have then given away in a\n\"anyone-can-spend\" output. (you may not realize this, but a scriptPubKey with a\nsingle pushdata opcode is always evaluated as true, which means it can be\nrespent by anyone)\n\nDon't feel bad though, I had to ask him to explain it to me too. :)\n\n> Rivest's PayWord for people who dont know the reference in this context is\n> the observation that for a low value micro-payment, you dont mind if you\n> only receive a payment 1 time in k so long as the expected payment is n\n> after receiving n (eg satoshi sized) payments.  Eg like a penny tip jar so\n> long as your expected payment is correct long term (win as often as you\n> lose) you dont mind.  And a fair 100% payout lottery can be fun of itself.\n\nI think you are misremembering. I just checked the paper and PayWord is based\non chains of hashes and you give the receiver a digest and if after n repeated\nhashes it is considered to have been worth n*k It is not a probabalistic\nscheme.\n\nIncedentally while it is an obvious enough idea, though I didn't see a\nreference to it, PayWords can be easily extended with a time-bandwidth\ntrade-off by using a structure similar to a merkle tree. The roots could be\ncreated from some fixed nonce K and a increaing integer, H(K | n) Then you\nwould provide a merkle path to the previously agreed upon final digest. So\nproof size for your payment would be log(n), and time to check the proof\nlog(n). Unfortunately setting up the scheme is still 2*n however that only\nneeds to be done once.\n\n> So let say each email client sends in an email header the head of the\n\nI have to respect a man who after all these years is still thinking\nabout anti-spam for email. :)\n\n> Maybe one can put the bitcoin hash in DNS with a 5min TTL and have mail\n> clients read that to reduce scope for stale mining.\n\nPeter actually made a blockchain headers over DNS system, and a blockchain\nheaders over twitter system as an April fools joke. See\nhttps://twitter.com/blockheaders\n\n> In this way one can merge mine bitcoin & hashcash to the benefit of the\n> recipient (or some beneficiary trusted not to be paying the proceeds to the\n> spammer).  And in a way that scales to email scale, and does not involve\n> installing a bitcoin client in every client, nor mail server.\n\nBlockchain header data may very well be one of the most widely distributed\nsingle data sets in the history of mankind, and most of its closest cousins are\ndefinitions such as the ASCII table or near definitions like the DNS root\nservers. Not something with new data every 10 minutes.\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\n\niQEcBAEBCAAGBQJRkJZoAAoJEEWCsU4mNhiPtscIAL4eM+reWCfAjw0FAv5c5lwQ\ntJvuVgmkCVyVurQLFbMt0hxXiYAFeTJ31uW0QBEdvitzIUAWR4QO/wfqNULAdZoA\nRzTCOBTjfFFGQLd7UdRuDSSEvq23oeJCoixbtdGpAmM1ySRvCExkO+fYehNqXEDN\nFF1PVv9VPc5KXbDw3mB6l8dkMCLEHmYpkdrNRvHHQMhyLXO8q3Q6H3zDy3YbztZC\nrxibYprOtF1Z2dZzIYTWaGoA9ONLqSgOU2J1htj6kastsjW1d3XKIkdU/eRP2cEs\nCG2EWyyrm59e4zpYL4BJj0zBMW9+pQQsSvrAtAoAFVdLojsAWBVL0PIQ8h8N6SY=\n=+ptH\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Adam Back",
                "date": "2013-05-13T10:54:08",
                "message_text_only": "On Mon, May 13, 2013 at 07:31:21AM +0000, John Dillon wrote:\n>[with] merge-mining [you get] more value from just one unit of work.\n\ncorrect.\n\n>But Peter's coinbase hashcash protocol carefully ensures [...] the amount\n>of value the miner would have then given away in a \"anyone-can-spend\"\n>output.\n\nI think there are 3 choices:\n\n1. merged-mine (almost zero incremental cost as the bitcoin mining return is\n    still earned)\n\n2. destroy bitcoin (hash of public key is all 00s so no computible private\n    key)\n\n3. anyone-can-spend (= first to spend gets coin?)\n\nSurely in 3 if you mine the bitcoin its no particular assurance a you will\ndo your best to make sure that it is *you* tht spends it, so it devolves to\nmerged-mine.  (Eg delay revealing it for 10 seconds while you broadcast your\nspend widely)\n\nPeter talks about value, but the proof only proves cost equal to bitcoin. \nThose are not the same thing.  And they are so-far non-respendable.\n\nI still dont understand what he was saying.  If you do please speakup.\n\n\nI think potentially a publicly auditable pooled mining protocol would be a\nplace to start thinking about respendble micropayments.  I made a post\non the bitcointalk forum outlining how that could be done:\n\nhttps://bitcointalk.org/index.php?topic=1976.msg2035637#msg2035637\n\nif you have a publicly auditable pool, where users can prove to each other\noutside of the bitcoin transaction log that they contributed a number of\nshares to a block, those could be traded somehow.  Possibly eg with the pool\nkeeping a double-spend db.  If the payments are low value, people maybe\nhappy trusting a pool.  If the pool cheats, everyone stops using the pool. \nYou rely on the pool not to spend the backing bitcoin blocks.  But it\nremains possible for the pool to cashout people who collected enough shares. \nProbably you could do that with blinding if desired.\n\n>> [probabilistic micro-payments]\n>\n>I think you are misremembering [...] It is not a probabalistic scheme.\n\nYou are right I was thinking of Rivest's peppercoin.\n\n>> In this way one can merge mine bitcoin & hashcash to the benefit of the\n>> recipient (or some beneficiary trusted not to be paying the proceeds to the\n>> spammer).  And in a way that scales to email scale, and does not involve\n>> installing a bitcoin client in every client, nor mail server.\n>\n>Blockchain header data may very well be one of the most widely distributed\n>single data sets in the history of mankind, and most of its closest cousins are\n>definitions such as the ASCII table or near definitions like the DNS root\n>servers. Not something with new data every 10 minutes.\n\nWell there doesnt need to be a one-true-blockchain DNS, though the power to\noutput a hash at any reasonable rate is a big proportion of the network\npower.  And the outputs are instantly verifiable, so it forms a kind of\ntrapdoor hashchain (where the trap door is not a secret but havng a huge\namount of CPU power).  And there can and should be many blockchain via DNS.\n\nFor namesaces in general another approach other than DHT/flood is numerous\ncompeting hierarchical, heavily cached, but publicly auditable.  Cheaters\nare shunned.  Same effect, more scalable, most people are not cheating most\nof the time.\n\nhttp://cypherspace.org/p2p/auditable-namespace.html\n\nAdam"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-05-13T18:38:15",
                "message_text_only": "On Mon, May 13, 2013 at 6:54 AM, Adam Back <adam at cypherspace.org> wrote:\n> On Mon, May 13, 2013 at 07:31:21AM +0000, John Dillon wrote:\n>>[with] merge-mining [you get] more value from just one unit of work.\n>\n> correct.\n>\n>>But Peter's coinbase hashcash protocol carefully ensures [...] the amount\n>>of value the miner would have then given away in a \"anyone-can-spend\"\n>>output.\n>\n> I think there are 3 choices:\n>\n> 1. merged-mine (almost zero incremental cost as the bitcoin mining return is\n>     still earned)\n>\n> 2. destroy bitcoin (hash of public key is all 00s so no computible private\n>     key)\n>\n> 3. anyone-can-spend (= first to spend gets coin?)\n\nDon't forget:  4. destroy-via-miner-fee, which is useful because it\nprovides funding for a public service (bitcoin transaction\nverification).\n\n(a tangent, but related)\n\nI've been thinking about a decentralized way to create an anonymous\nidentity, something I think it key to any number of decentralized, P2P\nand anonymous markets.  My main focus, for this identity project, is\nto develop a decentralized protocol for generating a UUID-like unique\nidentifier (bitstring), in a way that has some amount of creation cost\nattached (to prevent creating a billion of such tokens etc.).  I call\nit a system identifier, or SIN.\n\nOnce you have a SIN, you may associate the SIN with a GPG fingerprint,\nemail address, real name, login credentials, etc.  eBay-like\nmarketplaces publish SIN ratings (though it displays on screen as\n\"jgarzik\" not \"1234-abcd-5678-def0\").  Standard-and-Poors style\nratings agencies would similarly rate a business's SIN.  SIN's build a\nreputation and trust over time, while controlling their own anonymity\n(or lack thereof).  Anybody may abandon a SIN at any time. Ownership\nof a SIN is cryptographically proven via digital signature.\n\nGetting back on topic, somewhat, one idea I had for creation cost of a\nSIN was associating the creation cost of a SIN with a bitcoin\ntransaction's miner fee.  Anybody in the world could, therefore,\ncreate a SIN in a decentralized fashion, simply by following a\npublished protocol for burning a specified amount of bitcoins via\nminer fee.  It can be cryptographically proven with 100% certainty who\nmade such a transaction, and the miner fee attaches a creation cost to\nensure that SINs are not -too- cheap.\n\nBurn-via-miner-fee is a useful tool outside of this example.  It funds\na public service, providing a positive feedback loop for miners who\nreceive fees via such services.\n\n-- \nJeff Garzik\nexMULTI, Inc.\njgarzik at exmulti.com"
            },
            {
                "author": "Adam Back",
                "date": "2013-05-13T21:12:44",
                "message_text_only": "Some musings about the differences between Peter's proof-of-sacrifice (you\ndid the work but elected to make the small reward chance unclaimable), vs\nconventional actually doing the work but then destroying the bitcoin!\n\n- proof-of-sacrifice seems similiar to hashcash except its difficulty is\n   time stamped and measured against the bitcoins dynamic difficulty,\n   (coordinated inflation control being something posited but never\n   implemented in hashcash).  So thats kind of interesting, particularly if\n   you can do it with very low bandwidth, and decentralized; unclear.\n\n- with proof-of-sacrifice its more offline because you do not need an on\n   block-chain double spend protection (via flood-fill, validation, and block\n   chain mining) because it is simply \"unspendable\", though you could show\n   the same proof to multiple people.  In any case the values are far too low\n   to spam the block chain with.\n\n- because proof-of-sacrifice is small you can afford to mine them on the\n   spot and make them payable to the identity of the recipient, like cheques:\n   they identify the recipient, so they are automaticaly non-respendable in\n   the eyes of the recipient (he keeps his own double-spend db, and people\n   wont accept cheques made payabe to other people).  This is how hashcash\n   works for email.  Also a time-stamp ensures you dont even need a big\n   double-spend db, as you can prune it if you reject expired cheqes.\n\n- you could give a proof-of-sacrifice a private key, just like bitcoins;\n   then they could be pre-mined and identity or other info could be signed\n   later.  However then you have double spending issues again.  You can \n\n- I mentioned amortizable hashcash under-contribution feature you can make\n   it so the recipient uncovers the actual value of the coin (if it is\n   merge-mined).  (Put recipient public key in coinbase, hash for min share\n   size eg 32-bits leading 0s call that \"collision\"; send to recipient, he\n   decrypts the hash with private key, so the decryption is verifiable with\n   public key.  Then the full value of the coin is \n\t   zerobit( collision ) + zerobits( decrypt( collision ) )\n   if that alternate validation was allowed in bitcoin.\n\n- what about if a pool could lock the reward (rather than receive it or\n   destroy it) eg some kind of merkle root instead of a public key hash in\n   the reward recipient address field in the coinbase.  Then the miners who\n   created that block have actual share proofs that are claims against\n   something eventually redeemable.  Maybe if they collect enough\n   share-proofs to reach a minimum bitcoin transaction size, they can redeem\n   a big strip of shares for a few mBTC, but claims below that are rejected\n   by the network due to tx fee.  (btw I think it seems possible to have a\n   publicly auditable pool so it cant skim nor disclaim shares.)\n\n>I've been thinking about a decentralized way to create an anonymous\n>identity, something I think it key to any number of decentralized, P2P\n>and anonymous markets.  \n\nThere were some systems that charged hashcash for pseudonyms i2p names (i2p\nis a ToR like system)...  see htp://www.i2p2.e/naming.html then there was of\ncourse namecoin.  There was some remailer/email nymserver integration as\nwell.\n\n>Getting back on topic, somewhat, one idea I had for creation cost of a\n>SIN was associating the creation cost of a SIN with a bitcoin\n>transaction's miner fee.  Anybody in the world could, therefore,\n>create a SIN in a decentralized fashion, simply by following a\n>published protocol for burning a specified amount of bitcoins via\n>miner fee.  It can be cryptographically proven with 100% certainty who\n\nYes it seems that having a proof-of-sacrifice that hardens the block chain\nis the important part.\n\nWhen you said destroy-via-miner-fee:\n\n>Don't forget:  4. destroy-via-miner-fee, which is useful because it\n>provides funding for a public service (bitcoin transaction\n>verification).\n\nIs that directly possible?  Because the reward transaction has no source,\nand no fee?  Or can you put a 25BTC fee in the reward transaction in the\ncoinbase?\n\nIf so that seems like the best option for proof-of-sacrifice rather than\nproving destroying the possibility of reward.  But alternatively the bitcoin\nfoundation as recipient, or EFF etc.  25BTC is a big reward might have some\ndouble roll-over lottery effects - everyone piles in for the occasional\n25BTC!\n\nAdam\n\nOn Mon, May 13, 2013 at 02:38:15PM -0400, Jeff Garzik wrote:\n>On Mon, May 13, 2013 at 6:54 AM, Adam Back <adam at cypherspace.org> wrote:\n>> On Mon, May 13, 2013 at 07:31:21AM +0000, John Dillon wrote:\n>>>[with] merge-mining [you get] more value from just one unit of work.\n>>\n>> correct.\n>>\n>>>But Peter's coinbase hashcash protocol carefully ensures [...] the amount\n>>>of value the miner would have then given away in a \"anyone-can-spend\"\n>>>output.\n>>\n>> I think there are 3 choices:\n>>\n>> 1. merged-mine (almost zero incremental cost as the bitcoin mining return is\n>>     still earned)\n>>\n>> 2. destroy bitcoin (hash of public key is all 00s so no computible private\n>>     key)\n>>\n>> 3. anyone-can-spend (= first to spend gets coin?)\n>\n>Don't forget:  4. destroy-via-miner-fee, which is useful because it\n>provides funding for a public service (bitcoin transaction\n>verification).\n>\n>(a tangent, but related)\n>\n>I've been thinking about a decentralized way to create an anonymous\n>identity, something I think it key to any number of decentralized, P2P\n>and anonymous markets.  My main focus, for this identity project, is\n>to develop a decentralized protocol for generating a UUID-like unique\n>identifier (bitstring), in a way that has some amount of creation cost\n>attached (to prevent creating a billion of such tokens etc.).  I call\n>it a system identifier, or SIN.\n>\n>Once you have a SIN, you may associate the SIN with a GPG fingerprint,\n>email address, real name, login credentials, etc.  eBay-like\n>marketplaces publish SIN ratings (though it displays on screen as\n>\"jgarzik\" not \"1234-abcd-5678-def0\").  Standard-and-Poors style\n>ratings agencies would similarly rate a business's SIN.  SIN's build a\n>reputation and trust over time, while controlling their own anonymity\n>(or lack thereof).  Anybody may abandon a SIN at any time. Ownership\n>of a SIN is cryptographically proven via digital signature.\n>\n>Getting back on topic, somewhat, one idea I had for creation cost of a\n>SIN was associating the creation cost of a SIN with a bitcoin\n>transaction's miner fee.  Anybody in the world could, therefore,\n>create a SIN in a decentralized fashion, simply by following a\n>published protocol for burning a specified amount of bitcoins via\n>miner fee.  It can be cryptographically proven with 100% certainty who\n>made such a transaction, and the miner fee attaches a creation cost to\n>ensure that SINs are not -too- cheap.\n>\n>Burn-via-miner-fee is a useful tool outside of this example.  It funds\n>a public service, providing a positive feedback loop for miners who\n>receive fees via such services.\n>\n>-- \n>Jeff Garzik\n>exMULTI, Inc.\n>jgarzik at exmulti.com"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-05-13T22:00:27",
                "message_text_only": "On Mon, May 13, 2013 at 5:12 PM, Adam Back <adam at cypherspace.org> wrote:\n> When you said destroy-via-miner-fee:\n>\n>\n>> Don't forget:  4. destroy-via-miner-fee, which is useful because it\n>> provides funding for a public service (bitcoin transaction\n>> verification).\n>\n>\n> Is that directly possible?  Because the reward transaction has no source,\n> and no fee?  Or can you put a 25BTC fee in the reward transaction in the\n> coinbase?\n\nWhen a transaction's input value exceeds its output value, the\nremainder is the transaction fee.  The miner's reward for processing\ntransactions is the 25 BTC initial currency distribution + the sum of\nall per-transaction fees.  A destroy-by-miner fee transaction is a\nnormal bitcoin transaction sent by any user, that might look like\n\nInput 1: 1.0 BTC\nOutput 1: 0.5 BTC\n\n(the miner fee is implicitly 0.5 BTC, paid to whomever mines the\ntransaction into a block)\n\nSadly the bitcoin protocol prevents zero-output,\ngive-it-all-to-the-miner transactions.\n\n-- \nJeff Garzik\nexMULTI, Inc.\njgarzik at exmulti.com"
            },
            {
                "author": "Adam Back",
                "date": "2013-05-14T09:25:07",
                "message_text_only": "On Mon, May 13, 2013 at 06:00:27PM -0400, Jeff Garzik wrote:\n>When a transaction's input value exceeds its output value, the\n>remainder is the transaction fee.  The miner's reward for processing\n>transactions is the 25 BTC initial currency distribution + the sum of\n>all per-transaction fees.  A destroy-by-miner fee transaction is a\n>normal bitcoin transaction sent by any user, that might look like\n>\n>Input 1: 1.0 BTC\n>Output 1: 0.5 BTC\n>\n>(the miner fee is implicitly 0.5 BTC, paid to whomever mines the\n>transaction into a block)\n>\n>Sadly the bitcoin protocol prevents zero-output,\n>give-it-all-to-the-miner transactions.\n\nWell if it is a later transaction, not an integral part of the reward\ntransaction (that is definitionally mined by being serialized into the\ncoinbase), the user may elect to withhold the promised transaction\ngive-to-miner, so thats not so good.\n\nOr do you mean to say you could have (implicit reward 25BTC) and reward\ntransaction .001 BTC to self and 24.999 BTC with existing bitcoin format and\nvalidation semantics?  That would be close enough to give-to-miner.  Also\nthe output sum > 0BTC limitation could be changed to >= maybe... (just one\nwell placed character :)\n\nAdam"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-05-14T16:50:27",
                "message_text_only": "On Tue, May 14, 2013 at 5:25 AM, Adam Back <adam at cypherspace.org> wrote:\n> On Mon, May 13, 2013 at 06:00:27PM -0400, Jeff Garzik wrote:\n>>\n>> When a transaction's input value exceeds its output value, the\n>> remainder is the transaction fee.  The miner's reward for processing\n>> transactions is the 25 BTC initial currency distribution + the sum of\n>> all per-transaction fees.  A destroy-by-miner fee transaction is a\n>> normal bitcoin transaction sent by any user, that might look like\n>>\n>> Input 1: 1.0 BTC\n>> Output 1: 0.5 BTC\n>>\n>> (the miner fee is implicitly 0.5 BTC, paid to whomever mines the\n>> transaction into a block)\n>>\n>> Sadly the bitcoin protocol prevents zero-output,\n>> give-it-all-to-the-miner transactions.\n>\n>\n> Well if it is a later transaction, not an integral part of the reward\n> transaction (that is definitionally mined by being serialized into the\n> coinbase), the user may elect to withhold the promised transaction\n> give-to-miner, so thats not so good.\n\nThat evaluation largely depends on the needs of the service in question.\n\nIn my decentralized identity (SIN) example, you merely need to prove\nto the cloud that you sacrificed some bitcoins to any-miner.  The\nconfirmed, in-chain, non-coinbase transaction becomes the root node\nfor off-chain identity data.\n\nThe penalty for the user withholding the sacrifice transaction is that\ntheir SIN is not created.  That incentive may not exist in that way,\nin another service.\n\n> Or do you mean to say you could have (implicit reward 25BTC) and reward\n> transaction .001 BTC to self and 24.999 BTC with existing bitcoin format and\n> validation semantics?  That would be close enough to give-to-miner.  Also\n> the output sum > 0BTC limitation could be changed to >= maybe... (just one\n> well placed character :)\n\nJust referring to a standard, fee-bearing, user-created bitcoin\ntransaction, where output_value < input_value.  The fee is paid to the\nfirst miner who includes that transaction in a block, as part of the\nprotocol.\n\n-- \nJeff Garzik\nexMULTI, Inc.\njgarzik at exmulti.com"
            },
            {
                "author": "Adam Back",
                "date": "2013-05-14T20:07:31",
                "message_text_only": "On Tue, May 14, 2013 at 12:50:27PM -0400, Jeff Garzik wrote:\n>> Well if it is a later transaction, not an integral part of the reward\n>> transaction (that is definitionally mined by being serialized into the\n>> coinbase), the user may elect to withhold the promised transaction\n>> give-to-miner, so thats not so good. [...]\n>[...]\n>Just referring to a standard, fee-bearing, user-created bitcoin\n>transaction, where output_value < input_value.  The fee is paid to the\n>first miner who includes that transaction in a block, as part of the\n>protocol.\n\nYes but thats inferior in the sense that it is spamming the bitcoin payment\nprotocol slightly, to the small reward of miners, and involves actual money\nand traceability to real-name (where did you get the coin from to spend). \n\nIf alternatively you just proof you direct mined on a block with a coinbase\nthat immediately makes payment to future miners its better because: a) you\ncan do that with no new traffic for the bitcoin network (except when you\nmine a whole block, you'll post it); and b) anyone with a reasonable\nverification on the blockchain head (even if the spender has to give it to\nthem!) can verify it without any other network traffic; and c) if its\nmicro-mined on the spot it can be bound to the service whereas if you give\nit to fees as an on network transaction you are limited to values above the\nmin tx fee.  \n\nSo idealy I think you need to be able to simultanously mine and give reward\nto future block miners.\n\nWhat you could do with out that is d) mine for the reward of bitcoin\nfoundation/software author/or service provider.  In the last case (service\nprovider) its an extreme form of Rivests peppercoin probabilistic payment\n\nAdam"
            },
            {
                "author": "John Dillon",
                "date": "2013-05-14T02:30:18",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\n> - what about if a pool could lock the reward (rather than receive it or\n>   destroy it) eg some kind of merkle root instead of a public key hash in\n>   the reward recipient address field in the coinbase.\n\nSorry I don't have time for a full reply due to some other commitments, but you\nremind me of an idea bouncing around to use a Merkle Sum tree as a way to split\none sacrifice among an arbitrarily large set of users. Credit goes to Gregory\nMaxwell (according to the wiki) and the idea is to have the roots of the tree\nbe account \"numbers\" (pubkeys here) and account amounts. He proposed it for\noff-chain transaction account ledgers, but the idea works equally well here to\nsplit some initial sacrifice into lots of little bits. For instance a on-chain\nsacrifice to an anyone-can-pay output could be split into enough parts to make\nit useful even when tx fees become large.\n\nIncidentally all this stuff about rivest paywords is probably silly, why not\njust commit your sacrifice to a pubkey and make signatures saying what your new\nbalance is for each message and how much you intended to spend? This allows for\neasy fraud proof creation, and gives you a choice of either lying to some\nnodes, and getting poor propagation, or being honest and spending the amount\nyou should have.\n\nFor DoS protection it seems to me that mostly trusting nodes to give accurate\nbalances, enforced with a fraud proof system to halt double-spending, is\nperfectly adequate. But no sense implementing so much complexity right at the\nstart of the effort! Just a thought for where things can go in the future.\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\n\niQEcBAEBCAAGBQJRkaGUAAoJEEWCsU4mNhiPKsoH/1zhTBS/rINhF8oxxFoScD6i\n0ybiUarIQEmmpAr3i46oMcSrw0SiOoiUzj6zvJorA21ddoErkTDVpMWI18RnKFos\nbTC4NVzvcegLdnbYb+76XKOCMc1dchFXq+WEGRdu/WKzOL7ODUUKAl/hG2Fk4lPU\n3x8mHq0k2pqMAYX5/TX0w0pDnS227L+V1O3EoZD86MjR/CliHsZyBnXIqyqV4rY8\n354JswKQ/XWb85gwZwFq1WXsFIZAep+eRVqmOluu3Ol97c5G85utNYDkg2hALURy\ngfpwmXKPFGm8h2lE1cMaOxkvQHOOPH8v7WdoBx08/ojhsyQNMpND4xej5FP/e5c=\n=vrFC\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-05-14T17:25:36",
                "message_text_only": "> I've been thinking about a decentralized way to create an anonymous\n> identity\n\n\nThis is the fidelity bond/anonymous passport idea that has been kicked\naround in the forums quite a few times. I mentioned it on the tor-talk once\nas a solution to the problem that you cannot create Google accounts via Tor\nwithout a phone number. It's a good idea but not new. I have encouraged\npeople to implement a server that does it and then some integration for\nMediaWiki, Wordpress or phpBB, as they're both quite common software that\ngets a lot of spam and abuse. For instance we could use it on our own wiki\ninstead of paying the wiki operator (does anyone know what happens to those\nfunds by the way?).\n\nYou don't need GPG or anything like that - the transactions that spend to\nfees also contain pubkeys in the inputs, which you own the private keys\nfor. So you can sign a challenge nonce from the server to prove ownership\nof the \"passport\"/fidelity bond.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130514/4f7fcb9a/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "merged mining hashcash & bitcoin (Re: Coinbase TxOut Hashcash)",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Adam Back",
                "John Dillon",
                "Mike Hearn",
                "Jeff Garzik"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 42110
        }
    },
    {
        "title": "[Bitcoin-development] P2P non-blockchain message proposal",
        "thread_messages": [
            {
                "author": "John Dillon",
                "date": "2013-05-13T08:19:03",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nPeter's \"Coinbase TxOut Hashcash\" scheme mentions in passing anti-DoS\nprotection on the P2P flood-fill network for non-transaction messages, and an\napplication to use those messages, trust-free mixing. I did some review of the\nsource code and I think we can create a generalized P2P flood-fill message\nsystem without difficulty.\n\nFirst of all like Mike Hearn suggested in the tx-replacement (satoshi's\nversion) thread we can easily prioritize, or I should say deprioritize\nnon-essentially traffic with a simple \"allocated bandwidth\" scheme where nodes\nset how many KB/second of bandwidth they want to give to P2P network messages.\n\nNext out of that allocation use a priority scheme where higher priority\nmessages get put ahead of lower priority ones in the queue for retransmission.\nMessages of too low a priority are dropped, and in general they basically just\ndon't get good network propagation, much like transactions with dust outputs\nwill increasingly face.\n\nHow do you determine priority? Why simply a genuine bitcoin sacrifice!\nPreviously that would have been some big bulky fidelity bond scheme, but now we\ncan use Peter's Coinbase TxOut Hashcash, or PowPos (proof-of-work\nproof-of-sacrifice) as he mentioned in the forums. (and privately) I'll jump\nthe gun a bit and call it PowPos, it's a nice name as you say. :) We already\nrelay transactions based on 1mBTC/KB, so a similar per KB message cost is\nreasonable.\n\nPeter suggested using PayWords to amortize the cost of transmitting the PowPos\ninitial proof, which of course needs to be paid for. Storing original proofs\nshould be pretty cheap, so lets make the default to store them on disk, like\nthe UTXO set, with per-node settings for just how many of these proofs we are\nwilling to store. We can treat them kinda like accounts, and old enough\naccounts simply get deleted, with a per-node configuration on how old is too\nold. It's best effort, not permanent like the UTXO set. Nodes should be able to\nask their peers for the actual proof corresponding to a payment attempt if they\nneed it. (maybe a general delta compression system could do this and other\nstuff?)\n\nNitty gritty: define either NODE_P2PMSG for \"supports P2P messages\" or a more\ngeneral NODE_SELECTIVE_RELAY to advertise general limitations on what a node\nrelays. (min txout value, replace-by-fee, p2p message etc?)\n\nDefine MSG_FLOOD_MSG inventory type. The logic is that flood-fill messages\n*are* something you can have in your \"inventory\" of data, even though they are\nstill things that expire. Again nodes can set message expiration and prune them\nin some sane way, a days worth of messages is probably fine for the vast\nmajority of nodes.\n\nEach flood fill message needs a header with the sacrifice proof, either a full\nPowPos, or a PayWord linked to a PowPos, followed by a type disambiguator\n(64-bit uuid?) followed by the data payload. Limiting the payload to 100K by\ndefault seems fine to me, same limit as on transactions.\n\nThe PowPos initial proof could also be it's own message type, MSG_POWPOS, and\nagain it's something you would have in your \"inventory\"\n\n\nI haven't written up a formal trust-free-mix message proposal. Peter do you\nhave one? Seems to me negotiating transaction fees could be a bit tricky as you\nwant people to somehow at least say that yes they are willing to pay\ntransaction fees of X for the outputs they want, without revealing what those\ninputs are. At the same time opportunistic mixing is cool, where you say \"make\nthese coins available to be mixed if it doesn't cost me anything\" and duplicate\nother's txout values on the fly to make determining what is what as difficult\nas possible, as well as occasionally broadcasting requests for random, or even\n*common* txout values. (don't forget about zipfs law!)\n\nAnti-anti-propagation DoS prevent is going to be hard too. You can rank nodes\nbased on the sum of genuine Bitcoin, or in this case genuine sacrifice activity\nthey are broadcasting to you. Tricky though because PayWord sacrifices aren't\nstored anywhere, so a peer could reuse the same PowPos if they control all your\npeers that are using the protocol.\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\n\niQEcBAEBCAAGBQJRkKG0AAoJEEWCsU4mNhiP9nMH/1VB4ub5ftPfNK+2S0pcPaxd\nwlc3KigF+5mDKN7t2gKr+DevS0gEJdOBzsCYbyartHbqeUSt7MLofKITbiIEWuTV\nN1zaclwpP5VzkfiCoLj8sJ3If4s0Tkz71+y8WMAOfjJ/XqwqxHVnpLiLgLme1Wxb\nFlSEzXRcnR66DisfvO+dDd0h5A2+OQEIoreTARK/w49caSHU+vAw9j6RHmUZ1Muw\nzEy5VGs94kuehfn6nVyFSyZ3CdrEzstXFuv2eUs2bd3rUpGlgRjSUN1k6QnN5tdq\nXUefI0bSVu1nWxBuS6k3wbTFulkLyWUY3Mt8aNR0/Ss19V8eAjWu87Fc8x4rH5c=\n=KrwV\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "P2P non-blockchain message proposal",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "John Dillon"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 4657
        }
    },
    {
        "title": "[Bitcoin-development] ecash and revocability",
        "thread_messages": [
            {
                "author": "Adam Back",
                "date": "2013-05-14T11:51:51",
                "message_text_only": "So back in 1999, in an ecash thread on cypherpunks I claimed:\n\nhttp://marc.info/?l=cypherpunks&m=95280154629900&w=2\n\n> I wouldn't say ecash has to use blinding, but I would argue it would be a\n> misuse of the word \"ecash\", if something which was revocable were dubbed\n> ecash.\n\nThis was in the context of a discussion of digigold (e-gold stored the\nphysical gold, digigold offered \"ecash\" backed in that physical gold). \nDigigold ran on Systemics payment server/sox protocol.  Because of inferred\nregulatory concerns and patent licensing issues digigold & systemics were\nnot using blind signatures.  However with systemics sox server, like\nbitcoin, you could create multiple accounts on demand and shuffle payments\naround for a degree of privacy.  The bitcoin analogy would be the\ntransaction log lived in the systemics server, so it had a central failure\npoint, but arguably more privacy as the log was not public.  Also systemics\nSOX protocol (Ian Grigg & Gary Howland) had some aspect of bitcoins smart\ncontract concepts - ricardian contracts. \nhttp://iang.org/papers/ricardian_contract.html \n\n(Btw the anonymous reply itself was interesting -\nhttp://marc.info/?l=cypherpunks&m=95280154629912&w=2 that could have been\nNakamoto, the only missing thing from the parts on the discussion room floor\nto bitcoin is mathematical inflation control.)\n\nThe thread actually started here\nhttp://marc.info/?l=cypherpunks&m=95280154629912&w=2 and then continues here\nhttp://marc.info/?l=cypherpunks&m=95280154629900&w=2 because of a subject\nline change and then http://marc.info/?l=cypherpunks&m=95280154629916&w=2\nand http://marc.info/?l=cypherpunks&m=95280154629948&w=2\nmore subject line change confusion.\n\nA related thread a few days later also covers Sander & Ta-Shma (which\nzerocoin is based on):\n\nhttp://marc.info/?l=cypherpunks&m=95280154630167&w=2\n\nthere were many more threads about various ecash technologies.\n\nAdam"
            }
        ],
        "thread_summary": {
            "title": "ecash and revocability",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Adam Back"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1914
        }
    },
    {
        "title": "[Bitcoin-development] bitcoin taint & unilateral revocability (Re: ecash and revocability)",
        "thread_messages": [
            {
                "author": "Adam Back",
                "date": "2013-05-14T14:09:02",
                "message_text_only": "On Tue, May 14, 2013 at 01:51:51PM +0200, Adam Back wrote:\n> Adam Back in Sep 1999, cypherpunks list:\n>>I wouldn't say ecash has to use blinding, but I would argue it would be a\n>>misuse of the word \"ecash\", if something which was revocable were dubbed\n>>ecash.\n\nSo I still think that is an important point.  \"Ecash should not be\nrevocable\".  I think bitcoin currently has a partial problem because of\ntaint.\n\nNow blinding based unlinkability, in a distributed cryptographic payer/payee\nanonymous system like Sander & Ta Shma [1] and zerocoin has so far been\nbased on ZKP of set membership.  Of course that is somewhat expensive,\nthough zerocoin improved the ZKP with an relatively efficient (but still\ncut-and-choose) proof.\n\nBitcoins relative lack of privacy creates a problem with tainted coins\nrisking becoming unspendable, or spendable only with some users, or at a\ndiscount.  So while the policy coded says all coins are equally acceptable,\nthe information exists so people can unilaterally reject them, depending on\nwhat the taint is.  So far revocability hasnt reared it's head that I heard,\nnor taint inspection too much?  However people have the choice and technical\nmeans to check the taint and send the bitcoins back.\n\n\nAnother aspect is that bitcoin, like systemics sox/digigold, makes a\ndifferent privacy tradeoff.  Somewhat private, but not very much.\n\nBut it creates the question: could the taint issue be fixed efficiently (eg\neven without blinding or ZKP of set membership?)\n\n\nOne related concept is commitments.  I think its relatively easy to commit\nto a payment and lock a coin without identifying yourself, until the\ncommitment is released.  You might do the commitment, wait 6-blocks for\nconfirmation, then reveal the commitment.  Then that is like a self-issued\ngreen coin with no need for trust, that can be immediately cleared.  The\nrecipient has to be committed to at the same time to prevent double\nspending.\n\nSo just commit = H( input-pub ) H( transaction ) and put it in the block\nchain.  Where transaction the is usual ( input signature, output-pub,\nscript).  (Fee for the commit would have to come from an unlinked coin or\nthe input-pub reveals the coin).  Wait 6 blocks, send/reveal the transaction\n(free because fee was already paid).  Validators check input-pub hash\nagainst committed coins by hash, check the transaction hash, and the usual\nransaction validations = sum inputs, otherwise reject.  The user better pay\nchange if any to a different public key, as the inputs public keys are one\nuse - are after the reveal they are DoS lockable by other people reposting\nH( input-pub ).\n\nThe input-pub coin is locked as normal transactions have their public key hash\nvalidate as not being locked.\n\nAdam\n\n[1] Sander & Ta Shma \"Auditable, Anonymous Electronic Cash\"\n     http://www.cs.tau.ac.il/~amnon/Papers/ST.crypto99.pdf"
            },
            {
                "author": "Simon Barber",
                "date": "2013-05-14T14:27:58",
                "message_text_only": "Adam,\n\nTake a look at this privacy enhancing solution based on fair exchange \nimplemented by bitcoin contracts and cut-and-choose. It would require a \npublic pool of users willing to exchange in common denominations at \nmoments in time together to ensure unlinkability. It also leave a trace \nof exchange activity in the chain. This could all be added to wallet \nsoftware to become automatic.\n\nhttp://robotics.stanford.edu/~xb/fc12/index.html\n\nSimon\n\n\nOn 05/14/2013 07:09 AM, Adam Back wrote:\n> On Tue, May 14, 2013 at 01:51:51PM +0200, Adam Back wrote:\n>> Adam Back in Sep 1999, cypherpunks list:\n>>> I wouldn't say ecash has to use blinding, but I would argue it would be a\n>>> misuse of the word \"ecash\", if something which was revocable were dubbed\n>>> ecash.\n>\n> So I still think that is an important point.  \"Ecash should not be\n> revocable\".  I think bitcoin currently has a partial problem because of\n> taint.\n>\n> Now blinding based unlinkability, in a distributed cryptographic payer/payee\n> anonymous system like Sander & Ta Shma [1] and zerocoin has so far been\n> based on ZKP of set membership.  Of course that is somewhat expensive,\n> though zerocoin improved the ZKP with an relatively efficient (but still\n> cut-and-choose) proof.\n>\n> Bitcoins relative lack of privacy creates a problem with tainted coins\n> risking becoming unspendable, or spendable only with some users, or at a\n> discount.  So while the policy coded says all coins are equally acceptable,\n> the information exists so people can unilaterally reject them, depending on\n> what the taint is.  So far revocability hasnt reared it's head that I heard,\n> nor taint inspection too much?  However people have the choice and technical\n> means to check the taint and send the bitcoins back.\n>\n>\n> Another aspect is that bitcoin, like systemics sox/digigold, makes a\n> different privacy tradeoff.  Somewhat private, but not very much.\n>\n> But it creates the question: could the taint issue be fixed efficiently (eg\n> even without blinding or ZKP of set membership?)\n>\n>\n> One related concept is commitments.  I think its relatively easy to commit\n> to a payment and lock a coin without identifying yourself, until the\n> commitment is released.  You might do the commitment, wait 6-blocks for\n> confirmation, then reveal the commitment.  Then that is like a self-issued\n> green coin with no need for trust, that can be immediately cleared.  The\n> recipient has to be committed to at the same time to prevent double\n> spending.\n>\n> So just commit = H( input-pub ) H( transaction ) and put it in the block\n> chain.  Where transaction the is usual ( input signature, output-pub,\n> script).  (Fee for the commit would have to come from an unlinked coin or\n> the input-pub reveals the coin).  Wait 6 blocks, send/reveal the transaction\n> (free because fee was already paid).  Validators check input-pub hash\n> against committed coins by hash, check the transaction hash, and the usual\n> ransaction validations = sum inputs, otherwise reject.  The user better pay\n> change if any to a different public key, as the inputs public keys are one\n> use - are after the reveal they are DoS lockable by other people reposting\n> H( input-pub ).\n>\n> The input-pub coin is locked as normal transactions have their public key hash\n> validate as not being locked.\n>\n> Adam\n>\n> [1] Sander & Ta Shma \"Auditable, Anonymous Electronic Cash\"\n>       http://www.cs.tau.ac.il/~amnon/Papers/ST.crypto99.pdf\n>\n> ------------------------------------------------------------------------------\n> AlienVault Unified Security Management (USM) platform delivers complete\n> security visibility with the essential security capabilities. Easily and\n> efficiently configure, manage, and operate all of your security controls\n> from a single console and one unified framework. Download a free trial.\n> http://p.sf.net/sfu/alienvault_d2d\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "grarpamp",
                "date": "2013-05-14T17:30:05",
                "message_text_only": "> Bitcoins relative lack of privacy creates a problem with tainted coins\n> risking becoming unspendable, or spendable only with some users, or at a\n> discount.  So while the policy coded says all coins are equally acceptable,\n> the information exists so people can unilaterally reject them, depending on\n> what the taint is.  So far revocability hasnt reared it's head that I heard,\n> nor taint inspection too much?  However people have the choice and technical\n> means to check the taint and send the bitcoins back.\n\na) Is there a paper detailing bitcoin traceability issues?\nParticularly when using various combinations of the often\nadvised 'use different address for every transaction', 'wash coins',\nand 'use anonymity networks' privacy enhancement methods.\n\nb) People would be nuts to reject tainted coins on the current\nchain, or any chain. How many of the bills in your wallet passed\nthrough 'illicit' transactions? How would you feel if your payee's\nserial checker bounced yours, possibly forcing you to dispense\nwith them through other, possibly illicit, means? What about a\ntotal blackball? Who's going to compensate you? How exactly do\nyou roll that all back? And are you going to KYC and scour the lives\nof your every potential customer beforehand? What if someone has\nmoney to burn and blackballs a million notes for fun. A currency of\ncommon global adoption that you can't spend after some thieving\ncrackdealer bought an onion off your garden stand isn't of much use\nto anyone, not even the purists who come up with such ideas.\nSpecialized currencies in special markets, sure, maybe, all still\nfraught with the same dilemmas. But for a global common one? No."
            }
        ],
        "thread_summary": {
            "title": "bitcoin taint & unilateral revocability (Re: ecash and revocability)",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Adam Back",
                "Simon Barber",
                "grarpamp"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 8596
        }
    },
    {
        "title": "[Bitcoin-development] blind symmetric commitment for stronger byzantine voting resilience (Re: bitcoin taint & unilateral revocability)",
        "thread_messages": [
            {
                "author": "Adam Back",
                "date": "2013-05-15T10:25:09",
                "message_text_only": "So in a previous mail I described a simple, extremely efficient and easy to\nimplement symmetric key commitment that is unlinkable until reveal time (at\nbottom).  I think this can help improve the byzantine generals problem, that\nbitcoin only defends to simple majority (with one vote per CPU power), and\nso assumes most nodes by cpu power are honest.  With this simple protocol\nchange you dont need any honest nodes, just some honest clients to spend to,\nto have your transaction accepted.  \n\nYou can think of this in terms of a (somewhat distributed) server performing\nvalidations, but in a way that it sufficiently blind to the details of the\nvalidations that it can not selectively enforce a policy, it power is\nlimited to random DoS.\n\nThere are other situations where you can rely on a server for one property\nbut not another - eg a somewhat distributed encrypted backup (like Tahoe\nLAFS) you rely on for availability, but not integrity nor confidentiality\n(because you encrypt those, and some sharing scenarios still work.) So this\nis in that class of protocols - zero-trust in server, but can extract\nservice and some guarantees from the (optionally distributed) server anyway.\n\n(Bitcoin does not use known better than majority results for byzantine\ngenerals based on fair coin toss, relying instead on simple majority and an\nassumed largely unjammable network.  I notice Nick Szabo was complaining\nabout this on his blog and saying bitcoins majority is not even a standard\nor proven byzantine voting protocol - something adhoc.  I think the bitcoin\nunjammable network assumption is a false at the limit so that someone with\nstrong network hacking capabilities can create network splits long enough to\neven overcome the network majority vote without having any compute power of\ntheir own.  All they need is to have a split with enough power to plausibly\nquickly get the victims their desired number of (split) confirmations.)\n\nAnyway this should be a clear voting improvement, that is efficient.\n\nImagine a couple of big pools or ASIC miners started enforcing some\narbitrary coin policy, eg say coins must not have some taint according to\nits list of black coins, or coins must be certified by some entity, be\ntraceable to some type of event etc.  Well call these miners/voters\n\"dishonest\", in that they are not following the intended zero-policy\nprotocol.\n\nIf the coins dont match their chosen policy, the dishonest miners will\nrefuse to include transactions in blocks they issue.  If they see a\ntransaction which does not match their policy in a block by someone else\nthey will ignore it and try to make it into an orphan.  As they have say 75%\nof the network power they can do that successfully.  Even with current\nvalidation protocols in the clients, so the \"but clients wont accept the\nchange\" argument does not apply - the existing clients will accept the\npolicy change, because they cant detect it, nor prove it, and dont have the\nvoting power to impose honest policies.\n\n(For realism of this risk, note that according to Kaminsky there already\nexist multiple entities with reserve ASIC power each exceeding current\nnetwork difficulty who are holding part of their power in reserve for profit\nmaximisation reasons.  This is a coming to fruition of the concentration of\npower issue I was talking about in my first bitcoin forum post.  People who\nhave that kind of power in reserve have clearly invested millions of\ndollars, which probably makes them more vulnerable to political influence.)\n\n\nAlright so the solution.  Use the commitment protocol (below) which even\nthough it is symmetric key strongly hides the committed transaction public\nkey.  (Symmetric in the sense that the validation steps are all highly\nefficient symmetric key based).  Now send the transaction (which includes\nthe public key) direct to the receiver, over a secure channel, or an assumed\nnon-eavesdropped direct channel, with no p2p flood of the transaction.  The\nreceiver can check the hash to the commitment, and decide how many\nconfirmtions he needs.  Once he has eg 6 confirmations he reveals the\ncommitment to the transaction (by publishing it).  The sender may also send\nthe reveal/transaction to the network directly himself, if the recipient is\noffline.  However there is no advantage to publishing early so it seems\nbetter to let the recipient do it when he is ready to incorporate the\npayment into his wallet.  \n\nNow the powerful dishonest voters if they try to apply their policy when\nthey see the reveal triggers it, must redo the work of the 6-commitments\nthat they computed themselves.  This is like starting 6-steps behind in the\nstatstical gamblers ruin game that Nakamoto describes in the bitcoin paper. \nConsequently even with 75%, they will find it very hard to outcompete their\nown prior work, to create a 6 chain long orphan while the 25% is moving\nforward on the honest chain.  Each time they see transactions which violate\ntheir policy, they have to restart their chain recalculation again from\nscratch.  Often if simple lower powered intermittent recipient sends the\ncoin will be burried hundreds of blocks back.  In addition 6 chain long\nbranches are extremely unlikely with honest payers, so clients can (and\nmaybe already do?) act with suspicion of they see one.\n\n\nGoing further, I said for best security, the recipient should never even\nreveal (to the network) until he is actually about to spend, but futher he\ndoes not even have to reveal publicly ever, he can choose to reveal only to\nthe recipient with a direct connection (no p2p flood fill of transaction.)\nAnd the direct spend argument composes, ie the 2nd recipient can not do the\nsame thing again.  (public key A sends to public key B sends to public key\nC: B publishes COM( transaction B->C ), sends the reveal of COM( transaction\nA->B ), and COM transaction B->C ) to C.  C waits 6 confirmations and is\nconvinced.  So its the approach is composable, and in fact the network\ndoesnt learn the size of the transaction even, though the spend grows each\ntime.  Eventually presumably someone will publish will the confirmations to\nthe network to trim the tansaction size, though it is not strictly\nnecessary, and the transaction flow is small and direct (no network scaling\nissues), so that it wouldnt be a huge problem to have a 1MB payment\nrepresenting 1000s of hops of network blind transactions.  (For the\ncomposable network blind respending the commitment has to commit publicly to\nboth the sender and next hop recipient keys, so the network can see how long\nthe chain is).\n\nProbably you can cope with multiple inputs and outputs, and maybe given even\nyou can work with a 100% dishonest network mining network (all the dishonest\nminer can do is selectively DoS transactions if they are all network blind\nexcept the mining), maybe the mining can even be decoupled from the voting,\nas you no longer demand much from the voting process.  That admits more\ninteresting things like pool free direct mining, low variance hashcash\ncoins, probably.  Many things to think through.\n\nI suppose the commitment could be described as a blind symmetric commitment.\n\nAdam\n\nOn Tue, May 14, 2013 at 04:09:02PM +0200, Adam Back wrote:\n> [...]\n>\n>One related concept is commitments.  I think its relatively easy to commit\n>to a payment and lock a coin without identifying yourself, until the\n>commitment is released.  You might do the commitment, wait 6-blocks for\n>confirmation, then reveal the commitment.  Then that is like a self-issued\n>green coin with no need for trust, that can be immediately cleared.  The\n>recipient has to be committed to at the same time to prevent double\n>spending.\n>\n>So just commit = H( input-pub ) H( transaction ) and put it in the block\n>chain.  Where transaction the is usual ( input signature, output-pub,\n>script).  (Fee for the commit would have to come from an unlinked coin or\n>the input-pub reveals the coin).  Wait 6 blocks, send/reveal the transaction\n>(free because fee was already paid).  Validators check input-pub hash\n>against committed coins by hash, check the transaction hash, and the usual\n>ransaction validations = sum inputs, otherwise reject.  The user better pay\n>change if any to a different public key, as the inputs public keys are one\n>use - are after the reveal they are DoS lockable by other people reposting\n>H( input-pub ).\n>\n>The input-pub coin is locked as normal transactions have their public key hash\n>validate as not being locked.\n>\n>Adam"
            },
            {
                "author": "Peter Todd",
                "date": "2013-05-15T11:19:06",
                "message_text_only": "On Wed, May 15, 2013 at 12:25:09PM +0200, Adam Back wrote:\n\nProtocols aren't set in stone - any attacker that controls enough\nhashing power to pose a 51% attack can simply demand that you use a\nBitcoin client modified to provide the attack with the full transactions\nfrom the beginning. Any blocks containing transactions with unknown\ncontents will be attacked into oblivion.\n\nOn the other hand if the \"attacker\" has less than 50% of the hashing\npower, they have no choice but to let other blocks through, and provided\nminers are free from regulation imposed on them you can bid to get your\ntransactions mined with fees. Anyone using a blockchain-based\ncrypto-currency simply has to accept that mining is a random process and\ngetting a transaction confirmed is inherently unreliable.\n\n> So in a previous mail I described a simple, extremely efficient and easy to\n> implement symmetric key commitment that is unlinkable until reveal time (at\n> bottom).  I think this can help improve the byzantine generals problem, that\n> bitcoin only defends to simple majority (with one vote per CPU power), and\n> so assumes most nodes by cpu power are honest.  With this simple protocol\n> change you dont need any honest nodes, just some honest clients to spend to,\n> to have your transaction accepted.  \n\n-- \n'peter'[:-1]@petertodd.org\n00000000000001754b62829d854463fa72fe7d972a7b7d13d0c30fc86423773c\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130515/4fd75dd9/attachment.sig>"
            },
            {
                "author": "Adam Back",
                "date": "2013-05-15T11:49:56",
                "message_text_only": "On Wed, May 15, 2013 at 07:19:06AM -0400, Peter Todd wrote:\n>Protocols aren't set in stone - any attacker that controls enough\n>hashing power to pose a 51% attack can simply demand that you use a\n>Bitcoin client modified [to facilitate evaluation of his policy]\n\nProtocol voting is a vote per user policy preference, not a CPU vote, which\nis the point.  Current bitcoin protocol is vulnerable to hard to prove\narbitrary policies being imposable by a quorum of > 50% miners.  The blind\ncommitment proposal fixes that, so even an 99% quorum cant easily impose\npolicies, which leaves the weaker protocol vote attack as the remaining\navenue of attack.  That is a significant qualitative improvement.\n\nThe feasibility of protocol voting attacks is an open question, but you\nmight want to consider the seeming unstoppability of p2p protocols for a\nhint.\n\nAdam"
            },
            {
                "author": "Caleb James DeLisle",
                "date": "2013-05-15T12:40:59",
                "message_text_only": "I can't see this working, if 51% of the mining power doesn't like your\ncoins, when you create the commitment they will reject it.\nIf the commitment is opaque at the time of inclusion in the block then\nI will create multiple commitments and then after revealing the\ncommitment and spend to you I will reveal the earlier commitment which\ncommits the coins to an address I control.\n\nOn the topic of reversibility, I suspect in the long term the lack of\nchargebacks will create issues as criminals learn that for the first\ntime in history, kidnap & ransom is effective. Suffice to say after the\nfirst >= $10mn kidnapping-for-bitcoin heist, governments will be forced\nto decide how they view the system. It will likely fall somewhere between\n\"arrest/question anyone identified holding tainted coins\" to something\nnonsensical and reactionary like \"blocking\" bitcoin as Iran does TOR.\n\nThanks,\nCaleb\n\n\n\nOn 05/15/2013 07:49 AM, Adam Back wrote:\n> On Wed, May 15, 2013 at 07:19:06AM -0400, Peter Todd wrote:\n>> Protocols aren't set in stone - any attacker that controls enough\n>> hashing power to pose a 51% attack can simply demand that you use a\n>> Bitcoin client modified [to facilitate evaluation of his policy]\n> \n> Protocol voting is a vote per user policy preference, not a CPU vote, which\n> is the point.  Current bitcoin protocol is vulnerable to hard to prove\n> arbitrary policies being imposable by a quorum of > 50% miners.  The blind\n> commitment proposal fixes that, so even an 99% quorum cant easily impose\n> policies, which leaves the weaker protocol vote attack as the remaining\n> avenue of attack.  That is a significant qualitative improvement.\n> \n> The feasibility of protocol voting attacks is an open question, but you\n> might want to consider the seeming unstoppability of p2p protocols for a\n> hint.\n> \n> Adam\n> \n> ------------------------------------------------------------------------------\n> AlienVault Unified Security Management (USM) platform delivers complete\n> security visibility with the essential security capabilities. Easily and\n> efficiently configure, manage, and operate all of your security controls\n> from a single console and one unified framework. Download a free trial.\n> http://p.sf.net/sfu/alienvault_d2d\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Adam Back",
                "date": "2013-05-15T16:21:29",
                "message_text_only": "On Wed, May 15, 2013 at 08:40:59AM -0400, Caleb James DeLisle wrote:\n>If the commitment is opaque at the time of inclusion in the block then\n>I will create multiple commitments and then after revealing the\n>commitment and spend to you I will reveal the earlier commitment which\n>commits the coins to an address I control.\n\nBit-commitments are based on deterministic one-way functions eg like SHA1(\nSHA256( public key ) ) Obviously it has to be a different one-way function\nto the coin address calculation which is RIPEMD( SHA256( public key ) ) as\nthat is already public.  Alternatively it can be a different serialization\nusing the same hash eg RIPEMD( SHA256( 1 || public key ) ).\n\nThere is only one commitment possible per public key - so you can only\ncreate one commitment that would validate to a receiver, or to the network. \nThe network checks that there are no non-blind double spends of committed\ncoins which it can do as spends require disclosure of the public key, which\nallows existing commitments to be verified, and it similarly qchecks that\nthere are no blind double-commitments.\n\nEach committed coin would be:\n\none-spend-commit = Com( spender pub ), Com( transaction )\n\nwhere Com is implemented as the above hash.  The network just places the\ncommitments in order as with conventional transactions.\n\nThe committed coins are not linkable to your non-blind coin because you did\nnot reveal your public key in the (largely passive) act of receiving to a\ncoin address.\n\n>On the topic of reversibility, I suspect in the long term the lack of\n>chargebacks will create issues as criminals learn that for the first\n>time in history, kidnap & ransom is effective. \n\nThe temporary unlinkability (until commitment reveal) is a necessary side\neffect, not a cryptographic anonymity feature like zerocoin.  The\ntransactions are identical to bitcoins once revealed.  How long the\ncommitted transaction chains can be between reveals is an implementation\nchoice could be 1 hop, or as long as you like.  (Actually it appears to be\nup to the individual users how long the maximum chain they accept is - the\nnetwork itself, though ordering the committed spends (if there are multiple\nspends on the same key) cant even tell how long the commitment payment\nchains are).\n\nObviously the first coins in the network ordered committed coins on the same\nkey up to the coin value are spends as verified by the recipient, the rest\nare double-spend and ignored.  If someone wants to waste fees by sending\nmore spends than there inputs thats up to them.\n\nProbably the typical user doesnt care about long committed chains  other\nthan their wallet will bloat if the chains are too long, so probably they\nwould periodically compact it by revealing the long chains.  Committed coins\nare probably a bit less SPV client friendly, though with correct formatting\nin the merkle trees between blocks, probably a committed coin holder can\nprovide enough proof to an SPV client to verify even multi-spend committed\ncoins directly (without a network feed).\n\nAbout privacy, up to the entire commitment chain can be opened at any time\n(to other people or to the bitcoin network in general) with the cooperation\nof any user on the chain (up to the point they saw it), so while the blind\ncommitment protocol is not vulnerable to a > 50% power quorum unilaterally\nimposed policy (without even needing client updates), it is fully dependent\non the good will of the recipients for its temporary unlinkability.  Thats\nthe point: it puts policy control in the users hands not in the > 50% power\nquorum.\n\nIf you want cryptographic anonymity its better to look to zerocoin.  You may\nhave noticed zero coin talked about optional fraud tracing.  Its usually\ntrivial to add tracing to an otherwise privay preserving protocol.\n\nThe blind commitment if implemented as described (and its not obvious how to\nget more privacy from it) offers somewhat like community policing.  Users on\nthe chain can still themselves do fraud tracing, or any policy they choose,\non any blind committed coins that they receive.  If they dont like the\ncolour of them they can refund them.  The point is to enforce that this is a\nfree uncoerced community choice, by individual end users, not a > 50% cpu\npower quorum choice surreptitiously imposed.\n\nAdam"
            },
            {
                "author": "Caleb James DeLisle",
                "date": "2013-05-15T18:01:31",
                "message_text_only": "On 05/15/2013 12:21 PM, Adam Back wrote:\n> On Wed, May 15, 2013 at 08:40:59AM -0400, Caleb James DeLisle wrote:\n>> If the commitment is opaque at the time of inclusion in the block then\n>> I will create multiple commitments and then after revealing the\n>> commitment and spend to you I will reveal the earlier commitment which\n>> commits the coins to an address I control.\n> \n> Bit-commitments are based on deterministic one-way functions eg like SHA1(\n> SHA256( public key ) ) Obviously it has to be a different one-way function\n> to the coin address calculation which is RIPEMD( SHA256( public key ) ) as\n> that is already public.  Alternatively it can be a different serialization\n> using the same hash eg RIPEMD( SHA256( 1 || public key ) ).\n\n\nAhh thanks for clearing that up, although it would limit the possibilities\nof scripting it is silly of me not to think of it.\n\n\n> \n> There is only one commitment possible per public key - so you can only\n> create one commitment that would validate to a receiver, or to the network. The network checks that there are no non-blind double spends of committed\n> coins which it can do as spends require disclosure of the public key, which\n> allows existing commitments to be verified, and it similarly qchecks that\n> there are no blind double-commitments.\n> \n> Each committed coin would be:\n> \n> one-spend-commit = Com( spender pub ), Com( transaction )\n> \n> where Com is implemented as the above hash.  The network just places the\n> commitments in order as with conventional transactions.\n> \n> The committed coins are not linkable to your non-blind coin because you did\n> not reveal your public key in the (largely passive) act of receiving to a\n> coin address.\n> \n>> On the topic of reversibility, I suspect in the long term the lack of\n>> chargebacks will create issues as criminals learn that for the first\n>> time in history, kidnap & ransom is effective. \n> \n> The temporary unlinkability (until commitment reveal) is a necessary side\n> effect, not a cryptographic anonymity feature like zerocoin.  The\n> transactions are identical to bitcoins once revealed.  How long the\n> committed transaction chains can be between reveals is an implementation\n> choice could be 1 hop, or as long as you like.  (Actually it appears to be\n> up to the individual users how long the maximum chain they accept is - the\n> network itself, though ordering the committed spends (if there are multiple\n> spends on the same key) cant even tell how long the commitment payment\n> chains are).\n> \n> Obviously the first coins in the network ordered committed coins on the same\n> key up to the coin value are spends as verified by the recipient, the rest\n> are double-spend and ignored.  If someone wants to waste fees by sending\n> more spends than there inputs thats up to them.\n> \n> Probably the typical user doesnt care about long committed chains  other\n> than their wallet will bloat if the chains are too long, so probably they\n> would periodically compact it by revealing the long chains.  Committed coins\n> are probably a bit less SPV client friendly, though with correct formatting\n> in the merkle trees between blocks, probably a committed coin holder can\n> provide enough proof to an SPV client to verify even multi-spend committed\n> coins directly (without a network feed).\n> \n> About privacy, up to the entire commitment chain can be opened at any time\n> (to other people or to the bitcoin network in general) with the cooperation\n> of any user on the chain (up to the point they saw it), so while the blind\n> commitment protocol is not vulnerable to a > 50% power quorum unilaterally\n> imposed policy (without even needing client updates), it is fully dependent\n> on the good will of the recipients for its temporary unlinkability.  Thats\n> the point: it puts policy control in the users hands not in the > 50% power\n> quorum.\n\n\nThat is indeed interesting. If I understand this properly Alice commits coins\nto pay to Bob and gives Bob the transaction, Bob then commits to pay to Charlie\nand gives him the related transaction. If Charlie wants to collect the bitcoin\nhe then reveals Alice's transaction and Bob's.\n\nI think what you're trying to do is *almost* possible now (ab)using BIP-0016\nIn the output of the previous tx you put:\n\nOP_HASH160 [20-byte-hash-value] OP_EQUAL\n\nand in the next tx you use a new type of input which specifies it's value but\nnot the output which is spent. In the input script you place:\n\nOP_DUP OP_1ADD OP_HASH160 [20-byte-hash-value] OP_EQUALVERIFY\n\nThen a serialized script containing the normal stuff as well as the last\ntransaction hash and output index would be passed around out of band and the\nvalidating nodes would execute each script with a shared stack, beginning with\nthe out of band one, then the input one (the OP_EQUALVERIFY) then the output.\nWhen the serialized sigscript reaches the bottom of the stack, having been\nverified twice, it will now be evaluated as per the rules of P2SH.\n\nNone of this probably works in the real world since I'm not familiar with the\nactual implementation of P2SH and it probably has quite a number of things\nwhich will break if used this way but it is interesting to see that in theory\nit is possible with little change to the protocol (just a new input format).\n\nThanks,\nCaleb\n\n> \n> If you want cryptographic anonymity its better to look to zerocoin.  You may\n> have noticed zero coin talked about optional fraud tracing.  Its usually\n> trivial to add tracing to an otherwise privay preserving protocol.\n> \n> The blind commitment if implemented as described (and its not obvious how to\n> get more privacy from it) offers somewhat like community policing.  Users on\n> the chain can still themselves do fraud tracing, or any policy they choose,\n> on any blind committed coins that they receive.  If they dont like the\n> colour of them they can refund them.  The point is to enforce that this is a\n> free uncoerced community choice, by individual end users, not a > 50% cpu\n> power quorum choice surreptitiously imposed.\n> \n> Adam\n>"
            },
            {
                "author": "Adam Back",
                "date": "2013-05-15T23:40:30",
                "message_text_only": "btw I posted some of this thread on the dev forum:\n\nhttps://bitcointalk.org/index.php?topic=206303.msg2157994#msg2157994\n\nA related idea is occuring to me that maybe these committed transactions\ncould actually as a side effect make bitcoin scale slightly better by\nreducing the p2p flood filled transaction size.\n\nAs I said on the forum:\n\n> Note committed transactions are more compact than regular transactions -\n> they are just two hashes, so they reduce network bandwidth and make\n> bitcoin more scalable to the extent that transaction reveals stay off\n> network.  (As well as more secure against centralization policy risks). \n\nSurely its lower bandwidth for nodes to send only committed transactions to\nthe p2p network, and pass committed payment chains direct to recipients.\n\nSay committed transaction size is c (20bytes+32bytes+16bytes +header ~ 72\nbytes?) And full transaction smallest size is t (txin=20bytes, amount out\n4bytes, sender pub key 32bytes, recip address 20bytes, change address\n20bytes, formatting 5 bytes, ECDSA signature 64bytes, script 10 byte surely\n~ 175bytes)?  Thats over twice the size.  Probably average more, and it is\nsent to every node.  Its always going to be lower bandwidth to send\ntransactions to the recipients than to send to the network, even if you have\nto increase the transaction size with each respend.  The alternative is for\nthe entire network to see the same transaction.\n\nI think the commitment needs to bind the two parts together eg \n\n(blind-sender, auth-tag, tx-commit)\n\nblind-sender = SHA1( SHA256( 1, pub ) )\nauth = HMAC-SHA256-128( K, tx-commit )\ntx-commit = SHA-256( tx )\n\nOr some variantion, and you must not reuse the pub key, and must send change\nif any to a different address, otherwise chain recipients or malicious\nforwarders could lock your coin, by putting random junk onto the network\nwhich would be unverifiable, and non-disclaimable - you cant prove you dont\nknow the preimage of some junk.  The MAC prevents it.  Maybe there's a more\ncompact way to do it even, but that works efficient demonstration of\nsecurity feasibility.\n\nOther public key variants could be possible, P = xG is the ECDSA public key,\nx the private key, G base point.  Sender could reveal P' = cP, c some fixed\nconstant (computing c from cP is ECDL problem considered oneway & hard), and\na signature by private key x' = cx over the tx-commit.  That is a publicly\nauditable commitment also, but one tht can make an ECDSA signature over the\ntx-commit hash, and can be revealed by revealing P later.  However that\nimposes public key computation on the validation (which it already currently\ndoes, but faster validation as above is nicer).  With that one you dont even\nhave to verify the transaction signature on reveal :)  You already did it,\njust provide the tx that hashes to the signed hash, and P for the recipient\nto verify the signature was made by cP.\n\nAdam"
            },
            {
                "author": "Gavin",
                "date": "2013-05-16T01:24:47",
                "message_text_only": "Busy with pre-conference stuff, not following details of this conversation...\n\n... but it sounds a lot like the \"guy fawkes\" protocol Zooko was thinking about a year or so ago."
            },
            {
                "author": "Gregory Maxwell",
                "date": "2013-05-16T01:39:58",
                "message_text_only": "On Wed, May 15, 2013 at 6:24 PM, Gavin <gavinandresen at gmail.com> wrote:\n> Busy with pre-conference stuff, not following details of this conversation...\n>\n> ... but it sounds a lot like the \"guy fawkes\" protocol Zooko was thinking about a year or so ago.\n\nSort of, but in a guy fawkes signature you use the commitment to hide\nthe preimage that proves you had authority to spend a coin.   Adam\nproposes you do this in order to hide _which coin you're spending_.\n\nThis has obvious anti-DOS complications, but Adam deftly dodged my\ninitial attempts to shoot him down on these grounds by pointing out\nthat you could mix blinded and blinded inputs and have priority and\ntransaction fees come from only the unblinded ones.\n\nEffectively,  it means that so long as you could convince the network\nto let you spend some coins, you could also spend other ones along for\nthe ride and the network wouldn't know which ones those were until it\nwas too late for it to pretend it never saw them.\n\nI think there are all kinds of weird economic implications to this\u2014 a\nblinded payment would seem to have a different utility level to an\nunblinded one: you can't use it for fees\u2014 except you can unblind it at\nany time.  And the discontinuousness  (\"two types of inputs\") and that\nit would enable mining gibberish (though perhaps not data storage, if\nyou see my preimage solution to that) seems awkward and I think I have\nto spend some time internalizing it before I can really think through\nthe implications."
            },
            {
                "author": "Mike Hearn",
                "date": "2013-05-16T02:22:51",
                "message_text_only": "Conceptually it sounds a lot like ZeroCoin (not in implementation)?\n\nI'm not really convinced miner cartels that try to exclude transactions are\nlikely to be a big deal, but such schemes could I suppose be kept in a back\npocket in case one day I'm proven wrong.\n\n\nOn Wed, May 15, 2013 at 6:39 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n\n> On Wed, May 15, 2013 at 6:24 PM, Gavin <gavinandresen at gmail.com> wrote:\n> > Busy with pre-conference stuff, not following details of this\n> conversation...\n> >\n> > ... but it sounds a lot like the \"guy fawkes\" protocol Zooko was\n> thinking about a year or so ago.\n>\n> Sort of, but in a guy fawkes signature you use the commitment to hide\n> the preimage that proves you had authority to spend a coin.   Adam\n> proposes you do this in order to hide _which coin you're spending_.\n>\n> This has obvious anti-DOS complications, but Adam deftly dodged my\n> initial attempts to shoot him down on these grounds by pointing out\n> that you could mix blinded and blinded inputs and have priority and\n> transaction fees come from only the unblinded ones.\n>\n> Effectively,  it means that so long as you could convince the network\n> to let you spend some coins, you could also spend other ones along for\n> the ride and the network wouldn't know which ones those were until it\n> was too late for it to pretend it never saw them.\n>\n> I think there are all kinds of weird economic implications to this\u2014 a\n> blinded payment would seem to have a different utility level to an\n> unblinded one: you can't use it for fees\u2014 except you can unblind it at\n> any time.  And the discontinuousness  (\"two types of inputs\") and that\n> it would enable mining gibberish (though perhaps not data storage, if\n> you see my preimage solution to that) seems awkward and I think I have\n> to spend some time internalizing it before I can really think through\n> the implications.\n>\n>\n> ------------------------------------------------------------------------------\n> AlienVault Unified Security Management (USM) platform delivers complete\n> security visibility with the essential security capabilities. Easily and\n> efficiently configure, manage, and operate all of your security controls\n> from a single console and one unified framework. Download a free trial.\n> http://p.sf.net/sfu/alienvault_d2d\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130515/45e8634b/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2013-05-16T02:45:34",
                "message_text_only": "On Wed, May 15, 2013 at 7:22 PM, Mike Hearn <mike at plan99.net> wrote:\n> Conceptually it sounds a lot like ZeroCoin (not in implementation)?\n\nZerocoin conceals the connection from everyone forever, assuming the\nunderlying trapdoor problem is computational infeasible, but at great\ncost.\n\nAdamcoin, depending on how its done, at most conceals the transactions\nfrom people who aren't a party to them... though as time goes on\neventually everyone becomes a party to a sufficiently old coin, and\navoiding publication creates quadratic costs in evaluating a private\nclique's claims.... so instead an implementation would make the\nidentities public but only once they're burred a bit.\n\nPerhaps an extreme version of the idea is easier to understand. Ignore\nDOS attacks for a moment and pretend there is never any address reuse:\n\nEveryone creates txouts paying a P2SH addresses that have a OP_PUSH\nnonce in them and tell you recipient the nonce out of band.\n\nWhen the recipients spend those coins they provide the script but not the nonce.\n\nThe recipient knows what coins he's spending, but the public does not.\n\nThe public can tell there is no double spend though, because they'd\nsee the same script twice. The person he's paying may be skeptical\nthat he actually has any coin and didn't just mine some gibberish, but\nour spender tells that their receiver the nonce, and that person can\nsee the coin available for spending in the chain and also see that\nthere are no double spends.\n\nThis could actually go on forever with no ambiguity over who owns\nwhat, but the out of band proofs that you have to give people when you\nspend coins would grow with the history of the coins.\n\nSince there wouldn't be much privacy once a transaction was\nsufficiently split up in any case, you instead just publish the\nunblindings once transactions are sufficiently buried. Thus bounding\nthe growth of the proofs.   The reason I say I need to internalize\nthis more is mostly that I need to think about attacks on the\npublication for 'tained' transactions being more or less isomorphic\nto just refusing to allow spending of the 'tainted' coins in any case."
            },
            {
                "author": "Caleb James DeLisle",
                "date": "2013-05-16T05:52:41",
                "message_text_only": "Not only does the size of the proof grow endlessly as the coin is\npassed around, the size of the UTXO set grows endlessly as more and\nmore of the already spent coins cannot be proven to have been spent\nbecause the proofs are passed out-of-band. I never said the idea was\ngood, just interesting :)\n\nThanks,\nCaleb\n\n\nOn 05/15/2013 10:45 PM, Gregory Maxwell wrote:\n> On Wed, May 15, 2013 at 7:22 PM, Mike Hearn <mike at plan99.net> wrote:\n>> Conceptually it sounds a lot like ZeroCoin (not in implementation)?\n> \n> Zerocoin conceals the connection from everyone forever, assuming the\n> underlying trapdoor problem is computational infeasible, but at great\n> cost.\n> \n> Adamcoin, depending on how its done, at most conceals the transactions\n> from people who aren't a party to them... though as time goes on\n> eventually everyone becomes a party to a sufficiently old coin, and\n> avoiding publication creates quadratic costs in evaluating a private\n> clique's claims.... so instead an implementation would make the\n> identities public but only once they're burred a bit.\n> \n> Perhaps an extreme version of the idea is easier to understand. Ignore\n> DOS attacks for a moment and pretend there is never any address reuse:\n> \n> Everyone creates txouts paying a P2SH addresses that have a OP_PUSH\n> nonce in them and tell you recipient the nonce out of band.\n> \n> When the recipients spend those coins they provide the script but not the nonce.\n> \n> The recipient knows what coins he's spending, but the public does not.\n> \n> The public can tell there is no double spend though, because they'd\n> see the same script twice. The person he's paying may be skeptical\n> that he actually has any coin and didn't just mine some gibberish, but\n> our spender tells that their receiver the nonce, and that person can\n> see the coin available for spending in the chain and also see that\n> there are no double spends.\n> \n> This could actually go on forever with no ambiguity over who owns\n> what, but the out of band proofs that you have to give people when you\n> spend coins would grow with the history of the coins.\n> \n> Since there wouldn't be much privacy once a transaction was\n> sufficiently split up in any case, you instead just publish the\n> unblindings once transactions are sufficiently buried. Thus bounding\n> the growth of the proofs.   The reason I say I need to internalize\n> this more is mostly that I need to think about attacks on the\n> publication for 'tained' transactions being more or less isomorphic\n> to just refusing to allow spending of the 'tainted' coins in any case.\n> \n> ------------------------------------------------------------------------------\n> AlienVault Unified Security Management (USM) platform delivers complete\n> security visibility with the essential security capabilities. Easily and\n> efficiently configure, manage, and operate all of your security controls\n> from a single console and one unified framework. Download a free trial.\n> http://p.sf.net/sfu/alienvault_d2d\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Adam Back",
                "date": "2013-05-16T11:32:22",
                "message_text_only": "On Wed, May 15, 2013 at 07:45:34PM -0700, Gregory Maxwell wrote:\n>[committed coins] depending on how its done, at most conceals the\n>transactions from people who aren't a party to them...  though as time goes\n>on eventually everyone becomes a party to a sufficiently old coin, and\n>avoiding publication creates quadratic costs in evaluating a private\n>clique's claims....  so\n\nI believe the coin size and verification cost is linear not quadratic, but\nmaybe it depends on the parameter you're measuing in.  The coin size is\nlinear with the number of committed (uncompacted) spends.  You can view\nreveals as committed compaction.  For efficiency a recipient of a committed\ncoin may as well compact and spend in one transaction so no new messages are\ncreated.\n\nBtw I believe if one were concerned about the committed coin size, I can see\na small tweak that would keep the size of the committed coins small eg\n256-bit regardless of number of spends (no longer grows), and let the block\nstore the encrytped & MACed commitment.  Then compaction is no longer a\nconcern.  However I think that is SPV -> SPV client unfriendly.  (A full\nclient -> SPV client should still be workable as the full client could\nalternatively send the client the MACed data and key, rather than have him\nlook at it from his block history.)  (Crypto sketch below).\n\nHowever I am not sure multi-spend committed coin size is really a concern\nbecause to the extent people hold long commitments without revealing to the\nnetwork for the long term, that is a bandwidth saving to the network.\n\nOverall about privacy it would be typically temporary, though the peers have\nthe technical means to react and defend themselves by using longer committed\nchains if dishonest mining is detected on a significant scale.\n\n>instead an implementation would make the identities public but only once\n>they're burred a bit.\n\nThat was the seed idea.  The more aggressive \"spend lots of times in\ncommitted form\" is just a technical threat that will keep dishonest mining\nin check.  By definition the coin is already irrevocably spent before the\nreveal (without the threat of having the dishonest miners endlessly redoing\ntheir own deeply burried work).  The only person who could be punished by\npolicy by >50% dishonest miner (retroactively) is the recipient, not the\nspender, and the punishment is very muted: all he can do is prevent coin\ncompaction.  If the committed coins are small, compact doesnt even hurt the\ncommitted coin user, just network itself.  Therefore a dishonest miner is\nwasting his time his dishonesty cant enforce his dishonest policy.\n\nTo store the commitments in the block chain replace:\n\n> (blind-sender, auth-tag, tx-commit)\n> \n> blind-sender = SHA1( SHA256( 1, pub ) )\n> auth = HMAC-SHA256-128( K, tx-commit )\n> tx-commit = SHA-256( tx )\n> K = SHA-256( pub )\n\nwith:\n\n(blind-sender, auth-tag, encrypted-tx-commit)\n\n\tblind-sender = SHA1( SHA256( 1, pub ) )\n\tauth = HMAC-SHA256-128( K, encrypted-tx-commit )\n\tencrypted-tx-commit = AES( K, tx-commit )   (*)\n\tK = SHA-256( pub )\n\nthen a reveal is just to send the recipient the public key (32 bytes)\nper hop, still linear but ~3x smaller.\n\nI suggested fixed size committed coin spends, that also you can do but with\npublic key crypto needed probably, and so dropping to the verification\nefficiency of standard transactions.  Sketch 2:\n\n(blind-sender, auth-tag, encrypted-tx-commit)\n\n(pub key P = xG, G = base point)\n\n\tblind-sender = cP (public key EC multiplied by constant c)\n\tsig = ECDSA( cx, encrypted-tx-commit )\n\tencrypted-tx-commit = AES( K, tx-commit )\n\tK = random\n\nas K is random, knowledge of P if stored unencrypted does not allow\ncommitted spend-to-junk.  To reveal to a recipient just send them P and K at\neach hop.  (Same K each time, anyone on the committed coin spend chain can\nalready chose to reveal at any time so no loss of security.)\n\nYou dont need to verify a second signature inside the tx-commit because you\nalready signed the encrypted-tx which binds to it (encryption with out MAC\nis malleable but you cant change it at all without invalidating the\nencryption).  Just need to check the input tx in the tx-commit has P as its\nrecipient.  P does not even need to go into tx-commit as its already bound\nby cP and signature security (cant create a signature with someone elses\nkey).  So I think the commited coins of this form are the same size and\nverification cost for the network.  And small and fixed size to spend\noffline.  (32+32=64 bytes fixed).\n\nAdam\n\n(*) You should not as a principle re-use keys across algorithms, I omitted a\nsecond key for simplicity.  Really K1 = SHA256( 1||pub ), K2 = SHA256(\n2||pub ) encrypted-tx-commit = AES( K1, tx-commit ), auth = HMAC( K2,\nencrypted-tx-committ ).  Or more simply a combined authenticated mode like\nCCM or GCM and a single key managed by the mode."
            },
            {
                "author": "Adam Back",
                "date": "2013-05-16T14:51:09",
                "message_text_only": "More somewhat improved crypto stuff...\n\nOn Thu, May 16, 2013 at 01:32:22PM +0200, Adam Back wrote:\n>I suggested fixed size committed coin spends [...]\n>\n>(blind-sender, auth-tag, encrypted-tx-commit)\n>\n>(pub key P = xG, G = base point)\n>\n>\tblind-sender = cP (public key EC multiplied by constant c)\n>\tsig = ECDSA( cx, encrypted-tx-commit )\n>\tencrypted-tx-commit = AES( K, tx-commit )\n>\tK = random\n>\n>as K is random, knowledge of P if stored unencrypted does not allow\n>committed spend-to-junk.  To reveal to a recipient just send them P and K at\n>each hop.  (Same K each time, anyone on the committed coin spend chain can\n>already chose to reveal at any time so no loss of security.)\n\nActually same K every time is not so hot, as then earlier in the committed\nspend chain, can force a reveal for someone later.  A clearer requirement is\nthat each person should only be able to reveal committed coin chains up to\nthe point of their direct involvement.\n\nSo that is easily fixable, just include the K for the input committed coin\nin the encrypted-tx-commit, as above but:\n\n\tencrypted-tx-commit = AES( K_i, K_{i-1} || tx-commit )\n\tK_i = random\n\n(different K for each spend).\n\nAnd actually for symmetric encrypted variant the coin as specified was\nalready evaluatable with fixed size committed spend (of the last public key)\n- I just didnt realize it in the previous mail: the input public key is\nnecessarily revealed when processing the decrypted tx-commit, allowing\nidentification and validation of the txin, and validation recursively back\nto the first non-committed coin.  With symmetric verification, the\nlimitation is one-use coin committed addresses (and inability to remove\nspend to committed junk with public validation, though there is the tx fee\nas a discouragement, it does bloat a recipients verification and so maybe\nfrustates SPV->SPV consumption of committed coins).\n\n(blind-sender, auth-tag, encrypted-tx-commit)\n\n         blind-sender = SHA1( SHA256( 1, pub ) )\n         auth = HMAC-SHA256-128( K, encrypted-tx-commit )\n         encrypted-tx-commit = AES( K, tx-commit )\n         K = SHA-256( pub )\n\nAdam\n\nps and it would be better and clearer to read also in terms of purpose of\nhashes, to use a KDF like IEEE P1363 KDF2, or PKCS#5 PBKDF2 with 1\niteration, rather than adhoc hashes for key derivation."
            }
        ],
        "thread_summary": {
            "title": "blind symmetric commitment for stronger byzantine voting resilience (Re: bitcoin taint & unilateral revocability)",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Gavin",
                "Adam Back",
                "Caleb James DeLisle",
                "Mike Hearn",
                "Peter Todd",
                "Gregory Maxwell"
            ],
            "messages_count": 14,
            "total_messages_chars_count": 43480
        }
    },
    {
        "title": "[Bitcoin-development] Bitcoin2013 Speakers: Include your PGP fingerprint in your slides",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2013-05-14T18:41:20",
                "message_text_only": "report: https://bitcointalk.org/index.php?topic=205349.0\n\nEvery talk will be widely witnessed and videotaped so we can get some\nreasonably good security by simply putting out PGP fingerprints in our\nslides. Yeah, some fancy attacker could change the videos after the\nfact, but the talks themselves will have wide audiences and a lot of\nopportunities for fraud to be discovered. That means it'd also be\nreasonable for people to sign those keys too if you are present and are\nconvinced you aren't looking at some impostor. (of course, presenters,\ncheck that your PGP fingerprints are correct...)\n\n\nRemember that PGP depends on the web-of-trust. No single measure in a\nweb-of-trust is needs to be absolutely perfect; it's the sum of the\nverifications that matter. I don't think it matters much if you have,\nsay, seen Jeff Garzik's drivers license as much as it matters that you\nhave seen him in a public place with dozens of witnesses that would\nrecognize him and call out any attempt at fraud.\n\nSecondly remember that many of us are working on software where an\nattacker can steal from huge numbers of users at once if they manage to\nsneak some wallet stealing code in. We need better code signing\npractices, but they don't help without some way of being sure the keys\nsigning the code are valid. SSL and certificate authorities have\nadvantages, and so does the PGP WoT, so use both.\n\n\nFWIW I take this stuff pretty seriously myself. I generated my key\nsecurely in the first place, I use a hardware smartcard to store my PGP\nkey, and I keep the master signing key - the key with the ability to\nsign other keys - separate from my day-to-day signing subkeys. I also\nPGP sign emails regularly, which means anyone can get a decent idea of\nif they have the right key by looking at bitcoin-development mailing\nlist archives and checking the signatures. A truly dedicated attacker\ncould probably sign something without my knowledge, but I've certainly\nraised the bar.\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000016be577c0f0ce4c04a05fdbfc8e0b6f69053659f32aeea3a518\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130514/a4adf973/attachment.sig>"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2013-05-14T19:16:28",
                "message_text_only": "On 14 May 2013 20:41, Peter Todd <pete at petertodd.org> wrote:\n\n> report: https://bitcointalk.org/index.php?topic=205349.0\n>\n> Every talk will be widely witnessed and videotaped so we can get some\n> reasonably good security by simply putting out PGP fingerprints in our\n> slides. Yeah, some fancy attacker could change the videos after the\n> fact, but the talks themselves will have wide audiences and a lot of\n> opportunities for fraud to be discovered. That means it'd also be\n> reasonable for people to sign those keys too if you are present and are\n> convinced you aren't looking at some impostor. (of course, presenters,\n> check that your PGP fingerprints are correct...)\n>\n>\n> Remember that PGP depends on the web-of-trust. No single measure in a\n> web-of-trust is needs to be absolutely perfect; it's the sum of the\n> verifications that matter. I don't think it matters much if you have,\n> say, seen Jeff Garzik's drivers license as much as it matters that you\n> have seen him in a public place with dozens of witnesses that would\n> recognize him and call out any attempt at fraud.\n>\n> Secondly remember that many of us are working on software where an\n> attacker can steal from huge numbers of users at once if they manage to\n> sneak some wallet stealing code in. We need better code signing\n> practices, but they don't help without some way of being sure the keys\n> signing the code are valid. SSL and certificate authorities have\n> advantages, and so does the PGP WoT, so use both.\n>\n>\n> FWIW I take this stuff pretty seriously myself. I generated my key\n> securely in the first place, I use a hardware smartcard to store my PGP\n> key, and I keep the master signing key - the key with the ability to\n> sign other keys - separate from my day-to-day signing subkeys. I also\n> PGP sign emails regularly, which means anyone can get a decent idea of\n> if they have the right key by looking at bitcoin-development mailing\n> list archives and checking the signatures. A truly dedicated attacker\n> could probably sign something without my knowledge, but I've certainly\n> raised the bar.\n>\n\nJust out of curiosity, could PGP keyservers suffer from a similar 51%\nattack as the bitcoin network?\n\n\n>\n> --\n> 'peter'[:-1]@petertodd.org\n> 000000000000016be577c0f0ce4c04a05fdbfc8e0b6f69053659f32aeea3a518\n>\n>\n> ------------------------------------------------------------------------------\n> AlienVault Unified Security Management (USM) platform delivers complete\n> security visibility with the essential security capabilities. Easily and\n> efficiently configure, manage, and operate all of your security controls\n> from a single console and one unified framework. Download a free trial.\n> http://p.sf.net/sfu/alienvault_d2d\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130514/17d09b72/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2013-05-14T19:31:41",
                "message_text_only": "On Tue, May 14, 2013 at 09:16:28PM +0200, Melvin Carvalho wrote:\n> > FWIW I take this stuff pretty seriously myself. I generated my key\n> > securely in the first place, I use a hardware smartcard to store my PGP\n> > key, and I keep the master signing key - the key with the ability to\n> > sign other keys - separate from my day-to-day signing subkeys. I also\n> > PGP sign emails regularly, which means anyone can get a decent idea of\n> > if they have the right key by looking at bitcoin-development mailing\n> > list archives and checking the signatures. A truly dedicated attacker\n> > could probably sign something without my knowledge, but I've certainly\n> > raised the bar.\n> >\n> \n> Just out of curiosity, could PGP keyservers suffer from a similar 51%\n> attack as the bitcoin network?\n\nWhat guarantees do you think a keyserver provides about the keys it\nreturns?\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000142ad32a203b1627bee8126fa4bcd940b0da3f32bf1b5b07a24\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130514/cc1a2aca/attachment.sig>"
            },
            {
                "author": "Harald Schilly",
                "date": "2013-05-14T19:39:46",
                "message_text_only": "On Tue, May 14, 2013 at 9:16 PM, Melvin Carvalho\n<melvincarvalho at gmail.com> wrote:\n> Just out of curiosity, could PGP keyservers suffer from a similar 51% attack\n> as the bitcoin network?\n\nWell, no, and yes. It doesn't work like that.\n\nIf you have your own domain, you can store your key there as a TXT entry.\n\n$ dig +short harald._pka.schil.ly. TXT\n\nand even use it automatically:\n$ gpg \u2026 --auto-key-locate pka -r email at address.domain\n\nH"
            },
            {
                "author": "Adam Back",
                "date": "2013-05-14T20:12:32",
                "message_text_only": "On Tue, May 14, 2013 at 09:39:46PM +0200, Harald Schilly wrote:\n>If you have your own domain, you can store your key there as a TXT entry.\n>\n>$ dig +short harald._pka.schil.ly. TXT\n>\n>and even use it automatically:\n>$ gpg \u2026 --auto-key-locate pka -r email at address.domain\n\nNice.  But we all kow about the security of DNS ;)\n\nAdam"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin2013 Speakers: Include your PGP fingerprint in your slides",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Melvin Carvalho",
                "Adam Back",
                "Harald Schilly",
                "Peter Todd"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 7449
        }
    },
    {
        "title": "[Bitcoin-development] RFC: c32d encoding",
        "thread_messages": [
            {
                "author": "Luke-Jr",
                "date": "2013-05-15T06:33:28",
                "message_text_only": "https://bitcointalk.org/?topic=205878\n\nThis encoding is designed so that it could replace Base58Check in new data, \nwith the following goals in mind:\n- Impossible(?) to manipulate without completely changing it\n- Clearly identifiable prefix, regardless of data size\n- Cheaper to process (simpler and faster code; it's a power-of-two radix)\n- Fixed length string for fixed length data\n- More unambiguous (removal of chars 'isuvzSVZ')\n- Compatible with using seven-segment displays\n- Altcoin friendly (16 bit namespace, which can be read without decoding)\n\nSince there are fewer digits and more identifying/signature characters, \naddresses are longer. This should be less of a problem since ordinary users \nwill hopefully be using addresses less common as the payment protocol becomes \nmore popular.\n\nExample Python code (including tests) is attached.\nI can write up a formal BIP if this seems useful.\n\nFor example:\n\n160 bits of data, such as current addresses:\n    2nc111dhAPE2aUdYAOF88JhLn5jEjbULy4eFe9tyFYFE8\nAn ordinary P2SH destination, incorporating Greg's \"require the hash mid-image \nto be relayed\" concept (256 bits of data):\n    2bc511A95e74P13dPb6b5t7yrh12EhC363ayH98n1cFbr3rAHdA49nCcC1G3P71j\nThe same key in Namecoin:\n    2nc5119ttL35HPhc3Hh6aHe2tOhF6rdFtAOE1ahFLt9Ecabhcn5FLea5Le71P56C\nThe example \"puzzle\" script from the wiki (arbitrary scripting):\n    2bc311d126acCyAnHAjabeUtOHcr7F811j4UYE6ECtOcbcGGn4O9chAt7O7y2LU9ty9cnG4\nAn alternative for BIP32 extended public keys (560 bits):\n    2bc911AcchHheAGFnn9LC6FdF7bOc99APJtcEc46U655JheH6LCr3Y333eFEOtPJ9rj22rEcchHheAGFnn9LC6FdF7bOc99APJtcEc46U655JheH6LCr3YJCtPYea\nAn alternative for BIP32 extended private keys (552 bits):\n    2bcb11O77GHdP53FH7Jh44OdEh3rLd4eFr2h7c8rGeErELG18yCy9O7L9LednyHJa5hyeAP77GHdP53FH7Jh44OdEh3rLd4eFr2h7c8rGeErELG18yCyGG5drPF1\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: c32.py\nType: text/x-python\nSize: 1597 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130515/a0507aa4/attachment.py>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: c32d.py\nType: text/x-python\nSize: 5012 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130515/a0507aa4/attachment-0001.py>"
            }
        ],
        "thread_summary": {
            "title": "RFC: c32d encoding",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Luke-Jr"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2327
        }
    },
    {
        "title": "[Bitcoin-development] 2BTC reward for making probabalistic double-spending via conflicting transactions easy",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2013-05-15T11:38:27",
                "message_text_only": "Now that I have the replace-by-fee reward, I might as well spread the\nwealth a bit.\n\n\nSo for all this discussion about replace-by-fee and the supposed\nsecurity of zero-conf transactions, no-one seems to think much about how\nin practice very few vendors have a setup to detect if conflicting\ntransactions were broadcast on the network simultaneously - after all if\nthat is the case which transaction gets mined is up to chance, so much\nof the time you'll get away with a double spend. We don't yet have a\nmechanism to propagate double-spend warnings, and funny enough, in the\ncase of a single txin transaction the double-spend warning is also\nenough information to allow miners to implement replace-by-fee.\n\n\nSo I'm offering 2BTC for anyone who comes up with a nice and easy to use\ncommand line tool that lets you automagically create one version of the\ntransaction sending the coins to the desired recipient, and another\nversion sending all the coins back to you, both with the same\ntransaction inputs. In addition to creating the two versions, you need\nto find a way to broadcast them both simultaneously to different nodes\non the network. One clever approach might be to use blockchain.info's\nraw transaction POST API, and your local Bitcoin node.\n\nIf you happen to be at the conference, a cool demo would be to\ndemonstrate the attack against my Android wallet. I'll buy Bitcoins off\nof you at Mt. Gox rates + %10, and you can see if you can rip me off.\nYes, you can keep the loot. :) This should be videotaped so we can put\nan educational video on youtube after.\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000bafd0a55f013e058cc2a672ee0c66b9265a02390d80e4748f5\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130515/3be421d9/attachment.sig>"
            },
            {
                "author": "Peter Todd",
                "date": "2013-05-15T12:19:50",
                "message_text_only": "On Wed, May 15, 2013 at 07:38:27AM -0400, Peter Todd wrote:\n> So I'm offering 2BTC for anyone who comes up with a nice and easy to use\n> command line tool that lets you automagically create one version of the\n> transaction sending the coins to the desired recipient, and another\n> version sending all the coins back to you, both with the same\n> transaction inputs. In addition to creating the two versions, you need\n> to find a way to broadcast them both simultaneously to different nodes\n> on the network. One clever approach might be to use blockchain.info's\n> raw transaction POST API, and your local Bitcoin node.\n\nOh, and while we're at it, a good starting point for your work would be\nGavin's spendfrom utility in the contrib/spendfrom directory in the\nBitcoin-QT respository.\n\nAlso please do keep in mind that it's much better for the community if\nan attack is demonstrated first, followed by releasing the code some\ntime later.\n\n-- \n'peter'[:-1]@petertodd.org\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130515/5e326fcf/attachment.sig>"
            },
            {
                "author": "Alan Reiner",
                "date": "2013-05-15T13:31:33",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nYou can do this right now, with Armory.   If you switch Armory to Expert\nusermode, you can combine coin-control with unsigned transactions to do\nexactly this.  It's because Armory doesn't \"lock\" coins used in previous\nunsigned transactions, until they're actually broadcast and confirmed to\nbe \"out in the wild\".  This was done for simplicity to avoid people\ngetting arbitrarily-locked coins, even though it means you end up\naccidentally double-spending if you try to create two different unsigned\ntransactions from the same wallet without sign&broadcasting the first one.\n\nSo here's what you do:\n(1) Switch to \"Expert\" usermode in Armory\n(2) Open any wallet (you don't need a watch-only wallet, full wallet is\nfine)\n(3) In the \"Send Bitcoins\" window, click coin-control\n(4) Create a transaction using one sufficiently large input\n(5) Click \"Create Unsigned Transaction\" and save it\n(6) Repeat 3-5 with the same coin, but sending to yourself, specify a\nlarger fee\n(7) Go into \"Offline Transactions\" and \"Sign and Broadcast Transactions\"\n(8) Load tx1, sign & broadcast\n(9) Load tx2, sign & broadcast\n\nThis only works if your Bitcoin-Qt/bitcoind client has the\nreplace-by-fee patch, since Armory uses Bitcoin-Qt/bitcoind as a gateway\nto the network. Otherwise, the second tx will be DOA.  But you don't\nhave to mess with Armory other than switching it to Expert mode to get\nto the coin-control feature.\n\n- -Alan\n\nP.S. -- If you try this, Armory is likely to not show the second tx as\nhaving ever happened (Bitcoin-Qt will send it back to us and we ignore\nit because we already have a tx).  But if your Bitcoin node has the\nmodification, it /will/ reach the network\n\n\nOn 05/15/2013 08:19 AM, Peter Todd wrote:\n> On Wed, May 15, 2013 at 07:38:27AM -0400, Peter Todd wrote:\n>> So I'm offering 2BTC for anyone who comes up with a nice and easy to use\n>> command line tool that lets you automagically create one version of the\n>> transaction sending the coins to the desired recipient, and another\n>> version sending all the coins back to you, both with the same\n>> transaction inputs. In addition to creating the two versions, you need\n>> to find a way to broadcast them both simultaneously to different nodes\n>> on the network. One clever approach might be to use blockchain.info's\n>> raw transaction POST API, and your local Bitcoin node.\n>\n> Oh, and while we're at it, a good starting point for your work would be\n> Gavin's spendfrom utility in the contrib/spendfrom directory in the\n> Bitcoin-QT respository.\n>\n> Also please do keep in mind that it's much better for the community if\n> an attack is demonstrated first, followed by releasing the code some\n> time later.\n>\n>\n>\n>\n------------------------------------------------------------------------------\n> AlienVault Unified Security Management (USM) platform delivers complete\n> security visibility with the essential security capabilities. Easily and\n> efficiently configure, manage, and operate all of your security controls\n> from a single console and one unified framework. Download a free trial.\n> http://p.sf.net/sfu/alienvault_d2d\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\nComment: Using GnuPG with Thunderbird - http://www.enigmail.net/\n\niQIcBAEBAgAGBQJRk441AAoJEBHe6b77WWmFZNQP/02t6cQkhih/CcA1oSCM72np\nKMRW0Z+piHShORxLyhMX3cIpi3ICJ2lJ/Pm6GfDn74oSHq8wipIFoV88xhy810bL\nMnJtbPH900v8PHh/ji2nWMig9NibeUa1zV9/tp31rYjUT3mmMoC4yQlyxKII8GWK\niignkAHV/UL5kQGmhmr1RKN127cthSMeIzAYWXfIWVObPNm85pvizVZdgqzSK73h\nvwdfeFOelNbVn8ZCNT19OsxWfAKZSaBMywAX95wQBs0BtY2ZgDRmeXa6MdQKpXGW\nKP3O2zjjJC2CKc4+L6elMfsoL1doEsk35w/GuI4HZK4MLAI8BChi6ZPnAYjdRvir\neHeszyxkKDCEaJ9JPLA/AszqkYHIB+56wTtrpVb1duyTwuqgVT5dcpMPIH8bDqjq\nk3I8C9zCSeQ6JgyvOd8grKJchRtq0SOWYt2bB3ytePzwOs+W+6mRenb/WtMt2dQg\nntDTEIG7pCsWHenipeTBzvJNqeSsAAoIXnkGY20iDxCB+uFkTzisoCQqpOIglArm\nvD+Cl2nv3OKU3NTVTUt2VinoFskezI7xvsxHD8xs2V/hrlpPbPRAo+l7ER6aTazj\nwrONfmllHSE2XCM7wb/bX3gBNmsM3zUIgSBmNSH/SQeTy8PvwvlkZ/RRYmtVSmHL\nrUTp7x4U63JiIDO1jj+T\n=JiPo\n-----END PGP SIGNATURE-----\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130515/9f78f5e6/attachment.html>"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2013-05-15T12:41:09",
                "message_text_only": "On 15 May 2013 13:38, Peter Todd <pete at petertodd.org> wrote:\n\n> Now that I have the replace-by-fee reward, I might as well spread the\n> wealth a bit.\n>\n>\n> So for all this discussion about replace-by-fee and the supposed\n> security of zero-conf transactions, no-one seems to think much about how\n> in practice very few vendors have a setup to detect if conflicting\n> transactions were broadcast on the network simultaneously - after all if\n> that is the case which transaction gets mined is up to chance, so much\n> of the time you'll get away with a double spend. We don't yet have a\n> mechanism to propagate double-spend warnings, and funny enough, in the\n> case of a single txin transaction the double-spend warning is also\n> enough information to allow miners to implement replace-by-fee.\n>\n>\n> So I'm offering 2BTC for anyone who comes up with a nice and easy to use\n> command line tool that lets you automagically create one version of the\n> transaction sending the coins to the desired recipient, and another\n> version sending all the coins back to you, both with the same\n> transaction inputs. In addition to creating the two versions, you need\n> to find a way to broadcast them both simultaneously to different nodes\n> on the network. One clever approach might be to use blockchain.info's\n> raw transaction POST API, and your local Bitcoin node.\n>\n> If you happen to be at the conference, a cool demo would be to\n> demonstrate the attack against my Android wallet. I'll buy Bitcoins off\n> of you at Mt. Gox rates + %10, and you can see if you can rip me off.\n> Yes, you can keep the loot. :) This should be videotaped so we can put\n> an educational video on youtube after.\n>\n\nIsnt it potentially inviting trouble by encouraging people to insert double\nspends into the block chain?\n\nSure, zero conf isnt 100% safe, we all know that.\n\nBut neither is the postal service.  Doesnt mean we should be going around\npromoting the creation of tools to go into people's maiilboxes and open\ntheir letters!\n\n\n>\n> --\n> 'peter'[:-1]@petertodd.org\n> 00000000000000bafd0a55f013e058cc2a672ee0c66b9265a02390d80e4748f5\n>\n>\n> ------------------------------------------------------------------------------\n> AlienVault Unified Security Management (USM) platform delivers complete\n> security visibility with the essential security capabilities. Easily and\n> efficiently configure, manage, and operate all of your security controls\n> from a single console and one unified framework. Download a free trial.\n> http://p.sf.net/sfu/alienvault_d2d\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130515/c2398578/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "2BTC reward for making probabalistic double-spending via conflicting transactions easy",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Melvin Carvalho",
                "Alan Reiner",
                "Peter Todd"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 10523
        }
    },
    {
        "title": "[Bitcoin-development] double-spend deletes (or converts to fees) (Re: reward for making probabalistic double-spending via conflicting transactions easy)",
        "thread_messages": [
            {
                "author": "Adam Back",
                "date": "2013-05-15T13:00:14",
                "message_text_only": "On Wed, May 15, 2013 at 07:38:27AM -0400, Peter Todd wrote:\n>no-one seems to think much about how in practice very few vendors have a\n>setup to detect if conflicting transactions were broadcast on the network\n>simultaneously - after all if that is the case which transaction gets mined\n>is up to chance, so much of the time you'll get away with a double spend. \n>We don't yet have a mechanism to propagate double-spend warnings, and funny\n>enough, in the case of a single txin transaction the double-spend warning\n>is also enough information to allow miners to implement replace-by-fee.\n\nAbout double-spends it might be better if the double-spend results in no-one\nkeeping the money ie it gets deleted by definition (except for the fees, or\nthe whole payment gets converted into a 0BTC output so 100% fees).  Ideally\nyou'd want a way for known double spends to be circulated at priority in the\np2p network, even routed directly to earlier recipients if known.  However\nhave to watch out for even the fees being double spent in other\ntransactions.  Maybe the fees could be demanded to be self-created (no\ntrusted green-coin issuer) 6-confirmation spend-to-miner green-coins.\n\n(Note double spends are not-binary.  An attacker can spend a 25BTC coin via\n50x 1BTC transactions.  Which 25 are valid?  Currently it is the first 25\nfrom the network perspective of the miner that succeeds on the current\nblock.  (And that view overrides, even if other miners had differing views,\nunless the block later becomes an orphan).  Its surely easy for a double\nspender to accumulate fast connections to known powerful miners to get the\nspends that benefit him to them first.)\n\nIn that way (with double-spend deletes) the would be double-spender can not\ngain within the bitcoin protocol by double spending.  He can gain outside of\nthe protocol eg by persuading merchants to give him non-revocable resellable\nnon-physical goods (or physical but anonymous goods).  But that is harder\nwork, and people selling goods with no recourse will be defensive about\nconfirmations.\n\nps I still dont think replace-by-fee is a good idea, at least the way it was\nimplemented with changeable outputs, but I think that discussion seemed\nclosed, so I wont rehash it.\n\nAdam"
            }
        ],
        "thread_summary": {
            "title": "double-spend deletes (or converts to fees) (Re: reward for making probabalistic double-spending via conflicting transactions easy)",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Adam Back"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2236
        }
    },
    {
        "title": "[Bitcoin-development] Modularizing Bitcoin",
        "thread_messages": [
            {
                "author": "bitcoingrant at gmx.com",
                "date": "2013-05-16T10:02:05",
                "message_text_only": "One of the primary upcoming priorities for bitcoin\u2019s infrastructure, beyond the bloom filter, will be the continued modularization of the system.\nHere at the Bitcoin Grant, we would like to jump start this development with a financial incentive and initiate an ongoing conversation on how we can work together towards developing a smarter, more efficient system of tomorrow, today.\nUp for grabs: 500 bitcoins or $500,000; whichever is greater.\nTaking on a project of this scope is a highly intensive, technical undertaking and we believe excellent developers should be compensated as such, especially when it comes to open source projects.\nOne of the main goals will be to separate the wallet from the node, as we have already done with mining. This way, the wallet, which will only hold private keys and create transactions, would pass transactions directly to a relay node, based on the bloom filter. Meanwhile, the block node will maintain the block chain and validate and relay new blocks.\nSuch developments would significantly strengthen the system. Modularization would make cancer attacks less likely and increase the node count, which, currently, is fairly low.\nThis is by no means is a feature request, merely ideas as to initiate a discussion. We welcome any feedback or suggestions. And of course, let us know if you would like to contribute to this project by submiting a grant proposal.\nhttp://bitcoingrant.org http://bitcoingrant.org/&lang=en\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130516/844108a4/attachment.html>"
            },
            {
                "author": "Addy Yeow",
                "date": "2013-05-16T10:27:26",
                "message_text_only": "> Such developments would significantly strengthen the system. Modularization would make cancer attacks less likely and increase the node count, which, currently, is fairly low.\n\nDo we know for certain or at least a rough figure of the node count in\nthe network?\n\nOn Thu, May 16, 2013 at 8:02 PM,  <bitcoingrant at gmx.com> wrote:\n> One of the primary upcoming priorities for bitcoin\u2019s infrastructure, beyond\n> the bloom filter, will be the continued modularization of the system.\n>\n> Here at the Bitcoin Grant, we would like to jump start this development with\n> a financial incentive and initiate an ongoing conversation on how we can\n> work together towards developing a smarter, more efficient system of\n> tomorrow, today.\n>\n> Up for grabs: 500 bitcoins or $500,000; whichever is greater.\n>\n> Taking on a project of this scope is a highly intensive, technical\n> undertaking and we believe excellent developers should be compensated as\n> such, especially when it comes to open source projects.\n>\n> One of the main goals will be to separate the wallet from the node, as we\n> have already done with mining. This way, the wallet, which will only hold\n> private keys and create transactions, would pass transactions directly to a\n> relay node, based on the bloom filter. Meanwhile, the block node will\n> maintain the block chain and validate and relay new blocks.\n>\n> Such developments would significantly strengthen the system. Modularization\n> would make cancer attacks less likely and increase the node count, which,\n> currently, is fairly low.\n>\n> This is by no means is a feature request, merely ideas as to initiate a\n> discussion. We welcome any feedback or suggestions. And of course, let us\n> know if you would like to contribute to this project by submiting a grant\n> proposal.\n>\n> http://bitcoingrant.org\n>\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> AlienVault Unified Security Management (USM) platform delivers complete\n> security visibility with the essential security capabilities. Easily and\n> efficiently configure, manage, and operate all of your security controls\n> from a single console and one unified framework. Download a free trial.\n> http://p.sf.net/sfu/alienvault_d2d\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Brenton Camac",
                "date": "2013-05-16T16:43:14",
                "message_text_only": "It would be nice if that modularization effort would first and foremost focus on defining the protocols and APIs of the various modules (their responsibilities and patterns of interaction), rather than merely refactoring existing code.\n\nSuch an approach has many benefits.  \n\nFirst, it promotes diversity of implementations.  Diverse implementations are now possible because the correctness of an implementation is now determined entirely by the compliance of its external behavior with the stated protocols and not its internal design. Thus this approach allows for equivalent but alternate implementations. Consequently, this approach -\n\n1. increases the available pool of developers\n2. reduces the impact any one implementation defect can have on the overall Bitcoin infrastructure\n3. allows enhancement/optimization work of modules to proceed more easily as coupling with external modules is reduced\n\nSecond, and just as important, it allows analysis and critiquing of Bitcoin's infrastructure to be undertaken at a higher level than source code: i.e. abstract entities of the protocols and APIs.  Such scrutiny is important to being able to effectively manage the evolution of a system's architecture.\n\nIts been my first-hand experience across many projects that this strategy contributes directly to significant improvements to quality when developing large, distributed, complex software systems.  Indeed, its considered a best practice when developing enterprise-grade software.\n\nI would be happy to collaborate with others in such an undertaking.\n\n- Brenton\n\n\n\nOn May 16, 2013, at 3:02 AM, bitcoingrant at gmx.com wrote:\n\n> One of the primary upcoming priorities for bitcoin\u2019s infrastructure, beyond the bloom filter, will be the continued modularization of the system.\n> Here at the Bitcoin Grant, we would like to jump start this development with a financial incentive and initiate an ongoing conversation on how we can work together towards developing a smarter, more efficient system of tomorrow, today.\n> Up for grabs: 500 bitcoins or $500,000; whichever is greater.\n> Taking on a project of this scope is a highly intensive, technical undertaking and we believe excellent developers should be compensated as such, especially when it comes to open source projects.\n> One of the main goals will be to separate the wallet from the node, as we have already done with mining. This way, the wallet, which will only hold private keys and create transactions, would pass transactions directly to a relay node, based on the bloom filter. Meanwhile, the block node will maintain the block chain and validate and relay new blocks.\n> Such developments would significantly strengthen the system. Modularization would make cancer attacks less likely and increase the node count, which, currently, is fairly low.\n> This is by no means is a feature request, merely ideas as to initiate a discussion. We welcome any feedback or suggestions. And of course, let us know if you would like to contribute to this project by submiting a grant proposal.\n> http://bitcoingrant.org\n>  \n> \n>   ------------------------------------------------------------------------------\n> AlienVault Unified Security Management (USM) platform delivers complete\n> security visibility with the essential security capabilities. Easily and\n> efficiently configure, manage, and operate all of your security controls\n> from a single console and one unified framework. Download a free trial.\n> http://p.sf.net/sfu/alienvault_d2d_______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130516/f0087602/attachment-0001.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-05-16T19:35:29",
                "message_text_only": "I'm all for funding of Bitcoin development, but I suggest talking to Gavin\nto find out what efforts would be the biggest win right now. I don't see\nwhy separating wallet code from the main Bitcoin process would increase\nnode count, as the cost of running the node is almost all in keeping up\nwith transaction traffic and time spent in the wallet is likely to dominate\nonly for large merchants or exchanges.\n\nThat said, you can already do this today - just run an SPV wallet like\nbitcoinj connected to your personal node. The wallet code in bitcoind won't\nbe used for anything.\n\nThere are lots of things that can be done, but the best way to approach\nthis is to get tightly written technical requirements from people in the\nknow, and then contract with developers. Bounty style development has the\nrisk of uncoordinated development that duplicates work and puts pressure on\nGavin or other maintainers to accept shoddy code due to the \"first past the\npost\" winning criteria. Finding developers you trust and contracting with\nthem for well specified improvements minimises risk for everyone.\n\n\nOn Thu, May 16, 2013 at 3:02 AM, <bitcoingrant at gmx.com> wrote:\n\n> One of the primary upcoming priorities for bitcoin\u2019s infrastructure,\n> beyond the bloom filter, will be the continued modularization of the system.\n>\n> Here at the Bitcoin Grant, we would like to jump start this development\n> with a financial incentive and initiate an ongoing conversation on how we\n> can work together towards developing a smarter, more efficient system of\n> tomorrow, today.\n>\n> Up for grabs: 500 bitcoins or $500,000; whichever is greater.\n>\n> Taking on a project of this scope is a highly intensive, technical\n> undertaking and we believe excellent developers should be compensated as\n> such, especially when it comes to open source projects.\n>\n> One of the main goals will be to separate the wallet from the node, as we\n> have already done with mining. This way, the wallet, which will only hold\n> private keys and create transactions, would pass transactions directly to a\n> relay node, based on the bloom filter. Meanwhile, the block node will\n> maintain the block chain and validate and relay new blocks.\n>\n> Such developments would significantly strengthen the system.\n> Modularization would make cancer attacks less likely and increase the node\n> count, which, currently, is fairly low.\n>\n> This is by no means is a feature request, merely ideas as to initiate a\n> discussion. We welcome any feedback or suggestions. And of course, let us\n> know if you would like to contribute to this project by submiting a grant\n> proposal.\n>\n> http://bitcoingrant.org <http://bitcoingrant.org/&lang=en>\n>\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> AlienVault Unified Security Management (USM) platform delivers complete\n> security visibility with the essential security capabilities. Easily and\n> efficiently configure, manage, and operate all of your security controls\n> from a single console and one unified framework. Download a free trial.\n> http://p.sf.net/sfu/alienvault_d2d\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130516/0c7c9020/attachment.html>"
            },
            {
                "author": "Quinn Harris",
                "date": "2013-05-20T05:16:12",
                "message_text_only": "Could this modularization effort lead to a special compiled bitcoind \nsimulator that runs many virtual instances of a node on the same system \n(possibly same process)? The simulator would cache crypto computation \nresults (ECDSA, SSH-256) to significantly speed up processing \ntransactions and blocks between the virtual nodes.  The virtual nodes \nwould also need to share the same block data in memory when possible.  \nThis would also require significant additional work to simulate the \nnetwork and possibly computational limits.\n\nThe transactions on the existing block chain could be replayed into \nrandomly chosen virtual nodes to help ensure any code changes would not \nhave caused problems with historic transactions.  You could even record \nall the messages for some time on many real nodes and use that as test \ndata for the simulator.  Many other test programs could be devised to \nquickly simulate other network activity.\n\nThis wouldn't completely replace the test network but could provide \ngreater and quicker confidence that code changes are safe.\n\n- Quinn\n\n\nOn 05/16/2013 04:02 AM, bitcoingrant at gmx.com wrote:\n> One of the primary upcoming priorities for bitcoin's infrastructure, \n> beyond the bloom filter, will be the continued modularization of the \n> system.\n>\n> Here at the Bitcoin Grant, we would like to jump start this \n> development with a financial incentive and initiate an ongoing \n> conversation on how we can work together towards developing a smarter, \n> more efficient system of tomorrow, today.\n>\n> Up for grabs: 500 bitcoins or $500,000; whichever is greater.\n>\n> Taking on a project of this scope is a highly intensive, technical \n> undertaking and we believe excellent developers should be compensated \n> as such, especially when it comes to open source projects.\n>\n> One of the main goals will be to separate the wallet from the node, as \n> we have already done with mining. This way, the wallet, which will \n> only hold private keys and create transactions, would pass \n> transactions directly to a relay node, based on the bloom filter. \n> Meanwhile, the block node will maintain the block chain and validate \n> and relay new blocks.\n>\n> Such developments would significantly strengthen the system. \n> Modularization would make cancer attacks less likely and increase the \n> node count, which, currently, is fairly low.\n>\n> This is by no means is a feature request, merely ideas as to initiate \n> a discussion. We welcome any feedback or suggestions. And of course, \n> let us know if you would like to contribute to this project by \n> submiting a grant proposal.\n>\n> http://bitcoingrant.org <http://bitcoingrant.org/&lang=en>\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> AlienVault Unified Security Management (USM) platform delivers complete\n> security visibility with the essential security capabilities. Easily and\n> efficiently configure, manage, and operate all of your security controls\n> from a single console and one unified framework. Download a free trial.\n> http://p.sf.net/sfu/alienvault_d2d\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130519/49b165f2/attachment.html>"
            },
            {
                "author": "Luke-Jr",
                "date": "2013-05-26T23:53:57",
                "message_text_only": "On Thursday, May 16, 2013 10:02:05 AM bitcoingrant at gmx.com wrote:\n> One of the main goals will be to separate the wallet from the node, as we\n> have already done with mining.\n\nHow is this different from what Electrum has already done?\n\nLuke"
            },
            {
                "author": "bitcoingrant at gmx.com",
                "date": "2013-05-16T10:48:08",
                "message_text_only": "our estimates: ~8000\n----- Original Message -----\nFrom: Addy Yeow\nSent: 05/16/13 06:27 AM\nTo: bitcoingrant at gmx.com\nSubject: Re: [Bitcoin-development] Modularizing Bitcoin\n\n> Such developments would significantly strengthen the system. Modularization would make cancer attacks less likely and increase the node count, which, currently, is fairly low. Do we know for certain or at least a rough figure of the node count in the network?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130516/20112d50/attachment.html>"
            },
            {
                "author": "Addy Yeow",
                "date": "2013-05-16T10:55:44",
                "message_text_only": "Is the number representing the count for the client nodes?\n\nI was curious of the count myself earlier this week and started to\ntraverse down the network using getaddr message starting from seed\nnodes and found upward to 57k nodes running protocol >= 70001 with\ntimestamp no older than 24 hours.\n\nOn Thu, May 16, 2013 at 8:48 PM,  <bitcoingrant at gmx.com> wrote:\n> our estimates: ~8000\n>\n>\n>\n> ----- Original Message -----\n>\n> From: Addy Yeow\n>\n> Sent: 05/16/13 06:27 AM\n>\n> To: bitcoingrant at gmx.com\n>\n> Subject: Re: [Bitcoin-development] Modularizing Bitcoin\n>\n>\n>\n>> Such developments would significantly strengthen the system.\n>> Modularization would make cancer attacks less likely and increase the node\n>> count, which, currently, is fairly low.\n>\n> Do we know for certain or at least a rough figure of the node count in\n> the network?\n>"
            },
            {
                "author": "Luke-Jr",
                "date": "2013-05-26T23:57:10",
                "message_text_only": "On Thursday, May 16, 2013 10:55:44 AM Addy Yeow wrote:\n> Is the number representing the count for the client nodes?\n> \n> I was curious of the count myself earlier this week and started to\n> traverse down the network using getaddr message starting from seed\n> nodes and found upward to 57k nodes running protocol >= 70001 with\n> timestamp no older than 24 hours.\n\nThis sounds accurate for listening nodes, and similar to what my own system \ncounts: http://luke.dashjr.org/programs/bitcoin/files/charts/security.html\n\nOf course, it doesn't include the (many?) connect-only nodes (eg, mobile or \nfirewall/NAT'd) or non-p2p nodes (eg, Electrum).\n\nLuke"
            },
            {
                "author": "Ron",
                "date": "2013-05-26T21:46:32",
                "message_text_only": "From: <bitcoingrant at gm...> - 2013-05-16 10:02\n\t  \t\n\n\n            \n            \n            One of the primary upcoming priorities for bitcoin\u2019s infrastructure, beyond the bloom filter, will be the continued modularization of the system.\nHere at the Bitcoin Grant, we would like to jump start this development with a financial incentive and initiate an ongoing conversation on how we can work together towards developing a smarter, more efficient system of tomorrow, today.\nUp for grabs: 500 bitcoins or $500,000; whichever is greater.\nTaking on a project of this scope is a highly intensive, technical undertaking and we believe excellent developers should be compensated as such, especially when it comes to open source projects.\nOne of the main goals will be to separate the wallet from the node, as we have already done with mining. This way, the wallet, which will only hold private keys and create transactions, would pass transactions directly to a relay node, based on the bloom filter. Meanwhile, the block node will maintain the block chain and validate and relay new blocks.\nSuch developments would significantly strengthen the system. Modularization would make cancer attacks less likely and increase the node count, which, currently, is fairly low.\nThis is by no means is a feature request, merely ideas as to initiate a discussion. We welcome any feedback or suggestions. And of course, let us know if you would like to contribute to this project by submiting a grant proposal.\nhttp://bitcoingrant.org http://bitcoingrant.org/&lang=en\n\n\nHello\n\nI don't know if this is the proper method of replying or even if \nI am allowed to reply!\n\nModularization can have many meanings, depending upon one's past! \nThe code is somewhat compartmentalized/modularized now. But if one \nforces complete separation of the parts, with a 'loose coupling', \netc., I find that the performance tends to suffer and the size \nincreases. \n\nIn the Java world there is the notion of refactoring one's code. \nThis would be too much, I think, in this case. When I developed \nwith a team and alone, I would make what used to be called \n'step-wise refinements' on existing working code. To me, one of \nthings this meant was doing a one to one transformation of the \nsource code, in such a way as to have the identical, byte for \nbyte, executable file, but a 'better' set of source files. A \nsimilar process would seem appropriate here. Especially since \nthere is much in the code that I don't understand :) \n\nAs to 'separating the wallet from the node', do you mean allowing \nthe wallet.dat file to be anywhere, and not restricted to the 'OS default' \nor 'datadir' directory? If so, I have done that with no change to the \ncurrent behavior, and also the wallet.dat now can have any legal \nfilename too! I haven't tested it yet on bitcoin-qt, but it runs \non bitcoind. I am still 'ramping up' on github to get the code into \nview. After testing on bitcoin-qt of course.\n\nWhat may I ask, is a cancer attack?\n\nIf any of this inappropriate, forgive me.\n\nRon\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130526/e04fd700/attachment.html>"
            },
            {
                "author": "Tamas Blummer",
                "date": "2013-05-27T02:57:38",
                "message_text_only": "There is a modular, modern, open source implementation of the BItcoin protocol with properties, e.g. remote wallet, you look for at bitcoingrant. It is Bits of Proof. A supported and hosted product launched at the BItcoin2013. \n\nYou find the source at https://github.com/bitsofproof/supernode and supporting documentation at http://bitsofproof.com\n\nTam\u00e1s Blummer\n\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130527/5a72cae4/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Modularizing Bitcoin",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Addy Yeow",
                "Quinn Harris",
                "Luke-Jr",
                "Tamas Blummer",
                "Mike Hearn",
                "bitcoingrant at gmx.com",
                "Brenton Camac",
                "Ron"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 21045
        }
    },
    {
        "title": "[Bitcoin-development] is there a way to do bitcoin-staging?",
        "thread_messages": [
            {
                "author": "Adam Back",
                "date": "2013-05-19T13:23:59",
                "message_text_only": "Is there a way to experiment with new features - eg committed coins - that\ndoesnt involve an altcoin in the conventional sense, and also doesnt impose\na big testing burden on bitcoin main which is a security and testing risk?\n\neg lets say some form of merged mine where an alt-coin lets call it\nbitcoin-staging?  where the coins are the same coins as on bitcoin, the\nmining power goes to bitcoin main, so some aspect of merged mining, but no\nnative mining.  and ability to use bitcoins by locking them on bitcoin to\nmove them to bitcoin-staging and vice versa (ie exchange them 1:1\ncryptographically, no exchange).\n\nDid anyone figure anything like that out?  Seems vaguely doable and\nmaybe productive.  The only people with coins at risk of defects in a new\nfeature, or insufficiently well tested novel feature are people with coins\non bitcoin-staging.\n\nYes I know about bitcoin-test this is not it.  I mean a real live system,\nwith live value, but that is intentionally wanting to avoid forking bitcoins\nparameters, nor value, nor mindshare dillution.  In this way something\npotentially interesting could move forward faster, and be les risky to the\nmain bitcoin network.  eg particularly defenses against \n\nIt might also be a more real world test test (after bitcoin-test) because\nsome parameters are different on test, and some issues may not manifest\nwithout more real activity.\n\nThen also bitcoin could cherry pick interesting patches and merge them after\nextensive real-world validation with real-money at stake (by early\nadopters).\n\nAdam"
            },
            {
                "author": "Peter Vessenes",
                "date": "2013-05-19T15:08:59",
                "message_text_only": "I think this is a very interesting idea. As Bitcoiners, we often stuff\nthings into the 'alt chain' bucket in our heads; I wonder if this idea\nworks better as a curing period, essentially an extended version of the\ncurrent 100 block wait for mined coins.\n\nAn alternate setup comes to mind; I can imagine this working as a sort of\ngift economy; people pay real BTC for merge-mined \"beta BTC\" as a way to\nsupport development. There is no doubt a more elegant and practical\nsolution that might have different economic and crypto characteristics.\n\n\n\nOn Sun, May 19, 2013 at 6:23 AM, Adam Back <adam at cypherspace.org> wrote:\n\n> Is there a way to experiment with new features - eg committed coins - that\n> doesnt involve an altcoin in the conventional sense, and also doesnt impose\n> a big testing burden on bitcoin main which is a security and testing risk?\n>\n> eg lets say some form of merged mine where an alt-coin lets call it\n> bitcoin-staging?  where the coins are the same coins as on bitcoin, the\n> mining power goes to bitcoin main, so some aspect of merged mining, but no\n> native mining.  and ability to use bitcoins by locking them on bitcoin to\n> move them to bitcoin-staging and vice versa (ie exchange them 1:1\n> cryptographically, no exchange).\n>\n> Did anyone figure anything like that out?  Seems vaguely doable and\n> maybe productive.  The only people with coins at risk of defects in a new\n> feature, or insufficiently well tested novel feature are people with coins\n> on bitcoin-staging.\n>\n> Yes I know about bitcoin-test this is not it.  I mean a real live system,\n> with live value, but that is intentionally wanting to avoid forking\n> bitcoins\n> parameters, nor value, nor mindshare dillution.  In this way something\n> potentially interesting could move forward faster, and be les risky to the\n> main bitcoin network.  eg particularly defenses against\n>\n> It might also be a more real world test test (after bitcoin-test) because\n> some parameters are different on test, and some issues may not manifest\n> without more real activity.\n>\n> Then also bitcoin could cherry pick interesting patches and merge them\n> after\n> extensive real-world validation with real-money at stake (by early\n> adopters).\n>\n> Adam\n>\n>\n> ------------------------------------------------------------------------------\n> AlienVault Unified Security Management (USM) platform delivers complete\n> security visibility with the essential security capabilities. Easily and\n> efficiently configure, manage, and operate all of your security controls\n> from a single console and one unified framework. Download a free trial.\n> http://p.sf.net/sfu/alienvault_d2d\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n\n\n\n-- \nAre you coming to Bitcoin2013 <http://bitcoin2013.com> in San Jose In May?\n------------------------------\n\n[image: CoinLab Logo]PETER VESSENES\nCEO\n\n*peter at coinlab.com * /  206.486.6856  / SKYPE: vessenes\n71 COLUMBIA ST / SUITE 300  /  SEATTLE, WA 98104\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130519/64712563/attachment.html>"
            },
            {
                "author": "Alan Reiner",
                "date": "2013-05-20T06:34:06",
                "message_text_only": "This is exactly what I was planning to do with the inappropriately-named \n\"Ultimate Blockchain Compression \n<https://bitcointalk.org/index.php?topic=88208.0>\".  I wanted to \nreorganize the blockchain data into an authenticated tree, indexed by \nTxOut script (address), instead of tx-hash.  Much like a regular merkle \ntree, you can store the root in the block header, and communicate \nbranches of that tree to nodes, to prove inclusion (and exclusion!) of \nTxOuts for any given script/address.  Additionally, you can include at \neach node, the sum of BTC in all nodes below it, which offers some other \nnice benefits.\n\nI think this idea is has epic upside-potential for bitcoin if it works \n-- even \"SPV\" nodes could query their unspent TxOut list for their \nwallet from any untrusted peer and compare the result directly to the \nblockheaders/POW.  Given nothing but the headers, you can verify the \nbalance of 100 addresses with 250 kB.  But also epic failure-potential \nin terms of feasibility and cost-to-benefit for miners.  For it to \nreally work, it's gotta be part of the mainnet validation rules, but no \nway it can be evaluated realistically without some kind of \"staging\".  \nTherefore, I had proposed that this be merge-mined on a \"meta-chain\" \nfirst...get a bunch of miners on board to agree to merge mine and see it \nin action.  It seemed like a perfectly non-disruptive way to prove out a \nparticular idea before we actually consider making a protocol change \nthat significant.  Even if it stayed on its own meta chain, as long as \nthere is some significant amount of hashpower working on it, it can \nstill be a useful tool.\n\nUnfortunately, my experience with merged mining is minimal, so I'm still \nnot clear how feasible/reliable it is as an alternative to direct \nblockchain integration.  That's a discussion I'd like to have.\n\n-Alan\n\n\nOn 5/19/2013 11:08 AM, Peter Vessenes wrote:\n> I think this is a very interesting idea. As Bitcoiners, we often stuff \n> things into the 'alt chain' bucket in our heads; I wonder if this idea \n> works better as a curing period, essentially an extended version of \n> the current 100 block wait for mined coins.\n>\n> An alternate setup comes to mind; I can imagine this working as a sort \n> of gift economy; people pay real BTC for merge-mined \"beta BTC\" as a \n> way to support development. There is no doubt a more elegant and \n> practical solution that might have different economic and crypto \n> characteristics.\n>\n>\n>\n> On Sun, May 19, 2013 at 6:23 AM, Adam Back <adam at cypherspace.org \n> <mailto:adam at cypherspace.org>> wrote:\n>\n>     Is there a way to experiment with new features - eg committed\n>     coins - that\n>     doesnt involve an altcoin in the conventional sense, and also\n>     doesnt impose\n>     a big testing burden on bitcoin main which is a security and\n>     testing risk?\n>\n>     eg lets say some form of merged mine where an alt-coin lets call it\n>     bitcoin-staging?  where the coins are the same coins as on\n>     bitcoin, the\n>     mining power goes to bitcoin main, so some aspect of merged\n>     mining, but no\n>     native mining.  and ability to use bitcoins by locking them on\n>     bitcoin to\n>     move them to bitcoin-staging and vice versa (ie exchange them 1:1\n>     cryptographically, no exchange).\n>\n>     Did anyone figure anything like that out?  Seems vaguely doable and\n>     maybe productive.  The only people with coins at risk of defects\n>     in a new\n>     feature, or insufficiently well tested novel feature are people\n>     with coins\n>     on bitcoin-staging.\n>\n>     Yes I know about bitcoin-test this is not it.  I mean a real live\n>     system,\n>     with live value, but that is intentionally wanting to avoid\n>     forking bitcoins\n>     parameters, nor value, nor mindshare dillution.  In this way something\n>     potentially interesting could move forward faster, and be les\n>     risky to the\n>     main bitcoin network.  eg particularly defenses against\n>\n>     It might also be a more real world test test (after bitcoin-test)\n>     because\n>     some parameters are different on test, and some issues may not\n>     manifest\n>     without more real activity.\n>\n>     Then also bitcoin could cherry pick interesting patches and merge\n>     them after\n>     extensive real-world validation with real-money at stake (by early\n>     adopters).\n>\n>     Adam\n>\n>     ------------------------------------------------------------------------------\n>     AlienVault Unified Security Management (USM) platform delivers\n>     complete\n>     security visibility with the essential security capabilities.\n>     Easily and\n>     efficiently configure, manage, and operate all of your security\n>     controls\n>     from a single console and one unified framework. Download a free\n>     trial.\n>     http://p.sf.net/sfu/alienvault_d2d\n>     _______________________________________________\n>     Bitcoin-development mailing list\n>     Bitcoin-development at lists.sourceforge.net\n>     <mailto:Bitcoin-development at lists.sourceforge.net>\n>     https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n>\n> -- \n> Are you coming to Bitcoin2013 <http://bitcoin2013.com> in San Jose In \n> May?\n> ------------------------------------------------------------------------\n>\n> CoinLab LogoPETER VESSENES\n> CEO\n>\n> *peter at coinlab.com <mailto:peter at coinlab.com> * /  206.486.6856  / \n> SKYPE: vessenes\n> 71 COLUMBIA ST / SUITE 300  /  SEATTLE, WA 98104\n>\n>\n>\n> ------------------------------------------------------------------------------\n> AlienVault Unified Security Management (USM) platform delivers complete\n> security visibility with the essential security capabilities. Easily and\n> efficiently configure, manage, and operate all of your security controls\n> from a single console and one unified framework. Download a free trial.\n> http://p.sf.net/sfu/alienvault_d2d\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130520/93b18b19/attachment.html>"
            },
            {
                "author": "zooko",
                "date": "2013-05-22T03:37:23",
                "message_text_only": "Folks:\n\nI'm very interested in this idea. I got really excited about it and started\ntrying to write up schemes to implement it. Like much of Bitcoin, it gets my\nhead spinning, but then it turns out I don't really understand it.\n\nBecause when my write-ups of implementations all turned to dust and ashes, then\nI reconsidered, and I realized that I don't actually understand how the\nproposed thing is different than testnet. The proposed difference seems to be\nabout assigning real value to the coins on this \"beta bitcoin blockchain\", but\nthat's mostly not up to developers, except possibly through some crazy scheme\nwhich forces \"beta bitcoins\" to be exchangeable for real bitcoins... Actually,\nno, not even then.\n\nSo I guess what is *really* exciting about this idea has nothing to do with\nmaking the \"beta\" coins valuable nor with novel schemes for linking\nsemi-independent blockchains. What is really exciting about it is a shared\ncodebase that the Bitcoin core developers are (at least nominally) paying\nattention to, and that you can play with on some public blockchain.\n\nSo if that's the right goal, then the solution is a branch or a fork on github,\nand a name such as \"bitcoin-next\" or \"bitcoin-staging\" or whatever that confers\na certain aura of relevance.\n\nAnd maybe some publicly celebrated list of the testnet blockchain forks which\nhave been inevitably created by this \"bitcoin-next\" codebase.\n\nIt would give people with the \"better Bitcoin bug\" (such as me) a common\ncodebase to aim pull requests at, and to fork on github.\n\nLike Peter Vessenes says, this idea sounds like an alternative to \"go do it on\nan alt coin\".\n\nThis feels different to me from the \"go do it on an alt coin\" idea, because I\nsuspect most bitcoin core devs aren't really paying that much attention to alt\ncoin. I know *I'm* not paying attention to them, because I'm already overloaded\nwith things to learn. Having to learn about alt coins in order to try to\ncommunicate with bitcoin core devs that may or may not be really paying\nattention to the alt coin sounds daunting.\n\nRegards,\n\nZooko"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-05-22T04:12:52",
                "message_text_only": "On Tue, May 21, 2013 at 11:37 PM, zooko <zooko at zooko.com> wrote:\n> Folks:\n>\n> I'm very interested in this idea. I got really excited about it and started\n> trying to write up schemes to implement it. Like much of Bitcoin, it gets my\n> head spinning, but then it turns out I don't really understand it.\n>\n> Because when my write-ups of implementations all turned to dust and ashes, then\n> I reconsidered, and I realized that I don't actually understand how the\n> proposed thing is different than testnet. The proposed difference seems to be\n> about assigning real value to the coins on this \"beta bitcoin blockchain\", but\n> that's mostly not up to developers, except possibly through some crazy scheme\n> which forces \"beta bitcoins\" to be exchangeable for real bitcoins... Actually,\n> no, not even then.\n\nNote that testnet operates under the threat of being reset at any\ntime, if someone comes along and destroys its usefulness with spam or\nmining or whatnot.  That guarantees it remains a testing tool, and not\na real alt-currency.  The current testnet is the third iteration,\nhence you see \"testnet3\" in some source code.\n\nThis option is always available for any merge-mined chain as well,\nensuring little real value is assigned to the test chain.\n\nBut that is a binary decision:  If you don't have a reset-the-chain\npolicy, you have a de facto \"it is a real currency\" policy.\n\n\n> So I guess what is *really* exciting about this idea has nothing to do with\n> making the \"beta\" coins valuable nor with novel schemes for linking\n> semi-independent blockchains. What is really exciting about it is a shared\n> codebase that the Bitcoin core developers are (at least nominally) paying\n> attention to, and that you can play with on some public blockchain.\n>\n> So if that's the right goal, then the solution is a branch or a fork on github,\n> and a name such as \"bitcoin-next\" or \"bitcoin-staging\" or whatever that confers\n> a certain aura of relevance.\n>\n> And maybe some publicly celebrated list of the testnet blockchain forks which\n> have been inevitably created by this \"bitcoin-next\" codebase.\n>\n> It would give people with the \"better Bitcoin bug\" (such as me) a common\n> codebase to aim pull requests at, and to fork on github.\n\nA fork of the bitcoin.git codebase has the nice attribute of making it\neasy to \"upstream\" any useful changes that are not specific to that\none alt-coin.\n\n\n> This feels different to me from the \"go do it on an alt coin\" idea, because If\n> suspect most bitcoin core devs aren't really paying that much attention to alt\n> coin. I know *I'm* not paying attention to them, because I'm already overloaded\n> with things to learn. Having to learn about alt coins in order to try to\n> communicate with bitcoin core devs that may or may not be really paying\n> attention to the alt coin sounds daunting.\n\nWhat's neat about bitcoin is that it invented a whole new /category/\nof technology.  It's not just /an/ invention, but opened up all this\nnew experimentation with the new concept of money itself.\n\nHowever for the bitcoin.git reference implementation, it makes more\nsense to focus on supporting existing bitcoin users.  That permits\nalt-coins to bubble up (or not) organically, and at the same time\nreduces user confusion.  We have enough trouble explaining the basics\nof bitcoin to the world; trying to keep follow every alt-coin\nbandwagon just muddies the waters from a messaging standpoint.\n\nalt-coin changes fall into two categories:\n1) Rule changes.  We don't want these.\n2) Generic bug fixes, cleanups, changes etc.  It would be nice to see\nimprovements bubble up, benefitting everybody.\n\n\n-- \nJeff Garzik\nexMULTI, Inc.\njgarzik at exmulti.com"
            },
            {
                "author": "Luke-Jr",
                "date": "2013-05-20T07:12:16",
                "message_text_only": "This sounds similar to the \"bitcoin2\" branch I created a while back - \nbasically a \"next\"-like branch, but for hardforking changes that refused to \nrun without the -testnet option. There's so much non-hardforking code that can \nbe written/tested, at this point, that I think it was and maybe is premature \nto be writing hardforking code outside of necessity. But perhaps if you want \nto play around, it might be a good starting point (it can probably merge up to \nlatest master, and trivial to rebase if not).\n\nOn Sunday, May 19, 2013 1:23:59 PM Adam Back wrote:\n> Is there a way to experiment with new features - eg committed coins - that\n> doesnt involve an altcoin in the conventional sense, and also doesnt impose\n> a big testing burden on bitcoin main which is a security and testing risk?\n> \n> eg lets say some form of merged mine where an alt-coin lets call it\n> bitcoin-staging?  where the coins are the same coins as on bitcoin, the\n> mining power goes to bitcoin main, so some aspect of merged mining, but no\n> native mining.  and ability to use bitcoins by locking them on bitcoin to\n> move them to bitcoin-staging and vice versa (ie exchange them 1:1\n> cryptographically, no exchange).\n> \n> Did anyone figure anything like that out?  Seems vaguely doable and\n> maybe productive.  The only people with coins at risk of defects in a new\n> feature, or insufficiently well tested novel feature are people with coins\n> on bitcoin-staging.\n> \n> Yes I know about bitcoin-test this is not it.  I mean a real live system,\n> with live value, but that is intentionally wanting to avoid forking\n> bitcoins parameters, nor value, nor mindshare dillution.  In this way\n> something potentially interesting could move forward faster, and be les\n> risky to the main bitcoin network.  eg particularly defenses against\n> \n> It might also be a more real world test test (after bitcoin-test) because\n> some parameters are different on test, and some issues may not manifest\n> without more real activity.\n> \n> Then also bitcoin could cherry pick interesting patches and merge them\n> after extensive real-world validation with real-money at stake (by early\n> adopters).\n> \n> Adam\n> \n> ---------------------------------------------------------------------------\n> --- AlienVault Unified Security Management (USM) platform delivers complete\n> security visibility with the essential security capabilities. Easily and\n> efficiently configure, manage, and operate all of your security controls\n> from a single console and one unified framework. Download a free trial.\n> http://p.sf.net/sfu/alienvault_d2d\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            }
        ],
        "thread_summary": {
            "title": "is there a way to do bitcoin-staging?",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Luke-Jr",
                "Adam Back",
                "Peter Vessenes",
                "Alan Reiner",
                "zooko"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 19645
        }
    },
    {
        "title": "[Bitcoin-development] UUID to identify chains (payment protocol and elsewhere)",
        "thread_messages": [
            {
                "author": "Mark Friedenbach",
                "date": "2013-05-20T23:59:39",
                "message_text_only": "At the developer round-table it was asked if the payment protocol would \nalt-chains, and Gavin noted that it has a UTF-8 encoded string \nidentifying the network (\"main\" or \"test\"). As someone with two \nproposals in the works which also require chain/coin identification (one \nfor merged mining, one for colored coins), I am opinionated on this. I \nbelieve that we need a standard mechanism for identifying chains, and \none which avoids the trap of maintaining a standard registry of \nstring-to-chain mappings.\n\nAny chain can be uniquely identified by its genesis block, 122 random \nbits is more than sufficient for uniquely tagging chains/colored assets, \nand the low-order 16-bytes of the block's hash are effectively random. \nWith these facts in mind, I propose that we identify chains by UUID.\n\nSo as to remain reasonably compliant with RFC 4122, I recommend that we \nuse Version 4 (random) UUIDs, with the random bits extracted from the \ndouble-SHA256 hash of the genesis block of the chain. (For colored \ncoins, the colored coin definition transaction would be used instead, \nbut I will address that in a separate proposal and will say just one \nthing about it: adopting this method for identifying chains/coins will \ngreatly assist in adopting the payment protocol to colored coins.)\n\nThe following Python code illustrates how to construct the chain \nidentifier from the serialized genesis block:\n\n     from hashlib import sha256\n     from uuid import UUID\n     def chain_uuid(serialized_genesis_block):\n         h = sha256(serialized_genesis_block).digest()\n         h = sha256(h).digest()\n         h = h[:16]\n         h = ''.join([\n             h[:6],\n             chr(0x40 | ord(h[6]) & 0x0f),\n             h[7],\n             chr(0x80 | ord(h[8]) & 0x3f),\n             h[9:]\n         ])\n         return UUID(bytes=h)\n\nAnd some example chain identifiers:\n\n     mainnet:  UUID('6fe28c0a-b6f1-4372-81a6-a246ae63f74f')\n     testnet3: UUID('43497fd7-f826-4571-88f4-a30fd9cec3ae')\n     namecoin: UUID('70c7a9f0-a2fb-4d48-a635-a70d5b157c80')\n\nAs for encoding the chain identifier, the simplest method is to give \n\"network\" the \"bytes\" type, but defining a \"UUID\" message type is also \npossible. In either case bitcoin mainnet would be the default, so the \nextra 12 bytes (vs: \"main\" or \"test\") would only be an issue for \nalt-chains or colored coins.\n\nKind regards,\nMark Friedenbach"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-05-21T02:45:13",
                "message_text_only": "On Mon, May 20, 2013 at 7:59 PM, Mark Friedenbach <mark at monetize.io> wrote:\n> So as to remain reasonably compliant with RFC 4122, I recommend that we\n> use Version 4 (random) UUIDs, with the random bits extracted from the\n> double-SHA256 hash of the genesis block of the chain. (For colored\n> coins, the colored coin definition transaction would be used instead,\n> but I will address that in a separate proposal and will say just one\n> thing about it: adopting this method for identifying chains/coins will\n> greatly assist in adopting the payment protocol to colored coins.)\n\nThis proposal seems closer to Version 5 than Version 4, in spirit.\nBut given that useful content may be deduced from UUID, it is not\ntruly applicable to either.  A bitcoin-specific version 6, if you\nwill.\n\n\n> And some example chain identifiers:\n>\n>      mainnet:  UUID('6fe28c0a-b6f1-4372-81a6-a246ae63f74f')\n>      testnet3: UUID('43497fd7-f826-4571-88f4-a30fd9cec3ae')\n>      namecoin: UUID('70c7a9f0-a2fb-4d48-a635-a70d5b157c80')\n\nNote that, as this example unintentionally implies, humans are going\nto want a side-by-side mapping /anyway/, just to make it readable and\nusable to humans.\n\nAlmost all useful multi-chain software will require a readable\nshortname string anyway, the thing this proposal wishes to avoid.\n\n-- \nJeff Garzik\nexMULTI, Inc.\njgarzik at exmulti.com"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-05-21T03:30:00",
                "message_text_only": "Bitcoinj already has such chain id's and we use standard Java style reverse\nDNS names: org.bitcoin.main, etc. If we want a more global naming system\nthat seems like a good compromise between uniqueness and readability.\nOn 20 May 2013 19:45, \"Jeff Garzik\" <jgarzik at exmulti.com> wrote:\n\n> On Mon, May 20, 2013 at 7:59 PM, Mark Friedenbach <mark at monetize.io>\n> wrote:\n> > So as to remain reasonably compliant with RFC 4122, I recommend that we\n> > use Version 4 (random) UUIDs, with the random bits extracted from the\n> > double-SHA256 hash of the genesis block of the chain. (For colored\n> > coins, the colored coin definition transaction would be used instead,\n> > but I will address that in a separate proposal and will say just one\n> > thing about it: adopting this method for identifying chains/coins will\n> > greatly assist in adopting the payment protocol to colored coins.)\n>\n> This proposal seems closer to Version 5 than Version 4, in spirit.\n> But given that useful content may be deduced from UUID, it is not\n> truly applicable to either.  A bitcoin-specific version 6, if you\n> will.\n>\n>\n> > And some example chain identifiers:\n> >\n> >      mainnet:  UUID('6fe28c0a-b6f1-4372-81a6-a246ae63f74f')\n> >      testnet3: UUID('43497fd7-f826-4571-88f4-a30fd9cec3ae')\n> >      namecoin: UUID('70c7a9f0-a2fb-4d48-a635-a70d5b157c80')\n>\n> Note that, as this example unintentionally implies, humans are going\n> to want a side-by-side mapping /anyway/, just to make it readable and\n> usable to humans.\n>\n> Almost all useful multi-chain software will require a readable\n> shortname string anyway, the thing this proposal wishes to avoid.\n>\n> --\n> Jeff Garzik\n> exMULTI, Inc.\n> jgarzik at exmulti.com\n>\n>\n> ------------------------------------------------------------------------------\n> Try New Relic Now & We'll Send You this Cool Shirt\n> New Relic is the only SaaS-based application performance monitoring service\n> that delivers powerful full stack analytics. Optimize and monitor your\n> browser, app, & servers with just a few lines of code. Try New Relic\n> and get this awesome Nerd Life shirt! http://p.sf.net/sfu/newrelic_d2d_may\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130520/d0371a1f/attachment.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2013-05-21T04:00:44",
                "message_text_only": "This was meant to go to everyone:\n\nOn 5/20/13 7:45 PM, Jeff Garzik wrote:\n> On Mon, May 20, 2013 at 7:59 PM, Mark Friedenbach <mark at monetize.io> wrote:\n>> So as to remain reasonably compliant with RFC 4122, I recommend that we\n>> use Version 4 (random) UUIDs, with the random bits extracted from the\n>> double-SHA256 hash of the genesis block of the chain. (For colored\n>> coins, the colored coin definition transaction would be used instead,\n>> but I will address that in a separate proposal and will say just one\n>> thing about it: adopting this method for identifying chains/coins will\n>> greatly assist in adopting the payment protocol to colored coins.)\n> This proposal seems closer to Version 5 than Version 4, in spirit.\n> But given that useful content may be deduced from UUID, it is not\n> truly applicable to either.  A bitcoin-specific version 6, if you\n> will.\nThat is true, and perhaps we have enough clout to push an RFC specifying \na double-SHA256 Version 6, or at least get it reserved. I proposed \nVersion 4 (random) because any UUID library should allow you to specify \nthe 122 supposedly random bits of that version, whereas conceivably \nthere might exist UUID libraries that require a SHA1 pre-image to create \na Version 5 UUID (I know of no examples though). Regardless, making an \nofficial double-SHA256 UUID version RFC is an option worth considering.\n> And some example chain identifiers:\n>\n>       mainnet:  UUID('6fe28c0a-b6f1-4372-81a6-a246ae63f74f')\n>       testnet3: UUID('43497fd7-f826-4571-88f4-a30fd9cec3ae')\n>       namecoin: UUID('70c7a9f0-a2fb-4d48-a635-a70d5b157c80')\n> Note that, as this example unintentionally implies, humans are going\n> to want a side-by-side mapping /anyway/, just to make it readable and\n> usable to humans.\n>\n> Almost all useful multi-chain software will require a readable\n> shortname string anyway, the thing this proposal wishes to avoid.\nI think there are perhaps two issues being conflated here (and in Mike's \nresponse): the UI identifying the network/coin to the user, and the \nmatching of the protocol-supplied value to the underlying network/coin \nby the client/daemon. The former necessarily involves manual adjustments \n(e.g, localization), but it's preferable for the latter to be a \nself-validating reference to the block chain. This is a trivial \ndifference for multi-chain wallets (what are you doing receiving \nrequests for coins in chains you don't know about?), but is important \nfor colored coins. Let me explain:\n\nI will be proposing soon a colored coin architecture that allows \nissuance of new coins by anyone for a fee, by means of a special \ncategory of transaction. The hash of that issuing transaction would then \nbe used to generate a UUID identifying the asset for the payment \nprotocol and other purposes as well, analogous to how the hash of the \ngenesis block identifies the host currency, bitcoin. It is expected that \nthere will be many such coins issued, as they can be used to represent \nindividual loans or lines of credit. In this context, any colored-coin \naware client could scan the block chain (or lookup a maintained index) \nto discover the UUID -> coin mapping with absolute certainty. However \nthe mechanism for mapping the text \"mtgoxUSD\" to a specific coin is not \nclear, and using some sort of DNS-resolution system adds huge external \ndependencies. IMHO it is much better to have the identifier derived from \nblock chain data directly (and therefore accessible and trusted by all \nnodes), and then carry out optional UI mappings like UUID(...) -> \n\"mtgoxUSD\" at a higher level.\n\nDoes that make sense?"
            },
            {
                "author": "Luke-Jr",
                "date": "2013-05-21T04:04:28",
                "message_text_only": "Bitcoin currently uses raw hashes extensively as UUIDs; whether the payment \nprotocol should be influence by that or not, I've not given thought to yet.\n\nSome alt coins may share a blockchain, or even merely the genesis block (two \ncurrently do; despite one of those being a scamcoin, I think the possibility \nshould not be dismissed). Because of this, requiring a 1:1 mapping between \ngenesis block and chain or coin seems non-ideal.\n\nOn Monday, May 20, 2013 11:59:39 PM Mark Friedenbach wrote:\n> At the developer round-table it was asked if the payment protocol would\n> alt-chains, and Gavin noted that it has a UTF-8 encoded string\n> identifying the network (\"main\" or \"test\"). As someone with two\n> proposals in the works which also require chain/coin identification (one\n> for merged mining, one for colored coins), I am opinionated on this. I\n> believe that we need a standard mechanism for identifying chains, and\n> one which avoids the trap of maintaining a standard registry of\n> string-to-chain mappings.\n> \n> Any chain can be uniquely identified by its genesis block, 122 random\n> bits is more than sufficient for uniquely tagging chains/colored assets,\n> and the low-order 16-bytes of the block's hash are effectively random.\n> With these facts in mind, I propose that we identify chains by UUID.\n> \n> So as to remain reasonably compliant with RFC 4122, I recommend that we\n> use Version 4 (random) UUIDs, with the random bits extracted from the\n> double-SHA256 hash of the genesis block of the chain. (For colored\n> coins, the colored coin definition transaction would be used instead,\n> but I will address that in a separate proposal and will say just one\n> thing about it: adopting this method for identifying chains/coins will\n> greatly assist in adopting the payment protocol to colored coins.)\n> \n> The following Python code illustrates how to construct the chain\n> identifier from the serialized genesis block:\n> \n>      from hashlib import sha256\n>      from uuid import UUID\n>      def chain_uuid(serialized_genesis_block):\n>          h = sha256(serialized_genesis_block).digest()\n>          h = sha256(h).digest()\n>          h = h[:16]\n>          h = ''.join([\n>              h[:6],\n>              chr(0x40 | ord(h[6]) & 0x0f),\n>              h[7],\n>              chr(0x80 | ord(h[8]) & 0x3f),\n>              h[9:]\n>          ])\n>          return UUID(bytes=h)\n> \n> And some example chain identifiers:\n> \n>      mainnet:  UUID('6fe28c0a-b6f1-4372-81a6-a246ae63f74f')\n>      testnet3: UUID('43497fd7-f826-4571-88f4-a30fd9cec3ae')\n>      namecoin: UUID('70c7a9f0-a2fb-4d48-a635-a70d5b157c80')\n> \n> As for encoding the chain identifier, the simplest method is to give\n> \"network\" the \"bytes\" type, but defining a \"UUID\" message type is also\n> possible. In either case bitcoin mainnet would be the default, so the\n> extra 12 bytes (vs: \"main\" or \"test\") would only be an issue for\n> alt-chains or colored coins.\n> \n> Kind regards,\n> Mark Friedenbach\n> \n> ---------------------------------------------------------------------------\n> --- Try New Relic Now & We'll Send You this Cool Shirt\n> New Relic is the only SaaS-based application performance monitoring service\n> that delivers powerful full stack analytics. Optimize and monitor your\n> browser, app, & servers with just a few lines of code. Try New Relic\n> and get this awesome Nerd Life shirt! http://p.sf.net/sfu/newrelic_d2d_may\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2013-05-22T10:27:53",
                "message_text_only": "On 21 May 2013 01:59, Mark Friedenbach <mark at monetize.io> wrote:\n\n> At the developer round-table it was asked if the payment protocol would\n> alt-chains, and Gavin noted that it has a UTF-8 encoded string\n> identifying the network (\"main\" or \"test\"). As someone with two\n> proposals in the works which also require chain/coin identification (one\n> for merged mining, one for colored coins), I am opinionated on this. I\n> believe that we need a standard mechanism for identifying chains, and\n> one which avoids the trap of maintaining a standard registry of\n> string-to-chain mappings.\n>\n> Any chain can be uniquely identified by its genesis block, 122 random\n> bits is more than sufficient for uniquely tagging chains/colored assets,\n> and the low-order 16-bytes of the block's hash are effectively random.\n> With these facts in mind, I propose that we identify chains by UUID.\n>\n> So as to remain reasonably compliant with RFC 4122, I recommend that we\n> use Version 4 (random) UUIDs, with the random bits extracted from the\n> double-SHA256 hash of the genesis block of the chain. (For colored\n> coins, the colored coin definition transaction would be used instead,\n> but I will address that in a separate proposal and will say just one\n> thing about it: adopting this method for identifying chains/coins will\n> greatly assist in adopting the payment protocol to colored coins.)\n>\n> The following Python code illustrates how to construct the chain\n> identifier from the serialized genesis block:\n>\n>      from hashlib import sha256\n>      from uuid import UUID\n>      def chain_uuid(serialized_genesis_block):\n>          h = sha256(serialized_genesis_block).digest()\n>          h = sha256(h).digest()\n>          h = h[:16]\n>          h = ''.join([\n>              h[:6],\n>              chr(0x40 | ord(h[6]) & 0x0f),\n>              h[7],\n>              chr(0x80 | ord(h[8]) & 0x3f),\n>              h[9:]\n>          ])\n>          return UUID(bytes=h)\n>\n> And some example chain identifiers:\n>\n>      mainnet:  UUID('6fe28c0a-b6f1-4372-81a6-a246ae63f74f')\n>      testnet3: UUID('43497fd7-f826-4571-88f4-a30fd9cec3ae')\n>      namecoin: UUID('70c7a9f0-a2fb-4d48-a635-a70d5b157c80')\n>\n> As for encoding the chain identifier, the simplest method is to give\n> \"network\" the \"bytes\" type, but defining a \"UUID\" message type is also\n> possible. In either case bitcoin mainnet would be the default, so the\n> extra 12 bytes (vs: \"main\" or \"test\") would only be an issue for\n> alt-chains or colored coins.\n>\n\nThis is essentially name spacing.  As registries grow namespaces become\nmore important.  In bitcoin's quest for decentrality there's also the\nquestion of who maintains the registry.\n\nSome out of band algo/hash could work so long as there was a one to one\nrelationship between the described object and the UUID.  In this case the\ngensis block may not uniquely identify a coin.\n\nThe normal way to namespace a registry on the internet is to allow it to be\na URI.  In this case an http style uri has the added bonus side effect that\nit can be dereferencable and both human and machine readable.  So yes\nsomething like org.bitcoin.* is good, just simply growing things to http\nstyle uris is cleaner, imho\n\n\n>\n> Kind regards,\n> Mark Friedenbach\n>\n>\n> ------------------------------------------------------------------------------\n> Try New Relic Now & We'll Send You this Cool Shirt\n> New Relic is the only SaaS-based application performance monitoring service\n> that delivers powerful full stack analytics. Optimize and monitor your\n> browser, app, & servers with just a few lines of code. Try New Relic\n> and get this awesome Nerd Life shirt! http://p.sf.net/sfu/newrelic_d2d_may\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130522/d01951b4/attachment.html>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-05-22T14:07:51",
                "message_text_only": "On Wed, May 22, 2013 at 6:27 AM, Melvin Carvalho\n<melvincarvalho at gmail.com> wrote:\n> Some out of band algo/hash could work so long as there was a one to one\n> relationship between the described object and the UUID.  In this case the\n> gensis block may not uniquely identify a coin.\n\nWhat does this mean?  It seems extremely unlikely that two different\ngenesis blocks will have the same hash.\n\n-- \nJeff Garzik\nexMULTI, Inc.\njgarzik at exmulti.com"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2013-05-22T14:12:42",
                "message_text_only": "On 22 May 2013 16:07, Jeff Garzik <jgarzik at exmulti.com> wrote:\n\n> On Wed, May 22, 2013 at 6:27 AM, Melvin Carvalho\n> <melvincarvalho at gmail.com> wrote:\n> > Some out of band algo/hash could work so long as there was a one to one\n> > relationship between the described object and the UUID.  In this case the\n> > gensis block may not uniquely identify a coin.\n>\n> What does this mean?  It seems extremely unlikely that two different\n> genesis blocks will have the same hash.\n>\n\nTwo coin ecosystems could have the same genesis block\n\n\n>\n> --\n> Jeff Garzik\n> exMULTI, Inc.\n> jgarzik at exmulti.com\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130522/811027e3/attachment.html>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-05-22T14:20:22",
                "message_text_only": "On Wed, May 22, 2013 at 10:12 AM, Melvin Carvalho\n<melvincarvalho at gmail.com> wrote:\n> On 22 May 2013 16:07, Jeff Garzik <jgarzik at exmulti.com> wrote:\n>>\n>> On Wed, May 22, 2013 at 6:27 AM, Melvin Carvalho\n>> <melvincarvalho at gmail.com> wrote:\n>> > Some out of band algo/hash could work so long as there was a one to one\n>> > relationship between the described object and the UUID.  In this case\n>> > the\n>> > gensis block may not uniquely identify a coin.\n>>\n>> What does this mean?  It seems extremely unlikely that two different\n>> genesis blocks will have the same hash.\n>\n>\n> Two coin ecosystems could have the same genesis block\n\nThat has really, really bad side effects.  The whole point of the\nbitcoin consensus algorithm is to avoid situations like this.\n\nWe don't want to encourage that behavior with code.\n\n-- \nJeff Garzik\nexMULTI, Inc.\njgarzik at exmulti.com"
            },
            {
                "author": "Luke-Jr",
                "date": "2013-05-22T14:29:47",
                "message_text_only": "On Wednesday, May 22, 2013 2:20:22 PM Jeff Garzik wrote:\n> On Wed, May 22, 2013 at 10:12 AM, Melvin Carvalho\n> \n> <melvincarvalho at gmail.com> wrote:\n> > On 22 May 2013 16:07, Jeff Garzik <jgarzik at exmulti.com> wrote:\n> >> On Wed, May 22, 2013 at 6:27 AM, Melvin Carvalho\n> >> \n> >> <melvincarvalho at gmail.com> wrote:\n> >> > Some out of band algo/hash could work so long as there was a one to\n> >> > one relationship between the described object and the UUID.  In this\n> >> > case the\n> >> > gensis block may not uniquely identify a coin.\n> >> \n> >> What does this mean?  It seems extremely unlikely that two different\n> >> genesis blocks will have the same hash.\n> > \n> > Two coin ecosystems could have the same genesis block\n> \n> That has really, really bad side effects.  The whole point of the\n> bitcoin consensus algorithm is to avoid situations like this.\n> \n> We don't want to encourage that behavior with code.\n\nIn some cases, multiple currencies can use the same blockchain (not just the \nsingular genesis block). This use case *is* something we want to encourage - \nno reason for people to make an entirely new blockchain if their altcoin fits \nwithin the scope of Bitcoin or another existing altchain."
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-05-22T14:55:42",
                "message_text_only": "On Wed, May 22, 2013 at 10:29 AM, Luke-Jr <luke at dashjr.org> wrote:\n> In some cases, multiple currencies can use the same blockchain (not just the\n> singular genesis block). This use case *is* something we want to encourage -\n> no reason for people to make an entirely new blockchain if their altcoin fits\n> within the scope of Bitcoin or another existing altchain.\n\nOK, let me qualify.  Layers on top are one thing, but we really do not\nwant to support cases like the fork that leaves the genesis block\nintact, and leaves the subsidy at 50.0 BTC forever.\n\n-- \nJeff Garzik\nexMULTI, Inc.\njgarzik at exmulti.com"
            },
            {
                "author": "Gavin Andresen",
                "date": "2013-05-22T15:59:53",
                "message_text_only": "Getting back to the original proposal:\n\nRE: uuid instead of \"main\" / \"test\" in the payment protocol:\n\nI vote no.\n\nThe payment protocol will become at least 3 BIPs:\n\n1) Protocol messages (current gist, essentially)\n2) MIME type\n3) bitcoin: URI extension\n\nAn alt coin will need its own version of (2) and (3), so when you\nclick on a foocoin: link a foocoin-specific MIME type is fetched and\nfoocoin.exe is launched to handle the request.\n\n... or a specific MIME type is fetched and delivered to the\nHandlesLotsOfCoins application (... and it knows what MIME type it is\ngetting, so can Do the Right Thing).\n\nIf a payment request is delivered via HTTP or email, it will be\nbundled up in an envelope of some sort with the MIME type attached.\n\nSo, after further thought, I've changed my mind: which coin would be\nencoded in the MIME type.  Which chain for that coin would be encoded\nin PaymentDetails.network.\n\n-- \n--\nGavin Andresen\nChief Scientist, Bitcoin Foundation\nhttps://www.bitcoinfoundation.org/"
            }
        ],
        "thread_summary": {
            "title": "UUID to identify chains (payment protocol and elsewhere)",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Luke-Jr",
                "Mike Hearn",
                "Gavin Andresen",
                "Mark Friedenbach",
                "Melvin Carvalho"
            ],
            "messages_count": 12,
            "total_messages_chars_count": 22462
        }
    },
    {
        "title": "[Bitcoin-development] Double Spend Notification",
        "thread_messages": [
            {
                "author": "Quinn Harris",
                "date": "2013-05-21T00:45:28",
                "message_text_only": "The current BitCoin implementation is subject to relatively easy double \nspend attack for 0 confirmation payments.  Yet 0 confirmation payments \nare needed for typical in person transactions like most purchases at a \nlocal business.\n\nNotably, it is easy to transmit two transactions from the same output at \nthe same time to different sets of nodes on the network by using two \ninstances of bitcoind with same wallet file and a spend on each daemon \ninitiated by RPC by some easy to implement code.  If the first attempt \nto pay the merchant doesn't go through because they received the \"wrong\" \ntransaction it could be quickly followed up with another initiated spend \nfrom a different output switching which daemon sends the transaction the \nmerchant is expecting.  This means an unsophisticated attacker can \nreliably get away with this attack and it would be worth while for small \ntransactions.  Given this, I would be reluctant to trust 0 confirmation \ntransactions at all though I think many do in practice.  Someone could \nwrite and publish a special daemon to execute this attack further \nreducing the cost.\n\nRight now a node will drop any second spend of the same output in the \nmemory pool.  After the first transaction has propagated through the \nnetwork issuing a second double spend transaction isn't likely to be \nseen by a significant number of miners as most nodes especially non \nminer nodes will drop this transaction.  Today, it is necessary to \ntransmit both transactions on the network nearly simultaneously to \nreliably get away with this simple attack.  If in this case, the \nreceiving end is quickly notified of the double spend this attack \nbecomes more more difficult to get away with.\n\nIf the second transaction is relayed instead of being dropped to notify \nthe receiving party of the double spend, most miners will receive both \ntransactions and it is possible that some or even many of the miners \nwould replace the first transaction with the second if it has a higher \nfee as it would be in their short term interest. This can happen some \ntime after the first transaction has propagated through the network so \nthe receiving end wouldn't get a timely notification of the double \nspend.  Depending on the choices of the miners, this approach to double \nspend notification could exacerbate the very problem it was attempting \nto fix compared to the current implementation.  While miners might \ncontinue to drop the second spends, the easy availability of the second \nspends would increase the short term reward for changing this policy.\n\nThis problem can be fixed if instead of sending the second transaction a \nnew double spend message is sent with proof of the double spend but not \nthe complete transactions.  This would allow the receiving end to be \nquickly notified of a double spend while in no way increase the chance \nover the current implementation that a double spend would be successful.\n\nThe proof of the double spend would include the scriptSig (input) from \nthe original transactions and the hashes from the \"simplified\" \ntransaction used by OP_CHECKSIG of the scriptPubKey (output) but not the \nentire transaction.  This is the hash computed by the SignatureHash \nfunction in script.cpp.   The double spend notification message should \ncontain proofs of both signed transaction spending the same output \nordered by hash to produce a canonical proof for a specific two \ntransactions.  To reduce DOS potential, the proof should not be relayed \nunless one of the original transactions has been received to ensure \nthere is some commitment to the block chain and different double spend \nproofs of the same output should not be relayed.  The forwarding of \ntransactions should remain exactly the same as it is now where the \nsecond transaction is dropped but a double spend message is transmitted \nif appropriate.\n\nThe existing block chain needs to be checked to make sure the proof of \ndouble spend couldn't have been derived from the block chain and a \nsingle spend in the memory pool.  This could happen if there was already \nan identical transaction in the block chain.  This would typically only \nhappen if someone was paying someone else the same amount they had \nbefore and neither side changed addresses.  In this case double spend \ndetection wouldn't be reliable as it could be generated by anyone, but \nboth the sending and receiving client could detect this situation and \nwarn the user.\n\nIt would still be possible for an attacker to send the second \ntransaction directly to powerful miners but this is a distinctly less \nviable attack than the current double spend attack.\n\nI would expect this double spend notification implementation to make \ndouble spends more costly than they are worth for most cases today that \n0 confirmation acceptance is needed.  That said over time this provision \nmight become less effective.  As the reward for each block mined \ndecreases, transactions fees will become a more significant part of the \nmining reward accordingly increasing the incentive to replace \ntransactions with higher fees.  Today most BitCoin participants have a \nhigh expectation of significant future appreciation of BitCoins and \nrecognize anything that brings into question the integrity of the system \nis likely to reduce that future value so they have a long term self \ninterest to keep up the impression of integrity.  As BitCoin becomes \nmore establish this incentive will decrease.\n\nOn the other hand, non mining nodes have no incentive to replace by \nfee.  The continued increased capital costs of mining would likely \nincrease the proportion of non mining nodes typically run by those with \nan incentive to assure integrity of the network such as merchants.  But \nincreasing transaction volume is likely to increase node costs which \nwould push out non mining nodes with lower incentive more than mining \nnodes.  Accordingly increasing block size would have a tendency to \nreduce the effectiveness of double spend notification.  The primary \npoint is there are multiple counteracting forces that make predicting \nthe future effectiveness of double spend notification uncertain.\n\nI don't believe this necessary warrants conceding that we can not \nprovide any protection from non trusted 0 confirmations transaction as a \nreplace by fee implementation would do.  But it would still be important \nto work towards more robust solutions notably various forms of 3rd party \ntrust.  This could be tamper resistant devices trusted to not duplicate \nspends, 3rd party certificates with proof the transaction was spent by \nthe holder of the certificate or multi signature transactions on the \nblock chain that must be signed by a trusted 3rd party to spend.  I \nwould expect it would take significantly longer for the companies and \ntechnologies to be built to implement this on a wide scale than adding \ndouble spend proof messages to the current implementation.  In addition, \nthere will likely always be some use cases where a 3rd party \n(centralization) is not viable.\n\nShould a BIP and pull request implementing a double spend notification \nas described be accepted?\n\n- Quinn"
            },
            {
                "author": "Robert Backhaus",
                "date": "2013-05-21T01:24:22",
                "message_text_only": "Personally, I agree, but a different decision has been made by the main\ndevs.\n\nThe issue is this: consider two transactions in the unconfirmed pool. One\ntransaction has 2BTC input, 1.5BTC to one address (the payment), .4995 to\nanother address (change) and .0005 standard fee. Another transaction\nappears - Same input, 1BTC to one address, .999 to another, and .001 fee.\nWhich one would a miner include? On pure self interest, the second one,\nbecause it has twice the fee. Anyway, the miner has no real way of knowing\nwhich transaction was real, and which the fraudulent double-spend. The\nnetwork does not keep accurate timestamps, so it has no way of really\nknowing which is first. A bit of artificial DDOS-type overload on the\nrecipient's system, and the real transaction could easily appear last.\n\nSo the decision has been made to make 0-conf double spends trivial, so no\none will ever trust 0-confs. If a later transaction appears with a larger\nfee, it will be considered to be the valid one, and the first one dropped,\nas long as the first one has not been confirmed. This makes undoing a\nmistaken transaction possible.\n\nSo anyone needing 0-conf-like speed will have to make other arangements,\nsuch as contracting with enough mining pool power to never drop their\ntransactions unless confirmed multiple times. Secure 0-confs is an\nimpossible target with blockchain cyrpto-currencies as the stand. Any ideas\non how to make them work are welcome, of course - as long as we haven't\nheard them too many times before.\n\n\nOn 21 May 2013 10:45, Quinn Harris <btcdev at quinnharris.me> wrote:\n\n> The current BitCoin implementation is subject to relatively easy double\n> spend attack for 0 confirmation payments.  Yet 0 confirmation payments\n> are needed for typical in person transactions like most purchases at a\n> local business.\n>\n> Notably, it is easy to transmit two transactions from the same output at\n> the same time to different sets of nodes on the network by using two\n> instances of bitcoind with same wallet file and a spend on each daemon\n> initiated by RPC by some easy to implement code.  If the first attempt\n> to pay the merchant doesn't go through because they received the \"wrong\"\n> transaction it could be quickly followed up with another initiated spend\n> from a different output switching which daemon sends the transaction the\n> merchant is expecting.  This means an unsophisticated attacker can\n> reliably get away with this attack and it would be worth while for small\n> transactions.  Given this, I would be reluctant to trust 0 confirmation\n> transactions at all though I think many do in practice.  Someone could\n> write and publish a special daemon to execute this attack further\n> reducing the cost.\n>\n> Right now a node will drop any second spend of the same output in the\n> memory pool.  After the first transaction has propagated through the\n> network issuing a second double spend transaction isn't likely to be\n> seen by a significant number of miners as most nodes especially non\n> miner nodes will drop this transaction.  Today, it is necessary to\n> transmit both transactions on the network nearly simultaneously to\n> reliably get away with this simple attack.  If in this case, the\n> receiving end is quickly notified of the double spend this attack\n> becomes more more difficult to get away with.\n>\n> If the second transaction is relayed instead of being dropped to notify\n> the receiving party of the double spend, most miners will receive both\n> transactions and it is possible that some or even many of the miners\n> would replace the first transaction with the second if it has a higher\n> fee as it would be in their short term interest. This can happen some\n> time after the first transaction has propagated through the network so\n> the receiving end wouldn't get a timely notification of the double\n> spend.  Depending on the choices of the miners, this approach to double\n> spend notification could exacerbate the very problem it was attempting\n> to fix compared to the current implementation.  While miners might\n> continue to drop the second spends, the easy availability of the second\n> spends would increase the short term reward for changing this policy.\n>\n> This problem can be fixed if instead of sending the second transaction a\n> new double spend message is sent with proof of the double spend but not\n> the complete transactions.  This would allow the receiving end to be\n> quickly notified of a double spend while in no way increase the chance\n> over the current implementation that a double spend would be successful.\n>\n> The proof of the double spend would include the scriptSig (input) from\n> the original transactions and the hashes from the \"simplified\"\n> transaction used by OP_CHECKSIG of the scriptPubKey (output) but not the\n> entire transaction.  This is the hash computed by the SignatureHash\n> function in script.cpp.   The double spend notification message should\n> contain proofs of both signed transaction spending the same output\n> ordered by hash to produce a canonical proof for a specific two\n> transactions.  To reduce DOS potential, the proof should not be relayed\n> unless one of the original transactions has been received to ensure\n> there is some commitment to the block chain and different double spend\n> proofs of the same output should not be relayed.  The forwarding of\n> transactions should remain exactly the same as it is now where the\n> second transaction is dropped but a double spend message is transmitted\n> if appropriate.\n>\n> The existing block chain needs to be checked to make sure the proof of\n> double spend couldn't have been derived from the block chain and a\n> single spend in the memory pool.  This could happen if there was already\n> an identical transaction in the block chain.  This would typically only\n> happen if someone was paying someone else the same amount they had\n> before and neither side changed addresses.  In this case double spend\n> detection wouldn't be reliable as it could be generated by anyone, but\n> both the sending and receiving client could detect this situation and\n> warn the user.\n>\n> It would still be possible for an attacker to send the second\n> transaction directly to powerful miners but this is a distinctly less\n> viable attack than the current double spend attack.\n>\n> I would expect this double spend notification implementation to make\n> double spends more costly than they are worth for most cases today that\n> 0 confirmation acceptance is needed.  That said over time this provision\n> might become less effective.  As the reward for each block mined\n> decreases, transactions fees will become a more significant part of the\n> mining reward accordingly increasing the incentive to replace\n> transactions with higher fees.  Today most BitCoin participants have a\n> high expectation of significant future appreciation of BitCoins and\n> recognize anything that brings into question the integrity of the system\n> is likely to reduce that future value so they have a long term self\n> interest to keep up the impression of integrity.  As BitCoin becomes\n> more establish this incentive will decrease.\n>\n> On the other hand, non mining nodes have no incentive to replace by\n> fee.  The continued increased capital costs of mining would likely\n> increase the proportion of non mining nodes typically run by those with\n> an incentive to assure integrity of the network such as merchants.  But\n> increasing transaction volume is likely to increase node costs which\n> would push out non mining nodes with lower incentive more than mining\n> nodes.  Accordingly increasing block size would have a tendency to\n> reduce the effectiveness of double spend notification.  The primary\n> point is there are multiple counteracting forces that make predicting\n> the future effectiveness of double spend notification uncertain.\n>\n> I don't believe this necessary warrants conceding that we can not\n> provide any protection from non trusted 0 confirmations transaction as a\n> replace by fee implementation would do.  But it would still be important\n> to work towards more robust solutions notably various forms of 3rd party\n> trust.  This could be tamper resistant devices trusted to not duplicate\n> spends, 3rd party certificates with proof the transaction was spent by\n> the holder of the certificate or multi signature transactions on the\n> block chain that must be signed by a trusted 3rd party to spend.  I\n> would expect it would take significantly longer for the companies and\n> technologies to be built to implement this on a wide scale than adding\n> double spend proof messages to the current implementation.  In addition,\n> there will likely always be some use cases where a 3rd party\n> (centralization) is not viable.\n>\n> Should a BIP and pull request implementing a double spend notification\n> as described be accepted?\n>\n> - Quinn\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> Try New Relic Now & We'll Send You this Cool Shirt\n> New Relic is the only SaaS-based application performance monitoring service\n> that delivers powerful full stack analytics. Optimize and monitor your\n> browser, app, & servers with just a few lines of code. Try New Relic\n> and get this awesome Nerd Life shirt! http://p.sf.net/sfu/newrelic_d2d_may\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130521/65a0710f/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2013-05-21T01:56:57",
                "message_text_only": "On Tue, May 21, 2013 at 3:24 AM, Robert Backhaus <robbak at robbak.com> wrote:\n> So the decision has been made to make 0-conf double spends trivial, so no\n> one will ever trust 0-confs. If a later transaction appears with a larger\n> fee, it will be considered to be the valid one, and the first one dropped,\n> as long as the first one has not been confirmed. This makes undoing a\n> mistaken transaction possible.\n\nThis has been suggested, but I know of no such decision having been made.\n\n-- \nPieter"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-05-21T03:27:59",
                "message_text_only": "Indeed, that has been proposed but it's a dumb idea and I'm very sceptical\nit will go anywhere.  Certainly no decision was made. The arguments for it\nare based on some quite faulty thinking about economics. Double spend\nnotifications have been proposed a long time ago, I believe Matt has\nindicated some interest in implementing them and that is the right way to\ngo.\nOn 20 May 2013 18:57, \"Pieter Wuille\" <pieter.wuille at gmail.com> wrote:\n\n> On Tue, May 21, 2013 at 3:24 AM, Robert Backhaus <robbak at robbak.com>\n> wrote:\n> > So the decision has been made to make 0-conf double spends trivial, so no\n> > one will ever trust 0-confs. If a later transaction appears with a larger\n> > fee, it will be considered to be the valid one, and the first one\n> dropped,\n> > as long as the first one has not been confirmed. This makes undoing a\n> > mistaken transaction possible.\n>\n> This has been suggested, but I know of no such decision having been made.\n>\n> --\n> Pieter\n>\n>\n> ------------------------------------------------------------------------------\n> Try New Relic Now & We'll Send You this Cool Shirt\n> New Relic is the only SaaS-based application performance monitoring service\n> that delivers powerful full stack analytics. Optimize and monitor your\n> browser, app, & servers with just a few lines of code. Try New Relic\n> and get this awesome Nerd Life shirt! http://p.sf.net/sfu/newrelic_d2d_may\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130520/6d1de076/attachment.html>"
            },
            {
                "author": "Robert Backhaus",
                "date": "2013-05-21T03:39:30",
                "message_text_only": "That's good - what I had taken away from the replace-by-fee discussions was\nthat it was finally decided.\n\nMy opinion is that we should be doing what we can to make 0-confs as\nreliable as possible - which will always be 'not very', but a solid system\nto notify on attempted double-spends is a good start.\n\nI'd like to know how Peter Todd's experiment with the 2BTC reward has gone.\n\n\nOn 21 May 2013 13:27, Mike Hearn <mike at plan99.net> wrote:\n\n> Indeed, that has been proposed but it's a dumb idea and I'm very sceptical\n> it will go anywhere.  Certainly no decision was made. The arguments for it\n> are based on some quite faulty thinking about economics. Double spend\n> notifications have been proposed a long time ago, I believe Matt has\n> indicated some interest in implementing them and that is the right way to\n> go.\n> On 20 May 2013 18:57, \"Pieter Wuille\" <pieter.wuille at gmail.com> wrote:\n>\n>> On Tue, May 21, 2013 at 3:24 AM, Robert Backhaus <robbak at robbak.com>\n>> wrote:\n>> > So the decision has been made to make 0-conf double spends trivial, so\n>> no\n>> > one will ever trust 0-confs. If a later transaction appears with a\n>> larger\n>> > fee, it will be considered to be the valid one, and the first one\n>> dropped,\n>> > as long as the first one has not been confirmed. This makes undoing a\n>> > mistaken transaction possible.\n>>\n>> This has been suggested, but I know of no such decision having been made.\n>>\n>> --\n>> Pieter\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> Try New Relic Now & We'll Send You this Cool Shirt\n>> New Relic is the only SaaS-based application performance monitoring\n>> service\n>> that delivers powerful full stack analytics. Optimize and monitor your\n>> browser, app, & servers with just a few lines of code. Try New Relic\n>> and get this awesome Nerd Life shirt!\n>> http://p.sf.net/sfu/newrelic_d2d_may\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130521/860b94b0/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2013-05-21T13:06:13",
                "message_text_only": "On Tue, May 21, 2013 at 01:39:30PM +1000, Robert Backhaus wrote:\n> That's good - what I had taken away from the replace-by-fee discussions was\n> that it was finally decided.\n> \n> My opinion is that we should be doing what we can to make 0-confs as\n> reliable as possible - which will always be 'not very', but a solid system\n> to notify on attempted double-spends is a good start.\n> \n> I'd like to know how Peter Todd's experiment with the 2BTC reward has gone.\n\npiuk wrote a double-spender that I think meets the criteria for the\nreward: https://blockchain.info/create-double-spend\n\nI'll get a chance to test it properly when I'm back from vacation, but\nlooks like he's getting the 2BTC. If it does work as intended I'm also\nplanning on doing a demo/video at the next Toronto Bitcoin Meetup to\ndemonstrate the attack in a real-life exchange.\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000f31f5cd20f915e3edb8e3fceea49580235b984fea63f1f882c\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130521/8219e59c/attachment.sig>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2013-05-21T03:54:25",
                "message_text_only": "On Mon, May 20, 2013 at 6:56 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n> On Tue, May 21, 2013 at 3:24 AM, Robert Backhaus <robbak at robbak.com> wrote:\n>> So the decision has been made to make 0-conf double spends trivial, so no\n>> one will ever trust 0-confs. If a later transaction appears with a larger\n>> fee, it will be considered to be the valid one, and the first one dropped,\n>> as long as the first one has not been confirmed. This makes undoing a\n>> mistaken transaction possible.\n> This has been suggested, but I know of no such decision having been made.\n\nIndeed. I've argued against it pretty aggressively, but I am starting\nto find arguments for and against pure fee-based replacement more\nequally persuasive.\n\nRegardless of the eventual outcome, fees today aren't a major\nmotivator vs subsidy and overall network health\u2014 and even if some\nprotection isn't 100% there are plenty of cases where the risk is\naveraged across many small transactions and any reduction of risk is a\nreduction in operating cost.   (No one is going to double spend your\nsoda machine at high speed\u2014 so you can like increase your prices by\nthe amount of successful double spends you experience and call it\ndone)\n\nOn the other hand, it's well established that people underestimate the\ncosts of unlikely risks. More deterministic behavior can result in\nsafer interactions more than _better_ behavior. If we believe that in\nthe long term self-interest will result in pure-fee based replacement\nbeing wide spread then it is also good to not build a dependency on\nbehavior that will not last.\n\nOne point that was only recently exposed to me is that replacement\ncombined with child-pays-for-parent creates a new kind of double spend\n_defense_: If someone double spends a payment to an online key of\nyours, you can instantly produce a child transaction that pays 100% of\nthe double spend to fees... so a double spender can hurt you but not\nprofit from it.  (and if your side of the transaction is\npotentially/partially reversible he will lose)...\n\nBut then again, a race to burn more money is kinda ... odd and even if\nthe benefit of resisting the double spends is only a short term\nbenefit, a short term benefit can be greatly important in encouraging\nBitcoin adoption. ... and the long term behavior is far from certain.\n\nSo at least from my position it's far from clear what should be done here.\n\nI've noticed a number of people who seem to be swayed by replace by\nfee\u2014 or at least its inevitability if not value. So even ignoring\ndevelopers there may evolve a community consensus here regardless of\nwhat I think about it.\n\nMy SO pointed that that the transaction burning race described above\nsounds like an economists wet dream: it's one of those silly cases\nthey use in experiments to probe human behavior... except it sounds\nlike a possible eventual outcome in systems used by people.  Perhaps\nit would be useful to point some graduate students at this question\nand see what they can come up with about it."
            },
            {
                "author": "Gavin Andresen",
                "date": "2013-05-21T04:39:02",
                "message_text_only": "I'm very much in favor of double-spend propagation across the network.\n\nMost of the arguments about replace-based-on-fee /\nchild-pays-burn-coins / etc are orthogonal.\n\nLetting a merchant know ASAP that their customer is trying to cheat\nthem is, in my opinion, strictly better than what we have now.\n\n-- \n--\nGavin Andresen"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2013-05-21T07:04:16",
                "message_text_only": "On Mon, May 20, 2013 at 9:39 PM, Gavin Andresen <gavinandresen at gmail.com> wrote:\n> I'm very much in favor of double-spend propagation across the network.\n\nAbsolutely.\n\n(to the list:) Is there anyone who is not?  (assuming that it doesn't\nallow arbitrary traffic multiplication, which is easily solved)"
            },
            {
                "author": "Robert Backhaus",
                "date": "2013-05-21T08:08:04",
                "message_text_only": "Not at all - ACK from me, fwiw. Any attempt at a double spend should be\nshouted from the housetops.\n\nWhat Miners should do with that is still up for debate, it seems. My\nopinion is that they should hold on and attempt to confirm the first,\nletting it go only if a conflicting transaction is mined elsewhere. (Let\nyour Yes mean Yes...) But I understand the contrary arguments.\n\n\nOn 21 May 2013 17:04, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n\n> On Mon, May 20, 2013 at 9:39 PM, Gavin Andresen <gavinandresen at gmail.com>\n> wrote:\n> > I'm very much in favor of double-spend propagation across the network.\n>\n> Absolutely.\n>\n> (to the list:) Is there anyone who is not?  (assuming that it doesn't\n> allow arbitrary traffic multiplication, which is easily solved)\n>\n>\n> ------------------------------------------------------------------------------\n> Try New Relic Now & We'll Send You this Cool Shirt\n> New Relic is the only SaaS-based application performance monitoring service\n> that delivers powerful full stack analytics. Optimize and monitor your\n> browser, app, & servers with just a few lines of code. Try New Relic\n> and get this awesome Nerd Life shirt! http://p.sf.net/sfu/newrelic_d2d_may\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130521/bf2601af/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2013-05-21T13:05:57",
                "message_text_only": "On Mon, May 20, 2013 at 08:54:25PM -0700, Gregory Maxwell wrote:\n> One point that was only recently exposed to me is that replacement\n> combined with child-pays-for-parent creates a new kind of double spend\n> _defense_: If someone double spends a payment to an online key of\n> yours, you can instantly produce a child transaction that pays 100% of\n> the double spend to fees... so a double spender can hurt you but not\n> profit from it.  (and if your side of the transaction is\n> potentially/partially reversible he will lose)...\n\nYou can do better than that actually: you can arrange the transaction\nsuch that the double-spender is hurt by asking them to pay an excess on\ntop of the initial payment, and having that excess get returned to them\nin a subsequent transaction. Of course, that's trusting the merchant,\nbut you're trusting the merchant to ship to a product anyway so...\n\nA really interesting example for this though would be applications where\nyou are making a deposit. You credit the customer account immediately\nwith half of the deposit amount, allowing them to immediately spend that\nportion for something transferable. (perhaps an alt-coin) If the\ncustomer tries to double-spend you burn half to fees, still leaving the\nother half to pay for what they did spend. If they don't double-spend,\nthe rest of the balance becomes available after n confirmations. A\nBTC->alt-coin exchange could use this mechanism for instance, although\nit only works with widespread replace-by-fee adoption; blockchain.info's\nshared-send service is another application, as is SatoshiDice. (the\nfailed bet tx can be the refund)\n\nWhat's nice here is even if the customer tries to pay a miner to do the\ndirty work, a short-term rational miner still has an incentive to screw\nover the customer by accepting the merchant's double-spend. Now the\ncustomer can promise the miner future business, but they've shown\nthemselves to be dishonest... how much honor is there among thieves?\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000f31f5cd20f915e3edb8e3fceea49580235b984fea63f1f882c\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130521/ed1f372e/attachment.sig>"
            },
            {
                "author": "David Vorick",
                "date": "2013-05-21T14:26:18",
                "message_text_only": "I've been wondering why a blockchain is necessary at all. Ripple doesn't\nhave one (I haven't looked closely at their implementation but it seems\nreasonable to go without one).\n\nWhen you do blockchain based transaction confirmations, you give full\nauthority to the miner that finds the transaction block. That miner gets to\ndecide which transactions are real and which transactions are fraudulent,\nand even has the option to not include any particular transaction (maybe\nthey used dirty coins, or something like that). The advantage to using a\nblockchain is that any tough decisions to choose between two conflicting\ntransactions can be decided in an easy manner. The person who finds the\nnext block picks their favorite and tells everybody else.\n\nBut this has a huge downside: network confirmation can take more than 10\nminutes (for an unlucky block). If you really want to be certain, a\nconfirmation can take more than an hour (multi-block confirmations).\n\nFor a transaction with no conflict, the network should be able to confirm\nthe transaction within a few seconds, because the information can propagate\nto all of the nodes that quickly. The new issue is that if conflicting\ntransactions appear on opposite sides of the network, there needs to be\nsome way for the network to determine which transaction gets priority.\nRight now the method is to wait for a miner to find a block and then go\nwith his decision, but perhaps there's some way to resolve a double spend\nconflict without waiting for a block.\n\nAll you really need is for 51% of the nodes in the network to confirm a\ntransaction as legitimate in order for it to be 'confirmed' by the entire\nnetwork. Malicious nodes (nodes that confirm both conflicting transactions,\nor nodes that refuse to confirm a transaction even though there are no\nconflicts) can be excommunicated. The two challenges then would be\n\n1. telling everybody when a transaction has hit 51% confirmation\n2. dealing with a triple-or-more spend: A has 25% confirmation, B has 40%\nconfirmation, C has 35% confirmation, who wins?\n\nFor the first problem, each node only needs to see the transaction twice:\nonce when the node sees it for the first time and confirms it, and a second\ntime after the transaction hits 51% and is announced to the network as\nconfirmed. The first node to see the transaction hit 51% will make the\nannouncement.\n\nThe second problem could be reduced to a majority-wins problem. If a node\nsees that 94% of votes are in, and one of the transactions is more than 6%\nahead of the others, that transaction is the winner.\n\nIf for whatever reason a clear majority is not hit by the time the next\nmining block is found, the miner could just choose the transaction that had\nthe most votes when it saw it. It may be outdated but would clear up any\nissues. This delay would only occur for a transaction if the spender of the\ncoins was attempting a double spend, and would indicate dishonesty to the\nmerchants. They could then choose to wait and see if their account is the\nwinner or they could just refuse to give out their goods.\n\n\nOn Tue, May 21, 2013 at 9:05 AM, Peter Todd <pete at petertodd.org> wrote:\n\n> On Mon, May 20, 2013 at 08:54:25PM -0700, Gregory Maxwell wrote:\n> > One point that was only recently exposed to me is that replacement\n> > combined with child-pays-for-parent creates a new kind of double spend\n> > _defense_: If someone double spends a payment to an online key of\n> > yours, you can instantly produce a child transaction that pays 100% of\n> > the double spend to fees... so a double spender can hurt you but not\n> > profit from it.  (and if your side of the transaction is\n> > potentially/partially reversible he will lose)...\n>\n> You can do better than that actually: you can arrange the transaction\n> such that the double-spender is hurt by asking them to pay an excess on\n> top of the initial payment, and having that excess get returned to them\n> in a subsequent transaction. Of course, that's trusting the merchant,\n> but you're trusting the merchant to ship to a product anyway so...\n>\n> A really interesting example for this though would be applications where\n> you are making a deposit. You credit the customer account immediately\n> with half of the deposit amount, allowing them to immediately spend that\n> portion for something transferable. (perhaps an alt-coin) If the\n> customer tries to double-spend you burn half to fees, still leaving the\n> other half to pay for what they did spend. If they don't double-spend,\n> the rest of the balance becomes available after n confirmations. A\n> BTC->alt-coin exchange could use this mechanism for instance, although\n> it only works with widespread replace-by-fee adoption; blockchain.info's\n> shared-send service is another application, as is SatoshiDice. (the\n> failed bet tx can be the refund)\n>\n> What's nice here is even if the customer tries to pay a miner to do the\n> dirty work, a short-term rational miner still has an incentive to screw\n> over the customer by accepting the merchant's double-spend. Now the\n> customer can promise the miner future business, but they've shown\n> themselves to be dishonest... how much honor is there among thieves?\n>\n> --\n> 'peter'[:-1]@petertodd.org\n> 00000000000000f31f5cd20f915e3edb8e3fceea49580235b984fea63f1f882c\n>\n>\n> ------------------------------------------------------------------------------\n> Try New Relic Now & We'll Send You this Cool Shirt\n> New Relic is the only SaaS-based application performance monitoring service\n> that delivers powerful full stack analytics. Optimize and monitor your\n> browser, app, & servers with just a few lines of code. Try New Relic\n> and get this awesome Nerd Life shirt! http://p.sf.net/sfu/newrelic_d2d_may\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130521/bf07e21d/attachment.html>"
            },
            {
                "author": "Quinn Harris",
                "date": "2013-05-21T16:47:59",
                "message_text_only": "What if a transaction is tagged as eligible for replace by fee possibly \nusing the lock_time (0xFFFFFFFE) so the parties involved can decide \nwhich approach works best for them.  If the receiving side doesn't see \nthe type of transaction they want they consider it invalid.  The payment \nprotocol can be used to negotiate which method should be used.\n\nIf lock_time is final as it is now for all standard transactions, the \ncurrent behaviour for transaction propagation would be kept with the \naddition of double spend proof notifications as I described. But if the \ntransactions are tagged appropriately, they would be replaced by fee.\n\nIn the recommended implementation, once a node sees a transaction that \nis not eligible to be replaced by fee it would treat all successive \ntransactions that way despite the tag.\n\nThis shouldn't hurt merchants that wish to use just double spend \nnotification while still enabling replace by fee for those who think it \nis preferred.\n\nI do find the burn coins and buyer pays twice with a merchant refund to \nbe compelling solutions, but you can't always trust the merchant (face \nto face street merchant).  Also, there is a short window of time were a \nblock can be mined before the burn coin counter measure is received.  It \nis isn't guaranteed this will work better than current behaviour with \ndouble spend notification especially considering notification don't cost \nthe merchant when it works.\n\n- Quinn"
            },
            {
                "author": "Quinn Harris",
                "date": "2013-05-21T03:46:15",
                "message_text_only": "A part of my reason for sending this email was a quick discussion I had \nwith Gavin at the BitCoin conference.  I was under the strong impression \nthat double spend notification was something he approved of and was \nconsidering implementing himself.\n\nIn the case of a double spend, If the receiving end gets a timely \nnotification (few seconds) it isn't that important that any one of the \ntwo (or more) transactions is chosen over another.  The receiving side \ncan treat a double spend as a failed transaction as it should be proof \nthat the buyer is acting maliciously or has had their private keys \ncompromised.\n\nI am aware Peter Todd has implemented replace by fee and is operating a \nnode on testnet doing this.  I think he is rightly pointing out that the \ncurrent behaviour of dropping all second spends is based largely on the \ngood will of nodes and can absolutly contradict the perceived self \ninterest of those running miners.  Accordingly relying on this behaviour \ncan be precarious. It was from reading his emails to this list or \nbitcointalk that I recognized how essential it was to not transmit the \nsecond transaction if double spend notification had any hope of being \nworth much.\n\nThis is controversial because reliable 0-conf transactions are desirable \nbut as you said there really is no way to ensure significant integrity \nin a decentralized way.  Replace by fee would make what transactions get \ninto blocks more predictable and eliminate any expectation of reliable 0 \nconf transactions.  The question is if this consistency is a better \nchoice than a double spend notification that is far from perfect but \ntoday its still useful and in practice can probably be trusted as much \nas credit cards.\n\nA more strict version of replace by fee could be implemented that only \nreplaces transactions with ones that don't reduce any output quantity \nand accordingly require introducing a new input.  This would allow \nincreasing transaction fees on a transaction without hurting someone who \ntrusted a 0 conf transaction.  This seems like feature bloat to me but \nit wouldn't reduce 0 conf integrity.\n\nUnfortunately, I don't see a way to make everyone happy on this issue.  \nThough, I expect everyone would either prefer double spend notification \nor always replace by higher fee over what we have now.\n\n- Quinn\n\n\n\nOn 05/20/2013 07:24 PM, Robert Backhaus wrote:\n> Personally, I agree, but a different decision has been made by the \n> main devs.\n>\n> The issue is this: consider two transactions in the unconfirmed pool. \n> One transaction has 2BTC input, 1.5BTC to one address (the payment), \n> .4995 to another address (change) and .0005 standard fee. Another \n> transaction appears - Same input, 1BTC to one address, .999 to \n> another, and .001 fee. Which one would a miner include? On pure self \n> interest, the second one, because it has twice the fee. Anyway, the \n> miner has no real way of knowing which transaction was real, and which \n> the fraudulent double-spend. The network does not keep accurate \n> timestamps, so it has no way of really knowing which is first. A bit \n> of artificial DDOS-type overload on the recipient's system, and the \n> real transaction could easily appear last.\n>\n> So the decision has been made to make 0-conf double spends trivial, so \n> no one will ever trust 0-confs. If a later transaction appears with a \n> larger fee, it will be considered to be the valid one, and the first \n> one dropped, as long as the first one has not been confirmed. This \n> makes undoing a mistaken transaction possible.\n>\n> So anyone needing 0-conf-like speed will have to make other \n> arangements, such as contracting with enough mining pool power to \n> never drop their transactions unless confirmed multiple times. Secure \n> 0-confs is an impossible target with blockchain cyrpto-currencies as \n> the stand. Any ideas on how to make them work are welcome, of course - \n> as long as we haven't heard them too many times before.\n>\n>\n> On 21 May 2013 10:45, Quinn Harris <btcdev at quinnharris.me \n> <mailto:btcdev at quinnharris.me>> wrote:\n>\n>     The current BitCoin implementation is subject to relatively easy\n>     double\n>     spend attack for 0 confirmation payments.  Yet 0 confirmation payments\n>     are needed for typical in person transactions like most purchases at a\n>     local business.\n>\n>     Notably, it is easy to transmit two transactions from the same\n>     output at\n>     the same time to different sets of nodes on the network by using two\n>     instances of bitcoind with same wallet file and a spend on each daemon\n>     initiated by RPC by some easy to implement code.  If the first attempt\n>     to pay the merchant doesn't go through because they received the\n>     \"wrong\"\n>     transaction it could be quickly followed up with another initiated\n>     spend\n>     from a different output switching which daemon sends the\n>     transaction the\n>     merchant is expecting.  This means an unsophisticated attacker can\n>     reliably get away with this attack and it would be worth while for\n>     small\n>     transactions.  Given this, I would be reluctant to trust 0\n>     confirmation\n>     transactions at all though I think many do in practice.  Someone could\n>     write and publish a special daemon to execute this attack further\n>     reducing the cost.\n>\n>     Right now a node will drop any second spend of the same output in the\n>     memory pool.  After the first transaction has propagated through the\n>     network issuing a second double spend transaction isn't likely to be\n>     seen by a significant number of miners as most nodes especially non\n>     miner nodes will drop this transaction.  Today, it is necessary to\n>     transmit both transactions on the network nearly simultaneously to\n>     reliably get away with this simple attack.  If in this case, the\n>     receiving end is quickly notified of the double spend this attack\n>     becomes more more difficult to get away with.\n>\n>     If the second transaction is relayed instead of being dropped to\n>     notify\n>     the receiving party of the double spend, most miners will receive both\n>     transactions and it is possible that some or even many of the miners\n>     would replace the first transaction with the second if it has a higher\n>     fee as it would be in their short term interest. This can happen some\n>     time after the first transaction has propagated through the network so\n>     the receiving end wouldn't get a timely notification of the double\n>     spend.  Depending on the choices of the miners, this approach to\n>     double\n>     spend notification could exacerbate the very problem it was attempting\n>     to fix compared to the current implementation.  While miners might\n>     continue to drop the second spends, the easy availability of the\n>     second\n>     spends would increase the short term reward for changing this policy.\n>\n>     This problem can be fixed if instead of sending the second\n>     transaction a\n>     new double spend message is sent with proof of the double spend\n>     but not\n>     the complete transactions.  This would allow the receiving end to be\n>     quickly notified of a double spend while in no way increase the chance\n>     over the current implementation that a double spend would be\n>     successful.\n>\n>     The proof of the double spend would include the scriptSig (input) from\n>     the original transactions and the hashes from the \"simplified\"\n>     transaction used by OP_CHECKSIG of the scriptPubKey (output) but\n>     not the\n>     entire transaction.  This is the hash computed by the SignatureHash\n>     function in script.cpp.   The double spend notification message should\n>     contain proofs of both signed transaction spending the same output\n>     ordered by hash to produce a canonical proof for a specific two\n>     transactions.  To reduce DOS potential, the proof should not be\n>     relayed\n>     unless one of the original transactions has been received to ensure\n>     there is some commitment to the block chain and different double spend\n>     proofs of the same output should not be relayed.  The forwarding of\n>     transactions should remain exactly the same as it is now where the\n>     second transaction is dropped but a double spend message is\n>     transmitted\n>     if appropriate.\n>\n>     The existing block chain needs to be checked to make sure the proof of\n>     double spend couldn't have been derived from the block chain and a\n>     single spend in the memory pool.  This could happen if there was\n>     already\n>     an identical transaction in the block chain.  This would typically\n>     only\n>     happen if someone was paying someone else the same amount they had\n>     before and neither side changed addresses.  In this case double spend\n>     detection wouldn't be reliable as it could be generated by anyone, but\n>     both the sending and receiving client could detect this situation and\n>     warn the user.\n>\n>     It would still be possible for an attacker to send the second\n>     transaction directly to powerful miners but this is a distinctly less\n>     viable attack than the current double spend attack.\n>\n>     I would expect this double spend notification implementation to make\n>     double spends more costly than they are worth for most cases today\n>     that\n>     0 confirmation acceptance is needed.  That said over time this\n>     provision\n>     might become less effective.  As the reward for each block mined\n>     decreases, transactions fees will become a more significant part\n>     of the\n>     mining reward accordingly increasing the incentive to replace\n>     transactions with higher fees.  Today most BitCoin participants have a\n>     high expectation of significant future appreciation of BitCoins and\n>     recognize anything that brings into question the integrity of the\n>     system\n>     is likely to reduce that future value so they have a long term self\n>     interest to keep up the impression of integrity.  As BitCoin becomes\n>     more establish this incentive will decrease.\n>\n>     On the other hand, non mining nodes have no incentive to replace by\n>     fee.  The continued increased capital costs of mining would likely\n>     increase the proportion of non mining nodes typically run by those\n>     with\n>     an incentive to assure integrity of the network such as merchants.\n>      But\n>     increasing transaction volume is likely to increase node costs which\n>     would push out non mining nodes with lower incentive more than mining\n>     nodes.  Accordingly increasing block size would have a tendency to\n>     reduce the effectiveness of double spend notification.  The primary\n>     point is there are multiple counteracting forces that make predicting\n>     the future effectiveness of double spend notification uncertain.\n>\n>     I don't believe this necessary warrants conceding that we can not\n>     provide any protection from non trusted 0 confirmations\n>     transaction as a\n>     replace by fee implementation would do.  But it would still be\n>     important\n>     to work towards more robust solutions notably various forms of 3rd\n>     party\n>     trust.  This could be tamper resistant devices trusted to not\n>     duplicate\n>     spends, 3rd party certificates with proof the transaction was spent by\n>     the holder of the certificate or multi signature transactions on the\n>     block chain that must be signed by a trusted 3rd party to spend.  I\n>     would expect it would take significantly longer for the companies and\n>     technologies to be built to implement this on a wide scale than adding\n>     double spend proof messages to the current implementation.  In\n>     addition,\n>     there will likely always be some use cases where a 3rd party\n>     (centralization) is not viable.\n>\n>     Should a BIP and pull request implementing a double spend notification\n>     as described be accepted?\n>\n>     - Quinn\n>\n>\n>\n>     ------------------------------------------------------------------------------\n>     Try New Relic Now & We'll Send You this Cool Shirt\n>     New Relic is the only SaaS-based application performance\n>     monitoring service\n>     that delivers powerful full stack analytics. Optimize and monitor your\n>     browser, app, & servers with just a few lines of code. Try New Relic\n>     and get this awesome Nerd Life shirt!\n>     http://p.sf.net/sfu/newrelic_d2d_may\n>     _______________________________________________\n>     Bitcoin-development mailing list\n>     Bitcoin-development at lists.sourceforge.net\n>     <mailto:Bitcoin-development at lists.sourceforge.net>\n>     https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130520/e6592fd3/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Double Spend Notification",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Quinn Harris",
                "Robert Backhaus",
                "David Vorick",
                "Mike Hearn",
                "Peter Todd",
                "Gregory Maxwell",
                "Gavin Andresen",
                "Pieter Wuille"
            ],
            "messages_count": 14,
            "total_messages_chars_count": 50596
        }
    },
    {
        "title": "[Bitcoin-development] BIP 0021 idea: sendmany",
        "thread_messages": [
            {
                "author": "shaker521 at hushmail.com",
                "date": "2013-05-22T03:25:02",
                "message_text_only": "Multiple recipients/amounts. Any syntax you like. Thanks!\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130522/bd91142b/attachment.html>"
            },
            {
                "author": "Wladimir",
                "date": "2013-05-22T08:46:27",
                "message_text_only": "Do you have a specific use case in mind?\n\nMaybe - if you have a percentage slider like with humble bundles you can\nmake it more explicit what part went where?\n\nIn any case, if you're really interested in this you need to write a new\nBIP that extends 21. \"Any syntax will do\" does not help in implementation\n:-)\n\nWladimir\nMultiple recipients/amounts. Any syntax you like. Thanks!\n\n------------------------------------------------------------------------------\nTry New Relic Now & We'll Send You this Cool Shirt\nNew Relic is the only SaaS-based application performance monitoring service\nthat delivers powerful full stack analytics. Optimize and monitor your\nbrowser, app, & servers with just a few lines of code. Try New Relic\nand get this awesome Nerd Life shirt! http://p.sf.net/sfu/newrelic_d2d_may\n_______________________________________________\nBitcoin-development mailing list\nBitcoin-development at lists.sourceforge.net\nhttps://lists.sourceforge.net/lists/listinfo/bitcoin-development\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130522/707d7fed/attachment.html>"
            },
            {
                "author": "shaker521 at hushmail.com",
                "date": "2013-05-22T18:01:08",
                "message_text_only": "You can pull use cases out of thin air. Humble Bundle is a perfect example.\n\nBIP 0001 instructed me to introduce the idea here before performing the labor of writing a new BIP. If others reply in support then the labor will be justified.\n\nThe intended purpose is to give users the simplest way to perform a transaction with multiple outputs. Ideal would be to provide a single URI (or QR code or what have you) that specifies all of the outputs (address:amount pairs) and minimizes opportunities for user error, e.g. by omitting or altering an output. I'll take you through the process that brought me to the solution below.\n\nThe main part of the current bitcoin URI scheme is a single bitcoinaddress. If the sendmany scheme left this foundation unchanged there will be difficulty with both semantics and backwards compatibility.\n\nContemplate some use cases for sendmany URIs. Are each of the outputs in a given transaction equally important? In other words, are all outputs necessary to fulfill the terms of the exchange between the parties? I would say so.\n\nNot that the bitcoin client should forbid changing the outputs after processing the URI, but that it should reject the entire URI if the client does not support the multi-output syntax.\n\nThe discussion of backward compatibility in BIP 0021 recommends against reqparams being used in a mission-critical way while users upgrade their clients. A reqparams approach would permit the gravest possible error, i.e. an older client silently discarding all but the first address and allowing the user unwittingly to violate the terms of the exchange AND irreversibly send some BTC to a possibly adversarial party. We must guard against this potentially devastating failure mode.\n\nAfter a study of pchar and other BNF terms (http://www.w3.org/TR/hdml20-8.html) I propose the following format with optional labels and amounts:\n\nbitcoin:label/address:amount;label/address:amount?params\n\nBefore arriving at this format I tried and rejected these other output formats:\naddress/label:amount (ambiguous since \":\" and amount are allowed in label's *pchar)\naddress:amount/label (less readable since the label is split from its referent)\n\nThe proposed format keeps labels and addresses together for human readability. The label delimiter \"/\" is a reserved character which eliminates ambiguous cases, making this format easy for bitcoin clients to parse.\n\nTherefore I propose the following grammar:\n\nbitcoinurn     = \"bitcoin:\" outputs [ \"?\" bitcoinparams ]\noutputs        = output *[ \";\" output ] | bitcoinaddress\noutput         = [ label \"/\" ] bitcoinaddress [ \":\" amount ]\nbitcoinaddress = base58 *base58\namount         = *digit [ \".\" *digit ]\nbitcoinparams  = bitcoinparam *[ \"&\" bitcoinparam ]\nbitcoinparam   = amountparam | labelparam | messageparam | otherparam | reqparam\namountparam    = \"amount=\" amount\nlabelparam     = \"label=\" label\nlabel          = *pchar\nmessageparam   = \"message=\" *pchar\notherparam     = pchar *pchar \"=\" *pchar\nreqparam       = \"req-\" pchar *pchar \"=\" *pchar\n\nThis may be added under \"Simpler syntax\":\n\nbitcoin:<address>[:<amount>][/<label>][;<address>[:<amount>][/<label>]][?message=<message>]\n\nAs well as these examples:\n\nbitcoin:Bitcoin+Foundation/1BTCorgHwCg6u2YSAWKgS17qUad6kHmtQW\n\nbitcoin:eBook+Store/175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W:0.1;Bob+Author/1F4JfsqiDTG7vjnsz5daUrz2yexQGXB8uo:1.9?message=Purchased+eBook:+Bobgraphy\n\nBrief testing with MultiBit shows that the URIs above are fully rejected by the client. This is the desired behavior for clients lacking support for multiple-output URIs. Thus we guard against the devastating failure mode outlined above.\n\nDo you appreciate my work? Send a tip:\n1F4JfsqiDTG7vjnsz5daUrz2yexQGXB8uo"
            },
            {
                "author": "shaker521 at hushmail.com",
                "date": "2013-05-22T18:10:03",
                "message_text_only": ">bitcoin:<address>[:<amount>][/<label>][;<address>[:<amount>][/<labe\n>l>]][?message=<message>]\n\nCorrection:\nbitcoin:[<label>/]<address>[:<amount>][;[<label>/]<address>[:<amount>]][?message=<message>]"
            }
        ],
        "thread_summary": {
            "title": "BIP 0021 idea: sendmany",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Wladimir",
                "shaker521 at hushmail.com"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 5332
        }
    },
    {
        "title": "[Bitcoin-development] Changing PGP identities/keys",
        "thread_messages": [
            {
                "author": "Jeff Garzik",
                "date": "2013-05-23T15:26:30",
                "message_text_only": "As part of the process of moving to BitPay, I'll be switching to\njgarzik at bitpay.com as a PGP identity, with brand new signing keys.\n\nHere is a message, signed by jgarzik at exmulti.com's key (the one listed\non bitcoin.org), proving they are the same person.\n\nhttp://yyz.us/jgarzik-now-at-bitpay.txt\nhttp://yyz.us/jgarzik-bitpay-pubkey.txt\n\nIf a couple people would run through this and verify that \"I am me\", I\nwould appreciate it.  A sig check and IRC ack would be great.  Thanks!\n bitcoin.org will be updated after this.\n\n-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\n\nJeff Garzik's business identity and PGP information is:\n\npub  2048R/7ADCA079 2013-05-23 Jeff Garzik <jgarzik at bitpay.com>\n\t Fingerprint=3710 4081 6275 9FC5 A429  6536 E7A5 8E33 7ADC A079\n\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.12 (GNU/Linux)\n\niQIVAwUBUZ4ykNodwg8tvwyoAQImAg//WdYc4RpZDtLUGWGMXr4Jnme9gjLdmFr4\nem1McXk7faHls/qbQOlKdi46mTm4E/RZ6SLE7wMQkPD5RD0ukx3zkkFznbAuBuw2\n/wCmNP2Tt/PZI2x3e9gfdBL0WxVfDTczZtMEMhz0ovMm3MtfZ8Xv9GtK3go+4LXa\neX4OguGVsuh/iJ1fSgr9ObZM1RSC7d7niXDw7oK8St6+G9z/4JiAs7jSpG1/jkw1\nhNqSwxXSL/N5rbccPNvR91jWL7s63MQbrjYSWADxJQ81vLwV6JbyANyc6HnkfrPY\ns0LmqtGqO3qa3xikhde8Iw0urejgyLSSJXcYLak+3TgRZqXmqJWhCW5bwRmathht\nY7Aev1g5oUsrX1KfvSwc76U13C8lqCzi2ICmUt1r2nMDR74hi8rxsxlY/axqZ2nJ\nv2wROiD1ecxBx6rWeSi6K6cl3Oa7jUMkAk0avlw8Ozg/cXDmWqDzqyrLVZNFlDni\nFeoAbgoJ6AnKULVyMLjwHQqx4Dg7tFGFiVefkiNMsXijwhXE2IxiEK52yvBN1M06\nUWwmwBIqFnUnCHN98UGbI4yT9favE2eqKAChvQo4TowaycCw5wNtI1zCkb+Uw40j\n0l3TMCkrqIPJ+1EeQKusewgHk/knpeXuqDFei/04b2TILo1RaQLwwQMyZMILozki\n81Zs1bizUuU=\n=a02R\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Changing PGP identities/keys",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1592
        }
    },
    {
        "title": "[Bitcoin-development] Tentitive port for FreeBSD",
        "thread_messages": [
            {
                "author": "Robert Backhaus",
                "date": "2013-05-25T03:36:46",
                "message_text_only": "Here is the link to the FreeBSD build system 'port' that I am planning to\nget committed when 0.8.2 is released. Any comments appreciated.\n\nThe Makefile mostly just applies the users request for GIU/QR/UPNP. The\nmajor change is using the external port for leveldb. The files directory\ncontains 5 patches - 2 that add boost-crypto to LIBS because we still need\nthat until boost is updated, one that patches the build to use that\nexternal leveldb, and 2 minor fixes that are needed to build. I have got\nbranches ready for pullreqs on those minor fixes - I'll double check them\nand make pullreqs this evening.\n\nAgain, any comments very welcome.\n\nThe files are available at\nhttps://redports.org/browser/robbak/net-p2p/bitcoin\n\nThanks,\nRobert Backhaus.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130525/deacdb6e/attachment.html>"
            },
            {
                "author": "Luke-Jr",
                "date": "2013-05-25T04:03:43",
                "message_text_only": "On Saturday, May 25, 2013 3:36:46 AM Robert Backhaus wrote:\n> Here is the link to the FreeBSD build system 'port' that I am planning to\n> get committed when 0.8.2 is released. Any comments appreciated.\n> \n> The Makefile mostly just applies the users request for GIU/QR/UPNP. The\n> major change is using the external port for leveldb. The files directory\n> contains 5 patches - 2 that add boost-crypto to LIBS because we still need\n> that until boost is updated, one that patches the build to use that\n> external leveldb, and 2 minor fixes that are needed to build. I have got\n> branches ready for pullreqs on those minor fixes - I'll double check them\n> and make pullreqs this evening.\n> \n> Again, any comments very welcome.\n\nWould be nice if you could help test (and use?) the pull request for system \nLevelDB support: https://github.com/bitcoin/bitcoin/pull/2241\nNote that you should be careful to tie your port to the specific LevelDB \nversion bundled, to avoid any risk of unexpected hardforking bugs or fixes in \nupstream LevelDB.\n\nFor the other patches, please try to find a portable solution (if they aren't \nalready) and open pull requests on github.\n\nThanks,\n\nLuke"
            }
        ],
        "thread_summary": {
            "title": "Tentitive port for FreeBSD",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Luke-Jr",
                "Robert Backhaus"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2102
        }
    },
    {
        "title": "[Bitcoin-development] (no subject)",
        "thread_messages": [
            {
                "author": "Zooko Wilcox-OHearn",
                "date": "2013-05-25T05:46:11",
                "message_text_only": "jgarzik wrote:\n > 1) Rule changes.  We don't want these.\n\nIn general? What constitutes a rule change?\n\nFor example, if I understand correctly (from what Gavin said at\nBitcoin 2013), there is a move afoot to lift the block size limit.\nAlthough, when I went to confirm my understanding by reading the\nbitcoin-development list archives, I don't see mention of this. Is\nthere another forum I should be reading if I want to follow Bitcoin\ndevelopment?\n\nAnyway, I hope that there are some rule changes that you would\nconsider for Bitcoin, although I recognize there are vast classes of\nsuch changes that you wouldn't.\n\nI'm trying to figure out what's the most productive way to show you,\nand everyone, candidates for such changes. Things that are definitely\nnot suitable for merging to trunk tomorrow, but might be suitable in a\nyear or two, or \"Next Time We Have A Hardfork\".\n\nI don't think alternative bitcoin-clones are the best venue for those.\nAlthough they are certainly good venues for changes which can never\nmake it into Bitcoin.\n\nPerhaps the best venue for such a thing is just to fork bitcoin.git on github.\n\nRegards,\n\nZooko Wilcox-O'Hearn\n\nFounder, CEO, and Customer Support Rep\n\nhttps://LeastAuthority.com"
            },
            {
                "author": "Wladimir",
                "date": "2013-05-25T08:09:11",
                "message_text_only": "On Sat, May 25, 2013 at 7:46 AM, Zooko Wilcox-OHearn <\nzooko at leastauthority.com> wrote:\n\n> jgarzik wrote:\n>  > 1) Rule changes.  We don't want these.\n>\n> In general? What constitutes a rule change?\n>\n\nI'm sure he means rule changes with economical impact, such as miner block\nreward, total number of bitcoins, block speed. Mostly non-interesting from\na technical view point, but the only changes most altcoins seem to be\nmaking... In any case, these are set in stone and cannot ever be changed\nfor bitcoin or all hell will break loose.\n\nSee also https://en.bitcoin.it/wiki/Hardfork_Wishlist.\n\nWladimir\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130525/cbc46b25/attachment.html>"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2013-05-25T08:25:35",
                "message_text_only": "On 25 May 2013 07:46, Zooko Wilcox-OHearn <zooko at leastauthority.com> wrote:\n\n> jgarzik wrote:\n>  > 1) Rule changes.  We don't want these.\n>\n> In general? What constitutes a rule change?\n>\n> For example, if I understand correctly (from what Gavin said at\n> Bitcoin 2013), there is a move afoot to lift the block size limit.\n> Although, when I went to confirm my understanding by reading the\n> bitcoin-development list archives, I don't see mention of this. Is\n> there another forum I should be reading if I want to follow Bitcoin\n> development?\n>\n> Anyway, I hope that there are some rule changes that you would\n> consider for Bitcoin, although I recognize there are vast classes of\n> such changes that you wouldn't.\n>\n> I'm trying to figure out what's the most productive way to show you,\n> and everyone, candidates for such changes. Things that are definitely\n> not suitable for merging to trunk tomorrow, but might be suitable in a\n> year or two, or \"Next Time We Have A Hardfork\".\n>\n> I don't think alternative bitcoin-clones are the best venue for those.\n> Although they are certainly good venues for changes which can never\n> make it into Bitcoin.\n>\n> Perhaps the best venue for such a thing is just to fork bitcoin.git on\n> github.\n>\n\nIt might be an idea to have 'rule change' fixes and 'bug fix' releases go\nout separately\n\n\n>\n> Regards,\n>\n> Zooko Wilcox-O'Hearn\n>\n> Founder, CEO, and Customer Support Rep\n>\n> https://LeastAuthority.com\n>\n>\n> ------------------------------------------------------------------------------\n> Try New Relic Now & We'll Send You this Cool Shirt\n> New Relic is the only SaaS-based application performance monitoring service\n> that delivers powerful full stack analytics. Optimize and monitor your\n> browser, app, & servers with just a few lines of code. Try New Relic\n> and get this awesome Nerd Life shirt! http://p.sf.net/sfu/newrelic_d2d_may\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130525/84a6f9ae/attachment.html>"
            },
            {
                "author": "Luke-Jr",
                "date": "2013-05-25T08:53:17",
                "message_text_only": "On Saturday, May 25, 2013 8:25:35 AM Melvin Carvalho wrote:\n> It might be an idea to have 'rule change' fixes and 'bug fix' releases go\n> out separately\n\nBitcoin is a consensus system. You can't run clients with different rules on \nthe same blockchain/network - it just won't work! Maybe we're now talking \nabout mere client default policies? In which case, you should be able to \nconfigure previous behaviour...\n\nIf you want just bug fixes and rule changes, without policy default changes, \nnew features, etc, you can use the 0.4.x - 0.7.x backports. But be advised \nthese are short-term solutions and won't be maintained forever - so you really \nshould try to get the behaviour you want from the current release. If you \ncan't for some reason, please do report a bug explaining what it is the older \nversion was capable of that the new one isn't!\n\nLuke"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2013-05-25T09:23:12",
                "message_text_only": "On 25 May 2013 10:53, Luke-Jr <luke at dashjr.org> wrote:\n\n> On Saturday, May 25, 2013 8:25:35 AM Melvin Carvalho wrote:\n> > It might be an idea to have 'rule change' fixes and 'bug fix' releases go\n> > out separately\n>\n> Bitcoin is a consensus system. You can't run clients with different rules\n> on\n> the same blockchain/network - it just won't work! Maybe we're now talking\n> about mere client default policies? In which case, you should be able to\n> configure previous behaviour...\n>\n\n[[ Not wishing to stray too far off topic ]]\n\nI think you are perhaps underestimating the effect of 'mere' default\npolicies.\n\nIt would be nice to think that every node was a free thinking individual\nthat is motivated to vote with their feet, but in practice most people dont\nhave time.\n\nThere is research showing that 80% of users tend to accept defaults.\n\nRule changes and changing defaults would seem to be things worth weighing.\nBug fixes hopefully should be fairly unanimous.  Of course a grey area\nexists in between.\n\n\n>\n> If you want just bug fixes and rule changes, without policy default\n> changes,\n> new features, etc, you can use the 0.4.x - 0.7.x backports. But be advised\n> these are short-term solutions and won't be maintained forever - so you\n> really\n> should try to get the behaviour you want from the current release. If you\n> can't for some reason, please do report a bug explaining what it is the\n> older\n> version was capable of that the new one isn't!\n>\n> Luke\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130525/ddcd58cc/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "(no subject)",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Melvin Carvalho",
                "Luke-Jr",
                "Wladimir",
                "Zooko Wilcox-OHearn"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 6776
        }
    },
    {
        "title": "[Bitcoin-development] Handling alerts & communication on bitcoin.org",
        "thread_messages": [
            {
                "author": "Sa\u00efvann",
                "date": "2013-05-27T02:43:32",
                "message_text_only": "Hi,\n\nThere is currently 5 alerts pages on bitcoin.org concerning past network\nevents (vulnerabilities, hard fork, etc.). Those don't have any\nvisibility and cannot be listed or followed easily.\n\nI've created a setup to improve this and allow developers to easily\ncommunicate about any kind of network event worth mentionning. Code,\nscreenshot, live demo, instructions and details are in the pull request :\nhttps://github.com/bitcoin/bitcoin.org/pull/194\n\nAny comment is welcome. And since it is ultimately a tool for\ndevelopers, only you can define if it makes sense to merge it. Or if you\nwould like it to be done differently.\n\nBest,\n\nSa\u00efvann\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130526/894fc2cc/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Handling alerts & communication on bitcoin.org",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Sa\u00efvann"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 826
        }
    },
    {
        "title": "[Bitcoin-development] BIP0032",
        "thread_messages": [
            {
                "author": "Michael Gronager",
                "date": "2013-05-27T09:41:04",
                "message_text_only": "Pieter,\n\nI was re-reading BIP0032, and checking some of the equations... It seems\nto me that there is something wrong (or I have missed something).\n\nAs I see it there can only be one HMAC function, used for both private\nand public derivation - I assume that:\n[1]  CKD((k_par, c_par), i) -> (k_i, c_i)\n[2]  CKD'((K_par, c_par), i) -> (K_i, c_i)\n\nWhere K_par = k_par*G, will result in K_i = k_i*G (and identical c_i's\nin both expressions).\n\nNow following your formulas for [1]:\n  k_i = I_L + k_par (mod n)\nwhere I_L = {HMACSHA512(c_par, 0x00||k_par||i)}_L (denoting left\n256bits). Further c_i = I_R.\nThis gives a K_i = k_i*G = I_L*G + k_par(mod n)*G\n\nNow follow the formula for [2]:\n  K_i = (I_L+k_par)*G = I_L*G + K_par\nThis is not the same as above, however, if we remove the (mod n) we are\ngetting closer, but still the value of I_L are different in the two\nequations as: HMACSHA512(c_par, 0x00||k_par||i) <> HMAXSHA512(c_par,\nX(k_par*G)||i).\n\nWe can, however, fix things if we change private child key derivation to:\n\nTo define CDK((k_par, c_par), i) -> (k_i, c_i):\n* (no difference in deriving public or private):\n\tI = HMACSHA512(c_par, X(k_par*G)||i)\n* Split I into I_L, I_R (256bits each)\n* k_i = k_par + I_L\n* c_i = I_R\n* and, if using public derivation, we use K_i = (k_par + I_L)*G\n\nNow for pure public derivation (i.e. we don't know the private key):\nTo define CDK'((K_par, c_par), i) -> (K_i, c_i):\n* I = HMACSHA512(c_par, X(K_par)||i)\n* Split I into I_L and I_R\n* K_i = K_par + I_L*G (= k_par*G + I_L*G = (k_par+I_L)*G = k_i*G)\n* c_i = I_R\n\nNow we have the right properties, but it required quite some changes,\nalso note that c_i are now equal in both private and public derivation.\n\nComments ?\n\n\nSincerely,\n\nMichael"
            },
            {
                "author": "Michael Gronager",
                "date": "2013-05-27T13:10:04",
                "message_text_only": "Commenting on my own mail...\n\nRereading the BIP, it occurs to me that the private derivation is\nactually intentional. So:\n(m/i/j/k)*G = (M/i/j/k), but (m/i'/j/k)*G <> (M/i/j/k) (M/i'/j/k => ERROR)\n\nBut: ((m/i')*G)/j/k = (m/i'/j/k)*G\n\nSo, the motivation for the private derivation is to avoid the known (K,\nc) and known k_i => k known too! I fear that many will fall in this\ntrap, though...\n\n/Michael"
            },
            {
                "author": "Michael Gronager",
                "date": "2013-05-27T13:39:19",
                "message_text_only": "Which again means that the statement regarding Audits through the Master\nPublic key, M, is wrong - only incoming and outgoing transaction of\n_publicly_ derived wallets will be part of the audit... Privately\nderived wallets cannot be obtained, though you could, without loss of\nsecurity, share also the addition points from privately derived wallets:\n(m/i')*G, but there is no concept of a single public master key.\n\n==\nAudits: M\nIn case an auditor needs full access to the list of incoming and\noutgoing payments, one can share the master public extended key. This\nwill allow the auditor to see all transactions from and to the wallet,\nin all accounts, but not a single secret key.\n=="
            },
            {
                "author": "Amir Taaki",
                "date": "2013-05-27T17:21:04",
                "message_text_only": "Yeah, I tried implementing it based on the document there and the code that is available in sipa's repo on GitHub but it's not enough. I'm waiting until there is an implementation of this concept before moving on it.\n\n\n\n________________________________\n From: Michael Gronager <gronager at ceptacle.com>\nTo: bitcoin-development at lists.sourceforge.net \nSent: Monday, May 27, 2013 2:39 PM\nSubject: Re: [Bitcoin-development] BIP0032\n \n\nWhich again means that the statement regarding Audits through the Master\nPublic key, M, is wrong - only incoming and outgoing transaction of\n_publicly_ derived wallets will be part of the audit... Privately\nderived wallets cannot be obtained, though you could, without loss of\nsecurity, share also the addition points from privately derived wallets:\n(m/i')*G, but there is no concept of a single public master key.\n\n==\nAudits: M\nIn case an auditor needs full access to the list of incoming and\noutgoing payments, one can share the master public extended key. This\nwill allow the auditor to see all transactions from and to the wallet,\nin all accounts, but not a single secret key.\n==\n\n\n\n------------------------------------------------------------------------------\nTry New Relic Now & We'll Send You this Cool Shirt\nNew Relic is the only SaaS-based application performance monitoring service \nthat delivers powerful full stack analytics. Optimize and monitor your\nbrowser, app, & servers with just a few lines of code. Try New Relic\nand get this awesome Nerd Life shirt! http://p.sf.net/sfu/newrelic_d2d_may\n_______________________________________________\nBitcoin-development mailing list\nBitcoin-development at lists.sourceforge.net\nhttps://lists.sourceforge.net/lists/listinfo/bitcoin-development\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130527/8a3ba97d/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2013-05-27T20:45:30",
                "message_text_only": "On Mon, May 27, 2013 at 03:10:04PM +0200, Michael Gronager wrote:\n> Commenting on my own mail...\n> \n> Rereading the BIP, it occurs to me that the private derivation is\n> actually intentional. So:\n> (m/i/j/k)*G = (M/i/j/k), but (m/i'/j/k)*G <> (M/i/j/k) (M/i'/j/k => ERROR)\n> \n> But: ((m/i')*G)/j/k = (m/i'/j/k)*G\n> \n> So, the motivation for the private derivation is to avoid the known (K,\n> c) and known k_i => k known too! I fear that many will fall in this\n> trap, though...\n\nI think the current formulation in the BIP text is a bit confusing, as there\nis both \"public derivation\" (namely: derivation that can be done using just\nthe public key), and the \"public derivation function\" (the one that takes\nthe public key as input). Any suggestion for better terminology is welcome.\nOne possibility is calling it type-1 and type-2 derivation, but that's only\nenlightening if you of the origin of the concept.\n\nThere is current \"test vector generation\" code on the 'detwallet' branch on\nmy github repo, but this isn't useful for actual deterministic wallets.\nI'm working on having an implementation that nicely integrates with the key\nabstraction.\n\nAlso, there are already other implementations available, such as this Python\none https://github.com/FelixWeis/hdwallet, and Java code in Bits of Proof\n(with whom the test vectors match, after finding a bug in mine...)\n\nOf course, implementing a determinstic wallet is more than just key derivation.\nThere is dealing with detecting new keys/chains being used, lookahead, how to\nuse accounts (if at all), and internal/external subchains. I think this is\nmuch more likely to differ more between different implementations, and perhaps\ninteresting applications\n\n-- \nPieter"
            },
            {
                "author": "Tamas Blummer",
                "date": "2013-05-28T05:16:41",
                "message_text_only": "A JSON-ed version of the test vectors is here: https://github.com/bitsofproof/supernode/blob/master/api/src/test/resources/BIP32.json\n\nThe Bits of Proof code matching with them is at:\nhttps://github.com/bitsofproof/supernode/blob/master/api/src/main/java/com/bitsofproof/supernode/api/ExtendedKey.java\n\nTamas Blummer\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 495 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130528/18e85f10/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "BIP0032",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Michael Gronager",
                "Tamas Blummer",
                "Pieter Wuille",
                "Amir Taaki"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 7057
        }
    },
    {
        "title": "[Bitcoin-development] Bitcoin-Qt / bitcoind version 0.8.2 (final) released",
        "thread_messages": [
            {
                "author": "Gavin Andresen",
                "date": "2013-05-29T21:18:58",
                "message_text_only": "Bitcoin-Qt version 0.8.2 is now available from:\n  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.8.2/\n\nThis is a maintenance release that fixes many bugs and includes\na few small new features.\n\nPlease report bugs using the issue tracker at github:\n  https://github.com/bitcoin/bitcoin/issues\n\n\nHow to Upgrade\n--------------\n\nIf you are running an older version, shut it down. Wait\nuntil it has completely shut down (which might take a few minutes for older\nversions), then run the installer (on Windows) or just copy over\n/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).\n\nIf you are upgrading from version 0.7.2 or earlier, the first time you\nrun 0.8.2 your blockchain files will be re-indexed, which will take\nanywhere from 30 minutes to several hours, depending on the speed of\nyour machine.\n\n0.8.2 Release notes\n===================\n\nFee Policy changes\n------------------\n\nThe default fee for low-priority transactions is lowered from 0.0005 BTC\n(for each 1,000 bytes in the transaction; an average transaction is\nabout 500 bytes) to 0.0001 BTC.\n\nPayments (transaction outputs) of 0.543 times the minimum relay fee\n(0.00005430 BTC) are now considered 'non-standard', because storing them\ncosts the network more than they are worth and spending them will usually\ncost their owner more in transaction fees than they are worth.\n\nNon-standard transactions are not relayed across the network, are not included\nin blocks by most miners, and will not show up in your wallet until they are\nincluded in a block.\n\nThe default fee policy can be overridden using the -mintxfee and -minrelaytxfee\ncommand-line options, but note that we intend to replace the hard-coded fees\nwith code that automatically calculates and suggests appropriate fees in the\n0.9 release and note that if you set a fee policy significantly different from\nthe rest of the network your transactions may never confirm.\n\nBitcoin-Qt changes\n------------------\n\n* New icon and splash screen\n* Improve reporting of synchronization process\n* Remove hardcoded fee recommendations\n* Improve metadata of executable on MacOSX and Windows\n* Move export button to individual tabs instead of toolbar\n* Add \"send coins\" command to context menu in address book\n* Add \"copy txid\" command to copy transaction IDs from transaction overview\n* Save & restore window size and position when showing & hiding window\n* New translations: Arabic (ar), Bosnian (bs), Catalan (ca), Welsh (cy),\n  Esperanto (eo), Interlingua (la), Latvian (lv) and many improvements\n  to current translations\n\nMacOSX:\n* OSX support for click-to-pay (bitcoin:) links\n* Fix GUI disappearing problem on MacOSX (issue #1522)\n\nLinux/Unix:\n* Copy addresses to middle-mouse-button clipboard\n\n\nCommand-line options\n--------------------\n\n* -walletnotify will call a command on receiving transactions that\naffect the wallet.\n* -alertnotify will call a command on receiving an alert from the network.\n* -par now takes a negative number, to leave a certain amount of cores free.\n\nJSON-RPC API changes\n--------------------\n\n* fixed a getblocktemplate bug that caused excessive CPU creating blocks.\n* listunspent now lists account and address infromation.\n* getinfo now also returns the time adjustment estimated from your peers.\n* getpeerinfo now returns bytessent, bytesrecv and syncnode.\n* gettxoutsetinfo returns statistics about the unspent transaction\noutput database.\n* gettxout returns information about a specific unspent transaction output.\n\n\nNetworking changes\n------------------\n\n* Significant changes to the networking code, reducing latency and\nmemory consumption.\n* Avoid initial block download stalling.\n* Remove IRC seeding support.\n* Performance tweaks.\n* Added testnet DNS seeds.\n\nWallet compatibility/rescuing\n-----------------------------\n\n* Cases where wallets cannot be opened in another version/installation\nshould be reduced.\n* -salvagewallet now works for encrypted wallets.\n\n\nKnown Bugs\n----------\n\n* Entering the 'getblocktemplate' or 'getwork' RPC commands into the\nBitcoin-Qt debug\nconsole will cause Bitcoin-Qt to crash. Run Bitcoin-Qt with the\n-server command-line\noption to workaround.\n\nThanks to everybody who contributed to the 0.8.2 release!\n---------------------------------------------------------\n\nAPerson241\nAndrew Poelstra\nCalvin Owens\nChuck LeDuc D\u00edaz\nColin Dean\nDavid Griffith\nDavid Serrano\nEric Lombrozo\nGavin Andresen\nGregory Maxwell\nJeff Garzik\nJonas Schnelli\nLarry Gilbert\nLuke Dashjr\nMatt Corallo\nMichael Ford\nMike Hearn\nPatrick Brown\nPeter Todd\nPhilip Kaufmann\nPieter Wuille\nRichard Schwab\nRoman Mindalev\nScott Howard\nTariq Bashir\nWarren Togami\nWladimir J. van der Laan\nfreewil\ngladoscc\nkjj2\nmb300sd\nsuper3"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin-Qt / bitcoind version 0.8.2 (final) released",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Gavin Andresen"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 4694
        }
    },
    {
        "title": "[Bitcoin-development] 0.8.2 branch",
        "thread_messages": [
            {
                "author": "grarpamp",
                "date": "2013-05-30T02:54:00",
                "message_text_only": "Should there not be a 0.8.2 branch laid down at 09e437b (v0.8.2)\nin which the like of release build stoppers or critfixes such as d315eb0\nare included... for those tracking that level of defect without\nwishing to track all the growing post release slush in HEAD?"
            },
            {
                "author": "Luke-Jr",
                "date": "2013-05-30T02:57:06",
                "message_text_only": "On Thursday, May 30, 2013 2:54:00 AM grarpamp wrote:\n> Should there not be a 0.8.2 branch laid down at 09e437b (v0.8.2)\n> in which the like of release build stoppers or critfixes such as d315eb0\n> are included... for those tracking that level of defect without\n> wishing to track all the growing post release slush in HEAD?\n\nI'll branch 0.8.x sometime in the next few weeks.\n\nStable branches are maintained on Gitorious for now:\n\thttp://gitorious.org/bitcoin/bitcoind\n\nLuke"
            }
        ],
        "thread_summary": {
            "title": "0.8.2 branch",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Luke-Jr",
                "grarpamp"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 735
        }
    },
    {
        "title": "[Bitcoin-development] Implementing batch processing for -blocknotify",
        "thread_messages": [
            {
                "author": "Rune Kj\u00e6r Svendsen",
                "date": "2013-05-31T11:56:43",
                "message_text_only": "Hello dear list\n\nI have an application that wants to keep up with new blocks as they come\nin. For that I can use the -blocknotify option with bitcoind, which will\nexecute my application for each new block.\n\nThe problem is that my app isn't necessarily quick enough to finish its\nwork before a new block comes in and the app is executed again. This means\nthe that bitcoind might keep executing my application even though the\nprevious instance hasn't finished, and that's fairly inefficient\nresource-wise, as many instances of the application will be running\nsimultaneously.\n\nI've discussed this with wumpus on bitcoin-dev, and we figured out a\nsolution that might be better. It could replace -blocknotify or we could\nput it in a new function called -batchblocknotify\n\nThe idea is that when bitcoind is executed with the -batchblocknotify\noption, and it's missing a lot of blocks, upon the first incoming block,\nthe command specified by -batchblocknotify is executed, and if additional\nblocks come in while this command is still running, we add the block hashes\nto a list instead of executing the command again. When the previous command\nfinishes, we execute it again and pass two parameters to it: 1. the first\nblock hash in the list of queued blocks, and 2. the number of blocks that\nhave come in while the last command was executing.\n\nThis prevents bitcoind from \"fork bombing\" the system, and allows the\ncommand to handle incoming blocks in batches.\n\nWould this make sense as an approach?\n\nI've been looking at the code and I'm not sure how to implement it.\n\nAs far as I can see, I need to pass an object - whose state is retained\nbetween calls - to the thread function (runCommand) that runs the command,\nwhich contains a variable that keeps track of whether a previously executed\ncommand is still running, and that contains a list of block hashes that\nhaven't been processed. And I'm not sure how to do this.\n\nThe runCommand thread is started in SetBestChain() in\nmain.cpp. SetBestChain() is executed by ConnectBestBlock() in main.cpp.\nConnectBestBlock() is executed by CBlock::AddToBlockIndex() in main.cpp.\nCBlock::AddToBlockIndex() is executed by CBlock::AcceptBlock() in main.cpp.\nCBlock::AcceptBlock() is executed by ProcessBlock() in main.cpp.\nProcessBlock() is executed by ProcessMessage() in main.cpp. And so on, and\nso forth.\n\nWhat's the right way to create an object that can be passed to the\nrunCommand thread, whose state is retained, so it can hold information\nabout whether the -batchblocknotify command is still executing, and contain\na list of blocks that are waiting to be passed to the -batchblocknotify\ncommand?\n\nI assume I shouldn't add a new parameter to the ProcessMessage() function,\nwhich passes it to ProcessBlock(), which passes it to AcceptBlock() which\npasses it to AddToBlockIndex()... and so on.\n\nWould it be appropriate to store this object inside the CValidationState\nclass that is passed to SetBestChain()?\n\nI'm not quite so how to go about this.\n\n/Rune\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130531/73ed57be/attachment.html>"
            },
            {
                "author": "Michael Hendricks",
                "date": "2013-05-31T12:10:50",
                "message_text_only": "On Fri, May 31, 2013 at 5:56 AM, Rune Kj\u00e6r Svendsen <runesvend at gmail.com>wrote:\n\n> I have an application that wants to keep up with new blocks as they come\n> in. For that I can use the -blocknotify option with bitcoind, which will\n> execute my application for each new block.\n>\n> The problem is that my app isn't necessarily quick enough to finish its\n> work before a new block comes in and the app is executed again.\n>\n\nIn a similar circumstance, I changed my -blocknotify script to quickly\nappend necessary information to a queue and immediately exit.  A separate\nscript runs at all times monitoring this queue for work and performs the\nlabor intensive calculations.\n\nI hope that helps.\n\n-- \nMichael\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130531/82acd521/attachment.html>"
            },
            {
                "author": "Rune Kj\u00e6r Svendsen",
                "date": "2013-05-31T12:37:50",
                "message_text_only": "On Fri, May 31, 2013 at 2:10 PM, Michael Hendricks <michael at ndrix.org>wrote:\n\n> On Fri, May 31, 2013 at 5:56 AM, Rune Kj\u00e6r Svendsen <runesvend at gmail.com>wrote:\n>\n>> I have an application that wants to keep up with new blocks as they come\n>> in. For that I can use the -blocknotify option with bitcoind, which will\n>> execute my application for each new block.\n>>\n>> The problem is that my app isn't necessarily quick enough to finish its\n>> work before a new block comes in and the app is executed again.\n>>\n>\n> In a similar circumstance, I changed my -blocknotify script to quickly\n> append necessary information to a queue and immediately exit.  A separate\n> script runs at all times monitoring this queue for work and performs the\n> labor intensive calculations.\n>\n\nI've thought about this as well. It just seems somewhat clunky to me. I'd\nreally prefer having bitcoind put out messages in batches, if it's doable,\nthat is.\n\nI'd run into a lot of concurrency issues, as far as I can see, where I\ncan't be sure that the queue isn't written to while, for example, it is\nopened by the program that needs to process the queue items.\n\nWhat if a disk operation takes a long time to finish, and a two queue\noperations want to add to the queue simultaneously? This really brings\nforward all the horrors of concurrent programming.\n\n\nOn Fri, May 31, 2013 at 2:17 PM, Jeremy Spilman <jeremy at taplink.co> wrote:\n\n> Would it work to just block the bitcoind thread until your process exits?\n>\n\nI don't think that's optimal, no. That would slow down synchronization\ndrastically.\n\nIt would be really nimble for bitcoind to be able to synchronize at full\nspeed, and only send out events when necessary, batching together\npreviously queued items.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130531/56c9f354/attachment.html>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-05-31T19:25:44",
                "message_text_only": "On Fri, May 31, 2013 at 8:37 AM, Rune Kj\u00e6r Svendsen <runesvend at gmail.com> wrote:\n> I've thought about this as well. It just seems somewhat clunky to me. I'd\n> really prefer having bitcoind put out messages in batches, if it's doable,\n> that is.\n>\n> I'd run into a lot of concurrency issues, as far as I can see, where I can't\n> be sure that the queue isn't written to while, for example, it is opened by\n> the program that needs to process the queue items.\n>\n> What if a disk operation takes a long time to finish, and a two queue\n> operations want to add to the queue simultaneously? This really brings\n> forward all the horrors of concurrent programming.\n\nThis is not a compelling need to update bitcoind for this.\n\nThe vast majority of systems are currently capable of processing a\nblock, before another block arrives.\n\nAs for parallel processing, your \"what if\" has been a solved problem\nfor decade(s) now.\n\n-- \nJeff Garzik\nSenior Software Engineer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Andy Parkins",
                "date": "2013-05-31T12:54:03",
                "message_text_only": "On Friday 31 May 2013 12:56:43 Rune Kj\u00e6r Svendsen wrote:\n\n> I have an application that wants to keep up with new blocks as they come\n> in. For that I can use the -blocknotify option with bitcoind, which will\n> execute my application for each new block.\n> \n> The problem is that my app isn't necessarily quick enough to finish its\n> work before a new block comes in and the app is executed again. This means\n> the that bitcoind might keep executing my application even though the\n> previous instance hasn't finished, and that's fairly inefficient\n> resource-wise, as many instances of the application will be running\n> simultaneously.\n\nHave your program try to create a unix-domain socket when it starts.  If it \ncan't create it (because one already exists at that path), then connect to it.\n\nYou then have two modes:\n\n - Creator of socket, listens to socket for more incoming data, and adds it to\n   some sort of internal block queue.\n - Client to socket, pushes output of -blocknotify to socket and exits\n\nYour concurrency problems go away because only one process is ever actually \ndoing something with the data.\n\nShould be fairly straight forward.  The client is simple.  The server is two \nthreads, one listening on the socket and then briefly locking and updating a \nqueue, and one thread briefly locking and removing from the queue.\n\n\n\nAndy\n\n-- \nDr Andy Parkins\nandyparkins at gmail.com"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-05-31T13:05:54",
                "message_text_only": "On Fri, May 31, 2013 at 7:56 AM, Rune Kj\u00e6r Svendsen <runesvend at gmail.com> wrote:\n> Hello dear list\n>\n> I have an application that wants to keep up with new blocks as they come in.\n> For that I can use the -blocknotify option with bitcoind, which will execute\n> my application for each new block.\n>\n> The problem is that my app isn't necessarily quick enough to finish its work\n> before a new block comes in and the app is executed again. This means the\n> that bitcoind might keep executing my application even though the previous\n> instance hasn't finished, and that's fairly inefficient resource-wise, as\n> many instances of the application will be running simultaneously.\n>\n> I've discussed this with wumpus on bitcoin-dev, and we figured out a\n> solution that might be better. It could replace -blocknotify or we could put\n> it in a new function called -batchblocknotify\n\nSimilar to other suggestions in this thread,\n\nIf your -blocknotify execution is too slow, then create a solution\nthat simply queues work.  There is no need to add this code to\nbitcoind itself.\n\nAnother solution is modifying pynode to directly listen to a trusted\nnode (bitcoind), and monitor blocks as they arrive and are announced.\nThat does not fix the problem of slow block processing on your side,\nbut is another way to implement -blocknotify-like behavior.\n\n-- \nJeff Garzik\nSenior Software Engineer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Chris Double",
                "date": "2013-05-31T22:20:05",
                "message_text_only": "On Fri, May 31, 2013 at 11:56 PM, Rune Kj\u00e6r Svendsen\n<runesvend at gmail.com> wrote:\n> I'm not quite so how to go about this.\n\nAs others have said, queuing outside of bitcoind is a better approach.\nI use zeromq for this situation. blocknotify runs a program which uses\nzeromq's pub/sub to queue and the application subscribes to this to\nget notified of the data.\n\n-- \nhttp://www.bluishcoder.co.nz"
            },
            {
                "author": "Wladimir",
                "date": "2013-05-31T23:29:46",
                "message_text_only": "Chris,\n\nUsing zmq is a great fit for high-speed notifications such as this. Have\nyou seen the pull request to integrate zmq directly into bitcoind, so that\nyou don't even need -blocknotify?\n\nhttps://github.com/bitcoin/bitcoin/pull/2415\n\nIf not: we could use some testing there!\n\nWladimir\n\n\n\nOn Sat, Jun 1, 2013 at 12:20 AM, Chris Double <chris.double at double.co.nz>wrote:\n\n> On Fri, May 31, 2013 at 11:56 PM, Rune Kj\u00e6r Svendsen\n> <runesvend at gmail.com> wrote:\n> > I'm not quite so how to go about this.\n>\n> As others have said, queuing outside of bitcoind is a better approach.\n> I use zeromq for this situation. blocknotify runs a program which uses\n> zeromq's pub/sub to queue and the application subscribes to this to\n> get notified of the data.\n>\n> --\n> http://www.bluishcoder.co.nz\n>\n>\n> ------------------------------------------------------------------------------\n> Get 100% visibility into Java/.NET code with AppDynamics Lite\n> It's a free troubleshooting tool designed for production\n> Get down to code-level detail for bottlenecks, with <2% overhead.\n> Download for free and get started troubleshooting in minutes.\n> http://p.sf.net/sfu/appdyn_d2d_ap2\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130601/f301a032/attachment.html>"
            },
            {
                "author": "Chris Double",
                "date": "2013-05-31T23:47:17",
                "message_text_only": "On Sat, Jun 1, 2013 at 11:29 AM, Wladimir <laanwj at gmail.com> wrote:\n> Using zmq is a great fit for high-speed notifications such as this. Have you\n> seen the pull request to integrate zmq directly into bitcoind, so that you\n> don't even need -blocknotify?\n>\n> https://github.com/bitcoin/bitcoin/pull/2415\n>\n> If not: we could use some testing there!\n\nI hadn't seen this, thanks! I've integrated zmq myself for block\nnotifications in bitcoin and the alt coins I use it on my bitparking\nmerge mining pool. I would love to see something official. I'll try\nout the patch in the pull request.\n\nChris.\n-- \nhttp://www.bluishcoder.co.nz"
            }
        ],
        "thread_summary": {
            "title": "Implementing batch processing for -blocknotify",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Wladimir",
                "Chris Double",
                "Rune Kj\u00e6r Svendsen",
                "Andy Parkins",
                "Michael Hendricks"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 12418
        }
    },
    {
        "title": "[Bitcoin-development] Decentralizing mining",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2013-05-31T16:57:58",
                "message_text_only": "I just posted the following to bitcointalk.\n\nhttps://bitcointalk.org/index.php?topic=221164.0\n\n\nRight now between two to four running the largest pools control Bitcoin\nin the short term. That's a lot of hashing power in the hands of very,\nvery few people. In addition pools have little incentive to run secure\noperations, and many pools have been hacked with their funds stolen.\nThose hacks could just have easily been used to attack the network\nitself.\n\nThis needs to change.\n\nPooled-solo mining is a concept Gregory Maxwell, Luke Dashjr and I were\ndiscussing at the conference two weeks ago. (credit goes to Greg and\nLuke; I was mostly just listening) Basically the idea is that miners\nwith mining equipment run a local Bitcoin node and use that node to\nconstruct the blocks they mine - the same as if they were solo mining.\nThe pools job is then to only track shares and organize payouts.\n\nIf the pool gets hacked the worst that can happen is miners are ripped\noff, rather than Bitcoin itself being attacked. With pooled-solo mining\neven a pool with a majority of hashing power wouldn't be able to do much\nharm to Bitcoin. (depending on the implementation they may be able to\nblacklist specific transactions - the pool needs to know what\ntransactions are in the share to credit fees properly)\n\nTech-wise Luke created getblocktemplate last year as a means to audit\nmining pools. I'm sure Greg and Luke can explain the nitty gritty\ndetails better than I can, but essentially the plan is to take\ngetblocktemplate and extend it as required for pooled-solo mining. This\nwill include pool and miner software initially, and later improvements\nto GUIs and what not to make the whole process easier.\n\n\nWith the success of my recent video project I also want to make this\nKeep Bitcoin Free's next project, specifically funding a developer\n(likely Luke) to make this happen. Additionally once software is written\nand easily usable a good follow-up would be a video and other media to\npromote the idea to miners. No guarantees we'll be able to come up with\ncommercially competitive remuneration, but we can at least come up with\na \"Thank you\" tip. But first lets discuss the technical requirements to\nget an idea of what the scope is.\n\n\nFinally, for the record, a big part of the reason why myself and other\nKeep Bitcoin Free supporters are interested in doing this is very much\nto take power over the direction of the network from big pools and put\nit into the hands of thousands of individual miners. It's much easier to\nconvince people that changes to Bitcoin, like increasing the blocksize,\nare directly impacting decentralization when individual miners are\nseeing that happen to themselves.\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000c14fa7031b2431ab32785efdf1e5aaecc83555ee52a2fc550b\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130531/3bc128f5/attachment.sig>"
            },
            {
                "author": "Adam Back",
                "date": "2013-05-31T18:14:23",
                "message_text_only": "I like this idea a lot.\n\nTo add: I think it is a bug and security risk if pooled-solo or (current\npooled miners) do not add randomness to their extraNonce2 (like 128-bits of\nit).  For privacy and to avoid various hostile-pre-mining attacks it should\nbe done this way.  Lack of the self-chosen challenge field is the reason\nSatoshi's first year mining is marked (plus forgetting to reset the\ncounter).  (Bitcoind I believe considered the direct miners key as defense\nenough as a stand in for self-chosen challenge, which has a few problems).\n\nThe base counter I think is only 32-bits, the extranonce2 itself being\nrandom can be incremented while still looking random.  But incrementing\nextranonce directy while initializing it to 0 is not good (per previous\nmining extranone marked coins bug - is that even fixed?)\n\n(You dont want to  reveal the miners power in his pool shares, if the full\ncounter is revealed with no randomness it also reveals how many iterations\nhe can do since the block start).\n\nAdam\n\nOn Fri, May 31, 2013 at 12:57:58PM -0400, Peter Todd wrote:\n>I just posted the following to bitcointalk.\n>\n>https://bitcointalk.org/index.php?topic=221164.0\n>\n>\n>Right now between two to four running the largest pools control Bitcoin\n>in the short term. That's a lot of hashing power in the hands of very,\n>very few people. In addition pools have little incentive to run secure\n>operations, and many pools have been hacked with their funds stolen.\n>Those hacks could just have easily been used to attack the network\n>itself.\n>\n>This needs to change.\n>\n>Pooled-solo mining is a concept Gregory Maxwell, Luke Dashjr and I were\n>discussing at the conference two weeks ago. (credit goes to Greg and\n>Luke; I was mostly just listening) Basically the idea is that miners\n>with mining equipment run a local Bitcoin node and use that node to\n>construct the blocks they mine - the same as if they were solo mining.\n>The pools job is then to only track shares and organize payouts.\n>\n>If the pool gets hacked the worst that can happen is miners are ripped\n>off, rather than Bitcoin itself being attacked. With pooled-solo mining\n>even a pool with a majority of hashing power wouldn't be able to do much\n>harm to Bitcoin. (depending on the implementation they may be able to\n>blacklist specific transactions - the pool needs to know what\n>transactions are in the share to credit fees properly)\n>\n>Tech-wise Luke created getblocktemplate last year as a means to audit\n>mining pools. I'm sure Greg and Luke can explain the nitty gritty\n>details better than I can, but essentially the plan is to take\n>getblocktemplate and extend it as required for pooled-solo mining. This\n>will include pool and miner software initially, and later improvements\n>to GUIs and what not to make the whole process easier.\n>\n>\n>With the success of my recent video project I also want to make this\n>Keep Bitcoin Free's next project, specifically funding a developer\n>(likely Luke) to make this happen. Additionally once software is written\n>and easily usable a good follow-up would be a video and other media to\n>promote the idea to miners. No guarantees we'll be able to come up with\n>commercially competitive remuneration, but we can at least come up with\n>a \"Thank you\" tip. But first lets discuss the technical requirements to\n>get an idea of what the scope is.\n>\n>\n>Finally, for the record, a big part of the reason why myself and other\n>Keep Bitcoin Free supporters are interested in doing this is very much\n>to take power over the direction of the network from big pools and put\n>it into the hands of thousands of individual miners. It's much easier to\n>convince people that changes to Bitcoin, like increasing the blocksize,\n>are directly impacting decentralization when individual miners are\n>seeing that happen to themselves.\n>\n>-- \n>'peter'[:-1]@petertodd.org\n>00000000000000c14fa7031b2431ab32785efdf1e5aaecc83555ee52a2fc550b\n\n\n\n>------------------------------------------------------------------------------\n>Get 100% visibility into Java/.NET code with AppDynamics Lite\n>It's a free troubleshooting tool designed for production\n>Get down to code-level detail for bottlenecks, with <2% overhead.\n>Download for free and get started troubleshooting in minutes.\n>http://p.sf.net/sfu/appdyn_d2d_ap2\n\n>_______________________________________________\n>Bitcoin-development mailing list\n>Bitcoin-development at lists.sourceforge.net\n>https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            }
        ],
        "thread_summary": {
            "title": "Decentralizing mining",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Adam Back",
                "Peter Todd"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 7532
        }
    }
]