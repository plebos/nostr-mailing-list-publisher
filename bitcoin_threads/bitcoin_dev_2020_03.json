[
    {
        "title": "[bitcoin-dev] Nonce blinding protocol for hardware wallets and airgapped signers",
        "thread_messages": [
            {
                "author": "Dustin Dettmer",
                "date": "2020-03-02T19:45:02",
                "message_text_only": "+1 love that progress is being made on this. Excited to implement it once\nit\u2019s ready.\n\nWould love if things like the incrementing number were included in the\nstandard as well.\n\nCheers! \ud83c\udf7b\n\nOn Fri, Feb 28, 2020 at 9:51 AM Marko via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Thanks for starting this initiative; it has been a long standing goal of\n> mine to implement and release this protocol. Your blog post on the topic\n> actually inspired me to pick up this work again a few months ago.\n>\n> Jonas Nick has implemented the protocol in the secp256k1 library for\n> Schnorr sigs here: https://github.com/bitcoin-core/secp256k1/pull/590\n>\n> I have backported the same scheme to ECDSA in the secp256k1 library\n> here, so it can be used also for current transactions:\n>\n> https://github.com/bitcoin-core/secp256k1/pull/669\n>\n> I also made proof of concepts for the BitBox02 hw wallet firmware and\n> BitBoxApp wallet to verify that the protocol also works well in practice.\n>\n> The actual scheme used in those implementations is a generalized\n> sign-to-contract scheme, where the final nonce is computed as `k' = k +\n> H(k*G, n)` instead of `k'=k+n`, but otherwise it works mostly the same\n> for the anti nonce covert channel protocol. I suggest to use this scheme\n> in PSBT as well.\n>\n> > We can either use proprietary fields [4] or define key-value pairs and\n> add\n> > them to the BIP-174. Depends if anyone else is interested in using this\n> > protocol or not.\n>\n> I'd definitely be interested in seeing widespread support for this, and\n> standardizing it would help with that.\n>\n> With PSBT used with an air-gapped signer, there is increased danger in\n> implementing the protocol wrongly by relying on the contents of the PSBT\n> alone in the final verification step of a signature. The PSBT must be\n> verified carefully against state stored by the host for the PSBT.\n> Otherwise the signer can for example change or pre-fill the relevant\n> NONCE fields and leak the private keys anyway. Is there a current best\n> practice for how a PSBT can be identified by the host to store/retrieve\n> the state?\n>\n> Are there other examples in PSBT where the host can't trust the contents\n> of the PSBT the signer returns (except of course for the parts the user\n> can verify themselves, like recipients, amounts, etc.)? In any case,\n> guidelines or conventions on how to avoid the pitfalls would be good.\n>\n> Best, Marko\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200302/668d43e4/attachment.html>"
            },
            {
                "author": "Dustin Dettmer",
                "date": "2020-03-02T20:01:51",
                "message_text_only": "Stepan have you spent any time considering a scheme that could involve HD\nkeys, preregistering n (ie. 1000) preimages, or something similar to reduce\nthe number of rounds at time of signing?\n\nWould a zero knowledge solution allow for a reduction in rounds?\n\nOn Wed, Feb 26, 2020 at 7:13 PM Stepan Snigirev via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> This topic appeared in the list a few times so I would like to discuss it\n> in more detail and maybe push forward to standardization.\n>\n> We have to accept that any hardware wallet or an air-gapped computer we\n> use to sign transactions can be compromised. It may happen via a supply\n> chain attack or malicious firmware update.\n>\n> If the signer is isolated (faraday cage, airgap and so on), it still can\n> leak private keys to the outside world by choosing nonces for signatures in\n> a funny way such that the attacker can calculate our private keys. Back in\n> the days, I wrote a small post [1] and a proof-of-concept demo [2] of this\n> attack.\n>\n> Deterministic nonce generation can be verified only if we have private\n> keys somewhere else. It doubles the attack surface - now we need to\n> maintain two independent signers from different vendors that use the same\n> private key and the same deterministic algorithm for a nonce generation. In\n> addition to that, as Pieter mentioned in the Schnorr-BIP, deterministic\n> nonces are vulnerable to glitch attacks [3].\n>\n> A simple way to fix it is by forcing the signer to use additional entropy\n> from the host. This protocol takes away the privilege of picking nonce from\n> the signer and doesn't require any secret material outside the signer.\n>\n> I suggest the following implementation of the protocol for signing a\n> message `m`:\n>\n> 1. Host picks a random number `n` and sends its hash together with the\n> message `m` to the signer.\n> 2. Signer computes a nonce `k` it wants to use for signing. It can be\n> either a deterministic scheme or using RNG. Signer commits to the chosen\n> nonce by sending the corresponding point `R=kG` to the host.\n> 3. Host sends the preimage `n` to the signer\n> 4. Signer tweaks the nonce by this number `k'=k+n`, signs the message and\n> sends back the signature (R',s)\n> 5. Host verifies that the public point in the signature is tweaked by n:\n> `R'==R+nG`\n>\n> ASCII-art:\n>\n>    Host                                Untrusted signer\n> 1. Pick random n   --- sha256(n),m -->  calculate nonce k\n> 2.                 <------ R=kG ------  commit to k\n> 3. Send preimage   -------- n ------->  sign with nonce k'=k+n\n> 4. Verify R'==R+nG <------- sig ------\n>\n> I believe this protocol solves the problem. A drawback of this scheme is\n> that the number of communication rounds doubles, so it might be pretty\n> inconvenient for air-gapped remotely located signers.\n>\n> I also suggest the following extensions that might be helpful for certain\n> use-cases\n>\n> # Extensions\n>\n> ## Multiple hosts\n>\n> There are some use-cases where multiple hosts are involved in the setup\n> and all hosts don't trust each other and the signer. So all of them want to\n> give extra entropy to the signer and verify that it was included. At the\n> moment I have exactly this scenario - our main MCU doesn't trust the\n> proprietary closed-source secure element, and the computer doesn't trust\n> the whole hardware wallet. We need a way to convince both of them that\n> their entropy was used in the nonce.\n>\n> It can be solved by concatenating hashes and preimages:\n>\n> Host1 ------- h(n1) --> Host 2 -- h(n1) h(n2) --> Signer\n>       <--- R+n2 G -----        <------- R -------\n>       ------- n1 ----->        ------ n1 n2 ----> sign with k''=k+n1+n2\n> Ver: R''==R'+n1 G       Ver: R''==R+n2 G + n1 G\n>\n> In this case, the first host doesn't even notice that the second host was\n> also using this protocol and mixing in the entropy. And the signer only\n> needs to add one extra number to the nonce.\n>\n> ## Stateless random signer\n>\n> If the signer wants to generate a nonce non-deterministically but doesn't\n> have an ability to store a generated nonce it may send back to the host\n> some meta-information that would help it to re-generate the same nonce\n> later. It can be for example additional random data used in a deterministic\n> scheme, either encrypted and authenticated or just as a plain text (I am\n> more a fan of encrypted though).\n>\n> Generally, the host shouldn't care what this data is about - he just\n> stores the data between rounds and sends it back to the signer with the\n> next round.\n>\n> # Implementation for PSBT\n>\n> We can either use proprietary fields [4] or define key-value pairs and add\n> them to the BIP-174. Depends if anyone else is interested in using this\n> protocol or not.\n>\n> I would suggest the following key-value per-input pairs assuming multiple\n> hosts want to mix in external entropy:\n>\n> 1. Key: {PSBT_IN_EXT_NONCE_HASH}|{pubkey}, Value:\n> {sha256(n1)}|{sha256(n2)}|...\n> 2. Key: {PSBT_IN_NONCE_COMMITMENT}|{pubkey}, Value: {33-byte R point}\n> 3. Key: {PSBT_IN_NONCE_SIGNER_METADATA}|{pubkey}, Value: {anything}\n> 4. Key: {PSBT_IN_EXT_NONCE_PREIMAGE}|{pubkey}, Value: {n1}|{n2}|...\n>\n> Then the signature from the signer is placed into existing\n> PSBT_IN_PARTIAL_SIG. Combiner and Finaliser should verify that nonce in the\n> signature includes external entropy and may remove their own entropy from\n> the set. They should also verify that the values of the fields did not\n> change between rounds.\n>\n> So, list, what do you think? Am I missing something? Would it be\n> interesting to have this protocol standardized and deployed?\n>\n> # References\n>\n> [1]\n> https://medium.com/cryptoadvance/hardware-wallets-can-be-hacked-but-this-is-fine-a6156bbd199\n> [2]\n> https://github.com/stepansnigirev/chosen_nonce_demo/blob/master/HD_key.ipynb\n> [3]\n> https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#alternative-signing\n> [4]\n> https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki#proprietary-use-type\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200302/7860629d/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Nonce blinding protocol for hardware wallets and airgapped signers",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Dustin Dettmer"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 9160
        }
    },
    {
        "title": "[bitcoin-dev] Fwd: BIP 340 updates: even pubkeys, more secure nonce generation",
        "thread_messages": [
            {
                "author": "Marko",
                "date": "2020-03-03T11:29:22",
                "message_text_only": "That is an interesting point. Does the same concern apply to anti nonce\ncovert channel protocols? In those, the host would mix in a random nonce\nof its own. The process is still deterministic and can be checked during\nsigning, but unless the host persists the nonce contributions it\nprovides, one can't check how the nonce was computed for past\nsignatures. I am unsure how desirable this property would be in\npractice, though. I am guessing not that desirable, but it would be good\nto hear other opinions.\n\nSee\n\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017655.html\n\n\nand\n\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017663.html\n\nBest, Marko"
            }
        ],
        "thread_summary": {
            "title": "Fwd: BIP 340 updates: even pubkeys, more secure nonce generation",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Marko"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 695
        }
    },
    {
        "title": "[bitcoin-dev] Overview of anti-covert-channel signing techniques",
        "thread_messages": [
            {
                "author": "Pieter Wuille",
                "date": "2020-03-03T21:35:55",
                "message_text_only": "Hi all,\n\nGiven the recent activity and attention [1,2] around anti-covert channel\nsigning schemes, I decided to create this overview of the various techniques\nthat I know of, their trade-offs, and the various issues they protect against.\nMost of this is based on various schemes by a number of authors, and credit\ngoes to them. I'm putting this together into something hopefully more\ncomprehensive, but mistakes and omissions in this writeup are likely mine.\n\nI don't believe we have security proofs for any of the schemes, or for any of\nthe claims I make about the mitigation techniques below. I hope that having\nall properties written up in one place makes it easier to eventually get those.\n\n1) Security model\n-----------------\n\nWhen talking about signing with covert channels, we consider 3 parties:\n* HW, the hardware wallet (or other offline signing device) with secret data\n  (a private key, or a seed from which the private key is derived).\n* SW, the software wallet (or whatever communicates with HW and the network).\n* OO, the outside observer who is trying to learn information about HW's\n  secret data.\n\nWe consider two distinct attack models:\n* MSW, \"malicious software wallet\", but with honest HW. OO and SW are the\n  same party here, so this models the usual scenarios hardware wallets are\n  designed for, including side-channel attacks if those are considered to be\n  part of the threat model.\n* MHW, \"malicious hardware wallet\", but with honest SW and no malicious party\n  being able to communicate with HW directly. OO and HW may have shared secret\n  information that SW (or anyone else) is unaware of. SW's job is trying to\n  prevent HW from using this to leak any information about its secret.\n\nWhen both the HW and the SW are compromised, clearly no security is possible,\nas all entities are controlled by the same party in that case.\n\nIn case HW uses a deterministic algorithm, it is possible to protect against\nthe MHW case by spot checking HW's behavior, by using an externally known\nsecret/seed. However, we'd like to have better than just spot checking\nsecurity, and for protection against side-channel attacks we may want\nsomething that keeps working even when randomness is used by HW.\n\nTo keep the scope limited, we assume SW has no secret key of their own. This\nrules out solutions like using 2-of-2 MuSig between HW and SW, which work, but\ncome with their own complications (like needing secure storage for that\nsecret).\n\n2) Issues and solutions\n-----------------------\n\nIn this section I will go over the various issues that exist in the MHW and MSW\nmodels, the known mitigation techniques, and the resulting schemes.\n\nI'm assuming a Schnorr-like signature protocol, though everything should apply\nequally to ECDSA, and to a lesser extent probably also to multisignature\nschemes. These variable names are used:\n* H is a hash function.\n* G is the curve generator.\n* m is the message to be signed, known to and agreed upon by SW and HW.\n* d is HW's secret key, with corresponding public key Q=dG.\n* k is the secret nonce k, with corresponding public nonce R=kG.\n\nThe simplest protocol is naive Schnorr with deterministic nonce generation,\nwhere SW only verifies that a signature created by HW is valid:\n\n[Scheme 1: deterministic nonce, no tweak]\n* SW requests a signature by sending (Q,m) to HW.\n* HW computes k=H(d,m), R=kG, s=k+H(R,Q,m)d, and sends (R,s) to SW.\n* SW verifies sG=R+H(R,Q,m)Q, and publishes sig (R,s) in case of success.\n\n2.a) Predictable k value\n\nThere is a simple attack against Scheme 1 that will leak the entire private\nkey undetectably using a single signature, under MHW. Assume HW and OO both\nhave access to a shared secret a, unknown to anyone else. HW computes\nk=H(a,Q,m) instead, which SW cannot distinguish from the honest k=H(d,m) as it\nknows neither a or d. OO can compute k using the same formula, and thus\nrecover the private key as d=(s-k)/H(R,Q,m).\n\nThe general strategy to avoid this is by letting SW provide entropy that is\nincluded into the nonce computation. A very naive (and ineffective) way of\ndoing that would be:\n* SW generates random t, and requests a signature by sending (Q,m,t) to HW.\n* HW computes k0=H(d,m,t), R0=k0G, k=k0+t, R=kG, s=k+H(R,Q,m)d, and sends\n  (R0,R,s) to SW.\n* SW verifies sG=R+H(R,Q,m)Q, R=R0+tG, and publishes sig (R,s) if all is good.\n\nThis does not help as HW can still choose k directly, and retroactively\ncompute R0 as R-tG, satsifying SW's requirements. To address that, there are\ntwo options:\n* Turning R into a binding commitment to R0 and t (see Scheme 2).\n* Only revealing t after HW has revealed their R0 (see Scheme 3).\n\nThe first approach is based on making R a commitment to R0 and t using\nR=R0+H(R0,t)G. When applied to public keys this is known as pay-to-contract\n(and is the basis for Taproot); when applied to the R point in signatures it's\nknown as sign-to-contract [3]. These are generally useful approaches to make\npublic keys and signatures commit to/timestamp external data, but using this\nto protect against covert channels in signatures was first discussed by Greg\nMaxwell [4]:\n\n[Scheme 2: deterministic nonce, S2C tweak]\n* SW generates random t, and requests a signature by sending (Q,m,t) to HW.\n* HW computes k0=H(d,m,t), R0=k0G, k=k0+H(R0,t), R=kG,\n  s=k+H(R,Q,m)d, and sends (R0,R,s) to SW.\n* SW verifies sG=R+H(R,Q,m)Q, R=R0+H(R0,t)G, and publishes sig (R,s) if all\n  is good.\n\nThe second approach is adding a round, and only revealing the tweak t after HW\nhas revealed their R0:\n\n[Scheme 3: deterministic nonce, tweak revealed after nonce]\n* SW requests a signature by sending (Q,m) to HW.\n* HW computes k0=H(d,m), R0=k0G, and sends R0 to SW.\n* SW generates a random t, and sends it to HW.\n* HW computes k=k0+t, R=kG, s=k+H(R,Q,m)d, and sends (R,s) to SW.\n* SW verifies sG=R+H(R,Q,m)Q, R=R0+tG, and publishes (R,s) if all is good.\n\n2.b) Replay attacks\n\nScheme 3 introduces another problem however, this time under MSW. SW can ask\nHW to sign the same message twice, but then pick distinct values for t (t and\nt'). The resulting R points will be R=(k0+t)G and R'=(k0+t')G, and the s\nvalues will be s=k0+t+H(R,Q,m)d and s'=k0+t'+H(R',Q,m)d. This allows SW to\ncompute d=(s'-t'-s+t)/(H(R',Q,m)-H(R,Q,m)). A similar problem would also exist\nin Scheme 2 if t wasn't included in the formula for k0.\n\nThe problem is that SW is allowed to change their tweak while the nonce\nonly undergoes a linear function known to SW. There are again two ways to\naddress this problem:\n* Making k0 generation non-repeating by including a counter or randomness\n  in it (Scheme 4).\n* Making SW commit to their tweak before revealing it as well (Scheme 5).\n\n[Scheme 4: counter/random nonce, tweak revealed after nonce]\n* SW requests a signature by sending (Q,m) to HW.\n* HW uses a global counter c, or fresh randomness b, and computes k0=H(d,m,c)\n  or k0=H(d,m,b), R0=k0G, and sends R0 to SW.\n* SW generates a random t, and sends it to HW.\n* HW computes k=k0+t, R=kG, s=k+H(R,Q,m)d, and sends (R,s) to SW.\n* SW verifies sG=R+H(R,Q,m)Q, R=R0+tH, and publishes (R,s) if all is good.\n\nA variant of Scheme 4, but with multiplicative tweak rather than additive,\nand only revealing H(R0) rather than R0 immediately, was suggested by Sergio\nDemian Lerner in [5].\n\n[Scheme 5: deterministic nonce, precommited tweak revealed after nonce]\n* SW generates a random t, computes h=H(t), and requests a signature by\n  sending (Q,m,h) to HW.\n* HW computes k0=H(d,m,h), R0=k0G, and sends R0 to SW.\n* SW sends t to HW.\n* HW verifies h=H(t), and if so, computes k=k0+t, R=kG, s=k+H(R,Q,m)d, and\n  sends (R,s) to SW.\n* SW verifies sG=R+H(R,Q,m)Q, R=R0+tG, and publishes (R,s) if all is good.\n\nScheme 5 is the one suggested by Stepan Snigirev in [2,6]. A variant with\nS2C tweaking instead of additive tweaked was suggested by Andrew Poelstra\nin his talk [7], with transcript by Bryan Bishop in [8].\n\n2.c) k0 grinding\n\nSo far Schemes 2, 4, and 5 protect against predictable k values and replay\nattacks. Predictable k values are however not the only way MWH can leak\nsecrets.\n\nIf we imagine HW has significant computational power, in Scheme 2 it can try\nmany different k0 values (by deviating from k0=H(d,m,t)), and observe what the\nresulting (R,s) signature will be. For example, by iterating on average 256\ntimes, it can choose 8 bits in (R,s) that convey information about k, d, or\nwhatever seed or master key they are derived from. Using forward error\ncorrection (FEC) schemes, this channel of a few bits per signature may be\nenough to leak an entire seed over enough signatures. Using a shared secret a\nbetween HW and OO those bits can again be made undetectable to anyone else.\n\nSchemes 4 and 5 are not vulnerable to this problem, as they force HW to commit\nto its R0 before knowing the resulting R. One might think that Scheme 4 merely\nshifts this problem to MSW, where SW can grind t to make R biased in a similar\nway. We assumed that SW does not have access to any secrets however, so this\nis harmless.\n\n2.d) Statefulness\n\nWe're left with Schemes 4 and 5 that protect against all listed issues. Both\nneed two interaction rounds, with state that needs to be kept by HW between\nthe rounds (the k0 value). While not a problem in theory, this may be hard to\nimplement safely in simple APIs.\n\nOne possibility is sticking with our \"best one-round\" Scheme 2, and accepting\nthat that implies the k0 grinding vulnerability.\n\nThere is another possibility, namely splitting Scheme 5 into two independent\ninteractions with HW, where no memory between them is needed on the HW side:\n\n[Scheme 6: deterministic nonce, precommitted tweak revealed separately]\nFirst interaction:\n* SW generates a random t, computes h=H(t), and requests the R0 point that HW\n  would use by sending (Q,m,h) to HW.\n* HW computes k0=H(d,m,h), R0=k0G, and sends R0 to SW.\nSecond interaction:\n* SW requests a signature by sending (Q,m,t) to HW\n* HW computes k0=H(d,m,H(t)), k=k0+t, R0=R0k, R=kG, s=k+H(R,Q,m)d, and sends\n  (R0,R,s) to SW.\n* SW verifies that R0 matches the earlier R0 it received, and that\n  sG=R+H(R,Q,m)Q, R=R0+tG, and publishes (R,s) if all is good.\n\nA variant of Scheme 6, with S2C tweaking instead of additive tweaking, is what\nis being worked on by Jonas Nick [9] and Marko Bencun [10] for the\nlibsecp256k1 library.\n\nThe same technique cannot be applied to Scheme 4, as HW inherently needs state\nto keep the counter c, or to remember the randomness b between interactions\nthere.\n\n2.e) Failure bias\n\nThere is yet another, and even weaker, leak that is available in MHW: whenever\nHW learns what the eventual signature (R,s) will be, it could pretend to fail\nand go offline, or return some kind of error. In theory, this is enough to\nintroduce a similar bias, though it would come at possibly enormous failure\nrates. If HW is allowed to fail 255 times out of 256, it can introduce an\n8-bit bias, and employ similar techniques (FEC and shared HW/OO secret).\nThe obvious solution is showing a big warning to the user whenever any kind of\nfailure occurs (including device going offline, or returning invalid\nresponses) that the device is failing, and that if this happens frequently, it\nshould be treated as malicious.\n\nInterestingly, Scheme 6 can be adapted to reduce this (already very weak)\nchannel further. The observation is that HW cannot predict during the first\ninteraction what (R,s) is going to be, as t is not known. This means it can\nonly fail during the second interaction when the result is already committed\nto. Thus, if failure occurs during the second interaction, SW can simply\nretry it with the same t value. If that succeeds, either a glitch occurred and\nwas safely retried, or the device's attempt to bias was prevented. If the\nfailure persists, the user should still be warned - as restarting with a\ndifferent k would reintroduce the possibility for bias.\n\n2.f) Side-channel attacks\n\nAs a last consideration, let's see if these schemes have an impact on\npotential resilience against side-channel attacks. I say potential, because\nthese classes of attacks are in general hard to protect against and model,\nas they depend on implementation details and hardware protections. Still,\nthere are some general observations possible.\n\nA significant amount of time in HW is likely spent on the EC multiplications\nto obtain R0 and R from k0 and k. As s=k+H(R,Q,m)d, an variation of the replay\nattack is possible here. In schemes with deterministic nonces, SW can ask for\nthe same signature twice, but use a fault injection to hopefully (only) cause\nan error in R, R'. This would reveal (R,s) and (R',s') to SW, where s' is\nk+H(R',Q,m)d, which would let them compute d=(s'-s)/(H(R',Q,m)-H(R,q,m)).\nThere is an easy solution against this, namely verifying the final signature\n(R,s) in HW before sending it to SW, as almost certainly the result of such\na fault would not result in a valid signature. This comes at an extra\ncomputational cost, though.\n\nFor other side-channel attacks like different power analysis, research [11]\nshows that introducing fresh randomness in the right place may be helpful.\nThis approach is called \"synthetic nonces\" [12]. Unfortunately usage of these\nrules out the deterministic approach from Scheme 6. A variant of Scheme 5\nwith fresh randomness in the k0 computation can be used, though.\n\n3) Summary\n----------\n\nSix different issues of various levels of severity were discussed:\n  (a) Predictable k: (MHW) a single signature leaks the entire private key.\n  (b) Replay attacks: (MSW) a single signature leaks the entire private key.\n  (c) k0 grinding: (MHW) the HW can leak n bits with 2^n work.\n  (d) Statefulness: HW has to correctly maintain state, complicating things.\n  (e) Failure bias: (MHW) a selective failure rate of (2^n-1)/2^n can be used\n      to leak n bits of secret per signature.\n  (f) Side-channel attacks: (MSW) physical access to HW can help extracting\n      secrets.\n\nIt seems any reasonable solution should at least protect against (a), (b), and\n(c), but it seems no solution can be optimal for all of (d), (e), and (f) too.\n\nIf statelessness and protection against failure bias are prioritized, Scheme 6\nseems best. Its additive tweaking can be replaced with S2C (or multiplicative)\ntweaking too. S2C in particular may be desirable to unify with support for\nS2C-based timestamping.\n\nIf resistance against side-channels is prioritized, solutions with synthetic\nnonces seem best; either Scheme 4, or Scheme 5 with randomness added to the\nk0 computation. Again, any tweaking approach can be chosen.\n\nIf the 2-round approaches for Schemes 4, 5, and 6 are really unacceptable,\nScheme 2 (with S2C tweaking) could be used, but in that case protection\nagainst k0 grinding is reduced to spot checking. If randomness is additionally\nadded for side-channel resistance, the ability to spot check disappears\nentirely.\n\n4) References\n-------------\n\n  [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017649.html\n  [2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017655.html\n  [3] https://blog.eternitywall.com/2018/04/13/sign-to-contract/\n  [4] https://bitcointalk.org/index.php?topic=893898.msg9861102#msg9861102\n  [5] https://bitcointalk.org/index.php?topic=893898.msg9841502#msg9841502\n  [6] https://medium.com/cryptoadvance/hardware-wallets-can-be-hacked-but-this-is-fine-a6156bbd199\n  [7] https://youtu.be/j9Wvz7zI_Ac?t=640\n  [8] https://diyhpl.us/wiki/transcripts/sf-bitcoin-meetup/2019-02-04-threshold-signatures-and-accountability/\n  [9] https://github.com/bitcoin-core/secp256k1/pull/590\n  [10] https://github.com/bitcoin-core/secp256k1/pull/669\n  [11] https://eprint.iacr.org/2017/985\n  [12] https://moderncrypto.org/mail-archive/curves/2017/000925.html"
            },
            {
                "author": "Tim Ruffing",
                "date": "2020-03-21T13:34:14",
                "message_text_only": "Hi Pieter, \n\nThat's a really nice overview.\n\nLet's take a step back first. If we believe that malicious hardware\nwallets are big enough of a concern, then signing is only part of the\nproblem. The other issue is key generation. The PRG from which the seed\nis derived can be malicious, e.g., just H(k_OO,counter) for a key k_OO\nchosen by the hardware manufacturer. I haven't seen an argument why\nattacks during the signing model should more realistic than attacks\nduring key generation, so I'd be very hesitant to deploy anti-covert\nchannel singing protocols without deploying protocols for key\ngeneration that are secure in the same attacker model.\n\nWhile there's a bunch of protocols for signing, there's not much\nresearch for key generation. One simple idea is a simple commit-and-\nreveal protocol to generate a master (elliptic curve) public key pair\nwith entropy contributions from both HW and SW (similar to the\nprotocols here for generating R). Then use BIP32 public derivation for\nall other keys in order to make sure that SW can verify the derivation\nof the public kyes. The corresponding master secret key would replace\nthe seed, i.e., there's no \"symmetric\" seed. That idea comes with other\ndrawbacks however, most importantly this is not compatible with\nhardened derivation, which creates a new security risk. If we want\n(something like) hardened derivation, zero-knowledge proofs of correct\nderivation could maybe used but they again come with other issues\n(efficiency, complexity). \n\nBy the way, here's a paper that considers a similar setting where the\nhardware wallet is also malicious during key generation: \nhttps://fc19.ifca.ai/preproceedings/93-preproceedings.pdf\nThis model goes a step further and assumes threshold signatures but\ninterestingly here the human user (instead of the SW) is the trusted\nparty interacting with the HW. In this model the human user has a low-\nentropy password.\n\nNow back to the signing process: I think yet another security property\nto look at is security against a malicious SW with parallel signing\nsessions. I think it's reasonable to restrict a single HW device to a\nsingle session but what if the same seed is stored in two or more HW\nwallets? That's plausible at least. Taking this additional security\nproperty into account, it appears that Scheme 4 is vulnerable to\nWagner's attack because SW can influence R by choosing t after seeing\nR0. (This can be fixed, e.g., by using Scheme 5 instead.) \n\n\nOn Tue, 2020-03-03 at 21:35 +0000, Pieter Wuille via bitcoin-dev wrote:\n> 2.d) Statefulness\n> \n> We're left with Schemes 4 and 5 that protect against all listed\n> issues. Both\n> need two interaction rounds, with state that needs to be kept by HW\n> between\n> the rounds (the k0 value). While not a problem in theory, this may be\n> hard to\n> implement safely in simple APIs.\n\nA generic way to make one party (HW in this case) stateless is to let\nit encrypt and authenticate its state, e.g., using AEAD. In our\nparticular case I think that the state does not need to be\nconfidential, and a simple MAC suffices. For simplicity let's assume we\nhave another hash function H' (modeled as a random oracle) used as MAC.\nWe can (ab)use d as a MAC key.\n\nIf we don't want to spend an entire signature verification on the side\nof HW to protect against fault attacks, we can additionally let SW\ncompute and send the challenge hash e=H(R,Q,m) and let HW only verify\nthe computation of e. This helps against fault-attacks in the\ncomputation of R and e because now SW needs to commit to e, which is a\ncommitment to the exact computation fault that HW will suffer from. But\nI'm not sure yet if this is weaker or stronger or incomparable to\nverifying the signature. I guess it's weaker [1]. If we don't drop\nsignature verification, this technique does not hurt at least.  \n\n[Scheme 7: synthetic nonce, two interactions, stateless using MAC,\nverifying e]\n\nFirst interaction:\n * SW generates a random t, computes h=H(t), and requests the R0 point\n   that HW would use by sending (Q,m,h) to HW.\n * HW uses a global counter c (or fresh randomness c), and computes\n   k0=H(d,m,c,h), R0=k0G, mac=H'(d,m,c,h) and sends R0,c,mac to SW.\n\nSecond interaction:\n * SW computes R=R0+tG, e=H(R,Q,m) and requests a signature by sending\n   (Q,m,t,e,c,mac) to HW\n * HW verifies mac=H'(d,m,c,H(t)), recomputes k0=H(d,m,c,H(t)), k=k0+t,\n   computes R=kG, verifies e=H(R,Q,m), and if all is good computes\n   s=k+H(R,Q,m)d and sends s to SW.\n * SW verifies that sG=R+eQ and publishes (R,s) if all is good.\n\nOne last observation: Since the inputs to H and H' are the same, we\ncould even use H'(x)=H(H(x)). Not sure if that's useful.\n\nBest,\nTim\n\n[1] In the (admittedly weird) case that faults in two runs of the\nexecutions are independent and can be made highly likely (say\nprobability almost 1), verifying e could indeed be stronger than\nverifying the signature: When verifying the signature, the fault attack\nis successful if  the *same* fault happens during signing and\nverification (birthday collision!). When verifying e instead, the\nattack is successful if the attacker predicts the fault correctly. But\nI guess if faults can be made very likely, there's no hope anyway."
            },
            {
                "author": "Russell O'Connor",
                "date": "2020-03-21T16:59:47",
                "message_text_only": "On Sat, Mar 21, 2020 at 12:46 PM Tim Ruffing via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi Pieter,\n>\n> Let's take a step back first. If we believe that malicious hardware\n> wallets are big enough of a concern, then signing is only part of the\n> problem. The other issue is key generation. The PRG from which the seed\n> is derived can be malicious, e.g., just H(k_OO,counter) for a key k_OO\n> chosen by the hardware manufacturer. I haven't seen an argument why\n> attacks during the signing model should more realistic than attacks\n> during key generation, so I'd be very hesitant to deploy anti-covert\n> channel singing protocols without deploying protocols for key\n> generation that are secure in the same attacker model.\n>\n\nPublic keys are deterministic and can be spot checked.  In fact, AFAIU if\nhardened HD key derivations are not used, then spot checking is very easy.\n\nWhile spot checking isn't ideal, my original concern with the synthetic\nnone standard proposal was that it is inherently non-deterministic and\ncannot ever be spot checked.  This is why anti-covert signing protocols are\nso important if we are going to use synthetic nonces.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200321/33b4ef58/attachment.html>"
            },
            {
                "author": "Tim Ruffing",
                "date": "2020-03-22T09:43:12",
                "message_text_only": "On Sat, 2020-03-21 at 12:59 -0400, Russell O'Connor wrote:\n> Public keys are deterministic and can be spot checked.  In fact,\n> AFAIU if hardened HD key derivations are not used, then spot checking\n> is very easy.\n> \n> While spot checking isn't ideal, my original concern with the\n> synthetic none standard proposal was that it is inherently non-\n> deterministic and cannot ever be spot checked.  This is why anti-\n> covert signing protocols are so important if we are going to use\n> synthetic nonces.\n\nIf spot checking means checking a few instances, then I think this is a\npretty weak defense. What if the device starts to behave differently\nafter a year?\n\nOn Sat, 2020-03-21 at 21:29 +0100, Marko Bencun wrote:\n> Practically speaking, most hardware wallets allow you to import your\n> own BIP39 seed, so you can work around key generation attacks today,\n> with a one time inconvenience at the start. However, with the signing\n> nonce attacks, a user today has no protection.\n> \n\nHow do you know that the device really uses your seed? This can only be\ndone by comparing the public keys output by the HW with a second\ncomputation. Even if you use only non-hardened derivation, you need to\ncheck the master (root) public key and that means you need compute the\nmaster root public key once from the seed. You can't do this manually\non a sheet of paper after you rolled a few dice to generate your seed.\nSo you need to store the seed on a second device (if only for a short\ntime). And I think this defeats the purpose of a HW wallet.\n\nAnd even if assume that spot checking and importing the seed works, the\nproblem is not solved. We still need a clearly specified full protocol\nthat we can analyze. \n\nBest,\nTim"
            },
            {
                "author": "Russell O'Connor",
                "date": "2020-03-22T15:30:34",
                "message_text_only": "On Sun, Mar 22, 2020 at 5:43 AM Tim Ruffing <crypto at timruffing.de> wrote:\n\n> On Sat, 2020-03-21 at 12:59 -0400, Russell O'Connor wrote:\n> > Public keys are deterministic and can be spot checked.  In fact,\n> > AFAIU if hardened HD key derivations are not used, then spot checking\n> > is very easy.\n> >\n> > While spot checking isn't ideal, my original concern with the\n> > synthetic none standard proposal was that it is inherently non-\n> > deterministic and cannot ever be spot checked.  This is why anti-\n> > covert signing protocols are so important if we are going to use\n> > synthetic nonces.\n>\n> If spot checking means checking a few instances, then I think this is a\n> pretty weak defense. What if the device starts to behave differently\n> after a year?\n>\n\nI agree, which is why there perhaps is merit in using a non-hardered\nderivation path so that the software side of a hardware wallet can check\nthe pubkey. Though I understand there are some disadvantages to the\nnon-hardened paths.\n\nHowever, spot checking can even be done retroactively (and thoroughly).\nAgain, I agree that this is less than ideal, but does let you take some\naction once you notice a deviation.\n\nYour claim is that if we don't fix the pubkey issue there is no point in\nfixing the signature issue.  I disagree.  While I think both issues need to\nbe fully addressed, the issues around the original proposed\nnon-deterministic signature scheme are far more severe. The proposal would\nmove us from a deterministic scheme, where spot checks are possible, with\nall the caveats that entails, to a non-deterministic scheme where spot\nchecks are impossible.  My hope is that we can standardise a scheme that\nhas the advantages of non-determinism without the threat of covert channels.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200322/53768608/attachment-0001.html>"
            },
            {
                "author": "Tim Ruffing",
                "date": "2020-03-22T15:38:21",
                "message_text_only": "On Sun, 2020-03-22 at 11:30 -0400, Russell O'Connor wrote:\n> Your claim is that if we don't fix the pubkey issue there is no point\n> in fixing the signature issue.  I disagree.  While I think both\n> issues need to be fully addressed, the issues around the original\n> proposed non-deterministic signature scheme are far more severe. The\n> proposal would move us from a deterministic scheme, where spot checks\n> are possible, with all the caveats that entails, to a non-\n> deterministic scheme where spot checks are impossible.  My hope is\n> that we can standardise a scheme that has the advantages of non-\n> determinism without the threat of covert channels.\n\nI think we agree that both issues should be addressed, and this is all\nwhat matters in the end. Now that we have a proposal for Schnorr\nsignatures, it's indeed a good time to work on these issues.\n\nTim"
            },
            {
                "author": "Marko Bencun",
                "date": "2020-03-21T20:29:26",
                "message_text_only": "Practically speaking, most hardware wallets allow you to import your own\nBIP39 seed, so you can work around key generation attacks today, with a one\ntime inconvenience at the start. However, with the signing nonce attacks, a\nuser today has no protection.\n\nMitigating key generation attacks would be very desirable, but I see it as\nindependent of anti nonce covert channel protection.\n\nOn Sat, Mar 21, 2020 at 5:46 PM Tim Ruffing via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi Pieter,\n>\n> That's a really nice overview.\n>\n> Let's take a step back first. If we believe that malicious hardware\n> wallets are big enough of a concern, then signing is only part of the\n> problem. The other issue is key generation. The PRG from which the seed\n> is derived can be malicious, e.g., just H(k_OO,counter) for a key k_OO\n> chosen by the hardware manufacturer. I haven't seen an argument why\n> attacks during the signing model should more realistic than attacks\n> during key generation, so I'd be very hesitant to deploy anti-covert\n> channel singing protocols without deploying protocols for key\n> generation that are secure in the same attacker model.\n>\n> While there's a bunch of protocols for signing, there's not much\n> research for key generation. One simple idea is a simple commit-and-\n> reveal protocol to generate a master (elliptic curve) public key pair\n> with entropy contributions from both HW and SW (similar to the\n> protocols here for generating R). Then use BIP32 public derivation for\n> all other keys in order to make sure that SW can verify the derivation\n> of the public kyes. The corresponding master secret key would replace\n> the seed, i.e., there's no \"symmetric\" seed. That idea comes with other\n> drawbacks however, most importantly this is not compatible with\n> hardened derivation, which creates a new security risk. If we want\n> (something like) hardened derivation, zero-knowledge proofs of correct\n> derivation could maybe used but they again come with other issues\n> (efficiency, complexity).\n>\n> By the way, here's a paper that considers a similar setting where the\n> hardware wallet is also malicious during key generation:\n> https://fc19.ifca.ai/preproceedings/93-preproceedings.pdf\n> This model goes a step further and assumes threshold signatures but\n> interestingly here the human user (instead of the SW) is the trusted\n> party interacting with the HW. In this model the human user has a low-\n> entropy password.\n>\n> Now back to the signing process: I think yet another security property\n> to look at is security against a malicious SW with parallel signing\n> sessions. I think it's reasonable to restrict a single HW device to a\n> single session but what if the same seed is stored in two or more HW\n> wallets? That's plausible at least. Taking this additional security\n> property into account, it appears that Scheme 4 is vulnerable to\n> Wagner's attack because SW can influence R by choosing t after seeing\n> R0. (This can be fixed, e.g., by using Scheme 5 instead.)\n>\n>\n> On Tue, 2020-03-03 at 21:35 +0000, Pieter Wuille via bitcoin-dev wrote:\n> > 2.d) Statefulness\n> >\n> > We're left with Schemes 4 and 5 that protect against all listed\n> > issues. Both\n> > need two interaction rounds, with state that needs to be kept by HW\n> > between\n> > the rounds (the k0 value). While not a problem in theory, this may be\n> > hard to\n> > implement safely in simple APIs.\n>\n> A generic way to make one party (HW in this case) stateless is to let\n> it encrypt and authenticate its state, e.g., using AEAD. In our\n> particular case I think that the state does not need to be\n> confidential, and a simple MAC suffices. For simplicity let's assume we\n> have another hash function H' (modeled as a random oracle) used as MAC.\n> We can (ab)use d as a MAC key.\n>\n> If we don't want to spend an entire signature verification on the side\n> of HW to protect against fault attacks, we can additionally let SW\n> compute and send the challenge hash e=H(R,Q,m) and let HW only verify\n> the computation of e. This helps against fault-attacks in the\n> computation of R and e because now SW needs to commit to e, which is a\n> commitment to the exact computation fault that HW will suffer from. But\n> I'm not sure yet if this is weaker or stronger or incomparable to\n> verifying the signature. I guess it's weaker [1]. If we don't drop\n> signature verification, this technique does not hurt at least.\n>\n> [Scheme 7: synthetic nonce, two interactions, stateless using MAC,\n> verifying e]\n>\n> First interaction:\n>  * SW generates a random t, computes h=H(t), and requests the R0 point\n>    that HW would use by sending (Q,m,h) to HW.\n>  * HW uses a global counter c (or fresh randomness c), and computes\n>    k0=H(d,m,c,h), R0=k0G, mac=H'(d,m,c,h) and sends R0,c,mac to SW.\n>\n> Second interaction:\n>  * SW computes R=R0+tG, e=H(R,Q,m) and requests a signature by sending\n>    (Q,m,t,e,c,mac) to HW\n>  * HW verifies mac=H'(d,m,c,H(t)), recomputes k0=H(d,m,c,H(t)), k=k0+t,\n>    computes R=kG, verifies e=H(R,Q,m), and if all is good computes\n>    s=k+H(R,Q,m)d and sends s to SW.\n>  * SW verifies that sG=R+eQ and publishes (R,s) if all is good.\n>\n> One last observation: Since the inputs to H and H' are the same, we\n> could even use H'(x)=H(H(x)). Not sure if that's useful.\n>\n> Best,\n> Tim\n>\n> [1] In the (admittedly weird) case that faults in two runs of the\n> executions are independent and can be made highly likely (say\n> probability almost 1), verifying e could indeed be stronger than\n> verifying the signature: When verifying the signature, the fault attack\n> is successful if  the *same* fault happens during signing and\n> verification (birthday collision!). When verifying e instead, the\n> attack is successful if the attacker predicts the fault correctly. But\n> I guess if faults can be made very likely, there's no hope anyway.\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200321/da2e74e6/attachment.html>"
            },
            {
                "author": "Dustin Dettmer",
                "date": "2020-03-23T14:38:45",
                "message_text_only": "Excellent write up, thanks for putting it together.\n\nOn Tue, Mar 3, 2020 at 1:47 PM Pieter Wuille wrote:\n\n> When both the HW and the SW are compromised, clearly no security is\n> possible,\n> as all entities are controlled by the same party in that case.\n>\nWhile all SW being compromised can\u2019t be stopped, splitting the SW over two\nstages can dramatically increase your security if both HW & SW are\ncompromised. You can do that by:\n\n1) When you setup your storage solution (whatever it may be), export the\nxpub(s) and verify the receiving addresses match xpubs with external\nsoftware before receiving.\n2) Generate and export withdrawal transactions offline\n3) Verify transactions against the same xpub(s) using external software\n4) Upload transactions\n\nThis mitigates, I believe, all leak vectors besides k/R hacking and\nprechosen entropy.\n\nI made an external tool to just that here:\nhttps://github.com/koinkeep/gatekeeper\n\nWould love to add k commitments when (if?) we settle on best practices for\nit.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200323/114914d9/attachment.html>"
            },
            {
                "author": "Tim Ruffing",
                "date": "2020-03-24T07:49:38",
                "message_text_only": "Hi Dustin,\n\nThat sounds interesting but I can't follow your email to be honest.\n\nOn Mon, 2020-03-23 at 07:38 -0700, Dustin Dettmer via bitcoin-dev\nwrote:\n> This mitigates, I believe, all leak vectors besides k/R hacking and\n> prechosen entropy.\n\nHm, so what vectors is this supposed to mitigate? Leaking through the\ngenerated public keys? Anything else?\n\nHere are a few questions:\n - What are you trying to achieve? You seem to describe how you get\nfrom the setup to the goal in four steps but I don't understand what\nthe setup is or what the goal is. (What's a storage solution?)\n - \"all SW being compromised\" do you mean \"SW and HW compromised\"? Note\nthat SW and HW are parties in Pieter's writeup, not just abbreviations\nfor software and hardware. \n - Where are the two stages? You mention four steps.\n - Where do you run the external software? On a second SW? Is this the\nsecond stage?\n - Do you use unhardened derivation?\n - What's a k commitment?\n\n\nBest,\nTim"
            },
            {
                "author": "Dustin Dettmer",
                "date": "2020-03-24T14:51:32",
                "message_text_only": "Hi Tim,\n\nHm, so what vectors is this supposed to mitigate? Leaking through the\n> generated public keys? Anything else?\n\n\nThe main thing it\u2019s protecting against is the stealing of your funds by\nmalicious hardware & software. There are some side benefits as well though.\n\n - What are you trying to achieve? You seem to describe how you get\n> from the setup to the goal in four steps but I don't understand what\n> the setup is or what the goal is. (What's a storage solution?)\n\n\n\u201cStorage solution\u201d is however you\u2019re storing bitcoins today. Could be 12\nwords on some paper plus a computer running electrum. Could be a Ledger +\ncomputer. Point is this technique works regardless of how you\u2019re storing\nyour bitcoin.\n\n - \"all SW being compromised\" do you mean \"SW and HW compromised\"? Note\n> that SW and HW are parties in Pieter's writeup, not just abbreviations\n> for software and hardware.\n\n\nYeah \u2014 if you split the SW party into two, \u201cgenerator\u201d and \u201cvalidator\u201d some\ninteresting and useful security properties emerge.\n\n - Where are the two stages? You mention four steps.\n\n\n\u201cGenerator\u201d and \u201cvalidator\u201d. The generator creates and passes on receiving\naddresses and withdrawal transactions (while remaining offline). The\nvalidator double checks everything the generator did..\n\nIt works best if the validator is written entirely independently of the\ngenerator.\n\n - Where do you run the external software? On a second SW? Is this the\n> second stage?\n\n\nYes\n\n - Do you use unhardened derivation?\n\n\nIt\u2019s an open ended solution \u2014 it would work with a (presumably\nnon-trivial/random) unhardened derivation just fine.\n\n - What's a k commitment?\n\n\nIt is one of the proposed solutions presented (collected?) by Peter in this\nthread. As I understand it k is used to generate R in the signature. By\ncommitting to some k value the hardware wallet can\u2019t \u201csneak out\u201d your\nprivate key(s) in the R value.\n\nBest,\nDustin\n\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200324/db2f881c/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Overview of anti-covert-channel signing techniques",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Dustin Dettmer",
                "Tim Ruffing",
                "Russell O'Connor",
                "Pieter Wuille",
                "Marko Bencun"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 37244
        }
    },
    {
        "title": "[bitcoin-dev] RFC: Kicking BIP-322 (message signing) into motion",
        "thread_messages": [
            {
                "author": "Karl-Johan Alm",
                "date": "2020-03-04T06:23:53",
                "message_text_only": "Hello,\n\nI noticed recently that a PR to Bitcoin Core that pretty much touched\neverything my BIP-322 pull request touches (around the same\ncomplexity) was merged without a thought given to BIP-322\ncompatibility, despite the BIP-322 PR being open for 2x the time. I\ncan only conclude from this that people dislike BIP-322 in its current\nform, which the 9 month old pull request stagnating can probably\nattest to.\n\nThere are several things that I can do to make this a bit more\nappealing to people, which would hopefully kick the progress on this\nforward. I have already put in a non-trivial amount of energy and\neffort into maintaining the pull request as is, so I'd prefer if\npeople were harsh and unfiltered in their criticism rather than polite\nand buffered, so I can beat this thing into shape (or abandon it, in\nthe worst case).\n\n=============\n1. People use signmessage as a way to prove funds. This is misleading\nand should be discouraged; throw the sign message stuff out and\nreplace it entirely with a prove funds system.\n\nI know in particular luke-jr is of this opinion, and Greg Maxwell in\nhttps://github.com/bitcoin/bitcoin/pull/16440#issuecomment-568194168\nleans towards this opinion as well, it seems.\n\n=============\n2. Use a transaction rather than a new format; make the first input's\ntxid the message hash to ensure the tx cannot be broadcasted. This has\nthe benefit of being able to provide to an existing hardware wallet\nwithout making any modifications to its firmware.\n\nI think Mark Friedenbach and Johnson Lau are of this opinion, except\nJohnson Lau also suggests that the signature hash is modified, see\nhttps://github.com/bitcoin/bips/pull/725#issuecomment-420040430 --\nwhich defeats the benefit above since now hw wallets can no longer\nsign.\n\nPrusnak (I think he works at Trezor; apologies if I am mistaken) is\nagainst this idea, and proposes (3) below:\nhttps://github.com/bitcoin/bips/pull/725#issuecomment-420210488\n\n=============\n3. Use Trezor style\n\nSee https://github.com/trezor/trezor-mcu/issues/169\n\nThis has the benefit of already being adopted (which clearly BIP-322\nis failing hard at right now), but has the drawback that we can no\nlonger do *generic* signing; we are stuck with the exact same\nlimitations as in the legacy system, which we kinda wanted to fix in\nthe updated version.\n\n=============\n4. Introduce OP_MESSAGEONLY\n\nQuoting Johnson Lau at\nhttps://github.com/bitcoin/bips/pull/725#issuecomment-420421058 :\n\"\"\"\nOP_MESSAGEONLY means the script following the code would never be\nvalid. For example, a scriptPubKey:\n\nOP_IF OP_MESSAGEONLY <key_m> OP_ELSE <key_s> OP_ENDIF OP_CHECKSIG\n\nFor messaging purpose, OP_MESSAGEONLY is considered as OP_NOP and is\nignored. A message could be signed with either key_m or key_s.\n\nFor spending, only key_s is valid.\n\nI don't think it is a big problem to consume a op_code. If this is a\nreal concern, I could modify it as follow: in message system,\nOP_RETURN will pop the top stack. If top stack is msg in hex, it is\nignored. Otherwise, the script fails.\n\"\"\"\n\n=============\n5. Some other solution"
            },
            {
                "author": "Karl-Johan Alm",
                "date": "2020-03-04T07:03:34",
                "message_text_only": "I forgot one:\n\n=============\n5. The current BIP itself is poorly written and/or unnecessarily\ncomplex: e.g. remove the multi-proof support, and/or remove the\nextensibility stuff for a future proof-of-funds extension, and/or\nfocus solely on the generic sign message stuff.\n\n=============\n6. Some other solution\n\nOn Wed, Mar 4, 2020 at 3:23 PM Karl-Johan Alm\n<karljohan-alm at garage.co.jp> wrote:\n>\n> Hello,\n>\n> I noticed recently that a PR to Bitcoin Core that pretty much touched\n> everything my BIP-322 pull request touches (around the same\n> complexity) was merged without a thought given to BIP-322\n> compatibility, despite the BIP-322 PR being open for 2x the time. I\n> can only conclude from this that people dislike BIP-322 in its current\n> form, which the 9 month old pull request stagnating can probably\n> attest to.\n>\n> There are several things that I can do to make this a bit more\n> appealing to people, which would hopefully kick the progress on this\n> forward. I have already put in a non-trivial amount of energy and\n> effort into maintaining the pull request as is, so I'd prefer if\n> people were harsh and unfiltered in their criticism rather than polite\n> and buffered, so I can beat this thing into shape (or abandon it, in\n> the worst case).\n>\n> =============\n> 1. People use signmessage as a way to prove funds. This is misleading\n> and should be discouraged; throw the sign message stuff out and\n> replace it entirely with a prove funds system.\n>\n> I know in particular luke-jr is of this opinion, and Greg Maxwell in\n> https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-568194168\n> leans towards this opinion as well, it seems.\n>\n> =============\n> 2. Use a transaction rather than a new format; make the first input's\n> txid the message hash to ensure the tx cannot be broadcasted. This has\n> the benefit of being able to provide to an existing hardware wallet\n> without making any modifications to its firmware.\n>\n> I think Mark Friedenbach and Johnson Lau are of this opinion, except\n> Johnson Lau also suggests that the signature hash is modified, see\n> https://github.com/bitcoin/bips/pull/725#issuecomment-420040430 --\n> which defeats the benefit above since now hw wallets can no longer\n> sign.\n>\n> Prusnak (I think he works at Trezor; apologies if I am mistaken) is\n> against this idea, and proposes (3) below:\n> https://github.com/bitcoin/bips/pull/725#issuecomment-420210488\n>\n> =============\n> 3. Use Trezor style\n>\n> See https://github.com/trezor/trezor-mcu/issues/169\n>\n> This has the benefit of already being adopted (which clearly BIP-322\n> is failing hard at right now), but has the drawback that we can no\n> longer do *generic* signing; we are stuck with the exact same\n> limitations as in the legacy system, which we kinda wanted to fix in\n> the updated version.\n>\n> =============\n> 4. Introduce OP_MESSAGEONLY\n>\n> Quoting Johnson Lau at\n> https://github.com/bitcoin/bips/pull/725#issuecomment-420421058 :\n> \"\"\"\n> OP_MESSAGEONLY means the script following the code would never be\n> valid. For example, a scriptPubKey:\n>\n> OP_IF OP_MESSAGEONLY <key_m> OP_ELSE <key_s> OP_ENDIF OP_CHECKSIG\n>\n> For messaging purpose, OP_MESSAGEONLY is considered as OP_NOP and is\n> ignored. A message could be signed with either key_m or key_s.\n>\n> For spending, only key_s is valid.\n>\n> I don't think it is a big problem to consume a op_code. If this is a\n> real concern, I could modify it as follow: in message system,\n> OP_RETURN will pop the top stack. If top stack is msg in hex, it is\n> ignored. Otherwise, the script fails.\n> \"\"\"\n>\n> =============\n> 5. Some other solution"
            },
            {
                "author": "Luke Dashjr",
                "date": "2020-03-04T14:35:16",
                "message_text_only": "In addition to starting with proof-of-funds instead of proof-of-receiver, it \nwould be nice to integrate with Taproot somehow or another. Perhaps \nOP_MESSAGEONLY is the most straightforward way to do this? It might be a good \nidea to have a message type after the opcode too.\n\nOn Wednesday 04 March 2020 06:23:53 Karl-Johan Alm via bitcoin-dev wrote:\n> Hello,\n>\n> I noticed recently that a PR to Bitcoin Core that pretty much touched\n> everything my BIP-322 pull request touches (around the same\n> complexity) was merged without a thought given to BIP-322\n> compatibility, despite the BIP-322 PR being open for 2x the time. I\n> can only conclude from this that people dislike BIP-322 in its current\n> form, which the 9 month old pull request stagnating can probably\n> attest to.\n>\n> There are several things that I can do to make this a bit more\n> appealing to people, which would hopefully kick the progress on this\n> forward. I have already put in a non-trivial amount of energy and\n> effort into maintaining the pull request as is, so I'd prefer if\n> people were harsh and unfiltered in their criticism rather than polite\n> and buffered, so I can beat this thing into shape (or abandon it, in\n> the worst case).\n>\n> =============\n> 1. People use signmessage as a way to prove funds. This is misleading\n> and should be discouraged; throw the sign message stuff out and\n> replace it entirely with a prove funds system.\n>\n> I know in particular luke-jr is of this opinion, and Greg Maxwell in\n> https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-568194168\n> leans towards this opinion as well, it seems.\n>\n> =============\n> 2. Use a transaction rather than a new format; make the first input's\n> txid the message hash to ensure the tx cannot be broadcasted. This has\n> the benefit of being able to provide to an existing hardware wallet\n> without making any modifications to its firmware.\n>\n> I think Mark Friedenbach and Johnson Lau are of this opinion, except\n> Johnson Lau also suggests that the signature hash is modified, see\n> https://github.com/bitcoin/bips/pull/725#issuecomment-420040430 --\n> which defeats the benefit above since now hw wallets can no longer\n> sign.\n>\n> Prusnak (I think he works at Trezor; apologies if I am mistaken) is\n> against this idea, and proposes (3) below:\n> https://github.com/bitcoin/bips/pull/725#issuecomment-420210488\n>\n> =============\n> 3. Use Trezor style\n>\n> See https://github.com/trezor/trezor-mcu/issues/169\n>\n> This has the benefit of already being adopted (which clearly BIP-322\n> is failing hard at right now), but has the drawback that we can no\n> longer do *generic* signing; we are stuck with the exact same\n> limitations as in the legacy system, which we kinda wanted to fix in\n> the updated version.\n>\n> =============\n> 4. Introduce OP_MESSAGEONLY\n>\n> Quoting Johnson Lau at\n> https://github.com/bitcoin/bips/pull/725#issuecomment-420421058 :\n> \"\"\"\n> OP_MESSAGEONLY means the script following the code would never be\n> valid. For example, a scriptPubKey:\n>\n> OP_IF OP_MESSAGEONLY <key_m> OP_ELSE <key_s> OP_ENDIF OP_CHECKSIG\n>\n> For messaging purpose, OP_MESSAGEONLY is considered as OP_NOP and is\n> ignored. A message could be signed with either key_m or key_s.\n>\n> For spending, only key_s is valid.\n>\n> I don't think it is a big problem to consume a op_code. If this is a\n> real concern, I could modify it as follow: in message system,\n> OP_RETURN will pop the top stack. If top stack is msg in hex, it is\n> ignored. Otherwise, the script fails.\n> \"\"\"\n>\n> =============\n> 5. Some other solution\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Greg Sanders",
                "date": "2020-03-04T14:43:13",
                "message_text_only": "OP_MESSAGEONLY would make \"dumb\" signers like HWW more difficult to\nsupport. They'd have to do script interpretation to make sure they're not\nsigning something real with funds.\n\nJust FYI.\n\nOn Wed, Mar 4, 2020 at 9:35 AM Luke Dashjr via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> In addition to starting with proof-of-funds instead of proof-of-receiver,\n> it\n> would be nice to integrate with Taproot somehow or another. Perhaps\n> OP_MESSAGEONLY is the most straightforward way to do this? It might be a\n> good\n> idea to have a message type after the opcode too.\n>\n> On Wednesday 04 March 2020 06:23:53 Karl-Johan Alm via bitcoin-dev wrote:\n> > Hello,\n> >\n> > I noticed recently that a PR to Bitcoin Core that pretty much touched\n> > everything my BIP-322 pull request touches (around the same\n> > complexity) was merged without a thought given to BIP-322\n> > compatibility, despite the BIP-322 PR being open for 2x the time. I\n> > can only conclude from this that people dislike BIP-322 in its current\n> > form, which the 9 month old pull request stagnating can probably\n> > attest to.\n> >\n> > There are several things that I can do to make this a bit more\n> > appealing to people, which would hopefully kick the progress on this\n> > forward. I have already put in a non-trivial amount of energy and\n> > effort into maintaining the pull request as is, so I'd prefer if\n> > people were harsh and unfiltered in their criticism rather than polite\n> > and buffered, so I can beat this thing into shape (or abandon it, in\n> > the worst case).\n> >\n> > =============\n> > 1. People use signmessage as a way to prove funds. This is misleading\n> > and should be discouraged; throw the sign message stuff out and\n> > replace it entirely with a prove funds system.\n> >\n> > I know in particular luke-jr is of this opinion, and Greg Maxwell in\n> > https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-568194168\n> > leans towards this opinion as well, it seems.\n> >\n> > =============\n> > 2. Use a transaction rather than a new format; make the first input's\n> > txid the message hash to ensure the tx cannot be broadcasted. This has\n> > the benefit of being able to provide to an existing hardware wallet\n> > without making any modifications to its firmware.\n> >\n> > I think Mark Friedenbach and Johnson Lau are of this opinion, except\n> > Johnson Lau also suggests that the signature hash is modified, see\n> > https://github.com/bitcoin/bips/pull/725#issuecomment-420040430 --\n> > which defeats the benefit above since now hw wallets can no longer\n> > sign.\n> >\n> > Prusnak (I think he works at Trezor; apologies if I am mistaken) is\n> > against this idea, and proposes (3) below:\n> > https://github.com/bitcoin/bips/pull/725#issuecomment-420210488\n> >\n> > =============\n> > 3. Use Trezor style\n> >\n> > See https://github.com/trezor/trezor-mcu/issues/169\n> >\n> > This has the benefit of already being adopted (which clearly BIP-322\n> > is failing hard at right now), but has the drawback that we can no\n> > longer do *generic* signing; we are stuck with the exact same\n> > limitations as in the legacy system, which we kinda wanted to fix in\n> > the updated version.\n> >\n> > =============\n> > 4. Introduce OP_MESSAGEONLY\n> >\n> > Quoting Johnson Lau at\n> > https://github.com/bitcoin/bips/pull/725#issuecomment-420421058 :\n> > \"\"\"\n> > OP_MESSAGEONLY means the script following the code would never be\n> > valid. For example, a scriptPubKey:\n> >\n> > OP_IF OP_MESSAGEONLY <key_m> OP_ELSE <key_s> OP_ENDIF OP_CHECKSIG\n> >\n> > For messaging purpose, OP_MESSAGEONLY is considered as OP_NOP and is\n> > ignored. A message could be signed with either key_m or key_s.\n> >\n> > For spending, only key_s is valid.\n> >\n> > I don't think it is a big problem to consume a op_code. If this is a\n> > real concern, I could modify it as follow: in message system,\n> > OP_RETURN will pop the top stack. If top stack is msg in hex, it is\n> > ignored. Otherwise, the script fails.\n> > \"\"\"\n> >\n> > =============\n> > 5. Some other solution\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200304/4a364551/attachment.html>"
            },
            {
                "author": "Karl-Johan Alm",
                "date": "2020-03-25T06:31:56",
                "message_text_only": "Hello,\n\nI propose simplifying BIP-322 down to the single-proof case, and\nremoving some abstractions (e.g. the \"actions\"/\"purposes\" stuff):\nhttps://github.com/bitcoin/bips/pull/903\n\nFeedback welcome.\n\nNew version below:\n```\n<pre>\nBIP: 322\nLayer: Applications\nTitle: Generic Signed Message Format\nAuthor: Karl-Johan Alm <karljohan-alm at garage.co.jp>\nComments-Summary: No comments yet.\nComments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0322\nStatus: Draft\nType: Standards Track\nCreated: 2018-09-10\nLicense: CC0-1.0\n</pre>\n\n== Abstract ==\n\nA standard for interoperable generic signed messages based on the\nBitcoin Script format.\n\n== Background ==\n\n* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n* <code>P</code> wants to prove that they own the private key\n<code>k</code> associated with a given address <code>A</code> (which\nin turn is derived from the pubkey <code>kG</code>).\n* Let <code>V</code> generate a message <code>M</code> and hand this\nto <code>P</code>.\n* <code>P</code> generates a signature <code>S</code> by signing the\nmessage <code>M</code> using <code>k</code>. Given <code>S</code>,\n<code>V</code> can prove that <code>P</code> has the private key\nassociated with <code>A</code>.\n\nThe astute reader will notice that the above is missing a critical\npart, namely the pubkey <code>kG</code>, without which the verifier\ncannot actually verify the message. The current message signing\nstandard solves this via a cryptographic trick, wherein the signature\n<code>S</code> above is a special \"recoverable signature\" type. Given\nthe message <code>M</code> and the signature <code>S</code>, it is\nthen possible to recover the pubkey <code>kG</code>. The system thus\nderives the address for the pubkey <code>kG</code>, and if it does not\nmatch <code>A</code>, the proof is deemed invalid.\n\nWhile this is a neat trick, it unnecessarily restricts and complicates\nthe message signing mechanism; for instance, it is currently not\npossible to sign a message for a P2SH address, because there is no\npubkey to recover from the resulting signature.\n\n== Motivation ==\n\nThe current message signing standard only works for P2PKH (1...)\naddresses. By extending it to use a Bitcoin Script based approach, it\ncould be made more generic without causing a too big burden on\nimplementers, who most likely have access to Bitcoin Script\ninterpreters already.\n\n== Specification ==\n\nA new structure <code>SignatureProof</code> is added, which is a\nsimple serializable scriptSig & witness container.\n\n=== SignatureProof container ===\n\n{|class=\"wikitable\" style=\"text-align: center;\"\n|-\n!Type\n!Length\n!Name\n!Comment\n|-\n|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n|-\n|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n|-\n|VarInt||1-8||witlen||Number of entries in witness stack\n|-\n|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors,\neach one prepended with a varint of its size\n|}\n\nIn some cases, the scriptsig or wit may be empty. If both are empty,\nthe proof is incomplete.\n\n=== Result Codes ===\n\nA verification call will return a result code according to the table below.\n\n{|class=\"wikitable\" style=\"text-align: center;\"\n|-\n!Code\n!Description\n|-\n|INCOMPLETE||Empty proof.\n|-\n|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n|-\n|VALID||The proof was valid.\n|-\n|INVALID||The proof was invalid\n|-\n|ERROR||An error was encountered\n|}\n\n== Signing and Verifying ==\n\nIf the challenge consists of an address is in the P2PKH (legacy)\nformat, sign using the legacy format (further information below).\nOtherwise continue as stated below.\n\nFor both cases, generate a sighash based on the given scriptPubKey and\nmessage as follows:\n\n# Define the message pre-image as the sequence \"Bitcoin Signed\nMessage:\\n\" concatenated with the message, encoded in UTF-8 using\nNormalization Form Compatibility Decomposition (NFKD)\n# Let sighash = sha256(sha256(scriptPubKey || pre-image))\n\nA private key may be used directly to sign a message. In this case,\nits P2WPKH bech32 address shall be derived, and used as the input.\n\n=== Signing ===\n\nThe signature is generated as follows:\n\n# Derive the private key privkey for the scriptPubKey; FAIL if not VALID\n# Generate and return a signature sig with privkey=privkey, sighash=sighash\n\n=== Verifying ===\n\nVerify a proof, given a standard flags value, a script sig, an\noptional witness, and a derived sighash as described above.\n\nWhile omitted below, ERROR is returned if an unforeseen error occurs\nat any point in the process. A concrete example of this is if a legacy\nproof is given as input to a non-legacy address; the deserialization\nof the proof will fail in this case, and this should result in an\nERROR result.\n\n# Verify Script with flags=consensus flags (currently P2SH, DERSIG,\nNULLDUMMY, CLTV, CSV, WITNESS), scriptSig=script sig,\nscriptPubKey=scriptPubKey, witness=witness, and sighash=sighash\n# Return INVALID if verification fails\n# Verify Script with flags=standard flags (above plus STRICTENC,\nMINIMALDATA, etc.), scriptSig=script sig, scriptPubKey=scriptPubKey,\nwitness=witness, and sighash=sighash\n# Return VALID if verification succeeds, otherwise return INCONCLUSIVE\n\n== Legacy format ==\n\nThe legacy format is restricted to the legacy P2PKH address format.\n\nAny other input (i.e. non-P2PKH address format) must be signed using\nthe new format described above.\n\n=== Signing ===\n\nGiven the P2PKH address <code>a</code> and the message <code>m</code>,\nand the pubkey-hash function <code>pkh(P) =\nripemd160(sha256(P))</code>:\n\n# let <code>p</code> be the pubkey-hash <code>pkh(P)</code> for the\npubkey <code>P</code>, contained in <code>a</code>\n# let <code>x</code> be the private key associated with <code>P</code>\nso that <code>pkh(xG) = p</code>\n# let <code>digest</code> be <code>SHA56d(\"Bitcoin Signed Message:\\n\"||m)</code>\n# create a compact signature <code>sig</code> (aka \"recoverable ECDSA\nsignature\") using <code>x</code> on <code>digest</code>\n\nThe resulting proof is <code>sig</code>, serialized using the base64 encoding.\n\n=== Verifying ===\n\nGiven the P2PKH address <code>a</code>, the message <code>m</code>,\nthe compact signature <code>sig</code>, and the pubkey-hash function\n<code>pkh(P) = ripemd160(sha256(P))</code>:\n\n# let <code>p</code> be the pubkey-hash <code>pkh(P)</code> for the\npubkey <code>P</code>, contained in <code>a</code>\n# let <code>digest</code> be <code>SHA56d(\"Bitcoin Signed Message:\\n\"||m)</code>\n# attempt pubkey recovery for <code>digest</code> using the signature\n<code>sig</code> and store the resulting pubkey into <code>Q</code>\n## fail verification if pubkey recovery above fails\n# let <code>q</code> be the pubkey-hash <code>pkh(Q)</code> for the\npubkey <code>Q</code>\n# if <code>p == q</code>, the proof is valid, otherwise it is invalid\n\n== Compatibility ==\n\nThis specification is backwards compatible with the legacy\nsignmessage/verifymessage specification through the special case as\ndescribed above.\n\n== Reference implementation ==\n\n# Pull request to Bitcoin Core: https://github.com/bitcoin/bitcoin/pull/16440\n\n== Acknowledgements ==\n\nThanks to David Harding, Jim Posen, Kalle Rosenbaum, Pieter Wuille,\nand many others for their feedback on the specification.\n\n== References ==\n\n# Original mailing list thread:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015818.html\n\n== Copyright ==\n\nThis document is licensed under the Creative Commons CC0 1.0 Universal license.\n\n== Consensus and standard flags ==\n\nEach flag is associated with some type of enforced rule (most often a\nsoft fork). There are two sets of flags: consensus flags (which result\nin a block being rejected, if violated), and policy flags (which\nresult in a transaction being accepted only if it is contained within\nan actual block, and rejected otherwise, if violated). The policy\nflags are a super-set of the consensus flags.\n\nBIP322 specifies that a proof that validates for both rulesets is\nvalid, a proof that validates for consensus rules, but not for policy\nrules, is \"inconclusive\", and a proof that does not validate for\nconsensus rules is \"invalid\" (regardless of policy rule validation).\n\nThe ruleset sometimes changes. This BIP does not intend to be\ncomplete, nor does it indicate enforcement of rules, it simply lists\nthe rules as they stand at the point of writing.\n\n=== Consensus rules ===\n\n* P2SH: evaluate P2SH\n([https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki\nBIP16]) subscripts\n* DERSIG: enforce strict DER\n([https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki\nBIP66]) compliance\n* NULLDUMMY: enforce NULLDUMMY\n([https://github.com/bitcoin/bips/blob/master/bip-0147.mediawiki\nBIP147])\n* CHECKLOCKTIMEVERIFY: enable CHECKLOCKTIMEVERIFY\n([https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki\nBIP65])\n* CHECKSEQUENCEVERIFY: enable CHECKSEQUENCEVERIFY\n([https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki\nBIP112])\n* WITNESS: enable WITNESS\n([https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki\nBIP141])\n\n=== Policy rules ===\n\nAll of the above, plus (subject to change):\n\n* STRICTENC: non-strict DER signature or undefined hashtype\n* MINIMALDATA: require minimal encodings for all push operations\n* DISCOURAGE_UPGRADABLE_NOPS: discourage use of NOPs reserved for upgrades\n* CLEANSTACK: require that only a single stack element remains after evaluation\n* MINIMALIF: Segwit script only: require the argument of OP_IF/NOTIF\nto be exactly 0x01 or empty vector\n* NULLFAIL: signature(s) must be empty vector if a CHECK(MULTI)SIG\noperation failed\n* LOW_S: signature with S > order/2 in a checksig operation\n* DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM: v1-16 witness programs are\nnon-standard (i.e. forbidden)\n* WITNESS_PUBKEYTYPE: public keys in segregated witness scripts must\nbe compressed\n* CONST_SCRIPTCODE: OP_CODESEPARATOR and FindAndDelete fail any\nnon-segwit scripts\n\n== Test vectors ==\n\n(TODO: update test vectors, which are based on previous iteration\nwhere signature proofs contained additional data)\n\n== Native segwit test vector ==\n\n<pre>\naddress = bcrt1qe7nte4zk4ayly5tc53dtdjupgkz0lr8azx3rzz\nscriptpubkey = 0014cfa6bcd456af49f25178a45ab6cb814584ff8cfd\nmessage = hello\npreimage = 0014cfa6bcd456af49f25178a45ab6cb814584ff8cfd426974636f696e205369\n676e6564204d6573736167653a0a68656c6c6f\n(scriptpubkey || \"Bitcoin Signed Message:\\nhello\")\nsighash = 790eef86c204f0bff969ff822121317aa34eff0215dbd30ccf031e7b2f3f0cc1\n(sha256d(preimage), displayed in big-endian)\n</pre>\n\nThe proof becomes:\n\n<pre>\nHEX: 01000000010002473044022075b4fb40421d55c55462879cb352a85eeb3af2138d3f0290\n2c9143f12870f5f70220119c2995c1661138142f3899c1fd6d1af7e790e0e081be72db9c\ne7bf5b5b932901210290beccd02b73eca57467b2b6f1e47161a9b76a5e67586e7c1dee9e\na6e2dcd869\n\nBase64: AQAAAAEAAkcwRAIgdbT7QEIdVcVUYoecs1KoXus68hONPwKQLJFD8Shw9fcCIBGcKZXBZhE4\nFC84mcH9bRr355Dg4IG+ctuc579bW5MpASECkL7M0Ctz7KV0Z7K28eRxYam3al5nWG58He6e\npuLc2Gk=\n</pre>\n\nSplit into components:\n\n{|class=\"wikitable\" style=\"text-align: center;\"\n|-\n!Type\n!Length\n!Name\n!Value\n!Comment\n|-\n|Uint32||4||flags||<code>01000000</code>||proof format version\n|-\n|Uint8||1||entries||<code>01</code>||1 entry\n|-\n|VarInt||1-8||scriptsiglen||<code>00</code>||0 byte scriptsig\n|-\n|VarInt||1-8||wit entries||<code>02</code>||2 witness stack entries\n|-\n|VarInt||1-8||entry1len||<code>47</code>||71 byte entry\n|-\n|Uint8[71]||71||entry1||<code>3044022075b4fb40421d55c55462879cb352a85eeb3af213\n8d3f02902c9143f12870f5f70220119c2995c1661138142f\n3899c1fd6d1af7e790e0e081be72db9ce7bf5b5b932901</code>||Witness stack item 1\n|-\n|VarInt||1-8||entry2len||<code>21</code>||33 byte entry\n|-\n|Uint8[33]||33||entry2||<code>0290beccd02b73eca57467b2b6f1e47161a9b76a5e67586e\n7c1dee9ea6e2dcd869</code>||Witness stack item 2\n|}\n\nThe above test vector is for a bech32 P2WPKH (native segwit) address.\n(Once BIP solidifies, will add test vector for other types.)\n```\n\nOn Wed, Mar 4, 2020 at 11:43 PM Greg Sanders <gsanders87 at gmail.com> wrote:\n>\n> OP_MESSAGEONLY would make \"dumb\" signers like HWW more difficult to support. They'd have to do script interpretation to make sure they're not signing something real with funds.\n>\n> Just FYI.\n>\n> On Wed, Mar 4, 2020 at 9:35 AM Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> In addition to starting with proof-of-funds instead of proof-of-receiver, it\n>> would be nice to integrate with Taproot somehow or another. Perhaps\n>> OP_MESSAGEONLY is the most straightforward way to do this? It might be a good\n>> idea to have a message type after the opcode too.\n>>\n>> On Wednesday 04 March 2020 06:23:53 Karl-Johan Alm via bitcoin-dev wrote:\n>> > Hello,\n>> >\n>> > I noticed recently that a PR to Bitcoin Core that pretty much touched\n>> > everything my BIP-322 pull request touches (around the same\n>> > complexity) was merged without a thought given to BIP-322\n>> > compatibility, despite the BIP-322 PR being open for 2x the time. I\n>> > can only conclude from this that people dislike BIP-322 in its current\n>> > form, which the 9 month old pull request stagnating can probably\n>> > attest to.\n>> >\n>> > There are several things that I can do to make this a bit more\n>> > appealing to people, which would hopefully kick the progress on this\n>> > forward. I have already put in a non-trivial amount of energy and\n>> > effort into maintaining the pull request as is, so I'd prefer if\n>> > people were harsh and unfiltered in their criticism rather than polite\n>> > and buffered, so I can beat this thing into shape (or abandon it, in\n>> > the worst case).\n>> >\n>> > =============\n>> > 1. People use signmessage as a way to prove funds. This is misleading\n>> > and should be discouraged; throw the sign message stuff out and\n>> > replace it entirely with a prove funds system.\n>> >\n>> > I know in particular luke-jr is of this opinion, and Greg Maxwell in\n>> > https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-568194168\n>> > leans towards this opinion as well, it seems.\n>> >\n>> > =============\n>> > 2. Use a transaction rather than a new format; make the first input's\n>> > txid the message hash to ensure the tx cannot be broadcasted. This has\n>> > the benefit of being able to provide to an existing hardware wallet\n>> > without making any modifications to its firmware.\n>> >\n>> > I think Mark Friedenbach and Johnson Lau are of this opinion, except\n>> > Johnson Lau also suggests that the signature hash is modified, see\n>> > https://github.com/bitcoin/bips/pull/725#issuecomment-420040430 --\n>> > which defeats the benefit above since now hw wallets can no longer\n>> > sign.\n>> >\n>> > Prusnak (I think he works at Trezor; apologies if I am mistaken) is\n>> > against this idea, and proposes (3) below:\n>> > https://github.com/bitcoin/bips/pull/725#issuecomment-420210488\n>> >\n>> > =============\n>> > 3. Use Trezor style\n>> >\n>> > See https://github.com/trezor/trezor-mcu/issues/169\n>> >\n>> > This has the benefit of already being adopted (which clearly BIP-322\n>> > is failing hard at right now), but has the drawback that we can no\n>> > longer do *generic* signing; we are stuck with the exact same\n>> > limitations as in the legacy system, which we kinda wanted to fix in\n>> > the updated version.\n>> >\n>> > =============\n>> > 4. Introduce OP_MESSAGEONLY\n>> >\n>> > Quoting Johnson Lau at\n>> > https://github.com/bitcoin/bips/pull/725#issuecomment-420421058 :\n>> > \"\"\"\n>> > OP_MESSAGEONLY means the script following the code would never be\n>> > valid. For example, a scriptPubKey:\n>> >\n>> > OP_IF OP_MESSAGEONLY <key_m> OP_ELSE <key_s> OP_ENDIF OP_CHECKSIG\n>> >\n>> > For messaging purpose, OP_MESSAGEONLY is considered as OP_NOP and is\n>> > ignored. A message could be signed with either key_m or key_s.\n>> >\n>> > For spending, only key_s is valid.\n>> >\n>> > I don't think it is a big problem to consume a op_code. If this is a\n>> > real concern, I could modify it as follow: in message system,\n>> > OP_RETURN will pop the top stack. If top stack is msg in hex, it is\n>> > ignored. Otherwise, the script fails.\n>> > \"\"\"\n>> >\n>> > =============\n>> > 5. Some other solution\n>> > _______________________________________________\n>> > bitcoin-dev mailing list\n>> > bitcoin-dev at lists.linuxfoundation.org\n>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "RFC: Kicking BIP-322 (message signing) into motion",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Luke Dashjr",
                "Karl-Johan Alm",
                "Greg Sanders"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 31493
        }
    },
    {
        "title": "[bitcoin-dev] Hash function requirements for Taproot",
        "thread_messages": [
            {
                "author": "Lloyd Fournier",
                "date": "2020-03-04T07:10:04",
                "message_text_only": "Hi List,\n\nI recently presented a poster at the Financial Cryptography conference\n'2020 which you can find here:\nhttps://github.com/LLFourn/taproot-ggm/blob/master/main.pdf.  It attempts\nto show the security requirements for the tweak hash function in Taproot.\nIn this post I'll give a long description of it but first let me tl;dr:\n\nTaproot requires no new assumptions of SHA256 over what are already made by\nSchnorr signatures themselves with one exception: when using a\nnon-interactive key generation protocol to produce a Taproot internal key\n(e.g MuSig). To prove security in this scenario we need a make an\nadditional assumption about SHA256: as well as being collision resistant\n(i.e. find two hashes h_1 - h_2 = 0), it must satisfy a more general kind\nof collision resistance where it is hard to find h_1 - h_2 = d for *any d*\nwhen the adversary is challenged to find h_1 and h_2 with random prefixes.\nThis is obviously a plausible assumption. Put informally, it says that zero\nis not a special case where finding collisions is difficult but rather\nsolving the 2-sum problem is hard for all values of d (when challenged with\nrandom prefixes).\n\nNow the long version.\n\nMy motivation for creating this poster came from questions I had after\ndiscussions in Taproot Study Group #18 (this study group initiative was a\ngreat idea btw). The main question I had was \"Why is Taproot binding?\" i.e.\nwhy is it true that I can only commit to one Merkle root. Isn't it possible\nthat a malicious party could produce a second covert Taproot spend that\nnone of the other parties to the output agreed to? I submitted a poster\nproposal to FC to force myself to get to the bottom of it.\n\nThe premise of the poster is to use the Generic Group Model to try and\nfigure out how the hash function would have to fail for Taproot to be\ninsecure. Most of the poster is taken up cartoon reductions I made to\nremind myself as to why what I was saying might be true. They are\nincomplete and difficult to parse on their own so hopefully this post is a\nuseful companion to them.\n\n=== The Security of Taproot ===\n\nThere are three scenarios/games we must consider when asking whether\nTaproot is secure in the context of Bitcoin:\n\n1. Taproot Forge: Forging taproot spends must be hard. The adversary must\nnot be able to take a public key off the blockchain and produce a forged\nTaproot spend from it.\n2. Covert Taproot: When an adversary is executing a multi-party key\ngeneration protocol (e.g. MuSig) it should be hard for them to produce a\ncovert malicious Taproot spend from the joint key  i.e. when honest parties\nthink there is no Taproot on a key there shouldn't be any Taproot on the\nkey. Note this is not guaranteed to be hard by 1 being hard.\n3. Second Covert Taproot: Like 2, except that if honest parties agree to a\nTaproot spend then the adversary shouldn't be able to generate a second\nTaproot spend they are unaware of.\n\nProperties (1) and (2) can be argued succinctly if we just prove that\nTaproot is a secure commitment scheme. It should be clear that if a Taproot\nexternal key T = X + H(X||m)*G is a secure commitment scheme (Hiding and\nBinding) to any arbitrary message m, then it is a secure commitment scheme\nto a Merkle root. If so, then properties (1) and (3) hold. (1) holds\nbecause if you can create an opening to a commitment not generated by you,\nyou either broke hiding (if your opening is the same as the honest one) or\nbroke binding (if it's different). (3) holds because you must have broken\nbinding as there are now two openings to the same commitment.\n\nProperty (2) is more difficult to argue as it depends on the multi-party\nkey generation protocol. Case in point: Taproot is completely broken when\ncombined with a proof of knowledge key generation protocol where along with\ntheir public keys each party provides a proof of knowledge of the secret\nkey. Where X_1 is the key of the honest party, the malicious party can\nchoose their key X_2 to be G*H(X_1 || m) where m is a malicious Merkle\nroot. Clearly the malicious party has a covert Taproot for X = X_1 + X_2\nand can produce a proof of knowledge for X_2.\n\nGiven this definition of security, we now move onto how we should model the\nproblem to prove they hold.\n\n=== Generic Group Model vs Random Oracle Model ===\n\nFor practical cryptographic schemes you often have to idealise one of its\ncomponents to prove it secure. The most popular candidate for idealisation\nis the hash function in the Random Oracle Model (ROM), which idealises a\nhash function as a \"random oracle\", a black box which spits out random\nvalues for each input. For example, the original \"forking lemma\" proof by\nPointcheval and Stern [1] shows the Schnorr signature scheme is unforgeable\nin this model if the discrete logarithm problem is hard. In other words,\nidealising the hash function allows us to isolate what security assumptions\nwe are making about the group (e.g. the discrete logarithm problem being\nhard in it).\n\nBut what if we want to know what assumptions we are making about the hash\nfunction? Does the challenge hash in Schnorr signatures have to be\ncollision resistant or pre-image resistant or something else? To answer\nthis question Neven et al.[2] analysed Schnorr signatures by idealising the\ngroup in the \"Generic Group Model\" (GGM). By idealising the group, they\nwere able to isolate the security requirements of the hash function away\nfrom any assumptions being made about the group. In the GGM, the group\nbecomes a black box which, when given two group elements, spits out their\nsubtraction (for technical reasons it's subtraction rather than addition).\nThe adversary can only produce new group elements by querying the oracle.\nUsing the GGM they prove that the hash function needs to be Random-Prefix\nPreimage (RPP) resistant (and Random-Prefix Second-Preimage resistant)\nwhich are strictly weaker assumptions than collision resistance.\n\n=== Taproot in the Random Oracle Model ===\n\nProving that Taproot is a binding commitment scheme in the ROM is\nstraightforward (hiding is too but I'm going to skip that). To produce two\nopenings for the same external key, the adversary must have two random\noracle queries H(X || m) that result in the same external key T = X +\nH(X||m)*G. Since H(X||m)*G is an (almost) uniformly distributed group\nelement in the ROM, T is also uniformly distributed, thus breaking the\nbinding of Taproot is equivalent to solving a birthday problem of size\n2^256 (the same as finding hash collisions in the ROM). Note that this\nstatement is true regardless of the discrete logarithm problem being hard\nor not. This proves properties (1) and (3).\n\nFor property (2) let's consider MuSig as the key generation protocol. If we\nmodel the MuSig key tweak hash function as a random oracle as well then for\nevery key X_2,  the adversary has to query the MuSig hash oracle to\ndetermine the joint key X = X_1*H(X_1||L) + X_2*H(X_2| L). As before, it is\nclear to see that this makes X a uniform group element for every X_2 in the\nROM. Liekwise for every covert Taproot internal key C and message pair the\nexternal key T = C + H(C||m) *G will be uniform as before in the ROM. Thus,\nbreaking property (2) is the same as finding T = X, where you the adversary\ncan only sample T and X from uniform distributions and so we have another\nbirthday problem. This completes the proof of all three properties.\n\nPoelstra presented a proof in the ROM for the security of Taproot [3]. It\nframes Taproot as a way of combining two signature schemes into one public\nkey (in our case Schnorr and Tapscript). He uses a similar line of\nreasoning to what I have just presented in his proof (Lemma 1, step 3) but\nthis approach brings in many other considerations that I think can be\navoided by modelling it as a commitment scheme. Note that this proof only\nshows that Taproot forgeries are hard i.e. property (1).\n\n=== Taproot in the Generic Group Model ===\n\nThe ROM proof is an important first step -- if it couldn't be proved secure\nin ROM then it would probably be completely broken. But Taproot, unlike\nSchnorr, only relies on the security of its hash function when viewed as a\ncommitment scheme so it would be prudent to figure out what those\nproperties are. By using the ROM we artificially hide what those properties\nfrom our analysis. As in the case of Schnorr, we can idealise the group in\nthe GGM to help isolate the hash function's properties.\n\nTo prove Taproot was a binding commitment scheme in the GGM I had to\nintroduce a new property I called \"Chosen Offset Prefix-Collision\" (COPC)\nresistance. The precise security game is sketched in the poster, but I like\nto describe it as a more general kind of collision resistance. Instead of\nit being hard to find two preimages a and b where H(a) - H(b) = 0, it must\nbe hard to find H(P_1 || a) - H(P_2 || b) = d for any d (not just d  = 0)\nwith random prefixes P_1 and P_2 given by the challenger (d chosen by the\nadversary). COPC is necessary and sufficient to prove Taproot is a secure\ncommitment scheme in the GGM (the proof for this isn't in the poster but is\nvery similar to Second Covert Taproot proof).\n\nThis was not the ideal outcome, so I decided to analyse properties Taproot\n(1) and (3) independently rather than just imply them from the commitment\nscheme result. What ended up in the poster is three independent proofs for\neach Taproot security property with MuSig assumed to be key generation\nscheme for properties (2) and (3). Here's a summary of what I concluded for\neach property.\n\n1. Taproot Forge: In the GGM, an adversary who forges Taproot openings can\nbe used as a black box to mount a \"Random Prefix-Preimage\" (RPP) attack\nagainst the hash function. This is a very good result as RPP is already\nrequired by Schnorr. Essentially, this means anyone who can forge Taproot\nspends can also forge Schnorr signatures.\n\n2. Covert Taproot (MuSig): For this problem I had to split the adversary\ninto two types: those who query their MuSig public key X_2 from the group\noracle before their malicious internal key C and those that query C first\nor set X_2 = C. For the first case I was able to show another reduction\nfrom RRP (which shown in the poster).  The other case I was able to break\npreimage resistance as long as I modelled the MuSig hash function as a\nrandom oracle (not shown in the poster and this is only from memory). In\nboth cases the reduction does not work for n-party MuSig (only for 2\nparties). Obviously, this is not totally satisfying. The problem with\nn-party MuSig is it becomes exponentially more unlikely (in n) for the\nreduction to guess which keys the adversary will use for their MuSig keys.\n\n3. Second Covert Taproot (MuSig): Once again, this is where honest parties\nagree on a joint key and Taproot spend from it, but the adversary is\nsomehow able to create a second covert spend during the key generation\nphase. This is where I found that COPC does actually need to be hard to\nensure this property. This is true regardless of the number of parties.\nThus this is the only scenario where you need the additional security\nassumption to prove security.\n\n== Concluding Remarks ==\n\nThe main important take away of this is that there is actually a small\nsecurity cost to using a group element as both a commitment scheme and as a\npublic key. It would be very surprising if we got this for free. By using\nthe random oracle model we merely hide this in the idealisation of the hash\nfunction. The generic group model exposes it. The question is: is the cost\nworth it and who bears it? Here's what I consider to be the most important\npoints:\n\n1. You only take on this COPC assumption if you use Tapscript. If you're\njust putting your funds into a Taproot output without an internal key,\neither as a group or an individual there is no extra security assumption.\n(with the caveat that my technique only really works for  2-party MuSig).\n2. The COPC assumption seems to be very plausible.\n3. Even if COPC is broken and an adversary can output two openings to the\nsame external key, both those openings must be valid taproot spends for\nanyone to lose coins (i.e. Merkle roots with valid paths to leaves with\nvalid tapscript).\n4. Even if COPC was that badly broken on SHA256, old taproot outputs would\nnot be affected, the adversary has to break it during key generation before\nfunds are put into the output.\n5. You can completely circumvent this result by using coin-tossing rather\nthan MuSig for the key generation protocol. In most cases this doesn't even\nadd any extra rounds of communication since you are doing 3-round coin\ntossing to choose the R values for the signatures that spend from the joint\noutput anyway. You can just toss your public keys in parallel.\n\nIn my opinion, the cost of Taproot is mostly borne by theoreticians. They\ncan no longer treat a a public key ideally but have to consider the\nimplications of it also being a commitment. For the user and Bitcoin as a\nwhole it seems to offer an overwhelming benefit. In exchange for the\ncomplexity it adds to making security claims in the GGM (if using\nTaprscript and MuSig), it offers exciting new opportunities for\nnon-interactivity and fungibility over what just what Schnorr would provide.\n\nI don't consider my work to be a final proof of anything. I would welcome\nanyone who wants to take over this research direction and do a proper job\nof it! I didn't have any personal motivation for doing this work other than\ncuriosity and that curiosity has been satisfied. Questions and thoughts\nwelcome :)\n\n[1] https://www.di.ens.fr/david.pointcheval/Documents/Papers/2000_joc.pdf\n[2] http://www.neven.org/papers/schnorr.pdf\n[3] https://github.com/apoelstra/taproot/blob/master/main.pdf\n\nCheers,\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200304/1254933a/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-03-04T23:29:09",
                "message_text_only": "Good morning LL,\n\nThank you very much for this work, it seems quite interesting.\n\n> 5. You can completely circumvent this result by using coin-tossing rather than MuSig for the key generation protocol. In most cases this doesn't even add any extra rounds of communication since you are doing 3-round coin tossing to choose the R values for the signatures that spend from the joint output anyway. You can just toss your public keys in parallel.\n\nI am uncertain what you mean here by \"coin-tossing\".\n>From the comparison to MuSig, I imagine it is an interactive key generation protocol like this:\n\n* Everybody generates fresh keypairs.\n* Everybody sends the hash of their pubkey to everyone else.\n* After receiving a hash of pubkey from everyone else, everybody sends their pubkey to everyone else.\n* They add all their pubkeys to generate the aggregate key (and if using Taproot, use it as the internal key).\n\nIs that correct?\n\nIn any case, the comparison to MuSig signing appears to imply interactive key generation.\nThe advantage of MuSig is that it requires no interactivity for key generation of n-of-n (I am told it requires interactivity to generate k-of-n).\n\nHowever, it can generally be pointed out that, before you put anything into an n-of-n, you would damn well sure want to have *some* assurance that you can get it out later.\nSo in general you would need coordination and interaction anyway to arrange getting into an n-of-n in the first place.\n\nOn the other hand, it would be best to have at least some minimum of privacy by always interacting over Tor and having a Tor .onion address, which has absolutely horrid latency because human beings cry when peeling onions.\nSo in general reducing the latency by reducing communication rounds is better in general.\nCounter to this, assuming you use an n-of-n in an offchain protocol of some sort, the number of communication rounds to generate the aggregate key may be dwarfed by the total number of communication rounds to create signatures to update the offchain protocol.\nCounter counter to this is that one plan for reducing communications rounds for creating signatures during offchain operation is to (haha) use a Taproot with an n-of-n internal key and a tapscript that has n `OP_CHECKSIG` operations, so that for normal operation you just toss individual signatures at each other but at termination of the offchain protocol you can do the heavy MuSig-style signing with the n-of-n aggregate key.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2020-03-05T09:56:54",
                "message_text_only": "> I am uncertain what you mean here by \"coin-tossing\".\n> From the comparison to MuSig, I imagine it is an interactive key\ngeneration protocol like this:\n\n> * Everybody generates fresh keypairs.\n> * Everybody sends the hash of their pubkey to everyone else.\n> * After receiving a hash of pubkey from everyone else, everybody sends\ntheir pubkey to everyone else.\n> * They add all their pubkeys to generate the aggregate key (and if using\nTaproot, use it as the internal key).\n\n> Is that correct?\n\nYes exactly. The reason it's called coin tossing is that the resulting key\nis guaranteed to be uniformly random (in the random oracle model at least),\nso it's like tossing a fair 2^256 sided coin. This is not true in MuSig for\nexample, where the aggregate key is not guaranteed to be from a uniform\ndistribution against a malicious party (but still secure as an aggregate\nkey).\n\n> However, it can generally be pointed out that, before you put anything\ninto an n-of-n, you would damn well sure want to have *some* assurance that\nyou can get it out later. So in general you would need coordination and\ninteraction anyway to arrange getting into an n-of-n in the first place.\n\nRight. Taking your example of a lightning channel, when you set it up I\ndon't *think* there is a way to use the non-interactivity of MuSig to\nremove any rounds of communication to get to the starting state where there\nis a channel funding on-chain and both parties have a tx that spends from\nit which returns their funds. Doing coin tossing for the aggregate key as\nwell as the aggregate nonce shouldn't lead to any extra rounds of\ncommunication. The downside of coin tossing is that it requires honest\nparties to sample their keys non-deterministically (or at least have a\ncounter to avoid using the same key twice).\n\n> On the other hand, it would be best to have at least some minimum of\nprivacy by always interacting over Tor and having a Tor .onion address,\nwhich has absolutely horrid latency because human beings cry when peeling\nonions.\n> So in general reducing the latency by reducing communication rounds is\nbetter in general.\n> Counter to this, assuming you use an n-of-n in an offchain protocol of\nsome sort, the number of communication rounds to generate the aggregate key\nmay be dwarfed by the total number of communication rounds to create\nsignatures to update the offchain protocol.\n> Counter counter to this is that one plan for reducing communications\nrounds for creating signatures during offchain operation is to (haha) use a\nTaproot with an n-of-n internal key and a tapscript that has n\n`OP_CHECKSIG` operations, so that for normal operation you just toss\nindividual signatures at each other but at termination of the offchain\nprotocol you can do the heavy MuSig-style signing with the n-of-n aggregate\nkey.\n\nCounter\u00b3 to this is that, in the case of lightning, the aggregate key for a\nPTLC does not need to be chosen at payment time.  They channel members\ncould simply use the \"master\" aggregate key they generated by coin tossing\nat the channel's inception and pseudorandomly randomise it every time they\nneed a new joint key (so the keys do not look related to everyone else on\nthe chain but you would effectively just be reusing the same public key).\n\nHaving said that if there is some advantage to using MuSig in some\nparticular case I wouldn't hesitate to use it in combination with Taproot.\nI don't think the new assumption that I think you have to make wrt to the\nhash function really weighs up against most design considerations. In\ngeneral, it is probably worth considering whether your protocol actually\nbenefits from the non-interactivity MuSig gives in the key generation\nstage. If it doesn't due to the fact that it doesn't make signing anymore\nnon-interactive, then coin tossing might be the answer.\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200305/fdfb6b5c/attachment.html>"
            },
            {
                "author": "Tim Ruffing",
                "date": "2020-03-12T17:04:47",
                "message_text_only": "Hi Lloyd,\n\nThis is great research, thanks for this effort!\n\nHere are some comments:\n\nOn Wed, 2020-03-04 at 18:10 +1100, Lloyd Fournier via bitcoin-dev\nwrote:\n> \n> Property (2) is more difficult to argue as it depends on the multi-\n> party key generation protocol. Case in point: Taproot is completely\n> broken when combined with a proof of knowledge key generation\n> protocol where along with their public keys each party provides a\n> proof of knowledge of the secret key. Where X_1 is the key of the\n> honest party, the malicious party can choose their key X_2 to be\n> G*H(X_1 || m) where m is a malicious Merkle root. Clearly the\n> malicious party has a covert Taproot for X = X_1 + X_2 and can\n> produce a proof of knowledge for X_2.\n\nI mean, the good thing is that there's a general method to defend\nagainst this, namely always adding a Merkle root on top. Maybe it's\nuseful to make the warning here a litte bit more drastic:\nhttps://github.com/sipa/bips/blob/bip-taproot/bip-0341.mediawiki#cite_ref-22-0\nMaybe we could actually mention this in BIP340, too, when we talk about\nkey generation,\n\n> \n> Poelstra presented a proof in the ROM for the security of Taproot\n> [3]. It frames Taproot as a way of combining two signature schemes\n> into one public key (in our case Schnorr and Tapscript). He uses a\n> similar line of reasoning to what I have just presented in his proof\n> (Lemma 1, step 3) but this approach brings in many other\n> considerations that I think can be avoided by modelling it as a\n> commitment scheme. Note that this proof only shows that Taproot\n> forgeries are hard i.e. property (1).\n\nI agree that modeling it as a commitment scheme is more natural. But I\nthink an optimal model would capture both worlds, and would give the\nattacker signing oracles for the inner and the outer key, and an\ncommitment opening oracle That is, it would capture that \n * the ability to obtain signatures for the inner key does not help you\n   to forge for the outer key\n * the ability to obtain signatures for the outer key does not help you\n   to open the commitment, and --- if already opened --- do not help\n   you to forge for the inner key\n * the ability to obtain an opening does not help you to forge for\n   either key... \n * etc\n\nI believe that all these properties hold, and I believe this even\nwithout a formal proof. \n\nStill, it would be great to have one. The problem here is really that\nthings get complex so quickly. For example, how do you model key\ngeneration in the game(s) that I sketched above? The traditional way or\nwith MuSig. The reality is that we want to have everything combined:\n * BIP32\n * MuSig (and variants of it)\n * Taproot (with scripts that refer to the inner key)\n * sign-to-contract stuff (e.g., to prevent covert channels with\n   hardware wallets)\n * scriptless scrips\n * blind signatures\n * threshold signtures\n * whatever you can imagine on top of this\n\nIt's very cumbersome to come up with a formal model that includes all\nof this. One common approach to protocols that are getting too complex\nis to switch to simpler models, e.g., symbolic models/Dolev-Yao models\nbut that's hard here given that we don't have clear layering. Things\nwould be easier to analyze if Taproot was really  just a commitment to\na verification key. But it's more, it's something that's both a\nverification and a commitment. Taproot interferes with Schnorr\nsignatures on an algebraic level (not at all black-box), and that's\nactually the reason why it's so powerful and efficient. The same is\ntrue for almost everything in the list above, and this puts Taproot\noutside the scope of proof assistants for cryptographic protocols that\nwork on a symbolic level of abstraction. I really wonder how we can\nhandle this better. This would improve our understanding of the\ninterplay between various crypto components better, and make it easier\nto judge future proposals on all levels, from consensus changes to new\nmulti-signature protocols, etc.\n\n> \n> In my opinion, the cost of Taproot is mostly borne by theoreticians.\n> They can no longer treat a a public key ideally but have to consider\n> the implications of it also being a commitment. For the user and\n> Bitcoin as a whole it seems to offer an overwhelming benefit. In\n> exchange for the complexity it adds to making security claims in the\n> GGM (if using Taprscript and MuSig), it offers exciting new\n> opportunities for non-interactivity and fungibility over what just\n> what Schnorr would provide.\n\nI agree with this overall statement. I'm confident in Taproot, and I\nguess what say above really applies to the cost for theoreticians.\n(Let's just make sure that we don't forget how theory is relevant to\nsecurity in practice.) \n\nTim"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2020-03-16T07:31:44",
                "message_text_only": "On Fri, Mar 13, 2020 at 4:04 AM Tim Ruffing <crypto at timruffing.de> wrote:\n>\n> I mean, the good thing is that there's a general method to defend\n> against this, namely always adding a Merkle root on top. Maybe it's\n> useful to make the warning here a litte bit more drastic:\n>\nhttps://github.com/sipa/bips/blob/bip-taproot/bip-0341.mediawiki#cite_ref-22-0\n> Maybe we could actually mention this in BIP340, too, when we talk about\n> key generation,\n\nI missed this note in the BIP. This trick means you get property 2  (covert\ntaproot) for free if you prove property 3 (second covert taproot). This is\na big improvement as property 2 was dependent on the particulars of the key\ngeneration scheme whereas property 3 is just based on Taproot being a\nsecure commitment scheme. Nice!\n\n> I agree that modeling it as a commitment scheme is more natural. But I\n> think an optimal model would capture both worlds, and would give the\n> attacker signing oracles for the inner and the outer key, and an\n> commitment opening oracle That is, it would capture that\n>  * the ability to obtain signatures for the inner key does not help you\n>    to forge for the outer key\n>  * the ability to obtain signatures for the outer key does not help you\n>    to open the commitment, and --- if already opened --- do not help\n>    you to forge for the inner key\n>  * the ability to obtain an opening does not help you to forge for\n>    either key...\n>  * etc\n>\n> I believe that all these properties hold, and I believe this even\n> without a formal proof.\n>\n>\n> Still, it would be great to have one. The problem here is really that\n> things get complex so quickly. For example, how do you model key\n> generation in the game(s) that I sketched above? The traditional way or\n> with MuSig. The reality is that we want to have everything combined:\n>  * BIP32\n>  * MuSig (and variants of it)\n>  * Taproot (with scripts that refer to the inner key)\n>  * sign-to-contract stuff (e.g., to prevent covert channels with\n>    hardware wallets)\n>  * scriptless scrips\n>  * blind signatures\n>  * threshold signtures\n>  * whatever you can imagine on top of this\n>\n> It's very cumbersome to come up with a formal model that includes all\n> of this. One common approach to protocols that are getting too complex\n> is to switch to simpler models, e.g., symbolic models/Dolev-Yao models\n> but that's hard here given that we don't have clear layering. Things\n> would be easier to analyze if Taproot was really  just a commitment to\n> a verification key. But it's more, it's something that's both a\n> verification and a commitment. Taproot interferes with Schnorr\n> signatures on an algebraic level (not at all black-box), and that's\n> actually the reason why it's so powerful and efficient. The same is\n> true for almost everything in the list above, and this puts Taproot\n> outside the scope of proof assistants for cryptographic protocols that\n> work on a symbolic level of abstraction. I really wonder how we can\n> handle this better. This would improve our understanding of the\n> interplay between various crypto components better, and make it easier\n> to judge future proposals on all levels, from consensus changes to new\n> multi-signature protocols, etc.\n>\n\nI hope we can prove these things in a more modular way without creating a\nhybrid scheme with multiple oracles. My hope is that you can prove that any\nsecure key generation method will be secure once Taproot is applied to it\nif it is a secure commitment scheme. This was difficult before I knew about\nthe empty commitment trick! Although the Taprooted key and the internal key\nare algebraically related, the security requirements on the two primitives\n(the group and the hash function) are nicely separated. Intuitively,\n1. being able to  break the Taproot hash function (e.g. find pre-images)\ndoes not help you forge signatures on any external key; it can only help\nyou forge fake commitment openings (for the sake of this point assume that\nSchnorr uses an unrelated hash function for the challenge).\n2. being able solve discrete logarithms doesn't help you break Taproot; it\njust helps you forge signatures.\n\nI believe we can formally prove these two points and therefore dismiss the\nneed for any signing or commitment opening oracles in any security notion\nof Taproot:\n\n1. We can dismiss the idea of an adversary that uses a commitment opening\noracle to forge a signature because the commitment opening is not even an\ninput into the signing algorithm. Therefore it is information theoretically\nimpossible to learn anything about forging a signature from a Taproot\nopening.\n2. I think we can dismiss the idea of an adversary that uses a signing\noracle to forge a fake Taproot opening. To see this note that the Taproot\nForge reduction to RPP in my poster actually still holds if the adversary\nis given the secret key x (with a few other modifications). In the proof I\nkept it hidden just because that seemed more realistic. If we give the\nadversary the secret key we can dismiss the idea that a signing oracle will\nhelp them because they can just simulate it. Furthermore, if honest parties\nalways require the empty commitment be applied to their key we can dismiss\nthe idea of an adversary that forges just based on the binding of the\ncommitment scheme even if they know the secret key and regardless of the\nkey generation algorithm.\n\nThis allows us to restrict our notion of Taproot's security to its\ninteraction with the key generation protocol only. It should be sufficient\nto prove these three things:\n1. The key generation scheme is secure. I don't believe we have a\ndefinition for this yet but I guess it would be something like \"if the\nadversary can't output the secret key of the agg key then it is secure\".\n2. The Taproot transformation of any key generation scheme satisfying (1)\nalso satisfies (1).\n3. The external key produced by any transformed protocol is a secure\ncommitment to the message (if one is desired, if not the empty commitment\ntrick fixes this).\n\nThis gives us a modular and composable security model for Taproot. We can\njust prove that MuSig, threshold keygen, and all the other things you\nmentioned satisfy (1) and then by implication the Taprooted version of it\nis also secure. Or something like that!\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200316/144eb7a8/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Hash function requirements for Taproot",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Tim Ruffing",
                "Lloyd Fournier"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 31482
        }
    },
    {
        "title": "[bitcoin-dev] Signet: static genesis block, and dynamic message start",
        "thread_messages": [
            {
                "author": "Karl-Johan Alm",
                "date": "2020-03-05T06:43:03",
                "message_text_only": "Hello,\n\nI am proposing a modification to BIP-325 to make the genesis block\nstatic and to rely on the message start to avoid collision between\nsignets when multiple nets exist simultaneously:\n\nhttps://github.com/bitcoin/bips/pull/900"
            }
        ],
        "thread_summary": {
            "title": "Signet: static genesis block, and dynamic message start",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Karl-Johan Alm"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 232
        }
    },
    {
        "title": "[bitcoin-dev] Schnorr sigs vs pairing sigs",
        "thread_messages": [
            {
                "author": "Erik Aronesty",
                "date": "2020-03-05T19:01:27",
                "message_text_only": "Schnorr sigs rely so heavily on the masking provided by a random\nnonce.   There are so many easy ways to introduce bias (hash + modulo,\nfor example).\n\nEven 2 bits of bias can result in serious attacks:\n\nhttps://ecc2017.cs.ru.nl/slides/ecc2017-tibouchi.pdf\n\nMaybe pairing based sigs  - which are slower - might be both more\nflexible, and better suited to secure implemetnations?"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2020-03-06T06:40:24",
                "message_text_only": "Hi Erik,\n\nThere are a strong arguments for and against pairing based sigs in Bitcoin.\nOne very strong argument in favour over non-deterministic signatures like\nSchnorr over BLS is it enables a kind of signature encryption called\n\"adaptor signatures\". This construction is key to many exciting up and\ncoming layer 2 protocols and isn't possible unless the signature scheme\nuses randomness.\n\nself plug: I have a paper on this topic called \"One-Time Verifiably\nEncrypted Signatures A.K.A Adaptor Signatures\"\n https://github.com/LLFourn/one-time-VES/blob/master/main.pdf\n\nLL\n\n\nOn Fri, Mar 6, 2020 at 6:03 AM Erik Aronesty via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Schnorr sigs rely so heavily on the masking provided by a random\n> nonce.   There are so many easy ways to introduce bias (hash + modulo,\n> for example).\n>\n> Even 2 bits of bias can result in serious attacks:\n>\n> https://ecc2017.cs.ru.nl/slides/ecc2017-tibouchi.pdf\n>\n> Maybe pairing based sigs  - which are slower - might be both more\n> flexible, and better suited to secure implemetnations?\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200306/777ed685/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Schnorr sigs vs pairing sigs",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Erik Aronesty",
                "Lloyd Fournier"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1827
        }
    },
    {
        "title": "[bitcoin-dev] Removing Single Point of Failure with Seed Phrase Storage",
        "thread_messages": [
            {
                "author": "Russell O'Connor",
                "date": "2020-03-06T11:11:11",
                "message_text_only": "On Wed, Feb 26, 2020 at 2:56 PM Jeremy via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> As a replacement for paper, something like this makes sense v.s. what you\n> do with a ledger presently.\n>\n> However, shamir's shares notoriously have the issue that the key does\n> exist plaintext on a device at some point.\n>\n> Non-interactive multisig has the benefit of being able to sign\n> transactions without having keys in the same room/place/device ever.\n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin>\n> <https://twitter.com/JeremyRubin>\n>\n\nThe way I see it, the main benefit of Shamir's Secret Sharing is for those\npeople who are already willing or wanting to be able to sign transactions\non a single device, in a single room, etc., but would prefer not to keep\ntheir secret backup in a single room/place/device.  It is one thing to go\nand gather your shares whenever you need to recover from a broken/wiped\nhardware wallet versus having to go gather your shares whenever you want to\nmake a transaction.  (I do agree that SSS is not a suitabl for creating a\nmultisig from multiple participants.)\n\nThis thread inspired me tidy up and post my concept for creating secret\nshares using paper computers (slide charts) and can be found at\nhttps://github.com/roconnor-blockstream/SSS32/blob/master/SSS32.ps. It is a\ndesign for splitting a secret encoded in the Bech32 alphabet into 2-of-n\nshares (where n <= 31) using pencil, paper and lookup tables.  There are\nnumerous issues <https://github.com/roconnor-blockstream/SSS32/issues> and\nmore that need to be addressed before one could even think about using it\nfor actual valuable data.  Right now I'm mostly interested to find out if\npaper sharing is really feasible.\n\nA secret of 26 random Bech32 characters provides 130 bits of entropy, and a\nsecret of 51 random Bech32 characters provides 255 bits of entropy.\nHowever, to enable robust recovery, the secret data ought to contain an\nerror correcting code.  Because each character of the secret is\nindependently split into shares, any single character error in one of the\nshares translates into a single character error in the recovered secret\nwhich can be corrected by the error correcting code.  See the exercise at\nthe end of \"Verifying Bech32 Checksums with Pen and Paper\" <\nhttp://r6.ca/blog/20180106T164028Z.html> on how to attach the Bech32 error\ncorrecting code to a raw secret string by hand.  However, protecting the\nsecret data is so important that one would want to design a checksum BCH\ncode longer than 6 characters to get strong error correcting capabilities.\n\nI still don't know if this proposed method all a good idea or not.  I've\nonly experimented with encoding and recovering a 10 character \"secret\"\ndata.  Generating 2-of-n shares is quite easy as all the shares are a\nfunction of the secret share and the first random share.  It only takes\nlookup up a pair of coordinates in a table to generate one character for\neach of the n shares together.  Recovering the secret data is more work;\nhowever, if your plan is to recover a hardware wallet anyways, it is\nreasonable for the hardware wallet to do the recovery from the shares\nitself for you.  Generating the error correcting code by hand is a bit more\nworrying, because it doesn't do you much good if your generate an incorrect\nchecksum.  However, by doing 1 or 2 manual passes to verify the checksum is\nmaybe adequate.  Also passing the secret data into the hardware wallet you\nwish to use, along with its checksum, would let the hardware wallet tell\nyou if there was an error in the checksum.  I think creating more general\n3-of-n schemes can be implemented too, but require work similar to recovery\nto generate rather than the simple lookup table process.  Generating 4-of-n\nand higher schemes may also be possible, but would require even more hand\ncomputation (i.e. computing lagrange polynomials.)\n\nMaybe this scheme is workable for the subset of people that this would\nappeal to.  In anycase, my document is open source and available for those\nwho want to tinker with it.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200306/00d09243/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Removing Single Point of Failure with Seed Phrase Storage",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Russell O'Connor"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 4249
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Knots 0.19.1.knots20200304 released",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2020-03-07T19:47:36",
                "message_text_only": "Bitcoin Knots version 0.19.1.knots20200304 is now available from:\n\n  https://bitcoinknots.org/files/0.19.x/0.19.1.knots20200304/\n\nThis release includes new features, various bug fixes and performance\nimprovements, as well as updated translations.\n\nPlease report bugs using the issue tracker at GitHub:\n\n  https://github.com/bitcoinknots/bitcoin/issues\n\nTo receive security and update notifications, please subscribe to:\n\n  https://bitcoinknots.org/list/announcements/join/\n\nFor the full release notes and change log, see:\n  \nhttps://github.com/bitcoinknots/bitcoin/blob/v0.19.1.knots20200304/doc/release-notes.md\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 1528 bytes\nDesc: This is a digitally signed message part.\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200307/dcd345ed/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Knots 0.19.1.knots20200304 released",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Luke Dashjr"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 913
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Core 0.19.1 released",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2020-03-09T12:33:14",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\n0.19.1 Release Notes\n===============================\n\nBitcoin Core version 0.19.1 is now available from:\n\n  <https://bitcoincore.org/bin/bitcoin-core-0.19.1/>\n\nor through BitTorrent:\n\n  magnet:?xt=urn:btih:8b6ad1da5bbb24656234efc2370abc14781a6f83&dn=bitcoin-core-0.19.1&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337%2Fannounce&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969%2Fannounce&tr=udp%3A%2F%2Fexplodie.org%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.torrent.eu.org%3A451%2Fannounce&tr=udp%3A%2F%2Ftracker.bitcoin.sprovoost.nl%3A6969\n\nThis minor release includes various bug fixes and performance\nimprovements, as well as updated translations.\n\nPlease report bugs using the issue tracker at GitHub:\n\n  <https://github.com/bitcoin/bitcoin/issues>\n\nTo receive security and update notifications, please subscribe to:\n\n  <https://bitcoincore.org/en/list/announcements/join/>\n\nHow to Upgrade\n==============\n\nIf you are running an older version, shut it down. Wait until it has completely\nshut down (which might take a few minutes for older versions), then run the\ninstaller (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)\nor `bitcoind`/`bitcoin-qt` (on Linux).\n\nUpgrading directly from a version of Bitcoin Core that has reached its EOL is\npossible, but it might take some time if the datadir needs to be migrated. Old\nwallet versions of Bitcoin Core are generally supported.\n\nCompatibility\n==============\n\nBitcoin Core is supported and extensively tested on operating systems using\nthe Linux kernel, macOS 10.10+, and Windows 7 and newer. It is not recommended\nto use Bitcoin Core on unsupported systems.\n\nBitcoin Core should also work on most other Unix-like systems but is not\nas frequently tested on them.\n\n- From Bitcoin Core 0.17.0 onwards, macOS versions earlier than 10.10 are no\nlonger supported, as Bitcoin Core is now built using Qt 5.9.x which requires\nmacOS 10.10+. Additionally, Bitcoin Core does not yet change appearance when\nmacOS \"dark mode\" is activated.\n\nIn addition to previously supported CPU platforms, this release's pre-compiled\ndistribution provides binaries for the RISC-V platform.\n\n0.19.1 change log\n=================\n\n### Wallet\n- - #17643 Fix origfee return for bumpfee with feerate arg (instagibbs)\n- - #16963 Fix `unique_ptr` usage in boost::signals2 (promag)\n- - #17258 Fix issue with conflicted mempool tx in listsinceblock (adamjonas, mchrostowski)\n- - #17924 Bug: IsUsedDestination shouldn't use key id as script id for ScriptHash (instagibbs)\n- - #17621 IsUsedDestination should count any known single-key address (instagibbs)\n- - #17843 Reset reused transactions cache (fjahr)\n\n### RPC and other APIs\n- - #17687 cli: Fix fatal leveldb error when specifying -blockfilterindex=basic twice (brakmic)\n- - #17728 require second argument only for scantxoutset start action (achow101)\n- - #17445 zmq: Fix due to invalid argument and multiple notifiers (promag)\n- - #17524 psbt: handle unspendable psbts (achow101)\n- - #17156 psbt: check that various indexes and amounts are within bounds (achow101)\n\n### GUI\n- - #17427 Fix missing qRegisterMetaType for `size_t` (hebasto)\n- - #17695 disable File-\\>CreateWallet during startup (fanquake)\n- - #17634 Fix comparison function signature (hebasto)\n- - #18062 Fix unintialized WalletView::progressDialog (promag)\n\n### Tests and QA\n- - #17416 Appveyor improvement - text file for vcpkg package list (sipsorcery)\n- - #17488 fix \"bitcoind already running\" warnings on macOS (fanquake)\n- - #17980 add missing #include to fix compiler errors (kallewoof)\n\n### Platform support\n- - #17736 Update msvc build for Visual Studio 2019 v16.4 (sipsorcery)\n- - #17364 Updates to appveyor config for VS2019 and Qt5.9.8 + msvc project fixes (sipsorcery)\n- - #17887 bug-fix macos: give free bytes to `F_PREALLOCATE` (kallewoof)\n\n### Miscellaneous\n- - #17897 init: Stop indexes on shutdown after ChainStateFlushed callback (jimpo)\n- - #17450 util: Add missing headers to util/fees.cpp (hebasto)\n- - #17654 Unbreak build with Boost 1.72.0 (jbeich)\n- - #17857 scripts: Fix symbol-check & security-check argument passing (fanquake)\n- - #17762 Log to net category for exceptions in ProcessMessages (laanwj)\n- - #18100 Update univalue subtree (MarcoFalke)\n\nCredits\n=======\n\nThanks to everyone who directly contributed to this release:\n\n- - Aaron Clauson\n- - Adam Jonas\n- - Andrew Chow\n- - Fabian Jahr\n- - fanquake\n- - Gregory Sanders\n- - Harris\n- - Hennadii Stepanov\n- - Jan Beich\n- - Jim Posen\n- - Jo\u00e3o Barbosa\n- - Karl-Johan Alm\n- - Luke Dashjr\n- - MarcoFalke\n- - Michael Chrostowski\n- - Russell Yanofsky\n- - Wladimir J. van der Laan\n\nAs well as to everyone that helped with translations on\n[Transifex](https://www.transifex.com/bitcoin/bitcoin/).\n\n-----BEGIN PGP SIGNATURE-----\n\niQEzBAEBCgAdFiEEnerg3HBjJJ+wVHRoHkrtYphs0l0FAl5mN1QACgkQHkrtYphs\n0l1BuAf/RTyeosxcO4/VxR5nm2AEDb/gaaBDByRNgSxjZMT5dNnYDV8rmJgDoGAe\nFTHvp+/yC224TvDEFc2tcfU44L0nDfBfhZIPXkVQNVb75LGyN7nHCLIcLxxmutLZ\nHQ5cqehjzhbKdo0jGUhFa2vyVydbl823ZfJwt9gYRtIISxp78ZeXRFjm/2Br+TS0\nJ/9iA77eA1j4euVPoHs9K07AqCm2gIYYpZNiP1Xg6HEErPT6+7/nPzH95XRW2wX6\nea+QeuJcMRdoLXwxfENC9ywyxP3zgPvPPV6KFUBwchp+YczEZrQywbbYGRhbAcRh\nAOUVQ1tEfxN+wjBZjL5vcymwrChgiA==\n=M98k\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.19.1 released",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Wladimir J. van der Laan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5363
        }
    },
    {
        "title": "[bitcoin-dev] RFC: Deterministic Entropy From BIP32 Keychains",
        "thread_messages": [
            {
                "author": "Ethan Kosakovsky",
                "date": "2020-03-20T15:44:01",
                "message_text_only": "I would like to present a proposal for discussion and peer review. It aims to solve the problem of \"too many seeds and too many backups\" due to the many reasons stipulated in the proposal text.\n\nhttps://gist.githubusercontent.com/ethankosakovsky/f7d148f588d14e0bb4f70bb6afc509d0/raw/6da51e837b0e1f1b2b21f3d4cbc2c5a87969ffd5/bip-entropy-from-bip32.mediawiki\n\n<pre>\n  BIP:\n  Title: Deterministic Entropy From BIP32 Keychains\n  Author: Ethan Kosakovsky <ethankosakovsky at protonmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI:\n  Status: Proposed\n  Type: Standards Track\n  Created: 2020-03-20\n  License: BSD-2-Clause\n           OPL\n</pre>\n\n==Abstract==\n\nThis proposal provides a way to derive entropy from a HD keychain path in order to deterministically derive the initial entropy used to create keychain mnemonics and seeds.\n\n==Motivation==\n\nBIP32 uses some initial entropy as a seed to deterministically derive a BIP32 root for hierarchical deterministic keychains. BIP39 introduced a method of encoding initial entropy into a mnemonic phrase which is used as input to a one way hash function in order to deterministically derive a BIP32 seed. The motivation behind mnemonic phrases was to make it easier for humans to backup and store offline. There are also other variations of this theme.\n\nThe initial motivation of BIP32 was to make handling of large numbers of private keys easier to manage and backup, since you only need one BIP32 seed to cover all possible keys in the keychain. In practice however, due to various wallet implementations and security models, the average user may be faced with the need to handle an ever growing number of seeds/mnemonics. This is due to incompatible wallet standards, hardware wallets (HWW), seed formats and standards, as well as, the need to used a mix of hot and cold wallets depending on the application and environment.\n\nExamples would span wallets on mobile phones, online servers running protocols like Join Market or Lightning, and the difference between Electrum and BIP39 mnemonic seed formats. The reference implementation of Bitcoin Core uses BIP32, while other cryptocurrencies like Monero use different mnemonic encoding schemes.\n\nWe must also consider the different variety of physical backups including paper, metal and other physical storage devices, as well as the potentially splitting backups across different geographical locations. This complexity may result in less care being taken with subsequently generated seeds for new wallets need to be stored and it ultimately results in less security. In reality, the idea of having \"one seed for all\" has proven to be more difficult in practice than originally thought.\n\nSince all these derivation schemes are deterministic based on some initial entropy, this proposal aims to solve the above problems by detailing a way to deterministically derive the initial entropy used for new root keychains using a single BIP32 style \"master root key\". This will allow one root key or mnemonic to derive any variety of different root keychains in whatever format is required (like BIP32 and BIP39 etc).\n\n==Specification==\n\nInput starts with a BIP32 seed. Derivation scheme uses the format `m/83696968'/type'/index'` where `type` is the final seed type, and `index` in the key index of the hardened child private key.\n\n| type | bits| output                    |\n|------|-----|---------------------------|\n|   0  | 128 | 12 word BIP39 mnemonic    |\n|   1  | 256 | 24 word BIP39 mnemonic    |\n|   2  | 128 | 12 word Electrum mnemonic |\n|   3  | 256 | 24 word Electrum mnemonic |\n|   4  | 256 | WIF for Bitcoin Core      |\n|   5  | 256 | 25 word Monero mnemonic   |\n\nEntropy is calculated from the HMAC-SHA512(key=k, msg='bip-entropy-from-bip32') of the derived 32 byte private key (k). Entropy is taken from the result according to the number of bits required. This entropy can then be used as input to derive a mnemonic, wallet etc according to the `type` specified.\n\n==Compatibility==\n\nIn order to maintain the widest compatibility, the input to this function is a BIP32 seed, which may or may not have been derived from a BIP39 like mnemonic scheme. This maintains the original motivation that one backup can store any and all child derivation schemes depending on the user's preference or hardware signing devices. For example, devices that store the HD seed as a BIP39 mnemonic, Electrum seed, or BIP32 root key would all be able to implement this standard.\n\n==Discussion==\n\nThis proposal could be split into multiple discrete BIPs in the same way that BIP32 described the derivation mechanics, BIP39 the input encoding with mnemonics, and the derivation paths like BIP44, BIP49 and BIP84. This has been avoided to reduce complexity. The resulting private key processed with HMAC-SHA512 and truncated as necessary. HMAC-SHA512 was chosen because it may have better compatibility in embedded devices as it's already required in devices supporting BIP32.\n\n==Test Vectors==\n\n===Test case 1===\n\nMASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind employ giant era attitude exit final oval one finger decorate pair useless super method float toddler dance\nMASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfGJNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp\nPATH: m/83696968'/0'/0'\nBITS REQUIRED: 128\n\nDERIVED CHILD WIF=L3cefeCHyo8jczVjckMxaiPBaPUunc3D8CsjRxYbYp3FhasGpsV3\nDERIVED CHILD k=bed343b04ba0216d9eeebff0366b61c4179d90d44b61c716ef6d568836ba4d23\nCHILD ENTROPY=6458698fae3578b48a64124ea3514e12\nCONVERT ENTROPY TO WIF=KwDiBf89QgGbjEhKnhXJuH7T2Vv72UKQA8KRkmNwVFS2znAS5xb9\nCHILD BIP39 MNEMONIC=gold select glue fragile fiscal fog civil liquid exchange box fatal caught\nCHILD BIP39 SEED=2a2720e5590d4ec3140e51ba1b0b0a5183222c1668977c8a57572b0ea55d238cd8e899b3b1870e48894ca837e41e5d0db07554715efb21556fdde27f9f7ba153\nCHILD BIP32 ROOT KEY=xprv9s21ZrQH143K2ZH5qacptquLGvcYpHSNeyFVCU8Ur4u9kocajbBgcaCbHkGbwDsBR661H29F54j5mz14kwXbY9PZKdNRdjgRcGfshBK9XXb\n\n\n===Test case 2===\n\nMASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind employ giant era attitude exit final oval one finger decorate pair useless super method float toddler dance\nMASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfGJNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp\nPATH: m/83696968'/1'/0'\nBITS REQUIRED: 256\n\nDERIVED CHILD WIF=L1zCbtnDWUN4vJA3De4sxmJnoRim57CQUuBb4KBoRNs2EMEq2Brg\nDERIVED CHILD k=8e3ca6054a6303f4a6a1bcbda6134c9802f4f0a0d76b0ee6b69b06b1e80b2192\nCHILD ENTROPY=ec4e2f7e2c3fca9a34fa29747bf8ba0ab7f05136f37e134e2457e9e53639670b\nCONVERT ENTROPY TO WIF=L594JSCygt2wBaB9mCpXjiLkkxkEojpBdNXG8UrrdLd2LvPBRMUs\nCHILD BIP39 MNEMONIC=unable imitate test flash witness escape stadium early inner thank company betray lecture chuckle swift hurt battle illness bicycle stable fat bronze order high\nCHILD BIP39 SEED=73509b0e847ee66bddeb098a55063d73e8c6dd5f1c1db6969c668bb54c19bde6eae8acc29a81118d1d9719fa1bc620fee7edd7c15a17bcaf70b0fdfc0c0c3803\nCHILD BIP32 ROOT KEY=xprv9s21ZrQH143K4PfLyyjYLVmKbnUTNFK6Y7jPKWfRZB3iSw1Gy9qowEzkYHfetVabfmjHEEPrcTJbh7chae33Sm9uAjuXzhSL6Li8dcwM9Bm\n\n\n===Test case 3===\n\nMASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind employ giant era attitude exit final oval one finger decorate pair useless super method float toddler dance\nMASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfGJNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp\nPATH: m/83696968'/4'/0'\nBITS REQUIRED: 256\n\nDERIVED CHILD WIF=KwdD5PYnCU3xQDfFJ6XBf6UDaLrTUxrKmBpdjRuuavWyqAQtpaA2\nDERIVED CHILD k=0c169ce2c17bea08512a7519769e365242a1562bd63c4c903daef516000efbf2\nCHILD ENTROPY=25573247f8a76799f7abc086b9286b5a7ccb03cb8d3550f48ac1e71d90832974\nCONVERT ENTROPY TO WIF=KxUJ8VzMk7uWDEcwYjLRzRMGE6sSpwCfQxkE9GEwAvXhFSDNba9G\nCHILD BIP39 MNEMONIC=census ridge music vanish island smooth team job mammal sing bracket reject smile limit comfort pluck extend picture race soda suit dose place obtain\nCHILD BIP39 SEED=4e5c82be6455ecf0884d9475435e29a9afb9acf70b07296d7e5039c866e4d54647706918b9d14909dfbd7071a4b7aee8a4ad0ac2bf48f0a09a8899dd28564418\nCHILD BIP32 ROOT KEY=xprv9s21ZrQH143K2kekJsK9V6t4ZKwHkY1Q3umxuaAhdZKGxCMpHiddLdYUQBoynszpwnk5upoC788LiT5MZ5q1vUABXG7AMyZK5UjD9iyL7Am\n\n==References==\n\nBIP32, BIP39\n\n==Copyright==\n\nThis BIP is dual-licensed under the Open Publication License and BSD 2-clause license."
            },
            {
                "author": "Pavol Rusnak",
                "date": "2020-03-20T16:29:49",
                "message_text_only": "On 20/03/2020 16:44, Ethan Kosakovsky via bitcoin-dev wrote:\n> I would like to present a proposal for discussion and peer review\n\nI read your proposal twice and I still don't know what kind of problem\nare you trying to solve.\n\nThis should be obvious from the \"Abstract\" and it's bad if it's not.\n\n\n\n\n-- \nBest Regards / S pozdravom,\n\nPavol \"stick\" Rusnak\nCTO, SatoshiLabs"
            },
            {
                "author": "Ethan Kosakovsky",
                "date": "2020-03-20T17:34:05",
                "message_text_only": "Pavol,\n\nYes thank you. I find abstracts hard, I will try again.\n\nCurrently I need a separate BIP30 for many of my wallets. I cant have one master seed for all my wallets because some are less safe than others and storing the master in each environment will increase the chance it could be compromised (e.g. hot environments). I cant export a hardened xprv from my main BIP32 keychain and import it to my JM/Android wallet because they dont support it. There's also a usability issue there since xprvs are not easy to type.\n\ne.g.\n1. Join Market server (online)\n2. Lightning node (online)\n3. Trezor (offline)\n4. Smartphone wallet with coffee money (online) (and no HWW support)\n5. Bitcoin Core (doesn't use BIP39 at all)\n\nI cannot use the same BIP39 seed across all these services. 1,2,4,5 are effectively hot wallets.\n\nThe problem is BIP39. BIP32 is fine but the backup process is not human friendly. It would have been better to simply serialize 128 or 256 bits of entropy into words like BIP39 does and be done with it. After that, it's all deterministic anyway. Instead BIP39 tries to ensure pseudorandom entropy by hash-stretching the initial entropy.\n\nWe can already export keychains from BIP32, as xprvs, but there is also no easy way to make as a human readable/typeable like BIP39 mnemonics. Most wallets don't allow you to import an xprv anyway, but again, good luck typing it.\n\nWhat we are left with is an ecosystem that widely implements BIP39, so practically speaking if I want to use multiple wallets and cannot share an existing seed with that device, I need separate 12 or 24 word mnemonics. That's 5 times the complexity to store than one (in my case). I need a new cryptosteel. If I have two different geological locations for backup, it's hard to add more, since I need to travel. The whole point of BIP32 was one master key would rule them all - set up once, back up once and it's done. BIP39 was simply to make it human friendly to write down the seed on paper.\n\nThe easy solution as I see it is have one BIP39 mnemonic as my \"master root key\". From there it makes a BIP32 keychain and I can deterministically create child BIP39 seeds by taking a hardened path, using the private key as entropy ENT to create a new BIP39 mnemonic. If I do it this way I can have one initial backup, and if I need more wallets with a different seed, I can do it without worrying about backups. I'm future proof this way.\n\nEthan\n\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Friday, March 20, 2020 5:29 PM, Pavol Rusnak <stick at satoshilabs.com> wrote:\n\n> On 20/03/2020 16:44, Ethan Kosakovsky via bitcoin-dev wrote:\n>\n> > I would like to present a proposal for discussion and peer review\n>\n> I read your proposal twice and I still don't know what kind of problem\n> are you trying to solve.\n>\n> This should be obvious from the \"Abstract\" and it's bad if it's not.\n>\n>\n> -------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n>\n> Best Regards / S pozdravom,\n>\n> Pavol \"stick\" Rusnak\n> CTO, SatoshiLabs"
            },
            {
                "author": "Ethan Kosakovsky",
                "date": "2020-03-20T17:35:13",
                "message_text_only": "I think my proposal can be summarized simply:\n\n1. get a child private key, hmac it and get entropy bits.\n2. Use that entropy to feed BIP39 to make a new mnemonic seed\n\nBitcoin Core hdseed is a private key, so we can also do the same steps here\n\n1. get a child private key, hmac it and get entropy bits.\n2. Use that entropy to create a WIF to become the key for hdseed in Bitcoin Core.\n\nI standardize this by using paths (like BIP44/49)\n\nm/SEED'/BIP39'/index'\nm/SEED'/CORE'/index'\n\nindex allows me to generate multiple childs for that type.\n\nEthen\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Friday, March 20, 2020 6:34 PM, Ethan Kosakovsky <ethankosakovsky at protonmail.com> wrote:\n\n> Pavol,\n>\n> Yes thank you. I find abstracts hard, I will try again.\n>\n> Currently I need a separate BIP30 for many of my wallets. I cant have one master seed for all my wallets because some are less safe than others and storing the master in each environment will increase the chance it could be compromised (e.g. hot environments). I cant export a hardened xprv from my main BIP32 keychain and import it to my JM/Android wallet because they dont support it. There's also a usability issue there since xprvs are not easy to type.\n>\n> e.g.\n>\n> 1.  Join Market server (online)\n> 2.  Lightning node (online)\n> 3.  Trezor (offline)\n> 4.  Smartphone wallet with coffee money (online) (and no HWW support)\n> 5.  Bitcoin Core (doesn't use BIP39 at all)\n>\n>     I cannot use the same BIP39 seed across all these services. 1,2,4,5 are effectively hot wallets.\n>\n>     The problem is BIP39. BIP32 is fine but the backup process is not human friendly. It would have been better to simply serialize 128 or 256 bits of entropy into words like BIP39 does and be done with it. After that, it's all deterministic anyway. Instead BIP39 tries to ensure pseudorandom entropy by hash-stretching the initial entropy.\n>\n>     We can already export keychains from BIP32, as xprvs, but there is also no easy way to make as a human readable/typeable like BIP39 mnemonics. Most wallets don't allow you to import an xprv anyway, but again, good luck typing it.\n>\n>     What we are left with is an ecosystem that widely implements BIP39, so practically speaking if I want to use multiple wallets and cannot share an existing seed with that device, I need separate 12 or 24 word mnemonics. That's 5 times the complexity to store than one (in my case). I need a new cryptosteel. If I have two different geological locations for backup, it's hard to add more, since I need to travel. The whole point of BIP32 was one master key would rule them all - set up once, back up once and it's done. BIP39 was simply to make it human friendly to write down the seed on paper.\n>\n>     The easy solution as I see it is have one BIP39 mnemonic as my \"master root key\". From there it makes a BIP32 keychain and I can deterministically create child BIP39 seeds by taking a hardened path, using the private key as entropy ENT to create a new BIP39 mnemonic. If I do it this way I can have one initial backup, and if I need more wallets with a different seed, I can do it without worrying about backups. I'm future proof this way.\n>\n>     Ethan\n>\n>     \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>     On Friday, March 20, 2020 5:29 PM, Pavol Rusnak stick at satoshilabs.com wrote:\n>\n>\n> > On 20/03/2020 16:44, Ethan Kosakovsky via bitcoin-dev wrote:\n> >\n> > > I would like to present a proposal for discussion and peer review\n> >\n> > I read your proposal twice and I still don't know what kind of problem\n> > are you trying to solve.\n> > This should be obvious from the \"Abstract\" and it's bad if it's not.\n> >\n> > Best Regards / S pozdravom,\n> > Pavol \"stick\" Rusnak\n> > CTO, SatoshiLabs"
            },
            {
                "author": "Peter D. Gray",
                "date": "2020-03-20T20:02:53",
                "message_text_only": "I like this proposal and I see it's value: \"One seed to rule them all.\"\n\nNot hard to implement either.\n\n---\nPeter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10\n\n\nOn Fri, Mar 20, 2020 at 03:44:01PM +0000, Ethan Kosakovsky wrote:\n> I would like to present a proposal for discussion and peer review. It aims to solve the problem of \"too many seeds and too many backups\" due to the many reasons stipulated in the proposal text.\n> \n> https://gist.githubusercontent.com/ethankosakovsky/f7d148f588d14e0bb4f70bb6afc509d0/raw/6da51e837b0e1f1b2b21f3d4cbc2c5a87969ffd5/bip-entropy-from-bip32.mediawiki\n> \n> <pre>\n>   BIP:\n>   Title: Deterministic Entropy From BIP32 Keychains\n>   Author: Ethan Kosakovsky <ethankosakovsky at protonmail.com>\n>   Comments-Summary: No comments yet.\n>   Comments-URI:\n>   Status: Proposed\n>   Type: Standards Track\n>   Created: 2020-03-20\n>   License: BSD-2-Clause\n>            OPL\n> </pre>\n> \n> ==Abstract==\n> \n> This proposal provides a way to derive entropy from a HD keychain path in order to deterministically derive the initial entropy used to create keychain mnemonics and seeds.\n> \n...\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 529 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200320/4e6f725f/attachment.sig>"
            },
            {
                "author": "Christopher Allen",
                "date": "2020-03-21T01:46:19",
                "message_text_only": "I agree with the problem statement in this proposal, but not the proposed\nsolution.\n\nThe challenge of safely securing a seed for a single signature is not\ninsignificant. Blockchain Commons has published procedures that we consider\nthe current best practices for cold storage in a free book at\nhttp://bit.ly/SmartCustodyBookV101 and in github at\nhttps://github.com/BlockchainCommons/smartcustodybook. It currently\nrequires a couple of hours and $200 or more of materials (home safe, 2\nledgers, titanium blanks, etc.) to safely product (significantly less time\nand money than Glacier Protocol).\n\nPresumably, people are not going to go to this level of protection for too\nmany keys, thus there needs to be methods to leverage the root seeds that\nare properly protected.\n\nCurrently Blockchain Commons is working on standards for airgap solutions\nfor storing and signing from offline keys. Scenarios include using Shamir\nand SLIP-39  on an offline device with no-WiFi or Bluetooth, an air-gapped\nmobile phone in airplane mode, or another dedicated device (for instance\nthe SafeKey device if open source was an option). You would use this device\nto create and restore seeds, convert seeds from BIP-39 to SLIP-39, derive\nHD keys, and then use QR code from the device to transfer the generated\nchild keys for use by different apps. In some cases, this offline device\ncould also read QR transactions and sign them. We have working prototypes\nof this today.\n\nThis technique works fine for online Bitcoin apps that accept child keys in\nthe form of xprv (or equivalents) such as those our FullyNoded2 iOS wallet\nsupports, but the problem for other wallets is that you can't go from an\nxprv back to a seed \u2014 the xprv creation is a one-way hmac-sha512 operation\n(still not convinced this was a good decision).\n\nWhat I think Ethan is proposing is the ability to turn any child derived\nxprv key into a new set valid seed words that could be used by a wallet or\nother devices that don't understand xprv and will only allow import of new\nseeds words. This gets even more complicated if the seed words are not the\nstandard BIP-39 set (which BTW, are not an ideal set of words, the\nselection of the SLIP-39 words is much better).\n\nThough possibly pragmatic, this approach would be a hack \u2013 starting with\nsome raw entropy, convert this to an entropy seed, then to words, then hmac\nto xprv, then derive child keys, then convert that child key to a new\nentropy seed, then hmac to xprv, and then derive child keys again, etc.\n\nI'd really prefer to start with finding standards ways to protect the\nentropy seed (not specifically the bip39 words derived from that but also\nas derived roots for WebAuthN/FIDO, GPG, Signal/Session, etc.) that can be\nthen be used to create other hierarchies of keys using airgap solutions.\n\nFor instance, here is what FullyNoded 2 currently uses to restore a Bitcoin\nwallet including root seed:\n\n{\n  \"birthdate\": 1584725088,\n  \"label\": \"Testnet Single Signature\",\n  \"entropy\": \"b3b17e8f425bf7b96d68b67867cdc816\",\n  \"walletName\": \"DEFAULT_EBaiuGgZQS_StandUp\",\n  \"descriptor\":\n\"wpkh([6955c2cb/84'/1'/0']tprv8giCxdrRRrKfQkXTJ4q2PNZBsPL7HiTXXteajiG8wqAGpLVsHJfN1EwwKM8F8x1Cuk8p6vh1KrKBCuZtZdDtL6Sc2CB1ou8sYiGSf6hcujv/0/*)\",\n  \"blockheight\": 1\n}\n\nAlternatively, FullyNoded 2 can also restore a wallets without the full\nseed, so for instance, if this QR restore was missing the entropy field,\nonly derived child xprv from the descriptor could be used, so no other\naccounts could be created but new addresses as children of the xprv could\nbe created.\n\nThe advantage of of an entropy seed storage centered technique is that I\ncan convert that entropy seed into either BIP39 words, or any number of\nSLIP-39 shards, or Lightning words, and back. We are also looking at using\nthis with the VSS that underlies Schnorr Musig. We can talk other secure\ntool makers on how to use this raw entropy for other purposes to create\nchains or hierarchies of keys for their unique needs.\n\nBlockchain Common's doesn't have a full architecture for this yet as we are\nworking on our POC and are seeking suggestions from other wallet vendors\n(in particular lightning and non-bitcoin secure services) on requirements.\nLet me know if you'd like to participate in the discussions (currently\neither Github issues or a Signal group for the group)\n\n\u2014 Christopher Allen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200320/c56bcc9e/attachment.html>"
            },
            {
                "author": "Ethan Kosakovsky",
                "date": "2020-03-21T15:10:48",
                "message_text_only": "Chris,\n\nThank you for taking the time to share your thoughts. I agree there are wide considerations surrounding key handling and storage. I dont think my proposal interferes with that perspective any more than BIP32 itself would. How keys are handled is a separate matter than the cryptography of key derivation and trying to get back to the one single backup that is future proof.\n\nMy proposal is not concerned with how the initial master key/seed is generated, just that we have one. My proposal is concerned with how to avoid having to generate more master keys because of the wide adoption of standards that impose restrictions (like BIP39); or the fragmented methods of initialization various wallets; as well as the instances where sharing the BIP39 seed with multiple wallets is undesirable due to security concerns (for example hot and offline wallet); or just plain incompatible standards.\n\nIf we were to start everything from scratch, we would obviously do things differently. However, there are already millions of wallets created using existing standards. It's just not possible to reset sadly.\n\n> What I think Ethan is proposing is the ability to turn any child derived\n> xprv key into a new set valid seed words that could be used by a wallet or\n> other devices that don't understand xprv and will only allow import of new\n> seeds words. This gets even more complicated if the seed words are not the\n> standard BIP-39 set (which BTW, are not an ideal set of words, the\n> selection of the SLIP-39 words is much better).\n\nI am proposing two separate things.\n\n  - that we use fully hardened paths to derive keys in order to derive entropy.\n  - that a BIP44 like derivation path can be used to describe what the entropy is intended for\n\n    For example we use the prefix 83696968 (ASCII seed in decimal) `m/83696968'/type'/index'`\n      - `type` defines how the entropy will be used\n        `0` means use 128 bits of the entropy as input to BIP39, producing a 12 word BIP39 mnemonic\n        `4` means use 256 bits of the entropy as the secret exponent to create a compressed WIF (for use as hdseed in Bitcoin Core)\n\n    In this way, we can neatly define the specific use-cases of the entropy maintaining some order.\n\n      - `index` is the key index so we can generate multiple instances of this type of entropy\n\nTo answer your question about whether to one-way-transform the resulting k. In practice, k is already safe because it was derived from a fully hardened path which protects the parent tree. However, the purpose here semantically is to be entropy. But k is not entropy, it's a private key on that derivation path. Neither are we exporting and xprv. We want entropy to seed the derivation of something else specified by the `type`. For that reason I consider it important to transform k by way of a hash or hmac. Using HMAC over hash is a decision based on an abundance of caution to ensure ward off unwanted side effects should k be used for a dual purpose, including as a nonce hash(k), where undesirable and unforeseen interactions could occur.\n\n> Though possibly pragmatic, this approach would be a hack \u2013 starting with some raw entropy, convert this to an entropy seed, then to words, then hmac to xprv, then derive child keys, then convert that child key to a new entropy seed, then hmac to xprv, and then derive child keys again, etc.\n\nI am not proposing the nesting, although nothing would prohibit it, I'm just proposing one master root key from which all child keychains can be derived and overcome the incompatibilities and impracticalities detailed.\n\n> Let me know if you'd like to participate in the discussions (currently either Github issues or a Signal group for the group)\n\nSure! What's the URL of the Github?\n\nEthan\n\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Saturday, March 21, 2020 2:46 AM, Christopher Allen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I agree with the problem statement in this proposal, but not the proposed solution.\n>\n> The challenge of safely securing a seed for a single signature is not insignificant. Blockchain Commons has published procedures that we consider the current best practices for cold storage in a free book at\u00a0http://bit.ly/SmartCustodyBookV101 and in github at\u00a0https://github.com/BlockchainCommons/smartcustodybook. It currently requires a couple of hours and $200 or more of materials (home safe, 2 ledgers, titanium blanks, etc.) to safely product (significantly less time and money than Glacier Protocol).\u00a0\n>\n> Presumably, people are not going to go to this level of protection for too many keys, thus there needs to be methods to leverage the root seeds that are properly protected.\n>\n> Currently Blockchain Commons is working on standards for airgap solutions for storing and signing from offline keys. Scenarios include using Shamir and SLIP-39\u00a0 on an offline device with no-WiFi or Bluetooth, an air-gapped mobile phone in airplane mode, or another dedicated device (for instance the SafeKey device if open source was an option). You would use this device to create and restore seeds, convert seeds from BIP-39 to SLIP-39, derive HD keys, and then use QR code from the device to transfer the generated child keys for use by different apps. In some cases, this offline device could also read QR transactions and sign them. We have working prototypes of this today.\n>\n> This technique works fine for online Bitcoin apps that accept child keys in the form of xprv (or equivalents) such as those our FullyNoded2 iOS wallet supports, but the problem for other wallets is that you can't go from an xprv back to a seed \u2014 the xprv creation is a one-way hmac-sha512 operation (still not convinced this was a good decision).\u00a0\n>\n> What I think Ethan is proposing is the ability to turn any child derived xprv key into a new set valid seed words that could be used by a wallet or other devices that don't understand xprv and will only allow import of new seeds words. This gets even more complicated if the seed words are not the standard BIP-39 set (which BTW, are not an ideal set of words, the selection of the SLIP-39 words is much better).\u00a0\n>\n> Though possibly pragmatic, this approach would be a hack \u2013 starting with some raw entropy, convert this to an entropy seed, then to words, then hmac to xprv, then derive child keys, then convert that child key to a new entropy seed, then hmac to xprv, and then derive child keys again, etc.\n>\n> I'd really prefer to start with finding standards ways to protect the entropy seed (not specifically the bip39 words derived from that but also as derived roots for WebAuthN/FIDO, GPG, Signal/Session, etc.) that can be then be used to create other hierarchies of keys using airgap solutions.\n>\n> For instance, here is what FullyNoded 2 currently uses to restore a Bitcoin wallet including root seed:\n>\n> {\n> \u00a0 \"birthdate\": 1584725088,\n> \u00a0 \"label\": \"Testnet Single Signature\",\n> \u00a0 \"entropy\": \"b3b17e8f425bf7b96d68b67867cdc816\",\n> \u00a0 \"walletName\": \"DEFAULT_EBaiuGgZQS_StandUp\",\n> \u00a0 \"descriptor\": \"wpkh([6955c2cb/84'/1'/0']tprv8giCxdrRRrKfQkXTJ4q2PNZBsPL7HiTXXteajiG8wqAGpLVsHJfN1EwwKM8F8x1Cuk8p6vh1KrKBCuZtZdDtL6Sc2CB1ou8sYiGSf6hcujv/0/*)\",\n> \u00a0 \"blockheight\": 1\n> }\n>\n> Alternatively, FullyNoded 2 can also restore a wallets without the full seed, so for instance, if this QR restore was missing the entropy field, only derived child xprv from the descriptor could be used, so no other accounts could be created but new addresses as children of the xprv could be created.\n>\n> The advantage of of an entropy seed storage centered technique is that I can convert that entropy seed into either BIP39 words, or any number of SLIP-39 shards, or Lightning words, and back. We are also looking at using this with the VSS that underlies Schnorr Musig. We can talk other secure tool makers on how to use this raw entropy for other purposes to create chains or hierarchies of keys for their unique needs.\n>\n> Blockchain Common's doesn't have a full architecture for this yet as we are working on our POC and are seeking suggestions from other wallet vendors (in particular lightning and non-bitcoin secure services) on requirements. Let me know if you'd like to participate in the discussions (currently either Github issues or a Signal group for the group)\n>\n> \u2014 Christopher Allen"
            },
            {
                "author": "Ethan Kosakovsky",
                "date": "2020-03-22T11:58:53",
                "message_text_only": "I have completely revised the wording of this proposal I hope to be clearer in explaining the motivation and methodology.\n\nhttps://gist.github.com/ethankosakovsky/268c52f018b94bea29a6e809381c05d6\n\nEthan\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Friday, March 20, 2020 4:44 PM, Ethan Kosakovsky via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I would like to present a proposal for discussion and peer review. It aims to solve the problem of \"too many seeds and too many backups\" due to the many reasons stipulated in the proposal text.\n>\n> https://gist.githubusercontent.com/ethankosakovsky/f7d148f588d14e0bb4f70bb6afc509d0/raw/6da51e837b0e1f1b2b21f3d4cbc2c5a87969ffd5/bip-entropy-from-bip32.mediawiki\n>\n> <pre>\n> BIP:\n> Title: Deterministic Entropy From BIP32 Keychains\n> Author: Ethan Kosakovsky ethankosakovsky at protonmail.com\n> Comments-Summary: No comments yet.\n> Comments-URI:\n> Status: Proposed\n> Type: Standards Track\n> Created: 2020-03-20\n> License: BSD-2-Clause\n> OPL\n> </pre>\n>\n> ==Abstract==\n>\n> This proposal provides a way to derive entropy from a HD keychain path in order to deterministically derive the initial entropy used to create keychain mnemonics and seeds.\n>\n> ==Motivation==\n>\n> BIP32 uses some initial entropy as a seed to deterministically derive a BIP32 root for hierarchical deterministic keychains. BIP39 introduced a method of encoding initial entropy into a mnemonic phrase which is used as input to a one way hash function in order to deterministically derive a BIP32 seed. The motivation behind mnemonic phrases was to make it easier for humans to backup and store offline. There are also other variations of this theme.\n>\n> The initial motivation of BIP32 was to make handling of large numbers of private keys easier to manage and backup, since you only need one BIP32 seed to cover all possible keys in the keychain. In practice however, due to various wallet implementations and security models, the average user may be faced with the need to handle an ever growing number of seeds/mnemonics. This is due to incompatible wallet standards, hardware wallets (HWW), seed formats and standards, as well as, the need to used a mix of hot and cold wallets depending on the application and environment.\n>\n> Examples would span wallets on mobile phones, online servers running protocols like Join Market or Lightning, and the difference between Electrum and BIP39 mnemonic seed formats. The reference implementation of Bitcoin Core uses BIP32, while other cryptocurrencies like Monero use different mnemonic encoding schemes.\n>\n> We must also consider the different variety of physical backups including paper, metal and other physical storage devices, as well as the potentially splitting backups across different geographical locations. This complexity may result in less care being taken with subsequently generated seeds for new wallets need to be stored and it ultimately results in less security. In reality, the idea of having \"one seed for all\" has proven to be more difficult in practice than originally thought.\n>\n> Since all these derivation schemes are deterministic based on some initial entropy, this proposal aims to solve the above problems by detailing a way to deterministically derive the initial entropy used for new root keychains using a single BIP32 style \"master root key\". This will allow one root key or mnemonic to derive any variety of different root keychains in whatever format is required (like BIP32 and BIP39 etc).\n>\n> ==Specification==\n>\n> Input starts with a BIP32 seed. Derivation scheme uses the format `m/83696968'/type'/index'` where `type` is the final seed type, and `index` in the key index of the hardened child private key.\n>\n> type\n>\n> bits\n>\n> output\n>\n> 0\n>\n> 128\n>\n> 12 word BIP39 mnemonic\n>\n> 1\n>\n> 256\n>\n> 24 word BIP39 mnemonic\n>\n> 2\n>\n> 128\n>\n> 12 word Electrum mnemonic\n>\n> 3\n>\n> 256\n>\n> 24 word Electrum mnemonic\n>\n> 4\n>\n> 256\n>\n> WIF for Bitcoin Core\n>\n> 5\n>\n> 256\n>\n> 25 word Monero mnemonic\n>\n> Entropy is calculated from the HMAC-SHA512(key=k, msg='bip-entropy-from-bip32') of the derived 32 byte private key (k). Entropy is taken from the result according to the number of bits required. This entropy can then be used as input to derive a mnemonic, wallet etc according to the`type` specified.\n>\n> ==Compatibility==\n>\n> In order to maintain the widest compatibility, the input to this function is a BIP32 seed, which may or may not have been derived from a BIP39 like mnemonic scheme. This maintains the original motivation that one backup can store any and all child derivation schemes depending on the user's preference or hardware signing devices. For example, devices that store the HD seed as a BIP39 mnemonic, Electrum seed, or BIP32 root key would all be able to implement this standard.\n>\n> ==Discussion==\n>\n> This proposal could be split into multiple discrete BIPs in the same way that BIP32 described the derivation mechanics, BIP39 the input encoding with mnemonics, and the derivation paths like BIP44, BIP49 and BIP84. This has been avoided to reduce complexity. The resulting private key processed with HMAC-SHA512 and truncated as necessary. HMAC-SHA512 was chosen because it may have better compatibility in embedded devices as it's already required in devices supporting BIP32.\n>\n> ==Test Vectors==\n>\n> ===Test case 1===\n>\n> MASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind employ giant era attitude exit final oval one finger decorate pair useless super method float toddler dance\n> MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfGJNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp\n> PATH: m/83696968'/0'/0'\n> BITS REQUIRED: 128\n>\n> DERIVED CHILD WIF=L3cefeCHyo8jczVjckMxaiPBaPUunc3D8CsjRxYbYp3FhasGpsV3\n> DERIVED CHILD k=bed343b04ba0216d9eeebff0366b61c4179d90d44b61c716ef6d568836ba4d23\n> CHILD ENTROPY=6458698fae3578b48a64124ea3514e12\n> CONVERT ENTROPY TO WIF=KwDiBf89QgGbjEhKnhXJuH7T2Vv72UKQA8KRkmNwVFS2znAS5xb9\n> CHILD BIP39 MNEMONIC=gold select glue fragile fiscal fog civil liquid exchange box fatal caught\n> CHILD BIP39 SEED=2a2720e5590d4ec3140e51ba1b0b0a5183222c1668977c8a57572b0ea55d238cd8e899b3b1870e48894ca837e41e5d0db07554715efb21556fdde27f9f7ba153\n> CHILD BIP32 ROOT KEY=xprv9s21ZrQH143K2ZH5qacptquLGvcYpHSNeyFVCU8Ur4u9kocajbBgcaCbHkGbwDsBR661H29F54j5mz14kwXbY9PZKdNRdjgRcGfshBK9XXb\n>\n> ===Test case 2===\n>\n> MASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind employ giant era attitude exit final oval one finger decorate pair useless super method float toddler dance\n> MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfGJNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp\n> PATH: m/83696968'/1'/0'\n> BITS REQUIRED: 256\n>\n> DERIVED CHILD WIF=L1zCbtnDWUN4vJA3De4sxmJnoRim57CQUuBb4KBoRNs2EMEq2Brg\n> DERIVED CHILD k=8e3ca6054a6303f4a6a1bcbda6134c9802f4f0a0d76b0ee6b69b06b1e80b2192\n> CHILD ENTROPY=ec4e2f7e2c3fca9a34fa29747bf8ba0ab7f05136f37e134e2457e9e53639670b\n> CONVERT ENTROPY TO WIF=L594JSCygt2wBaB9mCpXjiLkkxkEojpBdNXG8UrrdLd2LvPBRMUs\n> CHILD BIP39 MNEMONIC=unable imitate test flash witness escape stadium early inner thank company betray lecture chuckle swift hurt battle illness bicycle stable fat bronze order high\n> CHILD BIP39 SEED=73509b0e847ee66bddeb098a55063d73e8c6dd5f1c1db6969c668bb54c19bde6eae8acc29a81118d1d9719fa1bc620fee7edd7c15a17bcaf70b0fdfc0c0c3803\n> CHILD BIP32 ROOT KEY=xprv9s21ZrQH143K4PfLyyjYLVmKbnUTNFK6Y7jPKWfRZB3iSw1Gy9qowEzkYHfetVabfmjHEEPrcTJbh7chae33Sm9uAjuXzhSL6Li8dcwM9Bm\n>\n> ===Test case 3===\n>\n> MASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind employ giant era attitude exit final oval one finger decorate pair useless super method float toddler dance\n> MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfGJNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp\n> PATH: m/83696968'/4'/0'\n> BITS REQUIRED: 256\n>\n> DERIVED CHILD WIF=KwdD5PYnCU3xQDfFJ6XBf6UDaLrTUxrKmBpdjRuuavWyqAQtpaA2\n> DERIVED CHILD k=0c169ce2c17bea08512a7519769e365242a1562bd63c4c903daef516000efbf2\n> CHILD ENTROPY=25573247f8a76799f7abc086b9286b5a7ccb03cb8d3550f48ac1e71d90832974\n> CONVERT ENTROPY TO WIF=KxUJ8VzMk7uWDEcwYjLRzRMGE6sSpwCfQxkE9GEwAvXhFSDNba9G\n> CHILD BIP39 MNEMONIC=census ridge music vanish island smooth team job mammal sing bracket reject smile limit comfort pluck extend picture race soda suit dose place obtain\n> CHILD BIP39 SEED=4e5c82be6455ecf0884d9475435e29a9afb9acf70b07296d7e5039c866e4d54647706918b9d14909dfbd7071a4b7aee8a4ad0ac2bf48f0a09a8899dd28564418\n> CHILD BIP32 ROOT KEY=xprv9s21ZrQH143K2kekJsK9V6t4ZKwHkY1Q3umxuaAhdZKGxCMpHiddLdYUQBoynszpwnk5upoC788LiT5MZ5q1vUABXG7AMyZK5UjD9iyL7Am\n>\n> ==References==\n>\n> BIP32, BIP39\n>\n> ==Copyright==\n>\n> This BIP is dual-licensed under the Open Publication License and BSD 2-clause license.\n>\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Tim Ruffing",
                "date": "2020-03-24T08:07:04",
                "message_text_only": "I think your proposal is simply to use BIP32 for all derivations and\nthe observation that you can work with derived keys with the\ncorresponding suffixes of the path. I believe that this is a good idea.\n\nBut I don't think that simply writing a standard will help. It's just\none step. If all your wallets support incompatible formats, we should\nwork on fixing this because that's the root of the issue. Otherwise you\nend up converting keys back and forth manually (as Chris pointed out),\nand this can't be the goal. \n\nBut then you need to reach out to wallet devs explicitly and get them\ninvolved in creating the standard. Otherwise they won't use it. That's\na hard process, and it's even harder to make sure that the resulting\nproposal isn't way too complex because everyone brings their special\ncase to the table. \n\nTim \n\nOn Sun, 2020-03-22 at 11:58 +0000, Ethan Kosakovsky via bitcoin-dev\nwrote:\n> I have completely revised the wording of this proposal I hope to be\n> clearer in explaining the motivation and methodology.\n> \n> https://gist.github.com/ethankosakovsky/268c52f018b94bea29a6e809381c05d6\n> \n> Ethan\n> \n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Friday, March 20, 2020 4:44 PM, Ethan Kosakovsky via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> > I would like to present a proposal for discussion and peer review.\n> > It aims to solve the problem of \"too many seeds and too many\n> > backups\" due to the many reasons stipulated in the proposal text.\n> > \n> > https://gist.githubusercontent.com/ethankosakovsky/f7d148f588d14e0bb4f70bb6afc509d0/raw/6da51e837b0e1f1b2b21f3d4cbc2c5a87969ffd5/bip-entropy-from-bip32.mediawiki\n> > \n> > <pre>\n> > BIP:\n> > Title: Deterministic Entropy From BIP32 Keychains\n> > Author: Ethan Kosakovsky ethankosakovsky at protonmail.com\n> > Comments-Summary: No comments yet.\n> > Comments-URI:\n> > Status: Proposed\n> > Type: Standards Track\n> > Created: 2020-03-20\n> > License: BSD-2-Clause\n> > OPL\n> > </pre>\n> > \n> > ==Abstract==\n> > \n> > This proposal provides a way to derive entropy from a HD keychain\n> > path in order to deterministically derive the initial entropy used\n> > to create keychain mnemonics and seeds.\n> > \n> > ==Motivation==\n> > \n> > BIP32 uses some initial entropy as a seed to deterministically\n> > derive a BIP32 root for hierarchical deterministic keychains. BIP39\n> > introduced a method of encoding initial entropy into a mnemonic\n> > phrase which is used as input to a one way hash function in order\n> > to deterministically derive a BIP32 seed. The motivation behind\n> > mnemonic phrases was to make it easier for humans to backup and\n> > store offline. There are also other variations of this theme.\n> > \n> > The initial motivation of BIP32 was to make handling of large\n> > numbers of private keys easier to manage and backup, since you only\n> > need one BIP32 seed to cover all possible keys in the keychain. In\n> > practice however, due to various wallet implementations and\n> > security models, the average user may be faced with the need to\n> > handle an ever growing number of seeds/mnemonics. This is due to\n> > incompatible wallet standards, hardware wallets (HWW), seed formats\n> > and standards, as well as, the need to used a mix of hot and cold\n> > wallets depending on the application and environment.\n> > \n> > Examples would span wallets on mobile phones, online servers\n> > running protocols like Join Market or Lightning, and the difference\n> > between Electrum and BIP39 mnemonic seed formats. The reference\n> > implementation of Bitcoin Core uses BIP32, while other\n> > cryptocurrencies like Monero use different mnemonic encoding\n> > schemes.\n> > \n> > We must also consider the different variety of physical backups\n> > including paper, metal and other physical storage devices, as well\n> > as the potentially splitting backups across different geographical\n> > locations. This complexity may result in less care being taken with\n> > subsequently generated seeds for new wallets need to be stored and\n> > it ultimately results in less security. In reality, the idea of\n> > having \"one seed for all\" has proven to be more difficult in\n> > practice than originally thought.\n> > \n> > Since all these derivation schemes are deterministic based on some\n> > initial entropy, this proposal aims to solve the above problems by\n> > detailing a way to deterministically derive the initial entropy\n> > used for new root keychains using a single BIP32 style \"master root\n> > key\". This will allow one root key or mnemonic to derive any\n> > variety of different root keychains in whatever format is required\n> > (like BIP32 and BIP39 etc).\n> > \n> > ==Specification==\n> > \n> > Input starts with a BIP32 seed. Derivation scheme uses the format\n> > `m/83696968'/type'/index'` where `type` is the final seed type, and\n> > `index` in the key index of the hardened child private key.\n> > \n> > type\n> > \n> > bits\n> > \n> > output\n> > \n> > 0\n> > \n> > 128\n> > \n> > 12 word BIP39 mnemonic\n> > \n> > 1\n> > \n> > 256\n> > \n> > 24 word BIP39 mnemonic\n> > \n> > 2\n> > \n> > 128\n> > \n> > 12 word Electrum mnemonic\n> > \n> > 3\n> > \n> > 256\n> > \n> > 24 word Electrum mnemonic\n> > \n> > 4\n> > \n> > 256\n> > \n> > WIF for Bitcoin Core\n> > \n> > 5\n> > \n> > 256\n> > \n> > 25 word Monero mnemonic\n> > \n> > Entropy is calculated from the HMAC-SHA512(key=k, msg='bip-entropy-\n> > from-bip32') of the derived 32 byte private key (k). Entropy is\n> > taken from the result according to the number of bits required.\n> > This entropy can then be used as input to derive a mnemonic, wallet\n> > etc according to the`type` specified.\n> > \n> > ==Compatibility==\n> > \n> > In order to maintain the widest compatibility, the input to this\n> > function is a BIP32 seed, which may or may not have been derived\n> > from a BIP39 like mnemonic scheme. This maintains the original\n> > motivation that one backup can store any and all child derivation\n> > schemes depending on the user's preference or hardware signing\n> > devices. For example, devices that store the HD seed as a BIP39\n> > mnemonic, Electrum seed, or BIP32 root key would all be able to\n> > implement this standard.\n> > \n> > ==Discussion==\n> > \n> > This proposal could be split into multiple discrete BIPs in the\n> > same way that BIP32 described the derivation mechanics, BIP39 the\n> > input encoding with mnemonics, and the derivation paths like BIP44,\n> > BIP49 and BIP84. This has been avoided to reduce complexity. The\n> > resulting private key processed with HMAC-SHA512 and truncated as\n> > necessary. HMAC-SHA512 was chosen because it may have better\n> > compatibility in embedded devices as it's already required in\n> > devices supporting BIP32.\n> > \n> > ==Test Vectors==\n> > \n> > ===Test case 1===\n> > \n> > MASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind\n> > employ giant era attitude exit final oval one finger decorate pair\n> > useless super method float toddler dance\n> > MASTER BIP32 ROOT KEY:\n> > xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfG\n> > JNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp\n> > PATH: m/83696968'/0'/0'\n> > BITS REQUIRED: 128\n> > \n> > DERIVED CHILD\n> > WIF=L3cefeCHyo8jczVjckMxaiPBaPUunc3D8CsjRxYbYp3FhasGpsV3\n> > DERIVED CHILD\n> > k=bed343b04ba0216d9eeebff0366b61c4179d90d44b61c716ef6d568836ba4d23\n> > CHILD ENTROPY=6458698fae3578b48a64124ea3514e12\n> > CONVERT ENTROPY TO\n> > WIF=KwDiBf89QgGbjEhKnhXJuH7T2Vv72UKQA8KRkmNwVFS2znAS5xb9\n> > CHILD BIP39 MNEMONIC=gold select glue fragile fiscal fog civil\n> > liquid exchange box fatal caught\n> > CHILD BIP39\n> > SEED=2a2720e5590d4ec3140e51ba1b0b0a5183222c1668977c8a57572b0ea55d23\n> > 8cd8e899b3b1870e48894ca837e41e5d0db07554715efb21556fdde27f9f7ba153\n> > CHILD BIP32 ROOT\n> > KEY=xprv9s21ZrQH143K2ZH5qacptquLGvcYpHSNeyFVCU8Ur4u9kocajbBgcaCbHkG\n> > bwDsBR661H29F54j5mz14kwXbY9PZKdNRdjgRcGfshBK9XXb\n> > \n> > ===Test case 2===\n> > \n> > MASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind\n> > employ giant era attitude exit final oval one finger decorate pair\n> > useless super method float toddler dance\n> > MASTER BIP32 ROOT KEY:\n> > xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfG\n> > JNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp\n> > PATH: m/83696968'/1'/0'\n> > BITS REQUIRED: 256\n> > \n> > DERIVED CHILD\n> > WIF=L1zCbtnDWUN4vJA3De4sxmJnoRim57CQUuBb4KBoRNs2EMEq2Brg\n> > DERIVED CHILD\n> > k=8e3ca6054a6303f4a6a1bcbda6134c9802f4f0a0d76b0ee6b69b06b1e80b2192\n> > CHILD\n> > ENTROPY=ec4e2f7e2c3fca9a34fa29747bf8ba0ab7f05136f37e134e2457e9e5363\n> > 9670b\n> > CONVERT ENTROPY TO\n> > WIF=L594JSCygt2wBaB9mCpXjiLkkxkEojpBdNXG8UrrdLd2LvPBRMUs\n> > CHILD BIP39 MNEMONIC=unable imitate test flash witness escape\n> > stadium early inner thank company betray lecture chuckle swift hurt\n> > battle illness bicycle stable fat bronze order high\n> > CHILD BIP39\n> > SEED=73509b0e847ee66bddeb098a55063d73e8c6dd5f1c1db6969c668bb54c19bd\n> > e6eae8acc29a81118d1d9719fa1bc620fee7edd7c15a17bcaf70b0fdfc0c0c3803\n> > CHILD BIP32 ROOT\n> > KEY=xprv9s21ZrQH143K4PfLyyjYLVmKbnUTNFK6Y7jPKWfRZB3iSw1Gy9qowEzkYHf\n> > etVabfmjHEEPrcTJbh7chae33Sm9uAjuXzhSL6Li8dcwM9Bm\n> > \n> > ===Test case 3===\n> > \n> > MASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind\n> > employ giant era attitude exit final oval one finger decorate pair\n> > useless super method float toddler dance\n> > MASTER BIP32 ROOT KEY:\n> > xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfG\n> > JNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp\n> > PATH: m/83696968'/4'/0'\n> > BITS REQUIRED: 256\n> > \n> > DERIVED CHILD\n> > WIF=KwdD5PYnCU3xQDfFJ6XBf6UDaLrTUxrKmBpdjRuuavWyqAQtpaA2\n> > DERIVED CHILD\n> > k=0c169ce2c17bea08512a7519769e365242a1562bd63c4c903daef516000efbf2\n> > CHILD\n> > ENTROPY=25573247f8a76799f7abc086b9286b5a7ccb03cb8d3550f48ac1e71d908\n> > 32974\n> > CONVERT ENTROPY TO\n> > WIF=KxUJ8VzMk7uWDEcwYjLRzRMGE6sSpwCfQxkE9GEwAvXhFSDNba9G\n> > CHILD BIP39 MNEMONIC=census ridge music vanish island smooth team\n> > job mammal sing bracket reject smile limit comfort pluck extend\n> > picture race soda suit dose place obtain\n> > CHILD BIP39\n> > SEED=4e5c82be6455ecf0884d9475435e29a9afb9acf70b07296d7e5039c866e4d5\n> > 4647706918b9d14909dfbd7071a4b7aee8a4ad0ac2bf48f0a09a8899dd28564418\n> > CHILD BIP32 ROOT\n> > KEY=xprv9s21ZrQH143K2kekJsK9V6t4ZKwHkY1Q3umxuaAhdZKGxCMpHiddLdYUQBo\n> > ynszpwnk5upoC788LiT5MZ5q1vUABXG7AMyZK5UjD9iyL7Am\n> > \n> > ==References==\n> > \n> > BIP32, BIP39\n> > \n> > ==Copyright==\n> > \n> > This BIP is dual-licensed under the Open Publication License and\n> > BSD 2-clause license.\n> > \n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Adam Back",
                "date": "2020-03-25T13:54:18",
                "message_text_only": "I think the point is to use this proposed extension/standard for a\nkind of \"seed management\" function, set it up on an offline device (an\nalways offline laptop, or a modified hardware wallet) where you put\nthe master seed.  And then you use this as a kind of seed manager and\ntranscript the seeds for different sub-wallets into the respective\nwallets as BIP39 mnemonics.\n\nSo I do not think it needs any changes from existing wallet authors,\nas the interaction point is a bip 39 seed, which they mostly know how\nto use.  Indeed if you were to modify an existing wallet to accept the\nmaster seed from seed management scheme and derive the seed it needs\non each wallet, then that would create a weakest link in the chain\nrisk - if that wallet was insecure, or compromised then all other\nderived seeds would be also and you want independence for each wallet.\n\nI do think that this use case is a practical problem for people\nmanaging multiple seeds for various wallets in a bitcoin business\nsetting or even power users - you lose the single backup design,\nbecause it's too cumbersome to create fresh backups for each of\nmultiple wallets, especially distributed , fireproof cryptosteel etc\nbackups and so in practice for multi wallet scenarios probably they\nare not all full backed up or not backed up as robustly (not as\ngeo-redundant, fireproof, secret-shared etc).\n\nAdam\n\nOn Tue, 24 Mar 2020 at 09:32, Tim Ruffing via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> I think your proposal is simply to use BIP32 for all derivations and\n> the observation that you can work with derived keys with the\n> corresponding suffixes of the path. I believe that this is a good idea.\n>\n> But I don't think that simply writing a standard will help. It's just\n> one step. If all your wallets support incompatible formats, we should\n> work on fixing this because that's the root of the issue. Otherwise you\n> end up converting keys back and forth manually (as Chris pointed out),\n> and this can't be the goal.\n>\n> But then you need to reach out to wallet devs explicitly and get them\n> involved in creating the standard. Otherwise they won't use it. That's\n> a hard process, and it's even harder to make sure that the resulting\n> proposal isn't way too complex because everyone brings their special\n> case to the table.\n>\n> Tim\n>\n> On Sun, 2020-03-22 at 11:58 +0000, Ethan Kosakovsky via bitcoin-dev\n> wrote:\n> > I have completely revised the wording of this proposal I hope to be\n> > clearer in explaining the motivation and methodology.\n> >\n> > https://gist.github.com/ethankosakovsky/268c52f018b94bea29a6e809381c05d6\n> >\n> > Ethan\n> >\n> > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> > On Friday, March 20, 2020 4:44 PM, Ethan Kosakovsky via bitcoin-dev <\n> > bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> > > I would like to present a proposal for discussion and peer review.\n> > > It aims to solve the problem of \"too many seeds and too many\n> > > backups\" due to the many reasons stipulated in the proposal text.\n> > >\n> > > https://gist.githubusercontent.com/ethankosakovsky/f7d148f588d14e0bb4f70bb6afc509d0/raw/6da51e837b0e1f1b2b21f3d4cbc2c5a87969ffd5/bip-entropy-from-bip32.mediawiki\n> > >\n> > > <pre>\n> > > BIP:\n> > > Title: Deterministic Entropy From BIP32 Keychains\n> > > Author: Ethan Kosakovsky ethankosakovsky at protonmail.com\n> > > Comments-Summary: No comments yet.\n> > > Comments-URI:\n> > > Status: Proposed\n> > > Type: Standards Track\n> > > Created: 2020-03-20\n> > > License: BSD-2-Clause\n> > > OPL\n> > > </pre>\n> > >\n> > > ==Abstract==\n> > >\n> > > This proposal provides a way to derive entropy from a HD keychain\n> > > path in order to deterministically derive the initial entropy used\n> > > to create keychain mnemonics and seeds.\n> > >\n> > > ==Motivation==\n> > >\n> > > BIP32 uses some initial entropy as a seed to deterministically\n> > > derive a BIP32 root for hierarchical deterministic keychains. BIP39\n> > > introduced a method of encoding initial entropy into a mnemonic\n> > > phrase which is used as input to a one way hash function in order\n> > > to deterministically derive a BIP32 seed. The motivation behind\n> > > mnemonic phrases was to make it easier for humans to backup and\n> > > store offline. There are also other variations of this theme.\n> > >\n> > > The initial motivation of BIP32 was to make handling of large\n> > > numbers of private keys easier to manage and backup, since you only\n> > > need one BIP32 seed to cover all possible keys in the keychain. In\n> > > practice however, due to various wallet implementations and\n> > > security models, the average user may be faced with the need to\n> > > handle an ever growing number of seeds/mnemonics. This is due to\n> > > incompatible wallet standards, hardware wallets (HWW), seed formats\n> > > and standards, as well as, the need to used a mix of hot and cold\n> > > wallets depending on the application and environment.\n> > >\n> > > Examples would span wallets on mobile phones, online servers\n> > > running protocols like Join Market or Lightning, and the difference\n> > > between Electrum and BIP39 mnemonic seed formats. The reference\n> > > implementation of Bitcoin Core uses BIP32, while other\n> > > cryptocurrencies like Monero use different mnemonic encoding\n> > > schemes.\n> > >\n> > > We must also consider the different variety of physical backups\n> > > including paper, metal and other physical storage devices, as well\n> > > as the potentially splitting backups across different geographical\n> > > locations. This complexity may result in less care being taken with\n> > > subsequently generated seeds for new wallets need to be stored and\n> > > it ultimately results in less security. In reality, the idea of\n> > > having \"one seed for all\" has proven to be more difficult in\n> > > practice than originally thought.\n> > >\n> > > Since all these derivation schemes are deterministic based on some\n> > > initial entropy, this proposal aims to solve the above problems by\n> > > detailing a way to deterministically derive the initial entropy\n> > > used for new root keychains using a single BIP32 style \"master root\n> > > key\". This will allow one root key or mnemonic to derive any\n> > > variety of different root keychains in whatever format is required\n> > > (like BIP32 and BIP39 etc).\n> > >\n> > > ==Specification==\n> > >\n> > > Input starts with a BIP32 seed. Derivation scheme uses the format\n> > > `m/83696968'/type'/index'` where `type` is the final seed type, and\n> > > `index` in the key index of the hardened child private key.\n> > >\n> > > type\n> > >\n> > > bits\n> > >\n> > > output\n> > >\n> > > 0\n> > >\n> > > 128\n> > >\n> > > 12 word BIP39 mnemonic\n> > >\n> > > 1\n> > >\n> > > 256\n> > >\n> > > 24 word BIP39 mnemonic\n> > >\n> > > 2\n> > >\n> > > 128\n> > >\n> > > 12 word Electrum mnemonic\n> > >\n> > > 3\n> > >\n> > > 256\n> > >\n> > > 24 word Electrum mnemonic\n> > >\n> > > 4\n> > >\n> > > 256\n> > >\n> > > WIF for Bitcoin Core\n> > >\n> > > 5\n> > >\n> > > 256\n> > >\n> > > 25 word Monero mnemonic\n> > >\n> > > Entropy is calculated from the HMAC-SHA512(key=k, msg='bip-entropy-\n> > > from-bip32') of the derived 32 byte private key (k). Entropy is\n> > > taken from the result according to the number of bits required.\n> > > This entropy can then be used as input to derive a mnemonic, wallet\n> > > etc according to the`type` specified.\n> > >\n> > > ==Compatibility==\n> > >\n> > > In order to maintain the widest compatibility, the input to this\n> > > function is a BIP32 seed, which may or may not have been derived\n> > > from a BIP39 like mnemonic scheme. This maintains the original\n> > > motivation that one backup can store any and all child derivation\n> > > schemes depending on the user's preference or hardware signing\n> > > devices. For example, devices that store the HD seed as a BIP39\n> > > mnemonic, Electrum seed, or BIP32 root key would all be able to\n> > > implement this standard.\n> > >\n> > > ==Discussion==\n> > >\n> > > This proposal could be split into multiple discrete BIPs in the\n> > > same way that BIP32 described the derivation mechanics, BIP39 the\n> > > input encoding with mnemonics, and the derivation paths like BIP44,\n> > > BIP49 and BIP84. This has been avoided to reduce complexity. The\n> > > resulting private key processed with HMAC-SHA512 and truncated as\n> > > necessary. HMAC-SHA512 was chosen because it may have better\n> > > compatibility in embedded devices as it's already required in\n> > > devices supporting BIP32.\n> > >\n> > > ==Test Vectors==\n> > >\n> > > ===Test case 1===\n> > >\n> > > MASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind\n> > > employ giant era attitude exit final oval one finger decorate pair\n> > > useless super method float toddler dance\n> > > MASTER BIP32 ROOT KEY:\n> > > xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfG\n> > > JNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp\n> > > PATH: m/83696968'/0'/0'\n> > > BITS REQUIRED: 128\n> > >\n> > > DERIVED CHILD\n> > > WIF=L3cefeCHyo8jczVjckMxaiPBaPUunc3D8CsjRxYbYp3FhasGpsV3\n> > > DERIVED CHILD\n> > > k=bed343b04ba0216d9eeebff0366b61c4179d90d44b61c716ef6d568836ba4d23\n> > > CHILD ENTROPY=6458698fae3578b48a64124ea3514e12\n> > > CONVERT ENTROPY TO\n> > > WIF=KwDiBf89QgGbjEhKnhXJuH7T2Vv72UKQA8KRkmNwVFS2znAS5xb9\n> > > CHILD BIP39 MNEMONIC=gold select glue fragile fiscal fog civil\n> > > liquid exchange box fatal caught\n> > > CHILD BIP39\n> > > SEED=2a2720e5590d4ec3140e51ba1b0b0a5183222c1668977c8a57572b0ea55d23\n> > > 8cd8e899b3b1870e48894ca837e41e5d0db07554715efb21556fdde27f9f7ba153\n> > > CHILD BIP32 ROOT\n> > > KEY=xprv9s21ZrQH143K2ZH5qacptquLGvcYpHSNeyFVCU8Ur4u9kocajbBgcaCbHkG\n> > > bwDsBR661H29F54j5mz14kwXbY9PZKdNRdjgRcGfshBK9XXb\n> > >\n> > > ===Test case 2===\n> > >\n> > > MASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind\n> > > employ giant era attitude exit final oval one finger decorate pair\n> > > useless super method float toddler dance\n> > > MASTER BIP32 ROOT KEY:\n> > > xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfG\n> > > JNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp\n> > > PATH: m/83696968'/1'/0'\n> > > BITS REQUIRED: 256\n> > >\n> > > DERIVED CHILD\n> > > WIF=L1zCbtnDWUN4vJA3De4sxmJnoRim57CQUuBb4KBoRNs2EMEq2Brg\n> > > DERIVED CHILD\n> > > k=8e3ca6054a6303f4a6a1bcbda6134c9802f4f0a0d76b0ee6b69b06b1e80b2192\n> > > CHILD\n> > > ENTROPY=ec4e2f7e2c3fca9a34fa29747bf8ba0ab7f05136f37e134e2457e9e5363\n> > > 9670b\n> > > CONVERT ENTROPY TO\n> > > WIF=L594JSCygt2wBaB9mCpXjiLkkxkEojpBdNXG8UrrdLd2LvPBRMUs\n> > > CHILD BIP39 MNEMONIC=unable imitate test flash witness escape\n> > > stadium early inner thank company betray lecture chuckle swift hurt\n> > > battle illness bicycle stable fat bronze order high\n> > > CHILD BIP39\n> > > SEED=73509b0e847ee66bddeb098a55063d73e8c6dd5f1c1db6969c668bb54c19bd\n> > > e6eae8acc29a81118d1d9719fa1bc620fee7edd7c15a17bcaf70b0fdfc0c0c3803\n> > > CHILD BIP32 ROOT\n> > > KEY=xprv9s21ZrQH143K4PfLyyjYLVmKbnUTNFK6Y7jPKWfRZB3iSw1Gy9qowEzkYHf\n> > > etVabfmjHEEPrcTJbh7chae33Sm9uAjuXzhSL6Li8dcwM9Bm\n> > >\n> > > ===Test case 3===\n> > >\n> > > MASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind\n> > > employ giant era attitude exit final oval one finger decorate pair\n> > > useless super method float toddler dance\n> > > MASTER BIP32 ROOT KEY:\n> > > xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfG\n> > > JNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp\n> > > PATH: m/83696968'/4'/0'\n> > > BITS REQUIRED: 256\n> > >\n> > > DERIVED CHILD\n> > > WIF=KwdD5PYnCU3xQDfFJ6XBf6UDaLrTUxrKmBpdjRuuavWyqAQtpaA2\n> > > DERIVED CHILD\n> > > k=0c169ce2c17bea08512a7519769e365242a1562bd63c4c903daef516000efbf2\n> > > CHILD\n> > > ENTROPY=25573247f8a76799f7abc086b9286b5a7ccb03cb8d3550f48ac1e71d908\n> > > 32974\n> > > CONVERT ENTROPY TO\n> > > WIF=KxUJ8VzMk7uWDEcwYjLRzRMGE6sSpwCfQxkE9GEwAvXhFSDNba9G\n> > > CHILD BIP39 MNEMONIC=census ridge music vanish island smooth team\n> > > job mammal sing bracket reject smile limit comfort pluck extend\n> > > picture race soda suit dose place obtain\n> > > CHILD BIP39\n> > > SEED=4e5c82be6455ecf0884d9475435e29a9afb9acf70b07296d7e5039c866e4d5\n> > > 4647706918b9d14909dfbd7071a4b7aee8a4ad0ac2bf48f0a09a8899dd28564418\n> > > CHILD BIP32 ROOT\n> > > KEY=xprv9s21ZrQH143K2kekJsK9V6t4ZKwHkY1Q3umxuaAhdZKGxCMpHiddLdYUQBo\n> > > ynszpwnk5upoC788LiT5MZ5q1vUABXG7AMyZK5UjD9iyL7Am\n> > >\n> > > ==References==\n> > >\n> > > BIP32, BIP39\n> > >\n> > > ==Copyright==\n> > >\n> > > This BIP is dual-licensed under the Open Publication License and\n> > > BSD 2-clause license.\n> > >\n> > > bitcoin-dev mailing list\n> > > bitcoin-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "RFC: Deterministic Entropy From BIP32 Keychains",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Christopher Allen",
                "Adam Back",
                "Pavol Rusnak",
                "Peter D. Gray",
                "Tim Ruffing",
                "Ethan Kosakovsky"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 62704
        }
    },
    {
        "title": "[bitcoin-dev] Block solving slowdown question/poll",
        "thread_messages": [
            {
                "author": "Dave Scotese",
                "date": "2020-03-21T18:40:24",
                "message_text_only": "It seems that many on this list think deeply enough to imagine the scenario\nwhere we have  few days left before a difficulty adjustment comes up but we\nalso see mining power dropping off at a rate that suggests the few days\nmight become a few weeks, and then, possibly, a few months or even the\nunthinkable, a few eons.  I'm curious to know if anyone has ideas on how\nthis might be handled because I'm sure we're not going to let it happen.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200321/ba94cdf9/attachment-0001.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2020-03-22T07:54:15",
                "message_text_only": "On Sat, Mar 21, 2020 at 11:40:24AM -0700, Dave Scotese via bitcoin-dev wrote:\n> [Imagine] we also see mining power dropping off at a rate that\n> suggests the few days [until retarget] might become a few weeks, and\n> then, possibly, a few months or even the unthinkable, a few eons.  I'm\n> curious to know if anyone has ideas on how this might be handled\n\nThere are only two practical solutions I'm aware of:\n\n1. Do nothing\n2. Hard fork a difficulty reduction\n\nIf bitcoins retain even a small fraction of their value compared to the\nprevious retarget period and if most mining equipment is still available\nfor operation, then doing nothing is probably the best choice---as block\nspace becomes scarcer, transaction feerates will increase and miners\nwill be incentivized to increase their block production rate.\n\nIf the bitcoin price has plummeted more than, say, 99% in two weeks\nwith no hope of short-term recovery or if a large fraction of mining\nequipment has become unusable (again, say, 99% in two weeks with no\nhope of short-term recovery), then it's probably worth Bitcoin users\ndiscussing a hard fork to reduce difficulty to a currently sustainable\nlevel.\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200322/12e12a70/attachment.sig>"
            },
            {
                "author": "LORD HIS EXCELLENCY JAMES HRMH",
                "date": "2020-03-22T11:58:33",
                "message_text_only": "There seems to be the real possibility that miners are simply trying to optimise mining profit by limiting the average hash rate during the retargeting, saving some electricity but poorly considering the overall situation where they give opportunity to other miners probably raising the hashrate for the next period. It is far more profitable for the ecosystem considering the whole to hold a lottery for minig as has been discussed elsewhere some time ago.\n\nRegards,\nLORD HIS EXCELLENCY JAMES HRMH\n\n\n________________________________\nFrom: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of David A. Harding via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nSent: Sunday, 22 March 2020 6:54 PM\nTo: Dave Scotese <dscotese at litmocracy.com>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>\nSubject: Re: [bitcoin-dev] Block solving slowdown question/poll\n\nOn Sat, Mar 21, 2020 at 11:40:24AM -0700, Dave Scotese via bitcoin-dev wrote:\n> [Imagine] we also see mining power dropping off at a rate that\n> suggests the few days [until retarget] might become a few weeks, and\n> then, possibly, a few months or even the unthinkable, a few eons.  I'm\n> curious to know if anyone has ideas on how this might be handled\n\nThere are only two practical solutions I'm aware of:\n\n1. Do nothing\n2. Hard fork a difficulty reduction\n\nIf bitcoins retain even a small fraction of their value compared to the\nprevious retarget period and if most mining equipment is still available\nfor operation, then doing nothing is probably the best choice---as block\nspace becomes scarcer, transaction feerates will increase and miners\nwill be incentivized to increase their block production rate.\n\nIf the bitcoin price has plummeted more than, say, 99% in two weeks\nwith no hope of short-term recovery or if a large fraction of mining\nequipment has become unusable (again, say, 99% in two weeks with no\nhope of short-term recovery), then it's probably worth Bitcoin users\ndiscussing a hard fork to reduce difficulty to a currently sustainable\nlevel.\n\n-Dave\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200322/f1e2fa82/attachment.html>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2020-03-22T16:54:19",
                "message_text_only": "Mining is a lottery.\n\ne\n\n> On Mar 22, 2020, at 07:10, LORD HIS EXCELLENCY JAMES HRMH via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \ufeff\n> There seems to be the real possibility that miners are simply trying to optimise mining profit by limiting the average hash rate during the retargeting, saving some electricity but poorly considering the overall situation where they give opportunity to other miners probably raising the hashrate for the next period. It is far more profitable for the ecosystem considering the whole to hold a lottery for minig as has been discussed elsewhere some time ago.\n> \n> Regards,\n> LORD HIS EXCELLENCY JAMES HRMH\n> \n> \n> From: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of David A. Harding via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> Sent: Sunday, 22 March 2020 6:54 PM\n> To: Dave Scotese <dscotese at litmocracy.com>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: Re: [bitcoin-dev] Block solving slowdown question/poll\n>  \n> On Sat, Mar 21, 2020 at 11:40:24AM -0700, Dave Scotese via bitcoin-dev wrote:\n> > [Imagine] we also see mining power dropping off at a rate that\n> > suggests the few days [until retarget] might become a few weeks, and\n> > then, possibly, a few months or even the unthinkable, a few eons.  I'm\n> > curious to know if anyone has ideas on how this might be handled\n> \n> There are only two practical solutions I'm aware of:\n> \n> 1. Do nothing\n> 2. Hard fork a difficulty reduction\n> \n> If bitcoins retain even a small fraction of their value compared to the\n> previous retarget period and if most mining equipment is still available\n> for operation, then doing nothing is probably the best choice---as block\n> space becomes scarcer, transaction feerates will increase and miners\n> will be incentivized to increase their block production rate.\n> \n> If the bitcoin price has plummeted more than, say, 99% in two weeks\n> with no hope of short-term recovery or if a large fraction of mining\n> equipment has become unusable (again, say, 99% in two weeks with no\n> hope of short-term recovery), then it's probably worth Bitcoin users\n> discussing a hard fork to reduce difficulty to a currently sustainable\n> level.\n> \n> -Dave\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200322/25b0e225/attachment.html>"
            },
            {
                "author": "Dave Scotese",
                "date": "2020-03-22T18:17:26",
                "message_text_only": "The software currently allows up to a two hour difference between the\nsystem clock and the time implied by a fresh block's timestamp (if I\nremember correctly).  This reliance on realtime system clocks can be used\nin a much weaker form to justify a plan for a difficulty adjustment to be\nbuilt into the software for when the expected block production rate is far\nenough behind its expected value.\n\nWe would have to agree on how far behind mining should be to justify\nexpediting the adjustment.  The sooner we decide on and implement this\nsecond difficulty adjustment trigger, the better.  It cuts off a nightmare\nscenario made possible by collusion between states through regulation and\nfiat, as well as any other external factors.  I propose that miners\ndetecting that the expected 2016 blocks have not been mined after twice the\nexpected wait time (4032 * 10 minutes = 28 days) ought to signal their\nrecognition in any block they produce, to be rejected by any miner whose\nclock disagrees (after taking into account the 2-hour leeway), and that any\nblock produced on top of one with such a signal should reflect an expedited\ndifficulty adjustment (and also include the signal), which is then in\neffect for the rest of the 2016 blocks and the entire following difficulty\nperiod.  Every block from there until the modulo 2016 block should have the\nsame signal, which not only indicates that a difficulty adjustment was\nexpedited, but also that the next modulo 2016 block should not make one,\nbut rather turn off the signal.\n\nIf anyone thinks it's a good enough idea for a BIP, I will consider writing\none unless someone else wants to.\n\nDave.\n\nOn Sun, Mar 22, 2020 at 9:54 AM Eric Voskuil via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Mining is a lottery.\n>\n> e\n>\n> On Mar 22, 2020, at 07:10, LORD HIS EXCELLENCY JAMES HRMH via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> \ufeff\n> There seems to be the real possibility that miners are simply trying to\n> optimise mining profit by limiting the average hash rate during the\n> retargeting, saving some electricity but poorly considering the overall\n> situation where they give opportunity to other miners probably raising the\n> hashrate for the next period. It is far more profitable for the ecosystem\n> considering the whole to hold a lottery for minig as has been discussed\n> elsewhere some time ago.\n>\n> Regards,\n> LORD HIS EXCELLENCY JAMES HRMH\n>\n>\n> ------------------------------\n> *From:* bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> on\n> behalf of David A. Harding via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org>\n> *Sent:* Sunday, 22 March 2020 6:54 PM\n> *To:* Dave Scotese <dscotese at litmocracy.com>; Bitcoin Protocol Discussion\n> <bitcoin-dev at lists.linuxfoundation.org>\n> *Subject:* Re: [bitcoin-dev] Block solving slowdown question/poll\n>\n> On Sat, Mar 21, 2020 at 11:40:24AM -0700, Dave Scotese via bitcoin-dev\n> wrote:\n> > [Imagine] we also see mining power dropping off at a rate that\n> > suggests the few days [until retarget] might become a few weeks, and\n> > then, possibly, a few months or even the unthinkable, a few eons.  I'm\n> > curious to know if anyone has ideas on how this might be handled\n>\n> There are only two practical solutions I'm aware of:\n>\n> 1. Do nothing\n> 2. Hard fork a difficulty reduction\n>\n> If bitcoins retain even a small fraction of their value compared to the\n> previous retarget period and if most mining equipment is still available\n> for operation, then doing nothing is probably the best choice---as block\n> space becomes scarcer, transaction feerates will increase and miners\n> will be incentivized to increase their block production rate.\n>\n> If the bitcoin price has plummeted more than, say, 99% in two weeks\n> with no hope of short-term recovery or if a large fraction of mining\n> equipment has become unusable (again, say, 99% in two weeks with no\n> hope of short-term recovery), then it's probably worth Bitcoin users\n> discussing a hard fork to reduce difficulty to a currently sustainable\n> level.\n>\n> -Dave\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n-- \nI like to provide some work at no charge to prove my value. Do you need a\ntechie?\nI own Litmocracy <http://www.litmocracy.com> and Meme Racing\n<http://www.memeracing.net> (in alpha).\nI'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which\nnow accepts Bitcoin.\nI also code for The Dollar Vigilante <http://dollarvigilante.com/>.\n\"He ought to find it more profitable to play by the rules\" - Satoshi\nNakamoto\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200322/dde91e34/attachment-0001.html>"
            },
            {
                "author": "Andrew Cann",
                "date": "2020-03-23T12:59:22",
                "message_text_only": "Hi, noob question here: Is there a long-term plan for if the block reward drops\ntoo low to ensure the security of the network?\n\nIIUC miners only make profit from block rewards and transaction fees, and once\nthe block reward drop to zero we're merely hoping that transaction fees will\nkeep mining expensive enough to stop a state actor or someone from buying\nenough hash power to attack the network. If that's the case, should we start\nmaking plans now to change the protocol to allow an adjustable block reward?\n\nHere's a half-baked idea I had of how that could work: Since the block reward\ndilutes the value of the currency bitcoin holders have an incentive to keep the\nreward low. However, since the block reward is also (partly) what incentivizes\nmining, bitcoin holders also have an incentive to keep the reward high enough\nto keep the network secure. So if bitcoin holders were able to vote to decide\nthe block reward they \"should\", hypothetically, reliably choose a value that\nbalances these two concerns. You could implement this voting by adding an\noptional extra field to every txout that signals what the holder thinks the\ninflation rate should be. If the field is missing you just assume the default\nvalue based on the current protocol. Then, whenever a new block is mined, you\ntake the median inflation rate of all the pre-existing utxos, weighted by the\nutxo value, to calculate the block's reward.\n\nIs this idea fundamentally broken somehow? Or are there already better ideas\nfor how to tackle this problem (I don't follow this list very closely)? Or is\nthis actually a non-issue to start with?\n\n - Andrew\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200323/fa0d5a7c/attachment.sig>"
            },
            {
                "author": "Dave Scotese",
                "date": "2020-03-23T18:39:05",
                "message_text_only": "I believe this isn't something we need to address.  The fact is that every\nbyte stored in the blockchain is already valuable to everyone who downloads\nthe blockchain because of what it allows them to prove - by adding more\nbytes to it.  Over time, the value per byte will increase.  Perhaps there\nwill be holding companies with specialized scripts that cost $500 - $1000\nto add to the blockchain and allow those companies to handle transactions\nfor thousands of customers, kind of like a community lightning channel.\n\nAnyway, yes, your idea is fundamentally broken because a zero block reward\nhappens because creating even one more satoshi will push the amount of\nbitcoin over 21,000,0000, breaking the meaning of \"bitcoin,\" or, if you\nlike, creating a fundamental contradiction in our use of the term.\n\nOn Mon, Mar 23, 2020 at 5:59 AM Andrew Cann <shum at canndrew.org> wrote:\n\n> Hi, noob question here: Is there a long-term plan for if the block reward\n> drops\n> too low to ensure the security of the network?\n>\n> IIUC miners only make profit from block rewards and transaction fees, and\n> once\n> the block reward drop to zero we're merely hoping that transaction fees\n> will\n> keep mining expensive enough to stop a state actor or someone from buying\n> enough hash power to attack the network. If that's the case, should we\n> start\n> making plans now to change the protocol to allow an adjustable block\n> reward?\n>\n> Here's a half-baked idea I had of how that could work: Since the block\n> reward\n> dilutes the value of the currency bitcoin holders have an incentive to\n> keep the\n> reward low. However, since the block reward is also (partly) what\n> incentivizes\n> mining, bitcoin holders also have an incentive to keep the reward high\n> enough\n> to keep the network secure. So if bitcoin holders were able to vote to\n> decide\n> the block reward they \"should\", hypothetically, reliably choose a value\n> that\n> balances these two concerns. You could implement this voting by adding an\n> optional extra field to every txout that signals what the holder thinks the\n> inflation rate should be. If the field is missing you just assume the\n> default\n> value based on the current protocol. Then, whenever a new block is mined,\n> you\n> take the median inflation rate of all the pre-existing utxos, weighted by\n> the\n> utxo value, to calculate the block's reward.\n>\n> Is this idea fundamentally broken somehow? Or are there already better\n> ideas\n> for how to tackle this problem (I don't follow this list very closely)? Or\n> is\n> this actually a non-issue to start with?\n>\n>  - Andrew\n>\n>\n\n-- \nI like to provide some work at no charge to prove my value. Do you need a\ntechie?\nI own Litmocracy <http://www.litmocracy.com> and Meme Racing\n<http://www.memeracing.net> (in alpha).\nI'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which\nnow accepts Bitcoin.\nI also code for The Dollar Vigilante <http://dollarvigilante.com/>.\n\"He ought to find it more profitable to play by the rules\" - Satoshi\nNakamoto\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200323/f83f9d48/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-03-24T07:42:46",
                "message_text_only": "Good morning Andrew,\n\n\n> > Hi, noob question here: Is there a long-term plan for if the block reward drops\n> > too low to ensure the security of the network?\n> >\n> > IIUC miners only make profit from block rewards and transaction fees, and once\n> > the block reward drop to zero we're merely hoping that transaction fees will\n> > keep mining expensive enough to stop a state actor or someone from buying\n> > enough hash power to attack the network. If that's the case, should we start\n> > making plans now to change the protocol to allow an adjustable block reward?\n> >\n> > Here's a half-baked idea I had of how that could work: Since the block reward\n> > dilutes the value of the currency bitcoin holders have an incentive to keep the\n> > reward low. However, since the block reward is also (partly) what incentivizes\n> > mining, bitcoin holders also have an incentive to keep the reward high enough\n> > to keep the network secure. So if bitcoin holders were able to vote to decide\n> > the block reward they \"should\", hypothetically, reliably choose a value that\n> > balances these two concerns.\n\nThey already do so, via an implicit \"field\", known as the transaction fee.\nThis is \"implicit\" since it is only the difference of the sum of all inputs with the sum of all outputs, but any Bitcoin HODLer spending their coins always need to make this decision.\n\nThis makes the vote for how much security is needed to be costly to the voter, which is appropriate: you pay for your security.\n\nThis mechanism is the same mechanism as well that is the long-term plan for the lowered block rewards in the future, and is already the best known idea to tackle this problem as well.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Andrew Cann",
                "date": "2020-03-25T15:23:02",
                "message_text_only": "Hi, thanks for the replies.\n\n> Anyway, yes, your idea is fundamentally broken because a zero block reward\n> happens because creating even one more satoshi will push the amount of\n> bitcoin over 21,000,0000, breaking the meaning of \"bitcoin,\" or, if you\n> like, creating a fundamental contradiction in our use of the term. \n\nI wouldn't really consider that fundamentally broken. It changes the meaning of\n\"bitcoin\", but so does every upgrade to the protocol. The worst problem I can\nsee with this is that there's probably a lot of software out there which\nassumes a cap of 21M. But we'd have years to find and fix those bugs.\n\n> They already do so, via an implicit \"field\", known as the transaction fee.\n> This makes the vote for how much security is needed to be costly to the\n> voter, which is appropriate: you pay for your security.\n\nThis isn't the same thing though, economically / game-theoretically speaking.\nTransaction fees are only paid when bitcoins get moved. There's no on-going\ncost for people holding bitcoins (assuming they're doing their day-to-day\ntransactions almost entirely off-chain, which is something that's only going to\nbecome more common). More to the point, the transaction fee is only set by the\ncurrent demand for block space. If transaction fees drop too low to maintain a\nsecure hash rate then people *could* willingly pay more than they need to to\nget their transactions mined, but it's unlikely they will since it'd be cheaper\nto just pay the minimum and hope that everyone else covers the costs of keeping\nthe network secure for them.\n\nWith the voting idea everyone decides what everyone pays (via dilution) to keep\nthe network secure. Choosing to signal a high inflation rate doesn't mean you\npay more than everyone else, just that you might shift the median, so there's\nno tragedy-of-the-commons problem. Also, votes are weighted by the value of\nthe utxo, so people both vote and pay in proportion to the amount of bitcoin\nthey're holding.\n\nDoes this make sense? Or is there some game-theoretic reason I'm not seeing for\nwhy transaction fees can never drop dangerously low in the first place?\n\n - Andrew\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200325/20997ba7/attachment.sig>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-03-26T01:42:22",
                "message_text_only": "Good morning Andrew,\n\n>\n> > Anyway, yes, your idea is fundamentally broken because a zero block reward\n> > happens because creating even one more satoshi will push the amount of\n> > bitcoin over 21,000,0000, breaking the meaning of \"bitcoin,\" or, if you\n> > like, creating a fundamental contradiction in our use of the term.\n>\n> I wouldn't really consider that fundamentally broken. It changes the meaning of\n> \"bitcoin\", but so does every upgrade to the protocol. The worst problem I can\n> see with this is that there's probably a lot of software out there which\n> assumes a cap of 21M. But we'd have years to find and fix those bugs.\n\nThere are changes of meaning, and then there are changes of meaning.\nSmaller changes that puny humans can understand are better than larger changes beyond the ken of mortal man.\nTo change the supply is far too big a change.\n\n> > They already do so, via an implicit \"field\", known as the transaction fee.\n> > This makes the vote for how much security is needed to be costly to the\n> > voter, which is appropriate: you pay for your security.\n>\n> This isn't the same thing though, economically / game-theoretically speaking.\n> Transaction fees are only paid when bitcoins get moved. There's no on-going\n> cost for people holding bitcoins (assuming they're doing their day-to-day\n> transactions almost entirely off-chain, which is something that's only going to\n> become more common). More to the point, the transaction fee is only set by the\n> current demand for block space. If transaction fees drop too low to maintain a\n> secure hash rate then people could willingly pay more than they need to to\n> get their transactions mined, but it's unlikely they will since it'd be cheaper\n> to just pay the minimum and hope that everyone else covers the costs of keeping\n> the network secure for them.\n>\n> With the voting idea everyone decides what everyone pays (via dilution) to keep\n> the network secure. Choosing to signal a high inflation rate doesn't mean you\n> pay more than everyone else, just that you might shift the median, so there's\n> no tragedy-of-the-commons problem. Also, votes are weighted by the value of\n> the utxo, so people both vote and pay in proportion to the amount of bitcoin\n> they're holding.\n>\n> Does this make sense? Or is there some game-theoretic reason I'm not seeing for\n> why transaction fees can never drop dangerously low in the first place?\n\nWhat happens if I own a few million Bitcoin and then accidentally lose my private keys in a tragic ear-cleaning accident?\n\nThen the vote of that UTXO containing a few million Bitcoins will remain forever fixed and unable to change according to whatever you believe would make us as a community decide to change the inflation rate.\n\nIf you enforce that only \"recently-created\" UTXOs get to vote, then in order for me to affect the vote (in the happy case where I do **not** lose all my privkeys in a tragic ear-cleaning accident), I would have to make a synthetic self-paying transaction.\nHow is it so different from me having to make up a synthetic transaction in order to pay fees and thus affect the current security of the blockchain?\n\n--\n\nIt is helpful to remember that as a UTXO gets buried deeper, its security is inevitably better, and once I have a sufficient level of security in my ownership of the coin, I will not particularly care about any improved security and will not be interested in paying for more, hence why should I support any fork which makes me pay for my security continuously when I can simply support a fork that retains the current supply and does *not* make me pay for continued security?\n\n--\n\nIf I want to *spend* my Bitcoins on something --- and nothing has value until I actually utilize it --- then I *will* pay transaction fees.\nThe receiver of the coin would want to ensure that the received UTXO is deeply buried to the point that it has sufficient security for the receiver, before releasing or providing me with whatever I am exchanging the coin for.\n\nThus, if I find that there are no miners at all, I could offer a high fee to get my transaction mined.\nOf course, you might say that this only pays for one block.\n\nBut in most cases I will have more value remaining beyond what I spend to the receiver, i.e. I have a change output from that transaction.\nIn such a case, I can  pay for more blocks by re-spending the change output to myself, paying a transaction fee each time, until the original transaction that spends to the receiver is deeply buried and the receiver credits it and then releases the product or service I am exchanging *for*.\nAlternately the receiver can do the same for its *own* UTXO, and will increase the payment it demands from me in order to perform this itself; thus I still end up paying for the security of the *transaction* and not the security of the *holding*.\n\nSo there is really no need for any mechanism beyond transaction fees.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Andrew Cann",
                "date": "2020-03-27T09:17:34",
                "message_text_only": "> To change the supply is far too big a change.\n\nIt would also be a big change if bitcoin became unusable due to mining profits\ndropping low enough for a state actor with a warehouse full of asics to mount a\n51% attack and mine empty blocks all day.\n\n> What happens if I own a few million Bitcoin and then accidentally lose my\n> private keys in a tragic ear-cleaning accident?\n> Then the vote of that UTXO containing a few million Bitcoins will remain\n> forever fixed and unable to change according to whatever you believe would\n> make us as a community decide to change the inflation rate.\n\nAll that matters is whether the long-term rate of deflation due to lost coins\nis less or greater than the rate of inflation. This determines whether the\nproportion of coins whose signaled inflation rate is fixed in time would tend\ntowards zero or one. I think it's /fairly/ safe to assume that it would remain\nless. People obviously have a pretty strong incentive to not lose their coins -\nparticularly people who are holding massive amounts of bitcoin - and as bitcoin\nbecomes more mainstream, regular users will necessarily be using forms of\nprotection against losing their coins (whatever they might be). Contrast this\nagainst the inflation rate which should remain high enough to prevent very\nwealthy entities from being able to mount a 51% attack. What proportion of the\ntotal market cap of bitcoin do you think your least favorite government could\nplausibly be willing to spend to take down bitcoin for a month? And do you\nthink it's less or greater than the proportion of all bitcoins that get lost in\na month?\n\n> It is helpful to remember that as a UTXO gets buried deeper, its security is\n> inevitably better, and once I have a sufficient level of security in my\n> ownership of the coin, I will not particularly care about any improved\n> security and will not be interested in paying for more.\n\nIf we're talking about the possibility of your coin becoming worthless because\nsomeone out there can unwind transactions at will and prevent you from spending\nit then you should definitely be interested.\n\n> If I want to *spend* my Bitcoins on something --- and nothing has value until\n> I actually utilize it --- then I *will* pay transaction fees. The receiver of\n> the coin would want to ensure that the received UTXO is deeply buried to the\n> point that it has sufficient security for the receiver, before releasing or\n> providing me with whatever I am exchanging the coin for.\n>\n> Thus, if I find that there are no miners at all, I could offer a high fee to\n> get my transaction mined. Of course, you might say that this only pays for\n> one block.\n>\n> But in most cases I will have more value remaining beyond what I spend to the\n> receiver, i.e. I have a change output from that transaction.\n>\n> In such a case, I can  pay for more blocks by re-spending the change output\n> to myself, paying a transaction fee each time, until the original transaction\n> that spends to the receiver is deeply buried and the receiver credits it and\n> then releases the product or service I am exchanging *for*. Alternately the\n> receiver can do the same for its *own* UTXO, and will increase the payment it\n> demands from me in order to perform this itself; thus I still end up paying\n> for the security of the *transaction* and not the security of the *holding*.\n\nIn your example though it's just you or the receiver paying for blocks. In that\ncase you're only paying for your own security and so there's no tragedy of the\ncommons and the system works. But once you have a thousand people putting\ntransactions in every block and everyone is collectively paying for everyone's\ncollective security then, without some mechanism to force everyone to pay their\nfair share, you're inviting Moloch to the party.\n\nHere's a better explanation than I could write of the phenomenon I'm talking\nabout:\n\n> As a thought experiment, let\u2019s consider aquaculture (fish farming) in a lake.\n> Imagine a lake with a thousand identical fish farms owned by a thousand\n> competing companies. Each fish farm earns a profit of $1000/month. For a\n> while, all is well.\n> \n> But each fish farm produces waste, which fouls the water in the lake. Let\u2019s\n> say each fish farm produces enough pollution to lower productivity in the\n> lake by $1/month.\n> \n> A thousand fish farms produce enough waste to lower productivity by\n> $1000/month, meaning none of the fish farms are making any money. Capitalism\n> to the rescue: someone invents a complex filtering system that removes waste\n> products. It costs $300/month to operate. All fish farms voluntarily install\n> it, the pollution ends, and the fish farms are now making a profit of\n> $700/month \u2013 still a respectable sum.\n> \n> But one farmer (let\u2019s call him Steve) gets tired of spending the money to\n> operate his filter. Now one fish farm worth of waste is polluting the lake,\n> lowering productivity by $1. Steve earns $999 profit, and everyone else earns\n> $699 profit.\n> \n> Everyone else sees Steve is much more profitable than they are, because he\u2019s\n> not spending the maintenance costs on his filter. They disconnect their\n> filters too.\n> \n> Once four hundred people disconnect their filters, Steve is earning\n> $600/month \u2013 less than he would be if he and everyone else had kept their\n> filters on! And the poor virtuous filter users are only making $300. Steve\n> goes around to everyone, saying \u201cWait! We all need to make a voluntary pact\n> to use filters! Otherwise, everyone\u2019s productivity goes down.\u201d\n> \n> Everyone agrees with him, and they all sign the Filter Pact, except one\n> person who is sort of a jerk. Let\u2019s call him Mike. Now everyone is back using\n> filters again, except Mike. Mike earns $999/month, and everyone else earns\n> $699/month. Slowly, people start thinking they too should be getting big\n> bucks like Mike, and disconnect their filter for $300 extra profit\u2026\n> \n> A self-interested person never has any incentive to use a filter. A\n> self-interested person has some incentive to sign a pact to make everyone use\n> a filter, but in many cases has a stronger incentive to wait for everyone\n> else to sign such a pact but opt out himself. This can lead to an undesirable\n> equilibrium in which no one will sign such a pact.\n\nWon't a thousand bitcoin-spenders, individually paying for their transactions\nbut collectively paying for their security, end up falling into the same\ndynamic?\n\n - Andrew\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200327/e6afc842/attachment.sig>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-03-28T02:12:37",
                "message_text_only": "Good morning Andrew,\n\n> Here's a better explanation than I could write of the phenomenon I'm talking\n> about:\n>\n> > As a thought experiment, let\u2019s consider aquaculture (fish farming) in a lake.\n> > Imagine a lake with a thousand identical fish farms owned by a thousand\n> > competing companies. Each fish farm earns a profit of $1000/month. For a\n> > while, all is well.\n> > But each fish farm produces waste, which fouls the water in the lake. Let\u2019s\n> > say each fish farm produces enough pollution to lower productivity in the\n> > lake by $1/month.\n> > A thousand fish farms produce enough waste to lower productivity by\n> > $1000/month, meaning none of the fish farms are making any money. Capitalism\n> > to the rescue: someone invents a complex filtering system that removes waste\n> > products. It costs $300/month to operate. All fish farms voluntarily install\n> > it, the pollution ends, and the fish farms are now making a profit of\n> > $700/month \u2013 still a respectable sum.\n> > But one farmer (let\u2019s call him Steve) gets tired of spending the money to\n> > operate his filter. Now one fish farm worth of waste is polluting the lake,\n> > lowering productivity by $1. Steve earns $999 profit, and everyone else earns\n> > $699 profit.\n> > Everyone else sees Steve is much more profitable than they are, because he\u2019s\n> > not spending the maintenance costs on his filter. They disconnect their\n> > filters too.\n> > Once four hundred people disconnect their filters, Steve is earning\n> > $600/month \u2013 less than he would be if he and everyone else had kept their\n> > filters on! And the poor virtuous filter users are only making $300. Steve\n> > goes around to everyone, saying \u201cWait! We all need to make a voluntary pact\n> > to use filters! Otherwise, everyone\u2019s productivity goes down.\u201d\n> > Everyone agrees with him, and they all sign the Filter Pact, except one\n> > person who is sort of a jerk. Let\u2019s call him Mike. Now everyone is back using\n> > filters again, except Mike. Mike earns $999/month, and everyone else earns\n> > $699/month. Slowly, people start thinking they too should be getting big\n> > bucks like Mike, and disconnect their filter for $300 extra profit\u2026\n> > A self-interested person never has any incentive to use a filter. A\n> > self-interested person has some incentive to sign a pact to make everyone use\n> > a filter, but in many cases has a stronger incentive to wait for everyone\n> > else to sign such a pact but opt out himself. This can lead to an undesirable\n> > equilibrium in which no one will sign such a pact.\n>\n> Won't a thousand bitcoin-spenders, individually paying for their transactions\n> but collectively paying for their security, end up falling into the same\n> dynamic?\n\nFortunately in our case, only the top 4,000,000 weight worth of transactions gets in a block.\nEvery bitcoin spender has an incentive to spend as little as possible to get into this top 4,000,000 weight and no more, but they still have to outbid every other user who wants the same security.\nSome bitcoin spender will then decide that overpaying slightly to ensure that they do not drop out of the top 4,000,000 weight even in case of a \"slow\" block.\n\nThus, there will always be a need for *some* block weight limit, and that is what ensures that miners can get paid.\n\nNow it was brought up earlier that people are moving transactions offchain, but that is perfectly fine, because every offchain mechanism first needs an onchain setup, and will at some point need an onchain teardown.\nThis allows increasing the effective capacity, while still ensuring that onchain fees remain at a level that will still ensure continued healthy operation of the blockchain layer.\nBasically, the offchain mechanism does not remove onchain fees, it only amortizes the onchain fees to multiple logical transactions.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Block solving slowdown question/poll",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Eric Voskuil",
                "LORD HIS EXCELLENCY JAMES HRMH",
                "Andrew Cann",
                "David A. Harding",
                "Dave Scotese",
                "ZmnSCPxj"
            ],
            "messages_count": 12,
            "total_messages_chars_count": 36725
        }
    },
    {
        "title": "[bitcoin-dev] Block solving slowdown",
        "thread_messages": [
            {
                "author": "Andrew Cann",
                "date": "2020-03-29T08:11:36",
                "message_text_only": "> Fortunately in our case, only the top 4,000,000 weight worth of transactions\n> gets in a block. Every bitcoin spender has an incentive to spend as little\n> as possible to get into this top 4,000,000 weight and no more, but they still\n> have to outbid every other user who wants the same security. Some bitcoin\n> spender will then decide that overpaying slightly to ensure that they do not\n> drop out of the top 4,000,000 weight even in case of a \"slow\" block.\n>\n> Thus, there will always be a need for *some* block weight limit, and that is\n> what ensures that miners can get paid.\n\nYes, but how does this ensure that miners get paid *enough*? Every individual\nmaking a transaction needs the miners to get paid enough for the transaction to\nbe meaningful, but they each individually only have the incentive to pay the\nmarket rate for block space which is set purely by supply and demand.\n\nIt's the same as the fish farming analogy. Everyone making a transaction could\ncollectively decide how much miners need to get paid and agree to split the\ncosts. But then each individual has the incentive to renege on the agreement\nand only pay the minimum they need to get their transaction included in the\nblock while everyone else pays for the transaction's security. My voting idea\nis one potential way they could break the Nash equilibrium.\n\n> Now it was brought up earlier that people are moving transactions offchain,\n> but that is perfectly fine, because every offchain mechanism first needs an\n> onchain setup, and will at some point need an onchain teardown. This\n> allows increasing the effective capacity, while still ensuring that onchain\n> fees remain at a level that will still ensure continued healthy operation of\n> the blockchain layer. Basically, the offchain mechanism does not remove\n> onchain fees, it only amortizes the onchain fees to multiple logical\n> transactions.\n\nI concede that every bitcoin user pays transaction fees, if not directly then\nindirectly, so whether miners get paid through transaction fees or a block\nreward is irrelevant. My concern is that moving things off-chain reduces the\ntransaction fees by reducing demand for block-space and that this could cause\nminer revenue to drop lower than what's required to keep the network secure.\n\nIs there any good reason to think this won't happen?\n\n - Andrew\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200329/5473ae9a/attachment.sig>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-03-30T02:59:52",
                "message_text_only": "Good morning Andrew,\n\n> > Fortunately in our case, only the top 4,000,000 weight worth of transactions\n> > gets in a block. Every bitcoin spender has an incentive to spend as little\n> > as possible to get into this top 4,000,000 weight and no more, but they still\n> > have to outbid every other user who wants the same security. Some bitcoin\n> > spender will then decide that overpaying slightly to ensure that they do not\n> > drop out of the top 4,000,000 weight even in case of a \"slow\" block.\n> > Thus, there will always be a need for some block weight limit, and that is\n> > what ensures that miners can get paid.\n>\n> Yes, but how does this ensure that miners get paidenough? Every individual\n> making a transaction needs the miners to get paid enough for the transaction to\n> be meaningful, but they each individually only have the incentive to pay the\n> market rate for block space which is set purely by supply and demand.\n\nIf your coins have no security, you cannot use them safely.\nIf you assign value to something, you will want to ensure some amount of protection to that something, proportional to the value you assign the something\n\nBy forcing a competition for limited block space, Bitcoin forces users to honestly assess how much security they are willing to pay for.\n\n> It's the same as the fish farming analogy. Everyone making a transaction could\n> collectively decide how much miners need to get paid and agree to split the\n> costs. But then each individual has the incentive to renege on the agreement\n> and only pay the minimum they need to get their transaction included in the\n> block while everyone else pays for the transaction's security. My voting idea\n> is one potential way they could break the Nash equilibrium.\n\nSuppose everybody \"agrees\" to a reasonable fee level.\nThey divide up the block space among themselves and assign a fee.\n\nThen suddenly one of the participants realizes they actually have to have a transaction added, but the block space they already agreed to use is not sufficient to fit.\nSince their agreement is just ink on a page, this participant spins up a new Bitcoin non-full node, connects to the Bitcoin network over TOR, then broadcasts the extra transaction with a higher feerate.\nThis evicts one of the transactions in the next block (which could also be one that this cheating participant wants, but let us say that this sudden new transaction is even more important than the others it currently has allocated for the next block).\n\nThe other participants now have a risk that their transaction does not get included in the block.\nEach one then re-assesses their security and timeliness requirements, and can then decide to bump their fee using RBF, if that is necessary.\n\nThis competition will then stabilize when each participant decides that the added fee to ensure their inclusion in the next block is too high for their security and timeliness requirements, and the risk they do not get their transaction confirmed is acceptable to them given the cost of getting their transaction confirmed.\n\nAll of the above is already how Bitcoin works today.\n\nThat is the only mechanism necessary, or even possible.\n\nAlways remember that any voting scheme always implicitly has an extra option called \"all the options suck so I will not vote\".\nIn this context, this implies that people can just sell their coins and forget the whole system, rather than deal with a mechanism which ensures that coins they own are always devalued continuously by others voting for devaluation.\nThey can sell it for a coin where their held coins are not devalued by policy, i.e. your mechanism will never have widespread support necessary for reliably forking the chain.\n\n>\n> > Now it was brought up earlier that people are moving transactions offchain,\n> > but that is perfectly fine, because every offchain mechanism first needs an\n> > onchain setup, and will at some point need an onchain teardown. This\n> > allows increasing the effective capacity, while still ensuring that onchain\n> > fees remain at a level that will still ensure continued healthy operation of\n> > the blockchain layer. Basically, the offchain mechanism does not remove\n> > onchain fees, it only amortizes the onchain fees to multiple logical\n> > transactions.\n>\n> I concede that every bitcoin user pays transaction fees, if not directly then\n> indirectly, so whether miners get paid through transaction fees or a block\n> reward is irrelevant. My concern is that moving things off-chain reduces the\n> transaction fees by reducing demand for block-space and that this could cause\n> miner revenue to drop lower than what's required to keep the network secure.\n>\n> Is there any good reason to think this won't happen?\n\nDeath.\n\nNo Lightning node will last forever, and its channels will be eventually be closed.\nThan, any onchain funds will be in the slow expensive onchain domain, so the heirs of the dead Lightning node will want to put them back into Lightning as fast as possible.\n\nGiven the number of economic nodes we expect to eventually exist (and thus possibly die) in the future, we can expect some level of such activity in the long run.\nIt is helpful to remember as well that this is a long-run issue anyway.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-03-31T02:06:32",
                "message_text_only": "Good morning Andrew,\n\nAnother thing I did not consider is how miners will actually behave under this ruleset.\n\nMiners are the direct beneficiaries of any increased inflation rate voted in.\n\nMiners are also ultimately the ones who decide which transactions get added into blocks, or put another way, which UTXOs are deleted and which UTXOs are created.\n\nThus, miners are likely to accept attempts to delete UTXOs that vote for lower inflation rates and create UTXOs that vote for higher inflation rates, and reject attempts to delete UTXOs that vote for higher inflation rates and create UTXOs that vote for lower inflation rates.\n\nThus, miners will end up strongly controlling the inflation rate of the coin.\n\nEven worse, since the inflation gives increased coins to miners, more and more of the value of the coin, with which you vote for, will be in the hands of miners, who can then vote directly instead of censoring votes they dislike.\n\nThe entire point of Bitcoin having a fixed inflation rate schedule (that is ultimately disinflationary) is to avoid the moral hazard of having the beneficiaries of higher inflation rates also be the ones who decide what the inflation rate will be.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Block solving slowdown",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Andrew Cann"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 9055
        }
    },
    {
        "title": "[bitcoin-dev] BIP 340 updates: even pubkeys, more secure nonce generation",
        "thread_messages": [
            {
                "author": "Lloyd Fournier",
                "date": "2020-03-22T05:51:59",
                "message_text_only": "* To protect against differential power analysis, a different way of\n> mixing in this randomness is used (masking the private key completely\n> with randomness before continuing, rather than hashing them together,\n> which is known in the literature to be vulnerable to DPA in some\n> scenarios).\n>\n\nI think citation for this would improve the spec.\n\nI haven't studied these attacks but it seems to me that every hardware\nwallet would be vulnerable to them while doing key derivation. If the\nattacker can get side channel information from hashes in nonce derivation\nthen they can surely get side channel information from hashes in HD key\nderivation. It should actually be easier since the master seed is hashed\nfor anything the hardware device needs to do including signing.\n\nis this the case?\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200322/2f7cb908/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP 340 updates: even pubkeys, more secure nonce generation",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Lloyd Fournier"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 977
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin-s v0.3.0 release",
        "thread_messages": [
            {
                "author": "Chris Stewart",
                "date": "2020-03-22T22:09:00",
                "message_text_only": "Hi all\n\nWe just released v0.3.0 of bitcoin-s.\n\nBitcoin-s is a loosely coupled set of cryptocurrency libraries for the JVM.\nThey work well together, but also can be used independently. This project's\ngoal is NOT to be a full node implementation, rather a set of scalable\ncryptocurrency libraries that use industry standard tools (rather than\nesoteric tech often found in cryptocurrency) where possible to make the\nlives of professional software engineers, security engineers, devops\nengineers and accountants easier. We are rapidly iterating on development\nwith the goal of getting to a set of stable APIs that only change when the\nunderlying bitcoin protocol changes.\n\nHere is an interactive code editor that allows you to play around with\nbasic data structures in bitcoin-s like private keys, psbts, and block\nfilters:\n\nhttps://scastie.scala-lang.org/Christewart/IqidPZ3gTbOUbMmAf6F2MA/5\n\nYou can find more examples of how our neutrino node, wallet, bitcoind rpc\nclient and secp256k1jni (bindings for libsecp256k1) work on our website:\n\nhttps://bitcoin-s.org/docs/next/getting-setup\n\nYou can find the release notes for v0.3.0 here:\n\nhttps://github.com/bitcoin-s/bitcoin-s/releases/tag/v0.3.0\n\n-Chris\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200322/214a9a57/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin-s v0.3.0 release",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Chris Stewart"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1383
        }
    },
    {
        "title": "[bitcoin-dev] Mitigating Differential Power Analysis in BIP-340",
        "thread_messages": [
            {
                "author": "Lloyd Fournier",
                "date": "2020-03-24T13:00:45",
                "message_text_only": "Hi List,\n\nI felt this topic deserved it's own thread but it follows on from the\nmailing list post [2] announcing a new PR [1] to change BIP-340 in several\nways, including adding random auxiliary data into the nonce\nderivation function. Rather than hashing the randomness with the secret key\nand message etc, the randomness is hashed then XOR'd (^) with the secret\nkey and the result is hashed like so to determine the secret nonce k:\n\n(1) k = H_derive( sec_key ^ H_aux(rand) || pub_key_x || message)\n\nThe claim made in the mailing list post is that this is more secure against\n\"differential power analysis\" (DPA) attacks than just doing the simpler and\nmore efficient:\n\n(2) k = H_derive(sec_key || rand || pub_key_x || message)\n\nThe TL;DR here is that I don't think this is the case.\n\nThere was no citation for this claim, so I did some digging and found two\npapers that seemed like they might be the origin of the idea [3,4] (I had\nno idea about these attacks before). A relatively easy to understand\nexplanation of DPA attacks against is in [3]:\n\nThe fundamental principle behind all DPA attacks is that at some point in\n> an algorithm\u2019s execution, a function f exists that combines a fixed secret\n> value with a variable which an attacker knows. An attacker can form\n> hypotheses about the fixed secret value, and compute the corresponding\n> output values of f by using an appropriate leakage model, such as the\n> Hamming Distance model. The attacker can then use the acquired power\n> consumption traces to verify her hypotheses, by partitioning the\n> acquisitions or using Pearson\u2019s correlation coefficient. These side-channel\n> analysis attacks are aided by knowledge of details of the implementation\n> under attack. Moreover, these attacks can be used to validate hypotheses\n> about implementation details. In subsequent sections, these side-channel\n> analysis attacks are referred to as DPA attacks.\n\n\nFor example, in the original BIP-340 proposal the nonce derivation was\nvulnerable to DPA attacks as it was derived simply by doing\nH_derive(sec_key || message). Since, the message is known to the attacker\nand variable (even if it is not controller by her), the SHA256 compression\nfunction run on (sec_key || message) may leak information about sec_key. It\nis crucial to understand that just hashing sec_key before passing it into\nthe H_derive does *not* fix the problem. Although the attacker would be\nunable to find sec_key directly, they could learn H(sec_key) and with that\nknow all the inputs into H_derive and therefore get the value of the secret\nnonce k and from there extract the secret key from any signature made with\nthis nonce derivation algorithm.\n\nThe key thing I want to argue with this post is that there is no advantage\nof (1) over (2) against DPA attacks, at least not given my understanding of\nthese papers. The way the attack in [3] works is by assuming that\noperations in the compression function leak the \"hamming distance\" [5] (HD)\nbetween the static secret thing that is being combined with the variable\npublic thing. In practice the attack involves many particulars about SHA256\nbut that is, at a high level, the right way to simplify it I think. The way\nthe paper suggests to fix the problem is to mask the secret data with\nsecret randomness before each sensitive operation and then strip off the\nsecret randomness afterwards. This seems to be the inspiration for the\nstructure of updated BIP-340 (1), however I don't believe that it provides\nany extra protection over (2). My argument is as follows:\n\nClaim A: If the randomness used during signing is kept secret from the\nattacker then (2) is secure against DPA.\n\nSince SHA256 has 64-byte blocks the hash H_derive(sec_key || rand ||\npub_key_x || message) will be split up into two 64 byte blocks, one\ncontaining secret data (sec_key || rand) and the other containing data\nknown to the attacker (pub_key_x || message). The compression function will\nrun on (sec_key || rand) but DPA will be useless here because the\nHD(sec_key, rand) will contain no information about sec_key since rand is\nalso secret. The output of the compression function on the first block will\nbe secret but *variable* so the intermediate hash state will not reveal\nuseful information when compressed with the second block.\n\nThen I thought perhaps (1) is more robust in the case where the randomness\nis known by the attacker (maybe the attacker can physically modify the\nchipset to control the rng). We'd have to assume that the sec_key ^\nH_aux(rand) isn't vulnerable to DPA (the LHS is under the control of the\nattacker) to be true. Even under this assumption it turned out not to be\nthe case:\n\nClaim B: If the randomness used during signing is known to the attacker,\nthen (1) is not secure against DPA.\n\nIn (1)  there are 96 bytes to be hashed and therefore two SHA256 blocks:\n(H_aux(sec_key) ^ rand || pub_key_x) and (message). During the first\ncompression function call the attacker gets the HD of:\nHD( sec_key ^ H_aux(rand),  pub_key_x)\nwhich is equal to the following as applying the same XOR to both sides does\nnot change the HD.\nHD(sec_key, H_aux(rand) ^ pub_key_x)\nSince the LHS is secret and static, and the RHS is variable and known to\nthe adversary we have a successful DPA attack -- the attacker will learn\nsec_key after enough runs.\n\nMaybe it's just a general rule if you can't produce randomness hidden to\nthe attacker then no defence is possible against DPA but I wanted to check\nthis anyway.\n\nMy conclusion from this is that (2) is preferable to (1) because it is\nsimpler and more efficient (it has one less SHA256 compression run) and no\nless secure against DPA (in this model). This is not really my area so\nperhaps there is a justification for (1) over (2) that I don't understand\nyet. If so, someone needs to write it down! If not then I think changing\nthe proposal to (2) is preferable.\n\nCheers,\n\nLL\n\n\n[1] https://github.com/bitcoin/bips/pull/893\n[2]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017639.html\n[3] http://www.oocities.org/mike.tunstall/papers/MTMM07.pdf\n[4] https://www.cryptoexperts.com/sbelaid/articleHMAC.pdf\n[5] https://en.wikipedia.org/wiki/Hamming_distance\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200325/e3675bf9/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2020-03-24T18:56:38",
                "message_text_only": "On Tuesday, March 24, 2020 6:00 AM, Lloyd Fournier via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi List,\n>\n> I felt this topic deserved it's own thread but it follows on from the mailing list post [2] announcing a new PR [1] to change BIP-340 in several ways, including adding random auxiliary\u00a0data into the nonce derivation\u00a0function. Rather than hashing the randomness with the secret key and message etc, the randomness is hashed then XOR'd (^) with the secret key and the result is hashed like so to determine the secret nonce k:\n>\n> (1) k = H_derive( sec_key ^ H_aux(rand) || pub_key_x || message)\n>\n> The claim made in the mailing list post is that this is more secure against \"differential power analysis\" (DPA) attacks than just doing the simpler and more efficient:\n>\n> (2) k = H_derive(sec_key || rand || pub_key_x || message)\n>\n> The TL;DR here is that I don't think this is the case.\n\nHi Lloyd,\n\nThank you for looking into this. I very much agree we haven't given nearly enough justification for the use of a non-standard scheme here.\n\nI'll try to summarize the discussion we had that led to this choice, but most of it is on https://github.com/sipa/bips/issues/195 if you want the details.\n\nLet me first try to address what I think you're overlooking: in a BIP32/Taproot like scenario, the private key that goes into the signing algorithm functions as *both* secret and known to the attacker. That is to say, there is a master secret s, and signing key x that goes into the hash is x=s+a (mod n) for some value a that the attacker knows, and can modify (he cannot control it directly, but he may be able to grind it to have a structure he likes). I believe that means that feeding x to a hash directly itself is already a problem, regardless of what else goes into the hash - interactions between bits inside the hash operation that all come from x itself can leak bit-level information of x.  XORing (or any other simple mix operation that does not expose bit-level information) into the private key before giving it to a hash function seems like it would address this.\n\nThat said, all these DPA issues are very hard to reason about, as it's hard to find a realistic attack model that both (a) leaks some information but (b) doesn't obviously leak the entire key immediately. In the reasoning above I assumed an attacker who can observe word-level Hamming weight aggregates of all variables in the algorithm (which seems to match what one of the papers observed), but not bit level information. It also assumes that somehow the computation of x itself is immune from leaks (something you pointed out in a previous e-mail, I noticed).\n\nSo really, all of this is trying to choose one alternative among a set of (when ignoring DPA) nearly equally good constructions. Note that randomness is useful for protection against fault attacks, but for that purpose it doesn't matter where in the hash it goes, or even that it's particularly strong randomness (a counter would also work). There are a number of other concerns we discussed in the linked thread:\n* Efficiency (how many SHA256 transformations, including the ability for some to be precomputed)\n* The risk that the randomness added is correlated with the private key in a way that cancels things out when they're naively XORed together.\n* The risk of having a midstate in the hash function leak (without leaking the actual private key, but enough to predict nonces).\n* The issue with public keys that are input to the signing algorithm which come directly from an attacker (which is the reason why pubkey goes into the nonce function too).\n\nThe solution we came up with (H(priv XOR H(aux) || pub || msg)) is the only that ticks most of the boxes - but a different prioritization may certainly lead to a different conclusion.\n\nI'm happy for any input you may have here. In particular, the recent discussions around the interactions between anti-covert channel protection, randomness, and the ability to spot check hardware devices may mean we should revise the advice to consider not adding randomness unless such a anti-covert channel scheme is used.\n\nCheers,\n\n--\nPieter"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2020-03-25T15:07:48",
                "message_text_only": "Hi Pieter,\n\nThanks for the detailed response.\n\n\n> /secret key/secret keyI'll try to summarize the discussion we had that led\n> to this choice, but most of it is on\n> https://github.com/sipa/bips/issues/195 if you want the details.\n\n\nAhh I can't believe I missed that github issue while searching. I guess I\nstarted reading a paper on DPA and got carried away. I can see you got to\nwhere I was and then went much further including some empirical analysis.\nNice. I agree with the conclusion that xor is more robust than just hashing\nrandomness in the same block as the secret key.\n\n\n> Let me first try to address what I think you're overlooking: in a\n> BIP32/Taproot like scenario, the private key that goes into the signing\n> algorithm functions as *both* secret and known to the attacker. That is to\n> say, there is a master secret s, and signing key x that goes into the hash\n> is x=s+a (mod n) for some value a that the attacker knows, and can modify\n> (he cannot control it directly, but he may be able to grind it to have a\n> structure he likes). I believe that means that feeding x to a hash directly\n> itself is already a problem, regardless of what else goes into the hash -\n> interactions between bits inside the hash operation that all come from x\n> itself can leak bit-level information of x.  XORing (or any other simple\n> mix operation that does not expose bit-level information) into the private\n> key before giving it to a hash function seems like it would address this.\n>\n\nThis is an subtle point that I didn't cross my mind. My gut feeling is\nthere isn't even a computational argument to made that what I was\nsuggesting is secure against DPA in that setting. DPA seems to be a PITA. A\nfootnote in the BIP with a citation for DPA (the ed25519 one from the issue\nis good) and a hint about why you should avoid hashing Bitcoin secret keys\naltogether would be good. This brings us to the next point.\n\nIt also assumes that somehow the computation of x itself is immune from\n> leaks (something you pointed out in a previous e-mail, I noticed).\n>\n\n>From my reading of the HMAC papers it seems you might be able to vary the\nBIP32 child index derivation to do this attack. Just thinking about it now,\nthese attacks seem far fetched just because in order for it to be useful\nyou need to have physical access to the device and to be able to accurately\nmeasure power consumption in high resolution (which I guess you can't do\nfrom a typical USB bus from corrupted software). Then you also need to get\nthe user to do lots of signing or derivation with their device. I guess a\nmalicious cable with some way of exfiltrating power consumption could do it.\n\n\n> I'm happy for any input you may have here. In particular, the recent\n> discussions around the interactions between anti-covert channel protection,\n> randomness, and the ability to spot check hardware devices may mean we\n> should revise the advice to consider not adding randomness unless such a\n> anti-covert channel scheme is used.\n>\n\nMy only comment here is that there will end up being more than one way to\ndo it and I think what you and your collaborators have put forward is at a\nlocal optimum of design (now that I understand it). Thanks and well done!\nIt won't be the right optimum for everyone. To me, it seems like a good\nplace to start. If you develop a decent nonce exfiltration protected\nsigning protocol later then I don't see why HW wallets wouldn't compete for\nfavour amongst the community by implementing and updating their devices to\nconform to it.\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200326/ef1f3213/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Mitigating Differential Power Analysis in BIP-340",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Pieter Wuille",
                "Lloyd Fournier"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 14232
        }
    },
    {
        "title": "[bitcoin-dev] Statechain implementations",
        "thread_messages": [
            {
                "author": "Tom Trevethan",
                "date": "2020-03-25T13:52:10",
                "message_text_only": "Hi all,\n\nWe are starting to work on an implementation of the statechains concept (\nhttps://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39),\nwith particular interest in using the protocol enable the change of\nownership (novation) of an individual position in an active discreet log\ncontract (DLC) without an on-chain transaction, and without needing the\ncooperation of the counterparty. The protocol as outlined by Ruben requires\nfeatures not currently available in Bitcoin (like SIGHASH_NOINPUT), and it\nis uncertain when (or even if) this will be added. So we are looking at\nvariants that would work with current Bitcoin functionality, and it would\nbe good to get some feedback on them.\n\nThere are two main modifications we are looking at:\n1. Instead of an eltoo-based backup/refund transaction (enabling the\ncurrent owner to claim the UTXO in case the statechain entity disappears)\nwe propose using a decrementing nLocktime for backup transactions as the\noutput changes hands. Here, the first owner gets a backup transaction with\nan nLocktime at some future height (h0), then the next owner gets a backup\ntransaction with nLocktime (h0-c) where c is a confirmation window. This\napproach has the downside of limiting the lifetime of the UTXO, but it also\ndoesn't require the current owner to be always online.\n\n2. Replacing the 2-of-2 multisig output (paying to statechain entity SE key\nand transitory key) with a single P2(W)PKH output where the public key\nshared between the SE and the current owner. The SE and the current owner\ncan then sign with a 2-of-2 ECDSA MPC. This enables each owner to generate\ntheir own private key share, and the SE changes their key share at each\nchange of ownership (with the shared public key remaining the same). This\nworks as follows (.G is EC point multiplication, * is scalar\nmultiplication):\n\nKeyGen:\n\na. Owner 1 generates private key share o1 then calculates the corresponding\npublic key of the share O1 and sends it to the SE: O1 = o1.G\nb. The SE then generates a private key: s1 (the SE private key share),\ncalculates the corresponding public key and sends it to Owner 1: S1 = s1.G\nc. Both SE and Owner 1 then multiply the public keys they receive by their\nown private key shares to obtain the same shared public key P (which\ncorresponds to a shared private key of p = o1*s1): P = o1.(s1.G) = s1.(o1.G)\nd. Owner 1 creates a funding transaction (Tx0) to pay an amount A to the\naddress corresponding to P (but doesn't sign it).\ne. Once Owner 1 and SE cooperatively sign the first backup transaction,\nOwner 1 then signs and broadcasts the deposit transaction Tx0.\n\nTransfer from Owner 1 to Owner 2:\n\na. Owner 2 generates two private keys: o2 (the new owner UTXO private key\nshare) and b2 (the new owner refund private key).\nb. The SE generates a temporary blinding nonce x and calculates the value\nx*s1 and sends this securely to Owner 2.\nc. Owner 2 then multiplies this received value by the modular inverse of o2\n(o2_inv) and then sends this value (x*s1*o2_inv), to Owner 1.\nd. Owner 1 then multiplies this received value by the key share o1 and\nsends the resulting value (x*s1*o2_inv*o1) to the SE.\ne. The SE then multiplies this received value by the modular inverse of the\ntemporary nonce (x_inv) to obtain x*s1*o2_inv*o1*x_inv. This cancels the\nblinding nonce x to give s1*o2_inv*o1. This value, when multiplied by the\nnew owner key share o2 equals the original shared private key s1*o1.\nf. The SE then sets this value equal to s2 = s1*o2_inv*o1 and deletes s1.\ns2 and o2 are now the key shares of `P` and can be used to colaboritively\nsign (with 2P ECDSA). So long as the SE delets s1, the old owner key share\n(o1) is of no use in deriving or co-signing with the full shared private\nkey, and is invalidated.\ng. The shared public key P remains unchanged, but the corresponding private\nkey (which no individual party ever has knowledge of or can derive) can\nonly be determined from the key shares of the SE and Owner 2 (i.e. P =\ns2*o2.G).\nh. Owner 2 then calculates their backup public key (B2 = b2.G) and sends it\nto the SE.\ni. The SE creates a backup transaction (Tx2) that pays the output of Tx0 to\nthe address corresponding to B2 , with `nLockTime` set to a block height h0\n- c0, where c0, is a confirmation time sufficient to guarantee that Tx2 can\nbe confirmed in the blockchain before Tx1 (therefore making Tx1 invalid).\nj. Owner 2 and the SE then cooperate to sign Tx2 with shared key (P) using\nthe 2P ECDSA protocol, which Owner 2 then saves.\n\nThe principle of the logic of the key transfer is that the two separate key\nshares are updated, but the full shared private key (which no-one knows)\nremains the same. The new owner chooses a new secret value for their\nprivate key share, and this (along with the private key share of the\nprevious owner) is utilized by the SE to update their share. The use of the\nnonce (x) prevents any of the participants from determining any information\nabout each others secret keys. In this way Owner 2 cannot determine s1 from\nx*s1, Owner 1 cannot determine s1 or o2 from x*s1*o2_inv and the SE cannot\ndetermine o1 or o2 from x*s1*o2_inv*o1.\n\nThis transfer protocol can be repeated to transfer the ownership to new\nowners. Each time the SE key share sX is updated, the previous key shares\nbecome invalid and are of no use even if the current key share is\nsubsequently revealed. The SE still needs to be trusted to delete the old\nkey share, but this protocol removes the risk the the SE can be hacked by a\nprevious owner to steal the funds.\n\nAny comments on the above would be greatly appreciated.\n\nTom\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200325/d83a4cfd/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-03-26T01:20:47",
                "message_text_only": "Good morning Tom,\n\n>\n> We are starting to work on an implementation of the statechains concept (https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39), with particular interest in using the protocol enable the change of ownership (novation) of an individual position in an active discreet log contract (DLC) without an on-chain transaction, and without needing the cooperation of the counterparty. The protocol as outlined by Ruben requires features not currently available in Bitcoin (like SIGHASH_NOINPUT), and it is uncertain when (or even if) this will be added. So we are looking at variants that would work with current Bitcoin functionality, and it would be good to get some feedback on them.\n>\n> There are two main modifications we are looking at:\n> 1. Instead of an eltoo-based backup/refund transaction (enabling the current owner to claim the UTXO in case the statechain entity disappears) we propose using a decrementing nLocktime for backup transactions as the output changes hands. Here, the first owner gets a backup transaction with an nLocktime at some future height (h0), then the next owner gets a backup transaction with nLocktime (h0-c) where c is a confirmation window. This approach has the downside of limiting the lifetime of the UTXO, but it also doesn't require the current owner to be always online.\n\nI believe I suggested this to Ruben Somsen as well in the past, but you can replace the state update mechanism with, for example, Decker-Wattenhofer decrementing-`nSequence`, which while it has a limit on the number of updates, does not have a limit on the time that a UTXO is locked in this mechanism.\n\nYou can even use the Decker-Wattenhofer trick of having a chain of decrementing-`nSequence` mechanisms to effectively multiply the number of updates that the overall mechanism can have.\n\nThe drawback is that in a unilateral close condition, the time to completely resolve the unilateral close is very large.\n\nFor a quick reference for this technique:\n\n* The funding transaction is anchored onchain, but all succeeding transactions are offchain.\n  * This funding transaction has a particular funding transaction output.\n* There is a kickoff transaction, which is a 1-input 1-output transaction without any `nLockTime` or `nSequence` limits.\n  * This spends the funding tx out.\n  * The signer set of the output is the same as the signer set of the funding transaction output.\n    * You could tweak keys or script to give a modicum of privacy.\n* There is one or more decrementing-`nSequence` transactions, which are 1-input 1-output transactions.\n  * Each one has a particular `nSequence` with a relative-locktime constraint.\n  * This spends the kickoff transaction output.\n  * The signer set of the output is the same as the signer set of the funding transaction output.\n* There is one or more decrementing-`nSequence` transactions, which are 1-input 1-output transactions.\n  * Each one has a particular `nSequence` with a relative-locktime constraint.\n  * This spends the previous stage decrementing-`nSequence` transaction output.\n  * The signer set of the output is the same as the signer set of the funding transaction output.\n* Repeat the above stage a few times.\n* There is one or more decrementing-`nSequence` transactions, which are 1-input multi-output transactions.\n  * Each one has a particular `nSequence` with a relative-locktime constraint.\n  * This spends the previous stage decrementing-`nSequence` transaction output.\n  * The outputs of this transaction represent the current state inside the statechain.\n\nThe `nSequence` use means there is no time-based lifetime limit.\nThe decrementing-`nSequence` stages mean that earlier states have higher `nSequence` limits, and newer states have lower `nSequence` limits.\nChaining multiple such mechanisms allows you to \"reset\" a stage by making a single update of the higher stage, which resets all further stages.\n\nSo for example, we could have a multi-stage mechanism as below:\n\n    ***blockchain***\n       [funding tx] -+\n         _ _ _ _ _ _ | _ _ _ _ _ _ _\n     offchain        |\n                     +->[kickoff tx]->[[14] stage]->[[14] stage]->[[14] stage]-> state outputs\n\nThe number in the brackets is the relative-locktime `nSequence` constraint in that stage transaction.\nLet us suppose that we agree to decrement `nSequence` by 7 blocks at each update.\n\nThen the first update will have:\n\n    ***blockchain***\n       [funding tx] -+\n         _ _ _ _ _ _ | _ _ _ _ _ _ _\n     offchain        |\n                     +->[kickoff tx]->[[14] stage]->[[14] stage]->[[ 7] stage]-> state outputs\n\nThe the second update:\n\n    ***blockchain***\n       [funding tx] -+\n         _ _ _ _ _ _ | _ _ _ _ _ _ _\n     offchain        |\n                     +->[kickoff tx]->[[14] stage]->[[14] stage]->[[ 0] stage]-> state outputs\n\nAfter this update, for the next update, we would also sign the second-to-the-last stage, and reset the last stage:\n\n    ***blockchain***\n       [funding tx] -+\n         _ _ _ _ _ _ | _ _ _ _ _ _ _\n     offchain        |\n                     +->[kickoff tx]->[[14] stage]->[[ 7] stage]->[[14] stage]-> state outputs\n\nAnd so on.\nEffectively it becomes a large counter, with the \"least significant digit\" being the last stage.\nThis multiplies the total number of updates your statechain can have, so for example the above uses a total unilateral close delay of 42 blocks to allow creation of 27 updates, whereas if it were a single stage those 42 blocks would only allow 7 updates.\n\nAs the first stage decrements, you can actually add more stages dependent on it, keeping a total maximum time that a unilateral close will resolve, but increasing the number of transactions that would need to be published onchain in a unilateral close.\nThis allows you to further extend the number of updates, possibly allowing an indefinite number of updates (at the cost of greatly increased blockchain usage in the unilateral close, which might not be feasible).\n\nThe original Decker-Wattenhofer paper \"Duplex Micropayment Channels\" has prettier graphics.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Albert",
                "date": "2020-03-26T03:55:50",
                "message_text_only": "Hi,\n\nGreat to see some work in this direction, here's some thoughts on your keygen scheme:\n\nIn the scenario where Owner1=Owner2, that is, one of the owners sends some coins to itself, that owner would get to know both x1*s1 and x2*s2=x2*s1*o2_inv*o1, and, because he already knows o1 and o2, that implies knowledge of both x1*s1 and x2*s1 where x1 and x2 are random numbers sampled from an uniform distribution. Once the owner has these two numbers, he can just sum these together to obtain s1*(x1+x2). \nNow, because of the central limit theorem, the distribution of x1+x2 should approximate a normal one, concretely an Irwin\u2013Hall distribution, with that approximation getting better when more numbers are collected through iterations of the protocol. Once you've collected enough numbers to approximate a normal well enough (looking at Irwin Hall distribution graphs^[1] you can observe that with less than 10 samples the distribution is already pretty similar to a normal one), it should be possible to drastically reduce the search space and apply brute force to guess the value of \\sum x and, consequently, s1.\n\nPractically, it's possible that the search space is still too large for brute-force to be fruitful, so this attack might not work, but it shows that there is information leakage in every protocol iteration.\n\nOn another note, if you are not already aware of, something which might be worth looking into is the possibility of further trust-minimising the SE role by forcing it's code to be run inside an AWS oracle or a hardware isolated processor such as SGX.\n\nAlbert\n\n[1] https://en.wikipedia.org/wiki/Irwin%E2%80%93Hall_distribution\n\nOn Wed, Mar 25, 2020, at 9:52 PM, Tom Trevethan via bitcoin-dev wrote:\n> Hi all,\n> \n> We are starting to work on an implementation of the statechains concept (https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39), with particular interest in using the protocol enable the change of ownership (novation) of an individual position in an active discreet log contract (DLC) without an on-chain transaction, and without needing the cooperation of the counterparty. The protocol as outlined by Ruben requires features not currently available in Bitcoin (like SIGHASH_NOINPUT), and it is uncertain when (or even if) this will be added. So we are looking at variants that would work with current Bitcoin functionality, and it would be good to get some feedback on them. \n> \n> There are two main modifications we are looking at: \n> 1. Instead of an eltoo-based backup/refund transaction (enabling the current owner to claim the UTXO in case the statechain entity disappears) we propose using a decrementing nLocktime for backup transactions as the output changes hands. Here, the first owner gets a backup transaction with an nLocktime at some future height (h0), then the next owner gets a backup transaction with nLocktime (h0-c) where c is a confirmation window. This approach has the downside of limiting the lifetime of the UTXO, but it also doesn't require the current owner to be always online. \n> \n> 2. Replacing the 2-of-2 multisig output (paying to statechain entity SE key and transitory key) with a single P2(W)PKH output where the public key shared between the SE and the current owner. The SE and the current owner can then sign with a 2-of-2 ECDSA MPC. This enables each owner to generate their own private key share, and the SE changes their key share at each change of ownership (with the shared public key remaining the same). This works as follows (.G is EC point multiplication, * is scalar multiplication):\n> \n> KeyGen:\n> \n>  a. Owner 1 generates private key share o1 then calculates the corresponding public key of the share O1 and sends it to the SE: O1 = o1.G\n>  b. The SE then generates a private key: s1 (the SE private key share), calculates the corresponding public key and sends it to Owner 1: S1 = s1.G\n>  c. Both SE and Owner 1 then multiply the public keys they receive by their own private key shares to obtain the same shared public key P (which corresponds to a shared private key of p = o1*s1): P = o1.(s1.G) = s1.(o1.G)\n>  d. Owner 1 creates a funding transaction (Tx0) to pay an amount A to the address corresponding to P (but doesn't sign it). \n>  e. Once Owner 1 and SE cooperatively sign the first backup transaction, Owner 1 then signs and broadcasts the deposit transaction Tx0. \n> \n> Transfer from Owner 1 to Owner 2:\n> \n>  a. Owner 2 generates two private keys: o2 (the new owner UTXO private key share) and b2 (the new owner refund private key).\n>  b. The SE generates a temporary blinding nonce x and calculates the value x*s1 and sends this securely to Owner 2. \n>  c. Owner 2 then multiplies this received value by the modular inverse of o2 (o2_inv) and then sends this value (x*s1*o2_inv), to Owner 1.\n>  d. Owner 1 then multiplies this received value by the key share o1 and sends the resulting value (x*s1*o2_inv*o1) to the SE.\n>  e. The SE then multiplies this received value by the modular inverse of the temporary nonce (x_inv) to obtain x*s1*o2_inv*o1*x_inv. This cancels the blinding nonce x to give s1*o2_inv*o1. This value, when multiplied by the new owner key share o2 equals the original shared private key s1*o1. \n>  f. The SE then sets this value equal to s2 = s1*o2_inv*o1 and deletes s1. s2 and o2 are now the key shares of `P` and can be used to colaboritively sign (with 2P ECDSA). So long as the SE delets s1, the old owner key share (o1) is of no use in deriving or co-signing with the full shared private key, and is invalidated. \n>  g. The shared public key P remains unchanged, but the corresponding private key (which no individual party ever has knowledge of or can derive) can only be determined from the key shares of the SE and Owner 2 (i.e. P = s2*o2.G).\n>  h. Owner 2 then calculates their backup public key (B2 = b2.G) and sends it to the SE.\n>  i. The SE creates a backup transaction (Tx2) that pays the output of Tx0 to the address corresponding to B2 , with `nLockTime` set to a block height h0 - c0, where c0, is a confirmation time sufficient to guarantee that Tx2 can be confirmed in the blockchain before Tx1 (therefore making Tx1 invalid).\n>  j. Owner 2 and the SE then cooperate to sign Tx2 with shared key (P) using the 2P ECDSA protocol, which Owner 2 then saves. \n> \n> The principle of the logic of the key transfer is that the two separate key shares are updated, but the full shared private key (which no-one knows) remains the same. The new owner chooses a new secret value for their private key share, and this (along with the private key share of the previous owner) is utilized by the SE to update their share. The use of the nonce (x) prevents any of the participants from determining any information about each others secret keys. In this way Owner 2 cannot determine s1 from x*s1, Owner 1 cannot determine s1 or o2 from x*s1*o2_inv and the SE cannot determine o1 or o2 from x*s1*o2_inv*o1. \n> \n> This transfer protocol can be repeated to transfer the ownership to new owners. Each time the SE key share sX is updated, the previous key shares become invalid and are of no use even if the current key share is subsequently revealed. The SE still needs to be trusted to delete the old key share, but this protocol removes the risk the the SE can be hacked by a previous owner to steal the funds. \n> \n> Any comments on the above would be greatly appreciated. \n> \n> Tom\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200326/b32e6be2/attachment-0001.html>"
            },
            {
                "author": "Ruben Somsen",
                "date": "2020-03-26T12:36:20",
                "message_text_only": "Hi Tom,\n\nNice to see you working on this.\n\nRegarding modification 1, I agree with ZmnSCPxj that Decker-Wattenhofer is\nyour next best option, given that eltoo is not yet available. But if you\nare going to use a kickoff transaction, keep in mind that every previous\nowner will have a copy of it. Because of this, you can't include a fee, and\nwill instead need to have a second output for CPFP. This way a previous\nowner will at least have to pay the fee if they want to publish it. Note\nthat it's still an improvement, because even if the kickoff transaction\ngets posted, it basically becomes no different than what it would have\nbeen, had you not used a kickoff transaction at all.\n\nRegarding modification 2, I like it a lot conceptually. It hadn't occurred\nto me before, and it's a clear security improvement. The only question is\nsomething Greg Sanders mentioned: whether it's enough to justify the added\ncomplexity of using 2P ECDSA. The alternative would be to simply use a\nregular 2-of-2 multisig (until Schnorr arrives, possibly).\n\nI'm looking forward to seeing statechains become a reality.\n\nCheers,\nRuben\n\nOn Thu, Mar 26, 2020 at 5:20 AM Albert via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi,\n>\n> Great to see some work in this direction, here's some thoughts on your\n> keygen scheme:\n>\n> In the scenario where Owner1=Owner2, that is, one of the owners sends some\n> coins to itself, that owner would get to know both x1*s1 and\n> x2*s2=x2*s1*o2_inv*o1, and, because he already knows o1 and o2, that\n> implies knowledge of both x1*s1 and x2*s1 where x1 and x2 are random\n> numbers sampled from an uniform distribution. Once the owner has these two\n> numbers, he can just sum these together to obtain s1*(x1+x2).\n> Now, because of the central limit theorem, the distribution of x1+x2\n> should approximate a normal one, concretely an Irwin\u2013Hall distribution,\n> with that approximation getting better when more numbers are collected\n> through iterations of the protocol. Once you've collected enough numbers to\n> approximate a normal well enough (looking at Irwin Hall distribution\n> graphs^[1] you can observe that with less than 10 samples the distribution\n> is already pretty similar to a normal one), it should be possible to\n> drastically reduce the search space and apply brute force to guess the\n> value of \\sum x and, consequently, s1.\n>\n> Practically, it's possible that the search space is still too large for\n> brute-force to be fruitful, so this attack might not work, but it shows\n> that there is information leakage in every protocol iteration.\n>\n> On another note, if you are not already aware of, something which might be\n> worth looking into is the possibility of further trust-minimising the SE\n> role by forcing it's code to be run inside an AWS oracle or a hardware\n> isolated processor such as SGX.\n>\n> Albert\n>\n> [1] https://en.wikipedia.org/wiki/Irwin%E2%80%93Hall_distribution\n>\n> On Wed, Mar 25, 2020, at 9:52 PM, Tom Trevethan via bitcoin-dev wrote:\n>\n> Hi all,\n>\n> We are starting to work on an implementation of the statechains concept (\n> https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39),\n> with particular interest in using the protocol enable the change of\n> ownership (novation) of an individual position in an active discreet log\n> contract (DLC) without an on-chain transaction, and without needing the\n> cooperation of the counterparty. The protocol as outlined by Ruben requires\n> features not currently available in Bitcoin (like SIGHASH_NOINPUT), and it\n> is uncertain when (or even if) this will be added. So we are looking at\n> variants that would work with current Bitcoin functionality, and it would\n> be good to get some feedback on them.\n>\n> There are two main modifications we are looking at:\n> 1. Instead of an eltoo-based backup/refund transaction (enabling the\n> current owner to claim the UTXO in case the statechain entity disappears)\n> we propose using a decrementing nLocktime for backup transactions as the\n> output changes hands. Here, the first owner gets a backup transaction with\n> an nLocktime at some future height (h0), then the next owner gets a backup\n> transaction with nLocktime (h0-c) where c is a confirmation window. This\n> approach has the downside of limiting the lifetime of the UTXO, but it also\n> doesn't require the current owner to be always online.\n>\n> 2. Replacing the 2-of-2 multisig output (paying to statechain entity SE\n> key and transitory key) with a single P2(W)PKH output where the public key\n> shared between the SE and the current owner. The SE and the current owner\n> can then sign with a 2-of-2 ECDSA MPC. This enables each owner to generate\n> their own private key share, and the SE changes their key share at each\n> change of ownership (with the shared public key remaining the same). This\n> works as follows (.G is EC point multiplication, * is scalar\n> multiplication):\n>\n> KeyGen:\n>\n> a. Owner 1 generates private key share o1 then calculates the\n> corresponding public key of the share O1 and sends it to the SE: O1 = o1.G\n> b. The SE then generates a private key: s1 (the SE private key share),\n> calculates the corresponding public key and sends it to Owner 1: S1 = s1.G\n> c. Both SE and Owner 1 then multiply the public keys they receive by their\n> own private key shares to obtain the same shared public key P (which\n> corresponds to a shared private key of p = o1*s1): P = o1.(s1.G) = s1.(o1.G)\n> d. Owner 1 creates a funding transaction (Tx0) to pay an amount A to the\n> address corresponding to P (but doesn't sign it).\n> e. Once Owner 1 and SE cooperatively sign the first backup transaction,\n> Owner 1 then signs and broadcasts the deposit transaction Tx0.\n>\n> Transfer from Owner 1 to Owner 2:\n>\n> a. Owner 2 generates two private keys: o2 (the new owner UTXO private key\n> share) and b2 (the new owner refund private key).\n> b. The SE generates a temporary blinding nonce x and calculates the value\n> x*s1 and sends this securely to Owner 2.\n> c. Owner 2 then multiplies this received value by the modular inverse of\n> o2 (o2_inv) and then sends this value (x*s1*o2_inv), to Owner 1.\n> d. Owner 1 then multiplies this received value by the key share o1 and\n> sends the resulting value (x*s1*o2_inv*o1) to the SE.\n> e. The SE then multiplies this received value by the modular inverse of\n> the temporary nonce (x_inv) to obtain x*s1*o2_inv*o1*x_inv. This cancels\n> the blinding nonce x to give s1*o2_inv*o1. This value, when multiplied by\n> the new owner key share o2 equals the original shared private key s1*o1.\n> f. The SE then sets this value equal to s2 = s1*o2_inv*o1 and deletes s1.\n> s2 and o2 are now the key shares of `P` and can be used to colaboritively\n> sign (with 2P ECDSA). So long as the SE delets s1, the old owner key share\n> (o1) is of no use in deriving or co-signing with the full shared private\n> key, and is invalidated.\n> g. The shared public key P remains unchanged, but the corresponding\n> private key (which no individual party ever has knowledge of or can derive)\n> can only be determined from the key shares of the SE and Owner 2 (i.e. P =\n> s2*o2.G).\n> h. Owner 2 then calculates their backup public key (B2 = b2.G) and sends\n> it to the SE.\n> i. The SE creates a backup transaction (Tx2) that pays the output of Tx0\n> to the address corresponding to B2 , with `nLockTime` set to a block height\n> h0 - c0, where c0, is a confirmation time sufficient to guarantee that Tx2\n> can be confirmed in the blockchain before Tx1 (therefore making Tx1\n> invalid).\n> j. Owner 2 and the SE then cooperate to sign Tx2 with shared key (P) using\n> the 2P ECDSA protocol, which Owner 2 then saves.\n>\n> The principle of the logic of the key transfer is that the two separate\n> key shares are updated, but the full shared private key (which no-one\n> knows) remains the same. The new owner chooses a new secret value for their\n> private key share, and this (along with the private key share of the\n> previous owner) is utilized by the SE to update their share. The use of the\n> nonce (x) prevents any of the participants from determining any information\n> about each others secret keys. In this way Owner 2 cannot determine s1 from\n> x*s1, Owner 1 cannot determine s1 or o2 from x*s1*o2_inv and the SE cannot\n> determine o1 or o2 from x*s1*o2_inv*o1.\n>\n> This transfer protocol can be repeated to transfer the ownership to new\n> owners. Each time the SE key share sX is updated, the previous key shares\n> become invalid and are of no use even if the current key share is\n> subsequently revealed. The SE still needs to be trusted to delete the old\n> key share, but this protocol removes the risk the the SE can be hacked by a\n> previous owner to steal the funds.\n>\n> Any comments on the above would be greatly appreciated.\n>\n> Tom\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200326/0a5f4fef/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2020-03-26T17:12:44",
                "message_text_only": "Ruben Somsen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nwrites:\n> Regarding modification 1, I agree with ZmnSCPxj that\n> Decker-Wattenhofer is your next best option, given that eltoo is not\n> yet available. But if you are going to use a kickoff transaction, keep\n> in mind that every previous owner will have a copy of it. Because of\n> this, you can't include a fee, and will instead need to have a second\n> output for CPFP. This way a previous owner will at least have to pay\n> the fee if they want to publish it. Note that it's still an\n> improvement, because even if the kickoff transaction gets posted, it\n> basically becomes no different than what it would have been, had you\n> not used a kickoff transaction at all.\n\nIt might be worth adopting the late fee binding we have in eltoo by\nhaving the kickoff transaction input spending the funding tx signed with\nsighash_single. This works because we only have 1 input and 1 output\nthat we really care about, and can allow others to attach fees at\nwill. That'd at least remove the need to guess the feerate days or\nmonths in advance and thus having to overestimate.  \n\n> Regarding modification 2, I like it a lot conceptually. It hadn't\n> occurred to me before, and it's a clear security improvement. The only\n> question is something Greg Sanders mentioned: whether it's enough to\n> justify the added complexity of using 2P ECDSA. The alternative would\n> be to simply use a regular 2-of-2 multisig (until Schnorr arrives,\n> possibly).\n\nWouldn't that result in a changing pubkey at each update, and thus\nrequire an onchain move to be committed?\n\n> I'm looking forward to seeing statechains become a reality.\n\nThat'd indeed be great :-)\n\nCheers,\nChristian"
            },
            {
                "author": "Greg Sanders",
                "date": "2020-03-26T17:17:13",
                "message_text_only": "> Wouldn't that result in a changing pubkey at each update, and thus\nrequire an onchain move to be committed?\n\nSuggestion was in line with original proposal where no keys are changing\never, just not presupposing existence of MuSig.\n\nOn Thu, Mar 26, 2020 at 1:15 PM Christian Decker via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Ruben Somsen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> writes:\n> > Regarding modification 1, I agree with ZmnSCPxj that\n> > Decker-Wattenhofer is your next best option, given that eltoo is not\n> > yet available. But if you are going to use a kickoff transaction, keep\n> > in mind that every previous owner will have a copy of it. Because of\n> > this, you can't include a fee, and will instead need to have a second\n> > output for CPFP. This way a previous owner will at least have to pay\n> > the fee if they want to publish it. Note that it's still an\n> > improvement, because even if the kickoff transaction gets posted, it\n> > basically becomes no different than what it would have been, had you\n> > not used a kickoff transaction at all.\n>\n> It might be worth adopting the late fee binding we have in eltoo by\n> having the kickoff transaction input spending the funding tx signed with\n> sighash_single. This works because we only have 1 input and 1 output\n> that we really care about, and can allow others to attach fees at\n> will. That'd at least remove the need to guess the feerate days or\n> months in advance and thus having to overestimate.\n>\n> > Regarding modification 2, I like it a lot conceptually. It hadn't\n> > occurred to me before, and it's a clear security improvement. The only\n> > question is something Greg Sanders mentioned: whether it's enough to\n> > justify the added complexity of using 2P ECDSA. The alternative would\n> > be to simply use a regular 2-of-2 multisig (until Schnorr arrives,\n> > possibly).\n>\n> Wouldn't that result in a changing pubkey at each update, and thus\n> require an onchain move to be committed?\n>\n> > I'm looking forward to seeing statechains become a reality.\n>\n> That'd indeed be great :-)\n>\n> Cheers,\n> Christian\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200326/7b38acf0/attachment.html>"
            },
            {
                "author": "Ruben Somsen",
                "date": "2020-03-26T18:53:13",
                "message_text_only": "Hey Christian,\n\nThanks for chiming in :)\n\n>It might be worth adopting the late fee binding we have in eltoo\n\nThat is where my thinking originally went as well, but then I remembered\nthat this alters the txid, causing the settlement tx to become invalid.\nWhat I am suggesting should be functionally the same (albeit less\nspace-efficient): a secondary output that can be spent by anyone, which can\nbe used to fee bump the kickoff tx with CPFP. I believe this same idea was\nconsidered for Lightning as well at some point. Do you happen to recall if\nthere was some kind of non-standardness issue with it?\n\n>Wouldn't that result in a changing pubkey at each update, and thus require\nan onchain move to be committed?\n\nI have yet to take a closer look at the math, but my understanding is that\nthe same key (x) gets redistributed. First x = s1 + o1 and after the\ntransfer x = s2 + o2 (not the actual math, but it demonstrates how the\ntransitory key can change from o1 to o2). Assuming s1 is then thrown away\n(trust assumption), o1 becomes harmless information.\n\nCheers,\nRuben\n\nOn Thu, Mar 26, 2020 at 6:17 PM Greg Sanders <gsanders87 at gmail.com> wrote:\n\n> > Wouldn't that result in a changing pubkey at each update, and thus\n> require an onchain move to be committed?\n>\n> Suggestion was in line with original proposal where no keys are changing\n> ever, just not presupposing existence of MuSig.\n>\n> On Thu, Mar 26, 2020 at 1:15 PM Christian Decker via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Ruben Somsen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n>> writes:\n>> > Regarding modification 1, I agree with ZmnSCPxj that\n>> > Decker-Wattenhofer is your next best option, given that eltoo is not\n>> > yet available. But if you are going to use a kickoff transaction, keep\n>> > in mind that every previous owner will have a copy of it. Because of\n>> > this, you can't include a fee, and will instead need to have a second\n>> > output for CPFP. This way a previous owner will at least have to pay\n>> > the fee if they want to publish it. Note that it's still an\n>> > improvement, because even if the kickoff transaction gets posted, it\n>> > basically becomes no different than what it would have been, had you\n>> > not used a kickoff transaction at all.\n>>\n>> It might be worth adopting the late fee binding we have in eltoo by\n>> having the kickoff transaction input spending the funding tx signed with\n>> sighash_single. This works because we only have 1 input and 1 output\n>> that we really care about, and can allow others to attach fees at\n>> will. That'd at least remove the need to guess the feerate days or\n>> months in advance and thus having to overestimate.\n>>\n>> > Regarding modification 2, I like it a lot conceptually. It hadn't\n>> > occurred to me before, and it's a clear security improvement. The only\n>> > question is something Greg Sanders mentioned: whether it's enough to\n>> > justify the added complexity of using 2P ECDSA. The alternative would\n>> > be to simply use a regular 2-of-2 multisig (until Schnorr arrives,\n>> > possibly).\n>>\n>> Wouldn't that result in a changing pubkey at each update, and thus\n>> require an onchain move to be committed?\n>>\n>> > I'm looking forward to seeing statechains become a reality.\n>>\n>> That'd indeed be great :-)\n>>\n>> Cheers,\n>> Christian\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200326/c5056e1f/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-03-27T01:46:15",
                "message_text_only": "Good morning Ruben,\n\n> Hey Christian,\n>\n> Thanks for chiming in :)\n>\n> >It might be worth adopting the late fee binding we have in eltoo\n>\n> That is where my thinking originally went as well, but then I remembered that this alters the txid, causing the settlement tx to become invalid. What I am suggesting should be functionally the same (albeit less space-efficient): a secondary output that can be spent by anyone, which can be used to fee bump the kickoff tx with CPFP. I believe this same idea was considered for Lightning as well at some point. Do you happen to recall if there was some kind of non-standardness issue with it?\n\nAny standardness issue can be fixed by embedding it in a P2WSH / P2SH, you can use an `OP_TRUE` `redeemScript`, for instance.\n\nUsing an `OP_TRUE` `redeemScript` would allow any third party to make you cry by opportunistically spending such an output.\nFor example your Bitcoin-network peer could notice you broadcasting such a transaction with an `OP_TRUE` output, see you spend that output with a CPFP-RBF-ed child transaction, then instead of further broadcasting the child transaction, instead broadcast a non-RBF child transaction with tiny fee, so that it and its parent transaction will be accepted into mempools but would not be replaceable with a higher-feerate child transaction (because not RBF-flagged).\nThus, some portion of mempools will contain this poisoned low-fee child transaction and prevent the parent from being confirmed (because the parent+child fees are not enough to justify being put in a block).\nWhich I suppose is an argument for Full RBF aka ignore-the-RBF-flag-and-always-RBF.\n\nThe solution that I remember being proposed for this in Lightning was to give each participant its own attach-your-fees output that only that participant can spend, which works for Lightning because the set of participants in a channel is permanently fixed, but probably not for statechains.\n\n--\n\nThe broadcasting of the kickoff simply means that the first stage cannot be easily changed, and you might still be able to make further updates by updating only the later stages, until the last stage is confirmable, so the kickoff being broadcast simply creates a \"dead man walking\" statechain.\nHowever, the implementation complexity would probably increase tremendously.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Ruben Somsen",
                "date": "2020-03-27T15:12:33",
                "message_text_only": "Hi ZmnSCPxj,\n\nI appreciate the input.\n\n>Any standardness issue can be fixed by embedding it in a P2WSH / P2SH, you\ncan use an `OP_TRUE` `redeemScript`, for instance.\n\nGood point. I guess the conversation I recall reading must have been about\navoiding p2sh in order to lower the tx size.\n\n>broadcast a non-RBF child transaction with tiny fee, so that it and its\nparent transaction will be accepted into mempools but would not be\nreplaceable\n\nI believe this is solved by inherited signalling. As long as the kickoff tx\nis RBF enabled (and unconfirmed), any transaction spending it automatically\ninherits its RBF status. See:\nhttps://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki#Summary\n\n>The broadcasting of the kickoff simply means that the first stage cannot\nbe easily changed\n\nI see what you're saying. Yeah, it does ruin the stages. If the kickoff tx\nhits the chain, you'd probably just want to \"refresh\" the UTXO by agreeing\nwith the statechain entity to spend it to a new statechain 2-of-2 UTXO\non-chain, thus removing all prior owners. Ideally you'd want it to be more\ncostly to CPFP the kickoff tx than it is to refresh the UTXO, so the\ndefender is at an advantage. The statechain entity should probably pay for\nevery refresh (\"insurance\"), since the actual owner isn't at fault.\n\nCheers,\nRuben\n\n\nOn Fri, Mar 27, 2020 at 2:46 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Ruben,\n>\n> > Hey Christian,\n> >\n> > Thanks for chiming in :)\n> >\n> > >It might be worth adopting the late fee binding we have in eltoo\n> >\n> > That is where my thinking originally went as well, but then I remembered\n> that this alters the txid, causing the settlement tx to become invalid.\n> What I am suggesting should be functionally the same (albeit less\n> space-efficient): a secondary output that can be spent by anyone, which can\n> be used to fee bump the kickoff tx with CPFP. I believe this same idea was\n> considered for Lightning as well at some point. Do you happen to recall if\n> there was some kind of non-standardness issue with it?\n>\n> Any standardness issue can be fixed by embedding it in a P2WSH / P2SH, you\n> can use an `OP_TRUE` `redeemScript`, for instance.\n>\n> Using an `OP_TRUE` `redeemScript` would allow any third party to make you\n> cry by opportunistically spending such an output.\n> For example your Bitcoin-network peer could notice you broadcasting such a\n> transaction with an `OP_TRUE` output, see you spend that output with a\n> CPFP-RBF-ed child transaction, then instead of further broadcasting the\n> child transaction, instead broadcast a non-RBF child transaction with tiny\n> fee, so that it and its parent transaction will be accepted into mempools\n> but would not be replaceable with a higher-feerate child transaction\n> (because not RBF-flagged).\n> Thus, some portion of mempools will contain this poisoned low-fee child\n> transaction and prevent the parent from being confirmed (because the\n> parent+child fees are not enough to justify being put in a block).\n> Which I suppose is an argument for Full RBF aka\n> ignore-the-RBF-flag-and-always-RBF.\n>\n> The solution that I remember being proposed for this in Lightning was to\n> give each participant its own attach-your-fees output that only that\n> participant can spend, which works for Lightning because the set of\n> participants in a channel is permanently fixed, but probably not for\n> statechains.\n>\n> --\n>\n> The broadcasting of the kickoff simply means that the first stage cannot\n> be easily changed, and you might still be able to make further updates by\n> updating only the later stages, until the last stage is confirmable, so the\n> kickoff being broadcast simply creates a \"dead man walking\" statechain.\n> However, the implementation complexity would probably increase\n> tremendously.\n>\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200327/c11adfcc/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-03-28T02:20:33",
                "message_text_only": "Good morning Ruben,\n\n\n> >The broadcasting of the kickoff simply means that the first stage cannot be easily changed\n>\n> I see what you're saying. Yeah, it does ruin the stages. If the kickoff tx hits the chain, you'd probably just want to \"refresh\" the UTXO by agreeing with the statechain entity to spend it to a new statechain 2-of-2 UTXO on-chain, thus removing all prior owners. Ideally you'd want it to be more costly to CPFP the kickoff tx than it is to refresh the UTXO, so the defender is at an advantage. The statechain entity should probably pay for every refresh (\"insurance\"), since the actual owner isn't at fault.\n\nActually, thinking a little more, it seems that you can try to ensure that the first stage never drops to 0 relative locktime.\nThen if somebody broadcasts the kick-off, the current owner can ask the statechain entity to sign an alternative to the first stage, with 0 relative locktime, that can now be a new funding transaction to anchor a (actually new, but logically a continuation) statechain.\n\nRegards,\nZmnSCPxj\n\n>\n> Cheers,\n> Ruben\n>\n> On Fri, Mar 27, 2020 at 2:46 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> > Good morning Ruben,\n> >\n> > > Hey Christian,\n> > >\n> > > Thanks for chiming in :)\n> > >\n> > > >It might be worth adopting the late fee binding we have in eltoo\n> > >\n> > > That is where my thinking originally went as well, but then I remembered that this alters the txid, causing the settlement tx to become invalid. What I am suggesting should be functionally the same (albeit less space-efficient): a secondary output that can be spent by anyone, which can be used to fee bump the kickoff tx with CPFP. I believe this same idea was considered for Lightning as well at some point. Do you happen to recall if there was some kind of non-standardness issue with it?\n> >\n> > Any standardness issue can be fixed by embedding it in a P2WSH / P2SH, you can use an `OP_TRUE` `redeemScript`, for instance.\n> >\n> > Using an `OP_TRUE` `redeemScript` would allow any third party to make you cry by opportunistically spending such an output.\n> > For example your Bitcoin-network peer could notice you broadcasting such a transaction with an `OP_TRUE` output, see you spend that output with a CPFP-RBF-ed child transaction, then instead of further broadcasting the child transaction, instead broadcast a non-RBF child transaction with tiny fee, so that it and its parent transaction will be accepted into mempools but would not be replaceable with a higher-feerate child transaction (because not RBF-flagged).\n> > Thus, some portion of mempools will contain this poisoned low-fee child transaction and prevent the parent from being confirmed (because the parent+child fees are not enough to justify being put in a block).\n> > Which I suppose is an argument for Full RBF aka ignore-the-RBF-flag-and-always-RBF.\n> >\n> > The solution that I remember being proposed for this in Lightning was to give each participant its own attach-your-fees output that only that participant can spend, which works for Lightning because the set of participants in a channel is permanently fixed, but probably not for statechains.\n> >\n> > --\n> >\n> > The broadcasting of the kickoff simply means that the first stage cannot be easily changed, and you might still be able to make further updates by updating only the later stages, until the last stage is confirmable, so the kickoff being broadcast simply creates a \"dead man walking\" statechain.\n> > However, the implementation complexity would probably increase tremendously.\n> >\n> > Regards,\n> > ZmnSCPxj"
            },
            {
                "author": "Bob McElrath",
                "date": "2020-03-26T14:52:36",
                "message_text_only": "Very good point, but I think this is easy to fix.\n\nIt's not actually necessary that the quantity in (b) involve the SE's secret key\ns1. It can be purely the blinding factor. This quantity gets relayed through the\nSE anyway, after a round trip through owner 2, where the SE removes the blinding\nnonce. The SE needs to determine the ratio of the two private keys o1*o2_inv.\nThere's no reason for the SE to send anything about s1 other than the public\nkeys S1=s1.G and S2=s2.G, keeping the secret keys s1 and s2 hidden behind ECDLP\nand not sharing quantities involving them in Z_p.\n\nThus:\nb. (SE) x -> (2)\nc. (2) o2_inv*x -> (1) \nd. (1) o1*(o2_inv*x) -> (SE)\ne. (SE) s2 = x_inv*(o1*o2_inv*x)*s1 = o1*o2_inv*s1\n        s2.G -> (2)\nf. (2) o2.s2.G = o1.s1.G = P\n\nNow we could have had a different problem, in step (e) if the SE sends owner 2\nthe quantity o1*o2_inv*s1, a self-sending owner can determine a similar quantity\nto what you described (x1+x2)*s1: (o1*o2_inv + o2*o3_inv)*s1 and we're back to\nan Irwin-Hall distribution.\n\nIt's not necessary to send a quantity involving s1 in steps (b-e). Owner 2\nalready has his private key o2 and the SE has his new private key\ns2=o1*o2_inv*s1. Since P=o1.s1.G=o2.s2.G we're set up for o2 to transfer the\nfunds, but it's necessary to prove to (2) that his o2 does in fact control the\nUTXO. This can be done by sending (2) the public key S2=s2.G which he can\nmultiply by o2 to get P=o2.s2.G and verify that the SE does have the correct\nprivate key corresponding to his o2 for the public key P recorded on-chain.\n\nThus in the self-send situation, the owner no longer has any algebraic relations\nhe can use as you describe.\n\nAlgebraic relations remain in step (d) that a self-sending owner could use, but\nthey all involve his own private keys, which he knows anyway. He has only one\nrelation from the previous owner and all subsequent relations do not involve\nthat owner. However if a pair of entities send funds back and forth, each owner\ncould collect a sum as you describe, if the counterparty (2) re-uses keys:\n    o2_inv*(x1 + x2)\nThe SE has similar relations in step (e) if there's key reuse.  Therefore it's\nimportant that on each transfer, you generate a new key and do not re-use keys.\nA responsible SE could detect a key-reuse situation by e.g.  recording old\npubkeys P1, P2 even though he deleted s1 and s2, and inform the user of the\nkey-reuse error and abort.\n\nDo you think that works?\n\nP.S. SGX is not \"trust minimization\", it's \"trust transfer\" -- specifically to\nthe keys managing the SGX. If we thought processor manufacturers were better at\nkey management than the rest of us, we should just hand them the task. I don't\nthink that's the case, and I don't think anyone else does either. An SGX\nattestation as an optional add-on I think is a worthwhile enhancement, as long\nas it's not on the critical path of the protocol.\n\nAlbert via bitcoin-dev [bitcoin-dev at lists.linuxfoundation.org] wrote:\n> Hi,\n> \n> Great to see some work in this direction, here's some thoughts on your keygen\n> scheme:\n> \n> In the scenario where Owner1=Owner2, that is, one of the owners sends some\n> coins to itself, that owner would get to know both x1*s1 and x2*s2=\n> x2*s1*o2_inv*o1, and, because he already knows o1 and o2, that implies\n> knowledge of both x1*s1 and x2*s1 where x1 and x2 are random numbers sampled\n> from an uniform distribution. Once the owner has these two numbers, he can just\n> sum these together to obtain s1*(x1+x2).\n> Now, because of the central limit theorem, the distribution of x1+x2 should\n> approximate a normal one, concretely an Irwin\u2013Hall distribution, with that\n> approximation getting better when more numbers are collected through iterations\n> of the protocol. Once you've collected enough numbers to approximate a normal\n> well enough (looking at Irwin Hall distribution graphs^[1] you can observe that\n> with less than 10 samples the distribution is already pretty similar to a\n> normal one), it should be possible to drastically reduce the search space and\n> apply brute force to guess the value of \\sum x and, consequently, s1.\n> \n> Practically, it's possible that the search space is still too large for\n> brute-force to be fruitful, so this attack might not work, but it shows that\n> there is information leakage in every protocol iteration.\n> \n> On another note, if you are not already aware of, something which might be\n> worth looking into is the possibility of further trust-minimising the SE role\n> by forcing it's code to be run inside an AWS oracle or a hardware isolated\n> processor such as SGX.\n> \n> Albert\n> \n> [1] https://en.wikipedia.org/wiki/Irwin%E2%80%93Hall_distribution\n> \n> On Wed, Mar 25, 2020, at 9:52 PM, Tom Trevethan via bitcoin-dev wrote:\n> \n>     Hi all,\n> \n>     We are starting to work on an implementation of the statechains concept (\n>     https://medium.com/@RubenSomsen/\n>     statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39), with\n>     particular interest in using the protocol enable the change of ownership\n>     (novation) of an individual position in an active discreet log contract\n>     (DLC) without an on-chain transaction, and without needing the cooperation\n>     of the counterparty. The protocol as outlined by Ruben requires features\n>     not currently available in Bitcoin (like SIGHASH_NOINPUT), and it is\n>     uncertain when (or even if) this will be added. So we are looking at\n>     variants that would work with current Bitcoin functionality, and it would\n>     be good to get some feedback on them.\n> \n>     There are two main modifications we are looking at:\n>     1. Instead of an eltoo-based backup/refund transaction (enabling the\n>     current owner to claim the UTXO in case the statechain entity disappears)\n>     we propose using a decrementing nLocktime for backup transactions as the\n>     output changes hands. Here, the first owner gets a backup transaction with\n>     an nLocktime at some future height (h0), then the next owner gets a backup\n>     transaction with nLocktime (h0-c) where c is a confirmation window. This\n>     approach has the downside of limiting the lifetime of the UTXO, but it also\n>     doesn't require the current owner to be always online.\n> \n>     2. Replacing the 2-of-2 multisig output (paying to statechain entity SE key\n>     and transitory key) with a single P2(W)PKH output where the public key\n>     shared between the SE and the current owner. The SE and the current owner\n>     can then sign with a 2-of-2 ECDSA MPC. This enables each owner to generate\n>     their own private key share, and the SE changes their key share at each\n>     change of ownership (with the shared public key remaining the same). This\n>     works as follows (.G is EC point multiplication, * is scalar\n>     multiplication):\n> \n>     KeyGen:\n> \n>     a. Owner 1 generates private key share o1 then calculates the corresponding\n>     public key of the share O1 and sends it to the SE: O1 = o1.G\n>     b. The SE then generates a private key: s1 (the SE private key share),\n>     calculates the corresponding public key and sends it to Owner 1: S1 = s1.G\n>     c. Both SE and Owner 1 then multiply the public keys they receive by their\n>     own private key shares to obtain the same shared public key P (which\n>     corresponds to a shared private key of p = o1*s1): P = o1.(s1.G) = s1.\n>     (o1.G)\n>     d. Owner 1 creates a funding transaction (Tx0) to pay an amount A to the\n>     address corresponding to P (but doesn't sign it).\n>     e. Once Owner 1 and SE cooperatively sign the first backup transaction,\n>     Owner 1 then signs and broadcasts the deposit transaction Tx0.\n> \n>     Transfer from Owner 1 to Owner 2:\n> \n>     a. Owner 2 generates two private keys: o2 (the new owner UTXO private key\n>     share) and b2 (the new owner refund private key).\n>     b. The SE generates a temporary blinding nonce x and calculates the value\n>     x*s1 and sends this securely to Owner 2.\n>     c. Owner 2 then multiplies this received value by the modular inverse of o2\n>     (o2_inv) and then sends this value (x*s1*o2_inv), to Owner 1.\n>     d. Owner 1 then multiplies this received value by the key share o1 and\n>     sends the resulting value (x*s1*o2_inv*o1) to the SE.\n>     e. The SE then multiplies this received value by the modular inverse of the\n>     temporary nonce (x_inv) to obtain x*s1*o2_inv*o1*x_inv. This cancels the\n>     blinding nonce x to give s1*o2_inv*o1. This value, when multiplied by the\n>     new owner key share o2 equals the original shared private key s1*o1.\n>     f. The SE then sets this value equal to s2 = s1*o2_inv*o1 and deletes s1.\n>     s2 and o2 are now the key shares of `P` and can be used to colaboritively\n>     sign (with 2P ECDSA). So long as the SE delets s1, the old owner key share\n>     (o1) is of no use in deriving or co-signing with the full shared private\n>     key, and is invalidated.\n>     g. The shared public key P remains unchanged, but the corresponding private\n>     key (which no individual party ever has knowledge of or can derive) can\n>     only be determined from the key shares of the SE and Owner 2 (i.e. P =\n>     s2*o2.G).\n>     h. Owner 2 then calculates their backup public key (B2 = b2.G) and sends it\n>     to the SE.\n>     i. The SE creates a backup transaction (Tx2) that pays the output of Tx0 to\n>     the address corresponding to B2 , with `nLockTime` set to a block height h0\n>     - c0, where c0, is a confirmation time sufficient to guarantee that Tx2 can\n>     be confirmed in the blockchain before Tx1 (therefore making Tx1 invalid).\n>     j. Owner 2 and the SE then cooperate to sign Tx2 with shared key (P) using\n>     the 2P ECDSA protocol, which Owner 2 then saves.\n> \n>     The principle of the logic of the key transfer is that the two separate key\n>     shares are updated, but the full shared private key (which no-one knows)\n>     remains the same. The new owner chooses a new secret value for their\n>     private key share, and this (along with the private key share of the\n>     previous owner) is utilized by the SE to update their share. The use of the\n>     nonce (x) prevents any of the participants from determining any information\n>     about each others secret keys. In this way Owner 2 cannot determine s1 from\n>     x*s1, Owner 1 cannot determine s1 or o2 from x*s1*o2_inv and the SE cannot\n>     determine o1 or o2 from x*s1*o2_inv*o1.\n> \n>     This transfer protocol can be repeated to transfer the ownership to new\n>     owners. Each time the SE key share sX is updated, the previous key shares\n>     become invalid and are of no use even if the current key share is\n>     subsequently revealed. The SE still needs to be trusted to delete the old\n>     key share, but this protocol removes the risk the the SE can be hacked by a\n>     previous owner to steal the funds.\n> \n>     Any comments on the above would be greatly appreciated.\n> \n>     Tom\n>     _______________________________________________\n>     bitcoin-dev mailing list\n>     bitcoin-dev at lists.linuxfoundation.org\n>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> \n> \n> !DSPAM:5e7c2da240641930319229!\n\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> \n> !DSPAM:5e7c2da240641930319229!\n\n--\nCheers, Bob McElrath\n\n\"For every complex problem, there is a solution that is simple, neat, and wrong.\"\n    -- H. L. Mencken"
            },
            {
                "author": "Bob McElrath",
                "date": "2020-03-27T17:10:18",
                "message_text_only": "Big picture, it seems to me this idea is workable and very interesting. I see\nthree likely enhancements that will be necessary or desirable:\n    1. Atomic swap of multiple UTXOs, and binary decomposition of value in lots\n    2. Key exchange (\"addresses\") to facilitate a secure comms path from \n        sender -> receiver\n    3. (Optional) single-use seals to close old state\n\n(1) It's unlikely that a party sending a UTXO to another party will have a UTXO\nof exactly the right size that's needed, already locked into the statechain. If\nhe has to create the UTXO first and then lock it into the statechain, the\nstatechain solution is no better than an on-chain send. And once the receiver\nhas the UTXO, it's unlikely that he will want to send exactly that same amount\nto another receiver later. This isn't a problem in Lightning where amounts can\nbe arbitrarily updated. As a consequence, I think Lightning is more valuable for\nsmall-value payments, and statechains will be more valuable for larger values.\n\nThe natural solution is to decompose your outputs in a binary decomposition,\nhaving e.g. UTXOs with 1048576 satoshis, another with 2097152 satoshis, and so\non. Then when I want to send, I select the appropriate UTXOs as a binary\ndecomposition of the value I want to send, with a \"lot size\" of 1048576\nsatoshis, or the dust limit. The notion of \"lots\" like this is common in\ntraditional markets...many stocks are bought and sold in lots of 100, and forex\nis traded in lots of $100,000. Users of a statechain therefore need log(V)\navailable UTXOs locked into the statechain, where V is their value in BTC.\nHaving fixed lot sizes like this also makes coinjoin-type uses more viable. The\nstatechain could also assist in dividing a UTXO into two utxos of the next lot\nsize down, so that I have the right UTXOs to hit the value I want to send.\n\nThis means that the statechain now has to *atomically* swap multiple UTXOs. In\nprinciple, it should be possible for a statechain to circumvent the\nPagnia-G\u00e4rtner theorem[1] as it is a trusted third party, but guaranteed output\ndelivery will still be a problem. If a statechain can do this, it is also\ncapable of performing such swaps across two blockchains, creating the\nexecution/clearing element (but not order book) for a DEX. This same mechanism\ncan also be used to pay the SE for its service through a different UTXO than the\none being transferred.\n\nSecond (2), the steps in Tom's protocol presuppose a secure communications path\nfrom the sender's wallet to the receiver's. This is probably not practical for a\nmyriad of reasons, but this data can be relayed through the SE if it is\nencrypted for the target. This implies a new kind of \"address\" or \"payment\nrequest\" that identifies the IP of the SE in use, pubkey of the\nsender/recipient, and amount. If sender and receiver have each other's pubkeys\nthrough another channel, as addresses/lightning payment requests are used today,\nthey can perform a Diffie-Hellman round mediated by the SE to establish a secure\ncommunications path for the rounds of the protocol. Piggybacking on the\nLightning p2p network might be another option.\n\nThird (3), a logical enhancement would be to use some kind of single-use seal,\nwhich is \"opened\" when the UTXO is created or transferred, and \"closed\" when it\nis transferred again. Thus a receiver can ensure that the sender is the holder\nof current state and not some old state.  It's a good idea from Peter Todd, and\nTom's Mainstay[2] may be a way to do it. The SE itself can maintain a rolling\nsingle-use seal Merkle root, periodically timestamped into Bitcoin for faster\ntime resolution than Bitcoin, if you trust the SE but not your counterparty\n(which is the trust assumption present in the first place). Getting Bitcoin\nitself to reject backout transactions from closed seals is another problem...but\nhaving a single-use seal implementation involved is a start.\n\n.. [1] https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.44.7863\n\n.. [2] https://mainstay.xyz\n\nTom Trevethan via bitcoin-dev [bitcoin-dev at lists.linuxfoundation.org] wrote:\n> Hi all,\n> \n> We are starting to work on an implementation of the statechains concept (https:\n> //medium.com/@RubenSomsen/\n> statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39), with\n> particular interest in using the protocol enable the change of ownership\n> (novation) of an individual position in an active discreet log contract (DLC)\n> without an on-chain transaction, and without needing the cooperation of the\n> counterparty. The protocol as outlined by Ruben requires features not currently\n> available in Bitcoin (like SIGHASH_NOINPUT), and it is uncertain when (or even\n> if) this will be added. So we are looking at variants that would work with\n> current Bitcoin functionality, and it would be good to get some feedback on\n> them.\n> \n> There are two main modifications we are looking at:\n> 1. Instead of an eltoo-based backup/refund transaction (enabling the current\n> owner to claim the UTXO in case the statechain entity disappears) we propose\n> using a decrementing nLocktime for backup transactions as the output changes\n> hands. Here, the first owner gets a backup transaction with an nLocktime at\n> some future height (h0), then the next owner gets a backup transaction with\n> nLocktime (h0-c) where c is a confirmation window. This approach has the\n> downside of limiting the lifetime of the UTXO, but it also doesn't require the\n> current owner to be always online.\n> \n> 2. Replacing the 2-of-2 multisig output (paying to statechain entity SE key and\n> transitory key) with a single P2(W)PKH output where the public key shared\n> between the SE and the current owner. The SE and the current owner can then\n> sign with a 2-of-2 ECDSA MPC. This enables each owner to generate their own\n> private key share, and the SE changes their key share at each change of\n> ownership (with the shared public key remaining the same). This works as\n> follows (.G is EC point multiplication, * is scalar multiplication):\n> \n> KeyGen:\n> \n> a. Owner 1 generates private key share o1 then calculates the corresponding\n> public key of the share O1 and sends it to the SE: O1 = o1.G\n> b. The SE then generates a private key: s1 (the SE private key share),\n> calculates the corresponding public key and sends it to Owner 1: S1 = s1.G\n> c. Both SE and Owner 1 then multiply the public keys they receive by their own\n> private key shares to obtain the same shared public key P (which corresponds to\n> a shared private key of p = o1*s1): P = o1.(s1.G) = s1.(o1.G)\n> d. Owner 1 creates a funding transaction (Tx0) to pay an amount A to the\n> address corresponding to P (but doesn't sign it).\n> e. Once Owner 1 and SE cooperatively sign the first backup transaction, Owner 1\n> then signs and broadcasts the deposit transaction Tx0.\n> \n> Transfer from Owner 1 to Owner 2:\n> \n> a. Owner 2 generates two private keys: o2 (the new owner UTXO private key\n> share) and b2 (the new owner refund private key).\n> b. The SE generates a temporary blinding nonce x and calculates the value x*s1\n> and sends this securely to Owner 2.\n> c. Owner 2 then multiplies this received value by the modular inverse of o2\n> (o2_inv) and then sends this value (x*s1*o2_inv), to Owner 1.\n> d. Owner 1 then multiplies this received value by the key share o1 and sends\n> the resulting value (x*s1*o2_inv*o1) to the SE.\n> e. The SE then multiplies this received value by the modular inverse of the\n> temporary nonce (x_inv) to obtain x*s1*o2_inv*o1*x_inv. This cancels the\n> blinding nonce x to give s1*o2_inv*o1. This value, when multiplied by the new\n> owner key share o2 equals the original shared private key s1*o1.\n> f. The SE then sets this value equal to s2 = s1*o2_inv*o1 and deletes s1. s2\n> and o2 are now the key shares of `P` and can be used to colaboritively sign\n> (with 2P ECDSA). So long as the SE delets s1, the old owner key share (o1) is\n> of no use in deriving or co-signing with the full shared private key, and is\n> invalidated.\n> g. The shared public key P remains unchanged, but the corresponding private key\n> (which no individual party ever has knowledge of or can derive) can only be\n> determined from the key shares of the SE and Owner 2 (i.e. P = s2*o2.G).\n> h. Owner 2 then calculates their backup public key (B2 = b2.G) and sends it to\n> the SE.\n> i. The SE creates a backup transaction (Tx2) that pays the output of Tx0 to the\n> address corresponding to B2 , with `nLockTime` set to a block height h0 - c0,\n> where c0, is a confirmation time sufficient to guarantee that Tx2 can be\n> confirmed in the blockchain before Tx1 (therefore making Tx1 invalid).\n> j. Owner 2 and the SE then cooperate to sign Tx2 with shared key (P) using the\n> 2P ECDSA protocol, which Owner 2 then saves.\n> \n> The principle of the logic of the key transfer is that the two separate key\n> shares are updated, but the full shared private key (which no-one knows)\n> remains the same. The new owner chooses a new secret value for their private\n> key share, and this (along with the private key share of the previous owner) is\n> utilized by the SE to update their share. The use of the nonce (x) prevents any\n> of the participants from determining any information about each others secret\n> keys. In this way Owner 2 cannot determine s1 from x*s1, Owner 1 cannot\n> determine s1 or o2 from x*s1*o2_inv and the SE cannot determine o1 or o2 from\n> x*s1*o2_inv*o1.\n> \n> This transfer protocol can be repeated to transfer the ownership to new owners.\n> Each time the SE key share sX is updated, the previous key shares become\n> invalid and are of no use even if the current key share is subsequently\n> revealed. The SE still needs to be trusted to delete the old key share, but\n> this protocol removes the risk the the SE can be hacked by a previous owner to\n> steal the funds.\n> \n> Any comments on the above would be greatly appreciated.\n> \n> Tom\n> !DSPAM:5e7b7203210751402398759!\n\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> \n> !DSPAM:5e7b7203210751402398759!\n\n--\nCheers, Bob McElrath\n\n\"For every complex problem, there is a solution that is simple, neat, and wrong.\"\n    -- H. L. Mencken \n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 181 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200327/72079e39/attachment-0001.sig>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-03-28T02:42:27",
                "message_text_only": "Good morning Bob,\n\n> Big picture, it seems to me this idea is workable and very interesting. I see\n> three likely enhancements that will be necessary or desirable:\n> 1. Atomic swap of multiple UTXOs, and binary decomposition of value in lots\n> 2. Key exchange (\"addresses\") to facilitate a secure comms path from\n> sender -> receiver\n>\n>     3. (Optional) single-use seals to close old state\n>\n>\n> (1) It's unlikely that a party sending a UTXO to another party will have a UTXO\n> of exactly the right size that's needed, already locked into the statechain. If\n> he has to create the UTXO first and then lock it into the statechain, the\n> statechain solution is no better than an on-chain send. And once the receiver\n> has the UTXO, it's unlikely that he will want to send exactly that same amount\n> to another receiver later. This isn't a problem in Lightning where amounts can\n> be arbitrarily updated. As a consequence, I think Lightning is more valuable for\n> small-value payments, and statechains will be more valuable for larger values.\n>\n> The natural solution is to decompose your outputs in a binary decomposition,\n> having e.g. UTXOs with 1048576 satoshis, another with 2097152 satoshis, and so\n> on. Then when I want to send, I select the appropriate UTXOs as a binary\n> decomposition of the value I want to send, with a \"lot size\" of 1048576\n> satoshis, or the dust limit. The notion of \"lots\" like this is common in\n> traditional markets...many stocks are bought and sold in lots of 100, and forex\n> is traded in lots of $100,000. Users of a statechain therefore need log(V)\n> available UTXOs locked into the statechain, where V is their value in BTC.\n> Having fixed lot sizes like this also makes coinjoin-type uses more viable. The\n> statechain could also assist in dividing a UTXO into two utxos of the next lot\n> size down, so that I have the right UTXOs to hit the value I want to send.\n\nMy understanding of statechains is that nothing prevents the statechain from internally having multiple UTXOs divided from a single large onchain UTXO.\n\nIndeed, a statechain can act much like a federated blockchain, and the interface to the statechain could be for its clients to send a Bitcoin transaction to it spending 1 or more of the UTXOs currently instantiated inside the statechain.\nThen the statechain validates the client Bitcoin transaction, updates its state and republishes it to its clients, removing the (internal-to-statechain-only) UTXOs spent, and inserting the new UTXOs of the incoming transaction.\n\nFor example, suppose I have a 1BTC onchain UTXO that I use to create a new statechain:\n\n    [funding tx]->1BTC(SE)-+  (onchain)\n    _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _\n              (statechain) |\n                           +->[update mechanism]->1BTC(ZmnSCPxj)\n\nThen I send to the statechain a transaction spending my 1BTC-on-statechain, giving you 0.11568768 BTC:\n\n    [funding tx]->1BTC(SE)-+  (onchain)\n    _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _\n              (statechain) |\n                           +->[update mechanism]->1BTC(ZmnSCPxj)->[tx]-+->0.11568768BTC(bsm117532)\n                                                                       +->0.88431232BTC(ZmnSCPxj)\n\nThe statechain verifies that the tx I sent is valid, then outputs the next state as below:\n\n    [funding tx]->1BTC(SE)-+  (onchain)\n    _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _\n              (statechain) |\n                           +->[update mechanism]-+->0.11568768BTC(bsm117532)\n                                                 +->0.88431232BTC(ZmnSCPxj)\n\nIn short, statechains can be implemented as a sort of super-transaction-cutthrough system.\n\nThis prevents the onchain UTXO from having a single logical owner, of course, so onchain it is the statechain entity that owns the entire fund, but if you are trusting the statechain entity anyway, the update mechanism is sufficient to ensure that nobody (other than the trusted statechain) can prevent the publication of the latest accepted state.\n\nThis is probably significantly more efficient than splitting up the 1BTC value to multiple lots.\n\nI think this framework will work for all offchain mechanisms (CoinSwap, Lightning, statechains), by the way --- you can always view the offchain update mechanism as logically implementing a \"new\" cryptocurrency system that maintains UTXO sets and allows removal and insertion of UTXO sets according to the same rules (sans relative-locktime) as the hosting cryptocurrency system (i.e. the blockchain).\nThe same realization is what underlies channel factories as well --- the hosting cryptocurrency system need not be a blockchain, it can be just another cryptocurrency system (of which a blockchain is just one kind).\n\nMy understanding is that the original description, which describes transferring the entire value inside the statechain to a new owner, was only for exposition and that it was an exercise for the reader to consider how a statechain can internally split the total value among multiple UTXOs.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Ruben Somsen",
                "date": "2020-03-28T17:38:47",
                "message_text_only": "Hi Bob,\n\nLooks like we're largely thinking along the same lines.\n\nIt's unlikely that a party sending a UTXO to another party will have a UTXO\n> of exactly the right size that's needed\n\n\nMy original proposal uses adaptor signatures to ensure swapping UTXOs is\natomic. All parties choose a secret, then they all make adaptor signatures,\nthen they reveal their secret to the statechain entity. The SE then\npublishes the signatures, causing everyone to learn the secret. And if the\nSE doesn't publish, it simply means the transfer didn't occur.\n\nBut taking a step back and thinking about an MVP, it may be easier to make\nit more like a fully audited transparent blockchain where multiple users\ncreate a combined transaction of all the UTXOs they want to swap, which is\npublished together with all the corresponding Bitcoin transactions. Then\nadaptor signatures aren't needed.\n\nThe downside of that method is that you lose the ability to only validate\nthe history of the coins you hold (scalability win). For this to be\npossible, you need to keep the history of every individual UTXO completely\nseparate. I still think that is where we eventually want to end up (as well\nas having blind signatures), but it adds a lot of complexity (adaptor\nsignatures, sparse merkle trees with non-inclusion proofs...).\n\nThe natural solution is to decompose your outputs in a binary decomposition\n\n\nI fully agree, but on top of that I think we also need Lightning,\nbecause....\n\nThis same mechanism can also be used to pay the SE for its service through\n> a different UTXO than the one being transferred.\n\n\nMy conclusion was that opening a Lightning channel on top of a statechain\nmakes more sense for this (as ZmnSCPxj explained in his reply to you). If\nwe expect BTC fees to go up, we can't expect the statechain to hold UTXOs\nthat are small enough to be used to pay for statechain fees.\n\nMore on this in my Breaking Bitcoin 2019 talk (timestamped link):\nhttps://youtu.be/09HcYRjDkMA?t=850\n\na logical enhancement would be to use some kind of single-use seal\n\n\nAny kind of system where users transfer ownership through signatures will\nresemble single-use seals, so I'd say that's inevitable! :)\n\nCheers,\nRuben\n\n\nOn Sat, Mar 28, 2020 at 3:42 AM ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Bob,\n>\n> > Big picture, it seems to me this idea is workable and very interesting.\n> I see\n> > three likely enhancements that will be necessary or desirable:\n> > 1. Atomic swap of multiple UTXOs, and binary decomposition of value in\n> lots\n> > 2. Key exchange (\"addresses\") to facilitate a secure comms path from\n> > sender -> receiver\n> >\n> >     3. (Optional) single-use seals to close old state\n> >\n> >\n> > (1) It's unlikely that a party sending a UTXO to another party will have\n> a UTXO\n> > of exactly the right size that's needed, already locked into the\n> statechain. If\n> > he has to create the UTXO first and then lock it into the statechain, the\n> > statechain solution is no better than an on-chain send. And once the\n> receiver\n> > has the UTXO, it's unlikely that he will want to send exactly that same\n> amount\n> > to another receiver later. This isn't a problem in Lightning where\n> amounts can\n> > be arbitrarily updated. As a consequence, I think Lightning is more\n> valuable for\n> > small-value payments, and statechains will be more valuable for larger\n> values.\n> >\n> > The natural solution is to decompose your outputs in a binary\n> decomposition,\n> > having e.g. UTXOs with 1048576 satoshis, another with 2097152 satoshis,\n> and so\n> > on. Then when I want to send, I select the appropriate UTXOs as a binary\n> > decomposition of the value I want to send, with a \"lot size\" of 1048576\n> > satoshis, or the dust limit. The notion of \"lots\" like this is common in\n> > traditional markets...many stocks are bought and sold in lots of 100,\n> and forex\n> > is traded in lots of $100,000. Users of a statechain therefore need\n> log(V)\n> > available UTXOs locked into the statechain, where V is their value in\n> BTC.\n> > Having fixed lot sizes like this also makes coinjoin-type uses more\n> viable. The\n> > statechain could also assist in dividing a UTXO into two utxos of the\n> next lot\n> > size down, so that I have the right UTXOs to hit the value I want to\n> send.\n>\n> My understanding of statechains is that nothing prevents the statechain\n> from internally having multiple UTXOs divided from a single large onchain\n> UTXO.\n>\n> Indeed, a statechain can act much like a federated blockchain, and the\n> interface to the statechain could be for its clients to send a Bitcoin\n> transaction to it spending 1 or more of the UTXOs currently instantiated\n> inside the statechain.\n> Then the statechain validates the client Bitcoin transaction, updates its\n> state and republishes it to its clients, removing the\n> (internal-to-statechain-only) UTXOs spent, and inserting the new UTXOs of\n> the incoming transaction.\n>\n> For example, suppose I have a 1BTC onchain UTXO that I use to create a new\n> statechain:\n>\n>     [funding tx]->1BTC(SE)-+  (onchain)\n>     _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _\n>               (statechain) |\n>                            +->[update mechanism]->1BTC(ZmnSCPxj)\n>\n> Then I send to the statechain a transaction spending my\n> 1BTC-on-statechain, giving you 0.11568768 BTC:\n>\n>     [funding tx]->1BTC(SE)-+  (onchain)\n>     _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _\n>               (statechain) |\n>                            +->[update\n> mechanism]->1BTC(ZmnSCPxj)->[tx]-+->0.11568768BTC(bsm117532)\n>\n>  +->0.88431232BTC(ZmnSCPxj)\n>\n> The statechain verifies that the tx I sent is valid, then outputs the next\n> state as below:\n>\n>     [funding tx]->1BTC(SE)-+  (onchain)\n>     _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _\n>               (statechain) |\n>                            +->[update\n> mechanism]-+->0.11568768BTC(bsm117532)\n>                                                  +->0.88431232BTC(ZmnSCPxj)\n>\n> In short, statechains can be implemented as a sort of\n> super-transaction-cutthrough system.\n>\n> This prevents the onchain UTXO from having a single logical owner, of\n> course, so onchain it is the statechain entity that owns the entire fund,\n> but if you are trusting the statechain entity anyway, the update mechanism\n> is sufficient to ensure that nobody (other than the trusted statechain) can\n> prevent the publication of the latest accepted state.\n>\n> This is probably significantly more efficient than splitting up the 1BTC\n> value to multiple lots.\n>\n> I think this framework will work for all offchain mechanisms (CoinSwap,\n> Lightning, statechains), by the way --- you can always view the offchain\n> update mechanism as logically implementing a \"new\" cryptocurrency system\n> that maintains UTXO sets and allows removal and insertion of UTXO sets\n> according to the same rules (sans relative-locktime) as the hosting\n> cryptocurrency system (i.e. the blockchain).\n> The same realization is what underlies channel factories as well --- the\n> hosting cryptocurrency system need not be a blockchain, it can be just\n> another cryptocurrency system (of which a blockchain is just one kind).\n>\n> My understanding is that the original description, which describes\n> transferring the entire value inside the statechain to a new owner, was\n> only for exposition and that it was an exercise for the reader to consider\n> how a statechain can internally split the total value among multiple UTXOs.\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200328/fa483e0f/attachment-0001.html>"
            },
            {
                "author": "Ruben Somsen",
                "date": "2020-03-28T17:42:58",
                "message_text_only": "Hi ZmnSCPxj,\n\nthe current owner can ask the statechain entity to sign an alternative to\n> the first stage, with 0 relative locktime\n\n\nUnless I am misunderstanding something, this seems to run into the problem\nthat the original first stage transaction is already out there (and its\nrelative timelock started ticking). There is no mechanism ensuring that the\nnew tx will have precedence. And even if it did work, I doubt it's cleaner\nthan doing a cooperative peg-out that simultaneously happens to peg back\nin, creating a brand new statechain UTXO with no history.\n\nCheers,\nRuben\n\nOn Sat, Mar 28, 2020 at 6:38 PM Ruben Somsen <rsomsen at gmail.com> wrote:\n\n> Hi Bob,\n>\n> Looks like we're largely thinking along the same lines.\n>\n> It's unlikely that a party sending a UTXO to another party will have a\n>> UTXO of exactly the right size that's needed\n>\n>\n> My original proposal uses adaptor signatures to ensure swapping UTXOs is\n> atomic. All parties choose a secret, then they all make adaptor signatures,\n> then they reveal their secret to the statechain entity. The SE then\n> publishes the signatures, causing everyone to learn the secret. And if the\n> SE doesn't publish, it simply means the transfer didn't occur.\n>\n> But taking a step back and thinking about an MVP, it may be easier to make\n> it more like a fully audited transparent blockchain where multiple users\n> create a combined transaction of all the UTXOs they want to swap, which is\n> published together with all the corresponding Bitcoin transactions. Then\n> adaptor signatures aren't needed.\n>\n> The downside of that method is that you lose the ability to only validate\n> the history of the coins you hold (scalability win). For this to be\n> possible, you need to keep the history of every individual UTXO completely\n> separate. I still think that is where we eventually want to end up (as well\n> as having blind signatures), but it adds a lot of complexity (adaptor\n> signatures, sparse merkle trees with non-inclusion proofs...).\n>\n> The natural solution is to decompose your outputs in a binary decomposition\n>\n>\n> I fully agree, but on top of that I think we also need Lightning,\n> because....\n>\n> This same mechanism can also be used to pay the SE for its service through\n>> a different UTXO than the one being transferred.\n>\n>\n> My conclusion was that opening a Lightning channel on top of a statechain\n> makes more sense for this (as ZmnSCPxj explained in his reply to you). If\n> we expect BTC fees to go up, we can't expect the statechain to hold UTXOs\n> that are small enough to be used to pay for statechain fees.\n>\n> More on this in my Breaking Bitcoin 2019 talk (timestamped link):\n> https://youtu.be/09HcYRjDkMA?t=850\n>\n> a logical enhancement would be to use some kind of single-use seal\n>\n>\n> Any kind of system where users transfer ownership through signatures will\n> resemble single-use seals, so I'd say that's inevitable! :)\n>\n> Cheers,\n> Ruben\n>\n>\n> On Sat, Mar 28, 2020 at 3:42 AM ZmnSCPxj via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Good morning Bob,\n>>\n>> > Big picture, it seems to me this idea is workable and very interesting.\n>> I see\n>> > three likely enhancements that will be necessary or desirable:\n>> > 1. Atomic swap of multiple UTXOs, and binary decomposition of value in\n>> lots\n>> > 2. Key exchange (\"addresses\") to facilitate a secure comms path from\n>> > sender -> receiver\n>> >\n>> >     3. (Optional) single-use seals to close old state\n>> >\n>> >\n>> > (1) It's unlikely that a party sending a UTXO to another party will\n>> have a UTXO\n>> > of exactly the right size that's needed, already locked into the\n>> statechain. If\n>> > he has to create the UTXO first and then lock it into the statechain,\n>> the\n>> > statechain solution is no better than an on-chain send. And once the\n>> receiver\n>> > has the UTXO, it's unlikely that he will want to send exactly that same\n>> amount\n>> > to another receiver later. This isn't a problem in Lightning where\n>> amounts can\n>> > be arbitrarily updated. As a consequence, I think Lightning is more\n>> valuable for\n>> > small-value payments, and statechains will be more valuable for larger\n>> values.\n>> >\n>> > The natural solution is to decompose your outputs in a binary\n>> decomposition,\n>> > having e.g. UTXOs with 1048576 satoshis, another with 2097152 satoshis,\n>> and so\n>> > on. Then when I want to send, I select the appropriate UTXOs as a binary\n>> > decomposition of the value I want to send, with a \"lot size\" of 1048576\n>> > satoshis, or the dust limit. The notion of \"lots\" like this is common in\n>> > traditional markets...many stocks are bought and sold in lots of 100,\n>> and forex\n>> > is traded in lots of $100,000. Users of a statechain therefore need\n>> log(V)\n>> > available UTXOs locked into the statechain, where V is their value in\n>> BTC.\n>> > Having fixed lot sizes like this also makes coinjoin-type uses more\n>> viable. The\n>> > statechain could also assist in dividing a UTXO into two utxos of the\n>> next lot\n>> > size down, so that I have the right UTXOs to hit the value I want to\n>> send.\n>>\n>> My understanding of statechains is that nothing prevents the statechain\n>> from internally having multiple UTXOs divided from a single large onchain\n>> UTXO.\n>>\n>> Indeed, a statechain can act much like a federated blockchain, and the\n>> interface to the statechain could be for its clients to send a Bitcoin\n>> transaction to it spending 1 or more of the UTXOs currently instantiated\n>> inside the statechain.\n>> Then the statechain validates the client Bitcoin transaction, updates its\n>> state and republishes it to its clients, removing the\n>> (internal-to-statechain-only) UTXOs spent, and inserting the new UTXOs of\n>> the incoming transaction.\n>>\n>> For example, suppose I have a 1BTC onchain UTXO that I use to create a\n>> new statechain:\n>>\n>>     [funding tx]->1BTC(SE)-+  (onchain)\n>>     _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _\n>>               (statechain) |\n>>                            +->[update mechanism]->1BTC(ZmnSCPxj)\n>>\n>> Then I send to the statechain a transaction spending my\n>> 1BTC-on-statechain, giving you 0.11568768 BTC:\n>>\n>>     [funding tx]->1BTC(SE)-+  (onchain)\n>>     _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _\n>>               (statechain) |\n>>                            +->[update\n>> mechanism]->1BTC(ZmnSCPxj)->[tx]-+->0.11568768BTC(bsm117532)\n>>\n>>  +->0.88431232BTC(ZmnSCPxj)\n>>\n>> The statechain verifies that the tx I sent is valid, then outputs the\n>> next state as below:\n>>\n>>     [funding tx]->1BTC(SE)-+  (onchain)\n>>     _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _\n>>               (statechain) |\n>>                            +->[update\n>> mechanism]-+->0.11568768BTC(bsm117532)\n>>\n>>  +->0.88431232BTC(ZmnSCPxj)\n>>\n>> In short, statechains can be implemented as a sort of\n>> super-transaction-cutthrough system.\n>>\n>> This prevents the onchain UTXO from having a single logical owner, of\n>> course, so onchain it is the statechain entity that owns the entire fund,\n>> but if you are trusting the statechain entity anyway, the update mechanism\n>> is sufficient to ensure that nobody (other than the trusted statechain) can\n>> prevent the publication of the latest accepted state.\n>>\n>> This is probably significantly more efficient than splitting up the 1BTC\n>> value to multiple lots.\n>>\n>> I think this framework will work for all offchain mechanisms (CoinSwap,\n>> Lightning, statechains), by the way --- you can always view the offchain\n>> update mechanism as logically implementing a \"new\" cryptocurrency system\n>> that maintains UTXO sets and allows removal and insertion of UTXO sets\n>> according to the same rules (sans relative-locktime) as the hosting\n>> cryptocurrency system (i.e. the blockchain).\n>> The same realization is what underlies channel factories as well --- the\n>> hosting cryptocurrency system need not be a blockchain, it can be just\n>> another cryptocurrency system (of which a blockchain is just one kind).\n>>\n>> My understanding is that the original description, which describes\n>> transferring the entire value inside the statechain to a new owner, was\n>> only for exposition and that it was an exercise for the reader to consider\n>> how a statechain can internally split the total value among multiple UTXOs.\n>>\n>> Regards,\n>> ZmnSCPxj\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200328/31e7991c/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-03-30T01:25:36",
                "message_text_only": "Good morning Ruben,\n\n> Hi ZmnSCPxj,\n>\n> > the current owner can ask the statechain entity to sign an alternative to the first stage, with 0 relative locktime\n>\n> Unless I am misunderstanding something, this seems to run into the problem that the original first stage transaction is already out there (and its relative timelock started ticking). There is no mechanism ensuring that the new tx will have precedence. And even if it did work, I doubt it's cleaner than doing a cooperative peg-out that simultaneously happens to peg back in, creating a brand new statechain UTXO with no history.\n\n\nIf:\n\n* You are sure the old first stage tx has > 0 relative locktime.\n* The replacement tx (which replaces the old first stage) has a 0 relative locktime.\n  * The replacement tx redirects the funds to a new funding output for a (logically continuous, onchain new) statechain.\n\nThen the replacement tx, having a smaller relative locktime than the old first stage, has precedence.\nIndeed, having a *smaller* relative locktime is exactly the mechanism Decker-Wattenhofer uses.\n\nSo this is the state, with the kickoff having just been confirmed onchain:\n\n\n    ***blockchain***\n       [funding tx]->[kickoff tx]-+\n         _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _\n     offchain                     |\n                                  +->[[ 7] stage]->[[ 0] stage]->[[14] stage]-> state outputs\n\nSince the first stage is still \"ticking\" it is not yet confirmable onchain.\n\nYou ask the statechain to create an alternative, 0-relative-locktime, re-funding tx, and create a new mechanism:\n\n    ***blockchain***\n       [funding tx]->[kickoff tx]-+\n         _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _\n     offchain                     |\n                                  +->[[ 7] stage]->[[ 0] stage]->[[14] stage]-> state outputs\n                                 (OR)\n                                  |\n                                  +->[[ 0] funding tx]->[kickoff tx]->[[14] stage]->[[14] stage]->[[14] stage]->state outputs\n\nBecause it has a time advantage, this new re-funding tx has higher priority (and is the same mechanism Decker-Wattenhofer has anyway).\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "David A. Harding",
                "date": "2020-03-31T10:35:08",
                "message_text_only": "On Wed, Mar 25, 2020 at 01:52:10PM +0000, Tom Trevethan via bitcoin-dev wrote:\n> Hi all,\n> \n> We are starting to work on an implementation of the statechains concept (\n> https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39),\n>\n> [...]\n> There are two main modifications we are looking at:\n> [...]\n> \n> 2. Replacing the 2-of-2 multisig output (paying to statechain entity SE key\n> and transitory key) with a single P2(W)PKH output where the public key\n> shared between the SE and the current owner. The SE and the current owner\n> can then sign with a 2-of-2 ECDSA MPC. \n\nDr. Trevethan,\n\nWould you be able to explain how your proposal to use statechains with\n2P-ECDSA relates to your patent assigned to nChain Holdings for \"Secure\noff-chain blockchain transactions\"?[1]  \n\n    [1] https://patents.google.com/patent/US20200074464A1\n\nHere are some excerpts from the application that caught my attention in\nthe context of statechains in general and your proposal to this list in\nparticular:\n\n> an exchange platform that is trusted to implement and operate the\n> transaction protocol, without requiring an on-chain transaction. The\n> off-chain transactions enable one computer system to generate multiple\n> transactions that are recordable to a blockchain in different\n> circumstances\n>\n> [...]\n>\n> at least some of the off-chain transactions are valid for recording on\n> the blockchain even in the event of a catastrophic failure of the\n> exchange (e.g., exchange going permanently off-line or loosing key\n> shares).\n>\n> [...]\n>\n> there may be provided a computer readable storage medium including a\n> two-party elliptic curve digital signature algorithm (two-party ECDSA)\n> script comprising computer executable instructions which, when\n> executed, configure a processor to perform functions of a two-party\n> elliptic curve digital signature algorithm described herein.\n>\n> [...]\n>\n> In this instance the malicious actor would then also have to collude\n> with a previous owner of the funds to recreate the full key. Because\n> an attack requires either the simultaneous theft of both exchange and\n> depositor keys or collusion with previous legitimate owners of funds,\n> the opportunities for a malicious attacker to compromise the exchange\n> platform are limited.\n\nThank you,\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200331/8c3cf059/attachment.sig>"
            },
            {
                "author": "Tom Trevethan",
                "date": "2020-03-31T11:41:46",
                "message_text_only": "Hi David,\n\nJust for clarity, I left nChain over 2 years ago (having worked there since\n2016). While there, I (along with other researchers) were given free rein\nto work on any ideas we wanted to. I had been interested in the scaling of\nBitcoin off-chain, and this was one of several things I spent time on\n(including things like sidechains, pegs and threshold signatures). This\npatent application came out of an idea I had to transfer ownership of UTXOs\noff-chain that has some similarities to the statechains proposal, which has\nshown there is interest and demand for this type of system.\n\nAlthough I think the existence of this application is something to be\nmindful of, there are several important things to note:\n\n1. Although there are similarities, the current ideas are significantly\ndifferent to those in the application.\n2. The key transfer protocol as described in the application is not secure\n(for several reasons, including as discussed above, by Albert and Bob etc.)\n- and a different mechanism is required.\n3. Decrementing timelocks (as suggested in the application) are prior art\n(Decker-Wattenhofer 2015), and in any case any implementation will most\nlikely use an 'invalidation tree' relative locktime backup mechanism for\nopen-ended UTXOs.\n4. The patent application has not been granted (it was made in May 2017)\nand the international search report rejected it on the grounds of prior\nart.\n\nTom\n\nOn Tue, Mar 31, 2020 at 11:36 AM David A. Harding <dave at dtrt.org> wrote:\n\n> On Wed, Mar 25, 2020 at 01:52:10PM +0000, Tom Trevethan via bitcoin-dev\n> wrote:\n> > Hi all,\n> >\n> > We are starting to work on an implementation of the statechains concept (\n> >\n> https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39\n> ),\n> >\n> > [...]\n> > There are two main modifications we are looking at:\n> > [...]\n> >\n> > 2. Replacing the 2-of-2 multisig output (paying to statechain entity SE\n> key\n> > and transitory key) with a single P2(W)PKH output where the public key\n> > shared between the SE and the current owner. The SE and the current owner\n> > can then sign with a 2-of-2 ECDSA MPC.\n>\n> Dr. Trevethan,\n>\n> Would you be able to explain how your proposal to use statechains with\n> 2P-ECDSA relates to your patent assigned to nChain Holdings for \"Secure\n> off-chain blockchain transactions\"?[1]\n>\n>     [1] https://patents.google.com/patent/US20200074464A1\n>\n> Here are some excerpts from the application that caught my attention in\n> the context of statechains in general and your proposal to this list in\n> particular:\n>\n> > an exchange platform that is trusted to implement and operate the\n> > transaction protocol, without requiring an on-chain transaction. The\n> > off-chain transactions enable one computer system to generate multiple\n> > transactions that are recordable to a blockchain in different\n> > circumstances\n> >\n> > [...]\n> >\n> > at least some of the off-chain transactions are valid for recording on\n> > the blockchain even in the event of a catastrophic failure of the\n> > exchange (e.g., exchange going permanently off-line or loosing key\n> > shares).\n> >\n> > [...]\n> >\n> > there may be provided a computer readable storage medium including a\n> > two-party elliptic curve digital signature algorithm (two-party ECDSA)\n> > script comprising computer executable instructions which, when\n> > executed, configure a processor to perform functions of a two-party\n> > elliptic curve digital signature algorithm described herein.\n> >\n> > [...]\n> >\n> > In this instance the malicious actor would then also have to collude\n> > with a previous owner of the funds to recreate the full key. Because\n> > an attack requires either the simultaneous theft of both exchange and\n> > depositor keys or collusion with previous legitimate owners of funds,\n> > the opportunities for a malicious attacker to compromise the exchange\n> > platform are limited.\n>\n> Thank you,\n>\n> -Dave\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200331/5da4965d/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Statechain implementations",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Greg Sanders",
                "David A. Harding",
                "Albert",
                "ZmnSCPxj",
                "Tom Trevethan",
                "Bob McElrath",
                "Ruben Somsen",
                "Christian Decker"
            ],
            "messages_count": 18,
            "total_messages_chars_count": 99616
        }
    }
]