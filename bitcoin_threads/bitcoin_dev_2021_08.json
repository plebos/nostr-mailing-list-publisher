[
    {
        "title": "[bitcoin-dev] Exploring: limiting transaction output amount as a function of total input value",
        "thread_messages": [
            {
                "author": "Zac Greenwood",
                "date": "2021-08-01T08:09:26",
                "message_text_only": "[Resubmitting to list with minor edits. My previous submission ended up\ninside an existing thread, apologies.]\n\nHi list,\n\nI'd like to explore whether it is feasible to implement new scripting\ncapabilities in Bitcoin that enable limiting the output amount of a\ntransaction based on the total value of its inputs. In other words, to\nimplement the ability to limit the maximum amount that can be sent from an\naddress.\n\nTwo use cases come to mind:\n\nUC1: enable a user to add additional protection their funds by\nrate-limiting the amount that they are allowed to send during a certain\nperiod (measured in blocks). A typical use case might be a user that\nintends to hodl their bitcoin, but still wishes to occasionally send small\namounts. Rate-limiting avoids an attacker from sweeping all the users'\nfunds in a single transaction, allowing the user to become aware of the\ntheft and intervene to prevent further thefts.\n\nUC2: exchanges may wish to rate-limit addresses containing large amounts of\nbitcoin, adding warm- or hot-wallet functionality to a cold-storage\naddress. This would enable an exchange to drastically reduce the number of\ntimes a cold wallet must be accessed with private keys that give access to\nthe full amount.\n\nIn a typical setup, I'd envision using multisig such that the user has two\nsets of private keys to their encumbered address (with a \"set\" of keys\nmeaning \"one or more\" keys). One set of private keys allows only for\nsending with rate-limiting restrictions in place, and a second set of\nprivate keys allowing for sending any amount without rate-limiting,\neffectively overriding such restriction.\n\nThe parameters that define in what way an output is rate-limited might be\ndefined as follows:\n\nParam 1: a block height \"h0\" indicating the first block height of an epoch;\nParam 2: a block height \"h1\" indicating the last block height of an epoch;\nParam 3: an amount \"a\" in satoshi indicating the maximum amount that is\nallowed to be sent in any epoch;\nParam 4: an amount \"a_remaining\" (in satoshi) indicating the maximum amount\nthat is allowed to be sent within the current epoch.\n\nFor example, consider an input containing 100m sats (1 BTC) which has been\nrate-limited with parameters (h0, h1, a, a_remaining) of (800000, 800143,\n500k, 500k). These parameters define that the address is rate-limited to\nsending a maximum of 500k sats in the current epoch that starts at block\nheight 800000 and ends at height 800143 (or about one day ignoring block\ntime variance) and that the full amount of 500k is still sendable. These\nrate-limiting parameters ensure that it takes at minimum 100m / 500k = 200\ntransactions and 200 x 144 blocks or about 200 days to spend the full 100m\nsats. As noted earlier, in a typical setup a user should retain the option\nto transact the entire amount using a second (set of) private key(s).\n\nFor rate-limiting to work, any change output created by a transaction from\na rate-limited address must itself be rate-limited as well. For instance,\nexpanding on the above example, assume that the user spends 200k sats from\na rate-limited address a1 containing 100m sats:\n\nStart situation:\nAt block height 800000: rate-limited address a1 is created;\nValue of a1: 100.0m sats;\nRate limiting params of a1: h0=800000, h1=800143, a=500k, a_remaining=500k;\n\nTransaction t1:\nIncluded at block height 800100;\nSpend: 200k + fee;\nRate limiting params: h0=800000, h1=800143, a=500k, a_remaining=300k.\n\nResult:\nValue at destination address: 200k sats;\nRate limiting params at destination address: none;\nValue at change address a2: 99.8m sats;\nRate limiting params at change address a2: h0=800000, h1=800143, a=500k,\na_remaining=300k.\n\nIn order to properly enforce rate limiting, the change address must be\nrate-limited such that the original rate limit of 500k sats per 144 blocks\ncannot be exceeded. In this example, the change address a2 were given the\nsame rate limiting parameters as the transaction that served as its input.\nAs a result, from block 800100 up until and including block 800143, a\nmaximum amount of 300k sats is allowed to be spent from the change address.\n\nExample continued:\na2: 99.8 sats at height 800100;\nRate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;\n\nTransaction t2:\nIncluded at block height 800200\nSpend: 400k + fees.\nRate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.\n\nResult:\nValue at destination address: 400k sats;\nRate limiting params at destination address: none;\nValue at change address a3: 99.4m sats;\nRate limiting params at change address a3: h0=800144, h1=800287, a=500k,\na_remaining=100k.\n\nTransaction t2 is allowed because it falls within the next epoch (running\nfrom 800144 to 800287) so a spend of 400k does not violate the constraint\nof 500k per epoch.\n\nAs could be seen, the rate limiting parameters are part of the transaction\nand chosen by the user (or their wallet). This means that the parameters\nmust be validated to ensure that they do not violate the intended\nconstraints.\n\nFor instance, this transaction should not be allowed:\na2: 99.8 sats at height 800100;\nRate-limit params of a2: h0=800000, h1=800143, a=500k, a_remaining=300k;\n\nTransaction t2a:\nIncluded at block height 800200;\nSpend: 400k + fees;\nRate-limit params: h0=800124, h1=800267, a=500k, a_remaining=100k.\n\nThis transaction t2a attempts to shift the epoch forward by 20 blocks such\nthat it starts at 800124 instead of 800144. Shifting the epoch forward like\nthis must not be allowed because it enables spending more that the rate\nlimit allows, which is 500k in any epoch of 144 blocks. It would enable\noverspending:\n\nt1: spend 200k at 800100 (epoch 1: total: 200k);\nt2a: spend 400k at 800200 (epoch 2: total: 400k);\nt3a: spend 100k at 800201 (epoch 2: total: 500k);\nt4a: spend 500k at 800268 (epoch 2: total: 1000k, overspending for epoch 2).\n\nSpecifying the rate-limiting parameters explicitly at every transaction\nallows the user to tighten the spending limit by setting tighter limits or\nfor instance by setting a_remainder to 0 if they wish to enforce not\nspending more during an epoch. A second advantage of explicitly specifying\nthe four rate-limiting parameters with each transaction is that it allows\nthe system to fully validate the transaction without having to consider any\nprevious transactions within an epoch.\n\nI will stop here because I would like to gauge interest in this idea first\nbefore continuing work on other aspects. Two main pieces of work jump to\nmind:\n\nDefine all validations;\nDescribe aggregate behaviour of multiple (rate-limited) inputs, proof that\ntwo rate-limited addresses cannot spend more than the sum of their\nindividual limits.\n\nZac\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210801/0082071c/attachment.html>"
            },
            {
                "author": "Billy Tetrud",
                "date": "2021-08-02T04:40:47",
                "message_text_only": "Hey Zac,\n\nI think this could be a useful opcode. It kinda seems like UC1 and UC2 are\nbasically the same use case: using rate-limiting to reduce risk of theft or\nmistake. I think this could be a helpful addition to a good wallet setup.\n\nI don't quite understand why you'd want to define a specific span of blocks\nfor the rate limit. Why not just specify the size of the window (in blocks)\nto rate limit within, and the limit?\n\nYou mentioned change addresses, however, with the parameters you defined,\nthere would be no way to connect together the change address with the\noriginal address, meaning they would have completely separate rate limits,\nwhich wouldn't work since the change output would ignore the previous rate\nlimit. I can think of the following options:\n\nA. You could always send change back to the *same* address. This is the\nsimplest option, and the only downside I can think of is exposing the\npublic key of an address. I'm not quite sure what the consensus is on the\ndangers of exposing the public key. It theoretically reduces quantum\nresistance a bit, but I think I read that some of taproot's mechanisms\nexpose the bare public key, so maybe consensus has changed about that in\nrecent years?\n\nB. Have some way to specify connected addresses in the output. This has the\nedge case that one of the addresses wouldn't be able to specify all the\naddresses that it should be connected with, because it would create a hash\nloop (ie if you had address A and B that should be connected, you can\ncreate address A and then specify that address B be connected to address A,\nbut address A cannot specify its connection to B because A was created\nbefore B was created). You wouldn't want one address to be able to simply\ndefine a connection to another address, because this would open up attack\nvectors where people could encumber other people's addresses with rate\nlimits connected to theirs. You could define connections based on\nsignatures, which could be done without creating a hash loop, however it\nwould require exposing the public keys of other addresses when you do that,\nat which point you might as well go with option A.\n\nC. You could specify that rate limits follow a certain output. Eg, if you\ncreate a transaction with destination output 1 and change output 2, your\nrate limiting opcode could specify that output 2 should inherit the rate\nlimit. These inherited rate limits could all be connected together\nautomatically.\n\nAnother consideration is what to use for a receive-address. I would say the\nsimplest option here is to receive at an address that contains an existing\noutput already. If you allowed receiving at an address that contains no\ncoins, you'd have to specify at least one other address to connect it with.\nThis could work, but I don't see any advantage to it, since you don't gain\nany privacy by creating a new address if you're going to immediately\nprogrammatically tie it to the other addresses.\n\nOne thing to consider is the cost of carrying around and checking these\nrate limits. Ideally it should be a very small amount of data carried\naround in the UTXO set, and be very cheap to verify when the opcode comes\nup. I think it would make sense for such an opcode to only be able to track\nrate-limits over short spans, like a month or less. Allowing the user to\nspecify an arbitrary window over which to track a rate-limit seems like\nsomething that would probably open up a dos vector or other node resource\nusage abuse attacks. It might be useful enough to simply rate limit over\neach epoch (two weeks), but having a small set of options could also be\nuseful (eg 1 day, 1 week, or 1 month).\n\nIn any case, I'd be interested in seeing you write a BIP for this. Of\ncourse, don't take my word as community interest. I'm reasonably new to the\nbitcoin dev community, so definitely don't jump the gun based on my\ninterest.\n\nOn Sat, Jul 31, 2021 at 2:51 PM Zac Greenwood via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi list,\n>\n> I'd like to explore whether it is feasible to implement new scripting\n> capabilities in Bitcoin that enable limiting the output amount of a\n> transaction based on the total value of its inputs. In other words, to\n> implement the ability to limit the maximum amount that can be sent from an\n> address.\n>\n> Two use cases come to mind:\n>\n> UC1: enable a user to add additional protection their funds by\n> rate-limiting the amount they are able to send during a certain period\n> (measured in blocks). A typical use case might be a user that intends to\n> hodl their bitcoin, but still wishes to occasionally send small amounts.\n> This avoids an attacker from sweeping all their funds in a single\n> transaction, allowing the user to become aware of the theft and intervene\n> to prevent further theft.\n>\n> UC2: exchanges may wish to rate-limit addresses containing large amounts\n> of bitcoin, adding warm- or hot-wallet functionality to a cold-storage\n> address. This would enable an exchange to drastically reduce the number of\n> times a cold wallet must be accessed with private keys that enable access\n> to the full amount.\n>\n> In a typical setup, I'd envision using multisig such that the user has two\n> sets of private keys to their encumbered address (with a \"set\" of keys\n> meaning \"one or more\" keys). One set of private keys allows only for\n> sending with rate-limiting restrictions in place, and a s second set of\n> private keys allowing for sending any amount without rate-limiting,\n> effectively overriding such restriction.\n>\n> The parameters that define in what way an output is rate-limited might be\n> defined as follows:\n>\n> Param 1: a block height \"h0\" indicating the first block height of an epoch;\n> Param 2: a block height \"h1\" indicating the last block height of an epoch;\n> Param 3: an amount \"a\" in satoshi indicating the maximum amount that is\n> allowed to be sent in any epoch;\n> Param 4: an amount \"a_remaining\" (in satoshi) indicating the maximum\n> amount that is allowed to be sent within the current epoch.\n>\n> For example, consider an input containing 100m sats (1 BTC) which has been\n> rate-limited with parameters (h0, h1, a, a_remaning) of (800000, 800143,\n> 500k, 500k). These parameters define that the address is rate-limited to\n> sending a maximum of 500k sats in the current epoch that starts at block\n> height 800000 and ends at height 800143 (or about one day ignoring block\n> time variance) and that the full amount of 500k is still sendable. These\n> rate-limiting parameters ensure that it takes at minimum 100m / 500k = 200\n> transactions and 200 x 144 blocks or about 200 days to spend the full 100m\n> sats. As noted earlier, in a typical setup a user should retain the option\n> to transact the entire amount using a second (set of) private key(s).\n>\n> For rate-limiting to work, any change output created by a transaction from\n> a rate-limited address must itself be rate-limited as well. For instance,\n> expanding on the above example, assume that the user spends 200k sats from\n> a rate-limited address a1 containing 100m sats:\n>\n> Start situation:\n> At block height 800000: rate-limited address a1 is created;\n> Value of a1: 100.0m sats;\n> Rate limiting params of a1: h0=800000, h1=800143, a=500k, a_remaining=500k;\n>\n> Transaction t1:\n> Included at block height 800100;\n> Spend: 200k + fee;\n> Rate limiting params: h0=800000, h1=800143, a=500k, a_remaining=300k.\n>\n> Result:\n> Value at destination address: 200k sats;\n> Rate limiting params at destination address: none;\n> Value at change address a2: 99.8m sats;\n> Rate limiting params at change address a2: h0=800000, h1=800143, a=500k,\n> a_remaining=300k.\n>\n> In order to properly enforce rate limiting, the change address must be\n> rate-limited such that the original rate limit of 500k sats per 144 blocks\n> cannot be exceeded. In this example, the change address a2 were given the\n> same rate limiting parameters as the transaction that served as its input.\n> As a result, from block 800100 up until and including block 800143, a\n> maximum amount of 300k sats is allowed to be spent from the change address.\n>\n> Example continued:\n> a2: 99.8 sats at height 800100;\n> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;\n>\n> Transaction t2:\n> Included at block height 800200\n> Spend: 400k + fees.\n> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.\n>\n> Result:\n> Value at destination address: 400k sats;\n> Rate limiting params at destination address: none;\n> Value at change address a3: 99.4m sats;\n> Rate limiting params at change address a3: h0=800144, h1=800287, a=500k,\n> a_remaining=100k.\n>\n> Transaction t2 is allowed because it falls within the next epoch (running\n> from 800144 to 800287) so a spend of 400k does not violate the constraint\n> of 500k per epoch.\n>\n> As could be seen, the rate limiting parameters are part of the transaction\n> and chosen by the user (or their wallet). This means that the parameters\n> must be validated to ensure that they do not violate the intended\n> constraints.\n>\n> For instance, this transaction should not be allowed:\n> a2: 99.8 sats at height 800100;\n> Rate-limit params of a2: h0=800000, h1=800143, a=500k, a_remaining=300k;\n>\n> Transaction t2a:\n> Included at block height 800200;\n> Spend: 400k + fees;\n> Rate-limit params: h0=800124, h1=800267, a=500k, a_remaining=100k.\n>\n> This transaction t2a attempts to shift the epoch forward by 20 blocks such\n> that it starts at 800124 instead of 800144. Shifting the epoch forward like\n> this must not be allowed because it enables spending more that the rate\n> limit allows, which is 500k in any epoch of 144 blocks. It would enable\n> overspending:\n>\n> t1: spend 200k at 800100 (epoch 1: total: 200k);\n> t2a: spend 400k at 800200 (epoch 2: total: 400k);\n> t3a: spend 100k at 800201 (epoch 2: total: 500k);\n> t4a: spend 500k at 800268 (epoch 2: total: 1000k, overspending for epoch\n> 2).\n>\n> Specifying the rate-limiting parameters explicitly at every transaction\n> allows the user to tighten the spending limit by setting tighter limits or\n> for instance by setting a_remainder to 0 if they wish to enforce not\n> spending more during an epoch.\n>\n> I will stop here because I would like to gauge interest in this idea first\n> before continuing work on other aspects. Two main pieces of work jump to\n> mind:\n>\n> Define all validations;\n> Describe aggregate behaviour of multiple (rate-limited) inputs, proof that\n> two rate-limited addresses cannot spend more than the sum of their\n> individual limits.\n>\n> Zac\n>\n>\n>\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210801/731b3ebe/attachment-0001.html>"
            },
            {
                "author": "Zac Greenwood",
                "date": "2021-08-02T09:32:36",
                "message_text_only": "[Note: I've moved your reply to the newly started thread]\n\nHi Billy,\n\nThank you for your kind and encouraging feedback.\n\nI don't quite understand why you'd want to define a specific span of blocks\n> for the rate limit. Why not just specify the size of the window (in blocks)\n> to rate limit within, and the limit?\n\n\nTo enable more straightforward validation logic.\n\nYou mentioned change addresses, however, with the parameters you defined,\n> there would be no way to connect together the change address with the\n> original address, meaning they would have completely separate rate limits,\n> which wouldn't work since the change output would ignore the previous rate\n> limit.\n\n\nThe rate-limiting parameters must be re-specified for each rate-limited\ninput. So, a transaction that has a rate-limited input is only valid if its\noutput is itself rate-limited such that it does not violate the\nrate-limiting constraints of its input.\n\nIn my thread-starter, I gave the below example of a rate-limited address a2\nthat serves as input for transaction t2:\n\na2: 99.8 sats at height 800100;\nRate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;\n\nTransaction t2:\nIncluded at block height 800200\nSpend: 400k + fees.\nRate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.\n\nNote how transaction t2 re-specifies the rate-limiting parameters.\nValidation must ensure that the re-specified parameters are within bounds,\ni.e., do not allow more spending per epoch than the rate-limiting\nparameters of its input address a2. Re-specifying the rate-limiting\nparameters offers the flexibility to further restrict spending, or to\ndisable any additional spending within the current epoch by setting\na_remaining to zero.\n\nResult:\nValue at destination address: 400k sats;\nRate limiting params at destination address: none;\nValue at change address a3: 99.4m sats;\nRate limiting params at change address a3: h0=800144, h1=800287, a=500k,\na_remaining=100k.\n\nAs a design principle I believe it makes sense if the system is able to\nverify the validity of a transaction without having to consider any\ntransactions that precede its inputs. As a side-note, doing away with this\ndesign principle would however enable more sophisticated rate-limiting\n(such as rate-limiting per sliding window instead of rate-limiting per\nepoch having a fixed start and end block), but while at the same time\nreducing the size of per rate-limiting transaction (because it would enable\nspecifying the rate-limiting parameters more space-efficiently). To test\nthe waters and to keep things relatively simple, I chose not to go into\nthis enhanced form of rate-limiting.\n\nI haven't gone into how to process a transaction having multiple\nrate-limited inputs. The easiest way to handle this case is to not allow\nany transaction having more than one rate-limited input. One could imagine\ncomplex logic to handle transactions having multiple rate-limited inputs by\ncreating multiple rate-limited change addresses. However at first glance I\ndon't believe that the marginal added functionality would justify the\nincreased implementation complexity.\n\n I'd be interested in seeing you write a BIP for this.\n\n\nThank you, but sadly my understanding of Bitcoin is way too low to be able\nto write a BIP and do the implementation. However I see tremendous value in\nthis functionality. Favorable feedback of the list regarding the usefulness\nand the technical feasibility of rate-limiting functionality would of\ncourse be an encouragement for me to descend further down the rabbit hole.\n\nZac\n\n\nOn Sun, Aug 1, 2021 at 10:09 AM Zac Greenwood <zachgrw at gmail.com> wrote:\n\n> [Resubmitting to list with minor edits. My previous submission ended up\n> inside an existing thread, apologies.]\n>\n> Hi list,\n>\n> I'd like to explore whether it is feasible to implement new scripting\n> capabilities in Bitcoin that enable limiting the output amount of a\n> transaction based on the total value of its inputs. In other words, to\n> implement the ability to limit the maximum amount that can be sent from an\n> address.\n>\n> Two use cases come to mind:\n>\n> UC1: enable a user to add additional protection their funds by\n> rate-limiting the amount that they are allowed to send during a certain\n> period (measured in blocks). A typical use case might be a user that\n> intends to hodl their bitcoin, but still wishes to occasionally send small\n> amounts. Rate-limiting avoids an attacker from sweeping all the users'\n> funds in a single transaction, allowing the user to become aware of the\n> theft and intervene to prevent further thefts.\n>\n> UC2: exchanges may wish to rate-limit addresses containing large amounts\n> of bitcoin, adding warm- or hot-wallet functionality to a cold-storage\n> address. This would enable an exchange to drastically reduce the number of\n> times a cold wallet must be accessed with private keys that give access to\n> the full amount.\n>\n> In a typical setup, I'd envision using multisig such that the user has two\n> sets of private keys to their encumbered address (with a \"set\" of keys\n> meaning \"one or more\" keys). One set of private keys allows only for\n> sending with rate-limiting restrictions in place, and a second set of\n> private keys allowing for sending any amount without rate-limiting,\n> effectively overriding such restriction.\n>\n> The parameters that define in what way an output is rate-limited might be\n> defined as follows:\n>\n> Param 1: a block height \"h0\" indicating the first block height of an epoch;\n> Param 2: a block height \"h1\" indicating the last block height of an epoch;\n> Param 3: an amount \"a\" in satoshi indicating the maximum amount that is\n> allowed to be sent in any epoch;\n> Param 4: an amount \"a_remaining\" (in satoshi) indicating the maximum\n> amount that is allowed to be sent within the current epoch.\n>\n> For example, consider an input containing 100m sats (1 BTC) which has been\n> rate-limited with parameters (h0, h1, a, a_remaining) of (800000, 800143,\n> 500k, 500k). These parameters define that the address is rate-limited to\n> sending a maximum of 500k sats in the current epoch that starts at block\n> height 800000 and ends at height 800143 (or about one day ignoring block\n> time variance) and that the full amount of 500k is still sendable. These\n> rate-limiting parameters ensure that it takes at minimum 100m / 500k = 200\n> transactions and 200 x 144 blocks or about 200 days to spend the full 100m\n> sats. As noted earlier, in a typical setup a user should retain the option\n> to transact the entire amount using a second (set of) private key(s).\n>\n> For rate-limiting to work, any change output created by a transaction from\n> a rate-limited address must itself be rate-limited as well. For instance,\n> expanding on the above example, assume that the user spends 200k sats from\n> a rate-limited address a1 containing 100m sats:\n>\n> Start situation:\n> At block height 800000: rate-limited address a1 is created;\n> Value of a1: 100.0m sats;\n> Rate limiting params of a1: h0=800000, h1=800143, a=500k, a_remaining=500k;\n>\n> Transaction t1:\n> Included at block height 800100;\n> Spend: 200k + fee;\n> Rate limiting params: h0=800000, h1=800143, a=500k, a_remaining=300k.\n>\n> Result:\n> Value at destination address: 200k sats;\n> Rate limiting params at destination address: none;\n> Value at change address a2: 99.8m sats;\n> Rate limiting params at change address a2: h0=800000, h1=800143, a=500k,\n> a_remaining=300k.\n>\n> In order to properly enforce rate limiting, the change address must be\n> rate-limited such that the original rate limit of 500k sats per 144 blocks\n> cannot be exceeded. In this example, the change address a2 were given the\n> same rate limiting parameters as the transaction that served as its input.\n> As a result, from block 800100 up until and including block 800143, a\n> maximum amount of 300k sats is allowed to be spent from the change address.\n>\n> Example continued:\n> a2: 99.8 sats at height 800100;\n> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;\n>\n> Transaction t2:\n> Included at block height 800200\n> Spend: 400k + fees.\n> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.\n>\n> Result:\n> Value at destination address: 400k sats;\n> Rate limiting params at destination address: none;\n> Value at change address a3: 99.4m sats;\n> Rate limiting params at change address a3: h0=800144, h1=800287, a=500k,\n> a_remaining=100k.\n>\n> Transaction t2 is allowed because it falls within the next epoch (running\n> from 800144 to 800287) so a spend of 400k does not violate the constraint\n> of 500k per epoch.\n>\n> As could be seen, the rate limiting parameters are part of the transaction\n> and chosen by the user (or their wallet). This means that the parameters\n> must be validated to ensure that they do not violate the intended\n> constraints.\n>\n> For instance, this transaction should not be allowed:\n> a2: 99.8 sats at height 800100;\n> Rate-limit params of a2: h0=800000, h1=800143, a=500k, a_remaining=300k;\n>\n> Transaction t2a:\n> Included at block height 800200;\n> Spend: 400k + fees;\n> Rate-limit params: h0=800124, h1=800267, a=500k, a_remaining=100k.\n>\n> This transaction t2a attempts to shift the epoch forward by 20 blocks such\n> that it starts at 800124 instead of 800144. Shifting the epoch forward like\n> this must not be allowed because it enables spending more that the rate\n> limit allows, which is 500k in any epoch of 144 blocks. It would enable\n> overspending:\n>\n> t1: spend 200k at 800100 (epoch 1: total: 200k);\n> t2a: spend 400k at 800200 (epoch 2: total: 400k);\n> t3a: spend 100k at 800201 (epoch 2: total: 500k);\n> t4a: spend 500k at 800268 (epoch 2: total: 1000k, overspending for epoch\n> 2).\n>\n> Specifying the rate-limiting parameters explicitly at every transaction\n> allows the user to tighten the spending limit by setting tighter limits or\n> for instance by setting a_remainder to 0 if they wish to enforce not\n> spending more during an epoch. A second advantage of explicitly specifying\n> the four rate-limiting parameters with each transaction is that it allows\n> the system to fully validate the transaction without having to consider any\n> previous transactions within an epoch.\n>\n> I will stop here because I would like to gauge interest in this idea first\n> before continuing work on other aspects. Two main pieces of work jump to\n> mind:\n>\n> Define all validations;\n> Describe aggregate behaviour of multiple (rate-limited) inputs, proof that\n> two rate-limited addresses cannot spend more than the sum of their\n> individual limits.\n>\n> Zac\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210802/49badd38/attachment.html>"
            },
            {
                "author": "Billy Tetrud",
                "date": "2021-08-03T18:12:28",
                "message_text_only": "> To enable more straightforward validation logic.\n> within the current epoch\n\nAh I see, this is all limited to within a single epoch. I think that\nsufficiently limits the window of time in which nodes have to store\ninformation for rate limited outputs. However, I don't see how specifying\nblock ranges simplifies the logic - wouldn't this complicate the logic with\nadditional user-specified constraints? It also prevents the output from\nbeing able to be rate limited over the span of multiple epochs, which would\nseem to make it a lot more difficult to use for certain types of wallets\n(eg cold wallets).\n\nI think I see the logic of your 'remaining' parameter there. If you start\nwith a single rate-limited input, you can split that into many outputs,\nonly one of which have a 'remaining' balance. The rest can simply remain\nunspendable for the rest of the epoch. That way these things don't need to\nbe tied together. However, that doesn't solve the problem of 3rd parties\nbeing able to send money into the wallet.\n\n> I don't believe that the marginal added functionality would justify the\nincreased implementation complexity\n\nPerhaps, but I think there is a lot of benefit in allowing these kinds of\nthings to operate as similarly as possible to normal transactions, for one\nbecause of usability reasons. If each opcode has its own quirks that are\nnot intuitively related to their purpose (eg if a rate-limited wallet had\nno way to get a receiving address), it would confuse end-users (eg who\nwonder how to get a receiving address and how they can ask people to send\nmoney into their wallet) or require a lot of technical complexity in\napplications (eg to support something like cooperatively connecting with\ntheir wallet so that a transaction can be made that creates a new\nsingle-output for the wallet). A little complexity in this opcode can save\na lot of external complexity here I think.\n\n> my understanding of Bitcoin is way too low to be able to write a BIP and\ndo the implementation\n\nYou might be able to find people willing to help. I would be willing to\nhelp write the BIP spec. I'm not the right person to help with the\nimplementation, but perhaps you could find someone else who is. Even if the\nBIP isn't adopted, it could be a starting point or inspiration for someone\nelse to write an improved version.\n\nOn Mon, Aug 2, 2021 at 2:32 AM Zac Greenwood <zachgrw at gmail.com> wrote:\n\n> [Note: I've moved your reply to the newly started thread]\n>\n> Hi Billy,\n>\n> Thank you for your kind and encouraging feedback.\n>\n> I don't quite understand why you'd want to define a specific span of\n>> blocks for the rate limit. Why not just specify the size of the window (in\n>> blocks) to rate limit within, and the limit?\n>\n>\n> To enable more straightforward validation logic.\n>\n> You mentioned change addresses, however, with the parameters you defined,\n>> there would be no way to connect together the change address with the\n>> original address, meaning they would have completely separate rate limits,\n>> which wouldn't work since the change output would ignore the previous rate\n>> limit.\n>\n>\n> The rate-limiting parameters must be re-specified for each rate-limited\n> input. So, a transaction that has a rate-limited input is only valid if its\n> output is itself rate-limited such that it does not violate the\n> rate-limiting constraints of its input.\n>\n> In my thread-starter, I gave the below example of a rate-limited address\n> a2 that serves as input for transaction t2:\n>\n> a2: 99.8 sats at height 800100;\n> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;\n>\n> Transaction t2:\n> Included at block height 800200\n> Spend: 400k + fees.\n> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.\n>\n> Note how transaction t2 re-specifies the rate-limiting parameters.\n> Validation must ensure that the re-specified parameters are within bounds,\n> i.e., do not allow more spending per epoch than the rate-limiting\n> parameters of its input address a2. Re-specifying the rate-limiting\n> parameters offers the flexibility to further restrict spending, or to\n> disable any additional spending within the current epoch by setting\n> a_remaining to zero.\n>\n> Result:\n> Value at destination address: 400k sats;\n> Rate limiting params at destination address: none;\n> Value at change address a3: 99.4m sats;\n> Rate limiting params at change address a3: h0=800144, h1=800287, a=500k,\n> a_remaining=100k.\n>\n> As a design principle I believe it makes sense if the system is able to\n> verify the validity of a transaction without having to consider any\n> transactions that precede its inputs. As a side-note, doing away with this\n> design principle would however enable more sophisticated rate-limiting\n> (such as rate-limiting per sliding window instead of rate-limiting per\n> epoch having a fixed start and end block), but while at the same time\n> reducing the size of per rate-limiting transaction (because it would enable\n> specifying the rate-limiting parameters more space-efficiently). To test\n> the waters and to keep things relatively simple, I chose not to go into\n> this enhanced form of rate-limiting.\n>\n> I haven't gone into how to process a transaction having multiple\n> rate-limited inputs. The easiest way to handle this case is to not allow\n> any transaction having more than one rate-limited input. One could imagine\n> complex logic to handle transactions having multiple rate-limited inputs by\n> creating multiple rate-limited change addresses. However at first glance I\n> don't believe that the marginal added functionality would justify the\n> increased implementation complexity.\n>\n>  I'd be interested in seeing you write a BIP for this.\n>\n>\n> Thank you, but sadly my understanding of Bitcoin is way too low to be able\n> to write a BIP and do the implementation. However I see tremendous value in\n> this functionality. Favorable feedback of the list regarding the usefulness\n> and the technical feasibility of rate-limiting functionality would of\n> course be an encouragement for me to descend further down the rabbit hole.\n>\n> Zac\n>\n>\n> On Sun, Aug 1, 2021 at 10:09 AM Zac Greenwood <zachgrw at gmail.com> wrote:\n>\n>> [Resubmitting to list with minor edits. My previous submission ended up\n>> inside an existing thread, apologies.]\n>>\n>> Hi list,\n>>\n>> I'd like to explore whether it is feasible to implement new scripting\n>> capabilities in Bitcoin that enable limiting the output amount of a\n>> transaction based on the total value of its inputs. In other words, to\n>> implement the ability to limit the maximum amount that can be sent from an\n>> address.\n>>\n>> Two use cases come to mind:\n>>\n>> UC1: enable a user to add additional protection their funds by\n>> rate-limiting the amount that they are allowed to send during a certain\n>> period (measured in blocks). A typical use case might be a user that\n>> intends to hodl their bitcoin, but still wishes to occasionally send small\n>> amounts. Rate-limiting avoids an attacker from sweeping all the users'\n>> funds in a single transaction, allowing the user to become aware of the\n>> theft and intervene to prevent further thefts.\n>>\n>> UC2: exchanges may wish to rate-limit addresses containing large amounts\n>> of bitcoin, adding warm- or hot-wallet functionality to a cold-storage\n>> address. This would enable an exchange to drastically reduce the number of\n>> times a cold wallet must be accessed with private keys that give access to\n>> the full amount.\n>>\n>> In a typical setup, I'd envision using multisig such that the user has\n>> two sets of private keys to their encumbered address (with a \"set\" of keys\n>> meaning \"one or more\" keys). One set of private keys allows only for\n>> sending with rate-limiting restrictions in place, and a second set of\n>> private keys allowing for sending any amount without rate-limiting,\n>> effectively overriding such restriction.\n>>\n>> The parameters that define in what way an output is rate-limited might be\n>> defined as follows:\n>>\n>> Param 1: a block height \"h0\" indicating the first block height of an\n>> epoch;\n>> Param 2: a block height \"h1\" indicating the last block height of an epoch;\n>> Param 3: an amount \"a\" in satoshi indicating the maximum amount that is\n>> allowed to be sent in any epoch;\n>> Param 4: an amount \"a_remaining\" (in satoshi) indicating the maximum\n>> amount that is allowed to be sent within the current epoch.\n>>\n>> For example, consider an input containing 100m sats (1 BTC) which has\n>> been rate-limited with parameters (h0, h1, a, a_remaining) of (800000,\n>> 800143, 500k, 500k). These parameters define that the address is\n>> rate-limited to sending a maximum of 500k sats in the current epoch that\n>> starts at block height 800000 and ends at height 800143 (or about one day\n>> ignoring block time variance) and that the full amount of 500k is still\n>> sendable. These rate-limiting parameters ensure that it takes at minimum\n>> 100m / 500k = 200 transactions and 200 x 144 blocks or about 200 days to\n>> spend the full 100m sats. As noted earlier, in a typical setup a user\n>> should retain the option to transact the entire amount using a second (set\n>> of) private key(s).\n>>\n>> For rate-limiting to work, any change output created by a transaction\n>> from a rate-limited address must itself be rate-limited as well. For\n>> instance, expanding on the above example, assume that the user spends 200k\n>> sats from a rate-limited address a1 containing 100m sats:\n>>\n>> Start situation:\n>> At block height 800000: rate-limited address a1 is created;\n>> Value of a1: 100.0m sats;\n>> Rate limiting params of a1: h0=800000, h1=800143, a=500k,\n>> a_remaining=500k;\n>>\n>> Transaction t1:\n>> Included at block height 800100;\n>> Spend: 200k + fee;\n>> Rate limiting params: h0=800000, h1=800143, a=500k, a_remaining=300k.\n>>\n>> Result:\n>> Value at destination address: 200k sats;\n>> Rate limiting params at destination address: none;\n>> Value at change address a2: 99.8m sats;\n>> Rate limiting params at change address a2: h0=800000, h1=800143, a=500k,\n>> a_remaining=300k.\n>>\n>> In order to properly enforce rate limiting, the change address must be\n>> rate-limited such that the original rate limit of 500k sats per 144 blocks\n>> cannot be exceeded. In this example, the change address a2 were given the\n>> same rate limiting parameters as the transaction that served as its input.\n>> As a result, from block 800100 up until and including block 800143, a\n>> maximum amount of 300k sats is allowed to be spent from the change address.\n>>\n>> Example continued:\n>> a2: 99.8 sats at height 800100;\n>> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;\n>>\n>> Transaction t2:\n>> Included at block height 800200\n>> Spend: 400k + fees.\n>> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.\n>>\n>> Result:\n>> Value at destination address: 400k sats;\n>> Rate limiting params at destination address: none;\n>> Value at change address a3: 99.4m sats;\n>> Rate limiting params at change address a3: h0=800144, h1=800287, a=500k,\n>> a_remaining=100k.\n>>\n>> Transaction t2 is allowed because it falls within the next epoch (running\n>> from 800144 to 800287) so a spend of 400k does not violate the constraint\n>> of 500k per epoch.\n>>\n>> As could be seen, the rate limiting parameters are part of the\n>> transaction and chosen by the user (or their wallet). This means that the\n>> parameters must be validated to ensure that they do not violate the\n>> intended constraints.\n>>\n>> For instance, this transaction should not be allowed:\n>> a2: 99.8 sats at height 800100;\n>> Rate-limit params of a2: h0=800000, h1=800143, a=500k, a_remaining=300k;\n>>\n>> Transaction t2a:\n>> Included at block height 800200;\n>> Spend: 400k + fees;\n>> Rate-limit params: h0=800124, h1=800267, a=500k, a_remaining=100k.\n>>\n>> This transaction t2a attempts to shift the epoch forward by 20 blocks\n>> such that it starts at 800124 instead of 800144. Shifting the epoch forward\n>> like this must not be allowed because it enables spending more that the\n>> rate limit allows, which is 500k in any epoch of 144 blocks. It would\n>> enable overspending:\n>>\n>> t1: spend 200k at 800100 (epoch 1: total: 200k);\n>> t2a: spend 400k at 800200 (epoch 2: total: 400k);\n>> t3a: spend 100k at 800201 (epoch 2: total: 500k);\n>> t4a: spend 500k at 800268 (epoch 2: total: 1000k, overspending for epoch\n>> 2).\n>>\n>> Specifying the rate-limiting parameters explicitly at every transaction\n>> allows the user to tighten the spending limit by setting tighter limits or\n>> for instance by setting a_remainder to 0 if they wish to enforce not\n>> spending more during an epoch. A second advantage of explicitly specifying\n>> the four rate-limiting parameters with each transaction is that it allows\n>> the system to fully validate the transaction without having to consider any\n>> previous transactions within an epoch.\n>>\n>> I will stop here because I would like to gauge interest in this idea\n>> first before continuing work on other aspects. Two main pieces of work jump\n>> to mind:\n>>\n>> Define all validations;\n>> Describe aggregate behaviour of multiple (rate-limited) inputs, proof\n>> that two rate-limited addresses cannot spend more than the sum of their\n>> individual limits.\n>>\n>> Zac\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210803/2ef771b3/attachment-0001.html>"
            },
            {
                "author": "Zac Greenwood",
                "date": "2021-08-04T10:48:44",
                "message_text_only": "> Ah I see, this is all limited to within a single epoch.\n\nNo, that wouldn't be useful. A maximum amount is allowed to be spent within\nEVERY epoch.\n\nConsider an epoch length of 100 blocks with a spend limit of 200k per\nepoch. The following is allowed:\n\nepoch1 (800101 - 800200): spend 120k in block 800140. Remaining for epoch1:\n80k;\nepoch1 (800101 - 800200): spend another 60k in block 800195. Remaining for\nepoch1: 20k;\nepoch2 (800201 - 800300): spend 160k in block 800201. Remaining for epoch2:\n40k.\n\nSince the limit pertains to each individual epoch, it is allowed to spend\nup to the full limit at the start of any new epoch. In this example, the\nspending was as follows:\n\n800140: 120k\n800195: 60k\n800201: 160k.\n\nNote that in a span of 62 blocks a total of 340k sats was spent. This may\nseem to violate the 200k limit per 100 blocks, but this is the result of\nusing a per-epoch limit. This allows a maximum of 400k to be spent in 2\nblocks llke so: 200k in the last block of an epoch and another 200k in the\nfirst block of the next epoch. However this is inconsequential for the\nintended goal of rate-limiting which is to enable small spends over time\nfrom a large amount and to prevent theft of a large amount with a single\ntransaction.\n\nTo explain the proposed design more clearly, I have renamed the params as\nfollows:\n\nepochStart: block height of first block of the current epoch (was: h0);\nepochEnd: block height of last block of the current epoch (was: h1);\nlimit: the maximum total amount allowed to be spent within the current\nepoch (was: a);\nremain: the remaining amount allowed to be spent within the current epoch\n(was: a_remaining);\n\nAlso, to illustrate that the params are specific to a transaction, I will\nhence precede the param with the transaction name like so:\ntx8_limit, tx31c_remain, tx42z_epochStart, ... etc.\n\nFor simplicity, only transactions with no more than one rate-limited input\nare considered, and with no more than two outputs: one rate-limited change\noutput, and a normal (not rate-limited) output.\n\nNormally, a simple transaction generates two outputs: one for a payment to\na third party and one for the change address. Again for simplicity, we\ndemand that a transaction which introduces rate-limiting must have only a\nsingle, rate-limited output. The validation rule might be: if a transaction\nhas rate-limiting params and none of its inputs are rate-limited, then\nthere must be only a single (rate-limited) output (and no second or change\noutput).\n\nConsider rate limiting transactions tx1 having one or more normal (non\nrate-limited) inputs:\n\ntx1 gets included at block height 800004;\nThe inputs of tx1 are not rate-limited => tx1 must have only a single\noutput which will become rate-limited;\nparams: tx1_epochStart=800001, tx1_epochEnd=800100, tx1_limit=200k,\ntx1_remain=200k;\n=> This defines that an epoch has 100 blocks and no more than 200k sats may\nbe spent in any one epoch. Within the current epoch, 200k sats may still be\nspent.\n\nThis transaction begins to rate-limit a set of inputs, so it has a single\nrate-limited output.\nLet's explore transactions that have the output of tx1 as their input. I\nwill denote the output of tx1 as \"out1\".\n\ntx2a has out1 as its only input;\ntx2a spends 50k sats and gets included at block height 803050;\ntx2a specifies the following params for its change output \"chg2a\":\nchg2a_epochStart=803001, chg2a_epochEnd=803100;\nchg2a_limit=200k, chg2a_remain=150k.\n\nTo enforce rate-limiting, the system must validate the params of the change\noutput chg2a to ensure that overspending is not allowed.\n\nThe above params are allowed because:\n=> 1. the epoch does not become smaller than 100 blocks [(chg2a_epochEnd -\nchg2a_epochStart) >= (tx1_epochEnd - tx1_epochStart)]\n=> 2. tx1_limit has not been increased (ch2a_limit <= tx1_limit)\n=> 3. the amount spent (50k sats) does not exceed tx1_remain AND does not\nexceed chg2a_limit;\n=> 4. chg2a_remain\" is 50k sats less than chg2a_limit.\n\nA transaction may also further constrain further spending like so:\n\ntx2b has out1as its only input;\ntx2b spends 8k sats and gets included at block height 808105;\ntx2b specifies the following params for its change output \"chg2b\":\nchg2b_epochStart=808101, chg2b_epochEnd=808250;\nchg2b_limit=10k, chg2b_remain=0.\n\nThese params are allowed because:\n=> 1. the epoch does not become smaller than100 blocks. It is fine to\nincrease the epoch to 150 blocks because it does not enable exceeding the\noriginal rate-limit;\n=> 2. the limit (chg2b_limit) has been decreased to 10k sats, further\nrestricting the maximum amount allowed to be spent within the current and\nany subsequent epochs;\n=> 3. the amount spent (10k sats) does not exceed tx1_remain AND does not\nexceed chg2b_limit;\n=> 4. chg2b_remain has been set to zero, meaning that within the current\nepoch (block height 808101 to and including 808250), tx2b cannot be used as\na spending input to any transaction.\n\nStarting from block height 808251, a new epoch will start and the\nrate-limited output of tx2b may again be used as an input for a subsequent\nrate-limited transaction tx3b. This transaction tx3b must again be\naccompanied by params that do not violate the rate-limit as defined by the\nparams of tx2b and which are stored with output out2b. So, the epoch of\ntx3b must be at minimum 150 blocks, the maximum that is allowed to be spent\nper epoch is at most 10k sats, and chg3b_remain must be decreased by at\nleast the amount spent by tx3b.\n\n>From the above, the rate-limiting mechanics should hopefully be clear and\nfull set of validation rules could be defined in a more generalized way\nwith little additional effort.\n\nNote that I conveniently avoided talking about how to represent the\nparameters within transactions or outputs, simply because I currently lack\nenough understanding to reason about this. I am hoping that others may\noffer help.\n\nZac\n\n\nOn Tue, Aug 3, 2021 at 8:12 PM Billy Tetrud <billy.tetrud at gmail.com> wrote:\n\n> > To enable more straightforward validation logic.\n> > within the current epoch\n>\n> Ah I see, this is all limited to within a single epoch. I think that\n> sufficiently limits the window of time in which nodes have to store\n> information for rate limited outputs. However, I don't see how specifying\n> block ranges simplifies the logic - wouldn't this complicate the logic with\n> additional user-specified constraints? It also prevents the output from\n> being able to be rate limited over the span of multiple epochs, which would\n> seem to make it a lot more difficult to use for certain types of wallets\n> (eg cold wallets).\n>\n> I think I see the logic of your 'remaining' parameter there. If you start\n> with a single rate-limited input, you can split that into many outputs,\n> only one of which have a 'remaining' balance. The rest can simply remain\n> unspendable for the rest of the epoch. That way these things don't need to\n> be tied together. However, that doesn't solve the problem of 3rd parties\n> being able to send money into the wallet.\n>\n> > I don't believe that the marginal added functionality would justify the\n> increased implementation complexity\n>\n> Perhaps, but I think there is a lot of benefit in allowing these kinds of\n> things to operate as similarly as possible to normal transactions, for one\n> because of usability reasons. If each opcode has its own quirks that are\n> not intuitively related to their purpose (eg if a rate-limited wallet had\n> no way to get a receiving address), it would confuse end-users (eg who\n> wonder how to get a receiving address and how they can ask people to send\n> money into their wallet) or require a lot of technical complexity in\n> applications (eg to support something like cooperatively connecting with\n> their wallet so that a transaction can be made that creates a new\n> single-output for the wallet). A little complexity in this opcode can save\n> a lot of external complexity here I think.\n>\n> > my understanding of Bitcoin is way too low to be able to write a BIP and\n> do the implementation\n>\n> You might be able to find people willing to help. I would be willing to\n> help write the BIP spec. I'm not the right person to help with the\n> implementation, but perhaps you could find someone else who is. Even if the\n> BIP isn't adopted, it could be a starting point or inspiration for someone\n> else to write an improved version.\n>\n> On Mon, Aug 2, 2021 at 2:32 AM Zac Greenwood <zachgrw at gmail.com> wrote:\n>\n>> [Note: I've moved your reply to the newly started thread]\n>>\n>> Hi Billy,\n>>\n>> Thank you for your kind and encouraging feedback.\n>>\n>> I don't quite understand why you'd want to define a specific span of\n>>> blocks for the rate limit. Why not just specify the size of the window (in\n>>> blocks) to rate limit within, and the limit?\n>>\n>>\n>> To enable more straightforward validation logic.\n>>\n>> You mentioned change addresses, however, with the parameters you defined,\n>>> there would be no way to connect together the change address with the\n>>> original address, meaning they would have completely separate rate limits,\n>>> which wouldn't work since the change output would ignore the previous rate\n>>> limit.\n>>\n>>\n>> The rate-limiting parameters must be re-specified for each rate-limited\n>> input. So, a transaction that has a rate-limited input is only valid if its\n>> output is itself rate-limited such that it does not violate the\n>> rate-limiting constraints of its input.\n>>\n>> In my thread-starter, I gave the below example of a rate-limited address\n>> a2 that serves as input for transaction t2:\n>>\n>> a2: 99.8 sats at height 800100;\n>> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;\n>>\n>> Transaction t2:\n>> Included at block height 800200\n>> Spend: 400k + fees.\n>> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.\n>>\n>> Note how transaction t2 re-specifies the rate-limiting parameters.\n>> Validation must ensure that the re-specified parameters are within bounds,\n>> i.e., do not allow more spending per epoch than the rate-limiting\n>> parameters of its input address a2. Re-specifying the rate-limiting\n>> parameters offers the flexibility to further restrict spending, or to\n>> disable any additional spending within the current epoch by setting\n>> a_remaining to zero.\n>>\n>> Result:\n>> Value at destination address: 400k sats;\n>> Rate limiting params at destination address: none;\n>> Value at change address a3: 99.4m sats;\n>> Rate limiting params at change address a3: h0=800144, h1=800287, a=500k,\n>> a_remaining=100k.\n>>\n>> As a design principle I believe it makes sense if the system is able to\n>> verify the validity of a transaction without having to consider any\n>> transactions that precede its inputs. As a side-note, doing away with this\n>> design principle would however enable more sophisticated rate-limiting\n>> (such as rate-limiting per sliding window instead of rate-limiting per\n>> epoch having a fixed start and end block), but while at the same time\n>> reducing the size of per rate-limiting transaction (because it would enable\n>> specifying the rate-limiting parameters more space-efficiently). To test\n>> the waters and to keep things relatively simple, I chose not to go into\n>> this enhanced form of rate-limiting.\n>>\n>> I haven't gone into how to process a transaction having multiple\n>> rate-limited inputs. The easiest way to handle this case is to not allow\n>> any transaction having more than one rate-limited input. One could imagine\n>> complex logic to handle transactions having multiple rate-limited inputs by\n>> creating multiple rate-limited change addresses. However at first glance I\n>> don't believe that the marginal added functionality would justify the\n>> increased implementation complexity.\n>>\n>>  I'd be interested in seeing you write a BIP for this.\n>>\n>>\n>> Thank you, but sadly my understanding of Bitcoin is way too low to be\n>> able to write a BIP and do the implementation. However I see tremendous\n>> value in this functionality. Favorable feedback of the list regarding the\n>> usefulness and the technical feasibility of rate-limiting functionality\n>> would of course be an encouragement for me to descend further down the\n>> rabbit hole.\n>>\n>> Zac\n>>\n>>\n>> On Sun, Aug 1, 2021 at 10:09 AM Zac Greenwood <zachgrw at gmail.com> wrote:\n>>\n>>> [Resubmitting to list with minor edits. My previous submission ended up\n>>> inside an existing thread, apologies.]\n>>>\n>>> Hi list,\n>>>\n>>> I'd like to explore whether it is feasible to implement new scripting\n>>> capabilities in Bitcoin that enable limiting the output amount of a\n>>> transaction based on the total value of its inputs. In other words, to\n>>> implement the ability to limit the maximum amount that can be sent from an\n>>> address.\n>>>\n>>> Two use cases come to mind:\n>>>\n>>> UC1: enable a user to add additional protection their funds by\n>>> rate-limiting the amount that they are allowed to send during a certain\n>>> period (measured in blocks). A typical use case might be a user that\n>>> intends to hodl their bitcoin, but still wishes to occasionally send small\n>>> amounts. Rate-limiting avoids an attacker from sweeping all the users'\n>>> funds in a single transaction, allowing the user to become aware of the\n>>> theft and intervene to prevent further thefts.\n>>>\n>>> UC2: exchanges may wish to rate-limit addresses containing large amounts\n>>> of bitcoin, adding warm- or hot-wallet functionality to a cold-storage\n>>> address. This would enable an exchange to drastically reduce the number of\n>>> times a cold wallet must be accessed with private keys that give access to\n>>> the full amount.\n>>>\n>>> In a typical setup, I'd envision using multisig such that the user has\n>>> two sets of private keys to their encumbered address (with a \"set\" of keys\n>>> meaning \"one or more\" keys). One set of private keys allows only for\n>>> sending with rate-limiting restrictions in place, and a second set of\n>>> private keys allowing for sending any amount without rate-limiting,\n>>> effectively overriding such restriction.\n>>>\n>>> The parameters that define in what way an output is rate-limited might\n>>> be defined as follows:\n>>>\n>>> Param 1: a block height \"h0\" indicating the first block height of an\n>>> epoch;\n>>> Param 2: a block height \"h1\" indicating the last block height of an\n>>> epoch;\n>>> Param 3: an amount \"a\" in satoshi indicating the maximum amount that is\n>>> allowed to be sent in any epoch;\n>>> Param 4: an amount \"a_remaining\" (in satoshi) indicating the maximum\n>>> amount that is allowed to be sent within the current epoch.\n>>>\n>>> For example, consider an input containing 100m sats (1 BTC) which has\n>>> been rate-limited with parameters (h0, h1, a, a_remaining) of (800000,\n>>> 800143, 500k, 500k). These parameters define that the address is\n>>> rate-limited to sending a maximum of 500k sats in the current epoch that\n>>> starts at block height 800000 and ends at height 800143 (or about one day\n>>> ignoring block time variance) and that the full amount of 500k is still\n>>> sendable. These rate-limiting parameters ensure that it takes at minimum\n>>> 100m / 500k = 200 transactions and 200 x 144 blocks or about 200 days to\n>>> spend the full 100m sats. As noted earlier, in a typical setup a user\n>>> should retain the option to transact the entire amount using a second (set\n>>> of) private key(s).\n>>>\n>>> For rate-limiting to work, any change output created by a transaction\n>>> from a rate-limited address must itself be rate-limited as well. For\n>>> instance, expanding on the above example, assume that the user spends 200k\n>>> sats from a rate-limited address a1 containing 100m sats:\n>>>\n>>> Start situation:\n>>> At block height 800000: rate-limited address a1 is created;\n>>> Value of a1: 100.0m sats;\n>>> Rate limiting params of a1: h0=800000, h1=800143, a=500k,\n>>> a_remaining=500k;\n>>>\n>>> Transaction t1:\n>>> Included at block height 800100;\n>>> Spend: 200k + fee;\n>>> Rate limiting params: h0=800000, h1=800143, a=500k, a_remaining=300k.\n>>>\n>>> Result:\n>>> Value at destination address: 200k sats;\n>>> Rate limiting params at destination address: none;\n>>> Value at change address a2: 99.8m sats;\n>>> Rate limiting params at change address a2: h0=800000, h1=800143, a=500k,\n>>> a_remaining=300k.\n>>>\n>>> In order to properly enforce rate limiting, the change address must be\n>>> rate-limited such that the original rate limit of 500k sats per 144 blocks\n>>> cannot be exceeded. In this example, the change address a2 were given the\n>>> same rate limiting parameters as the transaction that served as its input.\n>>> As a result, from block 800100 up until and including block 800143, a\n>>> maximum amount of 300k sats is allowed to be spent from the change address.\n>>>\n>>> Example continued:\n>>> a2: 99.8 sats at height 800100;\n>>> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;\n>>>\n>>> Transaction t2:\n>>> Included at block height 800200\n>>> Spend: 400k + fees.\n>>> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.\n>>>\n>>> Result:\n>>> Value at destination address: 400k sats;\n>>> Rate limiting params at destination address: none;\n>>> Value at change address a3: 99.4m sats;\n>>> Rate limiting params at change address a3: h0=800144, h1=800287, a=500k,\n>>> a_remaining=100k.\n>>>\n>>> Transaction t2 is allowed because it falls within the next epoch\n>>> (running from 800144 to 800287) so a spend of 400k does not violate the\n>>> constraint of 500k per epoch.\n>>>\n>>> As could be seen, the rate limiting parameters are part of the\n>>> transaction and chosen by the user (or their wallet). This means that the\n>>> parameters must be validated to ensure that they do not violate the\n>>> intended constraints.\n>>>\n>>> For instance, this transaction should not be allowed:\n>>> a2: 99.8 sats at height 800100;\n>>> Rate-limit params of a2: h0=800000, h1=800143, a=500k, a_remaining=300k;\n>>>\n>>> Transaction t2a:\n>>> Included at block height 800200;\n>>> Spend: 400k + fees;\n>>> Rate-limit params: h0=800124, h1=800267, a=500k, a_remaining=100k.\n>>>\n>>> This transaction t2a attempts to shift the epoch forward by 20 blocks\n>>> such that it starts at 800124 instead of 800144. Shifting the epoch forward\n>>> like this must not be allowed because it enables spending more that the\n>>> rate limit allows, which is 500k in any epoch of 144 blocks. It would\n>>> enable overspending:\n>>>\n>>> t1: spend 200k at 800100 (epoch 1: total: 200k);\n>>> t2a: spend 400k at 800200 (epoch 2: total: 400k);\n>>> t3a: spend 100k at 800201 (epoch 2: total: 500k);\n>>> t4a: spend 500k at 800268 (epoch 2: total: 1000k, overspending for epoch\n>>> 2).\n>>>\n>>> Specifying the rate-limiting parameters explicitly at every transaction\n>>> allows the user to tighten the spending limit by setting tighter limits or\n>>> for instance by setting a_remainder to 0 if they wish to enforce not\n>>> spending more during an epoch. A second advantage of explicitly specifying\n>>> the four rate-limiting parameters with each transaction is that it allows\n>>> the system to fully validate the transaction without having to consider any\n>>> previous transactions within an epoch.\n>>>\n>>> I will stop here because I would like to gauge interest in this idea\n>>> first before continuing work on other aspects. Two main pieces of work jump\n>>> to mind:\n>>>\n>>> Define all validations;\n>>> Describe aggregate behaviour of multiple (rate-limited) inputs, proof\n>>> that two rate-limited addresses cannot spend more than the sum of their\n>>> individual limits.\n>>>\n>>> Zac\n>>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210804/d529d396/attachment-0001.html>"
            },
            {
                "author": "Billy Tetrud",
                "date": "2021-08-05T06:39:34",
                "message_text_only": ">   A maximum amount is allowed to be spent within EVERY epoch.\n\nIt sounds like you're proposing an opcode that takes in epochStart and\nepochEnd as parameters. I still don't understand why its useful to specify\nthose as absolute block heights. You mentioned that this enables more\nstraightforward validation logic, but I don't see how. Eg, if you have a\nUTXO encumbered by rateLimit(epochStart = 800100, epochEnd = 800200, limit\n= 100k, remain = 100k), what happens if you don't spend that UTXO before\nblock 800200? Is the output no longer rate limited then? Or is the opcode\ncalculating 800200-800100 = 100 and applying a rate limit for the next\nepoch? If the first, then the UTXO must be spent within one epoch to remain\nrate limited. If the second, then it seems nearly identical to simply\nspecifying window=100 as a parameter instead of epochStart and epochEnd.\n\n> then there must be only a single (rate-limited) output\n\nThis rule would make transactions tricky if you're sending money into\nsomeone else's wallet that may be rate limited. If the requirement is that\nonly you yourself can send money into a rate limited wallet, then this\npoint is moot but it would be ideal to not have such a requirement.\n\nThis is how I'd imagine creating an opcode like this:\n\nrateLimit(windowSize = 144 blocks, limit = 100k sats)\n\nThis would define that the epoch is 1 day's worth of blocks. This would\nevenly divide bitcoin's retarget period and so each window would start and\nend at those dividing lines (eg the first 144 blocks of the retargetting\nperiod, then the second, then the third, etc).\n\nWhen this output is spent, it ensures that there's a maximum of 100k sats\nis sent to addresses other than the originating address. It also records\nthe amount spent in the current 144 block window for that address (eg by\nsimply recording the already-spent amount on the resulting UTXO and having\nan index that allows looking up UTXOs by address and adding them up). That\nway, when any output from that address is spent again, if a new 144 block\nwindow has started, the limit is reset, but if its still within the same\nwindow, the already-spent amounts for UTXOs from that address are added up\nand subtracted from the limit, and that number is the remaining limit a\nsubsequent transaction needs to adhere to.\n\nThis way, 3rd party could send transactions into an address like this, and\nmultiple outputs can be combined and used to spend to arbitrary outputs (up\nto the rate limit of course).\n\nOn Wed, Aug 4, 2021 at 3:48 AM Zac Greenwood <zachgrw at gmail.com> wrote:\n\n> > Ah I see, this is all limited to within a single epoch.\n>\n> No, that wouldn't be useful. A maximum amount is allowed to be spent\n> within EVERY epoch.\n>\n> Consider an epoch length of 100 blocks with a spend limit of 200k per\n> epoch. The following is allowed:\n>\n> epoch1 (800101 - 800200): spend 120k in block 800140. Remaining for\n> epoch1: 80k;\n> epoch1 (800101 - 800200): spend another 60k in block 800195. Remaining for\n> epoch1: 20k;\n> epoch2 (800201 - 800300): spend 160k in block 800201. Remaining for\n> epoch2: 40k.\n>\n> Since the limit pertains to each individual epoch, it is allowed to spend\n> up to the full limit at the start of any new epoch. In this example, the\n> spending was as follows:\n>\n> 800140: 120k\n> 800195: 60k\n> 800201: 160k.\n>\n> Note that in a span of 62 blocks a total of 340k sats was spent. This may\n> seem to violate the 200k limit per 100 blocks, but this is the result of\n> using a per-epoch limit. This allows a maximum of 400k to be spent in 2\n> blocks llke so: 200k in the last block of an epoch and another 200k in the\n> first block of the next epoch. However this is inconsequential for the\n> intended goal of rate-limiting which is to enable small spends over time\n> from a large amount and to prevent theft of a large amount with a single\n> transaction.\n>\n> To explain the proposed design more clearly, I have renamed the params as\n> follows:\n>\n> epochStart: block height of first block of the current epoch (was: h0);\n> epochEnd: block height of last block of the current epoch (was: h1);\n> limit: the maximum total amount allowed to be spent within the current\n> epoch (was: a);\n> remain: the remaining amount allowed to be spent within the current epoch\n> (was: a_remaining);\n>\n> Also, to illustrate that the params are specific to a transaction, I will\n> hence precede the param with the transaction name like so:\n> tx8_limit, tx31c_remain, tx42z_epochStart, ... etc.\n>\n> For simplicity, only transactions with no more than one rate-limited input\n> are considered, and with no more than two outputs: one rate-limited change\n> output, and a normal (not rate-limited) output.\n>\n> Normally, a simple transaction generates two outputs: one for a payment to\n> a third party and one for the change address. Again for simplicity, we\n> demand that a transaction which introduces rate-limiting must have only a\n> single, rate-limited output. The validation rule might be: if a transaction\n> has rate-limiting params and none of its inputs are rate-limited, then\n> there must be only a single (rate-limited) output (and no second or change\n> output).\n>\n> Consider rate limiting transactions tx1 having one or more normal (non\n> rate-limited) inputs:\n>\n> tx1 gets included at block height 800004;\n> The inputs of tx1 are not rate-limited => tx1 must have only a single\n> output which will become rate-limited;\n> params: tx1_epochStart=800001, tx1_epochEnd=800100, tx1_limit=200k,\n> tx1_remain=200k;\n> => This defines that an epoch has 100 blocks and no more than 200k sats\n> may be spent in any one epoch. Within the current epoch, 200k sats may\n> still be spent.\n>\n> This transaction begins to rate-limit a set of inputs, so it has a single\n> rate-limited output.\n> Let's explore transactions that have the output of tx1 as their input. I\n> will denote the output of tx1 as \"out1\".\n>\n> tx2a has out1 as its only input;\n> tx2a spends 50k sats and gets included at block height 803050;\n> tx2a specifies the following params for its change output \"chg2a\":\n> chg2a_epochStart=803001, chg2a_epochEnd=803100;\n> chg2a_limit=200k, chg2a_remain=150k.\n>\n> To enforce rate-limiting, the system must validate the params of the\n> change output chg2a to ensure that overspending is not allowed.\n>\n> The above params are allowed because:\n> => 1. the epoch does not become smaller than 100 blocks [(chg2a_epochEnd -\n> chg2a_epochStart) >= (tx1_epochEnd - tx1_epochStart)]\n> => 2. tx1_limit has not been increased (ch2a_limit <= tx1_limit)\n> => 3. the amount spent (50k sats) does not exceed tx1_remain AND does not\n> exceed chg2a_limit;\n> => 4. chg2a_remain\" is 50k sats less than chg2a_limit.\n>\n> A transaction may also further constrain further spending like so:\n>\n> tx2b has out1as its only input;\n> tx2b spends 8k sats and gets included at block height 808105;\n> tx2b specifies the following params for its change output \"chg2b\":\n> chg2b_epochStart=808101, chg2b_epochEnd=808250;\n> chg2b_limit=10k, chg2b_remain=0.\n>\n> These params are allowed because:\n> => 1. the epoch does not become smaller than100 blocks. It is fine to\n> increase the epoch to 150 blocks because it does not enable exceeding the\n> original rate-limit;\n> => 2. the limit (chg2b_limit) has been decreased to 10k sats, further\n> restricting the maximum amount allowed to be spent within the current and\n> any subsequent epochs;\n> => 3. the amount spent (10k sats) does not exceed tx1_remain AND does not\n> exceed chg2b_limit;\n> => 4. chg2b_remain has been set to zero, meaning that within the current\n> epoch (block height 808101 to and including 808250), tx2b cannot be used as\n> a spending input to any transaction.\n>\n> Starting from block height 808251, a new epoch will start and the\n> rate-limited output of tx2b may again be used as an input for a subsequent\n> rate-limited transaction tx3b. This transaction tx3b must again be\n> accompanied by params that do not violate the rate-limit as defined by the\n> params of tx2b and which are stored with output out2b. So, the epoch of\n> tx3b must be at minimum 150 blocks, the maximum that is allowed to be spent\n> per epoch is at most 10k sats, and chg3b_remain must be decreased by at\n> least the amount spent by tx3b.\n>\n> From the above, the rate-limiting mechanics should hopefully be clear and\n> full set of validation rules could be defined in a more generalized way\n> with little additional effort.\n>\n> Note that I conveniently avoided talking about how to represent the\n> parameters within transactions or outputs, simply because I currently lack\n> enough understanding to reason about this. I am hoping that others may\n> offer help.\n>\n> Zac\n>\n>\n> On Tue, Aug 3, 2021 at 8:12 PM Billy Tetrud <billy.tetrud at gmail.com>\n> wrote:\n>\n>> > To enable more straightforward validation logic.\n>> > within the current epoch\n>>\n>> Ah I see, this is all limited to within a single epoch. I think that\n>> sufficiently limits the window of time in which nodes have to store\n>> information for rate limited outputs. However, I don't see how specifying\n>> block ranges simplifies the logic - wouldn't this complicate the logic with\n>> additional user-specified constraints? It also prevents the output from\n>> being able to be rate limited over the span of multiple epochs, which would\n>> seem to make it a lot more difficult to use for certain types of wallets\n>> (eg cold wallets).\n>>\n>> I think I see the logic of your 'remaining' parameter there. If you start\n>> with a single rate-limited input, you can split that into many outputs,\n>> only one of which have a 'remaining' balance. The rest can simply remain\n>> unspendable for the rest of the epoch. That way these things don't need to\n>> be tied together. However, that doesn't solve the problem of 3rd parties\n>> being able to send money into the wallet.\n>>\n>> > I don't believe that the marginal added functionality would justify the\n>> increased implementation complexity\n>>\n>> Perhaps, but I think there is a lot of benefit in allowing these kinds of\n>> things to operate as similarly as possible to normal transactions, for one\n>> because of usability reasons. If each opcode has its own quirks that are\n>> not intuitively related to their purpose (eg if a rate-limited wallet had\n>> no way to get a receiving address), it would confuse end-users (eg who\n>> wonder how to get a receiving address and how they can ask people to send\n>> money into their wallet) or require a lot of technical complexity in\n>> applications (eg to support something like cooperatively connecting with\n>> their wallet so that a transaction can be made that creates a new\n>> single-output for the wallet). A little complexity in this opcode can save\n>> a lot of external complexity here I think.\n>>\n>> > my understanding of Bitcoin is way too low to be able to write a BIP\n>> and do the implementation\n>>\n>> You might be able to find people willing to help. I would be willing to\n>> help write the BIP spec. I'm not the right person to help with the\n>> implementation, but perhaps you could find someone else who is. Even if the\n>> BIP isn't adopted, it could be a starting point or inspiration for someone\n>> else to write an improved version.\n>>\n>> On Mon, Aug 2, 2021 at 2:32 AM Zac Greenwood <zachgrw at gmail.com> wrote:\n>>\n>>> [Note: I've moved your reply to the newly started thread]\n>>>\n>>> Hi Billy,\n>>>\n>>> Thank you for your kind and encouraging feedback.\n>>>\n>>> I don't quite understand why you'd want to define a specific span of\n>>>> blocks for the rate limit. Why not just specify the size of the window (in\n>>>> blocks) to rate limit within, and the limit?\n>>>\n>>>\n>>> To enable more straightforward validation logic.\n>>>\n>>> You mentioned change addresses, however, with the parameters you\n>>>> defined, there would be no way to connect together the change address with\n>>>> the original address, meaning they would have completely separate rate\n>>>> limits, which wouldn't work since the change output would ignore the\n>>>> previous rate limit.\n>>>\n>>>\n>>> The rate-limiting parameters must be re-specified for each rate-limited\n>>> input. So, a transaction that has a rate-limited input is only valid if its\n>>> output is itself rate-limited such that it does not violate the\n>>> rate-limiting constraints of its input.\n>>>\n>>> In my thread-starter, I gave the below example of a rate-limited address\n>>> a2 that serves as input for transaction t2:\n>>>\n>>> a2: 99.8 sats at height 800100;\n>>> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;\n>>>\n>>> Transaction t2:\n>>> Included at block height 800200\n>>> Spend: 400k + fees.\n>>> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.\n>>>\n>>> Note how transaction t2 re-specifies the rate-limiting parameters.\n>>> Validation must ensure that the re-specified parameters are within bounds,\n>>> i.e., do not allow more spending per epoch than the rate-limiting\n>>> parameters of its input address a2. Re-specifying the rate-limiting\n>>> parameters offers the flexibility to further restrict spending, or to\n>>> disable any additional spending within the current epoch by setting\n>>> a_remaining to zero.\n>>>\n>>> Result:\n>>> Value at destination address: 400k sats;\n>>> Rate limiting params at destination address: none;\n>>> Value at change address a3: 99.4m sats;\n>>> Rate limiting params at change address a3: h0=800144, h1=800287, a=500k,\n>>> a_remaining=100k.\n>>>\n>>> As a design principle I believe it makes sense if the system is able to\n>>> verify the validity of a transaction without having to consider any\n>>> transactions that precede its inputs. As a side-note, doing away with this\n>>> design principle would however enable more sophisticated rate-limiting\n>>> (such as rate-limiting per sliding window instead of rate-limiting per\n>>> epoch having a fixed start and end block), but while at the same time\n>>> reducing the size of per rate-limiting transaction (because it would enable\n>>> specifying the rate-limiting parameters more space-efficiently). To test\n>>> the waters and to keep things relatively simple, I chose not to go into\n>>> this enhanced form of rate-limiting.\n>>>\n>>> I haven't gone into how to process a transaction having multiple\n>>> rate-limited inputs. The easiest way to handle this case is to not allow\n>>> any transaction having more than one rate-limited input. One could imagine\n>>> complex logic to handle transactions having multiple rate-limited inputs by\n>>> creating multiple rate-limited change addresses. However at first glance I\n>>> don't believe that the marginal added functionality would justify the\n>>> increased implementation complexity.\n>>>\n>>>  I'd be interested in seeing you write a BIP for this.\n>>>\n>>>\n>>> Thank you, but sadly my understanding of Bitcoin is way too low to be\n>>> able to write a BIP and do the implementation. However I see tremendous\n>>> value in this functionality. Favorable feedback of the list regarding the\n>>> usefulness and the technical feasibility of rate-limiting functionality\n>>> would of course be an encouragement for me to descend further down the\n>>> rabbit hole.\n>>>\n>>> Zac\n>>>\n>>>\n>>> On Sun, Aug 1, 2021 at 10:09 AM Zac Greenwood <zachgrw at gmail.com> wrote:\n>>>\n>>>> [Resubmitting to list with minor edits. My previous submission ended up\n>>>> inside an existing thread, apologies.]\n>>>>\n>>>> Hi list,\n>>>>\n>>>> I'd like to explore whether it is feasible to implement new scripting\n>>>> capabilities in Bitcoin that enable limiting the output amount of a\n>>>> transaction based on the total value of its inputs. In other words, to\n>>>> implement the ability to limit the maximum amount that can be sent from an\n>>>> address.\n>>>>\n>>>> Two use cases come to mind:\n>>>>\n>>>> UC1: enable a user to add additional protection their funds by\n>>>> rate-limiting the amount that they are allowed to send during a certain\n>>>> period (measured in blocks). A typical use case might be a user that\n>>>> intends to hodl their bitcoin, but still wishes to occasionally send small\n>>>> amounts. Rate-limiting avoids an attacker from sweeping all the users'\n>>>> funds in a single transaction, allowing the user to become aware of the\n>>>> theft and intervene to prevent further thefts.\n>>>>\n>>>> UC2: exchanges may wish to rate-limit addresses containing large\n>>>> amounts of bitcoin, adding warm- or hot-wallet functionality to a\n>>>> cold-storage address. This would enable an exchange to drastically reduce\n>>>> the number of times a cold wallet must be accessed with private keys that\n>>>> give access to the full amount.\n>>>>\n>>>> In a typical setup, I'd envision using multisig such that the user has\n>>>> two sets of private keys to their encumbered address (with a \"set\" of keys\n>>>> meaning \"one or more\" keys). One set of private keys allows only for\n>>>> sending with rate-limiting restrictions in place, and a second set of\n>>>> private keys allowing for sending any amount without rate-limiting,\n>>>> effectively overriding such restriction.\n>>>>\n>>>> The parameters that define in what way an output is rate-limited might\n>>>> be defined as follows:\n>>>>\n>>>> Param 1: a block height \"h0\" indicating the first block height of an\n>>>> epoch;\n>>>> Param 2: a block height \"h1\" indicating the last block height of an\n>>>> epoch;\n>>>> Param 3: an amount \"a\" in satoshi indicating the maximum amount that is\n>>>> allowed to be sent in any epoch;\n>>>> Param 4: an amount \"a_remaining\" (in satoshi) indicating the maximum\n>>>> amount that is allowed to be sent within the current epoch.\n>>>>\n>>>> For example, consider an input containing 100m sats (1 BTC) which has\n>>>> been rate-limited with parameters (h0, h1, a, a_remaining) of (800000,\n>>>> 800143, 500k, 500k). These parameters define that the address is\n>>>> rate-limited to sending a maximum of 500k sats in the current epoch that\n>>>> starts at block height 800000 and ends at height 800143 (or about one day\n>>>> ignoring block time variance) and that the full amount of 500k is still\n>>>> sendable. These rate-limiting parameters ensure that it takes at minimum\n>>>> 100m / 500k = 200 transactions and 200 x 144 blocks or about 200 days to\n>>>> spend the full 100m sats. As noted earlier, in a typical setup a user\n>>>> should retain the option to transact the entire amount using a second (set\n>>>> of) private key(s).\n>>>>\n>>>> For rate-limiting to work, any change output created by a transaction\n>>>> from a rate-limited address must itself be rate-limited as well. For\n>>>> instance, expanding on the above example, assume that the user spends 200k\n>>>> sats from a rate-limited address a1 containing 100m sats:\n>>>>\n>>>> Start situation:\n>>>> At block height 800000: rate-limited address a1 is created;\n>>>> Value of a1: 100.0m sats;\n>>>> Rate limiting params of a1: h0=800000, h1=800143, a=500k,\n>>>> a_remaining=500k;\n>>>>\n>>>> Transaction t1:\n>>>> Included at block height 800100;\n>>>> Spend: 200k + fee;\n>>>> Rate limiting params: h0=800000, h1=800143, a=500k, a_remaining=300k.\n>>>>\n>>>> Result:\n>>>> Value at destination address: 200k sats;\n>>>> Rate limiting params at destination address: none;\n>>>> Value at change address a2: 99.8m sats;\n>>>> Rate limiting params at change address a2: h0=800000, h1=800143,\n>>>> a=500k, a_remaining=300k.\n>>>>\n>>>> In order to properly enforce rate limiting, the change address must be\n>>>> rate-limited such that the original rate limit of 500k sats per 144 blocks\n>>>> cannot be exceeded. In this example, the change address a2 were given the\n>>>> same rate limiting parameters as the transaction that served as its input.\n>>>> As a result, from block 800100 up until and including block 800143, a\n>>>> maximum amount of 300k sats is allowed to be spent from the change address.\n>>>>\n>>>> Example continued:\n>>>> a2: 99.8 sats at height 800100;\n>>>> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;\n>>>>\n>>>> Transaction t2:\n>>>> Included at block height 800200\n>>>> Spend: 400k + fees.\n>>>> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.\n>>>>\n>>>> Result:\n>>>> Value at destination address: 400k sats;\n>>>> Rate limiting params at destination address: none;\n>>>> Value at change address a3: 99.4m sats;\n>>>> Rate limiting params at change address a3: h0=800144, h1=800287,\n>>>> a=500k, a_remaining=100k.\n>>>>\n>>>> Transaction t2 is allowed because it falls within the next epoch\n>>>> (running from 800144 to 800287) so a spend of 400k does not violate the\n>>>> constraint of 500k per epoch.\n>>>>\n>>>> As could be seen, the rate limiting parameters are part of the\n>>>> transaction and chosen by the user (or their wallet). This means that the\n>>>> parameters must be validated to ensure that they do not violate the\n>>>> intended constraints.\n>>>>\n>>>> For instance, this transaction should not be allowed:\n>>>> a2: 99.8 sats at height 800100;\n>>>> Rate-limit params of a2: h0=800000, h1=800143, a=500k, a_remaining=300k;\n>>>>\n>>>> Transaction t2a:\n>>>> Included at block height 800200;\n>>>> Spend: 400k + fees;\n>>>> Rate-limit params: h0=800124, h1=800267, a=500k, a_remaining=100k.\n>>>>\n>>>> This transaction t2a attempts to shift the epoch forward by 20 blocks\n>>>> such that it starts at 800124 instead of 800144. Shifting the epoch forward\n>>>> like this must not be allowed because it enables spending more that the\n>>>> rate limit allows, which is 500k in any epoch of 144 blocks. It would\n>>>> enable overspending:\n>>>>\n>>>> t1: spend 200k at 800100 (epoch 1: total: 200k);\n>>>> t2a: spend 400k at 800200 (epoch 2: total: 400k);\n>>>> t3a: spend 100k at 800201 (epoch 2: total: 500k);\n>>>> t4a: spend 500k at 800268 (epoch 2: total: 1000k, overspending for\n>>>> epoch 2).\n>>>>\n>>>> Specifying the rate-limiting parameters explicitly at every transaction\n>>>> allows the user to tighten the spending limit by setting tighter limits or\n>>>> for instance by setting a_remainder to 0 if they wish to enforce not\n>>>> spending more during an epoch. A second advantage of explicitly specifying\n>>>> the four rate-limiting parameters with each transaction is that it allows\n>>>> the system to fully validate the transaction without having to consider any\n>>>> previous transactions within an epoch.\n>>>>\n>>>> I will stop here because I would like to gauge interest in this idea\n>>>> first before continuing work on other aspects. Two main pieces of work jump\n>>>> to mind:\n>>>>\n>>>> Define all validations;\n>>>> Describe aggregate behaviour of multiple (rate-limited) inputs, proof\n>>>> that two rate-limited addresses cannot spend more than the sum of their\n>>>> individual limits.\n>>>>\n>>>> Zac\n>>>>\n>>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210804/ecdc6902/attachment-0001.html>"
            },
            {
                "author": "Zac Greenwood",
                "date": "2021-08-05T14:22:12",
                "message_text_only": "Hi Billy,\n\n> It sounds like you're proposing an opcode\n\nNo. I don\u2019t have enough knowledge of Bitcoin to be able to tell how (and\nif) rate-limiting can be implemented as I suggested. I am not able to\nreason about opcodes, so I kept my description at a more functional level.\n\n> I still don't understand why its useful to specify those as absolute\nblock heights\n\nI feel that this a rather uninteresting data representation aspect that\u2019s\nnot worth going back and forth about. Sure, specifying the length of the\nepoch may also be an option, although at the price of giving up some\nfunctionality, and without much if any gains.\n\nBy explicitly specifying the start and end block of an epoch, the user has\nmore flexibility in shifting the epoch (using alternate values for\nepochStart and epochEnd) and simultaneously increasing the length of an\nepoch. These seem rather exotic features, but there\u2019s no harm in retaining\nthem.\n\n> if you have a UTXO encumbered by rateLimit(epochStart = 800100, epochEnd\n= 800200, limit = 100k, remain = 100k), what happens if you don't spend\nthat UTXO before block 800200?\n\nThe rate limit remains in place. So if this UTXO is spent in block 900000,\nthen at most 100k may be spent. Also, the new epoch must be at least 100\nblocks and remain must correctly account for the actual amount spent.\n\n> This is how I'd imagine creating an opcode like this:\n\n> rateLimit(windowSize = 144 blocks, limit = 100k sats)\n\nThis would require the system to bookkeep how much was spent since the\nfirst rate-limited output. It is a more intuitive way of rate-limiting but\nit may be much more difficult to implement, which is why I went with the\nepoch-based rate limiting solution. In terms of functionality, I believe\nthe two solutions are nearly identical for all practical purposes.\n\nYour next section confuses me. As I understand it, using an address as\ninput for a transaction will always spends the full amount at that address.\nThat\u2019s why change addresses are required, no? If Bitcoin were able to pay\nexact amounts then there wouldn\u2019t be any need for change outputs.\n\nZac\n\n\nOn Thu, 5 Aug 2021 at 08:39, Billy Tetrud <billy.tetrud at gmail.com> wrote:\n\n> >   A maximum amount is allowed to be spent within EVERY epoch.\n>\n> It sounds like you're proposing an opcode that takes in epochStart and\n> epochEnd as parameters. I still don't understand why its useful to specify\n> those as absolute block heights. You mentioned that this enables more\n> straightforward validation logic, but I don't see how. Eg, if you have a\n> UTXO encumbered by rateLimit(epochStart = 800100, epochEnd = 800200, limit\n> = 100k, remain = 100k), what happens if you don't spend that UTXO before\n> block 800200? Is the output no longer rate limited then? Or is the opcode\n> calculating 800200-800100 = 100 and applying a rate limit for the next\n> epoch? If the first, then the UTXO must be spent within one epoch to remain\n> rate limited. If the second, then it seems nearly identical to simply\n> specifying window=100 as a parameter instead of epochStart and epochEnd.\n>\n> > then there must be only a single (rate-limited) output\n>\n> This rule would make transactions tricky if you're sending money into\n> someone else's wallet that may be rate limited. If the requirement is that\n> only you yourself can send money into a rate limited wallet, then this\n> point is moot but it would be ideal to not have such a requirement.\n>\n> This is how I'd imagine creating an opcode like this:\n>\n> rateLimit(windowSize = 144 blocks, limit = 100k sats)\n>\n> This would define that the epoch is 1 day's worth of blocks. This would\n> evenly divide bitcoin's retarget period and so each window would start and\n> end at those dividing lines (eg the first 144 blocks of the retargetting\n> period, then the second, then the third, etc).\n>\n> When this output is spent, it ensures that there's a maximum of 100k sats\n> is sent to addresses other than the originating address. It also records\n> the amount spent in the current 144 block window for that address (eg by\n> simply recording the already-spent amount on the resulting UTXO and having\n> an index that allows looking up UTXOs by address and adding them up). That\n> way, when any output from that address is spent again, if a new 144 block\n> window has started, the limit is reset, but if its still within the same\n> window, the already-spent amounts for UTXOs from that address are added up\n> and subtracted from the limit, and that number is the remaining limit a\n> subsequent transaction needs to adhere to.\n>\n> This way, 3rd party could send transactions into an address like this, and\n> multiple outputs can be combined and used to spend to arbitrary outputs (up\n> to the rate limit of course).\n>\n> On Wed, Aug 4, 2021 at 3:48 AM Zac Greenwood <zachgrw at gmail.com> wrote:\n>\n>> > Ah I see, this is all limited to within a single epoch.\n>>\n>> No, that wouldn't be useful. A maximum amount is allowed to be spent\n>> within EVERY epoch.\n>>\n>> Consider an epoch length of 100 blocks with a spend limit of 200k per\n>> epoch. The following is allowed:\n>>\n>> epoch1 (800101 - 800200): spend 120k in block 800140. Remaining for\n>> epoch1: 80k;\n>> epoch1 (800101 - 800200): spend another 60k in block 800195. Remaining\n>> for epoch1: 20k;\n>> epoch2 (800201 - 800300): spend 160k in block 800201. Remaining for\n>> epoch2: 40k.\n>>\n>> Since the limit pertains to each individual epoch, it is allowed to spend\n>> up to the full limit at the start of any new epoch. In this example, the\n>> spending was as follows:\n>>\n>> 800140: 120k\n>> 800195: 60k\n>> 800201: 160k.\n>>\n>> Note that in a span of 62 blocks a total of 340k sats was spent. This may\n>> seem to violate the 200k limit per 100 blocks, but this is the result of\n>> using a per-epoch limit. This allows a maximum of 400k to be spent in 2\n>> blocks llke so: 200k in the last block of an epoch and another 200k in the\n>> first block of the next epoch. However this is inconsequential for the\n>> intended goal of rate-limiting which is to enable small spends over time\n>> from a large amount and to prevent theft of a large amount with a single\n>> transaction.\n>>\n>> To explain the proposed design more clearly, I have renamed the params as\n>> follows:\n>>\n>> epochStart: block height of first block of the current epoch (was: h0);\n>> epochEnd: block height of last block of the current epoch (was: h1);\n>> limit: the maximum total amount allowed to be spent within the current\n>> epoch (was: a);\n>> remain: the remaining amount allowed to be spent within the current epoch\n>> (was: a_remaining);\n>>\n>> Also, to illustrate that the params are specific to a transaction, I will\n>> hence precede the param with the transaction name like so:\n>> tx8_limit, tx31c_remain, tx42z_epochStart, ... etc.\n>>\n>> For simplicity, only transactions with no more than one rate-limited\n>> input are considered, and with no more than two outputs: one rate-limited\n>> change output, and a normal (not rate-limited) output.\n>>\n>> Normally, a simple transaction generates two outputs: one for a payment\n>> to a third party and one for the change address. Again for simplicity, we\n>> demand that a transaction which introduces rate-limiting must have only a\n>> single, rate-limited output. The validation rule might be: if a transaction\n>> has rate-limiting params and none of its inputs are rate-limited, then\n>> there must be only a single (rate-limited) output (and no second or change\n>> output).\n>>\n>> Consider rate limiting transactions tx1 having one or more normal (non\n>> rate-limited) inputs:\n>>\n>> tx1 gets included at block height 800004;\n>> The inputs of tx1 are not rate-limited => tx1 must have only a single\n>> output which will become rate-limited;\n>> params: tx1_epochStart=800001, tx1_epochEnd=800100, tx1_limit=200k,\n>> tx1_remain=200k;\n>> => This defines that an epoch has 100 blocks and no more than 200k sats\n>> may be spent in any one epoch. Within the current epoch, 200k sats may\n>> still be spent.\n>>\n>> This transaction begins to rate-limit a set of inputs, so it has a single\n>> rate-limited output.\n>> Let's explore transactions that have the output of tx1 as their input. I\n>> will denote the output of tx1 as \"out1\".\n>>\n>> tx2a has out1 as its only input;\n>> tx2a spends 50k sats and gets included at block height 803050;\n>> tx2a specifies the following params for its change output \"chg2a\":\n>> chg2a_epochStart=803001, chg2a_epochEnd=803100;\n>> chg2a_limit=200k, chg2a_remain=150k.\n>>\n>> To enforce rate-limiting, the system must validate the params of the\n>> change output chg2a to ensure that overspending is not allowed.\n>>\n>> The above params are allowed because:\n>> => 1. the epoch does not become smaller than 100 blocks [(chg2a_epochEnd\n>> - chg2a_epochStart) >= (tx1_epochEnd - tx1_epochStart)]\n>> => 2. tx1_limit has not been increased (ch2a_limit <= tx1_limit)\n>> => 3. the amount spent (50k sats) does not exceed tx1_remain AND does not\n>> exceed chg2a_limit;\n>> => 4. chg2a_remain\" is 50k sats less than chg2a_limit.\n>>\n>> A transaction may also further constrain further spending like so:\n>>\n>> tx2b has out1as its only input;\n>> tx2b spends 8k sats and gets included at block height 808105;\n>> tx2b specifies the following params for its change output \"chg2b\":\n>> chg2b_epochStart=808101, chg2b_epochEnd=808250;\n>> chg2b_limit=10k, chg2b_remain=0.\n>>\n>> These params are allowed because:\n>> => 1. the epoch does not become smaller than100 blocks. It is fine to\n>> increase the epoch to 150 blocks because it does not enable exceeding the\n>> original rate-limit;\n>> => 2. the limit (chg2b_limit) has been decreased to 10k sats, further\n>> restricting the maximum amount allowed to be spent within the current and\n>> any subsequent epochs;\n>> => 3. the amount spent (10k sats) does not exceed tx1_remain AND does not\n>> exceed chg2b_limit;\n>> => 4. chg2b_remain has been set to zero, meaning that within the current\n>> epoch (block height 808101 to and including 808250), tx2b cannot be used as\n>> a spending input to any transaction.\n>>\n>> Starting from block height 808251, a new epoch will start and the\n>> rate-limited output of tx2b may again be used as an input for a subsequent\n>> rate-limited transaction tx3b. This transaction tx3b must again be\n>> accompanied by params that do not violate the rate-limit as defined by the\n>> params of tx2b and which are stored with output out2b. So, the epoch of\n>> tx3b must be at minimum 150 blocks, the maximum that is allowed to be spent\n>> per epoch is at most 10k sats, and chg3b_remain must be decreased by at\n>> least the amount spent by tx3b.\n>>\n>> From the above, the rate-limiting mechanics should hopefully be clear and\n>> full set of validation rules could be defined in a more generalized way\n>> with little additional effort.\n>>\n>> Note that I conveniently avoided talking about how to represent the\n>> parameters within transactions or outputs, simply because I currently lack\n>> enough understanding to reason about this. I am hoping that others may\n>> offer help.\n>>\n>> Zac\n>>\n>>\n>> On Tue, Aug 3, 2021 at 8:12 PM Billy Tetrud <billy.tetrud at gmail.com>\n>> wrote:\n>>\n>>> > To enable more straightforward validation logic.\n>>> > within the current epoch\n>>>\n>>> Ah I see, this is all limited to within a single epoch. I think that\n>>> sufficiently limits the window of time in which nodes have to store\n>>> information for rate limited outputs. However, I don't see how specifying\n>>> block ranges simplifies the logic - wouldn't this complicate the logic with\n>>> additional user-specified constraints? It also prevents the output from\n>>> being able to be rate limited over the span of multiple epochs, which would\n>>> seem to make it a lot more difficult to use for certain types of wallets\n>>> (eg cold wallets).\n>>>\n>>> I think I see the logic of your 'remaining' parameter there. If you\n>>> start with a single rate-limited input, you can split that into many\n>>> outputs, only one of which have a 'remaining' balance. The rest can simply\n>>> remain unspendable for the rest of the epoch. That way these things don't\n>>> need to be tied together. However, that doesn't solve the problem of 3rd\n>>> parties being able to send money into the wallet.\n>>>\n>>> > I don't believe that the marginal added functionality would justify\n>>> the increased implementation complexity\n>>>\n>>> Perhaps, but I think there is a lot of benefit in allowing these kinds\n>>> of things to operate as similarly as possible to normal transactions, for\n>>> one because of usability reasons. If each opcode has its own quirks that\n>>> are not intuitively related to their purpose (eg if a rate-limited wallet\n>>> had no way to get a receiving address), it would confuse end-users (eg who\n>>> wonder how to get a receiving address and how they can ask people to send\n>>> money into their wallet) or require a lot of technical complexity in\n>>> applications (eg to support something like cooperatively connecting with\n>>> their wallet so that a transaction can be made that creates a new\n>>> single-output for the wallet). A little complexity in this opcode can save\n>>> a lot of external complexity here I think.\n>>>\n>>> > my understanding of Bitcoin is way too low to be able to write a BIP\n>>> and do the implementation\n>>>\n>>> You might be able to find people willing to help. I would be willing to\n>>> help write the BIP spec. I'm not the right person to help with the\n>>> implementation, but perhaps you could find someone else who is. Even if the\n>>> BIP isn't adopted, it could be a starting point or inspiration for someone\n>>> else to write an improved version.\n>>>\n>>> On Mon, Aug 2, 2021 at 2:32 AM Zac Greenwood <zachgrw at gmail.com> wrote:\n>>>\n>>>> [Note: I've moved your reply to the newly started thread]\n>>>>\n>>>> Hi Billy,\n>>>>\n>>>> Thank you for your kind and encouraging feedback.\n>>>>\n>>>> I don't quite understand why you'd want to define a specific span of\n>>>>> blocks for the rate limit. Why not just specify the size of the window (in\n>>>>> blocks) to rate limit within, and the limit?\n>>>>\n>>>>\n>>>> To enable more straightforward validation logic.\n>>>>\n>>>> You mentioned change addresses, however, with the parameters you\n>>>>> defined, there would be no way to connect together the change address with\n>>>>> the original address, meaning they would have completely separate rate\n>>>>> limits, which wouldn't work since the change output would ignore the\n>>>>> previous rate limit.\n>>>>\n>>>>\n>>>> The rate-limiting parameters must be re-specified for each rate-limited\n>>>> input. So, a transaction that has a rate-limited input is only valid if its\n>>>> output is itself rate-limited such that it does not violate the\n>>>> rate-limiting constraints of its input.\n>>>>\n>>>> In my thread-starter, I gave the below example of a rate-limited\n>>>> address a2 that serves as input for transaction t2:\n>>>>\n>>>> a2: 99.8 sats at height 800100;\n>>>> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;\n>>>>\n>>>> Transaction t2:\n>>>> Included at block height 800200\n>>>> Spend: 400k + fees.\n>>>> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.\n>>>>\n>>>> Note how transaction t2 re-specifies the rate-limiting parameters.\n>>>> Validation must ensure that the re-specified parameters are within bounds,\n>>>> i.e., do not allow more spending per epoch than the rate-limiting\n>>>> parameters of its input address a2. Re-specifying the rate-limiting\n>>>> parameters offers the flexibility to further restrict spending, or to\n>>>> disable any additional spending within the current epoch by setting\n>>>> a_remaining to zero.\n>>>>\n>>>> Result:\n>>>> Value at destination address: 400k sats;\n>>>> Rate limiting params at destination address: none;\n>>>> Value at change address a3: 99.4m sats;\n>>>> Rate limiting params at change address a3: h0=800144, h1=800287,\n>>>> a=500k, a_remaining=100k.\n>>>>\n>>>> As a design principle I believe it makes sense if the system is able to\n>>>> verify the validity of a transaction without having to consider any\n>>>> transactions that precede its inputs. As a side-note, doing away with this\n>>>> design principle would however enable more sophisticated rate-limiting\n>>>> (such as rate-limiting per sliding window instead of rate-limiting per\n>>>> epoch having a fixed start and end block), but while at the same time\n>>>> reducing the size of per rate-limiting transaction (because it would enable\n>>>> specifying the rate-limiting parameters more space-efficiently). To test\n>>>> the waters and to keep things relatively simple, I chose not to go into\n>>>> this enhanced form of rate-limiting.\n>>>>\n>>>> I haven't gone into how to process a transaction having multiple\n>>>> rate-limited inputs. The easiest way to handle this case is to not allow\n>>>> any transaction having more than one rate-limited input. One could imagine\n>>>> complex logic to handle transactions having multiple rate-limited inputs by\n>>>> creating multiple rate-limited change addresses. However at first glance I\n>>>> don't believe that the marginal added functionality would justify the\n>>>> increased implementation complexity.\n>>>>\n>>>>  I'd be interested in seeing you write a BIP for this.\n>>>>\n>>>>\n>>>> Thank you, but sadly my understanding of Bitcoin is way too low to be\n>>>> able to write a BIP and do the implementation. However I see tremendous\n>>>> value in this functionality. Favorable feedback of the list regarding the\n>>>> usefulness and the technical feasibility of rate-limiting functionality\n>>>> would of course be an encouragement for me to descend further down the\n>>>> rabbit hole.\n>>>>\n>>>> Zac\n>>>>\n>>>>\n>>>> On Sun, Aug 1, 2021 at 10:09 AM Zac Greenwood <zachgrw at gmail.com>\n>>>> wrote:\n>>>>\n>>>>> [Resubmitting to list with minor edits. My previous submission ended\n>>>>> up inside an existing thread, apologies.]\n>>>>>\n>>>>> Hi list,\n>>>>>\n>>>>> I'd like to explore whether it is feasible to implement new scripting\n>>>>> capabilities in Bitcoin that enable limiting the output amount of a\n>>>>> transaction based on the total value of its inputs. In other words, to\n>>>>> implement the ability to limit the maximum amount that can be sent from an\n>>>>> address.\n>>>>>\n>>>>> Two use cases come to mind:\n>>>>>\n>>>>> UC1: enable a user to add additional protection their funds by\n>>>>> rate-limiting the amount that they are allowed to send during a certain\n>>>>> period (measured in blocks). A typical use case might be a user that\n>>>>> intends to hodl their bitcoin, but still wishes to occasionally send small\n>>>>> amounts. Rate-limiting avoids an attacker from sweeping all the users'\n>>>>> funds in a single transaction, allowing the user to become aware of the\n>>>>> theft and intervene to prevent further thefts.\n>>>>>\n>>>>> UC2: exchanges may wish to rate-limit addresses containing large\n>>>>> amounts of bitcoin, adding warm- or hot-wallet functionality to a\n>>>>> cold-storage address. This would enable an exchange to drastically reduce\n>>>>> the number of times a cold wallet must be accessed with private keys that\n>>>>> give access to the full amount.\n>>>>>\n>>>>> In a typical setup, I'd envision using multisig such that the user has\n>>>>> two sets of private keys to their encumbered address (with a \"set\" of keys\n>>>>> meaning \"one or more\" keys). One set of private keys allows only for\n>>>>> sending with rate-limiting restrictions in place, and a second set of\n>>>>> private keys allowing for sending any amount without rate-limiting,\n>>>>> effectively overriding such restriction.\n>>>>>\n>>>>> The parameters that define in what way an output is rate-limited might\n>>>>> be defined as follows:\n>>>>>\n>>>>> Param 1: a block height \"h0\" indicating the first block height of an\n>>>>> epoch;\n>>>>> Param 2: a block height \"h1\" indicating the last block height of an\n>>>>> epoch;\n>>>>> Param 3: an amount \"a\" in satoshi indicating the maximum amount that\n>>>>> is allowed to be sent in any epoch;\n>>>>> Param 4: an amount \"a_remaining\" (in satoshi) indicating the maximum\n>>>>> amount that is allowed to be sent within the current epoch.\n>>>>>\n>>>>> For example, consider an input containing 100m sats (1 BTC) which has\n>>>>> been rate-limited with parameters (h0, h1, a, a_remaining) of (800000,\n>>>>> 800143, 500k, 500k). These parameters define that the address is\n>>>>> rate-limited to sending a maximum of 500k sats in the current epoch that\n>>>>> starts at block height 800000 and ends at height 800143 (or about one day\n>>>>> ignoring block time variance) and that the full amount of 500k is still\n>>>>> sendable. These rate-limiting parameters ensure that it takes at minimum\n>>>>> 100m / 500k = 200 transactions and 200 x 144 blocks or about 200 days to\n>>>>> spend the full 100m sats. As noted earlier, in a typical setup a user\n>>>>> should retain the option to transact the entire amount using a second (set\n>>>>> of) private key(s).\n>>>>>\n>>>>> For rate-limiting to work, any change output created by a transaction\n>>>>> from a rate-limited address must itself be rate-limited as well. For\n>>>>> instance, expanding on the above example, assume that the user spends 200k\n>>>>> sats from a rate-limited address a1 containing 100m sats:\n>>>>>\n>>>>> Start situation:\n>>>>> At block height 800000: rate-limited address a1 is created;\n>>>>> Value of a1: 100.0m sats;\n>>>>> Rate limiting params of a1: h0=800000, h1=800143, a=500k,\n>>>>> a_remaining=500k;\n>>>>>\n>>>>> Transaction t1:\n>>>>> Included at block height 800100;\n>>>>> Spend: 200k + fee;\n>>>>> Rate limiting params: h0=800000, h1=800143, a=500k, a_remaining=300k.\n>>>>>\n>>>>> Result:\n>>>>> Value at destination address: 200k sats;\n>>>>> Rate limiting params at destination address: none;\n>>>>> Value at change address a2: 99.8m sats;\n>>>>> Rate limiting params at change address a2: h0=800000, h1=800143,\n>>>>> a=500k, a_remaining=300k.\n>>>>>\n>>>>> In order to properly enforce rate limiting, the change address must be\n>>>>> rate-limited such that the original rate limit of 500k sats per 144 blocks\n>>>>> cannot be exceeded. In this example, the change address a2 were given the\n>>>>> same rate limiting parameters as the transaction that served as its input.\n>>>>> As a result, from block 800100 up until and including block 800143, a\n>>>>> maximum amount of 300k sats is allowed to be spent from the change address.\n>>>>>\n>>>>> Example continued:\n>>>>> a2: 99.8 sats at height 800100;\n>>>>> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;\n>>>>>\n>>>>> Transaction t2:\n>>>>> Included at block height 800200\n>>>>> Spend: 400k + fees.\n>>>>> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.\n>>>>>\n>>>>> Result:\n>>>>> Value at destination address: 400k sats;\n>>>>> Rate limiting params at destination address: none;\n>>>>> Value at change address a3: 99.4m sats;\n>>>>> Rate limiting params at change address a3: h0=800144, h1=800287,\n>>>>> a=500k, a_remaining=100k.\n>>>>>\n>>>>> Transaction t2 is allowed because it falls within the next epoch\n>>>>> (running from 800144 to 800287) so a spend of 400k does not violate the\n>>>>> constraint of 500k per epoch.\n>>>>>\n>>>>> As could be seen, the rate limiting parameters are part of the\n>>>>> transaction and chosen by the user (or their wallet). This means that the\n>>>>> parameters must be validated to ensure that they do not violate the\n>>>>> intended constraints.\n>>>>>\n>>>>> For instance, this transaction should not be allowed:\n>>>>> a2: 99.8 sats at height 800100;\n>>>>> Rate-limit params of a2: h0=800000, h1=800143, a=500k,\n>>>>> a_remaining=300k;\n>>>>>\n>>>>> Transaction t2a:\n>>>>> Included at block height 800200;\n>>>>> Spend: 400k + fees;\n>>>>> Rate-limit params: h0=800124, h1=800267, a=500k, a_remaining=100k.\n>>>>>\n>>>>> This transaction t2a attempts to shift the epoch forward by 20 blocks\n>>>>> such that it starts at 800124 instead of 800144. Shifting the epoch forward\n>>>>> like this must not be allowed because it enables spending more that the\n>>>>> rate limit allows, which is 500k in any epoch of 144 blocks. It would\n>>>>> enable overspending:\n>>>>>\n>>>>> t1: spend 200k at 800100 (epoch 1: total: 200k);\n>>>>> t2a: spend 400k at 800200 (epoch 2: total: 400k);\n>>>>> t3a: spend 100k at 800201 (epoch 2: total: 500k);\n>>>>> t4a: spend 500k at 800268 (epoch 2: total: 1000k, overspending for\n>>>>> epoch 2).\n>>>>>\n>>>>> Specifying the rate-limiting parameters explicitly at every\n>>>>> transaction allows the user to tighten the spending limit by setting\n>>>>> tighter limits or for instance by setting a_remainder to 0 if they wish to\n>>>>> enforce not spending more during an epoch. A second advantage of explicitly\n>>>>> specifying the four rate-limiting parameters with each transaction is that\n>>>>> it allows the system to fully validate the transaction without having to\n>>>>> consider any previous transactions within an epoch.\n>>>>>\n>>>>> I will stop here because I would like to gauge interest in this idea\n>>>>> first before continuing work on other aspects. Two main pieces of work jump\n>>>>> to mind:\n>>>>>\n>>>>> Define all validations;\n>>>>> Describe aggregate behaviour of multiple (rate-limited) inputs, proof\n>>>>> that two rate-limited addresses cannot spend more than the sum of their\n>>>>> individual limits.\n>>>>>\n>>>>> Zac\n>>>>>\n>>>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210805/55d5d18c/attachment-0001.html>"
            },
            {
                "author": "Billy Tetrud",
                "date": "2021-08-10T00:41:12",
                "message_text_only": ">  By explicitly specifying the start and end block of an epoch, the user\nhas more flexibility in shifting the epoch\n\nOk I see. I think I understand your proposal better now. If the output is\nspent within the range epochStart - epochEnd, the limit holds, if it is\nspent outside that range the change output must also have a range of the\nsame length (or shorter?). So you want there to be the ability for the user\nto precisely define the length and starting block of the\nrate-limiting-period (epoch). I'd say it'd be clearer to specify the window\nlength and the starting block in that case. The same semantics can be kept.\n\n> This would require the system to bookkeep how much was spent since the\nfirst rate-limited output\n\nYes, for the length of the epoch, after which the bookkeeping can be\ndiscarded/reset until a new transaction is sent. Your proposal also\nrequires bookkeeping tho - it needs to store the 'remain' value with the\nUTXO as well because its not efficient to go back and re-execute the script\njust to grab that value.\n\n> using an address as input for a transaction will always spends the full\namount at that address\n\nUsing a UTXO will spend the full UTXO. The address may contain many UTXOs.\nI'm not suggesting that a change address isn't needed - I'm suggesting that\nthe *same* address be used as the change address for the change output. Eg\nconsider the following UTXO info:\n\nAddress X: rateLimit(windowSize = 144 blocks, limit = 100k sats)\n* UTXO 1: 100k sats, 50k spent by ancestor inputs since epochStart 800100\n* UTXO 2: 200k sats, 10k spent since epochStart\n\nWhen sending a transaction using UTXO 2, a node would look up the list of\nUTXOs in Address X, add up the amount spent since epochStart (60k) and\nensure that at most 40k is going to an address that isn't address X. So a\nvalid transaction might look like:\n\nInput: UTXO 2\nOutput 1: 30k -> Address A\nOutput 2: 170k -> Address X\n\nOn Thu, Aug 5, 2021 at 7:22 AM Zac Greenwood <zachgrw at gmail.com> wrote:\n\n> Hi Billy,\n>\n> > It sounds like you're proposing an opcode\n>\n> No. I don\u2019t have enough knowledge of Bitcoin to be able to tell how (and\n> if) rate-limiting can be implemented as I suggested. I am not able to\n> reason about opcodes, so I kept my description at a more functional level.\n>\n> > I still don't understand why its useful to specify those as absolute\n> block heights\n>\n> I feel that this a rather uninteresting data representation aspect that\u2019s\n> not worth going back and forth about. Sure, specifying the length of the\n> epoch may also be an option, although at the price of giving up some\n> functionality, and without much if any gains.\n>\n> By explicitly specifying the start and end block of an epoch, the user has\n> more flexibility in shifting the epoch (using alternate values for\n> epochStart and epochEnd) and simultaneously increasing the length of an\n> epoch. These seem rather exotic features, but there\u2019s no harm in retaining\n> them.\n>\n> > if you have a UTXO encumbered by rateLimit(epochStart = 800100,\n> epochEnd = 800200, limit = 100k, remain = 100k), what happens if you don't\n> spend that UTXO before block 800200?\n>\n> The rate limit remains in place. So if this UTXO is spent in block 900000,\n> then at most 100k may be spent. Also, the new epoch must be at least 100\n> blocks and remain must correctly account for the actual amount spent.\n>\n> > This is how I'd imagine creating an opcode like this:\n>\n> > rateLimit(windowSize = 144 blocks, limit = 100k sats)\n>\n> This would require the system to bookkeep how much was spent since the\n> first rate-limited output. It is a more intuitive way of rate-limiting but\n> it may be much more difficult to implement, which is why I went with the\n> epoch-based rate limiting solution. In terms of functionality, I believe\n> the two solutions are nearly identical for all practical purposes.\n>\n> Your next section confuses me. As I understand it, using an address as\n> input for a transaction will always spends the full amount at that address.\n> That\u2019s why change addresses are required, no? If Bitcoin were able to pay\n> exact amounts then there wouldn\u2019t be any need for change outputs.\n>\n> Zac\n>\n>\n> On Thu, 5 Aug 2021 at 08:39, Billy Tetrud <billy.tetrud at gmail.com> wrote:\n>\n>> >   A maximum amount is allowed to be spent within EVERY epoch.\n>>\n>> It sounds like you're proposing an opcode that takes in epochStart and\n>> epochEnd as parameters. I still don't understand why its useful to specify\n>> those as absolute block heights. You mentioned that this enables more\n>> straightforward validation logic, but I don't see how. Eg, if you have a\n>> UTXO encumbered by rateLimit(epochStart = 800100, epochEnd = 800200, limit\n>> = 100k, remain = 100k), what happens if you don't spend that UTXO before\n>> block 800200? Is the output no longer rate limited then? Or is the opcode\n>> calculating 800200-800100 = 100 and applying a rate limit for the next\n>> epoch? If the first, then the UTXO must be spent within one epoch to remain\n>> rate limited. If the second, then it seems nearly identical to simply\n>> specifying window=100 as a parameter instead of epochStart and epochEnd.\n>>\n>> > then there must be only a single (rate-limited) output\n>>\n>> This rule would make transactions tricky if you're sending money into\n>> someone else's wallet that may be rate limited. If the requirement is that\n>> only you yourself can send money into a rate limited wallet, then this\n>> point is moot but it would be ideal to not have such a requirement.\n>>\n>> This is how I'd imagine creating an opcode like this:\n>>\n>> rateLimit(windowSize = 144 blocks, limit = 100k sats)\n>>\n>> This would define that the epoch is 1 day's worth of blocks. This would\n>> evenly divide bitcoin's retarget period and so each window would start and\n>> end at those dividing lines (eg the first 144 blocks of the retargetting\n>> period, then the second, then the third, etc).\n>>\n>> When this output is spent, it ensures that there's a maximum of 100k sats\n>> is sent to addresses other than the originating address. It also records\n>> the amount spent in the current 144 block window for that address (eg by\n>> simply recording the already-spent amount on the resulting UTXO and having\n>> an index that allows looking up UTXOs by address and adding them up). That\n>> way, when any output from that address is spent again, if a new 144 block\n>> window has started, the limit is reset, but if its still within the same\n>> window, the already-spent amounts for UTXOs from that address are added up\n>> and subtracted from the limit, and that number is the remaining limit a\n>> subsequent transaction needs to adhere to.\n>>\n>> This way, 3rd party could send transactions into an address like this,\n>> and multiple outputs can be combined and used to spend to arbitrary outputs\n>> (up to the rate limit of course).\n>>\n>> On Wed, Aug 4, 2021 at 3:48 AM Zac Greenwood <zachgrw at gmail.com> wrote:\n>>\n>>> > Ah I see, this is all limited to within a single epoch.\n>>>\n>>> No, that wouldn't be useful. A maximum amount is allowed to be spent\n>>> within EVERY epoch.\n>>>\n>>> Consider an epoch length of 100 blocks with a spend limit of 200k per\n>>> epoch. The following is allowed:\n>>>\n>>> epoch1 (800101 - 800200): spend 120k in block 800140. Remaining for\n>>> epoch1: 80k;\n>>> epoch1 (800101 - 800200): spend another 60k in block 800195. Remaining\n>>> for epoch1: 20k;\n>>> epoch2 (800201 - 800300): spend 160k in block 800201. Remaining for\n>>> epoch2: 40k.\n>>>\n>>> Since the limit pertains to each individual epoch, it is allowed to\n>>> spend up to the full limit at the start of any new epoch. In this example,\n>>> the spending was as follows:\n>>>\n>>> 800140: 120k\n>>> 800195: 60k\n>>> 800201: 160k.\n>>>\n>>> Note that in a span of 62 blocks a total of 340k sats was spent. This\n>>> may seem to violate the 200k limit per 100 blocks, but this is the result\n>>> of using a per-epoch limit. This allows a maximum of 400k to be spent in 2\n>>> blocks llke so: 200k in the last block of an epoch and another 200k in the\n>>> first block of the next epoch. However this is inconsequential for the\n>>> intended goal of rate-limiting which is to enable small spends over time\n>>> from a large amount and to prevent theft of a large amount with a single\n>>> transaction.\n>>>\n>>> To explain the proposed design more clearly, I have renamed the params\n>>> as follows:\n>>>\n>>> epochStart: block height of first block of the current epoch (was: h0);\n>>> epochEnd: block height of last block of the current epoch (was: h1);\n>>> limit: the maximum total amount allowed to be spent within the current\n>>> epoch (was: a);\n>>> remain: the remaining amount allowed to be spent within the current\n>>> epoch (was: a_remaining);\n>>>\n>>> Also, to illustrate that the params are specific to a transaction, I\n>>> will hence precede the param with the transaction name like so:\n>>> tx8_limit, tx31c_remain, tx42z_epochStart, ... etc.\n>>>\n>>> For simplicity, only transactions with no more than one rate-limited\n>>> input are considered, and with no more than two outputs: one rate-limited\n>>> change output, and a normal (not rate-limited) output.\n>>>\n>>> Normally, a simple transaction generates two outputs: one for a payment\n>>> to a third party and one for the change address. Again for simplicity, we\n>>> demand that a transaction which introduces rate-limiting must have only a\n>>> single, rate-limited output. The validation rule might be: if a transaction\n>>> has rate-limiting params and none of its inputs are rate-limited, then\n>>> there must be only a single (rate-limited) output (and no second or change\n>>> output).\n>>>\n>>> Consider rate limiting transactions tx1 having one or more normal (non\n>>> rate-limited) inputs:\n>>>\n>>> tx1 gets included at block height 800004;\n>>> The inputs of tx1 are not rate-limited => tx1 must have only a single\n>>> output which will become rate-limited;\n>>> params: tx1_epochStart=800001, tx1_epochEnd=800100, tx1_limit=200k,\n>>> tx1_remain=200k;\n>>> => This defines that an epoch has 100 blocks and no more than 200k sats\n>>> may be spent in any one epoch. Within the current epoch, 200k sats may\n>>> still be spent.\n>>>\n>>> This transaction begins to rate-limit a set of inputs, so it has a\n>>> single rate-limited output.\n>>> Let's explore transactions that have the output of tx1 as their input. I\n>>> will denote the output of tx1 as \"out1\".\n>>>\n>>> tx2a has out1 as its only input;\n>>> tx2a spends 50k sats and gets included at block height 803050;\n>>> tx2a specifies the following params for its change output \"chg2a\":\n>>> chg2a_epochStart=803001, chg2a_epochEnd=803100;\n>>> chg2a_limit=200k, chg2a_remain=150k.\n>>>\n>>> To enforce rate-limiting, the system must validate the params of the\n>>> change output chg2a to ensure that overspending is not allowed.\n>>>\n>>> The above params are allowed because:\n>>> => 1. the epoch does not become smaller than 100 blocks [(chg2a_epochEnd\n>>> - chg2a_epochStart) >= (tx1_epochEnd - tx1_epochStart)]\n>>> => 2. tx1_limit has not been increased (ch2a_limit <= tx1_limit)\n>>> => 3. the amount spent (50k sats) does not exceed tx1_remain AND does\n>>> not exceed chg2a_limit;\n>>> => 4. chg2a_remain\" is 50k sats less than chg2a_limit.\n>>>\n>>> A transaction may also further constrain further spending like so:\n>>>\n>>> tx2b has out1as its only input;\n>>> tx2b spends 8k sats and gets included at block height 808105;\n>>> tx2b specifies the following params for its change output \"chg2b\":\n>>> chg2b_epochStart=808101, chg2b_epochEnd=808250;\n>>> chg2b_limit=10k, chg2b_remain=0.\n>>>\n>>> These params are allowed because:\n>>> => 1. the epoch does not become smaller than100 blocks. It is fine to\n>>> increase the epoch to 150 blocks because it does not enable exceeding the\n>>> original rate-limit;\n>>> => 2. the limit (chg2b_limit) has been decreased to 10k sats, further\n>>> restricting the maximum amount allowed to be spent within the current and\n>>> any subsequent epochs;\n>>> => 3. the amount spent (10k sats) does not exceed tx1_remain AND does\n>>> not exceed chg2b_limit;\n>>> => 4. chg2b_remain has been set to zero, meaning that within the current\n>>> epoch (block height 808101 to and including 808250), tx2b cannot be used as\n>>> a spending input to any transaction.\n>>>\n>>> Starting from block height 808251, a new epoch will start and the\n>>> rate-limited output of tx2b may again be used as an input for a subsequent\n>>> rate-limited transaction tx3b. This transaction tx3b must again be\n>>> accompanied by params that do not violate the rate-limit as defined by the\n>>> params of tx2b and which are stored with output out2b. So, the epoch of\n>>> tx3b must be at minimum 150 blocks, the maximum that is allowed to be spent\n>>> per epoch is at most 10k sats, and chg3b_remain must be decreased by at\n>>> least the amount spent by tx3b.\n>>>\n>>> From the above, the rate-limiting mechanics should hopefully be clear\n>>> and full set of validation rules could be defined in a more generalized way\n>>> with little additional effort.\n>>>\n>>> Note that I conveniently avoided talking about how to represent the\n>>> parameters within transactions or outputs, simply because I currently lack\n>>> enough understanding to reason about this. I am hoping that others may\n>>> offer help.\n>>>\n>>> Zac\n>>>\n>>>\n>>> On Tue, Aug 3, 2021 at 8:12 PM Billy Tetrud <billy.tetrud at gmail.com>\n>>> wrote:\n>>>\n>>>> > To enable more straightforward validation logic.\n>>>> > within the current epoch\n>>>>\n>>>> Ah I see, this is all limited to within a single epoch. I think that\n>>>> sufficiently limits the window of time in which nodes have to store\n>>>> information for rate limited outputs. However, I don't see how specifying\n>>>> block ranges simplifies the logic - wouldn't this complicate the logic with\n>>>> additional user-specified constraints? It also prevents the output from\n>>>> being able to be rate limited over the span of multiple epochs, which would\n>>>> seem to make it a lot more difficult to use for certain types of wallets\n>>>> (eg cold wallets).\n>>>>\n>>>> I think I see the logic of your 'remaining' parameter there. If you\n>>>> start with a single rate-limited input, you can split that into many\n>>>> outputs, only one of which have a 'remaining' balance. The rest can simply\n>>>> remain unspendable for the rest of the epoch. That way these things don't\n>>>> need to be tied together. However, that doesn't solve the problem of 3rd\n>>>> parties being able to send money into the wallet.\n>>>>\n>>>> > I don't believe that the marginal added functionality would justify\n>>>> the increased implementation complexity\n>>>>\n>>>> Perhaps, but I think there is a lot of benefit in allowing these kinds\n>>>> of things to operate as similarly as possible to normal transactions, for\n>>>> one because of usability reasons. If each opcode has its own quirks that\n>>>> are not intuitively related to their purpose (eg if a rate-limited wallet\n>>>> had no way to get a receiving address), it would confuse end-users (eg who\n>>>> wonder how to get a receiving address and how they can ask people to send\n>>>> money into their wallet) or require a lot of technical complexity in\n>>>> applications (eg to support something like cooperatively connecting with\n>>>> their wallet so that a transaction can be made that creates a new\n>>>> single-output for the wallet). A little complexity in this opcode can save\n>>>> a lot of external complexity here I think.\n>>>>\n>>>> > my understanding of Bitcoin is way too low to be able to write a BIP\n>>>> and do the implementation\n>>>>\n>>>> You might be able to find people willing to help. I would be willing to\n>>>> help write the BIP spec. I'm not the right person to help with the\n>>>> implementation, but perhaps you could find someone else who is. Even if the\n>>>> BIP isn't adopted, it could be a starting point or inspiration for someone\n>>>> else to write an improved version.\n>>>>\n>>>> On Mon, Aug 2, 2021 at 2:32 AM Zac Greenwood <zachgrw at gmail.com> wrote:\n>>>>\n>>>>> [Note: I've moved your reply to the newly started thread]\n>>>>>\n>>>>> Hi Billy,\n>>>>>\n>>>>> Thank you for your kind and encouraging feedback.\n>>>>>\n>>>>> I don't quite understand why you'd want to define a specific span of\n>>>>>> blocks for the rate limit. Why not just specify the size of the window (in\n>>>>>> blocks) to rate limit within, and the limit?\n>>>>>\n>>>>>\n>>>>> To enable more straightforward validation logic.\n>>>>>\n>>>>> You mentioned change addresses, however, with the parameters you\n>>>>>> defined, there would be no way to connect together the change address with\n>>>>>> the original address, meaning they would have completely separate rate\n>>>>>> limits, which wouldn't work since the change output would ignore the\n>>>>>> previous rate limit.\n>>>>>\n>>>>>\n>>>>> The rate-limiting parameters must be re-specified for each\n>>>>> rate-limited input. So, a transaction that has a rate-limited input is only\n>>>>> valid if its output is itself rate-limited such that it does not violate\n>>>>> the rate-limiting constraints of its input.\n>>>>>\n>>>>> In my thread-starter, I gave the below example of a rate-limited\n>>>>> address a2 that serves as input for transaction t2:\n>>>>>\n>>>>> a2: 99.8 sats at height 800100;\n>>>>> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;\n>>>>>\n>>>>> Transaction t2:\n>>>>> Included at block height 800200\n>>>>> Spend: 400k + fees.\n>>>>> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.\n>>>>>\n>>>>> Note how transaction t2 re-specifies the rate-limiting parameters.\n>>>>> Validation must ensure that the re-specified parameters are within bounds,\n>>>>> i.e., do not allow more spending per epoch than the rate-limiting\n>>>>> parameters of its input address a2. Re-specifying the rate-limiting\n>>>>> parameters offers the flexibility to further restrict spending, or to\n>>>>> disable any additional spending within the current epoch by setting\n>>>>> a_remaining to zero.\n>>>>>\n>>>>> Result:\n>>>>> Value at destination address: 400k sats;\n>>>>> Rate limiting params at destination address: none;\n>>>>> Value at change address a3: 99.4m sats;\n>>>>> Rate limiting params at change address a3: h0=800144, h1=800287,\n>>>>> a=500k, a_remaining=100k.\n>>>>>\n>>>>> As a design principle I believe it makes sense if the system is able\n>>>>> to verify the validity of a transaction without having to consider any\n>>>>> transactions that precede its inputs. As a side-note, doing away with this\n>>>>> design principle would however enable more sophisticated rate-limiting\n>>>>> (such as rate-limiting per sliding window instead of rate-limiting per\n>>>>> epoch having a fixed start and end block), but while at the same time\n>>>>> reducing the size of per rate-limiting transaction (because it would enable\n>>>>> specifying the rate-limiting parameters more space-efficiently). To test\n>>>>> the waters and to keep things relatively simple, I chose not to go into\n>>>>> this enhanced form of rate-limiting.\n>>>>>\n>>>>> I haven't gone into how to process a transaction having multiple\n>>>>> rate-limited inputs. The easiest way to handle this case is to not allow\n>>>>> any transaction having more than one rate-limited input. One could imagine\n>>>>> complex logic to handle transactions having multiple rate-limited inputs by\n>>>>> creating multiple rate-limited change addresses. However at first glance I\n>>>>> don't believe that the marginal added functionality would justify the\n>>>>> increased implementation complexity.\n>>>>>\n>>>>>  I'd be interested in seeing you write a BIP for this.\n>>>>>\n>>>>>\n>>>>> Thank you, but sadly my understanding of Bitcoin is way too low to be\n>>>>> able to write a BIP and do the implementation. However I see tremendous\n>>>>> value in this functionality. Favorable feedback of the list regarding the\n>>>>> usefulness and the technical feasibility of rate-limiting functionality\n>>>>> would of course be an encouragement for me to descend further down the\n>>>>> rabbit hole.\n>>>>>\n>>>>> Zac\n>>>>>\n>>>>>\n>>>>> On Sun, Aug 1, 2021 at 10:09 AM Zac Greenwood <zachgrw at gmail.com>\n>>>>> wrote:\n>>>>>\n>>>>>> [Resubmitting to list with minor edits. My previous submission ended\n>>>>>> up inside an existing thread, apologies.]\n>>>>>>\n>>>>>> Hi list,\n>>>>>>\n>>>>>> I'd like to explore whether it is feasible to implement new scripting\n>>>>>> capabilities in Bitcoin that enable limiting the output amount of a\n>>>>>> transaction based on the total value of its inputs. In other words, to\n>>>>>> implement the ability to limit the maximum amount that can be sent from an\n>>>>>> address.\n>>>>>>\n>>>>>> Two use cases come to mind:\n>>>>>>\n>>>>>> UC1: enable a user to add additional protection their funds by\n>>>>>> rate-limiting the amount that they are allowed to send during a certain\n>>>>>> period (measured in blocks). A typical use case might be a user that\n>>>>>> intends to hodl their bitcoin, but still wishes to occasionally send small\n>>>>>> amounts. Rate-limiting avoids an attacker from sweeping all the users'\n>>>>>> funds in a single transaction, allowing the user to become aware of the\n>>>>>> theft and intervene to prevent further thefts.\n>>>>>>\n>>>>>> UC2: exchanges may wish to rate-limit addresses containing large\n>>>>>> amounts of bitcoin, adding warm- or hot-wallet functionality to a\n>>>>>> cold-storage address. This would enable an exchange to drastically reduce\n>>>>>> the number of times a cold wallet must be accessed with private keys that\n>>>>>> give access to the full amount.\n>>>>>>\n>>>>>> In a typical setup, I'd envision using multisig such that the user\n>>>>>> has two sets of private keys to their encumbered address (with a \"set\" of\n>>>>>> keys meaning \"one or more\" keys). One set of private keys allows only for\n>>>>>> sending with rate-limiting restrictions in place, and a second set of\n>>>>>> private keys allowing for sending any amount without rate-limiting,\n>>>>>> effectively overriding such restriction.\n>>>>>>\n>>>>>> The parameters that define in what way an output is rate-limited\n>>>>>> might be defined as follows:\n>>>>>>\n>>>>>> Param 1: a block height \"h0\" indicating the first block height of an\n>>>>>> epoch;\n>>>>>> Param 2: a block height \"h1\" indicating the last block height of an\n>>>>>> epoch;\n>>>>>> Param 3: an amount \"a\" in satoshi indicating the maximum amount that\n>>>>>> is allowed to be sent in any epoch;\n>>>>>> Param 4: an amount \"a_remaining\" (in satoshi) indicating the maximum\n>>>>>> amount that is allowed to be sent within the current epoch.\n>>>>>>\n>>>>>> For example, consider an input containing 100m sats (1 BTC) which has\n>>>>>> been rate-limited with parameters (h0, h1, a, a_remaining) of (800000,\n>>>>>> 800143, 500k, 500k). These parameters define that the address is\n>>>>>> rate-limited to sending a maximum of 500k sats in the current epoch that\n>>>>>> starts at block height 800000 and ends at height 800143 (or about one day\n>>>>>> ignoring block time variance) and that the full amount of 500k is still\n>>>>>> sendable. These rate-limiting parameters ensure that it takes at minimum\n>>>>>> 100m / 500k = 200 transactions and 200 x 144 blocks or about 200 days to\n>>>>>> spend the full 100m sats. As noted earlier, in a typical setup a user\n>>>>>> should retain the option to transact the entire amount using a second (set\n>>>>>> of) private key(s).\n>>>>>>\n>>>>>> For rate-limiting to work, any change output created by a transaction\n>>>>>> from a rate-limited address must itself be rate-limited as well. For\n>>>>>> instance, expanding on the above example, assume that the user spends 200k\n>>>>>> sats from a rate-limited address a1 containing 100m sats:\n>>>>>>\n>>>>>> Start situation:\n>>>>>> At block height 800000: rate-limited address a1 is created;\n>>>>>> Value of a1: 100.0m sats;\n>>>>>> Rate limiting params of a1: h0=800000, h1=800143, a=500k,\n>>>>>> a_remaining=500k;\n>>>>>>\n>>>>>> Transaction t1:\n>>>>>> Included at block height 800100;\n>>>>>> Spend: 200k + fee;\n>>>>>> Rate limiting params: h0=800000, h1=800143, a=500k, a_remaining=300k.\n>>>>>>\n>>>>>> Result:\n>>>>>> Value at destination address: 200k sats;\n>>>>>> Rate limiting params at destination address: none;\n>>>>>> Value at change address a2: 99.8m sats;\n>>>>>> Rate limiting params at change address a2: h0=800000, h1=800143,\n>>>>>> a=500k, a_remaining=300k.\n>>>>>>\n>>>>>> In order to properly enforce rate limiting, the change address must\n>>>>>> be rate-limited such that the original rate limit of 500k sats per 144\n>>>>>> blocks cannot be exceeded. In this example, the change address a2 were\n>>>>>> given the same rate limiting parameters as the transaction that served as\n>>>>>> its input. As a result, from block 800100 up until and including block\n>>>>>> 800143, a maximum amount of 300k sats is allowed to be spent from the\n>>>>>> change address.\n>>>>>>\n>>>>>> Example continued:\n>>>>>> a2: 99.8 sats at height 800100;\n>>>>>> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;\n>>>>>>\n>>>>>> Transaction t2:\n>>>>>> Included at block height 800200\n>>>>>> Spend: 400k + fees.\n>>>>>> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.\n>>>>>>\n>>>>>> Result:\n>>>>>> Value at destination address: 400k sats;\n>>>>>> Rate limiting params at destination address: none;\n>>>>>> Value at change address a3: 99.4m sats;\n>>>>>> Rate limiting params at change address a3: h0=800144, h1=800287,\n>>>>>> a=500k, a_remaining=100k.\n>>>>>>\n>>>>>> Transaction t2 is allowed because it falls within the next epoch\n>>>>>> (running from 800144 to 800287) so a spend of 400k does not violate the\n>>>>>> constraint of 500k per epoch.\n>>>>>>\n>>>>>> As could be seen, the rate limiting parameters are part of the\n>>>>>> transaction and chosen by the user (or their wallet). This means that the\n>>>>>> parameters must be validated to ensure that they do not violate the\n>>>>>> intended constraints.\n>>>>>>\n>>>>>> For instance, this transaction should not be allowed:\n>>>>>> a2: 99.8 sats at height 800100;\n>>>>>> Rate-limit params of a2: h0=800000, h1=800143, a=500k,\n>>>>>> a_remaining=300k;\n>>>>>>\n>>>>>> Transaction t2a:\n>>>>>> Included at block height 800200;\n>>>>>> Spend: 400k + fees;\n>>>>>> Rate-limit params: h0=800124, h1=800267, a=500k, a_remaining=100k.\n>>>>>>\n>>>>>> This transaction t2a attempts to shift the epoch forward by 20 blocks\n>>>>>> such that it starts at 800124 instead of 800144. Shifting the epoch forward\n>>>>>> like this must not be allowed because it enables spending more that the\n>>>>>> rate limit allows, which is 500k in any epoch of 144 blocks. It would\n>>>>>> enable overspending:\n>>>>>>\n>>>>>> t1: spend 200k at 800100 (epoch 1: total: 200k);\n>>>>>> t2a: spend 400k at 800200 (epoch 2: total: 400k);\n>>>>>> t3a: spend 100k at 800201 (epoch 2: total: 500k);\n>>>>>> t4a: spend 500k at 800268 (epoch 2: total: 1000k, overspending for\n>>>>>> epoch 2).\n>>>>>>\n>>>>>> Specifying the rate-limiting parameters explicitly at every\n>>>>>> transaction allows the user to tighten the spending limit by setting\n>>>>>> tighter limits or for instance by setting a_remainder to 0 if they wish to\n>>>>>> enforce not spending more during an epoch. A second advantage of explicitly\n>>>>>> specifying the four rate-limiting parameters with each transaction is that\n>>>>>> it allows the system to fully validate the transaction without having to\n>>>>>> consider any previous transactions within an epoch.\n>>>>>>\n>>>>>> I will stop here because I would like to gauge interest in this idea\n>>>>>> first before continuing work on other aspects. Two main pieces of work jump\n>>>>>> to mind:\n>>>>>>\n>>>>>> Define all validations;\n>>>>>> Describe aggregate behaviour of multiple (rate-limited) inputs, proof\n>>>>>> that two rate-limited addresses cannot spend more than the sum of their\n>>>>>> individual limits.\n>>>>>>\n>>>>>> Zac\n>>>>>>\n>>>>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210809/689af0be/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-08-10T02:17:47",
                "message_text_only": "fromGood morning Zac,\n\n\nWith some work, what you want can be implemented, to some extent, today, without changes to consensus.\n\nThe point you want, I believe, is to have two sets of keys:\n\n* A long-term-storage keyset, in \"cold\" storage.\n* A short-term-spending keyset, in \"warm\" storage, controlling only a small amount of funds.\n\nWhat you can do would be:\n\n* Put all your funds in a single UTXO, with an k-of-n of your cold keys (ideally P2TR, or some P2WSH k-of-n).\n* Put your cold keys online, and sign a transaction spending the above UTXO, and spending most of it to a new address that is a tweaked k-of-n of your cold keys, and a smaller output (up to the limit you want) controlled by the k-of-n of your warm keys.\n  * Keep this transaction offchain, in your warm storage.\n* Put your cold keys back offline.\n* When you need to spend using your warm keys, bring the above transaction onchain, then spend from the budget as needed.\n\n\nIf you need to have some estimated amount of usable funds for every future unit of time, just create a chain of transactions with future `nLockTime`.\n\n                                  nLocktime +1day  nLockTime +2day\n                  +------------+   +------------+   +------------+\n     cold UTXO -->|    cold TXO|-->|    cold TXO|-->|    cold TXO|--> etc.\n                  |            |   |            |   |            |\n                  |    warm TXO|   |    warm TXO|   |    warm TXO|\n                  +------------+   +------------+   +------------+\n\nPre-sign the above transactions, store the pre-signed transactions in warm storage together with your warm keys.\nThen put the cold keys back offline.\n\nThen from today to tomorrow, you can spend only the first warm TXO.\n>From tomorrow to the day after, you can spend only the first two warm TXOs.\nAnd so on.\n\nIf tomorrow your warm keys are stolen, you can bring the cold keys online to claim the second cold TXO and limit your fund loss to only just the first two warm TXOs.\n\nThe above is bulky, but it has the advantage of not using any special opcodes or features (improving privacy, especially with P2TR which would in theory allow k-of-n/n-of-n to be indistinguishable from 1-of-1), and using just `nLockTime`, which is much easier to hide since most modern wallets will set `nLockTime` to recent block heights.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Zac Greenwood",
                "date": "2021-08-13T11:02:14",
                "message_text_only": "Hi ZmnSCPxj,\n\nThank you for your insightful response.\n\nPerhaps I should take a step back and take a strictly functional angle.\nPerhaps the list could help me to establish whether the proposed\nfunctionality is:\n\nDesirable;\nNot already possible;\nFeasible to implement.\n\nThe proposed functionality is as follows:\n\nThe ability to control some coin with two private keys (or two sets of\nprivate keys) such that spending is limited over time for one private key\n(i.e., it is for instance not possible to spend all coin in a single\ntransaction) while spending is unrestricted for the other private key (no\nlimits apply). No limits must apply to coin transacted to a third party.\n\nAlso, it must be possible never having to bring the unrestricted private\nkey online unless more than the limit imposed on the restrictive private\nkey is desired to be spent.\n\nLess generally, taking the perspective of a hodler: the user must be able\nto keep one key offline and one key online. The offline key allows\nunrestricted spending, the online key is limited in how much it is allowed\nto spend over time.\n\nFurthermore, the spending limit must be intuitive. Best candidate I believe\nwould be a maximum spend per some fixed number of blocks. For instance, the\nrestrictive key may allow a maximum of 100k sats per any window of 144\nblocks. Ofcourse the user must be able to set these parameters freely.\n\nI look forward to any feedback you may have.\n\nZac\n\n\n\nOn Tue, 10 Aug 2021 at 04:17, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n>  fromGood morning Zac,\n>\n>\n> With some work, what you want can be implemented, to some extent, today,\n> without changes to consensus.\n>\n> The point you want, I believe, is to have two sets of keys:\n>\n> * A long-term-storage keyset, in \"cold\" storage.\n> * A short-term-spending keyset, in \"warm\" storage, controlling only a\n> small amount of funds.\n>\n> What you can do would be:\n>\n> * Put all your funds in a single UTXO, with an k-of-n of your cold keys\n> (ideally P2TR, or some P2WSH k-of-n).\n> * Put your cold keys online, and sign a transaction spending the above\n> UTXO, and spending most of it to a new address that is a tweaked k-of-n of\n> your cold keys, and a smaller output (up to the limit you want) controlled\n> by the k-of-n of your warm keys.\n>   * Keep this transaction offchain, in your warm storage.\n> * Put your cold keys back offline.\n> * When you need to spend using your warm keys, bring the above transaction\n> onchain, then spend from the budget as needed.\n>\n>\n> If you need to have some estimated amount of usable funds for every future\n> unit of time, just create a chain of transactions with future `nLockTime`.\n>\n>                                   nLocktime +1day  nLockTime +2day\n>                   +------------+   +------------+   +------------+\n>      cold UTXO -->|    cold TXO|-->|    cold TXO|-->|    cold TXO|--> etc.\n>                   |            |   |            |   |            |\n>                   |    warm TXO|   |    warm TXO|   |    warm TXO|\n>                   +------------+   +------------+   +------------+\n>\n> Pre-sign the above transactions, store the pre-signed transactions in warm\n> storage together with your warm keys.\n> Then put the cold keys back offline.\n>\n> Then from today to tomorrow, you can spend only the first warm TXO.\n> From tomorrow to the day after, you can spend only the first two warm TXOs.\n> And so on.\n>\n> If tomorrow your warm keys are stolen, you can bring the cold keys online\n> to claim the second cold TXO and limit your fund loss to only just the\n> first two warm TXOs.\n>\n> The above is bulky, but it has the advantage of not using any special\n> opcodes or features (improving privacy, especially with P2TR which would in\n> theory allow k-of-n/n-of-n to be indistinguishable from 1-of-1), and using\n> just `nLockTime`, which is much easier to hide since most modern wallets\n> will set `nLockTime` to recent block heights.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210813/35283ad0/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-08-14T01:50:45",
                "message_text_only": "Good morning Zac,\n\n\n> Hi\u00a0ZmnSCPxj,\n>\n> Thank you for your insightful response.\n>\n> Perhaps I should take a step back and take a strictly functional angle. Perhaps the list could help me to establish whether\u00a0the proposed functionality is:\n>\n> Desirable;\n> Not already possible;\n> Feasible to implement.\n>\n> The proposed functionality is as follows:\n>\n> The ability to control some coin with two private keys (or two sets of private keys) such that spending is limited over time for one private key (i.e., it is for instance not possible to spend all coin in a single transaction) while spending is unrestricted for the other private key (no limits apply). No limits must apply to coin transacted to a third party.\n>\n> Also, it must be possible never having to bring the unrestricted private key online unless more than the limit imposed on the restrictive private key is desired to be spent.\n>\n> Less generally, taking the perspective of a hodler: the user must be able to keep one key offline and one key online. The offline key allows unrestricted spending, the online key is limited in how much it is allowed to spend over time.\n>\n> Furthermore, the spending limit must be intuitive. Best candidate I believe would be a maximum spend per some fixed number of blocks. For instance, the restrictive key may allow a maximum of 100k sats per any window of 144 blocks. Ofcourse the user must be able to set these parameters freely.\n\nMy proposal does not *quite* implement a window.\nHowever, that is because it uses `nLockTime`.\n\nWith the use of `nSequence` in relative-locktime mode, however, it *does* implement a window, sort of.\nMore specifically, it implements a timeout on spending --- if you spend using a presigned transaction (which creates an unencumbered specific-valued TXO that can be arbitrarily spent with your online keyset) then you cannot get another \"batch\" of funds until the `nSequence` relative locktime passes.\nHowever, this *does* implement a window that limits a maximum value spendable per any window of the relative timelock you select.\n\nThe disadvantage is that `nSequence` use is a lot more obvious and discernible than `nLockTime` use.\nMany wallets today use non-zero `nLockTime` for anti-fee-sniping, and that is a good cover for `nLockTime` transactions.\nI believe Dave Harding proposed that wallets should also use, at random, (say 50-50) `nSequence`-in-relative-locktime-mode as an alternate anti-fee-sniping mechanism.\nThis alternate anti-fee-sniping would help cover `nSequence` use.\n\nNote that my proposal does impose a maximum limit on the number of windows.\nWith `nSequence`-in-relative-locktime-mode the limit is the number of times that the online keyset can spend.\nAfter spending that many windows, the offline keyset has to be put back online to generate a new set of transactions.\n\nIt has the massive massive advantage that you can implement it today without any consensus change, and I think you can expect that consensus change will take a LONG time (xref SegWit, Taproot).\n\nCertainly the functionality is desirable.\nBut it seems it can be implemented with Bitcoin today.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Zac Greenwood",
                "date": "2021-08-16T11:17:19",
                "message_text_only": "Hi ZmnSCPxj,\n\nThank you for your counterproposal. I fully agree that as a first step we\nmust establish whether the proposed functionality can be implemented\nwithout making any changes to consensus.\n\nYour counterproposal is understandably more technical in nature because it\nexplores an implementation on top of Bitcoin as-is. However I feel that for\na fair comparison of the functionality of both proposals a purely\nfunctional description of your proposal is essential.\n\nIf I understand your proposal correctly, then I believe there are some\nmajor gaps between yours and mine:\n\nKeys for unrestricted spending: in my proposal, they never have to come\nonline unless spending more than the limit is desired. In your proposal,\nthese keys are required to come online in several situations.\n\nPresigning transactions: not required in my proposal. Wouldn\u2019t such\npresigning requirement be detrimental for the usability of your proposal?\nDoes it mean that for instance the amount and window in which the\ntransaction can be spent is determined at the time of signing? In my\nproposal, there is no limit in the number of transactions per window.\n\nNumber of windows: limited in your proposal, unlimited in mine.\n\nThere are probably additional gaps that I am currently not technically able\nto recognize.\n\nI feel that the above gaps are significant enough to state that your\nproposal does not meet the basic requirements of my proposal.\n\nNext to consider is whether the gap is acceptable, weighing the effort to\nimplement the required consensus changes against the effort and feasibility\nof implementing your counterproposal.\n\nI feel that your counterproposal has little chance of being implemented\nbecause of the still considerable effort required and the poor result in\nfunctional terms. I also wonder if your proposal is feasible considering\nwallet operability.\n\nConsidering all the above, I believe that implementing consensus changes in\norder to support the proposed functionality would preferable  over your\ncounterproposal.\n\nI acknowledge that a consensus change takes years and is difficult to\nachieve, but that should not be any reason to stop exploring the appetite\nfor the proposed functionality and perhaps start looking at possible\ntechnical solutions.\n\nZac\n\n\nOn Sat, 14 Aug 2021 at 03:50, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Zac,\n>\n>\n> > Hi ZmnSCPxj,\n> >\n> > Thank you for your insightful response.\n> >\n> > Perhaps I should take a step back and take a strictly functional angle.\n> Perhaps the list could help me to establish whether the proposed\n> functionality is:\n> >\n> > Desirable;\n> > Not already possible;\n> > Feasible to implement.\n> >\n> > The proposed functionality is as follows:\n> >\n> > The ability to control some coin with two private keys (or two sets of\n> private keys) such that spending is limited over time for one private key\n> (i.e., it is for instance not possible to spend all coin in a single\n> transaction) while spending is unrestricted for the other private key (no\n> limits apply). No limits must apply to coin transacted to a third party.\n> >\n> > Also, it must be possible never having to bring the unrestricted private\n> key online unless more than the limit imposed on the restrictive private\n> key is desired to be spent.\n> >\n> > Less generally, taking the perspective of a hodler: the user must be\n> able to keep one key offline and one key online. The offline key allows\n> unrestricted spending, the online key is limited in how much it is allowed\n> to spend over time.\n> >\n> > Furthermore, the spending limit must be intuitive. Best candidate I\n> believe would be a maximum spend per some fixed number of blocks. For\n> instance, the restrictive key may allow a maximum of 100k sats per any\n> window of 144 blocks. Ofcourse the user must be able to set these\n> parameters freely.\n>\n> My proposal does not *quite* implement a window.\n> However, that is because it uses `nLockTime`.\n>\n> With the use of `nSequence` in relative-locktime mode, however, it *does*\n> implement a window, sort of.\n> More specifically, it implements a timeout on spending --- if you spend\n> using a presigned transaction (which creates an unencumbered\n> specific-valued TXO that can be arbitrarily spent with your online keyset)\n> then you cannot get another \"batch\" of funds until the `nSequence` relative\n> locktime passes.\n> However, this *does* implement a window that limits a maximum value\n> spendable per any window of the relative timelock you select.\n>\n> The disadvantage is that `nSequence` use is a lot more obvious and\n> discernible than `nLockTime` use.\n> Many wallets today use non-zero `nLockTime` for anti-fee-sniping, and that\n> is a good cover for `nLockTime` transactions.\n> I believe Dave Harding proposed that wallets should also use, at random,\n> (say 50-50) `nSequence`-in-relative-locktime-mode as an alternate\n> anti-fee-sniping mechanism.\n> This alternate anti-fee-sniping would help cover `nSequence` use.\n>\n> Note that my proposal does impose a maximum limit on the number of windows.\n> With `nSequence`-in-relative-locktime-mode the limit is the number of\n> times that the online keyset can spend.\n> After spending that many windows, the offline keyset has to be put back\n> online to generate a new set of transactions.\n>\n> It has the massive massive advantage that you can implement it today\n> without any consensus change, and I think you can expect that consensus\n> change will take a LONG time (xref SegWit, Taproot).\n>\n> Certainly the functionality is desirable.\n> But it seems it can be implemented with Bitcoin today.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210816/298ee64f/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-08-16T11:48:43",
                "message_text_only": "Good morning Zac,\n\n> Thank you for your counterproposal. I fully agree that as a first step we must establish whether the proposed functionality can be implemented without making any changes to consensus.\n>\n> Your counterproposal is understandably more technical in nature because it explores an implementation on top of Bitcoin as-is. However I feel that for a fair comparison of the functionality of both proposals a purely functional description of your proposal is essential.\n>\n> If I understand your proposal correctly, then I believe there are some major gaps between yours and mine:\n>\n> Keys for unrestricted spending: in my proposal, they never have to come online unless spending more than the limit is desired. In your proposal, these keys are required to come online in several situations.\n\nCorrect, that is indeed a weakness.\n\nIt is helpful to see https://zmnscpxj.github.io/bitcoin/unchained.html\nBasically: any quorum of signers can impose any rules that are not implementable on the base layer, including the rules you desire.\nThat quorum is the \"offline keyset\" in my proposal.\n\n>\n> Presigning transactions: not required in my proposal. Wouldn\u2019t such presigning requirement be detrimental for the usability of your proposal? Does it mean that for instance the amount and window in which the transaction can be spent is determined at the time of signing? In my proposal, there is no limit in the number of transactions per window.\n\nNo.\nRemember, the output is a simple 1-of-1 or k-of-n of the online keyset.\nThe online keyset can spend that wherever and however, including paying it out to N parties, or paying part of the limit to 1 party and then paying the remainder back to the same onchain keyset so it can access the funds in the future.\nBoth cases are also available in your proposal, and the latter case (pay out part of the limit to a single output, then keep the rest back to the same onchain keyset) can be used to add an indefinite number of transactions per window.\n\n>\n> Number of windows: limited in your proposal, unlimited in mine.\n\nCorrect, though you can always have a fairly large number of windows (\"640kB ought to be enough for anybody\").\n\n>\n> There are probably additional gaps that I am currently not technically able to recognize.\n\nIt requires a fair amount of storage for the signatures at minimum, though that may be as small as 64 bytes per window.\n1Mb of storage for signatures would allow 16,384 windows, assuming you use 1-day windows that is about 44.88 years, probably more than enough that a one-time onlining of the offline keys (or just print out the signatures on paper or display as a QR code, whatever) is acceptable.\n\n> I feel that the above gaps are significant enough to state that your proposal does not meet the basic requirements of my proposal.\n>\n> Next to consider is whether the gap is acceptable, weighing the effort to implement the required consensus changes against the effort and feasibility of implementing your counterproposal.\n>\n> I feel that your counterproposal has little chance of being implemented because of the still considerable effort required and the poor result in functional terms. I also wonder if your proposal is feasible considering wallet operability.\n\nSee above, particularly the gap that does not, in fact, exist.\n\n>\n> Considering all the above, I believe that implementing consensus changes in order to support the proposed functionality would preferable \u00a0over your counterproposal.\n>\n> I acknowledge that a consensus change takes years and is difficult to achieve, but that should not be any reason to stop exploring the appetite for the proposed functionality and perhaps start looking at possible technical solutions.\n\nYou can also look into the \"covenant\" opcodes (`OP_CHECKSIGFROMSTACK`, `OP_CHECKTEMPLATEVERIFY`, etc.), I think JeremyRubin has a bunch of them listed somewhere, which may be used to implement something similar without requiring presigning.\n\nSince the basic \"just use `nSequence`\" scheme already implements what you need, what the covenant opcodes buy you is that you do not need the offline keyset to be onlined and there is no need to keep signatures, removing the remaining gaps you identified.\nWith a proper looping covenant opcode, there is also no limit on the number of windows.\n\nThe issue with the covenant opcodes is that there are several proposals with overlapping abilities and different tradeoffs.\nThis is the sort of thing that invites bikeshed-painting.\n\nI suggest looking into the covenant opcodes and supporting those instead of your own proposal, as your application is very close to one of the motivating examples for covenants in the first place.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Zac Greenwood",
                "date": "2021-08-30T14:43:30",
                "message_text_only": "Hi ZmnSCPxj,\n\n> I suggest looking into the covenant opcodes and supporting those instead\nof your own proposal, as your application is very close to one of the\nmotivating examples for covenants in the first place.\n\nI believe it is not the right approach to take a proposal, chop off key\naspects of its functionality, and rely to some future change in Bitcoin\nthat may perhaps enable implementing some watered down version of the\nintended functionality. In my opinion the right order would be to first\ndiscuss the unmodified proposal on a functional level and gauge community\ninterest, then move forward to discuss technical challenges for the\n*unmodified* proposal instead of first knee-capping the proposal in order\nto (presumably) reduce cost of implementation.\n\nI believe that we both recognize that the proposed functionality would be\nbeneficial. I believe that your position is that functionality close to\nwhat I have in mind can be implemented using covenants, albeit with some\ngaps. For me personally however these gaps would not be acceptable because\nthey severely hurt the predictability and intuitiveness of the behavior of\nthe functionality for the end-user. But as noted, I believe at this point\nit is premature to have this discussion.\n\nPerhaps you could help me understand what would be required to implement\nthe *unmodified* proposal. That way, the community will be able to better\nassess the cost (in terms of effort and risk) and weigh it against the\nperceived benefits. Perhaps *then* we find that the cost could be\nsignificantly reduced without any significant reduction of the benefits,\nfor instance by slightly compromising on the functionality such that no\nchanges to consensus would be required for its implementation. (I am\nskeptical that this would be possible though). The cost reduction must be\ncarefully weighed against the functional gaps it creates.\n\nI am aware that my proposal must be well-defined functionally before being\nable to reason about its benefits and implementational aspects. I believe\nthat the proposed functionality is pretty straightforward, but I am happy\nto come up with a more precise functional spec. However, such effort would\nbe wasted if there is no community interest for this functionality. So far\nonly few people have engaged with this thread, and I am not sure that this\nis because there is no interest in the proposal or because most people just\nlurk here and do not feel like giving their opinion on random proposals. It\nwould be great however to learn about more people's opinions.\n\nAs a reminder, the proposed functionality is to enable a user to limit the\namount that they able to spent from an address within a certain time-frame\nor window (defined in number of blocks) while retaining the ability to\nspend arbitrary amounts using a secondary private key (or set of private\nkeys). The general use case is to prevent theft of large amounts while\nstill allowing a user to spend small amounts over time. Hodlers as well as\nexchanges dealing with cold, warm and hot wallets come to mind as users who\ncould materially benefit from this functionality.\n\nZac\n\n\n\nOn Mon, Aug 16, 2021 at 1:48 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Zac,\n>\n> > Thank you for your counterproposal. I fully agree that as a first step\n> we must establish whether the proposed functionality can be implemented\n> without making any changes to consensus.\n> >\n> > Your counterproposal is understandably more technical in nature because\n> it explores an implementation on top of Bitcoin as-is. However I feel that\n> for a fair comparison of the functionality of both proposals a purely\n> functional description of your proposal is essential.\n> >\n> > If I understand your proposal correctly, then I believe there are some\n> major gaps between yours and mine:\n> >\n> > Keys for unrestricted spending: in my proposal, they never have to come\n> online unless spending more than the limit is desired. In your proposal,\n> these keys are required to come online in several situations.\n>\n> Correct, that is indeed a weakness.\n>\n> It is helpful to see https://zmnscpxj.github.io/bitcoin/unchained.html\n> Basically: any quorum of signers can impose any rules that are not\n> implementable on the base layer, including the rules you desire.\n> That quorum is the \"offline keyset\" in my proposal.\n>\n> >\n> > Presigning transactions: not required in my proposal. Wouldn\u2019t such\n> presigning requirement be detrimental for the usability of your proposal?\n> Does it mean that for instance the amount and window in which the\n> transaction can be spent is determined at the time of signing? In my\n> proposal, there is no limit in the number of transactions per window.\n>\n> No.\n> Remember, the output is a simple 1-of-1 or k-of-n of the online keyset.\n> The online keyset can spend that wherever and however, including paying it\n> out to N parties, or paying part of the limit to 1 party and then paying\n> the remainder back to the same onchain keyset so it can access the funds in\n> the future.\n> Both cases are also available in your proposal, and the latter case (pay\n> out part of the limit to a single output, then keep the rest back to the\n> same onchain keyset) can be used to add an indefinite number of\n> transactions per window.\n>\n> >\n> > Number of windows: limited in your proposal, unlimited in mine.\n>\n> Correct, though you can always have a fairly large number of windows\n> (\"640kB ought to be enough for anybody\").\n>\n> >\n> > There are probably additional gaps that I am currently not technically\n> able to recognize.\n>\n> It requires a fair amount of storage for the signatures at minimum, though\n> that may be as small as 64 bytes per window.\n> 1Mb of storage for signatures would allow 16,384 windows, assuming you use\n> 1-day windows that is about 44.88 years, probably more than enough that a\n> one-time onlining of the offline keys (or just print out the signatures on\n> paper or display as a QR code, whatever) is acceptable.\n>\n> > I feel that the above gaps are significant enough to state that your\n> proposal does not meet the basic requirements of my proposal.\n> >\n> > Next to consider is whether the gap is acceptable, weighing the effort\n> to implement the required consensus changes against the effort and\n> feasibility of implementing your counterproposal.\n> >\n> > I feel that your counterproposal has little chance of being implemented\n> because of the still considerable effort required and the poor result in\n> functional terms. I also wonder if your proposal is feasible considering\n> wallet operability.\n>\n> See above, particularly the gap that does not, in fact, exist.\n>\n> >\n> > Considering all the above, I believe that implementing consensus changes\n> in order to support the proposed functionality would preferable  over your\n> counterproposal.\n> >\n> > I acknowledge that a consensus change takes years and is difficult to\n> achieve, but that should not be any reason to stop exploring the appetite\n> for the proposed functionality and perhaps start looking at possible\n> technical solutions.\n>\n> You can also look into the \"covenant\" opcodes (`OP_CHECKSIGFROMSTACK`,\n> `OP_CHECKTEMPLATEVERIFY`, etc.), I think JeremyRubin has a bunch of them\n> listed somewhere, which may be used to implement something similar without\n> requiring presigning.\n>\n> Since the basic \"just use `nSequence`\" scheme already implements what you\n> need, what the covenant opcodes buy you is that you do not need the offline\n> keyset to be onlined and there is no need to keep signatures, removing the\n> remaining gaps you identified.\n> With a proper looping covenant opcode, there is also no limit on the\n> number of windows.\n>\n> The issue with the covenant opcodes is that there are several proposals\n> with overlapping abilities and different tradeoffs.\n> This is the sort of thing that invites bikeshed-painting.\n>\n> I suggest looking into the covenant opcodes and supporting those instead\n> of your own proposal, as your application is very close to one of the\n> motivating examples for covenants in the first place.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210830/0da8e013/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-08-31T09:00:15",
                "message_text_only": "Good morning Zac,\n\n\n> Perhaps you could help me understand what would be required to implement the *unmodified* proposal. That way, the community will be able to better assess the cost (in terms of effort and risk) and weigh it against the perceived benefits. Perhaps *then* we find that the cost could be significantly reduced without any significant reduction of the benefits, for instance by slightly compromising on the functionality such that no changes to consensus would be required for its implementation. (I am skeptical that this would be possible though). The cost reduction must be carefully weighed against the functional gaps it creates.\n\nFor one, such output need to be explicitly visible, to implement the \"change outputs must also be rate-limited\".\nA tx spending a rate-limited output has to know that one of the outputs is also a rate-limited output.\n\nThis flagging needs to be done by either allocating a new SegWit version --- a resource that is not lightly allocated, there being only 30 versions left if my understanding is correct --- or blessing yet another anyone-can-spend `scriptPubKey` template, something we want to avoid which is why SegWit has versions (i.e. we want SegWit to be the last anyone-can-spend `scriptPubKey` template we bless for a **long** time).\n\nExplicit flagging is bad as well for privacy, which is another mark against it.\nNotice how Taproot improves privacy by making n-of-n indistinguishable from 1-of-1 (and with proper design or a setup ritual, k-of-n can be made indistinguishable from 1-of-1).\nNotice as well that my first counterproposal is significantly more private than explicit flagging, and my second coutnerproposal is also more private if wallets change their anti-fee-sniping mitigation.\nThis privacy loss represented by explicit flagging will be resisted by some people, especially those that use a bunch of random letters as a pseudonym (because duh, privacy).\n\n(Yes, people can just decide not to use the privacy-leaking explicitly-flagged outputs, but that reduces the anonymity set of people who *are* interested in privacy, so people who are interested in privacy will prefer that other people do not leak their privacy so they can hide among *those* people as well.)\n\nYou also probably need to keep some data with each output.\nThis can be done by explicitly storing that data in the output directly, rather than a commitment to that data --- again, the \"change outputs must also be rate-limited\" requirement needs to check those data.\n\nThe larger data stored with the output is undesirable, ideally we want each output to just be a commitment rather than contain any actual data, because often a 20-byte commitment is smaller than the data that needs to be stored.\nFor example, I imagine that your original proposal requires, for change outputs, to store:\n\n* The actual rate limit.\n* The time frame of the rate limit.\n* The reduced rate limit, since we spent an amount within a specific time frame (i.e. residual limit) which is why this is a change output.\n* How long that time frame lasts.\n* A commitment to the keys that can spend this.\n\nBasically, until the residual limit expires, we impose the residual limit, then after the expiry of the residual limit we go back to the original rate limit.\n\nThe commitment to the keys itself takes at least 20 bytes, and if you are planning a to support k-of-n then that takes at least 32 bytes.\nIf this was not explicitly tagged, then a 32 byte commitment to all the necessary data would have been enough, but you do need the explicit tagging for the \"change outputs must be rate-limited too\".\n\nNote as well that the residual needs to be kept with the output.\nBitcoin Core does not store transactions in a lookup table, it stores individual *outputs*.\nWhile the residual can be derived from the transaction, we do not have a transaction table.\nThus, we need to explicitly put it on the output itself, directly, since we only have a lookup table for the unspent outputs, not individual transactions.\n\n(well there is `txindex` but that is an option for each node, not something consensus code can rely on)\n\nSo yes, that \"change outputs must also be rate-limited\" is the big sticking point, and a lot of the \"gaps\" you worry about occur when we drop this bit.\nDrop this bit and you can implement it today without any consensus code change, and with privacy good enough to prevent people with random letters as pseudonym from trying to stop you.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Zac Greenwood",
                "date": "2021-08-31T14:09:04",
                "message_text_only": "Hi ZmnSCPxj,\n\nThank you for your helpful response. We're on the same page concerning\nprivacy so I'll focus on that. I understand from your mail that privacy\nwould be reduced by this proposal because:\n\n* It requires the introduction of a new type of transaction that is\ndifferent from a \"standard\" transaction (would that be P2TR in the\nfuture?), reducing the anonymity set for everyone;\n* The payment and change output will be identifiable because the change\noutput must be marked encumbered on-chain;\n* The specifics of how the output is encumbered must be visible on-chain as\nwell reducing privacy even further.\n\nI don't have the technical skills to judge whether these issues can somehow\nbe resolved. In functional terms, the output should be spendable in a way\nthat does not reveal that the output is encumbered, and produce a change\noutput that cannot be distinguished from a non-change output while still\nbeing encumbered. Perhaps some clever MAST-fu could somehow help?\n\nI imagine that the offered functionality does not justify the above\nmentioned privacy reductions, so unless these can be addressed, without\nfunctional modification this proposal sadly seems dead in the water.\n\nThanks again.\n\nZac\n\n\nOn Tue, Aug 31, 2021 at 11:00 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Zac,\n>\n>\n> > Perhaps you could help me understand what would be required to implement\n> the *unmodified* proposal. That way, the community will be able to better\n> assess the cost (in terms of effort and risk) and weigh it against the\n> perceived benefits. Perhaps *then* we find that the cost could be\n> significantly reduced without any significant reduction of the benefits,\n> for instance by slightly compromising on the functionality such that no\n> changes to consensus would be required for its implementation. (I am\n> skeptical that this would be possible though). The cost reduction must be\n> carefully weighed against the functional gaps it creates.\n>\n> For one, such output need to be explicitly visible, to implement the\n> \"change outputs must also be rate-limited\".\n> A tx spending a rate-limited output has to know that one of the outputs is\n> also a rate-limited output.\n>\n> This flagging needs to be done by either allocating a new SegWit version\n> --- a resource that is not lightly allocated, there being only 30 versions\n> left if my understanding is correct --- or blessing yet another\n> anyone-can-spend `scriptPubKey` template, something we want to avoid which\n> is why SegWit has versions (i.e. we want SegWit to be the last\n> anyone-can-spend `scriptPubKey` template we bless for a **long** time).\n>\n> Explicit flagging is bad as well for privacy, which is another mark\n> against it.\n> Notice how Taproot improves privacy by making n-of-n indistinguishable\n> from 1-of-1 (and with proper design or a setup ritual, k-of-n can be made\n> indistinguishable from 1-of-1).\n> Notice as well that my first counterproposal is significantly more private\n> than explicit flagging, and my second coutnerproposal is also more private\n> if wallets change their anti-fee-sniping mitigation.\n> This privacy loss represented by explicit flagging will be resisted by\n> some people, especially those that use a bunch of random letters as a\n> pseudonym (because duh, privacy).\n>\n> (Yes, people can just decide not to use the privacy-leaking\n> explicitly-flagged outputs, but that reduces the anonymity set of people\n> who *are* interested in privacy, so people who are interested in privacy\n> will prefer that other people do not leak their privacy so they can hide\n> among *those* people as well.)\n>\n> You also probably need to keep some data with each output.\n> This can be done by explicitly storing that data in the output directly,\n> rather than a commitment to that data --- again, the \"change outputs must\n> also be rate-limited\" requirement needs to check those data.\n>\n> The larger data stored with the output is undesirable, ideally we want\n> each output to just be a commitment rather than contain any actual data,\n> because often a 20-byte commitment is smaller than the data that needs to\n> be stored.\n> For example, I imagine that your original proposal requires, for change\n> outputs, to store:\n>\n> * The actual rate limit.\n> * The time frame of the rate limit.\n> * The reduced rate limit, since we spent an amount within a specific time\n> frame (i.e. residual limit) which is why this is a change output.\n> * How long that time frame lasts.\n> * A commitment to the keys that can spend this.\n>\n> Basically, until the residual limit expires, we impose the residual limit,\n> then after the expiry of the residual limit we go back to the original rate\n> limit.\n>\n> The commitment to the keys itself takes at least 20 bytes, and if you are\n> planning a to support k-of-n then that takes at least 32 bytes.\n> If this was not explicitly tagged, then a 32 byte commitment to all the\n> necessary data would have been enough, but you do need the explicit tagging\n> for the \"change outputs must be rate-limited too\".\n>\n> Note as well that the residual needs to be kept with the output.\n> Bitcoin Core does not store transactions in a lookup table, it stores\n> individual *outputs*.\n> While the residual can be derived from the transaction, we do not have a\n> transaction table.\n> Thus, we need to explicitly put it on the output itself, directly, since\n> we only have a lookup table for the unspent outputs, not individual\n> transactions.\n>\n> (well there is `txindex` but that is an option for each node, not\n> something consensus code can rely on)\n>\n> So yes, that \"change outputs must also be rate-limited\" is the big\n> sticking point, and a lot of the \"gaps\" you worry about occur when we drop\n> this bit.\n> Drop this bit and you can implement it today without any consensus code\n> change, and with privacy good enough to prevent people with random letters\n> as pseudonym from trying to stop you.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210831/d45764e3/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-08-31T14:22:29",
                "message_text_only": "Good morning Zac,\n\n> Hi ZmnSCPxj,\n>\n> Thank you for your helpful response. We're on the same page concerning privacy so I'll focus on that. I understand from your mail that privacy would be reduced by this proposal because:\n>\n> * It requires the introduction of a new type of transaction that is different from a \"standard\" transaction (would that be P2TR in the future?), reducing the anonymity set for everyone;\n> * The payment and change output will be identifiable because the change output must be marked encumbered on-chain;\n> * The specifics of how the output is encumbered must be visible on-chain as well reducing privacy even further.\n>\n> I don't have the technical skills to judge whether these issues can somehow be resolved. In functional terms, the output should be spendable in a way that does not reveal that the output is encumbered, and produce a change output that cannot be distinguished from a non-change output while still being encumbered. Perhaps some clever MAST-fu could somehow help?\n\nI believe some of the covenant efforts may indeed have such clever MAST-fu integrated into them, which is why I pointed you to them --- the people developing these (aj I think? RubenSomsen?) might be able to accommodate this or some subset of the desired feature in a sufficiently clever covenant scheme.\n\nThere are a number of such proposals, though, so I cannot really point you to one that seems likely to have a lot of traction.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Exploring: limiting transaction output amount as a function of total input value",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Zac Greenwood",
                "ZmnSCPxj",
                "Billy Tetrud"
            ],
            "messages_count": 17,
            "total_messages_chars_count": 178261
        }
    },
    {
        "title": "[bitcoin-dev] Online discussion on Taproot roll out - Tuesday July 20th 17:15 UTC",
        "thread_messages": [
            {
                "author": "Michael Folkson",
                "date": "2021-08-03T09:59:25",
                "message_text_only": "Please find below the video and transcript from the online discussion\non Taproot roll out that was held on July 20th.\n\nVideo: https://www.youtube.com/watch?v=GAkLuZNsZzw\nTranscript: https://btctranscripts.com/london-bitcoin-devs/2021-07-20-socratic-seminar-taproot-rollout/\nReading list: https://gist.github.com/michaelfolkson/0803271754f851530fe8242087859254\n\nOn Sat, Jul 17, 2021 at 2:16 PM Michael Folkson\n<michaelfolkson at gmail.com> wrote:\n>\n> Hi\n>\n> There is an online Zoom call (also livestreamed on YouTube) on Tuesday\n> July 20th at 17:15 UTC discussing Taproot roll out post activation in\n> November. It will be focused at developers and so discussion will be\n> technical but all are welcome to attend/watch.\n>\n> Murch has this wiki page monitoring planned ecosystem support of P2TR\n> addresses and it would be great to hear from projects and businesses\n> that have Taproot support on their medium/long term development\n> roadmap or are considering it:\n> https://en.bitcoin.it/wiki/Bech32_adoption\n>\n> Meetup link (Zoom link will be announced here):\n> https://www.meetup.com/BitDevsLDN/events/279041693/\n>\n> Draft pre-reading link (will be finalized before Tuesday):\n> https://gist.github.com/michaelfolkson/0803271754f851530fe8242087859254\n>\n> Thanks\n> Michael\n>\n> --\n> Michael Folkson\n> Email: michaelfolkson at gmail.com\n> Keybase: michaelfolkson\n> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3\n\n\n\n-- \nMichael Folkson\nEmail: michaelfolkson at gmail.com\nKeybase: michaelfolkson\nPGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3"
            }
        ],
        "thread_summary": {
            "title": "Online discussion on Taproot roll out - Tuesday July 20th 17:15 UTC",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Michael Folkson"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1554
        }
    },
    {
        "title": "[bitcoin-dev] Bip-0039/Wordlist - Romanian",
        "thread_messages": [
            {
                "author": "Justin Valceanu",
                "date": "2021-08-04T10:30:37",
                "message_text_only": "Hello,\n\nI have created a new Romanian wordlist for Bip-0039;\nRequesting permission to push to github the attached modified files.\n\nThanks\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: bip-0039-wordlists.md\nType: text/markdown\nSize: 6792 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210804/0445cdb6/attachment-0001.bin>\n-------------- next part --------------\nabajur\nabanos\nabatere\nabator\nabces\nabdomen\nabecedar\nabisal\nabordat\nabortare\nabrogat\nabsent\nabsint\nabsolvent\nabundent\naburi\nacadea\nacademic\nacalmie\nacatist\nacetat\naclama\nacomodat\nacord\nacordat\nacordeon\nacostament\nacrobat\nactivat\nactor\nactualitate\nacvaplanare\nacvatic\nadaos\nadaptabil\nadesiv\nadeziune\nadiacent\nadiere\nadjectiv\nadministrare\nadmis\nadorat\nadresa\nadverb\nadversar\naerat\naerogen\nafacere\nafluent\nagale\nagent\nagrement\nahtiere\nairbag\naiurea\najutat\nalambic\nalarmat\nalb\nalbastru\nalbatros\nalegoric\nalert\nalfabet\naliaj\nalifie\nalint\nalpin\naltruism\namabil\namalgam\namanet\namant\namestec\nametist\namfocit\namiabil\namnezie\namoniac\namonte\namorf\namper\namplu\namprenta\namurg\nananas\nancestru\nanexa\nanonimat\nansamblu\nantet\nantidot\nantonim\nantricot\nanual\naparat\naperitiv\napometru\naprig\naprilie\naproape\naprozar\naracet\naragaz\narcas\narctic\nardei\nargat\nargint\nargou\nargument\narhaism\narhiduce\narhitect\naritmic\narmament\narmat\narmonie\nartezian\nartifact\nasalt\nasertiv\nasfalt\nastro\nateneu\natlas\natomic\natractiv\naudit\naugust\naur\nautentic\nautocar\nautor\navanport\navans\navatar\navere\naxial\naxiom\nazimut\nbabic\nbabuin\nbaclava\nbacterie\nbagaj\nbalans\nbalast\nbalastru\nbalaur\nbalcanic\nbalcon\nbalet\nbalistic\nbaliza\nbalnear\nbalon\nbalsam\nbambus\nbanal\nbanca\nbancher\nbanda\nbandit\nbaraj\nbarbaric\nbarion\nbarman\nbaron\nbaros\nbasculant\nbasist\nbasm\nbastion\nbaston\nbatalion\nbaterie\nbaton\nbazalt\nbazar\nbazin\nbec\nbelciug\nbenefic\nbenzen\nberbec\nbeta\nbeton\nbezea\nbiban\nbibelou\nbiceps\nbideu\nbidon\nbijutier\nbilet\nbinar\nbinoclu\nbiolog\nbioritm\nbiped\nbirjar\nbirou\nbiscuit\nbisturiu\nbitum\nbiuvac\nbizar\nbizon\nblindat\nbloc\nblond\nblugi\nbluza\nboboc\nbocanc\nboier\nbolovan\nbondar\nbostan\nbrad\nbreaz\nbreloc\nbretea\nbriceag\nbronz\nbruiat\nbruma\nbrutar\nbufet\nbuimac\nbujor\nbulbar\nbuldozer\nbuletin\nbulevard\nburbon\nburic\nbutan\nbutic\nbutoi\nbutuc\nbuzunar\ncabanier\ncabanos\ncabaret\ncabinet\ncablu\ncacao\ncactus\ncadastru\ncadet\ncadou\ncadru\ncafea\ncaiac\ncaiet\ncal\ncalcul\ncalendar\ncaligraf\ncalup\ncamarad\ncamion\ncamping\ncampus\ncanal\ncangur\ncanibal\ncanion\ncanton\ncapabil\ncapac\ncaporal\ncaptiv\ncarapace\ncarbon\ncargo\ncarie\ncarne\ncarpatic\ncartier\ncasant\ncastel\ncastron\ncater\ncatod\ncatolic\ncauciuc\ncazan\nceainic\nceas\nceaun\ncelest\ncelofan\ncentaur\ncenzor\ncer\nceramic\ncerdac\ncerebel\ncezar\ncheag\ncheie\nchimic\nchiot\ncidru\ncifru\nciment\ncinci\ncinema\ncineva\ncinic\nciocan\ncivil\ncizmar\nclandestin\nclarinet\nclaxon\nclema\ncleric\nclima\nclocot\nclona\nclopot\ncobalt\ncodex\ncodru\ncoeficient\ncoeziune\ncofetar\ncoiot\ncolac\ncolaps\ncoleg\ncolerat\ncolor\ncomoara\ncomod\ncompact\ncompas\nconclav\ncontra\ncopac\ncopios\ncorabie\ncorect\ncoroziv\ncorset\ncortex\ncosmic\ncovor\ncovrig\ncreion\ncroitor\ncronic\ncruce\ncrupier\nctitor\ncuantic\ncuget\ncui\nculme\nculpabil\ncumin\ncuptor\ncuraj\ncurcan\ncurea\ncurte\ncutanat\ncutie\ncutremur\ncvorum\ncyborg\ndacic\ndafin\ndansator\ndatare\ndatorie\ndebara\ndeblocat\ndebut\ndecalat\ndecan\ndecizie\ndeconectat\ndecor\ndecret\ndecriptat\ndefensiv\ndegaja\ndegerat\ndeget\ndejun\ndelir\ndelta\ndemagog\ndemarcat\ndemis\ndemizeu\ndemocratic\ndemon\ndepanat\ndepou\ndepus\nderanj\nderapat\ndesert\ndetectiv\ndeterminat\ndetonator\ndeviz\ndexteritate\ndiabolic\ndiacritic\ndialect\ndiamant\ndiavol\ndiedru\ndifan\ndiftong\ndiligent\ndinar\ndinozaur\ndinte\ndipol\ndirectorat\ndiscografie\ndispozitiv\ndistribuit\ndivers\ndoctor\ndocument\ndolofan\ndomeniu\ndomestic\ndomiciliu\ndormitor\ndosar\ndovleac\ndozaj\ndrapel\ndraperie\ndrojdie\ndruid\ndrumar\ndualism\ndubios\nduhovnic\ndulceag\ndulgher\ndurere\necher\nechilater\nechilibru\nechipa\nechitabil\nechitate\neclectic\necler\necler\necograf\necologie\neconomat\neconomic\necran\necuator\necuson\necvestru\nedificiu\nedil\neditor\nefect\nefemer\neficace\neficient\nefort\nefractor\negal\nelaborat\nelectric\nelectrolit\nelefant\nelementar\neleron\nelev\nelice\nelicopter\neligibil\neliminat\neliptic\nelixir\nelocvent\nelogiat\nelucidat\neluziv\nemanat\nembargo\nemblematic\neminent\nemirat\nemotiv\nempatic\nemulsie\nendomorf\nendoscop\nenergie\nenigmatic\nentitate\nentuziast\neolian\nepicentru\nepidemic\nepilog\nepisod\nepitaf\nepolet\nepsilon\nepuizat\nequestru\neradicat\nereditar\nergonomic\nermetic\neroare\nerou\neroziune\nerudit\nescalop\nest\netaj\netalat\netalon\neteric\netern\netnie\netnograf\neucariot\neuforie\neugenie\neuropa\nevacua\nevalua\nevantai\neveniment\nevident\nevitat\nevocat\nevolua\nexagera\nexaltat\nexamen\nexcavator\nexcedent\nexces\nexcursie\nexecuta\nexod\nexomorf\nexpansiv\nexpat\nexperient\nexpert\nexplicat\nexplorat\nexplozie\nexport\nextaz\nextins\nextract\nezoteric\nfabrica\nfabulos\nfachir\nfacil\nfactor\nfactorial\nfacultate\nfagure\nfaima\nfalie\nfaliment\nfals\nfamilie\nfandare\nfanion\nfanta\nfapt\nfaraon\nfarfurie\nfaringe\nfarmacie\nfarmec\nfascicul\nfason\nfatal\nfault\nfauna\nfebruarie\nfecior\nfederal\nfelie\nfelin\nfelinar\nfeminin\nfenicul\nfenomen\nferbinte\nferibot\nfericire\nferie\nferm\nfermentare\nferoce\nferos\nfertil\nfestivitate\nfeudalism\nfezabilitate\nfiabil\nfiare\nfiasco\nficat\nfictiv\nficus\nfier\nfierar\nfierbe\nfierbinte\nfiert\nfigurant\nfilaj\nfilet\nfilm\nfilon\nfinisaj\nfinit\nfior\nfiord\nfioros\nfirav\nfiscalizat\nfisiune\nfistic\nfisura\nfixat\nflacon\nflagrant\nflambat\nflamingo\nflaps\nflaut\nflirt\nfloral\nflorian\nfluent\nfluier\nfluture\nfluviu\nflux\nfocal\nfolos\nfonic\nforaj\nformular\nfortificat\nfosfor\nfotbal\nfotograf\nfotoliu\nfoton\nfractal\nfrag\nfragment\nfranjur\nfrasin\nfrate\nfrecvent\nfrenetic\nfrigider\nfrizer\nfront\nfruct\nfucsia\nfular\nfulger\nfum\nfunciar\nfundal\nfunebru\nfunerar\nfungibil\nfunie\nfuraj\nfurie\nfurios\nfurnal\nfurnizor\nfursec\nfurtun\nfuturism\nfuziune\ngabarit\ngabion\ngalactic\ngalantar\ngalaxie\ngalop\ngama\ngarantat\ngard\ngardian\ngarou\ngastronom\ngazifer\ngazoduct\ngazos\ngeam\ngelos\ngem\ngemut\ngenerat\ngeneric\ngenist\ngeniu\ngenotip\ngentil\ngenunchi\ngeodezic\ngeoid\ngeomagnetic\ngeometric\ngermen\nghemotoc\nghepard\nghidat\nghilimele\nghimpe\nghiocel\nghiont\nghiozdan\nghips\nghiuden\ngigafon\ngigantic\ngimnaziast\ngin\nginere\ngirofar\ngiroplan\ngiroscop\ngiulgiu\ngiuvaier\ngladiator\nglazura\ngletuit\nglisant\nglobal\nglorie\ngluten\ngofra\ngolem\ngoliat\ngonac\ngonflabil\ngong\ngonit\ngrabnic\ngrade\ngrafit\ngramaj\ngramatic\ngramofon\ngrangur\ngranit\ngratis\ngraur\ngraviton\ngravor\ngrefa\ngreier\ngrenada\ngresie\ngreutate\ngrifon\ngrind\ngrindina\ngrosolan\ngrozav\ngrupat\nguler\ngulie\nguma\nguru\nguvern\nguvid\nhabar\nhabitat\nhaiduc\nhaihui\nhalterofil\nhalucinant\nhamac\nhamal\nhambar\nhamei\nhamsie\nhamster\nhandbal\nhangiu\nhanorac\nhaos\nhaotic\nharbuz\nharnic\nharpa\nharpon\nharta\nhazliu\nhectolitru\nheliograf\nheliomat\nheliport\nheliu\nhelium\nhelix\nhexagon\nhidrant\nhidratat\nhipiot\nhipnotizat\nholografic\nhomar\nhoroscop\nhorticultor\nhotel\nhrean\niaht\niatagan\niaurt\nibric\niconic\nidealism\nidentic\nideolog\niedera\nieftin\nienuper\nignat\nignorat\nigrasie\nilegal\nilustrat\niluzie\nimaculat\nimaginat\nimagine\nimatur\nimbus\nimens\niminent\nimpact\nimpas\nimpediment\nimperiu\nimplant\nimport\nimpuls\nimun\ninactiv\nincert\nincipit\nincolor\nincomod\nindexat\ninedit\ninformat\ningenios\ninima\ninjust\ninocent\ninox\ninsistent\ninsomnie\ninstalator\ninstructor\ninteligent\nintens\ninterviu\nintravilan\ninundat\ninutil\ninventator\niobag\nipsos\niregular\niscusit\nisoscel\niunie\nivit\nizbit\nizolat\nizomorf\nizopren\njaguar\njambon\njandarm\njargon\njenat\njeton\njgheab\njnepen\njoben\njoi\njoker\njunime\njurist\njuriu\njustificat\njuvete\njuxtapunere\nkaraoke\nkarate\nkarma\nkatana\nkelvin\nkerosen\nketchup\nkevlar\nkilogram\nkilometru\nkilovolt\nkitsch\nkripton\nlabirint\nlac\nlada\nlambda\nlaminaj\nlampion\nlance\nlansat\nlaptop\nlaser\nlatent\nlateral\nlecuit\nlefter\nlegal\nlege\nlegenda\nlemur\nleopard\nlespede\nletal\nlevier\nlexicon\nleziune\nliant\nliceu\nlider\nlift\nligament\nlighean\nlimax\nlimba\nlimbic\nlimita\nlimpede\nlingou\nlinie\nlipie\nliteral\nlivret\nlizibil\nlocatar\nlocuitor\nlogaritm\nlogic\nlogoped\nloial\nlombar\nlongevitate\nlucid\nlucru\nluminos\nlunar\nlunatic\nlunetist\nluni\nlutier\nluxos\nlynx\nmacadam\nmacao\nmacara\nmacaragiu\nmacaz\nmachiaj\nmacrou\nmaestru\nmafiot\nmagazin\nmagic\nmagnat\nmagnet\nmahamur\nmahon\nmaidan\nmaior\nmajordom\nmajoritar\nmajuscul\nmalac\nmalaxor\nmalefic\nmamaie\nmamograf\nmanager\nmandatar\nmanej\nmanevra\nmanierat\nmanipulat\nmanometru\nmansarda\nmantra\nmapamond\nmaraton\nmarcaj\nmarginal\nmargine\nmarinar\nmartie\nmartini\nmartor\nmasaj\nmascat\nmasculin\nmason\nmaster\nmaterie\nmatur\nmausoleu\nmecanic\nmecet\nmedalie\nmedian\nmedical\nmedie\nmediocru\nmeditat\nmelc\nmelc\nmemento\nmemorat\nmemorie\nmenajer\nmenisc\nmenit\nmeniu\nmental\nmercur\nmerge\nmerit\nmesaj\nmetaforic\nmetal\nmetalic\nmetan\nmeteo\nmeteorit\nmetrou\nmetru\nmiaun\nmicrob\nmicrofon\nmidie\nmiel\nmiercuri\nmiere\nmijloc\nmijluc\nmileu\nmiliard\nmilos\nmima\nmimetism\nmina\nminer\nmineralist\nminereu\nminerit\nminge\nminicar\nminimal\nminion\nminte\nminune\nmioritic\nmiotrop\nmiracol\nmirat\nmiriapod\nmiros\nmisionar\nmisterios\nmistuit\nmit\nmitic\nmitocan\nmitologie\nmixaj\nmixt\nmnemonic\nmobilat\nmobilizat\nmocasin\nmodel\nmodelat\nmodem\nmodern\nmodernizat\nmodest\nmodificat\nmodul\nmoft\nmolid\nmolie\nmoment\nmonarh\nmondial\nmonitor\nmonolog\nmonopol\nmonsenior\nmonstru\nmontabil\nmontaj\nmontan\nmontat\nmonument\nmoped\nmorar\nmorcov\nmorfologic\nmorman\nmorse\nmortar\nmotel\nmotiv\nmotor\nmotorizat\nmucegai\nmuget\nmugur\nmulat\nmumie\nmunte\nmuntos\nmural\nmurat\nmurdar\nmurmur\nmurmure\nmusaca\nmusafir\nmutant\nmutare\nmuzeolog\nmuzeu\nmuzical\nnabab\nnailon\nnaiv\nnapalm\nnarativ\nnasture\nnational\nnativ\nneant\nnebulos\nnecesar\nnectar\nnedormit\nnedumerit\nnegare\nnegociabil\nnegru\nnegustor\nnelimitat\nnemilos\nneobosit\nneon\nneopren\nnervos\nnesemnat\nneserios\nnesigur\nnesupus\nneted\nneural\nneuron\nneutru\nnevoie\nnibelung\nnihilism\nnimbus\nnimeni\nnimfa\nninsoare\nnirvana\nnisip\nnobel\nnociv\nnocturn\nnod\nnoiembrie\nnomadic\nnonsens\nnor\nnord\nnordic\nnormal\nnoroc\nnotabil\nnotar\nnucleu\nnudism\nnufar\nnumai\nnumar\nnume\nnumeric\nnumismatic\nnumit\noaie\noameni\noarba\noaspete\noaste\nobedient\nobelisc\nobicei\nobiect\noblic\nobligat\noblon\nobor\nobosit\nobraz\nobscur\nobsesie\nobsidian\nobstacol\nobturat\nobtuz\nocazie\nocean\nochelari\nocolit\nocrotit\noctagon\noctombrie\nocult\nocupat\nodaie\nodihnit\nodios\nodorizant\nofenziv\noftat\noinar\noituz\nolar\nolfactiv\noligarh\nolimpian\nolograf\nomagiu\nomega\nomenie\nomenos\nomnia\nomniprezent\nomogen\nondulat\nonest\nonorat\nopac\nopera\nopiat\nopinie\nopozabil\noprire\noptar\noptic\noptimal\noptimizat\noptzeci\nopulent\noracol\norar\norbital\nordin\nordinal\nordonat\norganic\norganizat\norguliu\norice\noricine\norient\norigine\norion\norizont\nornament\nortac\nortodox\noscilant\noseminte\nosmiu\nosmotic\nostenit\nostil\nosuar\noua\noxidat\noxigen\noximetru\noximoron\nozana\npace\npachebot\npachet\npacient\npacific\npact\npager\npalid\npalindrom\npalton\npancreas\npanorama\npanou\npantalon\npantof\npapagal\npapuc\nparapet\nparbriz\nparfum\nparitate\nparter\npasaj\npasiune\npatogen\npatriot\npatru\npavaj\npavea\npavilion\npecete\npegas\npelican\npenaj\npenar\npendul\npensie\npensiune\npensula\npepene\nperceptiv\nperdea\nperete\nperie\nperiodic\nperla\npermisie\nperplex\npersonaj\npescar\npetrol\npianist\npicant\npicior\npicolo\npictor\npiele\npiftie\npigment\npilon\npinguin\npiolet\npirat\npistol\npiston\nplacaj\nplafon\nplasa\nplat\npleonasm\nplete\nplic\nploape\nplumb\npodea\npodium\npoem\npoezie\npogon\npolar\npolen\npolonic\npopas\npopor\npopular\nport\nportocaliu\nportret\nposesiv\nposteritate\npotasiu\npotent\npotir\npotop\npoveste\npozitiv\npractic\npragmatic\npraznic\npreambul\nprecar\nprefect\npremolar\nprenume\npreot\npretabil\npriceput\nprieten\nprimit\nprivat\npriza\nproba\nproblema\nprofit\nprogram\nproiect\nprolific\nprompt\npropulsie\nprosop\nprotest\nprovincie\nprudent\nprunc\npublic\npudra\npufulete\npuhoi\npuiet\npulpa\npuls\npumnal\npunct\npupic\npustnic\nputere\nputred\nquark\nquasar\nquasi\nquinet\nrabat\nrabin\nrachiu\nracord\nradar\nradial\nradian\nradiat\nradiator\nradioactiv\nradiofonic\nradiolog\nradiometrie\nradon\nrafinat\nrafting\nraion\nraliu\nramuri\nrandomizat\nraport\nrarefiat\nrarisim\nrastel\nrateu\nraton\nrazant\nreactivat\nrealizat\nreanimat\nreaprins\nrebel\nrebus\nrebut\nrecalculat\nrece\nrecesiune\nrechin\nrecreativ\nrecrut\nrector\nrecuperat\nrecursiv\nredactare\nredresor\nredus\nredut\nreflexiv\nreflux\nrefuz\nrege\nregenerat\nregim\nregistru\nreglabil\nregret\nregular\nrelax\nreligie\nremediu\nremix\nremiza\nrentabil\nrenume\nrepaus\nrepede\nreper\nrepezit\nreporter\nreportofon\nresemnat\nrespins\nrestaurant\nretoric\nretras\nrevizie\nrevocat\nrezervor\nridicol\nrigla\nrindea\nring\nrininchi\nrinocer\nritmic\nrivanol\nroade\nrobotic\nrobust\nrodaj\nrodie\nroditor\nrotisor\nrotor\nrotula\nrotunjit\nroz\nrudimentar\nrugina\nrulat\nruleta\nrulment\nrulou\nrumenit\nrupestru\nsabie\nsabot\nsabotaj\nsac\nsafir\nsalam\nsalariu\nsaleu\nsaltea\nsalut\nsalvamont\nsalvat\nsalvie\nsamurai\nsanie\nsarcasm\nsare\nsatelit\nsaturat\nsaturn\nscadent\nscala\nscaun\nschimb\nsciatic\nsclipire\nscorpion\nscrum\nscula\nsecat\nsecera\nsecol\nsecret\nsector\nsecure\nsediment\nseism\nseismograf\nsejur\nsemafor\nsensibil\nsenzor\nsenzorial\nseptembrie\nserafim\nsergent\nsesiune\nsever\nsezon\nsfernic\nsfinx\nshogun\nsibiu\nsigiliu\nsigma\nsilicon\nsiloz\nsilvia\nsimbiot\nsimbolism\nsimfonic\nsimpatic\nsistem\nsmerit\nsmog\nsoare\nsobru\nsociabil\nsocietate\nsolar\nsolemn\nsolomonar\nsolubil\nsolvabil\nsomelier\nsomon\nsonar\nsondaj\nsonerie\nsonor\nsorbet\nspanac\nspate\nspecialist\nspectru\nspeolog\nspic\nspionaj\nstabil\nstagiar\nstand\nstart\nstativ\nstea\nsteag\nstejar\nstilou\nstimulant\nstraniu\nstrat\nstropitor\nstrug\nstudent\nstufos\nsubsol\nsubtil\nsuculent\nsufix\nsugar\nsulfat\nsumbru\nsunet\nsupernatural\nsurcele\nsurplus\nsurprins\nsusan\nsuspect\nsuspendat\nsvelt\ntabel\ntabiet\ntabla\ntablou\ntabu\ntabular\ntachet\ntacit\ntactil\ntahion\ntalaz\ntalcioc\ntalentat\ntalie\ntalisman\ntalon\ntalpa\ntamponat\ntanc\ntandem\ntandru\ntangibil\ntapet\ntaraf\ntardiv\ntarif\ntartor\ntasat\ntatuaj\nteanc\nteatru\nteflon\ntegument\ntejghea\ntelefon\nteleghidat\ntelepat\ntelescop\ntelevizor\ntelex\ntemelie\ntemerar\ntemperat\ntemplu\ntemporar\ntenace\ntendon\ntenor\ntentant\nteolog\nteorie\nterapeut\nterariu\nterasament\nteren\nterestru\nteribil\nteritoriu\nterminator\ntermometru\ntestament\ntestat\ntexturat\ntezaur\ntibie\ntigaie\ntigru\ntimid\ntimonerie\ntimp\ntimpan\ntipar\ntipizat\ntipografie\ntiraj\ntitlu\ntoamna\ntoane\ntocilar\ntocitor\ntoiag\ntolerat\ntomograf\ntoner\ntonomat\ntopmodel\ntopograf\ntoponim\ntopor\ntorace\ntoroid\ntotalitar\ntotem\ntrabant\ntrabuc\ntractare\ntractor\ntraducere\ntrafalet\ntrafic\ntraforaj\ntrainic\ntramvai\ntrandafir\ntranscendent\ntransfer\ntransfuzie\ntransport\ntranzit\ntraseu\ntravaliu\ntreaz\ntrece\ntrei\ntren\ntrepte\ntrestie\ntriaj\ntribal\ntribord\ntribut\ntriceps\ntricou\ntrifoi\ntrigon\ntrilateral\ntrimestru\ntriumf\ntrivial\ntrofeu\ntrompetist\ntronson\ntropical\ntropot\ntrotuar\ntrucaj\ntrucat\ntrunchi\ntsunami\ntuareg\ntulbure\ntun\ntunel\ntunet\ntunsoare\ntupeu\nturban\nturbo\nturnir\nturometru\ntutore\ntutun\nucenic\nuger\nuimit\nuimitor\nuituc\nulcior\nulei\nulterior\nultimatum\nultracentral\numan\numanitar\numbra\numed\numeri\numezit\numflat\numil\numor\nuncie\nunde\nundeva\nunghie\nunicat\nuniform\nunit\nunitate\nuniune\nunivers\nuns\nunsprezece\nunt\nunu\nuragan\nurangutan\nuraniu\nurare\nurcare\nureche\nurgent\nurmare\nurnit\nurs\nursit\nursitoare\nursuz\nuruit\nurzici\nusturoi\nutil\nutilaj\nutilat\nutilizat\nuzabil\nuzina\nuzufruct\nuzurpat\nvacant\nvacum\nvagon\nvalabil\nvale\nvalet\nvalid\nvaloare\nvaloros\nvals\nvaluta\nvamal\nvanilie\nvaporizator\nvariabil\nvast\nvatman\nvechi\nvecie\nvector\nvedere\nvega\nvegetal\nvehement\nvelur\nvenin\nventilator\nvenus\nverb\nverbal\nverificat\nveritabil\nvermut\nvernisaj\nvers\nvertex\nvertical\nvesel\nvespar\nvest\nvestiar\nvestit\nveterinar\nviabil\nviaduct\nvibrant\nviciu\nviclean\nvictorie\nvierme\nviespe\nvigilent\nviguros\nvineri\nvioloncel\nvipera\nvirament\nvirtual\nvisare\nviscol\nvital\nvizibil\nvizionar\nvizir\nvizitator\nvizitiu\nvizor\nvizuine\nvlavie\nvoal\nvocabular\nvocal\nvocalist\nvoce\nvoievod\nvoievodat\nvoios\nvoitor\nvolan\nvolatil\nvolei\nvolt\nvolum\nvopsea\nvortex\nvraci\nvreasc\nvrednic\nvreme\nvuiet\nvulcan\nvulgar\nvulnerabil\nvulpe\nvulture\nwalkman\nweb\nxenograf\nxerox\nyacht\nyachting\nyeti\nyoga\nyogin\nzadar\nzahar\nzaharisit\nzambilie\nzbanghiu\nzbor\nzbucium\nzdravan\nzdrobit\nzdrucit\nzebra\nzece\nzeitate\nzemos\nzero\nzeta\nzeu\nzgomot\nzguduit\nzgurav\nziar\nziarist\nzid\nzidar\nzidit\nzigot\nzilier\nzinc\nzodiac\nzodie\nzombi\nzona\nzonal\nzulu\nzumzet"
            },
            {
                "author": "ic",
                "date": "2021-08-04T13:28:55",
                "message_text_only": "Hi,\n\n> On 4 Aug 2021, at 12:30, Justin Valceanu via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> I have created a new Romanian wordlist for Bip-0039;\n> Requesting permission to push to github the attached modified files.\n\nAlthough I don\u2019t think it \u2019s hard requirement, it would be great if the words could be uniquely identified using the first 4 letters (most metal backup \u201cplates\u201d only have space for 4 letters).\n\nI see several occurrences of conflicting words in the first page alone.\n\n++ ic"
            },
            {
                "author": "s7r",
                "date": "2021-08-04T22:29:07",
                "message_text_only": "ic via bitcoin-dev wrote:\n> Hi,\n> \n>> On 4 Aug 2021, at 12:30, Justin Valceanu via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> I have created a new Romanian wordlist for Bip-0039;\n>> Requesting permission to push to github the attached modified files.\n> \n> Although I don\u2019t think it \u2019s hard requirement, it would be great if the words could be uniquely identified using the first 4 letters (most metal backup \u201cplates\u201d only have space for 4 letters).\n> \n> I see several occurrences of conflicting words in the first page alone.\n> \n> ++ ic\n> \n\n\nI am +1 on the unique identification using the first 4 letters, makes it \neasy for restoring from seed on mobile wallets. Don't know if this is \nreally a blocker but since RO is a rich enough language in terms of \nwords, this shouldn't be too hard.\n\nAlso, world list is not acceptable in this form. it should be revised by \nsomeone with knowledge in Romanian lexical area, I just briefly reviewed \nand:\n\n- _adesiv_ shouldn't be *adeziv* ?\n\n- _walkman_ - this is not a Romanian word, while it is of course \nsometimes used in Romania.\n\n- _web_ - this is not a Romanian word, while it is of course sometimes \nused in Romania.\n\n- _yachting_ - this is not a Romanian word and it most certainly not \nused in Romania :)) Why not use *navigatie* or something?\n\n- _topmodel_ - it's two words merged in one\n\n- _acvatic_ and _acvaplanare_ - they are both independent words but very \nclose to each other while one is an adjective and one substantive. These \ntwo for example break the \"no confusing words\" spec.\n\nI didn't review the entire word list and no sense to make this message \ntoo long, but I'm sure you see the point. Word list needs changes, \nplease correct."
            },
            {
                "author": "Justin Valceanu",
                "date": "2021-08-05T06:16:27",
                "message_text_only": "Hi,\n\n@IC\n\nThere were 325 words that were not uniquely identified by the first 4 \nchars. I've fixed that.\n\nAlso, simple words (* by simple I mean 4 char words *) now fill more space;\n\n@S7R\n\nYou were right about __adesiv__ - fixed that; The other sugestions, \n_topmodel_, _walkman_, _web_, _yachting_ were also removed. Between \n_acvatic_ and _acvaplanare_ only _acvatic_ remains in the list;\n\nI have also remove words starting with the letters _Q_, _W_, _X_ and _Y_ \nbecause most of the words used in Romanian were borrowed from other \nlanguages (mostly English, eg. web / yacht / walkman ...);\n\nI am confident that the wordlist is now complete and correct;\n\nPlease see attached, the wordlist and some statistics about the word \ndistribution.\n\nThanks,\n\n\n\nAttached is the new list;\n\nThanks,\n\n\n\nOn 8/5/21 1:29 AM, s7r wrote:\n> ic via bitcoin-dev wrote:\n>> Hi,\n>>\n>>> On 4 Aug 2021, at 12:30, Justin Valceanu via bitcoin-dev \n>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>> I have created a new Romanian wordlist for Bip-0039;\n>>> Requesting permission to push to github the attached modified files.\n>>\n>> Although I don\u2019t think it \u2019s hard requirement, it would be great if \n>> the words could be uniquely identified using the first 4 letters \n>> (most metal backup \u201cplates\u201d only have space for 4 letters).\n>>\n>> I see several occurrences of conflicting words in the first page alone.\n>>\n>> ++ ic\n>>\n>\n>\n> I am +1 on the unique identification using the first 4 letters, makes \n> it easy for restoring from seed on mobile wallets. Don't know if this \n> is really a blocker but since RO is a rich enough language in terms of \n> words, this shouldn't be too hard.\n>\n> Also, world list is not acceptable in this form. it should be revised \n> by someone with knowledge in Romanian lexical area, I just briefly \n> reviewed and:\n>\n> - _adesiv_ shouldn't be *adeziv* ?\n>\n> - _walkman_ - this is not a Romanian word, while it is of course \n> sometimes used in Romania.\n>\n> - _web_ - this is not a Romanian word, while it is of course sometimes \n> used in Romania.\n>\n> - _yachting_ - this is not a Romanian word and it most certainly not \n> used in Romania :)) Why not use *navigatie* or something?\n>\n> - _topmodel_ - it's two words merged in one\n>\n> - _acvatic_ and _acvaplanare_ - they are both independent words but \n> very close to each other while one is an adjective and one \n> substantive. These two for example break the \"no confusing words\" spec.\n>\n> I didn't review the entire word list and no sense to make this message \n> too long, but I'm sure you see the point. Word list needs changes, \n> please correct.\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: bip-0039-wordlists.md\nType: text/markdown\nSize: 6792 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210805/4b9a1b70/attachment-0001.bin>\n-------------- next part --------------\nabajur\nabanos\nabator\nabces\nabdomen\nabecedar\nabisal\nabordat\nabrogat\nabsent\nabsint\nabsolvent\nabundent\naburi\nacadea\nacalmie\nacatist\nacetat\nacid\naclama\nacomodat\nacord\nacostament\nacrobat\nactiv\nactor\nactualitate\nacvatic\nadaos\nadaptabil\nadeziv\nadiacent\nadiere\nadio\nadjectiv\nadmis\nadorat\nadresa\nadult\nadverb\naerat\naerogen\nafacere\nafin\nafluent\nagale\nagent\nagil\nagrement\nagricol\nahtiere\nairbag\naiurea\najutat\nalambic\nalarmat\nalb\nalbastru\nalegoric\nalert\nalfabet\naliaj\nalibi\nalifie\naligator\nalint\naloe\nalpin\naltitudine\naltruism\naluat\nalun\namabil\namalgam\namant\nambrozie\namestec\nametist\namfiteatru\namfocit\namiabil\namidon\namintire\namnezie\namonte\namorf\namper\namplu\namprenta\namurg\nananas\nancestru\nancora\nanexa\nangajat\nangelic\nanimal\naniversare\nanonim\nansamblu\nantet\nantidot\nantonim\nantricot\nanturaj\nanual\naparat\napel\naperitiv\napex\napolo\napometru\napostrof\naprig\naproape\napt\naracet\naragaz\narbitru\narcas\narctic\nardei\nargat\nargint\nargou\nargument\narhaism\narhiduce\naritmic\narmat\narmonie\narsenal\nartezian\nartifact\nasalt\nasertiv\nasfalt\nasigurare\naspirator\nasteroid\nastro\nateneu\natestat\natlas\natletic\natomic\natractiv\naudit\naugust\naur\nautentic\nautor\navans\navarie\navatar\navere\naviz\naxial\naxiom\nazimut\nazot\nbabic\nbabuin\nbaclava\nbacon\nbacterie\nbagaj\nbalans\nbalcon\nbalet\nbaliza\nbalnear\nbalon\nbalsam\nbambus\nbanal\nbanc\nbanda\nbaraj\nbarbaric\nbarion\nbarman\nbaron\nbasculant\nbasist\nbasm\nbaston\nbatalion\nbaterie\nbaton\nbazar\nbazin\nbec\nbej\nbelciug\nbenefic\nbenzen\nberbec\nbere\nbestie\nbeta\nbeton\nbezea\nbiban\nbibelou\nbiceps\nbici\nbideu\nbidon\nbijutier\nbilet\nbiliard\nbinar\nbinoclu\nbiolog\nbioritm\nbiped\nbirjar\nbirou\nbiscuit\nbistro\nbitum\nbiuvac\nbivol\nbizar\nbizon\nblindat\nblister\nbloc\nblond\nblugi\nbluza\nboboc\nbocanc\nboem\nboier\nboiler\nbolovan\nbondar\nborcan\nbord\nbostan\nbotez\nbrad\nbreaz\nbreloc\nbretea\nbrici\nbronz\nbruiat\nbruma\nbrutar\nbucle\nbufet\nbuget\nbuimac\nbujor\nbulbar\nbuldozer\nbuletin\nbulion\nbulz\nburbon\nburic\nburlan\nbursuc\nbust\nbusuioc\nbutan\nbutic\nbutoi\nbutuc\nbuzunar\ncabaret\ncabinet\ncablu\ncacao\ncactus\ncadastru\ncadet\ncadou\ncadru\ncafea\ncaiac\ncaiet\ncal\ncalamar\ncalcul\ncalendar\ncaligraf\ncalm\ncalup\ncamarad\ncamion\ncampus\ncanal\ncangur\ncanion\ncanoe\ncanton\ncapac\ncapital\ncaporal\ncapra\ncapsator\ncaptiv\ncarapace\ncarbon\ncardinal\ncargo\ncarie\ncarne\ncarou\ncarpatic\ncarte\ncasant\ncasetofon\ncasier\ncastel\ncater\ncatod\ncauciuc\ncavalerie\ncazan\ncazino\nceai\nceas\nceaun\ncedru\ncelest\ncelofan\ncentru\ncenzor\ncer\nceramic\ncerb\ncercel\ncerdac\ncerebel\ncesiune\ncetate\ncezar\ncheag\nchei\ncherestea\nchibrit\nchimic\nchiot\nchip\nchirie\nciclism\ncidru\ncifru\nciment\ncimpoi\ncina\ncinci\ncinema\ncinic\ncioban\nciocan\nciorap\ncirc\ncitat\ncitit\ncitrus\ncivil\ncizmar\nclandestin\nclar\nclaxon\nclema\ncleric\ncleste\nclient\nclima\nclocot\nclona\nclopot\nclor\nclub\ncoafor\ncobalt\ncocor\ncodex\ncodru\ncoeficient\ncoeziune\ncofetar\ncofraj\ncoiot\ncojoc\ncolac\ncoleg\ncolind\ncolor\ncomic\ncomod\ncompas\ncomunism\nconac\nconcav\nconector\nconfort\ncongelator\nconsul\nconte\ncopac\ncopios\ncoral\ncorb\ncorect\ncorn\ncoroziv\ncorset\ncort\ncositor\ncosmic\ncostum\ncovor\ncovrig\ncozonac\ncredit\ncreion\ncreol\ncrevete\ncrin\ncristal\ncrocodil\ncroitor\ncronic\ncruce\ncrupier\nctitor\ncuantic\ncub\ncuget\ncui\nculinar\nculme\nculori\nculpabil\ncumin\ncuptor\ncuraj\ncurcan\ncurea\ncurier\ncursor\ncurte\ncusut\ncutanat\ncutie\ncutremur\ncvorum\ncyborg\ndacic\ndafin\ndans\ndata\ndatorie\ndeal\ndebara\ndebit\ndeblocat\ndebut\ndecan\ndeceniu\ndecizie\ndecor\ndecret\ndefect\ndegaja\ndeget\ndejun\ndelfin\ndelir\ndelta\ndemagog\ndemis\ndemon\ndens\ndental\ndepanat\ndepou\ndepus\nderanj\ndesen\ndespot\ndetectiv\ndetonator\ndeviz\ndexteritate\ndiabolic\ndiacritic\ndialog\ndiamant\ndiavol\ndiedru\ndiesel\ndiez\ndifan\ndiferit\ndiftong\ndifuz\ndig\ndigestie\ndiligent\ndinar\ndinozaur\ndinte\ndiplomat\ndipol\ndirectorat\ndisc\ndispozitiv\ndistribuit\ndivers\ndoctor\ndocument\ndoi\ndolofan\ndomeniu\ndomiciliu\ndormitor\ndosar\ndovleac\ndozaj\ndragon\ndrapel\ndren\ndrept\ndrob\ndrojdie\ndruid\ndrumar\ndualism\ndubiu\nduhovnic\ndulceag\ndulgher\nduplex\ndurere\necher\nechipa\necler\necograf\necologie\neconomat\necran\necuator\necuson\necvestru\nedificiu\nedil\neditor\nefect\nefemer\neficace\nefort\nefractor\negal\nelaborat\nelan\nelastic\nelectric\nelefant\nelegant\nelementar\neleron\nelev\nelice\neligibil\neliminat\neliptic\nelixir\nelocvent\nelogiat\nelucidat\neluziv\nemanat\nembargo\nemblematic\neminent\nemirat\nemotiv\nempatic\nemulsie\nendomorf\nenergie\nenigmatic\nentitate\nentuziast\neolian\nepicentru\nepidemic\nepilog\nepisod\nepitaf\nepolet\nepsilon\nepuizat\nequestru\neradicat\nereditar\nergonomic\nermetic\neroare\nerou\neroziune\nerudit\nescalop\nest\netaj\netalat\netanol\netern\netnie\netnograf\neucariot\neuforie\neugenie\neuropa\nevacua\nevalua\nevantai\neveniment\nevident\nevitat\nevocat\nevolua\nexact\nexagera\nexaltat\nexamen\nexcavator\nexces\nexcursie\nexecuta\nexod\nexomorf\nexotic\nexpat\nexpert\nexpirat\nexplicat\nexport\nextaz\nextins\nextract\nezoteric\nfabrica\nfabulos\nfachir\nfacil\nfactor\nfacultate\nfagure\nfaima\nfalie\nfals\nfamilie\nfandare\nfanion\nfanta\nfapt\nfaraon\nfarfurie\nfaringe\nfarmec\nfascicul\nfason\nfatal\nfault\nfauna\nfaur\nfazan\nfebruarie\nfecior\nfederal\nfelie\nfemeie\nfeminin\nfenicul\nfenomen\nferbinte\nfericit\nferm\nferos\nfertil\nfestival\nfeudal\nfezabil\nfiabil\nfiare\nfiasco\nficat\nfictiv\nficus\nfier\nfigurant\nfilaj\nfilet\nfilm\nfilon\nfiltru\nfinit\nfior\nfirav\nfiscal\nfisiune\nfistic\nfisura\nfixat\nflacon\nflagrant\nflambat\nflaps\nflaut\nflirt\nfloral\nfluent\nfluier\nfluture\nfluviu\nflux\nfocal\nfochist\nfolie\nfolos\nfond\nfonic\nforaj\nforceps\nformular\nfortificat\nfosfor\nfotbal\nfoton\nfrac\nfrag\nfranjur\nfrasin\nfrate\nfrecvent\nfrenetic\nfreon\nfrigider\nfrizer\nfront\nfruct\nfucsia\nfular\nfulg\nfum\nfunciar\nfundal\nfunebru\nfungibil\nfunie\nfuraj\nfurie\nfurnal\nfurou\nfursec\nfurtun\nfuturism\nfuziune\ngabarit\ngabion\ngalaxie\ngalerie\ngalop\ngama\ngaraj\ngard\ngarou\ngastronom\ngazetar\ngazifer\ngazos\ngeam\ngelos\ngem\ngemut\ngenerat\ngeniu\ngenotip\ngentil\ngenunchi\ngeodezic\ngeoid\ngeometric\ngermen\nghemotoc\nghepard\nghicit\nghid\nghilimele\nghimpe\nghiont\nghips\nghiuden\ngigafon\ngimnaziast\ngin\nginere\ngirofar\ngiulgiu\ngiuvaier\ngladiator\nglazura\ngletuit\nglisant\nglobal\nglorie\ngluten\ngoblen\ngofra\ngol\ngolem\ngoliat\ngonac\ngonflabil\ngong\ngonit\ngospodar\ngrabnic\ngrade\ngrafit\ngramaj\ngranit\ngratis\ngraur\ngravor\ngrefa\ngreier\ngrenada\ngresie\ngreutate\ngrifon\ngrind\ngrosolan\ngrozav\ngrupat\nguler\ngulie\nguma\nguru\ngust\ngutui\nguvern\nguvid\nhabar\nhabitat\nhaiduc\nhaihui\nhalat\nhalterofil\nhalucinant\nhamac\nhambar\nhamei\nhamsie\nhandbal\nhangiu\nhanorac\nhaos\nhaotic\nharbuz\nharnic\nharpa\nharta\nhazard\nhazliu\nhectar\nheliu\nhexagon\nhibrid\nhidrant\nhipiot\nhipnotizat\nholografic\nhomar\nhorn\nhoroscop\nhorticultor\nhota\nhotel\nhrean\niaht\niasomie\niatagan\niaurt\niaz\nibric\niconic\nidealism\nidentic\nideolog\nidol\niedera\nieftin\nienuper\niepure\niglu\nignat\nignorat\nigrasie\nilegal\niluminat\nilustrat\niluzie\nimaculat\nimagine\nimatur\nimbus\nimens\niminent\nimn\nimpas\nimperiu\nimplant\nimport\nimprimat\nimpuls\nimun\ninactiv\nincert\nincipit\nincolor\nindexat\nindigo\nindustrie\ninedit\ninfinit\ninformat\ningenios\ninginer\ninima\ninjust\ninocent\ninox\ninsectar\ninsigna\ninsomnie\ninstinct\nintens\nintim\nintravilan\ninundat\ninutil\ninventator\ninvidie\niobag\niod\nipsos\niregular\niridiu\nironic\niscusit\nisoscel\niubire\niulie\niunie\nivit\nizbit\nizolat\nizomorf\nizopren\njaguar\njambon\njandarm\njanta\njargon\njenat\njeton\njgheab\njnepen\njoben\njoc\njoi\njoker\njumate\njunime\njuriu\njustificat\njuvete\njuxtapunere\nkarate\nkarma\nkatana\nkelvin\nkerosen\nketchup\nkevlar\nkilogram\nkilt\nkitsch\nkripton\nlabirint\nlac\nlada\nlambda\nlaminaj\nlampion\nlance\nlansat\nlapte\nlaser\nlatent\nlatin\nlecuit\nlefter\nlegal\nlege\nlemn\nlemur\nlenjerie\nleopard\nlespede\nletal\nlevier\nlexicon\nleziune\nliant\nliber\nliceu\nlichior\nlider\nlift\nligament\nlighean\nlignit\nlimax\nlimba\nlimita\nlimpede\nlingou\nlinie\nlipie\nliteral\nlitigiu\nlivret\nlizibil\nlocatar\nlocuitor\nlogaritm\nlogic\nlogoped\nloial\nlombar\nlongevitate\nloto\nlucid\nlucru\nlujer\nluminos\nlunar\nlunetist\nluni\nlutier\nluxos\nlynx\nmacao\nmachiaj\nmacrou\nmaestru\nmafiot\nmagazin\nmagic\nmagnat\nmahamur\nmahon\nmaidan\nmaior\nmajordom\nmajuscul\nmalac\nmalefic\nmamaie\nmamograf\nmanager\nmandatar\nmanej\nmanierat\nmanometru\nmansarda\nmantra\nmapamond\nmaraton\nmarcaj\nmargine\nmarinar\nmaro\nmartie\nmasaj\nmascat\nmason\nmaster\nmaterie\nmatur\nmausoleu\nmecanic\nmecet\nmedalie\nmedie\nmelc\nmemento\nmemorat\nmenajer\nmeniu\nmental\nmercur\nmerge\nmerit\nmesaj\nmetal\nmeteo\nmetru\nmiaun\nmicrob\nmidie\nmiel\nmiere\nmiez\nmijloc\nmileu\nmiliard\nmilos\nmima\nmimetism\nmina\nminer\nminge\nminion\nminte\nminut\nmioritic\nmiotrop\nmirat\nmiriapod\nmiros\nmisionar\nmistuit\nmit\nmitic\nmitocan\nmixaj\nmixt\nmnemonic\nmobilat\nmocasin\nmodel\nmodificat\nmodul\nmoft\nmolid\nmoloz\nmoment\nmonarh\nmondial\nmonitor\nmonolog\nmonstru\nmontan\nmonument\nmoped\nmops\nmorar\nmorcov\nmorfologic\nmorman\nmorse\nmortar\nmotan\nmotel\nmotiv\nmotor\nmucegai\nmuget\nmugur\nmulat\nmumie\nmunte\nmural\nmurdar\nmurmur\nmusaca\nmutant\nmuzeu\nmuzical\nnabab\nnailon\nnaiv\nnanism\nnapalm\nnarativ\nnasture\nnativ\nnaturist\nnavigator\nneant\nnebulos\nnecesar\nnectar\nnedormit\nnedumerit\nnegare\nnegociabil\nnegru\nnegustor\nnelimitat\nnemilos\nneobosit\nneon\nneopren\nneptun\nnervos\nnesemnat\nnesigur\nnesupus\nneted\nneural\nneutru\nnevoie\nnibelung\nnihilism\nnimbus\nnimeni\nnimfa\nninsoare\nnirvana\nnisip\nnivel\nnobel\nnociv\nnocturn\nnod\nnoiembrie\nnomadic\nnonsens\nnor\nnord\nnormal\nnoroc\nnotar\nnuc\nnucleu\nnudism\nnufar\nnumai\nnume\nnumit\noaie\noameni\noarba\noaspete\noaste\nobedient\nobelisc\nobicei\nobiect\noblic\noblon\nobor\nobosit\nobraz\nobscur\nobsesie\nobsidian\nobstacol\nobtuz\nocazie\nocean\nochelari\nocolit\nocrotit\noctagon\noctombrie\nocult\nocupat\nodaie\nodihnit\nodios\nodorizant\nofenziv\noftat\nogar\noinar\noituz\nolar\nolfactiv\noligarh\nolimpian\nolograf\nomagiu\nomega\nomenie\nomnia\nomogen\nondulat\nonest\nonorat\nopac\nopera\nopiat\nopinie\nopozabil\noprire\noptar\noptic\noptzeci\nopulent\noracol\norar\norbital\nordin\nordonat\norez\norganic\norgoliu\norguliu\norice\norient\norigine\norion\norizont\nornament\nortac\nortodox\noscilant\noseminte\nosmiu\nosmotic\nostenit\nostil\nosuar\notel\notet\notoman\noua\noxidat\noxigen\noximetru\nozana\nozon\npace\npachet\npacient\npact\npager\npalid\npalmier\npalton\npancreas\npanda\npanou\npantof\npapagal\npapion\npapuc\nparadis\nparbriz\nparc\nparfum\nparitate\nparlament\nparter\npasaj\npasiune\npaste\npateu\npatine\npatogen\npatru\npavaj\npavea\npavilion\npecete\npedometru\npegas\npeisaj\npelican\npenaj\npendul\npensie\npepene\nperceptiv\nperdea\nperete\nperfect\nperie\nperla\npermis\nperplex\npersonaj\npescar\npetrol\npianist\npicant\npicior\npicnic\npicolo\npictor\npiele\npiftie\npigment\npilaf\npilon\npinguin\npinion\npiolet\npipa\npiper\npirat\npistol\npitic\npiton\npivot\nplacaj\nplafon\nplan\nplasa\nplat\npleonasm\nplete\nplex\nplic\nploape\nplop\nplumb\nplus\npod\npodea\npodium\npoem\npoezie\npogon\npolar\npolen\npolizor\npolonic\npompa\nponton\npopas\npopor\npopular\nporc\nport\nporumb\nposesiv\npost\npotasiu\npotent\npotir\npotop\npoveste\npozitiv\npractic\nprag\npraznic\npreambul\nprecar\nprefix\npremolar\nprenume\npreot\npretabil\npriceput\nprieten\nprimit\nprivat\npriza\nproba\nprocent\nprodus\nprofit\nprogram\nproiect\nprolific\nprompt\npropan\nprosop\nprotest\nprovincie\nprudent\nprunc\npubertate\npublic\npudel\npudra\npuf\npufulete\npuhoi\npuiet\npulover\npulpa\npuls\npumn\npunct\npunte\npupic\npurtat\npustnic\nputere\nputred\nrabat\nrabin\nrachiu\nracord\nradar\nradial\nradon\nrafinat\nraft\nraid\nraion\nraliu\nrama\nramuri\nrandomizat\nrapid\nraport\nrarefiat\nrarisim\nrastel\nrateu\nraton\nrazant\nreactivat\nrealizat\nreanimat\nreaprins\nrebel\nrebus\nrecalculat\nrece\nrechin\nrecrut\nrector\nrecursiv\nredactare\nredresor\nredus\nreferat\nreflux\nrefuz\nrege\nregim\nreglabil\nregret\nregular\nrelax\nreleu\nrelief\nremediu\nremix\nrentabil\nrenume\nrepaus\nreper\nreporter\nresemnat\nrespins\nrestaurant\nretoric\nretras\nrevers\nrevizie\nrevocat\nrezervor\nricin\nridicol\nrigla\nrima\nrindea\nring\nrininchi\nrinocer\nritmic\nritual\nrivanol\nroaba\nroade\nrobinet\nrobot\nrobust\nrochie\nrodaj\nrodie\nrom\nromb\nrosu\nrotisor\nrotor\nrotula\nroz\nrubin\nrudimentar\nrugina\nrulat\nruleta\nrulment\nrulou\nrumenit\nrupestru\nrustic\nsabie\nsabot\nsac\nsafari\nsafir\nsalam\nsaleu\nsalon\nsalsa\nsaltea\nsalut\nsalvie\nsamurai\nsanie\nsarcasm\nsare\nsatelit\nsatin\nsaturn\nscadent\nscala\nscaun\nschi\nsciatic\nsclipire\nscorpion\nscrum\nscula\nscut\nsecat\nsecera\nsecol\nsecret\nsector\nsecure\nsediment\nseif\nseism\nsejur\nseleniu\nsemafor\nsenat\nsensibil\nsenzor\nsepie\nseptembrie\nserafim\nsergent\nserial\nsertar\nsesiune\nsever\nsezon\nsfecla\nsfernic\nsfinx\nshogun\nsibiu\nsifon\nsigiliu\nsigma\nsignal\nsilicon\nsiloz\nsilvia\nsimbiot\nsimfonic\nsimplu\nsincer\nsindrom\nsirop\nsistem\nsmerit\nsmog\nsoare\nsobru\nsoc\nsocial\nsoclu\nsoia\nsolar\nsolemn\nsolomonar\nsolubil\nsolvabil\nsomelier\nsomon\nsonar\nsondaj\nsonerie\nsonor\nsorbet\nsortit\nspanac\nspart\nspate\nspectru\nspeolog\nspic\nspin\nspion\nspirit\nspital\nsplina\nsport\nstabil\nstagiar\nstand\nstart\nstativ\nstea\nstejar\nstilou\nstimulant\nstivuitor\nstop\nstorno\nstrat\nstropitor\nstrug\nstudio\nstufos\nstup\nsublim\nsubsol\nsubtil\nsuculent\nsudor\nsufix\nsugar\nsulfat\nsultan\nsumbru\nsunet\nsupernatural\nsurcele\nsurplus\nsusan\nsuspect\nsutien\nsuveran\nsvelt\ntabel\ntabiet\ntabla\ntabu\ntachet\ntacit\ntactil\ntahion\ntaifun\ntalaz\ntalcioc\ntalentat\ntalie\ntalon\ntalpa\ntambur\ntamponat\ntanc\ntandem\ntangibil\ntapet\ntaraf\ntardiv\ntarif\ntartor\ntasat\ntatuaj\nteanc\nteatru\nteflon\ntegument\ntejghea\ntelex\ntemelie\ntemplu\ntenace\ntendon\ntenor\ntentant\nteolog\nteorie\nterariu\nteren\nteribil\nterminator\ntestat\ntexturat\ntezaur\ntibie\ntigaie\ntigru\ntimbru\ntimid\ntimonerie\ntimp\ntipar\ntipizat\ntipografie\ntiraj\ntitan\ntitlu\ntitular\ntoamna\ntoane\ntocat\ntocilar\ntoiag\ntolerat\ntomograf\nton\ntoner\ntonomat\ntopor\ntorace\ntoroid\ntort\ntotalitar\ntotem\ntoxic\ntrabuc\ntractor\ntraducere\ntrafic\ntrainic\ntramvai\ntranzit\ntrapez\ntraseu\ntravaliu\ntreaz\ntrece\ntrei\ntren\ntrepte\ntrestie\ntriaj\ntrib\ntricou\ntrifoi\ntrigon\ntrilateral\ntrimestru\ntriumf\ntrivial\ntrofeu\ntroliu\ntrompetist\ntronson\ntropot\ntrotuar\ntrucaj\ntrunchi\ntrust\ntsunami\ntuareg\ntulbure\ntun\ntuna\ntunel\ntunsoare\ntupeu\nturbo\nturcoaz\nturnir\nturometru\ntuse\ntutore\ntutun\nucenic\nuger\nuimit\nuituc\nulcior\nulei\nulterior\nultimatum\nultracentral\numan\numbra\numed\numeri\numezit\numflat\numil\numor\nuncie\nunde\nunghie\nunicat\nuniform\nunit\nuniune\nunivers\nuns\nunsprezece\nunt\nunu\nuragan\nuraniu\nurare\nurban\nurcare\nureche\nurgent\nurmare\nurnit\nurs\nursit\nursuz\nuruit\nurzici\nusturoi\nutil\nutopie\nuzabil\nuzina\nuzufruct\nuzurpat\nvacant\nvacum\nvagon\nvalabil\nvale\nvalid\nvaloare\nvals\nvaluta\nvamal\nvanilie\nvapor\nvariabil\nvast\nvatman\nveac\nvechi\nvecie\nvector\nvedere\nvega\nvegetal\nvehement\nvelur\nvenin\nventilator\nvenus\nverb\nverde\nverificat\nvermut\nvernisaj\nvers\nvertex\nvesel\nvespar\nvest\nveterinar\nviabil\nviaduct\nvibrant\nviciu\nviclean\nvictorie\nvierme\nviespe\nvigilent\nviguros\nvijelie\nvineri\nviolet\nvipera\nvirament\nvirtual\nvis\nvisare\nviscol\nvital\nvitraliu\nvizir\nvizor\nvizuine\nvlavie\nvoal\nvocal\nvoce\nvoievod\nvoios\nvoitor\nvolan\nvolei\nvolt\nvolum\nvopsea\nvortex\nvrabie\nvraci\nvreasc\nvrednic\nvreme\nvuiet\nvulcan\nvulgar\nvulnerabil\nvulpe\nvulture\nzadar\nzahar\nzambilie\nzbanghiu\nzbor\nzbucium\nzdravan\nzdrobit\nzdrucit\nzebra\nzece\nzeitate\nzemos\nzero\nzeta\nzeu\nzgomot\nzguduit\nzgurav\nziar\nzid\nzidar\nzidit\nzigot\nzilier\nzimbru\nzinc\nzmeu\nzodie\nzombi\nzona\nzugrav\nzulu\nzumzet\n-------------- next part --------------\n2021-08-05 :: 09:07:05 :: 2048 Words :: Completed: 100.00% :: Ramaining 0\n2021-08-05 :: 09:07:05 :: Min/Max: _alb_ (3) :: _supernatural_ (12)\n2021-08-05 :: 09:07:05 :: First 4 char distict groups: 2048\n2021-08-05 :: 09:07:05 :: Words with 3 characters in length :: 42 - 2.05%\n2021-08-05 :: 09:07:05 :: Words with 4 characters in length :: 186 - 9.08%\n2021-08-05 :: 09:07:05 :: Words with 5 characters in length :: 595 - 29.05%\n2021-08-05 :: 09:07:05 :: Words with 6 characters in length :: 549 - 26.81%\n2021-08-05 :: 09:07:05 :: Words with 7 characters in length :: 383 - 18.70%\n2021-08-05 :: 09:07:05 :: Words with 8 characters in length :: 199 - 9.72%\n2021-08-05 :: 09:07:05 :: Words with 9 characters in length :: 53 - 2.59%\n2021-08-05 :: 09:07:05 :: Words with 10 characters in length :: 34 - 1.66%\n2021-08-05 :: 09:07:05 :: Words with 11 characters in length :: 5 - 0.24%\n2021-08-05 :: 09:07:05 :: Words with 12 characters in length :: 2 - 0.10%\n2021-08-05 :: 09:07:05 :: Words starting with letter _A_ :: R 7.86% :: # of words 161\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _A_ :: 3 chars # 3 words (1.86%) -> 0.15% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _A_ :: 4 chars # 10 words (6.21%) -> 0.49% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _A_ :: 5 chars # 41 words (25.47%) -> 2.00% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _A_ :: 6 chars # 37 words (22.98%) -> 1.81% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _A_ :: 7 chars # 35 words (21.74%) -> 1.71% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _A_ :: 8 chars # 26 words (16.15%) -> 1.27% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _A_ :: 9 chars # 4 words (2.48%) -> 0.20% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _A_ :: 10 chars # 4 words (2.48%) -> 0.20% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _A_ :: 11 chars # 1 word (0.62%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: Words starting with letter _B_ :: R 5.47% :: # of words 112\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _B_ :: 3 chars # 2 words (1.79%) -> 0.10% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _B_ :: 4 chars # 11 words (9.82%) -> 0.54% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _B_ :: 5 chars # 44 words (39.29%) -> 2.15% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _B_ :: 6 chars # 33 words (29.46%) -> 1.61% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _B_ :: 7 chars # 16 words (14.29%) -> 0.78% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _B_ :: 8 chars # 5 words (4.46%) -> 0.24% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _B_ :: 9 chars # 1 word (0.89%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: Words starting with letter _C_ :: R 8.94% :: # of words 183\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _C_ :: 3 chars # 4 words (2.19%) -> 0.20% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _C_ :: 4 chars # 15 words (8.20%) -> 0.73% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _C_ :: 5 chars # 61 words (33.33%) -> 2.98% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _C_ :: 6 chars # 59 words (32.24%) -> 2.88% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _C_ :: 7 chars # 25 words (13.66%) -> 1.22% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _C_ :: 8 chars # 13 words (7.10%) -> 0.64% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _C_ :: 9 chars # 3 words (1.64%) -> 0.15% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _C_ :: 10 chars # 3 words (1.64%) -> 0.15% from dict\n2021-08-05 :: 09:07:05 :: Words starting with letter _D_ :: R 4.25% :: # of words 87\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _D_ :: 3 chars # 2 words (2.30%) -> 0.10% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _D_ :: 4 chars # 8 words (9.20%) -> 0.39% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _D_ :: 5 chars # 26 words (29.89%) -> 1.27% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _D_ :: 6 chars # 19 words (21.84%) -> 0.93% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _D_ :: 7 chars # 15 words (17.24%) -> 0.73% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _D_ :: 8 chars # 10 words (11.49%) -> 0.49% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _D_ :: 9 chars # 3 words (3.45%) -> 0.15% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _D_ :: 10 chars # 3 words (3.45%) -> 0.15% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _D_ :: 11 chars # 1 word (1.15%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: Words starting with letter _E_ :: R 5.27% :: # of words 108\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _E_ :: 3 chars # 1 word (0.93%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _E_ :: 4 chars # 7 words (6.48%) -> 0.34% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _E_ :: 5 chars # 12 words (11.11%) -> 0.59% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _E_ :: 6 chars # 30 words (27.78%) -> 1.47% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _E_ :: 7 chars # 27 words (25.00%) -> 1.32% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _E_ :: 8 chars # 23 words (21.30%) -> 1.12% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _E_ :: 9 chars # 7 words (6.48%) -> 0.34% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _E_ :: 10 chars # 1 word (0.93%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: Words starting with letter _F_ :: R 5.71% :: # of words 117\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _F_ :: 3 chars # 1 word (0.86%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _F_ :: 4 chars # 12 words (10.26%) -> 0.59% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _F_ :: 5 chars # 38 words (32.48%) -> 1.86% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _F_ :: 6 chars # 31 words (26.50%) -> 1.51% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _F_ :: 7 chars # 20 words (17.09%) -> 0.98% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _F_ :: 8 chars # 12 words (10.26%) -> 0.59% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _F_ :: 9 chars # 2 words (1.71%) -> 0.10% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _F_ :: 10 chars # 1 word (0.86%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: Words starting with letter _G_ :: R 4.15% :: # of words 85\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _G_ :: 3 chars # 3 words (3.53%) -> 0.15% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _G_ :: 4 chars # 8 words (9.41%) -> 0.39% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _G_ :: 5 chars # 21 words (24.71%) -> 1.03% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _G_ :: 6 chars # 23 words (27.06%) -> 1.12% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _G_ :: 7 chars # 17 words (20.00%) -> 0.83% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _G_ :: 8 chars # 7 words (8.24%) -> 0.34% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _G_ :: 9 chars # 5 words (5.88%) -> 0.24% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _G_ :: 10 chars # 1 word (1.18%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: Words starting with letter _H_ :: R 1.81% :: # of words 37\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _H_ :: 4 chars # 3 words (8.11%) -> 0.15% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _H_ :: 5 chars # 10 words (27.03%) -> 0.49% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _H_ :: 6 chars # 13 words (35.14%) -> 0.64% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _H_ :: 7 chars # 5 words (13.51%) -> 0.24% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _H_ :: 8 chars # 1 word (2.70%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _H_ :: 10 chars # 4 words (10.81%) -> 0.20% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _H_ :: 11 chars # 1 word (2.70%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: Words starting with letter _I_ :: R 3.91% :: # of words 80\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _I_ :: 3 chars # 3 words (3.75%) -> 0.15% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _I_ :: 4 chars # 6 words (7.50%) -> 0.29% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _I_ :: 5 chars # 13 words (16.25%) -> 0.64% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _I_ :: 6 chars # 19 words (23.75%) -> 0.93% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _I_ :: 7 chars # 25 words (31.25%) -> 1.22% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _I_ :: 8 chars # 11 words (13.75%) -> 0.54% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _I_ :: 9 chars # 1 word (1.25%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _I_ :: 10 chars # 2 words (2.50%) -> 0.10% from dict\n2021-08-05 :: 09:07:05 :: Words starting with letter _J_ :: R 0.93% :: # of words 19\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _J_ :: 3 chars # 2 words (10.53%) -> 0.10% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _J_ :: 5 chars # 6 words (31.58%) -> 0.29% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _J_ :: 6 chars # 8 words (42.11%) -> 0.39% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _J_ :: 7 chars # 1 word (5.26%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _J_ :: 10 chars # 1 word (5.26%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _J_ :: 11 chars # 1 word (5.26%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: Words starting with letter _K_ :: R 0.54% :: # of words 11\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _K_ :: 4 chars # 1 word (9.09%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _K_ :: 5 chars # 1 word (9.09%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _K_ :: 6 chars # 5 words (45.46%) -> 0.24% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _K_ :: 7 chars # 3 words (27.27%) -> 0.15% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _K_ :: 8 chars # 1 word (9.09%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: Words starting with letter _L_ :: R 3.13% :: # of words 64\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _L_ :: 3 chars # 1 word (1.56%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _L_ :: 4 chars # 7 words (10.94%) -> 0.34% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _L_ :: 5 chars # 22 words (34.38%) -> 1.07% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _L_ :: 6 chars # 12 words (18.75%) -> 0.59% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _L_ :: 7 chars # 15 words (23.44%) -> 0.73% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _L_ :: 8 chars # 6 words (9.38%) -> 0.29% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _L_ :: 11 chars # 1 word (1.56%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: Words starting with letter _M_ :: R 6.25% :: # of words 128\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _M_ :: 3 chars # 1 word (0.78%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _M_ :: 4 chars # 9 words (7.03%) -> 0.44% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _M_ :: 5 chars # 49 words (38.28%) -> 2.39% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _M_ :: 6 chars # 25 words (19.53%) -> 1.22% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _M_ :: 7 chars # 27 words (21.09%) -> 1.32% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _M_ :: 8 chars # 14 words (10.94%) -> 0.68% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _M_ :: 9 chars # 2 words (1.56%) -> 0.10% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _M_ :: 10 chars # 1 word (0.78%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: Words starting with letter _N_ :: R 3.03% :: # of words 62\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _N_ :: 3 chars # 3 words (4.84%) -> 0.15% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _N_ :: 4 chars # 4 words (6.45%) -> 0.20% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _N_ :: 5 chars # 15 words (24.19%) -> 0.73% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _N_ :: 6 chars # 15 words (24.19%) -> 0.73% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _N_ :: 7 chars # 12 words (19.36%) -> 0.59% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _N_ :: 8 chars # 8 words (12.90%) -> 0.39% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _N_ :: 9 chars # 4 words (6.45%) -> 0.20% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _N_ :: 10 chars # 1 word (1.61%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: Words starting with letter _O_ :: R 4.54% :: # of words 93\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _O_ :: 3 chars # 1 word (1.08%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _O_ :: 4 chars # 10 words (10.75%) -> 0.49% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _O_ :: 5 chars # 28 words (30.11%) -> 1.37% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _O_ :: 6 chars # 19 words (20.43%) -> 0.93% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _O_ :: 7 chars # 22 words (23.66%) -> 1.07% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _O_ :: 8 chars # 11 words (11.83%) -> 0.54% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _O_ :: 9 chars # 2 words (2.15%) -> 0.10% from dict\n2021-08-05 :: 09:07:05 :: Words starting with letter _P_ :: R 7.81% :: # of words 160\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _P_ :: 3 chars # 2 words (1.25%) -> 0.10% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _P_ :: 4 chars # 17 words (10.63%) -> 0.83% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _P_ :: 5 chars # 47 words (29.38%) -> 2.30% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _P_ :: 6 chars # 47 words (29.38%) -> 2.30% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _P_ :: 7 chars # 31 words (19.38%) -> 1.51% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _P_ :: 8 chars # 11 words (6.88%) -> 0.54% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _P_ :: 9 chars # 5 words (3.13%) -> 0.24% from dict\n2021-08-05 :: 09:07:05 :: Words starting with letter _Q_ :: R 0 :: # of words 0\n2021-08-05 :: 09:07:05 :: Words starting with letter _R_ :: R 4.93% :: # of words 101\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _R_ :: 3 chars # 2 words (1.98%) -> 0.10% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _R_ :: 4 chars # 9 words (8.91%) -> 0.44% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _R_ :: 5 chars # 29 words (28.71%) -> 1.42% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _R_ :: 6 chars # 26 words (25.74%) -> 1.27% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _R_ :: 7 chars # 16 words (15.84%) -> 0.78% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _R_ :: 8 chars # 13 words (12.87%) -> 0.64% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _R_ :: 9 chars # 2 words (1.98%) -> 0.10% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _R_ :: 10 chars # 4 words (3.96%) -> 0.20% from dict\n2021-08-05 :: 09:07:05 :: Words starting with letter _S_ :: R 6.93% :: # of words 142\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _S_ :: 3 chars # 2 words (1.41%) -> 0.10% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _S_ :: 4 chars # 11 words (7.75%) -> 0.54% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _S_ :: 5 chars # 49 words (34.51%) -> 2.39% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _S_ :: 6 chars # 42 words (29.58%) -> 2.05% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _S_ :: 7 chars # 24 words (16.90%) -> 1.17% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _S_ :: 8 chars # 8 words (5.63%) -> 0.39% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _S_ :: 9 chars # 4 words (2.82%) -> 0.20% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _S_ :: 10 chars # 1 word (0.70%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _S_ :: 12 chars # 1 word (0.70%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: Words starting with letter _T_ :: R 6.25% :: # of words 128\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _T_ :: 3 chars # 2 words (1.56%) -> 0.10% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _T_ :: 4 chars # 9 words (7.03%) -> 0.44% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _T_ :: 5 chars # 37 words (28.91%) -> 1.81% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _T_ :: 6 chars # 40 words (31.25%) -> 1.95% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _T_ :: 7 chars # 23 words (17.97%) -> 1.12% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _T_ :: 8 chars # 8 words (6.25%) -> 0.39% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _T_ :: 9 chars # 5 words (3.91%) -> 0.24% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _T_ :: 10 chars # 4 words (3.13%) -> 0.20% from dict\n2021-08-05 :: 09:07:05 :: Words starting with letter _U_ :: R 2.44% :: # of words 50\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _U_ :: 3 chars # 4 words (8.00%) -> 0.20% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _U_ :: 4 chars # 9 words (18.00%) -> 0.44% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _U_ :: 5 chars # 12 words (24.00%) -> 0.59% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _U_ :: 6 chars # 16 words (32.00%) -> 0.78% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _U_ :: 7 chars # 4 words (8.00%) -> 0.20% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _U_ :: 8 chars # 2 words (4.00%) -> 0.10% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _U_ :: 9 chars # 1 word (2.00%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _U_ :: 10 chars # 1 word (2.00%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _U_ :: 12 chars # 1 word (2.00%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: Words starting with letter _V_ :: R 4.20% :: # of words 86\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _V_ :: 3 chars # 1 word (1.16%) -> 0.05% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _V_ :: 4 chars # 11 words (12.79%) -> 0.54% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _V_ :: 5 chars # 25 words (29.07%) -> 1.22% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _V_ :: 6 chars # 24 words (27.91%) -> 1.17% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _V_ :: 7 chars # 14 words (16.28%) -> 0.68% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _V_ :: 8 chars # 7 words (8.14%) -> 0.34% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _V_ :: 9 chars # 2 words (2.33%) -> 0.10% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _V_ :: 10 chars # 2 words (2.33%) -> 0.10% from dict\n2021-08-05 :: 09:07:05 :: Words starting with letter _W_ :: R 0 :: # of words 0\n2021-08-05 :: 09:07:05 :: Words starting with letter _X_ :: R 0 :: # of words 0\n2021-08-05 :: 09:07:05 :: Words starting with letter _Y_ :: R 0 :: # of words 0\n2021-08-05 :: 09:07:05 :: Words starting with letter _Z_ :: R 1.66% :: # of words 34\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _Z_ :: 3 chars # 2 words (5.88%) -> 0.10% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _Z_ :: 4 chars # 9 words (26.47%) -> 0.44% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _Z_ :: 5 chars # 9 words (26.47%) -> 0.44% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _Z_ :: 6 chars # 6 words (17.65%) -> 0.29% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _Z_ :: 7 chars # 6 words (17.65%) -> 0.29% from dict\n2021-08-05 :: 09:07:05 :: ::::::::::: Letter _Z_ :: 8 chars # 2 words (5.88%) -> 0.10% from dict"
            }
        ],
        "thread_summary": {
            "title": "Bip-0039/Wordlist - Romanian",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "s7r",
                "Justin Valceanu",
                "ic"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 54711
        }
    },
    {
        "title": "[bitcoin-dev] BIP Proposals for Output Script Descriptors",
        "thread_messages": [
            {
                "author": "Sjors Provoost",
                "date": "2021-08-05T14:27:12",
                "message_text_only": "Thanks for writing this up!\n\nI think your modular BIP approach makes sense. (the abstract should mention this too)\n\nContents look good to me, modulo missing test vectors. I also suggest dropping combo(), see below.\n\n\nRegarding the use of h vs ', especially since they result in a different checksum, and equality is more tedious to verify, should we just pick one and recommend that software normalises to that?\n\nFor bip-descriptors-segwit, regardless of what Bitcoin Core does, is any hex encoded script allowed for wsh()? If so is it mandatory and/or allowed to use raw() as a sub descriptor?\n\nConversely, its BIP says: \"The <tt>raw(HEX)</tt> expression can only be used as a top level descriptor\". That answers the above, but not the why.\n\nIn the backwards compatibility section it may be worth pointing out that descriptors are also used by:\n* Specter since at least v1.2.2: https://github.com/cryptoadvance/specter-desktop/releases/tag/v1.2.2\n* Coldcard since 2.0.1: https://github.com/Coldcard/firmware/commit/af00f8778947664f2d74f19879b98f7925feb327\n* HWI since 1.0.3: https://github.com/bitcoin-core/HWI/releases/tag/1.0.3\n\nNone of these support the tr(), raw() and addr() descriptors afaik. HWI doesn't implement (sorted_)multi.\n\nDoes anyone actually use combo? It seems useless, because even with the help of BIP 88 there's no way to compress all three in a single descriptor, since BIP 44/49/84 each have a different derivation. Afaik Bitcoin Core doesn't really use them either. And for future wallet migration, we might as well make separate descriptors for each key type.\n\nOne thing on my wish list - for this BIP, BIP 88 (Hierarchical Deterministic Path Templates) or yet another one - is to include a birth date (minimum block height). E.g. tr([m/86'/0'/0']xpub.../{0-1}/*)>709631\n\nAnd then of course there's the gap limit. Perhaps we just need a \"metadata\" format to go along with descriptors to track the birth data, gap limit and anything else you need (nonce collection for musig2 setup?). E.g. a simple dictionary: tr([m/86'/0'/0']xpub.../{0-1}/*){dob:709631,gap:1000}\n\n- Sjors\n\n\n> Op 29 jun. 2021, om 23:14 heeft Andrew Chow via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:\n> \n> Hi All,\n> \n> I've been working on formalizing the Output Script Descriptors that have\n> been available in Bitcoin Core for a while into BIPs. Since descriptors\n> are modular and have optional components, I've decided to split it into\n> 7 BIPs, rather than a single one. The first describes descriptors in\n> general and does not specify any particular descriptor. However it does\n> describe the general operation, key expressions (including derivation\n> paths and key origin info), and the descriptor checksum. The following 6\n> BIPs specify the actual descriptors themselves. These are non-segwit\n> descriptor (pk, pkh, sh), segwit descriptors (wpkh, wsh), multisig\n> descriptors (multi, sortedmulti), the taproot descriptor (tr), the combo\n> descriptor, and opaque descriptors (raw, addr). This separation is so\n> that implementors can choose to not implement some descriptors and still\n> say which descriptors they support without being too difficult to\n> understand.\n> \n> The text of all of the documents are below, and they can also be found\n> on github:https://github.com/achow101/bips/tree/descriptors/\n> \n> Thanks,\n> Andrew Chow\n> \n> ---\n> \n> <pre>\n>   BIP: bip-descriptors-general\n>   Layer: Applications\n>   Title: Output Script Descriptors General Operation\n>   Author: Pieter Wuille <pieter at wuille.net>\n>           Andrew Chow <andrew at achow101.com>\n>   Comments-Summary: No comments yet.\n>   Comments-URI:\n> https://github.com/bitcoin/bips/wiki/Comments:BIP-descriptors-general\n>   Status: Draft\n>   Type: Informational\n>   Created: 2021-06-27\n>   License: BSD-2-Clause\n> </pre>\n> \n> ==Abstract==\n> \n> Output Script Descriptors are a simple language which can be used to\n> describe collections ofoutput scripts.\n> There can be many different descriptor fragments and functions.\n> This document describes the general syntax for descriptors, descriptor\n> checksums, and common expressions.\n> \n> ==Copyright==\n> \n> This BIP is licensed under the BSD 2-clause license.\n> \n> ==Motivation==\n> \n> Bitcoin wallets traditionally have stored a set of keys which are later\n> serialized and mutated to produce the output scripts that the wallet\n> watches and the addresses it provides to users.\n> Typically backups have consisted of solely the private keys, nowadays\n> primarily in the form of BIP 39 mnemonics.\n> However this backup solution is insuffient, especially since the\n> introduction of Segregated Witness which added new output types.\n> Given just the private keys, it is not possible for restored wallets to\n> know which kinds of output scripts and addresses to produce.\n> This has lead to incompatibilities between wallets when restoring a\n> backup or exporting data for a watch only wallet.\n> \n> Further complicating matters are BIP 32 derivation paths.\n> Although BIPs 44, 49, and 84 have specified standard BIP 32 derivation\n> paths for different output scripts and addresses, not all wallets\n> support them nor use those derivation paths.\n> The lack of derivation path information in these backups and exports\n> leads to further incompatibilities between wallets.\n> \n> Current solutions to these issues have not been generic and can be\n> viewed as being layer violations.\n> Solutions such as introducing different version bytes for extended key\n> serialization both are a layer violation (key derivation should be\n> separate from script type meaning) and specific only to a particular\n> derivation path and script type.\n> \n> Output Script Descriptors introduces a generic solution to these issues.\n> Script types are specified explicitly through the use of Script Expressions.\n> Key derivation paths are specified explicitly in Key Expressions.\n> These allow for creating wallet backups and exports which specify the\n> exact scripts, subscripts (redeemScript, witnessScript, etc.), and keys\n> to produce.\n> With the general structure specified in this BIP, new Script Expressions\n> can be introduced as new script types are added.\n> Lastly, the use of common terminology and existing standards allow for\n> Output Script Descriptors to be engineer readable so that the results\n> can be understood at a glance.\n> \n> ==Specification==\n> \n> Descriptors consist of several types of expressions.\n> The top level expression is a <tt>SCRIPT</tt>.\n> This expression may be followed by <tt>#CHECKSUM</tt>, where\n> <tt>CHECKSUM</tt> is an 8 character alphanumeric descriptor checksum.\n> \n> ===Script Expressions===\n> \n> Script Expressions (denoted <tt>SCRIPT</tt>) are expressions which\n> correspond directly with a Bitcoin script.\n> These expressions are written as functions and take arguments.\n> Such expressions have a script template which is filled with the\n> arguments correspondingly.\n> Expressions are written with a human readable identifier string with the\n> arguments enclosed with parentheses.\n> The identifier string should be alphanumeric and may include underscores.\n> \n> The arguments to a script expression are defined by that expression itself.\n> They could be a script expression, a key expression, or some other\n> expression entirely.\n> \n> ===Key Expressions===\n> \n> A common expression used as an argument to script expressions are key\n> expressions (denoted <tt>KEY</tt>).\n> These represent a public or private key and, optionally, information\n> about the origin of that key.\n> Key expressions can only be used as arguments to script expressions.\n> \n> Key expressions consist of:\n> * Optionally, key origin information, consisting of:\n> ** An open bracket <tt>[</tt>\n> ** Exactly 8 hex characters for the fingerprint of the key where the\n> derivation starts (see BIP 32 for details)\n> ** Followed by zero or more <tt>/NUM</tt> or <tt>/NUM'</tt>  path\n> elements to indicate the unhardened or hardened derivation steps between\n> the fingerprint and the key that follows.\n> ** A closing bracket <tt>]</tt>\n> * Followed by the actual key, which is either:\n> ** A hex encoded public key, which depending the script expression, may\n> be either:\n> *** 66 hex character string beginning with <tt>02</tt> or <tt>03</tt>\n> representing a compressed public key\n> *** 130 hex character string beginning with <tt>04</tt> representing an\n> uncompressed public key\n> *** 64 hex character string representing an x-only public key\n> ** A [[https://en.bitcoin.it/wiki/Wallet_import_format|WIF]] encoded\n> private key\n> ** <tt>xpub</tt> encoded extended public key or <tt>xprv</tt> encoded\n> extended private key (as defined in BIP 32)\n> *** Followed by zero or more <tt>/NUM</tt> or <tt>/NUM'</tt> path\n> elements indicating BIP 32 derivation steps to be taken after the given\n> extended key.\n> *** Optionally followed by a single <tt>/*</tt> or <tt>/*'</tt> final\n> step to denote all direct unhardened or hardened children.\n> \n> If the <tt>KEY</tt> is a BIP 32 extended key, before output scripts can\n> be created, child keys must be derived using the derivation information\n> that follows the extended key.\n> When the final step is <tt>/*</tt> or <tt>/*'</tt>, an output script\n> will be produced for every child key index.\n> The derived key must be serialized as a compressed public key.\n> \n> In the above specification, the hardened indicator <tt>'</tt> may be\n> replaced with alternative hardnened indicators of <tt>h</tt> or <tt>H</tt>.\n> \n> ===Character Set===\n> \n> The expressions used in descriptors must only contain characters within\n> this character set so that the descriptor checksum will work.\n> \n> The allowed characters are:\n> <pre>\n> 0123456789()[],'/*abcdefgh@:$%{}\n> IJKLMNOPQRSTUVWXYZ&+-.;<=>?!^_|~\n> ijklmnopqrstuvwxyzABCDEFGH`#\"\\<space>\n> </pre>\n> Note that <tt><space></tt> on the last line is a space character.\n> \n> This character set is written as 3 groups of 32 characters in this\n> specific order so that the checksum below can identify more errors.\n> The first group are the most common \"unprotected\" characters (i.e.\n> things such as hex and keypaths that do not already have their own\n> checksums).\n> Case errors cause an offset that is a multiple of 32 while as many\n> alphabetic characters are in the same group while following the previous\n> restrictions.\n> \n> ===Checksum===\n> \n> Follwing the top level script expression is a single octothorpe\n> (<tt>#</tt>) followed by the 8 character checksum.\n> The checksum is an error correcting checksum similar to bech32.\n> \n> The checksum has the following properties:\n> * Mistakes in a descriptor string are measured in \"symbol errors\". The\n> higher the number of symbol errors, the harder it is to detect:\n> ** An error substituting a character from\n> <tt>0123456789()[],'/*abcdefgh@:$%{}</tt> for another in that set always\n> counts as 1 symbol error.\n> *** Note that hex encoded keys are covered by these characters. Extended\n> keys (<tt>xpub</tt> and <tt>xprv</tt>) use other characters too, but\n> also have their own checksum mechansim.\n> *** <tt>SCRIPT</tt> expression function names use other characters, but\n> mistakes in these would generally result in an unparsable descriptor.\n> ** A case error always counts as 1 symbol error.\n> ** Any other 1 character substitution error counts as 1 or 2 symbol errors.\n> * Any 1 symbol error is always detected.\n> * Any 2 or 3 symbol error in a descriptor of up to 49154 characters is\n> always detected.\n> * Any 4 symbol error in a descriptor of up to 507 characters is always\n> detected.\n> * Any 5 symbol error in a descriptor of up to 77 characters is always\n> detected.\n> * Is optimized to minimize the chance of a 5 symbol error in a\n> descriptor up to 387 characters is undetected\n> * Random errors have a chance of 1 in 2<super>40</super> of being\n> undetected.\n> \n> The checksum itself uses the same character set as bech32:\n> <tt>qpzry9x8gf2tvdw0s3jn54khce6mua7l</tt>\n> \n> Valid descriptor strings with a checksum must pass the criteria for\n> validity specified by the Python3 code snippet below.\n> The function <tt>descsum_check</tt> must return true when its argument\n> <tt>s</tt> is a descriptor consisting in the form <tt>SCRIPT#CHECKSUM</tt>.\n> \n> <pre>\n> INPUT_CHARSET =\n> \"0123456789()[],'/*abcdefgh@:$%{}IJKLMNOPQRSTUVWXYZ&+-.;<=>?!^_|~ijklmnopqrstuvwxyzABCDEFGH`#\\\"\\\\\n> \"\n> CHECKSUM_CHARSET = \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"\n> GENERATOR = [0xf5dee51989, 0xa9fdca3312, 0x1bab10e32d, 0x3706b1677a,\n> 0x644d626ffd]\n> \n> def descsum_polymod(symbols):\n>     \"\"\"Internal function that computes the descriptor checksum.\"\"\"\n>     chk = 1\n>     for value in symbols:\n>         top = chk >> 35\n>         chk = (chk & 0x7ffffffff) << 5 ^ value\n>         for i in range(5):\n>             chk ^= GENERATOR[i] if ((top >> i) & 1) else 0\n>     return chk\n> \n> def descsum_expand(s):\n>     \"\"\"Internal function that does the character to symbol expansion\"\"\"\n>     groups = []\n>     symbols = []\n>     for c in s:\n>         if not c in INPUT_CHARSET:\n>             return None\n>         v = INPUT_CHARSET.find(c)\n>         symbols.append(v & 31)\n>         groups.append(v >> 5)\n>         if len(groups) == 3:\n>             symbols.append(groups[0] * 9 + groups[1] * 3 + groups[2])\n>             groups = []\n>     if len(groups) == 1:\n>         symbols.append(groups[0])\n>     elif len(groups) == 2:\n>         symbols.append(groups[0] * 3 + groups[1])\n>     return symbols\n> \n> def descsum_check(s):\n>     \"\"\"Verify that the checksum is correct in a descriptor\"\"\"\n>     if s[-9] != '#':\n>         return False\n>     if not all(x in CHECKSUM_CHARSET for x in s[-8:]):\n>         return False\n>     symbols = descsum_expand(s[:-9]) + [CHECKSUM_CHARSET.find(x) for x\n> in s[-8:]]\n>     return descsum_polymod(symbols) == 1\n> </pre>\n> \n> This implements a BCH code that has the properties described above.\n> The entire descriptor string is first processed into an array of symbols.\n> The symbol for each character is its position within its group.\n> After every 3rd symbol, a 4th symbol is inserted which represents the\n> group numbers combined together.\n> This means that a change that only affects the position within a group,\n> or only a group number change, will only affect a single symbol.\n> \n> To construct a valid checksum given a script expression, the code below\n> can be used:\n> \n> <pre>\n> def descsum_create(s):\n>     \"\"\"Add a checksum to a descriptor without\"\"\"\n>     symbols = descsum_expand(s) + [0, 0, 0, 0, 0, 0, 0, 0]\n>     checksum = descsum_polymod(symbols) ^ 1\n>     return s + '#' + ''.join(CHECKSUM_CHARSET[(checksum >> (5 * (7 -\n> i))) & 31] for i in range(8))\n> \n> </pre>\n> \n> ==Backwards Compatibility==\n> \n> Output script descriptors are an entirely new language which is not\n> compatible with any existing software.\n> However many components of the expressions reuse encodings and\n> serializations defined by previous BIPs.\n> \n> Output script descriptors are designed for future extension with further\n> fragment types and new script expressions.\n> These will be specified in additional BIPs.\n> \n> ==Reference Implemntation==\n> \n> Descriptors have been implemented in Bitcoin Core since version 0.17.\n> \n> ---\n> \n> <pre>\n>   BIP: bip-descriptors-segwit\n>   Layer: Applications\n>   Title: segwit Output Script Descriptors\n>   Author: Pieter Wuille <pieter at wuille.net>\n>           Andrew Chow <andrew at achow101.com>\n>   Comments-Summary: No comments yet.\n>   Comments-URI:\n> https://github.com/bitcoin/bips/wiki/Comments:BIP-descriptors-segwit\n>   Status: Draft\n>   Type: Informational\n>   Created: 2021-06-27\n>   License: BSD-2-Clause\n> </pre>\n> \n> ==Abstract==\n> \n> This document specifies <tt>wpkh()</tt>, and <tt>wsh()</tt> output\n> script descriptors.\n> <tt>wpkh()</tt> descriptors take a key and produces a P2WPKH output script.\n> <tt>wsh()</tt> descriptors take a script and produces a P2WSH output script.\n> \n> ==Copyright==\n> \n> This BIP is licensed under the BSD 2-clause license.\n> \n> ==Motivation==\n> \n> Segregated Witness added 2 additional standard output script formats:\n> P2WPKH and P2WSH.\n> These expressions allow specifying those formats as a descriptor.\n> \n> ==Specification==\n> \n> Two new script expressions are defined: <tt>wpkh()</tt>, and <tt>wsh()</tt>.\n> \n> ===<tt>wpkh()</tt>===\n> \n> The <tt>wpkh(KEY)</tt> expression can be used as a top level expression,\n> or inside of a <tt>sh()</tt> descriptor.\n> It takes a single key expression as an argument and produces a P2WPKH\n> output script.\n> Only keys which are/has compressed public keys can be contained in a\n> <tt>wpkh()</tt> expression.\n> \n> The output script produced is:\n> <pre>\n> OP_0 <KEY_hash160>\n> </pre>\n> \n> ===<tt>wsh()</tt>===\n> \n> The <tt>wsh(SCRIPT)</tt> expression can be used as a top level\n> expression, or inside of a <tt>sh()</tt> descriptor.\n> It takes a single script expression as an argument and produces a P2WSH\n> output script.\n> <tt>wsh()</tt> expressions also create a witnessScript which is required\n> in order to spend outputs which use its output script.\n> This redeemScript is the output script produced by the <tt>SCRIPT</tt>\n> argument to <tt>wsh()</tt>.\n> Any key expression found in any script expression contained by a\n> <tt>wsh()</tt> expression must only produce compresed public keys.\n> \n> The output script produced is:\n> <pre>\n> OP_0 <SCRIPT_sha256>\n> </pre>\n> \n> ==Test Vectors==\n> \n> TBD\n> \n> ==Backwards Compatibility==\n> \n> <tt>wpkh()</tt>, and <tt>wsh()</tt> descriptors use the format and\n> general operation specified in\n> [[bip-descriptor-general.mediawiki|bip-descriptor-general]].\n> As these are a wholly new descriptors, they are not compatible with any\n> implementation.\n> However the scripts produced are standard scripts so existing software\n> are likely to be familiar with them.\n> \n> ==Reference Implemntation==\n> \n> <tt>wpkh()</tt>, and <tt>wsh()</tt> descriptors have been implemented in\n> Bitcoin Core since version 0.17.\n> \n> ---\n> \n> <pre>\n>   BIP: bip-descriptors-non-segwit\n>   Layer: Applications\n>   Title: Non-segwit Output Script Descriptors\n>   Author: Pieter Wuille <pieter at wuille.net>\n>           Andrew Chow <andrew at achow101.com>\n>   Comments-Summary: No comments yet.\n>   Comments-URI:\n> https://github.com/bitcoin/bips/wiki/Comments:BIP-descriptors-non-segwit\n>   Status: Draft\n>   Type: Informational\n>   Created: 2021-06-27\n>   License: BSD-2-Clause\n> </pre>\n> \n> ==Abstract==\n> \n> This document specifies <tt>pk()</tt>, <tt>pkh()</tt>, and <tt>sh()</tt>\n> output script descriptors.\n> <tt>pk()</tt> descriptors take a key and produces a P2PK output script.\n> <tt>pkh()</tt> descriptors take a key and produces a P2PKH output script.\n> <tt>sh()</tt> descriptors take a script and produces a P2SH output script.\n> \n> ==Copyright==\n> \n> This BIP is licensed under the BSD 2-clause license.\n> \n> ==Motivation==\n> \n> Prior to the activation of Segregated Witness, there were 3 main\n> standard output script formats: P2PK, P2PKH, and P2SH.\n> These expressions allow specifying those formats as a descriptor.\n> \n> ==Specification==\n> \n> Three new script expressions are defined: <tt>pk()</tt>, <tt>pkh()</tt>,\n> and <tt>sh()</tt>.\n> \n> ===<tt>pk()</tt>===\n> \n> The <tt>pk(KEY)</tt> expression can be used in any context or level of a\n> descriptor.\n> It takes a single key expression as an argument and produces a P2PK\n> output script.\n> Depending on the higher level descriptors, there may be restrictions on\n> the type of public keys that can be included.\n> Such restrictions will be specified by those descriptors.\n> \n> The output script produced is:\n> <pre>\n> <KEY> OP_CHECKSIG\n> </pre>\n> \n> ===<tt>pkh()</tt>===\n> \n> The <tt>pkh(KEY)</tt> expression can be used as a top level expression,\n> or inside of either a <tt>sh()</tt> or <tt>wsh()</tt> descriptor.\n> It takes a single key expression as an argument and produces a P2PKH\n> output script.\n> Depending on the higher level descriptors, there may be restrictions on\n> the type of public keys that can be included.\n> Such restrictions will be specified by those descriptors.\n> \n> The output script produced is:\n> <pre>\n> OP_DUP OP_HASH160 <KEY_hash160> OP_EQUALVERIFY OP_CHECKSIG\n> </pre>\n> \n> ===<tt>sh()</tt>===\n> \n> The <tt>sh(SCRIPT)</tt> expression can only be used as a top level\n> expression.\n> It takes a single script expression as an argument and produces a P2SH\n> output script.\n> <tt>sh()</tt> expressions also create a redeemScript which is required\n> in order to spend outputs which use its output script.\n> This redeemScript is the output script produced by the <tt>SCRIPT</tt>\n> argument to <tt>sh()</tt>.\n> \n> The output script produced is:\n> <pre>\n> OP_HASH160 <SCRIPT_hash160> OP_EQUAL\n> </pre>\n> \n> ==Test Vectors==\n> \n> TBD\n> \n> ==Backwards Compatibility==\n> \n> <tt>pk()</tt>, <tt>pkh()</tt>, and <tt>sh()</tt> descriptors use the\n> format and general operation specified in\n> [[bip-descriptor-general.mediawiki|bip-descriptor-general]].\n> As these are a wholly new descriptors, they are not compatible with any\n> implementation.\n> However the scripts produced are standard scripts so existing software\n> are likely to be familiar with them.\n> \n> ==Reference Implemntation==\n> \n> <tt>pk()</tt>, <tt>pkh()</tt>, and <tt>sh()</tt> descriptors have been\n> implemented in Bitcoin Core since version 0.17.\n> \n> ---\n> \n> <pre>\n>   BIP: bip-descriptors-tr\n>   Layer: Applications\n>   Title: tr() Output Script Descriptors\n>   Author: Pieter Wuille <pieter at wuille.net>\n>           Andrew Chow <andrew at achow101.com>\n>   Comments-Summary: No comments yet.\n>   Comments-URI:\n> https://github.com/bitcoin/bips/wiki/Comments:BIP-descriptors-tr\n>   Status: Draft\n>   Type: Informational\n>   Created: 2021-06-27\n>   License: BSD-2-Clause\n> </pre>\n> \n> ==Abstract==\n> \n> This document specifies <tt>tr()</tt> output script descriptors.\n> <tt>tr()</tt> descriptors take a key and optionally a tree of scripts\n> and produces a P2TR output script.\n> \n> ==Copyright==\n> \n> This BIP is licensed under the BSD 2-clause license.\n> \n> ==Motivation==\n> \n> Taproot added one additional standard output script format: P2TR.\n> These expressions allow specifying those formats as a descriptor.\n> \n> ==Specification==\n> \n> A new script expressions are defined: <tt>tr()</tt>.\n> A new expression is defined: Tree Expressions\n> \n> ===Tree Expression===\n> \n> A Tree Expression (denoted <tt>TREE</tt>) is an expression which\n> represents a tree of scripts.\n> The way the tree is represented in an output script is dependent on the\n> higher level expressions.\n> \n> A Tree Expression is:\n> * Any Script Expression that is allowed at the level this Tree\n> Expression is in.\n> * A pair of Tree Expressions consisting of:\n> ** An open brace <tt>{</tt>\n> ** A Tree Expression\n> ** A comma <tt>,</tt>\n> ** A Tree Expression\n> ** A closing brance <tt>}</tt>\n> \n> ===<tt>tr()</tt>===\n> \n> The <tt>tr(KEY)</tt> or <tt>tr(KEY, TREE)</tt> expression can only be\n> used as a top level expression.\n> All key expressions under any <tt>tr()</tt> expression must create\n> x-only public keys.\n> \n> <tt>tr(KEY</tt> takes a single key expression as an argument and\n> produces a P2TR output script which does not have a script path.\n> The keys produced by the key expression are used as the internal key as\n> specified by [[bip-0341.mediawiki#cite_ref-22-0|BIP 341]].\n> Specifically, \"If the spending conditions do not require a script path,\n> the output key should commit to an unspendable script path instead of\n> having no script path.\n> This can be achieved by computing the output key point as ''Q = P +\n> int(hash<sub>TapTweak</sub>(bytes(P)))G''.\"\n> \n> <pre>\n> internal_key:       lift_x(KEY)\n> 32_byte_output_key: internal_key + int(HashTapTweak(bytes(internal_key)))G\n> scriptPubKey:       OP_1 <32_byte_output_key>\n> </pre>\n> \n> <tt>tr(KEY, TREE)</tt> takes a key expression as the first argument, and\n> a tree expression as the second argument and produces a P2TR output\n> script which has a script path.\n> The keys produced by the first key expression are used as the internal\n> key as specified by\n> [[bip-0341.mediawiki#Constructing_and_spending_Taproot_outputs|BIP 341]].\n> The Tree expression becomes the Taproot script tree as described in BIP 341.\n> A merkle root is computed from this tree and combined with the internal\n> key to create the Taproot output key.\n> \n> <pre>\n> internal_key:       lift_x(KEY)\n> merkle_root:        HashTapBranch(TREE)\n> 32_byte_output_key: internal_key + int(HashTapTweak(bytes(internal_key)\n> || merkle_root))G\n> scriptPubKey:       OP_1 <32_byte_output_key>\n> </pre>\n> \n> ==Test Vectors==\n> \n> TBD\n> \n> ==Backwards Compatibility==\n> \n> <tt>tr()</tt> descriptors use the format and general operation specified\n> in [[bip-descriptor-general.mediawiki|bip-descriptor-general]].\n> As these are a wholly new descriptors, they are not compatible with any\n> implementation.\n> However the scripts produced are standard scripts so existing software\n> are likely to be familiar with them.\n> \n> Tree Expressions are largely incompatible with existing script\n> expressions due to the restrictions in those expressions.\n> As of 2021-06-27, the only allowed script expression that can be used in\n> a tree expression is <tt>pk()</tt>.\n> However there will be future BIPs that specify script expressions that\n> can be used in tree expressions.\n> \n> ==Reference Implemntation==\n> \n> <tt>tr()</tt> descriptors have been implemented in Bitcoin Core since\n> version 22.0.\n> \n> ---\n> \n> <pre>\n>   BIP: bip-descriptors-multi\n>   Layer: Applications\n>   Title: Multisig Output Script Descriptors\n>   Author: Pieter Wuille <pieter at wuille.net>\n>           Andrew Chow <andrew at achow101.com>\n>   Comments-Summary: No comments yet.\n>   Comments-URI:\n> https://github.com/bitcoin/bips/wiki/Comments:BIP-descriptors-multi\n>   Status: Draft\n>   Type: Informational\n>   Created: 2021-06-27\n>   License: BSD-2-Clause\n> </pre>\n> \n> ==Abstract==\n> \n> This document specifies <tt>multi()</tt>, and <tt>sortedmulti()</tt>\n> output script descriptors.\n> Both functions take a threshold and one or more public keys and produce\n> a multisig output script.\n> <tt>multi()</tt> specifies the public keys in the output script in the\n> order given in the descriptor while <tt>sortedmulti()</tt> sorts the\n> public keys lexicographically when the output script is produced.\n> \n> ==Copyright==\n> \n> This BIP is licensed under the BSD 2-clause license.\n> \n> ==Motivation==\n> \n> The most common complex script used in Bitcoin is a threshold multisig.\n> These expressions allow specifying multisig scripts as a descriptor.\n> \n> ==Specification==\n> \n> Two new script expressions are defined: <tt>multi()</tt>, and\n> <tt>sortedmulti()</tt>.\n> Both expressions produce the scripts of the same template and take the\n> same arguments.\n> They are written as <tt>multi(k,KEY_1,KEY_2,...,KEY_n)</tt>.\n> <tt>k</tt> is the threshold - the number of keys that must sign the\n> input for the script to be valid.\n> <tt>KEY_1,KEY_2,...,KEY_n</tt> are the key expressions for the multisig.\n> <tt>k</tt> must be less than or equal to <tt>n<tt>.\n> \n> <tt>multi()</tt> and <tt>sortedmulti()</tt> expressions can be used as a\n> top level expression, or inside of either a <tt>sh()</tt> or\n> <tt>wsh()</tt> descriptor.\n> Depending on the higher level descriptors, there may be restrictions on\n> the type of public keys that can be included.\n> \n> Depending on the higher level descriptors, there are also restrictions\n> on the number of keys that can be present, i.e. the maximum value of\n> <tt>n</tt>.\n> When used at the top level, there can only be at most 3 keys.\n> When used inside of a <tt>sh()</tt> expression, there can only be most\n> 15 compressed public keys (this is limited by the P2SH script limit).\n> Otherwise the maximum number of keys is 20.\n> \n> The output script produced also depends on the value of <tt>k</tt>. If\n> <tt>k</tt> is less than or equal to 16:\n> <pre>\n> OP_k KEY_1 KEY_2 ... KEY_n OP_CHECKMULTISIG\n> </pre>\n> \n> if <tt>k</tt> is greater than 16:\n> <pre>\n> k KEY_1 KEY_2 ... KEY_n OP_CHECKMULTISIG\n> </pre>\n> \n> ===<tt>sortedmulti()</tt>===\n> \n> The only change for <tt>sortedmulti()</tt> is that the keys are sorted\n> lexicographically prior to the creation of the output script.\n> This sorting is on the keys that are to be put into the output script,\n> i.e. after all extended keys are derived.\n> \n> ===Multiple Extended Keys</tt>===\n> \n> When one or more the key expressions in a <tt>multi()</tt> or\n> <tt>sortedmulti()</tt> expression are extended keys, the derived keys\n> use the same child index.\n> This changes the keys in lockstep and allows for output scripts to be\n> indexed in the same way that the derived keys are indexed.\n> \n> ==Test Vectors==\n> \n> TBD\n> \n> ==Backwards Compatibility==\n> \n> <tt>multi()</tt>, and <tt>sortedmulti()</tt> descriptors use the format\n> and general operation specified in\n> [[bip-descriptor-general.mediawiki|bip-descriptor-general]].\n> As these are a wholly new descriptors, they are not compatible with any\n> implementation.\n> However the scripts produced are standard scripts so existing software\n> are likely to be familiar with them.\n> \n> ==Reference Implemntation==\n> \n> <tt>multi()</tt>, and <tt>multi()</tt> descriptors have been implemented\n> in Bitcoin Core since version 0.17.\n> \n> ---\n> \n> <pre>\n>   BIP: bip-descriptors-combo\n>   Layer: Applications\n>   Title: combo() Output Script Descriptors\n>   Author: Pieter Wuille <pieter at wuille.net>\n>           Andrew Chow <andrew at achow101.com>\n>   Comments-Summary: No comments yet.\n>   Comments-URI:\n> https://github.com/bitcoin/bips/wiki/Comments:BIP-descriptors-combo\n>   Status: Draft\n>   Type: Informational\n>   Created: 2021-06-27\n>   License: BSD-2-Clause\n> </pre>\n> \n> ==Abstract==\n> \n> This document specifies <tt>combo()</tt> output script descriptors.\n> These take a key and produce P2PK, P2PKH, P2WPKH, and P2SH-P2WPKH output\n> scripts if applicable to the key.\n> \n> ==Copyright==\n> \n> This BIP is licensed under the BSD 2-clause license.\n> \n> ==Motivation==\n> \n> In order to make the transition from traditional key based wallets to\n> descriptor based wallets easier, it is useful to be able to take a key\n> and produce the scripts which have traditionally been produced by wallet\n> software.\n> \n> ==Specification==\n> \n> A new top level script expression is defined: <tt>combo(KEY)</tt>.\n> This expression can only be used as a top level expression.\n> It takes a single key expression as an argument and produces either 2 or\n> 4 output scripts, depending on the key.\n> A <tt>combo()</tt> expression always produces a P2PK and P2PKH script,\n> the same as putting the key in both a <tt>pk()</tt> and a <tt>pkh()</tt>\n> expression.\n> If the key is/has a compressed public key, then P2WPKH and P2SH-P2WPKH\n> scripts are also produced, the same as putting the key in both a\n> <tt>wpkh()</tt> and <tt>sh(wpkh())</tt> expression.\n> \n> ==Test Vectors==\n> \n> TBD\n> \n> ==Backwards Compatibility==\n> \n> <tt>combo()</tt> descriptors use the format and general operation\n> specified in [[bip-descriptor-general.mediawiki|bip-descriptor-general]].\n> As this is a wholly new descriptor, it is not compatible with any\n> implementation.\n> However the scripts produced are standard scripts so existing software\n> are likely to be familiar with them.\n> \n> ==Reference Implemntation==\n> \n> <tt>combo</tt> descriptors have been implemented in Bitcoin Core since\n> version 0.17.\n> \n> ---\n> \n> <pre>\n>   BIP: bip-descriptors-encap\n>   Layer: Applications\n>   Title: raw() and addr() Output Script Descriptors\n>   Author: Andrew Chow <andrew at achow101.com>\n>           Pieter Wuille <pieter at wuille.net>\n>   Comments-Summary: No comments yet.\n>   Comments-URI:\n> https://github.com/bitcoin/bips/wiki/Comments:BIP-descriptors-raw\n>   Status: Draft\n>   Type: Informational\n>   Created: 2021-06-27\n>   License: BSD-2-Clause\n> </pre>\n> \n> ==Abstract==\n> \n> This document specifies <tt>raw()</tt> and <tt>addr()</tt> output script\n> descriptors.\n> <tt>raw()</tt> encapsulates a raw script as a descriptor.\n> <tt>addr()</tt> encapsulates an address as a descriptor.\n> \n> ==Copyright==\n> \n> This BIP is licensed under the BSD 2-clause license.\n> \n> ==Motivation==\n> \n> In order to make descriptors maximally compatible with scripts in use\n> today, it is useful to be able to wrap any arbitrary output script or an\n> address into a descriptor.\n> \n> ==Specification==\n> \n> Two new script expressions are defined: <tt>raw()</tt> and <tt>addr()</tt>.\n> \n> ===<tt>raw()</tt>===\n> \n> The <tt>raw(HEX)</tt> expression can only be used as a top level descriptor.\n> As the argument, it takes a hex string representing a Bitcoin script.\n> The output script produced by this descriptor is the script represented\n> by <tt>HEX</tt>.\n> \n> ===<tt>addr()</tt>===\n> \n> The <tt>addr(ADDR)</tt> expression can only be used as a top level\n> descriptor.\n> It takes an address as its single argument.\n> The output script produced by this descriptor is the output script\n> produced by the address <tt>ADDR</tt>.\n> \n> ==Test Vectors==\n> \n> TBD\n> \n> ==Backwards Compatibility==\n> \n> <tt>raw()</tt> and <tt>addr()</tt> descriptors use the format and\n> general operation specified in\n> [[bip-descriptor-general.mediawiki|bip-descriptor-general]].\n> As this is a wholly new descriptor, it is not compatible with any\n> implementation.\n> The reuse of existing Bitcoin addresses allows for this to be more\n> easily implemented.\n> \n> ==Reference Implemntation==\n> \n> <tt>raw()</tt> and <tt>addr</tt> descriptors have been implemented in\n> Bitcoin Core since version 0.17.\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210805/d32d322c/attachment-0001.sig>"
            },
            {
                "author": "Christopher Allen",
                "date": "2021-08-05T20:49:43",
                "message_text_only": "On Thu, Aug 5, 2021 at 8:07 AM Sjors Provoost via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> One thing on my wish list - for this BIP, BIP 88 (Hierarchical\n> Deterministic Path Templates) or yet another one - is to include a birth\n> date (minimum block height). E.g. tr([m/86'/0'/0']xpub.../{0-1}/*)>709631\n>\n> And then of course there's the gap limit. Perhaps we just need a\n> \"metadata\" format to go along with descriptors to track the birth data, gap\n> limit and anything else you need (nonce collection for musig2 setup?). E.g.\n> a simple dictionary: tr([m/86'/0'/0']xpub.../{0-1}/*){dob:709631,gap:1000}\n>\n\nThe UR standards we use in Airgap Wallet Community for interoperability\n(currently used by a number of recent wallets for airgap PSBT via animated\nQR) leverages CBOR's tagging capability, and thus explicitly supports\nmetadata. In particular the spec reference code support optional seed\nbirthdate as some wallet vendors really wanted that metadata.\n\nIt would be trivial to support it for hd-keys, and if gap is important, we\ncould also easily add this to the hd-keys spec as well. That is part of the\nreason why use CBOR for the underlying binary encoding is tagging lets\nus add important metadata. The UR standards themselves adds to binary CBOR\nencoding a very efficient transport via QRs or URLs that leverage native QR\ncompression.\n\nSee:\n* Video: [Blockchain Commons Technology Overview](\nhttps://www.youtube.com/watch?v=RYgOFSdUqWY)\n* Articles: [URs: An Overview](Docs/ur-1-overview.md)\n  * [A Guide to Using URs for Key Material](Docs/ur-2-keys.md)\n  *[A Guide to Using URs for SSKRs](Docs/ur-3-sskrs.md)**\n  * [A Guide to Using UR Request & Response](Docs/ur-99-request-response.md)\n* Specs:\n  * [Research 2020-05 - Uniform Resources (UR): Encoding Structured Binary\nData for Transport in URIs and QR Codes](\nhttps://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2020-005-ur.md\n)\n  * [Reserach 2020 - UR Type Definition for Hierarchical Deterministic (HD)\nKeys](\nhttps://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2020-007-hdkey.md\n)\n\nIf you have questions about these, drop by the Airgapped Wallet Community\non GitHub at https://github.com/BlockchainCommons/Airgapped-Wallet-Community\n\n-- Christopher Allen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210805/9bc986ff/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP Proposals for Output Script Descriptors",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Sjors Provoost",
                "Christopher Allen"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 36583
        }
    },
    {
        "title": "[bitcoin-dev] Boost Bitcoin circulation, Million Transactions Per Second with stronger privacy",
        "thread_messages": [
            {
                "author": "raymo at riseup.net",
                "date": "2021-08-08T09:11:42",
                "message_text_only": "Fine tuning Sabu in order to minimize the protocol risks\n\nAfter representing Sabu protocol \nhere\n(https://raymo-49157.medium.com/time-to-boost-bitcoin-circulation-million-transactions-per-second-and-privacy-1eef8568d180)\n\nand answer some comments and critics here\n(https://raymo-49157.medium.com/scaling-bitcoin-by-sabu-protocol-risks-and-benefits-62157f8a664e),\n\nI dedicated some days to tuning the Sabu transaction criteria in order\nto reduce the risks either for issuers or creditors. After that fine\ntuning, most of risks were decreased dramatically. In this post I\u2019ll\nrepresent these details. For whom may forget about how Sabu protocol\nwork, the core points are repeated for concept recall.\n\nWhy should we use Sabu protocol?\nThe main goal of Sabu is \u201cboosting Bitcoin C2C circulation\u201d by\ndistributing it between far more people. The protocol incentivizes the\nsmall Bitcoin owners (people who has a tenth of Bitcoin or less) to sell\nfew Satoshi (4 or 5 dollar or so) in person with no KYC due to Bitcoin\nethos and earn small transaction fees for each transaction. This\nmovement will end up to 10x or more bigger Bitcoin users, which\ndefinitely improves Bitcoin\u2019s community and its proper ecosystem.\n\nHow Bitcoin transaction work?\nOwning Bitcoin, means having some UTXO (recorded in Bitcoin blockchain)\nunder your control. That is, you can sign that UTXO to prove you are the\nlegitimate owner of that money. Thus, if you want to spend your\nBitcoins, you create a transaction by which sign your under-controlled\nUTXO(s) and represent your desire to transfer this ownership to the\nother person. This transaction is a document that issued by you and\nprovides a legitimate order for this money transfer. In order to execute\nthis money transfer, you need to broadcast your signed document to\nBitcoin network aimed to record it in Bitcoin blockchain, otherwise, no\nmoney transfer has taken place. After recording this transaction in\nBitcoin blockchain, the transfer is settled and \"everyone\" will be aware\nof the new owner(s) of that particular spent coins.\n\nHow Sabu protocol work?\nYou -as a UTXO owner- are an \"issuer\", and always can issue a document\n(AKA transaction) by which you represent your will to transfer some of\nyour UTXOs to others. Thus, Sabu is a non-custodial protocol. As long as\nthis debt document is not registered in the Bitcoin blockchain, it is\nnothing more than a liability, i.e., you owe some Bitcoins to someone\nelse. That guy naming her/him \"creditor\" payed money to you or provided\ngoods or services for you, in exchange of this debt-document. Thus s/he\nhas a copy of this transaction in her/his wallet. The issuer or creditor\nalways can send this transaction to Bitcoin blockchain network aimed to\nrecord this money transformation in Bitcoin blockchain, or keep this\ntransaction in wallet. But due to the high transaction fee on the\nBitcoin blockchain and the insignificance of the amount transferred (a\nfew Dollars), they will not send the document to the Bitcoin network,\ninstead prefers to use this document as a payment method and exchange\nthese documents in Sabu protocol and in an off-chain manner.\nWhen the creditor wants to spend his money, his wallet will send a\nrequest to the issuer\u2019s wallet and ask it to transfer the issuer\u2019s\nliability to another creditor. The issuer prepares a new transaction in\nwhich issuer owes the new creditor(s), and delivers this new transaction\nto both old and new creditors.\nThe issuers earn small Sabu-transaction-fee per each money transfer (one\nor two Sat per transaction). Millions of issuers and creditors are\nexchanging these documents (transactions) in a peer-to-peer network\ncontinually, with no central authority. There is no blockchain nor\npublic ledger.\nAfter each dealing, the issuer cancels the old transaction and creates a\nnew document, and updates the creditor balances. These documents will be\nin circulation between issuers and creditors in the Sabu network forever\nmeanwhile less than one percent of these transactions will be recorded\non the Bitcoin blockchain.\nEither issuers or creditors in order to use Sabu protocol need to\ninstall Sabu mobile wallet (called Gazin) and start to deal. That is all\nthey need. No technical skill or extra cost needed.\n\nHow Sabu prevents frauds?\nThe main mechanism of the system against fraud is the un-profitability\nof fraud in terms of economic benefits. In other words, all of malicious\nactivities will end up in losing money of attacker.\nIn short, the Sabu anti-fraud system works like that. The issuer always\ncreates and signs a transaction pair.  The Main Transaction which\nrepresents the real amount of outputs. And the Guarantee Transaction\nwhich pays relatively higher Bitcoin-transaction-fee. This fee increment\nis obtained by cutting from the issuer and creditor outputs in Main\nTransaction.\nCheck out this simple transaction to learn more about how the system\nworks.\nConsider Alice as an issuer. She owns a UTXO worth 20,000 Satoshi. So,\nshe can spend it by create a transaction and sign it and broadcast it to\nBitcoin network.\nSuppose Bob (as a creditor) pays Alice 5 dollars cash, and buys 12,000\nSatoshi from Alice in exchange.\nAlice gets this 5$ and prepare a Main transaction that represents this\nliability of Alice to Bob.\n\nMain Transaction (20,000 Sat input):\n* Bob (creditor): 9,000 Sat (the real credit of Bob is 12,000, but Bob\nhas to pay 3,000 as BTC fee)\n* Alice (issuer): 6,000 Sat\n* BTC Fee: 5,000 Sat (2,000 from Alice + 3,000 from Bob)\nThis is a valid transaction and both Bob and/or Alice can send it to\nBitcoin network, but none of them are interested in doing so. Because\nthey will lose 5,000 Satoshi of their own money as Bitcoin transaction\nfee.\n\nAlongside this transaction Alice (the issuer) has to create the\nGuarantee Transaction as well and deliver it to Bob. Otherwise, Bob will\nnot consider the deal completed. The Guarantee Transaction is another\nvalid Bitcoin transaction. It is created based on Main Transaction and\nwill cut a part of Bob and Alice money in favor of transaction fee.\n\nGuarantee Transaction (20,000 Sat input):\n* Bob (creditor): 9,000 \u2013 80.77%*9,000 = 9,000 \u2013 7,260 = 1,740 Sat\n* Alice (issuer): 6,000 \u2013 58%*6,000 = 6,000 \u2013 3,480 = 2,520 Sat\n* BTC Fee: 5,000 Sat (2,000 from Alice + 3,000 from Bob) + 7,260 (from\nBob) + 3,480 (from Al-ice) = 15,739 Sat\n\nThe Guarantee Transaction applies when the issuer does not live up to\nits promise and intends to spend the promised UTXO(s) in a way other\nthan that agreed upon. We already knew the fact that Sabu is not a\ncustodial solution, neither a M of N signature schema. As a result, the\nUTXO owner always can spend the already promised UTXO(s) in Sabu\nprotocol or out of Sabu on Bitcoin blockchain, Contrary to what was\npromised.\nWhen the Alice (issuer) breaks such a promise and sends the fraudulent\ntransaction to the Bitcoin network, Bob's wallet realizes that she\n(issuer) is spending the promised UTXO(s) and it sends the Guarantee\nTransaction(s) to the network as a last resort. The miners will face two\n(or more) transactions which are spending same UTXO(s), but one of them\nis paying notably higher Bitcoin transaction fee, thus they chose the\nhighest fee payer transaction, which is the Guarantee Transaction. The\nminer will put the Guarantee Transaction in next block and reject the\nrest double-spend transactions. Certainly, poor Bob cannot recoup all\nhis Satoshis. But he can retrieve a portion of his money and forces\nAlice to lose some of her money as well. tit for tat!\nBecause of this mechanism, the issuer will try to not cheat on creditor.\n\nBy the way there are some attacks that have very small chance to succeed\nbut the risk to reward ratio for these scenarios are too high to be\nconsidered as a real possible attack threat. I will review them a little\nlater in this post.\n\nWhat are the advantages of Sabu over Lightning?\nThere are four benefits to using Sabu.\nCost: In Sabu unlike Lightning, the transaction parties do not need to\nopen a channel and consequently they do not need to close it. Therefore,\nthey do not need to pay Bitcoin transaction fees two times. The\ntransaction parties will pay small Sabu-transaction-fee per each\ntransaction to the issuer because of creating and signing new\ntransaction. Every Sabu user can be an issuer (something like Lightning\nnode) and earn Bitcoin because of issuing credit liability document\n(pretty much like banks).\n\nEase of use:  All a user needs to use protocol is install wallet -called\nGazin- on mobile or desktop by one click. The user can be an issuer and\nissue transactions or be a creditor and buys Bitcoin or both\nsimultaneously. Users can then transfer their money to each other in\nSabu network. Every Sabu user can be a creditor and buy some Satoshi\nfrom issuer and spend it in small shopping. It seems that Bitcoiners can\nfinally buy coffee with Bitcoin without worrying about transaction fee\nor system scalability or even recording transaction forever on Bitcoin\nblockchain.\n\nPrivacy: Since the communication between nodes is PGP encrypted, and no\ntransaction will go to record on Bitcoin blockchain, the Sabu protocol\nprovides a strong privacy for transaction parties. Except sender and\nreceiver, no one will know how much Bitcoin between who was transferred.\nBillions of micro transfers will be scattered between thousands of nodes\nwithout no central control point and no transaction history recording\nand absolutely no KYC.\n\nScalability: Since the Sabu has no routing overhead and peers use the\ndirect communication it will be more scalable than Lightning.\n\nNew criteria:\n-\tEach transaction input must be 20,000 Satoshi or more.\n-\tMaximum liability in a single transaction would be 15,000 Satoshi. 14k\nfor creditor whose credit is more than 1k, so he is eligible to have\nboth MT & GT in his wallet, and 1k for the creditor without the right of\nhaving MT & GT due to his small amount of credit.\n-\tThe maximum transaction fee (for Bitcoin blockchain) for Main\nTransaction is 5,000 Satoshi. For transaction with liability less than\n4,000 Satoshi this fee would be less than 5,000 Satoshi relatively.\n-\tIn Guarantee Transaction the issuer loses 1% to 68% of his output in\nfavor of Bitcoin transaction fee depends to the liability amount. More\nliability more loss.\n-\tIn Guarantee Transaction the creditor loses 100% to 78% of his output\nin favor of Bitcoin transaction fee in reverse of the credit amount.\nMore credit less loss.\n-\tThe transaction fee (for Bitcoin blockchain) for Guarantee Transaction\nwould be transaction fee of Main Transaction plus 100% to 78% of\ncreditor\u2019s output plus 1% to 68% of issuer\u2019s output.\n-\tThe issuer has to issue both Main Transaction and Guarantee\ntransaction and deliver them to creditor.\n\nBoth issuer and creditor (sender and receiver) control these criteria\nbefore confirm the deal.\n\nFraudulent activities risk:\n\nThe griefers, - people who willing to spend time and money hurting\nsomeone else, even if they don't make a profit from it (other than\nschadenfreude). - still can hurt himself and the other party\nsimultaneously, but the damage amount is reduced dramatically.\nThe lowest amount that a griefer as a creditor can lose is 1,000 Satoshi\nto hurt the issuer 685 Satoshi (loss ratio 1.45), and the highest amount\nis losing 11,506 Satoshi to hurt issuer 4,720 Satoshi (loss ratio 2.43).\nIn any case, a griefer still has trouble finding big number of victims,\nsince the protocol is not centralized and the user\u2019s information is\nscattered among thousands of different nodes.\n\nHow can prevent the issuer from spending UTXO in a cheating way?\nThere are two possible scenarios for fraudulent issuer. First is paying\nhigh Bitcoin transaction fee, even higher than Guarantee Transaction\nfee, with the intention of placing the transaction desired by the issuer\nin the next block. Even Guarantee Transaction will cause the issuer to\nwaive part of his output in favor of Bitcoin transaction fee. Its loss\nis between 685 to 5,190 Satoshi. Therefore, carrying out this attack\nwill not be economically viable.\nThe second scenario is double spending the promised UTXO, hopping in a\nrace condition, the cheating transaction win the Guarantee Transaction.\nThe likelihood of success for this scenario is approximately 2 seconds /\n10 minutes (0.3% chance). In other word, the issuer has 0.3% chance to\nwin 10,000 Satoshi (15,000 Max liability in a transaction \u2013 5,000\nminimum transaction fee), and relatively he has 99.7% chance to lose\n4,720 Satoshi. The risk to reward ratio is too high to consider this\nscenario as a practical attack at all.\n\nWhat if issuer is miner as well?\nWhat a wicked issuer can earn from a block full of fraudulent\ntransactions or a real big batch transaction would be in maximum\nspending 10,000 promised UTXO as inputs. The issuer already got paid\nequal to 10,000 * 15,000 Satoshi from deceived creditors in fiat money\nor goods or services. He is a miner as well so the transaction fee is\nnot the case, thus we can say all the 1.5 Bitcoin is the issuer/miner\nbenefit. But a normal honest block usually makes same or more profit for\nits miner! So, what is the benefit of cheating creditors? The\nissuer/miner has to mine solely and take the risk of wasting energy for\nalmost nothing advanced a normal honest participating in network!\nIn other word, due to the small amount of inputs and outputs, spending\nthese Satoshis on any type of Bitcoin transaction is not cost effective\nin most cases.\n\nWhat if creditor is miner as well?\nThe wicked creditor in every case will lose part of his money, since he\ncan only put Main transaction or Guarantee Transaction in next block. In\nfirst case he paid unnecessary Bitcoin transaction fee. In second case\nhe paid even more unnecessary Bitcoin transaction fee.\n\nConclusion:\nTill here, after tuning the transaction parameters and the criteria of a\nsuccessful deal, seems most of the risks of Sabu protocol have been\naddressed.\nI intentionally didn\u2019t talk about BIPxxx \u201cmark/unmark promised UTXOs\u201d,\nbecause the Sabu protocol will work enough good without touching current\nBitcoin core protocol. In future, after implementing BIPxxx, the Sabu\nprotocol can remove some limitations and improve its features and\nfunctionalities.\n\n\nWhat is the next step?\nThe next step would be putting protocol in practice and developing a\nMinimum Viable Product (MVP). I am a developer and I think -for now- the\nbest technology and stack to develop the protocol and the proper mobile\nwallet would be \u201creact native\u201d. The protocol and the software will be\nopen source and under GPL v3.0. Let me know if you have alternate idea.\n\nAt the moment I cannot work full-time on this project and I need some\nhelp,\nBut I am gradually working on this project and looking forward to hear\nfrom Bitcoin real supporters.\n\nRegards\nRaymo <raymo at riseup.net> d89a49057b817be0\n\n\n\nthis post on medium.com\nhttps://raymo-49157.medium.com/fine-tuning-sabu-in-order-to-minimize-the-protocol-risks-95361dc5282b"
            },
            {
                "author": "s7r",
                "date": "2021-08-09T00:03:31",
                "message_text_only": "raymo via bitcoin-dev wrote:\n\nTL,DR: you were explained by ZmnSCPxj why this protocol will not work. \nThe possibility for just one party to sign will not work. I will explain \nagain why but in much more simpler description.\n\n\n> Check out this simple transaction to learn more about how the system\n> works.\n> Consider Alice as an issuer. She owns a UTXO worth 20,000 Satoshi. So,\n> she can spend it by create a transaction and sign it and broadcast it to\n> Bitcoin network.\n> Suppose Bob (as a creditor) pays Alice 5 dollars cash, and buys 12,000\n> Satoshi from Alice in exchange.\n> Alice gets this 5$ and prepare a Main transaction that represents this\n> liability of Alice to Bob.\n> \n> Main Transaction (20,000 Sat input):\n> * Bob (creditor): 9,000 Sat (the real credit of Bob is 12,000, but Bob\n> has to pay 3,000 as BTC fee)\n> * Alice (issuer): 6,000 Sat\n> * BTC Fee: 5,000 Sat (2,000 from Alice + 3,000 from Bob)\n> This is a valid transaction and both Bob and/or Alice can send it to\n> Bitcoin network, but none of them are interested in doing so. Because\n> they will lose 5,000 Satoshi of their own money as Bitcoin transaction\n> fee.\n> \n> Alongside this transaction Alice (the issuer) has to create the\n> Guarantee Transaction as well and deliver it to Bob. Otherwise, Bob will\n> not consider the deal completed. The Guarantee Transaction is another\n> valid Bitcoin transaction. It is created based on Main Transaction and\n> will cut a part of Bob and Alice money in favor of transaction fee.\n> \n> Guarantee Transaction (20,000 Sat input):\n> * Bob (creditor): 9,000 \u2013 80.77%*9,000 = 9,000 \u2013 7,260 = 1,740 Sat\n> * Alice (issuer): 6,000 \u2013 58%*6,000 = 6,000 \u2013 3,480 = 2,520 Sat\n> * BTC Fee: 5,000 Sat (2,000 from Alice + 3,000 from Bob) + 7,260 (from\n> Bob) + 3,480 (from Al-ice) = 15,739 Sat\n> \n> The Guarantee Transaction applies when the issuer does not live up to\n> its promise and intends to spend the promised UTXO(s) in a way other\n> than that agreed upon. We already knew the fact that Sabu is not a\n> custodial solution, neither a M of N signature schema. As a result, the\n> UTXO owner always can spend the already promised UTXO(s) in Sabu\n> protocol or out of Sabu on Bitcoin blockchain, Contrary to what was\n> promised.\n> When the Alice (issuer) breaks such a promise and sends the fraudulent\n> transaction to the Bitcoin network, Bob's wallet realizes that she\n> (issuer) is spending the promised UTXO(s) and it sends the Guarantee\n> Transaction(s) to the network as a last resort. The miners will face two\n> (or more) transactions which are spending same UTXO(s), but one of them\n> is paying notably higher Bitcoin transaction fee, thus they chose the\n> highest fee payer transaction, which is the Guarantee Transaction. The\n> miner will put the Guarantee Transaction in next block and reject the\n> rest double-spend transactions. Certainly, poor Bob cannot recoup all\n> his Satoshis. But he can retrieve a portion of his money and forces\n> Alice to lose some of her money as well. tit for tat!\n> Because of this mechanism, the issuer will try to not cheat on creditor.\n> \n> By the way there are some attacks that have very small chance to succeed\n> but the risk to reward ratio for these scenarios are too high to be\n> considered as a real possible attack threat. I will review them a little\n> later in this post.\n> \n>\n\nYou said that the guarantee transaction is created based on Main \nTransaction, how do you mean? If it is a child transaction of the Main \nTransaction it already doesn't work because Alice needs to broadcast the \n*Main Transaction* to the blockchain in order for the Guarantee \ntransaction to be accepted, and of she does this, Bob doesn't care \nbecause the transaction pays to him already the correct agreed amount. \nIf you did not mean this, still it won't work, because\n\nSimple:\n1. Alice will create transaction #3, or call it Sabu-killing-transaction \n(20,000 Sat input):\n* Alice (issuer): 15,000 Sat\n* BTC Fee: 5,000 Sat\n\nPERIOD.\n\nWhen Bob tries to broadcast the \"guarantee transaction\" he will get an \nerror: REJECTED FROM MEMPOOL, INPUTS (UTXO) ALREADY SPENT. The much \nlarger fee in the guarantee transaction will not matter. You have to \nassume a miner will violate the Bitcoin protocol and somehow drop \nSabu-killing-transaction from mempool and consider the Guarantee \ntransaction only. This is very unlikely to happen and you might also \nneed connection direct with the miners because most full nodes will not \neven accept the Guarantee transaction to their mempools in order to \nfurther broadcast it until it reaches the miners.\n\nWith the simple attack described above Alice's chance to fraud Bob are, \nfrom my point of view, 99%.\n\n(the only way to replace a transaction is Replace-By-Fee but this \nimplies the transaction that IS TO BE REPLACED has a certain flag set, \nand it is optional).\n\nGiven the Sabu-Killing-transaction comes first, Alice will of course \ncreate it without this flag set so even if you add to Sabu the \nrequirement of RBF enabled to the Guarantee transaction it will not \nwork, because it's the other way around.\n\n\nThe second question is just for an observation that it has no real \nbenefits over Lightning even if #1 wasn't true:\n\n2. The creditor (Bob) has to leave his wallet running 24x7 and ensure he \nis connected to the internet, otherwise if he loses connection to the \ninternet or energy supply, Alice attack will succeed entirely with 100% \nchances. So this means Bob needs to always be online like forever and ever.\n\nThe 3rd one is hypothetical and you don't even have to answer it:\n3. How does Bob (first creditor) spend the coins received / how does Bob \nbecome an issuer himself in relation to Dave (another creditor)? What \nhappens if Alice tries to fraud Bob after Bob spent its Sabu credit to \nDave? Dave has to hold all parent \"guarantee transactions\" and watch the \nnetwork for any potential fraudulent transactions that cancels his credit?"
            },
            {
                "author": "raymo at riseup.net",
                "date": "2021-08-09T16:22:29",
                "message_text_only": "Hi s7r,\nI already answered to ZmnSCPxj's comments.\n\nLet\u2019s go to yours.\n\n> If it is a child transaction of the Main Transaction\nSorry for my shortcoming in English, because it caused the\nmisunderstanding of proposal.\nThere is not any relation between Main Transaction and Guarantee\ntransaction. when I said \u201cthe Guarantee Transaction is created based on\nMain Transaction\u201d I was intended only the numbers. I mean the output\namounts of Guarantee Transaction are calculated relatively based on Main\nTransaction output amounts, in order to make a Guarantee Transaction\nwith relatively higher transaction fee. So, either of MT or GT can be\nbroadcasted or toke place in next block independently.  \n\n> When Bob tries to broadcast the \"guarantee transaction\" he will get an error: \n> REJECTED FROM MEMPOOL, INPUTS (UTXO) ALREADY SPENT\nHere is the part which I am not sure you are right about it. I do not\nknow in detail and I'm not sure how miners will react to the two\ndouble-spend transactions and which one they will prefer.\nWill they use the first seen transaction for block pre-image, or will\nuse the transaction with higher transaction fee?\nWe need the help of Bitcoin core developers to clarify this transaction\nselection mechanism. \nIf miners prefer the highest fee my scenario still is valid. But if\nminers always keep the first transaction received and drop subsequent\ntransactions, I have three different solution to solve that I will\nexplain in later posts.\n\n> 2. The creditor (Bob) has to leave his wallet running 24x7 and ensure he is connected \n> to the internet, otherwise if he loses connection to the internet or energy supply, \n> Alice attack will succeed entirely with 100% chances. \n> So this means Bob needs to always be online like forever and ever.\nSomehow you are right. Definitely Bob can delegate this task to a\ndoc-watcher, pretty much like watch-tower in Lightning, but due to the\nsmall amount of creditor's credits and the fact that this amount is\nscattered among many different issuers, I removed this part from the\noriginal design of Sabu architecture.\nBTW major creditors, such as stores that receives debt-documents worth\nthousands of dollars a day, should (and better say must) always be\nonline to protect their money. This job also creates a safe margin for\nother creditors.\nIMHO at the moment the protocol is good enough to start, but we can\nalways talk about improving the protocol.\n\n> The 3rd one is hypothetical and you don't even have to answer it:\n> 3. How does Bob (first creditor) spend the coins received / \n> how does Bob become an issuer himself in relation to Dave (another creditor)? \n> What happens if Alice tries to fraud Bob after Bob spent its Sabu credit to Dave? \n> Dave has to hold all parent \"guarantee transactions\" and watch the network for \n> any potential fraudulent transactions that cancels his credit?\nI already explained it in response of Billy here\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019271.html\n\njust look for \u201chow normal transactions happen in their entirety.\u201d\n\nLooking forward to hear from core developers about \u201chow miners will\nreact to the two double-spend transactions and which one they will\nprefer\u201d.\n\nRegards\nRaymo\n\n\nOn 2021-08-09 00:03, s7r wrote:\n> raymo via bitcoin-dev wrote:\n> \n> TL,DR: you were explained by ZmnSCPxj why this protocol will not work.\n> The possibility for just one party to sign will not work. I will\n> explain again why but in much more simpler description.\n> \n> \n>> Check out this simple transaction to learn more about how the system\n>> works.\n>> Consider Alice as an issuer. She owns a UTXO worth 20,000 Satoshi. So,\n>> she can spend it by create a transaction and sign it and broadcast it to\n>> Bitcoin network.\n>> Suppose Bob (as a creditor) pays Alice 5 dollars cash, and buys 12,000\n>> Satoshi from Alice in exchange.\n>> Alice gets this 5$ and prepare a Main transaction that represents this\n>> liability of Alice to Bob.\n>>\n>> Main Transaction (20,000 Sat input):\n>> * Bob (creditor): 9,000 Sat (the real credit of Bob is 12,000, but Bob\n>> has to pay 3,000 as BTC fee)\n>> * Alice (issuer): 6,000 Sat\n>> * BTC Fee: 5,000 Sat (2,000 from Alice + 3,000 from Bob)\n>> This is a valid transaction and both Bob and/or Alice can send it to\n>> Bitcoin network, but none of them are interested in doing so. Because\n>> they will lose 5,000 Satoshi of their own money as Bitcoin transaction\n>> fee.\n>>\n>> Alongside this transaction Alice (the issuer) has to create the\n>> Guarantee Transaction as well and deliver it to Bob. Otherwise, Bob will\n>> not consider the deal completed. The Guarantee Transaction is another\n>> valid Bitcoin transaction. It is created based on Main Transaction and\n>> will cut a part of Bob and Alice money in favor of transaction fee.\n>>\n>> Guarantee Transaction (20,000 Sat input):\n>> * Bob (creditor): 9,000 \u2013 80.77%*9,000 = 9,000 \u2013 7,260 = 1,740 Sat\n>> * Alice (issuer): 6,000 \u2013 58%*6,000 = 6,000 \u2013 3,480 = 2,520 Sat\n>> * BTC Fee: 5,000 Sat (2,000 from Alice + 3,000 from Bob) + 7,260 (from\n>> Bob) + 3,480 (from Al-ice) = 15,739 Sat\n>>\n>> The Guarantee Transaction applies when the issuer does not live up to\n>> its promise and intends to spend the promised UTXO(s) in a way other\n>> than that agreed upon. We already knew the fact that Sabu is not a\n>> custodial solution, neither a M of N signature schema. As a result, the\n>> UTXO owner always can spend the already promised UTXO(s) in Sabu\n>> protocol or out of Sabu on Bitcoin blockchain, Contrary to what was\n>> promised.\n>> When the Alice (issuer) breaks such a promise and sends the fraudulent\n>> transaction to the Bitcoin network, Bob's wallet realizes that she\n>> (issuer) is spending the promised UTXO(s) and it sends the Guarantee\n>> Transaction(s) to the network as a last resort. The miners will face two\n>> (or more) transactions which are spending same UTXO(s), but one of them\n>> is paying notably higher Bitcoin transaction fee, thus they chose the\n>> highest fee payer transaction, which is the Guarantee Transaction. The\n>> miner will put the Guarantee Transaction in next block and reject the\n>> rest double-spend transactions. Certainly, poor Bob cannot recoup all\n>> his Satoshis. But he can retrieve a portion of his money and forces\n>> Alice to lose some of her money as well. tit for tat!\n>> Because of this mechanism, the issuer will try to not cheat on creditor.\n>>\n>> By the way there are some attacks that have very small chance to succeed\n>> but the risk to reward ratio for these scenarios are too high to be\n>> considered as a real possible attack threat. I will review them a little\n>> later in this post.\n>>\n>>\n> \n> You said that the guarantee transaction is created based on Main\n> Transaction, how do you mean? If it is a child transaction of the Main\n> Transaction it already doesn't work because Alice needs to broadcast\n> the *Main Transaction* to the blockchain in order for the Guarantee\n> transaction to be accepted, and of she does this, Bob doesn't care\n> because the transaction pays to him already the correct agreed amount.\n> If you did not mean this, still it won't work, because\n> \n> Simple:\n> 1. Alice will create transaction #3, or call it\n> Sabu-killing-transaction (20,000 Sat input):\n> * Alice (issuer): 15,000 Sat\n> * BTC Fee: 5,000 Sat\n> \n> PERIOD.\n> \n> When Bob tries to broadcast the \"guarantee transaction\" he will get an\n> error: REJECTED FROM MEMPOOL, INPUTS (UTXO) ALREADY SPENT. The much\n> larger fee in the guarantee transaction will not matter. You have to\n> assume a miner will violate the Bitcoin protocol and somehow drop\n> Sabu-killing-transaction from mempool and consider the Guarantee\n> transaction only. This is very unlikely to happen and you might also\n> need connection direct with the miners because most full nodes will\n> not even accept the Guarantee transaction to their mempools in order\n> to further broadcast it until it reaches the miners.\n> \n> With the simple attack described above Alice's chance to fraud Bob\n> are, from my point of view, 99%.\n> \n> (the only way to replace a transaction is Replace-By-Fee but this\n> implies the transaction that IS TO BE REPLACED has a certain flag set,\n> and it is optional).\n> \n> Given the Sabu-Killing-transaction comes first, Alice will of course\n> create it without this flag set so even if you add to Sabu the\n> requirement of RBF enabled to the Guarantee transaction it will not\n> work, because it's the other way around.\n> \n> \n> The second question is just for an observation that it has no real\n> benefits over Lightning even if #1 wasn't true:\n> \n> 2. The creditor (Bob) has to leave his wallet running 24x7 and ensure\n> he is connected to the internet, otherwise if he loses connection to\n> the internet or energy supply, Alice attack will succeed entirely with\n> 100% chances. So this means Bob needs to always be online like forever\n> and ever.\n> \n> The 3rd one is hypothetical and you don't even have to answer it:\n> 3. How does Bob (first creditor) spend the coins received / how does\n> Bob become an issuer himself in relation to Dave (another creditor)?\n> What happens if Alice tries to fraud Bob after Bob spent its Sabu\n> credit to Dave? Dave has to hold all parent \"guarantee transactions\"\n> and watch the network for any potential fraudulent transactions that\n> cancels his credit?"
            },
            {
                "author": "raymo at riseup.net",
                "date": "2021-08-09T20:22:57",
                "message_text_only": "Hi Chris,\n\nThanks for your detailed answer. So, as you answered there is an\nuncertainty about this case. For me, even this uncertainty would be a\ngood point to start. Because if the miners realize the potentiality for\nincreasing revenue under Sabu protocol, very soon they will want to\nupdate their transaction selecting mechanism priorities, even before\noccurring the first real attack on the protocol in \u201cproduction\nsoftware\u201d. This upgrade in Bitcoin protocol will eliminate uncertainty\ntotally.\n\nHow hard do you think it will be this upgrade on protocol?\nIMO the most important thing will be the consensus on the implementation\nof these changes, while the code upgrading won't be a difficult\ntechnical issue.\nIf it were difficult to agree on a Bitcoin core protocol change, we\nmight be able to achieve our goals by changing the Stratum protocol.\nUnlike miners who would welcome that offer, full-nodes without hash\npower would probably not be interested in upgrading the software. Maybe\nbecause they do not want to disrupt the broadcasting of transactions by\nrelying double-spend transactions.\nI'm not sure if the normal full nodes (without hash power) use the same\nsoftware that miners use. If not, we have to fight on two fronts to\nupgrade the software.\n\nAgain, thanks for your fast and flourish reply :-)\nRaymo\n\n\nOn 2021-08-09 18:03, Chris Riley wrote:\n>> I'm not sure how miners will react to the two double-spend\n> transactions and which one they will prefer.\n>> Will they use the first seen transaction for block pre-image, or will\n> use the transaction with higher transaction fee?\n>> We need the help of Bitcoin core developers to clarify this\n> transaction selection mechanism.  If miners\n>> prefer the highest fee my scenario still is valid. But if miners\n> always keep the first transaction received\n>> and drop subsequent transactions,\n> Hi,\n> \n> Miners have the incentive to accept the highest fee transaction\n> whenever they see it.  That does not imply that miners _will_ accept\n> the highest fee transaction they see for a variety of reasons.  If a\n> transaction does not signal RBF (BIP 125) then in general a \"first\n> seen\" rule is applied, if a transaction does signal RBF, then in\n> general the highest fee is prefered.  Since this is an untrusted\n> network, a miner could use RBF even for transactions that don't signal\n> it, since she could claim she saw it first, assuming the miner was\n> aware of it which might imply it was submitted directly since the\n> network might not relay a higher fee transaction for a non-RBF\n> transaction.  Or a miner could see the first transaction and include\n> it in a block just after the RBF transaction is broadcast but before\n> the block is propagated. etc\n> \n> So there is only a question of probabilities:  in general miners\n> prefer the highest fee for RBF transactions and in general, miners\n> will not replace a non-RBF transaction with a later one.  However,\n> nothing is guaranteed given it is an untrusted network and people\n> could use non-standard rules for selection of what transactions are\n> included in a block.\n> \n> :-)\n> \n> On Mon, Aug 9, 2021 at 12:57 PM raymo via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n>> Hi s7r,\n>> I already answered to ZmnSCPxj's comments.\n>> \n>> Let\u2019s go to yours.\n>> \n>>> If it is a child transaction of the Main Transaction\n>> Sorry for my shortcoming in English, because it caused the\n>> misunderstanding of proposal.\n>> There is not any relation between Main Transaction and Guarantee\n>> transaction. when I said \u201cthe Guarantee Transaction is created\n>> based on\n>> Main Transaction\u201d I was intended only the numbers. I mean the\n>> output\n>> amounts of Guarantee Transaction are calculated relatively based on\n>> Main\n>> Transaction output amounts, in order to make a Guarantee Transaction\n>> with relatively higher transaction fee. So, either of MT or GT can\n>> be\n>> broadcasted or toke place in next block independently.\n>> \n>>> When Bob tries to broadcast the \"guarantee transaction\" he will\n>> get an error:\n>>> REJECTED FROM MEMPOOL, INPUTS (UTXO) ALREADY SPENT\n>> Here is the part which I am not sure you are right about it. I do\n>> not\n>> know in detail and I'm not sure how miners will react to the two\n>> double-spend transactions and which one they will prefer.\n>> Will they use the first seen transaction for block pre-image, or\n>> will\n>> use the transaction with higher transaction fee?\n>> We need the help of Bitcoin core developers to clarify this\n>> transaction\n>> selection mechanism.\n>> If miners prefer the highest fee my scenario still is valid. But if\n>> miners always keep the first transaction received and drop\n>> subsequent\n>> transactions, I have three different solution to solve that I will\n>> explain in later posts.\n>> \n>>> 2. The creditor (Bob) has to leave his wallet running 24x7 and\n>> ensure he is connected\n>>> to the internet, otherwise if he loses connection to the internet\n>> or energy supply,\n>>> Alice attack will succeed entirely with 100% chances.\n>>> So this means Bob needs to always be online like forever and ever.\n>> Somehow you are right. Definitely Bob can delegate this task to a\n>> doc-watcher, pretty much like watch-tower in Lightning, but due to\n>> the\n>> small amount of creditor's credits and the fact that this amount is\n>> scattered among many different issuers, I removed this part from the\n>> original design of Sabu architecture.\n>> BTW major creditors, such as stores that receives debt-documents\n>> worth\n>> thousands of dollars a day, should (and better say must) always be\n>> online to protect their money. This job also creates a safe margin\n>> for\n>> other creditors.\n>> IMHO at the moment the protocol is good enough to start, but we can\n>> always talk about improving the protocol.\n>> \n>>> The 3rd one is hypothetical and you don't even have to answer it:\n>>> 3. How does Bob (first creditor) spend the coins received /\n>>> how does Bob become an issuer himself in relation to Dave (another\n>> creditor)?\n>>> What happens if Alice tries to fraud Bob after Bob spent its Sabu\n>> credit to Dave?\n>>> Dave has to hold all parent \"guarantee transactions\" and watch the\n>> network for\n>>> any potential fraudulent transactions that cancels his credit?\n>> I already explained it in response of Billy here\n>> \n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019271.html\n>> \n>> just look for \u201chow normal transactions happen in their\n>> entirety.\u201d\n>> \n>> Looking forward to hear from core developers about \u201chow miners\n>> will\n>> react to the two double-spend transactions and which one they will\n>> prefer\u201d.\n>> \n>> Regards\n>> Raymo\n>> \n>> On 2021-08-09 00:03, s7r wrote:\n>>> raymo via bitcoin-dev wrote:\n>>> \n>>> TL,DR: you were explained by ZmnSCPxj why this protocol will not\n>> work.\n>>> The possibility for just one party to sign will not work. I will\n>>> explain again why but in much more simpler description.\n>>> \n>>> \n>>>> Check out this simple transaction to learn more about how the\n>> system\n>>>> works.\n>>>> Consider Alice as an issuer. She owns a UTXO worth 20,000\n>> Satoshi. So,\n>>>> she can spend it by create a transaction and sign it and\n>> broadcast it to\n>>>> Bitcoin network.\n>>>> Suppose Bob (as a creditor) pays Alice 5 dollars cash, and buys\n>> 12,000\n>>>> Satoshi from Alice in exchange.\n>>>> Alice gets this 5$ and prepare a Main transaction that represents\n>> this\n>>>> liability of Alice to Bob.\n>>>> \n>>>> Main Transaction (20,000 Sat input):\n>>>> * Bob (creditor): 9,000 Sat (the real credit of Bob is 12,000,\n>> but Bob\n>>>> has to pay 3,000 as BTC fee)\n>>>> * Alice (issuer): 6,000 Sat\n>>>> * BTC Fee: 5,000 Sat (2,000 from Alice + 3,000 from Bob)\n>>>> This is a valid transaction and both Bob and/or Alice can send it\n>> to\n>>>> Bitcoin network, but none of them are interested in doing so.\n>> Because\n>>>> they will lose 5,000 Satoshi of their own money as Bitcoin\n>> transaction\n>>>> fee.\n>>>> \n>>>> Alongside this transaction Alice (the issuer) has to create the\n>>>> Guarantee Transaction as well and deliver it to Bob. Otherwise,\n>> Bob will\n>>>> not consider the deal completed. The Guarantee Transaction is\n>> another\n>>>> valid Bitcoin transaction. It is created based on Main\n>> Transaction and\n>>>> will cut a part of Bob and Alice money in favor of transaction\n>> fee.\n>>>> \n>>>> Guarantee Transaction (20,000 Sat input):\n>>>> * Bob (creditor): 9,000 \u2013 80.77%*9,000 = 9,000 \u2013 7,260 =\n>> 1,740 Sat\n>>>> * Alice (issuer): 6,000 \u2013 58%*6,000 = 6,000 \u2013 3,480 = 2,520\n>> Sat\n>>>> * BTC Fee: 5,000 Sat (2,000 from Alice + 3,000 from Bob) + 7,260\n>> (from\n>>>> Bob) + 3,480 (from Al-ice) = 15,739 Sat\n>>>> \n>>>> The Guarantee Transaction applies when the issuer does not live\n>> up to\n>>>> its promise and intends to spend the promised UTXO(s) in a way\n>> other\n>>>> than that agreed upon. We already knew the fact that Sabu is not\n>> a\n>>>> custodial solution, neither a M of N signature schema. As a\n>> result, the\n>>>> UTXO owner always can spend the already promised UTXO(s) in Sabu\n>>>> protocol or out of Sabu on Bitcoin blockchain, Contrary to what\n>> was\n>>>> promised.\n>>>> When the Alice (issuer) breaks such a promise and sends the\n>> fraudulent\n>>>> transaction to the Bitcoin network, Bob's wallet realizes that\n>> she\n>>>> (issuer) is spending the promised UTXO(s) and it sends the\n>> Guarantee\n>>>> Transaction(s) to the network as a last resort. The miners will\n>> face two\n>>>> (or more) transactions which are spending same UTXO(s), but one\n>> of them\n>>>> is paying notably higher Bitcoin transaction fee, thus they chose\n>> the\n>>>> highest fee payer transaction, which is the Guarantee\n>> Transaction. The\n>>>> miner will put the Guarantee Transaction in next block and reject\n>> the\n>>>> rest double-spend transactions. Certainly, poor Bob cannot recoup\n>> all\n>>>> his Satoshis. But he can retrieve a portion of his money and\n>> forces\n>>>> Alice to lose some of her money as well. tit for tat!\n>>>> Because of this mechanism, the issuer will try to not cheat on\n>> creditor.\n>>>> \n>>>> By the way there are some attacks that have very small chance to\n>> succeed\n>>>> but the risk to reward ratio for these scenarios are too high to\n>> be\n>>>> considered as a real possible attack threat. I will review them a\n>> little\n>>>> later in this post.\n>>>> \n>>>> \n>>> \n>>> You said that the guarantee transaction is created based on Main\n>>> Transaction, how do you mean? If it is a child transaction of the\n>> Main\n>>> Transaction it already doesn't work because Alice needs to\n>> broadcast\n>>> the *Main Transaction* to the blockchain in order for the\n>> Guarantee\n>>> transaction to be accepted, and of she does this, Bob doesn't care\n>>> because the transaction pays to him already the correct agreed\n>> amount.\n>>> If you did not mean this, still it won't work, because\n>>> \n>>> Simple:\n>>> 1. Alice will create transaction #3, or call it\n>>> Sabu-killing-transaction (20,000 Sat input):\n>>> * Alice (issuer): 15,000 Sat\n>>> * BTC Fee: 5,000 Sat\n>>> \n>>> PERIOD.\n>>> \n>>> When Bob tries to broadcast the \"guarantee transaction\" he will\n>> get an\n>>> error: REJECTED FROM MEMPOOL, INPUTS (UTXO) ALREADY SPENT. The\n>> much\n>>> larger fee in the guarantee transaction will not matter. You have\n>> to\n>>> assume a miner will violate the Bitcoin protocol and somehow drop\n>>> Sabu-killing-transaction from mempool and consider the Guarantee\n>>> transaction only. This is very unlikely to happen and you might\n>> also\n>>> need connection direct with the miners because most full nodes\n>> will\n>>> not even accept the Guarantee transaction to their mempools in\n>> order\n>>> to further broadcast it until it reaches the miners.\n>>> \n>>> With the simple attack described above Alice's chance to fraud Bob\n>>> are, from my point of view, 99%.\n>>> \n>>> (the only way to replace a transaction is Replace-By-Fee but this\n>>> implies the transaction that IS TO BE REPLACED has a certain flag\n>> set,\n>>> and it is optional).\n>>> \n>>> Given the Sabu-Killing-transaction comes first, Alice will of\n>> course\n>>> create it without this flag set so even if you add to Sabu the\n>>> requirement of RBF enabled to the Guarantee transaction it will\n>> not\n>>> work, because it's the other way around.\n>>> \n>>> \n>>> The second question is just for an observation that it has no real\n>>> benefits over Lightning even if #1 wasn't true:\n>>> \n>>> 2. The creditor (Bob) has to leave his wallet running 24x7 and\n>> ensure\n>>> he is connected to the internet, otherwise if he loses connection\n>> to\n>>> the internet or energy supply, Alice attack will succeed entirely\n>> with\n>>> 100% chances. So this means Bob needs to always be online like\n>> forever\n>>> and ever.\n>>> \n>>> The 3rd one is hypothetical and you don't even have to answer it:\n>>> 3. How does Bob (first creditor) spend the coins received / how\n>> does\n>>> Bob become an issuer himself in relation to Dave (another\n>> creditor)?\n>>> What happens if Alice tries to fraud Bob after Bob spent its Sabu\n>>> credit to Dave? Dave has to hold all parent \"guarantee\n>> transactions\"\n>>> and watch the network for any potential fraudulent transactions\n>> that\n>>> cancels his credit?\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "Boost Bitcoin circulation, Million Transactions Per Second with stronger privacy",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "raymo at riseup.net",
                "s7r"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 43575
        }
    },
    {
        "title": "[bitcoin-dev] Removing the Dust Limit",
        "thread_messages": [
            {
                "author": "Jeremy",
                "date": "2021-08-08T18:52:55",
                "message_text_only": "We should remove the dust limit from Bitcoin. Five reasons:\n\n1) it's not our business what outputs people want to create\n2) dust outputs can be used in various authentication/delegation smart\ncontracts\n3) dust sized htlcs in lightning (\nhttps://bitcoin.stackexchange.com/questions/46730/can-you-send-amounts-that-would-typically-be-considered-dust-through-the-light)\nforce channels to operate in a semi-trusted mode which has implications\n(AFAIU) for the regulatory classification of channels in various\njurisdictions; agnostic treatment of fund transfers would simplify this\n(like getting a 0.01 cent dividend check in the mail)\n4) thinly divisible colored coin protocols might make use of sats as value\nmarkers for transactions.\n5) should we ever do confidential transactions we can't prevent it without\ncompromising privacy / allowed transfers\n\nThe main reasons I'm aware of not allow dust creation is that:\n\n1) dust is spam\n2) dust fingerprinting attacks\n\n1 is (IMO) not valid given the 5 reasons above, and 2 is preventable by\nwell behaved wallets to not redeem outputs that cost more in fees than they\nare worth.\n\ncheers,\n\njeremy\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210808/c022237a/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2021-08-08T21:14:23",
                "message_text_only": "If it weren't for the implications in changing standardness here, I think we should consider increasing the dust limit \ninstead.\n\nThe size of the UTXO set is a fundamental scalability constraint of the system. In fact, with proposals like \nassume-utxo/background history sync it is arguably *the* fundamental scalability constraint of the system. Today's dust \nlimit is incredibly low - its based on a feerate of only 3 sat/vByte in order for claiming the UTXO to have *any* value, \nnot just having enough value to be worth bothering. As feerates have gone up over time, and as we expect them to go up \nfurther, we should be considering drastically increasing the 3 sat/vByte basis to something more like 20 sat/vB.\n\nMatt\n\nOn 8/8/21 14:52, Jeremy via bitcoin-dev wrote:\n> We should remove the dust limit from Bitcoin. Five reasons:\n> \n> 1) it's not our business what outputs people want to create\n\nIt is precisely our business - the costs are born by us, not the creator. If someone wants to create outputs which don't \nmake sense to spend, they can do so using OP_RETURN, since they won't spend it anyway.\n\n> 2) dust outputs can be used in various authentication/delegation smart contracts\n\nSo can low-value-but-enough-to-be-worth-spending-when-you're-done-with-them outputs.\n\n> 3) dust sized htlcs in lightning \n> (https://bitcoin.stackexchange.com/questions/46730/can-you-send-amounts-that-would-typically-be-considered-dust-through-the-light \n> <https://bitcoin.stackexchange.com/questions/46730/can-you-send-amounts-that-would-typically-be-considered-dust-through-the-light>) \n> force channels to operate in a semi-trusted mode which has implications (AFAIU) for the regulatory classification of \n> channels in various jurisdictions; agnostic treatment of fund transfers\u00a0would simplify this (like getting a 0.01 cent \n> dividend check in the mail)\n\nThis is unrelated to the consensus dust limit. This is related to the practical question about the value of claiming an \noutput. Again, the appropriate way to solve this instead of including spendable dust outputs would be an OP_RETURN \noutput (though I believe this particular problem is actually better solved elsewhere in the lightning protocol).\n\n> 4) thinly divisible colored coin protocols might make use of sats as value markers for transactions.\n\nThese schemes can and should use values which make them economical to spend. The whole *point* of the dust limit is to \nencourage people to use values which make sense economically to \"clean up\" after they're done with them. If people want \nto use outputs which they will not spend/\"clean up\" later, they should be using OP_RETURN.\n\n> 5) should we ever do confidential transactions we can't prevent it without compromising\u00a0privacy / allowed transfers\n\nThis is the reason the dust limit is not a *consensus* limit. If and when CT were to happen we can and would relax the \nstandardness rules around the dust limit to allow for CT.\n\n> \n> The main reasons I'm aware of not allow dust creation is that:\n> \n> 1) dust is spam\n> 2) dust fingerprinting attacks\n\n3) The significant costs to every miner and full node operator."
            },
            {
                "author": "Oleg Andreev",
                "date": "2021-08-08T21:41:32",
                "message_text_only": "I agree with Jeremy. Dust limit works due to design accident: that outputs are not encrypted. But outputs are private business and the real issue is only the cost of utxo set storage born by every user. There are two ways to address this:\n\n1) either make ppl pay for renting that storage (which creates a ton of problems of its own)\n2) or make storage extremely cheap so it remains cheap at any scale. This is perfectly solved by Utreexo.\n\nBut looking at the private data because you can is a hack that creates issues of its own.\n\n> On 9 Aug 2021, at 00:16, Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \ufeffIf it weren't for the implications in changing standardness here, I think we should consider increasing the dust limit instead.\n> \n> The size of the UTXO set is a fundamental scalability constraint of the system. In fact, with proposals like assume-utxo/background history sync it is arguably *the* fundamental scalability constraint of the system. Today's dust limit is incredibly low - its based on a feerate of only 3 sat/vByte in order for claiming the UTXO to have *any* value, not just having enough value to be worth bothering. As feerates have gone up over time, and as we expect them to go up further, we should be considering drastically increasing the 3 sat/vByte basis to something more like 20 sat/vB.\n> \n> Matt\n> \n>> On 8/8/21 14:52, Jeremy via bitcoin-dev wrote:\n>> We should remove the dust limit from Bitcoin. Five reasons:\n>> 1) it's not our business what outputs people want to create\n> \n> It is precisely our business - the costs are born by us, not the creator. If someone wants to create outputs which don't make sense to spend, they can do so using OP_RETURN, since they won't spend it anyway.\n> \n>> 2) dust outputs can be used in various authentication/delegation smart contracts\n> \n> So can low-value-but-enough-to-be-worth-spending-when-you're-done-with-them outputs.\n> \n>> 3) dust sized htlcs in lightning (https://bitcoin.stackexchange.com/questions/46730/can-you-send-amounts-that-would-typically-be-considered-dust-through-the-light <https://bitcoin.stackexchange.com/questions/46730/can-you-send-amounts-that-would-typically-be-considered-dust-through-the-light>) force channels to operate in a semi-trusted mode which has implications (AFAIU) for the regulatory classification of channels in various jurisdictions; agnostic treatment of fund transfers would simplify this (like getting a 0.01 cent dividend check in the mail)\n> \n> This is unrelated to the consensus dust limit. This is related to the practical question about the value of claiming an output. Again, the appropriate way to solve this instead of including spendable dust outputs would be an OP_RETURN output (though I believe this particular problem is actually better solved elsewhere in the lightning protocol).\n> \n>> 4) thinly divisible colored coin protocols might make use of sats as value markers for transactions.\n> \n> These schemes can and should use values which make them economical to spend. The whole *point* of the dust limit is to encourage people to use values which make sense economically to \"clean up\" after they're done with them. If people want to use outputs which they will not spend/\"clean up\" later, they should be using OP_RETURN.\n> \n>> 5) should we ever do confidential transactions we can't prevent it without compromising privacy / allowed transfers\n> \n> This is the reason the dust limit is not a *consensus* limit. If and when CT were to happen we can and would relax the standardness rules around the dust limit to allow for CT.\n> \n>> The main reasons I'm aware of not allow dust creation is that:\n>> 1) dust is spam\n>> 2) dust fingerprinting attacks\n> \n> 3) The significant costs to every miner and full node operator.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Prayank",
                "date": "2021-08-09T10:25:50",
                "message_text_only": ">\u00a0As feerates have gone up over time, and as we expect them to go up further, we should be considering drastically increasing the 3 sat/vByte basis to something more like 20 sat/vB.\n\nI have no opinion on changing or removing dust limit. However, fee rates are not going up. Yes, we expect them to go up and miners revenue from fees as well. Although, fees/day (in terms of BTC) has been decreasing in each cycle. Fee rates have been ranging between 1 sat/vByte to 200-300 sat/vByte, regularly reset to 1-5 sat/vByte and very low since long time now except when hash rate went down.\n\nFees per MB since 2016: https://i.imgur.com/XEkkf99.png\u00a0\n\nHighest in this cycle on April 19 2021: 2.5 BTC\nHighest in previous cycle on December 18 2017: 10 BTC\n\nIt stays low all the time except few days in each cycle.\n\n-- \nPrayank\n\u00a0\nA3B1 E430 2298 178F\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210809/84b29654/attachment.html>"
            },
            {
                "author": "Karl",
                "date": "2021-08-09T11:58:03",
                "message_text_only": "Why would removing the dust limit impact decentralisation of mining if\nminers can reconfigure the dust limit for their mined blocks?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210809/42d76e8d/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Removing the Dust Limit",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Jeremy",
                "Karl",
                "Oleg Andreev",
                "Matt Corallo",
                "Prayank"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 9838
        }
    },
    {
        "title": "[bitcoin-dev] [Lightning-dev] Removing the Dust Limit",
        "thread_messages": [
            {
                "author": "David A. Harding",
                "date": "2021-08-08T21:51:01",
                "message_text_only": "On Sun, Aug 08, 2021 at 11:52:55AM -0700, Jeremy wrote:\n> We should remove the dust limit from Bitcoin. Five reasons:\n\nJeremy knows this, but to be clear for other readers, the dust limit is\na policy in Bitcoin Core (and other software) where it refuses by\ndefault to relay or mine transactions with outputs below a certain\namount.  If nodes or miners running with non-default policy choose to\nrelay or mine those transactions, they are not penalized (not directly,\nat least; there's BIP152 to consider).\n\nQuestion for Jeremy: would you also allow zero-value outputs?  Or would\nyou just move the dust limit down to a fixed 1-sat?\n\nI think the dust limit is worth keeping:\n\n> 1) it's not our business what outputs people want to create\n\nEvery additional output added to the UTXO set increases the amount of\nwork full nodes need to do to validate new transactions.  For miners\nfor whom fast validation of new blocks can significantly affect their\nrevenue, larger UTXO sets increase their costs and so contributes\ntowards centralization of mining.\n\nAllowing 0-value or 1-sat outputs minimizes the cost for polluting the\nUTXO set during periods of low feerates.\n\nIf your stuff is going to slow down my node and possibly reduce my\ncensorship resistance, how is that not my business?\n\n> 2) dust outputs can be used in various authentication/delegation smart\n> contracts\n\nAll of which can also use amounts that are economically rational to\nspend on their own.  If you're gonna use the chain for something besides\nvalue transfer, and you're already wiling to pay X in fees per onchain\nuse, why is it not reasonable for us to ask you to put up something on\nthe order of X as a bond that you'll actually clean up your mess when\nyou're no longer interested in your thing?\n\n> 3) dust sized htlcs in lightning (\n> https://bitcoin.stackexchange.com/questions/46730/can-you-send-amounts-that-would-typically-be-considered-dust-through-the-light)\n> force channels to operate in a semi-trusted mode \n\nNope, nothing is forced.  Any LN node can simply refuse to accept/route\nHTLCs below the dust limit.\n\n> which has implications\n> (AFAIU) for the regulatory classification of channels in various\n> jurisdictions\n\nSucks for the people living there.  They should change their laws.  If\nthey can't do that, they should change their LN node policies not to\nroute uneconomic HTLCs.  We shouldn't make Bitcoin worse to make\ncomplying with regulations easier.\n\nI also doubt your proposed solution fixes the problem.  Any LN node that\naccepts an uneconomic HTLC cannot recover that value, so the money is\nlost either way.  Any sane regulation would treat losing value to\ntransaction fees the same as losing value to uneconomical conditions.\n\nFinally, if LN nodes start polluting the UTXO set with no economic way\nto clean up their mess, I think that's going to cause tension between\nfull node operators and LN node operators.\n\n> agnostic treatment of fund transfers would simplify this\n> (like getting a 0.01 cent dividend check in the mail)\n\nI'm not sure I understand this point.  It sounds to me like you're\ncomparing receiving an uneconomic output to receiving a check that isn't\nworth the time to cash.  But the costs of checks are borne only by the\npeople who send, receive, and process them.  The costs of uneconomic\noutputs polluting the UTXO set are borne by every full node forever (or\nfor every archival full node forever if non-archival nodes end up using\nsomething like utreexo).\n\n> 4) thinly divisible colored coin protocols might make use of sats as value\n> markers for transactions.\n\nI'm not exactly sure what you're talking about, but if Alice wants to\ncommunicate the number n onchain, she can do:\n\n    if n < dust:\n      nSequence = 0x0000 + n  # should probably check endianess\n    else:\n      nValue = n\n\nThere's at least 15 bits of nSequence currently without consensus or\npolicy meaning, and the dust limits are currently in the hundreds of\nsat, so there's plenty of space.\n\nAlice could probably also communicate the same thing by grinding her\noutput script's hash or pubkey; again, with dust limits just being\nhundreds of sats, that's not too much grinding.\n\n> 5) should we ever do confidential transactions we can't prevent it without\n> compromising privacy / allowed transfers\n\nI'm not an expert, but it seems to me that you can do that with range\nproofs.  The range proof for >dust doesn't need to become part of the\nblock chain, it can be relay only.\n\nI haven't looked since they upgraded to bulletproofs, but ISTR the\noriginal CT implementation leaked the most significant digits or\nsomething (that kept down the byte size of the proofs), so maybe it was\nalready possible to know what was certainly not dust and what might be\ndust.\n\nIn short, it's my opinion that the dust limit is not creating any real\nproblems, so it should be kept for its contribution to keeping full\nnodes faster, cheaper, and more efficient.\n\n-Dave\n\nP.S. As I prepared to send this, Matt's email arrived about \"If it\nweren't for the implications in changing standardness here, I think we\nshould consider increasing the dust limit instead.\"  I'm in agreement\nwith both parts of that statement.\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210808/3feb232d/attachment.sig>"
            },
            {
                "author": "Jeremy",
                "date": "2021-08-08T22:46:26",
                "message_text_only": "Under no circumstances do I think we should *increase* the dust limit. That\nwould have a mildly confiscatory effect on current Lightning Channel\noperators, among others.\n\nGenerally, the UTXO set will grow. We should work to accommodate the worst\ncase scenario under current consensus rules. I think this points to using\nthings like Utreexo or similar rather than meddling in the user's business.\n\nI am skeptical that 0 value outputs are a real spam problem given the cost\nto create. Generally one creates an output when one either believes it\nwould make sense to redeem it in the future. So surely this is a market\nproblem, if people want them they can pay what it is worth for them to have\nit. Again, it's not my business.\n\nMatt proposes that people might use a nominal amount of bitcoin on a zero\nvalue input so that it doesn't look like dust. What Matt is asking for is\nthat in any protocol you pay for your space not via fees, but instead via\nan assurance bond that you will eventually redeem it and clean the state\nup. In my opinion, this is worse than just allowing a zero value input\nsince then you might accrue the need for an additional change output to\nwhich the bond's collateral be returned.\n\nWith respect to the check in the mail analogy, cutting down trees for paper\nis bad for everyone and shipping things using fossil fuels contributes to\nclimate change. Therefore it's a cost borne by society in some respects.\nStill, if someone else decides it's worth sending a remittance of whichever\nvalue, it is still not my business.\n\nWith respect to CT and using the range proofs to exclude dust, I'm aware\nthat can be done (hence compromising allowed transfers). Again, I don't\nthink it's quite our business what people do, but on a technical level,\nthis would have the impact of shrinking the anonymity set so is also\nsuspect to me.\n\n---------------\n\nIf we really want to create incentives for state clean up, I think it's a\ndecent design space to consider.\n\ne.g., we could set up a bottle deposit program whereby miners contribute an\namount of funds from fee revenue from creating N outputs to a \"rolling\nutxo\" (e.g., a coinbase utxo that gets spent each block op_true to op_true\nunder some miner rules) and the rolling utxo can either disperse funds to\nthe miner reward or soak up funds from the fees in order to encourage\nblocks which have a better ratio of inputs to outputs than the mean. Miners\ncan then apply this rule in the mempool to prioritize transactions that\nhelp their block's ratio. This is all without directly interfering with the\nuser's intent to create whatever outputs they want, it just provides a way\nof paying miners to clean up the public common.\n\nGas Token by Daian et al comes to mind, from Eth, w.r.t. many pitfalls\narbing these state space freeing return curves, but it's worth thinking\nthrough nonetheless.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210808/8fcb4331/attachment.html>"
            },
            {
                "author": "Jeremy",
                "date": "2021-08-08T23:07:27",
                "message_text_only": "some additional answers/clarifications\n\n\n\n> Question for Jeremy: would you also allow zero-value outputs?  Or would\n> you just move the dust limit down to a fixed 1-sat?\n>\n\nI would remove it entirely -- i don't think there's a difference between\nthe two realistically.\n\n\n\n>\n> Allowing 0-value or 1-sat outputs minimizes the cost for polluting the\n> UTXO set during periods of low feerates.\n>\n>\nMaybe that incentivizes people to make better use of the low\nfeerate periods to do more important work like consolidations so that\nothers do not have the opportunity to pollute (therefore eliminating the\nlow fee period ;)\n\n\n\n> If your stuff is going to slow down my node and possibly reduce my\n> censorship resistance, how is that not my business?\n>\n\nYou don't know that's what I'm doing, it's a guess as to my future behavior.\n\nIf it weren't worth it to me, I wouldn't be doing it. Market will solve\nwhat is worth v.s. not worth.\n\n\n\n>\n> > 2) dust outputs can be used in various authentication/delegation smart\n> > contracts\n>\n> All of which can also use amounts that are economically rational to\n> spend on their own.  If you're gonna use the chain for something besides\n> value transfer, and you're already wiling to pay X in fees per onchain\n> use, why is it not reasonable for us to ask you to put up something on\n> the order of X as a bond that you'll actually clean up your mess when\n> you're no longer interested in your thing?\n>\n\nThese authentication/delegation smart contracts can be a part of value\ntransfer e.g. some type of atomic swaps or other escrowed payment.\n\nA bond to clean it up is a fair reason; but perhaps in a protocol it might\nnot make sense to clean up the utxo otherwise and so you're creating a\ncleanup transaction (potentially has to be presigned in a way it can't be\ndone as a consolidation) and then some future consolidation to make the\ndusts+eps aggregately convenient to spend. So you'd be trading a decent\namount more chainspace v.s. just ignoring the output and writing it to disk\nand maybe eventually into a utreexo (e.g. imagine utreexo where the last N\nyears of outputs are held in memory, but eventually things get tree'd up)\nso the long term costs need not be entirely bourne in permanent storage.\n\n\n>\n> Nope, nothing is forced.  Any LN node can simply refuse to accept/route\n> HTLCs below the dust limit.\n>\n\nI'd love to hear some broad thoughts on the impact of this on routing (cc\nTarun who thinks about these things a decent amount) as this means for\nthings like multipath routes you have much stricter constraints on which\nnodes you can route payments through. The impact on capacity from every\nuser's pov might be not insubstantial.\n\n\n\n>\n> I also doubt your proposed solution fixes the problem.  Any LN node that\n> accepts an uneconomic HTLC cannot recover that value, so the money is\n> lost either way.  Any sane regulation would treat losing value to\n> transaction fees the same as losing value to uneconomical conditions.\n>\n> Finally, if LN nodes start polluting the UTXO set with no economic way\n> to clean up their mess, I think that's going to cause tension between\n> full node operators and LN node operators.\n>\n\n\n\nMy anticipation is that the LN operators would stick the uneconomic HTLCs\naggregately into a fan out utxo and try to cooperate, but failing that only\npollute the chain by O(1) for O(n) non economic HTLCs. There is a\ndifference between losing money and knowing exactly where it is but not\nclaiming it.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210808/b39f4a28/attachment-0001.html>"
            },
            {
                "author": "shymaa arafat",
                "date": "2021-08-18T19:06:30",
                "message_text_only": "Dear Sir,\n\nI'm not discussing the dust limit here, but I'm suggesting some mitigations\nto the dust problem which tackles almost the same points mentioned here\nespecially the scalability of the UTXOS set and the corresponding Merkle\nproofs/witnesses in Utreexo or any similar design ....\n.\nI suggest:\n1-Dust UTXOS, along with burned & non-standard UTXOS, to be stored\nseparately in secondary storage; their Hashes in a separate Merkle too in\nany accumulator design\n(an earlier draft of the idea\nhttps://bitcointalk.org/index.php?topic=5343748.new#new)\n.\n-In fact, the idea of separating the real UTXO values was first suggested in\nhttps://royalsocietypublishing.org/doi/10.1098/rsos.180817\nIn their words\n\"Similarly, one can think of a two-tier data structure where a UTXO subset\ncontaining UTXOs with a low probability of being selected such as dust is\nkept on disk, while the other UTXOs are kept in memory.\"\n.\n2-I suggest also that existing dust UTXOS (from the same paper, in some\ncases a UTXO could be added as an extra input with the cost of 68*fee/byte)\n, to be selected with large UTXO whenever they fit in a spending ( use one\nlarge & one small to get rid of the small)\n.\n3-In general when user is not willing to leave the dust to the fee, and if\nthere's no dust UTXOS, do not let the coin selection algorithm select the\nclosest match; let it choose the smallest that doesn't create dust.\nFor example if there's UTXOS 0.00013 & 0.00012 and user want to spend\n0.0001198 choose 0.00013 so that the change is not dust (with same cost).\n.\nThank you for your time,\nThis is the first time I send a suggestion to your emailing list, so sorry\nif I missed any regulations\n.\nShymaa M. Arafat\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210818/05bf3a96/attachment.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2021-08-09T13:22:28",
                "message_text_only": "I'm pretty conservative about increasing the standard dust limit in any\nway. This would convert a higher percentage of LN channels capacity into\ndust, which is coming with a lowering of funds safety [0]. Of course, we\ncan adjust the LN security model around dust handling to mitigate the\nsafety risk in case of adversarial settings, but ultimately the standard\ndust limit creates a  \"hard\" bound, and as such it introduces a trust\nvector in the reliability of your peer to not goes\nonchain with a commitment heavily-loaded with dust-HTLC you own.\n\nLN node operators might be willingly to compensate this \"dust\" trust vector\nby relying on side-trust model, such as PKI to authenticate their peers or\nAPI tokens (LSATs, PoW tokens), probably not free from consequences for the\n\"openness\" of the LN topology...\n\nFurther, I think any authoritative setting of the dust limit presents the\nrisk of becoming ill-adjusted  w.r.t to market realities after a few months\nor years, and would need periodic reevaluations. Those reevaluations, if\nnot automated, would become a vector of endless dramas and bikeshedding as\nthe L2s ecosystems grow bigger...\n\nNote, this would also constrain the design space of newer fee schemes. Such\nas negotiated-with-mining-pool and discounted consolidation during low\nfeerate periods deployed by such producers of low-value outputs.\n`\nMoreover as an operational point, if we proceed to such an increase on the\nbase-layer, e.g to 20 sat/vb, we're going to severely damage the\npropagation of any LN transaction, where a commitment transaction is built\nwith less than 20 sat/vb outputs. Of course, core's policy deployment on\nthe base layer is gradual, but we should first give a time window for the\nLN ecosystem to upgrade and as of today we're still devoid of the mechanism\nto do it cleanly and asynchronously (e.g dynamic upgrade or quiescence\nprotocol [1]).\n\nThat said, as raised by other commentators, I don't deny we have a\nlong-term tension between L2 nodes and full-nodes operators about the UTXO\nset growth, but for now I would rather solve this with smarter engineering\nsuch as utreexo on the base-layer side or multi-party shared-utxo or\ncompressed colored coins/authentication smart contracts (e.g\nopentimestamp's merkle tree in OP_RETURN) on the upper layers rather than\naltering the current equilibrium.\n\nI think the status quo is good enough for now, and I believe we would be\nbetter off to learn from another development cycle before tweaking the dust\nlimit in any sense.\n\nAntoine\n\n[0]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-May/002714.html\n[1] https://github.com/lightningnetwork/lightning-rfc/pull/869\n\nLe dim. 8 ao\u00fbt 2021 \u00e0 14:53, Jeremy <jlrubin at mit.edu> a \u00e9crit :\n\n> We should remove the dust limit from Bitcoin. Five reasons:\n>\n> 1) it's not our business what outputs people want to create\n> 2) dust outputs can be used in various authentication/delegation smart\n> contracts\n> 3) dust sized htlcs in lightning (\n> https://bitcoin.stackexchange.com/questions/46730/can-you-send-amounts-that-would-typically-be-considered-dust-through-the-light)\n> force channels to operate in a semi-trusted mode which has implications\n> (AFAIU) for the regulatory classification of channels in various\n> jurisdictions; agnostic treatment of fund transfers would simplify this\n> (like getting a 0.01 cent dividend check in the mail)\n> 4) thinly divisible colored coin protocols might make use of sats as value\n> markers for transactions.\n> 5) should we ever do confidential transactions we can't prevent it without\n> compromising privacy / allowed transfers\n>\n> The main reasons I'm aware of not allow dust creation is that:\n>\n> 1) dust is spam\n> 2) dust fingerprinting attacks\n>\n> 1 is (IMO) not valid given the 5 reasons above, and 2 is preventable by\n> well behaved wallets to not redeem outputs that cost more in fees than they\n> are worth.\n>\n> cheers,\n>\n> jeremy\n>\n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin>\n> <https://twitter.com/JeremyRubin>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210809/83985422/attachment.html>"
            },
            {
                "author": "Billy Tetrud",
                "date": "2021-08-10T00:30:02",
                "message_text_only": "> 5) should we ever do confidential transactions we can't prevent it without compromising\nprivacy / allowed transfers\n\nI wanted to mention the dubiousness of adding confidential transactions to\nbitcoin. Because adding CT would eliminate the ability for users to audit\nthe supply of Bitcoin, I think its incredibly unlikely to ever happen. I'm\nin the camp that we shouldn't do anything that prevents people from\nauditing the supply. I think that camp is probably pretty large. Regardless\nof what I think should happen there, and even if CT were to eventually\nhappen in bitcoin, I don't think that future possibility is a good reason\nto change the dust limit today.\n\nIt seems like dust is a scalability problem regardless of whether we use\nUtreexo eventually or not, tho an accumulator would help a ton. One idea\nwould be to destroy/delete dust at some point in the future. However, even\nif we were to plan to do this, I still don't think the dust limit should be\nremoved. But the dust limit should probably be lowered a bit, given that\nthe 546 sats limit is about 7 cents and its very doable to send 1 sat/vbyte\ntransactions, so lowering it to 200 sats seems reasonable.\n\n\nOn Mon, Aug 9, 2021 at 6:24 AM Antoine Riard via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I'm pretty conservative about increasing the standard dust limit in any\n> way. This would convert a higher percentage of LN channels capacity into\n> dust, which is coming with a lowering of funds safety [0]. Of course, we\n> can adjust the LN security model around dust handling to mitigate the\n> safety risk in case of adversarial settings, but ultimately the standard\n> dust limit creates a  \"hard\" bound, and as such it introduces a trust\n> vector in the reliability of your peer to not goes\n> onchain with a commitment heavily-loaded with dust-HTLC you own.\n>\n> LN node operators might be willingly to compensate this \"dust\" trust\n> vector by relying on side-trust model, such as PKI to authenticate their\n> peers or API tokens (LSATs, PoW tokens), probably not free from\n> consequences for the \"openness\" of the LN topology...\n>\n> Further, I think any authoritative setting of the dust limit presents the\n> risk of becoming ill-adjusted  w.r.t to market realities after a few months\n> or years, and would need periodic reevaluations. Those reevaluations, if\n> not automated, would become a vector of endless dramas and bikeshedding as\n> the L2s ecosystems grow bigger...\n>\n> Note, this would also constrain the design space of newer fee schemes.\n> Such as negotiated-with-mining-pool and discounted consolidation during low\n> feerate periods deployed by such producers of low-value outputs.\n> `\n> Moreover as an operational point, if we proceed to such an increase on the\n> base-layer, e.g to 20 sat/vb, we're going to severely damage the\n> propagation of any LN transaction, where a commitment transaction is built\n> with less than 20 sat/vb outputs. Of course, core's policy deployment on\n> the base layer is gradual, but we should first give a time window for the\n> LN ecosystem to upgrade and as of today we're still devoid of the mechanism\n> to do it cleanly and asynchronously (e.g dynamic upgrade or quiescence\n> protocol [1]).\n>\n> That said, as raised by other commentators, I don't deny we have a\n> long-term tension between L2 nodes and full-nodes operators about the UTXO\n> set growth, but for now I would rather solve this with smarter engineering\n> such as utreexo on the base-layer side or multi-party shared-utxo or\n> compressed colored coins/authentication smart contracts (e.g\n> opentimestamp's merkle tree in OP_RETURN) on the upper layers rather than\n> altering the current equilibrium.\n>\n> I think the status quo is good enough for now, and I believe we would be\n> better off to learn from another development cycle before tweaking the dust\n> limit in any sense.\n>\n> Antoine\n>\n> [0]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-May/002714.html\n> [1] https://github.com/lightningnetwork/lightning-rfc/pull/869\n>\n> Le dim. 8 ao\u00fbt 2021 \u00e0 14:53, Jeremy <jlrubin at mit.edu> a \u00e9crit :\n>\n>> We should remove the dust limit from Bitcoin. Five reasons:\n>>\n>> 1) it's not our business what outputs people want to create\n>> 2) dust outputs can be used in various authentication/delegation smart\n>> contracts\n>> 3) dust sized htlcs in lightning (\n>> https://bitcoin.stackexchange.com/questions/46730/can-you-send-amounts-that-would-typically-be-considered-dust-through-the-light)\n>> force channels to operate in a semi-trusted mode which has implications\n>> (AFAIU) for the regulatory classification of channels in various\n>> jurisdictions; agnostic treatment of fund transfers would simplify this\n>> (like getting a 0.01 cent dividend check in the mail)\n>> 4) thinly divisible colored coin protocols might make use of sats as\n>> value markers for transactions.\n>> 5) should we ever do confidential transactions we can't prevent it\n>> without compromising privacy / allowed transfers\n>>\n>> The main reasons I'm aware of not allow dust creation is that:\n>>\n>> 1) dust is spam\n>> 2) dust fingerprinting attacks\n>>\n>> 1 is (IMO) not valid given the 5 reasons above, and 2 is preventable by\n>> well behaved wallets to not redeem outputs that cost more in fees than they\n>> are worth.\n>>\n>> cheers,\n>>\n>> jeremy\n>>\n>> --\n>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>> <https://twitter.com/JeremyRubin>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210809/84b13e96/attachment-0001.html>"
            },
            {
                "author": "Jeremy",
                "date": "2021-08-10T05:04:07",
                "message_text_only": "You might be interested in https://eprint.iacr.org/2017/1066.pdf which\nclaims that you can make CT computationally hiding and binding, see section\n4.6.\n\nwith respect to utreexo, you might review\nhttps://github.com/mit-dci/utreexo/discussions/249?sort=new which discusses\ntradeoffs between different accumulator designs. With a swap tree, old\nthings that never move more or less naturally \"fall leftward\", although\nthere are reasons to prefer alternative designs.\n\n\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210809/b93d8107/attachment.html>"
            },
            {
                "author": "Billy Tetrud",
                "date": "2021-08-10T05:44:04",
                "message_text_only": "For sure, CT can be done with computational soundness. The advantage of\nunhidden amounts (as with current bitcoin) is that you get unconditional\nsoundness. My understanding is that there is a fundamental tradeoff between\nunconditional soundness and unconditional privacy. I believe Monero has\ntaken this alternate tradeoff path with unconditional privacy but only\ncomputational soundness\n<https://www.reddit.com/r/Monero/comments/8erg8e/what_should_monero_do_about_the_soundness_problem/dxy59ad?utm_source=share&utm_medium=web2x&context=3>\n.\n\n> old things that never move more or less naturally \"fall leftward\"\n\nAh yes, something like that would definitely be interesting to basically\nmake dust a moot point. Sounds like the tradeoff mentioned is that proofs\nwould be twice as big? Except newer UTXOs would have substantially shorter\nproofs. It sounds like the kind of thing where there's some point where\nthere would be so many old UTXOs that proofs would be smaller on average in\nthe swap tree version vs the dead-leaf version. Maybe someone smarter than\nme could estimate where that point is.\n\nOn Mon, Aug 9, 2021 at 10:04 PM Jeremy <jlrubin at mit.edu> wrote:\n\n> You might be interested in https://eprint.iacr.org/2017/1066.pdf which\n> claims that you can make CT computationally hiding and binding, see section\n> 4.6.\n>\n> with respect to utreexo, you might review\n> https://github.com/mit-dci/utreexo/discussions/249?sort=new which\n> discusses tradeoffs between different accumulator designs. With a swap\n> tree, old things that never move more or less naturally \"fall leftward\",\n> although there are reasons to prefer alternative designs.\n>\n>\n>>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210809/c4607f2b/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-08-10T11:37:37",
                "message_text_only": "Good morning Billy, et al.,\n\n> For sure, CT can be done with computational soundness. The advantage of unhidden amounts (as with current bitcoin) is that you get unconditional soundness.\n\nMy understanding is that it should be possible to have unconditional soundness with the use of El-Gamal commitment scheme, am I wrong?\n\nAlternately, one possible softforkable design would be for Bitcoin to maintain a non-CT block (the current scheme) and a separately-committed CT block (i.e. similar to how SegWit has a \"separate\" \"block\"/Merkle tree that includes witnesses).\nWhen transferring funds from the legacy non-CT block, on the legacy block you put it into a \"burn\" transaction that magically causes the same amount to be created (with a trivial/publicly known salt) in the CT block.\nThen to move from the CT block back to legacy non-CT you would match one of those \"burn\" TXOs and spend it, with a proof that the amount you are removing from the CT block is exactly the same value as the \"burn\" TXO you are now spending.\n\n(for additional privacy, the values of the \"burn\" TXOs might be made into some fixed single allowed value, so that transfers passing through the CT portion would have fewer identifying features)\n\nThe \"burn\" TXOs would be some trivial anyone-can-spend, such as `<saltpoint> <0> OP_EQUAL OP_NOT` with `<saltpoint>` being what is used in the CT to cover the value, and knowledge of the scalar behind this point would allow the CT output to be spent (assuming something very much like MimbleWimble is used; otherwise it could be the hash of some P2WSH or similar analogue on the CT side).\n\nBasically, this is \"CT as a 'sidechainlike' that every fullnode runs\".\n\nIn the legacy non-CT block, the total amount of funds that are in all CT outputs is known (it would be the sum total of all the \"burn\" TXOs) and will have a known upper limit, that cannot be higher than the supply limit of the legacy non-CT block, i.e. 21 million BTC.\nAt the same time, *individual* CT-block TXOs cannot have their values known; what is learnable is only how many BTC are in all CT block TXOs, which should be sufficient privacy if there are a large enough number of users of the CT block.\n\nThis allows the CT block to use an unconditional privacy and computational soundness scheme, and if somehow the computational soundness is broken then the first one to break it would be able to steal all the CT coins, but not *all* Bitcoin coins, as there would not be enough \"burn\" TXOs on the legacy non-CT blockchain.\n\nThis may be sufficient for practical privacy.\n\n\nOn the other hand, I think the dust limit still makes sense to keep for now, though.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Charlie Lee",
                "date": "2021-08-10T18:39:39",
                "message_text_only": "ZmnSCPxj, what you are describing is pretty much what Litecoin is doing\nwith MWEB. Basically MimbleWimble (which has CT) with extension blocks. If\nyou are interested:\nhttps://github.com/litecoin-project/lips/blob/master/lip-0002.mediawiki\nhttps://github.com/litecoin-project/lips/blob/master/lip-0003.mediawiki\n\nSorry to derail the conversation with non-Bitcoin stuff. \ud83d\ude00\n\n- Charlie\n\n\nOn Tue, Aug 10, 2021 at 5:38 AM ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Billy, et al.,\n>\n> > For sure, CT can be done with computational soundness. The advantage of\n> unhidden amounts (as with current bitcoin) is that you get unconditional\n> soundness.\n>\n> My understanding is that it should be possible to have unconditional\n> soundness with the use of El-Gamal commitment scheme, am I wrong?\n>\n> Alternately, one possible softforkable design would be for Bitcoin to\n> maintain a non-CT block (the current scheme) and a separately-committed CT\n> block (i.e. similar to how SegWit has a \"separate\" \"block\"/Merkle tree that\n> includes witnesses).\n> When transferring funds from the legacy non-CT block, on the legacy block\n> you put it into a \"burn\" transaction that magically causes the same amount\n> to be created (with a trivial/publicly known salt) in the CT block.\n> Then to move from the CT block back to legacy non-CT you would match one\n> of those \"burn\" TXOs and spend it, with a proof that the amount you are\n> removing from the CT block is exactly the same value as the \"burn\" TXO you\n> are now spending.\n>\n> (for additional privacy, the values of the \"burn\" TXOs might be made into\n> some fixed single allowed value, so that transfers passing through the CT\n> portion would have fewer identifying features)\n>\n> The \"burn\" TXOs would be some trivial anyone-can-spend, such as\n> `<saltpoint> <0> OP_EQUAL OP_NOT` with `<saltpoint>` being what is used in\n> the CT to cover the value, and knowledge of the scalar behind this point\n> would allow the CT output to be spent (assuming something very much like\n> MimbleWimble is used; otherwise it could be the hash of some P2WSH or\n> similar analogue on the CT side).\n>\n> Basically, this is \"CT as a 'sidechainlike' that every fullnode runs\".\n>\n> In the legacy non-CT block, the total amount of funds that are in all CT\n> outputs is known (it would be the sum total of all the \"burn\" TXOs) and\n> will have a known upper limit, that cannot be higher than the supply limit\n> of the legacy non-CT block, i.e. 21 million BTC.\n> At the same time, *individual* CT-block TXOs cannot have their values\n> known; what is learnable is only how many BTC are in all CT block TXOs,\n> which should be sufficient privacy if there are a large enough number of\n> users of the CT block.\n>\n> This allows the CT block to use an unconditional privacy and computational\n> soundness scheme, and if somehow the computational soundness is broken then\n> the first one to break it would be able to steal all the CT coins, but not\n> *all* Bitcoin coins, as there would not be enough \"burn\" TXOs on the legacy\n> non-CT blockchain.\n>\n> This may be sufficient for practical privacy.\n>\n>\n> On the other hand, I think the dust limit still makes sense to keep for\n> now, though.\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210810/2943c106/attachment.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2021-08-10T06:14:41",
                "message_text_only": "On Mon, Aug 09, 2021 at 09:22:28AM -0400, Antoine Riard wrote:\n> I'm pretty conservative about increasing the standard dust limit in any\n> way. This would convert a higher percentage of LN channels capacity into\n> dust, which is coming with a lowering of funds safety [0]. \n\nI think that reasoning is incomplete.  There are two related things here:\n\n- **Uneconomical outputs:** outputs that would cost more to spend than\n  the value they contain.\n\n- **Dust limit:** an output amount below which Bitcoin Core (and other\n  nodes) will not relay the transaction containing that output.\n\nAlthough raising the dust limit can have the effect you describe, \nincreases in the minimum necessary feerate to get a transaction\nconfirmed in an appropriate amount of time also \"converts a higher\npercentage of LN channel capacity into dust\".  As developers, we have no\ncontrol over prevailing feerates, so this is a problem LN needs to deal\nwith regardless of Bitcoin Core's dust limit.\n\n(Related to your linked thread, that seems to be about the risk of\n\"burning funds\" by paying them to a miner who may be a party to the\nattack.  There's plenty of other alternative ways to burn funds that can\nchange the risk profile.)\n\n> the standard dust limit [...] introduces a trust vector \n\nMy point above is that any trust vector is introduced not by the dust\nlimit but by the economics of outputs being worth less than they cost to\nspend.\n\n> LN node operators might be willingly to compensate this \"dust\" trust vector\n> by relying on side-trust model\n\nThey could also use trustless probabalistic payments, which have been\ndiscussed in the context of LN for handling the problem of payments too\nsmall to be represented onchain since early 2016:\nhttps://docs.google.com/presentation/d/1G4xchDGcO37DJ2lPC_XYyZIUkJc2khnLrCaZXgvDN0U/edit?pref=2&pli=1#slide=id.g85f425098_0_178\n\n(Probabalistic payments were discussed in the general context of Bitcoin\nwell before LN was proposed, and Elements even includes an opcode for\ncreating them.)\n\n> smarter engineering such as utreexo on the base-layer side \n\nUtreexo doesn't solve this problem.  Many nodes (such as miners) will\nstill want to store the full UTXO set and access it quickly,  Utreexo\nproofs will grow in size with UTXO set size (though, at best, only\nlog(n)), so full node operators will still not want their bandwidth\nwasted by people who create UTXOs they have no reason to spend.\n\n> I think the status quo is good enough for now\n\nI agree.\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210809/24595273/attachment-0001.sig>"
            },
            {
                "author": "Antoine Riard",
                "date": "2021-08-10T22:37:48",
                "message_text_only": ">  As developers, we have no\ncontrol over prevailing feerates, so this is a problem LN needs to deal\nwith regardless of Bitcoin Core's dust limit.\n\nRight, as of today, we're going to trim-to-dust any commitment output of\nwhich the value is inferior to the transaction owner's\n`dust_limit_satoshis` plus the HTLC-claim (either success/timeout) fee at\nthe agreed on feerate. So the feerate is the most significant variable in\ndefining what's a LN *uneconomical output*.\n\nIMO this approach presents annoying limitations. First, you still need to\ncome with an agreement among channel operators on the mempools feerate.\nSuch agreement might be problematic to find, as on one side you would like\nto let your counterparty free to pick up a feerate gauged as efficient for\nthe confirmation of their transactions but at the same time not too high to\nburn to fees your low-values HTLCs that *your* fee-estimator judged as sane\nto claim.\n\nSecondly, the trim-to-dust evaluation doesn't correctly match the lifetime\nof the HTLC. A HTLC might be considered as dust at block 100, at which\nmempools are full. Though its expiration only occurs at block 200, at which\nmempools are empty and this HTLC is fine to claim again. I think this\ninaccuracy will even become worse with a wider deployment of long-lived\nrouted packets over LN, such as DLCs or hodl invoices.\n\nAll this to say, if for those reasons LN devs remove feerate negotiation\nfrom the trim-to-dust definition to a static feerate, it would likely put a\nhigher pressure on the full-nodes operators, as the number of uneconomical\noutputs might increase.\n\n(From a LN viewpoint, I would say we're trying to solve a price discovery\nissue, namely the cost to write on the UTXO set, in a distributed system,\nwhere any deviation from the \"honest\" price means you trust more your LN\ncounterparty)\n\n> They could also use trustless probabalistic payments, which have been\ndiscussed in the context of LN for handling the problem of payments too\nsmall to be represented onchain since early 2016:\nhttps://docs.google.com/presentation/d/1G4xchDGcO37DJ2lPC_XYyZIUkJc2khnLrCaZXgvDN0U/edit?pref=2&pli=1#slide=id.g85f425098\n\nThanks to bringing to the surface probabilistic payments, yes that's a\nworthy alternative approach for low-value payments to keep in mind.\n\nLe mar. 10 ao\u00fbt 2021 \u00e0 02:15, David A. Harding <dave at dtrt.org> a \u00e9crit :\n\n> On Mon, Aug 09, 2021 at 09:22:28AM -0400, Antoine Riard wrote:\n> > I'm pretty conservative about increasing the standard dust limit in any\n> > way. This would convert a higher percentage of LN channels capacity into\n> > dust, which is coming with a lowering of funds safety [0].\n>\n> I think that reasoning is incomplete.  There are two related things here:\n>\n> - **Uneconomical outputs:** outputs that would cost more to spend than\n>   the value they contain.\n>\n> - **Dust limit:** an output amount below which Bitcoin Core (and other\n>   nodes) will not relay the transaction containing that output.\n>\n> Although raising the dust limit can have the effect you describe,\n> increases in the minimum necessary feerate to get a transaction\n> confirmed in an appropriate amount of time also \"converts a higher\n> percentage of LN channel capacity into dust\".  As developers, we have no\n> control over prevailing feerates, so this is a problem LN needs to deal\n> with regardless of Bitcoin Core's dust limit.\n>\n> (Related to your linked thread, that seems to be about the risk of\n> \"burning funds\" by paying them to a miner who may be a party to the\n> attack.  There's plenty of other alternative ways to burn funds that can\n> change the risk profile.)\n>\n> > the standard dust limit [...] introduces a trust vector\n>\n> My point above is that any trust vector is introduced not by the dust\n> limit but by the economics of outputs being worth less than they cost to\n> spend.\n>\n> > LN node operators might be willingly to compensate this \"dust\" trust\n> vector\n> > by relying on side-trust model\n>\n> They could also use trustless probabalistic payments, which have been\n> discussed in the context of LN for handling the problem of payments too\n> small to be represented onchain since early 2016:\n>\n> https://docs.google.com/presentation/d/1G4xchDGcO37DJ2lPC_XYyZIUkJc2khnLrCaZXgvDN0U/edit?pref=2&pli=1#slide=id.g85f425098_0_178\n>\n> (Probabalistic payments were discussed in the general context of Bitcoin\n> well before LN was proposed, and Elements even includes an opcode for\n> creating them.)\n>\n> > smarter engineering such as utreexo on the base-layer side\n>\n> Utreexo doesn't solve this problem.  Many nodes (such as miners) will\n> still want to store the full UTXO set and access it quickly,  Utreexo\n> proofs will grow in size with UTXO set size (though, at best, only\n> log(n)), so full node operators will still not want their bandwidth\n> wasted by people who create UTXOs they have no reason to spend.\n>\n> > I think the status quo is good enough for now\n>\n> I agree.\n>\n> -Dave\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210810/c82980c2/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-08-11T00:46:36",
                "message_text_only": "Good morning all,\n\nThinking a little more, if the dust limit is intended to help keep UTXO sets down, then on the LN side, this could be achieved as well by using channel factories (including \"one-shot\" factories which do not allow changing the topology of the subgraph inside the factory, but have the advantage of not requiring either `SIGHASH_NOINPUT` or an extra CSV constraint that is difficult to weigh in routing algorithms), where multiple channels are backed by a single UTXO.\n\nOf course, with channel factories there is now a greater set of participants who will have differing opinions on appropriate feerate.\n\nSo I suppose one can argue that the dust limit becomes less material to higher layers, than actual onchain feerates.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Anthony Towns",
                "date": "2021-08-12T22:03:39",
                "message_text_only": "On Tue, Aug 10, 2021 at 06:37:48PM -0400, Antoine Riard via bitcoin-dev wrote:\n> Secondly, the trim-to-dust evaluation doesn't correctly match the lifetime of\n> the HTLC.\n\nRight: but that just means it's not something you should determine once\nfor the HTLC, but something you should determine each time you update the\nchannel commitment -- if fee rates are at 1sat/vb, then a 10,000 sat HTLC\nthat's going to cost 100 sats to create the utxo and eventually claim it\nmight be worth committing to, but if fee rates suddenly rise to 75sat/vb,\nthen the combined cost of 7500 sat probably isn't worthwhile (and it\ncertainly isn't worthwhile if fees rise to above 100sat/vb).\n\nThat's independent of dust limits -- those only give you a fixed size\nlower limit or about 305sats for p2wsh outputs.\n\nThings become irrational before they become uneconomic as well: ie the\n100vb is perhaps 40vb to create then 60vb to spend, so if you create\nthe utxo anyway then the 40vb is a sunk cost, and redeeming the 10k sats\nmight still be marginally wortwhile up until about 167sat/vb fee rate.\n\nBut note the logic there: it's an uneconomic output if fees rise above\n167sat/vb, but it was already economically irrational for the two parties\nto create it in the first place when fees were at or above 100sat/vb. If\nyou're trying to save every sat, dust limits aren't your problem. If\nyou're not trying to save every sat, then just add 305 sats to your\noutput so you avoid the dust limit.\n\n(And the dust limit is only preventing you from creating outputs that\nwould be irrational if they only required a pubkey reveal and signature\nto spend -- so a HTLC that requires revealing a script, two hashes,\ntwo pubkeys, a hash preimage and two signatures with the same dust\nthreshold value for p2wsh of ~305sats would already be irrational at\nabout 2.1sat/vb and unconomic at 2.75 sat/vb).\n\n> (From a LN viewpoint, I would say we're trying to solve a price discovery\n> issue, namely the cost to write on the UTXO set, in a distributed system, where\n> any deviation from the \"honest\" price means you trust more your LN\n> counterparty)\n\nAt these amounts you're already trusting your LN counterparty to not just\nclose the channel unilaterally at a high fee rate time and waste your\nfunds in fees, vs doing a much for efficient mutual/cooperative close.\n\nCheers,\naj"
            },
            {
                "author": "Jeremy",
                "date": "2021-08-20T04:51:31",
                "message_text_only": "one interesting point that came up at the bitdevs in austin today that\nfavors remove that i believe is new to this discussion (it was new to me):\n\nthe argument can be reduced to:\n\n- dust limit is a per-node relay policy.\n- it is rational for miners to mine dust outputs given their cost of\nmaintenance (storing the output potentially forever) is lower than their\nimmediate reward in fees.\n- if txn relaying nodes censor something that a miner would mine, users\nwill seek a private/direct relay to the miner and vice versa.\n- if direct relay to miner becomes popular, it is both bad for privacy and\ndecentralization.\n- therefore the dust limit, should there be demand to create dust at\nprevailing mempool feerates, causes an incentive to increase network\ncentralization (immediately)\n\nthe tradeoff is if a short term immediate incentive to promote network\ncentralization is better or worse than a long term node operator overhead.\n\n\n///////////////////\n\nmy take is that:\n\n1) having a dust limit is worse since we'd rather not have an incentive to\nproduce or roll out centralizing software, whereas not having a dust limit\ncreates an mild incentive for node operators to improve utreexo\ndecentralizing software.\n2) it's hard to quantify the magnitude of the incentives, which does matter.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210819/831b9608/attachment.html>"
            },
            {
                "author": "shymaa arafat",
                "date": "2021-08-20T05:45:31",
                "message_text_only": "On Fri, Aug 20, 2021, 06:52 Jeremy via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> one interesting point that came up at the bitdevs in austin today that\n> favors remove that i believe is new to this discussion (it was new to me):\n>\n> the argument can be reduced to:\n>\n> - dust limit is a per-node relay policy.\n> - it is rational for miners to mine dust outputs given their cost of\n> maintenance (storing the output potentially forever) is lower than their\n> immediate reward in fees.\n>\n-Here, u  r assuming miners not running full nodes, or even stateless nodes\nas in Utreexo\n-otherwise they suffer from storing dust UTXOS/their effect on proof\nlength, right?\n\n- if txn relaying nodes censor something that a miner would mine, users\n> will seek a private/direct relay to the miner and vice versa.\n> - if direct relay to miner becomes popular, it is both bad for privacy and\n> decentralization.\n> - therefore the dust limit, should there be demand to create dust at\n> prevailing mempool feerates, causes an incentive to increase network\n> centralization (immediately)\n>\n> the tradeoff is if a short term immediate incentive to promote network\n> centralization is better or worse than a long term node operator overhead.\n>\n>\n> ///////////////////\n>\n> my take is that:\n>\n> 1) having a dust limit is worse since we'd rather not have an incentive to\n> produce or roll out centralizing software, whereas not having a dust limit\n> creates an mild incentive for node operators to improve utreexo\n> decentralizing software.\n>\nWhy not having dust limit improves Utreexo, I think (and tried to suggest\nmany times) separate storing of dust&other non spendable UTXOS (and their\nhashes) so that they do not affect other UTXOS proofs ( and not brought\ninto main memory unless called as a TXO)\n\n2) it's hard to quantify the magnitude of the incentives, which does matter.\n>\nI honestly don't get the long term perspective of miners Incentivised to\nstoring small dust UTXOS instead of having their values added to the fee.\n\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210820/607a4fa6/attachment-0001.html>"
            },
            {
                "author": "Billy Tetrud",
                "date": "2021-08-26T21:21:25",
                "message_text_only": "One interesting thing I thought of: the cost of maintenance of the dust\ncreates a (very) small incentive to mine transactions that *use* dust\noutputs with a slightly lower fee that contain dust, in order to reduce the\nfuture maintenance cost for themselves. However, the rational discount\nwould likely be vanishingly small.  It would be interesting to add\nsomething to the consensus rules to decrease the vbytes for a transaction\nthat consumes dust outputs such that the value of removing them from the\nsystem (saving the future cost of maintenance) is approximately equal to\nthe amount that the fee could be made lower for such transactions. Even\nmeasuring this as a value over the whole (future) bitcoin network, I'm not\nsure how to evaluate the magnitude of this future cost.\n\n\n\n\n\nOn Fri, Aug 20, 2021 at 8:12 PM ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Jeremy,\n>\n> > one interesting point that came up at the bitdevs in austin today that\n> favors remove that i believe is new to this discussion (it was new to me):\n> >\n> > the argument can be reduced to:\n> >\n> > - dust limit is a per-node relay policy.\n> > - it is rational for miners to mine dust outputs given their cost of\n> maintenance (storing the output potentially forever) is lower than their\n> immediate reward in fees.\n> > - if txn relaying nodes censor something that a miner would mine, users\n> will seek a private/direct relay to the miner and vice versa.\n> > - if direct relay to miner becomes popular, it is both bad for privacy\n> and decentralization.\n> > - therefore the dust limit, should there be demand to create dust at\n> prevailing mempool feerates, causes an incentive to increase network\n> centralization (immediately)\n> >\n> > the tradeoff is if a short term immediate incentive to promote network\n> centralization is better or worse than a long term node operator overhead.\n>\n> Against the above, we should note that in the Lightning spec, when an\n> output *would have been* created that is less than the dust limit, the\n> output is instead put into fees.\n>\n> https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#trimmed-outputs\n>\n> Thus, the existence of a dust limit encourages L2 protocols to have\n> similar rules, where outputs below the dust limit are just given over as\n> fees to miners, so the existence of a dust limit might very well be\n> incentivize-compatible for miners, regardless of centralization effects or\n> not.\n>\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210826/952bece6/attachment-0001.html>"
            },
            {
                "author": "shymaa arafat",
                "date": "2021-08-27T09:07:35",
                "message_text_only": "Allow me to ask:\n\n-Untill you find a mitigation that consolidate all dust UTXOS, why don't\nyou separate them and all probably Unspendable UTXOS in a different\npartition?\n-I'm talking at the real UTXO storage level (to be kept in secondary\nstorage), and at the Merkleization level in any accumulator design Utreexo\nor what so ever(putting them in one or two subtree/forest with hardly\nchanging roots according to the categorization will reduce the proof size,\neven if slightly)\n-This will also help things like Bloom filters, assume UTXOs,...etc when\nabout 10% with almost zero probability are trimmed from the pool you are\nwithdrawing from.\n.\n-The paper I mentioned earlier says in Feb 2018, there was about 2.4m UTXOS\nless than 1000 Satoshi, of which ~824,892 holds exactly 1 Satoshi\n-I don't think any of those were spent since that time, in fact there could\nbe a possibility that the numbers may have increased\n-As the last previous reply mentioned you have to consider the long run\neffect on the UTXO set forever, this is a straight forward improvement that\ncomes with almost no effort\n.\nPs.\n-If there is something wrong, something I missed in this idea please\nexplain it to me\n-Or do you find the improvement itself a \"dust\" that doesn't worth the\neffort???\n.\nRegards & thank you all for your time in reading & replying\nShymaa M. Arafat\nOn Fri, Aug 27, 2021, 00:06 Billy Tetrud via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> One interesting thing I thought of: the cost of maintenance of the dust\n> creates a (very) small incentive to mine transactions that *use* dust\n> outputs with a slightly lower fee that contain dust, in order to reduce the\n> future maintenance cost for themselves. However, the rational discount\n> would likely be vanishingly small.  It would be interesting to add\n> something to the consensus rules to decrease the vbytes for a transaction\n> that consumes dust outputs such that the value of removing them from the\n> system (saving the future cost of maintenance) is approximately equal to\n> the amount that the fee could be made lower for such transactions. Even\n> measuring this as a value over the whole (future) bitcoin network, I'm not\n> sure how to evaluate the magnitude of this future cost.\n>\n>\n>\n>\n>\n> On Fri, Aug 20, 2021 at 8:12 PM ZmnSCPxj via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Good morning Jeremy,\n>>\n>> > one interesting point that came up at the bitdevs in austin today that\n>> favors remove that i believe is new to this discussion (it was new to me):\n>> >\n>> > the argument can be reduced to:\n>> >\n>> > - dust limit is a per-node relay policy.\n>> > - it is rational for miners to mine dust outputs given their cost of\n>> maintenance (storing the output potentially forever) is lower than their\n>> immediate reward in fees.\n>> > - if txn relaying nodes censor something that a miner would mine, users\n>> will seek a private/direct relay to the miner and vice versa.\n>> > - if direct relay to miner becomes popular, it is both bad for privacy\n>> and decentralization.\n>> > - therefore the dust limit, should there be demand to create dust at\n>> prevailing mempool feerates, causes an incentive to increase network\n>> centralization (immediately)\n>> >\n>> > the tradeoff is if a short term immediate incentive to promote network\n>> centralization is better or worse than a long term node operator overhead.\n>>\n>> Against the above, we should note that in the Lightning spec, when an\n>> output *would have been* created that is less than the dust limit, the\n>> output is instead put into fees.\n>>\n>> https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#trimmed-outputs\n>>\n>> Thus, the existence of a dust limit encourages L2 protocols to have\n>> similar rules, where outputs below the dust limit are just given over as\n>> fees to miners, so the existence of a dust limit might very well be\n>> incentivize-compatible for miners, regardless of centralization effects or\n>> not.\n>>\n>>\n>> Regards,\n>> ZmnSCPxj\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210827/f42a4a62/attachment.html>"
            },
            {
                "author": "LORD HIS EXCELLENCY JAMES HRMH",
                "date": "2021-08-30T03:31:56",
                "message_text_only": "Good Afternoon,\n\nIt is worth reconsidering the value accumulated in dust. Speculatively, when the value of 1 BTC reaches US$ 1,000,000.00 then the value of one satoshi will be US$ 0.01 so, for 1 satoshi to be of any substantial value the value of Bitcoin will have to rise substantially higher. I ask what then should the value of fees be? Is there not a future case foreseeable at least in consideration of Bitcoin's comparison with Gold that the value may be so high as to allow that 1 satoshi may cover the mining cost of any transaction despite the reduction in sat/B for including the additional transaction. Is it not that we can foresee the dust has value and that the wealthy may have in fact millions of dust transactions that are inheritable, though I hesitate to make my business collecting them I may set up a website. The current reason for excluding dust is because it costs more to the transaction to add the dust than its value but that does not say that will always be the case.\n\nKING JAMES HRMH\nGreat British Empire\n\nRegards,\nThe Australian\nLORD HIS EXCELLENCY JAMES HRMH (& HMRH)\nof Hougun Manor & Glencoe & British Empire\nMR. Damian A. James Williamson\nWills\n\net al.\n\n\nWilltech\nwww.willtech.com.au\nwww.go-overt.com\nand other projects\n\nearn.com/willtech\nlinkedin.com/in/damianwilliamson\n\n\nm. 0487135719\nf. +61261470192\n\n\nThis email does not constitute a general advice. Please disregard this email if misdelivered.\n----\n________________________________\nFrom: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of shymaa arafat via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nSent: Friday, 27 August 2021 7:07 PM\nTo: Billy Tetrud <billy.tetrud at gmail.com>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>\nCc: lightning-dev <lightning-dev at lists.linuxfoundation.org>\nSubject: Re: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit\n\nAllow me to ask:\n\n-Untill you find a mitigation that consolidate all dust UTXOS, why don't you separate them and all probably Unspendable UTXOS in a different partition?\n-I'm talking at the real UTXO storage level (to be kept in secondary storage), and at the Merkleization level in any accumulator design Utreexo or what so ever(putting them in one or two subtree/forest with hardly changing roots according to the categorization will reduce the proof size, even if slightly)\n-This will also help things like Bloom filters, assume UTXOs,...etc when about 10% with almost zero probability are trimmed from the pool you are withdrawing from.\n.\n-The paper I mentioned earlier says in Feb 2018, there was about 2.4m UTXOS less than 1000 Satoshi, of which ~824,892 holds exactly 1 Satoshi\n-I don't think any of those were spent since that time, in fact there could be a possibility that the numbers may have increased\n-As the last previous reply mentioned you have to consider the long run effect on the UTXO set forever, this is a straight forward improvement that comes with almost no effort\n.\nPs.\n-If there is something wrong, something I missed in this idea please explain it to me\n-Or do you find the improvement itself a \"dust\" that doesn't worth the effort???\n.\nRegards & thank you all for your time in reading & replying\nShymaa M. Arafat\nOn Fri, Aug 27, 2021, 00:06 Billy Tetrud via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n\nOne interesting thing I thought of: the cost of maintenance of the dust creates a (very) small incentive to mine transactions that *use* dust outputs with a slightly lower fee that contain dust, in order to reduce the future maintenance cost for themselves. However, the rational discount would likely be vanishingly small.  It would be interesting to add something to the consensus rules to decrease the vbytes for a transaction that consumes dust outputs such that the value of removing them from the system (saving the future cost of maintenance) is approximately equal to the amount that the fee could be made lower for such transactions. Even measuring this as a value over the whole (future) bitcoin network, I'm not sure how to evaluate the magnitude of this future cost.\n\n\n\n\n\nOn Fri, Aug 20, 2021 at 8:12 PM ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\nGood morning Jeremy,\n\n> one interesting point that came up at the bitdevs in austin today that favors remove that i believe is new to this discussion (it was new to me):\n>\n> the argument can be reduced to:\n>\n> - dust limit is a per-node relay policy.\n> - it is rational for miners to mine dust outputs given their cost of maintenance (storing the output potentially forever) is lower than their immediate reward in fees.\n> - if txn relaying nodes censor something that a miner would mine, users will seek a private/direct relay to the miner and vice versa.\n> - if direct relay to miner becomes popular, it is both bad for privacy and decentralization.\n> - therefore the dust limit, should there be demand to create dust at prevailing mempool feerates, causes an incentive to increase network centralization (immediately)\n>\n> the tradeoff is if a short term immediate incentive to promote network centralization is better or worse than a long term node operator overhead.\n\nAgainst the above, we should note that in the Lightning spec, when an output *would have been* created that is less than the dust limit, the output is instead put into fees.\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#trimmed-outputs\n\nThus, the existence of a dust limit encourages L2 protocols to have similar rules, where outputs below the dust limit are just given over as fees to miners, so the existence of a dust limit might very well be incentivize-compatible for miners, regardless of centralization effects or not.\n\n\nRegards,\nZmnSCPxj\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210830/252c9f16/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Removing the Dust Limit",
            "categories": [
                "bitcoin-dev",
                "Lightning-dev"
            ],
            "authors": [
                "Jeremy",
                "Antoine Riard",
                "David A. Harding",
                "LORD HIS EXCELLENCY JAMES HRMH",
                "Anthony Towns",
                "Charlie Lee",
                "shymaa arafat",
                "ZmnSCPxj",
                "Billy Tetrud"
            ],
            "messages_count": 19,
            "total_messages_chars_count": 62018
        }
    },
    {
        "title": "[bitcoin-dev] [Lightning-dev]   Removing the Dust Limit",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2021-08-21T03:10:46",
                "message_text_only": "Good morning Jeremy,\n\n> one interesting point that came up at the bitdevs in austin today that favors remove that i believe is new to this discussion (it was new to me):\n>\n> the argument can be reduced to:\n>\n> - dust limit is a per-node relay policy.\n> - it is rational for miners to mine dust outputs given their cost of maintenance\u00a0(storing the output potentially forever) is lower than their immediate reward in fees.\n> - if txn relaying nodes censor something that a miner would mine, users will seek a private/direct relay to the miner and vice versa.\n> - if direct relay to miner becomes popular, it is both bad for privacy and decentralization.\n> - therefore the dust limit, should there be demand to create dust at prevailing mempool feerates, causes an incentive to increase network centralization\u00a0(immediately)\n>\n> the tradeoff is if a short term immediate incentive to promote network centralization is better or worse than a long term node operator overhead.\n\nAgainst the above, we should note that in the Lightning spec, when an output *would have been* created that is less than the dust limit, the output is instead put into fees.\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#trimmed-outputs\n\nThus, the existence of a dust limit encourages L2 protocols to have similar rules, where outputs below the dust limit are just given over as fees to miners, so the existence of a dust limit might very well be incentivize-compatible for miners, regardless of centralization effects or not.\n\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Removing the Dust Limit",
            "categories": [
                "bitcoin-dev",
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1552
        }
    },
    {
        "title": "[bitcoin-dev] Fwd: NLnet cryotoprimitives grant approved",
        "thread_messages": [
            {
                "author": "Luke Kenneth Casson Leighton",
                "date": "2021-08-10T12:54:55",
                "message_text_only": "with many thanks to NLnet, the EUR 50,000 grant to research and\ndevelop Draft cryptographic primitives and instructions to the\nnewly-open Power ISA has been approved.\n\nunlike RISC-V where full transparency and trust is problematic and\nthere are many participants whose interests may not necessarily align,\nthe OpenPOWER initiative, which has been in careful planning for\nnearly 10 years, is a much less crowded space and, crucially, does not\nrequire non-transparent membership of OPF in order to submit ISA RFCs\n(Requests for Change)\n\n[non-OPF members cannot participate in actual ISA WG meetings and\ncertainly cannot vote on RFCs, but they can at least submit them.\nwhereas whilst the RISC-V Foundation's Commercial Confidence\nRequirements are perfectly reasonable, the blanket secrecy even for\nsubmitting RFCs is not]\n\nwe at Libre-SOC aim to use this process, based on taking apart key\nstrategic cryptographic algorithms back to their mathematical roots,\nthen applying Vector ISA design analysis and seeing what can be\ncreated.\n\nexamples include going back to the fundamental basis of Rijndael, and\ninstead of creating hardcoded custom silicon for MixColumns as is the\n\"normal\" practice, adding a generic Galois Field ALU and a generic\nMatrix Multiply system.  another is to design instructions suitable\nfor \"big integer math\"\n\nthis in turn means that the resultant ISA would be ideally suited to\nthe experimental development of future cryptographic algorithms for\nuse in securing wallets and other purposes related to blockchain\nmanagement.\n\n[as bitcoin stands we cannot possibly hope to compete with custom\nsilicon dedicated to SHA hash production, however we would very much\nlike to see a future version of bitcoin that uses far less power yet\nretains its high strategic value, and, at the same time, like e.g.\nmonero RandomX, is better suited to a general-purpose Vector\nSupercomputer ISA, which is what we are developing]\n\nOpenPOWER's commitment to a transparent RFC process allows us to do\nthat without compromising trust: no discussions that we participate in\nwill ever be behind closed doors.\n\nif anyone would be interested to participate or collaborate on this,\nwe have funding available, and welcome involvement in designing and\ntesting an ISA suitable for securing bitcoin for end-users in a fully\ntransparent fashion.\n\nl.\n\n---\ncrowd-funded eco-conscious hardware: https://www.crowdsupply.com/eoma68"
            }
        ],
        "thread_summary": {
            "title": "Fwd: NLnet cryotoprimitives grant approved",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Luke Kenneth Casson Leighton"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2412
        }
    },
    {
        "title": "[bitcoin-dev] [Lightning-dev] Removing the Dust Limit Message-ID:",
        "thread_messages": [
            {
                "author": "John Tromp",
                "date": "2021-08-10T21:03:11",
                "message_text_only": "> Alternately, one possible softforkable design would be for Bitcoin to maintain a non-CT block (the current scheme) and a separately-committed CT block (i.e. similar to how SegWit has a \"separate\" \"block\"/Merkle tree that includes witnesses).\n> When transferring funds from the legacy non-CT block, on the legacy block you put it into a \"burn\" transaction that magically causes the same amount to be created (with a trivial/publicly known salt) in the CT block.\n> Then to move from the CT block back to legacy non-CT you would match one of those \"burn\" TXOs and spend it, with a proof that the amount you are removing from the CT block is exactly the same value as the \"burn\" TXO you are now spending.\n\n> (for additional privacy, the values of the \"burn\" TXOs might be made into some fixed single allowed value, so that transfers passing through the CT portion would have fewer identifying features)\n>\n> The \"burn\" TXOs would be some trivial anyone-can-spend, such as `<saltpoint> <0> OP_EQUAL OP_NOT` with `<saltpoint>` being what is used in the CT to cover the value, and knowledge of the scalar behind this point would allow the CT output to be spent (assuming something very much like MimbleWimble is used; otherwise it could be the hash of some P2WSH or similar analogue on the CT side).\n>\n> Basically, this is \"CT as a 'sidechainlike' that every fullnode runs\".\n>\n> In the legacy non-CT block, the total amount of funds that are in all CT outputs is known (it would be the sum total of all the \"burn\" TXOs) and will have a known upper limit, that cannot be higher than the supply limit of the legacy non-CT block, i.e. 21 million BTC.\n> At the same time, *individual* CT-block TXOs cannot have their values known; what is learnable is only how many BTC are in all CT block TXOs, which should be sufficient privacy if there are a large enough number of users of the CT block.\n>\n> This allows the CT block to use an unconditional privacy and computational soundness scheme, and if somehow the computational soundness is broken then the first one to break it would be able to steal all the CT coins, but not *all* Bitcoin coins, as there would not be enough \"burn\" TXOs on the legacy non-CT blockchain.\n>\n> This may be sufficient for practical privacy.\n\nThis is pretty much the Mimble Wimble Extension Block (MWEB) design\nfor Litecoin, as described at\nhttps://vaultoro.com/what-is-mweb-on-litecoin/\n\nTrue to the Harry Potter background theme of Mimblewimble, the regular\nLitecoin transaction responsible for pegging into and out of the\nextension block is call the Hogwarts Express (hogex).\n\nIf all goes well, it may activate as early as the end of this year...\n\nregards,\n-John"
            }
        ],
        "thread_summary": {
            "title": "Removing the Dust Limit Message-ID:",
            "categories": [
                "bitcoin-dev",
                "Lightning-dev"
            ],
            "authors": [
                "John Tromp"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2680
        }
    },
    {
        "title": "[bitcoin-dev] src/httprpc.cpp InterruptHTTPRPC",
        "thread_messages": [
            {
                "author": "Ali Sherief",
                "date": "2021-08-12T16:26:23",
                "message_text_only": "I am using Bitcoin Core's HTTP RPC server as a basis for my own application. While browsing the source code of src/httprpc.cpp, I notice that the InterruptHTTPRPC function https://github.com/bitcoin/bitcoin/blob/7fcf53f7b4524572d1d0c9a5fdc388e87eb02416/src/httprpc.cpp#L310-L314 just calls LogPrint() without doing anything else.\n\nDoes the HTTP RPC server support interrupting the event loop at this time, or is this method a stub?\n\n- Ali\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210812/40816fcb/attachment.html>"
            },
            {
                "author": "Jeremy",
                "date": "2021-08-12T18:09:19",
                "message_text_only": "This is probably best to open as an issue in github!\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\n\nOn Thu, Aug 12, 2021 at 11:03 AM Ali Sherief via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I am using Bitcoin Core's HTTP RPC server as a basis for my own\n> application. While browsing the source code of src/httprpc.cpp, I notice\n> that the InterruptHTTPRPC function\n> https://github.com/bitcoin/bitcoin/blob/7fcf53f7b4524572d1d0c9a5fdc388e87eb02416/src/httprpc.cpp#L310-L314 just\n> calls LogPrint() without doing anything else.\n>\n> Does the HTTP RPC server support interrupting the event loop at this time,\n> or is this method a stub?\n>\n> - Ali\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210812/63ded220/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "src/httprpc.cpp InterruptHTTPRPC",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Ali Sherief",
                "Jeremy"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1699
        }
    },
    {
        "title": "[bitcoin-dev] PSA: Taproot loss of quantum protections",
        "thread_messages": [
            {
                "author": "Erik Aronesty",
                "date": "2021-08-12T22:08:40",
                "message_text_only": "Noe: for A. Chow's upgrade to work, there obviously has to be an\neffort to deliberately-blacklist unupgraded coins, say after 10-20\nyears of opportunity to upgrade, or something like that, as long as\nthe transition to quantum isn't so fast that there's no way to do\nthis.\n\nOn Mon, Mar 22, 2021 at 10:24 AM Erik Aronesty <erik at q32.com> wrote:\n>\n> The argument that hashed public addresses provide meaningful quantum\n> resistance is flawed *when considered in the context*.of Bitcoin\n> itself.\n>\n> This article by Andrew Chow is easy to read and makes a strong case\n> against the quantum utility of hashed public keys:\n> https://cryptowords.github.io/why-does-hashing-public-keys-not-actually-provide-any-quantum-resistance\n>\n> And then, of course, one should be mindful of the case against quantum\n> computing itself - it is neither inevitable nor \"just around the\n> corner\".   Mikhail Dyakonov summarized the arguments well here:\n> https://t.co/cgrfrroTTT?amp=1.\n>\n> My current stance (at my company at least) is that planning for\n> quantum computing should be limited to \"a provable and written ability\n> to upgrade if it becomes clear that it's necessary.\"\n>\n> Does anyone think it would it be useful to write up a more official,\n> and even partly functional plan for Bitcoin to use zero-knowledge\n> proofs to transition to quantum resistance?\n>\n> - Erik Aronesty\n>   CTO, Atkama\n>\n> On Mon, Mar 15, 2021 at 5:48 PM Luke Dashjr via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> > I do not personally see this as a reason to NACK Taproot, but it has become\n> > clear to me over the past week or so that many others are unaware of this\n> > tradeoff, so I am sharing it here to ensure the wider community is aware of\n> > it and can make their own judgements.\n> >\n> > Mark Friedenbach explains on his blog:\n> >     https://freicoin.substack.com/p/why-im-against-taproot\n> >\n> > In short, Taproot loses an important safety protection against quantum.\n> > Note that in all circumstances, Bitcoin is endangered when QC becomes a\n> > reality, but pre-Taproot, it is possible for the network to \"pause\" while a\n> > full quantum-safe fix is developed, and then resume transacting. With Taproot\n> > as-is, it could very well become an unrecoverable situation if QC go online\n> > prior to having a full quantum-safe solution.\n> >\n> > Also, what I didn't know myself until today, is that we do not actually gain\n> > anything from this: the features proposed to make use of the raw keys being\n> > public prior to spending can be implemented with hashed keys as well.\n> > It would use significantly more CPU time and bandwidth (between private\n> > parties, not on-chain), but there should be no shortage of that for anyone\n> > running a full node (indeed, CPU time is freed up by Taproot!); at worst, it\n> > would create an incentive for more people to use their own full node, which\n> > is a good thing!\n> >\n> > Despite this, I still don't think it's a reason to NACK Taproot: it should be\n> > fairly trivial to add a hash on top in an additional softfork and fix this.\n> >\n> > In addition to the points made by Mark, I also want to add two more, in\n> > response to Pieter's \"you can't claim much security if 37% of the supply is\n> > at risk\" argument. This argument is based in part on the fact that many\n> > people reuse Bitcoin invoice addresses.\n> >\n> > First, so long as we have hash-based addresses as a best practice, we can\n> > continue to shrink the percentage of bitcoins affected through social efforts\n> > discouraging address use. If the standard loses the hash, the situation\n> > cannot be improved, and will indeed only get worse.\n> >\n> > Second, when/if quantum does compromise these coins, so long as they are\n> > neglected or abandoned/lost coins (inherent in the current model), it can be\n> > seen as equivalent to Bitcoin mining. At the end of the day, 37% of supply\n> > minable by QCs is really no different than 37% minable by ASICs. (We've seen\n> > far higher %s available for mining obviously.)\n> >\n> > To conclude, I recommend anyone using Bitcoin to read Mark's article, my\n> > thoughts, and any other arguments on the topic; decide if this is a concern\n> > to you, and make your own post(s) accordingly. Mark has conceded the argument\n> > (AFAIK he doesn't have an interest in bitcoins anyway), and I do not consider\n> > it a showstopper - so if anyone else out there does, please make yourself\n> > known ASAP since Taproot has already moved on to the activation phase and it\n> > is likely software will be released within the next month or two as things\n> > stand.\n> >\n> > Luke\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "PSA: Taproot loss of quantum protections",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Erik Aronesty"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 4813
        }
    },
    {
        "title": "[bitcoin-dev] bitcoin-ps | Desktop application to test Bitcoin Core using PowerShell scripts",
        "thread_messages": [
            {
                "author": "Prayank",
                "date": "2021-08-14T01:15:20",
                "message_text_only": "Hello World,\n\nI was working on an intern project in last few weeks which is almost ready for first release. Will be helpful if devs working on Bitcoin Core and .NET projects related to Bitcoin can share feedback. Pieter Wuille and Luke Dashjr had already shared few things before I started working on this project which wasn't really positive considering the use of .NET and PowerShell in this project. I respect their opinion and agree we could make better applications however I have tried my best to express the goal I am trying to achieve with this project below.\n\nProject repository:\u00a0https://github.com/prayank23/bitcoin-ps\n\nOther details about related milestones:\u00a0https://github.com/BlockchainCommons/Community/discussions/51\n\nProject is inspired by Burp Suite and I want to create a similar application which is only used to test privacy and security of Bitcoin Core RPC using GUI. I used WPF instead of Avalonia right now to save time. I will use it in future to make bitcoin-ps cross platform, most of the code will remain same and I have shared a proof of concept in milestones link above in which application works fine on Ubuntu with no pwsh installed. Hopefully this issue will also be resolved soon:\u00a0https://github.com/AvaloniaUI/Avalonia/issues/4361\n\nDefault scripts:\n\n1.CPU_RAM_sendtoaddress.ps1 : Check CPU and RAM usage while using some wallet RPCs multiple times. Results for Ubuntu and Windows were interesting. For some reason it almost used 100% CPU in Ubuntu.\n\n2.onlynet_i2p.ps1 : Outbound connections are made to onion peers while onlynet=i2p is used without any proxy\n\n3.lock_unspent.ps1 : Check if locked UTXOs are unlocked on restart\n\n4.custom_change_rbf.ps1: Compares the inputs for Tx1 and Tx2 where Tx1 is RBF transaction with 1 input, 2 ouputs (custom change address with label), Tx2 is replacement transaction\n\nWhy PowerShell?\n\n1.I have worked on 2 similar projects in past: A basic application for Office 365 admins and support engineers and One project related to Infosec.\n2.Testing using different languages locally doesn't impact Bitcoin Core or require any changes.\n3.Easier to write and devs who use PowerShell scripts in their projects could relate to it, find interesting and maybe start contributing to Bitcoin Core.\n4.It can be done using bash or maybe python scripts as well. For me using PowerShell in this project is like meeting a college friend and exploring new places.\n5.PowerShell Core is open source and works on Linux, Mac etc.\n\nLast but not least, I would like to thank Christopher, Vinay, guests in meetings, other interns and everyone involved in Blockchain Commons. I have learnt lot of new things during internship. Would suggest everyone to start with 'Learning Bitcoin from the Command Line' if they have recently started reading about Bitcoin. I wish I could do more projects, will work on DEX and OfflineTx even after internship ends to complete by end of this year.\n-- \nPrayank\n\nA3B1 E430 2298 178F \n\u00a0\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210814/617f14bf/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "bitcoin-ps | Desktop application to test Bitcoin Core using PowerShell scripts",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Prayank"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3146
        }
    },
    {
        "title": "[bitcoin-dev] Human readable checksum (verification code) to avoid errors on BTC public addresses",
        "thread_messages": [
            {
                "author": "ts",
                "date": "2021-08-16T04:23:25",
                "message_text_only": "Entering a BTC address for a transaction can pose a risk of error (human or technical). While \nthere is a checksum integrated in BTC addresses already, this is used only at a technical \nlevel and does not avoid entering a valid but otherwise wrong address. Moreover, it does not \nimprove the overall user experience.\n\nIn case this hasn't been discussed before, I propose to implement a 3 or 4 digit code (lets \ncall it 4DC for this text), generated as checksum from the address. This 4DC should be shown \nin all wallets next to the receiving address. When entering a new address to send BTC, the \nsending wallet should also show the 4DC next to the entered address. This way, the sending \nperson can easily verify that the resulting 4DC matches the one from the receiving address.\n\nThis would mean that a receiver would not only send his public address to the sender, but also \nthe 4DC. A minor disadvantage since a) it is not mandatory and b) it is very easy to do. \nHowever, it would greatly reduce the probability of performing transactions to a wrong address.\n\nTechnically, this is very easy to implement. The only effort needed is agreeing on a checksum \nstandard to generate the code. Once the standard is established, all wallet and exchange \ndevelopers can start implementing this.\n\nAgreeing on a good name for this code would be helpful for a fast adoption (human readable \nchecksum, verification code or 4DC are just examples).\n\nObviously, this solution could be used for all other coins/networks. But ideally, each of them \nshould have its own checksum algorithm, in order to further avoid sending funds to the wrong \nnetwork. Especially when the address standard is the same like it is the case with BTC and BCH.\n\nHopefully, Bitcoin can implement this first and serve as example-to-follow to other \ncoins/networks.\n\nCheers,\nTS"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-08-16T10:34:36",
                "message_text_only": "Good morning TS,\n\n> Entering a BTC address for a transaction can pose a risk of error (human or technical). While\n> there is a checksum integrated in BTC addresses already, this is used only at a technical\n> level and does not avoid entering a valid but otherwise wrong address. Moreover, it does not\n> improve the overall user experience.\n>\n> In case this hasn't been discussed before, I propose to implement a 3 or 4 digit code (lets\n> call it 4DC for this text), generated as checksum from the address. This 4DC should be shown\n> in all wallets next to the receiving address. When entering a new address to send BTC, the\n> sending wallet should also show the 4DC next to the entered address. This way, the sending\n> person can easily verify that the resulting 4DC matches the one from the receiving address.\n>\n> This would mean that a receiver would not only send his public address to the sender, but also\n> the 4DC. A minor disadvantage since a) it is not mandatory and b) it is very easy to do.\n> However, it would greatly reduce the probability of performing transactions to a wrong address.\n>\n> Technically, this is very easy to implement. The only effort needed is agreeing on a checksum\n> standard to generate the code. Once the standard is established, all wallet and exchange\n> developers can start implementing this.\n\nI think the \"only\" effort here is going to be the main bulk of the effort, and it will still take years of agreement (or sipa doing it, because every review is \"either sipa made it, or we have to check *everything* in detail for several months to make sure it is correct\").\n\nIn any case --- the last 5 characters of a bech32 string are already a human-readable 5-digit code, with fairly good properties, why is it not usable for this case?\n\nOn the other side of the coin, if you say \"the existing bech32 checksum is automatically checked by the software\", why is forcing something to be manually checked by a human better than leaving the checking to software?\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ts",
                "date": "2021-08-19T17:02:38",
                "message_text_only": "Hello ZmnSCPxj,\n\nZmnSCPxj wrote on 8/16/21 5:34 AM:\n> Good morning TS,\n> \n>> Entering a BTC address for a transaction can pose a risk of error (human or technical). While\n>> there is a checksum integrated in BTC addresses already, this is used only at a technical\n>> level and does not avoid entering a valid but otherwise wrong address. Moreover, it does not\n>> improve the overall user experience.\n>>\n>> In case this hasn't been discussed before, I propose to implement a 3 or 4 digit code (lets\n>> call it 4DC for this text), generated as checksum from the address. This 4DC should be shown\n>> in all wallets next to the receiving address. When entering a new address to send BTC, the\n>> sending wallet should also show the 4DC next to the entered address. This way, the sending\n>> person can easily verify that the resulting 4DC matches the one from the receiving address.\n>>\n>> This would mean that a receiver would not only send his public address to the sender, but also\n>> the 4DC. A minor disadvantage since a) it is not mandatory and b) it is very easy to do.\n>> However, it would greatly reduce the probability of performing transactions to a wrong address.\n>>\n>> Technically, this is very easy to implement. The only effort needed is agreeing on a checksum\n>> standard to generate the code. Once the standard is established, all wallet and exchange\n>> developers can start implementing this.\n> \n\n\nThanks for your comments.\n\n\n> I think the \"only\" effort here is going to be the main bulk of the effort, and it will still take years of agreement (or sipa doing it, because every review is \"either sipa made it, or we have to check *everything* in detail for several months to make sure it is correct\").\n\nI understand. If sipa could do it that would greatly simplify the process. Once an algorithm \nfor the generation of the code exists, it just needs to be communicated to wallet developers \nand let it grow organically. No need of extensive testing, since it is only a very simple \nfunction.\n\n\n> In any case --- the last 5 characters of a bech32 string are already a human-readable 5-digit code, with fairly good properties, why is it not usable for this case?\n\nWell, because\na) most people don't know that\nb) it is specific to bech32\nc) it is not easily readable being the last digits of a long address (although this could be \nfixed by the wallet by showing those digits bigger or separately)\nd) and most importantly: as mentioned in above my proposal, it only proves that an address is \nvalid, but not necessarily the correct one (perhaps the user copied the wrong address, there \nwas an old address in the clipboard, etc.)\n\n\n> On the other side of the coin, if you say \"the existing bech32 checksum is automatically checked by the software\", why is forcing something to be manually checked by a human better than leaving the checking to software?\n\nNot better, it should be on top. And not forced, but just as an optional check for the user. \nThe SW can (and should) only check that the address is valid (the SW doesn't know the user's \nintent). Only the human can \"double-check\" an easy-to-read-code to quickly know that he is \ndoing the right thing. (Entering a valid but wrong address is even worse than entering an \ninvalid one, since the latter will be stopped by the wallet. But the former most likely \nresults in loosing the funds.)\n\nNote: The code should never be entered manually or even copied together with the address in \none string. From the SW point of view, the code is an output only, never an input. It is \nmerely a visual verification for the user.\n\nExample of use: person A calls via phone person B and says: \"Send me 0.1 BTC to my address I \njust sent you via whatsapp. When entering the address, make sure that you get the verification \ncode 4385.\"\n\nRegards,\nTS\n\n\n> \n> \n> Regards,\n> ZmnSCPxj\n>"
            },
            {
                "author": "Christopher Allen",
                "date": "2021-08-19T17:37:29",
                "message_text_only": "As an alternative, you might want to consider LifeHash, which includes a\nvisual indicator as well as a readable fingerprint value.\n\nLifeHash is an open source visual hashing algorithm that we use for all our\nprojects. Lifehash has a number of desirable qualities, including high\ncomplexity, good aesthetics, a printer-friendly (CMYK) color gamut and\nrobustness when transformed to grayscale.\n\n* [LifeHask Overview and links to reference code](\nhttps://github.com/BlockchainCommons/lifehash)\n\n* [LifeHash Explainer on YouTube](\nhttps://www.youtube.com/watch?v=cu0K__KLxKo)\n\n* [Our LifeHash UX best practices - The Object Identity Block](\nhttps://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2021-002-digest.md#object-identity-block\n)\n\n-- Christopher Allen\n   Principal Architect, Blockchain Commons\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210819/54be28d3/attachment.html>"
            },
            {
                "author": "ts",
                "date": "2021-08-21T04:52:16",
                "message_text_only": "Good day Christopher,\n\nThanks for your comment! LifeHash looks indeed quite interesting. I can imagine some examples \nwhere it would be very useful, and I guess it could be used as a visual verification for the \naddress in a wallet as well.\n\nHowever, for my proposal (Human readable checksum (verification code) to avoid errors) it \ncould have the following disadvantages:\n\n1. It would be only one standard instead of one standard per crypto network (it should be \ndifferent on each of them as described in the proposal). This could be solved with the \ninclusion of a network identifier somehow, but would increase the complexity of the \nimplementation.\n\n2. For this special use case, a simple 3 to 4 digit code is easier to implement than a \ngraphic, and easier to include in an existing app, with minimal layout changes. The simpler it \nis, the more likely it will be for developers to actually implement it.\n\n3. A graphic cannot be communicated by voice (in some situations this could be an easier way \nto communicate the verification code)\n\nGreetings,\nTS\n\n\n\nChristopher Allen wrote on 8/19/21 12:37 PM:\n> As an alternative, you might want to consider LifeHash, which includes a visual indicator as \n> well as a readable fingerprint value.\n> \n> LifeHash is an open source visual hashing algorithm that we use for all our projects. Lifehash \n> has a number of desirable qualities, including high complexity, good aesthetics, a \n> printer-friendly (CMYK) color gamut and robustness when transformed to grayscale.\n> \n> * [LifeHask Overview and links to reference \n> code](https://github.com/BlockchainCommons/lifehash \n> <https://github.com/BlockchainCommons/lifehash>)\n> \n> * [LifeHash Explainer on YouTube](https://www.youtube.com/watch?v=cu0K__KLxKo \n> <https://www.youtube.com/watch?v=cu0K__KLxKo>)\n> \n> * [Our LifeHash UX best practices - The Object Identity \n> Block](https://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2021-002-digest.md#object-identity-block \n> <https://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2021-002-digest.md#object-identity-block>)\n> \n> -- Christopher Allen\n>  \u00a0 \u00a0Principal Architect, Blockchain Commons\n> \n>"
            },
            {
                "author": "Karl",
                "date": "2021-08-19T21:05:28",
                "message_text_only": "Something that could work really well here could be having a norm of using\nthe checksum for bright colors, weights, sizes, capitalizations, and/or\nspacing of the characters of the address, making different addresses more\nclearly visually distinct.\n\nEthereum uses mixed case to do this a little bit:\nhttps://eips.ethereum.org/EIPS/eip-55#implementation\n\nIt seems to me the checksum at the end of the address is sufficient for\ndifferentiating error, but making a checksum more visually distinctive is\nindeed an opportunity to add another digest, reducing collisions and such.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210819/566d8d96/attachment.html>"
            },
            {
                "author": "ts",
                "date": "2021-08-21T04:52:26",
                "message_text_only": "Hello Karl,\n\nYes, I agree in general. But while the visual checksum could be sometimes more interesting and \neven useful, I guess that the technically simpler solution might be more likely to be adopted. \nAnd also less prone to error. Just a thought.\n\nCheers,\nTS\n\n\nKarl wrote on 8/19/21 4:05 PM:\n> Something that could work really well here could be having a norm of using the checksum for \n> bright colors, weights, sizes, capitalizations, and/or spacing of the characters of the \n> address, making different addresses more clearly visually distinct.\n> \n> Ethereum uses mixed case to do this a little bit: \n> https://eips.ethereum.org/EIPS/eip-55#implementation \n> <https://eips.ethereum.org/EIPS/eip-55#implementation>\n> \n> It seems to me the checksum at the end of the address is sufficient for differentiating error, \n> but making a checksum more visually distinctive is indeed an opportunity to add another \n> digest, reducing collisions and such."
            },
            {
                "author": "Pieter Wuille",
                "date": "2021-08-29T14:42:07",
                "message_text_only": "On Thursday, August 19th, 2021 at 1:02 PM, ts via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> > In any case --- the last 5 characters of a bech32 string are already a human-readable 5-digit code, with fairly good properties, why is it not usable for this case?\n\nSide note: it's actually the last six characters.\n\n>\n> Well, because\n>\n> a) most people don't know that\n>\n> b) it is specific to bech32\n>\n> c) it is not easily readable being the last digits of a long address (although this could be\n\nI think this is a misconception. For the purpose of verifying that you have the *right* address (rather than just a valid one), the checksum, or even the knowledge that a checksum is present, is completely irrelevant.\n\nIn honestly-generated addresses, every character except the prefix (the ~2 first characters for P2PKH and P2SH, and the ~4 first characters for BIP173/BIP350 native segwit addresses) has exactly the same amount of entropy. Instead of adding say a 4 character code, just tell people to compare any 4 characters of their choosing. Or more - I would hope people are already comparing (much) more than 4 characters already.\n\nIt doesn't matter if the characters being compared are checksum characters or data characters. In honestly-generated addresses, both are equally random.\n\nAdding a special 4 character \"external\" checksum IMO would instead encourage people to perhaps just compare those 4 characters instead of the rest (or at least, focus mostly on those). That could easily worsen how well comparisons are done in practice...\n\nCheers,\n\n--\nPieter"
            },
            {
                "author": "ts",
                "date": "2021-08-31T02:17:07",
                "message_text_only": "Pieter Wuille wrote on 8/29/21 9:42 AM:\n> On Thursday, August 19th, 2021 at 1:02 PM, ts via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n>>> In any case --- the last 5 characters of a bech32 string are already a human-readable 5-digit code, with fairly good properties, why is it not usable for this case?\n> \n> Side note: it's actually the last six characters.\n> \n>>\n>> Well, because\n>>\n>> a) most people don't know that\n>>\n>> b) it is specific to bech32\n>>\n>> c) it is not easily readable being the last digits of a long address (although this could be\n> \n> I think this is a misconception. For the purpose of verifying that you have the *right* address (rather than just a valid one), the checksum, or even the knowledge that a checksum is present, is completely irrelevant.\n\nExactly, it is irrelevant in that case. That's why I added d) \"...it only proves that an \naddress is valid, but not necessarily the correct one...\"\n\n\n> In honestly-generated addresses, every character except the prefix (the ~2 first characters for P2PKH and P2SH, and the ~4 first characters for BIP173/BIP350 native segwit addresses) has exactly the same amount of entropy. Instead of adding say a 4 character code, just tell people to compare any 4 characters of their choosing. Or more - I would hope people are already comparing (much) more than 4 characters already.\n> \n> It doesn't matter if the characters being compared are checksum characters or data characters. In honestly-generated addresses, both are equally random.\n\nYes, I agree with this basically, the entropy would be the same. My proposal is all about \nimproving the user experience.\n\n\n> Adding a special 4 character \"external\" checksum IMO would instead encourage people to perhaps just compare those 4 characters instead of the rest (or at least, focus mostly on those). That could easily worsen how well comparisons are done in practice...\n\nThis is a good point. This feature should not encourage people to just compare the code on its \nown or to focus mostly on it. It should be understood as a verification ON TOP. But then \nagain, is there a perfect solution? As it is now, most users focus on only a few characters, \nif any.\n\n* New variant\nThis discussion is now leading me to a new thought. Since the entropy is the same with a given \nnumber of characters from the address as you say and the address has already an inbuilt \nchecksum, an alternative way to do this would be to just take 4 or 5 characters (as you \nproposed above) from a fixed position and present them to the user separately. Say, characters \nfrom position 11th to 15th. Those 5 characters should be displayed by the wallet next or \nbellow to the address in a clear box and big font. It could be called \"Quick Verification Box\" \nor some other catchy name.\n\nOf course, the user could do this by looking at the address on his own. But this way he is \nencouraged to look at a given number of characters. Plus, a the bigger font makes it easier to \nsee.\n\nExample (characters 11th-15th):\n1KM7GsxUvQiYC8eohKA2QHr9fCjkJXDFvg  [YC8eo] <- in a bigger font\n            ^^^^^\n\nOr alternatively, the first 2 characters, chars. at position 11 and 12, and the last 2 characters:\n1KM7GsxUvQiYC8eohKA2QHr9fCjkJXDFvg  [1K-YC-vg] <- in a bigger font\n^^         ^^                   ^^\n\nOr characters at pos. 11-13 and 18-20:\n1KM7GsxUvQiYC8eohKA2QHr9fCjkJXDFvg  [YC8-A2Q] <- in a bigger font\n            ^^^    ^^^\n\nWhatever combination is used, the important thing is that it becomes a standard and all \nwallets use the same one.\n\nThe advantage of this solution is that it would be technically even easier to implement, and \nmore transparent at the same time. It is again all about agreeing on which characters to pick.\n\n\n* Avoiding the confusion among networks (or blockchains)\nIn my original proposal, I mentioned that each network should use its own code generation \nalgorithm. This way, for networks sharing the same address format, like BTC and BCH, the user \nwould have this extra level of verification (in case he intends to send coins from BCH network \nto BTC or viceversa).\nFor the new variant above, this is easy to achieve too - each network should agree on a \ndifferent subset of characters,\n\nI hope I could explain this clearly enough, and that someone can see a value in this.\n\nCheers,\nTS"
            },
            {
                "author": "ts",
                "date": "2021-08-28T21:17:35",
                "message_text_only": "Following up on my original proposal, I would like to get some more feedback of the community \nto see if this could be realized at some point. Also, any recommendations as to who to contact \nto get things rolling?\n\nThanks,\nTS\n\n\n\nts wrote on 8/15/21 11:23 PM:\n> Entering a BTC address for a transaction can pose a risk of error (human or technical). While \n> there is a checksum integrated in BTC addresses already, this is used only at a technical \n> level and does not avoid entering a valid but otherwise wrong address. Moreover, it does not \n> improve the overall user experience.\n> \n> In case this hasn't been discussed before, I propose to implement a 3 or 4 digit code (lets \n> call it 4DC for this text), generated as checksum from the address. This 4DC should be shown \n> in all wallets next to the receiving address. When entering a new address to send BTC, the \n> sending wallet should also show the 4DC next to the entered address. This way, the sending \n> person can easily verify that the resulting 4DC matches the one from the receiving address.\n> \n> This would mean that a receiver would not only send his public address to the sender, but also \n> the 4DC (or communicate it via a different channel). A minor disadvantage since a) it is not  > mandatory and b) it is very easy to do.\n> However, it would greatly reduce the probability of performing transactions to a wrong address.\n> \n> Technically, this is very easy to implement. The only effort needed is agreeing on a checksum \n> standard to generate the code. Once the standard is established, all wallet and exchange \n> developers can start implementing this.\n> \n> Agreeing on a good name for this code would be helpful for a fast adoption (human readable \n> checksum, verification code or 4DC are just examples).\n> \n> Obviously, this solution could be used for all other coins/networks. But ideally, each of them \n> should have its own checksum algorithm, in order to further avoid sending funds to the wrong \n> network. Especially when the address standard is the same like it is the case with BTC and BCH.\n> \n> Hopefully, Bitcoin can implement this first and serve as example-to-follow to other \n> coins/networks.\n> \n> Cheers,\n> TS"
            },
            {
                "author": "Pieter Wuille",
                "date": "2021-08-29T14:24:48",
                "message_text_only": "On Saturday, August 28th, 2021 at 5:17 PM, ts via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Following up on my original proposal, I would like to get some more feedback of the community\n>\n> to see if this could be realized at some point. Also, any recommendations as to who to contact\n>\n> to get things rolling?\n\nI honestly don't understand the point of what you're suggesting.\n\n* If you're concerned about random typos, this is something already automatically protected against through the checksum (both base58check or bech32/bech32m).\n\n* If you're concerned about accidentally entering the wrong - but honestly created - address, comparing any few characters of the address is just as good as any other. It doesn't even require the presence of a checksum. Looking at the last N characters, or the middle N, or anything except the first few, will do, and is just as good as an \"external\" checksum added at the end. For randomly-generated addresses (as honest ones are), each of those has exactly as much entropy.\n\n* If you're concerned about maliciously constructed addresses, which are designed to look similar in specific places, an attacker can just as easily make the external checksum collide (and having one might even worsen this, as now the attacker can focus on exactly that, rather than needing to focus on every other character).\n\nThings would be different if you'd suggest a checksum in another medium than text (e.g. a visual/drawing/colorcoding one). But I don't see any added value for an additional text-based checksum when addresses are already text themselves. This is even disregarding the difficulty of getting the ecosystem to adopt such changes.\n\nCheers,\n\n--\nPieter"
            },
            {
                "author": "ts",
                "date": "2021-08-31T02:16:00",
                "message_text_only": "Pieter, thanks for your comments. Here my thoughts:\n\nPieter Wuille wrote on 8/29/21 9:24 AM:\n> On Saturday, August 28th, 2021 at 5:17 PM, ts via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n>> Following up on my original proposal, I would like to get some more feedback of the community\n>>\n>> to see if this could be realized at some point. Also, any recommendations as to who to contact\n>>\n>> to get things rolling?\n> \n> I honestly don't understand the point of what you're suggesting.\n\nIt is about creating a simple technical assistance that makes it more user friendly and less \nerror prone to verify the entered address. For all types of users, including those who are \nless tech savvy.\n\n\n> * If you're concerned about random typos, this is something already automatically protected against through the checksum (both base58check or bech32/bech32m).\n\nI agree, but as mentioned in the original proposal, it is not about random typos (although \nthis would help for other coins without integrated checksum of course), but rather about \ncopy&paste errors (both technical or user caused).\n\n\n> * If you're concerned about accidentally entering the wrong - but honestly created - address, comparing any few characters of the address is just as good as any other. It doesn't even require the presence of a checksum. Looking at the last N characters, or the middle N, or anything except the first few, will do, and is just as good as an \"external\" checksum added at the end. For randomly-generated addresses (as honest ones are), each of those has exactly as much entropy.\n\nCorrect. However, I believe that ADDITIONALLY to looking at N characters, a quick check of a 3 \nor 4 digit code in bigger font next to the address would make for a better user experience. \nThis gives the user the reassurance that there is definitely no error. I agree that most users \nwith technical background including most of us here will routinely check the first/last N \ncharacters. I usually check the first 3 + last 3 characters. But I don't think this is very \nuser friendly. More importantly, I once had the case that two addresses were very similar at \nprecisely those 6 characters, and only a more close and concentrated look made me see the \ndifference. Moreover, some inexperienced users that are not aware of the consequences of \nentering a wrong address (much worse than entering the wrong bank account in an online bank \ntransfer) might forget to look at the characters altogether.\n\n\n> * If you're concerned about maliciously constructed addresses, which are designed to look similar in specific places, an attacker can just as easily make the external checksum collide (and having one might even worsen this, as now the attacker can focus on exactly that, rather than needing to focus on every other character).\n\nNot so concerned about this case, since this is a very special case that can only occur under \ncertain circumstances. But taking this case also into consideration, this is why the user \nshould use the verification code ADDITIONALLY to the normal way of verifying, not instead. If \nthe attacker only focuses on the verification code, he will only be successful with users that \nONLY look at this code. But if the attacker intends to be more successful, he now needs to \ncreate a valid address that is both similar in specific places AND produces the same \nverification code, which is way more difficult to achieve.\n\n\n> Things would be different if you'd suggest a checksum in another medium than text (e.g. a visual/drawing/colorcoding one). But I don't see any added value for an additional text-based checksum when addresses are already text themselves.\n\nYes, a visual checksum could also work. Christopher Allen proposed to use LifeHash as an \nalternative. It would be a matter of balancing the more complex implementation and need of \nspace in the app's layout with the usability and advantages of use. One advantage of the digit \nverification code is that it can be spoken in a call or written in a message.\n\n> This is even disregarding the difficulty of getting the ecosystem to adopt such changes.\n\nNo changes are needed, only an agreement or recommendation on which algorithm for the code \ngeneration should be used. Once this is done, it is up to the developers of wallets and \nexchanges to implement this feature as they see fit.\n\nGreetings,\nTS"
            },
            {
                "author": "Marek Palatinus",
                "date": "2021-08-31T08:47:26",
                "message_text_only": "I fully agree with sipa and his reasoning that this proposal is not solving\nany particular problem, but making it actually a bit worse.\n\nAlso, do you know what I hate more than copy&pasting bitcoin addresses?\nCopy pasting zillion random fields for SEPA/wire transfers. And I believe\nthat a single copy pasta of a bitcoin address is a much better user\nexperience after all.\n\nBest,\nslush\n\nOn Tue, Aug 31, 2021 at 9:08 AM ts via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Pieter, thanks for your comments. Here my thoughts:\n>\n> Pieter Wuille wrote on 8/29/21 9:24 AM:\n> > On Saturday, August 28th, 2021 at 5:17 PM, ts via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> >> Following up on my original proposal, I would like to get some more\n> feedback of the community\n> >>\n> >> to see if this could be realized at some point. Also, any\n> recommendations as to who to contact\n> >>\n> >> to get things rolling?\n> >\n> > I honestly don't understand the point of what you're suggesting.\n>\n> It is about creating a simple technical assistance that makes it more user\n> friendly and less\n> error prone to verify the entered address. For all types of users,\n> including those who are\n> less tech savvy.\n>\n>\n> > * If you're concerned about random typos, this is something already\n> automatically protected against through the checksum (both base58check or\n> bech32/bech32m).\n>\n> I agree, but as mentioned in the original proposal, it is not about random\n> typos (although\n> this would help for other coins without integrated checksum of course),\n> but rather about\n> copy&paste errors (both technical or user caused).\n>\n>\n> > * If you're concerned about accidentally entering the wrong - but\n> honestly created - address, comparing any few characters of the address is\n> just as good as any other. It doesn't even require the presence of a\n> checksum. Looking at the last N characters, or the middle N, or anything\n> except the first few, will do, and is just as good as an \"external\"\n> checksum added at the end. For randomly-generated addresses (as honest ones\n> are), each of those has exactly as much entropy.\n>\n> Correct. However, I believe that ADDITIONALLY to looking at N characters,\n> a quick check of a 3\n> or 4 digit code in bigger font next to the address would make for a better\n> user experience.\n> This gives the user the reassurance that there is definitely no error. I\n> agree that most users\n> with technical background including most of us here will routinely check\n> the first/last N\n> characters. I usually check the first 3 + last 3 characters. But I don't\n> think this is very\n> user friendly. More importantly, I once had the case that two addresses\n> were very similar at\n> precisely those 6 characters, and only a more close and concentrated look\n> made me see the\n> difference. Moreover, some inexperienced users that are not aware of the\n> consequences of\n> entering a wrong address (much worse than entering the wrong bank account\n> in an online bank\n> transfer) might forget to look at the characters altogether.\n>\n>\n> > * If you're concerned about maliciously constructed addresses, which are\n> designed to look similar in specific places, an attacker can just as easily\n> make the external checksum collide (and having one might even worsen this,\n> as now the attacker can focus on exactly that, rather than needing to focus\n> on every other character).\n>\n> Not so concerned about this case, since this is a very special case that\n> can only occur under\n> certain circumstances. But taking this case also into consideration, this\n> is why the user\n> should use the verification code ADDITIONALLY to the normal way of\n> verifying, not instead. If\n> the attacker only focuses on the verification code, he will only be\n> successful with users that\n> ONLY look at this code. But if the attacker intends to be more successful,\n> he now needs to\n> create a valid address that is both similar in specific places AND\n> produces the same\n> verification code, which is way more difficult to achieve.\n>\n>\n> > Things would be different if you'd suggest a checksum in another medium\n> than text (e.g. a visual/drawing/colorcoding one). But I don't see any\n> added value for an additional text-based checksum when addresses are\n> already text themselves.\n>\n> Yes, a visual checksum could also work. Christopher Allen proposed to use\n> LifeHash as an\n> alternative. It would be a matter of balancing the more complex\n> implementation and need of\n> space in the app's layout with the usability and advantages of use. One\n> advantage of the digit\n> verification code is that it can be spoken in a call or written in a\n> message.\n>\n> > This is even disregarding the difficulty of getting the ecosystem to\n> adopt such changes.\n>\n> No changes are needed, only an agreement or recommendation on which\n> algorithm for the code\n> generation should be used. Once this is done, it is up to the developers\n> of wallets and\n> exchanges to implement this feature as they see fit.\n>\n> Greetings,\n> TS\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210831/3f498943/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Human readable checksum (verification code) to avoid errors on BTC public addresses",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Christopher Allen",
                "Karl",
                "ts",
                "ZmnSCPxj",
                "Marek Palatinus",
                "Pieter Wuille"
            ],
            "messages_count": 13,
            "total_messages_chars_count": 32164
        }
    },
    {
        "title": "[bitcoin-dev] Anyprevout functional tests using eltoo scripts",
        "thread_messages": [
            {
                "author": "Richard Myers",
                "date": "2021-08-17T11:24:14",
                "message_text_only": "I implemented some basic functional test scripts for the eltoo channel update scheme to better understand BIP-118/Anyprevout (APO). My tests are based on the rough Taproot eltoo scripts AJ Towns outlined on this list back in 2019. These tests also require AJ's APO branch of core. This is just the start of a real eltoo implementation, but I wanted to share it to get feedback and to help others interested in understanding APO and eltoo.\n\nIf you want to take a quick look, my functional tests are implemented in the function \"test_tapscript_eltoo\":\nhttps://github.com/remyers/bitcoin/blob/eltoo-anyprevout/test/functional/simulate_eltoo.py#L1623\n\nI've also written a blog post that describes in more detail how to run the tests and includes notes that I hope will be helpful to anyone else interested in APO and eltoo:\nhttps://yakshaver.org/2021/07/26/first.html\n\nI'd love to work with anyone else interested in eltoo and APO who wants to help extend and elaborate these tests. Any PRs for the eltoo tests or blog post would be very welcome.\n\nMany thanks to AJ and Christian Decker who have both been very generous with their time in helping me understand the finer details of APO and eltoo.\n\nAll the best,\n\n-- Richard\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210817/3302d5cf/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Anyprevout functional tests using eltoo scripts",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Richard Myers"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1402
        }
    },
    {
        "title": "[bitcoin-dev] Is there a tool like Ethereum EVM at present for Bitcoin script?",
        "thread_messages": [
            {
                "author": "Null Null",
                "date": "2021-08-24T03:39:44",
                "message_text_only": "Hi all,\n\nIs there a tool like Ethereum EVM at present? Users can write bitcoin scripts in a syntax just like python(or like other programming language); through this tool, they can be translated into bitcoin original scripts; it sounds like a new programming language has been invented.\n\nIn my opinion\uff0c Bitcoin script programming is based on reverse Polish expression; this is not friendly to programmers;\n\nIn fact, Bitcoin's opcode expression ability is very rich, and it may be unfriendly, which has affected the promotion of Bitcoin in the technical community.\n\nHope for hearing some voice about this.\n\nBest wish."
            },
            {
                "author": "Gijs van Dam",
                "date": "2021-08-24T07:36:29",
                "message_text_only": "Hi,\n\n\nBitcoin does not have a virtual machine. But you do have [Miniscript][1],\n[Min.sc][2], [Simplicity][3] and [Sapio][4]. These are all higher level\nlanguages that compile to Bitcoin Script. Sapio is \"just\" Rust, so that\nmight fit your setting best.\n\nBy the way, this question also has an answer on [Bitcoin Stackexchange][5]\nwhich is a great resource for questions like this.\n\n[1]: http://bitcoin.sipa.be/miniscript/\n[2]: https://min.sc/\n[3]: https://github.com/ElementsProject/simplicity\n[4]: https://learn.sapio-lang.org/\n[5]:\nhttps://bitcoin.stackexchange.com/questions/108261/is-there-a-tool-like-ethereum-evm-at-present-for-bitcoin-script\n\nOn Tue, Aug 24, 2021 at 2:55 PM Null Null via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi all,\n>\n> Is there a tool like Ethereum EVM at present? Users can write bitcoin\n> scripts in a syntax just like python(or like other programming language);\n> through this tool, they can be translated into bitcoin original scripts; it\n> sounds like a new programming language has been invented.\n>\n> In my opinion\uff0c Bitcoin script programming is based on reverse Polish\n> expression; this is not friendly to programmers;\n>\n> In fact, Bitcoin's opcode expression ability is very rich, and it may be\n> unfriendly, which has affected the promotion of Bitcoin in the technical\n> community.\n>\n> Hope for hearing some voice about this.\n>\n> Best wish.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210824/233f3b92/attachment.html>"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2021-08-24T13:08:49",
                "message_text_only": "Simplicity does not compile to Bitcoin Script, and Sapio assumes extensions\nto Bitcoin Script that are not currently part of the consensus code.\n\n\nOn Tue, Aug 24, 2021 at 03:36:29PM +0800, Gijs van Dam via bitcoin-dev wrote:\n> Hi,\n> \n> \n> Bitcoin does not have a virtual machine. But you do have [Miniscript][1],\n> [Min.sc][2], [Simplicity][3] and [Sapio][4]. These are all higher level\n> languages that compile to Bitcoin Script. Sapio is \"just\" Rust, so that\n> might fit your setting best.\n> \n> By the way, this question also has an answer on [Bitcoin Stackexchange][5]\n> which is a great resource for questions like this.\n> \n> [1]: http://bitcoin.sipa.be/miniscript/\n> [2]: https://min.sc/\n> [3]: https://github.com/ElementsProject/simplicity\n> [4]: https://learn.sapio-lang.org/\n> [5]:\n> https://bitcoin.stackexchange.com/questions/108261/is-there-a-tool-like-ethereum-evm-at-present-for-bitcoin-script\n> \n> On Tue, Aug 24, 2021 at 2:55 PM Null Null via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> > Hi all,\n> >\n> > Is there a tool like Ethereum EVM at present? Users can write bitcoin\n> > scripts in a syntax just like python(or like other programming language);\n> > through this tool, they can be translated into bitcoin original scripts; it\n> > sounds like a new programming language has been invented.\n> >\n> > In my opinion\uff0c Bitcoin script programming is based on reverse Polish\n> > expression; this is not friendly to programmers;\n> >\n> > In fact, Bitcoin's opcode expression ability is very rich, and it may be\n> > unfriendly, which has affected the promotion of Bitcoin in the technical\n> > community.\n> >\n> > Hope for hearing some voice about this.\n> >\n> > Best wish.\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n\n-- \nAndrew Poelstra\nDirector of Research, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\nThe sun is always shining in space\n    -Justin Lewis-Webster"
            },
            {
                "author": "Oleg Andreev",
                "date": "2021-08-26T08:12:22",
                "message_text_only": "It is worth checking out Ivy lang Playground by Dan Robinson, but AFAIK, it's not actively maintained. It compiles contracts to Bitcoin Script: https://www.ivylang.org/bitcoin\n\n> On 24. Aug 2021, at 16:08, Andrew Poelstra via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \n> Simplicity does not compile to Bitcoin Script, and Sapio assumes extensions\n> to Bitcoin Script that are not currently part of the consensus code.\n> \n> \n> On Tue, Aug 24, 2021 at 03:36:29PM +0800, Gijs van Dam via bitcoin-dev wrote:\n>> Hi,\n>> \n>> \n>> Bitcoin does not have a virtual machine. But you do have [Miniscript][1],\n>> [Min.sc][2], [Simplicity][3] and [Sapio][4]. These are all higher level\n>> languages that compile to Bitcoin Script. Sapio is \"just\" Rust, so that\n>> might fit your setting best.\n>> \n>> By the way, this question also has an answer on [Bitcoin Stackexchange][5]\n>> which is a great resource for questions like this.\n>> \n>> [1]: http://bitcoin.sipa.be/miniscript/\n>> [2]: https://min.sc/\n>> [3]: https://github.com/ElementsProject/simplicity\n>> [4]: https://learn.sapio-lang.org/\n>> [5]:\n>> https://bitcoin.stackexchange.com/questions/108261/is-there-a-tool-like-ethereum-evm-at-present-for-bitcoin-script\n>> \n>> On Tue, Aug 24, 2021 at 2:55 PM Null Null via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> \n>>> Hi all,\n>>> \n>>> Is there a tool like Ethereum EVM at present? Users can write bitcoin\n>>> scripts in a syntax just like python(or like other programming language);\n>>> through this tool, they can be translated into bitcoin original scripts; it\n>>> sounds like a new programming language has been invented.\n>>> \n>>> In my opinion\uff0c Bitcoin script programming is based on reverse Polish\n>>> expression; this is not friendly to programmers;\n>>> \n>>> In fact, Bitcoin's opcode expression ability is very rich, and it may be\n>>> unfriendly, which has affected the promotion of Bitcoin in the technical\n>>> community.\n>>> \n>>> Hope for hearing some voice about this.\n>>> \n>>> Best wish.\n>>> \n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>> \n> \n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> \n> -- \n> Andrew Poelstra\n> Director of Research, Blockstream\n> Email: apoelstra at wpsoftware.net\n> Web:   https://www.wpsoftware.net/andrew\n> \n> The sun is always shining in space\n>    -Justin Lewis-Webster\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Jeremy",
                "date": "2021-08-26T10:26:23",
                "message_text_only": "This has actually never been true (Sapio assumes extensions).\n\nIf the extensions are not present, you can stub them out with a signing\nfederation instead, configurable as flags, and you can also write many\ncontracts that do not use the ctv based components at all.\n\nThe protocol for emulation is a bit clever (if I do say so myself) since it\nensures that contract compilation is completely offline and the oracles are\ncompletely stateless.\n\nRelevant links:\n\nhttps://learn.sapio-lang.org/ch05-01-ctv-emulator.html\nhttps://learn.sapio-lang.org/ch03-02-finish.html\n\nCheers,\n\nJeremy\n\nOn Tue, Aug 24, 2021, 6:19 AM Andrew Poelstra via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> Simplicity does not compile to Bitcoin Script, and Sapio assumes extensions\n> to Bitcoin Script that are not currently part of the consensus code.\n>\n>\n> On Tue, Aug 24, 2021 at 03:36:29PM +0800, Gijs van Dam via bitcoin-dev\n> wrote:\n> > Hi,\n> >\n> >\n> > Bitcoin does not have a virtual machine. But you do have [Miniscript][1],\n> > [Min.sc][2], [Simplicity][3] and [Sapio][4]. These are all higher level\n> > languages that compile to Bitcoin Script. Sapio is \"just\" Rust, so that\n> > might fit your setting best.\n> >\n> > By the way, this question also has an answer on [Bitcoin\n> Stackexchange][5]\n> > which is a great resource for questions like this.\n> >\n> > [1]: http://bitcoin.sipa.be/miniscript/\n> > [2]: https://min.sc/\n> > [3]: https://github.com/ElementsProject/simplicity\n> > [4]: https://learn.sapio-lang.org/\n> > [5]:\n> >\n> https://bitcoin.stackexchange.com/questions/108261/is-there-a-tool-like-ethereum-evm-at-present-for-bitcoin-script\n> >\n> > On Tue, Aug 24, 2021 at 2:55 PM Null Null via bitcoin-dev <\n> > bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> > > Hi all,\n> > >\n> > > Is there a tool like Ethereum EVM at present? Users can write bitcoin\n> > > scripts in a syntax just like python(or like other programming\n> language);\n> > > through this tool, they can be translated into bitcoin original\n> scripts; it\n> > > sounds like a new programming language has been invented.\n> > >\n> > > In my opinion\uff0c Bitcoin script programming is based on reverse Polish\n> > > expression; this is not friendly to programmers;\n> > >\n> > > In fact, Bitcoin's opcode expression ability is very rich, and it may\n> be\n> > > unfriendly, which has affected the promotion of Bitcoin in the\n> technical\n> > > community.\n> > >\n> > > Hope for hearing some voice about this.\n> > >\n> > > Best wish.\n> > >\n> > > _______________________________________________\n> > > bitcoin-dev mailing list\n> > > bitcoin-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> > >\n>\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> --\n> Andrew Poelstra\n> Director of Research, Blockstream\n> Email: apoelstra at wpsoftware.net\n> Web:   https://www.wpsoftware.net/andrew\n>\n> The sun is always shining in space\n>     -Justin Lewis-Webster\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210826/90095c1d/attachment.html>"
            },
            {
                "author": "Null Null",
                "date": "2021-08-26T02:43:27",
                "message_text_only": "thanks for you suggestion, Gijs.\n\nI spent some time learning miniscript, and there are some problems that need to confirm for me:\n\n1. Is miniscript a brand new Bitcoin scripting language?\n2. If I use miniscript, do I need to compile it into a Bitcoin OP_CODE script? If so, how to do that ? has someone written a compiler? \nI found that @sipa has open sourced a compiler implemented in C++ on github( https://github.com/sipa/miniscript ). This should translate the policy language into miniscript;\n\n> 2021\u5e748\u670824\u65e5 \u4e0b\u53483:36\uff0cGijs van Dam via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> \u5199\u9053\uff1a\n> \n> Hi,\n> \n> \n> Bitcoin does not have a virtual machine. But you do have [Miniscript][1], [Min.sc][2], [Simplicity][3] and [Sapio][4]. These are all higher level languages that compile to Bitcoin Script. Sapio is \"just\" Rust, so that might fit your setting best.\n> \n> By the way, this question also has an answer on [Bitcoin Stackexchange][5] which is a great resource for questions like this.\n> \n> [1]: http://bitcoin.sipa.be/miniscript/\n> [2]: https://min.sc/\n> [3]: https://github.com/ElementsProject/simplicity\n> [4]: https://learn.sapio-lang.org/\n> [5]: https://bitcoin.stackexchange.com/questions/108261/is-there-a-tool-like-ethereum-evm-at-present-for-bitcoin-script\n> \n> On Tue, Aug 24, 2021 at 2:55 PM Null Null via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Hi all,\n> \n> Is there a tool like Ethereum EVM at present? Users can write bitcoin scripts in a syntax just like python(or like other programming language); through this tool, they can be translated into bitcoin original scripts; it sounds like a new programming language has been invented.\n> \n> In my opinion\uff0c Bitcoin script programming is based on reverse Polish expression; this is not friendly to programmers;\n> \n> In fact, Bitcoin's opcode expression ability is very rich, and it may be unfriendly, which has affected the promotion of Bitcoin in the technical community.\n> \n> Hope for hearing some voice about this.\n> \n> Best wish.\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Michael Folkson",
                "date": "2021-08-26T13:09:49",
                "message_text_only": "The \"No Taproot\" section of the Sapio docs need updating :) What are\nyour plans to take advantage of Taproot with Sapio? It would have been\ninteresting to see what a Taproot emulator would have looked like,\nalthough no need for it now. It seems to me Taproot would have been\nharder to emulate than CTV though I could be wrong.\n\nhttps://learn.sapio-lang.org/ch05-02-taproot.html\n\nAlso there have been a number of people asking questions about Sapio\nand CTV on the Libera equivalents of Freenode channels #sapio and\n##ctv-bip-review over the past months. Do you plan to join and claim\nthose channels?\n\nDate: Thu, 26 Aug 2021 03:26:23 -0700\nFrom: Jeremy <jlrubin at mit.edu>\nTo: Andrew Poelstra <apoelstra at wpsoftware.net>, Bitcoin Protocol\n        Discussion <bitcoin-dev at lists.linuxfoundation.org>\nSubject: Re: [bitcoin-dev] Is there a tool like Ethereum EVM at\n        present for Bitcoin script?\nMessage-ID:\n        <CAD5xwhgmAepA4jW3tK7nihMFsMEdgs0Z6UEs3k=3J1soDea0QQ at mail.gmail.com>\nContent-Type: text/plain; charset=\"utf-8\"\n\nThis has actually never been true (Sapio assumes extensions).\n\nIf the extensions are not present, you can stub them out with a signing\nfederation instead, configurable as flags, and you can also write many\ncontracts that do not use the ctv based components at all.\n\nThe protocol for emulation is a bit clever (if I do say so myself) since it\nensures that contract compilation is completely offline and the oracles are\ncompletely stateless.\n\nRelevant links:\n\nhttps://learn.sapio-lang.org/ch05-01-ctv-emulator.html\nhttps://learn.sapio-lang.org/ch03-02-finish.html\n\nCheers,\n\nJeremy\n\n-- \nMichael Folkson\nEmail: michaelfolkson at gmail.com\nKeybase: michaelfolkson\nPGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3"
            },
            {
                "author": "Jeremy",
                "date": "2021-08-26T20:03:47",
                "message_text_only": "Will update those soon / in November. Sapio needs the rust Bitcoin taproot\necosystem to mature, as well as a spec for miniscript taproot (altho we can\nkinda monkey patch one in without it).\n\nTo be honest, I had some technical difficulties with getting Libera to work\nand I gave up... But perhaps I can retry getting it to work again. Irc\ninfra \ud83e\udd37\u200d\u2642\ufe0f struggles...\n\n\nOn Thu, Aug 26, 2021, 6:10 AM Michael Folkson <michaelfolkson at gmail.com>\nwrote:\n\n> The \"No Taproot\" section of the Sapio docs need updating :) What are\n> your plans to take advantage of Taproot with Sapio? It would have been\n> interesting to see what a Taproot emulator would have looked like,\n> although no need for it now. It seems to me Taproot would have been\n> harder to emulate than CTV though I could be wrong.\n>\n> https://learn.sapio-lang.org/ch05-02-taproot.html\n>\n> Also there have been a number of people asking questions about Sapio\n> and CTV on the Libera equivalents of Freenode channels #sapio and\n> ##ctv-bip-review over the past months. Do you plan to join and claim\n> those channels?\n>\n> Date: Thu, 26 Aug 2021 03:26:23 -0700\n> From: Jeremy <jlrubin at mit.edu>\n> To: Andrew Poelstra <apoelstra at wpsoftware.net>, Bitcoin Protocol\n>         Discussion <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: Re: [bitcoin-dev] Is there a tool like Ethereum EVM at\n>         present for Bitcoin script?\n> Message-ID:\n>         <CAD5xwhgmAepA4jW3tK7nihMFsMEdgs0Z6UEs3k=\n> 3J1soDea0QQ at mail.gmail.com>\n> Content-Type: text/plain; charset=\"utf-8\"\n>\n> This has actually never been true (Sapio assumes extensions).\n>\n> If the extensions are not present, you can stub them out with a signing\n> federation instead, configurable as flags, and you can also write many\n> contracts that do not use the ctv based components at all.\n>\n> The protocol for emulation is a bit clever (if I do say so myself) since it\n> ensures that contract compilation is completely offline and the oracles are\n> completely stateless.\n>\n> Relevant links:\n>\n> https://learn.sapio-lang.org/ch05-01-ctv-emulator.html\n> https://learn.sapio-lang.org/ch03-02-finish.html\n>\n> Cheers,\n>\n> Jeremy\n>\n> --\n> Michael Folkson\n> Email: michaelfolkson at gmail.com\n> Keybase: michaelfolkson\n> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210826/b648e893/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Is there a tool like Ethereum EVM at present for Bitcoin script?",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Jeremy",
                "Michael Folkson",
                "Oleg Andreev",
                "Andrew Poelstra",
                "Gijs van Dam",
                "Null Null"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 17604
        }
    },
    {
        "title": "[bitcoin-dev] Announcing bip174.org, a web-based PSBT viewer and editor",
        "thread_messages": [
            {
                "author": "Alekos Filini",
                "date": "2021-08-25T18:03:24",
                "message_text_only": "Hello list,\n\nI'm writing this email to announce the launch of bip174.org, a PSBT viewer\nand editor that runs in the browser. The website itself is pretty simple,\nyou can paste a PSBT to see its content and whenever a change is made to\none of the various fields the PSBT is automatically updated. There are a\nfew examples built in if you just want to quickly try it out.\n\nDaniela Brozzoni and I have been working on this tool for a while, mainly\nbecause we felt the need ourselves for something that would allow us to\neasily dump/modify the PSBTs we work with in our day to day job. We are not\naware of any other tool that does something similar (`decodepsbt` in\nBitcoin Core can only show the content of a PSBT but not change it), so we\ndecided to build this instead, taking inspiration from the great bip32.org.\n\nFor anyone who's interested, the webapp is made entirely in Rust compiled\nto WASM. The source code is available on GitHub\n<https://github.com/afilini/bip174.org/>.\n\nContributions, feedback and bug reports are all very welcome!\n\n\nAlekos\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210825/09d93c0a/attachment.html>"
            },
            {
                "author": "Christopher Allen",
                "date": "2021-08-25T20:05:31",
                "message_text_only": "On Wed, Aug 25, 2021 at 12:42 PM Alekos Filini via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I'm writing this email to announce the launch of bip174.org, a PSBT\n> viewer and editor that runs in the browser.\n>\n\nThis will be useful.\n\n>\nI, and the larger Airgapped Wallet Community would love to see you add\noutput of UR-based animated QRs to your website. An increasing number of\nadvanced hardware & software wallets are now supporting Airgapped UR/QR\nPSBT signing.\nhttps://github.com/BlockchainCommons/Airgapped-Wallet-Community\n\nYou can see a video example of this in action between the Foundation\nDevices hardware wallet & Blue Wallet in this video, at the 17m48s mark:\nhttps://youtu.be/bYeoCBAUDYs\n\nThe easiest to do is output these UR QRs from your site, as there are\nmultiple libraries in multiple languages to support them, but I also know\nthat there are some major web-based transaction coordinator services also\nplanning to add Browser scanning of PSBTs on laptops with cameras as well.\n\n\u2014 Christopher Allen\n\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210825/0715c389/attachment.html>"
            },
            {
                "author": "Alekos Filini",
                "date": "2021-08-26T13:57:47",
                "message_text_only": "(sending it again as I forgot to \"reply-all\", sorry for the spam!)\n\nThe easiest to do is output these UR QRs from your site, as there are\n> multiple libraries in multiple languages to support them, but I also know\n> that there are some major web-based transaction coordinator services also\n> planning to add Browser scanning of PSBTs on laptops with cameras as well.\n>\n\nThat's a really good suggestion, thanks! I think it should be pretty\ndoable, we could also try working on reading a PSBT from a QR code using\nthe webcam.\n\n\nAlekos\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210826/718c6917/attachment.html>"
            },
            {
                "author": "Prayank",
                "date": "2021-08-26T09:20:02",
                "message_text_only": "Hi Alekos,\n\n> bip174.org, a PSBT viewer and editor that runs in the browser\n\nThe PSBT editor looks good and will be helpful. Thanks for working on it. Would love to see an option to switch between light and dark theme and highlighting few things with different colors.\n\nMaybe a similar project for descriptors with options to experiment with descriptors would also be useful.\n-- \nPrayank\n\nA3B1 E430 2298 178F\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210826/49a87b63/attachment.html>"
            },
            {
                "author": "Alekos Filini",
                "date": "2021-08-26T14:07:30",
                "message_text_only": "> Would love to see an option to switch between light and dark theme and\n> highlighting few things with different colors.\n>\n\nNeither of us is particularly good at UI/UX stuff, but we can give it a\nshot! :)\n\n\n> Maybe a similar project for descriptors with options to experiment with\n> descriptors would also be useful.\n>\n\nI don't think this is exactly what you have in mind, but a while back I\nmade a web-based tool to build descriptors graphically, based on Scratch.\nYou can find it here <https://bitcoindevkit.org/bdk-cli/playground/>, on\nBDK's website.\n\n\nAlekos\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210826/9eccca80/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Announcing bip174.org, a web-based PSBT viewer and editor",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Prayank",
                "Christopher Allen",
                "Alekos Filini"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 4508
        }
    },
    {
        "title": "[bitcoin-dev] Camouflage: A project dedicated to Hal Finney",
        "thread_messages": [
            {
                "author": "Prayank",
                "date": "2021-08-27T21:29:35",
                "message_text_only": "I wish Hal Finney was with us today and help us improve privacy in Bitcoin. I like reading his posts and one of them is https://bitcointalk.org/index.php?topic=156390.msg1659654#msg1659654 \n\nI had emailed about Privacy related things on July 23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019276.html\n\nIt was my birthday on 23 and had few beers so maybe email wasn't very focused. Although basic idea was to initiate discussion about improving privacy in different Bitcoin projects. I did not receive any response except one person who liked the video I mentioned in the email. So here is one project which uses GitHub pages and will have the following things:\n\n1.Issues and PRs related to privacy from different Bitcoin projects. I have added few from Bitcoin Core (full node implementation), Bisq(DEX) and LND (LN implementation) right now.\n2.Blog section for my opinion on different privacy related issues and PRs.\n3.'Hall of Fame' section to appreciate the contribution of devs who are improving privacy in different Bitcoin projects.\n\nI will be happy if this project helps in improving privacy or helps users/devs in any other way. This project will never turn in to a paid newsletter or needs any sponsors, however any contribution to make the website better would be appreciated. Edward Snowden can also contribute if he wants to do more than just tweets to help improve Bitcoin privacy.\n\nLink: https://prayank23.github.io/camouflage/\n\nWill move everything to new repository this weekend: https://github.com/BlockchainCommons/Bitcoin-Camouflage\n\n-- \nPrayank\n\nA3B1 E430 2298 178F\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210827/20e53400/attachment.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2021-08-28T16:36:26",
                "message_text_only": "Probably you could add to your links this discussion/issue\nhttps://github.com/bitcoin/bitcoin/pull/18988#issuecomment-646564853\n\n\nLe 27/08/2021 \u00e0 23:29, Prayank via bitcoin-dev a \u00e9crit :\n> I wish Hal Finney was with us today and help us improve privacy in\n> Bitcoin. I like reading his posts and one of them is\n> https://bitcointalk.org/index.php?topic=156390.msg1659654#msg1659654\n>\n> I had emailed about Privacy related things on July 23:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019276.html\n>\n> It was my birthday on 23 and had few beers so maybe email wasn't very\n> focused. Although basic idea was to initiate discussion about\n> improving privacy in different Bitcoin projects. I did not receive any\n> response except one person who liked the video I mentioned in the\n> email. So here is one project which uses GitHub pages and will have\n> the following things:\n>\n> 1.Issues and PRs related to privacy from different Bitcoin projects. I\n> have added few from Bitcoin Core (full node implementation), Bisq(DEX)\n> and LND (LN implementation) right now.\n> 2.Blog section for my opinion on different privacy related issues and PRs.\n> 3.'Hall of Fame' section to appreciate the contribution of devs who\n> are improving privacy in different Bitcoin projects.\n>\n> I will be happy if this project helps in improving privacy or helps\n> users/devs in any other way. This project will never turn in to a paid\n> newsletter or needs any sponsors, however any contribution to make the\n> website better would be appreciated. Edward Snowden can also\n> contribute if he wants to do more than just tweets to help improve\n> Bitcoin privacy.\n>\n> Link: https://prayank23.github.io/camouflage/\n>\n> Will move everything to new repository this weekend:\n> https://github.com/BlockchainCommons/Bitcoin-Camouflage\n>\n> -- \n> Prayank\n>\n> A3B1 E430 2298 178F\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210828/76d7d468/attachment.html>"
            },
            {
                "author": "Prayank",
                "date": "2021-08-28T22:40:38",
                "message_text_only": "Hi Aymeric,\n\nThanks for sharing the link. 'bitcoin-transactions' and 'node-Tor' looks interesting although I will have to check details and try things.\n\nOne observation: I noticed it's in JavaScript and will use WebRTC. Users who care about privacy normally disable both while using a browser.\n-- \nPrayank\n\nA3B1 E430 2298 178F\n\n\n\nAug 28, 2021, 22:06 by aymeric at peersm.com:\n\n>\n> Probably you could add to your links this discussion/issue > https://github.com/bitcoin/bitcoin/pull/18988#issuecomment-646564853\n>\n>\n> Le 27/08/2021 \u00e0 23:29, Prayank via      bitcoin-dev a \u00e9crit\u00a0:\n>\n>> I wish Hal Finney was with us today and help us improve        privacy in Bitcoin. I like reading his posts and one of them is >> https://bitcointalk.org/index.php?topic=156390.msg1659654#msg1659654>>  \n>>\n>> I had emailed about Privacy related things on July        23: >> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019276.html\n>>\n>> It was my birthday on 23 and had few beers so        maybe email wasn't very focused. Although basic idea was to        initiate discussion about improving privacy in different Bitcoin        projects. I did not receive any response except one person who        liked the video I mentioned in the email. So here is one project        which uses GitHub pages and will have the following things:\n>>\n>> 1.Issues and PRs related to privacy from different        Bitcoin projects. I have added few from Bitcoin Core (full node        implementation), Bisq(DEX) and LND (LN implementation) right        now.\n>> 2.Blog section for my opinion on different privacy        related issues and PRs.\n>> 3.'Hall of Fame' section to appreciate the        contribution of devs who are improving privacy in different        Bitcoin projects.\n>>\n>> I will be happy if this project helps in improving        privacy or helps users/devs in any other way. This project will        never turn in to a paid newsletter or needs any sponsors,        however any contribution to make the website better would be        appreciated. Edward Snowden can also contribute if he wants to        do more than just tweets to help improve Bitcoin privacy.\n>>\n>> Link: >> https://prayank23.github.io/camouflage/\n>>\n>> Will move everything to new repository this        weekend: >> https://github.com/BlockchainCommons/Bitcoin-Camouflage\n>>\n>> -- \n>> Prayank\n>>\n>> A3B1 E430 2298 178F\n>>\n>>\n>> _______________________________________________bitcoin-dev mailing list>> bitcoin-dev at lists.linuxfoundation.org>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210829/643f0d40/attachment.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2021-08-29T09:51:39",
                "message_text_only": "Hi,\n\nMaybe let's discuss the details privately since some might be off topic\nfor this list, as a quick answer the discussion I linked to is about\nusing the Tor protocol between bitcoin nodes piping the bitcoin protocol\nvia node-Tor (not to be misunderstood with the Tor network again), nodes\ncan be whatever you like including browsers (but the use of the Tor\nbrowser is not foreseen neither encouraged, disabling js and WebRTC is\nvalid when you are browsing, but browsing is not what is proposed here),\nthey can be wallets too, if you look at the browserification of\nbitcoin-transactions (https://peersm.com/wallet) there is a mechanism to\nmake sure the js code you loaded is the correct one, you can also create\na bookmarklet button with the js code to run it directly inside the\nbrowser without having to load it\n\nRegards\n\nAymeric\n\n\nLe 29/08/2021 \u00e0 00:40, Prayank a \u00e9crit :\n> Hi Aymeric,\n>\n> Thanks for sharing the link. 'bitcoin-transactions' and 'node-Tor'\n> looks interesting although I will have to check details and try things.\n>\n> One observation: I noticed it's in JavaScript and will use WebRTC.\n> Users who care about privacy normally disable both while using a browser.\n>\n> -- \n> Prayank\n>\n> A3B1 E430 2298 178F\n>\n>\n>\n> Aug 28, 2021, 22:06 by aymeric at peersm.com:\n>\n>     Probably you could add to your links this discussion/issue\n>     https://github.com/bitcoin/bitcoin/pull/18988#issuecomment-646564853\n>\n>\n>     Le 27/08/2021 \u00e0 23:29, Prayank via bitcoin-dev a \u00e9crit :\n>>     I wish Hal Finney was with us today and help us improve privacy\n>>     in Bitcoin. I like reading his posts and one of them is\n>>     https://bitcointalk.org/index.php?topic=156390.msg1659654#msg1659654\n>>\n>>     I had emailed about Privacy related things on July 23:\n>>     https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019276.html\n>>\n>>     It was my birthday on 23 and had few beers so maybe email wasn't\n>>     very focused. Although basic idea was to initiate discussion\n>>     about improving privacy in different Bitcoin projects. I did not\n>>     receive any response except one person who liked the video I\n>>     mentioned in the email. So here is one project which uses GitHub\n>>     pages and will have the following things:\n>>\n>>     1.Issues and PRs related to privacy from different Bitcoin\n>>     projects. I have added few from Bitcoin Core (full node\n>>     implementation), Bisq(DEX) and LND (LN implementation) right now.\n>>     2.Blog section for my opinion on different privacy related issues\n>>     and PRs.\n>>     3.'Hall of Fame' section to appreciate the contribution of devs\n>>     who are improving privacy in different Bitcoin projects.\n>>\n>>     I will be happy if this project helps in improving privacy or\n>>     helps users/devs in any other way. This project will never turn\n>>     in to a paid newsletter or needs any sponsors, however any\n>>     contribution to make the website better would be appreciated.\n>>     Edward Snowden can also contribute if he wants to do more than\n>>     just tweets to help improve Bitcoin privacy.\n>>\n>>     Link: https://prayank23.github.io/camouflage/\n>>\n>>     Will move everything to new repository this weekend:\n>>     https://github.com/BlockchainCommons/Bitcoin-Camouflage\n>>\n>>     -- \n>>     Prayank\n>>\n>>     A3B1 E430 2298 178F\n>>\n>>\n>>     _______________________________________________\n>>     bitcoin-dev mailing list\n>>     bitcoin-dev at lists.linuxfoundation.org\n>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n\n-- \nSophia-Antipolis, France\nLinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\nGitHub : https://www.github.com/Ayms\nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\nPeersm : http://www.peersm.com\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210829/3e69e234/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Camouflage: A project dedicated to Hal Finney",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Prayank",
                "Aymeric Vitte"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 11190
        }
    },
    {
        "title": "[bitcoin-dev] Braidpool: Proposal for a decentralised mining pool",
        "thread_messages": [
            {
                "author": "pool2win",
                "date": "2021-08-29T05:57:43",
                "message_text_only": "We have been working on a peer to peer mining pool that overcomes the\nproblems faced by P2Pool and enables building a futures market for\nhashrate.\n\u00a0\nThe proposal can be found here:\nhttps://github.com/pool2win/braidpool/raw/main/proposal/proposal.pdf\n\u00a0\nThe key features of the pool are:\n\u00a0\n1. Lower variance for smaller miners, even when large miners join\n\u00a0 the pool.\n2. Miners build their own blocks, just like in P2Pool.\n3. Payouts require a constant size blockspace, independent of the\n\u00a0 number of miners in the pool.\n4. Provide building blocks for enabling a futures market of hash\n\u00a0 rates.\n\u00a0\nBraidpool: Decentralised Mining Pool for Bitcoin\n\u00a0\nAbstract. Bitcoin P2Pool's usage has steadily declined over the years,\nnegatively impacting bitcoin's decentralisation. The variance in\nearnings for miners increases with total hashrate participating in\nP2Pool, and payouts require a linearly increasing block space with the\nnumber of miners participating in the pool. We present a solution that\nuses a DAG of shares replicated at all miners. The DAG is then used to\ncompute rewards for miners. Rewards are paid out using one-way payment\nchannels by an anonymous hub communicating with the miners using Tor's\nhidden services. Using the payment channels construction, neither the\nhub nor the miners can cheat.\n\nFull proposal at\nhttps://github.com/pool2win/braidpool/raw/main/proposal/proposal.pdf\n\u00a0\nDetails on trading hashrate are here:\nhttps://pool2win.github.io/braidpool/2021/08/18/deliver-hashrate-to-market-makers.html\n\u00a0\n@pool2win"
            }
        ],
        "thread_summary": {
            "title": "Braidpool: Proposal for a decentralised mining pool",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "pool2win"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1529
        }
    },
    {
        "title": "[bitcoin-dev] Using transaction version number in different projects",
        "thread_messages": [
            {
                "author": "Prayank",
                "date": "2021-08-29T09:32:47",
                "message_text_only": "print('Hello, world!')\n\nI had asked related question on Bitcoin Stackexchange:\u00a0https://bitcoin.stackexchange.com/questions/108248/version-in-transaction\n\nWanted to know if others think we should allow more numbers in transaction version by considering such transaction standard. I have shared an example how transaction version can be used to bet on something that involves 2 outcomes:\n\nhttps://gist.github.com/prayank23/6f54e9a27f057abd1182436e7f88d1ac\n\nAnything wrong with this approach? We could use oracles (DLC) or something else later to settle the bet and create a release transaction. However wanted to confirm if everything looks okay until funding transaction. Nothing involves any centralized server or trusting third parties:\n1.Tx1 is a normal OP_RETURN transaction.\n2.App will save results for `getrawmempool` regularly in local db. It will check if any transaction wants to participate in bets.\n3.Multisig address will be created using two public keys. One entered by user and other from mempool.\n4.Funding transaction will use the version bits to indicate if Alice wants to bet on India or Australia.\n\n\n-- \nPrayank\n\nA3B1 E430 2298 178F\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210829/4daf00e3/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2021-08-29T14:56:16",
                "message_text_only": "On Sunday, August 29th, 2021 at 5:32 AM, Prayank via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Wanted to know if others think we should allow more numbers in transaction version by considering such transaction standard. I have shared an example how transaction version can be used to bet on something that involves 2 outcomes:\n> https://gist.github.com/prayank23/6f54e9a27f057abd1182436e7f88d1ac\n\nI can't say I understand what you're suggesting, or what transaction version numbers have to do with it, so take the following with the caveat that I may be missing your point.\n\nGenerally, my view is that Bitcoin transactions should solely contain the information necessary for the world to validate them. Given that, as of now, there are no consensus rules (or even generally-adopted relay policies) that care about the version number except it being 1 or 2 (due to BIP68), I would say that the usage of anything but those 2 possible numbers is both pointless and a gratuitous loss of privacy: for numbers with no protocol-defined meaning, the usage of an uncommon one reveals something to the world that should be privately communicated to the parties involved instead.\n\nCombined with the fact that currently-unused version numbers may well be used for future consensus rules like BIP68, which any use you're suggesting may interfere with, I say no: versions numbers with no protocol-defined meaning should not be standard. They are reserved for future extensions.\n\nCheers,\n\n--\nPieter\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210829/37bf2c9a/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Using transaction version number in different projects",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Pieter Wuille",
                "Prayank"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3022
        }
    },
    {
        "title": "[bitcoin-dev] Proposal for a few IANA mime-types related to Bitcoin",
        "thread_messages": [
            {
                "author": "Peter D. Gray",
                "date": "2021-08-31T18:27:41",
                "message_text_only": "Hi list!\n\nI am proposing to register the following MIME (RFC 2046) media types with the IANA:\n\n\nbitcoin/psbt\n\n    - aka. a BIP-174 file, in binary\n    - does not make any claims about signed/unsigned status; lets leave that to the file\n\nbitcoin/txn\n\n    - aka. wire-ready fully-signed transaction in binary\n\nbitcoin/uri\n\n    - aka [BIP-21](https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki)\n    - could be just a bare bech32 or base58 payment address\n    - but can also encode amount, comments in URL args\n    - potentially interesting as a response to 402 - Payment required\n\n\nOther thoughts\n\n- some mime-types are proposed in BIP-71 but those are unrelated to above, and never\n  seem to have been registered\n\n- for those who like to encode their binary as base64 or hex, that can be indicated\n  as \"encoding=hex\" or \"encoding=base64\" in the optional parameters, just like\n  \"text/plain; encoding=utf-8\" does. However, the default must be binary.\n\n- although the above are useful for web servers, they are also useful elsewhere and I\n  intend to use them in NFC (NDEF records) where a shorter length is critical.\n\n- I have no idea how easily IANA will accept these proposals.\n\n- current approved mime types: https://www.iana.org/assignments/media-types/media-types.xhtml\n\nThoughts?\n\n---\n@DocHEX  ||  Coinkite  ||  PGP: A3A31BAD 5A2A5B10\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210831/a4aa0e7d/attachment.sig>"
            },
            {
                "author": "Christopher Allen",
                "date": "2021-08-31T19:01:23",
                "message_text_only": "Note that a number of wallet companies are now supporting the UR encoded\nversion of PSBTs, allowing for better QR & Airgap solutions, and also\nleverage CBOR which is an IETF standard.\n\nWe have a community of Airgap wallet developers at\nhttps://github.com/BlockchainCommons/Airgapped-Wallet-Community\n\n\u2026and libraries at\nhttps://github.com/BlockchainCommons/crypto-commons#urs\n\nWe\u2019d love for you to register UR as well, maybe as bitcoin/psbt+ur\n\nCan you bring this up in our community for further discussion?\nhttps://github.com/BlockchainCommons/Airgapped-Wallet-Community/discussions\n\nThanks!\n\n\u2014 Christopher Allen [via iPhone]\n\nOn Tue, Aug 31, 2021 at 11:41 AM Peter D. Gray via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi list!\n>\n> I am proposing to register the following MIME (RFC 2046) media types with\n> the IANA:\n>\n>\n> bitcoin/psbt\n>\n>     - aka. a BIP-174 file, in binary\n>     - does not make any claims about signed/unsigned status; lets leave\n> that to the file\n>\n> bitcoin/txn\n>\n>     - aka. wire-ready fully-signed transaction in binary\n>\n> bitcoin/uri\n>\n>     - aka [BIP-21](\n> https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki)\n>     - could be just a bare bech32 or base58 payment address\n>     - but can also encode amount, comments in URL args\n>     - potentially interesting as a response to 402 - Payment required\n>\n>\n> Other thoughts\n>\n> - some mime-types are proposed in BIP-71 but those are unrelated to above,\n> and never\n>   seem to have been registered\n>\n> - for those who like to encode their binary as base64 or hex, that can be\n> indicated\n>   as \"encoding=hex\" or \"encoding=base64\" in the optional parameters, just\n> like\n>   \"text/plain; encoding=utf-8\" does. However, the default must be binary.\n>\n> - although the above are useful for web servers, they are also useful\n> elsewhere and I\n>   intend to use them in NFC (NDEF records) where a shorter length is\n> critical.\n>\n> - I have no idea how easily IANA will accept these proposals.\n>\n> - current approved mime types:\n> https://www.iana.org/assignments/media-types/media-types.xhtml\n>\n> Thoughts?\n>\n> ---\n> @DocHEX  ||  Coinkite  ||  PGP: A3A31BAD 5A2A5B10\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210831/5b3915b1/attachment.html>"
            },
            {
                "author": "Peter D. Gray",
                "date": "2021-08-31T19:18:00",
                "message_text_only": "QR Codes do not use IANA mime-types.\n\nIf anyone wanted to use UR encoding for PSBT data in a web context (http),\nNFC, or email, it would probably be best to discourage them.\n\nWhile I can understand the need for UR encoding in animated QR\ncodes, I don't think any other use-case could justify introducing\na new word list (ByteWords), a unique checksum algo (Xoshiro256),\nfountain codes (Luby Transform) and CBOR... just to wrap a few k\nof binary.\n\nI do love CBOR though. It's the best.\n\n---\n@DocHEX  ||  Coinkite  ||  PGP: A3A31BAD 5A2A5B10\n\nOn Tue, Aug 31, 2021 at 12:01:23PM -0700, Christopher Allen wrote:\n> Note that a number of wallet companies are now supporting the UR encoded\n> version of PSBTs, allowing for better QR & Airgap solutions, and also\n> leverage CBOR which is an IETF standard.\n> \n> We have a community of Airgap wallet developers at\n> https://github.com/BlockchainCommons/Airgapped-Wallet-Community\n> \n> \u2026and libraries at\n> https://github.com/BlockchainCommons/crypto-commons#urs\n> \n> We\u2019d love for you to register UR as well, maybe as bitcoin/psbt+ur\n> \n> Can you bring this up in our community for further discussion?\n> https://github.com/BlockchainCommons/Airgapped-Wallet-Community/discussions\n> \n> Thanks!\n> \n> \u2014 Christopher Allen [via iPhone]\n> \n> On Tue, Aug 31, 2021 at 11:41 AM Peter D. Gray via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> > Hi list!\n> >\n> > I am proposing to register the following MIME (RFC 2046) media types with\n> > the IANA:\n> >\n> >\n> > bitcoin/psbt\n> >\n> >     - aka. a BIP-174 file, in binary\n> >     - does not make any claims about signed/unsigned status; lets leave\n> > that to the file\n> >\n> > bitcoin/txn\n> >\n> >     - aka. wire-ready fully-signed transaction in binary\n> >\n> > bitcoin/uri\n> >\n> >     - aka [BIP-21](\n> > https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki)\n> >     - could be just a bare bech32 or base58 payment address\n> >     - but can also encode amount, comments in URL args\n> >     - potentially interesting as a response to 402 - Payment required\n> >\n> >\n> > Other thoughts\n> >\n> > - some mime-types are proposed in BIP-71 but those are unrelated to above,\n> > and never\n> >   seem to have been registered\n> >\n> > - for those who like to encode their binary as base64 or hex, that can be\n> > indicated\n> >   as \"encoding=hex\" or \"encoding=base64\" in the optional parameters, just\n> > like\n> >   \"text/plain; encoding=utf-8\" does. However, the default must be binary.\n> >\n> > - although the above are useful for web servers, they are also useful\n> > elsewhere and I\n> >   intend to use them in NFC (NDEF records) where a shorter length is\n> > critical.\n> >\n> > - I have no idea how easily IANA will accept these proposals.\n> >\n> > - current approved mime types:\n> > https://www.iana.org/assignments/media-types/media-types.xhtml\n> >\n> > Thoughts?\n> >\n> > ---\n> > @DocHEX  ||  Coinkite  ||  PGP: A3A31BAD 5A2A5B10\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >"
            },
            {
                "author": "Christopher Allen",
                "date": "2021-08-31T20:02:44",
                "message_text_only": "On Tue, Aug 31, 2021 at 12:18 PM Peter D. Gray <peter at coinkite.com> wrote:\n\n> QR Codes do not use IANA mime-types.\n>\n> If anyone wanted to use UR encoding for PSBT data in a web context (http),\n> NFC, or email, it would probably be best to discourage them.\n>\n> While I can understand the need for UR encoding in animated QR\n> codes, I don't think any other use-case could justify introducing\n> a new word list (ByteWords), a unique checksum algo (Xoshiro256),\n> fountain codes (Luby Transform) and CBOR... just to wrap a few k\n> of binary.\n>\n> I do love CBOR though. It's the best.\n\n\nUR is more than just a QR, it is URL conformant text that is optimized for\ncompression in QRs.\n\nIn particular, take a look at the explanation of the UR format at the 20m0s\nmark in this video:\nhttps://youtu.be/RYgOFSdUqWY\n\nThe rest of the video explains why we made the choices we did. We wanted to\nleverage existing standards, but there were too many compromises expecially\ngive QR requirements. See the section on \u201cWhy Another Standard\u201d in our\noverview at\nhttps://github.com/BlockchainCommons/crypto-commons/blob/master/Docs/ur-1-overview.md#why-another-standard\n\nNote that the UR specification just is not just being adopted by wallet\nvendors, but also a number of online services / transaction coordinators\nthat only have access watch-only keys. These services can then do a\ncrypto-request for the airgapped wallet to sign the PSBT.\n\n\u2014 Christopher Allen\n\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210831/555ef40b/attachment.html>"
            },
            {
                "author": "Andrew Chow",
                "date": "2021-08-31T19:46:55",
                "message_text_only": "Hi Peter,\n\nIt would be nice to have mime types registered for Bitcoin things, but\nI'm not sure that it will be possible, at least not in the way that we\nwould like. I tried doing this with \"application/bitcoin-psbt\" back in\n2019 but it was not accepted. From that attempt, here is what I have\nlearned:\n\nThere are only a few accepted top level types, so we would not be able\nto use \"bitcoin\" as the top level (unless you want to submit an RFC to\nadd a \"bitcoin\" top level). Of the available top level types,\n\"application\" is the most appropriate for Bitcoin.\n\nNext is the tree that the mime type should be in. The best would be the\nStandards tree, but it has some requirements that Bitcoin doesn't really\nmeet. In order to be in the standards tree, the registration must be\neither associated with an IETF specification (so a RFC) or registered by\na recognized standards related organization. Unfortunately the closest\nthing to a standards organization that Bitcoin has is the BIPs process,\nand that is not a really a standards organization nor is it recognized\nby IANA. So in order to register the mimetypes as Standards tree types,\nwe would need to write an RFC, but this could be an independent\nsubmission (https://www.rfc-editor.org/about/independent/) rather than\nIETF-stream submission. I did not continue to pursue this because I\ndidn't have the time.\n\nAnother alternative would be to use the Vendor tree, but that would\nprefix the mimetype with \"vnd.\" so it would end up being something like\n\"application/vnd.bitcoin.psbt\". I did not think this was an reasonable\nso I did not continue to pursue this avenue.\n\n\nAndrew Chow\n\nOn 8/31/21 2:27 PM, Peter D. Gray via bitcoin-dev wrote:\n> Hi list!\n>\n> I am proposing to register the following MIME (RFC 2046) media types with the IANA:\n>\n>\n> bitcoin/psbt\n>\n>      - aka. a BIP-174 file, in binary\n>      - does not make any claims about signed/unsigned status; lets leave that to the file\n>\n> bitcoin/txn\n>\n>      - aka. wire-ready fully-signed transaction in binary\n>\n> bitcoin/uri\n>\n>      - aka [BIP-21](https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki)\n>      - could be just a bare bech32 or base58 payment address\n>      - but can also encode amount, comments in URL args\n>      - potentially interesting as a response to 402 - Payment required\n>\n>\n> Other thoughts\n>\n> - some mime-types are proposed in BIP-71 but those are unrelated to above, and never\n>    seem to have been registered\n>\n> - for those who like to encode their binary as base64 or hex, that can be indicated\n>    as \"encoding=hex\" or \"encoding=base64\" in the optional parameters, just like\n>    \"text/plain; encoding=utf-8\" does. However, the default must be binary.\n>\n> - although the above are useful for web servers, they are also useful elsewhere and I\n>    intend to use them in NFC (NDEF records) where a shorter length is critical.\n>\n> - I have no idea how easily IANA will accept these proposals.\n>\n> - current approved mime types: https://www.iana.org/assignments/media-types/media-types.xhtml\n>\n> Thoughts?\n>\n> ---\n> @DocHEX  ||  Coinkite  ||  PGP: A3A31BAD 5A2A5B10\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "Proposal for a few IANA mime-types related to Bitcoin",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Andrew Chow",
                "Peter D. Gray",
                "Christopher Allen"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 12237
        }
    }
]