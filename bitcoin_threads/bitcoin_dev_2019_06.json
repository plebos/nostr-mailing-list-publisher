[
    {
        "title": "[bitcoin-dev] OP_SECURETHEBAG (supersedes OP_CHECKOUTPUTSVERIFY)",
        "thread_messages": [
            {
                "author": "Jeremy",
                "date": "2019-06-01T05:35:45",
                "message_text_only": "Hi All,\n\nOP_CHECKOUTPUTSHASHVERIFY is retracted in favor of OP_SECURETHEBAG*.\nOP_SECURETHEBAG does more or less the same thing, but fixes malleability\nissues and lifts the single output restriction to a known number of inputs\nrestriction.\n\nOP_CHECKOUTPUTSVERIFY had some issues with malleability of version and\nlocktime. OP_SECURETHEBAG commits to both of these values.\n\nOP_SECURETHEBAG also lifts the restriction that OP_CHECKOUTPUTSVERIFY had\nto be spent as only a single input, and instead just commits to the number\nof inputs. This allows for more flexibility, but keeps it easy to get the\nsame single output restriction.\n\nBIP:\nhttps://github.com/JeremyRubin/bips/blob/op-secure-the-bag/bip-secure-the-bag.mediawiki\nImplementation: https://github.com/JeremyRubin/bitcoin/tree/secure_the_bag\n\nA particularly useful topic of discussion is how best to eliminate the\nPUSHDATA and treat OP_SECURETHEBAG like a pushdata directly. I thought\nabout how the interpreter works and is implemented and couldn't come up\nwith something noninvasive.\n\nThank you for your review and discussion,\n\nJeremy\n\n* Plus the name is better\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190531/b1cc3a48/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-02T05:35:43",
                "message_text_only": "> Using an OP_SECURETHEBAG Taproot, the recipient may even give the sender an address which makes a channel unbeknownst to them.\n\n\nThis requires special design to be safe.\n\nEvery offchain protocol requires a backout transaction to be created before the funding transaction output is committed onchain.\nThis backout transaction ensures that the funder of the channel can back out if the other side aborts the protocol.\n\nFor Poon-Dryja channels this is the initial commitment transaction.\nThe continued operation of the protocol requires the initial commitment to be revoked at the next update.\n\nSo we need a plausible backout for the receiver first.\n\nTo do so, we make the funding transaction address a Taproot with internal pubkey 2-of-2 of the receiver and its channel counterparty.\nThe Taproot hides a single script alternative, a `OP_SECURETHEBAG` that ensures it is paid out to a pure script (i.e. Taproot internal key is a NUMS point), the scripts forming a revocable output to the receiver (let receiver claim with `OP_CHECKSEQUENCEVERIFY`, or counterparty to revoke immediately if it knows revocation key).\n\nThis is essentially a walletless channel open, which I described before with `SIGHASH_NOINPUT`.\n\nChannel factories using `OP_SECURETHEBAG` cannot be updated (i.e. not able to close channels and reuse funds to open new channels offchain), i.e. close-only factories.\nThe above revocation trick only works with two participants, and it would be largely pointless to have 2-participant factories (unless you were e.g. transporting HTLCs separately from DLCs in two channels of the same factory).\n\nChannel factories based on the Decker-Russell-Osuntokun mechanism (\"eltoo\") allow reorganizing channels offchain, without hitting the chain at all.\nThese need `SIGHASH_NOINPUT`/`SIGHASH_ANYPREVOUT`.\n\nFor channel factories, `SIGHASH_NOINPUT` is better.\n`OP_SECURETHEBAG` requires the funding output to commit to a particular output set.\n`SIGHASH_NOINPUT` lets the signatories introduce a new possible output set later.\n\nOne might compare `OP_SECURETHEBAG` to MAST, while `SIGHASH_NOINPUT` is comparable to Graftroot.\nMAST has a fixed set of alternatives, while Graftroot allows signatories to add new alternatives later.\n\n\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Saturday, June 1, 2019 1:35 PM, Jeremy via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi All,\n>\n> OP_CHECKOUTPUTSHASHVERIFY is retracted in favor of OP_SECURETHEBAG*. OP_SECURETHEBAG does more or less the same thing, but fixes malleability issues and lifts the single output restriction to a known number of inputs restriction.\n>\n> OP_CHECKOUTPUTSVERIFY had some issues with malleability of version and locktime. OP_SECURETHEBAG commits to both of these values.\n>\n> OP_SECURETHEBAG also lifts the restriction that OP_CHECKOUTPUTSVERIFY had to be spent as only a single input, and instead just commits to the number of inputs. This allows for more flexibility, but keeps it easy to get the same single output restriction.\n>\n> BIP: https://github.com/JeremyRubin/bips/blob/op-secure-the-bag/bip-secure-the-bag.mediawiki\n> Implementation: https://github.com/JeremyRubin/bitcoin/tree/secure_the_bag\n>\n> A particularly useful topic of discussion is how best to eliminate the PUSHDATA and treat OP_SECURETHEBAG like a pushdata directly. I thought about how the interpreter works and is implemented and couldn't come up with something noninvasive.\n>\n> Thank you for your review and discussion,\n>\n> Jeremy\n>\n> * Plus the name is better"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-06-02T14:32:33",
                "message_text_only": "On Sat, Jun 1, 2019 at 12:47 PM Jeremy via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi All,\n>\n> OP_CHECKOUTPUTSHASHVERIFY is retracted in favor of OP_SECURETHEBAG*.\n> OP_SECURETHEBAG does more or less the same thing, but fixes malleability\n> issues and lifts the single output restriction to a known number of inputs\n> restriction.\n>\n> OP_CHECKOUTPUTSVERIFY had some issues with malleability of version and\n> locktime. OP_SECURETHEBAG commits to both of these values.\n>\n\nCan you elaborate a bit more on what the issues were?\n\n\n> OP_SECURETHEBAG also lifts the restriction that OP_CHECKOUTPUTSVERIFY had\n> to be spent as only a single input, and instead just commits to the number\n> of inputs. This allows for more flexibility, but keeps it easy to get the\n> same single output restriction.\n>\n> BIP:\n> https://github.com/JeremyRubin/bips/blob/op-secure-the-bag/bip-secure-the-bag.mediawiki\n> Implementation: https://github.com/JeremyRubin/bitcoin/tree/secure_the_bag\n>\n> A particularly useful topic of discussion is how best to eliminate the\n> PUSHDATA and treat OP_SECURETHEBAG like a pushdata directly. I thought\n> about how the interpreter works and is implemented and couldn't come up\n> with something noninvasive.\n>\n\nI'm not a Core developer but from what I understand, I'd be inclined to to\ntreat OP_SECURETHEBAG as with an immediate 32-byte parameter by modifying\nGetScriptOp to return the 32-byte parameter through pvchRet.\n\nbool GetScriptOp(CScriptBase::const_iterator& pc,\nCScriptBase::const_iterator end, opcodetype& opcodeRet,\nstd::vector<unsigned char>* pvchRet)\n{\n    opcodeRet = OP_INVALIDOPCODE;\n    if (pvchRet)\n        pvchRet->clear();\n    if (pc >= end)\n        return false;\n\n    // Read instruction\n    if (end - pc < 1)\n        return false;\n    unsigned int opcode = *pc++;\n\n    // Immediate operand\n    if (opcode <= OP_PUSHDATA4)\n    {\n        // ...\n    }\n\n    if (opcode == OP_SECURETHEBAG) {\n        if (end - pc < 0 || (unsigned int)(end - pc) < 32)\n            return false;\n        if (pvchRet)\n            pvchRet->assign(pc, pc + 32);\n        pc += 32;\n    }\n\n    opcodeRet = static_cast<opcodetype>(opcode);\n    return true;\n}\n\nand go from there.\n\nThank you for your review and discussion,\n>\n> Jeremy\n>\n> * Plus the name is better\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190602/74ada17f/attachment-0001.html>"
            },
            {
                "author": "Jeremy",
                "date": "2019-06-02T21:32:20",
                "message_text_only": "Hi Russell,\n\nThanks for the response. I double checked my work in drafting my response\nand realized I didn't address all the malleability concerns, I believe I\nhave now (fingers crossed) addressed all points of malleability.\n\n*The malleability concerns are as follows:*\n\nA TXID is computed as:\n\ndef txid(self):\n         r = b\"\"\n         r += struct.pack(\"<i\", self.nVersion)\n         r += ser_vector(self.vin)\n         r += ser_vector(self.vout)\n         r += struct.pack(\"<I\", self.nLockTime)\n         return sha256(r)\n\nif the bag hash is just:\n\ndef get_bag_hash(self):\n         r = b\"\"\n         r += ser_vector(self.vout)\n         return TaggedHash(\"BagHash\", r)\n\nWe allow changing a few things: nVersion, nLockTime, scriptSig (per input),\nnumber of inputs, nSequence (per input) which can change the TXID/what the\ntransaction does.\n\nchanging nVersion: can disable BIP68, change TXID\nchanging nLockTime: can change TXID\nchanging nSequence: can change TXID\nchanging number of inputs: half spend problem, change TXID\nchanging scriptsigs: change TXID if co-spent with legacy input\n\nInstead, we can use the following digest:\n\n    def get_bag_hash(self):\n         r = b\"\"\n         r += struct.pack(\"<i\", self.nVersion)\n         r += struct.pack(\"<I\", self.nLockTime)\n         r += sha256(b\"\".join(out.serialize() for out in self.vout))\n         r += sha256(b\"\".join(struct.pack(\"<I\", inp.nSequence) for inp in\nself.vin))\n         r += struct.pack(\"<Q\", len(self.vin))\n         for inp in self.vin:\n             r += ser_string(inp.scriptSig)\n         return TaggedHash(\"BagHash\", r)\n\nwhich should lock in all the relevant bits. The only part left out is the\nCOutpoint, which can't be known ahead of time (because it depends on the\ncreating txn). Technically, len(vin) is redundant with\nsha256(b\"\".join(struct.pack(\"<I\", inp.nSequence) for inp in self.vin)),\nbecause the length padding on the hash implied the number of inputs, but I\nfigured it's best to err on explicit.\n\nA further benefit (in a CISC sense) of committing to all these values is\nthat we enforce CLTV and CSV semantics for free on OP_SECURETHEBAG scripts,\nwhich helps with channels.\n\n\n\n*Treating OP_SECURETHEBAG as a PUSHDATA:*\n\nI agree in theory it's nicer, and am 100% open to implementing it that way.\nThe only concern I have with doing it this way is that it means that a\nflags must be added to GetOp (or GetOp must be modularized to be per-script\nversion) because it affects script parsing, as opposed to using a multibyte\nopcode which contains a pushdata, which remain compatible with prior script\nparsing.\n\nI'd like to get rough consensus on the best approach for compatibility with\ndownstream software, hence choosing this option for the draft.\n\nPersonally, my preference is to *not* do flags and just have a separate\nparser version which cleans up some of our past sins. We can experiment\nwith a fancier parser (as you've shown in Haskell/Rust/Coq), perhaps even\nbitwise huffman encoding opcodes to save space on scripts (i.e. the 7 most\ncommon opcodes could fit within 3 bits) or whatever else we like. I just\ndidn't want to have the scope creep too far on this particular BIP, but I'm\nwith you that lookahead is a hack compared to an actual parametrized\nargument.\n\nI think you'd also appreciate the template script expansion approach\nmentioned in the BIP -- it gets around some of these concerns, but requires\nchanges to Taproot.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190602/dfb4e5a2/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2019-06-05T09:30:39",
                "message_text_only": "On Fri, May 31, 2019 at 10:35:45PM -0700, Jeremy via bitcoin-dev wrote:\n> OP_CHECKOUTPUTSHASHVERIFY is retracted in favor of OP_SECURETHEBAG*.\n\nI think you could generalise that slightly and make it fit in\nwith the existing opcode naming by calling it something like\n\"OP_CHECKTXDIGESTVERIFY\" and pull a 33-byte value from the stack,\nconsisting of a sha256 hash and a sighash-byte, and adding a new sighash\nvalue corresponding to the set of info you want to include in the hash,\nwhich I think sounds a bit like \"SIGHASH_EXACTLY_ONE_INPUT | SIGHASH_ALL\"\n\nFWIW, I'm not really seeing any reason to complicate the spec to ensure\nthe digest is precommitted as part of the opcode.\n\nCheers,\naj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-06T07:30:13",
                "message_text_only": "Good morning aj,\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Wednesday, June 5, 2019 5:30 PM, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Fri, May 31, 2019 at 10:35:45PM -0700, Jeremy via bitcoin-dev wrote:\n>\n> > OP_CHECKOUTPUTSHASHVERIFY is retracted in favor of OP_SECURETHEBAG*.\n>\n> I think you could generalise that slightly and make it fit in\n> with the existing opcode naming by calling it something like\n> \"OP_CHECKTXDIGESTVERIFY\" and pull a 33-byte value from the stack,\n> consisting of a sha256 hash and a sighash-byte, and adding a new sighash\n> value corresponding to the set of info you want to include in the hash,\n> which I think sounds a bit like \"SIGHASH_EXACTLY_ONE_INPUT | SIGHASH_ALL\"\n>\n> FWIW, I'm not really seeing any reason to complicate the spec to ensure\n> the digest is precommitted as part of the opcode.\n>\n\nI believe in combination with `OP_LEFT` and `OP_CAT` this allows Turing-complete smart contracts, in much the same way as `OP_CHECKSIGFROMSTACK`?\n\nPass in the spent transaction (serialised for txid) and the spending transaction (serialised for sighash) as part of the witness of the spending transaction.\n\nScript verifies that the spending transaction witness value is indeed the spending transaction by `OP_SHA256 <SIGHASH_ALL> OP_SWAP OP_CAT OP_CHECKTXDIGESTVERIFY`.\nScript verifies the spent transaction witness value is indeed the spent transaction by hashing it, then splitting up the hash with `OP_LEFT` into bytes, and comparing the bytes to the bytes in the input of the spending transaction witness value (txid being the bytes in reversed order).\n\nThen the Script can extract a commitment of itself by extracting the output of the spent transaction.\nThis lets the Script check that the spending transaction also pays to the same script.\n\nThe Script can then access a state value, for example from an `OP_RETURN` output of the spent transaction, and enforce that a correct next-state is used in the spending transaction.\nIf the state is too large to fit in a standard `OP_RETURN`, then the current state can be passed in as a witness and validated against a hash commitment in an `OP_RETURN` output.\n\nI believe this is the primary reason against not pulling data from the stack.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-06-18T20:57:34",
                "message_text_only": "Just to be clear, while OP_CHECKTXDIGESTVERIFY would enable this style of\ncovenants if it pulled data from the stack, the OP_SECURETHEBAG probably\ncannot create covenants even if it were to pull the data from the stack\nunless some OP_TWEEKPUBKEY operation is added to Script because the\n\"commitment of the script itself\" isn't part of the OP_SECURETHEBAG.\n\nSo with regards to OP_SECURETHEBAG, I am also \"not really seeing any reason\nto complicate the spec to ensure the digest is precommitted as part of the\nopcode.\"\n\nOn Thu, Jun 6, 2019 at 3:33 AM ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning aj,\n>\n>\n> Sent with ProtonMail Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Wednesday, June 5, 2019 5:30 PM, Anthony Towns via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > On Fri, May 31, 2019 at 10:35:45PM -0700, Jeremy via bitcoin-dev wrote:\n> >\n> > > OP_CHECKOUTPUTSHASHVERIFY is retracted in favor of OP_SECURETHEBAG*.\n> >\n> > I think you could generalise that slightly and make it fit in\n> > with the existing opcode naming by calling it something like\n> > \"OP_CHECKTXDIGESTVERIFY\" and pull a 33-byte value from the stack,\n> > consisting of a sha256 hash and a sighash-byte, and adding a new sighash\n> > value corresponding to the set of info you want to include in the hash,\n> > which I think sounds a bit like \"SIGHASH_EXACTLY_ONE_INPUT | SIGHASH_ALL\"\n> >\n> > FWIW, I'm not really seeing any reason to complicate the spec to ensure\n> > the digest is precommitted as part of the opcode.\n> >\n>\n> I believe in combination with `OP_LEFT` and `OP_CAT` this allows\n> Turing-complete smart contracts, in much the same way as\n> `OP_CHECKSIGFROMSTACK`?\n>\n> Pass in the spent transaction (serialised for txid) and the spending\n> transaction (serialised for sighash) as part of the witness of the spending\n> transaction.\n>\n> Script verifies that the spending transaction witness value is indeed the\n> spending transaction by `OP_SHA256 <SIGHASH_ALL> OP_SWAP OP_CAT\n> OP_CHECKTXDIGESTVERIFY`.\n> Script verifies the spent transaction witness value is indeed the spent\n> transaction by hashing it, then splitting up the hash with `OP_LEFT` into\n> bytes, and comparing the bytes to the bytes in the input of the spending\n> transaction witness value (txid being the bytes in reversed order).\n>\n> Then the Script can extract a commitment of itself by extracting the\n> output of the spent transaction.\n> This lets the Script check that the spending transaction also pays to the\n> same script.\n>\n> The Script can then access a state value, for example from an `OP_RETURN`\n> output of the spent transaction, and enforce that a correct next-state is\n> used in the spending transaction.\n> If the state is too large to fit in a standard `OP_RETURN`, then the\n> current state can be passed in as a witness and validated against a hash\n> commitment in an `OP_RETURN` output.\n>\n> I believe this is the primary reason against not pulling data from the\n> stack.\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190618/783d5ba9/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2019-06-20T22:05:52",
                "message_text_only": "On Tue, Jun 18, 2019 at 04:57:34PM -0400, Russell O'Connor wrote:\n> So with regards to OP_SECURETHEBAG, I am also \"not really seeing any reason to\n> complicate the spec to ensure the digest is precommitted as part of the\n> opcode.\"\n\nAlso, I think you can simulate OP_SECURETHEBAG with an ANYPREVOUT\n(NOINPUT) sighash (Johnson Lau's mentioned this before, but not sure if\nit's been spelled out anywhere); ie instead of constructing\n\n  X = Hash_BagHash( version, locktime, [outputs], [sequences], num_in )\n\nand having the script be \"<X> OP_SECURETHEBAG\" you calculate an\nANYPREVOUT sighash for SIGHASH_ANYPREVOUTANYSCRIPT | SIGHASH_ALL:\n\n  Y = Hash_TapSighash( 0, 0xc1, version, locktime, [outputs], 0,\n                       amount, sequence)\n\nand calculate a signature sig = Schnorr(P,m) for some pubkey P, and\nmake your script be \"<sig> <P> CHECKSIG\".\n\nThat loses the ability to commit to the number of inputs or restrict\nthe nsequence of other inputs, and requires a bigger script (sig and P\nare ~96 bytes instead of X's 32 bytes), but is otherwise pretty much the\nsame as far as I can tell. Both scripts are automatically satisfied when\nrevealed (with the correct set of outputs), and don't need any additional\nwitness data.\n\nIf you wanted to construct \"X\" via script instead of hardcoding a value\nbecause it got you generalised covenants or whatever; I think you could\nget the same effect with CAT,LEFT, and RIGHT: you'd construct Y in much\nthe same way you construct X, but you'd then need to turn that into a\nsignature. You could do so by using pubkey P=G and nonce R=G, which\nmeans you need to calculate s=1+hash(G,G,Y)*1 -- calculating the hash\npart is easy, multiplying it by 1 is easy, and to add 1 you can probably\ndo something along the lines of:\n\n    OP_DUP 4 OP_RIGHT 1 OP_ADD OP_SWAP 28 OP_LEFT OP_SWAP OP_CAT\n\n(ie, take the last 4 bytes, increment it using 4-byte arithmetic,\nthen cat the first 28 bytes and the result. There's overflow issues,\nbut I think they can be worked around either by allowing you to choose\ndifferent locktimes, or by more complicated script)\n\nCheers,\naj"
            },
            {
                "author": "Jeremy",
                "date": "2019-06-23T06:43:22",
                "message_text_only": "This is insufficient: sequences must be committed to because they affect\nTXID. As with scriptsigs (witness data fine to ignore). NUM_IN too.\n\nAny malleability makes this much less useful.\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\n\nOn Fri, Jun 21, 2019 at 10:31 AM Anthony Towns via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Tue, Jun 18, 2019 at 04:57:34PM -0400, Russell O'Connor wrote:\n> > So with regards to OP_SECURETHEBAG, I am also \"not really seeing any\n> reason to\n> > complicate the spec to ensure the digest is precommitted as part of the\n> > opcode.\"\n>\n> Also, I think you can simulate OP_SECURETHEBAG with an ANYPREVOUT\n> (NOINPUT) sighash (Johnson Lau's mentioned this before, but not sure if\n> it's been spelled out anywhere); ie instead of constructing\n>\n>   X = Hash_BagHash( version, locktime, [outputs], [sequences], num_in )\n>\n> and having the script be \"<X> OP_SECURETHEBAG\" you calculate an\n> ANYPREVOUT sighash for SIGHASH_ANYPREVOUTANYSCRIPT | SIGHASH_ALL:\n>\n>   Y = Hash_TapSighash( 0, 0xc1, version, locktime, [outputs], 0,\n>                        amount, sequence)\n>\n> and calculate a signature sig = Schnorr(P,m) for some pubkey P, and\n> make your script be \"<sig> <P> CHECKSIG\".\n>\n> That loses the ability to commit to the number of inputs or restrict\n> the nsequence of other inputs, and requires a bigger script (sig and P\n> are ~96 bytes instead of X's 32 bytes), but is otherwise pretty much the\n> same as far as I can tell. Both scripts are automatically satisfied when\n> revealed (with the correct set of outputs), and don't need any additional\n> witness data.\n>\n> If you wanted to construct \"X\" via script instead of hardcoding a value\n> because it got you generalised covenants or whatever; I think you could\n> get the same effect with CAT,LEFT, and RIGHT: you'd construct Y in much\n> the same way you construct X, but you'd then need to turn that into a\n> signature. You could do so by using pubkey P=G and nonce R=G, which\n> means you need to calculate s=1+hash(G,G,Y)*1 -- calculating the hash\n> part is easy, multiplying it by 1 is easy, and to add 1 you can probably\n> do something along the lines of:\n>\n>     OP_DUP 4 OP_RIGHT 1 OP_ADD OP_SWAP 28 OP_LEFT OP_SWAP OP_CAT\n>\n> (ie, take the last 4 bytes, increment it using 4-byte arithmetic,\n> then cat the first 28 bytes and the result. There's overflow issues,\n> but I think they can be worked around either by allowing you to choose\n> different locktimes, or by more complicated script)\n>\n> Cheers,\n> aj\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190622/df90c3c4/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-23T13:11:03",
                "message_text_only": "Good morning Jeremy,\n\nWhile `OP_SECURETHEBAG` commits to the desired output script of the spending TX, what is being referred to here is the ability to verify the output script being spent, i.e. the script that actually contains the `OP_SECURETHEBAG`.\nBy this, we are able to create a contract that ensures that it is paid again (covenants), which in combination with a little more introspection of TX data, allows us to verify the execution of steps of a Turing-complete program.\n\nIt is surprisingly easy to make a language inadvertently Turing-complete, which is basically the argument here,\nThat is, with just a little more power and some additional operations that would appear reasonable to add by themselves (`OP_CAT`, `OP_LEFT`, `OP_TWEAKPUBKEY`) on top of some form of requiring a particular output script, it is possible to validate the execution of Turing-complete programs on the Bitcoin blockchain.\n\nThus, with quining (a script which gets the text of its own code as part of the static data it has), `OP_TWEAKPUBKEY`, and a `OP_SECURETHEBAG` that gets its argument from the stack, it will be possible to make Turing-complete Bitcoin SCRIPT.\n\nI would mildly suggest that we might very well want to consider creating a well-designed way of injecting Turing-completeness into Bitcoin SCRIPT (requiring it to be behind a Taproot, so that bugs in Turing-complete code at least have a chance to be bugfixed by agreement of the Taproot signing set) since we might eventually find ourselves introducing it inadvertently later in any case.\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Sunday, June 23, 2019 6:41 AM, Jeremy Rubin <jeremy.l.rubin at gmail.com> wrote:\n\n> Can you clarify this comment?\n>\n> We do in fact commit to the script and scriptsig itself (not the witness stack) in OP_SECURETHEBAG (unless I'm missing what you meant)?\n>\n> On Thu, Jun 20, 2019, 10:59 AM Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > Just to be clear, while OP_CHECKTXDIGESTVERIFY would enable this style of covenants if it pulled data from the stack, the OP_SECURETHEBAG probably cannot create covenants even if it were to pull the data from the stack unless some OP_TWEEKPUBKEY operation is added to Script because the \"commitment of the script itself\" isn't part of the OP_SECURETHEBAG.\n> >\n> > So with regards to OP_SECURETHEBAG, I am also \"not really seeing any reason to complicate the spec to ensure the digest is precommitted as part of the opcode.\"\n> >\n> > On Thu, Jun 6, 2019 at 3:33 AM ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> > > Good morning aj,\n> > >\n> > > Sent with ProtonMail Secure Email.\n> > >\n> > > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> > > On Wednesday, June 5, 2019 5:30 PM, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > >\n> > > > On Fri, May 31, 2019 at 10:35:45PM -0700, Jeremy via bitcoin-dev wrote:\n> > > >\n> > > > > OP_CHECKOUTPUTSHASHVERIFY is retracted in favor of OP_SECURETHEBAG*.\n> > > >\n> > > > I think you could generalise that slightly and make it fit in\n> > > > with the existing opcode naming by calling it something like\n> > > > \"OP_CHECKTXDIGESTVERIFY\" and pull a 33-byte value from the stack,\n> > > > consisting of a sha256 hash and a sighash-byte, and adding a new sighash\n> > > > value corresponding to the set of info you want to include in the hash,\n> > > > which I think sounds a bit like \"SIGHASH_EXACTLY_ONE_INPUT | SIGHASH_ALL\"\n> > > >\n> > > > FWIW, I'm not really seeing any reason to complicate the spec to ensure\n> > > > the digest is precommitted as part of the opcode.\n> > > >\n> > >\n> > > I believe in combination with `OP_LEFT` and `OP_CAT` this allows Turing-complete smart contracts, in much the same way as `OP_CHECKSIGFROMSTACK`?\n> > >\n> > > Pass in the spent transaction (serialised for txid) and the spending transaction (serialised for sighash) as part of the witness of the spending transaction.\n> > >\n> > > Script verifies that the spending transaction witness value is indeed the spending transaction by `OP_SHA256 <SIGHASH_ALL> OP_SWAP OP_CAT OP_CHECKTXDIGESTVERIFY`.\n> > > Script verifies the spent transaction witness value is indeed the spent transaction by hashing it, then splitting up the hash with `OP_LEFT` into bytes, and comparing the bytes to the bytes in the input of the spending transaction witness value (txid being the bytes in reversed order).\n> > >\n> > > Then the Script can extract a commitment of itself by extracting the output of the spent transaction.\n> > > This lets the Script check that the spending transaction also pays to the same script.\n> > >\n> > > The Script can then access a state value, for example from an `OP_RETURN` output of the spent transaction, and enforce that a correct next-state is used in the spending transaction.\n> > > If the state is too large to fit in a standard `OP_RETURN`, then the current state can be passed in as a witness and validated against a hash commitment in an `OP_RETURN` output.\n> > >\n> > > I believe this is the primary reason against not pulling data from the stack.\n> > >\n> > > Regards,\n> > > ZmnSCPxj\n> > > _______________________________________________\n> > > bitcoin-dev mailing list\n> > > bitcoin-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-06-24T14:34:54",
                "message_text_only": "OP_SECURETHEBAG doesn't include the script being executed (i.e the\nscriptPubKey specified in the output that is redeemed by this input) in its\nhash like ordinary signatures do\n<https://github.com/bitcoin/bitcoin/blob/master/src/script/interpreter.cpp#L1271>.\nOf course, this ScriptPubKey is indirectly committed to through the input's\nprevoutpoint.  However Script isn't able to reconstruct this script being\nexecuted from the prevoutpoint in tapscript without an implementation of\npublic key tweeking in Bitcoin Script.\n\nOn Sun, Jun 23, 2019 at 2:41 AM Jeremy Rubin <jeremy.l.rubin at gmail.com>\nwrote:\n\n> Can you clarify this comment?\n>\n> We do in fact commit to the script and scriptsig itself (not the witness\n> stack) in OP_SECURETHEBAG (unless I'm missing what you meant)?\n>\n> On Thu, Jun 20, 2019, 10:59 AM Russell O'Connor via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Just to be clear, while OP_CHECKTXDIGESTVERIFY would enable this style\n>> of covenants if it pulled data from the stack, the OP_SECURETHEBAG\n>> probably cannot create covenants even if it were to pull the data from the\n>> stack unless some OP_TWEEKPUBKEY operation is added to Script because the\n>> \"commitment of the script itself\" isn't part of the OP_SECURETHEBAG.\n>>\n>> So with regards to OP_SECURETHEBAG, I am also \"not really seeing any\n>> reason to complicate the spec to ensure the digest is precommitted as part\n>> of the opcode.\"\n>>\n>> On Thu, Jun 6, 2019 at 3:33 AM ZmnSCPxj via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Good morning aj,\n>>>\n>>>\n>>> Sent with ProtonMail Secure Email.\n>>>\n>>> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>>> On Wednesday, June 5, 2019 5:30 PM, Anthony Towns via bitcoin-dev <\n>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>> > On Fri, May 31, 2019 at 10:35:45PM -0700, Jeremy via bitcoin-dev wrote:\n>>> >\n>>> > > OP_CHECKOUTPUTSHASHVERIFY is retracted in favor of OP_SECURETHEBAG*.\n>>> >\n>>> > I think you could generalise that slightly and make it fit in\n>>> > with the existing opcode naming by calling it something like\n>>> > \"OP_CHECKTXDIGESTVERIFY\" and pull a 33-byte value from the stack,\n>>> > consisting of a sha256 hash and a sighash-byte, and adding a new\n>>> sighash\n>>> > value corresponding to the set of info you want to include in the hash,\n>>> > which I think sounds a bit like \"SIGHASH_EXACTLY_ONE_INPUT |\n>>> SIGHASH_ALL\"\n>>> >\n>>> > FWIW, I'm not really seeing any reason to complicate the spec to ensure\n>>> > the digest is precommitted as part of the opcode.\n>>> >\n>>>\n>>> I believe in combination with `OP_LEFT` and `OP_CAT` this allows\n>>> Turing-complete smart contracts, in much the same way as\n>>> `OP_CHECKSIGFROMSTACK`?\n>>>\n>>> Pass in the spent transaction (serialised for txid) and the spending\n>>> transaction (serialised for sighash) as part of the witness of the spending\n>>> transaction.\n>>>\n>>> Script verifies that the spending transaction witness value is indeed\n>>> the spending transaction by `OP_SHA256 <SIGHASH_ALL> OP_SWAP OP_CAT\n>>> OP_CHECKTXDIGESTVERIFY`.\n>>> Script verifies the spent transaction witness value is indeed the spent\n>>> transaction by hashing it, then splitting up the hash with `OP_LEFT` into\n>>> bytes, and comparing the bytes to the bytes in the input of the spending\n>>> transaction witness value (txid being the bytes in reversed order).\n>>>\n>>> Then the Script can extract a commitment of itself by extracting the\n>>> output of the spent transaction.\n>>> This lets the Script check that the spending transaction also pays to\n>>> the same script.\n>>>\n>>> The Script can then access a state value, for example from an\n>>> `OP_RETURN` output of the spent transaction, and enforce that a correct\n>>> next-state is used in the spending transaction.\n>>> If the state is too large to fit in a standard `OP_RETURN`, then the\n>>> current state can be passed in as a witness and validated against a hash\n>>> commitment in an `OP_RETURN` output.\n>>>\n>>> I believe this is the primary reason against not pulling data from the\n>>> stack.\n>>>\n>>> Regards,\n>>> ZmnSCPxj\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190624/f738daa1/attachment-0001.html>"
            },
            {
                "author": "Jeremy",
                "date": "2019-06-24T18:07:20",
                "message_text_only": "Do you think the following hypothesis is more or less true:\n\nH: There is no set of pure extensions* to script E such that enabling E and\nOP_SECURETHEBAG as proposed enables recursive covenants, but E alone does\nnot enable recursive covenants?\n\n* Of course there are things that specifically are specifically designed to\nswitch on if OP_SECURETHEBAG, so pure means normal things like OP_CAT that\nare a function of the arguments on the stack or hashed txn data.\n\nThis is the main draw of the design I proposed, it should be highly\nimprobable or impossible to accidentally introduce more behavior than\nintended with a new opcode.\n\nI think that given that H is not true for the stack reading version of the\nopcode, we should avoid doing it unless strongly motivated, so as to permit\nmore flexibility for which opcodes we can add in the future without\nintroducing recursion unless it is explicitly intended.\n\n\n\nOn Mon, Jun 24, 2019, 7:35 AM Russell O'Connor <roconnor at blockstream.io>\nwrote:\n\n> OP_SECURETHEBAG doesn't include the script being executed (i.e the\n> scriptPubKey specified in the output that is redeemed by this input) in its\n> hash like ordinary signatures do\n> <https://github.com/bitcoin/bitcoin/blob/master/src/script/interpreter.cpp#L1271>.\n> Of course, this ScriptPubKey is indirectly committed to through the input's\n> prevoutpoint.  However Script isn't able to reconstruct this script being\n> executed from the prevoutpoint in tapscript without an implementation of\n> public key tweeking in Bitcoin Script.\n>\n> On Sun, Jun 23, 2019 at 2:41 AM Jeremy Rubin <jeremy.l.rubin at gmail.com>\n> wrote:\n>\n>> Can you clarify this comment?\n>>\n>> We do in fact commit to the script and scriptsig itself (not the witness\n>> stack) in OP_SECURETHEBAG (unless I'm missing what you meant)?\n>>\n>> On Thu, Jun 20, 2019, 10:59 AM Russell O'Connor via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Just to be clear, while OP_CHECKTXDIGESTVERIFY would enable this style\n>>> of covenants if it pulled data from the stack, the OP_SECURETHEBAG\n>>> probably cannot create covenants even if it were to pull the data from the\n>>> stack unless some OP_TWEEKPUBKEY operation is added to Script because the\n>>> \"commitment of the script itself\" isn't part of the OP_SECURETHEBAG.\n>>>\n>>> So with regards to OP_SECURETHEBAG, I am also \"not really seeing any\n>>> reason to complicate the spec to ensure the digest is precommitted as part\n>>> of the opcode.\"\n>>>\n>>> On Thu, Jun 6, 2019 at 3:33 AM ZmnSCPxj via bitcoin-dev <\n>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>>> Good morning aj,\n>>>>\n>>>>\n>>>> Sent with ProtonMail Secure Email.\n>>>>\n>>>> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>>>> On Wednesday, June 5, 2019 5:30 PM, Anthony Towns via bitcoin-dev <\n>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>>\n>>>> > On Fri, May 31, 2019 at 10:35:45PM -0700, Jeremy via bitcoin-dev\n>>>> wrote:\n>>>> >\n>>>> > > OP_CHECKOUTPUTSHASHVERIFY is retracted in favor of OP_SECURETHEBAG*.\n>>>> >\n>>>> > I think you could generalise that slightly and make it fit in\n>>>> > with the existing opcode naming by calling it something like\n>>>> > \"OP_CHECKTXDIGESTVERIFY\" and pull a 33-byte value from the stack,\n>>>> > consisting of a sha256 hash and a sighash-byte, and adding a new\n>>>> sighash\n>>>> > value corresponding to the set of info you want to include in the\n>>>> hash,\n>>>> > which I think sounds a bit like \"SIGHASH_EXACTLY_ONE_INPUT |\n>>>> SIGHASH_ALL\"\n>>>> >\n>>>> > FWIW, I'm not really seeing any reason to complicate the spec to\n>>>> ensure\n>>>> > the digest is precommitted as part of the opcode.\n>>>> >\n>>>>\n>>>> I believe in combination with `OP_LEFT` and `OP_CAT` this allows\n>>>> Turing-complete smart contracts, in much the same way as\n>>>> `OP_CHECKSIGFROMSTACK`?\n>>>>\n>>>> Pass in the spent transaction (serialised for txid) and the spending\n>>>> transaction (serialised for sighash) as part of the witness of the spending\n>>>> transaction.\n>>>>\n>>>> Script verifies that the spending transaction witness value is indeed\n>>>> the spending transaction by `OP_SHA256 <SIGHASH_ALL> OP_SWAP OP_CAT\n>>>> OP_CHECKTXDIGESTVERIFY`.\n>>>> Script verifies the spent transaction witness value is indeed the spent\n>>>> transaction by hashing it, then splitting up the hash with `OP_LEFT` into\n>>>> bytes, and comparing the bytes to the bytes in the input of the spending\n>>>> transaction witness value (txid being the bytes in reversed order).\n>>>>\n>>>> Then the Script can extract a commitment of itself by extracting the\n>>>> output of the spent transaction.\n>>>> This lets the Script check that the spending transaction also pays to\n>>>> the same script.\n>>>>\n>>>> The Script can then access a state value, for example from an\n>>>> `OP_RETURN` output of the spent transaction, and enforce that a correct\n>>>> next-state is used in the spending transaction.\n>>>> If the state is too large to fit in a standard `OP_RETURN`, then the\n>>>> current state can be passed in as a witness and validated against a hash\n>>>> commitment in an `OP_RETURN` output.\n>>>>\n>>>> I believe this is the primary reason against not pulling data from the\n>>>> stack.\n>>>>\n>>>> Regards,\n>>>> ZmnSCPxj\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190624/1973d003/attachment-0001.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-06-24T18:48:51",
                "message_text_only": "I suspect that your conjecture is true.  And given that it is plausible\nthat we would want to add an opcode to tweak public keys, it seems like a\nreason design to avoid accidental covenants.\n(That said, I strongly prefer that the SECURETHEBAG data be the 32-bytes\nimmediately following the opcode rather than a OP_PUSHDATA, and I'd be\nwilling to help code this up (see below)).\n\nOn Mon, Jun 24, 2019 at 2:07 PM Jeremy <jlrubin at mit.edu> wrote:\n\n> Do you think the following hypothesis is more or less true:\n>\n> H: There is no set of pure extensions* to script E such that enabling E\n> and OP_SECURETHEBAG as proposed enables recursive covenants, but E alone\n> does not enable recursive covenants?\n>\n> * Of course there are things that specifically are specifically designed\n> to switch on if OP_SECURETHEBAG, so pure means normal things like OP_CAT\n> that are a function of the arguments on the stack or hashed txn data.\n>\n> This is the main draw of the design I proposed, it should be highly\n> improbable or impossible to accidentally introduce more behavior than\n> intended with a new opcode.\n>\n> I think that given that H is not true for the stack reading version of the\n> opcode, we should avoid doing it unless strongly motivated, so as to permit\n> more flexibility for which opcodes we can add in the future without\n> introducing recursion unless it is explicitly intended.\n>\n\nOn Sat, Jun 1, 2019 at 12:47 PM Jeremy via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> A particularly useful topic of discussion is how best to eliminate the\n> PUSHDATA and treat OP_SECURETHEBAG like a pushdata directly. I thought\n> about how the interpreter works and is implemented and couldn't come up\n> with something noninvasive.\n>\n\nWe shouldn't be using the complexity of the changes to the Bitcoin Core a\nmeasure of the complexity of a proposal.  That is looking the issue from\nthe wrong side.  If we measure the complexity of Script proposals by how\nhard it is to change Bitcoin Core, what will happen is more and more of the\nincidental details of Bitcoin Core's implementation will be pulled into the\nsemantics of Script (e.g. the fact that surrounding opcode values are\nreadily available in Bitcoin Core's particular implementation of its Script\ninterpreter).  Instead we should use the complexity of how hard it is to\nreason about the new Script semantics.\n\nThe peeking semantics of OP_SECURETHEBAG is particularly awful because it\nmore-or-less breaks the fact that Bitcoin Script can be decomposed into\nindividual units of \"opcodes\" whose semantics and be individually\ndescribed, and it harms the composability of Bitcoin Script where you can\ndivide the script between any opcodes and the semantics of the\nconcatenation of those two scripts is simply the composition of the\nsemantics of the two halves.  (For those interested in formal semantics,\nwhat we have here is a monoid homomorphism from list of opcodes (syntax) to\nstack transformation functions (with side-effects) under (Kleisli)\ncomposition (semantics).) Being able to decompose a Bitcoin Script this way\nand reasoning about components is how one would reason about Bitcoin Script\nin practice.  (Technically the structure is more involved than a list of\nopcodes due to OP_IF, and instead you get a railroad diagram\n<https://en.wikipedia.org/wiki/Syntax_diagram>).\n\nPutting the 32 bytes of data required by OP_SECURETHEBAG immediately after\nthe opcode, like how OP_PUSHDATA* works, is a superior design choice.  It\nlets us treat the opcodes and its immediate data as an atomic unit when\nreasoning about Script and removes the need to define what happens when\nOP_SECURETHEBAG is not followed by an OP_PUSDATA.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190624/9d04f319/attachment-0001.html>"
            },
            {
                "author": "Jeremy",
                "date": "2019-06-24T22:47:44",
                "message_text_only": "I agree in principal, but I think that's just a bit of 'how things are'\nversus how they should be.\n\nI disagree that we get composability semantics because of OP_IF. E.g., the\nscript \"OP_IF .... \" and \"OP_END\" are two scripts that separately are\ninvalid as parsed, but together are valid. OP_IF already imposes some\nlookahead functionality... but as I understand it, it may be feasible to\nget rid of OP_IF for tapscripts anyways. Also in this bucket are P2SH and\nsegwit, which I think breaks this because the concat of two p2sh scripts or\nsegwit scripts is not the same as them severally.\n\nI also think that the OP_SECURETHEBAG use of pushdata is a backwards\ncompatible hack: we can always later redefine the parser to parse\nOP_SECURETHEBAG as the 34 byte opcode, recapturing the purity of the\nsemantics. We can also fix it to not use an extra byte in a future tapleaf\nversion.\n\n====\n\nIn any case, I don't disagree with figuring out what patching the parser to\nhandle multibyte opcodes would look like. If that sort of upgrade-path were\nreadily available when I wrote this, it's how I would have done it. There\nare two approaches I looked at mostly:\n\n1) Adding flags to GetOp to change how it parses\n  a) Most of the same code paths used for new and old script\n  b) Higher risk of breaking something in old script style/downstream\n  c) Cleans up only one issue (multibyte opcodes) leaves other warts in\nplace\n  d) less bikesheddable design (mostly same as old script)\n  e) code not increased in size\n2) Adding a completely new interpreter for Tapscript\n  a) Fork the existing interpreter code\n  b) For all places where scripts are run, switch based on if it is\ntapscript or not\n  c) Can clean up various semantics, can even do fancier things like\nhuffman encode opcodes to less than a byte\n  d) Can clearly separate parsing the script from executing it\n  e) Can improve versioning techniques\n  f) Low risk of breaking something in old script style/downstream\n  g) Increases amount of code substantially\n  h) Bikesheddable design (everything is on the table).\n  i) probably a better general mechanism for future changes to script\nparsing, less consensus risk\n  j) More compatible with templated script as well.\n\nIf not clear, I think that 2 is probably a better approach, but I'm worried\nthat 2.h means this would take a much longer time to implement.\n\n2 can be segmented into two components:\n\n1) the architecture of script parser versioning\n2) the actual new script version\n\nI think that component 1 can be relatively non controversial, thankfully,\nusing tapleaf versions (the architecture question is more around code\nstructure). A proof of concept of this would be to have a fork that uses\ntwo independent, but identical, script parsers.\n\nPart two of this plan would be to modify one of the versions substantially.\nI'm not sure what exists on the laundry list, but I think it would be\npossible to pick a few worthwhile cleanups. E.g.:\n\n1) Multibyte opcodes\n2) Templated scripts\n3) Huffman Encoding opcodes\n4) OP_IF handling (maybe just get rid of it in favor of conditional Verify\nsemantics)\n\nAnd make it clear that because we can add future script versions fairly\neasily, this is a sufficient step.\n\n\nDoes that seem in line with your understanding of how this might be done?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190624/86f6c9df/attachment-0001.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-06-25T17:05:39",
                "message_text_only": "Bitcoin Core is somewhat outside my core competence, but the various\nOP_PUSHDATA are already multi-byte opcodes and GetOp already has a data\nreturn parameter that is suitable for returning the payload of an immediate\n32-byte data variant of OP_SECURETHEBAG.  All that I expect is needed is to\nensure that nowhere else is using a non-empty data-field as a proxy for a\nnon-empty push operation and fixing any such occurrences if they exist.\n(AFAIKT there are only a handful of calls to GetOp).\n\nIt is probably worth updating the tapscript implementation to better\nprepare it for new uses of OP_SUCCESSx.  Parsing should halt when an\nOP_SUCCESSx is encountered, by having GetScriptOp advance the pc to end\nafter encountering such a code (decoding Script is no longer meaningful\nafter an OP_SUCCESS is encountered).  However, that means that GetScriptOp\nneeds to know what version of script it is expected to be parsing.  This\ncould be done by sending down some versioning flags, possibly by adding a\nversioning field to CScript that can be initialized @\nhttps://github.com/sipa/bitcoin/blob/7ddc7027b2cbdd11416809400c588e585a8b44ed/src/script/interpreter.cpp#L1679\nor some other mechanism (and at the same time perhaps having GetSigOpCount\nreturn 0 for tapscript, since counting sigops is not really meaningful in\ntapscript). There are probably other reasonable approaches too (e.g your\noption 2 below).  I could write some code to illustrate what I'm thinking\nif you feel that would be helpful and I do think such changes around\nOP_SUCCESS should be implemented regardless of whether we move forward with\nOP_SECURETHEBAG or not.\n\nIt is probably worth doing this properly the first time around if we are\ngoing to do it at all.\n\nP.S. OP_RESERVED1 has been renamed to OP_SUCCESS137 in bip-tapscript.\n\n\n>\n> On Mon, Jun 24, 2019 at 6:47 PM Jeremy <jlrubin at mit.edu> wrote:\n\n> I agree in principal, but I think that's just a bit of 'how things are'\n> versus how they should be.\n>\n> I disagree that we get composability semantics because of OP_IF. E.g., the\n> script \"OP_IF .... \" and \"OP_END\" are two scripts that separately are\n> invalid as parsed, but together are valid. OP_IF already imposes some\n> lookahead functionality... but as I understand it, it may be feasible to\n> get rid of OP_IF for tapscripts anyways. Also in this bucket are P2SH and\n> segwit, which I think breaks this because the concat of two p2sh scripts or\n> segwit scripts is not the same as them severally.\n>\n> I also think that the OP_SECURETHEBAG use of pushdata is a backwards\n> compatible hack: we can always later redefine the parser to parse\n> OP_SECURETHEBAG as the 34 byte opcode, recapturing the purity of the\n> semantics. We can also fix it to not use an extra byte in a future tapleaf\n> version.\n>\n\n> In any case, I don't disagree with figuring out what patching the parser\n> to handle multibyte opcodes would look like. If that sort of upgrade-path\n> were readily available when I wrote this, it's how I would have done it.\n> There are two approaches I looked at mostly:\n>\n> 1) Adding flags to GetOp to change how it parses\n>   a) Most of the same code paths used for new and old script\n>   b) Higher risk of breaking something in old script style/downstream\n>   c) Cleans up only one issue (multibyte opcodes) leaves other warts in\n> place\n>   d) less bikesheddable design (mostly same as old script)\n>   e) code not increased in size\n> 2) Adding a completely new interpreter for Tapscript\n>   a) Fork the existing interpreter code\n>   b) For all places where scripts are run, switch based on if it is\n> tapscript or not\n>   c) Can clean up various semantics, can even do fancier things like\n> huffman encode opcodes to less than a byte\n>   d) Can clearly separate parsing the script from executing it\n>   e) Can improve versioning techniques\n>   f) Low risk of breaking something in old script style/downstream\n>   g) Increases amount of code substantially\n>   h) Bikesheddable design (everything is on the table).\n>   i) probably a better general mechanism for future changes to script\n> parsing, less consensus risk\n>   j) More compatible with templated script as well.\n>\n> If not clear, I think that 2 is probably a better approach, but I'm\n> worried that 2.h means this would take a much longer time to implement.\n>\n> 2 can be segmented into two components:\n>\n> 1) the architecture of script parser versioning\n> 2) the actual new script version\n>\n> I think that component 1 can be relatively non controversial, thankfully,\n> using tapleaf versions (the architecture question is more around code\n> structure). A proof of concept of this would be to have a fork that uses\n> two independent, but identical, script parsers.\n>\n> Part two of this plan would be to modify one of the versions\n> substantially. I'm not sure what exists on the laundry list, but I think it\n> would be possible to pick a few worthwhile cleanups. E.g.:\n>\n> 1) Multibyte opcodes\n> 2) Templated scripts\n> 3) Huffman Encoding opcodes\n> 4) OP_IF handling (maybe just get rid of it in favor of conditional Verify\n> semantics)\n>\n> And make it clear that because we can add future script versions fairly\n> easily, this is a sufficient step.\n>\n>\n> Does that seem in line with your understanding of how this might be done?\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190625/870a1cdd/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "OP_SECURETHEBAG (supersedes OP_CHECKOUTPUTSVERIFY)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Anthony Towns",
                "Jeremy",
                "Russell O'Connor"
            ],
            "messages_count": 15,
            "total_messages_chars_count": 51449
        }
    },
    {
        "title": "[bitcoin-dev] [PROPOSAL] Emergency RBF (BIP 125)",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2019-06-02T04:41:39",
                "message_text_only": "Hi all,\n\n        I want to propose a modification to rules 3, 4 and 5 of BIP 125:\n\nTo remind you of BIP 125:\n 3. The replacement transaction pays an absolute fee of at least the sum\n    paid by the original transactions.\n\n 4. The replacement transaction must also pay for its own bandwidth at\n    or above the rate set by the node's minimum relay fee setting.\n\n 5. The number of original transactions to be replaced and their\n    descendant transactions which will be evicted from the mempool must not\n    exceed a total of 100 transactions.\n\nThe new \"emergency RBF\" rule:\n\n 6. If the original transaction was not in the first 4,000,000 weight\n    units of the fee-ordered mempool and the replacement transaction is,\n    rules 3, 4 and 5 do not apply.\n\nThis means:\n\n1. RBF can be used in adversarial conditions, such as lightning\n   unilateral closes where the adversary has another valid transaction\n   and can use it to block yours.  This is a problem when we allow\n   differential fees between the two current lightning transactions\n   (aka \"Bring Your Own Fees\").\n\n2. RBF can be used without knowing about miner's mempools, or that the\n   above problem is occurring.  One simply gets close to the required\n   maximum height for lightning timeout, and bids to get into the next\n   block.\n\n3. This proposal does not open any significant new ability to RBF spam,\n   since it can (usually) only be used once.  IIUC bitcoind won't\n   accept more that 100 descendents of an unconfirmed tx anyway.\n\n4. This proposal makes RBF miner-incentive compatible.  Currently the\n   protocol tells miners they shouldn't accept the highest bidding tx\n   for the good of the network.  This conflict is particularly sharp\n   in the case where the replacement tx would be immediately minable,\n   which this proposal addresses.\n\nUnfortunately I haven't found time to code this up in bitcoin, but if\nthere's positive response I can try.\n\nThanks for reading!\nRusty."
            },
            {
                "author": "rhavar at protonmail.com",
                "date": "2019-06-03T01:49:15",
                "message_text_only": "+1\n\n>From an incentive-compatible point of view, miners should be accepting transactions that increase the amount of fees that can achieved with 4M weight of transactions, so it seems like a pretty sane plan.\n\nOne common problem I've run into with RBF is since you're using RBF you probably want to low ball fees. With good coin selection (*cough* coinsayer.com *cough*), it'll use that opportunity to consolidate inputs. But now let's say fees suddenly spike (pretty common), you might want to fee bump your now stuck transaction. But now that fees are high, it doesn't make sense to be consolidating so ideally you'd just replace it with a much smaller transaction (that pays higher fee rate).\n\n\nSo if anything, I think your proposal doesn't go far enough. I think even in \"non-emergency\" cases, we could get away with removing the requirement to increase the absolute fee (as long as the fee rate is increased); which also makes it incentive compatible if you assume a reasonable fee-market.\n\nI realize it does open potential DoS vectors, but they seem reasonably small.\n\n\n\n\n\n\n\n-Ryan\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Saturday, June 1, 2019 9:41 PM, Rusty Russell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi all,\n>\n> I want to propose a modification to rules 3, 4 and 5 of BIP 125:\n>\n> To remind you of BIP 125:\n> 3. The replacement transaction pays an absolute fee of at least the sum\n> paid by the original transactions.\n>\n> 4. The replacement transaction must also pay for its own bandwidth at\n> or above the rate set by the node's minimum relay fee setting.\n>\n> 5. The number of original transactions to be replaced and their\n> descendant transactions which will be evicted from the mempool must not\n> exceed a total of 100 transactions.\n>\n> The new \"emergency RBF\" rule:\n>\n> 6. If the original transaction was not in the first 4,000,000 weight\n> units of the fee-ordered mempool and the replacement transaction is,\n> rules 3, 4 and 5 do not apply.\n>\n> This means:\n>\n> 1.  RBF can be used in adversarial conditions, such as lightning\n>     unilateral closes where the adversary has another valid transaction\n>     and can use it to block yours. This is a problem when we allow\n>     differential fees between the two current lightning transactions\n>     (aka \"Bring Your Own Fees\").\n>\n> 2.  RBF can be used without knowing about miner's mempools, or that the\n>     above problem is occurring. One simply gets close to the required\n>     maximum height for lightning timeout, and bids to get into the next\n>     block.\n>\n> 3.  This proposal does not open any significant new ability to RBF spam,\n>     since it can (usually) only be used once. IIUC bitcoind won't\n>     accept more that 100 descendents of an unconfirmed tx anyway.\n>\n> 4.  This proposal makes RBF miner-incentive compatible. Currently the\n>     protocol tells miners they shouldn't accept the highest bidding tx\n>     for the good of the network. This conflict is particularly sharp\n>     in the case where the replacement tx would be immediately minable,\n>     which this proposal addresses.\n>\n>     Unfortunately I haven't found time to code this up in bitcoin, but if\n>     there's positive response I can try.\n>\n>     Thanks for reading!\n>     Rusty.\n>\n>\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Matt Corallo",
                "date": "2019-06-03T09:48:31",
                "message_text_only": "I think this needs significantly improved motivation/description. A few areas I'd like to see calculated out:\n\n1) wrt rule 3, for this to be obviously-incentive-compatible-for-the-next-miner, I'd think no evicted transactions would be allowed to be in the next block range. This would probably require some significant additional tracking in today's mempool logic.\n\n2) wrt rule 4, I'd like to see a calculation of worst-case free relay. I think we're already not in a great place, but maybe it's worth it or maybe there is some other way to reduce this cost (intuitively it looks like this proposal could make things very, very, very bad).\n\n3) wrt rule 5, I'd like to see benchmarks, it's probably a pretty nasty DoS attack, but it may also be the case that is (a) not worse than other fundamental issues or (b) sufficiently expensive.\n\n4) As I've indicated before, I'm generaly not a fan of such vague protections for time-critical transactions such as payment channel punishment transactions. At a high-level, in this context your counterparty's transactions (not to mention every other transaction in everyone's mempool) are still involved in the decision about whether to accept an RBF, in contrast to previous proposals, which makes it much harder to reason about. As a specific example, if an attacker exploits mempool policy differences they may cause your concept of \"top 4M weight\" to be bogus for a subeset of nodes, causing propogation to be limited.\n\nObviously there is also a ton more client-side knowledge required and complexity to RBF decisions here than other previous, more narrowly-targeted proposals.\n\n(I don't think this one use-case being not optimal should prevent such a proposal, i agree it's quite nice for some other cases).\n\nMatt\n\n> On Jun 2, 2019, at 06:41, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> \n> Hi all,\n> \n>       I want to propose a modification to rules 3, 4 and 5 of BIP 125:\n> \n> To remind you of BIP 125:\n> 3. The replacement transaction pays an absolute fee of at least the sum\n>   paid by the original transactions.\n> \n> 4. The replacement transaction must also pay for its own bandwidth at\n>   or above the rate set by the node's minimum relay fee setting.\n> \n> 5. The number of original transactions to be replaced and their\n>   descendant transactions which will be evicted from the mempool must not\n>   exceed a total of 100 transactions.\n> \n> The new \"emergency RBF\" rule:\n> \n> 6. If the original transaction was not in the first 4,000,000 weight\n>   units of the fee-ordered mempool and the replacement transaction is,\n>   rules 3, 4 and 5 do not apply.\n> \n> This means:\n> \n> 1. RBF can be used in adversarial conditions, such as lightning\n>  unilateral closes where the adversary has another valid transaction\n>  and can use it to block yours.  This is a problem when we allow\n>  differential fees between the two current lightning transactions\n>  (aka \"Bring Your Own Fees\").\n> \n> 2. RBF can be used without knowing about miner's mempools, or that the\n>  above problem is occurring.  One simply gets close to the required\n>  maximum height for lightning timeout, and bids to get into the next\n>  block.\n> \n> 3. This proposal does not open any significant new ability to RBF spam,\n>  since it can (usually) only be used once.  IIUC bitcoind won't\n>  accept more that 100 descendents of an unconfirmed tx anyway.\n> \n> 4. This proposal makes RBF miner-incentive compatible.  Currently the\n>  protocol tells miners they shouldn't accept the highest bidding tx\n>  for the good of the network.  This conflict is particularly sharp\n>  in the case where the replacement tx would be immediately minable,\n>  which this proposal addresses.\n> \n> Unfortunately I haven't found time to code this up in bitcoin, but if\n> there's positive response I can try.\n> \n> Thanks for reading!\n> Rusty."
            },
            {
                "author": "Rusty Russell",
                "date": "2019-06-06T05:16:54",
                "message_text_only": "Matt Corallo <lf-lists at mattcorallo.com> writes:\n> I think this needs significantly improved motivation/description. A few areas I'd like to see calculated out:\n>\n> 1) wrt rule 3, for this to be obviously-incentive-compatible-for-the-next-miner, I'd think no evicted transactions would be allowed to be in the next block range. This would probably require some significant additional tracking in today's mempool logic.\n\nThis is a good question, which is why I really wanted to look into the\nimplementation details.  There are some approximations possible wrt. pre-\nand post- tx bundle feerate, but they have to be examined closely.\n\n> 2) wrt rule 4, I'd like to see a calculation of worst-case free relay. I think we're already not in a great place, but maybe it's worth it or maybe there is some other way to reduce this cost (intuitively it looks like this proposal could make things very, very, very bad).\n\nI *think* you can currently create a tx at 1 sat/byte, have it\npropagate, then RBF it to 2 sat/byte, 3... and do that a few thousand\ntimes before your transaction gets mined.\n\nIf that's true, I don't think this proposal makes it worse.\n\n>> 3) wrt rule 5, I'd like to see benchmarks, it's probably a pretty nasty DoS attack, but it may also be the case that is (a) not worse than other fundamental issues or (b) sufficiently expensive.\n\nI thought we still meet rule 5 in practice since bitcoind will never\neven accept a tree of unconfirmed txs which is > 100 txs?  That would\nstill stand, it's just that we'd still consider a replacement.\n\n> 4) As I've indicated before, I'm generaly not a fan of such vague\n> protections for time-critical transactions such as payment channel\n> punishment transactions.\n\nThe bitcoin network offers no propagation guarantees; it's all best\neffort anyway.  This makes it no worse, and we can tunnel txs through\nthe lightning network if we have to.\n\n> At a high-level, in this context your counterparty's transactions (not to mention every other transaction in everyone's mempool) are still involved in the decision about whether to accept an RBF, in contrast to previous proposals, which makes it much harder to reason about. As a specific example, if an attacker exploits mempool policy differences they may cause your concept of \"top 4M weight\" to be bogus for a subeset of nodes, causing propogation to be limited.\n\nIf miners have a conflicting tx in the top 4MSipa, you don't have a\nproblem.  So an attacker needs to limit propagation in a way which\nisolates the miners from either the new tx or the conflicting one, which\nis much harder.\n\n> Obviously there is also a ton more client-side knowledge required and complexity to RBF decisions here than other previous, more narrowly-targeted proposals.\n\nDefine client-side here?\n\nI'd say from the lightning side it's as simple as a normal RBF policy\nuntil you get within a few blocks of a deadline, then you increase the\nfees until it's well within reach of the next block.  You can even\napproximate this by looking at fees on the previous block, with some\ncare for outliers.\n\n> (I don't think this one use-case being not optimal should prevent such a proposal, i agree it's quite nice for some other cases).\n\nI like that it's conceptually simple and inventive-robust, and doesn't\nreally rely on bitcoind's internal policy mechanics of RBF.\n\nI think in the longer term we're going to need other mechanisms for\nrestricting abusive propagation anyway, but that's a bit out-of-scope.\n\nThanks!\nRusty."
            },
            {
                "author": "David A. Harding",
                "date": "2019-06-09T14:07:36",
                "message_text_only": "On Thu, Jun 06, 2019 at 02:46:54PM +0930, Rusty Russell via bitcoin-dev wrote:\n> Matt Corallo <lf-lists at mattcorallo.com> writes:\n> > 2) wrt rule 4, I'd like to see a calculation of worst-case free\n> > relay. I think we're already not in a great place, but maybe it's\n> > worth it or maybe there is some other way to reduce this cost\n> > (intuitively it looks like this proposal could make things very,\n> > very, very bad).\n> \n> I *think* you can currently create a tx at 1 sat/byte, have it\n> propagate, then RBF it to 2 sat/byte, 3... and do that a few thousand\n> times before your transaction gets mined.\n\nYes, the current incremental relay fee in Bitcoin Core is 0.00001000\nBTC/KvB.\n\n> If that's true, I don't think this proposal makes it worse.\n\nHere's a scenario that I think shows it being at least 20x worse.\n\nLet's imagine that you create two transactions:\n\n  tx0: A very small transaction (~100 vbytes) that's just 1-in, 1-out.\n       At the minimum relay fee, this costs 0.00000100 BTC\n\n  tx1: A child of that transaction that's very large (~100,000 vbytes,\n       or almost 400,000 bytes using special scripts that allow witness\n       stuffing).  At the minimum relay fee, this costs 0.00100000 BTC\n\nUnder the current rules, if an attacker wants to fee-bump tx0 by the\nminimum incremental fee (a trivial amount, ~0.00000100 BTC), the\nattacker's replacement also needs to pay for the eviction of the huge\nchild tx1 by that same incremental fee (~0.00100000).\n\nThus the replacement would cost the attacker a minimum of about\n0.00100100 (~1 mBTC) for the original transactions and 0.00100100 for\nthe replacement (about 2 mBTC total).\n\nThe attacker could then spend another 1 mBTC re-attaching the child and\nyet another 1 mBTC bumping again, incuring about a 2 mBTC cost per\nreplacement round.  At writing, 2 mBTC is about $14.00 USD---an amount\nthat's probably enough to deter most attacks at scale.\n\n* * *\n\nUnder the new proposed rule 6, Mallory's replacement cost would be the\namount to get the small tx0 to near the top of the mempool (say\n0.00100000 BTC/KvB, so 0.00010000 BTC total).  Because this would evict\nthe expensive child, it would actually reduce the original amount paid\nby the attacker by 90% compared to the previous section's example where\nusing RBF increased the original costs by 100%.\n\nThe 0.1 mBTC cost of this attack is about $0.70 USD today for the\nroughly the same data relay use as one round of the currently possible\nattack.  In short, if I haven't misplaced a decimal point or made some\nother mistake, I think the proposed rule 6 would result in approximately\na 95% reduction in the cost paid by an attacker for wasting 400,000\nbytes of bandwidth per node (x60,000 nodes = 24 GB across all nodes, not\ncounting INV overhead).\n\nAlthough the attacker might only get one replacement per block per\ntransaction pair out of this version of the attack, they could execute\nthe attack many times in parallel using different tranaction pairs.  If\nthis is combined with the treadmill leapfrogging Russell O'Connor\ndescribed elsewhere in this thread, the attack could possibly be\nrepeated multiple times per block per transaction pair at only slightly\nincreased cost (to pay the increasing next-block transaction fees).\n\n> >> 3) wrt rule 5, I'd like to see benchmarks, it's probably a pretty\n> >> nasty DoS attack, but it may also be the case that is (a) not worse\n> >> than other fundamental issues or (b) sufficiently expensive.\n> \n> I thought we still meet rule 5 in practice since bitcoind will never\n> even accept a tree of unconfirmed txs which is > 100 txs?  That would\n> still stand, it's just that we'd still consider a replacement.\n\nAlthough the BIP125 limit is 100, Bitcoin Core's current default is 25.[1]\n(When RBF was implemented in Bitcoin Core, transaction ancestry was only\ntracked for purposes of ensuring valid transaction ordering within\nblocks; later when CPFP was implemented, ancestry was additionally used\nto calculate each transaction's package fee---the value of it and all\nits unconfirmed ancestors.  This requires more computation to update\nthe mempool metadata when the ancestry graph changes.)\n\nAgain, I'd be thinking here of something similar to O'Connor's\ntreadmilling attack where replacements can push each other out of the\ntop mempool and so create enough churn for a CPU exhaustion attack.\n\n> >>  Obviously there is also a ton more client-side knowledge required\n> >>  and complexity to RBF decisions here than other previous, more\n> >>  narrowly-targeted proposals.\n> I'd say from the lightning side it's as simple as a normal RBF policy\n> until you get within a few blocks of a deadline, then you increase the\n> fees until it's well within reach of the next block.\n\nIt's already hard for wallet software to determine whether or not its\ntransactions have successfully been relayed.  This proposal requires LN\nwallets not only be able to guess where the next-block feerate boundary\nis in other nodes' individual mempools (now and in the future for the\ntime it takes the transaction to propagate to ~100% of miners), but it\npossibly requires that under the condition that the LN wallet can't\nguess too low because it might not get another chance for relay in the\nlimited time available before contract expiration.\n\nOn top of that, there's O'Connor's suggestion to increase treadmilling\ncosts by only allowing bumps if they're in the top-half of the\nnext-block mempool.\n\nConsidered that way, I worry that these constraints produce a recipe for\npaying extremely high feerates.  If that's an actual risk, is that\nactually significantly better than dealing with the existing transaction\npinning issue where one needs to pay a high total fee in order to evict\na bunch of junk descendents?  Paying lots of fees may not be the optimal\nsolution to the problem of having to pay lots of fees.  :-)\n\n-Dave\n\n[1] Excerpt from bitcoind -help-debug :\n\n  -limitancestorcount=<n>\n       Do not accept transactions if number of in-mempool ancestors is <n> or\n       more (default: 25)\n\n  -limitdescendantcount=<n>\n       Do not accept transactions if any ancestor would have <n> or more\n       in-mempool descendants (default: 25)"
            },
            {
                "author": "rhavar at protonmail.com",
                "date": "2019-06-10T16:34:33",
                "message_text_only": "What about this? We store a RBU (\"relay bandwidth used\") with each transaction in the mempool. Where RBU is defined as the size of the transaction + RBU of all transactions it has evicted.\n\nFor a replacement to be valid: The feerate must be higher than what it's evicting, and the fee must be greater than minRelayFee*RBU.\n\n\n\n\n-Ryan\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Sunday, June 9, 2019 7:07 AM, David A. Harding via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Thu, Jun 06, 2019 at 02:46:54PM +0930, Rusty Russell via bitcoin-dev wrote:\n>\n> > Matt Corallo lf-lists at mattcorallo.com writes:\n> >\n> > > 2.  wrt rule 4, I'd like to see a calculation of worst-case free\n> > >     relay. I think we're already not in a great place, but maybe it's\n> > >     worth it or maybe there is some other way to reduce this cost\n> > >     (intuitively it looks like this proposal could make things very,\n> > >     very, very bad).\n> > >\n> >\n> > I think you can currently create a tx at 1 sat/byte, have it\n> > propagate, then RBF it to 2 sat/byte, 3... and do that a few thousand\n> > times before your transaction gets mined.\n>\n> Yes, the current incremental relay fee in Bitcoin Core is 0.00001000\n> BTC/KvB.\n>\n> > If that's true, I don't think this proposal makes it worse.\n>\n> Here's a scenario that I think shows it being at least 20x worse.\n>\n> Let's imagine that you create two transactions:\n>\n> tx0: A very small transaction (~100 vbytes) that's just 1-in, 1-out.\n> At the minimum relay fee, this costs 0.00000100 BTC\n>\n> tx1: A child of that transaction that's very large (~100,000 vbytes,\n> or almost 400,000 bytes using special scripts that allow witness\n> stuffing). At the minimum relay fee, this costs 0.00100000 BTC\n>\n> Under the current rules, if an attacker wants to fee-bump tx0 by the\n> minimum incremental fee (a trivial amount, ~0.00000100 BTC), the\n> attacker's replacement also needs to pay for the eviction of the huge\n> child tx1 by that same incremental fee (~0.00100000).\n>\n> Thus the replacement would cost the attacker a minimum of about\n> 0.00100100 (~1 mBTC) for the original transactions and 0.00100100 for\n> the replacement (about 2 mBTC total).\n>\n> The attacker could then spend another 1 mBTC re-attaching the child and\n> yet another 1 mBTC bumping again, incuring about a 2 mBTC cost per\n> replacement round. At writing, 2 mBTC is about $14.00 USD---an amount\n> that's probably enough to deter most attacks at scale.\n>\n> Under the new proposed rule 6, Mallory's replacement cost would be the\n> amount to get the small tx0 to near the top of the mempool (say\n> 0.00100000 BTC/KvB, so 0.00010000 BTC total). Because this would evict\n> the expensive child, it would actually reduce the original amount paid\n> by the attacker by 90% compared to the previous section's example where\n> using RBF increased the original costs by 100%.\n>\n> The 0.1 mBTC cost of this attack is about $0.70 USD today for the\n> roughly the same data relay use as one round of the currently possible\n> attack. In short, if I haven't misplaced a decimal point or made some\n> other mistake, I think the proposed rule 6 would result in approximately\n> a 95% reduction in the cost paid by an attacker for wasting 400,000\n> bytes of bandwidth per node (x60,000 nodes = 24 GB across all nodes, not\n> counting INV overhead).\n>\n> Although the attacker might only get one replacement per block per\n> transaction pair out of this version of the attack, they could execute\n> the attack many times in parallel using different tranaction pairs. If\n> this is combined with the treadmill leapfrogging Russell O'Connor\n> described elsewhere in this thread, the attack could possibly be\n> repeated multiple times per block per transaction pair at only slightly\n> increased cost (to pay the increasing next-block transaction fees).\n>\n> > > > 3.  wrt rule 5, I'd like to see benchmarks, it's probably a pretty\n> > > >     nasty DoS attack, but it may also be the case that is (a) not worse\n> > > >     than other fundamental issues or (b) sufficiently expensive.\n> > > >\n> >\n> > I thought we still meet rule 5 in practice since bitcoind will never\n> > even accept a tree of unconfirmed txs which is > 100 txs? That would\n> > still stand, it's just that we'd still consider a replacement.\n>\n> Although the BIP125 limit is 100, Bitcoin Core's current default is 25.[1]\n> (When RBF was implemented in Bitcoin Core, transaction ancestry was only\n> tracked for purposes of ensuring valid transaction ordering within\n> blocks; later when CPFP was implemented, ancestry was additionally used\n> to calculate each transaction's package fee---the value of it and all\n> its unconfirmed ancestors. This requires more computation to update\n> the mempool metadata when the ancestry graph changes.)\n>\n> Again, I'd be thinking here of something similar to O'Connor's\n> treadmilling attack where replacements can push each other out of the\n> top mempool and so create enough churn for a CPU exhaustion attack.\n>\n> > > > Obviously there is also a ton more client-side knowledge required\n> > > > and complexity to RBF decisions here than other previous, more\n> > > > narrowly-targeted proposals.\n> > > > I'd say from the lightning side it's as simple as a normal RBF policy\n> > > > until you get within a few blocks of a deadline, then you increase the\n> > > > fees until it's well within reach of the next block.\n>\n> It's already hard for wallet software to determine whether or not its\n> transactions have successfully been relayed. This proposal requires LN\n> wallets not only be able to guess where the next-block feerate boundary\n> is in other nodes' individual mempools (now and in the future for the\n> time it takes the transaction to propagate to ~100% of miners), but it\n> possibly requires that under the condition that the LN wallet can't\n> guess too low because it might not get another chance for relay in the\n> limited time available before contract expiration.\n>\n> On top of that, there's O'Connor's suggestion to increase treadmilling\n> costs by only allowing bumps if they're in the top-half of the\n> next-block mempool.\n>\n> Considered that way, I worry that these constraints produce a recipe for\n> paying extremely high feerates. If that's an actual risk, is that\n> actually significantly better than dealing with the existing transaction\n> pinning issue where one needs to pay a high total fee in order to evict\n> a bunch of junk descendents? Paying lots of fees may not be the optimal\n> solution to the problem of having to pay lots of fees. :-)\n>\n> -Dave\n>\n> [1] Excerpt from bitcoind -help-debug :\n>\n> -limitancestorcount=<n>\n>\n>        Do not accept transactions if number of in-mempool ancestors is <n> or\n>\n>        more (default: 25)\n>\n>\n> -limitdescendantcount=<n>\n>\n>        Do not accept transactions if any ancestor would have <n> or more\n>\n>        in-mempool descendants (default: 25)\n>\n>\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-06-14T05:50:17",
                "message_text_only": "\"David A. Harding\" <dave at dtrt.org> writes:\n> On Thu, Jun 06, 2019 at 02:46:54PM +0930, Rusty Russell via bitcoin-dev wrote:\n>> If that's true, I don't think this proposal makes it worse.\n>\n> Here's a scenario that I think shows it being at least 20x worse.\n\n[ Snip ]\n\nIndeed :(\n\nTo be fair, if I have a transaction of median size (250 bytes) and I use\nthe current estimatefee 2 of '0.00068325' I get to replace is 68 times;\nthat's $0 for an additional 1GB across all nodes.\n\nSo, I don't think the current rules are sufficient.  But I understand\nthe desire not to make things worse.  I'll roll in some changes and\nre-propose.\n\n> It's already hard for wallet software to determine whether or not its\n> transactions have successfully been relayed.\n\nAs the deadline approaches, a lightning wallet would RBF with increasing\ndesparation until it gets into a block.  It doesn't really matter *why*\nthe tx isn't going through, there's nothing else it can do.\n\n> This proposal requires LN\n> wallets not only be able to guess where the next-block feerate boundary\n> is in other nodes' individual mempools (now and in the future for the\n> time it takes the transaction to propagate to ~100% of miners), but it\n> possibly requires that under the condition that the LN wallet can't\n> guess too low because it might not get another chance for relay in the\n> limited time available before contract expiration.\n\nI think you mean any proposal which relies on a deadline?  If so, that\nbus has already left.\n\nWhen you see a block you can guess the fees required for the next block.\nYou need some smoothing to avoid wild spikes, but in practice you can\nstart this \"desperation mode\" 10 blocks before your deadline.\n\nWithout RBF changes, it needs to assume that it needs to replace a\n400kSipa tx @ feerate-for-next-block.  With some RBF change, it need\nonly replace @feerate-for-next-block.\n\n> Considered that way, I worry that these constraints produce a recipe for\n> paying extremely high feerates.  If that's an actual risk, is that\n> actually significantly better than dealing with the existing transaction\n> pinning issue where one needs to pay a high total fee in order to evict\n> a bunch of junk descendents?  Paying lots of fees may not be the optimal\n> solution to the problem of having to pay lots of fees.  :-)\n\nI don't understand this at all, sorry.\n\nCheers,\nRusty."
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-06-03T12:56:42",
                "message_text_only": "Hi Rusty,\n\nOn Sun, Jun 2, 2019 at 9:21 AM Rusty Russell via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> The new \"emergency RBF\" rule:\n>\n>  6. If the original transaction was not in the first 4,000,000 weight\n>     units of the fee-ordered mempool and the replacement transaction is,\n>     rules 3, 4 and 5 do not apply.\n>\n> This means:\n>\n> 3. This proposal does not open any significant new ability to RBF spam,\n>    since it can (usually) only be used once.  IIUC bitcoind won't\n>    accept more that 100 descendents of an unconfirmed tx anyway.\n>\n\nIs it not possible for Alice to grief Bob's node by alternating RBFing two\ntransactions, each one placing itself at the bottom of Bob's top 4,000,000\nweight mempool which pushes the other one below the top 4,000,000 weight,\nand then repeating with the other transaction?  It might be possible to\namend this proposal to partially mitigate this.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190603/66962193/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-06-06T03:08:50",
                "message_text_only": "\"Russell O'Connor\" <roconnor at blockstream.io> writes:\n> Hi Rusty,\n>\n> On Sun, Jun 2, 2019 at 9:21 AM Rusty Russell via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> The new \"emergency RBF\" rule:\n>>\n>>  6. If the original transaction was not in the first 4,000,000 weight\n>>     units of the fee-ordered mempool and the replacement transaction is,\n>>     rules 3, 4 and 5 do not apply.\n>>\n>> This means:\n>>\n>> 3. This proposal does not open any significant new ability to RBF spam,\n>>    since it can (usually) only be used once.  IIUC bitcoind won't\n>>    accept more that 100 descendents of an unconfirmed tx anyway.\n>>\n>\n> Is it not possible for Alice to grief Bob's node by alternating RBFing two\n> transactions, each one placing itself at the bottom of Bob's top 4,000,000\n> weight mempool which pushes the other one below the top 4,000,000 weight,\n> and then repeating with the other transaction?  It might be possible to\n> amend this proposal to partially mitigate this.\n\nGood point.  This will cost Alice approximately one tx every block, but\nthat may still be annoying.  My intuition says it's hard to play these\ngames across swathes of non-direct peers, since mempools are in constant\nflux and propagation is a bit random.\n\nWhat mitigations were you thinking?\n\nCheers,\nRusty."
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-06-09T04:21:19",
                "message_text_only": "On Sat, Jun 8, 2019 at 11:59 PM Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n> \"Russell O'Connor\" <roconnor at blockstream.io> writes:\n> > Hi Rusty,\n> >\n> > On Sun, Jun 2, 2019 at 9:21 AM Rusty Russell via bitcoin-dev <\n> > bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> >> The new \"emergency RBF\" rule:\n> >>\n> >>  6. If the original transaction was not in the first 4,000,000 weight\n> >>     units of the fee-ordered mempool and the replacement transaction is,\n> >>     rules 3, 4 and 5 do not apply.\n> >>\n> >> This means:\n> >>\n> >> 3. This proposal does not open any significant new ability to RBF spam,\n> >>    since it can (usually) only be used once.  IIUC bitcoind won't\n> >>    accept more that 100 descendents of an unconfirmed tx anyway.\n> >>\n> >\n> > Is it not possible for Alice to grief Bob's node by alternating RBFing\n> two\n> > transactions, each one placing itself at the bottom of Bob's top\n> 4,000,000\n> > weight mempool which pushes the other one below the top 4,000,000 weight,\n> > and then repeating with the other transaction?  It might be possible to\n> > amend this proposal to partially mitigate this.\n>\n> Good point.  This will cost Alice approximately one tx every block, but\n> that may still be annoying.  My intuition says it's hard to play these\n> games across swathes of non-direct peers, since mempools are in constant\n> flux and propagation is a bit random.\n>\n> What mitigations were you thinking?\n>\n\nFor example,  \"If the original transaction was not in the first 4,000,000\nweight units of the fee-ordered mempool and the replacement transaction is\nin the first 2,000,000 weight units....\" might adequately address the issue.\nThere are probably other ways as well.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190609/e1605c53/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Emergency RBF (BIP 125)",
            "categories": [
                "bitcoin-dev",
                "PROPOSAL"
            ],
            "authors": [
                "Rusty Russell",
                "David A. Harding",
                "rhavar at protonmail.com",
                "Russell O'Connor",
                "Matt Corallo"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 32536
        }
    },
    {
        "title": "[bitcoin-dev] Formalizing Blind Statechains as a minimalistic blind signing server",
        "thread_messages": [
            {
                "author": "Ruben Somsen",
                "date": "2019-06-04T11:28:26",
                "message_text_only": "Hi everyone,\n\nFor those who are unfamiliar, Statechains enable the transfer UTXOs\noff-chain with the help of a Statechain entity (trusted server(s))\nwithout giving them full custodial control over your coins [0]. At\nScaling Bitcoin \u201818 [1] I briefly mentioned utilizing blind signatures\n[2] to make the entity unaware of what it's signing. I now think this\nis the more interesting approach. The functionality can be described\nfairly elegantly as follows.\n\nBlind signing server with two functions users can call:\n\n// Start new signature chain\n(1) requestNewKey(userPubkey) => returns a new serverPubkey and\nregisters it to userPubkey\n\n// Extend existing chain\n(2) requestBlindSig(userSignature, blindedMessage, nextUserPubkey) =>\nreturns blindSignature, registers the serverPubkey to nextUserPubkey\n\nThe resulting output is a public ECC chain (one blindSignature per\nuser, one chain per serverPubkey) of blindly signed messages,\nrequested by users (1, 2, 3, etc.):\n\nuserSignature1(blindedMessage1, userPubkey2) => blindSignature1\nuserSignature2(blindedMessage2, userPubkey3) => blindSignature2\netc.\n\nAssuming the server is honest (more on this below), we can use it to\ntransfer over the signing rights of a private key without actually\nchanging the key itself.\n\nThe functionality is general and therefore suitable for more than just\nBitcoin, but let's walk through the primary envisioned use case where\nwe transfer the ownership of a Bitcoin UTXO off-chain. Note that the\nserver is kept completely unaware that it's handling a BTC\ntransaction, since it's signing blindly:\n\n- B uses function (1) with userPubkey = B to request serverPubkey A\n- B then generates transitory key X, and creates a single MuSig key AX\n(key X is called \u201ctransitory\u201d because its private key will later be passed on)\n- B prepares tx1: 1BTC to AX (he doesn't send it yet)\n- B creates tx2: an eltoo tx [3] that assigns the 1BTC back to B (off-chain)\n- B uses (2) with nextUserPubkey = B and blindedMessage = tx2\n- B sends tx1 to the blockchain and waits for it to confirm\n- B receives a key from C in order to prepare a payment\n- B creates tx3: an eltoo tx (with higher priority) with 1BTC to C (off-chain)\n- B uses (2) with nextUserPubkey = C and blindedMessage = tx3\n- B passes the private key of X (the transitory key) on to C\n- C takes blinded tx2 and tx3 from the public server output and\nunblinds them with X\n- C only accepts the payment if everything is in order [4]\n\nEven if the server goes offline, C can still get the money by sending\ntx3 to the blockchain.\n\nA and B can collude to take the money from C, but since all instances\nof userSignature and blindSignature are published openly, cheating is\npublicly detectable (e.g. the server signed two messages from B\ninstead of one).\n\nTrust can be distributed by turning the server into a multisig\nthreshold key, so serverPubkey A becomes e.g. 8-of-12 multisig. This\nmeans security can be on par with federated sidechains [5], and is\nsimilar to how ZmnSCPxj replaced the escrow key with a federation in\n\u201cSmart Contracts Unchained\u201d [6].\n\nLastly, by utilizing adaptor signatures [7], the userSignature can be\ntied to the blindSignature. In fact, this can be done for any number\nof signatures, allowing multiple signing sessions to take place\natomically [8]. This denies the server the ability to selectively\npublish one signature and not the other, allowing safe atomic swaps\nvia the server.\n\nEssentially, anything that requires UTXO ownership can be achieved\noff-chain via Blind Statechains. Coinjoin, Lightning channel\nopening/adjusting/closing, Discreet Log Contract style bets [9],\ncross-chain atomic swaps, etc. Since the blind signing server\nfunctionality is non-specific to Bitcoin, it'll be useful for\nnon-cryptocurrency related use cases as well, but I have not given\nthis a lot of thought.\n\nI also recently published a more high-level overview of Statechains\nhere, which may be of interest:\nhttps://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39\n\n-- Ruben Somsen\n\n\n\n[0] Statechains paper:\nhttps://github.com/RubenSomsen/rubensomsen.github.io/blob/master/img/statechains.pdf\n\n[1] Statechains Scaling Bitcoin \u201818: http://youtu.be/FI9cwksTrQs?t=47m36s\n    Transcript:\nhttp://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/statechains/\n\n[2] Blind signatures, Jonas Nick:\nhttp://diyhpl.us/wiki/transcripts/building-on-bitcoin/2018/blind-signatures-and-scriptless-scripts/\n\n[3] eltoo: https://blockstream.com/eltoo.pdf\n\n[4] Similar to client-side validation, Peter Todd:\nhttps://diyhpl.us/wiki/transcripts/scalingbitcoin/milan/client-side-validation/\n\n[5] Sidechains Appendix A, federated peg: https://blockstream.com/sidechains.pdf\n\n[6] Smart Contracts Unchained ,ZmnSCPxj:\nhttps://zmnscpxj.github.io/bitcoin/unchained.html\n\n[7] Adaptor signatures, Andrew Poelstra:\nhttp://diyhpl.us/wiki/transcripts/layer2-summit/2018/scriptless-scripts/\n\n[8] Adam Gibson (Waxwing) separately made a similar observation on his\nblog: https://joinmarket.me/blog/blog/multiparty-s6/\n\n[9] Discreet Log Contracts, Thaddeus Dryja: https://adiabat.github.io/dlc.pdf"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-06T00:09:28",
                "message_text_only": "Good morning Ruben,\n\n> At\n> Scaling Bitcoin \u201818 [1] I briefly mentioned utilizing blind signatures\n> [2] to make the entity unaware of what it's signing. I now think this\n> is the more interesting approach. The functionality can be described\n> fairly elegantly as follows.\n\nI agree.\nI had no interest in Statechains at all before, but now that you have blind signing servers, this is significantly more interesting.\n\n\n>\n> Blind signing server with two functions users can call:\n>\n> // Start new signature chain\n> (1) requestNewKey(userPubkey) => returns a new serverPubkey and\n> registers it to userPubkey\n>\n> // Extend existing chain\n> (2) requestBlindSig(userSignature, blindedMessage, nextUserPubkey) =>\n> returns blindSignature, registers the serverPubkey to nextUserPubkey\n>\n> The resulting output is a public ECC chain (one blindSignature per\n> user, one chain per serverPubkey) of blindly signed messages,\n> requested by users (1, 2, 3, etc.):\n>\n> userSignature1(blindedMessage1, userPubkey2) => blindSignature1\n> userSignature2(blindedMessage2, userPubkey3) => blindSignature2\n> etc.\n>\n> Assuming the server is honest (more on this below), we can use it to\n> transfer over the signing rights of a private key without actually\n> changing the key itself.\n>\n> The functionality is general and therefore suitable for more than just\n> Bitcoin, but let's walk through the primary envisioned use case where\n> we transfer the ownership of a Bitcoin UTXO off-chain. Note that the\n> server is kept completely unaware that it's handling a BTC\n> transaction, since it's signing blindly:\n>\n> -   B uses function (1) with userPubkey = B to request serverPubkey A\n> -   B then generates transitory key X, and creates a single MuSig key AX\n>     (key X is called \u201ctransitory\u201d because its private key will later be passed on)\n>\n> -   B prepares tx1: 1BTC to AX (he doesn't send it yet)\n> -   B creates tx2: an eltoo tx [3] that assigns the 1BTC back to B (off-chain)\n\nOf note, is that a Decker-Russell-Osuntokun construction (\"eltoo\") is not *strictly* required.\nWe can still make use of the Decker-Wattenhofer construction instead.\n\nThe core of Decker-Wattenhofer is a sequence of decrementing-`nSequence` update systems.\nNumber of maximum updates is limited by the starting `nSequence`, however if we put an update system inside an update system, we can \"reset\" the `nSequence` of the inner update system by updating the outer update system.\nWe can chain this concept further and add more update systems nested inside update systems to gain more leverage from the maximum relative wait time.\n\nAs we expect fewer updates are needed for statechains than e.g. actual Lightning channels (your given CoinSwap protocol is \"only\" two updates, for instance) this is usually a good tradeoff,\n\nIt is thus possible to use statechains in case `SIGHASH_ANYPREVOUT` is too controversial to get into Bitcoin, provided Schnorr (definitely uncontroversial) does get into Bitcoin.\n\n>     A and B can collude to take the money from C, but since all instances\n>     of userSignature and blindSignature are published openly, cheating is\n>     publicly detectable (e.g. the server signed two messages from B\n>     instead of one).\n\nThis still admits the possibility of an exit scam once a few \"big enough\" swaps are in position to be stolen, trading off earned reputation for cold-stored cash.\n\n>\n>     Trust can be distributed by turning the server into a multisig\n>     threshold key, so serverPubkey A becomes e.g. 8-of-12 multisig. This\n>     means security can be on par with federated sidechains [5], and is\n>     similar to how ZmnSCPxj replaced the escrow key with a federation in\n>     \u201cSmart Contracts Unchained\u201d [6].\n\nThis makes me happy.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Ruben Somsen",
                "date": "2019-06-06T05:20:31",
                "message_text_only": "Hi ZmnSCPxj,\n\nThank you for your comments.\n\n>Of note, is that a Decker-Russell-Osuntokun construction (\"eltoo\") is not *strictly* required. We can still make use of the Decker-Wattenhofer construction instead.\n\nYes, an early draft (from before the eltoo paper) was using that\nconstruction, but it seemed quite unwieldy. Timelocks have to be long,\nnesting adds more transactions, channels expire faster with more use,\nand tx fee handling is more complex. But you make a good point that if\nSIGHASH_ANYPREVOUT turns out to be too controversial (or for\nsupporting older altcoins), this would be a potential fallback.\n\n>This still admits the possibility of an exit scam once a few \"big enough\" swaps are in position to be stolen, trading off earned reputation for cold-stored cash.\n\nThat is correct. The worst case for security still comes down to\nhaving to trust the federation, but the transitory key, as well as the\nblind signature scheme, does add an interesting layer of separation\nthat makes it essentially \"non-custodial\". The article I linked has\nmore on this.\n\nCheers,\nRuben\n\nOn Thu, Jun 6, 2019 at 2:09 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> Good morning Ruben,\n>\n> > At\n> > Scaling Bitcoin \u201818 [1] I briefly mentioned utilizing blind signatures\n> > [2] to make the entity unaware of what it's signing. I now think this\n> > is the more interesting approach. The functionality can be described\n> > fairly elegantly as follows.\n>\n> I agree.\n> I had no interest in Statechains at all before, but now that you have blind signing servers, this is significantly more interesting.\n>\n>\n> >\n> > Blind signing server with two functions users can call:\n> >\n> > // Start new signature chain\n> > (1) requestNewKey(userPubkey) => returns a new serverPubkey and\n> > registers it to userPubkey\n> >\n> > // Extend existing chain\n> > (2) requestBlindSig(userSignature, blindedMessage, nextUserPubkey) =>\n> > returns blindSignature, registers the serverPubkey to nextUserPubkey\n> >\n> > The resulting output is a public ECC chain (one blindSignature per\n> > user, one chain per serverPubkey) of blindly signed messages,\n> > requested by users (1, 2, 3, etc.):\n> >\n> > userSignature1(blindedMessage1, userPubkey2) => blindSignature1\n> > userSignature2(blindedMessage2, userPubkey3) => blindSignature2\n> > etc.\n> >\n> > Assuming the server is honest (more on this below), we can use it to\n> > transfer over the signing rights of a private key without actually\n> > changing the key itself.\n> >\n> > The functionality is general and therefore suitable for more than just\n> > Bitcoin, but let's walk through the primary envisioned use case where\n> > we transfer the ownership of a Bitcoin UTXO off-chain. Note that the\n> > server is kept completely unaware that it's handling a BTC\n> > transaction, since it's signing blindly:\n> >\n> > -   B uses function (1) with userPubkey = B to request serverPubkey A\n> > -   B then generates transitory key X, and creates a single MuSig key AX\n> >     (key X is called \u201ctransitory\u201d because its private key will later be passed on)\n> >\n> > -   B prepares tx1: 1BTC to AX (he doesn't send it yet)\n> > -   B creates tx2: an eltoo tx [3] that assigns the 1BTC back to B (off-chain)\n>\n> Of note, is that a Decker-Russell-Osuntokun construction (\"eltoo\") is not *strictly* required.\n> We can still make use of the Decker-Wattenhofer construction instead.\n>\n> The core of Decker-Wattenhofer is a sequence of decrementing-`nSequence` update systems.\n> Number of maximum updates is limited by the starting `nSequence`, however if we put an update system inside an update system, we can \"reset\" the `nSequence` of the inner update system by updating the outer update system.\n> We can chain this concept further and add more update systems nested inside update systems to gain more leverage from the maximum relative wait time.\n>\n> As we expect fewer updates are needed for statechains than e.g. actual Lightning channels (your given CoinSwap protocol is \"only\" two updates, for instance) this is usually a good tradeoff,\n>\n> It is thus possible to use statechains in case `SIGHASH_ANYPREVOUT` is too controversial to get into Bitcoin, provided Schnorr (definitely uncontroversial) does get into Bitcoin.\n>\n> >     A and B can collude to take the money from C, but since all instances\n> >     of userSignature and blindSignature are published openly, cheating is\n> >     publicly detectable (e.g. the server signed two messages from B\n> >     instead of one).\n>\n> This still admits the possibility of an exit scam once a few \"big enough\" swaps are in position to be stolen, trading off earned reputation for cold-stored cash.\n>\n> >\n> >     Trust can be distributed by turning the server into a multisig\n> >     threshold key, so serverPubkey A becomes e.g. 8-of-12 multisig. This\n> >     means security can be on par with federated sidechains [5], and is\n> >     similar to how ZmnSCPxj replaced the escrow key with a federation in\n> >     \u201cSmart Contracts Unchained\u201d [6].\n>\n> This makes me happy.\n>\n> Regards,\n> ZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-06T06:31:45",
                "message_text_only": "Good morning Ruben,\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Thursday, June 6, 2019 1:20 PM, Ruben Somsen <rsomsen at gmail.com> wrote:\n\n> Hi ZmnSCPxj,\n>\n> Thank you for your comments.\n>\n> > Of note, is that a Decker-Russell-Osuntokun construction (\"eltoo\") is not strictly required. We can still make use of the Decker-Wattenhofer construction instead.\n>\n> Yes, an early draft (from before the eltoo paper) was using that\n> construction, but it seemed quite unwieldy. Timelocks have to be long,\n> nesting adds more transactions, channels expire faster with more use,\n> and tx fee handling is more complex. But you make a good point that if\n> SIGHASH_ANYPREVOUT turns out to be too controversial (or for\n> supporting older altcoins), this would be a potential fallback.\n\nThe lack of `SIGHASH_ANYPREVOUT` does make it difficult to operate a channel factory.\nFactory operations would still require the signatures of all participants, but once a participant has released its signature, it cannot be sure whether its channels should be rooted on the previous factory state or the next (i.e. the [Stale Factory problem](https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-April/001974.html) ).\nThis is fixable if we use `SIGHASH_ANYPREVOUT` on channel update transactions.\nAlternately without that flag we can run channels rooted on both the previous and next factory states, which actually is similar to what we need to do for splice-in (so we could reuse that code, possibly).\n\n>\n> > This still admits the possibility of an exit scam once a few \"big enough\" swaps are in position to be stolen, trading off earned reputation for cold-stored cash.\n>\n> That is correct. The worst case for security still comes down to\n> having to trust the federation, but the transitory key, as well as the\n> blind signature scheme, does add an interesting layer of separation\n> that makes it essentially \"non-custodial\". The article I linked has\n> more on this.\n\nOf note is that this is roughly the same as the common key in my own Smart Contracts Unchained.\n\nIf `SIGHASH_ANYPREVOUT` ends up requiring a chaperone signature, it seems this transitory/common key can be used for the chaperone.\n\nGoing further on Smart Contracts Unchained, I observe that the below:\n\n> // Start new signature chain\n> (1) requestNewKey(userPubkey) => returns a new serverPubkey and registers it to userPubkey\n> // Extend existing chain\n> (2) requestBlindSig(userSignature, blindedMessage, nextUserPubkey) => returns blindSignature, registers the serverPubkey to nextUserPubkey\n\nCan be generalized, such that instead of pubKeys and their signatures, we have validation programs and their witnesses.\n\nFor example, instead of userPubkey and nextUserPubkey we have a userScript and nextUserScript, with userSignature replaced by a userWitness.\n\nThis would be nearer to my own Smart Contracts Unchained, though without committing to the smart contract onchain, only offchain in the server.\n\n\n\n>\n> Cheers,\n> Ruben\n>\n> On Thu, Jun 6, 2019 at 2:09 AM ZmnSCPxj ZmnSCPxj at protonmail.com wrote:\n>\n> > Good morning Ruben,\n> >\n> > > At\n> > > Scaling Bitcoin \u201818 [1] I briefly mentioned utilizing blind signatures\n> > > [2] to make the entity unaware of what it's signing. I now think this\n> > > is the more interesting approach. The functionality can be described\n> > > fairly elegantly as follows.\n> >\n> > I agree.\n> > I had no interest in Statechains at all before, but now that you have blind signing servers, this is significantly more interesting.\n> >\n> > > Blind signing server with two functions users can call:\n> > > // Start new signature chain\n> > > (1) requestNewKey(userPubkey) => returns a new serverPubkey and\n> > > registers it to userPubkey\n> > > // Extend existing chain\n> > > (2) requestBlindSig(userSignature, blindedMessage, nextUserPubkey) =>\n> > > returns blindSignature, registers the serverPubkey to nextUserPubkey\n> > > The resulting output is a public ECC chain (one blindSignature per\n> > > user, one chain per serverPubkey) of blindly signed messages,\n> > > requested by users (1, 2, 3, etc.):\n> > > userSignature1(blindedMessage1, userPubkey2) => blindSignature1\n> > > userSignature2(blindedMessage2, userPubkey3) => blindSignature2\n> > > etc.\n> > > Assuming the server is honest (more on this below), we can use it to\n> > > transfer over the signing rights of a private key without actually\n> > > changing the key itself.\n> > > The functionality is general and therefore suitable for more than just\n> > > Bitcoin, but let's walk through the primary envisioned use case where\n> > > we transfer the ownership of a Bitcoin UTXO off-chain. Note that the\n> > > server is kept completely unaware that it's handling a BTC\n> > > transaction, since it's signing blindly:\n> > >\n> > > -   B uses function (1) with userPubkey = B to request serverPubkey A\n> > >\n> > > -   B then generates transitory key X, and creates a single MuSig key AX\n> > >     (key X is called \u201ctransitory\u201d because its private key will later be passed on)\n> > >\n> > > -   B prepares tx1: 1BTC to AX (he doesn't send it yet)\n> > >\n> > > -   B creates tx2: an eltoo tx [3] that assigns the 1BTC back to B (off-chain)\n> > >\n> >\n> > Of note, is that a Decker-Russell-Osuntokun construction (\"eltoo\") is not strictly required.\n> > We can still make use of the Decker-Wattenhofer construction instead.\n> > The core of Decker-Wattenhofer is a sequence of decrementing-`nSequence` update systems.\n> > Number of maximum updates is limited by the starting `nSequence`, however if we put an update system inside an update system, we can \"reset\" the `nSequence` of the inner update system by updating the outer update system.\n> > We can chain this concept further and add more update systems nested inside update systems to gain more leverage from the maximum relative wait time.\n> > As we expect fewer updates are needed for statechains than e.g. actual Lightning channels (your given CoinSwap protocol is \"only\" two updates, for instance) this is usually a good tradeoff,\n> > It is thus possible to use statechains in case `SIGHASH_ANYPREVOUT` is too controversial to get into Bitcoin, provided Schnorr (definitely uncontroversial) does get into Bitcoin.\n> >\n> > >     A and B can collude to take the money from C, but since all instances\n> > >     of userSignature and blindSignature are published openly, cheating is\n> > >     publicly detectable (e.g. the server signed two messages from B\n> > >     instead of one).\n> > >\n> >\n> > This still admits the possibility of an exit scam once a few \"big enough\" swaps are in position to be stolen, trading off earned reputation for cold-stored cash.\n> >\n> > >     Trust can be distributed by turning the server into a multisig\n> > >     threshold key, so serverPubkey A becomes e.g. 8-of-12 multisig. This\n> > >     means security can be on par with federated sidechains [5], and is\n> > >     similar to how ZmnSCPxj replaced the escrow key with a federation in\n> > >     \u201cSmart Contracts Unchained\u201d [6].\n> > >\n> >\n> > This makes me happy.\n> > Regards,\n> > ZmnSCPxj"
            },
            {
                "author": "Ruben Somsen",
                "date": "2019-06-12T21:26:01",
                "message_text_only": "Hi ZmnSCPxj,\n\n\nThanks for the reply. Sorry to keep you waiting, Coredev and Breaking\nBitcoin have been keeping me busy.\n\nTranscript from Coredev (thanks Bryan):\nhttp://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-statechains/\n\nBlind Statechains at Breaking Bitcoin:\nhttps://www.youtube.com/watch?v=DqhxPWsJFZE&t=4h59m4s\n\n\n>an early draft\n\nI meant an early draft of Statechains, sorry if that was confusing.\nBut yes, it's essentially no different from channel factories without\neltoo.\n\n\n>If `SIGHASH_ANYPREVOUT` ends up requiring a chaperone signature, it seems this transitory/common key can be used for the chaperone.\n\nThat is a good point. One thing I have not yet fully analysed are the\nprivacy considerations. Perhaps we don't want to reveal X on-chain.\n\n\n>This would be nearer to my own Smart Contracts Unchained\n\nAdding scripting is not my preferred approach. The beauty of the\nsystem is that the server doesn't evaluate any scripts whatsoever.\n\nThat being said, Smart Contracts Unchained (SCU) can be inserted quite\nelegantly as a separate smart contracting layer.\n\nThe observation is that anything that can be done with a UTXO\non-chain, can also be done off-chain via Statechains, including SCU.\n\nIf SCU is a single (N-of-N or (1-of-N + escrow)) key, you can simply\nuse this as the userKey (as well as inside the off-chain eltoo tx).\n\nIt's pretty interesting how smart contracting can be added like this.\nCool stuff, ZmnSCPxj. I'll definitely be thinking about this more.\n\n\nCheers,\nRuben\n\nOn Thu, Jun 6, 2019 at 8:32 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> Good morning Ruben,\n>\n>\n> Sent with ProtonMail Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Thursday, June 6, 2019 1:20 PM, Ruben Somsen <rsomsen at gmail.com> wrote:\n>\n> > Hi ZmnSCPxj,\n> >\n> > Thank you for your comments.\n> >\n> > > Of note, is that a Decker-Russell-Osuntokun construction (\"eltoo\") is not strictly required. We can still make use of the Decker-Wattenhofer construction instead.\n> >\n> > Yes, an early draft (from before the eltoo paper) was using that\n> > construction, but it seemed quite unwieldy. Timelocks have to be long,\n> > nesting adds more transactions, channels expire faster with more use,\n> > and tx fee handling is more complex. But you make a good point that if\n> > SIGHASH_ANYPREVOUT turns out to be too controversial (or for\n> > supporting older altcoins), this would be a potential fallback.\n>\n> The lack of `SIGHASH_ANYPREVOUT` does make it difficult to operate a channel factory.\n> Factory operations would still require the signatures of all participants, but once a participant has released its signature, it cannot be sure whether its channels should be rooted on the previous factory state or the next (i.e. the [Stale Factory problem](https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-April/001974.html) ).\n> This is fixable if we use `SIGHASH_ANYPREVOUT` on channel update transactions.\n> Alternately without that flag we can run channels rooted on both the previous and next factory states, which actually is similar to what we need to do for splice-in (so we could reuse that code, possibly).\n>\n> >\n> > > This still admits the possibility of an exit scam once a few \"big enough\" swaps are in position to be stolen, trading off earned reputation for cold-stored cash.\n> >\n> > That is correct. The worst case for security still comes down to\n> > having to trust the federation, but the transitory key, as well as the\n> > blind signature scheme, does add an interesting layer of separation\n> > that makes it essentially \"non-custodial\". The article I linked has\n> > more on this.\n>\n> Of note is that this is roughly the same as the common key in my own Smart Contracts Unchained.\n>\n> If `SIGHASH_ANYPREVOUT` ends up requiring a chaperone signature, it seems this transitory/common key can be used for the chaperone.\n>\n> Going further on Smart Contracts Unchained, I observe that the below:\n>\n> > // Start new signature chain\n> > (1) requestNewKey(userPubkey) => returns a new serverPubkey and registers it to userPubkey\n> > // Extend existing chain\n> > (2) requestBlindSig(userSignature, blindedMessage, nextUserPubkey) => returns blindSignature, registers the serverPubkey to nextUserPubkey\n>\n> Can be generalized, such that instead of pubKeys and their signatures, we have validation programs and their witnesses.\n>\n> For example, instead of userPubkey and nextUserPubkey we have a userScript and nextUserScript, with userSignature replaced by a userWitness.\n>\n> This would be nearer to my own Smart Contracts Unchained, though without committing to the smart contract onchain, only offchain in the server.\n>\n>\n>\n> >\n> > Cheers,\n> > Ruben\n> >\n> > On Thu, Jun 6, 2019 at 2:09 AM ZmnSCPxj ZmnSCPxj at protonmail.com wrote:\n> >\n> > > Good morning Ruben,\n> > >\n> > > > At\n> > > > Scaling Bitcoin \u201818 [1] I briefly mentioned utilizing blind signatures\n> > > > [2] to make the entity unaware of what it's signing. I now think this\n> > > > is the more interesting approach. The functionality can be described\n> > > > fairly elegantly as follows.\n> > >\n> > > I agree.\n> > > I had no interest in Statechains at all before, but now that you have blind signing servers, this is significantly more interesting.\n> > >\n> > > > Blind signing server with two functions users can call:\n> > > > // Start new signature chain\n> > > > (1) requestNewKey(userPubkey) => returns a new serverPubkey and\n> > > > registers it to userPubkey\n> > > > // Extend existing chain\n> > > > (2) requestBlindSig(userSignature, blindedMessage, nextUserPubkey) =>\n> > > > returns blindSignature, registers the serverPubkey to nextUserPubkey\n> > > > The resulting output is a public ECC chain (one blindSignature per\n> > > > user, one chain per serverPubkey) of blindly signed messages,\n> > > > requested by users (1, 2, 3, etc.):\n> > > > userSignature1(blindedMessage1, userPubkey2) => blindSignature1\n> > > > userSignature2(blindedMessage2, userPubkey3) => blindSignature2\n> > > > etc.\n> > > > Assuming the server is honest (more on this below), we can use it to\n> > > > transfer over the signing rights of a private key without actually\n> > > > changing the key itself.\n> > > > The functionality is general and therefore suitable for more than just\n> > > > Bitcoin, but let's walk through the primary envisioned use case where\n> > > > we transfer the ownership of a Bitcoin UTXO off-chain. Note that the\n> > > > server is kept completely unaware that it's handling a BTC\n> > > > transaction, since it's signing blindly:\n> > > >\n> > > > -   B uses function (1) with userPubkey = B to request serverPubkey A\n> > > >\n> > > > -   B then generates transitory key X, and creates a single MuSig key AX\n> > > >     (key X is called \u201ctransitory\u201d because its private key will later be passed on)\n> > > >\n> > > > -   B prepares tx1: 1BTC to AX (he doesn't send it yet)\n> > > >\n> > > > -   B creates tx2: an eltoo tx [3] that assigns the 1BTC back to B (off-chain)\n> > > >\n> > >\n> > > Of note, is that a Decker-Russell-Osuntokun construction (\"eltoo\") is not strictly required.\n> > > We can still make use of the Decker-Wattenhofer construction instead.\n> > > The core of Decker-Wattenhofer is a sequence of decrementing-`nSequence` update systems.\n> > > Number of maximum updates is limited by the starting `nSequence`, however if we put an update system inside an update system, we can \"reset\" the `nSequence` of the inner update system by updating the outer update system.\n> > > We can chain this concept further and add more update systems nested inside update systems to gain more leverage from the maximum relative wait time.\n> > > As we expect fewer updates are needed for statechains than e.g. actual Lightning channels (your given CoinSwap protocol is \"only\" two updates, for instance) this is usually a good tradeoff,\n> > > It is thus possible to use statechains in case `SIGHASH_ANYPREVOUT` is too controversial to get into Bitcoin, provided Schnorr (definitely uncontroversial) does get into Bitcoin.\n> > >\n> > > >     A and B can collude to take the money from C, but since all instances\n> > > >     of userSignature and blindSignature are published openly, cheating is\n> > > >     publicly detectable (e.g. the server signed two messages from B\n> > > >     instead of one).\n> > > >\n> > >\n> > > This still admits the possibility of an exit scam once a few \"big enough\" swaps are in position to be stolen, trading off earned reputation for cold-stored cash.\n> > >\n> > > >     Trust can be distributed by turning the server into a multisig\n> > > >     threshold key, so serverPubkey A becomes e.g. 8-of-12 multisig. This\n> > > >     means security can be on par with federated sidechains [5], and is\n> > > >     similar to how ZmnSCPxj replaced the escrow key with a federation in\n> > > >     \u201cSmart Contracts Unchained\u201d [6].\n> > > >\n> > >\n> > > This makes me happy.\n> > > Regards,\n> > > ZmnSCPxj\n>\n>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-13T01:22:38",
                "message_text_only": "Good morning Ruben,\n> > an early draft\n>\n> I meant an early draft of Statechains, sorry if that was confusing.\n> But yes, it's essentially no different from channel factories without\n> eltoo.\n\nSorry, I am referring to current issues with channel factories, which were not addressed in the original channel factories paper.\nBasically, the \"Stale Factory\" and \"Broken Factory\" problems.\nBroken factory seems unsolvable.\nStale factory is fixable if the channels within the factory use `SIGHASH_NOINPUT` (assuming it gets into Bitcoin) for all unilateral paths (use `SIGHASH_ALL` for cooperative paths).\n\n>\n> > If `SIGHASH_ANYPREVOUT` ends up requiring a chaperone signature, it seems this transitory/common key can be used for the chaperone.\n>\n> That is a good point. One thing I have not yet fully analysed are the\n> privacy considerations. Perhaps we don't want to reveal X on-chain.\n\nOn reflection, probably best not to.\nIt requires a script that reveals the pubkeys.\nAnd it now becomes possible for the server to monitor the blockchain for revelation of server pubkey in a spend path.\nThis will let the server know, after-the-fact, that it was signing blockchain transactions.\nThis might not let it preemptively censor or otherwise disrupt, but it *could* sell the private fact that a statechain was used.\nCombining it via MuSig is probably best, as the server is now unable to recognize even the pubkey (assuming it never is informed `X`).\n\n>\n> > This would be nearer to my own Smart Contracts Unchained\n>\n> Adding scripting is not my preferred approach. The beauty of the\n> system is that the server doesn't evaluate any scripts whatsoever.\n\nOn reflection, this is probably best.\nAs the server is blinded, it cannot determine anything about the message being signed.\n\nOn the other cognition sub-agent, however, a simple scripting that allows \"if somebody provides x of H(x) plus signature A, sign a blinded message M1, else if after 2:30PM PST on Jun 24 2019 if somebody provides signature of B, sign a blinded message M2\" could still potentially be useful, and might allow \"programmable escrow\" like I imagine Smart Contracts Unchained could allow.\n\n>\n> That being said, Smart Contracts Unchained (SCU) can be inserted quite\n> elegantly as a separate smart contracting layer.\n>\n> The observation is that anything that can be done with a UTXO\n> on-chain, can also be done off-chain via Statechains, including SCU.\n\nThe Real (TM) observation is that anything that can be done with a UTXO onchain, can also be done offchain via any updateable offchain cryptocurrency system, whether Statechains, Spillman, Decker-Wattenhofer, Poon-Dryja, or Decker-Russell-Osuntokun.\n(I should probably look up the authors of the Statechains paper to make my naming convention consistent)\n\nOne might observe that any updateable offchain cryptocurrency system worth its salt would have some way of unilaterally dropping transactions onchain.\nThose transactions would create new UTXOs that can be spent by further transactions.\nBy presenting those \"further transactions\" to the offchain system, we can provide an argument that the offchain system can just \"append\" those \"further transactions\" to the existing unilateral-case transactions, then cut-through the further transactions on its next update (i.e. delete the current UTXOs spent and insert the new UTXOs introduced by the \"further transactions\").\n(In the case of Statechains, you would present this argument to the signers of the latest `userPubKey`, not to the server, who is unaware of the semantics of what it is signing)\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Ruben Somsen",
                "date": "2019-06-14T07:18:27",
                "message_text_only": "Hi ZmnSCPxj,\n\n\n>Basically, the \"Stale Factory\" and \"Broken Factory\" problems.\n\nI see, I'll have to read up on those.\n\n\n>Combining it via MuSig is probably best, as the server is now unable to recognize even the pubkey (assuming it never is informed `X`).\n\nYes, that's the current thinking. See also:\nhttps://twitter.com/SomsenRuben/status/1138199578996555784 (sorry no\ntime to make a gist)\n\n\n>As the server is blinded, it cannot determine anything about the message being signed.\n\nYes, you could build a non-blind variant with scripting, but that\nwould be quite different.\n\n\n>a simple scripting that allows \"if somebody provides x of H(x) plus signature A, sign a blinded message M1, else if after 2:30PM PST on Jun 24 2019 if somebody provides signature of B, sign a blinded message M2\" could still potentially be useful\n\nI believe adaptor signatures are enough to replace hashing. A time\nlock could potentially be added with some very basic scripting, but my\nfeeling is still that this is better avoided. We're essentially\nrelying on the Bitcoin blockchain for that, because the off-chain\ntransactions can be encumbered by any script you like.\n\n\n>anything that can be done with a UTXO onchain, can also be done offchain via any updateable offchain cryptocurrency system\n\nYou're right that I didn't properly point to the key difference, which\nis transfer of UTXO ownership. Other off-chain systems don't allow you\nto go from e.g. 2-of-2 to 3-of-3, but of course we're adding a\nfederation in order to make this happen, so it's not exactly a fair\ncomparison.\n\n\n>(I should probably look up the authors of the Statechains paper to make my naming convention consistent)\n\nThat would be \"Somsen\". I am the sole author.\n\n\n>By presenting those \"further transactions\" to the offchain system, we can provide an argument that the offchain system can just \"append\" those \"further transactions\" to the existing unilateral-case transactions, then cut-through the further transactions on its next update\n\nThat's an interesting way of looking at it. This is currently achieved\nin Statechains by making the top-level on the Statechain N-of-N, so\nall participants of the \"further transactions\" have to agree in order\nto achieve full cut-through on the Statechain. In practice this would\nmean that the final signature requested from the server is a\n\"cooperative close\".\n\n\nCheers,\nRuben\n\n\nOn Thu, Jun 13, 2019 at 3:22 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> Good morning Ruben,\n> > > an early draft\n> >\n> > I meant an early draft of Statechains, sorry if that was confusing.\n> > But yes, it's essentially no different from channel factories without\n> > eltoo.\n>\n> Sorry, I am referring to current issues with channel factories, which were not addressed in the original channel factories paper.\n> Basically, the \"Stale Factory\" and \"Broken Factory\" problems.\n> Broken factory seems unsolvable.\n> Stale factory is fixable if the channels within the factory use `SIGHASH_NOINPUT` (assuming it gets into Bitcoin) for all unilateral paths (use `SIGHASH_ALL` for cooperative paths).\n>\n> >\n> > > If `SIGHASH_ANYPREVOUT` ends up requiring a chaperone signature, it seems this transitory/common key can be used for the chaperone.\n> >\n> > That is a good point. One thing I have not yet fully analysed are the\n> > privacy considerations. Perhaps we don't want to reveal X on-chain.\n>\n> On reflection, probably best not to.\n> It requires a script that reveals the pubkeys.\n> And it now becomes possible for the server to monitor the blockchain for revelation of server pubkey in a spend path.\n> This will let the server know, after-the-fact, that it was signing blockchain transactions.\n> This might not let it preemptively censor or otherwise disrupt, but it *could* sell the private fact that a statechain was used.\n> Combining it via MuSig is probably best, as the server is now unable to recognize even the pubkey (assuming it never is informed `X`).\n>\n> >\n> > > This would be nearer to my own Smart Contracts Unchained\n> >\n> > Adding scripting is not my preferred approach. The beauty of the\n> > system is that the server doesn't evaluate any scripts whatsoever.\n>\n> On reflection, this is probably best.\n> As the server is blinded, it cannot determine anything about the message being signed.\n>\n> On the other cognition sub-agent, however, a simple scripting that allows \"if somebody provides x of H(x) plus signature A, sign a blinded message M1, else if after 2:30PM PST on Jun 24 2019 if somebody provides signature of B, sign a blinded message M2\" could still potentially be useful, and might allow \"programmable escrow\" like I imagine Smart Contracts Unchained could allow.\n>\n> >\n> > That being said, Smart Contracts Unchained (SCU) can be inserted quite\n> > elegantly as a separate smart contracting layer.\n> >\n> > The observation is that anything that can be done with a UTXO\n> > on-chain, can also be done off-chain via Statechains, including SCU.\n>\n> The Real (TM) observation is that anything that can be done with a UTXO onchain, can also be done offchain via any updateable offchain cryptocurrency system, whether Statechains, Spillman, Decker-Wattenhofer, Poon-Dryja, or Decker-Russell-Osuntokun.\n> (I should probably look up the authors of the Statechains paper to make my naming convention consistent)\n>\n> One might observe that any updateable offchain cryptocurrency system worth its salt would have some way of unilaterally dropping transactions onchain.\n> Those transactions would create new UTXOs that can be spent by further transactions.\n> By presenting those \"further transactions\" to the offchain system, we can provide an argument that the offchain system can just \"append\" those \"further transactions\" to the existing unilateral-case transactions, then cut-through the further transactions on its next update (i.e. delete the current UTXOs spent and insert the new UTXOs introduced by the \"further transactions\").\n> (In the case of Statechains, you would present this argument to the signers of the latest `userPubKey`, not to the server, who is unaware of the semantics of what it is signing)\n>\n>\n> Regards,\n> ZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Formalizing Blind Statechains as a minimalistic blind signing server",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Ruben Somsen"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 39617
        }
    },
    {
        "title": "[bitcoin-dev] Fwd: [ots-dev] miniOTS: ots proofs that fit in a tweet",
        "thread_messages": [
            {
                "author": "Bryan Bishop",
                "date": "2019-06-05T14:24:29",
                "message_text_only": "---------- Forwarded message ---------\nFrom: William Casarin <jb55 at jb55.com>\nDate: Wed, Jun 5, 2019 at 9:13 AM\nSubject: [ots-dev] miniOTS: ots proofs that fit in a tweet\nTo: <ots-dev at lists.opentimestamps.org>\n\n\n\nHello OTS people,\n\nFollowing from my previous post about cleartext OTS proof sharing[1],\nI've been working on a new OTS format called miniOTS, which is\nminimal/compressed format that allows attestations to fit in a tweet[2]\nand for other space constrained contexts.\n\nJust stripping out additional attestations in the standard format only\ngets it down to just above ~280 bytes when base58 encoded, which is too\nmuch for a tweet, so I decided to roll a custom format that is a bit\nmore efficient with attestation and op tags.\n\nThe goal was to have small enoughs proofs that I could reply to a tweet\nwith the stamp of the previous message, instead of relying on external\nsites such as @otsproofbot\n\n\nCurrent format (210 bytes, 288 bytes base58-encoded):\n\n00000000: 004f 7065 6e54 696d 6573 7461 6d70 7300  .OpenTimestamps.\n00000010: 0050 726f 6f66 00bf 89e2 e884 e892 9401  .Proof..........\n00000020: 08cb 2d4a f572 8d44 a5b0 7c7b f1ff 78a9  ..-J.r.D..|{..x.\n00000030: 1818 7270 13f1 9bbd f4b0 344b 9e93 0c6b  ..rp......4K...k\n00000040: 39f0 1020 34fe cad9 edef bab0 3420 e4ee  9.. 4.......4 ..\n00000050: d3a7 c608 fff0 107c 31f7 da6c dbf2 3271  .......|1..l..2q\n00000060: 904c c5dd f58d eb08 f120 e4f7 3eaf a747  .L....... ..>..G\n00000070: 324a f096 1aa0 928d e1c1 91bf 3c38 237d  2J..........<8#}\n00000080: d412 c1c0 e94c d4ae 3f76 08f1 045c 4cb3  .....L..?v...\\L.\n00000090: a4f0 08f7 834d 4b14 68fd 41ff 0083 dfe3  .....MK.h.A.....\n000000a0: 0d2e f90c 8e2c 2b68 7474 7073 3a2f 2f62  .....,+https://b\n000000b0: 6f62 2e62 7463 2e63 616c 656e 6461 722e  ob.btc.calendar.\n000000c0: 6f70 656e 7469 6d65 7374 616d 7073 2e6f  opentimestamps.o\n000000d0: 7267                                     rg\n\nminiOTS format (133 bytes, 183 bytes base58-encoded):\n\n00000000: 6f74 7301 8a20 34fe cad9 edef bab0 3420  ots.. 4.......4\n00000010: e4ee d3a7 c683 8a7c 31f7 da6c dbf2 3271  .......|1..l..2q\n00000020: 904c c5dd f58d eb83 8be4 f73e afa7 4732  .L.........>..G2\n00000030: 4af0 961a a092 8de1 c191 bf3c 3823 7dd4  J..........<8#}.\n00000040: 12c1 c0e9 4cd4 ae3f 7683 8b5c 4cb3 a48a  ....L..?v..\\L...\n00000050: f783 4d4b 1468 fd41 9a2b 6874 7470 733a  ..MK.h.A.+https:\n00000060: 2f2f 626f 622e 6274 632e 6361 6c65 6e64  //bob.btc.calend\n00000070: 6172 2e6f 7065 6e74 696d 6573 7461 6d70  ar.opentimestamp\n00000080: 732e 6f72 67                             s.org\n\n\nbase58 before:\n\n12j6JNmon36jC1MMcpvC8nHqg5p8DAT2mmPQ5aLaBmAbk8naEVt8HFVohRqkuMXZF2Wo2n9kv\n5ByeL17yUww4NHuFyCT6PXsGxRuEZ12Z33gsLbXL5FuFmnvMLd3tzf76n69J7qxLPxmoAgm1z\n9NEMi2MRypDNKy1GypGN5NLwerzy1nU5g5dZxV6TZ5rBs4gYqnMNJn9VMkfKeDSZ9M8aoMWrL\nShokXUpnS1qrqkTvTwyKMx17fhKfcP9FyhNkb81t8dwYLtBsN4QuP9UAktMUvjEoBzHt\n\nbase58 after:\n\n6gQjQUehytgUevKLRtAFYbC6UJX72LCDgVWxAUPsCt3tqEVTEQfmUB1T1Y1GTyY8sugiPY97K\ngWRPPXYJmH3J5jqVtyNLrzdkySM6VAYDVckya9BxbUbFB8Gs4U3LHEauTmgCPEhGhiRdC3eFW\n63SwfAvKB8Q8Ku8ZM9uASCwWZ8K2AoVabuAn\n\n\nYou can check it out here:\n\n  git clone https://git.sr.ht/~jb55/ots-tool\n\nThis is still a work in progress, I haven't built the miniOTS -> OTS\ndecoder yet.\n\nmake\n./otsmini file.ots\n\n\nCheers,\nWill\n\n\n[1] id:878t1fzn0v.fsf at jb55.com\n[2] https://twitter.com/jb55/status/1136260220521336832\n\n\n-- \n- Bryan\nhttp://heybryan.org/\n1 512 203 0507\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190605/e02128e5/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Fwd: miniOTS: ots proofs that fit in a tweet",
            "categories": [
                "bitcoin-dev",
                "ots-dev"
            ],
            "authors": [
                "Bryan Bishop"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3596
        }
    },
    {
        "title": "[bitcoin-dev] Transcripts from coredev.tech Amsterdam 2019 meeting",
        "thread_messages": [
            {
                "author": "Bryan Bishop",
                "date": "2019-06-07T15:02:13",
                "message_text_only": "Hi,\n\nThe following are some notes from the coredev.tech Amsterdam 2019 meeting.\nAny mistakes are my probably my own.\n\nHere is a conversation about the code review process in Bitcoin Core:\nhttp://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-05-code-review/\n\nHere is a conversation with some of the maintainers about what problems\nthey are seeing:\nhttp://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-06-maintainers/\n\nWallet re-architecture discussion\nhttp://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-05-wallet-architecture/\n\nGreat consensus cleanup\nhttp://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-06-great-consensus-cleanup/\n\nSIGHASH_NOINPUT, OP_CHECKSIGFROMSTACK, OP_CHECKOUTPUTSHASHVERIFY,\nOP_SECURETHEBAG\nhttp://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-06-noinput-etc/\n\nTaproot discussion\nhttp://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-06-taproot/\n\nUtreexo\nhttp://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-06-utreexo/\n\nassumeutxo\nhttp://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-assumeutxo/\n\nHardware wallets and HWI\nhttp://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-hardware-wallets/\n\nbip151, p2p encryption and v2 message format\nhttp://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-p2p-encryption/\n\nSignet for bitcoin test networks\nhttp://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-signet/\n\nStatechains overview\nhttp://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-statechains/\n\nThanks,\n- Bryan\nhttps://heybryan.org/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190607/ffa4857e/attachment.html>"
            },
            {
                "author": "Cory Fields",
                "date": "2019-06-21T02:56:21",
                "message_text_only": "A belated thanks (as always) for the great notes, Bryan. This is so\nvaluable!\n\nCory\n\n\nOn Fri, Jun 7, 2019 at 11:07 AM Bryan Bishop via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi,\n>\n> The following are some notes from the coredev.tech Amsterdam 2019 meeting.\n> Any mistakes are my probably my own.\n>\n> Here is a conversation about the code review process in Bitcoin Core:\n>\n> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-05-code-review/\n>\n> Here is a conversation with some of the maintainers about what problems\n> they are seeing:\n>\n> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-06-maintainers/\n>\n> Wallet re-architecture discussion\n>\n> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-05-wallet-architecture/\n>\n> Great consensus cleanup\n>\n> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-06-great-consensus-cleanup/\n>\n> SIGHASH_NOINPUT, OP_CHECKSIGFROMSTACK, OP_CHECKOUTPUTSHASHVERIFY,\n> OP_SECURETHEBAG\n>\n> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-06-noinput-etc/\n>\n> Taproot discussion\n> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-06-taproot/\n>\n> Utreexo\n> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-06-utreexo/\n>\n> assumeutxo\n>\n> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-assumeutxo/\n>\n> Hardware wallets and HWI\n>\n> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-hardware-wallets/\n>\n> bip151, p2p encryption and v2 message format\n>\n> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-p2p-encryption/\n>\n> Signet for bitcoin test networks\n> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-signet/\n>\n> Statechains overview\n>\n> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-statechains/\n>\n> Thanks,\n> - Bryan\n> https://heybryan.org/\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190620/611c57f3/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Transcripts from coredev.tech Amsterdam 2019 meeting",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Bryan Bishop",
                "Cory Fields"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 4052
        }
    },
    {
        "title": "[bitcoin-dev] testnet4",
        "thread_messages": [
            {
                "author": "Emil Engler",
                "date": "2019-06-07T23:49:16",
                "message_text_only": "Hello, I tried myself with some Bitcoin development. For this I used of \ncourse the Bitcoin testnet. However it took me one hour to sync the \nblockchain with around 1538358 blocks. In my opinion that is too much \nfor a testnet. Especially the blockchain size with around 26GB is so \nmuch. Would it be possible to reset the testnet with a new genesis block \n? And if so, can we setup a fixed cycle for resetting the testnet (For \nexample every second 1st of January) ?\n\nGreetings,\nEmil Engler"
            },
            {
                "author": "Bryan Bishop",
                "date": "2019-06-08T14:21:40",
                "message_text_only": "Be greeted Emil,\n\nOn Sat, Jun 8, 2019 at 9:21 AM Emil Engler via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello, I tried myself with some Bitcoin development. For this I used of\n> course the Bitcoin testnet. However it took me one hour to sync the\n> blockchain with around 1538358 blocks. In my opinion that is too much\n> for a testnet. Especially the blockchain size with around 26GB is so\n> much. Would it be possible to reset the testnet with a new genesis block\n> ? And if so, can we setup a fixed cycle for resetting the testnet (For\n> example every second 1st of January) ?\n>\n\nAt the moment, I somewhat doubt this is likely to happen. Signet provides\nan alternative for configuring multiple separate private and public testing\nnetworks. If you would like to get involved, check out the recent\ndiscussion on the topic recorded here:\nhttp://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-signet/\n\n- Bryan\nhttp://heybryan.org/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190608/ae64c521/attachment.html>"
            },
            {
                "author": "Emil Engler",
                "date": "2019-06-08T15:01:50",
                "message_text_only": "I don't get why the testnet shouldn't be resetted just because there is \na (probably better) alternative for it. The testnet is still a thing and \nis also used.\n\nAm 08.06.19 um 16:21 schrieb Bryan Bishop:\n> Be greeted Emil,\n> \n> On Sat, Jun 8, 2019 at 9:21 AM Emil Engler via bitcoin-dev \n> <bitcoin-dev at lists.linuxfoundation.org \n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> \n>     Hello, I tried myself with some Bitcoin development. For this I used of\n>     course the Bitcoin testnet. However it took me one hour to sync the\n>     blockchain with around 1538358 blocks. In my opinion that is too much\n>     for a testnet. Especially the blockchain size with around 26GB is so\n>     much. Would it be possible to reset the testnet with a new genesis\n>     block\n>     ? And if so, can we setup a fixed cycle for resetting the testnet (For\n>     example every second 1st of January) ?\n> \n> \n> At the moment, I somewhat doubt this is likely to happen. Signet \n> provides an alternative for configuring multiple separate private and \n> public testing networks. If you would like to get involved, check out \n> the recent discussion on the topic recorded here:\n> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-signet/\n> \n> - Bryan\n> http://heybryan.org/"
            },
            {
                "author": "Peter Todd",
                "date": "2019-06-16T20:25:06",
                "message_text_only": "On Sat, Jun 08, 2019 at 05:01:50PM +0200, Emil Engler via bitcoin-dev wrote:\n> I don't get why the testnet shouldn't be resetted just because there is a\n> (probably better) alternative for it. The testnet is still a thing and is\n> also used.\n\nRemember that the size of testnet itself is an important test; I've argued in\nthat past that we should consider making testnet *larger* than mainnet. There's\ngood arguments against that too, but I personally think the current size is a\nreasonable compromise.\n\nOf course, I personally tend to do all my testing on either internal regtest\nnodes, or directly on mainnet. But the fact that works for me is specific to\nthe exact type of development I do and may not be applicable to you.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190616/8496db8e/attachment.sig>"
            },
            {
                "author": "Emil Engler",
                "date": "2019-06-17T11:41:08",
                "message_text_only": "Indeed a large testnet blockchain has advantages too.\nBut because it is the testnet and the testnet coins have no value, the\nblockchain could be 'spammed' after a reset for some days/weeks until it\nhas a certain size.\nCould this be realistic solution ?\n\nAm 16.06.19 um 22:25 schrieb Peter Todd:\n> On Sat, Jun 08, 2019 at 05:01:50PM +0200, Emil Engler via bitcoin-dev wrote:\n>> I don't get why the testnet shouldn't be resetted just because there is a\n>> (probably better) alternative for it. The testnet is still a thing and is\n>> also used.\n> \n> Remember that the size of testnet itself is an important test; I've argued in\n> that past that we should consider making testnet *larger* than mainnet. There's\n> good arguments against that too, but I personally think the current size is a\n> reasonable compromise.\n> \n> Of course, I personally tend to do all my testing on either internal regtest\n> nodes, or directly on mainnet. But the fact that works for me is specific to\n> the exact type of development I do and may not be applicable to you.\n> \n\n-- \nhttps://www.emilengler.com\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: pEpkey.asc\nType: application/pgp-keys\nSize: 3147 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190617/80546911/attachment.bin>"
            }
        ],
        "thread_summary": {
            "title": "testnet4",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Emil Engler",
                "Bryan Bishop",
                "Peter Todd"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 5328
        }
    },
    {
        "title": "[bitcoin-dev] WORKVERIFY: uncensorable contracts hedging biggest risk of mining without 3rd party or oracle",
        "thread_messages": [
            {
                "author": "Tamas Blummer",
                "date": "2019-06-08T18:59:09",
                "message_text_only": "In an earlier post [1] I suggested an approach to create native Bitcoin contracts that reduce mining's income volatility and received very helpful comments on implementation from Pieter Wuille [2] and Natanael [3]\n\nAfter processing those comments I instead suggest the following restricted interpretation of nSequence and a new opcode WORKVERIFY that in combination is easier to implement and reason about as it follows the implementation pattern of CHECKSEQUENCEVERIFY[5]\n\nAccumulated work on the blockchain is strictly increasing, therefore transaction eligibility rule with a >= condition on it would need no re-evaluation for descendant blocks, in mempool or at re-org, since additional blocks or re-org can only increase the accumulated work. Accumulated work is just like time, it is actually an alternate measure of time through computation[6], therefore analogous to MTP based restriction implemented with BIP68 [4].\n\n=== (the implementation proposal) ===\n\n(needs soft fork for two reasons, activation logic tbd.)\n\nI. Stricter interpretation of nSequence to optionally refer accumulated work:\n\nOnly if bit 31 AND bit 30 is set in nSequence can the transaction be included into any block. This is a restricting a rule of BIP68 [4] that only required bit 31 to be set for unrestricted inclusion into blocks. Otherwise nSequence refers to accumulated work (see encoding later) and it is only viable to include the transaction into a block if the block has >= work accumulated. This would define the meaning of one additional bit in nSequence, but leave all other freedom of later improvement left by BIP68.\n\nII. New WORKVERIFY opcode redefining a NOPx in transaction script as:\n\nTerminate script with false for any reason described in BIP112 or if bit 31 is set but bit 30 is not set and 256 bit unsigned integer on stack is higher than (nSequence &0xffff)>> 6 * 2^((nSequence & 0x3f) + 84)\n\n=== (end proposal) ===\n\nNotes on the work encoding:\n\nTotal accumulated work as of now is > 2^90 and if we assume that mining capacity keeps increasing with Moore\u2019s law (double every year) for the next 50 years, then it could sum up to 2^140. We have much less bits available in nSequence therefore we have to encode accumulated work in a floating point number with sufficient precision.\n\nThe work accumulated during the current difficulty adjustment cycle is > 2016 * 2^74 which is > 2^84. It is rather unlikely that accumulated work in a difficulty adjustment period drops below 2^80 ever again in future which means we need not be more precise than  2^80/2^90 or 2^-10 to allow for contracts that reference increment until the next adjustment. Therefore a mantissa of 10 bits should be sufficient. Using 6 bits of exponent and an offset of 2^84 we can express the range of [2^84, 2^148) that should be sufficient now and for foreseeable future. Please let me know if the approach is not optimal or future proof in your opinion.\n\nWhy, should we build this into Bitcoin ?\n\nThe most influential risk factor in miners' investment decision is the anticipated change of difficulty over the time horizon of the mining equipment's expected lifetime. Their investments secure the network. The ability to create contracts that reduce income volatility would lead to additional investment into mining.\n\nA native Bitcoin contract is far superior to alternatives that could be offered on traditional markets as:\n\na native Bitcoin contract would be:\n- uncensorable: It requires only the agreement to terms between those financially involved\n- fully collaterized: no counterparty risk which means Miner could buy hedging contracts from any unkown and un-trusted actor that is able to commit collateral\n- no oracle is needed\n- no disagreement on the settlement\n- publicly observable: allow to observe market opinion on future difficulty\n- the length of the contract could match miner's investment horizon extending over several difficulty adjustments.\n\nWhy not on a side-chain ?\n\nWork is fundamental and intrinsic to the base layer. A contract that reduces earnings volatility helps to attract more capital for mining and therefore increase security on the base layer.\n\nHow would this be used?\n\nMiner and Speculator sign a transaction that has an nLockTime of S in the future. This gives both parties the option to alternatively spend committed output in case the other would not follow through and publish committing the collateral until S.\n\nSpeculators contribution to collateral is higher than that of the Miner. Miner\u2019s collateral is the premium for the insurance provided by Speculator.\n\nThe single output of the transaction has following script:\n\nIF\n\t<maturity> CHECKLOCKTIMEVERIFY DROP\n        <speculator\u2019s key> CHECKSIGVERIFY\nELSE\n        <sufficient work> WORKVERIFY DROP\n        <miner\u2019s key> CHECKSIGVERIFY\nENDIF\n\nThis allows the speculator to take back its collateral plus the option premium after the maturity time point, which would however only be possible if it was not taken earlier by Miner as sufficient work was reached.\n\nThe contract in finance terms is an american digital call option with maturity and sufficient work as strike. The Miner profits of the contract if work accumulated is more than contracted in which case he would also have lower mining income, hence the contract would reduce earnings shortcome. The Speculator would earn the option premium if the contracted work was not required until maturity. In this case higher mining income through higher market share compensates Miner for the loss of option premium.  In both cases Miner\u2019s income volatility is reduced. The Speculator may find it attractive to enter the contract if the probability weighted option premium represents an attractive interest on the capital committed.\n\nContracted work would reflect the consenus of expected difficulty increase over future time horizons. Observing above contracts on the blockchain would allow calculation of market implied forward curve of mining difficulty and its implied volatility which again would help evaluating investment proposals into mining.\n\nAn alternate more flexible setup would be a Lightning Network like re-allocation of total collateral. Which would allo parties to mark the option to market (observed work and volatility) as time passes and allow for cooperative unwind.\n\nTamas Blummer\n\n[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016952.html\n[2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016958.html\n[3] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016969.html\n[4] https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki\n[5] https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki\n[6] https://medium.com/@tamas.blummer/measuring-time-with-chain-of-blocks-893a38cc06bb\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190608/fae077b6/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "WORKVERIFY: uncensorable contracts hedging biggest risk of mining without 3rd party or oracle",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tamas Blummer"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 7071
        }
    },
    {
        "title": "[bitcoin-dev] bitcoin-dev Digest, Vol 49, Issue 8",
        "thread_messages": [
            {
                "author": "Tim Menapace",
                "date": "2019-06-09T14:55:25",
                "message_text_only": ">I don't get why the testnet shouldn't be >resetted just because there is \n>a (probably better) alternative for it. The >testnet is still a thing and \n>is also used.\n\nLike Bryan said, lot of miners test here. E.g. new firmware versions, hardware prototypes and operation services. Difficulty will be on current levels in a short period of time.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190609/25bbb05c/attachment.html>"
            },
            {
                "author": "Emil Engler",
                "date": "2019-06-09T18:56:47",
                "message_text_only": "But using the testnet means that you actually need to deal with resets. \nThere were 2 resets in the past but the last was in 2011.\n\nAm 09.06.19 um 16:55 schrieb Tim Menapace:\n>  >I don't get why the testnet shouldn't be >resetted just because there is\n>  >a (probably better) alternative for it. The >testnet is still a thing and\n>  >is also used.\n> \n> Like Bryan said, lot of miners test here. E.g. new firmware versions, \n> hardware prototypes and operation services. Difficulty will be on \n> current levels in a short period of time."
            }
        ],
        "thread_summary": {
            "title": "bitcoin-dev Digest, Vol 49, Issue 8",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Emil Engler",
                "Tim Menapace"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1063
        }
    },
    {
        "title": "[bitcoin-dev] Transcripts from Breaking Bitcoin 2019",
        "thread_messages": [
            {
                "author": "Bryan Bishop",
                "date": "2019-06-09T21:14:39",
                "message_text_only": "Hi all,\n\nThe following are some notes I took during Breaking Bitcoin 2019, selected\nfor relevance. Any mistakes are most likely my own.\n\nCarl Dong gave an excellent talk on guix as a replacement for the gitian\nbuild system:\nhttp://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/bitcoin-build-system/\nbut really just watch his presentation:\nhttps://www.youtube.com/watch?v=I2iShmUTEl8\n\nMempool analysis, client-side filtering, client updates\nhttp://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/mempool-analysis-simulation/\nhttp://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/neutrino/\nhttp://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/p2p-encryption/\n\nSome privacy and coinjoin talks:\nhttp://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/breaking-bitcoin-privacy/\nhttp://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/breaking-wasabi/\n\nHardware wallets:\nhttp://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/extracting-seeds-from-hardware-wallets/\nhttp://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/future-of-hardware-wallets/\n\nBitcoin upgrades:\nhttp://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/secure-protocols-bip-taproot/\n\np2pool analysis:\nhttp://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/security-attacks-decentralized-mining-pools/\n\nLightning network:\nhttp://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/lightning-network-routing-security/\nhttp://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/lightning-network-topological-analysis/\nhttp://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/lightning-network-security-panel/\n\nOf possible interest (general, not really development focused):\nhttp://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/defense-of-bitcoin/\n\n- Bryan\nhttp://heybryan.org/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190609/d578b4da/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Transcripts from Breaking Bitcoin 2019",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Bryan Bishop"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1929
        }
    },
    {
        "title": "[bitcoin-dev] An alternative: OP_CAT & OP_CHECKSIGFROMSTACK",
        "thread_messages": [
            {
                "author": "Tamas Blummer",
                "date": "2019-06-13T08:14:02",
                "message_text_only": "ZmnSCPxj already observed in [1] that these ops would enable introspection of any field of the transactions and make both `OP_CHECKLOCKTIMEVERIFY` and `OP_CHECKSEQUENCEVERIFY` superfluous.\nThere is much more to this as enumerated in generic terms by Russel O\u2019Connor below and I would like to add a concrete example.\n\nWe could implement oracle less difficulty contracts without the need the of a CISC type OP_WORKVERIFY but instead through resurrection/extension of OP_CAT, OP_GREATERTHANOREQUAL and introduction of a new RISC opcode OP_CHECKBLOCKATHEIGHT[3] suggested by Luke Dashjr. Thanks for the pointer to Nathan Cook [4]\n\nTechnically we could resurrect and add them without burning more than one OP_NOP by redefining it as a prefix (OP_EXTENSION), such as:\n\nOP_EXTENSION OP_CAT would become a two byte opcode pointing to a resurrected implementation of OP_CAT.\n\nThis could be soft forked in.\n\nA concrete oracle less difficulty contract could look like:\nIt is an european digital call option on target difficulty after maturity and 10 blocks notice period. I gave you reasons while having these would increase bitcoin's security in [2]\n\nIF\n\t<maturity as block height + 10> CHECKLOCKTIMEVERIFY DROP\n      <speculator\u2019s key> CHECKSIGVERIFY\nELSE\n\tOP_DUP  <maturity as block height - 1> OP_CHECKBLOCKATHEIGHT OP_LESSTHANEQUAL OP_VERIFY\n\tOP_SWAP OP_CAT  OP_CAT  OP_HASH256 <contracted target> OP_LESSTHANEQUAL OP_VERIFY\n\t<miner\u2019s key> CHECKSIGVERIFY\nENDIF\n\ninsurance premium could be collected by the seller of the insurance after maturity + 10 blocks if target difficulty was not reached\n\n<speculator\u2019s signature>\n\nminer would get back its insurance premium plus collateral of the seller if target difficulty was not reached at maturity. Miner has 10 blocks time after maturity to claim with:\n\n<maturity block header after prevhash> <maturity block version> <prevhash>\n\nThe stack would be in second case processed as:\n\n1: after pushes\n<maturity block prevhash>\n<maturity block version>\n<maturity block block header after prevhash>\n\n2: after OP_DUP:\n<maturity block prevhash>\n<maturity block prevhash>\n<maturity block version>\n<maturity block block header after prevhash>\n\n3: after push\n<maturity as block height - 1>\n<maturity block prevhash>\n<maturity block prevhash>\n<maturity block version>\n<maturity block block header after prevhash>\n\n4: after OP_CHECKBLOCKATHEIGHT OP_VERIFY is successful proving that prevhash is the block at maturity block height - 1\n<maturity block prevhash>\n<maturity block version>\n<maturity block block header after prevhash>\n\n5: after OP_SWAP\n<block version>\n<maturity block prevhash>\n<block header after prevhash>\n\n6: after OP_CAT\n<maturity block version concatenated with maturity prevhash>\n<maturity block block header after maturity prevhash>\n\n7: after OP_CAT\n<complete block header>\n\n8: after OP_HASH256\n<block hash computed for header>\n\n9: after push\n<contracted target>\n<block hash computed for header>\n\n10: after OP_GREATERTHANOREQUAL OP_VERIFY proves that contracted target was reached\n\nTamas Blummer\n\n\n[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016966.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016966.html>\n[2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017019.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017019.html>\n[3] https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki <https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki>\n[4] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016954.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016954.html>\n[5] https://github.com/bitcoin/bitcoin/blob/master/src/script/script.h <https://github.com/bitcoin/bitcoin/blob/master/src/script/script.h>\n> On May 22, 2019, at 23:01, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Recently there have been some tapscript proposals, SIGHASH_ANYPREVOUT and OP_CHECKOUTPUTHASHVERIFY, that aim to enable particular new features for Bitcoin via new Script operations.  However, I think that these proposals miss the mark when it comes to how they approach Bitcoin Script and language features.\n> \n> Bitcoin Script appears designed to be a flexible programmable system that provides generic features to be composed to achieve various purposes.  Thus, when we design new language features for Script, we should be striving, as much as possible, to similarly build general purpose tools which can in turn be used for a variety of purposes.\n> \n> I feel the SIGHASH_ANYPREVOUT and OP_CHECKOUTPUTHASHVERIFY proposals fail to achieve these design goals.  They are both are designed with very narrow applications in mind, while also going out of their way to extend the semantic domain of the interpretation of Bitcoin operations in new ways that complicate their specification.  In the case of SIGHASH_ANYPREVOUT, the semantic domain is extended by adding new counters to track the use of various v0 and v2 signature types.  In the case of OP_CHECKOUTPUTHASHVERIFY, it employs a new context-sensitive operation that peeks at the value of surrounding opcodes.\n> \n> Instead, I propose that, for the time being, we simply implement OP_CAT and OP_CHECKSIGFROMSTACKVERIFY.  OP_CAT pops two byte arrays off the stack and pushes their concatenation back onto the stack.  OP_CHECKSIGFROMSTACKVERIFY pops a signature, message, and pubkey off the stack and performs a bip-schnorr verification on the SHA256 hash of the message.\n> \n> In concert, these two operations enable:\n> \n> * Oracle signature verification, including discrete log contracts.\n> * Amortized secure multiparty computations (see \"Amortizing Secure Computation with Penalties\" by Kumaresan and Bentov).\n> * Transaction introspection including:\n> + <> Simulated SIGHASH_ANYPREVOUT, which are necessarily chaperoned simply by the nature of the construction.\n> + <> Decide if a transaction has exactly one input or not. (etc.)\n> + Weak covenants, which can verify output scripts to see if they are among a set of predefined values or verify the output hash.\n> \n> and presumably more applications as well.\n> \n> For better or for worse, without an OP_PUBKEYTWEEK operation available, the more interesting recursive-covenants remain largely out of reach, with the exception of a recursive covenant that is only able to send back to its own address, possibly abusing its own TXO value as a state variable.\n> \n> All this is accomplished by two straightforward opcodes whose semantics are pure computational operations on stack values.  The only semantic side-effect is that OP_CHECKSIGFROMSTACKVERIFY would count towards the existing 'sigops_passed' count.  Moreover, I feel that adding these operations does not preclude adding more specialized opcodes in the future as an optimization for whatever popular constructions come up, once we know what those are.\n> \n> I feel that this style of generic building blocks truly embodies what is meant by \"programmable money\".\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190613/4583e8b3/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190613/4583e8b3/attachment-0001.sig>"
            }
        ],
        "thread_summary": {
            "title": "An alternative: OP_CAT & OP_CHECKSIGFROMSTACK",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tamas Blummer"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 7706
        }
    },
    {
        "title": "[bitcoin-dev] New BIP - v2 peer-to-peer message transport protocol",
        "thread_messages": [
            {
                "author": "Elichai Turkel",
                "date": "2019-06-17T02:06:21",
                "message_text_only": "Hi everyone,\nAbout the nonce being 64bit. (rfc7539 changed it to 96bit, which djb later\ncalls xchacha)\n\nYou suggest that we use the \"message sequence number\" as the nonce for\nChacha20, Is this number randomly generate or is this a counter?\nAnd could it be reseted without rekeying?\n\nIf it is randomly generated then 64bit isn't secure enough. And we should\neither move to the chacha20 from RFC7539 which has 96bit nonce and 32bit\ncounter or increment it manually every time.\n\nIf it's simply a counter then 64bit nonce should be fine :)\n\nThanks,\nElichai.\n\n-- \nPGP: 5607C93B5F86650C\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190616/84c36142/attachment.html>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2019-06-17T16:20:32",
                "message_text_only": "Hi Elichai\n\n> About the nonce being 64bit. (rfc7539 changed it to 96bit, which djb later calls xchacha)\n> \n> You suggest that we use the \"message sequence number\" as the nonce for Chacha20, Is this number randomly generate or is this a counter?\n> And could it be reseted without rekeying?\n\nThe in BIP324 (v2 message transport protocol) proposed AEAD, ChaCha20Poly1305 at Bitcoin [1], uses a \u201emessage sequence number\u201c. There is no such thing as random nonce described in the BIP (hence the term \u201esequence number\u201c). The message sequence number starts with 0 and the max traffic before a rekey must occur is 1GB. A nonce/key reuse is conceptually impossible (of course implementations could screw up at this point).\n\nUsing XChaCha20 with the possibility of a random nonce could be done, but I don\u2019t see a reason to use it in our case since the usage of a sequence number as nonce seems perfectly save.\n\n[1] https://gist.github.com/jonasschnelli/c530ea8421b8d0e80c51486325587c52#chacha20-poly1305bitcoin-cipher-suite\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190617/06f5efa8/attachment-0001.sig>"
            },
            {
                "author": "Elichai Turkel",
                "date": "2019-06-17T17:13:05",
                "message_text_only": "Thanks,\nI just couldn't find where is the message sequence number comes from.\nSo if it's max 1GB and it's an incremental counter that cannot be reseted\nwithout a rekeying than it's perfectly fine :).\n\nThanks for the answer!\n\nOn Mon, Jun 17, 2019 at 12:20 PM Jonas Schnelli <dev at jonasschnelli.ch>\nwrote:\n\n> Hi Elichai\n>\n> > About the nonce being 64bit. (rfc7539 changed it to 96bit, which djb\n> later calls xchacha)\n> >\n> > You suggest that we use the \"message sequence number\" as the nonce for\n> Chacha20, Is this number randomly generate or is this a counter?\n> > And could it be reseted without rekeying?\n>\n> The in BIP324 (v2 message transport protocol) proposed AEAD,\n> ChaCha20Poly1305 at Bitcoin [1], uses a \u201emessage sequence number\u201c. There is\n> no such thing as random nonce described in the BIP (hence the term\n> \u201esequence number\u201c). The message sequence number starts with 0 and the max\n> traffic before a rekey must occur is 1GB. A nonce/key reuse is conceptually\n> impossible (of course implementations could screw up at this point).\n>\n> Using XChaCha20 with the possibility of a random nonce could be done, but\n> I don\u2019t see a reason to use it in our case since the usage of a sequence\n> number as nonce seems perfectly save.\n>\n> [1]\n> https://gist.github.com/jonasschnelli/c530ea8421b8d0e80c51486325587c52#chacha20-poly1305bitcoin-cipher-suite\n>\n\n\n-- \nPGP: 5607C93B5F86650C\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190617/d7cf1656/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "New BIP - v2 peer-to-peer message transport protocol",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Elichai Turkel",
                "Jonas Schnelli"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 3643
        }
    },
    {
        "title": "[bitcoin-dev] PSA: Upcoming disclosure of pre-v0.17.1 vulnerabilities",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2019-06-22T23:42:52",
                "message_text_only": "Two relatively minor vulnerabilities will likely be disclosed sometime soon.\n\nThe first vulnerability, CVE-2017-18350, was introduced in v0.7.0 (released in \n2012 September), and affects all versions released until the fix was included \nin v0.15.1 (released in 2017 November). No versions prior to v0.15.1 are \nexpected to be fixed.\n\nThe second vulnerability, CVE-2018-20586, was introduced in v0.12.0 (released \nin 2016 February), and affects all versions released until the fix was \nincluded in v0.17.1 (released in 2018 December). As of today, this fix has \nNOT been backported to older versions. When/if v0.15.3 and v0.16.4 are \nreleased, they may also include a fix, but due to the minor severity of this \nvulnerability, it does not merit a dedicated release on its own. (The git \nbranches are also NOT fixed at this time.)\n\nPlease be sure you have upgraded to a fixed version no later than August 1st."
            }
        ],
        "thread_summary": {
            "title": "PSA: Upcoming disclosure of pre-v0.17.1 vulnerabilities",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Luke Dashjr"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 907
        }
    },
    {
        "title": "[bitcoin-dev] Taproot proposal",
        "thread_messages": [
            {
                "author": "Russell O'Connor",
                "date": "2019-06-27T00:08:01",
                "message_text_only": "I have a comment about the 'input_index' of the transaction digest for\ntaproot signatures.  It is currently listed as 2 bytes.  I think it would\nbe better to expand that to 4 bytes.\nThe two byte limit is derived from the block size / weight limit, which\nlimits the maximum size of a transaction, which in turn, due to a minimum\nsize of an inputs, places a limit on the maximum number of inputs.\n\nHowever, I think it is a mistake to mix limits from the block layer into\nthe transaction layer of the consensus rules.  For example, I believe that,\nas it stands currently, if we wanted to hardfork an increase in the block\nweight limit, doing so wouldn't have any impact on the transaction layer\nand we could transparently manage larger transactions with the current\ntransaction format [2].  However if we start incorporating the block limits\ninto the transaction layer, then we run the risk of such a hard fork\nneeding to also make consensus changes in the transaction\nformat/interpretation if we wanted to handle larger transaction sizes,\nwhich, while doable, wouldn't be so great.\n\nThe current transaction format limits the number of inputs (and the number\nof outputs) to 2^32-1 or less [1].  So using 4 bytes for the 'input_index'\nwill suffice.\n\nGiven that adding 2 bytes to the signed transaction digest isn't a big\ndeal, it's probably better just to keep block limits and transaction limits\nseparate.\n\n[1]The var-integer field for the number of inputs (and the number of\noutputs) in a transaction looks like it should allow upto 2^64-1 inputs;\nhowever this is an illusion.  The P2P rules dictate that these values are\nimmediately taken modulo 2^32 after decoding.  For example, if the number\nof inputs is a var-integer encoding of 0x0100000001, it is actually just a\nnon-canonical way of encoding that there is 1 input.  Try this at home!\n\n[2]If we were to hardfork an increase in the block weight limit, we would\nprobably want to still keep the limit on the size of transactions that\nconsume legacy UTXOs in order to avoid the quadratic computation problems\nthat plagues the legacy transaction digest.\n\nOn Mon, May 6, 2019 at 2:36 PM Pieter Wuille via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello everyone,\n>\n> Here are two BIP drafts that specify a proposal for a Taproot\n> softfork. A number of ideas are included:\n>\n> * Taproot to make all outputs and cooperative spends indistinguishable\n> from eachother.\n> * Merkle branches to hide the unexecuted branches in scripts.\n> * Schnorr signatures enable wallet software to use key\n> aggregation/thresholds within one input.\n> * Improvements to the signature hashing algorithm (including signing\n> all input amounts).\n> * Replacing OP_CHECKMULTISIG(VERIFY) with OP_CHECKSIGADD, to support\n> batch validation.\n> * Tagged hashing for domain separation (avoiding issues like\n> CVE-2012-2459 in Merkle trees).\n> * Extensibility through leaf versions, OP_SUCCESS opcodes, and\n> upgradable pubkey types.\n>\n> The BIP drafts can be found here:\n> * https://github.com/sipa/bips/blob/bip-schnorr/bip-taproot.mediawiki\n> specifies the transaction input spending rules.\n> * https://github.com/sipa/bips/blob/bip-schnorr/bip-tapscript.mediawiki\n> specifies the changes to Script inside such spends.\n> * https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki\n> is the Schnorr signature proposal that was discussed earlier on this\n> list (See\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016203.html\n> )\n>\n> An initial reference implementation of the consensus changes, plus\n> preliminary construction/signing tests in the Python framework can be\n> found on https://github.com/sipa/bitcoin/commits/taproot. All\n> together, excluding the Schnorr signature module in libsecp256k1, the\n> consensus changes are around 520 LoC.\n>\n> While many other ideas exist, not everything is incorporated. This\n> includes several ideas that can be implemented separately without loss\n> of effectiveness. One such idea is a way to integrate SIGHASH_NOINPUT,\n> which we're working on as an independent proposal.\n>\n> The document explains basic wallet operations, such as constructing\n> outputs and signing. However, a wide variety of more complex\n> constructions exist. Standardizing these is useful, but out of scope\n> for now. It is likely also desirable to define extensions to PSBT\n> (BIP174) for interacting with Taproot. That too is not included here.\n>\n> Cheers,\n>\n> --\n> Pieter\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190626/7223bf9f/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2019-06-28T09:49:37",
                "message_text_only": "On Wed, Jun 26, 2019 at 08:08:01PM -0400, Russell O'Connor via bitcoin-dev wrote:\n> I have a comment about the 'input_index' of the transaction digest for taproot\n> signatures.\u00a0 It is currently listed as 2 bytes.\u00a0 I think it would be better to\n> expand that to 4 bytes.\n\nFWIW, I think this would be essentially free, at least for the current\nsighash modes, as (I think) all the non-ANYONECANPAY modes have at least\n4 bytes of sha256 padding at present.\n\nIn addition to (or, perhaps, as a special case of) the reasons Russell\ngives, I think this change would also better support proof-of-reserves\nvia taproot signatures (cf [0] or BIP 127), as it would allow the proof\ntx to include more than 65k utxos with each utxo being signed with a\nsignature that commits to all inputs including the invalid placeholder.\n\n[0] https://blockstream.com/2019/02/04/en-standardizing-bitcoin-proof-of-reserves/\n\nIf you didn't have this, but wanted to do proof-of-reserves over >65k\ntaproot UTXOs, you could use ANYONECANPAY signatures, and use the output\namounts to ensure the signatures can't be abused, something like:\n\n   inputs:\n     0: spend from txid 0000..0000 vout 0, no witness data\n     1: utxo1, signed with ANYONECANPAY|ALL\n     2: utxo2, signed with ANYONECANPAY|ALL\n     3: utxo3, signed with ANYONECANPAY|ALL\n     [etc]\n\n   outputs:\n     0: sum(utxo1..utxoN), pay to self\n     1: 2099999997690001-sum(utxo1..utxo3), payable to whatever\n\nThe total output value is therefore one satoshi more bitcoin than there\ncould ever have been, so none of the utxoK signatures can be reused on the\nblockchain (unless there's severe inflation due to bugs or hardforks),\nbut the values (and sums) all remain less than 21M BTC so it also won't\nfail the current \"amount too big\" sanity checks.\n\nThat seems a bit more fragile/complicated than using SIGHASH_ALL for\neverything, though it means your cold wallet doesn't have to serialize\nyour >65k transactions to verify it's signing what it thinks it is.\n\n> [1]The var-integer field for the number of inputs (and the number of outputs)\n> in a transaction looks like it should allow upto 2^64-1 inputs; however this is\n> an illusion.\u00a0 The P2P rules dictate that these values are immediately taken\n> modulo 2^32 after decoding.\u00a0 For example, if the number of inputs is a\n> var-integer encoding of 0x0100000001, it is actually just a non-canonical way\n> of encoding that there is 1 input.\u00a0 Try this at home!\n\nHmm? If I'm following what you mean, that's not the P2P rules, it's the\nUnserialize code, in particular:\n\n  compat/assumptions.h:52:static_assert(sizeof(int) == 4, \"32-bit int assumed\");\n\n  serialize.h:289:uint64_t ReadCompactSize(Stream& is)\n\n  serialize.h-679-template<typename Stream, unsigned int N, typename T, typename V>\n  serialize.h-680-void Unserialize_impl(Stream& is, prevector<N, T>& v, const V&)\n  serialize.h-681-{\n  serialize.h-682-    v.clear();\n  serialize.h:683:    unsigned int nSize = ReadCompactSize(is);\n\n  (and other Unserialize_impl implementations)\n\nHowever, ReadCompactSize throws \"size too large\" if the return value is\ngreater than MAX_SIZE == 0x02000000 =~ 33.5M, which prior to the implicit\ncast to 32 bits in Unserialize_impl. And it looks like that check's been\nthere since Satoshi...\n\nSo as far as I can see, that encoding's just unsupported/invalid, rather\nthan equivalent/non-canonical?\n\nCheers,\naj"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-06-28T11:16:46",
                "message_text_only": "Hmm? If I'm following what you mean, that's not the P2P rules, it's the\n> Unserialize code, in particular:\n>\n>   compat/assumptions.h:52:static_assert(sizeof(int) == 4, \"32-bit int\n> assumed\");\n>\n>   serialize.h:289:uint64_t ReadCompactSize(Stream& is)\n>\n>   serialize.h-679-template<typename Stream, unsigned int N, typename T,\n> typename V>\n>   serialize.h-680-void Unserialize_impl(Stream& is, prevector<N, T>& v,\n> const V&)\n>   serialize.h-681-{\n>   serialize.h-682-    v.clear();\n>   serialize.h:683:    unsigned int nSize = ReadCompactSize(is);\n>\n>   (and other Unserialize_impl implementations)\n>\n> However, ReadCompactSize throws \"size too large\" if the return value is\n> greater than MAX_SIZE == 0x02000000 =~ 33.5M, which prior to the implicit\n> cast to 32 bits in Unserialize_impl. And it looks like that check's been\n> there since Satoshi...\n>\n> So as far as I can see, that encoding's just unsupported/invalid, rather\n> than equivalent/non-canonical?\n>\n\nThanks for this correction!  I totally missed that MAX_SIZE == 0x02000000.\nI think I mistook it for SIZE_MAX when reviewing this, or just didn't\nnotice it at all.\n\nCheers,\n> aj\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190628/e7442a36/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Taproot proposal",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Russell O'Connor",
                "Anthony Towns"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 9534
        }
    },
    {
        "title": "[bitcoin-dev] BIP174 extension proposal (Global Type: PSBT_GLOBAL_XPUB_SIGNATURE)",
        "thread_messages": [
            {
                "author": "Jonathan Underwood",
                "date": "2019-06-27T02:11:23",
                "message_text_only": "Hello all,\n\nJust wanted to pick your brains about an idea for PSBT extension.\n\nOne problem we try to solve with cold -> warm and warm -> hot sends for our\nexchange wallet is \"How do I know that the address I am sending to is not a\nhacker's address that was swapped in between unsigned tx creation and first\nsignature?\"\n\nWe have a proprietary JSON based encoding system which we are looking to\nmove towards PSBT, but PSBT is missing this key functionality.\n\nBIP32_DERIVATION does allow us to verify the address is from a certain\nXPUB, but, for example, it can not allow us to verify a signature of that\nxpub.\n\nI have made a rough draft of the proposed key value specification.\nhttps://github.com/junderw/bips/blob/addXpubSig/bip-0174.mediawiki#specification\n\nThe signing key path used in the spec is just randomly chosen 31 x 4 bits\nshown as numbers with hardened paths.\n\nSince this issue seems similar to the change address issue, I started from\nthat as a base. With the HW wallet case, I can verify the xpub by just\nderiving it locally and comparing equality, however, in our case, we need\nto verify an xpub that we do not have access to via derivation from our\ncold key(s) (since we don't want to import our warm private key into our\ncold signer)\n\nSo the flow would be:\n1. Securely verify the xpub of the warm / hot wallet.\n2. Using the airgap signing tool, sign the xpub with all cold keys.\n3. Upload the signature/xpub pairs to the online unsigned transaction\ngenerator.\n4. Include one keyval pair per coldkey/xpub pairing.\n5. When offline signing, if the wallet detects there is a global keyval\nXPUB_SIGNATURE with its pubkey in the key, it must verify that all outputs\nhave BIP32_DERIVATION and that it can verify the outputs through the\nderivation, to the xpub, and to the signature.\n\nIn my attempt to fitting this into PSBT, I am slightly altering our current\nsystem, so don't take this as an indication 100% of how we work in the\nbackend.\n\nHowever, I would like to hear any feedback on this proposal.\n\nThanks,\nJonathan\n\n-- \n-----------------\nJonathan Underwood\n\u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n-----------------\n\n\u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n\n\u6307\u7d0b: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190627/82c9ecc0/attachment.html>"
            },
            {
                "author": "Jonathan Underwood",
                "date": "2019-06-27T05:07:47",
                "message_text_only": "Thanks for the reply.\n\nThe way we would do it is:\n\nLet's say we have 3 cold keys for multisig: A B and C\n\nWhose xpubs are: xA xB and xC\n\nWe all sign each other's xpubs, whose signatures are:\nsAxB\nsAxC\nsBxA\nsBxC\nsCxA\nsCxB\n\nWe can then create a wallet that says \"when verifying change with 0x01\nglobal type proposed by Andrew Chow, if the change is multisig, we MUST\nrequire the other pubkeys to have signatures via my 0x02 proposal\"\n\nThis way, all my PSBTs for my cold will have:\n1. an 0x01 entry to tell me how to get my change.\n2. All 6 of the signatures above.\n\nAnd the signer will then look at the change, check my pubkey by deriving\nthe xpub and checking equality to the BIP_DERIVATION of the output... it\nwill then check the OTHER pubkeys via BIP32_DERIVATION to master\nfingerprint, then link that fingerprint to a 0x02 sig from MY key,\nverifying all pubkeys.\n\nSo this proposal of mine would not only fix the \"send to address\nverification\" problem for HD, but also the multisig change problem with\n0x01.\n\nCool.\n\nOnly thing that is kind of sad is having to include n! (of m-of-n)\nsignatures in every PSBT... but tbh, the PSBT size is not of much concern.\n\nThanks for the reply.\n- Jonathan\n\n\n2019\u5e746\u670827\u65e5(\u6728) 13:49 Dmitry Petukhov <dp at simplexum.com>:\n\n> Hi!\n>\n> I wonder how your scheme handles multisig ?\n>\n> As I understand, you sign individual xpubs with cold keys, so that cold\n> keys can check destination addresses are trusted.\n>\n> I seems to me that if you sign individual xpubs of a multisig warm\n> wallet, and one key from that multisig is compromized, attackers can\n> then create a single-sig destination address that they control, and\n> move the coins in a chain of two transactions, first to this single-sig\n> address, and then to an address that they independently control.\n>\n> My idea to prevent this [1] is to sign the whole 'xpub package' of the\n> multisig wallet, but there is also an issue of 'partial compromize',\n> where some of the keys in a multisig warm wallet is compromized, and\n> you do not want to regard a particular 'xpub package' as trusted. My\n> idea was [2] to use an auxiliary message that would be signed along with\n> the 'xpub package', and that message can include specific 'epoch' word\n> that hardware wallet can show prominently before signing, or have\n> 'serial number' for xpub packages (but that will require to store last\n> known serial inside hw wallet, making it stateful).\n>\n> I like the idea to extend PSBT to accomodate these schemes, but given\n> that the huge number of possible schemes that each may probably\n> require its own PSBT field type, I think that this is better dealt with\n> outside of PSBT, as 'PSBT metainformation', or using some form of\n> 'vendor-specific', or 'metainformation-specific' PSBT field. This way\n> each usecase can be independently described in its own documentation,\n> that would include the particulars of the format for the\n> metainformation. This would also make it easier to implement PSBT for\n> simple cases, because the 'core specification' would not grow that big.\n>\n> [1]\n>\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016917.html\n>\n> [2]\n>\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016926.html\n>\n>\n> \u0412 Thu, 27 Jun 2019 11:11:23 +0900 Jonathan Underwood via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > Hello all,\n> >\n> > Just wanted to pick your brains about an idea for PSBT extension.\n> >\n> > One problem we try to solve with cold -> warm and warm -> hot sends\n> > for our exchange wallet is \"How do I know that the address I am\n> > sending to is not a hacker's address that was swapped in between\n> > unsigned tx creation and first signature?\"\n> >\n> > We have a proprietary JSON based encoding system which we are looking\n> > to move towards PSBT, but PSBT is missing this key functionality.\n> >\n> > BIP32_DERIVATION does allow us to verify the address is from a certain\n> > XPUB, but, for example, it can not allow us to verify a signature of\n> > that xpub.\n> >\n> > I have made a rough draft of the proposed key value specification.\n> >\n> https://github.com/junderw/bips/blob/addXpubSig/bip-0174.mediawiki#specification\n> >\n> > The signing key path used in the spec is just randomly chosen 31 x 4\n> > bits shown as numbers with hardened paths.\n> >\n> > Since this issue seems similar to the change address issue, I started\n> > from that as a base. With the HW wallet case, I can verify the xpub\n> > by just deriving it locally and comparing equality, however, in our\n> > case, we need to verify an xpub that we do not have access to via\n> > derivation from our cold key(s) (since we don't want to import our\n> > warm private key into our cold signer)\n> >\n> > So the flow would be:\n> > 1. Securely verify the xpub of the warm / hot wallet.\n> > 2. Using the airgap signing tool, sign the xpub with all cold keys.\n> > 3. Upload the signature/xpub pairs to the online unsigned transaction\n> > generator.\n> > 4. Include one keyval pair per coldkey/xpub pairing.\n> > 5. When offline signing, if the wallet detects there is a global\n> > keyval XPUB_SIGNATURE with its pubkey in the key, it must verify that\n> > all outputs have BIP32_DERIVATION and that it can verify the outputs\n> > through the derivation, to the xpub, and to the signature.\n> >\n> > In my attempt to fitting this into PSBT, I am slightly altering our\n> > current system, so don't take this as an indication 100% of how we\n> > work in the backend.\n> >\n> > However, I would like to hear any feedback on this proposal.\n> >\n> > Thanks,\n> > Jonathan\n> >\n>\n>\n\n-- \n-----------------\nJonathan Underwood\n\u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n-----------------\n\n\u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n\n\u6307\u7d0b: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190627/14367388/attachment-0001.html>"
            },
            {
                "author": "Jonathan Underwood",
                "date": "2019-06-27T08:16:14",
                "message_text_only": "I see what you mean.\n\nWhat about this?\nhttps://github.com/junderw/bips/commit/57a57b4fae1ae14b77a2eebd99cd719148e3027e?short_path=82656c8#diff-82656c833e31e6751a412ce5e5c70920\n\nPlus side: for single sig case, the key only increases by one byte (0x00\nfor the {m} value)\n\nThis way if it was 2 of 3 like before, you sign the whole \"packet\" so each\nkey only signs the packet once. Way better than n!\n\nAnywho. Please send your feedback. Thanks.\nJonathan\n\n2019\u5e746\u670827\u65e5(\u6728) 16:27 Dmitry Petukhov <dp at simplexum.com>:\n\n> How would signer know that there _should_ be at least 3 signatures\n> signed by the key owned by this signer ?\n>\n> If it does not know that it should enforce 2of3 multisig, for example,\n> the attacker that control only one key A can fool signer B by\n> sending to 1of1 single-sig that is derived from A's xpub, and providing\n> only sBxA in PSBT.\n>\n> If the signer does not have a hardcoded configuration that\n> will mandate a particular multisig scheme, it will allow sending to any\n> scheme.\n>\n> If the signer has a rich enough state to store updatable configuration,\n> it can just store the trusted xpubs directly.\n>\n> Alternatively, signer can sign not individual xpubs, but whole xpub\n> packages that correspond to particular multisig configuration, and\n> enforce that destination addresses correspond to this configuration.\n>\n> But this would not be possible with your PSBT scheme that uses\n> individual key-xpub pairs.\n>\n> \u0412 Thu, 27 Jun 2019 14:07:47 +0900\n> Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:\n>\n> > Thanks for the reply.\n> >\n> > The way we would do it is:\n> >\n> > Let's say we have 3 cold keys for multisig: A B and C\n> >\n> > Whose xpubs are: xA xB and xC\n> >\n> > We all sign each other's xpubs, whose signatures are:\n> > sAxB\n> > sAxC\n> > sBxA\n> > sBxC\n> > sCxA\n> > sCxB\n> >\n> > We can then create a wallet that says \"when verifying change with 0x01\n> > global type proposed by Andrew Chow, if the change is multisig, we\n> > MUST require the other pubkeys to have signatures via my 0x02\n> > proposal\"\n> >\n> > This way, all my PSBTs for my cold will have:\n> > 1. an 0x01 entry to tell me how to get my change.\n> > 2. All 6 of the signatures above.\n> >\n> > And the signer will then look at the change, check my pubkey by\n> > deriving the xpub and checking equality to the BIP_DERIVATION of the\n> > output... it will then check the OTHER pubkeys via BIP32_DERIVATION\n> > to master fingerprint, then link that fingerprint to a 0x02 sig from\n> > MY key, verifying all pubkeys.\n> >\n> > So this proposal of mine would not only fix the \"send to address\n> > verification\" problem for HD, but also the multisig change problem\n> > with 0x01.\n> >\n> > Cool.\n> >\n> > Only thing that is kind of sad is having to include n! (of m-of-n)\n> > signatures in every PSBT... but tbh, the PSBT size is not of much\n> > concern.\n> >\n> > Thanks for the reply.\n> > - Jonathan\n> >\n> >\n> > 2019\u5e746\u670827\u65e5(\u6728) 13:49 Dmitry Petukhov <dp at simplexum.com>:\n> >\n> > > Hi!\n> > >\n> > > I wonder how your scheme handles multisig ?\n> > >\n> > > As I understand, you sign individual xpubs with cold keys, so that\n> > > cold keys can check destination addresses are trusted.\n> > >\n> > > I seems to me that if you sign individual xpubs of a multisig warm\n> > > wallet, and one key from that multisig is compromized, attackers can\n> > > then create a single-sig destination address that they control, and\n> > > move the coins in a chain of two transactions, first to this\n> > > single-sig address, and then to an address that they independently\n> > > control.\n> > >\n> > > My idea to prevent this [1] is to sign the whole 'xpub package' of\n> > > the multisig wallet, but there is also an issue of 'partial\n> > > compromize', where some of the keys in a multisig warm wallet is\n> > > compromized, and you do not want to regard a particular 'xpub\n> > > package' as trusted. My idea was [2] to use an auxiliary message\n> > > that would be signed along with the 'xpub package', and that\n> > > message can include specific 'epoch' word that hardware wallet can\n> > > show prominently before signing, or have 'serial number' for xpub\n> > > packages (but that will require to store last known serial inside\n> > > hw wallet, making it stateful).\n> > >\n> > > I like the idea to extend PSBT to accomodate these schemes, but\n> > > given that the huge number of possible schemes that each may\n> > > probably require its own PSBT field type, I think that this is\n> > > better dealt with outside of PSBT, as 'PSBT metainformation', or\n> > > using some form of 'vendor-specific', or 'metainformation-specific'\n> > > PSBT field. This way each usecase can be independently described in\n> > > its own documentation, that would include the particulars of the\n> > > format for the metainformation. This would also make it easier to\n> > > implement PSBT for simple cases, because the 'core specification'\n> > > would not grow that big.\n> > >\n> > > [1]\n> > >\n> > >\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016917.html\n> > >\n> > > [2]\n> > >\n> > >\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016926.html\n> > >\n> > >\n> > > \u0412 Thu, 27 Jun 2019 11:11:23 +0900 Jonathan Underwood via bitcoin-dev\n> > > <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > >\n> > > > Hello all,\n> > > >\n> > > > Just wanted to pick your brains about an idea for PSBT extension.\n> > > >\n> > > > One problem we try to solve with cold -> warm and warm -> hot\n> > > > sends for our exchange wallet is \"How do I know that the address\n> > > > I am sending to is not a hacker's address that was swapped in\n> > > > between unsigned tx creation and first signature?\"\n> > > >\n> > > > We have a proprietary JSON based encoding system which we are\n> > > > looking to move towards PSBT, but PSBT is missing this key\n> > > > functionality.\n> > > >\n> > > > BIP32_DERIVATION does allow us to verify the address is from a\n> > > > certain XPUB, but, for example, it can not allow us to verify a\n> > > > signature of that xpub.\n> > > >\n> > > > I have made a rough draft of the proposed key value specification.\n> > > >\n> > >\n> https://github.com/junderw/bips/blob/addXpubSig/bip-0174.mediawiki#specification\n>\n> > > >\n> > > > The signing key path used in the spec is just randomly chosen 31\n> > > > x 4 bits shown as numbers with hardened paths.\n> > > >\n> > > > Since this issue seems similar to the change address issue, I\n> > > > started from that as a base. With the HW wallet case, I can\n> > > > verify the xpub by just deriving it locally and comparing\n> > > > equality, however, in our case, we need to verify an xpub that we\n> > > > do not have access to via derivation from our cold key(s) (since\n> > > > we don't want to import our warm private key into our cold signer)\n> > > >\n> > > > So the flow would be:\n> > > > 1. Securely verify the xpub of the warm / hot wallet.\n> > > > 2. Using the airgap signing tool, sign the xpub with all cold\n> > > > keys. 3. Upload the signature/xpub pairs to the online unsigned\n> > > > transaction generator.\n> > > > 4. Include one keyval pair per coldkey/xpub pairing.\n> > > > 5. When offline signing, if the wallet detects there is a global\n> > > > keyval XPUB_SIGNATURE with its pubkey in the key, it must verify\n> > > > that all outputs have BIP32_DERIVATION and that it can verify the\n> > > > outputs through the derivation, to the xpub, and to the signature.\n> > > >\n> > > > In my attempt to fitting this into PSBT, I am slightly altering\n> > > > our current system, so don't take this as an indication 100% of\n> > > > how we work in the backend.\n> > > >\n> > > > However, I would like to hear any feedback on this proposal.\n> > > >\n> > > > Thanks,\n> > > > Jonathan\n> > > >\n> > >\n> > >\n> >\n>\n>\n\n-- \n-----------------\nJonathan Underwood\n\u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n-----------------\n\n\u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n\n\u6307\u7d0b: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190627/30b46b5a/attachment-0001.html>"
            },
            {
                "author": "Jonathan Underwood",
                "date": "2019-06-27T08:59:44",
                "message_text_only": "When I say order is not necessary I mean, I won't have to brute force order.\n\nEither way, if we don't sort the xpubs in the key, it would be possible to\ncreate multiple key value pairs for essentially the same group of pubkeys.\n\"I only want to sign if the multisig is in this order\" is pointless.\n\nAnd like I said, output PSBT includes redeemscript and witnessscript, so my\napp can just say \"if no redeemscript or witnessscript or BIP32_DERIVATION\nfor the output, fail\"\n\n- Jonathan\n\n2019\u5e746\u670827\u65e5(\u6728) 17:56 Jonathan Underwood <junderwood at bitcoinbank.co.jp>:\n\n> The output will have redeemscript and witnessscript so order is not\n> necessary. I can just look at the multisig script and find the pubkey\n> inside it.\n>\n> -Jonathan\n>\n> 2019\u5e746\u670827\u65e5(\u6728) 17:45 Dmitry Petukhov <dp at simplexum.com>:\n>\n>> > m value for a multisig (set 0 for non-multisig), followed by 1 or\n>> > more 78 byte serialized extended public keys sorted in canonical\n>> > order\n>>\n>> Sorting xpubs would work if the addresses also sort their pubkeys (like\n>> in BIP67)\n>>\n>> But if the pubkey order in address creation is fixed, you better have\n>> the fixed order for xpubs, otherwise you would need to try all\n>> combinations of derived pubkeys when checking if the addresss match the\n>> presented xpubs. That would be factorial of the number of keys, not\n>> feasible beyond very small number of keys.\n>>\n>> Bitcoin Core, for example, currently does not support BIP67 and supports\n>> only fixed pubkey positions in their script descriptors specification.\n>>\n>> You also need to include all xpubs to match the address, for m of n\n>> standard multisig, you need to include n and check that number of keys\n>> is exactly n.\n>>\n>> Otherwise your would not be able to construct the address to compare to\n>> the destination address that you need to check, as you need all pubkesy\n>> to construct P2SH or P2WSH address.\n>>\n>> With Shnorr-musig, you probably can interpolate the combined pubkey out\n>> of m paticpant pubkeys (but don't cite me on this, I might be wrong)\n>>\n>> \u0412 Thu, 27 Jun 2019 17:16:14 +0900\n>> Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:\n>>\n>> > I see what you mean.\n>> >\n>> > What about this?\n>> >\n>> https://github.com/junderw/bips/commit/57a57b4fae1ae14b77a2eebd99cd719148e3027e?short_path=82656c8#diff-82656c833e31e6751a412ce5e5c70920\n>> >\n>> > Plus side: for single sig case, the key only increases by one byte\n>> > (0x00 for the {m} value)\n>> >\n>> > This way if it was 2 of 3 like before, you sign the whole \"packet\" so\n>> > each key only signs the packet once. Way better than n!\n>> >\n>> > Anywho. Please send your feedback. Thanks.\n>> > Jonathan\n>> >\n>> > 2019\u5e746\u670827\u65e5(\u6728) 16:27 Dmitry Petukhov <dp at simplexum.com>:\n>> >\n>> > > How would signer know that there _should_ be at least 3 signatures\n>> > > signed by the key owned by this signer ?\n>> > >\n>> > > If it does not know that it should enforce 2of3 multisig, for\n>> > > example, the attacker that control only one key A can fool signer B\n>> > > by sending to 1of1 single-sig that is derived from A's xpub, and\n>> > > providing only sBxA in PSBT.\n>> > >\n>> > > If the signer does not have a hardcoded configuration that\n>> > > will mandate a particular multisig scheme, it will allow sending to\n>> > > any scheme.\n>> > >\n>> > > If the signer has a rich enough state to store updatable\n>> > > configuration, it can just store the trusted xpubs directly.\n>> > >\n>> > > Alternatively, signer can sign not individual xpubs, but whole xpub\n>> > > packages that correspond to particular multisig configuration, and\n>> > > enforce that destination addresses correspond to this configuration.\n>> > >\n>> > > But this would not be possible with your PSBT scheme that uses\n>> > > individual key-xpub pairs.\n>> > >\n>> > > \u0412 Thu, 27 Jun 2019 14:07:47 +0900\n>> > > Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:\n>> > >\n>> > > > Thanks for the reply.\n>> > > >\n>> > > > The way we would do it is:\n>> > > >\n>> > > > Let's say we have 3 cold keys for multisig: A B and C\n>> > > >\n>> > > > Whose xpubs are: xA xB and xC\n>> > > >\n>> > > > We all sign each other's xpubs, whose signatures are:\n>> > > > sAxB\n>> > > > sAxC\n>> > > > sBxA\n>> > > > sBxC\n>> > > > sCxA\n>> > > > sCxB\n>> > > >\n>> > > > We can then create a wallet that says \"when verifying change with\n>> > > > 0x01 global type proposed by Andrew Chow, if the change is\n>> > > > multisig, we MUST require the other pubkeys to have signatures\n>> > > > via my 0x02 proposal\"\n>> > > >\n>> > > > This way, all my PSBTs for my cold will have:\n>> > > > 1. an 0x01 entry to tell me how to get my change.\n>> > > > 2. All 6 of the signatures above.\n>> > > >\n>> > > > And the signer will then look at the change, check my pubkey by\n>> > > > deriving the xpub and checking equality to the BIP_DERIVATION of\n>> > > > the output... it will then check the OTHER pubkeys via\n>> > > > BIP32_DERIVATION to master fingerprint, then link that\n>> > > > fingerprint to a 0x02 sig from MY key, verifying all pubkeys.\n>> > > >\n>> > > > So this proposal of mine would not only fix the \"send to address\n>> > > > verification\" problem for HD, but also the multisig change problem\n>> > > > with 0x01.\n>> > > >\n>> > > > Cool.\n>> > > >\n>> > > > Only thing that is kind of sad is having to include n! (of m-of-n)\n>> > > > signatures in every PSBT... but tbh, the PSBT size is not of much\n>> > > > concern.\n>> > > >\n>> > > > Thanks for the reply.\n>> > > > - Jonathan\n>> > > >\n>> > > >\n>> > > > 2019\u5e746\u670827\u65e5(\u6728) 13:49 Dmitry Petukhov <dp at simplexum.com>:\n>> > > >\n>> > > > > Hi!\n>> > > > >\n>> > > > > I wonder how your scheme handles multisig ?\n>> > > > >\n>> > > > > As I understand, you sign individual xpubs with cold keys, so\n>> > > > > that cold keys can check destination addresses are trusted.\n>> > > > >\n>> > > > > I seems to me that if you sign individual xpubs of a multisig\n>> > > > > warm wallet, and one key from that multisig is compromized,\n>> > > > > attackers can then create a single-sig destination address that\n>> > > > > they control, and move the coins in a chain of two\n>> > > > > transactions, first to this single-sig address, and then to an\n>> > > > > address that they independently control.\n>> > > > >\n>> > > > > My idea to prevent this [1] is to sign the whole 'xpub package'\n>> > > > > of the multisig wallet, but there is also an issue of 'partial\n>> > > > > compromize', where some of the keys in a multisig warm wallet is\n>> > > > > compromized, and you do not want to regard a particular 'xpub\n>> > > > > package' as trusted. My idea was [2] to use an auxiliary message\n>> > > > > that would be signed along with the 'xpub package', and that\n>> > > > > message can include specific 'epoch' word that hardware wallet\n>> > > > > can show prominently before signing, or have 'serial number'\n>> > > > > for xpub packages (but that will require to store last known\n>> > > > > serial inside hw wallet, making it stateful).\n>> > > > >\n>> > > > > I like the idea to extend PSBT to accomodate these schemes, but\n>> > > > > given that the huge number of possible schemes that each may\n>> > > > > probably require its own PSBT field type, I think that this is\n>> > > > > better dealt with outside of PSBT, as 'PSBT metainformation', or\n>> > > > > using some form of 'vendor-specific', or\n>> > > > > 'metainformation-specific' PSBT field. This way each usecase\n>> > > > > can be independently described in its own documentation, that\n>> > > > > would include the particulars of the format for the\n>> > > > > metainformation. This would also make it easier to implement\n>> > > > > PSBT for simple cases, because the 'core specification' would\n>> > > > > not grow that big.\n>> > > > >\n>> > > > > [1]\n>> > > > >\n>> > > > >\n>> > >\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016917.html\n>>\n>> > > > >\n>> > > > > [2]\n>> > > > >\n>> > > > >\n>> > >\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016926.html\n>>\n>> > > > >\n>> > > > >\n>> > > > > \u0412 Thu, 27 Jun 2019 11:11:23 +0900 Jonathan Underwood via\n>> > > > > bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> > > > >\n>> > > > > > Hello all,\n>> > > > > >\n>> > > > > > Just wanted to pick your brains about an idea for PSBT\n>> > > > > > extension.\n>> > > > > >\n>> > > > > > One problem we try to solve with cold -> warm and warm -> hot\n>> > > > > > sends for our exchange wallet is \"How do I know that the\n>> > > > > > address I am sending to is not a hacker's address that was\n>> > > > > > swapped in between unsigned tx creation and first signature?\"\n>> > > > > >\n>> > > > > > We have a proprietary JSON based encoding system which we are\n>> > > > > > looking to move towards PSBT, but PSBT is missing this key\n>> > > > > > functionality.\n>> > > > > >\n>> > > > > > BIP32_DERIVATION does allow us to verify the address is from a\n>> > > > > > certain XPUB, but, for example, it can not allow us to verify\n>> > > > > > a signature of that xpub.\n>> > > > > >\n>> > > > > > I have made a rough draft of the proposed key value\n>> > > > > > specification.\n>> > > > >\n>> > >\n>> https://github.com/junderw/bips/blob/addXpubSig/bip-0174.mediawiki#specification\n>> > >\n>> > > > > >\n>> > > > > > The signing key path used in the spec is just randomly chosen\n>> > > > > > 31 x 4 bits shown as numbers with hardened paths.\n>> > > > > >\n>> > > > > > Since this issue seems similar to the change address issue, I\n>> > > > > > started from that as a base. With the HW wallet case, I can\n>> > > > > > verify the xpub by just deriving it locally and comparing\n>> > > > > > equality, however, in our case, we need to verify an xpub\n>> > > > > > that we do not have access to via derivation from our cold\n>> > > > > > key(s) (since we don't want to import our warm private key\n>> > > > > > into our cold signer)\n>> > > > > >\n>> > > > > > So the flow would be:\n>> > > > > > 1. Securely verify the xpub of the warm / hot wallet.\n>> > > > > > 2. Using the airgap signing tool, sign the xpub with all cold\n>> > > > > > keys. 3. Upload the signature/xpub pairs to the online\n>> > > > > > unsigned transaction generator.\n>> > > > > > 4. Include one keyval pair per coldkey/xpub pairing.\n>> > > > > > 5. When offline signing, if the wallet detects there is a\n>> > > > > > global keyval XPUB_SIGNATURE with its pubkey in the key, it\n>> > > > > > must verify that all outputs have BIP32_DERIVATION and that\n>> > > > > > it can verify the outputs through the derivation, to the\n>> > > > > > xpub, and to the signature.\n>> > > > > >\n>> > > > > > In my attempt to fitting this into PSBT, I am slightly\n>> > > > > > altering our current system, so don't take this as an\n>> > > > > > indication 100% of how we work in the backend.\n>> > > > > >\n>> > > > > > However, I would like to hear any feedback on this proposal.\n>> > > > > >\n>> > > > > > Thanks,\n>> > > > > > Jonathan\n>> > > > > >\n>> > > > >\n>> > > > >\n>> > > >\n>> > >\n>> > >\n>> >\n>>\n>>\n>\n> --\n> -----------------\n> Jonathan Underwood\n> \u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n> -----------------\n>\n> \u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n>\n> \u6307\u7d0b: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3\n>\n\n\n-- \n-----------------\nJonathan Underwood\n\u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n-----------------\n\n\u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n\n\u6307\u7d0b: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190627/c0a55da6/attachment-0001.html>"
            },
            {
                "author": "Jonathan Underwood",
                "date": "2019-06-27T09:32:46",
                "message_text_only": "There is no need, as you can look at the number of xpubs and use that as n.\n\nYour wallet will not allow {m=2}{xpub1}{xpub2} signed message to vouch for\n2 of 4 because you signed 2 of 2 where the n is shown by the number of\nxpubs signed.\n\nThere is no need to add the extra byte, except maybe to help people who are\nimplementing a wallet checking some features to remember to check for the\nnumber of total keys.\n\n----\n\nThe expire / revoke problem is a larger problem than this feature can\nhandle.\n\nIn general, if one of the cold keys is stolen, there is rarely a situation\nwhere you are completely sure the other cold keys haven't been\ncompromised... so the best practice would be all signers generate new keys\nand all funds are moved to a completely new multisig wallet (no common\nxpubs).\n\n- Jonathan\n\n2019\u5e746\u670827\u65e5(\u6728) 18:20 Dmitry Petukhov <dp at simplexum.com>:\n\n> You're right re order of the keys, I forgot that redeem/witness\n> scripts are included in outputs.\n>\n> But regarding the number of the keys, you need to always include all of\n> xpubs, because otherwise, if you only put `m` in PSBT, and you use\n> 2of3, for example, attacker may put 2 as `m`, two of your xpubs, but\n> then use redeem/witness scripts for 2of4, where two other keys are\n> under attacker's control.\n>\n> If you only encode `n`, and allow any 'm of n' scheme, then in 2of3\n> case, if the attackers have control of only one of the keys, they can\n> use redeem/witness scripts for 1of3, where two other keys are under\n> their control.\n>\n> It seems to me that you need to sign the whole configuration:\n> `n`, `m`, and the xpubs.\n>\n> And then there's a question of how to conveniently `expire` the keys\n> that were compromized. If the attackers have a signature of\n> `n+n+xpubs` package for some configuration that include the keys that\n> was compromized, they can use that old signed package to fool the\n> signer.\n>\n> Signer would need to somehow distinguish between old and new\n> configurations, or you would need to change the keys in all the signers\n> even if one is compromized, so the already-signed packages would become\n> invalid.\n>\n> You could do without changing all the keys when only one is compromized\n> by including a serial number in the xpub package (but that means signer\n> will need to have a state where it would store the latest serial\n> number), or you need some message to be included in the package that a\n> human can check when manually signing, to ensure that 'obsolete' xpub\n> package was not used.\n>\n> \u0412 Thu, 27 Jun 2019 17:56:06 +0900\n> Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:\n>\n> > The output will have redeemscript and witnessscript so order is not\n> > necessary. I can just look at the multisig script and find the pubkey\n> > inside it.\n> >\n> > -Jonathan\n> >\n> > 2019\u5e746\u670827\u65e5(\u6728) 17:45 Dmitry Petukhov <dp at simplexum.com>:\n> >\n> > > > m value for a multisig (set 0 for non-multisig), followed by 1 or\n> > > > more 78 byte serialized extended public keys sorted in canonical\n> > > > order\n> > >\n> > > Sorting xpubs would work if the addresses also sort their pubkeys\n> > > (like in BIP67)\n> > >\n> > > But if the pubkey order in address creation is fixed, you better\n> > > have the fixed order for xpubs, otherwise you would need to try all\n> > > combinations of derived pubkeys when checking if the addresss match\n> > > the presented xpubs. That would be factorial of the number of keys,\n> > > not feasible beyond very small number of keys.\n> > >\n> > > Bitcoin Core, for example, currently does not support BIP67 and\n> > > supports only fixed pubkey positions in their script descriptors\n> > > specification.\n> > >\n> > > You also need to include all xpubs to match the address, for m of n\n> > > standard multisig, you need to include n and check that number of\n> > > keys is exactly n.\n> > >\n> > > Otherwise your would not be able to construct the address to\n> > > compare to the destination address that you need to check, as you\n> > > need all pubkesy to construct P2SH or P2WSH address.\n> > >\n> > > With Shnorr-musig, you probably can interpolate the combined pubkey\n> > > out of m paticpant pubkeys (but don't cite me on this, I might be\n> > > wrong)\n> > >\n> > > \u0412 Thu, 27 Jun 2019 17:16:14 +0900\n> > > Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:\n> > >\n> > > > I see what you mean.\n> > > >\n> > > > What about this?\n> > > >\n> > >\n> https://github.com/junderw/bips/commit/57a57b4fae1ae14b77a2eebd99cd719148e3027e?short_path=82656c8#diff-82656c833e31e6751a412ce5e5c70920\n>\n> > > >\n> > > > Plus side: for single sig case, the key only increases by one byte\n> > > > (0x00 for the {m} value)\n> > > >\n> > > > This way if it was 2 of 3 like before, you sign the whole\n> > > > \"packet\" so each key only signs the packet once. Way better than\n> > > > n!\n> > > >\n> > > > Anywho. Please send your feedback. Thanks.\n> > > > Jonathan\n> > > >\n> > > > 2019\u5e746\u670827\u65e5(\u6728) 16:27 Dmitry Petukhov <dp at simplexum.com>:\n> > > >\n> > > > > How would signer know that there _should_ be at least 3\n> > > > > signatures signed by the key owned by this signer ?\n> > > > >\n> > > > > If it does not know that it should enforce 2of3 multisig, for\n> > > > > example, the attacker that control only one key A can fool\n> > > > > signer B by sending to 1of1 single-sig that is derived from A's\n> > > > > xpub, and providing only sBxA in PSBT.\n> > > > >\n> > > > > If the signer does not have a hardcoded configuration that\n> > > > > will mandate a particular multisig scheme, it will allow\n> > > > > sending to any scheme.\n> > > > >\n> > > > > If the signer has a rich enough state to store updatable\n> > > > > configuration, it can just store the trusted xpubs directly.\n> > > > >\n> > > > > Alternatively, signer can sign not individual xpubs, but whole\n> > > > > xpub packages that correspond to particular multisig\n> > > > > configuration, and enforce that destination addresses\n> > > > > correspond to this configuration.\n> > > > >\n> > > > > But this would not be possible with your PSBT scheme that uses\n> > > > > individual key-xpub pairs.\n> > > > >\n> > > > > \u0412 Thu, 27 Jun 2019 14:07:47 +0900\n> > > > > Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:\n> > > > >\n> > > > > > Thanks for the reply.\n> > > > > >\n> > > > > > The way we would do it is:\n> > > > > >\n> > > > > > Let's say we have 3 cold keys for multisig: A B and C\n> > > > > >\n> > > > > > Whose xpubs are: xA xB and xC\n> > > > > >\n> > > > > > We all sign each other's xpubs, whose signatures are:\n> > > > > > sAxB\n> > > > > > sAxC\n> > > > > > sBxA\n> > > > > > sBxC\n> > > > > > sCxA\n> > > > > > sCxB\n> > > > > >\n> > > > > > We can then create a wallet that says \"when verifying change\n> > > > > > with 0x01 global type proposed by Andrew Chow, if the change\n> > > > > > is multisig, we MUST require the other pubkeys to have\n> > > > > > signatures via my 0x02 proposal\"\n> > > > > >\n> > > > > > This way, all my PSBTs for my cold will have:\n> > > > > > 1. an 0x01 entry to tell me how to get my change.\n> > > > > > 2. All 6 of the signatures above.\n> > > > > >\n> > > > > > And the signer will then look at the change, check my pubkey\n> > > > > > by deriving the xpub and checking equality to the\n> > > > > > BIP_DERIVATION of the output... it will then check the OTHER\n> > > > > > pubkeys via BIP32_DERIVATION to master fingerprint, then link\n> > > > > > that fingerprint to a 0x02 sig from MY key, verifying all\n> > > > > > pubkeys.\n> > > > > >\n> > > > > > So this proposal of mine would not only fix the \"send to\n> > > > > > address verification\" problem for HD, but also the multisig\n> > > > > > change problem with 0x01.\n> > > > > >\n> > > > > > Cool.\n> > > > > >\n> > > > > > Only thing that is kind of sad is having to include n! (of\n> > > > > > m-of-n) signatures in every PSBT... but tbh, the PSBT size is\n> > > > > > not of much concern.\n> > > > > >\n> > > > > > Thanks for the reply.\n> > > > > > - Jonathan\n> > > > > >\n> > > > > >\n> > > > > > 2019\u5e746\u670827\u65e5(\u6728) 13:49 Dmitry Petukhov <dp at simplexum.com>:\n> > > > > >\n> > > > > > > Hi!\n> > > > > > >\n> > > > > > > I wonder how your scheme handles multisig ?\n> > > > > > >\n> > > > > > > As I understand, you sign individual xpubs with cold keys,\n> > > > > > > so that cold keys can check destination addresses are\n> > > > > > > trusted.\n> > > > > > >\n> > > > > > > I seems to me that if you sign individual xpubs of a\n> > > > > > > multisig warm wallet, and one key from that multisig is\n> > > > > > > compromized, attackers can then create a single-sig\n> > > > > > > destination address that they control, and move the coins\n> > > > > > > in a chain of two transactions, first to this single-sig\n> > > > > > > address, and then to an address that they independently\n> > > > > > > control.\n> > > > > > >\n> > > > > > > My idea to prevent this [1] is to sign the whole 'xpub\n> > > > > > > package' of the multisig wallet, but there is also an issue\n> > > > > > > of 'partial compromize', where some of the keys in a\n> > > > > > > multisig warm wallet is compromized, and you do not want to\n> > > > > > > regard a particular 'xpub package' as trusted. My idea was\n> > > > > > > [2] to use an auxiliary message that would be signed along\n> > > > > > > with the 'xpub package', and that message can include\n> > > > > > > specific 'epoch' word that hardware wallet can show\n> > > > > > > prominently before signing, or have 'serial number' for\n> > > > > > > xpub packages (but that will require to store last known\n> > > > > > > serial inside hw wallet, making it stateful).\n> > > > > > >\n> > > > > > > I like the idea to extend PSBT to accomodate these schemes,\n> > > > > > > but given that the huge number of possible schemes that\n> > > > > > > each may probably require its own PSBT field type, I think\n> > > > > > > that this is better dealt with outside of PSBT, as 'PSBT\n> > > > > > > metainformation', or using some form of 'vendor-specific',\n> > > > > > > or 'metainformation-specific' PSBT field. This way each\n> > > > > > > usecase can be independently described in its own\n> > > > > > > documentation, that would include the particulars of the\n> > > > > > > format for the metainformation. This would also make it\n> > > > > > > easier to implement PSBT for simple cases, because the\n> > > > > > > 'core specification' would not grow that big.\n> > > > > > >\n> > > > > > > [1]\n> > > > > > >\n> > > > > > >\n> > > > >\n> > >\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016917.html\n> > >\n> > > > > > >\n> > > > > > > [2]\n> > > > > > >\n> > > > > > >\n> > > > >\n> > >\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016926.html\n> > >\n> > > > > > >\n> > > > > > >\n> > > > > > > \u0412 Thu, 27 Jun 2019 11:11:23 +0900 Jonathan Underwood via\n> > > > > > > bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > > > > > >\n> > > > > > > > Hello all,\n> > > > > > > >\n> > > > > > > > Just wanted to pick your brains about an idea for PSBT\n> > > > > > > > extension.\n> > > > > > > >\n> > > > > > > > One problem we try to solve with cold -> warm and warm ->\n> > > > > > > > hot sends for our exchange wallet is \"How do I know that\n> > > > > > > > the address I am sending to is not a hacker's address\n> > > > > > > > that was swapped in between unsigned tx creation and\n> > > > > > > > first signature?\"\n> > > > > > > >\n> > > > > > > > We have a proprietary JSON based encoding system which we\n> > > > > > > > are looking to move towards PSBT, but PSBT is missing\n> > > > > > > > this key functionality.\n> > > > > > > >\n> > > > > > > > BIP32_DERIVATION does allow us to verify the address is\n> > > > > > > > from a certain XPUB, but, for example, it can not allow\n> > > > > > > > us to verify a signature of that xpub.\n> > > > > > > >\n> > > > > > > > I have made a rough draft of the proposed key value\n> > > > > > > > specification.\n> > > > > > >\n> > > > >\n> > >\n> https://github.com/junderw/bips/blob/addXpubSig/bip-0174.mediawiki#specification\n>\n> > > > >\n> > > > > > > >\n> > > > > > > > The signing key path used in the spec is just randomly\n> > > > > > > > chosen 31 x 4 bits shown as numbers with hardened paths.\n> > > > > > > >\n> > > > > > > > Since this issue seems similar to the change address\n> > > > > > > > issue, I started from that as a base. With the HW wallet\n> > > > > > > > case, I can verify the xpub by just deriving it locally\n> > > > > > > > and comparing equality, however, in our case, we need to\n> > > > > > > > verify an xpub that we do not have access to via\n> > > > > > > > derivation from our cold key(s) (since we don't want to\n> > > > > > > > import our warm private key into our cold signer)\n> > > > > > > >\n> > > > > > > > So the flow would be:\n> > > > > > > > 1. Securely verify the xpub of the warm / hot wallet.\n> > > > > > > > 2. Using the airgap signing tool, sign the xpub with all\n> > > > > > > > cold keys. 3. Upload the signature/xpub pairs to the\n> > > > > > > > online unsigned transaction generator.\n> > > > > > > > 4. Include one keyval pair per coldkey/xpub pairing.\n> > > > > > > > 5. When offline signing, if the wallet detects there is a\n> > > > > > > > global keyval XPUB_SIGNATURE with its pubkey in the key,\n> > > > > > > > it must verify that all outputs have BIP32_DERIVATION and\n> > > > > > > > that it can verify the outputs through the derivation, to\n> > > > > > > > the xpub, and to the signature.\n> > > > > > > >\n> > > > > > > > In my attempt to fitting this into PSBT, I am slightly\n> > > > > > > > altering our current system, so don't take this as an\n> > > > > > > > indication 100% of how we work in the backend.\n> > > > > > > >\n> > > > > > > > However, I would like to hear any feedback on this\n> > > > > > > > proposal.\n> > > > > > > >\n> > > > > > > > Thanks,\n> > > > > > > > Jonathan\n> > > > > > > >\n> > > > > > >\n> > > > > > >\n> > > > > >\n> > > > >\n> > > > >\n> > > >\n> > >\n> > >\n> >\n>\n>\n\n-- \n-----------------\nJonathan Underwood\n\u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n-----------------\n\n\u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n\n\u6307\u7d0b: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190627/6e5ce627/attachment-0001.html>"
            },
            {
                "author": "Peter D. Gray",
                "date": "2019-06-27T15:07:45",
                "message_text_only": "I haven't studied the new proposal in depth, but my first impression is:\n\nWouldn't it just be easier and better to just sign the entire \"outputs\" section of the PSBT?\n\nThe signature would cover every byte, and therefore would cover any\nfuture BIP additions to the outputs area, and also help non-multisig\ncases today.\n\n---\nPeter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10"
            },
            {
                "author": "Jonathan Underwood",
                "date": "2019-06-28T02:44:15",
                "message_text_only": "Hi Peter,\n\ntl;dr The problem this solves is \"How can a signer verify an address with\nHD changing the address every time?\"\n\nAs an aside: (This is sort of explaining the current PR for the 0x01 global\nfield (separate from mine))\nThe problem is more easily understood with change addresses: If someone can\nalter my PSBT before signing, they could replace my change address with\ntheir address, and my signer would not know unless the signer just guesses\nall the path sets it knows, then derives thousands of change addresses and\nsearches (most likely a signer is offline, so gap limit doesn't work since\nwe can't tell which change addresses have tx history. So the 0x01 global\ntag will tell the signer \"here's how you get from your master private key\nto the xpub used in the change output's output BIP32_DERIVATION tag... you\ncan then derive the same key and check it is yours before signing.\"\n\nBack to my proposal, this problem extends across wallets, since,\nfor example, if I want to send from my cold wallet to my warm wallet, I\ndon't want to give my cold signer my warm master key just so it can derive\nand check the key. That's what signatures are for. So this proposal says \"A\nsigner can be built to only sign if it sees a signature that itself has\nsigned, then from that signed xpub(s) derives the BIP32_DERIVATION in the\noutputs, and if the output doesn't match it will reject and not sign\"\n\nThis creates a sort of \"chain of trust\" for the wallet.\n\nCurrently the best way to prevent this (hacker swapping the send to\naddress) without using signatures is to reuse the same address every time\nyou want to send to the warm wallet, since after a few times, the signers\n(people) will be able to remember the address.\n\nThis is a huge HD drawback for high security requirement environments.\nHaving this data in the PSBT standard will allow Trezor etc. to create an\nenforceable whitelist feature.\n\nLet me know if you have feedback on the details.\n\nThanks,\nJon\n\n2019\u5e746\u670828\u65e5(\u91d1) 0:07 Peter D. Gray <peter at coinkite.com>:\n\n> I haven't studied the new proposal in depth, but my first impression is:\n>\n> Wouldn't it just be easier and better to just sign the entire \"outputs\"\n> section of the PSBT?\n>\n> The signature would cover every byte, and therefore would cover any\n> future BIP additions to the outputs area, and also help non-multisig\n> cases today.\n>\n> ---\n> Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG:\n> A3A31BAD 5A2A5B10\n>\n>\n\n-- \n-----------------\nJonathan Underwood\n\u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n-----------------\n\n\u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n\n\u6307\u7d0b: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190628/eee0ccf7/attachment.html>"
            },
            {
                "author": "Peter D. Gray",
                "date": "2019-06-28T14:37:55",
                "message_text_only": "Thanks I get the idea better now: You want the PSBT creator to be\nable to indicate to the signers that it (the PSBT creator) controls\nspecific outputs that don't otherwise look like change.\n\nSome problems:\n\n> extended private key of the current signer derived from the\n> signer's root to m/2042083607'/959190427'/1400854130'/990526201'\n\n1) The PSBT creator would need to know that private key, and the Coldcard, as a matter\n   of policy, will never export a private subkey.\n\n2) The 'm' in that path depends on who is reading the PSBT file, in the multisig\n   case. Each cosigner would need a different version of the PSBT file.\n\n3) XPUB's are big and hard to parse, and this addition is using lots of them.\n\n4) Coinjoins, and more complex script types, will want to authorize\n   outputs that the PSBT signer may not fully understand. Your proposal\n   would only help P2PKH and M-of-N multisig users.\n\nTo fix, may I propose:\n\n- the signer and PSBT creator must share a pubkey/private key out of band (setup time)\n- the origin of that key is out of scope of this standard (but it could be derived via BIP32)\n- the PSBT creator can, optionally, sign any or all output sections by number using that key\n\nI would prefer the signatures are in the global section, and the\nsignature is over all the bytes in the indicated output section,\nas originally serialized when it came into the signer's possession.\n\nWe should be able to support multiple signers for individual outputs,\nand also multiple signatures for the same output section. That would\nsupport different derived keys per co-signer, and also quorum\napproval or other policies like that.\n\nAfterthought: Might be good to allow signature over the unsigned transaction, or\nmaybe it should be part of the signature always.\n\n---\nPeter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10\n\nOn Fri, Jun 28, 2019 at 11:44:15AM +0900, Jonathan Underwood wrote:\n> Hi Peter,\n> \n> tl;dr The problem this solves is \"How can a signer verify an address with\n> HD changing the address every time?\"\n> \n> As an aside: (This is sort of explaining the current PR for the 0x01 global\n> field (separate from mine))\n> The problem is more easily understood with change addresses: If someone can\n> alter my PSBT before signing, they could replace my change address with\n> their address, and my signer would not know unless the signer just guesses\n> all the path sets it knows, then derives thousands of change addresses and\n> searches (most likely a signer is offline, so gap limit doesn't work since\n> we can't tell which change addresses have tx history. So the 0x01 global\n> tag will tell the signer \"here's how you get from your master private key\n> to the xpub used in the change output's output BIP32_DERIVATION tag... you\n> can then derive the same key and check it is yours before signing.\"\n> \n> Back to my proposal, this problem extends across wallets, since,\n> for example, if I want to send from my cold wallet to my warm wallet, I\n> don't want to give my cold signer my warm master key just so it can derive\n> and check the key. That's what signatures are for. So this proposal says \"A\n> signer can be built to only sign if it sees a signature that itself has\n> signed, then from that signed xpub(s) derives the BIP32_DERIVATION in the\n> outputs, and if the output doesn't match it will reject and not sign\"\n> \n> This creates a sort of \"chain of trust\" for the wallet.\n> \n> Currently the best way to prevent this (hacker swapping the send to\n> address) without using signatures is to reuse the same address every time\n> you want to send to the warm wallet, since after a few times, the signers\n> (people) will be able to remember the address.\n> \n> This is a huge HD drawback for high security requirement environments.\n> Having this data in the PSBT standard will allow Trezor etc. to create an\n> enforceable whitelist feature.\n> \n> Let me know if you have feedback on the details.\n> \n> Thanks,\n> Jon\n> \n> 2019\u5e746\u670828\u65e5(\u91d1) 0:07 Peter D. Gray <peter at coinkite.com>:\n> \n> > I haven't studied the new proposal in depth, but my first impression is:\n> >\n> > Wouldn't it just be easier and better to just sign the entire \"outputs\"\n> > section of the PSBT?\n> >\n> > The signature would cover every byte, and therefore would cover any\n> > future BIP additions to the outputs area, and also help non-multisig\n> > cases today.\n> >\n> > ---\n> > Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG:\n> > A3A31BAD 5A2A5B10\n> >\n> >\n> \n> -- \n> -----------------\n> Jonathan Underwood\n> \u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n> -----------------\n> \n> \u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n> \n> \u6307\u7d0b: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3"
            },
            {
                "author": "Jonathan Underwood",
                "date": "2019-06-28T15:00:22",
                "message_text_only": "Thanks for the reply Peter. Comments inline:\n\n2019\u5e746\u670828\u65e5(\u91d1) 23:37 Peter D. Gray <peter at coinkite.com>:\n\n> Thanks I get the idea better now: You want the PSBT creator to be\n> able to indicate to the signers that it (the PSBT creator) controls\n> specific outputs that don't otherwise look like change.\n>\n> Some problems:\n>\n> > extended private key of the current signer derived from the\n> > signer's root to m/2042083607'/959190427'/1400854130'/990526201'\n>\n> 1) The PSBT creator would need to know that private key, and the Coldcard,\n> as a matter\n>    of policy, will never export a private subkey.\n>\n\nI think you have misunderstood. The signature inserted into this 0x02 field\nis generated BY the signer (Coldkey) airgapped ahead of time. Then the\nsignature (and all the xpubs that were signed, since basically the \"key\"\nvalue contains the \"pubkey\" and \"message\" while the \"value\" part has the\n\"signature\". so all data items for verification are present.) will be\nstored on the unsigned transaction preparing app. (MyTrezor dot com etc.\nhave an encrypted storage through Dropbox + encrypting with Trezor, so\nthey, for instance, could store the \"whitelist signatures\" on that dropbox\nfeature.\n\n\n> 2) The 'm' in that path depends on who is reading the PSBT file, in the\n> multisig\n>    case. Each cosigner would need a different version of the PSBT file\n\n\nAgain, this is the m of the signer's root. The signer should have an xprv,\nor some sort of seed (a la BIP39 or aezeed or Electrum phrase etc.) that\ngets turned into a xprv. That xprv is m in this case... in the case that\nsome offline signer is storing the xprv of some path like \"xprv/25'/42'\" or\nsomething, then the signer's \"identity\" is whatever xprv that signer holds\nand not any of the xprvs derived from that first xprv.\n\nThe reason we want only one HD key to sign it is because we want the signer\nto be able to generate that path from the root xprv they hold, check that\nthe pubkey matched the pubkey for verification, then verify. Now the signer\nknows \"oh, I have signed this xpub / multisig setup before, therefore I\ntrust it\"\n\n\n> 3) XPUB's are big and hard to parse, and this addition is using lots of\n> them.\n>\n\nAny app requiring this level of security would gladly add a few millisecond\nfor parsing some xpubs.\nAny HD wallet that can sign using HD derived keys already has the necessary\ntools to parse an xpub.\n\n\n> 4) Coinjoins, and more complex script types, will want to authorize\n>    outputs that the PSBT signer may not fully understand. Your proposal\n>    would only help P2PKH and M-of-N multisig users.\n>\n\nYes. This proposal is not a requirement. It is just a reservation for a\nslot in the key-value scheme for a use case that many exchanges and\nhardware wallets should implement. We have implemented something similar to\nthis using JSON format internally, but since HW wallet makers seem to be\nmoving toward PSBT adoption, I would love for this info to be possible to\nbe sent into an HW wallet so that Trezor etc. can implement this\n\"whitelist\" type situation in a way that the Trezor can trust. (remember, a\n\"whitelist\" that just lives in my trezor dot com website cache etc. is\nprone to modification, whereas with my proposal the worst case is a hacker\ndeletes a signature, so Trezor doesn't trust something it should have, and\nfails signing. It can not add itself to the \"whitelist\" without the HW\nwallet private key.)\n\nTo fix, may I propose:\n>\n>\nThe following suggestions seems to be predicated on a misunderstanding of\nmy proposal, so I will hold off for now.\n\n\n> - the signer and PSBT creator must share a pubkey/private key out of band\n> (setup time)\n> - the origin of that key is out of scope of this standard (but it could be\n> derived via BIP32)\n> - the PSBT creator can, optionally, sign any or all output sections by\n> number using that key\n>\n> I would prefer the signatures are in the global section, and the\n> signature is over all the bytes in the indicated output section,\n> as originally serialized when it came into the signer's possession.\n>\n> We should be able to support multiple signers for individual outputs,\n> and also multiple signatures for the same output section. That would\n> support different derived keys per co-signer, and also quorum\n> approval or other policies like that.\n>\n> Afterthought: Might be good to allow signature over the unsigned\n> transaction, or\n> maybe it should be part of the signature always.\n>\n> ---\n> Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG:\n> A3A31BAD 5A2A5B10\n>\n> On Fri, Jun 28, 2019 at 11:44:15AM +0900, Jonathan Underwood wrote:\n> > Hi Peter,\n> >\n> > tl;dr The problem this solves is \"How can a signer verify an address with\n> > HD changing the address every time?\"\n> >\n> > As an aside: (This is sort of explaining the current PR for the 0x01\n> global\n> > field (separate from mine))\n> > The problem is more easily understood with change addresses: If someone\n> can\n> > alter my PSBT before signing, they could replace my change address with\n> > their address, and my signer would not know unless the signer just\n> guesses\n> > all the path sets it knows, then derives thousands of change addresses\n> and\n> > searches (most likely a signer is offline, so gap limit doesn't work\n> since\n> > we can't tell which change addresses have tx history. So the 0x01 global\n> > tag will tell the signer \"here's how you get from your master private key\n> > to the xpub used in the change output's output BIP32_DERIVATION tag...\n> you\n> > can then derive the same key and check it is yours before signing.\"\n> >\n> > Back to my proposal, this problem extends across wallets, since,\n> > for example, if I want to send from my cold wallet to my warm wallet, I\n> > don't want to give my cold signer my warm master key just so it can\n> derive\n> > and check the key. That's what signatures are for. So this proposal says\n> \"A\n> > signer can be built to only sign if it sees a signature that itself has\n> > signed, then from that signed xpub(s) derives the BIP32_DERIVATION in the\n> > outputs, and if the output doesn't match it will reject and not sign\"\n> >\n> > This creates a sort of \"chain of trust\" for the wallet.\n> >\n> > Currently the best way to prevent this (hacker swapping the send to\n> > address) without using signatures is to reuse the same address every time\n> > you want to send to the warm wallet, since after a few times, the signers\n> > (people) will be able to remember the address.\n> >\n> > This is a huge HD drawback for high security requirement environments.\n> > Having this data in the PSBT standard will allow Trezor etc. to create an\n> > enforceable whitelist feature.\n> >\n> > Let me know if you have feedback on the details.\n> >\n> > Thanks,\n> > Jon\n> >\n> > 2019\u5e746\u670828\u65e5(\u91d1) 0:07 Peter D. Gray <peter at coinkite.com>:\n> >\n> > > I haven't studied the new proposal in depth, but my first impression\n> is:\n> > >\n> > > Wouldn't it just be easier and better to just sign the entire \"outputs\"\n> > > section of the PSBT?\n> > >\n> > > The signature would cover every byte, and therefore would cover any\n> > > future BIP additions to the outputs area, and also help non-multisig\n> > > cases today.\n> > >\n> > > ---\n> > > Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG:\n> > > A3A31BAD 5A2A5B10\n> > >\n> > >\n> >\n> > --\n> > -----------------\n> > Jonathan Underwood\n> > \u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n> > -----------------\n> >\n> > \u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n> >\n> > \u6307\u7d0b: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3\n>\n\n\n-- \n-----------------\nJonathan Underwood\n\u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n-----------------\n\n\u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n\n\u6307\u7d0b: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190629/4b55a1c7/attachment-0001.html>"
            },
            {
                "author": "Jonathan Underwood",
                "date": "2019-06-27T09:52:28",
                "message_text_only": "> By the way, why is this particular path ?\n\nThe signing key path used in the spec is just randomly chosen 31 x 4 bits\nshown as numbers with hardened paths. Just wanted to make sure it wasn't a\nkey that people are likely to use for something else.\n\n> It is not clear to me what public key this refers to\n\nI just used the same sentence from the other proposal for 0x01 global tag.\nIt is kind of confusing, but \"can be derived\" implies that it is referring\nto an xpub, since normal public keys can not \"derive children\"...\n\nBut I could change it if it would be clearer.\n\n2019\u5e746\u670827\u65e5(\u6728) 18:47 Dmitry Petukhov <dp at simplexum.com>:\n\n> \" It should be the public key at the highest hardened derivation index\n> so that the unhardened child keys used in the transaction can be\n> derived.\"\n>\n> It is not clear to me what public key this refers to - does this\n> refer to 'signing pubkey' ? - then the exact derivation indexes for that\n> are given in the value section:\n>\n>    m/2042083607'/959190427'/1400854130'/990526201'\n>\n> By the way, why is this particular path ?\n>\n> \u0412 Thu, 27 Jun 2019 17:16:14 +0900\n> Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:\n>\n> > I see what you mean.\n> >\n> > What about this?\n> >\n> https://github.com/junderw/bips/commit/57a57b4fae1ae14b77a2eebd99cd719148e3027e?short_path=82656c8#diff-82656c833e31e6751a412ce5e5c70920\n> >\n> > Plus side: for single sig case, the key only increases by one byte\n> > (0x00 for the {m} value)\n> >\n> > This way if it was 2 of 3 like before, you sign the whole \"packet\" so\n> > each key only signs the packet once. Way better than n!\n> >\n> > Anywho. Please send your feedback. Thanks.\n> > Jonathan\n> >\n> > 2019\u5e746\u670827\u65e5(\u6728) 16:27 Dmitry Petukhov <dp at simplexum.com>:\n> >\n> > > How would signer know that there _should_ be at least 3 signatures\n> > > signed by the key owned by this signer ?\n> > >\n> > > If it does not know that it should enforce 2of3 multisig, for\n> > > example, the attacker that control only one key A can fool signer B\n> > > by sending to 1of1 single-sig that is derived from A's xpub, and\n> > > providing only sBxA in PSBT.\n> > >\n> > > If the signer does not have a hardcoded configuration that\n> > > will mandate a particular multisig scheme, it will allow sending to\n> > > any scheme.\n> > >\n> > > If the signer has a rich enough state to store updatable\n> > > configuration, it can just store the trusted xpubs directly.\n> > >\n> > > Alternatively, signer can sign not individual xpubs, but whole xpub\n> > > packages that correspond to particular multisig configuration, and\n> > > enforce that destination addresses correspond to this configuration.\n> > >\n> > > But this would not be possible with your PSBT scheme that uses\n> > > individual key-xpub pairs.\n> > >\n> > > \u0412 Thu, 27 Jun 2019 14:07:47 +0900\n> > > Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:\n> > >\n> > > > Thanks for the reply.\n> > > >\n> > > > The way we would do it is:\n> > > >\n> > > > Let's say we have 3 cold keys for multisig: A B and C\n> > > >\n> > > > Whose xpubs are: xA xB and xC\n> > > >\n> > > > We all sign each other's xpubs, whose signatures are:\n> > > > sAxB\n> > > > sAxC\n> > > > sBxA\n> > > > sBxC\n> > > > sCxA\n> > > > sCxB\n> > > >\n> > > > We can then create a wallet that says \"when verifying change with\n> > > > 0x01 global type proposed by Andrew Chow, if the change is\n> > > > multisig, we MUST require the other pubkeys to have signatures\n> > > > via my 0x02 proposal\"\n> > > >\n> > > > This way, all my PSBTs for my cold will have:\n> > > > 1. an 0x01 entry to tell me how to get my change.\n> > > > 2. All 6 of the signatures above.\n> > > >\n> > > > And the signer will then look at the change, check my pubkey by\n> > > > deriving the xpub and checking equality to the BIP_DERIVATION of\n> > > > the output... it will then check the OTHER pubkeys via\n> > > > BIP32_DERIVATION to master fingerprint, then link that\n> > > > fingerprint to a 0x02 sig from MY key, verifying all pubkeys.\n> > > >\n> > > > So this proposal of mine would not only fix the \"send to address\n> > > > verification\" problem for HD, but also the multisig change problem\n> > > > with 0x01.\n> > > >\n> > > > Cool.\n> > > >\n> > > > Only thing that is kind of sad is having to include n! (of m-of-n)\n> > > > signatures in every PSBT... but tbh, the PSBT size is not of much\n> > > > concern.\n> > > >\n> > > > Thanks for the reply.\n> > > > - Jonathan\n> > > >\n> > > >\n> > > > 2019\u5e746\u670827\u65e5(\u6728) 13:49 Dmitry Petukhov <dp at simplexum.com>:\n> > > >\n> > > > > Hi!\n> > > > >\n> > > > > I wonder how your scheme handles multisig ?\n> > > > >\n> > > > > As I understand, you sign individual xpubs with cold keys, so\n> > > > > that cold keys can check destination addresses are trusted.\n> > > > >\n> > > > > I seems to me that if you sign individual xpubs of a multisig\n> > > > > warm wallet, and one key from that multisig is compromized,\n> > > > > attackers can then create a single-sig destination address that\n> > > > > they control, and move the coins in a chain of two\n> > > > > transactions, first to this single-sig address, and then to an\n> > > > > address that they independently control.\n> > > > >\n> > > > > My idea to prevent this [1] is to sign the whole 'xpub package'\n> > > > > of the multisig wallet, but there is also an issue of 'partial\n> > > > > compromize', where some of the keys in a multisig warm wallet is\n> > > > > compromized, and you do not want to regard a particular 'xpub\n> > > > > package' as trusted. My idea was [2] to use an auxiliary message\n> > > > > that would be signed along with the 'xpub package', and that\n> > > > > message can include specific 'epoch' word that hardware wallet\n> > > > > can show prominently before signing, or have 'serial number'\n> > > > > for xpub packages (but that will require to store last known\n> > > > > serial inside hw wallet, making it stateful).\n> > > > >\n> > > > > I like the idea to extend PSBT to accomodate these schemes, but\n> > > > > given that the huge number of possible schemes that each may\n> > > > > probably require its own PSBT field type, I think that this is\n> > > > > better dealt with outside of PSBT, as 'PSBT metainformation', or\n> > > > > using some form of 'vendor-specific', or\n> > > > > 'metainformation-specific' PSBT field. This way each usecase\n> > > > > can be independently described in its own documentation, that\n> > > > > would include the particulars of the format for the\n> > > > > metainformation. This would also make it easier to implement\n> > > > > PSBT for simple cases, because the 'core specification' would\n> > > > > not grow that big.\n> > > > >\n> > > > > [1]\n> > > > >\n> > > > >\n> > >\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016917.html\n>\n> > > > >\n> > > > > [2]\n> > > > >\n> > > > >\n> > >\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016926.html\n>\n> > > > >\n> > > > >\n> > > > > \u0412 Thu, 27 Jun 2019 11:11:23 +0900 Jonathan Underwood via\n> > > > > bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > > > >\n> > > > > > Hello all,\n> > > > > >\n> > > > > > Just wanted to pick your brains about an idea for PSBT\n> > > > > > extension.\n> > > > > >\n> > > > > > One problem we try to solve with cold -> warm and warm -> hot\n> > > > > > sends for our exchange wallet is \"How do I know that the\n> > > > > > address I am sending to is not a hacker's address that was\n> > > > > > swapped in between unsigned tx creation and first signature?\"\n> > > > > >\n> > > > > > We have a proprietary JSON based encoding system which we are\n> > > > > > looking to move towards PSBT, but PSBT is missing this key\n> > > > > > functionality.\n> > > > > >\n> > > > > > BIP32_DERIVATION does allow us to verify the address is from a\n> > > > > > certain XPUB, but, for example, it can not allow us to verify\n> > > > > > a signature of that xpub.\n> > > > > >\n> > > > > > I have made a rough draft of the proposed key value\n> > > > > > specification.\n> > > > >\n> > >\n> https://github.com/junderw/bips/blob/addXpubSig/bip-0174.mediawiki#specification\n> > >\n> > > > > >\n> > > > > > The signing key path used in the spec is just randomly chosen\n> > > > > > 31 x 4 bits shown as numbers with hardened paths.\n> > > > > >\n> > > > > > Since this issue seems similar to the change address issue, I\n> > > > > > started from that as a base. With the HW wallet case, I can\n> > > > > > verify the xpub by just deriving it locally and comparing\n> > > > > > equality, however, in our case, we need to verify an xpub\n> > > > > > that we do not have access to via derivation from our cold\n> > > > > > key(s) (since we don't want to import our warm private key\n> > > > > > into our cold signer)\n> > > > > >\n> > > > > > So the flow would be:\n> > > > > > 1. Securely verify the xpub of the warm / hot wallet.\n> > > > > > 2. Using the airgap signing tool, sign the xpub with all cold\n> > > > > > keys. 3. Upload the signature/xpub pairs to the online\n> > > > > > unsigned transaction generator.\n> > > > > > 4. Include one keyval pair per coldkey/xpub pairing.\n> > > > > > 5. When offline signing, if the wallet detects there is a\n> > > > > > global keyval XPUB_SIGNATURE with its pubkey in the key, it\n> > > > > > must verify that all outputs have BIP32_DERIVATION and that\n> > > > > > it can verify the outputs through the derivation, to the\n> > > > > > xpub, and to the signature.\n> > > > > >\n> > > > > > In my attempt to fitting this into PSBT, I am slightly\n> > > > > > altering our current system, so don't take this as an\n> > > > > > indication 100% of how we work in the backend.\n> > > > > >\n> > > > > > However, I would like to hear any feedback on this proposal.\n> > > > > >\n> > > > > > Thanks,\n> > > > > > Jonathan\n> > > > > >\n> > > > >\n> > > > >\n> > > >\n> > >\n> > >\n> >\n>\n>\n\n-- \n-----------------\nJonathan Underwood\n\u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n-----------------\n\n\u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n\n\u6307\u7d0b: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190627/e247bc0d/attachment.html>"
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2019-06-27T15:29:32",
                "message_text_only": "Oh, I saw that you covered it in another mail:\n\n> The expire / revoke problem is a larger problem than this feature can\n> handle.\n\n> In general, if one of the cold keys is stolen, there is rarely a\n> situation where you are completely sure the other cold keys haven't\n> been compromised... so the best practice would be all signers\n> generate new keys and all funds are moved to a completely new\n> multisig wallet (no common xpubs).\n\nThe setup might not be 'all cold keys', but the keys with different\nlevels of exposure to possible theft. In this config, compromise of one\nof the 'warm' keys might not necessary require changing the 'cold' key.\n\nI'm not sure whether this usecase warrants adding extra 'serial'\nfield, but on the other hand it is rather simple change, and those who\ndoes not care can always set 0. \n\n\u0412 Thu, 27 Jun 2019 18:14:29 +0500\nDmitry Petukhov <dp at simplexum.com> wrote:\n\n> What do you think about adding serial number to the xpub package ?\n> \n> The key would be \n> \n> {0x02}|{signing_pubkey}|{serial}|{m}|{xpub}|...|{xpub}\n> \n> and if the signer have the ability to store a counter, it can reject\n> 'outdated' xpub packages, and only accept those that was signed using\n> the serial number that it deems recent. This would allow a limited\n> mechanism to 'revoke' previously signed packages that have compromized\n> keys in them.\n> \n> \u0412 Thu, 27 Jun 2019 17:16:14 +0900\n> Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:\n> \n> > I see what you mean.\n> > \n> > What about this?\n> > https://github.com/junderw/bips/commit/57a57b4fae1ae14b77a2eebd99cd719148e3027e?short_path=82656c8#diff-82656c833e31e6751a412ce5e5c70920\n> > \n> > Plus side: for single sig case, the key only increases by one byte\n> > (0x00 for the {m} value)\n> > \n> > This way if it was 2 of 3 like before, you sign the whole \"packet\"\n> > so each key only signs the packet once. Way better than n!\n> > \n> > Anywho. Please send your feedback. Thanks.\n> > Jonathan\n> > \n> > 2019\u5e746\u670827\u65e5(\u6728) 16:27 Dmitry Petukhov <dp at simplexum.com>:\n> >   \n> > > How would signer know that there _should_ be at least 3 signatures\n> > > signed by the key owned by this signer ?\n> > >\n> > > If it does not know that it should enforce 2of3 multisig, for\n> > > example, the attacker that control only one key A can fool signer\n> > > B by sending to 1of1 single-sig that is derived from A's xpub, and\n> > > providing only sBxA in PSBT.\n> > >\n> > > If the signer does not have a hardcoded configuration that\n> > > will mandate a particular multisig scheme, it will allow sending\n> > > to any scheme.\n> > >\n> > > If the signer has a rich enough state to store updatable\n> > > configuration, it can just store the trusted xpubs directly.\n> > >\n> > > Alternatively, signer can sign not individual xpubs, but whole\n> > > xpub packages that correspond to particular multisig\n> > > configuration, and enforce that destination addresses correspond\n> > > to this configuration.\n> > >\n> > > But this would not be possible with your PSBT scheme that uses\n> > > individual key-xpub pairs.\n> > >\n> > > \u0412 Thu, 27 Jun 2019 14:07:47 +0900\n> > > Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:\n> > >    \n> > > > Thanks for the reply.\n> > > >\n> > > > The way we would do it is:\n> > > >\n> > > > Let's say we have 3 cold keys for multisig: A B and C\n> > > >\n> > > > Whose xpubs are: xA xB and xC\n> > > >\n> > > > We all sign each other's xpubs, whose signatures are:\n> > > > sAxB\n> > > > sAxC\n> > > > sBxA\n> > > > sBxC\n> > > > sCxA\n> > > > sCxB\n> > > >\n> > > > We can then create a wallet that says \"when verifying change\n> > > > with 0x01 global type proposed by Andrew Chow, if the change is\n> > > > multisig, we MUST require the other pubkeys to have signatures\n> > > > via my 0x02 proposal\"\n> > > >\n> > > > This way, all my PSBTs for my cold will have:\n> > > > 1. an 0x01 entry to tell me how to get my change.\n> > > > 2. All 6 of the signatures above.\n> > > >\n> > > > And the signer will then look at the change, check my pubkey by\n> > > > deriving the xpub and checking equality to the BIP_DERIVATION of\n> > > > the output... it will then check the OTHER pubkeys via\n> > > > BIP32_DERIVATION to master fingerprint, then link that\n> > > > fingerprint to a 0x02 sig from MY key, verifying all pubkeys.\n> > > >\n> > > > So this proposal of mine would not only fix the \"send to address\n> > > > verification\" problem for HD, but also the multisig change\n> > > > problem with 0x01.\n> > > >\n> > > > Cool.\n> > > >\n> > > > Only thing that is kind of sad is having to include n! (of\n> > > > m-of-n) signatures in every PSBT... but tbh, the PSBT size is\n> > > > not of much concern.\n> > > >\n> > > > Thanks for the reply.\n> > > > - Jonathan\n> > > >\n> > > >\n> > > > 2019\u5e746\u670827\u65e5(\u6728) 13:49 Dmitry Petukhov <dp at simplexum.com>:\n> > > >    \n> > > > > Hi!\n> > > > >\n> > > > > I wonder how your scheme handles multisig ?\n> > > > >\n> > > > > As I understand, you sign individual xpubs with cold keys, so\n> > > > > that cold keys can check destination addresses are trusted.\n> > > > >\n> > > > > I seems to me that if you sign individual xpubs of a multisig\n> > > > > warm wallet, and one key from that multisig is compromized,\n> > > > > attackers can then create a single-sig destination address\n> > > > > that they control, and move the coins in a chain of two\n> > > > > transactions, first to this single-sig address, and then to an\n> > > > > address that they independently control.\n> > > > >\n> > > > > My idea to prevent this [1] is to sign the whole 'xpub\n> > > > > package' of the multisig wallet, but there is also an issue\n> > > > > of 'partial compromize', where some of the keys in a multisig\n> > > > > warm wallet is compromized, and you do not want to regard a\n> > > > > particular 'xpub package' as trusted. My idea was [2] to use\n> > > > > an auxiliary message that would be signed along with the\n> > > > > 'xpub package', and that message can include specific 'epoch'\n> > > > > word that hardware wallet can show prominently before\n> > > > > signing, or have 'serial number' for xpub packages (but that\n> > > > > will require to store last known serial inside hw wallet,\n> > > > > making it stateful).\n> > > > >\n> > > > > I like the idea to extend PSBT to accomodate these schemes,\n> > > > > but given that the huge number of possible schemes that each\n> > > > > may probably require its own PSBT field type, I think that\n> > > > > this is better dealt with outside of PSBT, as 'PSBT\n> > > > > metainformation', or using some form of 'vendor-specific', or\n> > > > > 'metainformation-specific' PSBT field. This way each usecase\n> > > > > can be independently described in its own documentation, that\n> > > > > would include the particulars of the format for the\n> > > > > metainformation. This would also make it easier to implement\n> > > > > PSBT for simple cases, because the 'core specification' would\n> > > > > not grow that big.\n> > > > >\n> > > > > [1]\n> > > > >\n> > > > >    \n> > > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016917.html    \n> > > > >\n> > > > > [2]\n> > > > >\n> > > > >    \n> > > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016926.html    \n> > > > >\n> > > > >\n> > > > > \u0412 Thu, 27 Jun 2019 11:11:23 +0900 Jonathan Underwood via\n> > > > > bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > > > >    \n> > > > > > Hello all,\n> > > > > >\n> > > > > > Just wanted to pick your brains about an idea for PSBT\n> > > > > > extension.\n> > > > > >\n> > > > > > One problem we try to solve with cold -> warm and warm ->\n> > > > > > hot sends for our exchange wallet is \"How do I know that the\n> > > > > > address I am sending to is not a hacker's address that was\n> > > > > > swapped in between unsigned tx creation and first\n> > > > > > signature?\"\n> > > > > >\n> > > > > > We have a proprietary JSON based encoding system which we\n> > > > > > are looking to move towards PSBT, but PSBT is missing this\n> > > > > > key functionality.\n> > > > > >\n> > > > > > BIP32_DERIVATION does allow us to verify the address is\n> > > > > > from a certain XPUB, but, for example, it can not allow us\n> > > > > > to verify a signature of that xpub.\n> > > > > >\n> > > > > > I have made a rough draft of the proposed key value\n> > > > > > specification.   \n> > > > >    \n> > > https://github.com/junderw/bips/blob/addXpubSig/bip-0174.mediawiki#specification\n> > >    \n> > > > > >\n> > > > > > The signing key path used in the spec is just randomly\n> > > > > > chosen 31 x 4 bits shown as numbers with hardened paths.\n> > > > > >\n> > > > > > Since this issue seems similar to the change address issue,\n> > > > > > I started from that as a base. With the HW wallet case, I\n> > > > > > can verify the xpub by just deriving it locally and\n> > > > > > comparing equality, however, in our case, we need to verify\n> > > > > > an xpub that we do not have access to via derivation from\n> > > > > > our cold key(s) (since we don't want to import our warm\n> > > > > > private key into our cold signer)\n> > > > > >\n> > > > > > So the flow would be:\n> > > > > > 1. Securely verify the xpub of the warm / hot wallet.\n> > > > > > 2. Using the airgap signing tool, sign the xpub with all\n> > > > > > cold keys. 3. Upload the signature/xpub pairs to the online\n> > > > > > unsigned transaction generator.\n> > > > > > 4. Include one keyval pair per coldkey/xpub pairing.\n> > > > > > 5. When offline signing, if the wallet detects there is a\n> > > > > > global keyval XPUB_SIGNATURE with its pubkey in the key, it\n> > > > > > must verify that all outputs have BIP32_DERIVATION and that\n> > > > > > it can verify the outputs through the derivation, to the\n> > > > > > xpub, and to the signature.\n> > > > > >\n> > > > > > In my attempt to fitting this into PSBT, I am slightly\n> > > > > > altering our current system, so don't take this as an\n> > > > > > indication 100% of how we work in the backend.\n> > > > > >\n> > > > > > However, I would like to hear any feedback on this proposal.\n> > > > > >\n> > > > > > Thanks,\n> > > > > > Jonathan\n> > > > > >    \n> > > > >\n> > > > >    \n> > > >    \n> > >\n> > >    \n> >   \n>"
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2019-06-28T21:48:16",
                "message_text_only": "In your proposed field key format,\n\n{0x02}|{signing_pubkey}|{m}|{xpub}|...|{xpub}\n\nI think you can replace the signing pubkey with just a fingerprint of\nthe master key, that would save 29 bytes per 0x02 field.\n\nIf the only entity that is concerned about the validity of the\nsignature is those that possess the signing_privkey, it will check the\nsignature when it sees the 0x02 field starting with its own key\nfingerprint, and will ignore the field if the signature does not match.\n\nIf someone other than the signer needs to check that this xpub-package\nwas signed by certain cold key, it will need to know signing_pubkey\nanyway, before it parses PSBT, as it won't have the means to check if\ncertain pubkey found in 0x02 field in PSBT is related to certain\nsigner, without knowing anything about the pubkey beforehand.\n\nI'm not sure if the ability of unrelated parties to verify that\nxpub-package matches its signature is useful in practice. 29 bytes per\n0x02 field is not a big saving of space, and if this ability is actually\nuseful, the saving may not be worh loosing this ability.\n\nOther note: you have 'unused' value of 1 for `m` in your scheme, why\nnot require m=1 for single-sig case, and use 0 as indicator that there\nare a serlal number following it?\n\nThe key for the field would be encoded as\n\n{0x02}|{signing_pubkey}|{m}|{xpub}|...|{xpub}\n\nfor usual case, and\n\n{0x02}|{signing_pubkey}|0x00|{serial}|{m}|{xpub}|...|{xpub}\n\nfor the case when the signing scheme actually cares about different\nversions of xpub packages signed by certain cold key\n\nGoing back to the idea of moving 'complex' usecases outside of BIP174:\nmaybe we could have a 'BIP-specific' field, that would have the key as\n\n{0x0?}|{BIP-number}|{bip-specific-suffix-data}\n\nso that the different usecases that are not general enough to be\nincluded in BIP174 itself, may have their own BIPs. Vendor-specific\nfields may also be done as a separate BIP.\n\n\u0412 Thu, 27 Jun 2019 20:29:32 +0500\nDmitry Petukhov <dp at simplexum.com> wrote:\n\n> Oh, I saw that you covered it in another mail:\n> \n> > The expire / revoke problem is a larger problem than this feature\n> > can handle.  \n> \n> > In general, if one of the cold keys is stolen, there is rarely a\n> > situation where you are completely sure the other cold keys haven't\n> > been compromised... so the best practice would be all signers\n> > generate new keys and all funds are moved to a completely new\n> > multisig wallet (no common xpubs).  \n> \n> The setup might not be 'all cold keys', but the keys with different\n> levels of exposure to possible theft. In this config, compromise of\n> one of the 'warm' keys might not necessary require changing the\n> 'cold' key.\n> \n> I'm not sure whether this usecase warrants adding extra 'serial'\n> field, but on the other hand it is rather simple change, and those who\n> does not care can always set 0. \n> \n> \u0412 Thu, 27 Jun 2019 18:14:29 +0500\n> Dmitry Petukhov <dp at simplexum.com> wrote:\n> \n> > What do you think about adding serial number to the xpub package ?\n> > \n> > The key would be \n> > \n> > {0x02}|{signing_pubkey}|{serial}|{m}|{xpub}|...|{xpub}\n> > \n> > and if the signer have the ability to store a counter, it can reject\n> > 'outdated' xpub packages, and only accept those that was signed\n> > using the serial number that it deems recent. This would allow a\n> > limited mechanism to 'revoke' previously signed packages that have\n> > compromized keys in them.\n> > \n> > \u0412 Thu, 27 Jun 2019 17:16:14 +0900\n> > Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:\n> >   \n> > > I see what you mean.\n> > > \n> > > What about this?\n> > > https://github.com/junderw/bips/commit/57a57b4fae1ae14b77a2eebd99cd719148e3027e?short_path=82656c8#diff-82656c833e31e6751a412ce5e5c70920\n> > > \n> > > Plus side: for single sig case, the key only increases by one byte\n> > > (0x00 for the {m} value)\n> > > \n> > > This way if it was 2 of 3 like before, you sign the whole \"packet\"\n> > > so each key only signs the packet once. Way better than n!\n> > > \n> > > Anywho. Please send your feedback. Thanks.\n> > > Jonathan\n> > > \n> > > 2019\u5e746\u670827\u65e5(\u6728) 16:27 Dmitry Petukhov <dp at simplexum.com>:\n> > >     \n> > > > How would signer know that there _should_ be at least 3\n> > > > signatures signed by the key owned by this signer ?\n> > > >\n> > > > If it does not know that it should enforce 2of3 multisig, for\n> > > > example, the attacker that control only one key A can fool\n> > > > signer B by sending to 1of1 single-sig that is derived from A's\n> > > > xpub, and providing only sBxA in PSBT.\n> > > >\n> > > > If the signer does not have a hardcoded configuration that\n> > > > will mandate a particular multisig scheme, it will allow sending\n> > > > to any scheme.\n> > > >\n> > > > If the signer has a rich enough state to store updatable\n> > > > configuration, it can just store the trusted xpubs directly.\n> > > >\n> > > > Alternatively, signer can sign not individual xpubs, but whole\n> > > > xpub packages that correspond to particular multisig\n> > > > configuration, and enforce that destination addresses correspond\n> > > > to this configuration.\n> > > >\n> > > > But this would not be possible with your PSBT scheme that uses\n> > > > individual key-xpub pairs.\n> > > >\n> > > > \u0412 Thu, 27 Jun 2019 14:07:47 +0900\n> > > > Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:\n> > > >      \n> > > > > Thanks for the reply.\n> > > > >\n> > > > > The way we would do it is:\n> > > > >\n> > > > > Let's say we have 3 cold keys for multisig: A B and C\n> > > > >\n> > > > > Whose xpubs are: xA xB and xC\n> > > > >\n> > > > > We all sign each other's xpubs, whose signatures are:\n> > > > > sAxB\n> > > > > sAxC\n> > > > > sBxA\n> > > > > sBxC\n> > > > > sCxA\n> > > > > sCxB\n> > > > >\n> > > > > We can then create a wallet that says \"when verifying change\n> > > > > with 0x01 global type proposed by Andrew Chow, if the change\n> > > > > is multisig, we MUST require the other pubkeys to have\n> > > > > signatures via my 0x02 proposal\"\n> > > > >\n> > > > > This way, all my PSBTs for my cold will have:\n> > > > > 1. an 0x01 entry to tell me how to get my change.\n> > > > > 2. All 6 of the signatures above.\n> > > > >\n> > > > > And the signer will then look at the change, check my pubkey\n> > > > > by deriving the xpub and checking equality to the\n> > > > > BIP_DERIVATION of the output... it will then check the OTHER\n> > > > > pubkeys via BIP32_DERIVATION to master fingerprint, then link\n> > > > > that fingerprint to a 0x02 sig from MY key, verifying all\n> > > > > pubkeys.\n> > > > >\n> > > > > So this proposal of mine would not only fix the \"send to\n> > > > > address verification\" problem for HD, but also the multisig\n> > > > > change problem with 0x01.\n> > > > >\n> > > > > Cool.\n> > > > >\n> > > > > Only thing that is kind of sad is having to include n! (of\n> > > > > m-of-n) signatures in every PSBT... but tbh, the PSBT size is\n> > > > > not of much concern.\n> > > > >\n> > > > > Thanks for the reply.\n> > > > > - Jonathan\n> > > > >\n> > > > >\n> > > > > 2019\u5e746\u670827\u65e5(\u6728) 13:49 Dmitry Petukhov <dp at simplexum.com>:\n> > > > >      \n> > > > > > Hi!\n> > > > > >\n> > > > > > I wonder how your scheme handles multisig ?\n> > > > > >\n> > > > > > As I understand, you sign individual xpubs with cold keys,\n> > > > > > so that cold keys can check destination addresses are\n> > > > > > trusted.\n> > > > > >\n> > > > > > I seems to me that if you sign individual xpubs of a\n> > > > > > multisig warm wallet, and one key from that multisig is\n> > > > > > compromized, attackers can then create a single-sig\n> > > > > > destination address that they control, and move the coins\n> > > > > > in a chain of two transactions, first to this single-sig\n> > > > > > address, and then to an address that they independently\n> > > > > > control.\n> > > > > >\n> > > > > > My idea to prevent this [1] is to sign the whole 'xpub\n> > > > > > package' of the multisig wallet, but there is also an issue\n> > > > > > of 'partial compromize', where some of the keys in a\n> > > > > > multisig warm wallet is compromized, and you do not want to\n> > > > > > regard a particular 'xpub package' as trusted. My idea was\n> > > > > > [2] to use an auxiliary message that would be signed along\n> > > > > > with the 'xpub package', and that message can include\n> > > > > > specific 'epoch' word that hardware wallet can show\n> > > > > > prominently before signing, or have 'serial number' for\n> > > > > > xpub packages (but that will require to store last known\n> > > > > > serial inside hw wallet, making it stateful).\n> > > > > >\n> > > > > > I like the idea to extend PSBT to accomodate these schemes,\n> > > > > > but given that the huge number of possible schemes that each\n> > > > > > may probably require its own PSBT field type, I think that\n> > > > > > this is better dealt with outside of PSBT, as 'PSBT\n> > > > > > metainformation', or using some form of 'vendor-specific',\n> > > > > > or 'metainformation-specific' PSBT field. This way each\n> > > > > > usecase can be independently described in its own\n> > > > > > documentation, that would include the particulars of the\n> > > > > > format for the metainformation. This would also make it\n> > > > > > easier to implement PSBT for simple cases, because the\n> > > > > > 'core specification' would not grow that big.\n> > > > > >\n> > > > > > [1]\n> > > > > >\n> > > > > >      \n> > > > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016917.html      \n> > > > > >\n> > > > > > [2]\n> > > > > >\n> > > > > >      \n> > > > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016926.html      \n> > > > > >\n> > > > > >\n> > > > > > \u0412 Thu, 27 Jun 2019 11:11:23 +0900 Jonathan Underwood via\n> > > > > > bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > > > > >      \n> > > > > > > Hello all,\n> > > > > > >\n> > > > > > > Just wanted to pick your brains about an idea for PSBT\n> > > > > > > extension.\n> > > > > > >\n> > > > > > > One problem we try to solve with cold -> warm and warm ->\n> > > > > > > hot sends for our exchange wallet is \"How do I know that\n> > > > > > > the address I am sending to is not a hacker's address\n> > > > > > > that was swapped in between unsigned tx creation and first\n> > > > > > > signature?\"\n> > > > > > >\n> > > > > > > We have a proprietary JSON based encoding system which we\n> > > > > > > are looking to move towards PSBT, but PSBT is missing this\n> > > > > > > key functionality.\n> > > > > > >\n> > > > > > > BIP32_DERIVATION does allow us to verify the address is\n> > > > > > > from a certain XPUB, but, for example, it can not allow us\n> > > > > > > to verify a signature of that xpub.\n> > > > > > >\n> > > > > > > I have made a rough draft of the proposed key value\n> > > > > > > specification.     \n> > > > > >      \n> > > > https://github.com/junderw/bips/blob/addXpubSig/bip-0174.mediawiki#specification\n> > > >      \n> > > > > > >\n> > > > > > > The signing key path used in the spec is just randomly\n> > > > > > > chosen 31 x 4 bits shown as numbers with hardened paths.\n> > > > > > >\n> > > > > > > Since this issue seems similar to the change address\n> > > > > > > issue, I started from that as a base. With the HW wallet\n> > > > > > > case, I can verify the xpub by just deriving it locally\n> > > > > > > and comparing equality, however, in our case, we need to\n> > > > > > > verify an xpub that we do not have access to via\n> > > > > > > derivation from our cold key(s) (since we don't want to\n> > > > > > > import our warm private key into our cold signer)\n> > > > > > >\n> > > > > > > So the flow would be:\n> > > > > > > 1. Securely verify the xpub of the warm / hot wallet.\n> > > > > > > 2. Using the airgap signing tool, sign the xpub with all\n> > > > > > > cold keys. 3. Upload the signature/xpub pairs to the\n> > > > > > > online unsigned transaction generator.\n> > > > > > > 4. Include one keyval pair per coldkey/xpub pairing.\n> > > > > > > 5. When offline signing, if the wallet detects there is a\n> > > > > > > global keyval XPUB_SIGNATURE with its pubkey in the key,\n> > > > > > > it must verify that all outputs have BIP32_DERIVATION and\n> > > > > > > that it can verify the outputs through the derivation, to\n> > > > > > > the xpub, and to the signature.\n> > > > > > >\n> > > > > > > In my attempt to fitting this into PSBT, I am slightly\n> > > > > > > altering our current system, so don't take this as an\n> > > > > > > indication 100% of how we work in the backend.\n> > > > > > >\n> > > > > > > However, I would like to hear any feedback on this\n> > > > > > > proposal.\n> > > > > > >\n> > > > > > > Thanks,\n> > > > > > > Jonathan\n> > > > > > >      \n> > > > > >\n> > > > > >      \n> > > > >      \n> > > >\n> > > >      \n> > >     \n> >   \n>"
            },
            {
                "author": "Jonathan Underwood",
                "date": "2019-06-29T00:19:41",
                "message_text_only": "replies in-line. Thanks!\n\n2019\u5e746\u670829\u65e5(\u571f) 6:46 Dmitry Petukhov <dp at simplexum.com>:\n\n> In your proposed field key format,\n>\n> {0x02}|{signing_pubkey}|{m}|{xpub}|...|{xpub}\n>\n> I think you can replace the signing pubkey with just a fingerprint of\n> the master key, that would save 29 bytes per 0x02 field.\n>\n\nGood point.\n\n\n> If the only entity that is concerned about the validity of the\n> signature is those that possess the signing_privkey, it will check the\n> signature when it sees the 0x02 field starting with its own key\n> fingerprint, and will ignore the field if the signature does not match.\n>\n> If someone other than the signer needs to check that this xpub-package\n> was signed by certain cold key, it will need to know signing_pubkey\n> anyway, before it parses PSBT, as it won't have the means to check if\n> certain pubkey found in 0x02 field in PSBT is related to certain\n> signer, without knowing anything about the pubkey beforehand.\n>\n> I'm not sure if the ability of unrelated parties to verify that\n> xpub-package matches its signature is useful in practice. 29 bytes per\n> 0x02 field is not a big saving of space, and if this ability is actually\n> useful, the saving may not be worh loosing this ability.\n>\n\nAll good points, I think we'll just use the first 4 bytes of the hash160 of\nthe pubkey, aka fingerprint.\n\n\n> Other note: you have 'unused' value of 1 for `m` in your scheme, why\n> not require m=1 for single-sig case, and use 0 as indicator that there\n> are a serlal number following it?\n>\n\n0x00 is single sig, aka, OP_CHECKSIG\n\n0x01 is multisig, aka, 1-of-3, 1-of-2 OP_CHECKMULTISIG\n\n\n> The key for the field would be encoded as\n>\n> {0x02}|{signing_pubkey}|{m}|{xpub}|...|{xpub}\n>\n> for usual case, and\n>\n> {0x02}|{signing_pubkey}|0x00|{serial}|{m}|{xpub}|...|{xpub}\n>\n> for the case when the signing scheme actually cares about different\n> versions of xpub packages signed by certain cold key\n>\n\nsince OP_CHECKMULTISIG only supports at most 15-of-15 due to stack item\nsize limitations, we could make 0xff into this serial marker.\n\n\n> Going back to the idea of moving 'complex' usecases outside of BIP174:\n> maybe we could have a 'BIP-specific' field, that would have the key as\n>\n> {0x0?}|{BIP-number}|{bip-specific-suffix-data}\n>\n> so that the different usecases that are not general enough to be\n> included in BIP174 itself, may have their own BIPs. Vendor-specific\n> fields may also be done as a separate BIP.\n>\n\nDefinitely sounds good, but the currently proposed 0x01 global type is\nbeing added to BIP174 directly under the assumption that it is useful for\nall users of PSBT, and I would argue that 0x01 being an HD change verifying\nmethod, it only seems logical to add a similar method of \"verifying\"\nnon-self keys, aka whitelisting for security purposes, and such a feature\nwould require this data be included into the PSBT sent into the device.\n\nIf the consensus is that this data is unneeded, 0x01 should probably also\nbe a separate BIP.\n\nThough outside the scope of this BIP, one difficulty of a whitelist feature\nwould be revocation of signatures. If we pre-sign a revocation cert and\nsomehow make the wallet blacklist if seen... then the question is \"if your\nsigner has a trustworthy store of state, why not store the whitelist\npubkeys?\"\n\nBut that feature itself should be a separate BIP.\n\nAlso, POR_COMMITMENT being in BIP174 kind of set a precedent... :-/\n\n\n> \u0412 Thu, 27 Jun 2019 20:29:32 +0500\n> Dmitry Petukhov <dp at simplexum.com> wrote:\n>\n> > Oh, I saw that you covered it in another mail:\n> >\n> > > The expire / revoke problem is a larger problem than this feature\n> > > can handle.\n> >\n> > > In general, if one of the cold keys is stolen, there is rarely a\n> > > situation where you are completely sure the other cold keys haven't\n> > > been compromised... so the best practice would be all signers\n> > > generate new keys and all funds are moved to a completely new\n> > > multisig wallet (no common xpubs).\n> >\n> > The setup might not be 'all cold keys', but the keys with different\n> > levels of exposure to possible theft. In this config, compromise of\n> > one of the 'warm' keys might not necessary require changing the\n> > 'cold' key.\n> >\n> > I'm not sure whether this usecase warrants adding extra 'serial'\n> > field, but on the other hand it is rather simple change, and those who\n> > does not care can always set 0.\n> >\n> > \u0412 Thu, 27 Jun 2019 18:14:29 +0500\n> > Dmitry Petukhov <dp at simplexum.com> wrote:\n> >\n> > > What do you think about adding serial number to the xpub package ?\n> > >\n> > > The key would be\n> > >\n> > > {0x02}|{signing_pubkey}|{serial}|{m}|{xpub}|...|{xpub}\n> > >\n> > > and if the signer have the ability to store a counter, it can reject\n> > > 'outdated' xpub packages, and only accept those that was signed\n> > > using the serial number that it deems recent. This would allow a\n> > > limited mechanism to 'revoke' previously signed packages that have\n> > > compromized keys in them.\n> > >\n> > > \u0412 Thu, 27 Jun 2019 17:16:14 +0900\n> > > Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:\n> > >\n> > > > I see what you mean.\n> > > >\n> > > > What about this?\n> > > >\n> https://github.com/junderw/bips/commit/57a57b4fae1ae14b77a2eebd99cd719148e3027e?short_path=82656c8#diff-82656c833e31e6751a412ce5e5c70920\n> > > >\n> > > > Plus side: for single sig case, the key only increases by one byte\n> > > > (0x00 for the {m} value)\n> > > >\n> > > > This way if it was 2 of 3 like before, you sign the whole \"packet\"\n> > > > so each key only signs the packet once. Way better than n!\n> > > >\n> > > > Anywho. Please send your feedback. Thanks.\n> > > > Jonathan\n> > > >\n> > > > 2019\u5e746\u670827\u65e5(\u6728) 16:27 Dmitry Petukhov <dp at simplexum.com>:\n> > > >\n> > > > > How would signer know that there _should_ be at least 3\n> > > > > signatures signed by the key owned by this signer ?\n> > > > >\n> > > > > If it does not know that it should enforce 2of3 multisig, for\n> > > > > example, the attacker that control only one key A can fool\n> > > > > signer B by sending to 1of1 single-sig that is derived from A's\n> > > > > xpub, and providing only sBxA in PSBT.\n> > > > >\n> > > > > If the signer does not have a hardcoded configuration that\n> > > > > will mandate a particular multisig scheme, it will allow sending\n> > > > > to any scheme.\n> > > > >\n> > > > > If the signer has a rich enough state to store updatable\n> > > > > configuration, it can just store the trusted xpubs directly.\n> > > > >\n> > > > > Alternatively, signer can sign not individual xpubs, but whole\n> > > > > xpub packages that correspond to particular multisig\n> > > > > configuration, and enforce that destination addresses correspond\n> > > > > to this configuration.\n> > > > >\n> > > > > But this would not be possible with your PSBT scheme that uses\n> > > > > individual key-xpub pairs.\n> > > > >\n> > > > > \u0412 Thu, 27 Jun 2019 14:07:47 +0900\n> > > > > Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:\n> > > > >\n> > > > > > Thanks for the reply.\n> > > > > >\n> > > > > > The way we would do it is:\n> > > > > >\n> > > > > > Let's say we have 3 cold keys for multisig: A B and C\n> > > > > >\n> > > > > > Whose xpubs are: xA xB and xC\n> > > > > >\n> > > > > > We all sign each other's xpubs, whose signatures are:\n> > > > > > sAxB\n> > > > > > sAxC\n> > > > > > sBxA\n> > > > > > sBxC\n> > > > > > sCxA\n> > > > > > sCxB\n> > > > > >\n> > > > > > We can then create a wallet that says \"when verifying change\n> > > > > > with 0x01 global type proposed by Andrew Chow, if the change\n> > > > > > is multisig, we MUST require the other pubkeys to have\n> > > > > > signatures via my 0x02 proposal\"\n> > > > > >\n> > > > > > This way, all my PSBTs for my cold will have:\n> > > > > > 1. an 0x01 entry to tell me how to get my change.\n> > > > > > 2. All 6 of the signatures above.\n> > > > > >\n> > > > > > And the signer will then look at the change, check my pubkey\n> > > > > > by deriving the xpub and checking equality to the\n> > > > > > BIP_DERIVATION of the output... it will then check the OTHER\n> > > > > > pubkeys via BIP32_DERIVATION to master fingerprint, then link\n> > > > > > that fingerprint to a 0x02 sig from MY key, verifying all\n> > > > > > pubkeys.\n> > > > > >\n> > > > > > So this proposal of mine would not only fix the \"send to\n> > > > > > address verification\" problem for HD, but also the multisig\n> > > > > > change problem with 0x01.\n> > > > > >\n> > > > > > Cool.\n> > > > > >\n> > > > > > Only thing that is kind of sad is having to include n! (of\n> > > > > > m-of-n) signatures in every PSBT... but tbh, the PSBT size is\n> > > > > > not of much concern.\n> > > > > >\n> > > > > > Thanks for the reply.\n> > > > > > - Jonathan\n> > > > > >\n> > > > > >\n> > > > > > 2019\u5e746\u670827\u65e5(\u6728) 13:49 Dmitry Petukhov <dp at simplexum.com>:\n> > > > > >\n> > > > > > > Hi!\n> > > > > > >\n> > > > > > > I wonder how your scheme handles multisig ?\n> > > > > > >\n> > > > > > > As I understand, you sign individual xpubs with cold keys,\n> > > > > > > so that cold keys can check destination addresses are\n> > > > > > > trusted.\n> > > > > > >\n> > > > > > > I seems to me that if you sign individual xpubs of a\n> > > > > > > multisig warm wallet, and one key from that multisig is\n> > > > > > > compromized, attackers can then create a single-sig\n> > > > > > > destination address that they control, and move the coins\n> > > > > > > in a chain of two transactions, first to this single-sig\n> > > > > > > address, and then to an address that they independently\n> > > > > > > control.\n> > > > > > >\n> > > > > > > My idea to prevent this [1] is to sign the whole 'xpub\n> > > > > > > package' of the multisig wallet, but there is also an issue\n> > > > > > > of 'partial compromize', where some of the keys in a\n> > > > > > > multisig warm wallet is compromized, and you do not want to\n> > > > > > > regard a particular 'xpub package' as trusted. My idea was\n> > > > > > > [2] to use an auxiliary message that would be signed along\n> > > > > > > with the 'xpub package', and that message can include\n> > > > > > > specific 'epoch' word that hardware wallet can show\n> > > > > > > prominently before signing, or have 'serial number' for\n> > > > > > > xpub packages (but that will require to store last known\n> > > > > > > serial inside hw wallet, making it stateful).\n> > > > > > >\n> > > > > > > I like the idea to extend PSBT to accomodate these schemes,\n> > > > > > > but given that the huge number of possible schemes that each\n> > > > > > > may probably require its own PSBT field type, I think that\n> > > > > > > this is better dealt with outside of PSBT, as 'PSBT\n> > > > > > > metainformation', or using some form of 'vendor-specific',\n> > > > > > > or 'metainformation-specific' PSBT field. This way each\n> > > > > > > usecase can be independently described in its own\n> > > > > > > documentation, that would include the particulars of the\n> > > > > > > format for the metainformation. This would also make it\n> > > > > > > easier to implement PSBT for simple cases, because the\n> > > > > > > 'core specification' would not grow that big.\n> > > > > > >\n> > > > > > > [1]\n> > > > > > >\n> > > > > > >\n> > > > >\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016917.html\n>\n> > > > > > >\n> > > > > > > [2]\n> > > > > > >\n> > > > > > >\n> > > > >\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016926.html\n>\n> > > > > > >\n> > > > > > >\n> > > > > > > \u0412 Thu, 27 Jun 2019 11:11:23 +0900 Jonathan Underwood via\n> > > > > > > bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > > > > > >\n> > > > > > > > Hello all,\n> > > > > > > >\n> > > > > > > > Just wanted to pick your brains about an idea for PSBT\n> > > > > > > > extension.\n> > > > > > > >\n> > > > > > > > One problem we try to solve with cold -> warm and warm ->\n> > > > > > > > hot sends for our exchange wallet is \"How do I know that\n> > > > > > > > the address I am sending to is not a hacker's address\n> > > > > > > > that was swapped in between unsigned tx creation and first\n> > > > > > > > signature?\"\n> > > > > > > >\n> > > > > > > > We have a proprietary JSON based encoding system which we\n> > > > > > > > are looking to move towards PSBT, but PSBT is missing this\n> > > > > > > > key functionality.\n> > > > > > > >\n> > > > > > > > BIP32_DERIVATION does allow us to verify the address is\n> > > > > > > > from a certain XPUB, but, for example, it can not allow us\n> > > > > > > > to verify a signature of that xpub.\n> > > > > > > >\n> > > > > > > > I have made a rough draft of the proposed key value\n> > > > > > > > specification.\n> > > > > > >\n> > > > >\n> https://github.com/junderw/bips/blob/addXpubSig/bip-0174.mediawiki#specification\n> > > > >\n> > > > > > > >\n> > > > > > > > The signing key path used in the spec is just randomly\n> > > > > > > > chosen 31 x 4 bits shown as numbers with hardened paths.\n> > > > > > > >\n> > > > > > > > Since this issue seems similar to the change address\n> > > > > > > > issue, I started from that as a base. With the HW wallet\n> > > > > > > > case, I can verify the xpub by just deriving it locally\n> > > > > > > > and comparing equality, however, in our case, we need to\n> > > > > > > > verify an xpub that we do not have access to via\n> > > > > > > > derivation from our cold key(s) (since we don't want to\n> > > > > > > > import our warm private key into our cold signer)\n> > > > > > > >\n> > > > > > > > So the flow would be:\n> > > > > > > > 1. Securely verify the xpub of the warm / hot wallet.\n> > > > > > > > 2. Using the airgap signing tool, sign the xpub with all\n> > > > > > > > cold keys. 3. Upload the signature/xpub pairs to the\n> > > > > > > > online unsigned transaction generator.\n> > > > > > > > 4. Include one keyval pair per coldkey/xpub pairing.\n> > > > > > > > 5. When offline signing, if the wallet detects there is a\n> > > > > > > > global keyval XPUB_SIGNATURE with its pubkey in the key,\n> > > > > > > > it must verify that all outputs have BIP32_DERIVATION and\n> > > > > > > > that it can verify the outputs through the derivation, to\n> > > > > > > > the xpub, and to the signature.\n> > > > > > > >\n> > > > > > > > In my attempt to fitting this into PSBT, I am slightly\n> > > > > > > > altering our current system, so don't take this as an\n> > > > > > > > indication 100% of how we work in the backend.\n> > > > > > > >\n> > > > > > > > However, I would like to hear any feedback on this\n> > > > > > > > proposal.\n> > > > > > > >\n> > > > > > > > Thanks,\n> > > > > > > > Jonathan\n> > > > > > > >\n> > > > > > >\n> > > > > > >\n> > > > > >\n> > > > >\n> > > > >\n> > > >\n> > >\n> >\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190629/aed02387/attachment-0001.html>"
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2019-06-29T04:31:04",
                "message_text_only": "\u0412 Sat, 29 Jun 2019 09:19:41 +0900\nJonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:\n\n> Though outside the scope of this BIP, one difficulty of a whitelist\n> feature would be revocation of signatures. If we pre-sign a\n> revocation cert and somehow make the wallet blacklist if seen... then\n> the question is \"if your signer has a trustworthy store of state, why\n> not store the whitelist pubkeys?\"\n\nIn principle, if the hardware wallet can permanently store at least one\ncounter, it can have rich state, stored externally. It would sign a\nstate stored in RAM, and give out the state + signature to the\nsupporting app. The state will include a serial number, corresponding to\nthe internal counter stored in the hardware wallet. Next time, the app\nwill give the signed state to the hardware wallet along with\ntransaction data. Hardware wallet checks its signature over the state,\nchecks that serial matches its internal counter, uses and modifies the\nstate, then updates the internal counter and the serial number of the\nstate, and gives out the signed new state to the app. If the app\nloses the state blob, though, there should be some mechanism to securely\noverride the hw wallet internal state.\n\nThis approach might have other limitations, as processing and storing\nbig enough state in the RAM of a resource-constrained device might\npresent a problem in itself.\n\nThe 'add serial to xpub-package' idea is in the same vein: you can\nstore this xpub-package serial inside the hw wallet directly, or inside\nits 'external rich state blob', but it can take only one byte (unlikely\nto need more than 255 xpub-package 'revocations', at that point you\nare probably OK to change your cold keys already)"
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2019-06-29T04:46:23",
                "message_text_only": "\u0412 Sat, 29 Jun 2019 09:19:41 +0900\nJonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:\n\n> > Other note: you have 'unused' value of 1 for `m` in your scheme, why\n> > not require m=1 for single-sig case, and use 0 as indicator that\n> > there are a serlal number following it?\n> >  \n> \n> 0x00 is single sig, aka, OP_CHECKSIG\n> \n> 0x01 is multisig, aka, 1-of-3, 1-of-2 OP_CHECKMULTISIG\n\nThis informatin is available in per-output redeem/witness script,\nsigner will be able to distinguish between multisig/single-sig by\nlooking at this script. I think it only need to know the total number\nof keys participating in the signing, and check that this number\nmatches the particulars of redeem/witness script."
            },
            {
                "author": "Jonathan Underwood",
                "date": "2019-06-29T08:11:56",
                "message_text_only": "Even if the difference is apparent outside the signed data (in the output).\nSigning the data explicitly is more secure.\n\nie. if some sort of vulnerability / way to break this system for 1-of-1\nmultisig is found, someone who signed a single sig xpub whitelist will not\nbe exposed.\n\n2019\u5e746\u670829\u65e5(\u571f) 13:43 Dmitry Petukhov <dp at simplexum.com>:\n\n> \u0412 Sat, 29 Jun 2019 09:19:41 +0900\n> Jonathan Underwood <junderwood at bitcoinbank.co.jp> \u043f\u0438\u0448\u0435\u0442:\n>\n> > > Other note: you have 'unused' value of 1 for `m` in your scheme, why\n> > > not require m=1 for single-sig case, and use 0 as indicator that\n> > > there are a serlal number following it?\n> > >\n> >\n> > 0x00 is single sig, aka, OP_CHECKSIG\n> >\n> > 0x01 is multisig, aka, 1-of-3, 1-of-2 OP_CHECKMULTISIG\n>\n> This informatin is available in per-output redeem/witness script,\n> signer will be able to distinguish between multisig/single-sig by\n> looking at this script. I think it only need to know the total number\n> of keys participating in the signing, and check that this number\n> matches the particulars of redeem/witness script.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190629/04fd8336/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP174 extension proposal (Global Type: PSBT_GLOBAL_XPUB_SIGNATURE)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Jonathan Underwood",
                "Peter D. Gray",
                "Dmitry Petukhov"
            ],
            "messages_count": 16,
            "total_messages_chars_count": 108953
        }
    },
    {
        "title": "[bitcoin-dev] Generalized covenants with taproot enable riskless or risky lending, prevent credit inflation through fractional reserve",
        "thread_messages": [
            {
                "author": "Tamas Blummer",
                "date": "2019-06-28T08:27:16",
                "message_text_only": "I start with a formalisation of loans as common in finance:\n\nA zero bond is a contract between two parties Alice and Bob whereby Alice receives an amount less than P and has to pay back P at a later time point called maturity.\nThe difference between the amount received and P is the interest implied by the contract. E.g. receiving 1 Bitcoin (<P) and agree to pay back 1.1 (=P) in a year is the same as getting a loan with 10% p.a. interest.\n\nThe inherent risk in the contract is that Alice may not honor the agreement or be bankrupt by then.\n\nIf we could programmatically guarantee that Alice honors the contract then we would be able to create a riskless zero bond, the fundation of financial engineering.\n\nA systemic problem with loans is that the lender might operate on fractional reserve, that is lending more than his capital.\n\nUnchecked inflation of money supply through fractional reserve is creating a mess in the world we live in. Bitcoin could overcome this mess implementing this proposal!\n\nI stop here with finance speak as the purpose of this mail is not to dive into finance, but to show how loans with full reserve check could be implemented in Bitcoin.\n\n1. Receiving the loan is a payment from Bob to Alice, but we need a restriction how Alice can use the funds, so Bob can get them back unconditionally at maturity, so lending is riskless to him.\n2. Bob wants to receive interest, since he gives up his control of the coins until maturity, he can not use them elsewhere until then. That interest could be paid in advance, this can be solved with Bitcoin as is.\n\nHow do we allow Alice to use the coins, that is: split/merge and transfer them to others, but still ensure Bob can claim them back at maturity?\n\nWe ensure that Alice can only send the coins to outputs that inherit a taproot path of validation (using http://bitcoin.sipa.be/miniscript/): 'and(time(100),pk(C))' where C is Bob\u2019s key and 100 is maturity\n\nThis requires a generalization of the Bitcoin Covenants Idea[1] such that it nicely fits with taproot as follows:\n\n1. A covenant in the form of '_ covenant C\u2019 on output means that it can be spent to an output that maches the covenant pattern with placeholder _  and the output(s) will be assigned 'covenant C'.\n2. A covenant that mandates an output script with alternate validation paths can also assign alternate covernants to be inherited by the output(s) depending on which path was used to spend the input eg. 'covenant or(c covenant C, d covernant D)\u2019\n3. The resulting covenant of outputs should be reduced following boolean algebra, e.g. or(b,or(b,a)) to or(b, a)\n4. express transitivity with 'covenant transitive\u2019 which means the output will have the same covenant as the input\n5. allow to omit covenant on the output with 'covenant drop'\n\nThe covenant Bob would assign to the loan output sent to Alice is: 'covenant or(and(time(100),pk(Bob)) covenant drop, _ covenant transitive)' which means:\n- Alice can send to an output script where she is free to chose the embedded script at the placeholder _ and that output will again have the same covenant as the input.\n- After maturity Bob can claim any coin that is transitively rooted in the loan (more on this later) and the covenant will no longer be assigned to his new output(s).\n\nAssuming Alice wants to send some of the borrowed coins to Charlie:\n\nfor shorter notation lets use b='and(time(100),pk(Bob)) covenant drop\u2019 for the script that gives Bob control after maturity.\n\nAlice can not send to pk(Charlie), but she can send to or(b, pk(Charlie) covenant transitive)\nSending to pk(Charlie) would be sending cash, sending to or(b, pk(Charlie) covenant transitive) is a promissory note issued by Alice to Charlie, here is why:\n\nIf Charlie accepts an or(b, pk(Charlie) covenant transitive) output then he trusts, that Alice will offer a regular payment in exchange for it before maturity, since that output is worthless to Charlie after maturity as Bob can just take it.\n\nIt seems at the first sight that there is no value in these outputs for Charlie, since he still has to ensure Alice replaces them before maturity.\n\nThe value of these outputs to Charlie is the proof that he has exclusive control of the coins until maturity.\nAlice can not issue promissory notes in excess of own capital or capital that she was able to borrow. No coin inflation or fractional reserve here, which also reduces the credit risk Charlie takes.\n\nDue to the transitive covenant Charlie could pass on the coins to an other temporary owner until maturity when Bob would re-collect them unconditionally.\n\nShould Charlie no longer be comfortable with Alice\u2019s promise or need final coins (cash) immediatelly, then he could turn to Dan and do a re-purchase (repo) agreement with him.\n\nCharlie would receive final coins from Dan in exchange for the temporarily controled coins and Charlie's promise to replace them with final coins before maturity.\nDan would thereby charge high interest through a discount since as he has to bear the credit risk of Charlie. This is not a riskless but a plain zero bond.\n\nWhy would Dan want to take temporary control of the coins at all? Again, to ensure Charlie is not doing yet another repo with Frank on the same coins, the sum of Charlie's repo deals are not in excess of his claims against others.\nThis again avoids lending in excess of coin supply and reduces the credit risk Dan takes.\n\nHere are the sketches for the transacions for above alternate actions:\n\nlets use shortcut c for 'or(and(time(100),pk(Bob)) covenant drop, _ covenant transitive)\u2019\n\nthe transactions offer a fee of 0.0001\n\nBob gives a riskless credit to Alice:\n\nInput\t\t\tOutput\n1 pk(Bob) \t\t1 or(b,pk(Alice) covenant c)\n0.1 pk(Alice)\t\t0.9999 pk(Bob)\n\nAlice could send a 0.5 promissory note to Charlie:\n\nInput\t\t\t\t\tOutput\n1 or(pk(Alice) covenant c)\t\t0.5 or(b,pk(Charlie) covenant c)\n1 pk(Alice)\t\t\t\t0.5 or(b,pk(Alice) covenant c)\n\t\t\t\t\t0.9999 pk(Alice)\n\nAlice could make good of the note before maturity, pay some interest and get back temporary control of the coins with:\nInput\t\t\t\t\t\tOutput\n0.5 or(b,pk(Charlie) covenant c)\t\t0.5 or(b,pk(Alice) covenant c)\n0.5101 pk(Alice)\t\t\t\t0.51 pk(Charlie)\n\nalternatively Charlie borrows from Dan at high interest:\n\nInput\t\t\t\t\t\tOutput\n0.5 or(b,pk(Charlie) covenant c)\t\t0.5 or(b,pk(Dan) covenant c)\n0.3001 pk(Dan)\t\t\t\t0.3 pk(Charlie)\n\nand Charlie re-purchases the temporary coins before maturity, making good of the repo with Dan:\n\nInput\t\t\t\t\t\t\tOutput\n0.5 or(b,pk(Dan) covenant c)\t\t\t0.5 or(b,pk(Charlie) covenant c)\n0.5001 pk(Charlie)\t\t\t\t\t0.5 pk(Dan)\n\nWe need to define further transaction level validations for transactions spending inputs with covenants as follows:\n\n1. If there are inputs without covenant before the input with covenant than inputs without covenant must be spent exactly with outputs preceeding the outputs with covenants.\n2. A transaction can have inputs with different covenants, their allocation to outputs should follow input order.\n3. For output(s) that share input(s) with covenant, the sum of covenant outputs must exactly add up to the input(s). This allows merging and splitting them.\n\nBob would re-collect his coins at maturity unconditionally. Who followed through promises or defaulted down the transitive chain is irrelevant to him.\nRemark: we might also need a covenant attribute defining the minimum size of output, so Bob is not forced to collect dust, which would be expensive or even impossible. I am not yet happy with this solution, looking for better.\n\nI am very excited about the possibilities this proposal would unlock and ask you verify usefulness of this scheme and join working out the details and how covenants would be integrated with taproot.\n\nTamas Blummer\n\n[1] Malte Moser, Ittay Eyal, and Emin Gun Sirer. Bitcoin Covenants. URL: http://fc16.ifca.ai/bitcoin/papers/MES16.pdf\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190628/25fe4569/attachment-0001.sig>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2019-06-28T17:25:22",
                "message_text_only": "Hi Tamas,\n\nThere are a number of economic assumptions contained herein. While I understand you would like to focus on implementation, the worst bugs are requirements bugs. IMO these should be addressed first. I\u2019ve addressed some possible issues inline.\n\n> On Jun 28, 2019, at 01:27, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> I start with a formalisation of loans as common in finance:\n> \n> A zero bond is a contract between two parties Alice and Bob whereby Alice receives an amount less than P and has to pay back P at a later time point called maturity.\n> The difference between the amount received and P is the interest implied by the contract. E.g. receiving 1 Bitcoin (<P) and agree to pay back 1.1 (=P) in a year is the same as getting a loan with 10% p.a. interest.\n> \n> The inherent risk in the contract is that Alice may not honor the agreement or be bankrupt by then.\n> \n> If we could programmatically guarantee that Alice honors the contract then we would be able to create a riskless zero bond, the fundation of financial engineering.\n\nI\u2019m not aware of the basis of this statement. While people use the term \u201crisk free rate of return\u201d there has never actually been such a thing. It\u2019s not clear to me how a unicorn has been the foundation of \u201cfinancial engineering\u201d, but I\u2019m not also clear and what is intended by \u201cengineering\u201d in this sense. Generally engineering is the implementation of higher level concepts. It is those concepts that constitute requirements here.\n\nAt a minimum, interest cannot be guaranteed by this proposal, which implies that at best it guarantees, setting aside changes in purchasing power, a return of principle minus economic interest on that principle (ie opportunity cost). Given that purchasing power changes over time, risk increases with the term of the loan. As such this is not riskless - both volatility and opportunity cost remain as risks.\n\n> A systemic problem with loans is that the lender might operate on fractional reserve, that is lending more than his capital.\n\nThis is not a systemic problem, this is the very nature of lending. Fractional reserve is simply a state banking term used to describe the fact that people invest (lend) a fraction of their savings and hoard the rest. It matters not that banks or individuals do this, credit expansion is inherent in economy. Without it there is no investment and therefore no production whatsoever.\n\n> Unchecked inflation of money supply through fractional reserve is creating a mess in the world we live in. Bitcoin could overcome this mess implementing this proposal!\n\nYou seem to be conflating state banking with the effects of investing. Taxpayer support for bank investment creates both a moral hazard (and the resulting misallocation of capital to state-favored projects, creating the famed economic \u201cbusiness cycle\u201d) and is a manifestation of persistent monetary inflation (ie seigniorage is a source taxation. Investment implies credit expansion, and the level of this expansion is controlled by time preference alone.\n\n> I stop here with finance speak as the purpose of this mail is not to dive into finance, but to show how loans with full reserve check could be implemented in Bitcoin.\n> \n> 1. Receiving the loan is a payment from Bob to Alice, but we need a restriction how Alice can use the funds, so Bob can get them back unconditionally at maturity, so lending is riskless to him.\n> 2. Bob wants to receive interest, since he gives up his control of the coins until maturity, he can not use them elsewhere until then. That interest could be paid in advance, this can be solved with Bitcoin as is.\n\nInterest cannot be paid in advance. This implies nothing more than a smaller amount of principle.\n\n> How do we allow Alice to use the coins, that is: split/merge and transfer them to others, but still ensure Bob can claim them back at maturity?\n> \n> We ensure that Alice can only send the coins to outputs that inherit a taproot path of validation (using http://bitcoin.sipa.be/miniscript/): 'and(time(100),pk(C))' where C is Bob\u2019s key and 100 is maturity\n> \n> This requires a generalization of the Bitcoin Covenants Idea[1] such that it nicely fits with taproot as follows:\n> \n> 1. A covenant in the form of '_ covenant C\u2019 on output means that it can be spent to an output that maches the covenant pattern with placeholder _  and the output(s) will be assigned 'covenant C'.\n> 2. A covenant that mandates an output script with alternate validation paths can also assign alternate covernants to be inherited by the output(s) depending on which path was used to spend the input eg. 'covenant or(c covenant C, d covernant D)\u2019\n> 3. The resulting covenant of outputs should be reduced following boolean algebra, e.g. or(b,or(b,a)) to or(b, a)\n> 4. express transitivity with 'covenant transitive\u2019 which means the output will have the same covenant as the input\n> 5. allow to omit covenant on the output with 'covenant drop'\n> \n> The covenant Bob would assign to the loan output sent to Alice is: 'covenant or(and(time(100),pk(Bob)) covenant drop, _ covenant transitive)' which means:\n> - Alice can send to an output script where she is free to chose the embedded script at the placeholder _ and that output will again have the same covenant as the input.\n> - After maturity Bob can claim any coin that is transitively rooted in the loan (more on this later) and the covenant will no longer be assigned to his new output(s).\n> \n> Assuming Alice wants to send some of the borrowed coins to Charlie:\n> \n> for shorter notation lets use b='and(time(100),pk(Bob)) covenant drop\u2019 for the script that gives Bob control after maturity.\n> \n> Alice can not send to pk(Charlie), but she can send to or(b, pk(Charlie) covenant transitive)\n> Sending to pk(Charlie) would be sending cash, sending to or(b, pk(Charlie) covenant transitive) is a promissory note issued by Alice to Charlie, here is why:\n> \n> If Charlie accepts an or(b, pk(Charlie) covenant transitive) output then he trusts, that Alice will offer a regular payment in exchange for it before maturity, since that output is worthless to Charlie after maturity as Bob can just take it.\n> \n> It seems at the first sight that there is no value in these outputs for Charlie, since he still has to ensure Alice replaces them before maturity.\n> \n> The value of these outputs to Charlie is the proof that he has exclusive control of the coins until maturity.\n\nAt a minimum, money that predictably depreciates (to zero in this case) must be discounted accordingly. How much is money worth today that is worth zero tomorrow? This can be observed with both inflation and demurrage money. This also implies that each encumbered coin is not fungible with any other of a distinct discount schedule.\n\nWhat is the economic consequence of lending discounted money? Lower interest rates. How much lower? The rate of depreciation. This can also be observed with inflation and demurrage, but observation isn\u2019t required. This is a necessary outcome.\n\nSo when one lends 1 demurrage coin for a term one cannot earn interest on 1 coin, one is earning interest on a fraction of a coin. That fraction creates credit expansion and reduces return in direct proportion to the risk that has been offset. In other words, the risk cost has been converted to opportunity cost. The discounted fraction earns no interest.\n\nSo credit expansion and risk remain, in the same proportions as without such a system. However lack of fungibility introduces an additional overhead cost.\n\ne\n\n> Alice can not issue promissory notes in excess of own capital or capital that she was able to borrow. No coin inflation or fractional reserve here, which also reduces the credit risk Charlie takes.\n> \n> Due to the transitive covenant Charlie could pass on the coins to an other temporary owner until maturity when Bob would re-collect them unconditionally.\n> \n> Should Charlie no longer be comfortable with Alice\u2019s promise or need final coins (cash) immediatelly, then he could turn to Dan and do a re-purchase (repo) agreement with him.\n> \n> Charlie would receive final coins from Dan in exchange for the temporarily controled coins and Charlie's promise to replace them with final coins before maturity.\n> Dan would thereby charge high interest through a discount since as he has to bear the credit risk of Charlie. This is not a riskless but a plain zero bond.\n> \n> Why would Dan want to take temporary control of the coins at all? Again, to ensure Charlie is not doing yet another repo with Frank on the same coins, the sum of Charlie's repo deals are not in excess of his claims against others.\n> This again avoids lending in excess of coin supply and reduces the credit risk Dan takes.\n> \n> Here are the sketches for the transacions for above alternate actions:\n> \n> lets use shortcut c for 'or(and(time(100),pk(Bob)) covenant drop, _ covenant transitive)\u2019\n> \n> the transactions offer a fee of 0.0001\n> \n> Bob gives a riskless credit to Alice:\n> \n> Input            Output\n> 1 pk(Bob)        1 or(b,pk(Alice) covenant c)\n> 0.1 pk(Alice)        0.9999 pk(Bob)\n> \n> Alice could send a 0.5 promissory note to Charlie:\n> \n> Input                    Output\n> 1 or(pk(Alice) covenant c)        0.5 or(b,pk(Charlie) covenant c)\n> 1 pk(Alice)                0.5 or(b,pk(Alice) covenant c)\n>                    0.9999 pk(Alice)\n> \n> Alice could make good of the note before maturity, pay some interest and get back temporary control of the coins with:\n> Input                        Output\n> 0.5 or(b,pk(Charlie) covenant c)        0.5 or(b,pk(Alice) covenant c)\n> 0.5101 pk(Alice)                0.51 pk(Charlie)\n> \n> alternatively Charlie borrows from Dan at high interest:\n> \n> Input                        Output\n> 0.5 or(b,pk(Charlie) covenant c)        0.5 or(b,pk(Dan) covenant c)\n> 0.3001 pk(Dan)                0.3 pk(Charlie)\n> \n> and Charlie re-purchases the temporary coins before maturity, making good of the repo with Dan:\n> \n> Input                            Output\n> 0.5 or(b,pk(Dan) covenant c)            0.5 or(b,pk(Charlie) covenant c)\n> 0.5001 pk(Charlie)                    0.5 pk(Dan)\n> \n> We need to define further transaction level validations for transactions spending inputs with covenants as follows:\n> \n> 1. If there are inputs without covenant before the input with covenant than inputs without covenant must be spent exactly with outputs preceeding the outputs with covenants.\n> 2. A transaction can have inputs with different covenants, their allocation to outputs should follow input order.\n> 3. For output(s) that share input(s) with covenant, the sum of covenant outputs must exactly add up to the input(s). This allows merging and splitting them.\n> \n> Bob would re-collect his coins at maturity unconditionally. Who followed through promises or defaulted down the transitive chain is irrelevant to him.\n> Remark: we might also need a covenant attribute defining the minimum size of output, so Bob is not forced to collect dust, which would be expensive or even impossible. I am not yet happy with this solution, looking for better.\n> \n> I am very excited about the possibilities this proposal would unlock and ask you verify usefulness of this scheme and join working out the details and how covenants would be integrated with taproot.\n> \n> Tamas Blummer\n> \n> [1] Malte Moser, Ittay Eyal, and Emin Gun Sirer. Bitcoin Covenants. URL: http://fc16.ifca.ai/bitcoin/papers/MES16.pdf\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Tamas Blummer",
                "date": "2019-06-28T19:21:56",
                "message_text_only": "Hi Eric,\n\nThank you for your questions as they show what concepts need further explanation, so you understand the potential of this proposal and how it is helpful to the ecosystem.\n\nRiskless zero bond is in fact the most basic concept of financial engineering. Yes, there are engineers of finance, those who create and price financial derivatives (e.g. options, swaps) and structure products such as e.g. ABS, CDO etc.\nI used to be one of them.\n\nA zero bond formalizes the observation that 1 unit of currency in the future has different value than 1 unit available now. It is called riskless if it is certain to receive the payment in the future.\nIf we put this difference of vaue in relation to the amount then we get the \u201crisk freee rate of return\u201d, that you heard of.\n\nE.g if one is willing to exchange 1 BTC unconditionally available now for 1.1 BTC certainly available in a year but not earlier, then the implied \u201crisk free rate of return\u201d is apparently 10% pa. for Bitcoins.\n\nThe transaction I construct in the first example achives exactly this, because:\n\nBob forgoes his ability to use his unconditionally available coins by giving them to Alice with a covenant that ensures that Bob will receive them back later.\nBob does this because Alice pays for this in advance.\n\nAlice can further transfer the coins encumbered by the covenant, but they will unconditionally return to Bob in the future.\n\nThe utility of these encumbered coins is that they prove that the loan is fully covered by reserves.\n\nHow valuable this utility is will be decided by the market and that value will be interest received by those who temporarily give up control. I am guess the value will be low but positive.\n\nLending does not mandate fractional or full reserves. These are choices the market or regulators enforce. Full reserve banking is not a fiction but is how things worked before introduction of gold receipts. A bank could only lend gold coins it possesed. Perils of fractional reserve were felt repeatedly by the Bitcoin ecnomy e.g. in the collaps of MtGox.\n\nThe idea to return to full reserve banking is not unique to gold bugs or Bitcoin but recently a popular vote was initiated in Switzerland to force Swiss banks to full reserves with respect to lending. This popular vote achived  24% support [1] which is quite remarkable if considered that the topic is not trivial as also our exchange shows.\n\nI published today a writing in medium, that explains the concept of fractional vs. full reserve banking in conjunction with this proposal. Please read: https://medium.com/@tamas.blummer/full-reserve-banking-with-bitcoin-462b21ae9479 <https://medium.com/@tamas.blummer/full-reserve-banking-with-bitcoin-462b21ae9479>\n\nI would welcome feedback on the generalized covenant construct or its implementation, as I think it can open up much more uses than the few examples I gave.\n\nTamas Blummer\n\n[1] Vollgeld Initiative: https://www.bfs.admin.ch/bfs/de/home/statistiken/politik/abstimmungen/jahr-2018/2018-06-10/vollgeld-initiative.html <https://www.bfs.admin.ch/bfs/de/home/statistiken/politik/abstimmungen/jahr-2018/2018-06-10/vollgeld-initiative.html>\n> On Jun 28, 2019, at 19:25, Eric Voskuil <eric at voskuil.org> wrote:\n> \n> Hi Tamas,\n> \n> There are a number of economic assumptions contained herein. While I understand you would like to focus on implementation, the worst bugs are requirements bugs. IMO these should be addressed first. I\u2019ve addressed some possible issues inline.\n> \n>> On Jun 28, 2019, at 01:27, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>> \n>> I start with a formalisation of loans as common in finance:\n>> \n>> A zero bond is a contract between two parties Alice and Bob whereby Alice receives an amount less than P and has to pay back P at a later time point called maturity.\n>> The difference between the amount received and P is the interest implied by the contract. E.g. receiving 1 Bitcoin (<P) and agree to pay back 1.1 (=P) in a year is the same as getting a loan with 10% p.a. interest.\n>> \n>> The inherent risk in the contract is that Alice may not honor the agreement or be bankrupt by then.\n>> \n>> If we could programmatically guarantee that Alice honors the contract then we would be able to create a riskless zero bond, the fundation of financial engineering.\n> \n> I\u2019m not aware of the basis of this statement. While people use the term \u201crisk free rate of return\u201d there has never actually been such a thing. It\u2019s not clear to me how a unicorn has been the foundation of \u201cfinancial engineering\u201d, but I\u2019m not also clear and what is intended by \u201cengineering\u201d in this sense. Generally engineering is the implementation of higher level concepts. It is those concepts that constitute requirements here.\n> \n> At a minimum, interest cannot be guaranteed by this proposal, which implies that at best it guarantees, setting aside changes in purchasing power, a return of principle minus economic interest on that principle (ie opportunity cost). Given that purchasing power changes over time, risk increases with the term of the loan. As such this is not riskless - both volatility and opportunity cost remain as risks.\n> \n>> A systemic problem with loans is that the lender might operate on fractional reserve, that is lending more than his capital.\n> \n> This is not a systemic problem, this is the very nature of lending. Fractional reserve is simply a state banking term used to describe the fact that people invest (lend) a fraction of their savings and hoard the rest. It matters not that banks or individuals do this, credit expansion is inherent in economy. Without it there is no investment and therefore no production whatsoever.\n> \n>> Unchecked inflation of money supply through fractional reserve is creating a mess in the world we live in. Bitcoin could overcome this mess implementing this proposal!\n> \n> You seem to be conflating state banking with the effects of investing. Taxpayer support for bank investment creates both a moral hazard (and the resulting misallocation of capital to state-favored projects, creating the famed economic \u201cbusiness cycle\u201d) and is a manifestation of persistent monetary inflation (ie seigniorage is a source taxation. Investment implies credit expansion, and the level of this expansion is controlled by time preference alone.\n> \n>> I stop here with finance speak as the purpose of this mail is not to dive into finance, but to show how loans with full reserve check could be implemented in Bitcoin.\n>> \n>> 1. Receiving the loan is a payment from Bob to Alice, but we need a restriction how Alice can use the funds, so Bob can get them back unconditionally at maturity, so lending is riskless to him.\n>> 2. Bob wants to receive interest, since he gives up his control of the coins until maturity, he can not use them elsewhere until then. That interest could be paid in advance, this can be solved with Bitcoin as is.\n> \n> Interest cannot be paid in advance. This implies nothing more than a smaller amount of principle.\n> \n>> How do we allow Alice to use the coins, that is: split/merge and transfer them to others, but still ensure Bob can claim them back at maturity?\n>> \n>> We ensure that Alice can only send the coins to outputs that inherit a taproot path of validation (using http://bitcoin.sipa.be/miniscript/): 'and(time(100),pk(C))' where C is Bob\u2019s key and 100 is maturity\n>> \n>> This requires a generalization of the Bitcoin Covenants Idea[1] such that it nicely fits with taproot as follows:\n>> \n>> 1. A covenant in the form of '_ covenant C\u2019 on output means that it can be spent to an output that maches the covenant pattern with placeholder _  and the output(s) will be assigned 'covenant C'.\n>> 2. A covenant that mandates an output script with alternate validation paths can also assign alternate covernants to be inherited by the output(s) depending on which path was used to spend the input eg. 'covenant or(c covenant C, d covernant D)\u2019\n>> 3. The resulting covenant of outputs should be reduced following boolean algebra, e.g. or(b,or(b,a)) to or(b, a)\n>> 4. express transitivity with 'covenant transitive\u2019 which means the output will have the same covenant as the input\n>> 5. allow to omit covenant on the output with 'covenant drop'\n>> \n>> The covenant Bob would assign to the loan output sent to Alice is: 'covenant or(and(time(100),pk(Bob)) covenant drop, _ covenant transitive)' which means:\n>> - Alice can send to an output script where she is free to chose the embedded script at the placeholder _ and that output will again have the same covenant as the input.\n>> - After maturity Bob can claim any coin that is transitively rooted in the loan (more on this later) and the covenant will no longer be assigned to his new output(s).\n>> \n>> Assuming Alice wants to send some of the borrowed coins to Charlie:\n>> \n>> for shorter notation lets use b='and(time(100),pk(Bob)) covenant drop\u2019 for the script that gives Bob control after maturity.\n>> \n>> Alice can not send to pk(Charlie), but she can send to or(b, pk(Charlie) covenant transitive)\n>> Sending to pk(Charlie) would be sending cash, sending to or(b, pk(Charlie) covenant transitive) is a promissory note issued by Alice to Charlie, here is why:\n>> \n>> If Charlie accepts an or(b, pk(Charlie) covenant transitive) output then he trusts, that Alice will offer a regular payment in exchange for it before maturity, since that output is worthless to Charlie after maturity as Bob can just take it.\n>> \n>> It seems at the first sight that there is no value in these outputs for Charlie, since he still has to ensure Alice replaces them before maturity.\n>> \n>> The value of these outputs to Charlie is the proof that he has exclusive control of the coins until maturity.\n> \n> At a minimum, money that predictably depreciates (to zero in this case) must be discounted accordingly. How much is money worth today that is worth zero tomorrow? This can be observed with both inflation and demurrage money. This also implies that each encumbered coin is not fungible with any other of a distinct discount schedule.\n> \n> What is the economic consequence of lending discounted money? Lower interest rates. How much lower? The rate of depreciation. This can also be observed with inflation and demurrage, but observation isn\u2019t required. This is a necessary outcome.\n> \n> So when one lends 1 demurrage coin for a term one cannot earn interest on 1 coin, one is earning interest on a fraction of a coin. That fraction creates credit expansion and reduces return in direct proportion to the risk that has been offset. In other words, the risk cost has been converted to opportunity cost. The discounted fraction earns no interest.\n> \n> So credit expansion and risk remain, in the same proportions as without such a system. However lack of fungibility introduces an additional overhead cost.\n> \n> e\n> \n>> Alice can not issue promissory notes in excess of own capital or capital that she was able to borrow. No coin inflation or fractional reserve here, which also reduces the credit risk Charlie takes.\n>> \n>> Due to the transitive covenant Charlie could pass on the coins to an other temporary owner until maturity when Bob would re-collect them unconditionally.\n>> \n>> Should Charlie no longer be comfortable with Alice\u2019s promise or need final coins (cash) immediatelly, then he could turn to Dan and do a re-purchase (repo) agreement with him.\n>> \n>> Charlie would receive final coins from Dan in exchange for the temporarily controled coins and Charlie's promise to replace them with final coins before maturity.\n>> Dan would thereby charge high interest through a discount since as he has to bear the credit risk of Charlie. This is not a riskless but a plain zero bond.\n>> \n>> Why would Dan want to take temporary control of the coins at all? Again, to ensure Charlie is not doing yet another repo with Frank on the same coins, the sum of Charlie's repo deals are not in excess of his claims against others.\n>> This again avoids lending in excess of coin supply and reduces the credit risk Dan takes.\n>> \n>> Here are the sketches for the transacions for above alternate actions:\n>> \n>> lets use shortcut c for 'or(and(time(100),pk(Bob)) covenant drop, _ covenant transitive)\u2019\n>> \n>> the transactions offer a fee of 0.0001\n>> \n>> Bob gives a riskless credit to Alice:\n>> \n>> Input            Output\n>> 1 pk(Bob)        1 or(b,pk(Alice) covenant c)\n>> 0.1 pk(Alice)        0.9999 pk(Bob)\n>> \n>> Alice could send a 0.5 promissory note to Charlie:\n>> \n>> Input                    Output\n>> 1 or(pk(Alice) covenant c)        0.5 or(b,pk(Charlie) covenant c)\n>> 1 pk(Alice)                0.5 or(b,pk(Alice) covenant c)\n>>                   0.9999 pk(Alice)\n>> \n>> Alice could make good of the note before maturity, pay some interest and get back temporary control of the coins with:\n>> Input                        Output\n>> 0.5 or(b,pk(Charlie) covenant c)        0.5 or(b,pk(Alice) covenant c)\n>> 0.5101 pk(Alice)                0.51 pk(Charlie)\n>> \n>> alternatively Charlie borrows from Dan at high interest:\n>> \n>> Input                        Output\n>> 0.5 or(b,pk(Charlie) covenant c)        0.5 or(b,pk(Dan) covenant c)\n>> 0.3001 pk(Dan)                0.3 pk(Charlie)\n>> \n>> and Charlie re-purchases the temporary coins before maturity, making good of the repo with Dan:\n>> \n>> Input                            Output\n>> 0.5 or(b,pk(Dan) covenant c)            0.5 or(b,pk(Charlie) covenant c)\n>> 0.5001 pk(Charlie)                    0.5 pk(Dan)\n>> \n>> We need to define further transaction level validations for transactions spending inputs with covenants as follows:\n>> \n>> 1. If there are inputs without covenant before the input with covenant than inputs without covenant must be spent exactly with outputs preceeding the outputs with covenants.\n>> 2. A transaction can have inputs with different covenants, their allocation to outputs should follow input order.\n>> 3. For output(s) that share input(s) with covenant, the sum of covenant outputs must exactly add up to the input(s). This allows merging and splitting them.\n>> \n>> Bob would re-collect his coins at maturity unconditionally. Who followed through promises or defaulted down the transitive chain is irrelevant to him.\n>> Remark: we might also need a covenant attribute defining the minimum size of output, so Bob is not forced to collect dust, which would be expensive or even impossible. I am not yet happy with this solution, looking for better.\n>> \n>> I am very excited about the possibilities this proposal would unlock and ask you verify usefulness of this scheme and join working out the details and how covenants would be integrated with taproot.\n>> \n>> Tamas Blummer\n>> \n>> [1] Malte Moser, Ittay Eyal, and Emin Gun Sirer. Bitcoin Covenants. URL: http://fc16.ifca.ai/bitcoin/papers/MES16.pdf\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190628/b6aef1d2/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190628/b6aef1d2/attachment-0001.sig>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2019-06-29T21:21:20",
                "message_text_only": "> On Jun 28, 2019, at 12:21, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n> \n> Hi Eric,\n> \n> Thank you for your questions as they show what concepts need further explanation, so you understand the potential of this proposal and how it is helpful to the ecosystem.\n> \n> Riskless zero bond is in fact the most basic concept of financial engineering. Yes, there are engineers of finance, those who create and price financial derivatives (e.g. options, swaps) and structure products such as e.g. ABS, CDO etc.\n> I used to be one of them.\n> \n> A zero bond formalizes the observation that 1 unit of currency in the future has different value than 1 unit available now. It is called riskless if it is certain to receive the payment in the future.\n> If we put this difference of vaue in relation to the amount then we get the \u201crisk freee rate of return\u201d, that you heard of.\n> \n> E.g if one is willing to exchange 1 BTC unconditionally available now for 1.1 BTC certainly available in a year but not earlier, then the implied \u201crisk free rate of return\u201d is apparently 10% pa. for Bitcoins.\n\nAs I implied, I am well aware of the concept of risk free rate of return, which is a hypothetical.\n\n> The transaction I construct in the first example achives exactly this, because:\n\nWhich implies you have created an actual instance of this heretofore purely hypothetical concept.\n\n> Bob forgoes his ability to use his unconditionally available coins by giving them to Alice with a covenant that ensures that Bob will receive them back later.\n> Bob does this because Alice pays for this in advance. \n> \n> Alice can further transfer the coins encumbered by the covenant, but they will unconditionally return to Bob in the future. \n\nWhy would Alice pay for this at all?\n\n> The utility of these encumbered coins is that they prove that the loan is fully covered by reserves.\n\nWhat loan? Alice has paid Bob for something of no possible utility to her, or anyone else.\n\nBitcoin is a money, not consumable in any way. Its utility arises strictly from the possibility of eventually being traded for something else. The only reason to accept it in trade is that expectation. Removing that possibility, even transitively and over time, removes all utility immediately. In my previous comments I described a necessary discount to NPV, but it\u2019s safe to say that must be 100%.\n\n> How valuable this utility is will be decided by the market\n\nValue is of course subjective, and is determined by individual preferences. Yet what is the value one might place on something of no use? Economically speaking it must be zero, since value is a subjective evaluation of utility (i.e. service to a person).\n\nConsider the case of the 1000 and 500 rupee demonetization. Long lines of people formed at banks to convert to notes to others of equivalent denomination.\n\nhttps://en.m.wikipedia.org/wiki/2016_Indian_banknote_demonetisation\n\nOf course, upon announcement of the demonetization, existing 1000/500 rupee notes were discounted for the cost/risk of accomplishing this conversion (several people are reported to have died in the effort). If there was no such conversion possible, making the notes worthless at the future date, the *immediate* effect would necessarily have been 100% discount.\n\nThis of course sets aside any consumable value of the \u201cpaper\u201d notes, such as burning for heat or trading as novelties (e.g. demonetized Zimbabwean 100T notes currently trading), as Bitcoin is not capable of being consumed. It also sets aside the possibility that some people were unaware of the demonetization.\n\nWho would accept such a note today that was known to be worthless at a future date? If they did, who would would accept it from them? It\u2019s literally an on-chain scamcoin, where the first sucker must find another, and he another, an so on, as soon as possible, before it expires, leaving the last sucker holding the bag. Given an efficient market (i.e perfect knowledge of the scam), zero initial value is implied.\n\n> and that value will be interest received by those who temporarily give up control. I am guess the value will be low but positive.\n\nGiving up control of money for a period does not imply the money is useful to someone else. Bob might as well lock his coins in a time capsule, for which he has the only key, and ask Alice to pay him for it.\n\n> Lending does not mandate fractional or full reserves.\n\nI didn\u2019t say that it does. Lending implies no \u201cmandate\u201d. But the nature of fractional reservation is inherent in every loan/investment. \n\n> These are choices the market or regulators enforce.\n\nFractional reservation is not a consequence of statutory or market controls. The level of hoarding vs. lending is a consequence of individual time preference.\n\n> Full reserve banking is not a fiction but is how things worked before introduction of gold receipts. A bank could only lend gold coins it possesed. Perils of fractional reserve were felt repeatedly by the Bitcoin ecnomy e.g. in the collaps of MtGox.\n\nI don\u2019t believe I called full reserve a fiction. With full reserve there is no possible investment, production or products. Unlikely, and disastrous for humanity, but not provably impossible.\n\nA hazard of viewing economic concepts through a financial lens is that those higher order concepts become obscured by a morass of economically-irrelevant regulation and implementation details.\n\nAt this point we are going to end up in a discussion on what fractional reserve actually is. I\u2019d be happy to have a discussion on the topic, but this list is clearly not a good forum for that.\n\nFurthermore the question of whether or not this proposal is relevant to fractional reserve is moot unless it can be shown that the assumed utility actually exists. So I suggest we take this interesting but secondary question on fractional reserve somewhere else.\n\n> The idea to return to full reserve banking is not unique to gold bugs or Bitcoin but recently a popular vote was initiated in Switzerland to force Swiss banks to full reserves with respect to lending. This popular vote achived  24% support [1] which is quite remarkable if considered that the topic is not trivial as also our exchange shows.\n\nIt shows the breadth of economic ignorance which is not surprising given its counterintuitive nature.\n\nBest,\nEric\n\n> I published today a writing in medium, that explains the concept of fractional vs. full reserve banking in conjunction with this proposal. Please read: https://medium.com/@tamas.blummer/full-reserve-banking-with-bitcoin-462b21ae9479\n> \n> I would welcome feedback on the generalized covenant construct or its implementation, as I think it can open up much more uses than the few examples I gave.\n> \n> Tamas Blummer\n> \n> [1] Vollgeld Initiative: https://www.bfs.admin.ch/bfs/de/home/statistiken/politik/abstimmungen/jahr-2018/2018-06-10/vollgeld-initiative.html\n> \n>> On Jun 28, 2019, at 19:25, Eric Voskuil <eric at voskuil.org> wrote:\n>> \n>> Hi Tamas,\n>> \n>> There are a number of economic assumptions contained herein. While I understand you would like to focus on implementation, the worst bugs are requirements bugs. IMO these should be addressed first. I\u2019ve addressed some possible issues inline.\n>> \n>>> On Jun 28, 2019, at 01:27, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>> \n>>> I start with a formalisation of loans as common in finance:\n>>> \n>>> A zero bond is a contract between two parties Alice and Bob whereby Alice receives an amount less than P and has to pay back P at a later time point called maturity.\n>>> The difference between the amount received and P is the interest implied by the contract. E.g. receiving 1 Bitcoin (<P) and agree to pay back 1.1 (=P) in a year is the same as getting a loan with 10% p.a. interest.\n>>> \n>>> The inherent risk in the contract is that Alice may not honor the agreement or be bankrupt by then.\n>>> \n>>> If we could programmatically guarantee that Alice honors the contract then we would be able to create a riskless zero bond, the fundation of financial engineering.\n>> \n>> I\u2019m not aware of the basis of this statement. While people use the term \u201crisk free rate of return\u201d there has never actually been such a thing. It\u2019s not clear to me how a unicorn has been the foundation of \u201cfinancial engineering\u201d, but I\u2019m not also clear and what is intended by \u201cengineering\u201d in this sense. Generally engineering is the implementation of higher level concepts. It is those concepts that constitute requirements here.\n>> \n>> At a minimum, interest cannot be guaranteed by this proposal, which implies that at best it guarantees, setting aside changes in purchasing power, a return of principle minus economic interest on that principle (ie opportunity cost). Given that purchasing power changes over time, risk increases with the term of the loan. As such this is not riskless - both volatility and opportunity cost remain as risks.\n>> \n>>> A systemic problem with loans is that the lender might operate on fractional reserve, that is lending more than his capital.\n>> \n>> This is not a systemic problem, this is the very nature of lending. Fractional reserve is simply a state banking term used to describe the fact that people invest (lend) a fraction of their savings and hoard the rest. It matters not that banks or individuals do this, credit expansion is inherent in economy. Without it there is no investment and therefore no production whatsoever.\n>> \n>>> Unchecked inflation of money supply through fractional reserve is creating a mess in the world we live in. Bitcoin could overcome this mess implementing this proposal!\n>> \n>> You seem to be conflating state banking with the effects of investing. Taxpayer support for bank investment creates both a moral hazard (and the resulting misallocation of capital to state-favored projects, creating the famed economic \u201cbusiness cycle\u201d) and is a manifestation of persistent monetary inflation (ie seigniorage is a source taxation. Investment implies credit expansion, and the level of this expansion is controlled by time preference alone.\n>> \n>>> I stop here with finance speak as the purpose of this mail is not to dive into finance, but to show how loans with full reserve check could be implemented in Bitcoin.\n>>> \n>>> 1. Receiving the loan is a payment from Bob to Alice, but we need a restriction how Alice can use the funds, so Bob can get them back unconditionally at maturity, so lending is riskless to him.\n>>> 2. Bob wants to receive interest, since he gives up his control of the coins until maturity, he can not use them elsewhere until then. That interest could be paid in advance, this can be solved with Bitcoin as is.\n>> \n>> Interest cannot be paid in advance. This implies nothing more than a smaller amount of principle.\n>> \n>>> How do we allow Alice to use the coins, that is: split/merge and transfer them to others, but still ensure Bob can claim them back at maturity?\n>>> \n>>> We ensure that Alice can only send the coins to outputs that inherit a taproot path of validation (using http://bitcoin.sipa.be/miniscript/): 'and(time(100),pk(C))' where C is Bob\u2019s key and 100 is maturity\n>>> \n>>> This requires a generalization of the Bitcoin Covenants Idea[1] such that it nicely fits with taproot as follows:\n>>> \n>>> 1. A covenant in the form of '_ covenant C\u2019 on output means that it can be spent to an output that maches the covenant pattern with placeholder _  and the output(s) will be assigned 'covenant C'.\n>>> 2. A covenant that mandates an output script with alternate validation paths can also assign alternate covernants to be inherited by the output(s) depending on which path was used to spend the input eg. 'covenant or(c covenant C, d covernant D)\u2019\n>>> 3. The resulting covenant of outputs should be reduced following boolean algebra, e.g. or(b,or(b,a)) to or(b, a)\n>>> 4. express transitivity with 'covenant transitive\u2019 which means the output will have the same covenant as the input\n>>> 5. allow to omit covenant on the output with 'covenant drop'\n>>> \n>>> The covenant Bob would assign to the loan output sent to Alice is: 'covenant or(and(time(100),pk(Bob)) covenant drop, _ covenant transitive)' which means:\n>>> - Alice can send to an output script where she is free to chose the embedded script at the placeholder _ and that output will again have the same covenant as the input.\n>>> - After maturity Bob can claim any coin that is transitively rooted in the loan (more on this later) and the covenant will no longer be assigned to his new output(s).\n>>> \n>>> Assuming Alice wants to send some of the borrowed coins to Charlie:\n>>> \n>>> for shorter notation lets use b='and(time(100),pk(Bob)) covenant drop\u2019 for the script that gives Bob control after maturity.\n>>> \n>>> Alice can not send to pk(Charlie), but she can send to or(b, pk(Charlie) covenant transitive)\n>>> Sending to pk(Charlie) would be sending cash, sending to or(b, pk(Charlie) covenant transitive) is a promissory note issued by Alice to Charlie, here is why:\n>>> \n>>> If Charlie accepts an or(b, pk(Charlie) covenant transitive) output then he trusts, that Alice will offer a regular payment in exchange for it before maturity, since that output is worthless to Charlie after maturity as Bob can just take it.\n>>> \n>>> It seems at the first sight that there is no value in these outputs for Charlie, since he still has to ensure Alice replaces them before maturity.\n>>> \n>>> The value of these outputs to Charlie is the proof that he has exclusive control of the coins until maturity.\n>> \n>> At a minimum, money that predictably depreciates (to zero in this case) must be discounted accordingly. How much is money worth today that is worth zero tomorrow? This can be observed with both inflation and demurrage money. This also implies that each encumbered coin is not fungible with any other of a distinct discount schedule.\n>> \n>> What is the economic consequence of lending discounted money? Lower interest rates. How much lower? The rate of depreciation. This can also be observed with inflation and demurrage, but observation isn\u2019t required. This is a necessary outcome.\n>> \n>> So when one lends 1 demurrage coin for a term one cannot earn interest on 1 coin, one is earning interest on a fraction of a coin. That fraction creates credit expansion and reduces return in direct proportion to the risk that has been offset. In other words, the risk cost has been converted to opportunity cost. The discounted fraction earns no interest.\n>> \n>> So credit expansion and risk remain, in the same proportions as without such a system. However lack of fungibility introduces an additional overhead cost.\n>> \n>> e\n>> \n>>> Alice can not issue promissory notes in excess of own capital or capital that she was able to borrow. No coin inflation or fractional reserve here, which also reduces the credit risk Charlie takes.\n>>> \n>>> Due to the transitive covenant Charlie could pass on the coins to an other temporary owner until maturity when Bob would re-collect them unconditionally.\n>>> \n>>> Should Charlie no longer be comfortable with Alice\u2019s promise or need final coins (cash) immediatelly, then he could turn to Dan and do a re-purchase (repo) agreement with him.\n>>> \n>>> Charlie would receive final coins from Dan in exchange for the temporarily controled coins and Charlie's promise to replace them with final coins before maturity.\n>>> Dan would thereby charge high interest through a discount since as he has to bear the credit risk of Charlie. This is not a riskless but a plain zero bond.\n>>> \n>>> Why would Dan want to take temporary control of the coins at all? Again, to ensure Charlie is not doing yet another repo with Frank on the same coins, the sum of Charlie's repo deals are not in excess of his claims against others.\n>>> This again avoids lending in excess of coin supply and reduces the credit risk Dan takes.\n>>> \n>>> Here are the sketches for the transacions for above alternate actions:\n>>> \n>>> lets use shortcut c for 'or(and(time(100),pk(Bob)) covenant drop, _ covenant transitive)\u2019\n>>> \n>>> the transactions offer a fee of 0.0001\n>>> \n>>> Bob gives a riskless credit to Alice:\n>>> \n>>> Input            Output\n>>> 1 pk(Bob)        1 or(b,pk(Alice) covenant c)\n>>> 0.1 pk(Alice)        0.9999 pk(Bob)\n>>> \n>>> Alice could send a 0.5 promissory note to Charlie:\n>>> \n>>> Input                    Output\n>>> 1 or(pk(Alice) covenant c)        0.5 or(b,pk(Charlie) covenant c)\n>>> 1 pk(Alice)                0.5 or(b,pk(Alice) covenant c)\n>>>                   0.9999 pk(Alice)\n>>> \n>>> Alice could make good of the note before maturity, pay some interest and get back temporary control of the coins with:\n>>> Input                        Output\n>>> 0.5 or(b,pk(Charlie) covenant c)        0.5 or(b,pk(Alice) covenant c)\n>>> 0.5101 pk(Alice)                0.51 pk(Charlie)\n>>> \n>>> alternatively Charlie borrows from Dan at high interest:\n>>> \n>>> Input                        Output\n>>> 0.5 or(b,pk(Charlie) covenant c)        0.5 or(b,pk(Dan) covenant c)\n>>> 0.3001 pk(Dan)                0.3 pk(Charlie)\n>>> \n>>> and Charlie re-purchases the temporary coins before maturity, making good of the repo with Dan:\n>>> \n>>> Input                            Output\n>>> 0.5 or(b,pk(Dan) covenant c)            0.5 or(b,pk(Charlie) covenant c)\n>>> 0.5001 pk(Charlie)                    0.5 pk(Dan)\n>>> \n>>> We need to define further transaction level validations for transactions spending inputs with covenants as follows:\n>>> \n>>> 1. If there are inputs without covenant before the input with covenant than inputs without covenant must be spent exactly with outputs preceeding the outputs with covenants.\n>>> 2. A transaction can have inputs with different covenants, their allocation to outputs should follow input order.\n>>> 3. For output(s) that share input(s) with covenant, the sum of covenant outputs must exactly add up to the input(s). This allows merging and splitting them.\n>>> \n>>> Bob would re-collect his coins at maturity unconditionally. Who followed through promises or defaulted down the transitive chain is irrelevant to him.\n>>> Remark: we might also need a covenant attribute defining the minimum size of output, so Bob is not forced to collect dust, which would be expensive or even impossible. I am not yet happy with this solution, looking for better.\n>>> \n>>> I am very excited about the possibilities this proposal would unlock and ask you verify usefulness of this scheme and join working out the details and how covenants would be integrated with taproot.\n>>> \n>>> Tamas Blummer\n>>> \n>>> [1] Malte Moser, Ittay Eyal, and Emin Gun Sirer. Bitcoin Covenants. URL: http://fc16.ifca.ai/bitcoin/papers/MES16.pdf\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190629/52c9105b/attachment-0001.html>"
            },
            {
                "author": "Tamas Blummer",
                "date": "2019-06-30T10:56:46",
                "message_text_only": "Hi Eric,\n\n> On Jun 29, 2019, at 23:21, Eric Voskuil <eric at voskuil.org> wrote:\n> \n> What loan? Alice has paid Bob for something of no possible utility to her, or anyone else.\n> \n\nCoins encumbered with the described covenant represent temporary control of a scarce resource.\n\nCan this obtain value? That depends on the availability of final control and ability to deal with temporary control.\n\nAn example where final control is not available are areas and jurisdictions where land can not be bought only long time rents are offered.\nPeople pay high prices there to step in place of the renter in an existing long term rent contract and they figured out the contracts that work under these restrictions.\n\nBitcoin\u2019s predominant use is already store of value. Many assume not only wealth preservation but that it would allow to purchase of more goods in the future than now.\nThis leads to unwillingnes to give up final control, which can resolve in two ways:\n\n- Increasing fiat prices for final control. We see this, and is actually further reinforcing unwillingnes to give up final control.\n- dealing with temporary control. We do not yet have the technical means of even representing this. Developing them is my goal.\n\nI think you do not show the neccesary respect of the market.\n\nYour rant reminds me of renowed economists who still argue final control Bitcoin can not have value, you do the same proclaiming that temporary control of Bitcoin can not have value.\n\nI say, that temporary control does not have value until means dealing with it are offered, and that is I work on. Thereafter might obtain value if final control is deemed too expensive or not attainable, we shall see.\n\nTamas Blummer\n\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190630/936be150/attachment.sig>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2019-06-30T17:41:33",
                "message_text_only": "> On Jun 30, 2019, at 03:56, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n> \n> Hi Eric,\n> \n>> On Jun 29, 2019, at 23:21, Eric Voskuil <eric at voskuil.org> wrote:\n>> \n>> What loan? Alice has paid Bob for something of no possible utility to her, or anyone else.\n>> \n> \n> Coins encumbered with the described covenant represent temporary control of a scarce resource.\n> \n> Can this obtain value? That depends on the availability of final control and ability to deal with temporary control.\n\nFor something to become property (and therefore have marketable value) requires that it be both scarce and useful. Bitcoin is useful only to the extent that it can be traded for something else that is useful. Above you are only dealing with scarcity, ignoring utility.\n\n> An example where final control is not available are areas and jurisdictions where land can not be bought only long time rents are offered.\n> People pay high prices there to step in place of the renter in an existing long term rent contract and they figured out the contracts that work under these restrictions.\n\nI was careful to point out that bitcoin is not in any way consumable. Occupying scarce land is a service to people. Units of bitcoin encumbered such that they cannot be traded for something of service to a person do not constitute property. You cannot even polish them, stack them on the floor, and roll around on them.\n\n> Bitcoin\u2019s predominant use is already store of value. Many assume not only wealth preservation but that it would allow to purchase of more goods in the future than now.\n\nYet it has been established that these encumbered coins cannot purchase anything of value except to the extent that an imperfect market is unaware of the scam.\n\n> This leads to unwillingnes to give up final control, which can resolve in two ways:\n> \n> - Increasing fiat prices for final control. We see this, and is actually further reinforcing unwillingnes to give up final control.\n> - dealing with temporary control. We do not yet have the technical means of even representing this. Developing them is my goal.\n\nYour goal is clear and not at issue.\n\n> I think you do not show the neccesary respect of the market.\n\nI\u2019m not sure what is meant here by respect, or how much of it is necessary. I am merely explaining the market.\n\n> Your rant reminds me of renowed economists who still argue final control Bitcoin can not have value, you do the same proclaiming that temporary control of Bitcoin can not have value.\n\nIt seems to me you have reversed the meaning of temporary and final. Bitcoin is useful because of the presumption that there is no finality of control. One presumes an ability to trade control of it for something else. This is temporary control. Final control would be the case in which, at some point, it can no longer be traded, making it worthless at that point. If this is known to be the case it implies that it it worthless at all prior points as well.\n\nThese are distinct scenarios. The fact that temporary (in my usage) control implies the possibility of value does not imply that finality of control does as well. The fact that (renowned or otherwise) people have made errors does not imply that I am making an error. These are both non-sequiturs.\n\n> I say, that temporary control does not have value until means dealing with it are offered, and that is I work on. Thereafter might obtain value if final control is deemed too expensive or not attainable, we shall see.\n\nThe analogy to rental of a consumable good does not apply to the case of a non-consumable good. If it cannot be traded and cannot be consumed it cannot obtain marketable value. To this point it matters not whether it exists.\n\nBest,\nEric\n\n> Tamas Blummer\n> \n>"
            },
            {
                "author": "Tamas Blummer",
                "date": "2019-06-30T18:35:33",
                "message_text_only": "> On Jun 30, 2019, at 19:41, Eric Voskuil <eric at voskuil.org> wrote:\n> \n> \n>> On Jun 30, 2019, at 03:56, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n>> \n>> Hi Eric,\n>> \n>>> On Jun 29, 2019, at 23:21, Eric Voskuil <eric at voskuil.org> wrote:\n>>> \n>>> What loan? Alice has paid Bob for something of no possible utility to her, or anyone else.\n>>> \n>> \n>> Coins encumbered with the described covenant represent temporary control of a scarce resource.\n>> \n>> Can this obtain value? That depends on the availability of final control and ability to deal with temporary control.\n> \n> For something to become property (and therefore have marketable value) requires that it be both scarce and useful. Bitcoin is useful only to the extent that it can be traded for something else that is useful. Above you are only dealing with scarcity, ignoring utility.\n\nThere is a deeper utility of Bitcoin than it can be traded for something else. That utility is to use its unforgeable register.\nWe have only one kind of units in this register and by having covenants we would create other kinds that are while encumbered not fungible with the common ones.\n\nUnits are certainly less desirable if encumbered with a debt covenant. You say no one would assign them any value.\n\nI am not that sure as they still offer the utility of using the unforgeable register, in this case a register of debt covered by reserves.\nYou also doubt forcing debt to be covered by reserves is a good idea, I got that, but suppose we do not discuss this here.\nIf there are people who think it is a good idea, then they would find having an unforgeable register of it useful and therefore units needed to maintain that register valuable to some extent.\n\n> \n>> I think you do not show the neccesary respect of the market.\n> \n> I\u2019m not sure what is meant here by respect, or how much of it is necessary. I am merely explaining the market.\n> \n\nYou are not explaining an existing market but claim that market that is not yet there will follow your arguments.\n\n>> Your rant reminds me of renowed economists who still argue final control Bitcoin can not have value, you do the same proclaiming that temporary control of Bitcoin can not have value.\n> \n> It seems to me you have reversed the meaning of temporary and final. Bitcoin is useful because of the presumption that there is no finality of control. One presumes an ability to trade control of it for something else. This is temporary control. Final control would be the case in which, at some point, it can no longer be traded, making it worthless at that point. If this is known to be the case it implies that it it worthless at all prior points as well.\n> \n> These are distinct scenarios. The fact that temporary (in my usage) control implies the possibility of value does not imply that finality of control does as well. The fact that (renowned or otherwise) people have made errors does not imply that I am making an error. These are both non-sequiturs.\n> \n>> I say, that temporary control does not have value until means dealing with it are offered, and that is I work on. Thereafter might obtain value if final control is deemed too expensive or not attainable, we shall see.\n> \n> The analogy to rental of a consumable good does not apply to the case of a non-consumable good. If it cannot be traded and cannot be consumed it cannot obtain marketable value. To this point it matters not whether it exists.\n> \n\nI meant with control the control of entries in the register which I think is the deeper utility of Bitcoin. Final control is meant to be the opposite of temporary which is the time limited control with some expiry.\n\nThank you for your thoughts as they help to sharpen my arguments.\n\nBest,\n\nTamas Blummer\n\n> Best,\n> Eric\n> \n>> Tamas Blummer\n>> \n>> \n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190630/cf9f6ebc/attachment.sig>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2019-06-30T18:54:45",
                "message_text_only": "Could you please explain the meaning and utility of \u201cunforgeable register\u201d as it pertains to such encumbered coins?\n\nThe meaning in terms of Bitcoin is clear - the \u201cowner\u201d of outputs that represent value (i.e. in the ability to trade them for something else) is recorded publicly and, given Bitcoin security assumptions, cannot be faked. What is not clear is the utility of a record of outputs that cannot be traded for something else. You seem to imply that a record is valuable simply because it\u2019s a record.\n\ne\n\n> On Jun 30, 2019, at 11:35, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n> \n> \n>> On Jun 30, 2019, at 19:41, Eric Voskuil <eric at voskuil.org> wrote:\n>> \n>> \n>>> On Jun 30, 2019, at 03:56, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n>>> \n>>> Hi Eric,\n>>> \n>>>> On Jun 29, 2019, at 23:21, Eric Voskuil <eric at voskuil.org> wrote:\n>>>> \n>>>> What loan? Alice has paid Bob for something of no possible utility to her, or anyone else.\n>>>> \n>>> \n>>> Coins encumbered with the described covenant represent temporary control of a scarce resource.\n>>> \n>>> Can this obtain value? That depends on the availability of final control and ability to deal with temporary control.\n>> \n>> For something to become property (and therefore have marketable value) requires that it be both scarce and useful. Bitcoin is useful only to the extent that it can be traded for something else that is useful. Above you are only dealing with scarcity, ignoring utility.\n> \n> There is a deeper utility of Bitcoin than it can be traded for something else. That utility is to use its unforgeable register.\n> We have only one kind of units in this register and by having covenants we would create other kinds that are while encumbered not fungible with the common ones.\n> \n> Units are certainly less desirable if encumbered with a debt covenant. You say no one would assign them any value.\n> \n> I am not that sure as they still offer the utility of using the unforgeable register, in this case a register of debt covered by reserves.\n> You also doubt forcing debt to be covered by reserves is a good idea, I got that, but suppose we do not discuss this here.\n> If there are people who think it is a good idea, then they would find having an unforgeable register of it useful and therefore units needed to maintain that register valuable to some extent.\n> \n>> \n>>> I think you do not show the neccesary respect of the market.\n>> \n>> I\u2019m not sure what is meant here by respect, or how much of it is necessary. I am merely explaining the market.\n>> \n> \n> You are not explaining an existing market but claim that market that is not yet there will follow your arguments.\n> \n>>> Your rant reminds me of renowed economists who still argue final control Bitcoin can not have value, you do the same proclaiming that temporary control of Bitcoin can not have value.\n>> \n>> It seems to me you have reversed the meaning of temporary and final. Bitcoin is useful because of the presumption that there is no finality of control. One presumes an ability to trade control of it for something else. This is temporary control. Final control would be the case in which, at some point, it can no longer be traded, making it worthless at that point. If this is known to be the case it implies that it it worthless at all prior points as well.\n>> \n>> These are distinct scenarios. The fact that temporary (in my usage) control implies the possibility of value does not imply that finality of control does as well. The fact that (renowned or otherwise) people have made errors does not imply that I am making an error. These are both non-sequiturs.\n>> \n>>> I say, that temporary control does not have value until means dealing with it are offered, and that is I work on. Thereafter might obtain value if final control is deemed too expensive or not attainable, we shall see.\n>> \n>> The analogy to rental of a consumable good does not apply to the case of a non-consumable good. If it cannot be traded and cannot be consumed it cannot obtain marketable value. To this point it matters not whether it exists.\n>> \n> \n> I meant with control the control of entries in the register which I think is the deeper utility of Bitcoin. Final control is meant to be the opposite of temporary which is the time limited control with some expiry.\n> \n> Thank you for your thoughts as they help to sharpen my arguments.\n> \n> Best,\n> \n> Tamas Blummer\n> \n>> Best,\n>> Eric\n>> \n>>> Tamas Blummer\n>>> \n>>> \n>"
            },
            {
                "author": "Tamas Blummer",
                "date": "2019-06-30T19:55:41",
                "message_text_only": "> On Jun 30, 2019, at 20:54, Eric Voskuil <eric at voskuil.org> wrote:\n> \n> Could you please explain the meaning and utility of \u201cunforgeable register\u201d as it pertains to such encumbered coins?\n\nI guess we agree that some way of keeping track of ownership is prerequisite for something to aquire value.\nWe likely also agree that the security of that ownership register has great influence to the value.\n\nThe question remains if a register as utility in itself gives value to the thing needed to use that register.\nI think it does, if people are interested in what it keeps track of, for whatever reason, even for reasons you find bogus.\n\nIt was not intentional, but I think I just explained why Ethereum aquired higher market value by being register of ICO tokens.\n\nNow back to the coins encumbered with the debt covenant:\nTransactions moving them constitute a register of covered debt and you need them to update that register.\nShould some people find such a register useful then those coins needed to update this register will aquire value.\nDoes not matter if you think the concept of covered debt is just as bogus as ICOs.\n\nHere some good news: If they aquire value then they offer a way to generate income for hodler by temporarily giving up control.\n\nTamas Blummer\n\n> \n> The meaning in terms of Bitcoin is clear - the \u201cowner\u201d of outputs that represent value (i.e. in the ability to trade them for something else) is recorded publicly and, given Bitcoin security assumptions, cannot be faked. What is not clear is the utility of a record of outputs that cannot be traded for something else. You seem to imply that a record is valuable simply because it\u2019s a record.\n> \n> e\n> \n>> On Jun 30, 2019, at 11:35, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n>> \n>> \n>>> On Jun 30, 2019, at 19:41, Eric Voskuil <eric at voskuil.org> wrote:\n>>> \n>>> \n>>>> On Jun 30, 2019, at 03:56, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n>>>> \n>>>> Hi Eric,\n>>>> \n>>>>> On Jun 29, 2019, at 23:21, Eric Voskuil <eric at voskuil.org> wrote:\n>>>>> \n>>>>> What loan? Alice has paid Bob for something of no possible utility to her, or anyone else.\n>>>>> \n>>>> \n>>>> Coins encumbered with the described covenant represent temporary control of a scarce resource.\n>>>> \n>>>> Can this obtain value? That depends on the availability of final control and ability to deal with temporary control.\n>>> \n>>> For something to become property (and therefore have marketable value) requires that it be both scarce and useful. Bitcoin is useful only to the extent that it can be traded for something else that is useful. Above you are only dealing with scarcity, ignoring utility.\n>> \n>> There is a deeper utility of Bitcoin than it can be traded for something else. That utility is to use its unforgeable register.\n>> We have only one kind of units in this register and by having covenants we would create other kinds that are while encumbered not fungible with the common ones.\n>> \n>> Units are certainly less desirable if encumbered with a debt covenant. You say no one would assign them any value.\n>> \n>> I am not that sure as they still offer the utility of using the unforgeable register, in this case a register of debt covered by reserves.\n>> You also doubt forcing debt to be covered by reserves is a good idea, I got that, but suppose we do not discuss this here.\n>> If there are people who think it is a good idea, then they would find having an unforgeable register of it useful and therefore units needed to maintain that register valuable to some extent.\n>> \n>>> \n>>>> I think you do not show the neccesary respect of the market.\n>>> \n>>> I\u2019m not sure what is meant here by respect, or how much of it is necessary. I am merely explaining the market.\n>>> \n>> \n>> You are not explaining an existing market but claim that market that is not yet there will follow your arguments.\n>> \n>>>> Your rant reminds me of renowed economists who still argue final control Bitcoin can not have value, you do the same proclaiming that temporary control of Bitcoin can not have value.\n>>> \n>>> It seems to me you have reversed the meaning of temporary and final. Bitcoin is useful because of the presumption that there is no finality of control. One presumes an ability to trade control of it for something else. This is temporary control. Final control would be the case in which, at some point, it can no longer be traded, making it worthless at that point. If this is known to be the case it implies that it it worthless at all prior points as well.\n>>> \n>>> These are distinct scenarios. The fact that temporary (in my usage) control implies the possibility of value does not imply that finality of control does as well. The fact that (renowned or otherwise) people have made errors does not imply that I am making an error. These are both non-sequiturs.\n>>> \n>>>> I say, that temporary control does not have value until means dealing with it are offered, and that is I work on. Thereafter might obtain value if final control is deemed too expensive or not attainable, we shall see.\n>>> \n>>> The analogy to rental of a consumable good does not apply to the case of a non-consumable good. If it cannot be traded and cannot be consumed it cannot obtain marketable value. To this point it matters not whether it exists.\n>>> \n>> \n>> I meant with control the control of entries in the register which I think is the deeper utility of Bitcoin. Final control is meant to be the opposite of temporary which is the time limited control with some expiry.\n>> \n>> Thank you for your thoughts as they help to sharpen my arguments.\n>> \n>> Best,\n>> \n>> Tamas Blummer\n>> \n>>> Best,\n>>> Eric\n>>> \n>>>> Tamas Blummer\n>>>> \n>>>> \n>> \n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190630/cdfe49a4/attachment-0001.sig>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2019-06-30T20:13:02",
                "message_text_only": "ICO tokens can be traded (indefinitely) for other things of value, so the comparison isn\u2019t valid. I think we\u2019ve both made our points clearly, so I\u2019ll leave it at that.\n\nBest,\nEric\n\n> On Jun 30, 2019, at 12:55, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n> \n> \n>> On Jun 30, 2019, at 20:54, Eric Voskuil <eric at voskuil.org> wrote:\n>> \n>> Could you please explain the meaning and utility of \u201cunforgeable register\u201d as it pertains to such encumbered coins?\n> \n> I guess we agree that some way of keeping track of ownership is prerequisite for something to aquire value.\n> We likely also agree that the security of that ownership register has great influence to the value.\n> \n> The question remains if a register as utility in itself gives value to the thing needed to use that register.\n> I think it does, if people are interested in what it keeps track of, for whatever reason, even for reasons you find bogus.\n> \n> It was not intentional, but I think I just explained why Ethereum aquired higher market value by being register of ICO tokens.\n> \n> Now back to the coins encumbered with the debt covenant:\n> Transactions moving them constitute a register of covered debt and you need them to update that register.\n> Should some people find such a register useful then those coins needed to update this register will aquire value.\n> Does not matter if you think the concept of covered debt is just as bogus as ICOs.\n> \n> Here some good news: If they aquire value then they offer a way to generate income for hodler by temporarily giving up control.\n> \n> Tamas Blummer\n> \n>> \n>> The meaning in terms of Bitcoin is clear - the \u201cowner\u201d of outputs that represent value (i.e. in the ability to trade them for something else) is recorded publicly and, given Bitcoin security assumptions, cannot be faked. What is not clear is the utility of a record of outputs that cannot be traded for something else. You seem to imply that a record is valuable simply because it\u2019s a record.\n>> \n>> e\n>> \n>>> On Jun 30, 2019, at 11:35, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n>>> \n>>> \n>>>> On Jun 30, 2019, at 19:41, Eric Voskuil <eric at voskuil.org> wrote:\n>>>> \n>>>> \n>>>>> On Jun 30, 2019, at 03:56, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n>>>>> \n>>>>> Hi Eric,\n>>>>> \n>>>>>> On Jun 29, 2019, at 23:21, Eric Voskuil <eric at voskuil.org> wrote:\n>>>>>> \n>>>>>> What loan? Alice has paid Bob for something of no possible utility to her, or anyone else.\n>>>>>> \n>>>>> \n>>>>> Coins encumbered with the described covenant represent temporary control of a scarce resource.\n>>>>> \n>>>>> Can this obtain value? That depends on the availability of final control and ability to deal with temporary control.\n>>>> \n>>>> For something to become property (and therefore have marketable value) requires that it be both scarce and useful. Bitcoin is useful only to the extent that it can be traded for something else that is useful. Above you are only dealing with scarcity, ignoring utility.\n>>> \n>>> There is a deeper utility of Bitcoin than it can be traded for something else. That utility is to use its unforgeable register.\n>>> We have only one kind of units in this register and by having covenants we would create other kinds that are while encumbered not fungible with the common ones.\n>>> \n>>> Units are certainly less desirable if encumbered with a debt covenant. You say no one would assign them any value.\n>>> \n>>> I am not that sure as they still offer the utility of using the unforgeable register, in this case a register of debt covered by reserves.\n>>> You also doubt forcing debt to be covered by reserves is a good idea, I got that, but suppose we do not discuss this here.\n>>> If there are people who think it is a good idea, then they would find having an unforgeable register of it useful and therefore units needed to maintain that register valuable to some extent.\n>>> \n>>>> \n>>>>> I think you do not show the neccesary respect of the market.\n>>>> \n>>>> I\u2019m not sure what is meant here by respect, or how much of it is necessary. I am merely explaining the market.\n>>>> \n>>> \n>>> You are not explaining an existing market but claim that market that is not yet there will follow your arguments.\n>>> \n>>>>> Your rant reminds me of renowed economists who still argue final control Bitcoin can not have value, you do the same proclaiming that temporary control of Bitcoin can not have value.\n>>>> \n>>>> It seems to me you have reversed the meaning of temporary and final. Bitcoin is useful because of the presumption that there is no finality of control. One presumes an ability to trade control of it for something else. This is temporary control. Final control would be the case in which, at some point, it can no longer be traded, making it worthless at that point. If this is known to be the case it implies that it it worthless at all prior points as well.\n>>>> \n>>>> These are distinct scenarios. The fact that temporary (in my usage) control implies the possibility of value does not imply that finality of control does as well. The fact that (renowned or otherwise) people have made errors does not imply that I am making an error. These are both non-sequiturs.\n>>>> \n>>>>> I say, that temporary control does not have value until means dealing with it are offered, and that is I work on. Thereafter might obtain value if final control is deemed too expensive or not attainable, we shall see.\n>>>> \n>>>> The analogy to rental of a consumable good does not apply to the case of a non-consumable good. If it cannot be traded and cannot be consumed it cannot obtain marketable value. To this point it matters not whether it exists.\n>>>> \n>>> \n>>> I meant with control the control of entries in the register which I think is the deeper utility of Bitcoin. Final control is meant to be the opposite of temporary which is the time limited control with some expiry.\n>>> \n>>> Thank you for your thoughts as they help to sharpen my arguments.\n>>> \n>>> Best,\n>>> \n>>> Tamas Blummer\n>>> \n>>>> Best,\n>>>> Eric\n>>>> \n>>>>> Tamas Blummer\n>>>>> \n>>>>> \n>>> \n>"
            },
            {
                "author": "Tamas Blummer",
                "date": "2019-06-30T20:26:29",
                "message_text_only": "My argument does not need the comparison with ICOs.\n\nThey were just an example that people pay for the utility of register even though others think the tokens they keep track of are worthless.\n\nTamas Blummer\n\n\n> On Jun 30, 2019, at 22:13, Eric Voskuil <eric at voskuil.org> wrote:\n> \n> ICO tokens can be traded (indefinitely) for other things of value, so the comparison isn\u2019t valid. I think we\u2019ve both made our points clearly, so I\u2019ll leave it at that.\n> \n> Best,\n> Eric\n> \n>> On Jun 30, 2019, at 12:55, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n>> \n>> \n>>> On Jun 30, 2019, at 20:54, Eric Voskuil <eric at voskuil.org> wrote:\n>>> \n>>> Could you please explain the meaning and utility of \u201cunforgeable register\u201d as it pertains to such encumbered coins?\n>> \n>> I guess we agree that some way of keeping track of ownership is prerequisite for something to aquire value.\n>> We likely also agree that the security of that ownership register has great influence to the value.\n>> \n>> The question remains if a register as utility in itself gives value to the thing needed to use that register.\n>> I think it does, if people are interested in what it keeps track of, for whatever reason, even for reasons you find bogus.\n>> \n>> It was not intentional, but I think I just explained why Ethereum aquired higher market value by being register of ICO tokens.\n>> \n>> Now back to the coins encumbered with the debt covenant:\n>> Transactions moving them constitute a register of covered debt and you need them to update that register.\n>> Should some people find such a register useful then those coins needed to update this register will aquire value.\n>> Does not matter if you think the concept of covered debt is just as bogus as ICOs.\n>> \n>> Here some good news: If they aquire value then they offer a way to generate income for hodler by temporarily giving up control.\n>> \n>> Tamas Blummer\n>> \n>>> \n>>> The meaning in terms of Bitcoin is clear - the \u201cowner\u201d of outputs that represent value (i.e. in the ability to trade them for something else) is recorded publicly and, given Bitcoin security assumptions, cannot be faked. What is not clear is the utility of a record of outputs that cannot be traded for something else. You seem to imply that a record is valuable simply because it\u2019s a record.\n>>> \n>>> e\n>>> \n>>>> On Jun 30, 2019, at 11:35, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n>>>> \n>>>> \n>>>>> On Jun 30, 2019, at 19:41, Eric Voskuil <eric at voskuil.org> wrote:\n>>>>> \n>>>>> \n>>>>>> On Jun 30, 2019, at 03:56, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n>>>>>> \n>>>>>> Hi Eric,\n>>>>>> \n>>>>>>> On Jun 29, 2019, at 23:21, Eric Voskuil <eric at voskuil.org> wrote:\n>>>>>>> \n>>>>>>> What loan? Alice has paid Bob for something of no possible utility to her, or anyone else.\n>>>>>>> \n>>>>>> \n>>>>>> Coins encumbered with the described covenant represent temporary control of a scarce resource.\n>>>>>> \n>>>>>> Can this obtain value? That depends on the availability of final control and ability to deal with temporary control.\n>>>>> \n>>>>> For something to become property (and therefore have marketable value) requires that it be both scarce and useful. Bitcoin is useful only to the extent that it can be traded for something else that is useful. Above you are only dealing with scarcity, ignoring utility.\n>>>> \n>>>> There is a deeper utility of Bitcoin than it can be traded for something else. That utility is to use its unforgeable register.\n>>>> We have only one kind of units in this register and by having covenants we would create other kinds that are while encumbered not fungible with the common ones.\n>>>> \n>>>> Units are certainly less desirable if encumbered with a debt covenant. You say no one would assign them any value.\n>>>> \n>>>> I am not that sure as they still offer the utility of using the unforgeable register, in this case a register of debt covered by reserves.\n>>>> You also doubt forcing debt to be covered by reserves is a good idea, I got that, but suppose we do not discuss this here.\n>>>> If there are people who think it is a good idea, then they would find having an unforgeable register of it useful and therefore units needed to maintain that register valuable to some extent.\n>>>> \n>>>>> \n>>>>>> I think you do not show the neccesary respect of the market.\n>>>>> \n>>>>> I\u2019m not sure what is meant here by respect, or how much of it is necessary. I am merely explaining the market.\n>>>>> \n>>>> \n>>>> You are not explaining an existing market but claim that market that is not yet there will follow your arguments.\n>>>> \n>>>>>> Your rant reminds me of renowed economists who still argue final control Bitcoin can not have value, you do the same proclaiming that temporary control of Bitcoin can not have value.\n>>>>> \n>>>>> It seems to me you have reversed the meaning of temporary and final. Bitcoin is useful because of the presumption that there is no finality of control. One presumes an ability to trade control of it for something else. This is temporary control. Final control would be the case in which, at some point, it can no longer be traded, making it worthless at that point. If this is known to be the case it implies that it it worthless at all prior points as well.\n>>>>> \n>>>>> These are distinct scenarios. The fact that temporary (in my usage) control implies the possibility of value does not imply that finality of control does as well. The fact that (renowned or otherwise) people have made errors does not imply that I am making an error. These are both non-sequiturs.\n>>>>> \n>>>>>> I say, that temporary control does not have value until means dealing with it are offered, and that is I work on. Thereafter might obtain value if final control is deemed too expensive or not attainable, we shall see.\n>>>>> \n>>>>> The analogy to rental of a consumable good does not apply to the case of a non-consumable good. If it cannot be traded and cannot be consumed it cannot obtain marketable value. To this point it matters not whether it exists.\n>>>>> \n>>>> \n>>>> I meant with control the control of entries in the register which I think is the deeper utility of Bitcoin. Final control is meant to be the opposite of temporary which is the time limited control with some expiry.\n>>>> \n>>>> Thank you for your thoughts as they help to sharpen my arguments.\n>>>> \n>>>> Best,\n>>>> \n>>>> Tamas Blummer\n>>>> \n>>>>> Best,\n>>>>> Eric\n>>>>> \n>>>>>> Tamas Blummer\n>>>>>> \n>>>>>> \n>>>> \n>> \n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190630/b632dbbf/attachment.sig>"
            },
            {
                "author": "David A. Harding",
                "date": "2019-06-29T18:21:03",
                "message_text_only": "On Fri, Jun 28, 2019 at 10:27:16AM +0200, Tamas Blummer via bitcoin-dev wrote:\n> The value of these outputs to Charlie is the proof that he has\n> exclusive control of the coins until maturity.\n>\n> Alice can not issue promissory notes in excess of own capital or\n> capital that she was able to borrow. No coin inflation or fractional\n> reserve here, which also reduces the credit risk Charlie takes.\n\nI believe these goals are obtainable today without any consensus\nchanges.  Bob can provably timelock bitcoins using CLTV or CSV in a\nscript that commits to the outpoint (txid, vout) of an output that will\nbe used as a colored coin to track the debt instrument.  The colored\ncoin, which has no appreciable onchain value itself, can then be\ntrustlessly traded, e.g. from Alice to Charlie to Dan as you describe.  \n\nAnyone with a copy of the script Bob paid, the confirmed transaction he\nincluded it in, and the confirmed transaction history of the colored\ncoin can trustlessly verify the ownership record---including that no\ninflation or fractional reserve occurred.\n\nI believe the RGB working group has set for itself the goal[1] of making\ntrustless colored coin protocols more efficient when performed on top of\nBitcoin.  I'd also suggest reading about Peter Todd's concept of\nsingle-use seals[2].  You may want to investigate these ideas and see\nwhether they can be integrated with your own.\n\n[1] https://github.com/rgb-org/spec/blob/master/00-introduction.md\n[2] https://petertodd.org/2016/commitments-and-single-use-seals#bitcoin-transaction-outputs-as-single-use-seals\n\n-Dave"
            }
        ],
        "thread_summary": {
            "title": "Generalized covenants with taproot enable riskless or risky lending, prevent credit inflation through fractional reserve",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Eric Voskuil",
                "Tamas Blummer",
                "David A. Harding"
            ],
            "messages_count": 12,
            "total_messages_chars_count": 89113
        }
    },
    {
        "title": "[bitcoin-dev] Generalized covenant to implement side chains embedded into the bitcoin block chain",
        "thread_messages": [
            {
                "author": "Tamas Blummer",
                "date": "2019-06-29T05:53:57",
                "message_text_only": "I introduced you to gerneralized covenants[1] earlier, but in a domain specific context that de-routed us from technical discussion. Let me demonstrate the concept in a more generic use:\n\nA covenant\n\nor(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\n\nwould put a coin under the alternative control of a Transfer and Exit keys together with the script in control of the current owner.\nAdditional transaction level validations of transactions spending input with covenants apply as in [1]\n\nOwner of such coins would be able to transfer them to others provided an addtional Transfer signature, in which case the coin remains encumbered with the same covenant.\nIf Exit and owner signs the covenant is dropped on the output, it becomes a plain Bitcoin again.\n\nThe Thransfer and Exit signatures could be threshold signatures of a federation, whereby member decide if the proposed transfer transaction complies with whatever unique rules they impose.\n\nThe result is a federated side chain embedded into the Bitcoin block chain.\n\nBob could purchase some asset guarded by the federation with a transaction:\n\nInputs\n100.0001 pk(Bob)\n\nOutputs\n0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\n99.9 pk(Transfer)\n\nTransfer to Alice with consent of the transfer validators:\n\nInputs\n0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\n100.001 pk(Alice)\n\nOutputs\n0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\n100 pk(Bob)\n\nAlice might be approved to exit with the exit signature of the federation:\n\nInputs\n0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\n99.9 pk(Transfer)\n\nOutputs\n99.9999 pk(Alice)\n\nTamas Blummer\n[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017059.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017059.html>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190629/090fe907/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190629/090fe907/attachment.sig>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-29T20:25:07",
                "message_text_only": "Good morning Tamas,\n\nWhile I think covenants for some kind of debt tool is mildly interesting and an appropriate solution, I wonder about this particular use-case.\n\nIt seems to me that, as either the `Transfer` signers or `Exit` signers are always involved, that the `Transfer` signers can be constrained so as to ensure that the rules are followed correctly, without requiring that covenants be used on the Bitcoin layer.\nAfter all, the outputs of each transaction signed by the `Transfer` signers are part of the transaction that is being signed; surely the `Transfer` signers can validate that the output matches the contract expected, without requiring that fullnodes also validate this?\n\nIn particular, it seems to me that covenants are only useful if there exist some alternative that does not involve some kind of fixed `Transfer` signer set, but still requires a covenant.\nOtherwise, the `Transfer` signer set could simply impose the rules by themselves.\n\n\nAnother thing is that, if my understanding is correct, the \"sidechain\" here is not in fact a sidechain; the \"sidechain\" transaction graph is published on the Bitcoin blockchain.\nInstead, the `Transfer` signers simply validate some smart contract, most likely embedded as a pay-to-contract in the `pk(Alice)`/`pk(Bob)` public keys, and ensure that the smart contract is correctly executed.\nIn that case, it may be useful to consider Smart Contracts Unchained instead: https://zmnscpxj.github.io/bitcoin/unchained.html\n\nIt would be possible, under Smart Contracts Unchained, to keep the `Transfer`-signed transactions offchain, until `Exit`-signing.\nThen, when this chain of transaction spends is presented to the participants, the participants can be convinced to sign a \"cut-through\" transaction that cuts through the offchain transactions, with the resulting cut-through being the one confirmed onchain, and signed only the participants, without the `Transfer` or `Exit` federation signatures appearing onchain.\nThis hides not only the smart contract being executed, but also the fact that a Smart Contracts Unchained technique was at all used.\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Saturday, June 29, 2019 1:53 PM, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I introduced you to gerneralized covenants[1] earlier, but in a domain specific context that de-routed us from technical discussion. Let me demonstrate the concept in a more generic use:\n>\n> A covenant\u00a0\n>\n> or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\u00a0\n>\n> would put a coin under the alternative control of a Transfer and Exit keys together with the script in control of the current owner.\u00a0\n> Additional transaction level validations of transactions spending input with covenants apply as in [1]\n>\n> Owner of such coins would be able to transfer them to others provided an addtional Transfer signature, in which case the coin remains encumbered with the same covenant.\n> If Exit and owner signs the covenant is dropped on the output, it becomes a plain Bitcoin again.\n>\n> The Thransfer and Exit signatures could be threshold signatures of a federation, whereby member decide if the proposed transfer transaction complies with whatever unique rules they impose.\u00a0\n>\n> The result is a federated side chain embedded into the Bitcoin block chain.\n>\n> Bob could purchase some asset guarded by the federation with a transaction:\n>\n> Inputs\n> 100.0001 pk(Bob)\n>\n> Outputs\n> 0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\u00a0\n> 99.9\u00a0pk(Transfer)\n>\n> Transfer to Alice with consent of the transfer validators:\n>\n> Inputs\n> 0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\u00a0\n> 100.001 pk(Alice)\n>\n> Outputs\n> 0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\u00a0\n> 100 pk(Bob)\n>\n> Alice might be approved to exit with the exit signature of the federation:\n>\n> Inputs\n> 0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\u00a0\n> 99.9 pk(Transfer)\n>\n> Outputs\n> 99.9999 pk(Alice)\n>\n> Tamas Blummer\n> [1]\u00a0https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017059.html"
            },
            {
                "author": "Tamas Blummer",
                "date": "2019-06-30T16:57:06",
                "message_text_only": "Hello ZmnSCPxj,\n\nYes, representation of debt is more interesting here as it requires the covenant, wheras this example, as you point out, was less convincing given alternatives.\nI created this example to avoid discussion of topics not approriate on this list.\n\nThank you for the suggestion of unchained execution of transfers with cut-through exit transaction as this made the example much stronger:\n\nThe most important question for someone who trusts his coins to some unchained platform is probably the question of how exit is guaranteed if one is unhappy with what one gets.\n\nWith the exit covenant exit conditions are set in stone, since validated on-chain. If the exit key is owned by a trusted arbiter other than the federation governing the unchained platform\nthen one at least have the option to cut losses at some point by presenting the arbiter a chain of valid transactions and asking to sign the exit.\n\nParticipants in the unchained platform would also be interested to regularly snapshot the economic effect of offchain transactions with cut-through transactions as such cut-through shortens the chain of transactions\nthey would need to get on chain if chosing the exit without consent of the federation governing the transfers.\n\nSo the convenant needed is: 'covenant or(_ covenant transitive, and(pkExit, _) covenant drop)' which gives unrestricted flexibility to the unchained platform with the exception that it has to maintain the exit option.\n\n\nTamas Blummer\n\n\n> On Jun 29, 2019, at 22:25, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> \n> Good morning Tamas,\n> \n> While I think covenants for some kind of debt tool is mildly interesting and an appropriate solution, I wonder about this particular use-case.\n> \n> It seems to me that, as either the `Transfer` signers or `Exit` signers are always involved, that the `Transfer` signers can be constrained so as to ensure that the rules are followed correctly, without requiring that covenants be used on the Bitcoin layer.\n> After all, the outputs of each transaction signed by the `Transfer` signers are part of the transaction that is being signed; surely the `Transfer` signers can validate that the output matches the contract expected, without requiring that fullnodes also validate this?\n> \n> In particular, it seems to me that covenants are only useful if there exist some alternative that does not involve some kind of fixed `Transfer` signer set, but still requires a covenant.\n> Otherwise, the `Transfer` signer set could simply impose the rules by themselves.\n> \n> \n> Another thing is that, if my understanding is correct, the \"sidechain\" here is not in fact a sidechain; the \"sidechain\" transaction graph is published on the Bitcoin blockchain.\n> Instead, the `Transfer` signers simply validate some smart contract, most likely embedded as a pay-to-contract in the `pk(Alice)`/`pk(Bob)` public keys, and ensure that the smart contract is correctly executed.\n> In that case, it may be useful to consider Smart Contracts Unchained instead: https://zmnscpxj.github.io/bitcoin/unchained.html\n> \n> It would be possible, under Smart Contracts Unchained, to keep the `Transfer`-signed transactions offchain, until `Exit`-signing.\n> Then, when this chain of transaction spends is presented to the participants, the participants can be convinced to sign a \"cut-through\" transaction that cuts through the offchain transactions, with the resulting cut-through being the one confirmed onchain, and signed only the participants, without the `Transfer` or `Exit` federation signatures appearing onchain.\n> This hides not only the smart contract being executed, but also the fact that a Smart Contracts Unchained technique was at all used.\n> \n> Regards,\n> ZmnSCPxj\n> \n> \n> Sent with ProtonMail Secure Email.\n> \n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Saturday, June 29, 2019 1:53 PM, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n>> I introduced you to gerneralized covenants[1] earlier, but in a domain specific context that de-routed us from technical discussion. Let me demonstrate the concept in a more generic use:\n>> \n>> A covenant\n>> \n>> or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\n>> \n>> would put a coin under the alternative control of a Transfer and Exit keys together with the script in control of the current owner.\n>> Additional transaction level validations of transactions spending input with covenants apply as in [1]\n>> \n>> Owner of such coins would be able to transfer them to others provided an addtional Transfer signature, in which case the coin remains encumbered with the same covenant.\n>> If Exit and owner signs the covenant is dropped on the output, it becomes a plain Bitcoin again.\n>> \n>> The Thransfer and Exit signatures could be threshold signatures of a federation, whereby member decide if the proposed transfer transaction complies with whatever unique rules they impose.\n>> \n>> The result is a federated side chain embedded into the Bitcoin block chain.\n>> \n>> Bob could purchase some asset guarded by the federation with a transaction:\n>> \n>> Inputs\n>> 100.0001 pk(Bob)\n>> \n>> Outputs\n>> 0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\n>> 99.9 pk(Transfer)\n>> \n>> Transfer to Alice with consent of the transfer validators:\n>> \n>> Inputs\n>> 0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\n>> 100.001 pk(Alice)\n>> \n>> Outputs\n>> 0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\n>> 100 pk(Bob)\n>> \n>> Alice might be approved to exit with the exit signature of the federation:\n>> \n>> Inputs\n>> 0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\n>> 99.9 pk(Transfer)\n>> \n>> Outputs\n>> 99.9999 pk(Alice)\n>> \n>> Tamas Blummer\n>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017059.html\n> \n> \n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190630/513968e9/attachment.sig>"
            },
            {
                "author": "Tamas Blummer",
                "date": "2019-06-30T17:50:21",
                "message_text_only": "I made an error proposing the new covenant. It should be unchanged as in the original example:\n\n\u2018covenant or(and(_, pk(Transfer)) covenant transitive, and(pk(Exit), _) covenant drop)\u2019\n\nsince the placeholder stays for the control of the rightful owner without transfer signature on or off chain.\n\nThe exit could be alternatively automatic allowing to exit a stalling unchained platform:\n\n\u2018covenant or(and(_, pk(Transfer)) covenant transitive, and(delay(100), _) covenant drop)\u2019\n\nThere remains the question why the rightful owner is not enforcing the covenant instead of having it enforced by on-chain consensus.\n\nI do not yet have a good answer for that as in contrast to the debt example, here it is aligned with the interest of the current owner to have the covenant.\n\nTamas Blummer\n\n> On Jun 30, 2019, at 18:57, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n> \n> Hello ZmnSCPxj,\n> \n> Yes, representation of debt is more interesting here as it requires the covenant, wheras this example, as you point out, was less convincing given alternatives.\n> I created this example to avoid discussion of topics not approriate on this list.\n> \n> Thank you for the suggestion of unchained execution of transfers with cut-through exit transaction as this made the example much stronger:\n> \n> The most important question for someone who trusts his coins to some unchained platform is probably the question of how exit is guaranteed if one is unhappy with what one gets.\n> \n> With the exit covenant exit conditions are set in stone, since validated on-chain. If the exit key is owned by a trusted arbiter other than the federation governing the unchained platform\n> then one at least have the option to cut losses at some point by presenting the arbiter a chain of valid transactions and asking to sign the exit.\n> \n> Participants in the unchained platform would also be interested to regularly snapshot the economic effect of offchain transactions with cut-through transactions as such cut-through shortens the chain of transactions\n> they would need to get on chain if chosing the exit without consent of the federation governing the transfers.\n> \n> So the convenant needed is: 'covenant or(_ covenant transitive, and(pkExit, _) covenant drop)' which gives unrestricted flexibility to the unchained platform with the exception that it has to maintain the exit option.\n> \n> \n> Tamas Blummer\n> \n> \n>> On Jun 29, 2019, at 22:25, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>> \n>> Good morning Tamas,\n>> \n>> While I think covenants for some kind of debt tool is mildly interesting and an appropriate solution, I wonder about this particular use-case.\n>> \n>> It seems to me that, as either the `Transfer` signers or `Exit` signers are always involved, that the `Transfer` signers can be constrained so as to ensure that the rules are followed correctly, without requiring that covenants be used on the Bitcoin layer.\n>> After all, the outputs of each transaction signed by the `Transfer` signers are part of the transaction that is being signed; surely the `Transfer` signers can validate that the output matches the contract expected, without requiring that fullnodes also validate this?\n>> \n>> In particular, it seems to me that covenants are only useful if there exist some alternative that does not involve some kind of fixed `Transfer` signer set, but still requires a covenant.\n>> Otherwise, the `Transfer` signer set could simply impose the rules by themselves.\n>> \n>> \n>> Another thing is that, if my understanding is correct, the \"sidechain\" here is not in fact a sidechain; the \"sidechain\" transaction graph is published on the Bitcoin blockchain.\n>> Instead, the `Transfer` signers simply validate some smart contract, most likely embedded as a pay-to-contract in the `pk(Alice)`/`pk(Bob)` public keys, and ensure that the smart contract is correctly executed.\n>> In that case, it may be useful to consider Smart Contracts Unchained instead: https://zmnscpxj.github.io/bitcoin/unchained.html\n>> \n>> It would be possible, under Smart Contracts Unchained, to keep the `Transfer`-signed transactions offchain, until `Exit`-signing.\n>> Then, when this chain of transaction spends is presented to the participants, the participants can be convinced to sign a \"cut-through\" transaction that cuts through the offchain transactions, with the resulting cut-through being the one confirmed onchain, and signed only the participants, without the `Transfer` or `Exit` federation signatures appearing onchain.\n>> This hides not only the smart contract being executed, but also the fact that a Smart Contracts Unchained technique was at all used.\n>> \n>> Regards,\n>> ZmnSCPxj\n>> \n>> \n>> Sent with ProtonMail Secure Email.\n>> \n>> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>> On Saturday, June 29, 2019 1:53 PM, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> \n>>> I introduced you to gerneralized covenants[1] earlier, but in a domain specific context that de-routed us from technical discussion. Let me demonstrate the concept in a more generic use:\n>>> \n>>> A covenant\n>>> \n>>> or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\n>>> \n>>> would put a coin under the alternative control of a Transfer and Exit keys together with the script in control of the current owner.\n>>> Additional transaction level validations of transactions spending input with covenants apply as in [1]\n>>> \n>>> Owner of such coins would be able to transfer them to others provided an addtional Transfer signature, in which case the coin remains encumbered with the same covenant.\n>>> If Exit and owner signs the covenant is dropped on the output, it becomes a plain Bitcoin again.\n>>> \n>>> The Thransfer and Exit signatures could be threshold signatures of a federation, whereby member decide if the proposed transfer transaction complies with whatever unique rules they impose.\n>>> \n>>> The result is a federated side chain embedded into the Bitcoin block chain.\n>>> \n>>> Bob could purchase some asset guarded by the federation with a transaction:\n>>> \n>>> Inputs\n>>> 100.0001 pk(Bob)\n>>> \n>>> Outputs\n>>> 0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\n>>> 99.9 pk(Transfer)\n>>> \n>>> Transfer to Alice with consent of the transfer validators:\n>>> \n>>> Inputs\n>>> 0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\n>>> 100.001 pk(Alice)\n>>> \n>>> Outputs\n>>> 0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\n>>> 100 pk(Bob)\n>>> \n>>> Alice might be approved to exit with the exit signature of the federation:\n>>> \n>>> Inputs\n>>> 0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\n>>> 99.9 pk(Transfer)\n>>> \n>>> Outputs\n>>> 99.9999 pk(Alice)\n>>> \n>>> Tamas Blummer\n>>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017059.html\n>> \n>> \n> \n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190630/25c90620/attachment-0001.sig>"
            },
            {
                "author": "Tamas Blummer",
                "date": "2019-06-30T22:25:03",
                "message_text_only": "Any meaningful covenant must be one that is reducing control by the current owner.\n\nI can think of countless predicates reducing control, but try to explore the least invasive first,\nand see if they unlock a new use.\n\nOffering alternate control paths is what taproot was designed for, therefore a covenant\nthat requires that a control path is inherited seems a fit. That is all the\ndebt covenant needs.\n\nThere are other predicates with exciting use, such as one on total work performed by miner\nwhich I tried to explore earlier. Pieter Wuille said it could be a candidate for the annex.\n\nTamas Blummer\n\n\n> On Jun 30, 2019, at 19:50, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n> \n> I made an error proposing the new covenant. It should be unchanged as in the original example:\n> \n> \u2018covenant or(and(_, pk(Transfer)) covenant transitive, and(pk(Exit), _) covenant drop)\u2019\n> \n> since the placeholder stays for the control of the rightful owner without transfer signature on or off chain.\n> \n> The exit could be alternatively automatic allowing to exit a stalling unchained platform:\n> \n> \u2018covenant or(and(_, pk(Transfer)) covenant transitive, and(delay(100), _) covenant drop)\u2019\n> \n> There remains the question why the rightful owner is not enforcing the covenant instead of having it enforced by on-chain consensus.\n> \n> I do not yet have a good answer for that as in contrast to the debt example, here it is aligned with the interest of the current owner to have the covenant.\n> \n> Tamas Blummer\n> \n>> On Jun 30, 2019, at 18:57, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n>> \n>> Hello ZmnSCPxj,\n>> \n>> Yes, representation of debt is more interesting here as it requires the covenant, wheras this example, as you point out, was less convincing given alternatives.\n>> I created this example to avoid discussion of topics not approriate on this list.\n>> \n>> Thank you for the suggestion of unchained execution of transfers with cut-through exit transaction as this made the example much stronger:\n>> \n>> The most important question for someone who trusts his coins to some unchained platform is probably the question of how exit is guaranteed if one is unhappy with what one gets.\n>> \n>> With the exit covenant exit conditions are set in stone, since validated on-chain. If the exit key is owned by a trusted arbiter other than the federation governing the unchained platform\n>> then one at least have the option to cut losses at some point by presenting the arbiter a chain of valid transactions and asking to sign the exit.\n>> \n>> Participants in the unchained platform would also be interested to regularly snapshot the economic effect of offchain transactions with cut-through transactions as such cut-through shortens the chain of transactions\n>> they would need to get on chain if chosing the exit without consent of the federation governing the transfers.\n>> \n>> So the convenant needed is: 'covenant or(_ covenant transitive, and(pkExit, _) covenant drop)' which gives unrestricted flexibility to the unchained platform with the exception that it has to maintain the exit option.\n>> \n>> \n>> Tamas Blummer\n>> \n>> \n>>> On Jun 29, 2019, at 22:25, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>>> \n>>> Good morning Tamas,\n>>> \n>>> While I think covenants for some kind of debt tool is mildly interesting and an appropriate solution, I wonder about this particular use-case.\n>>> \n>>> It seems to me that, as either the `Transfer` signers or `Exit` signers are always involved, that the `Transfer` signers can be constrained so as to ensure that the rules are followed correctly, without requiring that covenants be used on the Bitcoin layer.\n>>> After all, the outputs of each transaction signed by the `Transfer` signers are part of the transaction that is being signed; surely the `Transfer` signers can validate that the output matches the contract expected, without requiring that fullnodes also validate this?\n>>> \n>>> In particular, it seems to me that covenants are only useful if there exist some alternative that does not involve some kind of fixed `Transfer` signer set, but still requires a covenant.\n>>> Otherwise, the `Transfer` signer set could simply impose the rules by themselves.\n>>> \n>>> \n>>> Another thing is that, if my understanding is correct, the \"sidechain\" here is not in fact a sidechain; the \"sidechain\" transaction graph is published on the Bitcoin blockchain.\n>>> Instead, the `Transfer` signers simply validate some smart contract, most likely embedded as a pay-to-contract in the `pk(Alice)`/`pk(Bob)` public keys, and ensure that the smart contract is correctly executed.\n>>> In that case, it may be useful to consider Smart Contracts Unchained instead: https://zmnscpxj.github.io/bitcoin/unchained.html\n>>> \n>>> It would be possible, under Smart Contracts Unchained, to keep the `Transfer`-signed transactions offchain, until `Exit`-signing.\n>>> Then, when this chain of transaction spends is presented to the participants, the participants can be convinced to sign a \"cut-through\" transaction that cuts through the offchain transactions, with the resulting cut-through being the one confirmed onchain, and signed only the participants, without the `Transfer` or `Exit` federation signatures appearing onchain.\n>>> This hides not only the smart contract being executed, but also the fact that a Smart Contracts Unchained technique was at all used.\n>>> \n>>> Regards,\n>>> ZmnSCPxj\n>>> \n>>> \n>>> Sent with ProtonMail Secure Email.\n>>> \n>>> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>>> On Saturday, June 29, 2019 1:53 PM, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>> \n>>>> I introduced you to gerneralized covenants[1] earlier, but in a domain specific context that de-routed us from technical discussion. Let me demonstrate the concept in a more generic use:\n>>>> \n>>>> A covenant\n>>>> \n>>>> or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\n>>>> \n>>>> would put a coin under the alternative control of a Transfer and Exit keys together with the script in control of the current owner.\n>>>> Additional transaction level validations of transactions spending input with covenants apply as in [1]\n>>>> \n>>>> Owner of such coins would be able to transfer them to others provided an addtional Transfer signature, in which case the coin remains encumbered with the same covenant.\n>>>> If Exit and owner signs the covenant is dropped on the output, it becomes a plain Bitcoin again.\n>>>> \n>>>> The Thransfer and Exit signatures could be threshold signatures of a federation, whereby member decide if the proposed transfer transaction complies with whatever unique rules they impose.\n>>>> \n>>>> The result is a federated side chain embedded into the Bitcoin block chain.\n>>>> \n>>>> Bob could purchase some asset guarded by the federation with a transaction:\n>>>> \n>>>> Inputs\n>>>> 100.0001 pk(Bob)\n>>>> \n>>>> Outputs\n>>>> 0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\n>>>> 99.9 pk(Transfer)\n>>>> \n>>>> Transfer to Alice with consent of the transfer validators:\n>>>> \n>>>> Inputs\n>>>> 0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\n>>>> 100.001 pk(Alice)\n>>>> \n>>>> Outputs\n>>>> 0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\n>>>> 100 pk(Bob)\n>>>> \n>>>> Alice might be approved to exit with the exit signature of the federation:\n>>>> \n>>>> Inputs\n>>>> 0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)\n>>>> 99.9 pk(Transfer)\n>>>> \n>>>> Outputs\n>>>> 99.9999 pk(Alice)\n>>>> \n>>>> Tamas Blummer\n>>>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017059.html\n>>> \n>>> \n>> \n> \n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190701/783d02da/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Generalized covenant to implement side chains embedded into the bitcoin block chain",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Tamas Blummer"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 29286
        }
    }
]