[
    {
        "title": "[Bitcoin-development] Implementing batch processing for -blocknotify",
        "thread_messages": [
            {
                "author": "Rune Kj\u00e6r Svendsen",
                "date": "2013-06-01T13:12:32",
                "message_text_only": "Thanks for the input all! You make a lot of sense :). I will go with the\nUnix socket method, I think. It's about time I learn about those.\n\n/Rune\n\n\nOn Sat, Jun 1, 2013 at 1:47 AM, Chris Double <chris.double at double.co.nz>wrote:\n\n> On Sat, Jun 1, 2013 at 11:29 AM, Wladimir <laanwj at gmail.com> wrote:\n> > Using zmq is a great fit for high-speed notifications such as this. Have\n> you\n> > seen the pull request to integrate zmq directly into bitcoind, so that\n> you\n> > don't even need -blocknotify?\n> >\n> > https://github.com/bitcoin/bitcoin/pull/2415\n> >\n> > If not: we could use some testing there!\n>\n> I hadn't seen this, thanks! I've integrated zmq myself for block\n> notifications in bitcoin and the alt coins I use it on my bitparking\n> merge mining pool. I would love to see something official. I'll try\n> out the patch in the pull request.\n>\n> Chris.\n> --\n> http://www.bluishcoder.co.nz\n>\n>\n> ------------------------------------------------------------------------------\n> Get 100% visibility into Java/.NET code with AppDynamics Lite\n> It's a free troubleshooting tool designed for production\n> Get down to code-level detail for bottlenecks, with <2% overhead.\n> Download for free and get started troubleshooting in minutes.\n> http://p.sf.net/sfu/appdyn_d2d_ap2\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130601/b17539b1/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Implementing batch processing for -blocknotify",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Rune Kj\u00e6r Svendsen"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1658
        }
    },
    {
        "title": "[Bitcoin-development] Proposal: soft-fork to make anyone-can-spend outputs unspendable for 100 blocks",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2013-06-01T19:30:36",
                "message_text_only": "Currently the most compact way (proof-size) to sacrifice Bitcoins that\ndoes not involve making them unspendable is to create a anyone-can-spend\noutput as the last txout in the coinbase of a block:\n\nscriptPubKey: <data> OP_TRUE\n\nThe proof is then the SHA256 midstate, the txout, and the merkle path to\nthe block header. However this mechanism needs miner support, and it is\nnot possible to pay for such a sacrifice securely, or create an\nassurance contract to create one.\n\nA anyone-can-spend in a regular txout is another option, but there is no\nway to prevent a miner from including a transaction spending that txout\nin the same block. Once that happens, there is no way to prove the miner\ndidn't create both, thus invalidating the sacrifice. The announce-commit\nprotocol solves that problem, but at the cost of a much larger proof,\nespecially if multiple parties want to get together to pay the cost of\nthe sacrifice. (the proof must include the entire tx used to make the\nsacrifice)\n\nHowever if we add a rule where txouts ending in OP_TRUE are unspendable\nfor 100 blocks, similar to coinbases, we fix these problems. The rule\ncan be done as a soft-fork with 95% support in the same way the\nblockheight rule was implemented. Along with that change\nanyone-can-spend outputs should be make IsStandard() so they will be\nrelayed.\n\nThe alternative is sacrifices to unspendable outputs, which is very\nundesirable compared to sending the money to miners to further\nstrengthen the security of the network.\n\nWe should always make it easy for people to write code that does what is\nbest for Bitcoin.\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000ce3427502ee6a254fed27e1cd21a656a335cd2ada79b7b5293\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130601/9a4fd0e7/attachment.sig>"
            },
            {
                "author": "Adam Back",
                "date": "2013-06-02T21:45:54",
                "message_text_only": "So the idea is that people may want to use proof-of-work unrelated to\nbitcoin, and abuse bitcoin to obtain that proof, in a way denominated in BTC\n(and with a published USD exchange rate).  And the ways they can do that are\nto:\n\na) create unspendable addresses (which maybe you cant compact in the UTXO\nset if the unspendable address choices are not standardized)\n\nb) spend to anyone which I take it goes to a random person who happens to\nsee the address first and race the \"spend to me\" out on to the network, and\nhope miners dnt replace it with \"spend to miner\", which is insecure\n\nc) doesnt delay by 100 blocks just delay the \"spend to me\" race?  Also most\nlikely to be one by a big miner once they adapt and join the race.\n\nd) some new standardized spend to fees (only miners can claim).\n\ne) spend to charity/non-profit of choice could be useful also\n\nf) I guess we see something related in zerocoin - locked but unlockable via\nanother type of transaction later.\n\ng) why not instead make the beneficiary the address of the service the user\nis consuming that is being DoS protected by the proof-of-sacrifice?  Seems\nmore useful than burning virtual money, then it helps the bitcoin network\nAND it helps the service provide better service!\n\nso if I understand what you proposed d) seems like a useful concept if that\nis not currently possible.  eg alternatively could we not just propose a\nstandard recognized address that clearly no-one knows the EC discrete log\nof?\n\nAdam\n\nOn Sat, Jun 01, 2013 at 03:30:36PM -0400, Peter Todd wrote:\n>Currently the most compact way (proof-size) to sacrifice Bitcoins that\n>does not involve making them unspendable is to create a anyone-can-spend\n>output as the last txout in the coinbase of a block:\n>\n>scriptPubKey: <data> OP_TRUE\n>\n>The proof is then the SHA256 midstate, the txout, and the merkle path to\n>the block header. However this mechanism needs miner support, and it is\n>not possible to pay for such a sacrifice securely, or create an\n>assurance contract to create one.\n>\n>A anyone-can-spend in a regular txout is another option, but there is no\n>way to prevent a miner from including a transaction spending that txout\n>in the same block. Once that happens, there is no way to prove the miner\n>didn't create both, thus invalidating the sacrifice. The announce-commit\n>protocol solves that problem, but at the cost of a much larger proof,\n>especially if multiple parties want to get together to pay the cost of\n>the sacrifice. (the proof must include the entire tx used to make the\n>sacrifice)\n>\n>However if we add a rule where txouts ending in OP_TRUE are unspendable\n>for 100 blocks, similar to coinbases, we fix these problems. The rule\n>can be done as a soft-fork with 95% support in the same way the\n>blockheight rule was implemented. Along with that change\n>anyone-can-spend outputs should be make IsStandard() so they will be\n>relayed.\n>\n>The alternative is sacrifices to unspendable outputs, which is very\n>undesirable compared to sending the money to miners to further\n>strengthen the security of the network.\n>\n>We should always make it easy for people to write code that does what is\n>best for Bitcoin.\n>\n>-- \n>'peter'[:-1]@petertodd.org\n>00000000000000ce3427502ee6a254fed27e1cd21a656a335cd2ada79b7b5293\n\n\n\n>------------------------------------------------------------------------------\n>Get 100% visibility into Java/.NET code with AppDynamics Lite\n>It's a free troubleshooting tool designed for production\n>Get down to code-level detail for bottlenecks, with <2% overhead.\n>Download for free and get started troubleshooting in minutes.\n>http://p.sf.net/sfu/appdyn_d2d_ap2\n\n>_______________________________________________\n>Bitcoin-development mailing list\n>Bitcoin-development at lists.sourceforge.net\n>https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-06-04T14:12:44",
                "message_text_only": "On Sun, Jun 2, 2013 at 5:45 PM, Adam Back <adam at cypherspace.org> wrote:\n> d) some new standardized spend to fees (only miners can claim).\n\n> so if I understand what you proposed d) seems like a useful concept if that\n> is not currently possible.  eg alternatively could we not just propose a\n> standard recognized address that clearly no-one knows the EC discrete log\n> of?\n\nI'm one of the people experimenting in this area.  I've long argued\nthat a zero-output transaction should be permitted -- 100% miner fee\n-- as an elegant proof of sacrifice.  Unfortunately that requires a\nhard fork.  Also, for most people, it seems likely that a change\ntransaction would be generated.  That, then, would generate an\nalready-standard transaction, where inputs > outputs.\n\n-- \nJeff Garzik\nSenior Software Engineer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "John Dillon",
                "date": "2013-06-04T14:55:36",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\n> I'm one of the people experimenting in this area.  I've long argued\n> that a zero-output transaction should be permitted -- 100% miner fee\n> -- as an elegant proof of sacrifice.  Unfortunately that requires a\n> hard fork.  Also, for most people, it seems likely that a change\n> transaction would be generated.  That, then, would generate an\n> already-standard transaction, where inputs > outputs.\n\n100% miner fee is not a proof of anything because the miner could have created\nthat transaction for themselves. You must have proof that all miners had an\nequal opportunity at collecting the fee, and the only way to do that is by\nPeter's announce-commit protocol, or his unspendable until after n blocks\nproposal.\n\nAlso the idea of a zero-output transaction is silly. In almost all cases you\nare making the sarifice to link that act to an identity, and linking that act\nto arbitrary data is far more flexible than any scheme relying on the pubkeys\nthat paid for the transaction. With a arbitrary data you can slice up the\nsacrifice for instance with a merkle-sum-tree, as well as hide what the\nsacrifice was for to preserve anonymity. The extra cost in size of the provably\nunspendable OP_RETURN scriptPubKey is minimal for the rare time when it isn't\nrequired.\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\n\niQEcBAEBCAAGBQJRrf/BAAoJEEWCsU4mNhiP7+MH/RGfo2k+Zd0VoGzv3KSTzBrM\nauK9Do2fYp2YvMnT/JFYbz2MgbTcCiKGyZfxjaH+zrqdTFgkgAE53midIv/Rd5/w\nkjjifJuqw5AyIN6ANA1TuLQ64elPOXXymsaMqWO8ou0angG6DBI/LZZEG7SXM7+I\nJwk3MXLhFswvvuRif4G2C9v29WqSj4XRxxl3o63ziSYvZPPCHLYHAL9BJaMpDhaw\nLxebM088RofzJAoGL1QIeQhDS3aAK4jKSZtJ/6+fwYZQB2Qc3sa1v9IAcCQHE+M3\n6oQY0tzEEFg9+xdnSM7J6pW7qW28nFS8Fdr6UkUUlwhI5c4KnIKCtQa3o1mYDFE=\n=SHWS\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-06-04T17:42:53",
                "message_text_only": "On Tue, Jun 4, 2013 at 10:55 AM, John Dillon\n<john.dillon892 at googlemail.com> wrote:\n>> I'm one of the people experimenting in this area.  I've long argued\n>> that a zero-output transaction should be permitted -- 100% miner fee\n>> -- as an elegant proof of sacrifice.  Unfortunately that requires a\n>> hard fork.  Also, for most people, it seems likely that a change\n>> transaction would be generated.  That, then, would generate an\n>> already-standard transaction, where inputs > outputs.\n>\n> 100% miner fee is not a proof of anything because the miner could have created\n> that transaction for themselves. You must have proof that all miners had an\n> equal opportunity at collecting the fee, and the only way to do that is by\n> Peter's announce-commit protocol, or his unspendable until after n blocks\n> proposal.\n\nAbsolutely.  It wholly depends on the security model, and\neconomic-incentives model.  Some use models simply don't care if the\nminer created a transaction that gave the fee to themselves.  It might\neven be /encouraged/ to do this!  Sure they are paying themselves, but\ngiven bitcoin network difficulty is so high, simply obtaining\npayments-go-myself-as-miner transactions is itself difficult.\nProducing an identity (my goal) or whatever is just fine, and in such\ncase becomes simply an additional block reward -- an additional\nincentive to buy into this identity creation/management system.\n\nOr exchange \"identity\" with another token, for another data service of\nyour choice.\n\nThis is no longer a strict \"proof of sacrifice\" system, if such\nbehavior is encouraged, but it is nonetheless valid.\n\n-- \nJeff Garzik\nSenior Software Engineer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Roy Badami",
                "date": "2013-06-04T18:36:53",
                "message_text_only": "> Sure they are paying themselves, but given bitcoin network\n> difficulty is uso high, simply obtaining payments-go-myself-as-miner\n> transactions is itself difficult.\n\nNot for pool operators it isn't.  Nor for people buying hashing power\nfrom a GPUMAX-type service, if such services still exist (or should\nthey exist again in future)."
            },
            {
                "author": "Melvin Carvalho",
                "date": "2013-06-03T23:43:27",
                "message_text_only": "On 1 June 2013 21:30, Peter Todd <pete at petertodd.org> wrote:\n\n> Currently the most compact way (proof-size) to sacrifice Bitcoins that\n> does not involve making them unspendable is to create a anyone-can-spend\n> output as the last txout in the coinbase of a block:\n>\n> scriptPubKey: <data> OP_TRUE\n>\n> The proof is then the SHA256 midstate, the txout, and the merkle path to\n> the block header. However this mechanism needs miner support, and it is\n> not possible to pay for such a sacrifice securely, or create an\n> assurance contract to create one.\n>\n\nSorry if this is a stupid question, but why would someone want to sacrifice\ntheir bitcoins?\n\n\n>\n> A anyone-can-spend in a regular txout is another option, but there is no\n> way to prevent a miner from including a transaction spending that txout\n> in the same block. Once that happens, there is no way to prove the miner\n> didn't create both, thus invalidating the sacrifice. The announce-commit\n> protocol solves that problem, but at the cost of a much larger proof,\n> especially if multiple parties want to get together to pay the cost of\n> the sacrifice. (the proof must include the entire tx used to make the\n> sacrifice)\n>\n> However if we add a rule where txouts ending in OP_TRUE are unspendable\n> for 100 blocks, similar to coinbases, we fix these problems. The rule\n> can be done as a soft-fork with 95% support in the same way the\n> blockheight rule was implemented. Along with that change\n> anyone-can-spend outputs should be make IsStandard() so they will be\n> relayed.\n>\n> The alternative is sacrifices to unspendable outputs, which is very\n> undesirable compared to sending the money to miners to further\n> strengthen the security of the network.\n>\n> We should always make it easy for people to write code that does what is\n> best for Bitcoin.\n>\n> --\n> 'peter'[:-1]@petertodd.org\n> 00000000000000ce3427502ee6a254fed27e1cd21a656a335cd2ada79b7b5293\n>\n>\n> ------------------------------------------------------------------------------\n> Get 100% visibility into Java/.NET code with AppDynamics Lite\n> It's a free troubleshooting tool designed for production\n> Get down to code-level detail for bottlenecks, with <2% overhead.\n> Download for free and get started troubleshooting in minutes.\n> http://p.sf.net/sfu/appdyn_d2d_ap2\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130604/0230ef96/attachment.html>"
            },
            {
                "author": "Michael Hendricks",
                "date": "2013-06-04T02:26:16",
                "message_text_only": "On Mon, Jun 3, 2013 at 5:43 PM, Melvin Carvalho <melvincarvalho at gmail.com>wrote:\n\n> Sorry if this is a stupid question, but why would someone want to\n> sacrifice their bitcoins?\n>\n\nGood question.  One reason is https://en.bitcoin.it/wiki/Fidelity_bonds\n\nCheers,\nMichael\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130603/2d82b7c7/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2013-06-01T20:58:53",
                "message_text_only": "On Sat, Jun 01, 2013 at 08:34:29PM +0000, Luke-Jr wrote:\n> On Saturday, June 01, 2013 7:30:36 PM Peter Todd wrote:\n> > scriptPubKey: <data> OP_TRUE\n> > \n> > ...\n> > Along with that change anyone-can-spend outputs should be make IsStandard()\n> > so they will be relayed.\n> \n> Data does not belong in the blockchain. People running nodes have all \n> implicitly agreed to store the blocks for financial purposes, and storing data \n> is a violation of that social contract. Proof-of-stake may be arguably \n> financial, but I'm sure there must be a way to do it without spamming people \n> against their consent.\n\nWe have no way of preventing this, so ensure it's done in a way that\nminimizes harm. For instance, my zookeyv key-value consensus system can\nbe implemented using transactions with txout pairs of the following\nform:\n\nLet H(d) = RIPEMD160(SHA256(d))\n\ntxout_k*2  : OP_DUP H(key) OP_EQUALVERIFY\ntxout_k*2+1: OP_DUP H(value) OP_EQUALVERIFY\n\nWith an additional rule to allow for references to previous sacrifices\nwith txouts of the form:\n\ntxout_n: OP_DUP H(txid:vout) OP_EQUALVERIFY\n\nThis is perfectly compatible with Gregory Maxwell's address pre-image\nfix to data-in-chain storage, and at the same time is completely\nunblockable by making such transactions more expensive - the whole point\nis to prove you've sacrificed funds.\n\nYet another reason why increasing the blocksize is madness.\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000018235c41836eb88ea45343c746a3704c5a155bb90c7d2d9a48\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130601/857d9a1c/attachment.sig>"
            },
            {
                "author": "Peter Todd",
                "date": "2013-06-02T06:13:27",
                "message_text_only": "On Sat, Jun 01, 2013 at 10:32:07PM -0400, Gavin wrote:\n> Feels like a new opcode might be better.\n> \n> Eg  <data> 100 OP_NOP1\n> \n> ... Where op_nop1 is redefined to be 'verify depth' ... \n\nGood idea.\n\nEither way, looks like complex announce-commit logic isn't needed and a\nsimple txout with one of a few possible forms will work.\n\nI'd say we tell people to sacrifice to (provably) unspendable for now\nand do a soft-fork later if there is real demand for this stuff in the\nfuture.\n\n> On Jun 1, 2013, at 3:30 PM, Peter Todd <pete at petertodd.org> wrote:\n> \n> > Currently the most compact way (proof-size) to sacrifice Bitcoins that\n> > does not involve making them unspendable is to create a anyone-can-spend\n> > output as the last txout in the coinbase of a block:\n> > \n> > scriptPubKey: <data> OP_TRUE\n> > \n> > The proof is then the SHA256 midstate, the txout, and the merkle path to\n> > the block header. However this mechanism needs miner support, and it is\n> > not possible to pay for such a sacrifice securely, or create an\n> > assurance contract to create one.\n> > \n> > A anyone-can-spend in a regular txout is another option, but there is no\n> > way to prevent a miner from including a transaction spending that txout\n> > in the same block. Once that happens, there is no way to prove the miner\n> > didn't create both, thus invalidating the sacrifice. The announce-commit\n> > protocol solves that problem, but at the cost of a much larger proof,\n> > especially if multiple parties want to get together to pay the cost of\n> > the sacrifice. (the proof must include the entire tx used to make the\n> > sacrifice)\n> > \n> > However if we add a rule where txouts ending in OP_TRUE are unspendable\n> > for 100 blocks, similar to coinbases, we fix these problems. The rule\n> > can be done as a soft-fork with 95% support in the same way the\n> > blockheight rule was implemented. Along with that change\n> > anyone-can-spend outputs should be make IsStandard() so they will be\n> > relayed.\n> > \n> > The alternative is sacrifices to unspendable outputs, which is very\n> > undesirable compared to sending the money to miners to further\n> > strengthen the security of the network.\n> > \n> > We should always make it easy for people to write code that does what is\n> > best for Bitcoin.\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000092f448c7630e47584650efa7e27604161c0b5984d603d944ea\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130602/e4620fb3/attachment.sig>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-06-02T17:35:10",
                "message_text_only": "On Sun, Jun 2, 2013 at 2:13 AM, Peter Todd <pete at petertodd.org> wrote:\n> I'd say we tell people to sacrifice to (provably) unspendable for now\n> and do a soft-fork later if there is real demand for this stuff in the\n> future.\n\nThat seems fair.\n\nIn general, people are actively bloating the UTXO set with unspendable\noutputs (that cannot be 100% proven unspendable).  Provably\nunspendable seems like an improvement on long term UTXO health.\n\nIt is a fair criticism that this inches the incentives, a bit, towards\ntimestamping and other non-currency uses.  But those uses (a) cannot\nbe prevented and (b) have already been automated anyway (e.g. the\npython upload/download tools stored in-chain).\n\nI do think the overwhelming majority of users are invested in\nbitcoin-the-currency (or bitcoin-the-commodity, take your pick), i.e.\nthe value proposition.  That's our 98% use case.  Given the relative\nvolumes of traffic, timestamping/data storage/messaging is essentially\ngetting a free ride.  So IMO it is worth continuing to explore\n/disincentives/ for use of the blockchain for data storage and\nmessaging, for the rare times where a clear currency-or-data-storage\nincentive is available.\n\n-- \nJeff Garzik\nSenior Software Engineer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Peter Todd",
                "date": "2013-06-02T18:41:13",
                "message_text_only": "On Sun, Jun 02, 2013 at 01:35:10PM -0400, Jeff Garzik wrote:\n> It is a fair criticism that this inches the incentives, a bit, towards\n> timestamping and other non-currency uses.  But those uses (a) cannot\n> be prevented and (b) have already been automated anyway (e.g. the\n> python upload/download tools stored in-chain).\n\nYeah, and Bitcoin sacrifices are kind of an odd middle ground there.\nIt's been suggested to make provably unspendable OP_RETURN IsStandard()\nonly if the txout value is zero, but considering the sacrifice use-case\nI'm thinking we should allow people to throw away coins in a\nnon-UTXO-bloating way if they choose too.\n\n> I do think the overwhelming majority of users are invested in\n> bitcoin-the-currency (or bitcoin-the-commodity, take your pick), i.e.\n> the value proposition.  That's our 98% use case.  Given the relative\n> volumes of traffic, timestamping/data storage/messaging is essentially\n> getting a free ride.  So IMO it is worth continuing to explore\n> /disincentives/ for use of the blockchain for data storage and\n> messaging, for the rare times where a clear currency-or-data-storage\n> incentive is available.\n\nIndeed, just recognize that those disincentives must be implemented in a\nway that makes doing the less-harmful thing is to your advantage. For\ninstance people keep arguing for OP_RETURN to only be allowed as one\ntxout in a tx, which puts it at a disadvantage relative to just using\nunspendable outputs. Similarly because people can play OP_CHECKMULTISIG\ngames, allow as much data as can be included in that form, 195 bytes.\n\n\nOf course, you can't block everything:\n\n----- Forwarded message from aitahk2l <aitahk2l at tormail.org> -----\n\nDate: Sun, 02 Jun 2013 02:40:10 +0100\nFrom: aitahk2l <aitahk2l at tormail.org>\nTo: pete at petertodd.org\nSubject: Your timestamper\n\nWe spoke a few months back and I sent you some funds to run your\ntimestamper.\n\nI'm letting you know we're going back to unspendable txout timestamps\nfor our needs. Your service is great, but I think you have written it\nprematurely. Like you said in your recent bitcoin-development post on\nsacrifices if the technology enables a use, people will use it. \nInefficient timestamping is one such use and threatens the blockchain\nwith unlimited bloat, but from what I hear from Gavin he doesn't see \ndecentralization as particularly important.\n\nYou really should turn off your OpenTimestamps servers. They mislead\npeople into a sense of scalability that just isn't there. You'll see \nsome of our efforts at 1MBGavinWuiJCF6thGfEriB2WhDD5nhB2a soon;\nfrankly I think he is the biggest threat Bitcoin faces in the long\nterm and will back us all into a scalability corner with no good\nsolutions.\n\nFeel free to forward this message to others.\n\n\n----- End forwarded message -----\n\nSeems legit - traffic on my timestamper is significantly reduced from\nwhat it was before. Incidentally, I've left the opentimestamps client\ndeliberately broken for months now to see if anyone used it, and other\nthan this guy I've had zero bug reports.\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000046da2c6f02bf57f3bdc48a08388e0030fc4490f5fc048516e6\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130602/68f8b3a6/attachment.sig>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2013-06-04T00:22:43",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nOn Sat, Jun 01, 2013 at 10:32:07PM -0400, Gavin wrote:\n>> Feels like a new opcode might be better.\n>>\n>> Eg  <data> 100 OP_NOP1\n>>\n>> ... Where op_nop1 is redefined to be 'verify depth' ...\nI would suggest the more general 'push depth onto stack'. You can then\nuse the usual math/relational operators which otherwise have seen little\nuse.\n\nAssuming it's even a good idea to go down this route at all.\n\nMark\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG/MacGPG2 v2.0.19 (Darwin)\nComment: GPGTools - http://gpgtools.org\nComment: Using GnuPG with Thunderbird - http://www.enigmail.net/\n\niQIcBAEBAgAGBQJRrTNTAAoJEAdzVfsmodw4mf0QAJAej83Pth0ZVfua3I5+RR58\n7gHpt2rBHP8KuwDH6J3VbxZDKy0n+6/nC5+kjI+G0tYGt3yU4wARJA+afB+zxScT\nDPO1iMRxcwOz6KtPWpyCEEOW4ZlILQmbhGyA7XZ+Oy+hZZMBWvPCt4BQsyTjUJ4Y\n+gTDqdkNk9B2HZh5gskXRkOYWGB9517tTQ0zYWLtVm2sgeJvRkd73WLZGHm4nrLI\n20OLaTP0RuW5+qfV4BSQp/Y3k/9OqrAFXiXo5NAs6PL81x3/IDGKpsfnZNLxPU0i\nQLg9RdHZ9769fTgACO8822pLaWQ4LtLB4FA/mVYBhr/ORWSIKfod7TPGF3AYiIpF\ndb2IESX2HFAxMQ9xTi/2R9zYwCvVpQWwZNse+DEMhoQhykcNv/+sZBE93xHGSgsq\nXKBOXLJGCxnUwszz+CSmwrQVmwPqLAU/fFybnAI/6VHMMd8phgNV5oLluAaZyBTi\nDpImUul2fqKaJeRjQBB1Qya7az0Qvf4LSHFDQKYYWG/H03R5CxFkxiM/XsiyuzpK\n7+MVh6gnWaoayB/eAh0KVgWXUrQQGUBwvVmSk6DU73yQ8Db0BHaxBaUihlsJrMTX\nYbh8d8GSbXsaUjolvJ/dSclcAw7ovW91jqEhRoBq9AKQA23RjHChzT8M1UkXZclZ\n8k6XWOJy+NaNmklEwMqF\n=iDLz\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-06-04T18:49:54",
                "message_text_only": "On Tue, Jun 4, 2013 at 2:36 PM, Roy Badami <roy at gnomon.org.uk> wrote:\n>> Sure they are paying themselves, but given bitcoin network\n>> difficulty is uso high, simply obtaining payments-go-myself-as-miner\n>> transactions is itself difficult.\n>\n> Not for pool operators it isn't.  Nor for people buying hashing power\n> from a GPUMAX-type service, if such services still exist (or should\n> they exist again in future).\n\nRe-read what I wrote.  That's perfectly OK.  It is analogous to a pool\noperator receiving merged mined coins, each time they mine a bitcoin\nblock.\n\nIf you achieve the very high difficulty needed to create a valid\nbitcoin block, you have achieved a very high bar.\n\n-- \nJeff Garzik\nSenior Software Engineer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Peter Todd",
                "date": "2013-06-04T20:25:18",
                "message_text_only": "On Tue, Jun 04, 2013 at 02:49:54PM -0400, Jeff Garzik wrote:\n> On Tue, Jun 4, 2013 at 2:36 PM, Roy Badami <roy at gnomon.org.uk> wrote:\n> >> Sure they are paying themselves, but given bitcoin network\n> >> difficulty is uso high, simply obtaining payments-go-myself-as-miner\n> >> transactions is itself difficult.\n> >\n> > Not for pool operators it isn't.  Nor for people buying hashing power\n> > from a GPUMAX-type service, if such services still exist (or should\n> > they exist again in future).\n> \n> Re-read what I wrote.  That's perfectly OK.  It is analogous to a pool\n> operator receiving merged mined coins, each time they mine a bitcoin\n> block.\n> \n> If you achieve the very high difficulty needed to create a valid\n> bitcoin block, you have achieved a very high bar.\n\n\"High\" is relative.\n\nI could make a 100BTC apparently sacrifice via fees by just waiting a\nmonth or two for my mining hardware to find a block that had a\npre-prepared fake sacrifice. It'd cost me roughly 1BTC when you take\norphans into account. Similarly I could hack into a pool and have them\ndo it on my behalf, or a pool could just offer the service for a fee.\n\nI already worry enough that announce-commit sacrifices to mining fees\naren't secure enough given the potential of a few large pools teaming\nup to create them cheaply, let alone what you're talking about...\n\n\nHey Luke: so what's the going rate to get Eligius to mine a fake mining\nfee sacrifice? Can I get a discount on repeat orders? :)\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000014c5bfacfca559fd6a9519dcd338f9fca6590eda7d156120013\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130604/0f3549cf/attachment.sig>"
            },
            {
                "author": "Luke-Jr",
                "date": "2013-06-06T19:14:17",
                "message_text_only": "On Saturday, June 01, 2013 7:30:36 PM Peter Todd wrote:\n> scriptPubKey: <data> OP_TRUE\n> \n> ...\n> Along with that change anyone-can-spend outputs should be make IsStandard()\n> so they will be relayed.\n\nData does not belong in the blockchain. People running nodes have all \nimplicitly agreed to store the blocks for financial purposes, and storing data \nis a violation of that social contract. Proof-of-stake may be arguably \nfinancial, but I'm sure there must be a way to do it without spamming people \nagainst their consent.\n\n> The alternative is sacrifices to unspendable outputs, which is very\n> undesirable compared to sending the money to miners to further\n> strengthen the security of the network.\n\nThe alternative is to make other standard outputs unable to store data as \nwell.\n\nLuke"
            },
            {
                "author": "Andreas M. Antonopoulos",
                "date": "2013-06-06T19:59:16",
                "message_text_only": "Is there any consideration given to the fact that bitcoin can operate as a\nplatform for many other services, if it is able to be neutral to payload,\nas long as the fee is paid for the transaction size?\n\nUnless I have misunderstood this discussion, it seems to me that this is a\nbit like saying in 1990 \"IP Is only for email, the majority of users want\nemail, we shouldn't allow video, voice or images\". Ooops, there goes the\nweb.\n\nIs it possible to solve this by solving the issue of provably un-spendable\noutputs without foreclosing on the possibility of other types of\ntransaction payloads (ie, not money), that would open the possibility for a\nmyriad of layered apps above? For example, hashes of content that is\nexternal to bitcoin, that people want to pay to have timestamped in the\nblockchain, as provably unspendable outputs.\n\nThe social compact is to accept transaction for fee. I think it is a major\nmistake to make decisions that discriminate on the content of the\ntransaction, saying that some uses are not appropriate. If the fee is paid\nand it covers the size of the transaction, why would it matter if it is not\na payment?\n\nI could be totally misreading this thread, too, so please allow me some\nslack if I have!\n\n\n\n\nOn Thu, Jun 6, 2013 at 12:14 PM, Luke-Jr <luke at dashjr.org> wrote:\n\n> On Saturday, June 01, 2013 7:30:36 PM Peter Todd wrote:\n> > scriptPubKey: <data> OP_TRUE\n> >\n> > ...\n> > Along with that change anyone-can-spend outputs should be make\n> IsStandard()\n> > so they will be relayed.\n>\n> Data does not belong in the blockchain. People running nodes have all\n> implicitly agreed to store the blocks for financial purposes, and storing\n> data\n> is a violation of that social contract. Proof-of-stake may be arguably\n> financial, but I'm sure there must be a way to do it without spamming\n> people\n> against their consent.\n>\n> > The alternative is sacrifices to unspendable outputs, which is very\n> > undesirable compared to sending the money to miners to further\n> > strengthen the security of the network.\n>\n> The alternative is to make other standard outputs unable to store data as\n> well.\n>\n> Luke\n>\n>\n> ------------------------------------------------------------------------------\n> How ServiceNow helps IT people transform IT departments:\n> 1. A cloud service to automate IT design, transition and operations\n> 2. Dashboards that offer high-level views of enterprise services\n> 3. A single system of record for all IT processes\n> http://p.sf.net/sfu/servicenow-d2d-j\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130606/89394efb/attachment.html>"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2013-06-06T20:25:54",
                "message_text_only": "On 6 June 2013 21:59, Andreas M. Antonopoulos <andreas at rooteleven.com>wrote:\n\n> Is there any consideration given to the fact that bitcoin can operate as a\n> platform for many other services, if it is able to be neutral to payload,\n> as long as the fee is paid for the transaction size?\n>\n> Unless I have misunderstood this discussion, it seems to me that this is a\n> bit like saying in 1990 \"IP Is only for email, the majority of users want\n> email, we shouldn't allow video, voice or images\". Ooops, there goes the\n> web.\n>\n> Is it possible to solve this by solving the issue of provably un-spendable\n> outputs without foreclosing on the possibility of other types of\n> transaction payloads (ie, not money), that would open the possibility for a\n> myriad of layered apps above? For example, hashes of content that is\n> external to bitcoin, that people want to pay to have timestamped in the\n> blockchain, as provably unspendable outputs.\n>\n> The social compact is to accept transaction for fee. I think it is a major\n> mistake to make decisions that discriminate on the content of the\n> transaction, saying that some uses are not appropriate. If the fee is paid\n> and it covers the size of the transaction, why would it matter if it is not\n> a payment?\n>\n> I could be totally misreading this thread, too, so please allow me some\n> slack if I have!\n>\n\n+1 we're still early into the bitcoin story ... unexpected reuse should not\nbe ruled out ...\n\n\n>\n>\n>\n>\n> On Thu, Jun 6, 2013 at 12:14 PM, Luke-Jr <luke at dashjr.org> wrote:\n>\n>> On Saturday, June 01, 2013 7:30:36 PM Peter Todd wrote:\n>> > scriptPubKey: <data> OP_TRUE\n>> >\n>> > ...\n>> > Along with that change anyone-can-spend outputs should be make\n>> IsStandard()\n>> > so they will be relayed.\n>>\n>> Data does not belong in the blockchain. People running nodes have all\n>> implicitly agreed to store the blocks for financial purposes, and storing\n>> data\n>> is a violation of that social contract. Proof-of-stake may be arguably\n>> financial, but I'm sure there must be a way to do it without spamming\n>> people\n>> against their consent.\n>>\n>> > The alternative is sacrifices to unspendable outputs, which is very\n>> > undesirable compared to sending the money to miners to further\n>> > strengthen the security of the network.\n>>\n>> The alternative is to make other standard outputs unable to store data as\n>> well.\n>>\n>> Luke\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> How ServiceNow helps IT people transform IT departments:\n>> 1. A cloud service to automate IT design, transition and operations\n>> 2. Dashboards that offer high-level views of enterprise services\n>> 3. A single system of record for all IT processes\n>> http://p.sf.net/sfu/servicenow-d2d-j\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> How ServiceNow helps IT people transform IT departments:\n> 1. A cloud service to automate IT design, transition and operations\n> 2. Dashboards that offer high-level views of enterprise services\n> 3. A single system of record for all IT processes\n> http://p.sf.net/sfu/servicenow-d2d-j\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130606/befb429c/attachment.html>"
            },
            {
                "author": "Luke-Jr",
                "date": "2013-06-06T20:07:38",
                "message_text_only": "On Thursday, June 06, 2013 7:59:16 PM Andreas M. Antonopoulos wrote:\n> Is there any consideration given to the fact that bitcoin can operate as a\n> platform for many other services, if it is able to be neutral to payload,\n> as long as the fee is paid for the transaction size?\n\nThis doesn't work like you might think: first of all, the fees today are \ngreatly subsidized - the actual cost to store data in the blockchain is much \nhigher than most storage solutions. Secondly, only the miner receives the \nfees, not the majority of nodes which have to bear the burden of the data.\nThat is, the fee system is setup as an antispam/deterrant, not as payment for \nstorage.\n\n> Unless I have misunderstood this discussion, it seems to me that this is a\n> bit like saying in 1990 \"IP Is only for email, the majority of users want\n> email, we shouldn't allow video, voice or images\". Ooops, there goes the\n> web.\n\nNot the same thing at all; nobody is forced to store/relay video/voice/images \nwithout reimbursement. On the other hand, any full Bitcoin node is required to \nat least download the entire blockchain once. And the network as a whole \nsuffers if nodes decide to start not-storing parts of the blockchain they \ndon't want to deal with.\n\n> Is it possible to solve this by solving the issue of provably un-spendable\n> outputs without foreclosing on the possibility of other types of\n> transaction payloads (ie, not money), that would open the possibility for a\n> myriad of layered apps above? For example, hashes of content that is\n> external to bitcoin, that people want to pay to have timestamped in the\n> blockchain, as provably unspendable outputs.\n\nThis is how merged mining solves the problem. A single extra hash in the \ncoinbase can link the bitcoin blockchain up with unlimited other data.\n\n> The social compact is to accept transaction for fee. I think it is a major\n> mistake to make decisions that discriminate on the content of the\n> transaction, saying that some uses are not appropriate. If the fee is paid\n> and it covers the size of the transaction, why would it matter if it is not\n> a payment?\n\nSee above.\n\n> I could be totally misreading this thread, too, so please allow me some\n> slack if I have!\n> \n> On Thu, Jun 6, 2013 at 12:14 PM, Luke-Jr <luke at dashjr.org> wrote:\n> > On Saturday, June 01, 2013 7:30:36 PM Peter Todd wrote:\n> > > scriptPubKey: <data> OP_TRUE\n> > > \n> > > ...\n> > > Along with that change anyone-can-spend outputs should be make\n> > \n> > IsStandard()\n> > \n> > > so they will be relayed.\n> > \n> > Data does not belong in the blockchain. People running nodes have all\n> > implicitly agreed to store the blocks for financial purposes, and storing\n> > data\n> > is a violation of that social contract. Proof-of-stake may be arguably\n> > financial, but I'm sure there must be a way to do it without spamming\n> > people\n> > against their consent.\n> > \n> > > The alternative is sacrifices to unspendable outputs, which is very\n> > > undesirable compared to sending the money to miners to further\n> > > strengthen the security of the network.\n> > \n> > The alternative is to make other standard outputs unable to store data as\n> > well.\n> > \n> > Luke\n> > \n> > \n> > -------------------------------------------------------------------------\n> > ----- How ServiceNow helps IT people transform IT departments:\n> > 1. A cloud service to automate IT design, transition and operations\n> > 2. Dashboards that offer high-level views of enterprise services\n> > 3. A single system of record for all IT processes\n> > http://p.sf.net/sfu/servicenow-d2d-j\n> > _______________________________________________\n> > Bitcoin-development mailing list\n> > Bitcoin-development at lists.sourceforge.net\n> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Andreas M. Antonopoulos",
                "date": "2013-06-06T20:16:40",
                "message_text_only": "> This doesn't work like you might think: first of all, the fees today are\n> greatly subsidized - the actual cost to store data in the blockchain is\n> much\n> higher than most storage solutions. Secondly, only the miner receives the\n> fees, not the majority of nodes which have to bear the burden of the data.\n> That is, the fee system is setup as an antispam/deterrant, not as payment\n> for\n> storage.\n>\n\nThere's a difference between storing the content itself, and storing just a\nhash to content (which however is not spendable payment). I undertand why\ncontent itself doesn't belong. But it goes too far to say that only\npayments should be allowed.\n\nIf the fees are not enough, fix the fee structure, don't stop incredibly\ninnovative and promising uses of the distributed timestamping database.\nThat is definitely throwing the baby out with the bathwater. If the issue\nis size, then address that, rather than the content itself.\n\nHave I misunderstood this discussion or are some proposing than nothing\nexcept payments be allowed?\n\nDiscriminating based on transaction content violates neutrality of the\nprotocol and in my mind removes a very very large possibility of future\ninnovation. If bitcoin is a *platform* and not just a payment system, then\nit needs to be neutral to content, like TCP/IP so that other protocols can\nbe layered. Solve the size problem itself, without picking and chosing\nwhich uses of bitcoin are good and which are \"bad\" or \"spam\". I think it\nrisks killing a tremendous amount of innovation just as it is starting.\n\n>\n>\n>\n> Not the same thing at all; nobody is forced to store/relay\n> video/voice/images\n> without reimbursement. On the other hand, any full Bitcoin node is\n> required to\n> at least download the entire blockchain once. And the network as a whole\n> suffers if nodes decide to start not-storing parts of the blockchain they\n> don't want to deal with.\n>\n> So don't store content, but allow hashes of content.\nAgain, I think it is extreme and extremely restrictive to say that ONLY\npayments are allowed.\n\n\n\n> This is how merged mining solves the problem. A single extra hash in the\n> coinbase can link the bitcoin blockchain up with unlimited other data.\n>\n>\n>\nCan you explain this part or refer me to some docs? What do you mean by\n\"coinbase\", I assume not the company.\n\n\nThanks for the reply and explanation!\n\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130606/bd951646/attachment.html>"
            },
            {
                "author": "Luke-Jr",
                "date": "2013-06-06T21:48:13",
                "message_text_only": "On Thursday, June 06, 2013 8:16:40 PM Andreas M. Antonopoulos wrote:\n> > This doesn't work like you might think: first of all, the fees today are\n> > greatly subsidized - the actual cost to store data in the blockchain is\n> > much higher than most storage solutions. Secondly, only the miner receives\n> > the fees, not the majority of nodes which have to bear the burden of the\n> > data. That is, the fee system is setup as an antispam/deterrant, not as\n> > payment for\n> > storage.\n> \n> There's a difference between storing the content itself, and storing just a\n> hash to content (which however is not spendable payment). I undertand why\n> content itself doesn't belong. But it goes too far to say that only\n> payments should be allowed.\n\nBecause payments are the only thing everyone using Bitcoin has agreed to use \nthe blockchain for. Furthermore, there is no *reason* to store non-payments in \nthe blockchain. If there was in fact such a use case, things might be arguable \n- but there isn't any I'm aware of.\n\n> If the fees are not enough, fix the fee structure, don't stop incredibly\n> innovative and promising uses of the distributed timestamping database.\n> That is definitely throwing the baby out with the bathwater. If the issue\n> is size, then address that, rather than the content itself.\n\nThe issue is using other peoples' resources for something they did not agree \nto use it for. The fees aren't merely \"not enough\", they were never *intended* \nto be \"cost of storage\". They are \"cost of security\" and \"prevent spamming\".\n\n> Discriminating based on transaction content violates neutrality of the\n> protocol and in my mind removes a very very large possibility of future\n> innovation. If bitcoin is a *platform* and not just a payment system, then\n> it needs to be neutral to content, like TCP/IP so that other protocols can\n> be layered. Solve the size problem itself, without picking and chosing\n> which uses of bitcoin are good and which are \"bad\" or \"spam\". I think it\n> risks killing a tremendous amount of innovation just as it is starting.\n\nThe concepts behind Bitcoin are applicable to future innovation, but this can \nall be accomplished without spamming Bitcoin itself.\n\n> > Not the same thing at all; nobody is forced to store/relay\n> > video/voice/images without reimbursement. On the other hand, any full\n> > Bitcoin node is required to at least download the entire blockchain once.\n> > And the network as a whole suffers if nodes decide to start not-storing\n> > parts of the blockchain they don't want to deal with.\n> > \n> > So don't store content, but allow hashes of content.\n> \n> Again, I think it is extreme and extremely restrictive to say that ONLY\n> payments are allowed.\n\nNon-payments are quite possible without the Bitcoin blockchain itself. If \nyou're worried that not enough people will store the alternative-non-payment \ndata, then you are essentially saying that voluntary participation is not \nenough and that forced storage is your solution. I don't think this is what \nyou intend...\n\n> > This is how merged mining solves the problem. A single extra hash in the\n> > coinbase can link the bitcoin blockchain up with unlimited other data.\n> \n> Can you explain this part or refer me to some docs? What do you mean by\n> \"coinbase\", I assume not the company.\n\nThe Bitcoin blockchain protocol has 95 bytes per block reserved for miners to \nput extra data. Currently, this is used for extranonces, political or other \nshort messages (such as in the Genesis block), miner \"signatures\", and also, \nas I mentioned, merged mining. Merged mining works by tying a non-\ntransactional merkle tree to the blockchain. The block coinbase stores the \nhash of the top of this merkle tree, so any data within the merkle tree can \nprove it is associated to the block. The merged mining merkle tree then stores \nhashes of multiple other data sets: for example, a Namecoin block can be \nreferenced in a merged mining merkle tree, to use the Bitcoin block's proof-\nof-work for itself (so, miners can mine both Bitcoin and Namecoin using the \nsame hashing effort). You could also add other non-transactional blocks to the \nmerged mining merkle tree, for generic timestamping or really anything at all.\n\nLuke"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2013-06-06T22:10:11",
                "message_text_only": "On 6 June 2013 23:48, Luke-Jr <luke at dashjr.org> wrote:\n\n> On Thursday, June 06, 2013 8:16:40 PM Andreas M. Antonopoulos wrote:\n> > > This doesn't work like you might think: first of all, the fees today\n> are\n> > > greatly subsidized - the actual cost to store data in the blockchain is\n> > > much higher than most storage solutions. Secondly, only the miner\n> receives\n> > > the fees, not the majority of nodes which have to bear the burden of\n> the\n> > > data. That is, the fee system is setup as an antispam/deterrant, not as\n> > > payment for\n> > > storage.\n> >\n> > There's a difference between storing the content itself, and storing\n> just a\n> > hash to content (which however is not spendable payment). I undertand why\n> > content itself doesn't belong. But it goes too far to say that only\n> > payments should be allowed.\n>\n> Because payments are the only thing everyone using Bitcoin has agreed to\n> use\n> the blockchain for. Furthermore, there is no *reason* to store\n> non-payments in\n> the blockchain. If there was in fact such a use case, things might be\n> arguable\n> - but there isn't any I'm aware of.\n>\n\nTwo quotes satoshi:\n\n\"Piling every proof-of-work quorum system in the world into one dataset\ndoesn't scale.\"\n\nand\n\n\"I like Hal Finney's idea for user-friendly timestamping.  Convert the hash\nof a file to a bitcoin address and send 0.01 to it\"\n\nThis leads me to believe, that while bitcoin should not be over used as a\ntime stamp server, there could be a balance reached for casual time stamp\nrecording as part of satoshi's concept.\n\nWhat we call \"spam\" is to a degree subjective, and I think not always\nobvious, tho in some cases it clearly is.\n\n\n> > If the fees are not enough, fix the fee structure, don't stop incredibly\n> > innovative and promising uses of the distributed timestamping database.\n> > That is definitely throwing the baby out with the bathwater. If the issue\n> > is size, then address that, rather than the content itself.\n>\n> The issue is using other peoples' resources for something they did not\n> agree\n> to use it for. The fees aren't merely \"not enough\", they were never\n> *intended*\n> to be \"cost of storage\". They are \"cost of security\" and \"prevent\n> spamming\".\n>\n> > Discriminating based on transaction content violates neutrality of the\n> > protocol and in my mind removes a very very large possibility of future\n> > innovation. If bitcoin is a *platform* and not just a payment system,\n> then\n> > it needs to be neutral to content, like TCP/IP so that other protocols\n> can\n> > be layered. Solve the size problem itself, without picking and chosing\n> > which uses of bitcoin are good and which are \"bad\" or \"spam\". I think it\n> > risks killing a tremendous amount of innovation just as it is starting.\n>\n> The concepts behind Bitcoin are applicable to future innovation, but this\n> can\n> all be accomplished without spamming Bitcoin itself.\n>\n> > > Not the same thing at all; nobody is forced to store/relay\n> > > video/voice/images without reimbursement. On the other hand, any full\n> > > Bitcoin node is required to at least download the entire blockchain\n> once.\n> > > And the network as a whole suffers if nodes decide to start not-storing\n> > > parts of the blockchain they don't want to deal with.\n> > >\n> > > So don't store content, but allow hashes of content.\n> >\n> > Again, I think it is extreme and extremely restrictive to say that ONLY\n> > payments are allowed.\n>\n> Non-payments are quite possible without the Bitcoin blockchain itself. If\n> you're worried that not enough people will store the\n> alternative-non-payment\n> data, then you are essentially saying that voluntary participation is not\n> enough and that forced storage is your solution. I don't think this is what\n> you intend...\n>\n> > > This is how merged mining solves the problem. A single extra hash in\n> the\n> > > coinbase can link the bitcoin blockchain up with unlimited other data.\n> >\n> > Can you explain this part or refer me to some docs? What do you mean by\n> > \"coinbase\", I assume not the company.\n>\n> The Bitcoin blockchain protocol has 95 bytes per block reserved for miners\n> to\n> put extra data. Currently, this is used for extranonces, political or other\n> short messages (such as in the Genesis block), miner \"signatures\", and\n> also,\n> as I mentioned, merged mining. Merged mining works by tying a non-\n> transactional merkle tree to the blockchain. The block coinbase stores the\n> hash of the top of this merkle tree, so any data within the merkle tree can\n> prove it is associated to the block. The merged mining merkle tree then\n> stores\n> hashes of multiple other data sets: for example, a Namecoin block can be\n> referenced in a merged mining merkle tree, to use the Bitcoin block's\n> proof-\n> of-work for itself (so, miners can mine both Bitcoin and Namecoin using the\n> same hashing effort). You could also add other non-transactional blocks to\n> the\n> merged mining merkle tree, for generic timestamping or really anything at\n> all.\n>\n> Luke\n>\n>\n> ------------------------------------------------------------------------------\n> How ServiceNow helps IT people transform IT departments:\n> 1. A cloud service to automate IT design, transition and operations\n> 2. Dashboards that offer high-level views of enterprise services\n> 3. A single system of record for all IT processes\n> http://p.sf.net/sfu/servicenow-d2d-j\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130607/79f171a4/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Proposal: soft-fork to make anyone-can-spend outputs unspendable for 100 blocks",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Luke-Jr",
                "Andreas M. Antonopoulos",
                "Adam Back",
                "John Dillon",
                "Roy Badami",
                "Peter Todd",
                "Mark Friedenbach",
                "Melvin Carvalho",
                "Michael Hendricks"
            ],
            "messages_count": 22,
            "total_messages_chars_count": 50512
        }
    },
    {
        "title": "[Bitcoin-development] Fwd: Creating a Currency for the (Read / Write) Web",
        "thread_messages": [
            {
                "author": "Melvin Carvalho",
                "date": "2013-06-05T17:01:42",
                "message_text_only": "FYI: I think this may be a possible blue print for a web version of\nbitcoin+ripple combined.\n\n---------- Forwarded message ----------\nFrom: Melvin Carvalho <melvincarvalho at gmail.com>\nDate: 5 June 2013 18:50\nSubject: Creating a Currency for the (Read / Write) Web\nTo: public-rww <public-rww at w3.org>, Nathan Rixham <nrixham at gmail.com>, Web\nPayments <public-webpayments at w3.org>\n\n\nI've been thinking for a while about how to create a currency for the read\nwrite web.  And I thought I'd share some preliminary ideas.  Essentially\nthis is bitcoin+ripple translated to the Web.\n\n*Introduction\n\n*\nFor those not familiar with the bitcoin concept it's essentially a\ndistributed ledger where each subject is a primary key in the ledger and\ncan hold 0 or more coins.  Coins are transferred using a signed and\ntimestamped PKI transaction log from one address to another, in a\ndistributed data base.\n\n*Addresses\n\n*\nI think using a portable URI for addresses is the thing that makes most\nsense.  So possibilities for this may be a URN, or schemes such as di:\n(digest) or ni: (named information).  Anyone should be able to generate an\naddress, and they should be wide ranging to improve liquidity.\n\n*Balances\n\n*\nBalances can be calculated by summing all inputs to that address.  You can\nadditionally keep a state of balances using the payswarm vocab, or perhaps,\ngoodRelations\n\n*Transactions\n\n*\nI think a distributed data base could be maintained using read / write web\ntechnologies, such as HTTP POST / PATCH or SPARQL Update.  The signatures\ncould be added using the WebKeys spec.\n\n*Distributed Database\n\n*\nThere are challenges associated with maintaining a distributed database.  I\nsuggest we start small and whoever opts in can become part of the\nverification process.  There are two recent methods for mitigating race\nconditions an important one of which is called \"double spend\".  One is\nproof of work, the other is consensus based on a unique node list.  I would\nsuggest using both techniques.  I'd like it to be possible to use both HTTP\n(with self signed certificates), HTTP, and (secure) websockets too as the\ntransport layer.\n\n*Coin Creation\n\n*\nThis tends to be the most contentious point, with people tending not to\nlike the \"premine\" concept where you allocate coins to yourself.  However\ncompanies like opencoin have successfully rolled out multi million or even\nbillion dollar premine schemes.  I would suggest coin creation in line with\nbitcoin, where they are created proportionally to those maintaining the\nintegrity of rhe shared database.\n\n*Spam Protection\n\n*\nGiven the nature of the system, it may be easy to spam the network with\nmicro transactions.  As such there should be a transaction fee where those\nthat pay the highest fee are prioritized.\n\n*Trust and Reputation\n\n*\nI think it would also help to have a trust and reputation system added to\nthe process, such that honest nodes benefit from acting honestly, and nodes\nwhich are dishonest or not up to date are considered less dubious.  The\nnature of the function should be that it's exponentially harder to gain\ntrust after you have a certain score.  Similar to chess ELO ratings.\n\n*Linked Data and Exensibility\n\n*\nI think there should be a deep integration with web principles and linked\ndata to promote an app eco system and allow unexpected reuse.  Also it\nshould allow extensions such as the ripple protocol's trust lines, IOUs and\ndistributed markets, which are not initially scoped out.  Reusing existing\nconcepts such as the bitcon blockchain (e.g. so-called coloured coins),\nripple ledger, opentransactions, payswarm and web credits should all be\ndoable.\n\n\nJust some food for thought.  Criticisms welcome.  Please let me know if\nyou're interested in running a node, and maybe we an get a reference\nimplementation going, as proof of concept.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130605/348483b9/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Fwd: Creating a Currency for the (Read / Write) Web",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Melvin Carvalho"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 4004
        }
    },
    {
        "title": "[Bitcoin-development] Revocability with known trusted escrow services?",
        "thread_messages": [
            {
                "author": "Peter Vessenes",
                "date": "2013-06-06T00:19:16",
                "message_text_only": "So, this\nhttp://www.americanbanker.com/bankthink/the-last-straw-for-bitcoin-1059608-1.html?pg=1\narticle got posted today, noting that FinCEN thinks irrevocable\npayments\nare money laundering tools.\n\nI will hold my thoughts about the net social good of rent-seeking large\ncorporations taking money from consumers over fraudulent reversals.\nActually, I won't, I just said it.\n\nAt any rate, it got me thinking, can we layer on revocability somehow\nwithout any protocol change, as an opt-in?\n\nMy initial scheme is a trusted (hah) escrow service that issues time\npromises for signing. If it doesn't receive a cancel message, it will sign\nat the end of the time.\n\nThe addresses would be listed by the escrow service, or in an open\nregistry, so you could see if you were going to have a delay period when\nyou saw a transaction go out.\n\nThis seems sort of poor to me, it imagines that mythical thing, a trusted\nescrow service, and is vulnerable to griefing, but I thought I'd see if\nsome of the brighter minds than me can come up with a layer-on approach\nhere.\n\nWhen I think about it, I can imagine that I would put a good number of my\ncoins in a one day reversible system, because I would have warning if\nsomeone wanted to try and spend them, and could do something about it. I'm\nnot sure if it gets me anything over a standard escrow arrangement, though.\n\nPeter\n\n-- \n\n------------------------------\n\n[image: CoinLab Logo]PETER VESSENES\nCEO\n\n*peter at coinlab.com * /  206.486.6856  / SKYPE: vessenes\n71 COLUMBIA ST / SUITE 300  /  SEATTLE, WA 98104\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130605/a980c720/attachment.html>"
            },
            {
                "author": "Alan Reiner",
                "date": "2013-06-06T00:34:55",
                "message_text_only": "The two most basic ways would be simply:\n\n(1) You create your transactions having a locktime of X days and has\nsequence numbers such that it can be replaced exactly once.  The\nreplacement, can be executed within 30 days.\n\n(2) You simply send money to 1-of-2 transactions:  me-or-you.  If the\nperson who is receiving it wants it, they have to sign for it by sending\nit to one of their own single-sig addresses.  Otherwise, you can return\nit to yourself at some point in the future.\n\nI don't totally understand the goal, and how/if these solutions actually\nachieve such goal.  But it does add a way for transactions to exist a\nnon-final state for some amount of time.  But in both cases,\naccessibility is still binary:  you have complete access to it, until\nyou don't.   Which might be seen as the point of irrevocable transfer.\n\n-Alan\n\n\n\nOn 06/05/2013 08:19 PM, Peter Vessenes wrote:\n> So, this\n> http://www.americanbanker.com/bankthink/the-last-straw-for-bitcoin-1059608-1.html?pg=1\n>  article got posted today, noting that FinCEN thinks irrevocable\n> payments are money laundering tools. \n>\n> I will hold my thoughts about the net social good of rent-seeking\n> large corporations taking money from consumers over fraudulent\n> reversals. Actually, I won't, I just said it.\n>\n> At any rate, it got me thinking, can we layer on revocability somehow\n> without any protocol change, as an opt-in?\n>\n> My initial scheme is a trusted (hah) escrow service that issues time\n> promises for signing. If it doesn't receive a cancel message, it will\n> sign at the end of the time. \n>\n> The addresses would be listed by the escrow service, or in an open\n> registry, so you could see if you were going to have a delay period\n> when you saw a transaction go out.\n>\n> This seems sort of poor to me, it imagines that mythical thing, a\n> trusted escrow service, and is vulnerable to griefing, but I thought\n> I'd see if some of the brighter minds than me can come up with a\n> layer-on approach here.\n>\n> When I think about it, I can imagine that I would put a good number of\n> my coins in a one day reversible system, because I would have warning\n> if someone wanted to try and spend them, and could do something about\n> it. I'm not sure if it gets me anything over a standard escrow\n> arrangement, though.\n>\n> Peter\n>\n> -- \n>\n> ------------------------------------------------------------------------\n>\n> CoinLab LogoPETER VESSENES \n> CEO\n>\n> *peter at coinlab.com <mailto:peter at coinlab.com> * /  206.486.6856\n>  / SKYPE: vessenes \n> 71 COLUMBIA ST / SUITE 300  /  SEATTLE, WA 98104\n>\n>\n>\n> ------------------------------------------------------------------------------\n> How ServiceNow helps IT people transform IT departments:\n> 1. A cloud service to automate IT design, transition and operations\n> 2. Dashboards that offer high-level views of enterprise services\n> 3. A single system of record for all IT processes\n> http://p.sf.net/sfu/servicenow-d2d-j\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130605/a7e538e5/attachment.html>"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2013-06-06T01:06:56",
                "message_text_only": "On 6 June 2013 02:19, Peter Vessenes <peter at coinlab.com> wrote:\n\n> So, this\n> http://www.americanbanker.com/bankthink/the-last-straw-for-bitcoin-1059608-1.html?pg=1 article got posted today, noting that FinCEN thinks irrevocable payments\n> are money laundering tools.\n>\n\nIt's great that this article quotes the first page of Sasoshi's white\npaper.  There are some other text that they missed, though, which I think\nmay be relevant.\n\n[[\nCompletely non-reversible transactions are not really possible, since\nfinancial institutions cannot\navoid mediating disputes. The cost of mediation increases transaction\ncosts, limiting the\nminimum practical transaction size and cutting off the possibility for\nsmall casual transactions,\nand there is a broader cost in the loss of ability to make non-reversible\npayments for non-\nreversible services. With the possibility of reversal, the need for trust\nspreads. Merchants must\nbe wary of their customers, hassling them for more information than they\nwould otherwise need.\nA certain percentage of fraud is accepted as unavoidable. These costs and\npayment uncertainties\ncan be avoided in person by using physical currency, but no mechanism\nexists to make payments\nover a communications channel without a trusted party.\n\nWhat is needed is an electronic payment system based on cryptographic proof\ninstead of trust,\nallowing any two willing parties to transact directly with each other\nwithout the need for a trusted\nthird party. Transactions that are computationally impractical to reverse\nwould protect sellers\nfrom fraud, and routine escrow mechanisms could easily be implemented to\nprotect buyers.\n]]\n\n\n>\n> I will hold my thoughts about the net social good of rent-seeking large\n> corporations taking money from consumers over fraudulent reversals.\n> Actually, I won't, I just said it.\n>\n> At any rate, it got me thinking, can we layer on revocability somehow\n> without any protocol change, as an opt-in?\n>\n> My initial scheme is a trusted (hah) escrow service that issues time\n> promises for signing. If it doesn't receive a cancel message, it will sign\n> at the end of the time.\n>\n> The addresses would be listed by the escrow service, or in an open\n> registry, so you could see if you were going to have a delay period when\n> you saw a transaction go out.\n>\n> This seems sort of poor to me, it imagines that mythical thing, a trusted\n> escrow service, and is vulnerable to griefing, but I thought I'd see if\n> some of the brighter minds than me can come up with a layer-on approach\n> here.\n>\n> When I think about it, I can imagine that I would put a good number of my\n> coins in a one day reversible system, because I would have warning if\n> someone wanted to try and spend them, and could do something about it. I'm\n> not sure if it gets me anything over a standard escrow arrangement, though.\n>\n> Peter\n>\n> --\n>\n> ------------------------------\n>\n> [image: CoinLab Logo]PETER VESSENES\n> CEO\n>\n> *peter at coinlab.com * /  206.486.6856  / SKYPE: vessenes\n> 71 COLUMBIA ST / SUITE 300  /  SEATTLE, WA 98104\n>\n>\n> ------------------------------------------------------------------------------\n> How ServiceNow helps IT people transform IT departments:\n> 1. A cloud service to automate IT design, transition and operations\n> 2. Dashboards that offer high-level views of enterprise services\n> 3. A single system of record for all IT processes\n> http://p.sf.net/sfu/servicenow-d2d-j\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130606/592bb5b3/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2013-06-06T08:31:16",
                "message_text_only": "On Wed, Jun 05, 2013 at 05:19:16PM -0700, Peter Vessenes wrote:\n> So, this\n> http://www.americanbanker.com/bankthink/the-last-straw-for-bitcoin-1059608-1.html?pg=1\n> article got posted today, noting that FinCEN thinks irrevocable\n> payments\n> are money laundering tools.\n> \n> I will hold my thoughts about the net social good of rent-seeking large\n> corporations taking money from consumers over fraudulent reversals.\n> Actually, I won't, I just said it.\n> \n> At any rate, it got me thinking, can we layer on revocability somehow\n> without any protocol change, as an opt-in?\n> \n> My initial scheme is a trusted (hah) escrow service that issues time\n> promises for signing. If it doesn't receive a cancel message, it will sign\n> at the end of the time.\n> \n> The addresses would be listed by the escrow service, or in an open\n> registry, so you could see if you were going to have a delay period when\n> you saw a transaction go out.\n> \n> This seems sort of poor to me, it imagines that mythical thing, a trusted\n> escrow service, and is vulnerable to griefing, but I thought I'd see if\n> some of the brighter minds than me can come up with a layer-on approach\n> here.\n> \n> When I think about it, I can imagine that I would put a good number of my\n> coins in a one day reversible system, because I would have warning if\n> someone wanted to try and spend them, and could do something about it. I'm\n> not sure if it gets me anything over a standard escrow arrangement, though.\n\nA few issues:\n\nRevocable payments are almost always invoked in cases where the decision\nthat a payment needs to be revoked is done by humans. To worry about the\ndifficulty of finding a \"trusted escrow service\" is irrelevant at the\nprotocol level - this isn't a problem that can be solved by math.\n\nLegally speaking revocation can generally happen any time in the future,\neven years in the future. Note the controversies involved around a\nvariety of land transactions that occured hundreds of years in the past\nin North America and other parts of the world, where distant relatives\nof those who made the transactions are attempting to have them reversed\npartially or fully. Technical solutions with a limited revocation window\nare likely to be found unacceptable in the eyes of the law.\n\nFocusing on the need to \"revoke\" a transaction is taking a banking idea,\nand applying it very incorrectly to the Bitcoin world; in banking\nrevoking a transaction can result in your balance being negative.\n\nWhat you need to focus on is the spirit of what revoking a transaction\nis about, which is to take money from someone who thought they had it,\nand give it to someone else. We can easily replicate this effect in\nBitcoin by simply giving the private keys for our wallets to the\nrelevant revocation authority, or, if more auditing is desired, storing\nour coins in 1-of-2 multisig addresses spendable by either us or that\nauthority.\n\nIn the event that a transaction needs to be revoked, simply have the\nescrow service make a transaction that takes the correct amount of coins\nfrom your wallet, and gives it to the person who sent you the money.\n\nProblem solved.\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000108f8cf27a2a2f49384346d915ff0970554358b9544bc7f5bfd\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130606/f92a83c2/attachment.sig>"
            },
            {
                "author": "Leszek Rychlewski",
                "date": "2013-06-06T09:01:52",
                "message_text_only": "Transactions with cash are even less revocable (there is no negative cash\nbalance while a btc wallet can have a negative balance) so it looks like the\nauthorities are exploiting differences between crypto currencies and the\nbanking system as an excuse to prosecute members of the new industry.\n\nCollecting arguments against such accusations should suffice [but I like the\nmaturation concept for dedicated accounts/transactions :-)].\n\nLeszek"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2013-06-06T16:31:34",
                "message_text_only": "P2SH with 2 of 3: the payer, recipient and a trusted third party.\nIt is explained here:\n\nhttps://en.bitcoin.it/wiki/Contracts#Example_2:_Escrow_and_dispute_mediation\n\nNothing can be done at the protocol level if you want it to remain\np2p. Much like the tainted coins stuff.\nMaybe offtopic but I disliked what everyone but Alan said in that\nbitcoin2013 \"security panel\" about it.\nWell, I didn't like several claims on that panel...\n\n\nOn 6/6/13, Leszek Rychlewski <leszek at bioinfo.pl> wrote:\n> Transactions with cash are even less revocable (there is no negative cash\n> balance while a btc wallet can have a negative balance) so it looks like\n> the\n> authorities are exploiting differences between crypto currencies and the\n> banking system as an excuse to prosecute members of the new industry.\n>\n> Collecting arguments against such accusations should suffice [but I like\n> the\n> maturation concept for dedicated accounts/transactions :-)].\n>\n> Leszek\n>\n>\n> ------------------------------------------------------------------------------\n> How ServiceNow helps IT people transform IT departments:\n> 1. A cloud service to automate IT design, transition and operations\n> 2. Dashboards that offer high-level views of enterprise services\n> 3. A single system of record for all IT processes\n> http://p.sf.net/sfu/servicenow-d2d-j\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n\n\n-- \nJorge Tim\u00f3n\n\nhttp://freico.in/"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-06-06T09:03:19",
                "message_text_only": "On Thu, Jun 6, 2013 at 2:19 AM, Peter Vessenes <peter at coinlab.com> wrote:\n\n> So, this\n> http://www.americanbanker.com/bankthink/the-last-straw-for-bitcoin-1059608-1.html?pg=1 article got posted today, noting that FinCEN thinks irrevocable payments\n> are money laundering tools.\n>\n\nThat's not how I read it, I don't see how one could argue that irreversible\ntransactions are a money laundering tool. Credit card transactions aren't\ncompletely reversible either, you have to either claim that the card was\nstolen or that the merchant didn't deliver. If you charge back routinely,\nthen the card companies are supposed to crack down on you. Though I don't\nknow if that really happens.\n\nI think we should expect the head of FinCEN to argue that more or less\nanything can be seen as money laundering. She directly and personally\nprofits from expansion of the notion of money laundering. That doesn't mean\nother people have to agree.\n\n\n> At any rate, it got me thinking, can we layer on revocability somehow\n> without any protocol change, as an opt-in?\n>\n\nI think we need 2-of-3 dispute mediation and have thought that for a long\ntime, indeed, Satoshi's paper says so:\n\nhttps://en.bitcoin.it/wiki/Contracts#Example_2:_Escrow_and_dispute_mediation\n\nIt doesn't require any core protocol changes but it does require deployment\nof the payment protocol first, as that's the foundation on which we can add\nlots of other useful features like that. And then it needs a whole lot of\nwork to define how you open a dispute from your wallet, how you find\nmutually agreeable mediators, etc. Having reversible payments in which one\nof the trading parties gets to decide whether to reverse seems pointless to\nme. If the buyer decides it's simply equivalent to post pay, and if the\nseller decides then it's just a refund, which the payment protocol already\nsupports.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130606/2ca93083/attachment.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2013-06-06T18:18:26",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nIf a technical solution could be found, I don't doubt that it will\nquickly become the only legal way to do transfers in the U.S.\n\nPeter, you are Executive Director of the Bitcoin Foundation. I would\nlike to know that your efforts are focused on fighting this archaic\nworld view, not bending over backwards to comply with it.\n\nMark\nOn 6/5/13 5:19 PM, Peter Vessenes wrote:\n> So, this http://www.americanbanker.com/bankthink/the-last-straw-for-bitcoin-1059608-1.html?pg=1  article got posted today, noting that FinCEN thinks irrevocable payments are money laundering tools.\n>\n> I will hold my thoughts about the net social good of rent-seeking\nlarge corporations taking money from consumers over fraudulent\nreversals. Actually, I won't, I just said it.\n>\n> At any rate, it got me thinking, can we layer on revocability somehow\nwithout any protocol change, as an opt-in?\n>\n> My initial scheme is a trusted (hah) escrow service that issues time\npromises for signing. If it doesn't receive a cancel message, it will\nsign at the end of the time.\n>\n> The addresses would be listed by the escrow service, or in an open\nregistry, so you could see if you were going to have a delay period when\nyou saw a transaction go out.\n>\n> This seems sort of poor to me, it imagines that mythical thing, a\ntrusted escrow service, and is vulnerable to griefing, but I thought I'd\nsee if some of the brighter minds than me can come up with a layer-on\napproach here.\n>\n> When I think about it, I can imagine that I would put a good number of\nmy coins in a one day reversible system, because I would have warning if\nsomeone wanted to try and spend them, and could do something about it.\nI'm not sure if it gets me anything over a standard escrow arrangement,\nthough.\n>\n> Peter\n>\n> --\n>\n> -------------------------\n>\n> CoinLab LogoPETER VESSENES\n> CEO\n>\n> *peter at coinlab.com <mailto:peter at coinlab.com> * /  206.486.6856  /\nSKYPE: vessenes\n> 71 COLUMBIA ST / SUITE 300  /  SEATTLE, WA 98104\n>\n>\n>\n>\n------------------------------------------------------------------------------\n> How ServiceNow helps IT people transform IT departments:\n> 1. A cloud service to automate IT design, transition and operations\n> 2. Dashboards that offer high-level views of enterprise services\n> 3. A single system of record for all IT processes\n> http://p.sf.net/sfu/servicenow-d2d-j\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG/MacGPG2 v2.0.19 (Darwin)\nComment: GPGTools - http://gpgtools.org\nComment: Using GnuPG with Thunderbird - http://www.enigmail.net/\n\niQIcBAEBAgAGBQJRsNJyAAoJEAdzVfsmodw4KBgP/A0ozXRdY0YbaFYL5tyWp+xO\nOdOKbVFSQynHMws+CyA47x/DgiUbzrRwmx3fN7N67pPizYpjQLfJEwNkr6oy0Ga6\nbbubYIz+TLI7sPS0B+ENg6XboChP+ZE7TPC56SyNgPUALwzsvcGZEYCHwwvIUx3F\nEcUtXTw+VsBu935nRTvKj2HXruU94CaCiapS0knvgWg1/sB/PRFDQzu+fbBiLSL0\nxWiuRaPs4dt+LCK2rfYtysKSv2S0FjOOwZ/Cj2J3KRtqTOnTSE2MZNAfNcMGA89u\nLwWAfZohXywk2mBOk6avYxi5I0nNOndzfKQZgyHMH6zYdIP8B4gtBMxNP4CtsLaH\nGWNdvYcxILcbeYqJUqlZfJamKkI0rAxgdk20YSaCAgU6rmJ8PQ4Ryl4uTS5i0xOb\nxfMmHT68SOsvfL8XWobpMidVIUA+vKDZbd5AmJ9RCvJV5mj0Mrt/nJQM04NEQmtE\ngb29fA1vh+nNKkPoVkyU02ghBYznurV+GMd5iFe8LObg6WxcIImadI1tdPpgINoK\nglHeUl0zGXsbZDodk7imeZA3DXIf5xa9LfoVmJZrMMB/c3SQqRMwtUX04dMYQiCG\nGq4eisPXrUwepZ6hSgXqGktXYKn9dIlXR43zl4+ZBDjsAIiRiipK12WCz3pUTDow\n/Xcx2iVrRWcZQefxJ3dz\n=o0rL\n-----END PGP SIGNATURE-----\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130606/83c47ef2/attachment.html>"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2013-06-06T22:22:40",
                "message_text_only": "On 6 June 2013 02:19, Peter Vessenes <peter at coinlab.com> wrote:\n\n> So, this\n> http://www.americanbanker.com/bankthink/the-last-straw-for-bitcoin-1059608-1.html?pg=1 article got posted today, noting that FinCEN thinks irrevocable payments\n> are money laundering tools.\n>\n> I will hold my thoughts about the net social good of rent-seeking large\n> corporations taking money from consumers over fraudulent reversals.\n> Actually, I won't, I just said it.\n>\n> At any rate, it got me thinking, can we layer on revocability somehow\n> without any protocol change, as an opt-in?\n>\n> My initial scheme is a trusted (hah) escrow service that issues time\n> promises for signing. If it doesn't receive a cancel message, it will sign\n> at the end of the time.\n>\n> The addresses would be listed by the escrow service, or in an open\n> registry, so you could see if you were going to have a delay period when\n> you saw a transaction go out.\n>\n> This seems sort of poor to me, it imagines that mythical thing, a trusted\n> escrow service, and is vulnerable to griefing, but I thought I'd see if\n> some of the brighter minds than me can come up with a layer-on approach\n> here.\n>\n> When I think about it, I can imagine that I would put a good number of my\n> coins in a one day reversible system, because I would have warning if\n> someone wanted to try and spend them, and could do something about it. I'm\n> not sure if it gets me anything over a standard escrow arrangement, though.\n>\n\nAlso see satoshi's comments on this, though it may be restating what others\nhave said:\n\nhttps://bitcointalk.org/index.php?topic=750.0\n\n\"Here's an outline of the kind of escrow transaction that's possible in\nsoftware.  This is not implemented and I probably won't have time to\nimplement it soon, but just to let you know what's possible.\n\nThe basic escrow: The buyer commits a payment to escrow. The seller\nreceives a transaction with the money in escrow, but he can't spend it\nuntil the buyer unlocks it. The buyer can release the payment at any time\nafter that, which could be never. This does not allow the buyer to take the\nmoney back, but it does give him the option to burn the money out of spite\nby never releasing it. The seller has the option to release the money back\nto the buyer.\n\nWhile this system does not guarantee the parties against loss, it takes the\nprofit out of cheating.\n\nIf the seller doesn't send the goods, he doesn't get paid. The buyer would\nstill be out the money, but at least the seller has no monetary motivation\nto stiff him.\n\nThe buyer can't benefit by failing to pay. He can't get the escrow money\nback. He can't fail to pay due to lack of funds. The seller can see that\nthe funds are committed to his key and can't be sent to anyone else.\n\nNow, an economist would say that a fraudulent seller could start\nnegotiating, such as \"release the money and I'll give you half of it back\",\nbut at that point, there would be so little trust and so much spite that\nnegotiation is unlikely. Why on earth would the fraudster keep his word and\nsend you half if he's already breaking his word to steal it? I think for\nmodest amounts, almost everyone would refuse on principle alone.\"\n\n\n>\n> Peter\n>\n> --\n>\n> ------------------------------\n>\n> [image: CoinLab Logo]PETER VESSENES\n> CEO\n>\n> *peter at coinlab.com * /  206.486.6856  / SKYPE: vessenes\n> 71 COLUMBIA ST / SUITE 300  /  SEATTLE, WA 98104\n>\n>\n> ------------------------------------------------------------------------------\n> How ServiceNow helps IT people transform IT departments:\n> 1. A cloud service to automate IT design, transition and operations\n> 2. Dashboards that offer high-level views of enterprise services\n> 3. A single system of record for all IT processes\n> http://p.sf.net/sfu/servicenow-d2d-j\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130607/c8a04aa5/attachment.html>"
            },
            {
                "author": "Caleb James DeLisle",
                "date": "2013-06-07T05:46:04",
                "message_text_only": "IMO this story falls somewhere between rose colored glasses and outright trolling.\nWhereas LR was a (relatively shady) company, bitcoin is an entire branch of technology\nand research, I can't think of any real caselaw in the US with regards to banning a\ntechnology, perhaps the cryptography export regulation and we all know how well that\nworked. Furthermore, the non-reversibility of LR is mostly because they didn't want\nto deal with mediation while the non-reversibility of bitcoin is technological barrier.\n\nIt seems AmericanBanker has a record of hosting articles which urge policy decisions:\n  http://www.americanbanker.com/bankthink/governments-must-co-opt-bitcoin-to-avert-disaster-1058380-1.html\nthat would obviously be of personal benefit to the article's author:\n  http://www.clearbit.com/company_management.htm\nIt is the very job of governments to resist the efforts of lobbyists to line their\npockets at the public expense.\n\nWhile I don't think significant risk of developed countries actually banning an entire\narea of research such as bitcoin, I do suspect that bitcoin's popularity lead to LR's\ndownfall as it will other companies which allow people to transact anonymously.\n\n\nThe tragedy of bitcoin's irreversibility is that it makes kidnap/ransom schemes\nprofitable. The relative safety of the first world is largely due to the fact that\nuntil now, there has never been any effective way to steal significant amounts of\nmoney. While this problem is serious I don't think it's intractable. Bitcoin offers\nus a modeling tool which like never before allows us to experiment with our\nmotivations and build something better than even bitcoin is today.\n\nI believe regulators are intelligent people who understand this and would rather\nlegitimize bitcoin than ban it. If there ever were such a ban, I would be more\nconcerned for the future of the country imposing it than I would for bitcoin.\n\n\nThanks,\nCaleb\n\ntl;dr haters gonna hate\n\n\n\nOn 06/06/2013 06:22 PM, Melvin Carvalho wrote:\n> \n> \n> \n> On 6 June 2013 02:19, Peter Vessenes <peter at coinlab.com <mailto:peter at coinlab.com>> wrote:\n> \n>     So, this http://www.americanbanker.com/bankthink/the-last-straw-for-bitcoin-1059608-1.html?pg=1  article got posted today, noting that FinCEN thinks irrevocable payments are money laundering tools. \n> \n>     I will hold my thoughts about the net social good of rent-seeking large corporations taking money from consumers over fraudulent reversals. Actually, I won't, I just said it.\n> \n>     At any rate, it got me thinking, can we layer on revocability somehow without any protocol change, as an opt-in?\n> \n>     My initial scheme is a trusted (hah) escrow service that issues time promises for signing. If it doesn't receive a cancel message, it will sign at the end of the time. \n> \n>     The addresses would be listed by the escrow service, or in an open registry, so you could see if you were going to have a delay period when you saw a transaction go out.\n> \n>     This seems sort of poor to me, it imagines that mythical thing, a trusted escrow service, and is vulnerable to griefing, but I thought I'd see if some of the brighter minds than me can come up with a layer-on approach here.\n> \n>     When I think about it, I can imagine that I would put a good number of my coins in a one day reversible system, because I would have warning if someone wanted to try and spend them, and could do something about it. I'm not sure if it gets me anything over a standard escrow arrangement, though.\n> \n> \n> Also see satoshi's comments on this, though it may be restating what others have said:\n> \n> https://bitcointalk.org/index.php?topic=750.0\n> \n> \"Here's an outline of the kind of escrow transaction that's possible in software.  This is not implemented and I probably won't have time to implement it soon, but just to let you know what's possible.\n> \n> The basic escrow: The buyer commits a payment to escrow. The seller receives a transaction with the money in escrow, but he can't spend it until the buyer unlocks it. The buyer can release the payment at any time after that, which could be never. This does not allow the buyer to take the money back, but it does give him the option to burn the money out of spite by never releasing it. The seller has the option to release the money back to the buyer.\n> \n> While this system does not guarantee the parties against loss, it takes the profit out of cheating.\n> \n> If the seller doesn't send the goods, he doesn't get paid. The buyer would still be out the money, but at least the seller has no monetary motivation to stiff him.\n> \n> The buyer can't benefit by failing to pay. He can't get the escrow money back. He can't fail to pay due to lack of funds. The seller can see that the funds are committed to his key and can't be sent to anyone else.\n> \n> Now, an economist would say that a fraudulent seller could start negotiating, such as \"release the money and I'll give you half of it back\", but at that point, there would be so little trust and so much spite that negotiation is unlikely. Why on earth would the fraudster keep his word and send you half if he's already breaking his word to steal it? I think for modest amounts, almost everyone would refuse on principle alone.\"\n>  \n> \n> \n>     Peter\n> \n>     -- \n> \n>     --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n> \n>     CoinLab LogoPETER VESSENES \n>     CEO\n> \n>     *peter at coinlab.com <mailto:peter at coinlab.com> * /  206.486.6856 <tel:206.486.6856>  / SKYPE: vessenes \n>     71 COLUMBIA ST / SUITE 300  /  SEATTLE, WA 98104\n> \n> \n>     ------------------------------------------------------------------------------\n>     How ServiceNow helps IT people transform IT departments:\n>     1. A cloud service to automate IT design, transition and operations\n>     2. Dashboards that offer high-level views of enterprise services\n>     3. A single system of record for all IT processes\n>     http://p.sf.net/sfu/servicenow-d2d-j\n>     _______________________________________________\n>     Bitcoin-development mailing list\n>     Bitcoin-development at lists.sourceforge.net <mailto:Bitcoin-development at lists.sourceforge.net>\n>     https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> \n> \n> \n> \n> ------------------------------------------------------------------------------\n> How ServiceNow helps IT people transform IT departments:\n> 1. A cloud service to automate IT design, transition and operations\n> 2. Dashboards that offer high-level views of enterprise services\n> 3. A single system of record for all IT processes\n> http://p.sf.net/sfu/servicenow-d2d-j\n> \n> \n> \n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            }
        ],
        "thread_summary": {
            "title": "Revocability with known trusted escrow services?",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Caleb James DeLisle",
                "Leszek Rychlewski",
                "Mike Hearn",
                "Peter Todd",
                "Peter Vessenes",
                "Alan Reiner",
                "Jorge Tim\u00f3n",
                "Mark Friedenbach",
                "Melvin Carvalho"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 31523
        }
    },
    {
        "title": "[Bitcoin-development] Blockchain alternative storage",
        "thread_messages": [
            {
                "author": "Marko Otbalkana",
                "date": "2013-06-06T00:53:16",
                "message_text_only": "Could anyone point me to work/project(s) related to storing the block chain\nin a database, like PostgreSQL, MySQL? How about any tools that can read\nthe block chain from the Satoshi client and convert it into different\nformats?\n\nThanks,\n-Marko\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130605/557f0d62/attachment.html>"
            },
            {
                "author": "Patrick Strateman",
                "date": "2013-06-06T01:17:30",
                "message_text_only": "If you're only interested in storing the best chain then a fairly simple\nschema is possible.\n\nCREATE TABLE blocks (\n    hash bytea NOT NULL PRIMARY KEY,\n    index integer NOT NULL UNIQUE,\n    CONSTRAINT block_hash_size_check CHECK ((octet_length(hash) = (256 /\n8)))\n);\n\nCREATE TABLE transaction_inputs (\n    output_transaction_id bytea NOT NULL,\n    output_index integer NOT NULL,\n    block_index integer NOT NULL,\n    CONSTRAINT transaction_id_size_check CHECK\n((octet_length(output_transaction_id) = (256 / 8))),\n    PRIMARY KEY (output_transaction_id, output_index)\n);\n\nCREATE INDEX transaction_inputs_block_index_idx ON transaction_inputs\nUSING btree (block_index)\n\nCREATE TABLE transaction_outputs (\n    transaction_id bytea NOT NULL,\n    index integer NOT NULL,\n    amount numeric(16,8) NOT NULL,\n    type character varying NOT NULL,\n    addresses character varying[],\n    block_index integer NOT NULL,\n    spent boolean DEFAULT false NOT NULL,\n    CONSTRAINT transaction_id_size_check CHECK\n((octet_length(transaction_id) = (256 / 8))),\n    PRIMARY KEY (transaction_id, index)\n);\n\nCREATE INDEX transaction_outputs_addresses_idx ON transaction_outputs\nUSING gin (addresses);\nCREATE INDEX transaction_outputs_block_index_idx ON transaction_outputs\nUSING btree (block_index);\n\nOn 06/05/2013 05:53 PM, Marko Otbalkana wrote:\n> Could anyone point me to work/project(s) related to storing the block\n> chain in a database, like PostgreSQL, MySQL? How about any tools that\n> can read the block chain from the Satoshi client and convert it into\n> different formats?\n>\n> Thanks,\n> -Marko\n>\n>\n> ------------------------------------------------------------------------------\n> How ServiceNow helps IT people transform IT departments:\n> 1. A cloud service to automate IT design, transition and operations\n> 2. Dashboards that offer high-level views of enterprise services\n> 3. A single system of record for all IT processes\n> http://p.sf.net/sfu/servicenow-d2d-j\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130605/3673d6e4/attachment.html>"
            },
            {
                "author": "Petr Praus",
                "date": "2013-06-06T01:49:22",
                "message_text_only": "BitcoinJ is storing parsed blocks (not the whole chunks of bytes) in H2, an\nembedded SQL database for Java.\n\n\nOn 5 June 2013 19:53, Marko Otbalkana <marko.otbalkana at gmail.com> wrote:\n\n> Could anyone point me to work/project(s) related to storing the block\n> chain in a database, like PostgreSQL, MySQL? How about any tools that can\n> read the block chain from the Satoshi client and convert it into different\n> formats?\n>\n> Thanks,\n> -Marko\n>\n>\n> ------------------------------------------------------------------------------\n> How ServiceNow helps IT people transform IT departments:\n> 1. A cloud service to automate IT design, transition and operations\n> 2. Dashboards that offer high-level views of enterprise services\n> 3. A single system of record for all IT processes\n> http://p.sf.net/sfu/servicenow-d2d-j\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130605/26287145/attachment.html>"
            },
            {
                "author": "Jouke Hofman",
                "date": "2013-06-06T08:20:50",
                "message_text_only": "Abe is able to do what you want.\n\nhttps://github.com/jtobey/bitcoin-abe\nhttps://bitcointalk.org/index.php?topic=22785.0\n\nWith kind regards,\n\nJouke Hofman\nBitonic.nl\n\n\n\nOn 06/06/2013 02:53 AM, Marko Otbalkana wrote:\n> Could anyone point me to work/project(s) related to storing the block\n> chain in a database, like PostgreSQL, MySQL? How about any tools that\n> can read the block chain from the Satoshi client and convert it into\n> different formats?\n> \n> Thanks,\n> -Marko\n> \n> \n> ------------------------------------------------------------------------------\n> How ServiceNow helps IT people transform IT departments:\n> 1. A cloud service to automate IT design, transition and operations\n> 2. Dashboards that offer high-level views of enterprise services\n> 3. A single system of record for all IT processes\n> http://p.sf.net/sfu/servicenow-d2d-j\n> \n> \n> \n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            }
        ],
        "thread_summary": {
            "title": "Blockchain alternative storage",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Marko Otbalkana",
                "Jouke Hofman",
                "Petr Praus",
                "Patrick Strateman"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 5026
        }
    },
    {
        "title": "[Bitcoin-development] address collision and undependability",
        "thread_messages": [
            {
                "author": "Melvin Carvalho",
                "date": "2013-06-06T11:37:26",
                "message_text_only": "There was a discussion on #bitcon-dev yesterday\n\nI stated that it would be impractical to generate two bitcoin addresses,\nsuch that they differed in exactly one character (modulo different\nchecksums).\n\nThe corollary to this is that if you find an address with a verifiable\nsignature.  Changing one character of that address would have no known\nprivate key, and hence be normally undependable.\n\nDoes that sound correct?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130606/4bd0ab7f/attachment.html>"
            },
            {
                "author": "Byte Coin",
                "date": "2013-06-06T12:00:42",
                "message_text_only": ">From https://bitcointalk.org/index.php?topic=20955.msg264038#msg264038\n\nThis may be an appropriate thread to mention that the the \"checksum\" at the end of an address does not effectively prevent single character errors or transpositions.\n\nFor instance https://blockexplorer.com/search/1ByteCoin  shows that\n\n1ByteCoinAddressesMatch1kpCWNXmHKW 1ByteCoinAddressesMatch1kpCxNXmHKW \nare both valid addresses even though they only differ by one character.\n\nSimilarly, the valid addresses\n\n1ByteCoinAddressesMatchcNN781jjwLY 1ByteCoinAddressesMatchcNN718jjwLY \nonly differ by one transposition.\n\nByteCoin\n----- Original Message -----\nFrom: Melvin Carvalho\nSent: 06/06/13 12:37 PM\nTo: Bitcoin Dev\nSubject: [Bitcoin-development] address collision and undependability\n\nThere was a discussion on #bitcon-dev yesterday\nI stated that it would be impractical to generate two bitcoin addresses, such that they differed in exactly one character (modulo different checksums).\nThe corollary to this is that if you find an address with a verifiable signature. Changing one character of that address would have no known private key, and hence be normally undependable.\nDoes that sound correct?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130606/ec2b4c4c/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "address collision and undependability",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Melvin Carvalho",
                "Byte Coin"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1959
        }
    },
    {
        "title": "[Bitcoin-development] Proposal: Vote on the blocksize limit with proof-of-stake voting",
        "thread_messages": [
            {
                "author": "John Dillon",
                "date": "2013-06-10T04:09:26",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nIt has been suggested that we leave the decision of what the blocksize to be\nentirely up to miners. However this leaves a parameter that affects every\nBitcoin participant in the control of a small minority. Of course we can not\nforce miners to increase the blocksize if they choose to decrease it, because\nthe contents of the blocks they make are their decision and their decision\nonly. However proposals to leave the maximum size unlimited to allow miners to\nforce us to accept arbitrarily large blocks even if the will of the majority of\nBitcoin participants is that they wish to remain able to validate the\nblockchain.\n\nWhat we need is a way to balance this asymetrical power relationship.\n\nProof-of-stake voting gives us a way of achieving that balance. Essentially for\na miner to prove that the majority will of the poeple is to accept a larger\nblocksize they must prove that the majority has in fact voted for that\nincrease. The upper limit on the blocksize is then determined by the median of\nall votes, where each txout in the UTXO set is one vote, weighted by txout\nvalue. A txout without a corresponding vote is considered to be a vote for the\nstatus quo. To allow the voting process to continue even if coins are \"lost\"\nvotes, including default votes, are weighted inversely according to their age\nin years after 1 year. IE a vote with weight 1BTC that is 1.5 years old will be\nrecorded the same as a <1 year old vote weighted as 0.67BTC, and a 1 day old\nand 6 months old UTXO are treated equivalently. The 1 year minimum is simply to\nmake voting required no more than once per year. (of course, a real\nimplementation should do all of these figures by block height, IE after 52,560\nblocks instead of after 1 year)\n\nA vote will consist of a txout with a scriptPubKey of the following form:\n\n    OP_RETURN magic vote_id txid vout vote scriptSig\n\nWhere scriptSig is a valid signature for a transaction with nLockTime\n500,000,000-1 spending txid:vout to scriptPubKey:\n\n    OP_HASH160 H(OP_RETURN magic vote_id txid vout vote) OP_EQUAL\n\nvote_id is the ID of the specific vote being made, and magic is included to\nallow UTXO proof implementations a as yet unspecified way of identifying votes\nand including the weighted median as part of the UTXO tree sums. (it also\nallows SPV clients to verify the vote if the UTXO set is a Patricia tree of\nscriptPubKeys) vote is just the numerical vote itself. The vote must compute\nthe median, rather than the mean, so as to not allow someone to skew the vote\nby simply setting their value extremely high. Someone who still remembers their\nstatistics classes should chime in on the right way to compute a median in a\nmerkle-sum-tree.\n\nThe slightly unusual construction of votes makes implementation by wallet\nsoftware as simple as possible within existing code-paths. Votes could still be\nconstructed even in wallets lacking specific voting capability provided the\nwallet software does have the ability to set nLockTime.\n\nOf course in the future the voting mechanism can be used for additional votes\nwith an additional vote_id. For instance the Bitcoin community could vote to\nincrease the inflation subsidy, another example of a situation where the wishes\nof miners may conflict with the wishes of the broader community.\n\nUsers may of course actually create these specially encoded txouts themselves\nand get them into the blockchain.  However doing so is not needed as a given\nvote is only required to actually be in the chain by a miner wishing to\nincrease the blocksize. Thus we should extend the P2P protocol with a mechanism\nby which votes can be broadcast independently of transactions. To prevent DoS\nattacks only votes with known vote_id's will be accepted, and only for\ntxid:vout's already in the blockchain, and a record of txouts for whom votes\nhave already broadcast will be kept. (this record need not be authoritative as\nits purpose is only to prevent DoS attacks) Miners wishing to increase the\nblocksize can record these votes and include them in the blocks they mine as\nrequired. To reduce the cost of including votes in blocks 5% of every block\nshould be assigned to voting only. (this can be implemented by a soft-fork)\n\nFor any given block actual limit in effect is then the rolling median of the\nblocks in the last year. At the beginning of every year the value considered to\nbe the status quo resets to the mean of the limit at the beginning and end of\nthe interval.  (again, by \"year\" we really mean 52,560 blocks) The rolling\nmedian and periodic reset process ensures that the limit changes gradually and\nis not influenced by temporary events such as hacks to large exchanges or\nmalicious wallet software.  The rolling median also ensures that for a miner\nthe act of including a vote is never wasted due to the txout later being spent.\n\nImplementing the voting system can happen prior to an actual hard-fork allowing\nfor an increase and can be an important part of determining if the hard-fork is\nrequired at all.\n\nCoercion and vote buying is of course possible in this system. A miner could\nsay that they will only accept transactions accompanied by a vote for a given\nlimit. However in a decentralized system completely preventing vote buying is\nof course impossble, and the design of Bitcoin itself has a fundemental\nassumption that a majority of miners will behave in a specific kind of \"honest\"\nway.\n\nA voting process ensures that any increase to the blocksize genuinely\nrepresents the desires of the Bitcoin community, and the process described\nabove ensures that any changes happen at a rate that gives all participants\ntime to react. The process also gives a mechanism for the community to vote to\ndecrease the limit if it turns out that the new one was in fact too high. (note\nhow the way the status quo is set ensures the default action is for the limit\nto gradually decrease even if everyone stops voting)\n\nAs many of you know I have been quite vocal that the 1MB limit should stay. But\nI would be happy to support the outcome of a vote done properly, whatever that\noutcome may be.\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\n\niQEcBAEBCAAGBQJRtVFBAAoJEEWCsU4mNhiP6EAIAMjq4UgXxmEjOgHWf0KcmwmH\nRa/I3oY7krvg/lu1YCa+ACMBdoca9WODySUIe7R3niphKXEnknHGUIf8tm/Vrq4H\ngPF4cgYEr18EYTVtvT9J1pZUB4f5dxkXXNpcQ60juaz9KervFQMOGnpr6Fyxi3dS\nghObNYcr3D2v1fjx56sp7BCNn0XHxTb1ZLUJB0BZhDKlamfgcxruKMbpsZmACJUj\ngTNLNweaAomBIH++j7cnXeB0jZc/1ilv8qLA/f3TGb43FDkAQcvvSjGijI+OJOm6\nFh/WRBav1BJiV6PKs9xuHXsaxZ/T7Fb8Wg8EynSi0mSj47QXdKZgeZCi3XlSyxM=\n=aKBD\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Peter Todd",
                "date": "2013-06-10T05:30:02",
                "message_text_only": "On Mon, Jun 10, 2013 at 04:09:26AM +0000, John Dillon wrote:\n\nMy general comments on the idea are that while it's hard to say if a\nvote by proof-of-stake is really representative, it's likely the closest\nthing we'll ever get to a fair vote. Proof-of-stake is certainely better\nthan just letting miners choose; as you point out miners can always\nchoose to decrease the blocksize anyway so we only need a vote on\nallowable increases. Proof-of-stake also clearly favors those who\nactually have invested in Bitcoin over those who only talk about\nBitcoin.\n\nI'll also say that while I know people will complain about putting\npolitics into a technical problem, as I keep saying, is *is* a political\nissue. The limitations may be technical, but the ultimate issue is a\nvery political decision about what we want Bitcoin to be. Yes, there\nwill be people campaigning left and right to get users to vote for\nvarious limits with their coins, deal with it. Democracy is messy.\n\nVoting would take a lot of the nastier politics out of the situation,\nperhaps somewhat ironically. It would quite clearly take control away\nfrom the core development team, and the Bitcoin Foundation, and put it\nback in the hands of the community; you can't argue conspiracy theories\nthat the Foundation is trying to control Bitcoin when there is a\ncompletely transparent voting system in place. People will complain that\nbig Bitcoin players are throwing their weight around, but the blockchain\nitself is a voting mechanism that is anything but 1 person = 1 vote.\n\nOf course I wouldn't be the slightest bit surprised if users happily\nvote themselves into something looking like a centralized PayPal\nreplacement in the long run, but at least if that happens the process by\nwhich they get there will be transparent and relatively democratic.\n\n\n> A vote will consist of a txout with a scriptPubKey of the following form:\n> \n>     OP_RETURN magic vote_id txid vout vote scriptSig\n> \n> Where scriptSig is a valid signature for a transaction with nLockTime\n> 500,000,000-1 spending txid:vout to scriptPubKey:\n> \n>     OP_HASH160 H(OP_RETURN magic vote_id txid vout vote) OP_EQUAL\n\nI just wanted to point out how general this mechanism is. Regardless of\nwhat the scriptPubKey form is, standard, P2SH, multisig, whatever to\nvote is to simply prove you could have spent the txout.\n\n> vote_id is the ID of the specific vote being made, and magic is included to\n> allow UTXO proof implementations a as yet unspecified way of identifying votes\n> and including the weighted median as part of the UTXO tree sums. (it also\n> allows SPV clients to verify the vote if the UTXO set is a Patricia tree of\n> scriptPubKeys) vote is just the numerical vote itself.\n\nAh, you're assuming a direct Patricia tree. Keep in mind that\nscriptPubKey's can be up to 10,000 bytes long, and an attacker can use\nthat (with 10,000 other txouts) to create some extremely deep trees. I\nsaid on IRC a few days ago about how skeptical I am of implementing\nconsensus critical systems with such huge differences in average and\nworst case, but I'll admit this is a decent use-case.\n\nHaving said that, proof to SPV clients leaves open the interesting\npossibility that a third-party holding Bitcoins on your behalf can prove\nthat they voted according to your wishes, or even prove they voted\naccording to all their users wishes. Basically we'd add a rule for the\nUTXO tree where a specific OP_RETURN form is included in the UTXO tree,\neven though it is unspendable, and is removed from the tree if the\nmaster txout is spent. Note that in this case by \"prove they voted\" we\nmean the service actually taking the step of ensuring their vote was\nrecorded in the blockchain.\n\n> The vote must compute\n> the median, rather than the mean, so as to not allow someone to skew the vote\n> by simply setting their value extremely high. Someone who still remembers their\n> statistics classes should chime in on the right way to compute a median in a\n> merkle-sum-tree.\n\nI think the definition of the median requires knowledge of all the points so\nit'll have to be a separate sorted tree - kinda complex unfortunately if\nyou really do want to be able to do full proof to SPV clients. Maybe\njust putting the hash of the overall results in the coinbase is enough\nfor now.\n\nThe term to google is \"moving median\" - looks complex.\n\n> Of course in the future the voting mechanism can be used for additional votes\n> with an additional vote_id. For instance the Bitcoin community could vote to\n> increase the inflation subsidy, another example of a situation where the wishes\n> of miners may conflict with the wishes of the broader community.\n\nGood idea on keeping the code general.\n\n> For any given block actual limit in effect is then the rolling median of the\n> blocks in the last year. At the beginning of every year the value considered to\n> be the status quo resets to the mean of the limit at the beginning and end of\n> the interval.  (again, by \"year\" we really mean 52,560 blocks) The rolling\n> median and periodic reset process ensures that the limit changes gradually and\n> is not influenced by temporary events such as hacks to large exchanges or\n> malicious wallet software.  The rolling median also ensures that for a miner\n> the act of including a vote is never wasted due to the txout later being spent.\n\nGood points, although keep in mind you've created a lot of consensus\ncritical code that is easiest to implement with floating point... not a\ngood thing.\n\nOne way to mitigate that risk might be to take advantage of the fact\nthat unless the rolling median code itself is buggy, a consensus failure\nin the calculation is likely to result in different implementations\nstill having a close agreement on the limit. So maybe we write some code\nwhere we won't build on top of a block that is larger than, say, 95% of\nthe hard-limit unless another miner does so too?\n\n> Implementing the voting system can happen prior to an actual hard-fork allowing\n> for an increase and can be an important part of determining if the hard-fork is\n> required at all.\n\nStep #0 would be to think about OP_RETURN actually. FWIW Jeff Garzik has\na pull-req (https://github.com/bitcoin/bitcoin/pull/2738) to enable it,\nalthough only one txout per tx, and only with a 80-byte payload.\n\nEven just some ad-hoc voting by the \"raise-the-limit\" crowd would be a\ngood first step to gaging interest.\n\n> Coercion and vote buying is of course possible in this system. A miner could\n> say that they will only accept transactions accompanied by a vote for a given\n> limit. However in a decentralized system completely preventing vote buying is\n> of course impossble, and the design of Bitcoin itself has a fundemental\n\nIs it really? There might be someone clever with a cryptographic voting\nprotocol, although in the case of Bitcoin we have to let people vote\nwith arbitrary scriptPubKeys, so almost anything less general than full\non SCIP just means miners force people to use the protocol where\nvote-buying is possible.\n\n> A voting process ensures that any increase to the blocksize genuinely\n> represents the desires of the Bitcoin community, and the process described\n> above ensures that any changes happen at a rate that gives all participants\n> time to react. The process also gives a mechanism for the community to vote to\n> decrease the limit if it turns out that the new one was in fact too high. (note\n> how the way the status quo is set ensures the default action is for the limit\n> to gradually decrease even if everyone stops voting)\n\nGood idea. So it'd decrease to the mean of the old and new limits\nbasically, and if Bitcoin becomes \"too centralized\" users can simply do\nnothing and the process gradually reverses.\n\n> As many of you know I have been quite vocal that the 1MB limit should stay. But\n> I would be happy to support the outcome of a vote done properly, whatever that\n> outcome may be.\n\nSame here.\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000068a8ad033afa763246fe451e840eae5215eb3a64e8101a46c3\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130610/3963113e/attachment.sig>"
            },
            {
                "author": "Daniel Lidstrom",
                "date": "2013-06-10T06:34:33",
                "message_text_only": "Reserving my judgement until I've though about it more (design by committee\nscares me, and this voting sounds expensive), I think the SPV-verifiable\nmoving median can be done by binning the space of block size limits, and\nfor each node in the UTXO tree, a value for each bin is stored which is the\nsum of the corresponding bins of each of the children.  The childless nodes\n- which correspond to the individual UTXOs - increment the appropriate bin\nof their parents according to the rules you mentioned.  The bin values in\nthe root node of the UTXO tree would then be added to those, weighted\nappropriately, of the previous N blocks.\n\nThe hash of a node would be that of the bin values, concatenated with the\nchild nodes' hashes.  In this way, any step of the calculation of the\nmedian would produce a localized error in the UTXO tree that's easily\nverified.\n\nThe number of bins would have to be kept relatively small in order to keep\nthis from adding too much data to the UTXO tree branches though.\n\n\nOn Mon, Jun 10, 2013 at 2:30 AM, Peter Todd <pete at petertodd.org> wrote:\n\n> On Mon, Jun 10, 2013 at 04:09:26AM +0000, John Dillon wrote:\n>\n> My general comments on the idea are that while it's hard to say if a\n> vote by proof-of-stake is really representative, it's likely the closest\n> thing we'll ever get to a fair vote. Proof-of-stake is certainely better\n> than just letting miners choose; as you point out miners can always\n> choose to decrease the blocksize anyway so we only need a vote on\n> allowable increases. Proof-of-stake also clearly favors those who\n> actually have invested in Bitcoin over those who only talk about\n> Bitcoin.\n>\n> I'll also say that while I know people will complain about putting\n> politics into a technical problem, as I keep saying, is *is* a political\n> issue. The limitations may be technical, but the ultimate issue is a\n> very political decision about what we want Bitcoin to be. Yes, there\n> will be people campaigning left and right to get users to vote for\n> various limits with their coins, deal with it. Democracy is messy.\n>\n> Voting would take a lot of the nastier politics out of the situation,\n> perhaps somewhat ironically. It would quite clearly take control away\n> from the core development team, and the Bitcoin Foundation, and put it\n> back in the hands of the community; you can't argue conspiracy theories\n> that the Foundation is trying to control Bitcoin when there is a\n> completely transparent voting system in place. People will complain that\n> big Bitcoin players are throwing their weight around, but the blockchain\n> itself is a voting mechanism that is anything but 1 person = 1 vote.\n>\n> Of course I wouldn't be the slightest bit surprised if users happily\n> vote themselves into something looking like a centralized PayPal\n> replacement in the long run, but at least if that happens the process by\n> which they get there will be transparent and relatively democratic.\n>\n>\n> > A vote will consist of a txout with a scriptPubKey of the following form:\n> >\n> >     OP_RETURN magic vote_id txid vout vote scriptSig\n> >\n> > Where scriptSig is a valid signature for a transaction with nLockTime\n> > 500,000,000-1 spending txid:vout to scriptPubKey:\n> >\n> >     OP_HASH160 H(OP_RETURN magic vote_id txid vout vote) OP_EQUAL\n>\n> I just wanted to point out how general this mechanism is. Regardless of\n> what the scriptPubKey form is, standard, P2SH, multisig, whatever to\n> vote is to simply prove you could have spent the txout.\n>\n> > vote_id is the ID of the specific vote being made, and magic is included\n> to\n> > allow UTXO proof implementations a as yet unspecified way of identifying\n> votes\n> > and including the weighted median as part of the UTXO tree sums. (it also\n> > allows SPV clients to verify the vote if the UTXO set is a Patricia tree\n> of\n> > scriptPubKeys) vote is just the numerical vote itself.\n>\n> Ah, you're assuming a direct Patricia tree. Keep in mind that\n> scriptPubKey's can be up to 10,000 bytes long, and an attacker can use\n> that (with 10,000 other txouts) to create some extremely deep trees. I\n> said on IRC a few days ago about how skeptical I am of implementing\n> consensus critical systems with such huge differences in average and\n> worst case, but I'll admit this is a decent use-case.\n>\n> Having said that, proof to SPV clients leaves open the interesting\n> possibility that a third-party holding Bitcoins on your behalf can prove\n> that they voted according to your wishes, or even prove they voted\n> according to all their users wishes. Basically we'd add a rule for the\n> UTXO tree where a specific OP_RETURN form is included in the UTXO tree,\n> even though it is unspendable, and is removed from the tree if the\n> master txout is spent. Note that in this case by \"prove they voted\" we\n> mean the service actually taking the step of ensuring their vote was\n> recorded in the blockchain.\n>\n> > The vote must compute\n> > the median, rather than the mean, so as to not allow someone to skew the\n> vote\n> > by simply setting their value extremely high. Someone who still\n> remembers their\n> > statistics classes should chime in on the right way to compute a median\n> in a\n> > merkle-sum-tree.\n>\n> I think the definition of the median requires knowledge of all the points\n> so\n> it'll have to be a separate sorted tree - kinda complex unfortunately if\n> you really do want to be able to do full proof to SPV clients. Maybe\n> just putting the hash of the overall results in the coinbase is enough\n> for now.\n>\n> The term to google is \"moving median\" - looks complex.\n>\n> > Of course in the future the voting mechanism can be used for additional\n> votes\n> > with an additional vote_id. For instance the Bitcoin community could\n> vote to\n> > increase the inflation subsidy, another example of a situation where the\n> wishes\n> > of miners may conflict with the wishes of the broader community.\n>\n> Good idea on keeping the code general.\n>\n> > For any given block actual limit in effect is then the rolling median of\n> the\n> > blocks in the last year. At the beginning of every year the value\n> considered to\n> > be the status quo resets to the mean of the limit at the beginning and\n> end of\n> > the interval.  (again, by \"year\" we really mean 52,560 blocks) The\n> rolling\n> > median and periodic reset process ensures that the limit changes\n> gradually and\n> > is not influenced by temporary events such as hacks to large exchanges or\n> > malicious wallet software.  The rolling median also ensures that for a\n> miner\n> > the act of including a vote is never wasted due to the txout later being\n> spent.\n>\n> Good points, although keep in mind you've created a lot of consensus\n> critical code that is easiest to implement with floating point... not a\n> good thing.\n>\n> One way to mitigate that risk might be to take advantage of the fact\n> that unless the rolling median code itself is buggy, a consensus failure\n> in the calculation is likely to result in different implementations\n> still having a close agreement on the limit. So maybe we write some code\n> where we won't build on top of a block that is larger than, say, 95% of\n> the hard-limit unless another miner does so too?\n>\n> > Implementing the voting system can happen prior to an actual hard-fork\n> allowing\n> > for an increase and can be an important part of determining if the\n> hard-fork is\n> > required at all.\n>\n> Step #0 would be to think about OP_RETURN actually. FWIW Jeff Garzik has\n> a pull-req (https://github.com/bitcoin/bitcoin/pull/2738) to enable it,\n> although only one txout per tx, and only with a 80-byte payload.\n>\n> Even just some ad-hoc voting by the \"raise-the-limit\" crowd would be a\n> good first step to gaging interest.\n>\n> > Coercion and vote buying is of course possible in this system. A miner\n> could\n> > say that they will only accept transactions accompanied by a vote for a\n> given\n> > limit. However in a decentralized system completely preventing vote\n> buying is\n> > of course impossble, and the design of Bitcoin itself has a fundemental\n>\n> Is it really? There might be someone clever with a cryptographic voting\n> protocol, although in the case of Bitcoin we have to let people vote\n> with arbitrary scriptPubKeys, so almost anything less general than full\n> on SCIP just means miners force people to use the protocol where\n> vote-buying is possible.\n>\n> > A voting process ensures that any increase to the blocksize genuinely\n> > represents the desires of the Bitcoin community, and the process\n> described\n> > above ensures that any changes happen at a rate that gives all\n> participants\n> > time to react. The process also gives a mechanism for the community to\n> vote to\n> > decrease the limit if it turns out that the new one was in fact too\n> high. (note\n> > how the way the status quo is set ensures the default action is for the\n> limit\n> > to gradually decrease even if everyone stops voting)\n>\n> Good idea. So it'd decrease to the mean of the old and new limits\n> basically, and if Bitcoin becomes \"too centralized\" users can simply do\n> nothing and the process gradually reverses.\n>\n> > As many of you know I have been quite vocal that the 1MB limit should\n> stay. But\n> > I would be happy to support the outcome of a vote done properly,\n> whatever that\n> > outcome may be.\n>\n> Same here.\n>\n> --\n> 'peter'[:-1]@petertodd.org\n> 0000000000000068a8ad033afa763246fe451e840eae5215eb3a64e8101a46c3\n>\n>\n> ------------------------------------------------------------------------------\n> How ServiceNow helps IT people transform IT departments:\n> 1. A cloud service to automate IT design, transition and operations\n> 2. Dashboards that offer high-level views of enterprise services\n> 3. A single system of record for all IT processes\n> http://p.sf.net/sfu/servicenow-d2d-j\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130610/214bfa8e/attachment.html>"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2013-06-10T08:14:01",
                "message_text_only": "On 10 June 2013 06:09, John Dillon <john.dillon892 at googlemail.com> wrote:\n\n> -----BEGIN PGP SIGNED MESSAGE-----\n> Hash: SHA256\n>\n> It has been suggested that we leave the decision of what the blocksize to\n> be\n> entirely up to miners. However this leaves a parameter that affects every\n> Bitcoin participant in the control of a small minority. Of course we can\n> not\n> force miners to increase the blocksize if they choose to decrease it,\n> because\n> the contents of the blocks they make are their decision and their decision\n> only. However proposals to leave the maximum size unlimited to allow\n> miners to\n> force us to accept arbitrarily large blocks even if the will of the\n> majority of\n> Bitcoin participants is that they wish to remain able to validate the\n> blockchain.\n>\n> What we need is a way to balance this asymetrical power relationship.\n>\n> Proof-of-stake voting gives us a way of achieving that balance.\n> Essentially for\n> a miner to prove that the majority will of the poeple is to accept a larger\n> blocksize they must prove that the majority has in fact voted for that\n> increase. The upper limit on the blocksize is then determined by the\n> median of\n> all votes, where each txout in the UTXO set is one vote, weighted by txout\n> value. A txout without a corresponding vote is considered to be a vote for\n> the\n> status quo. To allow the voting process to continue even if coins are\n> \"lost\"\n> votes, including default votes, are weighted inversely according to their\n> age\n> in years after 1 year. IE a vote with weight 1BTC that is 1.5 years old\n> will be\n> recorded the same as a <1 year old vote weighted as 0.67BTC, and a 1 day\n> old\n> and 6 months old UTXO are treated equivalently. The 1 year minimum is\n> simply to\n> make voting required no more than once per year. (of course, a real\n> implementation should do all of these figures by block height, IE after\n> 52,560\n> blocks instead of after 1 year)\n>\n> A vote will consist of a txout with a scriptPubKey of the following form:\n>\n>     OP_RETURN magic vote_id txid vout vote scriptSig\n>\n> Where scriptSig is a valid signature for a transaction with nLockTime\n> 500,000,000-1 spending txid:vout to scriptPubKey:\n>\n>     OP_HASH160 H(OP_RETURN magic vote_id txid vout vote) OP_EQUAL\n>\n> vote_id is the ID of the specific vote being made, and magic is included to\n> allow UTXO proof implementations a as yet unspecified way of identifying\n> votes\n> and including the weighted median as part of the UTXO tree sums. (it also\n> allows SPV clients to verify the vote if the UTXO set is a Patricia tree of\n> scriptPubKeys) vote is just the numerical vote itself. The vote must\n> compute\n> the median, rather than the mean, so as to not allow someone to skew the\n> vote\n> by simply setting their value extremely high. Someone who still remembers\n> their\n> statistics classes should chime in on the right way to compute a median in\n> a\n> merkle-sum-tree.\n>\n> The slightly unusual construction of votes makes implementation by wallet\n> software as simple as possible within existing code-paths. Votes could\n> still be\n> constructed even in wallets lacking specific voting capability provided the\n> wallet software does have the ability to set nLockTime.\n>\n> Of course in the future the voting mechanism can be used for additional\n> votes\n> with an additional vote_id. For instance the Bitcoin community could vote\n> to\n> increase the inflation subsidy, another example of a situation where the\n> wishes\n> of miners may conflict with the wishes of the broader community.\n>\n> Users may of course actually create these specially encoded txouts\n> themselves\n> and get them into the blockchain.  However doing so is not needed as a\n> given\n> vote is only required to actually be in the chain by a miner wishing to\n> increase the blocksize. Thus we should extend the P2P protocol with a\n> mechanism\n> by which votes can be broadcast independently of transactions. To prevent\n> DoS\n> attacks only votes with known vote_id's will be accepted, and only for\n> txid:vout's already in the blockchain, and a record of txouts for whom\n> votes\n> have already broadcast will be kept. (this record need not be\n> authoritative as\n> its purpose is only to prevent DoS attacks) Miners wishing to increase the\n> blocksize can record these votes and include them in the blocks they mine\n> as\n> required. To reduce the cost of including votes in blocks 5% of every block\n> should be assigned to voting only. (this can be implemented by a soft-fork)\n>\n> For any given block actual limit in effect is then the rolling median of\n> the\n> blocks in the last year. At the beginning of every year the value\n> considered to\n> be the status quo resets to the mean of the limit at the beginning and end\n> of\n> the interval.  (again, by \"year\" we really mean 52,560 blocks) The rolling\n> median and periodic reset process ensures that the limit changes gradually\n> and\n> is not influenced by temporary events such as hacks to large exchanges or\n> malicious wallet software.  The rolling median also ensures that for a\n> miner\n> the act of including a vote is never wasted due to the txout later being\n> spent.\n>\n> Implementing the voting system can happen prior to an actual hard-fork\n> allowing\n> for an increase and can be an important part of determining if the\n> hard-fork is\n> required at all.\n>\n> Coercion and vote buying is of course possible in this system. A miner\n> could\n> say that they will only accept transactions accompanied by a vote for a\n> given\n> limit. However in a decentralized system completely preventing vote buying\n> is\n> of course impossble, and the design of Bitcoin itself has a fundemental\n> assumption that a majority of miners will behave in a specific kind of\n> \"honest\"\n> way.\n>\n> A voting process ensures that any increase to the blocksize genuinely\n> represents the desires of the Bitcoin community, and the process described\n> above ensures that any changes happen at a rate that gives all participants\n> time to react. The process also gives a mechanism for the community to\n> vote to\n> decrease the limit if it turns out that the new one was in fact too high.\n> (note\n> how the way the status quo is set ensures the default action is for the\n> limit\n> to gradually decrease even if everyone stops voting)\n>\n> As many of you know I have been quite vocal that the 1MB limit should\n> stay. But\n> I would be happy to support the outcome of a vote done properly, whatever\n> that\n> outcome may be.\n> -----BEGIN PGP SIGNATURE-----\n> Version: GnuPG v1.4.11 (GNU/Linux)\n>\n> iQEcBAEBCAAGBQJRtVFBAAoJEEWCsU4mNhiP6EAIAMjq4UgXxmEjOgHWf0KcmwmH\n> Ra/I3oY7krvg/lu1YCa+ACMBdoca9WODySUIe7R3niphKXEnknHGUIf8tm/Vrq4H\n> gPF4cgYEr18EYTVtvT9J1pZUB4f5dxkXXNpcQ60juaz9KervFQMOGnpr6Fyxi3dS\n> ghObNYcr3D2v1fjx56sp7BCNn0XHxTb1ZLUJB0BZhDKlamfgcxruKMbpsZmACJUj\n> gTNLNweaAomBIH++j7cnXeB0jZc/1ilv8qLA/f3TGb43FDkAQcvvSjGijI+OJOm6\n> Fh/WRBav1BJiV6PKs9xuHXsaxZ/T7Fb8Wg8EynSi0mSj47QXdKZgeZCi3XlSyxM=\n> =aKBD\n> -----END PGP SIGNATURE-----\n>\n\n-1\n\nFirstly I appreciate the ingenious thought that went into this post.\n\nHowever, Bitcoin's fundamental philosophy was one CPU one vote.\n\nVoting is easily gamed.  While this may work in one particular case, it is\nperhaps a bad precedent to set.  Establishing methods of voting can lead to\nsingle points of failure.\n\nThe asymmetry lies in psychological terms, in that new defaults tend to be\nadopted 80% of the time, so core devs have disproportionate amount of power\nas things stand.\n\nUnless there's a very good reason not to, e.g. miners are clearly abusing\nthe system, we should stick with 1 CPU one vote.\n\n\n>\n>\n> ------------------------------------------------------------------------------\n> How ServiceNow helps IT people transform IT departments:\n> 1. A cloud service to automate IT design, transition and operations\n> 2. Dashboards that offer high-level views of enterprise services\n> 3. A single system of record for all IT processes\n> http://p.sf.net/sfu/servicenow-d2d-j\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130610/e22f5db1/attachment.html>"
            },
            {
                "author": "John Dillon",
                "date": "2013-06-10T08:26:39",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nOn Mon, Jun 10, 2013 at 8:14 AM, Melvin Carvalho\n<melvincarvalho at gmail.com> wrote:\n> -1\n>\n> Firstly I appreciate the ingenious thought that went into this post.\n>\n> However, Bitcoin's fundamental philosophy was one CPU one vote.\n\nIndeed it was. Which is why as GPU's came onto the scene Satoshi was strongly\nagainst them. I have to wonder what he thinks of ASICs where just a handful of\ncompanies control the supply of Bitcoin hashing power.\n\nSatoshi also never forsaw pools, which are why just 2 or 3 people control the\nmajority of Bitcoin hashing power.\n\n> The asymmetry lies in psychological terms, in that new defaults tend to be\n> adopted 80% of the time, so core devs have disproportionate amount of power\n> as things stand.\n\nThat's why I'm very clear that doing nothing is a vote for the status quo. Of\ncourse wallet authors can do what they want to try to get users to vote\naccording to their wishes, or for that matter simply steal your vote, but we\nalready must put a lot of faith into wallets to not steal our funds.\n\n> Unless there's a very good reason not to, e.g. miners are clearly abusing\n> the system, we should stick with 1 CPU one vote.\n\nPeople are proposing we put control of the blocksize entirely into the hands of\nminers, yet we all have an interest in auditing the blocks miners produce.\nThere must be balance.\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\n\niQEcBAEBCAAGBQJRtY2jAAoJEEWCsU4mNhiPQEsH/0VNA7aJYdUbJjTnIiKoaCv3\nJtWS1MKHjAJE6ZPDt+T/QPkEdZI4kNz3DGcZL6EDJtvZxZHfvEIaZDF1gpaH6OkC\noIZ0PkFPOxi0cncuAvT/a770evu7LzuT6fisY3EgGnlHujLQZ47LEa73Xo7pJVc7\nRJHamGwkj+3HZRIuZIAn87qws/zRyTx5SXvb56xCKb0oxE4ZO0dn+8/nNSPWw13i\np3LpLlEQBBu+Du2nPSQupRjkz4MPP8v9EYefV5cjtNBK7ufAvA64OnwKB5dST+h+\nN/vBcj3EIj/WEOf4myGcVxKp+skJ2SJDwxLigevgkKYPDNTVfXIverdXB0ANrQA=\n=c8iU\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2013-06-10T08:39:09",
                "message_text_only": "On 10 June 2013 10:26, John Dillon <john.dillon892 at googlemail.com> wrote:\n\n> -----BEGIN PGP SIGNED MESSAGE-----\n> Hash: SHA256\n>\n> On Mon, Jun 10, 2013 at 8:14 AM, Melvin Carvalho\n> <melvincarvalho at gmail.com> wrote:\n> > -1\n> >\n> > Firstly I appreciate the ingenious thought that went into this post.\n> >\n> > However, Bitcoin's fundamental philosophy was one CPU one vote.\n>\n> Indeed it was. Which is why as GPU's came onto the scene Satoshi was\n> strongly\n> against them. I have to wonder what he thinks of ASICs where just a\n> handful of\n> companies control the supply of Bitcoin hashing power.\n>\n\nThanks for your reply.  Do you have a pointer to Satoshi being strongly\nagainst GPU?  I'd be interested to see that.  FWIW, I've read all his forum\nposts a few times, I just dont recall this one, tho I'm sure it's there...\n\n\n>\n> Satoshi also never forsaw pools, which are why just 2 or 3 people control\n> the\n> majority of Bitcoin hashing power.\n>\n> > The asymmetry lies in psychological terms, in that new defaults tend to\n> be\n> > adopted 80% of the time, so core devs have disproportionate amount of\n> power\n> > as things stand.\n>\n> That's why I'm very clear that doing nothing is a vote for the status quo.\n> Of\n> course wallet authors can do what they want to try to get users to vote\n> according to their wishes, or for that matter simply steal your vote, but\n> we\n> already must put a lot of faith into wallets to not steal our funds.\n>\n> > Unless there's a very good reason not to, e.g. miners are clearly abusing\n> > the system, we should stick with 1 CPU one vote.\n>\n> People are proposing we put control of the blocksize entirely into the\n> hands of\n> miners, yet we all have an interest in auditing the blocks miners produce.\n> There must be balance.\n> -----BEGIN PGP SIGNATURE-----\n> Version: GnuPG v1.4.11 (GNU/Linux)\n>\n> iQEcBAEBCAAGBQJRtY2jAAoJEEWCsU4mNhiPQEsH/0VNA7aJYdUbJjTnIiKoaCv3\n> JtWS1MKHjAJE6ZPDt+T/QPkEdZI4kNz3DGcZL6EDJtvZxZHfvEIaZDF1gpaH6OkC\n> oIZ0PkFPOxi0cncuAvT/a770evu7LzuT6fisY3EgGnlHujLQZ47LEa73Xo7pJVc7\n> RJHamGwkj+3HZRIuZIAn87qws/zRyTx5SXvb56xCKb0oxE4ZO0dn+8/nNSPWw13i\n> p3LpLlEQBBu+Du2nPSQupRjkz4MPP8v9EYefV5cjtNBK7ufAvA64OnwKB5dST+h+\n> N/vBcj3EIj/WEOf4myGcVxKp+skJ2SJDwxLigevgkKYPDNTVfXIverdXB0ANrQA=\n> =c8iU\n> -----END PGP SIGNATURE-----\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130610/d2971bec/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2013-06-10T08:35:19",
                "message_text_only": "On Mon, Jun 10, 2013 at 10:14 AM, Melvin Carvalho\n<melvincarvalho at gmail.com> wrote:\n> However, Bitcoin's fundamental philosophy was one CPU one vote.\n\nThis is perhaps the largest misconception that keeps being repeated.\nBitcoin is not a democracy; it is a zero-trust system. The rules are\nset in stone, and every full node verifies all rules and must\nindependently come to the same result as everyone else. Obviously, if\neveryone changes their software, anything can change, but from within\nthe system there is no way to change which blocks are considered\nvalid, and there is certainly no voting mechanism about that.\n\nWhat is voted about, is the one single thing that cannot be decided by\neach node individually: namely the order of otherwise valid and\nnon-conflicting transactions, and that's just because it's a\nnecessity. Because deciding the order includes delaying transaction\npotentially indefinitely, a majority of miners can indeed choose the\nenforce an additional rule about which transactions are considered\nvalid, but the rules implemented in full nodes do not change without\nchanging the software. For example, miners cannot decide to raise the\nblock subsidy, even if every single miner out there would want that.\nThey'd just end up being ignored by everyone else.\n\n> Voting is easily gamed.  While this may work in one particular case, it is\n> perhaps a bad precedent to set.  Establishing methods of voting can lead to\n> single points of failure.\n\nThe problem is that at some point, you have to look at the system from\na higher level than just the technical part. And because ultimately\nthe possibility exists where everyone changes their software, and\nthere is an exceedingly high incentive for consensus (a deliberate\nhard-fork where two groups of users decide to use different and\nincompatible rules, aware of eachother, is suicide for the system, in\nmy opinion). This results in the fact that proposed changes can indeed\nbecome new adopted hard rules in the system, and I don't think there's\nanything that can be done about it. Bitcoin is a consensus system - at\nthe technical level - but also a consensus of the people using it, and\nultimately they decide the rules.\n\n> Unless there's a very good reason not to, e.g. miners are clearly abusing\n> the system, we should stick with 1 CPU one vote.\n\nSo you're saying that instead of a zero-trust system, we should move\nto a system where miners can decide _everything_ - as opposed to just\nbeing in charge of ordering transactions? I don't think you understand\nthe system at all, if that is what you're proposing.\n\n-- \nPieter"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2013-06-10T12:30:02",
                "message_text_only": "On 10 June 2013 10:35, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n\n> On Mon, Jun 10, 2013 at 10:14 AM, Melvin Carvalho\n> <melvincarvalho at gmail.com> wrote:\n> > However, Bitcoin's fundamental philosophy was one CPU one vote.\n>\n> This is perhaps the largest misconception that keeps being repeated.\n> Bitcoin is not a democracy; it is a zero-trust system. The rules are\n> set in stone, and every full node verifies all rules and must\n> independently come to the same result as everyone else. Obviously, if\n> everyone changes their software, anything can change, but from within\n> the system there is no way to change which blocks are considered\n> valid, and there is certainly no voting mechanism about that.\n>\n> What is voted about, is the one single thing that cannot be decided by\n> each node individually: namely the order of otherwise valid and\n> non-conflicting transactions, and that's just because it's a\n> necessity. Because deciding the order includes delaying transaction\n> potentially indefinitely, a majority of miners can indeed choose the\n> enforce an additional rule about which transactions are considered\n> valid, but the rules implemented in full nodes do not change without\n> changing the software. For example, miners cannot decide to raise the\n> block subsidy, even if every single miner out there would want that.\n> They'd just end up being ignored by everyone else.\n>\n> > Voting is easily gamed.  While this may work in one particular case, it\n> is\n> > perhaps a bad precedent to set.  Establishing methods of voting can lead\n> to\n> > single points of failure.\n>\n> The problem is that at some point, you have to look at the system from\n> a higher level than just the technical part. And because ultimately\n> the possibility exists where everyone changes their software, and\n> there is an exceedingly high incentive for consensus (a deliberate\n> hard-fork where two groups of users decide to use different and\n> incompatible rules, aware of eachother, is suicide for the system, in\n> my opinion). This results in the fact that proposed changes can indeed\n> become new adopted hard rules in the system, and I don't think there's\n> anything that can be done about it. Bitcoin is a consensus system - at\n> the technical level - but also a consensus of the people using it, and\n> ultimately they decide the rules.\n>\n\nOK I accept that the timestamping is one CPU one vote.  However rule\nchanges seem rather arbitrary.\n\nTowit if you use a voting/consensus system and want to destroy bitcion it\nseems quite easy.\n\nIterate on picking a rule chance that will divide the consensus in such a\nway as to create ensuing chaos.\n\nI think voting is too easy gamed for it it to be meaningful other than a\nstraw poll.\n\nIf there's a bug, and everyone is unanimous that it's a bug, it can be\nfixed.\n\nIf there's a controversial rule change, we should be extremely cautious and\nnot do it unless there's a very good reason.  Keeping to satoshi's model as\nmuch as possible without introducing human factors, unnecessarily.\n\n\n>\n>\n> > Unless there's a very good reason not to, e.g. miners are clearly abusing\n> > the system, we should stick with 1 CPU one vote.\n>\n> So you're saying that instead of a zero-trust system, we should move\n> to a system where miners can decide _everything_ - as opposed to just\n> being in charge of ordering transactions? I don't think you understand\n> the system at all, if that is what you're proposing.\n>\n> --\n> Pieter\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130610/7686b617/attachment.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2013-06-10T16:46:16",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nJohn,\n\nWhat you are recommending is a drastic change that the conservative\nbitcoin developers probably wouldn't get behind (but let's see). However\nproof-of-stake voting on protocol soft-forks has vast implications even\nbeyond the block size limit. Within Freicoin, we have looked at is as a\npossibility for determining how to distribute the demurrage, a proposal\nwe are calling 'Republicoin' due to the fact that with proxy voting we\nexpect a system to emerge similar to the government budgeting in\nparliamentary republics. Distributed, non-coersive government by\nprotocol, if you will.\n\nSo anyway, even if you get shot down, please continue to pursue this\nproposal. It very likely has uses that you haven't thought of yet.\n\nCheers,\nMark\n\nOn 6/9/13 9:09 PM, John Dillon wrote:\n> It has been suggested that we leave the decision of what the blocksize to be\n> entirely up to miners. However this leaves a parameter that affects every\n> Bitcoin participant in the control of a small minority. Of course we\ncan not\n> force miners to increase the blocksize if they choose to decrease it,\nbecause\n> the contents of the blocks they make are their decision and their decision\n> only. However proposals to leave the maximum size unlimited to allow\nminers to\n> force us to accept arbitrarily large blocks even if the will of the\nmajority of\n> Bitcoin participants is that they wish to remain able to validate the\n> blockchain.\n>\n> What we need is a way to balance this asymetrical power relationship.\n>\n> Proof-of-stake voting gives us a way of achieving that balance.\nEssentially for\n> a miner to prove that the majority will of the poeple is to accept a\nlarger\n> blocksize they must prove that the majority has in fact voted for that\n> increase. The upper limit on the blocksize is then determined by the\nmedian of\n> all votes, where each txout in the UTXO set is one vote, weighted by txout\n> value. A txout without a corresponding vote is considered to be a vote\nfor the\n> status quo. To allow the voting process to continue even if coins are\n\"lost\"\n> votes, including default votes, are weighted inversely according to\ntheir age\n> in years after 1 year. IE a vote with weight 1BTC that is 1.5 years\nold will be\n> recorded the same as a <1 year old vote weighted as 0.67BTC, and a 1\nday old\n> and 6 months old UTXO are treated equivalently. The 1 year minimum is\nsimply to\n> make voting required no more than once per year. (of course, a real\n> implementation should do all of these figures by block height, IE\nafter 52,560\n> blocks instead of after 1 year)\n>\n> A vote will consist of a txout with a scriptPubKey of the following form:\n>\n>     OP_RETURN magic vote_id txid vout vote scriptSig\n>\n> Where scriptSig is a valid signature for a transaction with nLockTime\n> 500,000,000-1 spending txid:vout to scriptPubKey:\n>\n>     OP_HASH160 H(OP_RETURN magic vote_id txid vout vote) OP_EQUAL\n>\n> vote_id is the ID of the specific vote being made, and magic is\nincluded to\n> allow UTXO proof implementations a as yet unspecified way of\nidentifying votes\n> and including the weighted median as part of the UTXO tree sums. (it also\n> allows SPV clients to verify the vote if the UTXO set is a Patricia\ntree of\n> scriptPubKeys) vote is just the numerical vote itself. The vote must\ncompute\n> the median, rather than the mean, so as to not allow someone to skew\nthe vote\n> by simply setting their value extremely high. Someone who still\nremembers their\n> statistics classes should chime in on the right way to compute a\nmedian in a\n> merkle-sum-tree.\n>\n> The slightly unusual construction of votes makes implementation by wallet\n> software as simple as possible within existing code-paths. Votes could\nstill be\n> constructed even in wallets lacking specific voting capability\nprovided the\n> wallet software does have the ability to set nLockTime.\n>\n> Of course in the future the voting mechanism can be used for\nadditional votes\n> with an additional vote_id. For instance the Bitcoin community could\nvote to\n> increase the inflation subsidy, another example of a situation where\nthe wishes\n> of miners may conflict with the wishes of the broader community.\n>\n> Users may of course actually create these specially encoded txouts\nthemselves\n> and get them into the blockchain.  However doing so is not needed as a\ngiven\n> vote is only required to actually be in the chain by a miner wishing to\n> increase the blocksize. Thus we should extend the P2P protocol with a\nmechanism\n> by which votes can be broadcast independently of transactions. To\nprevent DoS\n> attacks only votes with known vote_id's will be accepted, and only for\n> txid:vout's already in the blockchain, and a record of txouts for whom\nvotes\n> have already broadcast will be kept. (this record need not be\nauthoritative as\n> its purpose is only to prevent DoS attacks) Miners wishing to increase the\n> blocksize can record these votes and include them in the blocks they\nmine as\n> required. To reduce the cost of including votes in blocks 5% of every\nblock\n> should be assigned to voting only. (this can be implemented by a\nsoft-fork)\n>\n> For any given block actual limit in effect is then the rolling median\nof the\n> blocks in the last year. At the beginning of every year the value\nconsidered to\n> be the status quo resets to the mean of the limit at the beginning and\nend of\n> the interval.  (again, by \"year\" we really mean 52,560 blocks) The rolling\n> median and periodic reset process ensures that the limit changes\ngradually and\n> is not influenced by temporary events such as hacks to large exchanges or\n> malicious wallet software.  The rolling median also ensures that for a\nminer\n> the act of including a vote is never wasted due to the txout later\nbeing spent.\n>\n> Implementing the voting system can happen prior to an actual hard-fork\nallowing\n> for an increase and can be an important part of determining if the\nhard-fork is\n> required at all.\n>\n> Coercion and vote buying is of course possible in this system. A miner\ncould\n> say that they will only accept transactions accompanied by a vote for\na given\n> limit. However in a decentralized system completely preventing vote\nbuying is\n> of course impossble, and the design of Bitcoin itself has a fundemental\n> assumption that a majority of miners will behave in a specific kind of\n\"honest\"\n> way.\n>\n> A voting process ensures that any increase to the blocksize genuinely\n> represents the desires of the Bitcoin community, and the process described\n> above ensures that any changes happen at a rate that gives all\nparticipants\n> time to react. The process also gives a mechanism for the community to\nvote to\n> decrease the limit if it turns out that the new one was in fact too\nhigh. (note\n> how the way the status quo is set ensures the default action is for\nthe limit\n> to gradually decrease even if everyone stops voting)\n>\n> As many of you know I have been quite vocal that the 1MB limit should\nstay. But\n> I would be happy to support the outcome of a vote done properly,\nwhatever that\n> outcome may be.\n>\n>\n------------------------------------------------------------------------------\n> How ServiceNow helps IT people transform IT departments:\n> 1. A cloud service to automate IT design, transition and operations\n> 2. Dashboards that offer high-level views of enterprise services\n> 3. A single system of record for all IT processes\n> http://p.sf.net/sfu/servicenow-d2d-j\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> .\n>\n\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG/MacGPG2 v2.0.19 (Darwin)\nComment: GPGTools - http://gpgtools.org\nComment: Using GnuPG with Thunderbird - http://www.enigmail.net/\n\niQIcBAEBAgAGBQJRtgLYAAoJEAdzVfsmodw4vWEQAIWxuEXMZb80qTMFyvWiR0Tt\nCn/yx8iG2tPa4xGUq0ypwBU3doFEzYBj3bMyQuluGRP7BBhGat4qhrmI/qGVwYXW\nRSQdbdgnp4DXhaOD2QzYh/5zDbN/1jCkuxyUvx/QNAeNEpmN1BoDKhDlM/ywCKdj\nqfFZWj30pTzADJiY7P5upCu3TiYuQtTWTHlap2c4fToNsLxAMiLZJTOE1Ytdc31Q\nO8iwkV7eFlueawtfFLh/dNz5zVKXSOoNz1sFmgjkO3QQaSqSzinBE1z3vR9QYL+A\nR7X1v0sQXDpE0XiPymWE8adjGIai3CBUVZcvnJrPtUznydmpe+OvLf3UZE+QfCuJ\ntLP9u42e+gjOb6r9qp4tLZBGlTR2moY/IPtVs8KiMDWt9Nq1fO94IBGyJgFYOxRn\nZq6/funKTO6SO8d+ppQ158s2faVmN3OKMrn6BNnfddWD3/EBhGzEDzuNuNAvfKqQ\nnrqEusWrfOZOh66pIs6qvROSamaC42FXMUwBU0wA3W3MEuQhXrGM1S2huKykgZ9W\nWsOpC6ng6j5H5dSIs4tvnsDY9hUa9zWIB1+i368pXDv8biOs7ULKEP3mdC1q+4YD\ntM/MkC0xKax2zG4wbbez8FpwTpUOOznpYPMZqXkLOkGCAdiAyg2UnLPduudaAkQz\nadXXe284XHjjOcZUDvGw\n=trsn\n-----END PGP SIGNATURE-----\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130610/42ceb624/attachment.html>"
            },
            {
                "author": "Alan Reiner",
                "date": "2013-06-10T17:25:05",
                "message_text_only": "One major problem I see with this, no matter how well-thought-out it is,\nit's unlikely that those with money will participate.  Those with the\nmost stake, likely have their private keys behind super-secure\naccessibility barriers, and are not likely to go through the effort just\nto sign votes.  Not only that, but it would require them to reveal their\npublic key, which while isn't technically so terrible, large amounts of\nmoney intended to be kept in storage for 10+ years will prefer to avoid\nany exposure at all, in the oft-chance that QCs come around a lot\nearlier than we expected.  Sure, the actual risk should be pretty much\nnon-existent, but some of the most paranoid folks are probably the same\nones who have a lot of funds and want 100.00% of the security that is\npossible.   They will see this as wildly inconvenient.\n\nI think this a great thought experiment, and I'd like to see where this\nidea goes, in terms of designing ways for a decentralized community to\nfind consensus for important decisions, but I don't think that any idea\nthat requires users to dig up their private keys is going to be feasible\n(or possibly reconstruct them from pieces and/or get multiple\nsignatures).  Especially if the system requires some kind of persistent\nvoting.\n\n-Alan\n\n\nOn 06/10/2013 12:46 PM, Mark Friedenbach wrote:\n>\n> John,\n>\n> What you are recommending is a drastic change that the conservative\n> bitcoin developers probably wouldn't get behind (but let's see).\n> However proof-of-stake voting on protocol soft-forks has vast\n> implications even beyond the block size limit. Within Freicoin, we\n> have looked at is as a possibility for determining how to distribute\n> the demurrage, a proposal we are calling 'Republicoin' due to the fact\n> that with proxy voting we expect a system to emerge similar to the\n> government budgeting in parliamentary republics. Distributed,\n> non-coersive government by protocol, if you will.\n>\n> So anyway, even if you get shot down, please continue to pursue this\n> proposal. It very likely has uses that you haven't thought of yet.\n>\n> Cheers,\n> Mark\n>\n> On 6/9/13 9:09 PM, John Dillon wrote:\n> > It has been suggested that we leave the decision of what the\n> blocksize to be\n> > entirely up to miners. However this leaves a parameter that affects\n> every\n> > Bitcoin participant in the control of a small minority. Of course we\n> can not\n> > force miners to increase the blocksize if they choose to decrease\n> it, because\n> > the contents of the blocks they make are their decision and their\n> decision\n> > only. However proposals to leave the maximum size unlimited to allow\n> miners to\n> > force us to accept arbitrarily large blocks even if the will of the\n> majority of\n> > Bitcoin participants is that they wish to remain able to validate the\n> > blockchain.\n>\n> > What we need is a way to balance this asymetrical power relationship.\n>\n> > Proof-of-stake voting gives us a way of achieving that balance.\n> Essentially for\n> > a miner to prove that the majority will of the poeple is to accept a\n> larger\n> > blocksize they must prove that the majority has in fact voted for that\n> > increase. The upper limit on the blocksize is then determined by the\n> median of\n> > all votes, where each txout in the UTXO set is one vote, weighted by\n> txout\n> > value. A txout without a corresponding vote is considered to be a\n> vote for the\n> > status quo. To allow the voting process to continue even if coins\n> are \"lost\"\n> > votes, including default votes, are weighted inversely according to\n> their age\n> > in years after 1 year. IE a vote with weight 1BTC that is 1.5 years\n> old will be\n> > recorded the same as a <1 year old vote weighted as 0.67BTC, and a 1\n> day old\n> > and 6 months old UTXO are treated equivalently. The 1 year minimum\n> is simply to\n> > make voting required no more than once per year. (of course, a real\n> > implementation should do all of these figures by block height, IE\n> after 52,560\n> > blocks instead of after 1 year)\n>\n> > A vote will consist of a txout with a scriptPubKey of the following\n> form:\n>\n> >     OP_RETURN magic vote_id txid vout vote scriptSig\n>\n> > Where scriptSig is a valid signature for a transaction with nLockTime\n> > 500,000,000-1 spending txid:vout to scriptPubKey:\n>\n> >     OP_HASH160 H(OP_RETURN magic vote_id txid vout vote) OP_EQUAL\n>\n> > vote_id is the ID of the specific vote being made, and magic is\n> included to\n> > allow UTXO proof implementations a as yet unspecified way of\n> identifying votes\n> > and including the weighted median as part of the UTXO tree sums. (it\n> also\n> > allows SPV clients to verify the vote if the UTXO set is a Patricia\n> tree of\n> > scriptPubKeys) vote is just the numerical vote itself. The vote must\n> compute\n> > the median, rather than the mean, so as to not allow someone to skew\n> the vote\n> > by simply setting their value extremely high. Someone who still\n> remembers their\n> > statistics classes should chime in on the right way to compute a\n> median in a\n> > merkle-sum-tree.\n>\n> > The slightly unusual construction of votes makes implementation by\n> wallet\n> > software as simple as possible within existing code-paths. Votes\n> could still be\n> > constructed even in wallets lacking specific voting capability\n> provided the\n> > wallet software does have the ability to set nLockTime.\n>\n> > Of course in the future the voting mechanism can be used for\n> additional votes\n> > with an additional vote_id. For instance the Bitcoin community could\n> vote to\n> > increase the inflation subsidy, another example of a situation where\n> the wishes\n> > of miners may conflict with the wishes of the broader community.\n>\n> > Users may of course actually create these specially encoded txouts\n> themselves\n> > and get them into the blockchain.  However doing so is not needed as\n> a given\n> > vote is only required to actually be in the chain by a miner wishing to\n> > increase the blocksize. Thus we should extend the P2P protocol with\n> a mechanism\n> > by which votes can be broadcast independently of transactions. To\n> prevent DoS\n> > attacks only votes with known vote_id's will be accepted, and only for\n> > txid:vout's already in the blockchain, and a record of txouts for\n> whom votes\n> > have already broadcast will be kept. (this record need not be\n> authoritative as\n> > its purpose is only to prevent DoS attacks) Miners wishing to\n> increase the\n> > blocksize can record these votes and include them in the blocks they\n> mine as\n> > required. To reduce the cost of including votes in blocks 5% of\n> every block\n> > should be assigned to voting only. (this can be implemented by a\n> soft-fork)\n>\n> > For any given block actual limit in effect is then the rolling\n> median of the\n> > blocks in the last year. At the beginning of every year the value\n> considered to\n> > be the status quo resets to the mean of the limit at the beginning\n> and end of\n> > the interval.  (again, by \"year\" we really mean 52,560 blocks) The\n> rolling\n> > median and periodic reset process ensures that the limit changes\n> gradually and\n> > is not influenced by temporary events such as hacks to large\n> exchanges or\n> > malicious wallet software.  The rolling median also ensures that for\n> a miner\n> > the act of including a vote is never wasted due to the txout later\n> being spent.\n>\n> > Implementing the voting system can happen prior to an actual\n> hard-fork allowing\n> > for an increase and can be an important part of determining if the\n> hard-fork is\n> > required at all.\n>\n> > Coercion and vote buying is of course possible in this system. A\n> miner could\n> > say that they will only accept transactions accompanied by a vote\n> for a given\n> > limit. However in a decentralized system completely preventing vote\n> buying is\n> > of course impossble, and the design of Bitcoin itself has a fundemental\n> > assumption that a majority of miners will behave in a specific kind\n> of \"honest\"\n> > way.\n>\n> > A voting process ensures that any increase to the blocksize genuinely\n> > represents the desires of the Bitcoin community, and the process\n> described\n> > above ensures that any changes happen at a rate that gives all\n> participants\n> > time to react. The process also gives a mechanism for the community\n> to vote to\n> > decrease the limit if it turns out that the new one was in fact too\n> high. (note\n> > how the way the status quo is set ensures the default action is for\n> the limit\n> > to gradually decrease even if everyone stops voting)\n>\n> > As many of you know I have been quite vocal that the 1MB limit\n> should stay. But\n> > I would be happy to support the outcome of a vote done properly,\n> whatever that\n> > outcome may be.\n>\n> >\n> ------------------------------------------------------------------------------\n> > How ServiceNow helps IT people transform IT departments:\n> > 1. A cloud service to automate IT design, transition and operations\n> > 2. Dashboards that offer high-level views of enterprise services\n> > 3. A single system of record for all IT processes\n> > http://p.sf.net/sfu/servicenow-d2d-j\n> > _______________________________________________\n> > Bitcoin-development mailing list\n> > Bitcoin-development at lists.sourceforge.net\n> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> > .\n>\n>\n>\n>\n>\n>\n------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130610/6c87044b/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2013-06-10T17:43:06",
                "message_text_only": "On Mon, Jun 10, 2013 at 01:25:05PM -0400, Alan Reiner wrote:\n> to sign votes.  Not only that, but it would require them to reveal their\n> public key, which while isn't technically so terrible, large amounts of\n> money intended to be kept in storage for 10+ years will prefer to avoid\n> any exposure at all, in the oft-chance that QCs come around a lot\n> earlier than we expected.  Sure, the actual risk should be pretty much\n> non-existent, but some of the most paranoid folks are probably the same\n> ones who have a lot of funds and want 100.00% of the security that is\n> possible.   They will see this as wildly inconvenient.\n\nSolving that problem is pretty easy actually: just add a voting only\npublic key to your outputs. Specifically you would have an opcode called\nsomething like \"OP_VOTE\" and put a code-path in your script that only\nexecutes for that specific key.\n\nIt'd work best if we implement merklized abstract syntax trees to allow\nyou to reveal only the part of a script that is actually executed rather\nthan the whole script, a feature useful for a lot of other things.\n\n\nIncidentally remember that we can implement as many new opcodes as we\nwant with a soft-fork by redefining one of the OP_NOP's to be a\nOP_VERSION opcode that returns false for a given version:\n\n    version OP_VERSION OP_IFNOT {new opcodes} OP_ENDIF\n\nNodes with the existing codebase will think the script always succeeds,\nbecause the IFNOT branch isn't taken, leaving the non-false version on\nthe stack, while new nodes will take that branch.\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000109243df1322b7b5173c5796cf979318e933d887210c981c1f8\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130610/0edca47a/attachment.sig>"
            },
            {
                "author": "John Dillon",
                "date": "2013-06-15T18:28:23",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nOn Mon, Jun 10, 2013 at 5:43 PM, Peter Todd <pete at petertodd.org> wrote:\n> On Mon, Jun 10, 2013 at 01:25:05PM -0400, Alan Reiner wrote:\n>> to sign votes.  Not only that, but it would require them to reveal their\n>> public key, which while isn't technically so terrible, large amounts of\n>> money intended to be kept in storage for 10+ years will prefer to avoid\n>> any exposure at all, in the oft-chance that QCs come around a lot\n>> earlier than we expected.  Sure, the actual risk should be pretty much\n>> non-existent, but some of the most paranoid folks are probably the same\n>> ones who have a lot of funds and want 100.00% of the security that is\n>> possible.   They will see this as wildly inconvenient.\n>\n> Solving that problem is pretty easy actually: just add a voting only\n> public key to your outputs. Specifically you would have an opcode called\n> something like \"OP_VOTE\" and put a code-path in your script that only\n> executes for that specific key.\n\nRather than \"OP_VOTE\" all you really need is the \"spending tx matches a\ntemplate\" functionality that has been proposed for many other things.\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\n\niQEcBAEBCAAGBQJRvLIoAAoJEEWCsU4mNhiPdtoIAKOeEwtWXw6fNKbSN0miGmcQ\nrHxgoEh5EAPsbs0hkCRpsVF7OjvmAftOn0Z0K0X/a4UFVHI64bvvGUg0brmAMnh3\nha4Mu/o7UwxwVJmmd6vpUw4smjbQrKbRzheXXQKUsDG2HOmRzMabFjJG1F20mPdg\nRobwYG49fKLcjAfqqTjOwSQE5KBjrugAUo32OUJWHZyNR5E3JYUXRHseHCfQ+1Fd\nVOQ8rWA4OaqwiX7PXdrNMWXc7Ab1dK7j9U7n4FgzCGIJjAek2dGbYLdrjftGKI+z\nVje7o/RCJFLkJW5cC/wDoB/58XyJuvsvGOBAjvz01UrengUiapkhLRjKQwbveEo=\n=P0Hm\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2013-06-22T12:05:41",
                "message_text_only": "On 10 June 2013 06:09, John Dillon <john.dillon892 at googlemail.com> wrote:\n\n> -----BEGIN PGP SIGNED MESSAGE-----\n> Hash: SHA256\n>\n> It has been suggested that we leave the decision of what the blocksize to\n> be\n> entirely up to miners. However this leaves a parameter that affects every\n> Bitcoin participant in the control of a small minority. Of course we can\n> not\n> force miners to increase the blocksize if they choose to decrease it,\n> because\n> the contents of the blocks they make are their decision and their decision\n> only. However proposals to leave the maximum size unlimited to allow\n> miners to\n> force us to accept arbitrarily large blocks even if the will of the\n> majority of\n> Bitcoin participants is that they wish to remain able to validate the\n> blockchain.\n>\n> What we need is a way to balance this asymetrical power relationship.\n>\n> Proof-of-stake voting gives us a way of achieving that balance.\n> Essentially for\n> a miner to prove that the majority will of the poeple is to accept a larger\n> blocksize they must prove that the majority has in fact voted for that\n> increase. The upper limit on the blocksize is then determined by the\n> median of\n> all votes, where each txout in the UTXO set is one vote, weighted by txout\n> value. A txout without a corresponding vote is considered to be a vote for\n> the\n> status quo. To allow the voting process to continue even if coins are\n> \"lost\"\n> votes, including default votes, are weighted inversely according to their\n> age\n> in years after 1 year. IE a vote with weight 1BTC that is 1.5 years old\n> will be\n> recorded the same as a <1 year old vote weighted as 0.67BTC, and a 1 day\n> old\n> and 6 months old UTXO are treated equivalently. The 1 year minimum is\n> simply to\n> make voting required no more than once per year. (of course, a real\n> implementation should do all of these figures by block height, IE after\n> 52,560\n> blocks instead of after 1 year)\n>\n> A vote will consist of a txout with a scriptPubKey of the following form:\n>\n>     OP_RETURN magic vote_id txid vout vote scriptSig\n>\n> Where scriptSig is a valid signature for a transaction with nLockTime\n> 500,000,000-1 spending txid:vout to scriptPubKey:\n>\n>     OP_HASH160 H(OP_RETURN magic vote_id txid vout vote) OP_EQUAL\n>\n> vote_id is the ID of the specific vote being made, and magic is included to\n> allow UTXO proof implementations a as yet unspecified way of identifying\n> votes\n> and including the weighted median as part of the UTXO tree sums. (it also\n> allows SPV clients to verify the vote if the UTXO set is a Patricia tree of\n> scriptPubKeys) vote is just the numerical vote itself. The vote must\n> compute\n> the median, rather than the mean, so as to not allow someone to skew the\n> vote\n> by simply setting their value extremely high. Someone who still remembers\n> their\n> statistics classes should chime in on the right way to compute a median in\n> a\n> merkle-sum-tree.\n>\n> The slightly unusual construction of votes makes implementation by wallet\n> software as simple as possible within existing code-paths. Votes could\n> still be\n> constructed even in wallets lacking specific voting capability provided the\n> wallet software does have the ability to set nLockTime.\n>\n> Of course in the future the voting mechanism can be used for additional\n> votes\n> with an additional vote_id. For instance the Bitcoin community could vote\n> to\n> increase the inflation subsidy, another example of a situation where the\n> wishes\n> of miners may conflict with the wishes of the broader community.\n>\n> Users may of course actually create these specially encoded txouts\n> themselves\n> and get them into the blockchain.  However doing so is not needed as a\n> given\n> vote is only required to actually be in the chain by a miner wishing to\n> increase the blocksize. Thus we should extend the P2P protocol with a\n> mechanism\n> by which votes can be broadcast independently of transactions. To prevent\n> DoS\n> attacks only votes with known vote_id's will be accepted, and only for\n> txid:vout's already in the blockchain, and a record of txouts for whom\n> votes\n> have already broadcast will be kept. (this record need not be\n> authoritative as\n> its purpose is only to prevent DoS attacks) Miners wishing to increase the\n> blocksize can record these votes and include them in the blocks they mine\n> as\n> required. To reduce the cost of including votes in blocks 5% of every block\n> should be assigned to voting only. (this can be implemented by a soft-fork)\n>\n> For any given block actual limit in effect is then the rolling median of\n> the\n> blocks in the last year. At the beginning of every year the value\n> considered to\n> be the status quo resets to the mean of the limit at the beginning and end\n> of\n> the interval.  (again, by \"year\" we really mean 52,560 blocks) The rolling\n> median and periodic reset process ensures that the limit changes gradually\n> and\n> is not influenced by temporary events such as hacks to large exchanges or\n> malicious wallet software.  The rolling median also ensures that for a\n> miner\n> the act of including a vote is never wasted due to the txout later being\n> spent.\n>\n> Implementing the voting system can happen prior to an actual hard-fork\n> allowing\n> for an increase and can be an important part of determining if the\n> hard-fork is\n> required at all.\n>\n> Coercion and vote buying is of course possible in this system. A miner\n> could\n> say that they will only accept transactions accompanied by a vote for a\n> given\n> limit. However in a decentralized system completely preventing vote buying\n> is\n> of course impossble, and the design of Bitcoin itself has a fundemental\n> assumption that a majority of miners will behave in a specific kind of\n> \"honest\"\n> way.\n>\n> A voting process ensures that any increase to the blocksize genuinely\n> represents the desires of the Bitcoin community, and the process described\n> above ensures that any changes happen at a rate that gives all participants\n> time to react. The process also gives a mechanism for the community to\n> vote to\n> decrease the limit if it turns out that the new one was in fact too high.\n> (note\n> how the way the status quo is set ensures the default action is for the\n> limit\n> to gradually decrease even if everyone stops voting)\n>\n> As many of you know I have been quite vocal that the 1MB limit should\n> stay. But\n> I would be happy to support the outcome of a vote done properly, whatever\n> that\n> outcome may be.\n>\n\nThinking about this a little more, I guess it does not hurt to build some\nkind of voting system into the clients.  But I think it's more useful for\nstraw polls.  For example a bug fix 100% of people should agree on.  A\nprotocol optimization perhaps 80% would agree on.  A protocol change that\nredistributes wealth or incentives perhaps only 60% will agree on.\n\nAt this point in time it's far too easy to deliver contentious changes into\nthe hands of the general population.  I think that fortunately we're\nblessed with a very strong dev team, but the fundamental philosophy of\nbitcoin is to not put too much trust in single point, but rather, to\ndistribute and diversify trust to the edges.\n\n\n\n> -----BEGIN PGP SIGNATURE-----\n> Version: GnuPG v1.4.11 (GNU/Linux)\n>\n> iQEcBAEBCAAGBQJRtVFBAAoJEEWCsU4mNhiP6EAIAMjq4UgXxmEjOgHWf0KcmwmH\n> Ra/I3oY7krvg/lu1YCa+ACMBdoca9WODySUIe7R3niphKXEnknHGUIf8tm/Vrq4H\n> gPF4cgYEr18EYTVtvT9J1pZUB4f5dxkXXNpcQ60juaz9KervFQMOGnpr6Fyxi3dS\n> ghObNYcr3D2v1fjx56sp7BCNn0XHxTb1ZLUJB0BZhDKlamfgcxruKMbpsZmACJUj\n> gTNLNweaAomBIH++j7cnXeB0jZc/1ilv8qLA/f3TGb43FDkAQcvvSjGijI+OJOm6\n> Fh/WRBav1BJiV6PKs9xuHXsaxZ/T7Fb8Wg8EynSi0mSj47QXdKZgeZCi3XlSyxM=\n> =aKBD\n> -----END PGP SIGNATURE-----\n>\n>\n> ------------------------------------------------------------------------------\n> How ServiceNow helps IT people transform IT departments:\n> 1. A cloud service to automate IT design, transition and operations\n> 2. Dashboards that offer high-level views of enterprise services\n> 3. A single system of record for all IT processes\n> http://p.sf.net/sfu/servicenow-d2d-j\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130622/230318e0/attachment.html>"
            },
            {
                "author": "John Dillon",
                "date": "2013-06-28T10:25:28",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\n> Thinking about this a little more, I guess it does not hurt to build some\n> kind of voting system into the clients.  But I think it's more useful for\n> straw polls.  For example a bug fix 100% of people should agree on.  A\n> protocol optimization perhaps 80% would agree on.  A protocol change that\n> redistributes wealth or incentives perhaps only 60% will agree on.\n>\n> At this point in time it's far too easy to deliver contentious changes into\n> the hands of the general population.  I think that fortunately we're blessed\n> with a very strong dev team, but the fundamental philosophy of bitcoin is to\n> not put too much trust in single point, but rather, to distribute and\n> diversify trust to the edges.\n\nI disagree entirely. Your example of \"straw polls\" for bug fixes and\nfeatures is precisely what the current method of rough consensus and\nrunning code, an IETF expression, handles just fine.\n\nWhat the method does not handle effectively are issues that are\nfundementally political rather than technical in nature. Blocksize is\nprecisely the latter because while the tradeoffs are technical in\nnature the fundemental issue at hand is what do we want Bitcoin to be?\nWho are we going to allow to participate?\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\n\niQEcBAEBCAAGBQJRzWR7AAoJEEWCsU4mNhiPEYsIAME+VvS4vfE0PdOMv3vHWGSH\nHwUJdtKPold4+p0jhPBKSMbgnpMvXsZezMIIxj8xehnblnVuUdyakibXAdgVNLvp\na6SCw+W/VnopYCw151zZ4FQS92KQuSbX+XmYTQy32oqZIXtBmTE1fydw5q6YhoXb\ngCCygPRyLTIQxLZAxqqRrQ0nsSE5ID5kDcr+xRsmCvfIKrzoOCbYL+nXPCB4Zzgu\nGs7Lfa0yfTrUlQmoDseyoWrVuhfYuFNesTAs3z6imMTdHqZh8Z+a+gmC+G9qFO1h\ny7hOmzW4oz7hH4R2F6M+UpV6rKdwMaNYwrDw5eHClDgGYNfjjVduQ/YMQnbjyAc=\n=5mhd\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "John Dillon",
                "date": "2013-06-10T04:59:45",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nOn Mon, Jun 10, 2013 at 4:44 AM, Edmund Broadley <rebroad at gmail.com> wrote:\n> I really like this idea. I also like that users with no clue will leave\n> their vote to the default chosen by the software developers, which hopefully\n> will be 1MB. I like how coin age is factored in do votes are hopefully\n> proportional to bitcoin assert ownership.\n\nThe default should *not* be set by wallets at all in fact. The default is that\nby not voting, you accept the status quo, which is defined as the mean of the\nold and new limits in the past year.\n\nSo lets say the limit is 1MB, and through voting it ends up at 2MB in one year.\nUntil that time by not voting you are in effect voting for the limit to be 1MB,\nbut after the next interval you not voting is equivalent to voting for a 1.5MB\nlimit. A subtle issue is then txout age, and at that point a 1.5 year old txout\nshould be like voting for the 1MB limit still, albeit weighted less. What you\ndon't want is your lack of vote to suddenly turn into a 1.5MB vote. This makes\nsure that at all levels the increases are gradual rather than abrupt, although\nthe rate of increase may still be quite fast if the community votes that way.\n(first derivative of the limit is a close approximation to a continuous\nfunction)\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\n\niQEcBAEBCAAGBQJRtV0iAAoJEEWCsU4mNhiPRDIH+wapKxD0fc2div9gkhxZ4qVt\n9Wh4u1vKM4RsxdPgh9uKFJomjErBXBROJ57cJqB1rwHt1xhUyHgbC8JstU0PWzUM\nYgwgibe9nsSjqHp2w15Bat+NmkYpxrjmVhf9woZkPQl+A1bWd3MFXOGoTIPPCl3I\nKkMTaR3VbZDwqg0DlteZMR2im2DkT4zDsCkSb8KSCoaeTEdafkPceVHWU6isWxV9\nY0TGFCKaoMjxqxnkgH+vHsJlIM4E3rb0NHTo8rHD7Hm1txw/4/fVwE56/9U+8FaK\nXAPXS0gkIR83V7cWMLa/q6LpZyzJmfFXCZhjT4YxVqeq/wB/SR9j2hhNdLnjuCo=\n=y1c+\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Proposal: Vote on the blocksize limit with proof-of-stake voting",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Daniel Lidstrom",
                "John Dillon",
                "Peter Todd",
                "Alan Reiner",
                "Mark Friedenbach",
                "Melvin Carvalho",
                "Pieter Wuille"
            ],
            "messages_count": 15,
            "total_messages_chars_count": 78132
        }
    },
    {
        "title": "[Bitcoin-development] Decentralizing mining",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2013-06-10T21:09:13",
                "message_text_only": "So here's the parts that need to be done for step #1:\n\n\n# Protocol Work\n\nBasic idea is the miner makes two connections, their pool, and a local\nbitcoind.\n\nThey always (usually?) work on the subset of transactions common to both\nthe pool's getblocktemplate and their local one. When they find a share\nif it doesn't meet difficulty they just hand it to the pool. Currently\nthat is done by handing the whole block over, correct? I know the BIP\nsays otherwise, but we should optimize this to just hand over tx hashes\nwhere possible.\n\nIf the share does meet difficulty, hand it to both the pool and the\nlocal bitcoind. Should hand it to the pool first though, because the\npool likely has the fastest block propagation, then hand it to local\nbitcoind. An optimized version may want to have some record of measured\nbandwidth - this applies Bitcoin in general too, although also has other\nissues.\n\n\n## Reducing bandwidth\n\nHow about for normal shares we just pass the block header, and have the\npool randomly pick a subset of transactions to audit? Any fraud cancels\nthe users shares. This will work best in conjunction with a UTXO proof\ntree to prove fees, or by just picking whole shares randomly to audit.\n\nWe'll need persistent share storage so if your connection disconnects\nyou can provide the pool with the full share later though.\n\nIncedentally, note how the miner can do the reverse: pick random block\nheaders and challenge the pool to prove that they correspond to a valid\nblock. With some modifications Stratum can support this approach.\n\n\n## Delibrate orphaning of slow to propagate blocks\n\nBlock headers can be flooded-filled much faster than blocks themselves.\nThey are also small enough to fit into a UDP packet. Nodes should pass\nheaders around separately via UDP, optinally with some tiny number of\ntransactions. When we see a valid block header whose contents we do not\nknow about a miner should switch to mining empty or near empty blocks in\nsolo mode that would orphan the still propagating block. Doing this is\nsafe, we'll never build on an invalid block, economically rational while\nthe inflation subsidy is still high, and helps reduce (although not\neliminate!) the advantage a large miner with high-bandwidth connections\nhas over those who don't.\n\nOf course, the other option is to build a block extending the one you\ndon't know about, which is even more rational, but doing poses major\nrisks to Bitcoin...\n\nThis functionality can be implemented later - it's not strictly part of\npooled-solo mode.\n\n\n# Pool work\n\nSo does eliopool already accept arbitrary shares like this and do the\ncorrect accounting already? (IE adjust share amount based on fees?) What\nhappens when the pool doesn't get the share directly, but does see the\nnew block?\n\n+ possible protocol extensions\n\n\n# Miner work\n\nBasically we need code to merge the two block templates together to find\ncommonality. I guess you probably want to implement this in bfgminer\nfirst, so add the code to libblkmaker first, then maybe python-blkmaker.\n\nWe also want an automatic fallback to local solo mining if the pool\ncan't be contacted.\n\n+ possible protocol extensions\n\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000005576673e616271f762a5d8779d5fe7796c6e43ed43df5aa189\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130610/ee10beed/attachment.sig>"
            },
            {
                "author": "Luke-Jr",
                "date": "2013-06-10T21:23:14",
                "message_text_only": "On Monday, June 10, 2013 9:09:13 PM Peter Todd wrote:\n> # Protocol Work\n\nThis is basically done.\n\n> Basic idea is the miner makes two connections, their pool, and a local\n> bitcoind.\n> \n> They always (usually?) work on the subset of transactions common to both\n> the pool's getblocktemplate and their local one. When they find a share\n> if it doesn't meet difficulty they just hand it to the pool. Currently\n> that is done by handing the whole block over, correct? I know the BIP\n> says otherwise, but we should optimize this to just hand over tx hashes\n> where possible.\n\nThe plan was to tell the pool it doesn't need to send transactions at all, and \nonly work on the ones from bitcoind. Currently, share submissions are just the \nblock header and coinbase transaction; in this case, however, the miner will \nneed to send merkle links also, possibly just once via a block proposal in \nadvance.\n\n> If the share does meet difficulty, hand it to both the pool and the\n> local bitcoind. Should hand it to the pool first though, because the\n> pool likely has the fastest block propagation, then hand it to local\n> bitcoind. An optimized version may want to have some record of measured\n> bandwidth - this applies Bitcoin in general too, although also has other\n> issues.\n\nCurrently, BFGMiner is doing submission to the pool, waiting for a response, \nthen submitting to a local bitcoind. This is because the pool might need to \nreceive/record the share before it processes the block on bitcoind, or you \ncould lose credit for it. The response from the pool is rather small (a single \nTCP packet), so this shouldn't delay much longer.\n\n> ## Reducing bandwidth\n> \n> How about for normal shares we just pass the block header, and have the\n> pool randomly pick a subset of transactions to audit? Any fraud cancels\n> the users shares. This will work best in conjunction with a UTXO proof\n> tree to prove fees, or by just picking whole shares randomly to audit.\n\nMight as well just use higher difficulty shares (each one audited) for the \nsame effect. Block proposals allow the miner to tell the pool its transaction \nset once (per txset change) for any number of shares.\n\nIF bandwidth becomes a real problem, I have a draft of a \"GBT 2.0\" that does \nsome more improvement in this area.\n\n> # Pool work\n> \n> So does eliopool already accept arbitrary shares like this and do the\n> correct accounting already? (IE adjust share amount based on fees?) What\n> happens when the pool doesn't get the share directly, but does see the\n> new block?\n> \n> + possible protocol extensions\n\nI don't follow.\n\n> # Miner work\n> \n> Basically we need code to merge the two block templates together to find\n> commonality. I guess you probably want to implement this in bfgminer\n> first, so add the code to libblkmaker first, then maybe python-blkmaker.\n\nlibblkmaker's API was designed for this from the start, so it should be fairly \neasily implemented.\n\n> We also want an automatic fallback to local solo mining if the pool\n> can't be contacted.\n> \n> + possible protocol extensions\n\nFailover already functions, but probably could use a rewrite...\n\nLuke"
            },
            {
                "author": "Peter Todd",
                "date": "2013-06-14T20:06:54",
                "message_text_only": "On Mon, Jun 10, 2013 at 09:23:14PM +0000, Luke-Jr wrote:\n> > They always (usually?) work on the subset of transactions common to both\n> > the pool's getblocktemplate and their local one. When they find a share\n> > if it doesn't meet difficulty they just hand it to the pool. Currently\n> > that is done by handing the whole block over, correct? I know the BIP\n> > says otherwise, but we should optimize this to just hand over tx hashes\n> > where possible.\n> \n> The plan was to tell the pool it doesn't need to send transactions at all, and \n> only work on the ones from bitcoind. Currently, share submissions are just the \n> block header and coinbase transaction; in this case, however, the miner will \n> need to send merkle links also, possibly just once via a block proposal in \n> advance.\n\nIt strikes me that this would work best if the pool has a mempool with\nchild-pays-for-parent support where conflicts *are* allowed.\n\nIE you record whatever transactions you know about, conflicting or not,\ncalculate which ones gives you the most fees/kb, and then figure out\nwhich set of non-conflicting ones are optimal. Of course, \"optimal\" is\nthe knapsack problem...\n\nNow you can easilly tell the miners working on shares for you which tx's\nwould be optimal if they wish to know, and at the same time whatever\nshares they send you are most likely to include transactions in your\nmempool inventory, and thus they can send just tx hashes to reduce\nbandwidth.\n\n\nPart of the broader issue that when we send peers INV advertisements we\nshould be telling them what the fee/kb is so our peers can prioritize\nproperly. That'd also help for the case where you want to broadcast two\ntransactions in a row, but the pair is only profitable because the\nsecond is paying the fee for the first.\n\nSpeaking of, the way we tell peers about new blocks is really\nsuboptimal: we tell every peer, in no particular order, about a new\nblock via a block INV message, and then we give them the new block in\nparallel. I was looking through comp-sci papers on optimal\nflood-fill/gossip algorithms for random graph networks and it appears\nthat optimal is to spend all your bandwidth to send the message to your\nfastest peer first, followed by your next fastest and so on. This works\nbest because you get the exponential growth scaling faster by\npropagating the message as \"deep\" as possible in the network, and it\nthen can flood outwards from there. Just sorting the peer list by\n#inv-recevied/time when doing INV pushes and when attending to incoming\nmessages would probably be a big improvement.\n\n> > If the share does meet difficulty, hand it to both the pool and the\n> > local bitcoind. Should hand it to the pool first though, because the\n> > pool likely has the fastest block propagation, then hand it to local\n> > bitcoind. An optimized version may want to have some record of measured\n> > bandwidth - this applies Bitcoin in general too, although also has other\n> > issues.\n> \n> Currently, BFGMiner is doing submission to the pool, waiting for a response, \n> then submitting to a local bitcoind. This is because the pool might need to \n> receive/record the share before it processes the block on bitcoind, or you \n> could lose credit for it. The response from the pool is rather small (a single \n> TCP packet), so this shouldn't delay much longer.\n\nRight, I guess the pool wants to be sure you were actually the one who\nfound the share, rather than just someone who was lucky enough to see it\non the network and submitted it as your own.\n\n> > ## Reducing bandwidth\n> > \n> > How about for normal shares we just pass the block header, and have the\n> > pool randomly pick a subset of transactions to audit? Any fraud cancels\n> > the users shares. This will work best in conjunction with a UTXO proof\n> > tree to prove fees, or by just picking whole shares randomly to audit.\n> \n> Might as well just use higher difficulty shares (each one audited) for the \n> same effect. Block proposals allow the miner to tell the pool its transaction \n> set once (per txset change) for any number of shares.\n\nThat's a good point - the current practice most pools seem to follow of\nabout a share per second seems very excessive to me. On the other hand,\nit does have good user optics. The right solution might be something\nakin to P2Pool where the UI level is telling the user shares are being\nfound so it's clear \"stuff is happening\", but under the hood only a\nsmall subset are ever sent to the pool.\n\n> > # Pool work\n> > \n> > So does eliopool already accept arbitrary shares like this and do the\n> > correct accounting already? (IE adjust share amount based on fees?) What\n> > happens when the pool doesn't get the share directly, but does see the\n> > new block?\n> > \n> > + possible protocol extensions\n> \n> I don't follow.\n\nWhat part don't you follow?\n\n> > # Miner work\n> > \n> > Basically we need code to merge the two block templates together to find\n> > commonality. I guess you probably want to implement this in bfgminer\n> > first, so add the code to libblkmaker first, then maybe python-blkmaker.\n> \n> libblkmaker's API was designed for this from the start, so it should be fairly \n> easily implemented.\n\nGood.\n\n> > We also want an automatic fallback to local solo mining if the pool\n> > can't be contacted.\n> > \n> > + possible protocol extensions\n> \n> Failover already functions, but probably could use a rewrite...\n\nSounds good.\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000006ed83d97e7266a66dcb057cd53750795bd209076fa0a34d4ec\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130614/e8f743c8/attachment.sig>"
            },
            {
                "author": "Luke-Jr",
                "date": "2013-06-14T21:05:28",
                "message_text_only": "On Friday, June 14, 2013 8:06:54 PM Peter Todd wrote:\n> On Mon, Jun 10, 2013 at 09:23:14PM +0000, Luke-Jr wrote:\n> > Might as well just use higher difficulty shares (each one audited) for\n> > the same effect. Block proposals allow the miner to tell the pool its\n> > transaction set once (per txset change) for any number of shares.\n> \n> That's a good point - the current practice most pools seem to follow of\n> about a share per second seems very excessive to me. On the other hand,\n> it does have good user optics. The right solution might be something\n> akin to P2Pool where the UI level is telling the user shares are being\n> found so it's clear \"stuff is happening\", but under the hood only a\n> small subset are ever sent to the pool.\n\nShare rate is relevant to more than user information - it also affects the \nvariance of reward/payout. I disagree with claiming shares are found when \nthey're not sent to the pool - this makes auditing and troubleshooting more \ndifficult; for example, see the GUIMiner bug where it reports shares despite \nmisinterpreting the pool's target and submitting nothing at all (this happens \nwhen the pool uses pdiff 1).\n\n> > > # Pool work\n> > > \n> > > So does eliopool already accept arbitrary shares like this and do the\n> > > correct accounting already? (IE adjust share amount based on fees?)\n> > > What happens when the pool doesn't get the share directly, but does\n> > > see the new block?\n> > > \n> > > + possible protocol extensions\n> > \n> > I don't follow.\n> \n> What part don't you follow?\n\nI don't understand the first two questions here at all.\n\nLuke"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-06-17T15:16:01",
                "message_text_only": "On Fri, Jun 14, 2013 at 4:06 PM, Peter Todd <pete at petertodd.org> wrote:\n> It strikes me that this would work best if the pool has a mempool with\n> child-pays-for-parent support where conflicts *are* allowed.\n>\n> IE you record whatever transactions you know about, conflicting or not,\n> calculate which ones gives you the most fees/kb, and then figure out\n> which set of non-conflicting ones are optimal. Of course, \"optimal\" is\n> the knapsack problem...\n>\n> Now you can easilly tell the miners working on shares for you which tx's\n> would be optimal if they wish to know, and at the same time whatever\n> shares they send you are most likely to include transactions in your\n> mempool inventory, and thus they can send just tx hashes to reduce\n> bandwidth.\n>\n>\n> Part of the broader issue that when we send peers INV advertisements we\n> should be telling them what the fee/kb is so our peers can prioritize\n> properly. That'd also help for the case where you want to broadcast two\n> transactions in a row, but the pair is only profitable because the\n> second is paying the fee for the first.\n\nInteresting proposals, particularly this last.  The net result impact\nis, however, that which was criticized in at least one forum thread:\nreplace-with-higher-fee.\n\n\n> Speaking of, the way we tell peers about new blocks is really\n> suboptimal: we tell every peer, in no particular order, about a new\n> block via a block INV message, and then we give them the new block in\n> parallel. I was looking through comp-sci papers on optimal\n> flood-fill/gossip algorithms for random graph networks and it appears\n> that optimal is to spend all your bandwidth to send the message to your\n> fastest peer first, followed by your next fastest and so on. This works\n> best because you get the exponential growth scaling faster by\n> propagating the message as \"deep\" as possible in the network, and it\n> then can flood outwards from there. Just sorting the peer list by\n> #inv-recevied/time when doing INV pushes and when attending to incoming\n> messages would probably be a big improvement.\n\nIn terms of packet size, I would like to look into the network-wide\ncosts of simply broadcasting block header + coinbase TX + TX list.  I\nbet miners would love to opt into that.\n\n\n>> > If the share does meet difficulty, hand it to both the pool and the\n>> > local bitcoind. Should hand it to the pool first though, because the\n>> > pool likely has the fastest block propagation, then hand it to local\n>> > bitcoind. An optimized version may want to have some record of measured\n>> > bandwidth - this applies Bitcoin in general too, although also has other\n>> > issues.\n>>\n>> Currently, BFGMiner is doing submission to the pool, waiting for a response,\n>> then submitting to a local bitcoind. This is because the pool might need to\n>> receive/record the share before it processes the block on bitcoind, or you\n>> could lose credit for it. The response from the pool is rather small (a single\n>> TCP packet), so this shouldn't delay much longer.\n>\n> Right, I guess the pool wants to be sure you were actually the one who\n> found the share, rather than just someone who was lucky enough to see it\n> on the network and submitted it as your own.\n>\n>> > ## Reducing bandwidth\n>> >\n>> > How about for normal shares we just pass the block header, and have the\n>> > pool randomly pick a subset of transactions to audit? Any fraud cancels\n>> > the users shares. This will work best in conjunction with a UTXO proof\n>> > tree to prove fees, or by just picking whole shares randomly to audit.\n>>\n>> Might as well just use higher difficulty shares (each one audited) for the\n>> same effect. Block proposals allow the miner to tell the pool its transaction\n>> set once (per txset change) for any number of shares.\n>\n> That's a good point - the current practice most pools seem to follow of\n> about a share per second seems very excessive to me. On the other hand,\n> it does have good user optics. The right solution might be something\n> akin to P2Pool where the UI level is telling the user shares are being\n> found so it's clear \"stuff is happening\", but under the hood only a\n> small subset are ever sent to the pool.\n\nWith the onslaught of ASIC mining, most big pools are past a share per\nsecond.  Variable difficulty or set-to-higher-difficulty quickly\nbecame the norm, almost out of necessity.\n\nPersonally, I think most pools should target at _least_ 5-10 seconds\nper share, no matter the strength of the miner.\n\n-- \nJeff Garzik\nSenior Software Engineer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Peter Todd",
                "date": "2013-06-17T17:39:42",
                "message_text_only": "On Mon, Jun 17, 2013 at 11:16:01AM -0400, Jeff Garzik wrote:\n> > Part of the broader issue that when we send peers INV advertisements we\n> > should be telling them what the fee/kb is so our peers can prioritize\n> > properly. That'd also help for the case where you want to broadcast two\n> > transactions in a row, but the pair is only profitable because the\n> > second is paying the fee for the first.\n> \n> Interesting proposals, particularly this last.  The net result impact\n> is, however, that which was criticized in at least one forum thread:\n> replace-with-higher-fee.\n\nActually the two are orthogonal: a low-priority no-fee tx might result\nbecause it was from a customer paying a merchant via the payment\nprotocol. The merchant can then respend that tx with a fee to cover\nboth, but with the current mempool arrangement if the no-fee tx load is\nhigh actually getting that first tx to propagate so the second can will\nbe difficult.\n\nA nice way to do this would be to accept tx's into your mempool\nindiscriminately but delay broadcasting INV messages until you find\nchild tx's that make the low-profit ones worth mining. When you do find\na child with a sufficiently high fee, send an INVGROUP message to notify\nyour peers of the new opportunity. Different nodes will have different\nideas of what priority TX deserves to be broadcast, but here provided\nthe group meets the threshold a peer will always find out.\n\n> > Speaking of, the way we tell peers about new blocks is really\n> > suboptimal: we tell every peer, in no particular order, about a new\n> > block via a block INV message, and then we give them the new block in\n> > parallel. I was looking through comp-sci papers on optimal\n> > flood-fill/gossip algorithms for random graph networks and it appears\n> > that optimal is to spend all your bandwidth to send the message to your\n> > fastest peer first, followed by your next fastest and so on. This works\n> > best because you get the exponential growth scaling faster by\n> > propagating the message as \"deep\" as possible in the network, and it\n> > then can flood outwards from there. Just sorting the peer list by\n> > #inv-recevied/time when doing INV pushes and when attending to incoming\n> > messages would probably be a big improvement.\n> \n> In terms of packet size, I would like to look into the network-wide\n> costs of simply broadcasting block header + coinbase TX + TX list.  I\n> bet miners would love to opt into that.\n\nWhether or not that is a improvement is a really complex question, even\nwithout taking failure into account. If you agressively prioritize peers\nthat are the most connected and keep your # of peers reasonably low you\ncan afford the memory to keep track of what tx's your peers already know\nabout so to save on round trips for TX hash's they don't have. On the\nother hand if you have a large number of peers and can't do that, or\nneed to cut down on bandwidth used up by the INV floods and have a\nprobabalistic scheme, you are risking more round-trip latency.\n\nNot to mention the nasty problem of how *relying* on TX hashes to keep\nyour bandwidth down means that anything disrupting that system suddenly\nhas a big impact on the network. I don't think we really understand all\nthe nuances of that - look at how few people realize that you need\nmultiples of average bandwidth to have sufficient emergency bandwidth\navailable to catch up in the event of a chain fork.\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000a1c290ce20953d864a4b9c603abc8a9c77a04429c89c5e9fac\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130617/a764a270/attachment.sig>"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2013-06-10T21:31:18",
                "message_text_only": "On 10 June 2013 23:09, Peter Todd <pete at petertodd.org> wrote:\n\n> So here's the parts that need to be done for step #1:\n>\n>\n> # Protocol Work\n>\n> Basic idea is the miner makes two connections, their pool, and a local\n> bitcoind.\n>\n> They always (usually?) work on the subset of transactions common to both\n> the pool's getblocktemplate and their local one. When they find a share\n> if it doesn't meet difficulty they just hand it to the pool. Currently\n> that is done by handing the whole block over, correct? I know the BIP\n> says otherwise, but we should optimize this to just hand over tx hashes\n> where possible.\n>\n> If the share does meet difficulty, hand it to both the pool and the\n> local bitcoind. Should hand it to the pool first though, because the\n> pool likely has the fastest block propagation, then hand it to local\n> bitcoind. An optimized version may want to have some record of measured\n> bandwidth - this applies Bitcoin in general too, although also has other\n> issues.\n>\n>\n> ## Reducing bandwidth\n>\n> How about for normal shares we just pass the block header, and have the\n> pool randomly pick a subset of transactions to audit? Any fraud cancels\n> the users shares. This will work best in conjunction with a UTXO proof\n> tree to prove fees, or by just picking whole shares randomly to audit.\n>\n> We'll need persistent share storage so if your connection disconnects\n> you can provide the pool with the full share later though.\n>\n> Incedentally, note how the miner can do the reverse: pick random block\n> headers and challenge the pool to prove that they correspond to a valid\n> block. With some modifications Stratum can support this approach.\n>\n>\n> ## Delibrate orphaning of slow to propagate blocks\n>\n> Block headers can be flooded-filled much faster than blocks themselves.\n> They are also small enough to fit into a UDP packet. Nodes should pass\n> headers around separately via UDP, optinally with some tiny number of\n> transactions. When we see a valid block header whose contents we do not\n> know about a miner should switch to mining empty or near empty blocks in\n> solo mode that would orphan the still propagating block. Doing this is\n> safe, we'll never build on an invalid block, economically rational while\n> the inflation subsidy is still high, and helps reduce (although not\n> eliminate!) the advantage a large miner with high-bandwidth connections\n> has over those who don't.\n>\n> Of course, the other option is to build a block extending the one you\n> don't know about, which is even more rational, but doing poses major\n> risks to Bitcoin...\n>\n> This functionality can be implemented later - it's not strictly part of\n> pooled-solo mode.\n>\n>\n> # Pool work\n>\n> So does eliopool already accept arbitrary shares like this and do the\n> correct accounting already? (IE adjust share amount based on fees?) What\n> happens when the pool doesn't get the share directly, but does see the\n> new block?\n>\n> + possible protocol extensions\n>\n>\n> # Miner work\n>\n> Basically we need code to merge the two block templates together to find\n> commonality. I guess you probably want to implement this in bfgminer\n> first, so add the code to libblkmaker first, then maybe python-blkmaker.\n>\n> We also want an automatic fallback to local solo mining if the pool\n> can't be contacted.\n>\n> + possible protocol extensions\n>\n\nSounds very promising.  Suspect it will need a fair amount of testing ...\n\n\n>\n>\n> --\n> 'peter'[:-1]@petertodd.org\n> 000000000000005576673e616271f762a5d8779d5fe7796c6e43ed43df5aa189\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130610/78f5d4ac/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Decentralizing mining",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Luke-Jr",
                "Peter Todd",
                "Melvin Carvalho"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 26456
        }
    },
    {
        "title": "[Bitcoin-development] Bitcoin addresses -- opaque or not",
        "thread_messages": [
            {
                "author": "Melvin Carvalho",
                "date": "2013-06-11T13:11:33",
                "message_text_only": "There was some confusion on IRC as to whether bitcoin addresses are opaque\nor not.\n\nhttps://en.bitcoin.it/wiki/Address\n\nFor the sake of argument let's say that opaque means that you can tell\nnothing about the address by examining the characters.\n\nMy understanding was that they are NOT opaque, and that if that has\nchanged, it will invalidate much at least some wiki page, for examples at\nleast some of the following would now be false:\n\n--------\n\"A Bitcoin address, or simply address, is an identifier of 27-34\nalphanumeric characters\" -- FALSE\n\n\"with the number 1 or 3\" -- FALSE\n\n\"you can send bitcoins to a person by sending bitcoins to one of their\naddresses\" -- FALSE\n\n\"Addresses are created simply by generating random numbers and then\nperforming mathematical operations to derive matching pairs of \"public\" and\n\"private\" keys\" -- FALSE\n\n\"The probability that a mistyped address is accepted as being valid is 1 in\n232, that is, approximately 1 in 4.29 billion\" -- FALSE\n\n\"If you would like to validate a Bitcoin address in an application, it is\nadvisable to use a method from this thread rather than to just check for\nstring length, allowed characters, or that the address starts with a 1 or\n3.\" -- FALSE\n\n\"For most properly-generated Bitcoin addresses, there is at least one\nsecret number known as a private key\" -- FALSE\n\n\"They consist of random digits and uppercase and lowercase letters, with\nthe exception that the uppercase letter \"O\", uppercase letter \"I\",\nlowercase letter \"l\", and the number \"0\" are never used to prevent visual\nambiguity\" -- FALSE\n\n\"Some Bitcoin addresses can be shorter than 34 characters (as few as 27)\"\n-- FALSE\n\n\"Several of the characters inside a Bitcoin address are used as a checksum\nso that typographical errors can be automatically found and rejected\" --\nFALSE\n\n\"The checksum also allows Bitcoin software to confirm that a 33-character\n(or shorter) address is in fact valid and isn't simply an address with a\nmissing character\" -- FALSE\n--------\n\nI also here that there is a LIKELY change from the base58 encoding ... when\nwas this established?\n\nThere's either been some bit changes to the fundamentals of bitcoin here or\nthere's been some misunderstandings.  It would be good to clear things up\nas to what exactly an address is now beleived to be, and reflect that in\nthe wiki.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130611/8d2e4750/attachment.html>"
            },
            {
                "author": "Wladimir",
                "date": "2013-06-11T13:44:39",
                "message_text_only": "On Tue, Jun 11, 2013 at 3:11 PM, Melvin Carvalho\n<melvincarvalho at gmail.com>wrote:\n\n> There was some confusion on IRC as to whether bitcoin addresses are opaque\n> or not.\n>\n> https://en.bitcoin.it/wiki/Address\n>\n> For the sake of argument let's say that opaque means that you can tell\n> nothing about the address by examining the characters.\n>\n> My understanding was that they are NOT opaque, and that if that has\n> changed, it will invalidate much at least some wiki page, for examples at\n> least some of the following would now be false:\n>\n\nHow do you define opaque? As far as humans are concerned the addresses are\nopaque. They don't tell anything about your country or location, your bank,\nyour name, they don't even form some kind of hierarchy.\n\n>From the viewpoint of the code you could argue they have a meaning \"address\ntype + hashed public key, base58 encoded\" thus are not fully opaque. But\nit's a long shot, as a hashed value is still very opaque.\n\n\n> I also here that there is a LIKELY change from the base58 encoding ...\n> when was this established?\n>\n\nNo, there have been no changes to base58. The encoding is still exactly the\nsame as when Satoshi coined it. Can you show an example of what you mean?\n\nWladimir\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130611/a763d832/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2013-06-11T14:12:52",
                "message_text_only": "On Tue, Jun 11, 2013 at 3:11 PM, Melvin Carvalho\n<melvincarvalho at gmail.com> wrote:\n> There was some confusion on IRC as to whether bitcoin addresses are opaque\n> or not.\n>\n> https://en.bitcoin.it/wiki/Address\n>\n> For the sake of argument let's say that opaque means that you can tell\n> nothing about the address by examining the characters.\n>\n> My understanding was that they are NOT opaque, and that if that has changed,\n> it will invalidate much at least some wiki page, for examples at least some\n> of the following would now be false:\n\nI'm afraid this is the result of a misunderstanding.\n\nYesterday on IRC you were asking why the URI specification doesn't\ninclude the semantics and encoding of addresses. Some people,\nincluding me, argued that addresses should be considered opaque. That\ndoesn't mean they don't have well-specified definition, only that for\nthe purposes of URI parsing and handling, code shouldn't know or care\nwhat they represent or how they are formatted. Addresses are specified\nin one place, and the URI format simply passes addresses through.\n\nThe reason for keeping them independent is that the address format\ncould change (say, a new type is added, like P2SH (BIP13) before), and\nthere is no reason why this should break or even concern URI handling\ncode. Clearly, anything that actually interprets addresses in order to\nconstruct transactions will need changing. It's just two separate\nconcerns, and they should be dealt with separately.\n\n-- \nPieter"
            },
            {
                "author": "Luke-Jr",
                "date": "2013-06-11T15:29:11",
                "message_text_only": "On Tuesday, June 11, 2013 1:11:33 PM Melvin Carvalho wrote:\n> For the sake of argument let's say that opaque means that you can tell\n> nothing about the address by examining the characters.\n\nThis is true or false based on CONTEXT.\n\nObviously, an implementation of transaction handling (eg, wallets) needs to be \nable to translate addresses to and from what they represent.\n\nOn the other hand, things like URI handlers do not (and should not) try to \ninterpret the address as anything other than an arbitrary word (\\w+).\n\n> My understanding was that they are NOT opaque, and that if that has\n> changed, it will invalidate much at least some wiki page, for examples at\n> least some of the following would now be false:\n\nThe wiki goes into much detail on how addresses work, which is not the concern \nof most software in the Bitcoin ecosystem, but may be of interest to humans \nand developers working on the one component that operates the \"black box\" that \naddresses are.\n\n> --------\n> <snip>\n> --------\n\nThese aren't FALSE, they are \"true at the moment, but subject to revision by \nnewer standards\".\n\n> I also here that there is a LIKELY change from the base58 encoding ... when\n> was this established?\n\nI stated (on IRC) that it was likely Bitcoin would change from the base58 \nencoding for addresses ... at some unspecified time in the future, to some \nunspecified new encoding that addressed known limitations of base58. What \nthose changes will be, or when, are not all established at this time. The only \ncurrently-planned change to addresses (very loosely defined) is inclusion of \nthe Payment Protocol URIs. But the point is that software developers shouldn't \nassume that addresses will remain base58 forever.\n\nLuke"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2013-06-15T09:50:30",
                "message_text_only": "On 11 June 2013 17:29, Luke-Jr <luke at dashjr.org> wrote:\n\n> On Tuesday, June 11, 2013 1:11:33 PM Melvin Carvalho wrote:\n> > For the sake of argument let's say that opaque means that you can tell\n> > nothing about the address by examining the characters.\n>\n> This is true or false based on CONTEXT.\n>\n> Obviously, an implementation of transaction handling (eg, wallets) needs\n> to be\n> able to translate addresses to and from what they represent.\n>\n> On the other hand, things like URI handlers do not (and should not) try to\n> interpret the address as anything other than an arbitrary word (\\w+).\n>\n\nI think this statement may need to be justified.\n\n\n>\n> > My understanding was that they are NOT opaque, and that if that has\n> > changed, it will invalidate much at least some wiki page, for examples at\n> > least some of the following would now be false:\n>\n> The wiki goes into much detail on how addresses work, which is not the\n> concern\n> of most software in the Bitcoin ecosystem, but may be of interest to humans\n> and developers working on the one component that operates the \"black box\"\n> that\n> addresses are.\n>\n> > --------\n> > <snip>\n> > --------\n>\n> These aren't FALSE, they are \"true at the moment, but subject to revision\n> by\n> newer standards\".\n>\n\nGot it.\n\n\n>\n> > I also here that there is a LIKELY change from the base58 encoding ...\n> when\n> > was this established?\n>\n> I stated (on IRC) that it was likely Bitcoin would change from the base58\n> encoding for addresses ... at some unspecified time in the future, to some\n> unspecified new encoding that addressed known limitations of base58. What\n> those changes will be, or when, are not all established at this time. The\n> only\n> currently-planned change to addresses (very loosely defined) is inclusion\n> of\n> the Payment Protocol URIs. But the point is that software developers\n> shouldn't\n> assume that addresses will remain base58 forever.\n>\n\nDoes this mean that people should not be investing in \"vanity addresses\"?\n\n\n>\n> Luke\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130615/7197e065/attachment.html>"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2013-06-22T11:48:08",
                "message_text_only": "On 11 June 2013 17:29, Luke-Jr <luke at dashjr.org> wrote:\n\n> On Tuesday, June 11, 2013 1:11:33 PM Melvin Carvalho wrote:\n> > For the sake of argument let's say that opaque means that you can tell\n> > nothing about the address by examining the characters.\n>\n> This is true or false based on CONTEXT.\n>\n> Obviously, an implementation of transaction handling (eg, wallets) needs\n> to be\n> able to translate addresses to and from what they represent.\n>\n> On the other hand, things like URI handlers do not (and should not) try to\n> interpret the address as anything other than an arbitrary word (\\w+).\n>\n\nLuke, if you think that the sole purpose of a URI scheme is to be used as a\nURI handler, I think you've not fully understood the concept.  URIs are the\nglobal variable of the internet, and as such the need to play nicely with\nall other URI schemes on the net.  They need to be able to be linked to, to\nbe defined and documented.  This is important for bitcoin to get right\nbecause bitcoin: needs to treated in a special way on the internet, I just\nsaw today that it was treated by some software as a relative URL, which is\ngoing to break a ton of stuff.\n\n\n>\n> > My understanding was that they are NOT opaque, and that if that has\n> > changed, it will invalidate much at least some wiki page, for examples at\n> > least some of the following would now be false:\n>\n> The wiki goes into much detail on how addresses work, which is not the\n> concern\n> of most software in the Bitcoin ecosystem, but may be of interest to humans\n> and developers working on the one component that operates the \"black box\"\n> that\n> addresses are.\n>\n> > --------\n> > <snip>\n> > --------\n>\n> These aren't FALSE, they are \"true at the moment, but subject to revision\n> by\n> newer standards\".\n>\n> > I also here that there is a LIKELY change from the base58 encoding ...\n> when\n> > was this established?\n>\n> I stated (on IRC) that it was likely Bitcoin would change from the base58\n> encoding for addresses ... at some unspecified time in the future, to some\n> unspecified new encoding that addressed known limitations of base58. What\n> those changes will be, or when, are not all established at this time. The\n> only\n> currently-planned change to addresses (very loosely defined) is inclusion\n> of\n> the Payment Protocol URIs. But the point is that software developers\n> shouldn't\n> assume that addresses will remain base58 forever.\n>\n\nI am opposed to address changes in general, until he wider implications are\nfully understood.\n\n\n>\n> Luke\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130622/d05ef409/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin addresses -- opaque or not",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Melvin Carvalho",
                "Luke-Jr",
                "Pieter Wuille",
                "Wladimir"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 12003
        }
    },
    {
        "title": "[Bitcoin-development] Fwd: The \"pay it forward approach\" to crypto currencies",
        "thread_messages": [
            {
                "author": "Melvin Carvalho",
                "date": "2013-06-12T17:46:13",
                "message_text_only": "FYI: some musings on how crypto currencies might be combined with social\ngood ...\n\n---------- Forwarded message ----------\nFrom: Melvin Carvalho <melvincarvalho at gmail.com>\nDate: 12 June 2013 19:39\nSubject: The \"pay it forward approach\" to crypto currencies\nTo: building-a-distributed-decentralized-internet at googlegroups.com\n\n\nCrypto currencies are doing quite well, but they have yet to make a\nmeaningful impact on any economy, nor have they achieved much in the way of\nsocial good, however there is a tangible excitement about ways that it can\nmodernize the way we live our lives\n\nWe live in a world where 10,000 children under the age of five die every\nday, which can be prevented by simple, affordable interventions ... why do\nwe let this happen?\n\nTurning he question on its head, what interventions do crypto currencies\nenable us to perform, that could help solve this problem\n\nWell certainly crypto currencies have opened pandora's box in terms of\ntechnology being able to create money, let it float, and let it appreciate\nin value ... something that the alchemists of old (whose number include\nAristotle, Newton and Keynes) would have been proud.  Well done Satoshi,\nnow what shall we do with this gift?\n\nThe optimal principle should be that we beam new money to the people that\nneed it most, on a relatively uniform basis.  Something of a harder\nproblem, and one with no perfect solution.  But we could make some\napproximations ... perhaps.\n\n**\nSuppose you were to credit 10,000 new coins to every person on the planet.\nThen let it float on the free market (a la bitcoin).  Initially worth zero,\nthe coins would potentially rise in value to become a consensus driven\nglobal dividend.  Certainly if it went higher it could do a lot to\nalleviate many problems for poorer people.\n\nUnfortunately we dont have a huge database of every person on the planet in\nthe public domain, so this strategy is problematic.  However we roughly do\nhave good statistics that most people have a mobile phone, so we could beam\ncoins to every mobile phone.  (technically you can do this using the tel:\nURI scheme such that you get one phone, one share).\n\nPhones are now banks, and also have the ability to send money via SMS.\n\nThe problem with this approach is that it favours people with multiple\nphones, who are probably correlated to relatively wealthy people.  Not\ngreat, but it's a start.\n\nHow about we then do it country by country and beam coins to the poorest\ncountries, say in proportion to GNP per capita.  Perhaps better.\n\nAgain, it's possible to systematically game the system, to an extent.  So\none way to reduce the risk would be to allocate coins on a lottery basis,\nwhere a random number generator selects 'lucky' winners.  The net effect\nwill be generally positive, while preventing major systemic risk.\n\nLittle by little, we can bring people out of poverty using crypto coins and\nmake a better world.\n\nNow, I know what you're thinking.  Money for nothing, that makes no sense.\nWhy would these coins ever be worth anything.\n\nThere is where the \"pay it forward\" concept comes in.  All coin recipients\nare encouraged to \"pay it forward\" ... do good for the sake of good, and\nallow that karma to flow back to you.  Eventually this can take the form of\nrebuying the coins that saved your life when you were young, and enabled\nyou to become a successful businessman.\n\nAs the value, liquidity, trust, and importantly, social good of the system\nbuild.  So it becomes easier for people to maintain societies, for\neconomies to thrive, and for governments to balance their budgets.\n\nIt becomes an ever increasing virtuous circle, that can transform the\nplanet.\n\nI've left out a few gaps and technical details, but I'm sure it's possible\nto join the dots and incrementally move towards an optimal solution.  I\nthink bitcoin and the internet have paved the way for \"pay it forward\"\ncrypto currencies.\n\nAnd hopefully it can one day become \"an idea worth spending\".  :)\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130612/b5b76c0c/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Fwd: The \"pay it forward approach\" to crypto currencies",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Melvin Carvalho"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 4145
        }
    },
    {
        "title": "[Bitcoin-development] is there a way to do bitcoin-staging?",
        "thread_messages": [
            {
                "author": "Adam Back",
                "date": "2013-06-13T13:39:32",
                "message_text_only": "I had one thought towards this which is a different kind of merged mining.\n\nI think a \"fair\" merged mining aiming for price parity would be done by the\nminer having to choose the altcoin or btc at mine time, and altcoin chain\nconsidering btc mine unspendable and bitcoin considering ac unspendable.\n\nIn terms of validation which miners are currently doing to help SVP clients,\nit implies verification of both chains.  Or more incrementally each mine\nshould indicate in its serialization which chain it has validated.  This wa\nabout a hypothethical pure zerocoin altcoin hence zc/zerocoin:\n\nMaybe we can say that a mergemine does not count as a validation of the\nnetwork for the respective network unless there is serialization in the\ncoinbase indicating that the network is validated.  In that way you could\nhave zerocoin mined and zerocoin validated, zero mined and bitcoin validated\n(strange but possible), zerocoin mined and both zero and bit coin validated,\nand also the same for bitcoin mined and zerocoin validated (strange but\npossible), bitcoin mined and bitcoin validated (normal bitcoin ignoring\nzerocoin) and bitcoin mined and bitcoin and zerocoin validated.  Then the\nvalidation events on zerocoin network might not be as frequent.  Maybe\nminers will tend to validate both networks as then they can claim fees on\nboth networks, even if the protocol prevents direct merged mining on both\nnetworks (one or the other mined, and whatever chains validated as indicated\nby coinbase serialization).\n\n(I described it in this thread\nhttps://bitcointalk.org/index.php?topic=175156.msg2420768#msg2420768 which\nis mostly about understanding zerocoin, but digressed at that point to a\nhypothetical pure zerocoin alt-coin that retains a fair merged mine and\nexchangeless tradeability with main bitcoin.)\n\nI think another gap is the exchangeless tradeability.  Apparently the\ncontract based proposals have race conditions, and ransom issues (refuse to\ncomplete agreed commitment phase without being part-paid again).  I didnt\nfollow that discussion yet but Greg Maxwell and Sergio Lerner were\ndiscussing and that seemed to be their conclusion, and Sergio's proposed\nsolution relied on a non-standard and not-fully-worked-through assumption\nfor the alt-coin (probably non-SPV compatible I think).\n\nps I thought it was quite interesting that seemingly you could make a pure\nzerocoin alt-coin, it turns out you could direct mine them, and do zc-zc\ntransactions.  \n\nThey are fixed denomination however I think you could extend them with\nhomomorphic amounts.  I noticed Matthew Green mentioned this idea in his\npresentation at microsoft research (saw in the video they have put online). \n From my perspective (he didnt specify how other than as an attribute) its\nsomething like a Brands credential where you can prove in ZK that two\nattributes sum to a given value without revealing the attributes at all. \nThe missing last part is you have to prove that the attributes are less than\nsome threshold to avoid people cheating and adding q to their balance. \n(Arithmetic in the exponents is modulo q in the subgroup used in zerocoin). \nThere are several approaches to doing this some of them not that cheap (eg\ninvolving k DSA-like signatures to prove vale v < 2^k).  The idea of proving\nit is less than k where k is say 128 is that then to add q, you have to\nspend 2^128 coins which you cant do.  You can either make the values\nuncertain by having v eg have 44 bits of useful precision and a few binary\n00s and then 80-bits of randomness, or you can use a second never disclosed\nrandom attribute like in a Pederson commitment or Brands credential eg \nc=g^v h^r mod p where r is random and never disclosed, but the user proves\nknowledge of discrete log representation of c in terms of powers of g and h.\nThe downside of k signatures is validation CPU cost, and worse transaction\nsize.\n\nThere are several other approaches which seem to be able to prove v < 2^k\nwith less than k, eg even 1 DSA-like signature.  I need to gather that info\nin one place and write something referencing the literature I found so far. \nA homomorphically verifiable coin balance transfer could be interesting\noutside of zerocoin - eg for bitcoin, or an alt-coin.\n\nAdam\n\nOn Sun, May 19, 2013 at 03:23:59PM +0200, Adam Back wrote:\n>Is there a way to experiment with new features - eg committed coins - that\n>doesnt involve an altcoin in the conventional sense, and also doesnt impose\n>a big testing burden on bitcoin main which is a security and testing risk?\n>\n>eg lets say some form of merged mine where an alt-coin lets call it\n>bitcoin-staging?  where the coins are the same coins as on bitcoin, the\n>mining power goes to bitcoin main, so some aspect of merged mining, but no\n>native mining.  and ability to use bitcoins by locking them on bitcoin to\n>move them to bitcoin-staging and vice versa (ie exchange them 1:1\n>cryptographically, no exchange).\n>\n>Did anyone figure anything like that out?  Seems vaguely doable and\n>maybe productive.  The only people with coins at risk of defects in a new\n>feature, or insufficiently well tested novel feature are people with coins\n>on bitcoin-staging.\n>\n>Yes I know about bitcoin-test this is not it.  I mean a real live system,\n>with live value, but that is intentionally wanting to avoid forking bitcoins\n>parameters, nor value, nor mindshare dillution.  In this way something\n>potentially interesting could move forward faster, and be les risky to the\n>main bitcoin network.  eg particularly defenses against\n>\n>It might also be a more real world test test (after bitcoin-test) because\n>some parameters are different on test, and some issues may not manifest\n>without more real activity.\n>\n>Then also bitcoin could cherry pick interesting patches and merge them after\n>extensive real-world validation with real-money at stake (by early\n>adopters).\n>\n>Adam"
            },
            {
                "author": "Peter Todd",
                "date": "2013-06-14T19:20:58",
                "message_text_only": "On Thu, Jun 13, 2013 at 03:39:32PM +0200, Adam Back wrote:\n> I had one thought towards this which is a different kind of merged mining.\n> \n> I think a \"fair\" merged mining aiming for price parity would be done by the\n> miner having to choose the altcoin or btc at mine time, and altcoin chain\n> considering btc mine unspendable and bitcoin considering ac unspendable.\n\nOne way to look at what you are describing is to say you want to prove\nyour sacrifice of potential BTC earnings. That goes back to the PoW\nhashcash stuff I mentioned earlier, and is accomplished by simply mining\nshares with an unspendable coinbase to prove you did work that could\nhave resulted in Bitcoins, but didn't.\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000b7dc90d34b08218b76687c0cd8a00878fea13d4ce98b0f4df0\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130614/e7325843/attachment.sig>"
            },
            {
                "author": "Adam Back",
                "date": "2013-06-14T20:50:31",
                "message_text_only": "Agreed.  What I mean is a coinbase for parity-priced alt-coin would be\nintentionally considered (and required by the alt-coin to be considered) an\ninvalid bitcoin address, and vice versa.  The difference is for this purpose\nit is both valid alt-coin coinbase (as well as unspendable bitcoin\ncoinbase).\n\nAdam\n\nOn Fri, Jun 14, 2013 at 03:20:58PM -0400, Peter Todd wrote:\n>On Thu, Jun 13, 2013 at 03:39:32PM +0200, Adam Back wrote:\n>> I had one thought towards this which is a different kind of merged mining.\n>>\n>> I think a \"fair\" merged mining aiming for price parity would be done by the\n>> miner having to choose the altcoin or btc at mine time, and altcoin chain\n>> considering btc mine unspendable and bitcoin considering ac unspendable.\n>\n>One way to look at what you are describing is to say you want to prove\n>your sacrifice of potential BTC earnings. That goes back to the PoW\n>hashcash stuff I mentioned earlier, and is accomplished by simply mining\n>shares with an unspendable coinbase to prove you did work that could\n>have resulted in Bitcoins, but didn't."
            },
            {
                "author": "Luke-Jr",
                "date": "2013-06-14T21:10:08",
                "message_text_only": "Note that the \"earn a mixture of BTC and TBC, but not both in full volume\" \nonly works for TBC because the price is by definition fixed with BTC.\nI'm not sure how you could implement something like this for an altcoin where \nthe price is floating independently of Bitcoin.. that is, how you would know \nthe right amount of Bitcoin to require sacrificed.\n\nLuke\n\n\nOn Friday, June 14, 2013 8:50:31 PM Adam Back wrote:\n> Agreed.  What I mean is a coinbase for parity-priced alt-coin would be\n> intentionally considered (and required by the alt-coin to be considered) an\n> invalid bitcoin address, and vice versa.  The difference is for this\n> purpose it is both valid alt-coin coinbase (as well as unspendable bitcoin\n> coinbase).\n> \n> Adam\n> \n> On Fri, Jun 14, 2013 at 03:20:58PM -0400, Peter Todd wrote:\n> >On Thu, Jun 13, 2013 at 03:39:32PM +0200, Adam Back wrote:\n> >> I had one thought towards this which is a different kind of merged\n> >> mining.\n> >> \n> >> I think a \"fair\" merged mining aiming for price parity would be done by\n> >> the miner having to choose the altcoin or btc at mine time, and altcoin\n> >> chain considering btc mine unspendable and bitcoin considering ac\n> >> unspendable.\n> >\n> >One way to look at what you are describing is to say you want to prove\n> >your sacrifice of potential BTC earnings. That goes back to the PoW\n> >hashcash stuff I mentioned earlier, and is accomplished by simply mining\n> >shares with an unspendable coinbase to prove you did work that could\n> >have resulted in Bitcoins, but didn't.\n> \n> ---------------------------------------------------------------------------\n> --- This SF.net email is sponsored by Windows:\n> \n> Build for Windows Store.\n> \n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Andreas Petersson",
                "date": "2013-06-14T21:25:44",
                "message_text_only": "my initial idea (not sure if it is good) was to have an asymetric market.\nlets say you want to create altcoin ALC. ALC are merge-mined with btc,\nthough without block reward.\nto create 1 ALC you have two choices: destroy 1 BTC, or buy 1 ALC for a\nfloating amount from an exchange.\n\nin my book, this would automatically lead to a slightly lower price for\n1 ALC, and an automatic ceiling of 1 BTC, since you could always\nsacrifice BTC to gain ALC.\nbut it would not diverge drastically lower, since apparently somebody\nwas willing to destroy 1 BTC to create it. maybe it could even trade\nslightly higher because traded ALC could be spendable instantly while\nsacrificed ALC would need a 120 blocks maturing period.\nthe \"beauty\" of that system is also it does not inflate the\ncryptocurrency realm.\n\nAndreas\n\nAm 14.06.2013 23:10, schrieb Luke-Jr:\n> Note that the \"earn a mixture of BTC and TBC, but not both in full volume\" \n> only works for TBC because the price is by definition fixed with BTC.\n> I'm not sure how you could implement something like this for an altcoin where \n> the price is floating independently of Bitcoin.. that is, how you would know \n> the right amount of Bitcoin to require sacrificed."
            },
            {
                "author": "Dennison Bertram",
                "date": "2013-06-15T00:09:09",
                "message_text_only": "It seems so much easier to just allow bitcoin testnet to be used more widely for larger scale bitcoin staging. People can assign value as they wish to testnet bitcoins but at their own risk/peril. This incremental amount of value though would allow for testing of larger ideas, ideas that perhaps might not be appropriate in their nascent stages to apply for bitcoin. \n\nHave your seen 'proof of existence'? It's basically a bitcoin notary service that proves a document existed before it gets inserted into the blockchain. While a good idea- you could argue that it's blockchain spam as well- especially if one were to adapt it to high volumes in the future for notarizing permanently things like tweets (for example) or combining it with something like colored coins. These are great ideas, but maybe better suited to a proto bitcoin without needing to fashion a brand new coin. \n\nSent from my iPhone\n\nOn Jun 14, 2013, at 11:25 PM, Andreas Petersson <andreas at petersson.at> wrote:\n\n> my initial idea (not sure if it is good) was to have an asymetric market.\n> lets say you want to create altcoin ALC. ALC are merge-mined with btc,\n> though without block reward.\n> to create 1 ALC you have two choices: destroy 1 BTC, or buy 1 ALC for a\n> floating amount from an exchange.\n> \n> in my book, this would automatically lead to a slightly lower price for\n> 1 ALC, and an automatic ceiling of 1 BTC, since you could always\n> sacrifice BTC to gain ALC.\n> but it would not diverge drastically lower, since apparently somebody\n> was willing to destroy 1 BTC to create it. maybe it could even trade\n> slightly higher because traded ALC could be spendable instantly while\n> sacrificed ALC would need a 120 blocks maturing period.\n> the \"beauty\" of that system is also it does not inflate the\n> cryptocurrency realm.\n> \n> Andreas\n> \n> Am 14.06.2013 23:10, schrieb Luke-Jr:\n>> Note that the \"earn a mixture of BTC and TBC, but not both in full volume\" \n>> only works for TBC because the price is by definition fixed with BTC.\n>> I'm not sure how you could implement something like this for an altcoin where \n>> the price is floating independently of Bitcoin.. that is, how you would know \n>> the right amount of Bitcoin to require sacrificed.\n> \n> \n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n> \n> Build for Windows Store.\n> \n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Luke-Jr",
                "date": "2013-06-15T01:57:06",
                "message_text_only": "Timestamping (\"proof of existence\") doesn't need a coin at all. Just collect \nall the hashes you need timestamped into a PoE merkle tree and add that to the \nmerged mining MT. It's pretty simple and straightforward, just needs someone \nto implement it.\n\nOn Saturday, June 15, 2013 12:09:09 AM Dennison Bertram wrote:\n> Have your seen 'proof of existence'? It's basically a bitcoin notary\n> service that proves a document existed before it gets inserted into the\n> blockchain. While a good idea- you could argue that it's blockchain spam\n> as well- especially if one were to adapt it to high volumes in the future\n> for notarizing permanently things like tweets (for example) or combining\n> it with something like colored coins. These are great ideas, but maybe\n> better suited to a proto bitcoin without needing to fashion a brand new\n> coin."
            },
            {
                "author": "Dennison Bertram",
                "date": "2013-06-15T08:43:48",
                "message_text_only": "That is true, but someone is already running it as a service on the blockchain itself. See:\n\nhttps://www.proofofexistence.com/\n\nYou can imagine similar  services cropping up for things like torrents, sending btc tweets, etc. While I am not saying these things are particularly refined ideas in and of themselves, people should have an opportunity to play with them, and better testnet. \n\nSent from my iPhone\n\nOn Jun 15, 2013, at 3:57 AM, \"Luke-Jr\" <luke at dashjr.org> wrote:\n\n> Timestamping (\"proof of existence\") doesn't need a coin at all. Just collect \n> all the hashes you need timestamped into a PoE merkle tree and add that to the \n> merged mining MT. It's pretty simple and straightforward, just needs someone \n> to implement it.\n> \n> On Saturday, June 15, 2013 12:09:09 AM Dennison Bertram wrote:\n>> Have your seen 'proof of existence'? It's basically a bitcoin notary\n>> service that proves a document existed before it gets inserted into the\n>> blockchain. While a good idea- you could argue that it's blockchain spam\n>> as well- especially if one were to adapt it to high volumes in the future\n>> for notarizing permanently things like tweets (for example) or combining\n>> it with something like colored coins. These are great ideas, but maybe\n>> better suited to a proto bitcoin without needing to fashion a brand new\n>> coin.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130615/0b5c737e/attachment.html>"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2013-06-15T11:18:43",
                "message_text_only": "On 19 May 2013 15:23, Adam Back <adam at cypherspace.org> wrote:\n\n> Is there a way to experiment with new features - eg committed coins - that\n> doesnt involve an altcoin in the conventional sense, and also doesnt impose\n> a big testing burden on bitcoin main which is a security and testing risk?\n>\n> eg lets say some form of merged mine where an alt-coin lets call it\n> bitcoin-staging?  where the coins are the same coins as on bitcoin, the\n> mining power goes to bitcoin main, so some aspect of merged mining, but no\n> native mining.  and ability to use bitcoins by locking them on bitcoin to\n> move them to bitcoin-staging and vice versa (ie exchange them 1:1\n> cryptographically, no exchange).\n>\n> Did anyone figure anything like that out?  Seems vaguely doable and\n> maybe productive.  The only people with coins at risk of defects in a new\n> feature, or insufficiently well tested novel feature are people with coins\n> on bitcoin-staging.\n>\n> Yes I know about bitcoin-test this is not it.  I mean a real live system,\n> with live value, but that is intentionally wanting to avoid forking\n> bitcoins\n> parameters, nor value, nor mindshare dillution.  In this way something\n> potentially interesting could move forward faster, and be les risky to the\n> main bitcoin network.  eg particularly defenses against\n>\n> It might also be a more real world test test (after bitcoin-test) because\n> some parameters are different on test, and some issues may not manifest\n> without more real activity.\n>\n> Then also bitcoin could cherry pick interesting patches and merge them\n> after\n> extensive real-world validation with real-money at stake (by early\n> adopters).\n>\n\nInteresting idea.  I wonder if ripple could be used to set up a transfer\nsystem between the 'main' and 'staging' systems ...\n\n\n>\n> Adam\n>\n>\n> ------------------------------------------------------------------------------\n> AlienVault Unified Security Management (USM) platform delivers complete\n> security visibility with the essential security capabilities. Easily and\n> efficiently configure, manage, and operate all of your security controls\n> from a single console and one unified framework. Download a free trial.\n> http://p.sf.net/sfu/alienvault_d2d\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130615/ded41a25/attachment.html>"
            },
            {
                "author": "Dennison Bertram",
                "date": "2013-06-15T13:26:01",
                "message_text_only": "Why use ripple and not just use the testnet? \n\nThe advantageous of allowing testnet to be used as an alt-coin are That Non standard transactions can be tested in a pseudo live environment where because the coins have some nominal value people are incentivized to try and steal and come up with clever ways of gamin the system. This sort of knowledge would be invaluable if non standard transactions are ever going to become a reality on main net. \n\nIt also allows developers a chance to develop in advance new technologies and services that currently won't run on bitcoin main net but might be enabled in the future at which point they can switch over to main net. Additionally without any development happening with non standard transactions as currently there is no economic incentive , there might be a strong argument to never bother enabling non standard transactions as the risk of doing so might not justify in many people's minds  the benefits as if no one develops anything in advance  most users might not find the theoretical possibilities worth the risk, thus permanently hobbling the full potential of satoshis idea. Rather if testnet were allowed to act as an alt coin something cool might be developed that the main net users might desire enough to overcome the inertia of the status quo. \n\nAdditionally it should be considered that the time in the future when non standard transactions might be enabled  might be so far in the future when bitcoin has hit mass adoption and changing anything might require far more political negotiations between users and devs then currently. Meaning that perhaps much more proof of functionality and value as well as testing might e required. \n\nDennison\n\nSent from my iPhone\n\nOn Jun 15, 2013, at 1:18 PM, Melvin Carvalho <melvincarvalho at gmail.com> wrote:\n\n> \n> \n> \n> On 19 May 2013 15:23, Adam Back <adam at cypherspace.org> wrote:\n>> Is there a way to experiment with new features - eg committed coins - that\n>> doesnt involve an altcoin in the conventional sense, and also doesnt impose\n>> a big testing burden on bitcoin main which is a security and testing risk?\n>> \n>> eg lets say some form of merged mine where an alt-coin lets call it\n>> bitcoin-staging?  where the coins are the same coins as on bitcoin, the\n>> mining power goes to bitcoin main, so some aspect of merged mining, but no\n>> native mining.  and ability to use bitcoins by locking them on bitcoin to\n>> move them to bitcoin-staging and vice versa (ie exchange them 1:1\n>> cryptographically, no exchange).\n>> \n>> Did anyone figure anything like that out?  Seems vaguely doable and\n>> maybe productive.  The only people with coins at risk of defects in a new\n>> feature, or insufficiently well tested novel feature are people with coins\n>> on bitcoin-staging.\n>> \n>> Yes I know about bitcoin-test this is not it.  I mean a real live system,\n>> with live value, but that is intentionally wanting to avoid forking bitcoins\n>> parameters, nor value, nor mindshare dillution.  In this way something\n>> potentially interesting could move forward faster, and be les risky to the\n>> main bitcoin network.  eg particularly defenses against\n>> \n>> It might also be a more real world test test (after bitcoin-test) because\n>> some parameters are different on test, and some issues may not manifest\n>> without more real activity.\n>> \n>> Then also bitcoin could cherry pick interesting patches and merge them after\n>> extensive real-world validation with real-money at stake (by early\n>> adopters).\n> \n> Interesting idea.  I wonder if ripple could be used to set up a transfer system between the 'main' and 'staging' systems ...\n>  \n>> \n>> Adam\n>> \n>> ------------------------------------------------------------------------------\n>> AlienVault Unified Security Management (USM) platform delivers complete\n>> security visibility with the essential security capabilities. Easily and\n>> efficiently configure, manage, and operate all of your security controls\n>> from a single console and one unified framework. Download a free trial.\n>> http://p.sf.net/sfu/alienvault_d2d\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> \n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n> \n> Build for Windows Store.\n> \n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130615/2042ba06/attachment.html>"
            },
            {
                "author": "Dennison Bertram",
                "date": "2013-06-16T15:46:41",
                "message_text_only": "Is there a relatively easy way to switch between Testnet versions in the\nclient? On the forums I am in discussion with one member who mentioned the\nidea of a Main net, a testnet and a \"beta-net\" where the coins on the\nbeta-net would be allowed to have value. It seems like simple and logical\nway to do this would be something like a \"testnet=1, testnetversion=3\" in\nthe bitcoin.conf file. Is this possible?\n\n\nOn Sat, Jun 15, 2013 at 3:26 PM, Dennison Bertram <\ndennison at dennisonbertram.com> wrote:\n\n> Why use ripple and not just use the testnet?\n>\n> The advantageous of allowing testnet to be used as an alt-coin are\n> That Non standard transactions can be tested in a pseudo live environment\n> where because the coins have some nominal value people are incentivized to\n> try and steal and come up with clever ways of gamin the system. This sort\n> of knowledge would be invaluable if non standard transactions are ever\n> going to become a reality on main net.\n>\n> It also allows developers a chance to develop in advance new technologies\n> and services that currently won't run on bitcoin main net but might be\n> enabled in the future at which point they can switch over to main net.\n> Additionally without any development happening with non standard\n> transactions as currently there is no economic incentive , there might be a\n> strong argument to never bother enabling non standard transactions as the\n> risk of doing so might not justify in many people's minds  the benefits as\n> if no one develops anything in advance  most users might not find the\n> theoretical possibilities worth the risk, thus permanently hobbling the\n> full potential of satoshis idea. Rather if testnet were allowed to act as\n> an alt coin something cool might be developed that the main net users might\n> desire enough to overcome the inertia of the status quo.\n>\n> Additionally it should be considered that the time in the future when non\n> standard transactions might be enabled  might be so far in the future when\n> bitcoin has hit mass adoption and changing anything might require far more\n> political negotiations between users and devs then currently. Meaning that\n> perhaps much more proof of functionality and value as well as testing might\n> e required.\n>\n> Dennison\n>\n> Sent from my iPhone\n>\n> On Jun 15, 2013, at 1:18 PM, Melvin Carvalho <melvincarvalho at gmail.com>\n> wrote:\n>\n>\n>\n>\n> On 19 May 2013 15:23, Adam Back <adam at cypherspace.org> wrote:\n>\n>> Is there a way to experiment with new features - eg committed coins - that\n>> doesnt involve an altcoin in the conventional sense, and also doesnt\n>> impose\n>> a big testing burden on bitcoin main which is a security and testing risk?\n>>\n>> eg lets say some form of merged mine where an alt-coin lets call it\n>> bitcoin-staging?  where the coins are the same coins as on bitcoin, the\n>> mining power goes to bitcoin main, so some aspect of merged mining, but no\n>> native mining.  and ability to use bitcoins by locking them on bitcoin to\n>> move them to bitcoin-staging and vice versa (ie exchange them 1:1\n>> cryptographically, no exchange).\n>>\n>> Did anyone figure anything like that out?  Seems vaguely doable and\n>> maybe productive.  The only people with coins at risk of defects in a new\n>> feature, or insufficiently well tested novel feature are people with coins\n>> on bitcoin-staging.\n>>\n>> Yes I know about bitcoin-test this is not it.  I mean a real live system,\n>> with live value, but that is intentionally wanting to avoid forking\n>> bitcoins\n>> parameters, nor value, nor mindshare dillution.  In this way something\n>> potentially interesting could move forward faster, and be les risky to the\n>> main bitcoin network.  eg particularly defenses against\n>>\n>> It might also be a more real world test test (after bitcoin-test) because\n>> some parameters are different on test, and some issues may not manifest\n>> without more real activity.\n>>\n>> Then also bitcoin could cherry pick interesting patches and merge them\n>> after\n>> extensive real-world validation with real-money at stake (by early\n>> adopters).\n>>\n>\n> Interesting idea.  I wonder if ripple could be used to set up a transfer\n> system between the 'main' and 'staging' systems ...\n>\n>\n>>\n>> Adam\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> AlienVault Unified Security Management (USM) platform delivers complete\n>> security visibility with the essential security capabilities. Easily and\n>> efficiently configure, manage, and operate all of your security controls\n>> from a single console and one unified framework. Download a free trial.\n>> http://p.sf.net/sfu/alienvault_d2d\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n>\n> _______________________________________________\n>\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n\n\n-- \n\nDennison Bertram, photographer and film maker\n\nwww.dennisonbertram.com\n\ndennison at dennisonbertram.com\n\nMilan: +39 320 781 0128\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130616/1727472b/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "is there a way to do bitcoin-staging?",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Luke-Jr",
                "Dennison Bertram",
                "Andreas Petersson",
                "Adam Back",
                "Peter Todd",
                "Melvin Carvalho"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 29186
        }
    },
    {
        "title": "[Bitcoin-development] bitcoinj 0.9",
        "thread_messages": [
            {
                "author": "Mike Hearn",
                "date": "2013-06-17T21:19:21",
                "message_text_only": "I'm pleased to announce the release of bitcoinj 0.9, a Java library for\nworking with the Bitcoin protocol. Both simplified and full verification\nare supported. BitcoinJ has been used to create everything from end-user\nwallet apps to network crawlers to SatoshiDice.\n\nTo get bitcoinj 0.9, check out our source from git and then run *git fetch\n--all; git checkout **67b187c4c4c4*. This will place you on the 0.9 branch\nin a secure manner. The roots of trust are the announcement sent to\nbitcoinj-announce (which is signed by the google.comDKIM key) and the Maven\npage of the bitcoinj website. This paragraph is signed with the same key as\nthe previous releases (16vSNFP5Acsa6RBbjEA7QYCCRDRGXRFH4m). In addition,\nthe 0.9 release is signed by Andreas Schildbach (GPG key id 0x8B877A60,\naccessible via http://bitcoin.org/andreas_schildbach.asc) and can be\nverified with *git tag -v 0.9* once you have his key.\n\nSignature for the last paragraph:\n IEVMFkGVfE5Q7mezpNc2srdMXMkE66AEW2g7AtWa2KGa2PcK5ehqGbKPOWaL2oftcN/939VHWViMLnCKGrS3E9g=\n\nWe have a new article in the documentation library, Working with\ncontracts<https://code.google.com/p/bitcoinj/wiki/WorkingWithContracts>.\n It shows how to create and use multi-signature transactions, signed by\ndifferent parties, using a simple API.\n\n*New in this release*\n\n   - Thanks to Matt Corallo, we now have a basic *fee solver* that will\n   attach the correct (minimum) fee per kilobyte to a created transaction\n   using the 0.8.2+ fee rules. Note that there's no attempt to minimize the\n   size of a calculated transaction and thus fee, but some other optimisations\n   are applied. By default bitcoinj will always attach a fee, to learn how to\n   customise this refer to the article *Working with the wallet*.\n   - The wallet's re-org handling code was rewritten and simplified.\n   - A new class, WalletAppKit, simplifies the process of instantiating all\n   the objects and files that are needed to run a basic app that can\n   send/receive money.\n   - Add optional support for Pieter Wiulle's native secp256k1\n   implementation, which is significantly faster than Bouncy Castle.\n   - Improvements to coin selection in the wallet.\n   - Many new functions and minor API improvements, for instance, it's now\n   easier to tell the wallet to allow spending of unconfirmed coins.\n   - A new ScriptBuilder class simplifies the process of constructing\n   various kinds of scripts.\n   - A new block importer tool can parse bitcoind block files and process\n   them, which is faster than streaming them over a network connection.\n   - Support for the regtest mode added by the C++ side pull req 2632. This\n   makes app development and testing easier by eliminating the need to wait\n   for a block.\n   - Many bug fixes and testing improvements.\n\n*API changes*\n\n   - NetworkParameters has now been refactored into separate classes.\n   - Wallet extensions have been tweaked, please refer to the javadocs for\n   details.\n   - Many other minor additions and changes that are mostly backwards\n   compatible.\n\n*Known issues*\n*\n*\nPlease see the limitations and missing features\npage<https://code.google.com/p/bitcoinj/wiki/Limitations> on\nour website.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130617/2a2df5ec/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "bitcoinj 0.9",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Mike Hearn"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3354
        }
    },
    {
        "title": "[Bitcoin-development] Optional \"wallet-linkable\" address format - Payment Protocol",
        "thread_messages": [
            {
                "author": "Alan Reiner",
                "date": "2013-06-18T03:48:22",
                "message_text_only": "_*Goal*_:  An alternative address format made possible by BIP 32, which\nallows one to specify a \"Wallet ID\" and \"One-time payment\" code, instead\nof the standard one-use Base58-Hash160 addresses.   This allows parties\nwith a persistent relationship to be able to prove that payment\naddresses they provide each other are linked to a particular wallet,\nreducing exposure to MitM attacks without the need for SSL or a web of\ntrust, and without compromising the privacy of either party.    For\ninstance, this could be used between businesses that frequently do\nbusiness, by exchanging and verifying public keys beforehand, or could\nbe used by an exchange to identify if a customer withdrawal address is\nrelated to their last deposit address, and if not enforce extra\nauthentication measures.\n\n_*Background*__:_\nI haven't been following the payment protocol discussions/development\nmuch, so I apologize if this has already been addressed.   I'm calling\nit \"wallet-linkable\" addresses, which would be an optional second form\nfor sending someone your address.   With BIP 32, the address is computed\nby the payee (the person sending the address to receive money):\n\n   Standard Address ~ Base58(0x00 || hash160(PubKeyParent *\nMultiplier[i]) || checksum)\n\nWhat I'd like to do is have the option, when specifying an address\nthrough the payment protocol, to send *just* the {PublicKeyParent,\nMultiplier[i]} and let the receiver of that address compute the address\non their own.  This is no significant burden on the receiver, but it\ndoes provide the useful property that they can recognize when addresses\nspecified in this way come from the same wallet -- because the\nPubKeyParent will be the same.  Remember, this is _optional_ for the\nperson providing the address.\n\nOne nice, accidental feature of BIP 32 is that the Multiplier[i] used\nabove does not actually reveal the \"chaincode\" (I think Pieter started\ncalling it the \"tweak\").   It is derived from the chaincode but doesn't\nreveal it.  Therefore, the payer sees the parent public key, but that's\nnot useful to derive any of the other addresses unless they also have\nthe chaincode.  But they can verify that the PublicKeyParent is\nidentical between transactions, and thus is accessible only to that\nwallet.  It allows them validate a specific address provided by the\npayee, but not generate or identify any other addresses.\n\n*_Use Cases:_*\n(1)  So, just like with PGP/GPG, when two parties decide they will start\na relationship, they can start by exchanging the public keys of their\nwallet and verify them in a reliable manner.  After that, when one party\nrequests a payment address from the other, they can optionally send\n{PubKey, Multiplier}, and the payer's software will identify the owner\nof that address, or let you select who you think the address belongs to\nand it will verify it.  If the payee's system is compromised and address\nis replaced, the address received by the payer won't validate.  This\ndoesn't help if the side sending the money is compromised.\n\n(2)  When a customer first provides a deposit to an exchange, it will\nsend money from an address in their wallet and the software will provide\nthe exchange the {PubKey,Mult}.  When the customer later provides a\nwithdrawal address, the site can automatically trust the address as long\nit is provided in the alternate form and the public keys match.  If they\ndon't, it might be the same customer just requesting a withdrawal to a\ndifferent wallet, which is fine, but they'll have to go through an extra\nverification step to do so. \n\n\n_*Downsides:*_ \nMulti-sig/P2SH  - The only way this works with P2SH, violates one of the\ngoals of P2SH slightly, but may not matter much if it's all done under\nthe hood by the software.  Instead of providing a 20-byte hash of a\nscript, you provide all the public keys and multipliers for the\nindividual addresses.  The payer's software automatically verifies all\naddresses and creates the P2SH script itself (after a divine decree that\npublic keys will always be sorted lexicographically in the multi-sig\nscript).  The blockchain still benefits from the \"compression\" of moving\nthe bulky scripts to the TxIn, but it does require revealing more\ninformation than is necessary for the payer to pay the payee.  But it\nmay not /really/ be a problem, given the benefits.  It might just be\nslightly longer strings to exchange during initialization and for each\ntransaction.\n\nI have various reasons I'd like to use this, and it'd be nice to have\nsome community backing, so I don't have to twist anyone's arm to trust\nme that it's legit.\n\n-Alan\n\n\n\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130617/d52177a4/attachment.html>"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2013-06-19T12:19:40",
                "message_text_only": "On 18 June 2013 05:48, Alan Reiner <etotheipi at gmail.com> wrote:\n\n>  *Goal*:  An alternative address format made possible by BIP 32, which\n> allows one to specify a \"Wallet ID\" and \"One-time payment\" code, instead of\n> the standard one-use Base58-Hash160 addresses.   This allows parties with a\n> persistent relationship to be able to prove that payment addresses they\n> provide each other are linked to a particular wallet, reducing exposure to\n> MitM attacks without the need for SSL or a web of trust, and without\n> compromising the privacy of either party.    For instance, this could be\n> used between businesses that frequently do business, by exchanging and\n> verifying public keys beforehand, or could be used by an exchange to\n> identify if a customer withdrawal address is related to their last deposit\n> address, and if not enforce extra authentication measures.\n>\n> *Background**:*\n> I haven't been following the payment protocol discussions/development\n> much, so I apologize if this has already been addressed.   I'm calling it\n> \"wallet-linkable\" addresses, which would be an optional second form for\n> sending someone your address.   With BIP 32, the address is computed by the\n> payee (the person sending the address to receive money):\n>\n>    Standard Address ~ Base58(0x00 || hash160(PubKeyParent * Multiplier[i])\n> || checksum)\n>\n> What I'd like to do is have the option, when specifying an address through\n> the payment protocol, to send *just* the {PublicKeyParent, Multiplier[i]}\n> and let the receiver of that address compute the address on their own.\n> This is no significant burden on the receiver, but it does provide the\n> useful property that they can recognize when addresses specified in this\n> way come from the same wallet -- because the PubKeyParent will be the\n> same.  Remember, this is *optional* for the person providing the address.\n>\n> One nice, accidental feature of BIP 32 is that the Multiplier[i] used\n> above does not actually reveal the \"chaincode\" (I think Pieter started\n> calling it the \"tweak\").   It is derived from the chaincode but doesn't\n> reveal it.  Therefore, the payer sees the parent public key, but that's not\n> useful to derive any of the other addresses unless they also have the\n> chaincode.  But they can verify that the PublicKeyParent is identical\n> between transactions, and thus is accessible only to that wallet.  It\n> allows them validate a specific address provided by the payee, but not\n> generate or identify any other addresses.\n>\n> *Use Cases:*\n> (1)  So, just like with PGP/GPG, when two parties decide they will start a\n> relationship, they can start by exchanging the public keys of their wallet\n> and verify them in a reliable manner.  After that, when one party requests\n> a payment address from the other, they can optionally send {PubKey,\n> Multiplier}, and the payer's software will identify the owner of that\n> address, or let you select who you think the address belongs to and it will\n> verify it.  If the payee's system is compromised and address is replaced,\n> the address received by the payer won't validate.  This doesn't help if the\n> side sending the money is compromised.\n>\n> (2)  When a customer first provides a deposit to an exchange, it will send\n> money from an address in their wallet and the software will provide the\n> exchange the {PubKey,Mult}.  When the customer later provides a withdrawal\n> address, the site can automatically trust the address as long it is\n> provided in the alternate form and the public keys match.  If they don't,\n> it might be the same customer just requesting a withdrawal to a different\n> wallet, which is fine, but they'll have to go through an extra verification\n> step to do so.\n>\n>\n> *Downsides:*\n> Multi-sig/P2SH  - The only way this works with P2SH, violates one of the\n> goals of P2SH slightly, but may not matter much if it's all done under the\n> hood by the software.  Instead of providing a 20-byte hash of a script, you\n> provide all the public keys and multipliers for the individual addresses.\n> The payer's software automatically verifies all addresses and creates the\n> P2SH script itself (after a divine decree that public keys will always be\n> sorted lexicographically in the multi-sig script).  The blockchain still\n> benefits from the \"compression\" of moving the bulky scripts to the TxIn,\n> but it does require revealing more information than is necessary for the\n> payer to pay the payee.  But it may not *really* be a problem, given the\n> benefits.  It might just be slightly longer strings to exchange during\n> initialization and for each transaction.\n>\n> I have various reasons I'd like to use this, and it'd be nice to have some\n> community backing, so I don't have to twist anyone's arm to trust me that\n> it's legit.\n>\n\nGenerally in favour of hierarchical deterministic wallets.\n\nWill this new style of address make it into the block chain?  I'd be less\nkeen on that.\n\nI'm finding BIP0032 quite hard to read right now, but perhaps that's\nbecause I'm less familiar with the material than some.  However, there's\nlittle things like it never actually defines a deterministic wallet in the\nAbstract.  But, I'll keep trying to understand and see if I can use the\ntest vectors.\n\n\n>\n> -Alan\n>\n>\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/c32fc5bc/attachment.html>"
            },
            {
                "author": "Alan Reiner",
                "date": "2013-06-19T13:37:36",
                "message_text_only": "On 06/19/2013 08:19 AM, Melvin Carvalho wrote:\n>\n> Generally in favour of hierarchical deterministic wallets.\n>\n> Will this new style of address make it into the block chain?  I'd be\n> less keen on that.\n>\n> I'm finding BIP0032 quite hard to read right now, but perhaps that's\n> because I'm less familiar with the material than some.  However,\n> there's little things like it never actually defines a deterministic\n> wallet in the Abstract.  But, I'll keep trying to understand and see\n> if I can use the test vectors.\n>  \n>\n>\n\nThis has nothing to do with the blockchain.  This is simply an alternate\nway to encode an address, in the event that you want to prove that this\naddress is linked to another address.  The same thing ends up in the\nblockchain, either way.\n\nEither:\n(1) I give you a Hash160 address which shows up in the blockchain\nor\n(2) I give you {PubKey, Mult}, then you compute PubKey*Mult then hash it\nto get the same Hash160 I would've given you in (1)\n\nI can always give you version #1, and that's what everyone does right\nnow.  Version #2 is essentially the same, but used if you want to give\nthe other party extra information (such as the root public key, so that\nthe next time you send a version#2 address they can see they are from\nthe same root public key). \n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/1038df24/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2013-06-19T13:54:04",
                "message_text_only": "On Mon, Jun 17, 2013 at 11:48:22PM -0400, Alan Reiner wrote:\n> _*Goal*_:  An alternative address format made possible by BIP 32, which\n> allows one to specify a \"Wallet ID\" and \"One-time payment\" code, instead\n> of the standard one-use Base58-Hash160 addresses.   This allows parties\n> with a persistent relationship to be able to prove that payment\n> addresses they provide each other are linked to a particular wallet,\n> reducing exposure to MitM attacks without the need for SSL or a web of\n> trust, and without compromising the privacy of either party.    For\n> instance, this could be used between businesses that frequently do\n> business, by exchanging and verifying public keys beforehand, or could\n> be used by an exchange to identify if a customer withdrawal address is\n> related to their last deposit address, and if not enforce extra\n> authentication measures.\n\nHave you seen Timo Hanke's pay-to-contract presentation at the San Jose\nconference? It seems very related:\n\n  http://www.youtube.com/watch?v=qwyALGlG33Q\n\n-- \nPieter"
            },
            {
                "author": "Timo Hanke",
                "date": "2013-06-19T14:25:10",
                "message_text_only": "Since you mention to use this in conjunction with the payment protocol,\nnote the following subtlety. Suppose the payer has to paid this address\ncalled \"destination\": \n>    Standard Address ~ Base58(0x00 || hash160(PubKeyParent * Multiplier[i]) ||\n> checksum)\nAlso suppose the payee has spent the output, i.e. the pubkey\ncorresponding to \"destination\", which is PubKeyParent * Multiplier[i],\nis publicly known. Then anybody can (in retrospect) create arbitrary\nmany pairs {PublicKeyParent, Multiplier} (in particular different\nPublicKeyParent) that lead to the same \"destination\".\n\nDepending on what you have in mind that the transaction should \"prove\"\nregarding its actual receiver or regarding the receiver's PubKeyParent,\nthis could be an unwanted feature (or it could be just fine). If it is\nunwanted then I suggest replacing\nPubKeyParent * Multiplier[i] by \nPubKeyParent * HMAC(Multiplier[i],PubKeyParent)\nwhich eliminates from the destination all ambiguity about PubKeyParent.\n\nThis modification would not be directly compatible with BIP32 anymore\n(unfortunately), but seems to be better suited for use in conjunction\nwith a payment protocol. \n\nTimo\n\nOn Mon, Jun 17, 2013 at 11:48:22PM -0400, Alan Reiner wrote:\n> Goal:  An alternative address format made possible by BIP 32, which allows one\n> to specify a \"Wallet ID\" and \"One-time payment\" code, instead of the standard\n> one-use Base58-Hash160 addresses.   This allows parties with a persistent\n> relationship to be able to prove that payment addresses they provide each other\n> are linked to a particular wallet, reducing exposure to MitM attacks without\n> the need for SSL or a web of trust, and without compromising the privacy of\n> either party.    For instance, this could be used between businesses that\n> frequently do business, by exchanging and verifying public keys beforehand, or\n> could be used by an exchange to identify if a customer withdrawal address is\n> related to their last deposit address, and if not enforce extra authentication\n> measures.\n> \n> Background:\n> I haven't been following the payment protocol discussions/development much, so\n> I apologize if this has already been addressed.   I'm calling it\n> \"wallet-linkable\" addresses, which would be an optional second form for sending\n> someone your address.   With BIP 32, the address is computed by the payee (the\n> person sending the address to receive money):\n> \n>    Standard Address ~ Base58(0x00 || hash160(PubKeyParent * Multiplier[i]) ||\n> checksum)\n> \n> What I'd like to do is have the option, when specifying an address through the\n> payment protocol, to send *just* the {PublicKeyParent, Multiplier[i]} and let\n> the receiver of that address compute the address on their own.  This is no\n> significant burden on the receiver, but it does provide the useful property\n> that they can recognize when addresses specified in this way come from the same\n> wallet -- because the PubKeyParent will be the same.  Remember, this is\n> optional for the person providing the address.\n> \n> One nice, accidental feature of BIP 32 is that the Multiplier[i] used above\n> does not actually reveal the \"chaincode\" (I think Pieter started calling it the\n> \"tweak\").   It is derived from the chaincode but doesn't reveal it.  Therefore,\n> the payer sees the parent public key, but that's not useful to derive any of\n> the other addresses unless they also have the chaincode.  But they can verify\n> that the PublicKeyParent is identical between transactions, and thus is\n> accessible only to that wallet.  It allows them validate a specific address\n> provided by the payee, but not generate or identify any other addresses.\n> \n> Use Cases:\n> (1)  So, just like with PGP/GPG, when two parties decide they will start a\n> relationship, they can start by exchanging the public keys of their wallet and\n> verify them in a reliable manner.  After that, when one party requests a\n> payment address from the other, they can optionally send {PubKey, Multiplier},\n> and the payer's software will identify the owner of that address, or let you\n> select who you think the address belongs to and it will verify it.  If the\n> payee's system is compromised and address is replaced, the address received by\n> the payer won't validate.  This doesn't help if the side sending the money is\n> compromised.\n> \n> (2)  When a customer first provides a deposit to an exchange, it will send\n> money from an address in their wallet and the software will provide the\n> exchange the {PubKey,Mult}.  When the customer later provides a withdrawal\n> address, the site can automatically trust the address as long it is provided in\n> the alternate form and the public keys match.  If they don't, it might be the\n> same customer just requesting a withdrawal to a different wallet, which is\n> fine, but they'll have to go through an extra verification step to do so. \n> \n> \n> Downsides: \n> Multi-sig/P2SH  - The only way this works with P2SH, violates one of the goals\n> of P2SH slightly, but may not matter much if it's all done under the hood by\n> the software.  Instead of providing a 20-byte hash of a script, you provide all\n> the public keys and multipliers for the individual addresses.  The payer's\n> software automatically verifies all addresses and creates the P2SH script\n> itself (after a divine decree that public keys will always be sorted\n> lexicographically in the multi-sig script).  The blockchain still benefits from\n> the \"compression\" of moving the bulky scripts to the TxIn, but it does require\n> revealing more information than is necessary for the payer to pay the payee. \n> But it may not really be a problem, given the benefits.  It might just be\n> slightly longer strings to exchange during initialization and for each\n> transaction.\n> \n> I have various reasons I'd like to use this, and it'd be nice to have some\n> community backing, so I don't have to twist anyone's arm to trust me that it's\n> legit.\n> \n> -Alan\n> \n> \n> \n> \n\n-- \nTimo Hanke\nPGP 1EFF 69BC 6FB7 8744 14DB  631D 1BB5 D6E3 AB96 7DA8"
            },
            {
                "author": "Alan Reiner",
                "date": "2013-06-19T14:39:04",
                "message_text_only": "On 06/19/2013 10:25 AM, Timo Hanke wrote:\n> Since you mention to use this in conjunction with the payment protocol,\n> note the following subtlety. Suppose the payer has to paid this address\n> called \"destination\": \n>>    Standard Address ~ Base58(0x00 || hash160(PubKeyParent * Multiplier[i]) ||\n>> checksum)\n> Also suppose the payee has spent the output, i.e. the pubkey\n> corresponding to \"destination\", which is PubKeyParent * Multiplier[i],\n> is publicly known. Then anybody can (in retrospect) create arbitrary\n> many pairs {PublicKeyParent, Multiplier} (in particular different\n> PublicKeyParent) that lead to the same \"destination\".\n>\n> Depending on what you have in mind that the transaction should \"prove\"\n> regarding its actual receiver or regarding the receiver's PubKeyParent,\n> this could be an unwanted feature (or it could be just fine). If it is\n> unwanted then I suggest replacing\n> PubKeyParent * Multiplier[i] by \n> PubKeyParent * HMAC(Multiplier[i],PubKeyParent)\n> which eliminates from the destination all ambiguity about PubKeyParent.\n>\n> This modification would not be directly compatible with BIP32 anymore\n> (unfortunately), but seems to be better suited for use in conjunction\n> with a payment protocol. \n>\n> Timo\n\nIt's an interesting observation, but it looks like the most-obvious\nattack vector is discrete log problem:  spoofing a relationship between\na target public key and one that you control.   For instance, if you see\n{PubA, Mult} produces PubB and you have PubC already in your control\nthat you want to \"prove\" [maliciously] is related to PubB, then you have\nto find the multiplier, M that solves:  M*PubC = PubB.  That's a\ndiscrete logarithm problem.\n\nI'm not as familiar as you are, with the available operations on\nelliptic curves, but it sounds like you can produce essentially-random\npairs of {PubX, Mult} pairs that give the same PubB, but you won't have\nthe private key associated with those public keys.  It's an interesting\npoint, and there may be a reason to be concerned about it.  Though, I\ndon't see it yet.\n\n-Alan"
            },
            {
                "author": "Adam Back",
                "date": "2013-06-19T15:28:15",
                "message_text_only": "I think Timo's point is that while you cant do discrete log, you can do y-th\nroot.  So if P = xG is a parent public key (x private key, G base point),\nthen your proposed multiplier address is hash of Q=yP.  However its easy to\nfind another P such that Q=zP'.  ie just \"divide by z\" (EC multiply by z^-1\nmod n, n the order of the curve).  So P'=z^-1.Q, which will work because\nQ=zP', substituting P' you get Q=z.z^-1.Q, Q=Q.\n\nOf course the attacker has just performed an unspenable DoS (maybe, or maybe\na useless collision) because he wont know the discrete log of Q, nor P, nor\nP'.  So thats the question, does the protocol have any reliance on knowing\nthe discrete log - is it a problem if someone can find different multipliers\nof different (unknown, uncomputable discrete log) parent keys.\n\nIf it was a concern I guess you could require a proof of knowledge of\ndiscrete log.  ie as well as public key parent, multiplier the address must\ninclude ECDSA sig or Schnorr proof of knowledge (which both demonstrate\nknowledge of the discrete log of Q to base G.)\n\nSo his defense could probably be more simply viewed as hash rather than MAC\n(same thing approximately) you provide the pre-image of the multiplier.  So\nprovide P (public parent), x' (mutiplier pre-image).  And compute Q=xP where\nx=H(x',P).  You cant use just x=H(x') because I could choose random x',\ncompute x=H(x') compute x^-1 and multiply Q to find P'=x^-1.Q=H(x')^-1.Q as\nbefore.  Because x includes P as well, I would have to simultaneously choose\na P' such that Q=H(x',P').P' which requires a birthday attack on the hash\n(or MAC).\n\nAdam\n\nOn Wed, Jun 19, 2013 at 10:39:04AM -0400, Alan Reiner wrote:\n>\n>On 06/19/2013 10:25 AM, Timo Hanke wrote:\n>> Since you mention to use this in conjunction with the payment protocol,\n>> note the following subtlety. Suppose the payer has to paid this address\n>> called \"destination\":\n>>>    Standard Address ~ Base58(0x00 || hash160(PubKeyParent * Multiplier[i]) ||\n>>> checksum)\n>> Also suppose the payee has spent the output, i.e. the pubkey\n>> corresponding to \"destination\", which is PubKeyParent * Multiplier[i],\n>> is publicly known. Then anybody can (in retrospect) create arbitrary\n>> many pairs {PublicKeyParent, Multiplier} (in particular different\n>> PublicKeyParent) that lead to the same \"destination\".\n>>\n>> Depending on what you have in mind that the transaction should \"prove\"\n>> regarding its actual receiver or regarding the receiver's PubKeyParent,\n>> this could be an unwanted feature (or it could be just fine). If it is\n>> unwanted then I suggest replacing\n>> PubKeyParent * Multiplier[i] by\n>> PubKeyParent * HMAC(Multiplier[i],PubKeyParent)\n>> which eliminates from the destination all ambiguity about PubKeyParent.\n>>\n>> This modification would not be directly compatible with BIP32 anymore\n>> (unfortunately), but seems to be better suited for use in conjunction\n>> with a payment protocol.\n>>\n>> Timo\n>\n>It's an interesting observation, but it looks like the most-obvious\n>attack vector is discrete log problem:  spoofing a relationship between\n>a target public key and one that you control.   For instance, if you see\n>{PubA, Mult} produces PubB and you have PubC already in your control\n>that you want to \"prove\" [maliciously] is related to PubB, then you have\n>to find the multiplier, M that solves:  M*PubC = PubB.  That's a\n>discrete logarithm problem.\n>\n>I'm not as familiar as you are, with the available operations on\n>elliptic curves, but it sounds like you can produce essentially-random\n>pairs of {PubX, Mult} pairs that give the same PubB, but you won't have\n>the private key associated with those public keys.  It's an interesting\n>point, and there may be a reason to be concerned about it.  Though, I\n>don't see it yet.\n>\n>-Alan\n>\n>------------------------------------------------------------------------------\n>This SF.net email is sponsored by Windows:\n>\n>Build for Windows Store.\n>\n>http://p.sf.net/sfu/windows-dev2dev\n>_______________________________________________\n>Bitcoin-development mailing list\n>Bitcoin-development at lists.sourceforge.net\n>https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Adam Back",
                "date": "2013-06-19T18:36:57",
                "message_text_only": "This maybe simpler and trivially compatible with existing type2 public keys\n(ones that are multiples of a parent public key): send an ECDSA signature of\nthe multiplier, and as we know you can compute (\"recover\") the parent public\nkey from an the ECDSA signature made using it.\n\nAdam\n\nOn Wed, Jun 19, 2013 at 05:28:15PM +0200, Adam Back wrote:\n>[q-th root with unknown no discrete log artefact]\n>\n>If it was a concern I guess you could require a proof of knowledge of\n>discrete log.  ie as well as public key parent, multiplier the address must\n>include ECDSA sig or Schnorr proof of knowledge (which both demonstrate\n>knowledge of the discrete log of Q to base G.)"
            },
            {
                "author": "Alan Reiner",
                "date": "2013-06-19T19:00:42",
                "message_text_only": "On 06/19/2013 02:36 PM, Adam Back wrote:\n> This maybe simpler and trivially compatible with existing type2 public\n> keys\n> (ones that are multiples of a parent public key): send an ECDSA\n> signature of\n> the multiplier, and as we know you can compute (\"recover\") the parent\n> public\n> key from an the ECDSA signature made using it.\n>\n> Adam\n>\n> On Wed, Jun 19, 2013 at 05:28:15PM +0200, Adam Back wrote:\n>> [q-th root with unknown no discrete log artefact]\n>>\n>> If it was a concern I guess you could require a proof of knowledge of\n>> discrete log.  ie as well as public key parent, multiplier the\n>> address must\n>> include ECDSA sig or Schnorr proof of knowledge (which both demonstrate\n>> knowledge of the discrete log of Q to base G.)\n\nIt's a cool trick but requiring a signature on each multiplier defeats\none of the purposes of a deterministic wallet.  I don't want to have to\nexplicitly export a whole bunch of signatures from my offline system\njust to exercise this address option.  The \"observer wallet\" should be\nable to do anything it needs to on its own, without help from the\noffline wallet. \n\nUnless you mean that there is a one-time signature from the offline\ncomputer that works for all addresses, that can be exported with the\nobserver wallet...?  If all you want to do is prove that /someone/ owns\nthat private key, you could send {Sign(MagicString), Multiplier}.   So\nit becomes one signature operation *per wallet*, but creating new\nwallets would require going back to the offline computer for that\none-time signature.  That's better than the alternative, but it's still\nextra bloat for the wallet apps.\n\nEither way, I'm not convinced that these are a problem for the specified\nuse cases I outlined.   In cases where you have a persistent business\nrelationship, they need to verify the parent public key exchange\nanyway.  After that, the software doesn't technically require the\ntransmission of the PubKey, it only needs the Name/ID of the party and\nthe multiplier and it will fetch the PubKey from its data store.  Or it\nis transmitted and the payer verifies it's correct.  Computing an\nalternate {PubKey', Mult'} that produces the same address and then using\nit in a MitM attack doesn't work here if the two parties pre-verified\nthe public keys. \n\nIn the case that a business is checking whether the cashout address of a\ncustomer is the same as the last time:  if the first payout was not\nreplaced by an attacker, then the business already has the correct\npublic key in their DB and a replacement of further payout requests will\nfail validation.  If the first payout was replaced... well that could've\nbeen done anyway (with or without this alternate form), and the customer\nwouldn't have received their money and the whole process would be\nflagged and terminated before further transactions.\n\n-Alan\n\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/55223863/attachment.html>"
            },
            {
                "author": "Timo Hanke",
                "date": "2013-06-20T07:48:30",
                "message_text_only": "On Wed, Jun 19, 2013 at 05:28:15PM +0200, Adam Back wrote:\n> I think Timo's point is that while you cant do discrete log, you can do y-th\n> root.  So if P = xG is a parent public key (x private key, G base point),\n> then your proposed multiplier address is hash of Q=yP.  However its easy to\n> find another P such that Q=zP'.  ie just \"divide by z\" (EC multiply by z^-1\n> mod n, n the order of the curve).  So P'=z^-1.Q, which will work because\n> Q=zP', substituting P' you get Q=z.z^-1.Q, Q=Q.\n> \n> Of course the attacker has just performed an unspenable DoS (maybe, or maybe\n> a useless collision) because he wont know the discrete log of Q, nor P, nor\n> P'.  So thats the question, does the protocol have any reliance on knowing\n> the discrete log - is it a problem if someone can find different multipliers\n> of different (unknown, uncomputable discrete log) parent keys.\n> \n> If it was a concern I guess you could require a proof of knowledge of\n> discrete log.  ie as well as public key parent, multiplier the address must\n> include ECDSA sig or Schnorr proof of knowledge (which both demonstrate\n> knowledge of the discrete log of Q to base G.)\n\nThe \"concern\" (if there is any) would be that the owner of the parent\nP=xG, i.e. the person knowing x, in addition to y creates another pair\n(P',z) such that yP=Q=zP' and uses that second pair maliciously later on\n(such as claiming the payment went to identity P' not P). Since the\nowner of P knows the private key for P' (x*y*z^-1) he can also produce\nproof of knowledge for discrete log for P'. I think adding proof of\nknowledge or signatures on the multiplier don't help to eliminate all\npossible concerns, which could involve proving something to a third\nparty that has not seen the communication between payer and payee. \n\nIf you consider only payer and payee then Alan's original proposal is\njust fine, as far as I can tell. Only if you start using it in a payment\nprotocol or, more precisely, if you start interpreting P as an identity\n(as Alan suggested in subsequent posts) _and_ this identity is a\npublic/global one rather than a local one that only the payer uses, then\nreasons can pop up to eliminate ambiguity about which identity each\npayment went to.\n\nTimo\n\nps the fact that this post used the multiplicative rather than additive\nderivation scheme doesn't change the argument.\n\n-- \nTimo Hanke\nPGP 1EFF 69BC 6FB7 8744 14DB  631D 1BB5 D6E3 AB96 7DA8"
            },
            {
                "author": "Jeremy Spilman",
                "date": "2013-06-20T09:10:26",
                "message_text_only": "> which could involve proving something to a third party that has not seen \n> the communication between payer and payee.\n\nOK - I think I follow now.  So a third-party who does not see any of the \ncommunication between the payer and payee only knows the HASH160.  Let's say \nthe payee denies receipt of the funds....\n\nIt's easy to prove what public key it was sent to (it's the preimage), but \nyou can't prove the parent of that public key. You can provide any number of \nParentPubKey * Multiplier that could have been used, so the 3rd party is \nunconvinced by a \"matching\" ParentPubKey * Multiplier.\n\nHowever, if you calculated the destination using: PubKeyParent * \nHMAC(Multiplier,PubKeyParent) as Timo said, now if you give the 3rd party a \nPubKeyParent and Multiplier (or Addend) that produces the destination \naddress, you've proven the payment is in fact spendable by PubKeyParent, and \nthey can't deny receipt. Very cool.\n\nSorry for \"echoing\" this back, it took me a little while to work it out, so \nI thought I'd write it down. Hope I got it right...\n\nIf you give {PubKey, ChainCode} you do get this feature. If you give \n{ParentPubKey, Addend} or {ParentPubKey, Addend, ChainCode} you're back to \nhaving plausible deniability.\n\nIf BIP32's CKD'((Kpar, cpar), i) was actually HMAC(HMAC(cpar, i), Kpar) you \ncould give HMAC(cpar, i) instead of Addend, and then you would get this \nfeature; a way to 'skip down' a level in the wallet hierarchy, keep the \n'chain of custody' so to speak back to the ParentPubKey intact, without \nhaving to disclose the ChainCode. Meh...\n\nThanks,\n--Jeremy"
            },
            {
                "author": "Alan Reiner",
                "date": "2013-06-20T16:09:10",
                "message_text_only": "On 06/20/2013 05:10 AM, Jeremy Spilman wrote:\n>> which could involve proving something to a third party that has not seen \n>> the communication between payer and payee.\n> OK - I think I follow now.  So a third-party who does not see any of the \n> communication between the payer and payee only knows the HASH160.  Let's say \n> the payee denies receipt of the funds....\n>\n> It's easy to prove what public key it was sent to (it's the preimage), but \n> you can't prove the parent of that public key. You can provide any number of \n> ParentPubKey * Multiplier that could have been used, so the 3rd party is \n> unconvinced by a \"matching\" ParentPubKey * Multiplier.\n>\n> However, if you calculated the destination using: PubKeyParent * \n> HMAC(Multiplier,PubKeyParent) as Timo said, now if you give the 3rd party a \n> PubKeyParent and Multiplier (or Addend) that produces the destination \n> address, you've proven the payment is in fact spendable by PubKeyParent, and \n> they can't deny receipt. Very cool.\n>\n> Sorry for \"echoing\" this back, it took me a little while to work it out, so \n> I thought I'd write it down. Hope I got it right...\n>\n> If you give {PubKey, ChainCode} you do get this feature. If you give \n> {ParentPubKey, Addend} or {ParentPubKey, Addend, ChainCode} you're back to \n> having plausible deniability.\n>\n> If BIP32's CKD'((Kpar, cpar), i) was actually HMAC(HMAC(cpar, i), Kpar) you \n> could give HMAC(cpar, i) instead of Addend, and then you would get this \n> feature; a way to 'skip down' a level in the wallet hierarchy, keep the \n> 'chain of custody' so to speak back to the ParentPubKey intact, without \n> having to disclose the ChainCode. Meh...\n>\n>\n\nI agree, if we used Timo's suggestion, that seems to clean up the\nremaining uncertainties with this recommendation.   I'm not convinced\nthose uncertainties matter in this situation, where there is no question\nabout the parent public key.  That is the part of the process that was\nalready verified, per my previous examples.  But certainly, for this to\nbe more versatile it would need that. \n\nIf I modify my request to match Timo's recommendation, then it loses the\nbenefit of being a simple, non-disruptive extension of BIP 32.   I'm not\nfond of deviating from BIP 32, as it kind of defeats one of the benefits\nof BIP 32:  standardization.   And I'm not inclined to make an\nArmory-specific wallet variant.\n\nBut I can't tell if the benefits are lost on you, or you just don't\nthink they are worth it (or I'm overstating them).  I'm strongly opposed\nto bring extra wallets/chains into this equation /*just*/ to get a\nbenefit that can be had with a simple alternative encoding.  This isn't\na question of which is better, it's a matter of recognizing that both\nforms have usefulness and should both be supported. \n\n-Alan\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/a9b89205/attachment.html>"
            },
            {
                "author": "Timo Hanke",
                "date": "2013-06-19T20:03:07",
                "message_text_only": "On Wed, Jun 19, 2013 at 10:39:04AM -0400, Alan Reiner wrote:\n> On 06/19/2013 10:25 AM, Timo Hanke wrote:\n> > Since you mention to use this in conjunction with the payment protocol,\n> > note the following subtlety. Suppose the payer has to paid this address\n> > called \"destination\": \n> >>    Standard Address ~ Base58(0x00 || hash160(PubKeyParent * Multiplier[i]) ||\n> >> checksum)\n> > Also suppose the payee has spent the output, i.e. the pubkey\n> > corresponding to \"destination\", which is PubKeyParent * Multiplier[i],\n> > is publicly known. Then anybody can (in retrospect) create arbitrary\n> > many pairs {PublicKeyParent, Multiplier} (in particular different\n> > PublicKeyParent) that lead to the same \"destination\".\n> >\n> > Depending on what you have in mind that the transaction should \"prove\"\n> > regarding its actual receiver or regarding the receiver's PubKeyParent,\n> > this could be an unwanted feature (or it could be just fine). If it is\n> > unwanted then I suggest replacing\n> > PubKeyParent * Multiplier[i] by \n> > PubKeyParent * HMAC(Multiplier[i],PubKeyParent)\n> > which eliminates from the destination all ambiguity about PubKeyParent.\n> >\n> > This modification would not be directly compatible with BIP32 anymore\n> > (unfortunately), but seems to be better suited for use in conjunction\n> > with a payment protocol. \n> >\n> > Timo\n> \n> It's an interesting observation, but it looks like the most-obvious\n> attack vector is discrete log problem:  spoofing a relationship between\n> a target public key and one that you control.   For instance, if you see\n> {PubA, Mult} produces PubB and you have PubC already in your control\n> that you want to \"prove\" [maliciously] is related to PubB, then you have\n> to find the multiplier, M that solves:  M*PubC = PubB.  That's a\n> discrete logarithm problem.\n\nCorrect, for a given PubC in advance you can't create such a \"malicious\"\nrelation to PubB. You can only \"reversely\" construct new PubC from given\nPubB.\n\n> I'm not as familiar as you are, with the available operations on\n> elliptic curves, but it sounds like you can produce essentially-random\n> pairs of {PubX, Mult} pairs that give the same PubB, but you won't have\n> the private key associated with those public keys.  \n\nDepends on who is \"you\". The arbitrary person who produces {PubX, Mult}\nwon't have the private key, but the person who knows the private key for\nPubA will have it (assuming that PubB was computed from {PubA, Mult} in\nthe first place).\n\nIn the end, it all depends on your application. What proves enough for\none party doing repeated transactions with another may not suffice for a\nthird party doing auditing. On the other hand, ambiguity about PubA may\njust as well be a wanted feature for deniability reasons.\n\nTimo\n\n-- \nTimo Hanke\nPGP 1EFF 69BC 6FB7 8744 14DB  631D 1BB5 D6E3 AB96 7DA8"
            },
            {
                "author": "Jeremy Spilman",
                "date": "2013-06-19T19:29:19",
                "message_text_only": "If you have two parties who want to form a persistent relationship, by exchanging and verifying public keys beforehand, then I think the canonical way to do this with BIP32 is for the parties to exchange PubKey and *ChainCode*.\n\nI don\u2019t understand the use case for handing out individual multipliers, if what you desire is a persistent relationship. If each party dedicates a child-wallet for receiving coins, and saves a PubKey/ChainCode for sending coins, the two parties can transaction securely forever without ever exchanging any more information, and without any address reuse.\n\nI think ideally, the default behavior is that wallets always dedicate a new child node {PubKey, ChainCode} to each party they transact with. At the presentation layer, you have a \u201ccontact\u201d and each contact has a transaction history. You can send coins to a contact at any time, and internally the wallet picks the next address in their sequence. Any funds received on pubkeys from contact\u2019s sequence are attributed to that contact. The wallet can organize the contacts, and roll-up the transaction history into \u2018ledgers\u2019 and \u2018balances\u2019 however they want \u2013 it could be based on the underlying BIP32 hierarchy or perhaps not. The cost of watching large a number of pubkeys, even if you \u2018look ahead\u2019 100 pubkeys for each contact, is relatively small versus the benefits.\n\nWhat might be nice is a \u2018Contact Request\u2019 protocol, basically the same as a PaymentRequest but no actual payments are sent, just child wallets created:\n\nmessage Contact {\n    optional uint32 contact_version = 1 [default = 1];\n    optional string pki_type = 2 [default = \"none\"];\n    optional bytes pki_data = 3;\n    required bytes serialized_contact_details = 4;\n    optional bytes signature = 5;\n}\n\nmessage ContactDetails {\n    optional string network = 1 [default = \"main\"];\n    required bytes pubkey = 2;\n    required bytes chaincode = 3;\n    optional string memo = 4;\n    optional string response_url = 5;\n}\n\nAlice sends a Contact+ContactDetails to Bob.  If Bob accepts, he sends his own Contact+ContactDetails (without a response_url) back to Alice. Basically just like adding a contact to your IM contacts.\n\nAlice could send a Contact+ContactDetails to Bob without a response_url, in which case after accepting the contact, Bob could send funds to Alice, but not receive funds.\n\nYou could probably pack the whole message inside a bitcoin:// URI if you wanted to.\n\nThanks,\n--Jeremy\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/81654330/attachment.html>"
            },
            {
                "author": "Alan Reiner",
                "date": "2013-06-19T20:10:29",
                "message_text_only": "On 06/19/2013 03:29 PM, Jeremy Spilman wrote:\n> If you have two parties who want to form a persistent relationship, by\n> exchanging and verifying public keys beforehand, then I think the\n> canonical way to do this with BIP32 is for the parties to exchange\n> PubKey and *ChainCode*.\n>  \n> I don't understand the use case for handing out individual\n> multipliers, if what you desire is a persistent relationship. If each\n> party dedicates a child-wallet for receiving coins, and saves a\n> PubKey/ChainCode for sending coins, the two parties can transaction\n> securely forever without ever exchanging any more information, and\n> without any address reuse.\n>  \n> I think ideally, the default behavior is that wallets always dedicate\n> a new child node {PubKey, ChainCode} to each party they transact with.\n> At the presentation layer, you have a \"contact\" and each contact has a\n> transaction history. You can send coins to a contact at any time, and\n> internally the wallet picks the next address in their sequence. Any\n> funds received on pubkeys from contact's sequence are attributed to\n> that contact. The wallet can organize the contacts, and roll-up the\n> transaction history into 'ledgers' and 'balances' however they want --\n> it could be based on the underlying BIP32 hierarchy or perhaps not.\n> The cost of watching large a number of pubkeys, even if you 'look\n> ahead' 100 pubkeys for each contact, is relatively small versus the\n> benefits.\n>  \n>\n\nWhat you just described is complimentary to what I am proposing.  There\nis nothing stopping you from doing it that way, except that it may be\ninconvenient in some circumstances.  BIP 32 does not prescribe a way to\nuse multiple chains like you described with the convenient type-2\nderivation (though we could create a variant that does).  And all\nseparate chains with their 100-address look-aheads may be fine for your\ndesktop or mobile device, but maybe not a HW signing device with 128 kB\nof memory. \n\nSo, some use cases might prefer having a different parent public key\n[and chaincode] per contact, some may prefer to synchronize across many\ncontacts.  For instance, maybe there's a benefit to using the same\nparent pubkey across multiple services, as a form of identity.   If I\ndon't want that, I use your method.  If I do want that, I use my\nmethod.  Given its simplicity, I don't know why both can't be options.\n\nActually, it doesn't have to be specific to the payment protocol, it can\njust be alternative address encoding that some apps would use if they\nhave a need for it.\n\n-Alan\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/bc4628e8/attachment.html>"
            },
            {
                "author": "Jeremy Spilman",
                "date": "2013-06-19T21:58:06",
                "message_text_only": "Hi Alan,\n\n> \u201cBIP 32 does not prescribe a way to use multiple chains like you described \n> with the convenient type-2 derivation (though we could create a variant \n> that does)\u201d\n\nWhat do you think is missing from BIP32 for this? A wallet creates a \nchild-node using the public / type-2 CDF, hands out the PubKey/ChainCode, \nand then generally expects transactions to come in starting at /0 and \nincrementing monotonically.\n\nAlso, I'm not sure I follow your point about the 128kB hardware wallet --  \nit's a signing device, so assuming it's even validating output amounts, at \nworst it cares about the number of inputs to the outputs being spent, but in \nmany cases you're just handing it a sighash and the BIP32 \"path\" \n(/1/54/27/0) to generate the right private key for signing. The hardware \nwallet is not actually listening on the P2P network and detecting payments, \nso it's unaffected by dedicating child-nodes to each contact.\n\nConsider the benefits of gaining critical mass of support for a technique \nwhich [I think] can be used in all cases, and increases security and privacy \nfor everyone. I think there are huge benefits to leaving the age of 'single \naddress generation' behind us...\n\nThanks,\n--Jeremy"
            },
            {
                "author": "Alan Reiner",
                "date": "2013-06-19T22:47:22",
                "message_text_only": "On 06/19/2013 05:58 PM, Jeremy Spilman wrote:\n> Hi Alan,\n>\n>> \u201cBIP 32 does not prescribe a way to use multiple chains like you described \n>> with the convenient type-2 derivation (though we could create a variant \n>> that does)\u201d\n> What do you think is missing from BIP32 for this? A wallet creates a \n> child-node using the public / type-2 CDF, hands out the PubKey/ChainCode, \n> and then generally expects transactions to come in starting at /0 and \n> incrementing monotonically.\n>\n\n\nYou are suggesting that creating new wallet chains are the only\noperation needed to achieve the functionality I'm requesting.  I\ndisagree.  I am okay with using different wallets for different parties\n*/if the user wants to/*.  But there are orthogonal use-cases to having\na single wallet serve as a single identity that can be used across\nmultiple transactions or services.  And doing so is much simpler\nconceptually for the user, and simpler in implementation for the app\ndeveloper.\n\nBIP 32 already specifies how to use the first three tree levels: \nM/i/j/k, i~wallet, j~Internal/External, k~address.  The first level is\nactually type-1 derived, and thus we cannot create an arbitrary number\nof them without pre-computing them from the offline wallet.  So it's not\n\"free\" to create new wallets unless we redefine how the levels work. \nEven if we assume the simplest case where the first level is actually\ntype-2 derived and it costs nothing to create separate wallets for each\ncontact/party:\n \n-- Do these extra wallet chains behave as different wallets, or\nsub-wallets? \n-- Should their balances be bundled into a single wallet or displayed\nseparately?\n-- When a user tries to spend, does he have to specify which wallet(s)\nhe's spending from?\n-- Should the app developer be required to implement a multiple-wallet\ninterface, and handle cross-wallet spending just to achieve this simple\nmechanism?  Sure, they could instead implement a tiered wallet hierarchy\nwith primary wallets and sub-wallets... wait this just got complicated.\n\nAll that complexity just to support this identity mechanism that can be\nincluded purely as an alternative address encoding with a single\nwallet.  With my request, the user can't have one wallet and distribute\nmost of his addresses the normal/anonymous way, but certain apps would\nchoose to use the alternate encoding as a form of identity.  If the user\nfeels the need to create a separate wallet for certain operations to\nseparate his identities, that is his option if the software supports\nmultiple wallets.  But it's not the only way.\n\nTo achieve what I'm suggesting is useful and trivial to implement even\nin the simplest wallet applications. \n\n-Alan\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/350ab33e/attachment.html>"
            },
            {
                "author": "Jeremy Spilman",
                "date": "2013-06-20T03:54:18",
                "message_text_only": "> BIP 32 already specifies how to use the first three tree levels:  M/i/j/k, \n> i~wallet, j~Internal/External, k~address.  The first level is actually \n> type-1 derived, and thus we cannot create an arbitrary number of them \n> without pre-computing them from the offline wallet.  So it's not \"free\" to \n> create new wallets unless we redefine how the levels work.\n\nInitially I was thinking that you would share the public key and chain code \nfrom [m/i'/0] so that you can receive payments at [m/i'/0/k], for a unique \nvalue of 'i' for each receive chain.\n\nFor the case of generating new receive chains from a *watch-only* wallet, as \nyou say, the options are to either keep a cache of PubKey/ChainCode for \nunused [m/i'] or simply increment 'j' past 1 for an existing [m/i'/j] -- the \nconcept of 'internal/'external' and change addresses at Depth=2 don't make \nsense for handing out receive chains to lots of people anyway, and certainly \nBIP32 doesn't *require* 0 <= j <= 1.  So I think incrementing 'j' is the way \nto go here...\n\nThe \"default\" layout of BIP32 does NOT mean that implementations should not \ncheck for transactions with j > 1. That would be a useless constraint and \nobviously self-limiting. It might be helpful to add to the 'Compatibility' \nsection some minimum expectations about how a wallet should be 'probed' when \nimported. If you don't feel completely free to monotonically increment 'j' \nto your hearts content to achieve major usability benefits, then I say BIP32 \ncould use some clarifying.\n\nBTW - the spec calls for addition not multiplication now, so we should call \nit the 'Addend' not the 'Multiplier' :-)\n\n> Do these extra wallet chains behave as different wallets, or sub-wallets?\n\nThey could, but they certainly don't need to!  A single-wallet \nimplementation treats this merely as an address-generation algorithm, and \ndoes not expose any hierarchy to the user interface.  The user just \n\u201cmagically\u201d gets the ability to send multiple payments to their contacts \nwithout immediately sacrificing their privacy \n(http://www.wired.com/wiredenterprise/2013/06/bitcoin_retai/). Everything \ngoes into the same ledger, balance, coin pool, etc. Most of the code base is \nunaware BIP32 is even in use.\n\nWhile it is *possible* to support separate ledgers, balances, etc. it is \ncertainly not required, and you get all the benefits either way.\n\nI think, since your proposal generates and receives payments into \nBIP32-style addresses, we both need similar underlying wallet code. The only \ndifference is that you are passing the Kpar for [m/i'/0/k] and the *result* \nof CKD'((Kpar, cpar), k), and instead I proposed passing Kpar and cpar, and \nleaving 'k' out of it, letting the receive choose 'k'.\n\n> For instance, maybe there's a benefit to using the same parent pubkey \n> across multiple services, as a form of identity.   If I don't want that, I \n> use your method.  If I do want that, I use my method.\n\nI think it's a interesting idea using static public keys as a means for \npersistent identity and hence security from MitM. If you want a shared \npublic key across multiple services we could just combine both ideas and get \nall the benefits, by making the data structure { ParentPubKey, Addend, \nChainCode }:\n\n   ParentPubKey: Public key of m/i' -- 33 bytes\n   Addend: I[L]*G from CDK'(m/i', j) -- 33 bytes\n   ChainCode: I[R] from CDK'(m/i', j) -- 32 bytes\n\nAll that remains secret is the ChainCode from [m/i'] -- and of course the \nprivate keys.  The ParentPubKey is a common value across multiple services, \ncorresponding to user's identity rooted in [m/i'].  Each service gets their \nown 'j'.  ParentPubKey + Addend gives you the PubKey of [m/i'/j].  With the \nChainCode, the receiver then can generate [m/i'/j/k] for monotonically \nincreasing 'k'. Again, from the user perspective all transactions under \n[m/i'] can be presented in a single ledger, or not.\n\nAnyway, fundamentally my feedback is if you are designing for persistent \nlong-term relationships, you could build in a mechanism for generating \naddress chains so you don't need any further communication after the initial \nexchange, and it need not complicate the wallet.\n\nThanks,\n--Jeremy"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-06-20T07:32:22",
                "message_text_only": "Agree with Jeremy and once the payment protocol work is further along I'd\nlike to see us define an extension that lets you send payment requests\ncontaining public keys+chain codes, so further payments can be made\npush-style with no recipient interaction (e.g. for repeated billing). How\napps choose to arrange their chains internally seems like an area for\nexperimentation. I definitely want to implement HD wallets in bitcoinj to\nallow this and if that means not using the same tree structure as in the\nBIP then so be it.\n\n\nOn Thu, Jun 20, 2013 at 5:54 AM, Jeremy Spilman <jeremy at taplink.co> wrote:\n\n> > BIP 32 already specifies how to use the first three tree levels:\n>  M/i/j/k,\n> > i~wallet, j~Internal/External, k~address.  The first level is actually\n> > type-1 derived, and thus we cannot create an arbitrary number of them\n> > without pre-computing them from the offline wallet.  So it's not \"free\"\n> to\n> > create new wallets unless we redefine how the levels work.\n>\n> Initially I was thinking that you would share the public key and chain code\n> from [m/i'/0] so that you can receive payments at [m/i'/0/k], for a unique\n> value of 'i' for each receive chain.\n>\n> For the case of generating new receive chains from a *watch-only* wallet,\n> as\n> you say, the options are to either keep a cache of PubKey/ChainCode for\n> unused [m/i'] or simply increment 'j' past 1 for an existing [m/i'/j] --\n> the\n> concept of 'internal/'external' and change addresses at Depth=2 don't make\n> sense for handing out receive chains to lots of people anyway, and\n> certainly\n> BIP32 doesn't *require* 0 <= j <= 1.  So I think incrementing 'j' is the\n> way\n> to go here...\n>\n> The \"default\" layout of BIP32 does NOT mean that implementations should not\n> check for transactions with j > 1. That would be a useless constraint and\n> obviously self-limiting. It might be helpful to add to the 'Compatibility'\n> section some minimum expectations about how a wallet should be 'probed'\n> when\n> imported. If you don't feel completely free to monotonically increment 'j'\n> to your hearts content to achieve major usability benefits, then I say\n> BIP32\n> could use some clarifying.\n>\n> BTW - the spec calls for addition not multiplication now, so we should call\n> it the 'Addend' not the 'Multiplier' :-)\n>\n> > Do these extra wallet chains behave as different wallets, or sub-wallets?\n>\n> They could, but they certainly don't need to!  A single-wallet\n> implementation treats this merely as an address-generation algorithm, and\n> does not expose any hierarchy to the user interface.  The user just\n> \u201cmagically\u201d gets the ability to send multiple payments to their contacts\n> without immediately sacrificing their privacy\n> (http://www.wired.com/wiredenterprise/2013/06/bitcoin_retai/). Everything\n> goes into the same ledger, balance, coin pool, etc. Most of the code base\n> is\n> unaware BIP32 is even in use.\n>\n> While it is *possible* to support separate ledgers, balances, etc. it is\n> certainly not required, and you get all the benefits either way.\n>\n> I think, since your proposal generates and receives payments into\n> BIP32-style addresses, we both need similar underlying wallet code. The\n> only\n> difference is that you are passing the Kpar for [m/i'/0/k] and the *result*\n> of CKD'((Kpar, cpar), k), and instead I proposed passing Kpar and cpar, and\n> leaving 'k' out of it, letting the receive choose 'k'.\n>\n> > For instance, maybe there's a benefit to using the same parent pubkey\n> > across multiple services, as a form of identity.   If I don't want that,\n> I\n> > use your method.  If I do want that, I use my method.\n>\n> I think it's a interesting idea using static public keys as a means for\n> persistent identity and hence security from MitM. If you want a shared\n> public key across multiple services we could just combine both ideas and\n> get\n> all the benefits, by making the data structure { ParentPubKey, Addend,\n> ChainCode }:\n>\n>    ParentPubKey: Public key of m/i' -- 33 bytes\n>    Addend: I[L]*G from CDK'(m/i', j) -- 33 bytes\n>    ChainCode: I[R] from CDK'(m/i', j) -- 32 bytes\n>\n> All that remains secret is the ChainCode from [m/i'] -- and of course the\n> private keys.  The ParentPubKey is a common value across multiple services,\n> corresponding to user's identity rooted in [m/i'].  Each service gets their\n> own 'j'.  ParentPubKey + Addend gives you the PubKey of [m/i'/j].  With the\n> ChainCode, the receiver then can generate [m/i'/j/k] for monotonically\n> increasing 'k'. Again, from the user perspective all transactions under\n> [m/i'] can be presented in a single ledger, or not.\n>\n> Anyway, fundamentally my feedback is if you are designing for persistent\n> long-term relationships, you could build in a mechanism for generating\n> address chains so you don't need any further communication after the\n> initial\n> exchange, and it need not complicate the wallet.\n>\n> Thanks,\n> --Jeremy\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/6ee026aa/attachment.html>"
            },
            {
                "author": "Alan Reiner",
                "date": "2013-06-26T15:29:50",
                "message_text_only": "Although I'd still prefer my original request, I get much of what I want\nfrom your guys' recommendation.  It complicates the wallet design,\nbecause it requires tracking and associating a matrix of addresses for\neach wallet, instead of a single linear list.  But if this is what it's\ngoing to take then I will go along. \n\nRight now BIP 32 defines, m/i'/j/k, where j=0 is the \"external\" chain\nused for distributing addresses, and j=1 is the \"internal\" chain for\nsending change.  The CONOPs (concept of operations) for the extended\nwallet would be like Jeremy described:\n\n- Chains with j>=2 would be independent address chains carved out for\nindividuals relationships\n- Add wallet code to individually associate each j-value with a\nparticular identity\n- Update the wallet code to pool all the addresses in all j-chains when\ncalculating the balance of the wallet and/or creating transactions\n- When choosing to generically \"Receive Bitcoins\", will pick the next\naddress from the j=0 chain\n- Will have to add extra function to \"Receive Bitcoins\" button to allow\ncreation of new contacts/identities.\n- Change will always go to the next address in j=1, no matter which\nchains are used to provide inputs.\n- Add code to figure out lookaheads for each alternate chain.  Not just\neach chain, but looking ahead a couple chains, too.  Luckily, the\nlookahead doesn't have to be very big for chains j>=1 \n- Add an interface to display and choose the different chains in your\nwallet, and export the pubkey&chaincode in some soon-to-be-standardized\nformat. \n- Add code and interface to receive and track alternate j-chains from\nother clients/users, and maintain those.  Should we try associating\nincoming and outgoing chains?  What happens if they do it wrong?  Meh...\n\nJust as one final swipe at this idea, you can see that I gotta do quite\na bit of work to support the multi-chain idea, and adds a little extra\nburden on the user to maintain the organization of the wallet.  This\nwould all be totally unnecessary with a simple alternate encoding. \nGranted, I think the multi-chain idea is good, and one that I will\nprobably implement anyway, but it seems like overkill in terms of\ndeveloper complexity, and interface complexity to achieve something much\nsimpler.  Developers of much simpler/lightweight clients would probably\nfind this prohibitive.\n\nOn another note:  I thought we weren't encouraging automatic payments\nwithout requesting from the other party...?  It makes me uneasy, but it\nsounds like group thought has converged on that being acceptable.  I\nbring it up, because there are situations where it makes sense, but it\nsounds unsafe for general users.   Alice will give Bob his own chain for\nsending Alice money, then a year later Bob will send money automatically\nto Alice not realizing that the wallet was lost, retired or\ncompromised.  It's not that Bob can't ask for a new address, it's that\nif the interface says \"Send Money to Alice\", that looks legit enough\nthat Bob may not feel it necessary to check with Alice first.   That's\nmore of an interface issue though.  We can add a warning to \"check with\nthe recipient that they still have access to wallet 3cQ398x\", etc.   But\nI just know someone is going to lose money anyway...\n\n-Alan\n\n\n\n\n\nOn 06/20/2013 03:32 AM, Mike Hearn wrote:\n> Agree with Jeremy and once the payment protocol work is further along\n> I'd like to see us define an extension that lets you send payment\n> requests containing public keys+chain codes, so further payments can\n> be made push-style with no recipient interaction (e.g. for repeated\n> billing). How apps choose to arrange their chains internally seems\n> like an area for experimentation. I definitely want to implement HD\n> wallets in bitcoinj to allow this and if that means not using the same\n> tree structure as in the BIP then so be it.\n>\n>\n> On Thu, Jun 20, 2013 at 5:54 AM, Jeremy Spilman <jeremy at taplink.co\n> <mailto:jeremy at taplink.co>> wrote:\n>\n>     > BIP 32 already specifies how to use the first three tree levels:\n>      M/i/j/k,\n>     > i~wallet, j~Internal/External, k~address.  The first level is\n>     actually\n>     > type-1 derived, and thus we cannot create an arbitrary number of\n>     them\n>     > without pre-computing them from the offline wallet.  So it's not\n>     \"free\" to\n>     > create new wallets unless we redefine how the levels work.\n>\n>     Initially I was thinking that you would share the public key and\n>     chain code\n>     from [m/i'/0] so that you can receive payments at [m/i'/0/k], for\n>     a unique\n>     value of 'i' for each receive chain.\n>\n>     For the case of generating new receive chains from a *watch-only*\n>     wallet, as\n>     you say, the options are to either keep a cache of\n>     PubKey/ChainCode for\n>     unused [m/i'] or simply increment 'j' past 1 for an existing\n>     [m/i'/j] -- the\n>     concept of 'internal/'external' and change addresses at Depth=2\n>     don't make\n>     sense for handing out receive chains to lots of people anyway, and\n>     certainly\n>     BIP32 doesn't *require* 0 <= j <= 1.  So I think incrementing 'j'\n>     is the way\n>     to go here...\n>\n>     The \"default\" layout of BIP32 does NOT mean that implementations\n>     should not\n>     check for transactions with j > 1. That would be a useless\n>     constraint and\n>     obviously self-limiting. It might be helpful to add to the\n>     'Compatibility'\n>     section some minimum expectations about how a wallet should be\n>     'probed' when\n>     imported. If you don't feel completely free to monotonically\n>     increment 'j'\n>     to your hearts content to achieve major usability benefits, then I\n>     say BIP32\n>     could use some clarifying.\n>\n>     BTW - the spec calls for addition not multiplication now, so we\n>     should call\n>     it the 'Addend' not the 'Multiplier' :-)\n>\n>     > Do these extra wallet chains behave as different wallets, or\n>     sub-wallets?\n>\n>     They could, but they certainly don't need to!  A single-wallet\n>     implementation treats this merely as an address-generation\n>     algorithm, and\n>     does not expose any hierarchy to the user interface.  The user just\n>     \"magically\" gets the ability to send multiple payments to their\n>     contacts\n>     without immediately sacrificing their privacy\n>     (http://www.wired.com/wiredenterprise/2013/06/bitcoin_retai/).\n>     Everything\n>     goes into the same ledger, balance, coin pool, etc. Most of the\n>     code base is\n>     unaware BIP32 is even in use.\n>\n>     While it is *possible* to support separate ledgers, balances, etc.\n>     it is\n>     certainly not required, and you get all the benefits either way.\n>\n>     I think, since your proposal generates and receives payments into\n>     BIP32-style addresses, we both need similar underlying wallet\n>     code. The only\n>     difference is that you are passing the Kpar for [m/i'/0/k] and the\n>     *result*\n>     of CKD'((Kpar, cpar), k), and instead I proposed passing Kpar and\n>     cpar, and\n>     leaving 'k' out of it, letting the receive choose 'k'.\n>\n>     > For instance, maybe there's a benefit to using the same parent\n>     pubkey\n>     > across multiple services, as a form of identity.   If I don't\n>     want that, I\n>     > use your method.  If I do want that, I use my method.\n>\n>     I think it's a interesting idea using static public keys as a\n>     means for\n>     persistent identity and hence security from MitM. If you want a shared\n>     public key across multiple services we could just combine both\n>     ideas and get\n>     all the benefits, by making the data structure { ParentPubKey, Addend,\n>     ChainCode }:\n>\n>        ParentPubKey: Public key of m/i' -- 33 bytes\n>        Addend: I[L]*G from CDK'(m/i', j) -- 33 bytes\n>        ChainCode: I[R] from CDK'(m/i', j) -- 32 bytes\n>\n>     All that remains secret is the ChainCode from [m/i'] -- and of\n>     course the\n>     private keys.  The ParentPubKey is a common value across multiple\n>     services,\n>     corresponding to user's identity rooted in [m/i'].  Each service\n>     gets their\n>     own 'j'.  ParentPubKey + Addend gives you the PubKey of [m/i'/j].\n>      With the\n>     ChainCode, the receiver then can generate [m/i'/j/k] for monotonically\n>     increasing 'k'. Again, from the user perspective all transactions\n>     under\n>     [m/i'] can be presented in a single ledger, or not.\n>\n>     Anyway, fundamentally my feedback is if you are designing for\n>     persistent\n>     long-term relationships, you could build in a mechanism for generating\n>     address chains so you don't need any further communication after\n>     the initial\n>     exchange, and it need not complicate the wallet.\n>\n>     Thanks,\n>     --Jeremy\n>\n>\n>\n>     ------------------------------------------------------------------------------\n>     This SF.net email is sponsored by Windows:\n>\n>     Build for Windows Store.\n>\n>     http://p.sf.net/sfu/windows-dev2dev\n>     _______________________________________________\n>     Bitcoin-development mailing list\n>     Bitcoin-development at lists.sourceforge.net\n>     <mailto:Bitcoin-development at lists.sourceforge.net>\n>     https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130626/ab610b9b/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Optional \"wallet-linkable\" address format - Payment Protocol",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Adam Back",
                "Mike Hearn",
                "Timo Hanke",
                "Alan Reiner",
                "Jeremy Spilman",
                "Melvin Carvalho",
                "Pieter Wuille"
            ],
            "messages_count": 20,
            "total_messages_chars_count": 67708
        }
    },
    {
        "title": "[Bitcoin-development] Missing fRelayTxes in version message",
        "thread_messages": [
            {
                "author": "Turkey Breast",
                "date": "2013-06-18T17:45:55",
                "message_text_only": "See this BIP. I'm not sure if this is a bug or what, but it would be good if messages always had a fixed number of fields per protocol version.\n\nhttps://en.bitcoin.it/wiki/BIP_0060#Code_Updates\n\nThis BIP details everything that needs to be done and proposes a protocol upgrade.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130618/4bb74b27/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-06-18T19:48:38",
                "message_text_only": "It's not a bug (although there was recently a change to make bitcoind/qt\nalways send this field anyway).\n\nI don't know where Amir is going with BIP 60. Version messages have always\nbeen variable length. There's nothing inherent in the Bitcoin protocol that\nsays all messages are fixed length, indeed, tx messages are allowed to have\narbitrary data appended after them that gets relayed.\n\n\nOn Tue, Jun 18, 2013 at 7:45 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:\n\n> See this BIP. I'm not sure if this is a bug or what, but it would be good\n> if messages always had a fixed number of fields per protocol version.\n>\n> https://en.bitcoin.it/wiki/BIP_0060#Code_Updates\n>\n> This BIP details everything that needs to be done and proposes a protocol\n> upgrade.\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130618/b5a7149b/attachment.html>"
            },
            {
                "author": "Turkey Breast",
                "date": "2013-06-18T22:30:30",
                "message_text_only": "That's me. I never said to make all messages fixed length. I said to make a fixed number of fields per protocol. So given a protocol version number, you know the number of fields in a message. This is not only easier for parsing messages, but just good practice. I don't see why a 1 byte flag needs to be optional anyway.\n\n\n\n________________________________\n From: Mike Hearn <mike at plan99.net>\nTo: Turkey Breast <turkeybreast at yahoo.com> \nCc: Bitcoin Dev <bitcoin-development at lists.sourceforge.net> \nSent: Tuesday, June 18, 2013 9:48 PM\nSubject: Re: [Bitcoin-development] Missing fRelayTxes in version message\n \n\n\nIt's not a bug (although there was recently a change to make bitcoind/qt always send this field anyway).\u00a0\n\nI don't know where Amir is going with BIP 60. Version messages have always been variable length. There's nothing inherent in the Bitcoin protocol that says all messages are fixed length, indeed, tx messages are allowed to have arbitrary data appended after them that gets relayed.\n\n\n\nOn Tue, Jun 18, 2013 at 7:45 PM, Turkey Breast <turkeybreast at yahoo.com> wrote:\n\nSee this BIP. I'm not sure if this is a bug or what, but it would be good if messages always had a fixed number of fields per protocol version.\n>\n>\n>https://en.bitcoin.it/wiki/BIP_0060#Code_Updates\n>\n>\n>This BIP details everything that needs to be done and proposes a protocol upgrade.\n>\n>------------------------------------------------------------------------------\n>This SF.net email is sponsored by Windows:\n>\n>Build for Windows Store.\n>\n>http://p.sf.net/sfu/windows-dev2dev\n>_______________________________________________\n>Bitcoin-development mailing list\n>Bitcoin-development at lists.sourceforge.net\n>https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130618/55556c86/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-06-19T09:39:34",
                "message_text_only": "It has to be optional because old clients don't send it, obviously.\n\nWhy is this even an issue? There's no problem with variable length messages\nin any codebase that I'm aware of. Is this solving some actual problem?\n\n\nOn Wed, Jun 19, 2013 at 12:30 AM, Turkey Breast <turkeybreast at yahoo.com>wrote:\n\n> That's me. I never said to make all messages fixed length. I said to make\n> a fixed number of fields per protocol. So given a protocol version number,\n> you know the number of fields in a message. This is not only easier for\n> parsing messages, but just good practice. I don't see why a 1 byte flag\n> needs to be optional anyway.\n>\n>   ------------------------------\n>  *From:* Mike Hearn <mike at plan99.net>\n> *To:* Turkey Breast <turkeybreast at yahoo.com>\n> *Cc:* Bitcoin Dev <bitcoin-development at lists.sourceforge.net>\n> *Sent:* Tuesday, June 18, 2013 9:48 PM\n> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version message\n>\n> It's not a bug (although there was recently a change to make bitcoind/qt\n> always send this field anyway).\n>\n> I don't know where Amir is going with BIP 60. Version messages have always\n> been variable length. There's nothing inherent in the Bitcoin protocol that\n> says all messages are fixed length, indeed, tx messages are allowed to have\n> arbitrary data appended after them that gets relayed.\n>\n>\n> On Tue, Jun 18, 2013 at 7:45 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:\n>\n> See this BIP. I'm not sure if this is a bug or what, but it would be good\n> if messages always had a fixed number of fields per protocol version.\n>\n> https://en.bitcoin.it/wiki/BIP_0060#Code_Updates\n>\n> This BIP details everything that needs to be done and proposes a protocol\n> upgrade.\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net <http://sf.net/> email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/24060aea/attachment.html>"
            },
            {
                "author": "Turkey Breast",
                "date": "2013-06-19T10:33:13",
                "message_text_only": "It's a problem if you work with iterators to deserialize the byte stream. Even failing that, it's just sloppy programming. What happens in the future when new fields are added to the version message? It's not a big deal to say that this protocol version has X number of fields, that (higher) protocol version message has X + N number of fields. Deterministic number of fields per protocol version is sensical and how Bitcoin has been for a long time.\n\nAnd yes, it was a problem for me that caused a lot of confusion why this byte didn't exist in many version messages despite the standard saying it should and the code in bitcoind indicating it should. Nowhere was this written. It doesn't help other implementations to have an unclear behaviour that depends on some magic from one implementation.\n\n\n\n________________________________\n From: Mike Hearn <mike at plan99.net>\nTo: Turkey Breast <turkeybreast at yahoo.com> \nCc: \"bitcoin-development at lists.sourceforge.net\" <bitcoin-development at lists.sourceforge.net> \nSent: Wednesday, June 19, 2013 11:39 AM\nSubject: Re: [Bitcoin-development] Missing fRelayTxes in version message\n \n\n\nIt has to be optional because old clients don't send it, obviously.\n\nWhy is this even an issue? There's no problem with variable length messages in any codebase that I'm aware of. Is this solving some actual problem?\n\n\n\nOn Wed, Jun 19, 2013 at 12:30 AM, Turkey Breast <turkeybreast at yahoo.com> wrote:\n\nThat's me. I never said to make all messages fixed length. I said to make a fixed number of fields per protocol. So given a protocol version number, you know the number of fields in a message. This is not only easier for parsing messages, but just good practice. I don't see why a 1 byte flag needs to be optional anyway.\n>\n>\n>\n>\n>________________________________\n> From: Mike Hearn <mike at plan99.net>\n>To: Turkey Breast <turkeybreast at yahoo.com> \n>Cc: Bitcoin Dev <bitcoin-development at lists.sourceforge.net> \n>Sent: Tuesday, June 18, 2013 9:48 PM\n>Subject: Re: [Bitcoin-development] Missing fRelayTxes in version message\n> \n>\n>\n>It's not a bug (although there was recently a change to make bitcoind/qt always send this field anyway).\u00a0\n>\n>\n>I don't know where Amir is going with BIP 60. Version messages have always been variable length. There's nothing inherent in the Bitcoin protocol that says all messages are fixed length, indeed, tx messages are allowed to have arbitrary data appended after them that gets relayed.\n>\n>\n>\n>On Tue, Jun 18, 2013 at 7:45 PM, Turkey Breast <turkeybreast at yahoo.com> wrote:\n>\n>See this BIP. I'm not sure if this is a bug or what, but it would be good if messages always had a fixed number of fields per protocol version.\n>>\n>>\n>>https://en.bitcoin.it/wiki/BIP_0060#Code_Updates\n>>\n>>\n>>This BIP details everything that needs to be done and proposes a protocol upgrade.\n>>\n>>------------------------------------------------------------------------------\n>>This SF.net email is sponsored by Windows:\n>>\n>>Build for Windows Store.\n>>\n>>http://p.sf.net/sfu/windows-dev2dev\n>>_______________________________________________\n>>Bitcoin-development mailing list\n>>Bitcoin-development at lists.sourceforge.net\n>>https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>>\n>\n>\n>\n>------------------------------------------------------------------------------\n>This SF.net email is sponsored by Windows:\n>\n>Build for Windows Store.\n>\n>http://p.sf.net/sfu/windows-dev2dev\n>_______________________________________________\n>Bitcoin-development mailing list\n>Bitcoin-development at lists.sourceforge.net\n>https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/1a0bb11c/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-06-19T10:43:29",
                "message_text_only": "Bitcoin-Qt on master does send it now although it doesn't affect anything,\nbut as old pre-filtering versions will continue to exist, you'll always\nhave to be able to deserialize version messages without it.\n\nBitcoin version messages have always had variable length, look at how the\ncode is written in main.cpp. If you didn't experience issues until now all\nit means is that no sufficiently old nodes were talking to yours.\n\nThe standard does not say it should appear. Read it again - BIP 37 says\nabout the new version message field:\nIf false then broadcast transactions will not be announced until a\nfilter{load,add,clear} command is received. *If missing or true*, no change\nin protocol behaviour occurs.\n\n\nOn Wed, Jun 19, 2013 at 12:33 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:\n\n> It's a problem if you work with iterators to deserialize the byte stream.\n> Even failing that, it's just sloppy programming. What happens in the future\n> when new fields are added to the version message? It's not a big deal to\n> say that this protocol version has X number of fields, that (higher)\n> protocol version message has X + N number of fields. Deterministic number\n> of fields per protocol version is sensical and how Bitcoin has been for a\n> long time.\n>\n> And yes, it was a problem for me that caused a lot of confusion why this\n> byte didn't exist in many version messages despite the standard saying it\n> should and the code in bitcoind indicating it should. Nowhere was this\n> written. It doesn't help other implementations to have an unclear behaviour\n> that depends on some magic from one implementation.\n>\n>   ------------------------------\n>  *From:* Mike Hearn <mike at plan99.net>\n> *To:* Turkey Breast <turkeybreast at yahoo.com>\n> *Cc:* \"bitcoin-development at lists.sourceforge.net\" <\n> bitcoin-development at lists.sourceforge.net>\n> *Sent:* Wednesday, June 19, 2013 11:39 AM\n>\n> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version message\n>\n> It has to be optional because old clients don't send it, obviously.\n>\n> Why is this even an issue? There's no problem with variable length\n> messages in any codebase that I'm aware of. Is this solving some actual\n> problem?\n>\n>\n> On Wed, Jun 19, 2013 at 12:30 AM, Turkey Breast <turkeybreast at yahoo.com>wrote:\n>\n> That's me. I never said to make all messages fixed length. I said to make\n> a fixed number of fields per protocol. So given a protocol version number,\n> you know the number of fields in a message. This is not only easier for\n> parsing messages, but just good practice. I don't see why a 1 byte flag\n> needs to be optional anyway.\n>\n>   ------------------------------\n>  *From:* Mike Hearn <mike at plan99.net>\n> *To:* Turkey Breast <turkeybreast at yahoo.com>\n> *Cc:* Bitcoin Dev <bitcoin-development at lists.sourceforge.net>\n> *Sent:* Tuesday, June 18, 2013 9:48 PM\n> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version message\n>\n> It's not a bug (although there was recently a change to make bitcoind/qt\n> always send this field anyway).\n>\n> I don't know where Amir is going with BIP 60. Version messages have always\n> been variable length. There's nothing inherent in the Bitcoin protocol that\n> says all messages are fixed length, indeed, tx messages are allowed to have\n> arbitrary data appended after them that gets relayed.\n>\n>\n> On Tue, Jun 18, 2013 at 7:45 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:\n>\n> See this BIP. I'm not sure if this is a bug or what, but it would be good\n> if messages always had a fixed number of fields per protocol version.\n>\n> https://en.bitcoin.it/wiki/BIP_0060#Code_Updates\n>\n> This BIP details everything that needs to be done and proposes a protocol\n> upgrade.\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net <http://sf.net/> email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/11b9537c/attachment.html>"
            },
            {
                "author": "Paul Lyon",
                "date": "2013-06-19T13:03:32",
                "message_text_only": "I\u2019m also running into this exact same issue with my parser, now I understand why the relay field behavior I was seeing doesn\u2019tmatch the wiki.\n\n\nSo to parse a version message, you can\u2019t rely on the protocol version? You have to know how long the payload is, and then parse the message accordingly? I agree with Turkey Breast, this seems a bit sloppy to me.\n\n\nPaul\n\n\nP.S. I\u2019ve never used a dev mailing list before and I want to get involved with the Bitcoin dev community, so let me know if I\u2019m horribly violating any mailing list etiquette. \ud83d\ude0a\n\n\n\nFrom: Mike Hearn\nSent: \u200eWednesday\u200e, \u200eJune\u200e \u200e19\u200e, \u200e2013 \u200e7\u200e:\u200e43\u200e \u200eAM\nTo: Turkey Breast\nCc: bitcoin-development at lists.sourceforge.net\n\n\nBitcoin-Qt on master does send it now although it doesn't affect anything, but as old pre-filtering versions will continue to exist, you'll always have to be able to deserialize version messages without it.\n\n\n\nBitcoin version messages have always had variable length, look at how the code is written in main.cpp. If you didn't experience issues until now all it means is that no sufficiently old nodes were talking to yours.\n\n\n\n\nThe standard does not say it should appear. Read it again - BIP 37 says about the new version message field:\n\n\nIf false then broadcast transactions will not be announced until a filter{load,add,clear} command is received. If missing or true, no change in protocol behaviour occurs.\n\n\n\n\n\nOn Wed, Jun 19, 2013 at 12:33 PM, Turkey Breast <turkeybreast at yahoo.com> wrote:\n\n\n\n\nIt's a problem if you work with iterators to deserialize the byte stream. Even failing that, it's just sloppy programming. What happens in the future when new fields are added to the version message? It's not a big deal to say that this protocol version has X number of fields, that (higher) protocol version message has X + N number of fields. Deterministic number of fields per protocol version is sensical and how Bitcoin has been for a long time.\n\n\n\n\nAnd yes, it was a problem for me that caused a lot of confusion why this byte didn't exist in many version messages despite the standard saying it should and the code in bitcoind indicating it should. Nowhere was this written. It doesn't help other implementations to have an unclear behaviour that depends on some magic from one implementation.\n\n\n\n\n\n\n\n\n\n\nFrom: Mike Hearn <mike at plan99.net>\nTo: Turkey Breast <turkeybreast at yahoo.com> \n\nCc: \"bitcoin-development at lists.sourceforge.net\" <bitcoin-development at lists.sourceforge.net> \nSent: Wednesday, June 19, 2013 11:39 AM\n\n\nSubject: Re: [Bitcoin-development] Missing fRelayTxes in version message\n\n \n\n\n\n\n\nIt has to be optional because old clients don't send it, obviously.\n\n\n\nWhy is this even an issue? There's no problem with variable length messages in any codebase that I'm aware of. Is this solving some actual problem?\n\n\n\n\nOn Wed, Jun 19, 2013 at 12:30 AM, Turkey Breast <turkeybreast at yahoo.com> wrote:\n\n\n\n\nThat's me. I never said to make all messages fixed length. I said to make a fixed number of fields per protocol. So given a protocol version number, you know the number of fields in a message. This is not only easier for parsing messages, but just good practice. I don't see why a 1 byte flag needs to be optional anyway.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFrom: Mike Hearn <mike at plan99.net>\nTo: Turkey Breast <turkeybreast at yahoo.com> \nCc: Bitcoin Dev <bitcoin-development at lists.sourceforge.net> \nSent: Tuesday, June 18, 2013 9:48 PM\nSubject: Re: [Bitcoin-development] Missing fRelayTxes in version message\n \n\n\n\n\n\n\nIt's not a bug (although there was recently a change to make bitcoind/qt always send this field anyway). \n\n\n\nI don't know where Amir is going with BIP 60. Version messages have always been variable length. There's nothing inherent in the Bitcoin protocol that says all messages are fixed length, indeed, tx messages are allowed to have arbitrary data appended after them that gets relayed.\n\n\n\n\nOn Tue, Jun 18, 2013 at 7:45 PM, Turkey Breast <turkeybreast at yahoo.com> wrote:\n\n\n\n\nSee this BIP. I'm not sure if this is a bug or what, but it would be good if messages always had a fixed number of fields per protocol version.\n\n\n\n\nhttps://en.bitcoin.it/wiki/BIP_0060#Code_Updates\n\n\n\n\nThis BIP details everything that needs to be done and proposes a protocol upgrade.\n\n\n------------------------------------------------------------------------------\nThis SF.net email is sponsored by Windows:\n\nBuild for Windows Store.\n\nhttp://p.sf.net/sfu/windows-dev2dev\n_______________________________________________\nBitcoin-development mailing list\nBitcoin-development at lists.sourceforge.net\nhttps://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n\n\n\n\n------------------------------------------------------------------------------\nThis SF.net email is sponsored by Windows:\n\nBuild for Windows Store.\n\nhttp://p.sf.net/sfu/windows-dev2dev\n_______________________________________________\nBitcoin-development mailing list\nBitcoin-development at lists.sourceforge.net\nhttps://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n\n\n\n\n------------------------------------------------------------------------------\nThis SF.net email is sponsored by Windows:\n\nBuild for Windows Store.\n\nhttp://p.sf.net/sfu/windows-dev2dev\n_______________________________________________\nBitcoin-development mailing list\nBitcoin-development at lists.sourceforge.net\nhttps://lists.sourceforge.net/lists/listinfo/bitcoin-development\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/0831e4ce/attachment.html>\n-------------- next part --------------\n------------------------------------------------------------------------------\nThis SF.net email is sponsored by Windows:\n\nBuild for Windows Store.\n\nhttp://p.sf.net/sfu/windows-dev2dev\n-------------- next part --------------\n_______________________________________________\nBitcoin-development mailing list\nBitcoin-development at lists.sourceforge.net\nhttps://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-06-19T13:20:10",
                "message_text_only": "If you want to criticise the Bitcoin protocol for sloppyness, the variable\nlength of some messages isn't where I'd start.\n\nNote that ping has the same issue, its length has changed over time to\ninclude the nonce.\n\nIf your parser can't handle that kind of thing, you need to fix it. The\nprotocol has always worked that way.\n\n\n\nOn Wed, Jun 19, 2013 at 3:03 PM, Paul Lyon <pmlyon at hotmail.ca> wrote:\n\n> I\u2019m also running into this exact same issue with my parser, now I\n> understand why the relay field behavior I was seeing doesn\u2019t match the wiki.\n>\n> So to parse a version message, you can\u2019t rely on the protocol version? You\n> have to know how long the payload is, and then parse the message\n> accordingly? I agree with Turkey Breast, this seems a bit sloppy to me.\n>\n> Paul\n>\n> P.S. I\u2019ve never used a dev mailing list before and I want to get involved\n> with the Bitcoin dev community, so let me know if I\u2019m horribly violating\n> any mailing list etiquette. \ud83d\ude0a\n>\n> *From:* Mike Hearn\n> *Sent:* \u200eWednesday\u200e, \u200eJune\u200e \u200e19\u200e, \u200e2013 \u200e7\u200e:\u200e43\u200e \u200eAM\n> *To:* Turkey Breast\n> *Cc:* bitcoin-development at lists.sourceforge.net\n>\n> Bitcoin-Qt on master does send it now although it doesn't affect anything,\n> but as old pre-filtering versions will continue to exist, you'll always\n> have to be able to deserialize version messages without it.\n>\n> Bitcoin version messages have always had variable length, look at how the\n> code is written in main.cpp. If you didn't experience issues until now all\n> it means is that no sufficiently old nodes were talking to yours.\n>\n> The standard does not say it should appear. Read it again - BIP 37 says\n> about the new version message field:\n> If false then broadcast transactions will not be announced until a\n> filter{load,add,clear} command is received. *If missing or true*, no\n> change in protocol behaviour occurs.\n>\n>\n> On Wed, Jun 19, 2013 at 12:33 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:\n>\n>> It's a problem if you work with iterators to deserialize the byte stream.\n>> Even failing that, it's just sloppy programming. What happens in the future\n>> when new fields are added to the version message? It's not a big deal to\n>> say that this protocol version has X number of fields, that (higher)\n>> protocol version message has X + N number of fields. Deterministic number\n>> of fields per protocol version is sensical and how Bitcoin has been for a\n>> long time.\n>>\n>> And yes, it was a problem for me that caused a lot of confusion why this\n>> byte didn't exist in many version messages despite the standard saying it\n>> should and the code in bitcoind indicating it should. Nowhere was this\n>> written. It doesn't help other implementations to have an unclear behaviour\n>> that depends on some magic from one implementation.\n>>\n>>   ------------------------------\n>>  *From:* Mike Hearn <mike at plan99.net>\n>> *To:* Turkey Breast <turkeybreast at yahoo.com>\n>> *Cc:* \"bitcoin-development at lists.sourceforge.net\" <\n>> bitcoin-development at lists.sourceforge.net>\n>> *Sent:* Wednesday, June 19, 2013 11:39 AM\n>>\n>> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version\n>> message\n>>\n>> It has to be optional because old clients don't send it, obviously.\n>>\n>> Why is this even an issue? There's no problem with variable length\n>> messages in any codebase that I'm aware of. Is this solving some actual\n>> problem?\n>>\n>>\n>> On Wed, Jun 19, 2013 at 12:30 AM, Turkey Breast <turkeybreast at yahoo.com>wrote:\n>>\n>> That's me. I never said to make all messages fixed length. I said to make\n>> a fixed number of fields per protocol. So given a protocol version number,\n>> you know the number of fields in a message. This is not only easier for\n>> parsing messages, but just good practice. I don't see why a 1 byte flag\n>> needs to be optional anyway.\n>>\n>>   ------------------------------\n>>  *From:* Mike Hearn <mike at plan99.net>\n>> *To:* Turkey Breast <turkeybreast at yahoo.com>\n>> *Cc:* Bitcoin Dev <bitcoin-development at lists.sourceforge.net>\n>> *Sent:* Tuesday, June 18, 2013 9:48 PM\n>> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version\n>> message\n>>\n>> It's not a bug (although there was recently a change to make bitcoind/qt\n>> always send this field anyway).\n>>\n>> I don't know where Amir is going with BIP 60. Version messages have\n>> always been variable length. There's nothing inherent in the Bitcoin\n>> protocol that says all messages are fixed length, indeed, tx messages are\n>> allowed to have arbitrary data appended after them that gets relayed.\n>>\n>>\n>> On Tue, Jun 18, 2013 at 7:45 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:\n>>\n>> See this BIP. I'm not sure if this is a bug or what, but it would be good\n>> if messages always had a fixed number of fields per protocol version.\n>>\n>> https://en.bitcoin.it/wiki/BIP_0060#Code_Updates\n>>\n>> This BIP details everything that needs to be done and proposes a protocol\n>> upgrade.\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> This SF.net <http://sf.net/> email is sponsored by Windows:\n>>\n>> Build for Windows Store.\n>>\n>> http://p.sf.net/sfu/windows-dev2dev\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>>\n>>\n>>\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> This SF.net email is sponsored by Windows:\n>>\n>> Build for Windows Store.\n>>\n>> http://p.sf.net/sfu/windows-dev2dev\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>>\n>>\n>>\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> This SF.net email is sponsored by Windows:\n>>\n>> Build for Windows Store.\n>>\n>> http://p.sf.net/sfu/windows-dev2dev\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/9e7088a9/attachment.html>"
            },
            {
                "author": "Turkey Breast",
                "date": "2013-06-20T06:20:37",
                "message_text_only": "I never said that Bitcoin message field lengths should always be the same. But before this change they certainly were constant per protocol version. All I'm saying is that optional lengths shouldn't be used (a field exists or not) and for every field change, the protocol version should be upgraded.\n\nNow that fRelayTxes is part of the protocol, the version number should be upgraded to reflect this fact.\n\n\n\n________________________________\n From: Mike Hearn <mike at plan99.net>\nTo: Paul Lyon <pmlyon at hotmail.ca> \nCc: Turkey Breast <turkeybreast at yahoo.com>; \"bitcoin-development at lists.sourceforge.net\" <bitcoin-development at lists.sourceforge.net> \nSent: Wednesday, June 19, 2013 3:20 PM\nSubject: Re: [Bitcoin-development] Missing fRelayTxes in version message\n \n\n\nIf you want to criticise the Bitcoin protocol for sloppyness, the variable length of some messages isn't where I'd start.\n\nNote that ping has the same issue, its length has changed over time to include the nonce.\n\nIf your parser can't handle that kind of thing, you need to fix it. The protocol has always worked that way.\n\n\n\n\nOn Wed, Jun 19, 2013 at 3:03 PM, Paul Lyon <pmlyon at hotmail.ca> wrote:\n\nI\u2019m also running into this exact same issue with my parser, now I understand why the relay field behavior I was seeing\u00a0doesn\u2019t match the wiki.\n>\u00a0\n>So to parse a version message, you can\u2019t rely on the protocol version? You have to know how long the payload is, and then parse the message accordingly? I agree with Turkey Breast, this seems a bit sloppy to me.\n>\u00a0\n>Paul\n>\u00a0\n>P.S. I\u2019ve never used a dev mailing list before and I want to get involved with the Bitcoin dev community, so let me know if I\u2019m horribly violating any\u00a0mailing list etiquette. \ud83d\ude0a\n>\u00a0\n>From:\u00a0Mike Hearn\n>Sent:\u00a0\u200eWednesday\u200e, \u200eJune\u200e \u200e19\u200e, \u200e2013 \u200e7\u200e:\u200e43\u200e \u200eAM\n>To:\u00a0Turkey Breast\n>Cc:\u00a0bitcoin-development at lists.sourceforge.net\n>\u00a0\n>Bitcoin-Qt on master does send it now although it doesn't affect anything, but as old pre-filtering versions will continue to exist, you'll always have to be able to deserialize version messages without it.\n>\n>\n>Bitcoin version messages have always had variable length, look at how the code is written in main.cpp. If you didn't experience issues until now all it means is that no sufficiently old nodes were talking to yours.\n>\n>\n>The standard does not say it should appear. Read it again - BIP 37 says about the new version message field:\n>If false then broadcast transactions will not be announced until a filter{load,add,clear} command is received. If missing or true, no change in protocol behaviour occurs.\n> \n>\n>\n>\n>On Wed, Jun 19, 2013 at 12:33 PM, Turkey Breast <turkeybreast at yahoo.com> wrote:\n>\n>It's a problem if you work with iterators to deserialize the byte stream. Even failing that, it's just sloppy programming. What happens in the future when new fields are added to the version message? It's not a big deal to say that this protocol version has X number of fields, that (higher) protocol version message has X + N number of fields. Deterministic number of fields per protocol version is sensical and how Bitcoin has been for a long time.\n>>\n>>\n>>And yes, it was a problem for me that caused a lot of confusion why this byte didn't exist in many version messages despite the standard saying it should and the code in bitcoind indicating it should. Nowhere was this written. It doesn't help other implementations to have an unclear behaviour that depends on some magic from one implementation.\n>>\n>>\n>>\n>>\n>>________________________________\n>> From: Mike Hearn <mike at plan99.net>\n>>To: Turkey Breast <turkeybreast at yahoo.com> \n>>Cc: \"bitcoin-development at lists.sourceforge.net\" <bitcoin-development at lists.sourceforge.net> \n>>Sent: Wednesday, June 19, 2013 11:39 AM\n>>\n>>Subject: Re: [Bitcoin-development] Missing fRelayTxes in version message\n>> \n>>\n>>\n>>It has to be optional because old clients don't send it, obviously.\n>>\n>>\n>>Why is this even an issue? There's no problem with variable length messages in any codebase that I'm aware of. Is this solving some actual problem?\n>>\n>>\n>>\n>>On Wed, Jun 19, 2013 at 12:30 AM, Turkey Breast <turkeybreast at yahoo.com> wrote:\n>>\n>>That's me. I never said to make all messages fixed length. I said to make a fixed number of fields per protocol. So given a protocol version number, you know the number of fields in a message. This is not only easier for parsing messages, but just good practice. I don't see why a 1 byte flag needs to be optional anyway.\n>>>\n>>>\n>>>\n>>>\n>>>________________________________\n>>> From: Mike Hearn <mike at plan99.net>\n>>>To: Turkey Breast <turkeybreast at yahoo.com> \n>>>Cc: Bitcoin Dev <bitcoin-development at lists.sourceforge.net> \n>>>Sent: Tuesday, June 18, 2013 9:48 PM\n>>>Subject: Re: [Bitcoin-development] Missing fRelayTxes in version message\n>>> \n>>>\n>>>\n>>>It's not a bug (although there was recently a change to make bitcoind/qt always send this field anyway).\u00a0\n>>>\n>>>\n>>>I don't know where Amir is going with BIP 60. Version messages have always been variable length. There's nothing inherent in the Bitcoin protocol that says all messages are fixed length, indeed, tx messages are allowed to have arbitrary data appended after them that gets relayed.\n>>>\n>>>\n>>>\n>>>On Tue, Jun 18, 2013 at 7:45 PM, Turkey Breast <turkeybreast at yahoo.com> wrote:\n>>>\n>>>See this BIP. I'm not sure if this is a bug or what, but it would be good if messages always had a fixed number of fields per protocol version.\n>>>>\n>>>>\n>>>>https://en.bitcoin.it/wiki/BIP_0060#Code_Updates\n>>>>\n>>>>\n>>>>This BIP details everything that needs to be done and proposes a protocol upgrade.\n>>>>\n>>>>------------------------------------------------------------------------------\n>>>>This SF.net email is sponsored by Windows:\n>>>>\n>>>>Build for Windows Store.\n>>>>\n>>>>http://p.sf.net/sfu/windows-dev2dev\n>>>>_______________________________________________\n>>>>Bitcoin-development mailing list\n>>>>Bitcoin-development at lists.sourceforge.net\n>>>>https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>>>\n>>>>\n>>>\n>>>\n>>>\n>>>------------------------------------------------------------------------------\n>>>This SF.net email is sponsored by Windows:\n>>>\n>>>Build for Windows Store.\n>>>\n>>>http://p.sf.net/sfu/windows-dev2dev\n>>>_______________________________________________\n>>>Bitcoin-development mailing list\n>>>Bitcoin-development at lists.sourceforge.net\n>>>https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>>\n>>>\n>>\n>>\n>>\n>>------------------------------------------------------------------------------\n>>This SF.net email is sponsored by Windows:\n>>\n>>Build for Windows Store.\n>>\n>>http://p.sf.net/sfu/windows-dev2dev\n>>_______________________________________________\n>>Bitcoin-development mailing list\n>>Bitcoin-development at lists.sourceforge.net\n>>https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/852f3ff4/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-06-20T07:10:05",
                "message_text_only": "The protocol version was bumped when Bloom filtering was added so there's\nnot much point bumping it again - you have to handle the old clients no\nmatter what. Nobody brought this up as an issue when the BIP or code was\nfirst written and as you can see from main.cpp, it was done this way to be\nconsistent with how other version fields are handled:\n\n        if (!vRecv.empty())\n            vRecv >> addrFrom >> nNonce;\n        if (!vRecv.empty())\n            vRecv >> pfrom->strSubVer;\n        if (!vRecv.empty())\n            vRecv >> pfrom->nStartingHeight;\n        if (!vRecv.empty())\n            vRecv >> pfrom->fRelayTxes; // set to true after we get the\nfirst filter* message\n\nThe existence of the nStartingHeight field for instance depends on the\nmessage length and not anything else.\n\nAnyway, are you really asking for the protocol to be changed to work around\nan issue specific to how you wrote your parsing code? This is the first\ntime anyone has suggested this minor detail is a problem. It doesn't\npresent any issues for the C++ code or bitcoinj where message objects know\ntheir own length at parse time.\n\n\n\nOn Thu, Jun 20, 2013 at 8:20 AM, Turkey Breast <turkeybreast at yahoo.com>wrote:\n\n> I never said that Bitcoin message field lengths should always be the same.\n> But before this change they certainly were constant per protocol version.\n> All I'm saying is that optional lengths shouldn't be used (a field exists\n> or not) and for every field change, the protocol version should be upgraded.\n>\n> Now that fRelayTxes is part of the protocol, the version number should be\n> upgraded to reflect this fact.\n>\n>   ------------------------------\n>  *From:* Mike Hearn <mike at plan99.net>\n> *To:* Paul Lyon <pmlyon at hotmail.ca>\n> *Cc:* Turkey Breast <turkeybreast at yahoo.com>; \"\n> bitcoin-development at lists.sourceforge.net\" <\n> bitcoin-development at lists.sourceforge.net>\n> *Sent:* Wednesday, June 19, 2013 3:20 PM\n>\n> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version message\n>\n> If you want to criticise the Bitcoin protocol for sloppyness, the variable\n> length of some messages isn't where I'd start.\n>\n> Note that ping has the same issue, its length has changed over time to\n> include the nonce.\n>\n> If your parser can't handle that kind of thing, you need to fix it. The\n> protocol has always worked that way.\n>\n>\n>\n> On Wed, Jun 19, 2013 at 3:03 PM, Paul Lyon <pmlyon at hotmail.ca> wrote:\n>\n>  I\u2019m also running into this exact same issue with my parser, now I\n> understand why the relay field behavior I was seeing doesn\u2019t match the wiki.\n>\n> So to parse a version message, you can\u2019t rely on the protocol version? You\n> have to know how long the payload is, and then parse the message\n> accordingly? I agree with Turkey Breast, this seems a bit sloppy to me.\n>\n> Paul\n>\n> P.S. I\u2019ve never used a dev mailing list before and I want to get involved\n> with the Bitcoin dev community, so let me know if I\u2019m horribly violating\n> any mailing list etiquette. \ud83d\ude0a\n>\n> *From:* Mike Hearn\n> *Sent:* \u200eWednesday\u200e, \u200eJune\u200e \u200e19\u200e, \u200e2013 \u200e7\u200e:\u200e43\u200e \u200eAM\n> *To:* Turkey Breast\n> *Cc:* bitcoin-development at lists.sourceforge.net\n>\n> Bitcoin-Qt on master does send it now although it doesn't affect anything,\n> but as old pre-filtering versions will continue to exist, you'll always\n> have to be able to deserialize version messages without it.\n>\n> Bitcoin version messages have always had variable length, look at how the\n> code is written in main.cpp. If you didn't experience issues until now all\n> it means is that no sufficiently old nodes were talking to yours.\n>\n> The standard does not say it should appear. Read it again - BIP 37 says\n> about the new version message field:\n> If false then broadcast transactions will not be announced until a\n> filter{load,add,clear} command is received. *If missing or true*, no\n> change in protocol behaviour occurs.\n>\n>\n> On Wed, Jun 19, 2013 at 12:33 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:\n>\n> It's a problem if you work with iterators to deserialize the byte stream.\n> Even failing that, it's just sloppy programming. What happens in the future\n> when new fields are added to the version message? It's not a big deal to\n> say that this protocol version has X number of fields, that (higher)\n> protocol version message has X + N number of fields. Deterministic number\n> of fields per protocol version is sensical and how Bitcoin has been for a\n> long time.\n>\n> And yes, it was a problem for me that caused a lot of confusion why this\n> byte didn't exist in many version messages despite the standard saying it\n> should and the code in bitcoind indicating it should. Nowhere was this\n> written. It doesn't help other implementations to have an unclear behaviour\n> that depends on some magic from one implementation.\n>\n>   ------------------------------\n>  *From:* Mike Hearn <mike at plan99.net>\n> *To:* Turkey Breast <turkeybreast at yahoo.com>\n> *Cc:* \"bitcoin-development at lists.sourceforge.net\" <\n> bitcoin-development at lists.sourceforge.net>\n> *Sent:* Wednesday, June 19, 2013 11:39 AM\n>\n> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version message\n>\n> It has to be optional because old clients don't send it, obviously.\n>\n> Why is this even an issue? There's no problem with variable length\n> messages in any codebase that I'm aware of. Is this solving some actual\n> problem?\n>\n>\n> On Wed, Jun 19, 2013 at 12:30 AM, Turkey Breast <turkeybreast at yahoo.com>wrote:\n>\n> That's me. I never said to make all messages fixed length. I said to make\n> a fixed number of fields per protocol. So given a protocol version number,\n> you know the number of fields in a message. This is not only easier for\n> parsing messages, but just good practice. I don't see why a 1 byte flag\n> needs to be optional anyway.\n>\n>   ------------------------------\n>  *From:* Mike Hearn <mike at plan99.net>\n> *To:* Turkey Breast <turkeybreast at yahoo.com>\n> *Cc:* Bitcoin Dev <bitcoin-development at lists.sourceforge.net>\n> *Sent:* Tuesday, June 18, 2013 9:48 PM\n> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version message\n>\n> It's not a bug (although there was recently a change to make bitcoind/qt\n> always send this field anyway).\n>\n> I don't know where Amir is going with BIP 60. Version messages have always\n> been variable length. There's nothing inherent in the Bitcoin protocol that\n> says all messages are fixed length, indeed, tx messages are allowed to have\n> arbitrary data appended after them that gets relayed.\n>\n>\n> On Tue, Jun 18, 2013 at 7:45 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:\n>\n> See this BIP. I'm not sure if this is a bug or what, but it would be good\n> if messages always had a fixed number of fields per protocol version.\n>\n> https://en.bitcoin.it/wiki/BIP_0060#Code_Updates\n>\n> This BIP details everything that needs to be done and proposes a protocol\n> upgrade.\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net <http://sf.net/> email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/ace406cd/attachment.html>"
            },
            {
                "author": "Addy Yeow",
                "date": "2013-06-20T07:13:11",
                "message_text_only": "I personally don't treat the relay field as optional, i.e. it is there as\n0x01 if it is set. Otherwise, it is simply a trailing zero byte. Hence, the\nright way of reading the packet as with any network packet is to first\nretrieve the header information, get the actual payload length, then parse\nthe payload accordingly. I can also choose to include 0x00 for my relay\nfield in my outgoing packet and reflect that accordingly in my length field\nin the header.\n\n\nOn Thu, Jun 20, 2013 at 4:20 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:\n\n> I never said that Bitcoin message field lengths should always be the same.\n> But before this change they certainly were constant per protocol version.\n> All I'm saying is that optional lengths shouldn't be used (a field exists\n> or not) and for every field change, the protocol version should be upgraded.\n>\n> Now that fRelayTxes is part of the protocol, the version number should be\n> upgraded to reflect this fact.\n>\n>   ------------------------------\n>  *From:* Mike Hearn <mike at plan99.net>\n> *To:* Paul Lyon <pmlyon at hotmail.ca>\n> *Cc:* Turkey Breast <turkeybreast at yahoo.com>; \"\n> bitcoin-development at lists.sourceforge.net\" <\n> bitcoin-development at lists.sourceforge.net>\n> *Sent:* Wednesday, June 19, 2013 3:20 PM\n> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version message\n>\n> If you want to criticise the Bitcoin protocol for sloppyness, the variable\n> length of some messages isn't where I'd start.\n>\n> Note that ping has the same issue, its length has changed over time to\n> include the nonce.\n>\n> If your parser can't handle that kind of thing, you need to fix it. The\n> protocol has always worked that way.\n>\n>\n>\n> On Wed, Jun 19, 2013 at 3:03 PM, Paul Lyon <pmlyon at hotmail.ca> wrote:\n>\n>  I\u2019m also running into this exact same issue with my parser, now I\n> understand why the relay field behavior I was seeing doesn\u2019t match the wiki.\n>\n> So to parse a version message, you can\u2019t rely on the protocol version? You\n> have to know how long the payload is, and then parse the message\n> accordingly? I agree with Turkey Breast, this seems a bit sloppy to me.\n>\n> Paul\n>\n> P.S. I\u2019ve never used a dev mailing list before and I want to get involved\n> with the Bitcoin dev community, so let me know if I\u2019m horribly violating\n> any mailing list etiquette. \ud83d\ude0a\n>\n> *From:* Mike Hearn\n> *Sent:* \u200eWednesday\u200e, \u200eJune\u200e \u200e19\u200e, \u200e2013 \u200e7\u200e:\u200e43\u200e \u200eAM\n> *To:* Turkey Breast\n> *Cc:* bitcoin-development at lists.sourceforge.net\n>\n> Bitcoin-Qt on master does send it now although it doesn't affect anything,\n> but as old pre-filtering versions will continue to exist, you'll always\n> have to be able to deserialize version messages without it.\n>\n> Bitcoin version messages have always had variable length, look at how the\n> code is written in main.cpp. If you didn't experience issues until now all\n> it means is that no sufficiently old nodes were talking to yours.\n>\n> The standard does not say it should appear. Read it again - BIP 37 says\n> about the new version message field:\n> If false then broadcast transactions will not be announced until a\n> filter{load,add,clear} command is received. *If missing or true*, no\n> change in protocol behaviour occurs.\n>\n>\n> On Wed, Jun 19, 2013 at 12:33 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:\n>\n> It's a problem if you work with iterators to deserialize the byte stream.\n> Even failing that, it's just sloppy programming. What happens in the future\n> when new fields are added to the version message? It's not a big deal to\n> say that this protocol version has X number of fields, that (higher)\n> protocol version message has X + N number of fields. Deterministic number\n> of fields per protocol version is sensical and how Bitcoin has been for a\n> long time.\n>\n> And yes, it was a problem for me that caused a lot of confusion why this\n> byte didn't exist in many version messages despite the standard saying it\n> should and the code in bitcoind indicating it should. Nowhere was this\n> written. It doesn't help other implementations to have an unclear behaviour\n> that depends on some magic from one implementation.\n>\n>   ------------------------------\n>  *From:* Mike Hearn <mike at plan99.net>\n> *To:* Turkey Breast <turkeybreast at yahoo.com>\n> *Cc:* \"bitcoin-development at lists.sourceforge.net\" <\n> bitcoin-development at lists.sourceforge.net>\n> *Sent:* Wednesday, June 19, 2013 11:39 AM\n>\n> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version message\n>\n> It has to be optional because old clients don't send it, obviously.\n>\n> Why is this even an issue? There's no problem with variable length\n> messages in any codebase that I'm aware of. Is this solving some actual\n> problem?\n>\n>\n> On Wed, Jun 19, 2013 at 12:30 AM, Turkey Breast <turkeybreast at yahoo.com>wrote:\n>\n> That's me. I never said to make all messages fixed length. I said to make\n> a fixed number of fields per protocol. So given a protocol version number,\n> you know the number of fields in a message. This is not only easier for\n> parsing messages, but just good practice. I don't see why a 1 byte flag\n> needs to be optional anyway.\n>\n>   ------------------------------\n>  *From:* Mike Hearn <mike at plan99.net>\n> *To:* Turkey Breast <turkeybreast at yahoo.com>\n> *Cc:* Bitcoin Dev <bitcoin-development at lists.sourceforge.net>\n> *Sent:* Tuesday, June 18, 2013 9:48 PM\n> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version message\n>\n> It's not a bug (although there was recently a change to make bitcoind/qt\n> always send this field anyway).\n>\n> I don't know where Amir is going with BIP 60. Version messages have always\n> been variable length. There's nothing inherent in the Bitcoin protocol that\n> says all messages are fixed length, indeed, tx messages are allowed to have\n> arbitrary data appended after them that gets relayed.\n>\n>\n> On Tue, Jun 18, 2013 at 7:45 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:\n>\n> See this BIP. I'm not sure if this is a bug or what, but it would be good\n> if messages always had a fixed number of fields per protocol version.\n>\n> https://en.bitcoin.it/wiki/BIP_0060#Code_Updates\n>\n> This BIP details everything that needs to be done and proposes a protocol\n> upgrade.\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net <http://sf.net/> email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/0683b160/attachment.html>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-06-20T13:35:11",
                "message_text_only": "On Thu, Jun 20, 2013 at 3:13 AM, Addy Yeow <ayeowch at gmail.com> wrote:\n> I personally don't treat the relay field as optional, i.e. it is there as\n> 0x01 if it is set. Otherwise, it is simply a trailing zero byte. Hence, the\n> right way of reading the packet as with any network packet is to first\n> retrieve the header information, get the actual payload length, then parse\n> the payload accordingly. I can also choose to include 0x00 for my relay\n> field in my outgoing packet and reflect that accordingly in my length field\n> in the header.\n\nThat works until another field is added in the same manner.\n\nImplementations are expected to follow the standard logic of\n\nif (more data)\n   parse field X\nif (more data)\n   parse field X+1\nif (more data)\n   parse field X+2\netc.\n\nUgly or not, there is no point in changing now.  Updating the version\nmessage to a radically different design, for simply cleanliness\nreasons, is not sufficient cause to migrate the entire bitcoin\nuniverse to a new and different version/feature negotiation setup.\n\n--\nJeff Garzik\nSenior Software Engineer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            }
        ],
        "thread_summary": {
            "title": "Missing fRelayTxes in version message",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Addy Yeow",
                "Mike Hearn",
                "Paul Lyon",
                "Turkey Breast"
            ],
            "messages_count": 12,
            "total_messages_chars_count": 52945
        }
    },
    {
        "title": "[Bitcoin-development] Missing fRelayTxes in version",
        "thread_messages": [
            {
                "author": "Tamas Blummer",
                "date": "2013-06-20T07:30:29",
                "message_text_only": "Hi Mike,\n\nThe issue with the current parser is that those fields are conditionally optional on that there will be no subsequent fields added.\nIf there will be further fields they will become manadory. \n \nWhy not bump the version and parse the fields as mandatory from then on? This would be backward compatible and cleaner\ngoing forward.\n\nTamas Blummer\nhttp://bitsofproof.com\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/3b03828f/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-06-20T07:36:40",
                "message_text_only": "Sure but why not do that when there's an actual new field to add? Does\nanyone have a proposal for a feature that needs a new version field at the\nmoment? There's no point changing the protocol now unless there's actually\na new field to add.\n\nAnyway I still don't see why anyone cares about this issue. The Bitcoin\nprotocol does not and never has required that all messages have a fixed\nnumber of fields per version. Any parser written on the assumption it did\nwas just buggy. Look at how tx messages are relayed for the most obvious\nexample of that pattern in action - it's actually the raw byte stream\nthat's stored and relayed to ensure that fields added in new versions\naren't dropped during round-tripping. Old versions are supposed to preserve\nfields from the future.\n\n\n\nOn Thu, Jun 20, 2013 at 9:30 AM, Tamas Blummer <tamas at bitsofproof.com>wrote:\n\n> Hi Mike,\n>\n> The issue with the current parser is that those fields are conditionally\n> optional on that there will be no subsequent fields added.\n> If there will be further fields they will become manadory.\n>\n> Why not bump the version and parse the fields as mandatory from then on?\n> This would be backward compatible and cleaner\n> going forward.\n>\n> Tamas Blummer\n> http://bitsofproof.com\n>  <http://bitsofproof.com/>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/750bf247/attachment.html>"
            },
            {
                "author": "Tamas Blummer",
                "date": "2013-06-20T08:17:04",
                "message_text_only": "I agree that this can be deferred until there is an actual new field without any harm. But then remember to update the BIP37 too saying that it is optional only if flag added in BIPXX is not present.\n\nYour argument is that this complexity is already there so why not preserve it. I think eliminating complexity (that has no benefit) strengthens the system.\n\nTam\u00e1s Blummer\nhttp://bitsofproof.com\n\nOn 20.06.2013, at 09:36, Mike Hearn <mike at plan99.net> wrote:\n\n> Sure but why not do that when there's an actual new field to add? Does anyone have a proposal for a feature that needs a new version field at the moment? There's no point changing the protocol now unless there's actually a new field to add.\n> \n> Anyway I still don't see why anyone cares about this issue. The Bitcoin protocol does not and never has required that all messages have a fixed number of fields per version. Any parser written on the assumption it did was just buggy. Look at how tx messages are relayed for the most obvious example of that pattern in action - it's actually the raw byte stream that's stored and relayed to ensure that fields added in new versions aren't dropped during round-tripping. Old versions are supposed to preserve fields from the future.\n> \n> \n> \n> On Thu, Jun 20, 2013 at 9:30 AM, Tamas Blummer <tamas at bitsofproof.com> wrote:\n> Hi Mike,\n> \n> The issue with the current parser is that those fields are conditionally optional on that there will be no subsequent fields added.\n> If there will be further fields they will become manadory. \n>  \n> Why not bump the version and parse the fields as mandatory from then on? This would be backward compatible and cleaner\n> going forward.\n> \n> Tamas Blummer\n> http://bitsofproof.com\n> \n> \n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n> \n> Build for Windows Store.\n> \n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> \n> \n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/b1e7c9e1/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-06-20T08:31:34",
                "message_text_only": "You can't eliminate the complexity (yet), otherwise you wouldn't be able to\ntalk to old nodes. You'll have to wait until versions prior to a particular\nversion are hard-forked off and can be safely dropped at connect time.\n\nThat said the reason I'm being so grumpy about this is that compared to the\ncomplexity in the rest of the system, this is such a trivial and minor\ndetail. It's hardly even worth thinking about. I mean, we have a scripting\nlanguage full of opcodes nobody ever figured out how to use and the\nprotocol uses a mixture of byte orders, so an optional field in the version\nmessage is really not such a big deal :)\n\n\nOn Thu, Jun 20, 2013 at 10:17 AM, Tamas Blummer <tamas at bitsofproof.com>wrote:\n\n> I agree that this can be deferred until there is an actual new field\n> without any harm. But then remember to update the BIP37 too saying that it\n> is optional only if flag added in BIPXX is not present.\n>\n> Your argument is that this complexity is already there so why not preserve\n> it. I think eliminating complexity (that has no benefit) strengthens the\n> system.\n>\n> *Tam\u00e1s Blummer*\n> http://bitsofproof.com\n>  <http://bitsofproof.com/>\n>\n> On 20.06.2013, at 09:36, Mike Hearn <mike at plan99.net> wrote:\n>\n> Sure but why not do that when there's an actual new field to add? Does\n> anyone have a proposal for a feature that needs a new version field at the\n> moment? There's no point changing the protocol now unless there's actually\n> a new field to add.\n>\n> Anyway I still don't see why anyone cares about this issue. The Bitcoin\n> protocol does not and never has required that all messages have a fixed\n> number of fields per version. Any parser written on the assumption it did\n> was just buggy. Look at how tx messages are relayed for the most obvious\n> example of that pattern in action - it's actually the raw byte stream\n> that's stored and relayed to ensure that fields added in new versions\n> aren't dropped during round-tripping. Old versions are supposed to preserve\n> fields from the future.\n>\n>\n>\n> On Thu, Jun 20, 2013 at 9:30 AM, Tamas Blummer <tamas at bitsofproof.com>wrote:\n>\n>>  Hi Mike,\n>>\n>> The issue with the current parser is that those fields are conditionally\n>> optional on that there will be no subsequent fields added.\n>> If there will be further fields they will become manadory.\n>>\n>> Why not bump the version and parse the fields as mandatory from then on?\n>> This would be backward compatible and cleaner\n>> going forward.\n>>\n>> Tamas Blummer\n>> http://bitsofproof.com\n>>  <http://bitsofproof.com/>\n>>\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> This SF.net email is sponsored by Windows:\n>>\n>> Build for Windows Store.\n>>\n>> http://p.sf.net/sfu/windows-dev2dev\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/561ebbf1/attachment.html>"
            },
            {
                "author": "Tamas Blummer",
                "date": "2013-06-20T08:39:10",
                "message_text_only": "Yes it is trivial. I do not think greater complexity in the system should keep us from addressing low complexity issues.\nYou can't blame me or others not trying to simplify scripts, if there is such a headwind simplifying a version message.\nYou are right there is too much fuss about this.\n\nTam\u00e1s Blummer\nFounder, CEO\nhttp://bitsofproof.com\n\nOn 20.06.2013, at 10:31, Mike Hearn <mike at plan99.net> wrote:\n\n> You can't eliminate the complexity (yet), otherwise you wouldn't be able to talk to old nodes. You'll have to wait until versions prior to a particular version are hard-forked off and can be safely dropped at connect time.\n> \n> That said the reason I'm being so grumpy about this is that compared to the complexity in the rest of the system, this is such a trivial and minor detail. It's hardly even worth thinking about. I mean, we have a scripting language full of opcodes nobody ever figured out how to use and the protocol uses a mixture of byte orders, so an optional field in the version message is really not such a big deal :)\n> \n> \n> On Thu, Jun 20, 2013 at 10:17 AM, Tamas Blummer <tamas at bitsofproof.com> wrote:\n> I agree that this can be deferred until there is an actual new field without any harm. But then remember to update the BIP37 too saying that it is optional only if flag added in BIPXX is not present.\n> \n> Your argument is that this complexity is already there so why not preserve it. I think eliminating complexity (that has no benefit) strengthens the system.\n> \n> Tam\u00e1s Blummer\n> http://bitsofproof.com\n> \n> On 20.06.2013, at 09:36, Mike Hearn <mike at plan99.net> wrote:\n> \n>> Sure but why not do that when there's an actual new field to add? Does anyone have a proposal for a feature that needs a new version field at the moment? There's no point changing the protocol now unless there's actually a new field to add.\n>> \n>> Anyway I still don't see why anyone cares about this issue. The Bitcoin protocol does not and never has required that all messages have a fixed number of fields per version. Any parser written on the assumption it did was just buggy. Look at how tx messages are relayed for the most obvious example of that pattern in action - it's actually the raw byte stream that's stored and relayed to ensure that fields added in new versions aren't dropped during round-tripping. Old versions are supposed to preserve fields from the future.\n>> \n>> \n>> \n>> On Thu, Jun 20, 2013 at 9:30 AM, Tamas Blummer <tamas at bitsofproof.com> wrote:\n>> Hi Mike,\n>> \n>> The issue with the current parser is that those fields are conditionally optional on that there will be no subsequent fields added.\n>> If there will be further fields they will become manadory. \n>>  \n>> Why not bump the version and parse the fields as mandatory from then on? This would be backward compatible and cleaner\n>> going forward.\n>> \n>> Tamas Blummer\n>> http://bitsofproof.com\n>> \n>> \n>> ------------------------------------------------------------------------------\n>> This SF.net email is sponsored by Windows:\n>> \n>> Build for Windows Store.\n>> \n>> http://p.sf.net/sfu/windows-dev2dev\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>> \n>> \n> \n> \n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/652c48ba/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2013-06-20T09:06:50",
                "message_text_only": "On Thu, Jun 20, 2013 at 09:36:40AM +0200, Mike Hearn wrote:\n> Sure but why not do that when there's an actual new field to add? Does\n> anyone have a proposal for a feature that needs a new version field at the\n> moment? There's no point changing the protocol now unless there's actually\n> a new field to add.\n> \n> Anyway I still don't see why anyone cares about this issue. The Bitcoin\n> protocol does not and never has required that all messages have a fixed\n> number of fields per version. Any parser written on the assumption it did\n> was just buggy. Look at how tx messages are relayed for the most obvious\n> example of that pattern in action - it's actually the raw byte stream\n> that's stored and relayed to ensure that fields added in new versions\n> aren't dropped during round-tripping. Old versions are supposed to preserve\n> fields from the future.\n\nActually, that is not the same issue. What is being argued for here is that\nthe version in the version message itself should indicate which fields are\npresent, so a parser doesn't need to look at the length of the message. That\nseems like a minor but very reasonable request to me, and it's trivial to do.\nThat doesn't mean that you may receive versions higher than what you know of,\nand thus messages with fields you don't know about. That doesn't matter, you\ncan just ignore them.\n\nI see no problem with raising the protocol version number to indicate\n\"all fields up to fRelayTxes are required, if the announced nVersion is above N\".\nIn fact, I believe (though haven't checked) all previous additions to the version\nmessage were accompanied with a protocol version (then: client version) increase\nas well.\n\n-- \nPieter"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-06-20T09:17:11",
                "message_text_only": "There's no problem, but there's no benefit either. It also locks us in to a\npotentially problematic guarantee - what if in future we want to have, say,\ntwo optional new pieces of data in two different messages. We don't want to\nrequire that if version > X then you have to implement all features up to\nand including that point.\n\nEssentially the number of fields in a message is like a little version\nnumber, just for that message. It adds flexibility to keep it that way, and\nthere's no downside, seeing as that bridge was already crossed and people\nwith parsers that can't handle it need to fix their code anyway.\n\nSo I have a slight preference for keeping things the way they are, it keeps\nthings flexible for future and costs nothing.\n\n\n\nOn Thu, Jun 20, 2013 at 11:06 AM, Pieter Wuille <pieter.wuille at gmail.com>wrote:\n\n> On Thu, Jun 20, 2013 at 09:36:40AM +0200, Mike Hearn wrote:\n> > Sure but why not do that when there's an actual new field to add? Does\n> > anyone have a proposal for a feature that needs a new version field at\n> the\n> > moment? There's no point changing the protocol now unless there's\n> actually\n> > a new field to add.\n> >\n> > Anyway I still don't see why anyone cares about this issue. The Bitcoin\n> > protocol does not and never has required that all messages have a fixed\n> > number of fields per version. Any parser written on the assumption it did\n> > was just buggy. Look at how tx messages are relayed for the most obvious\n> > example of that pattern in action - it's actually the raw byte stream\n> > that's stored and relayed to ensure that fields added in new versions\n> > aren't dropped during round-tripping. Old versions are supposed to\n> preserve\n> > fields from the future.\n>\n> Actually, that is not the same issue. What is being argued for here is that\n> the version in the version message itself should indicate which fields are\n> present, so a parser doesn't need to look at the length of the message.\n> That\n> seems like a minor but very reasonable request to me, and it's trivial to\n> do.\n> That doesn't mean that you may receive versions higher than what you know\n> of,\n> and thus messages with fields you don't know about. That doesn't matter,\n> you\n> can just ignore them.\n>\n> I see no problem with raising the protocol version number to indicate\n> \"all fields up to fRelayTxes are required, if the announced nVersion is\n> above N\".\n> In fact, I believe (though haven't checked) all previous additions to the\n> version\n> message were accompanied with a protocol version (then: client version)\n> increase\n> as well.\n>\n> --\n> Pieter\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/038a834a/attachment.html>"
            },
            {
                "author": "Turkey Breast",
                "date": "2013-06-20T10:37:05",
                "message_text_only": "I don't get why this is such a contentious change?\n\nBefore I was able to use asserts to check the expected length of length of messages per protocol version, I could pass in dumb iterators that just parse the byte stream and I could serialize and deserialize a message to check the parser is correct (in debug mode).\n\nThis 'simple' change causes all that behaviour to be lost. You can no longer just use iterators but must know the remaining length (or if you use std::distance, you can only use specific std containers - not just anything with an iterator and an operator++). You cannot check the deserialization process by serializing the deserialized message and comparing it to the original data (because the bool is always present in the serializer).\n\nIt's a bit stupid you call it buggy code when this behaviour has never been present in Bitcoin. The BIP doesn't introduce any unwanted side-effects and is a trivial reasonable change.\n\nIf you want optional fields then the proper way to do it, is to either set a flag in the Services field of the \"version\" message to indicate different formats for messages (i.e use this template structure for a message, not that one), introduce a new message (if the changes are big), to approve/improve Stefan's BIP 32 for custom services or to have a value in the byte stream indicating which fields are present (maybe a bitfield or so).\n\nUsing a quirk of an implementation is just bad form and sloppy coding. Optional fields should have their own mechanism that allows them to remain as optional fields between protocol version upgrades.\n\n\nThe bitcoind software can probably be improved too, by checking that the length of the version message is consistent for the protocol version given by the connected node. Right now it makes no assumptions based on that which is a mistake (new clients can broadcast older version messages that don't have all the fields required). Probably the software should penalise hosts which do that.\n\nWhat's the big deal to update the protocol version number from 70001 to 70002? It's not like we'll run out of integers. The field has now gone from optional to required now anyway - that's a behaviour change. It'd be good to enforce that. I see this as a bug.\n\n\n\n________________________________\n From: Mike Hearn <mike at plan99.net>\nTo: Pieter Wuille <pieter.wuille at gmail.com> \nCc: Bitcoin Dev <bitcoin-development at lists.sourceforge.net>; Tamas Blummer <tamas at bitsofproof.com> \nSent: Thursday, June 20, 2013 11:17 AM\nSubject: Re: [Bitcoin-development] Missing fRelayTxes in version\n \n\n\nThere's no problem, but there's no benefit either. It also locks us in to a potentially problematic guarantee - what if in future we want to have, say, two optional new pieces of data in two different messages. We don't want to require that if version > X then you have to implement all features up to and including that point.\n\nEssentially the number of fields in a message is like a little version number, just for that message. It adds flexibility to keep it that way, and there's no downside, seeing as that bridge was already crossed and people with parsers that can't handle it need to fix their code anyway.\n\nSo I have a slight preference for keeping things the way they are, it keeps things flexible for future and costs nothing.\n\n\n\n\nOn Thu, Jun 20, 2013 at 11:06 AM, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n\nOn Thu, Jun 20, 2013 at 09:36:40AM +0200, Mike Hearn wrote:\n>> Sure but why not do that when there's an actual new field to add? Does\n>> anyone have a proposal for a feature that needs a new version field at the\n>> moment? There's no point changing the protocol now unless there's actually\n>> a new field to add.\n>>\n>> Anyway I still don't see why anyone cares about this issue. The Bitcoin\n>> protocol does not and never has required that all messages have a fixed\n>> number of fields per version. Any parser written on the assumption it did\n>> was just buggy. Look at how tx messages are relayed for the most obvious\n>> example of that pattern in action - it's actually the raw byte stream\n>> that's stored and relayed to ensure that fields added in new versions\n>> aren't dropped during round-tripping. Old versions are supposed to preserve\n>> fields from the future.\n>\n>Actually, that is not the same issue. What is being argued for here is that\n>the version in the version message itself should indicate which fields are\n>present, so a parser doesn't need to look at the length of the message. That\n>seems like a minor but very reasonable request to me, and it's trivial to do.\n>That doesn't mean that you may receive versions higher than what you know of,\n>and thus messages with fields you don't know about. That doesn't matter, you\n>can just ignore them.\n>\n>I see no problem with raising the protocol version number to indicate\n>\"all fields up to fRelayTxes are required, if the announced nVersion is above N\".\n>In fact, I believe (though haven't checked) all previous additions to the version\n>message were accompanied with a protocol version (then: client version) increase\n>as well.\n>\n>--\n>Pieter\n>\n>\n\n------------------------------------------------------------------------------\nThis SF.net email is sponsored by Windows:\n\nBuild for Windows Store.\n\nhttp://p.sf.net/sfu/windows-dev2dev\n_______________________________________________\nBitcoin-development mailing list\nBitcoin-development at lists.sourceforge.net\nhttps://lists.sourceforge.net/lists/listinfo/bitcoin-development\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/0b45aac2/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-06-20T10:50:28",
                "message_text_only": "Sure, the issue isn't running out of integers, it's that you have to handle\nthe case of truncated messages whether you like it or not so it doesn't add\nany simplicity. Even if Bitcoin-Qt starts only sending the new field with a\nnew version number, there are tens of thousands of bitcoinj based wallets\nout there now that send the current version number and the fRelayTx field\nas well, so you cannot assume anything about whether the field will exist\nor not based on the version number regardless of what is changed on the C++\nside. Assuming you care about your code being able to serve Bloom-filtering\nclients of course.\n\nWith regards to relying on quirks, etc, this is the old \"is the protocol\ndefined by Satoshi's code\" debate again ... as I said, version messages\nhave always had a variable number of fields. You didn't notice before\nbecause it was a long time since any fields were added. Perhaps it's indeed\nnot ideal, perhaps if Bitcoin was designed in 2013 it'd be using protobufs\nor some other pre-packaged serialization system. But it is what it is.\n\n\n\nOn Thu, Jun 20, 2013 at 12:37 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:\n\n> I don't get why this is such a contentious change?\n>\n> Before I was able to use asserts to check the expected length of length of\n> messages per protocol version, I could pass in dumb iterators that just\n> parse the byte stream and I could serialize and deserialize a message to\n> check the parser is correct (in debug mode).\n>\n> This 'simple' change causes all that behaviour to be lost. You can no\n> longer just use iterators but must know the remaining length (or if you use\n> std::distance, you can only use specific std containers - not just anything\n> with an iterator and an operator++). You cannot check the deserialization\n> process by serializing the deserialized message and comparing it to the\n> original data (because the bool is always present in the serializer).\n>\n> It's a bit stupid you call it buggy code when this behaviour has never\n> been present in Bitcoin. The BIP doesn't introduce any unwanted\n> side-effects and is a trivial reasonable change.\n>\n> If you want optional fields then the proper way to do it, is to either set\n> a flag in the Services field of the \"version\" message to indicate different\n> formats for messages (i.e use this template structure for a message, not\n> that one), introduce a new message (if the changes are big), to\n> approve/improve Stefan's BIP 32 for custom services or to have a value in\n> the byte stream indicating which fields are present (maybe a bitfield or\n> so).\n>\n> Using a quirk of an implementation is just bad form and sloppy coding.\n> Optional fields should have their own mechanism that allows them to remain\n> as optional fields between protocol version upgrades.\n>\n> The bitcoind software can probably be improved too, by checking that the\n> length of the version message is consistent for the protocol version given\n> by the connected node. Right now it makes no assumptions based on that\n> which is a mistake (new clients can broadcast older version messages that\n> don't have all the fields required). Probably the software should penalise\n> hosts which do that.\n>\n> What's the big deal to update the protocol version number from 70001 to\n> 70002? It's not like we'll run out of integers. The field has now gone from\n> optional to required now anyway - that's a behaviour change. It'd be good\n> to enforce that. I see this as a bug.\n>\n>   ------------------------------\n>  *From:* Mike Hearn <mike at plan99.net>\n> *To:* Pieter Wuille <pieter.wuille at gmail.com>\n> *Cc:* Bitcoin Dev <bitcoin-development at lists.sourceforge.net>; Tamas\n> Blummer <tamas at bitsofproof.com>\n> *Sent:* Thursday, June 20, 2013 11:17 AM\n> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version\n>\n> There's no problem, but there's no benefit either. It also locks us in to\n> a potentially problematic guarantee - what if in future we want to have,\n> say, two optional new pieces of data in two different messages. We don't\n> want to require that if version > X then you have to implement all features\n> up to and including that point.\n>\n> Essentially the number of fields in a message is like a little version\n> number, just for that message. It adds flexibility to keep it that way, and\n> there's no downside, seeing as that bridge was already crossed and people\n> with parsers that can't handle it need to fix their code anyway.\n>\n> So I have a slight preference for keeping things the way they are, it\n> keeps things flexible for future and costs nothing.\n>\n>\n>\n> On Thu, Jun 20, 2013 at 11:06 AM, Pieter Wuille <pieter.wuille at gmail.com>wrote:\n>\n> On Thu, Jun 20, 2013 at 09:36:40AM +0200, Mike Hearn wrote:\n> > Sure but why not do that when there's an actual new field to add? Does\n> > anyone have a proposal for a feature that needs a new version field at\n> the\n> > moment? There's no point changing the protocol now unless there's\n> actually\n> > a new field to add.\n> >\n> > Anyway I still don't see why anyone cares about this issue. The Bitcoin\n> > protocol does not and never has required that all messages have a fixed\n> > number of fields per version. Any parser written on the assumption it did\n> > was just buggy. Look at how tx messages are relayed for the most obvious\n> > example of that pattern in action - it's actually the raw byte stream\n> > that's stored and relayed to ensure that fields added in new versions\n> > aren't dropped during round-tripping. Old versions are supposed to\n> preserve\n> > fields from the future.\n>\n> Actually, that is not the same issue. What is being argued for here is that\n> the version in the version message itself should indicate which fields are\n> present, so a parser doesn't need to look at the length of the message.\n> That\n> seems like a minor but very reasonable request to me, and it's trivial to\n> do.\n> That doesn't mean that you may receive versions higher than what you know\n> of,\n> and thus messages with fields you don't know about. That doesn't matter,\n> you\n> can just ignore them.\n>\n> I see no problem with raising the protocol version number to indicate\n> \"all fields up to fRelayTxes are required, if the announced nVersion is\n> above N\".\n> In fact, I believe (though haven't checked) all previous additions to the\n> version\n> message were accompanied with a protocol version (then: client version)\n> increase\n> as well.\n>\n> --\n> Pieter\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/3bc5a976/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2013-06-20T10:52:51",
                "message_text_only": "Let's just increase the version number and be done with this discussion.\nIt's a small benefit, but it simplifies things and it's trivial to do.\n\nI don't understand how a policy of requiring version increases could limit\nfuture extensions: after the version/verack exchange, the protocol version\nis negotiated between peers, and there is no need for anything optional\nanymore.\n\nNote thay this is just about parsing, not about relaying - you should still\nrelay parts of a message you haven't parsed. But that doesn't apply to the\nversion message anyway, which is the only place where this matters.\n\n-- \nPieter\n On 20 Jun 2013 12:38, \"Turkey Breast\" <turkeybreast at yahoo.com> wrote:\n\n> I don't get why this is such a contentious change?\n>\n> Before I was able to use asserts to check the expected length of length of\n> messages per protocol version, I could pass in dumb iterators that just\n> parse the byte stream and I could serialize and deserialize a message to\n> check the parser is correct (in debug mode).\n>\n> This 'simple' change causes all that behaviour to be lost. You can no\n> longer just use iterators but must know the remaining length (or if you use\n> std::distance, you can only use specific std containers - not just anything\n> with an iterator and an operator++). You cannot check the deserialization\n> process by serializing the deserialized message and comparing it to the\n> original data (because the bool is always present in the serializer).\n>\n> It's a bit stupid you call it buggy code when this behaviour has never\n> been present in Bitcoin. The BIP doesn't introduce any unwanted\n> side-effects and is a trivial reasonable change.\n>\n> If you want optional fields then the proper way to do it, is to either set\n> a flag in the Services field of the \"version\" message to indicate different\n> formats for messages (i.e use this template structure for a message, not\n> that one), introduce a new message (if the changes are big), to\n> approve/improve Stefan's BIP 32 for custom services or to have a value in\n> the byte stream indicating which fields are present (maybe a bitfield or\n> so).\n>\n> Using a quirk of an implementation is just bad form and sloppy coding.\n> Optional fields should have their own mechanism that allows them to remain\n> as optional fields between protocol version upgrades.\n>\n> The bitcoind software can probably be improved too, by checking that the\n> length of the version message is consistent for the protocol version given\n> by the connected node. Right now it makes no assumptions based on that\n> which is a mistake (new clients can broadcast older version messages that\n> don't have all the fields required). Probably the software should penalise\n> hosts which do that.\n>\n> What's the big deal to update the protocol version number from 70001 to\n> 70002? It's not like we'll run out of integers. The field has now gone from\n> optional to required now anyway - that's a behaviour change. It'd be good\n> to enforce that. I see this as a bug.\n>\n>   ------------------------------\n>  *From:* Mike Hearn <mike at plan99.net>\n> *To:* Pieter Wuille <pieter.wuille at gmail.com>\n> *Cc:* Bitcoin Dev <bitcoin-development at lists.sourceforge.net>; Tamas\n> Blummer <tamas at bitsofproof.com>\n> *Sent:* Thursday, June 20, 2013 11:17 AM\n> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version\n>\n> There's no problem, but there's no benefit either. It also locks us in to\n> a potentially problematic guarantee - what if in future we want to have,\n> say, two optional new pieces of data in two different messages. We don't\n> want to require that if version > X then you have to implement all features\n> up to and including that point.\n>\n> Essentially the number of fields in a message is like a little version\n> number, just for that message. It adds flexibility to keep it that way, and\n> there's no downside, seeing as that bridge was already crossed and people\n> with parsers that can't handle it need to fix their code anyway.\n>\n> So I have a slight preference for keeping things the way they are, it\n> keeps things flexible for future and costs nothing.\n>\n>\n>\n> On Thu, Jun 20, 2013 at 11:06 AM, Pieter Wuille <pieter.wuille at gmail.com>wrote:\n>\n> On Thu, Jun 20, 2013 at 09:36:40AM +0200, Mike Hearn wrote:\n> > Sure but why not do that when there's an actual new field to add? Does\n> > anyone have a proposal for a feature that needs a new version field at\n> the\n> > moment? There's no point changing the protocol now unless there's\n> actually\n> > a new field to add.\n> >\n> > Anyway I still don't see why anyone cares about this issue. The Bitcoin\n> > protocol does not and never has required that all messages have a fixed\n> > number of fields per version. Any parser written on the assumption it did\n> > was just buggy. Look at how tx messages are relayed for the most obvious\n> > example of that pattern in action - it's actually the raw byte stream\n> > that's stored and relayed to ensure that fields added in new versions\n> > aren't dropped during round-tripping. Old versions are supposed to\n> preserve\n> > fields from the future.\n>\n> Actually, that is not the same issue. What is being argued for here is that\n> the version in the version message itself should indicate which fields are\n> present, so a parser doesn't need to look at the length of the message.\n> That\n> seems like a minor but very reasonable request to me, and it's trivial to\n> do.\n> That doesn't mean that you may receive versions higher than what you know\n> of,\n> and thus messages with fields you don't know about. That doesn't matter,\n> you\n> can just ignore them.\n>\n> I see no problem with raising the protocol version number to indicate\n> \"all fields up to fRelayTxes are required, if the announced nVersion is\n> above N\".\n> In fact, I believe (though haven't checked) all previous additions to the\n> version\n> message were accompanied with a protocol version (then: client version)\n> increase\n> as well.\n>\n> --\n> Pieter\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/de57996b/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-06-20T10:58:31",
                "message_text_only": "As I said, there's no benefit. Even if we do that on the C++ side, you\nstill have to handle connections from bitcoinj clients which will send the\nfield with the old version number. You can't assume they'll all be updated\nsimultaneously, even though both the Android app and MultiBit do have\nupdate notifications these days and eventually old versions will presumably\ndisappear.\n\nRe: flexibility. Let's say version V+1 adds a complicated new set of data\nto some messages. Not every client wants or needs the feature enabled by\nthem.\n\nNow version V+2 adds a simple extension to a basic message that everyone\nwants/needs.\n\nTo get the latter feature, all clients now have to support the first\nfeature as well because the version number is monotonic.\n\nOK, we can use a service bit to handle these cases, if we anticipate that\nnot all clients will want the first feature. But then again, we can also\nuse the presence of the additional data as the ground truth instead of\nduplicating that fact. I don't really mind either way. It just seems that\nparsing always requires you to be able to handle truncated messages anyway\n(without asserting or crashing), because a bogus client can always send you\npartial data. So I don't see what effort is saved.\n\n\n\nOn Thu, Jun 20, 2013 at 12:52 PM, Pieter Wuille <pieter.wuille at gmail.com>wrote:\n\n> Let's just increase the version number and be done with this discussion.\n> It's a small benefit, but it simplifies things and it's trivial to do.\n>\n> I don't understand how a policy of requiring version increases could limit\n> future extensions: after the version/verack exchange, the protocol version\n> is negotiated between peers, and there is no need for anything optional\n> anymore.\n>\n> Note thay this is just about parsing, not about relaying - you should\n> still relay parts of a message you haven't parsed. But that doesn't apply\n> to the version message anyway, which is the only place where this matters.\n>\n> --\n> Pieter\n>  On 20 Jun 2013 12:38, \"Turkey Breast\" <turkeybreast at yahoo.com> wrote:\n>\n>> I don't get why this is such a contentious change?\n>>\n>> Before I was able to use asserts to check the expected length of length\n>> of messages per protocol version, I could pass in dumb iterators that just\n>> parse the byte stream and I could serialize and deserialize a message to\n>> check the parser is correct (in debug mode).\n>>\n>> This 'simple' change causes all that behaviour to be lost. You can no\n>> longer just use iterators but must know the remaining length (or if you use\n>> std::distance, you can only use specific std containers - not just anything\n>> with an iterator and an operator++). You cannot check the deserialization\n>> process by serializing the deserialized message and comparing it to the\n>> original data (because the bool is always present in the serializer).\n>>\n>> It's a bit stupid you call it buggy code when this behaviour has never\n>> been present in Bitcoin. The BIP doesn't introduce any unwanted\n>> side-effects and is a trivial reasonable change.\n>>\n>> If you want optional fields then the proper way to do it, is to either\n>> set a flag in the Services field of the \"version\" message to indicate\n>> different formats for messages (i.e use this template structure for a\n>> message, not that one), introduce a new message (if the changes are big),\n>> to approve/improve Stefan's BIP 32 for custom services or to have a value\n>> in the byte stream indicating which fields are present (maybe a bitfield or\n>> so).\n>>\n>> Using a quirk of an implementation is just bad form and sloppy coding.\n>> Optional fields should have their own mechanism that allows them to remain\n>> as optional fields between protocol version upgrades.\n>>\n>> The bitcoind software can probably be improved too, by checking that the\n>> length of the version message is consistent for the protocol version given\n>> by the connected node. Right now it makes no assumptions based on that\n>> which is a mistake (new clients can broadcast older version messages that\n>> don't have all the fields required). Probably the software should penalise\n>> hosts which do that.\n>>\n>> What's the big deal to update the protocol version number from 70001 to\n>> 70002? It's not like we'll run out of integers. The field has now gone from\n>> optional to required now anyway - that's a behaviour change. It'd be good\n>> to enforce that. I see this as a bug.\n>>\n>>   ------------------------------\n>>  *From:* Mike Hearn <mike at plan99.net>\n>> *To:* Pieter Wuille <pieter.wuille at gmail.com>\n>> *Cc:* Bitcoin Dev <bitcoin-development at lists.sourceforge.net>; Tamas\n>> Blummer <tamas at bitsofproof.com>\n>> *Sent:* Thursday, June 20, 2013 11:17 AM\n>> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version\n>>\n>> There's no problem, but there's no benefit either. It also locks us in to\n>> a potentially problematic guarantee - what if in future we want to have,\n>> say, two optional new pieces of data in two different messages. We don't\n>> want to require that if version > X then you have to implement all features\n>> up to and including that point.\n>>\n>> Essentially the number of fields in a message is like a little version\n>> number, just for that message. It adds flexibility to keep it that way, and\n>> there's no downside, seeing as that bridge was already crossed and people\n>> with parsers that can't handle it need to fix their code anyway.\n>>\n>> So I have a slight preference for keeping things the way they are, it\n>> keeps things flexible for future and costs nothing.\n>>\n>>\n>>\n>> On Thu, Jun 20, 2013 at 11:06 AM, Pieter Wuille <pieter.wuille at gmail.com>wrote:\n>>\n>> On Thu, Jun 20, 2013 at 09:36:40AM +0200, Mike Hearn wrote:\n>> > Sure but why not do that when there's an actual new field to add? Does\n>> > anyone have a proposal for a feature that needs a new version field at\n>> the\n>> > moment? There's no point changing the protocol now unless there's\n>> actually\n>> > a new field to add.\n>> >\n>> > Anyway I still don't see why anyone cares about this issue. The Bitcoin\n>> > protocol does not and never has required that all messages have a fixed\n>> > number of fields per version. Any parser written on the assumption it\n>> did\n>> > was just buggy. Look at how tx messages are relayed for the most obvious\n>> > example of that pattern in action - it's actually the raw byte stream\n>> > that's stored and relayed to ensure that fields added in new versions\n>> > aren't dropped during round-tripping. Old versions are supposed to\n>> preserve\n>> > fields from the future.\n>>\n>> Actually, that is not the same issue. What is being argued for here is\n>> that\n>> the version in the version message itself should indicate which fields are\n>> present, so a parser doesn't need to look at the length of the message.\n>> That\n>> seems like a minor but very reasonable request to me, and it's trivial to\n>> do.\n>> That doesn't mean that you may receive versions higher than what you know\n>> of,\n>> and thus messages with fields you don't know about. That doesn't matter,\n>> you\n>> can just ignore them.\n>>\n>> I see no problem with raising the protocol version number to indicate\n>> \"all fields up to fRelayTxes are required, if the announced nVersion is\n>> above N\".\n>> In fact, I believe (though haven't checked) all previous additions to the\n>> version\n>> message were accompanied with a protocol version (then: client version)\n>> increase\n>> as well.\n>>\n>> --\n>> Pieter\n>>\n>>\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> This SF.net email is sponsored by Windows:\n>>\n>> Build for Windows Store.\n>>\n>> http://p.sf.net/sfu/windows-dev2dev\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>>\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> This SF.net email is sponsored by Windows:\n>>\n>> Build for Windows Store.\n>>\n>> http://p.sf.net/sfu/windows-dev2dev\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/64e336a0/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Missing fRelayTxes in version",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Mike Hearn",
                "Tamas Blummer",
                "Turkey Breast",
                "Pieter Wuille"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 44742
        }
    },
    {
        "title": "[Bitcoin-development] CTxIn::nSequence",
        "thread_messages": [
            {
                "author": "Marko Otbalkana",
                "date": "2013-06-21T00:54:38",
                "message_text_only": "Could anyone tell me what CTxIn::nSequence is meant for?\n\nBest Regards,\n-Marko\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/55f82c57/attachment.html>"
            },
            {
                "author": "Patrick Strateman",
                "date": "2013-06-21T04:03:58",
                "message_text_only": "It's well answered by this stack exchange question.\n\nhttp://bitcoin.stackexchange.com/questions/2025/what-is-txins-sequence\n\nOn 06/20/2013 05:54 PM, Marko Otbalkana wrote:\n> Could anyone tell me what CTxIn::nSequence is meant for?\n>\n> Best Regards,\n> -Marko\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/1e2140bf/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-06-21T08:20:06",
                "message_text_only": "Indeed, and for a higher level answer, see here:\n\nhttps://en.bitcoin.it/wiki/Contracts\n\n\nOn Fri, Jun 21, 2013 at 6:03 AM, Patrick Strateman\n<patrick at intersango.com>wrote:\n\n>  It's well answered by this stack exchange question.\n>\n> http://bitcoin.stackexchange.com/questions/2025/what-is-txins-sequence\n>\n>\n> On 06/20/2013 05:54 PM, Marko Otbalkana wrote:\n>\n>  Could anyone tell me what CTxIn::nSequence is meant for?\n>\n>  Best Regards,\n>  -Marko\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n> http://p.sf.net/sfu/windows-dev2dev\n>\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing listBitcoin-development at lists.sourceforge.nethttps://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130621/dfa4b5a4/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "CTxIn::nSequence",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Mike Hearn",
                "Marko Otbalkana",
                "Patrick Strateman"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 2537
        }
    },
    {
        "title": "[Bitcoin-development] Standard public key base58-check address prefix?",
        "thread_messages": [
            {
                "author": "Nadav Ivgi",
                "date": "2013-06-21T20:15:55",
                "message_text_only": "I'm working on a project that requires users to exchange public keys (for\nmultisig transactions).\n\nIt seems that hex encoding is usually used to display public keys (i.e. in\nbitaddress and brainwallet), which results in longer strings and lacks the\n4-bytes verification.\n\nA standard way to encode public keys as base58-check addresses would make\nit easier and safer to display and exchange public keys. All that is really\nneeded is deciding on a prefix byte.\n\nPerhaps we can use 0x37/0x38, which results in the letter P (for \"Public\")?\nIt seems like those bytes aren't used for anything yet.\n\nThanks,\nNadav\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130621/bcb99d60/attachment.html>"
            },
            {
                "author": "Nadav Ivgi",
                "date": "2013-06-21T20:25:59",
                "message_text_only": "I'm working on a project that requires users to exchange public keys (for\nmultisig transactions).\n\nIt seems that hex encoding is usually used to display public keys (i.e. in\nbitaddress and brainwallet), which results in longer strings and lacks the\n4-bytes verification.\n\nA standard way to encode public keys as base58-check addresses would make\nit easier and safer to display and exchange public keys. All that is really\nneeded is deciding on a prefix byte.\n\nPerhaps we can use 0x37/0x38, which results in the letter P (for \"Public\")?\nIt seems like those bytes aren't used for anything yet.\n\nThanks,\nNadav\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130621/b811ebcb/attachment.html>"
            },
            {
                "author": "Nadav Ivgi",
                "date": "2013-06-21T20:41:25",
                "message_text_only": "Just a small clarification: I was referring to the actual public key,\nand not the hash160 of it used for Bitcoin addresses. Its usually not\nused, but it is needed for multisig transaction.\n\nOn Fri, Jun 21, 2013 at 11:25 PM, Nadav Ivgi <nadav at shesek.info> wrote:\n> I'm working on a project that requires users to exchange public keys (for\n> multisig transactions).\n>\n> It seems that hex encoding is usually used to display public keys (i.e. in\n> bitaddress and brainwallet), which results in longer strings and lacks the\n> 4-bytes verification.\n>\n> A standard way to encode public keys as base58-check addresses would make it\n> easier and safer to display and exchange public keys. All that is really\n> needed is deciding on a prefix byte.\n>\n> Perhaps we can use 0x37/0x38, which results in the letter P (for \"Public\")?\n> It seems like those bytes aren't used for anything yet.\n>\n> Thanks,\n> Nadav"
            }
        ],
        "thread_summary": {
            "title": "Standard public key base58-check address prefix?",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Nadav Ivgi"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 2477
        }
    },
    {
        "title": "[Bitcoin-development] bitcoind and C++ namespaces?",
        "thread_messages": [
            {
                "author": "Jeff Garzik",
                "date": "2013-06-22T19:28:54",
                "message_text_only": "Slowly warming to C++ namespaces.  How about starting small, and\nwrapping most stuff inside a bitcoin namespace?  Bike shedding can be\ndone at any point; the main idea is to start small, and gain\nexperience.\n\n-- \nJeff Garzik\nSenior Software Engineer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            }
        ],
        "thread_summary": {
            "title": "bitcoind and C++ namespaces?",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 314
        }
    },
    {
        "title": "[Bitcoin-development] Bitcoin-Qt/bitcoind version 0.8.3 released",
        "thread_messages": [
            {
                "author": "Gavin Andresen",
                "date": "2013-06-25T17:57:15",
                "message_text_only": "Bitcoin-Qt version 0.8.3 is now available from:\n  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.8.3/\n\nThis is a maintenance release to fix a denial-of-service attack that\ncan cause nodes to crash.\n\nPlease report bugs using the issue tracker at github:\n  https://github.com/bitcoin/bitcoin/issues\n\n0.8.3 Release notes\n===================\n\nTruncate over-size messages to prevent a memory exhaustion attack.\n\nFix a regression that causes excessive re-writing of the 'peers.dat' file.\n\n\n===================\n\nThanks to Peter Todd for responsibly disclosing the vulnerability\n( CVE-2013-4627 ) and creating a fix."
            },
            {
                "author": "Jesus Cea",
                "date": "2013-06-25T23:13:25",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nOn 25/06/13 19:57, Gavin Andresen wrote:\n> Bitcoin-Qt version 0.8.3 is now available from: \n> http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.8.3/\n\nThe\n> \n\"splash\" banner shows \"0.8.3-BETA\".\n\n- -- \nJes\u00fas Cea Avi\u00f3n                         _/_/      _/_/_/        _/_/_/\njcea at jcea.es - http://www.jcea.es/     _/_/    _/_/  _/_/    _/_/  _/_/\nTwitter: @jcea                        _/_/    _/_/          _/_/_/_/_/\njabber / xmpp:jcea at jabber.org  _/_/  _/_/    _/_/          _/_/  _/_/\n\"Things are not so easy\"      _/_/  _/_/    _/_/  _/_/    _/_/  _/_/\n\"My name is Dump, Core Dump\"   _/_/_/        _/_/_/      _/_/  _/_/\n\"El amor es poner tu felicidad en la felicidad de otro\" - Leibniz\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.10 (GNU/Linux)\nComment: Using GnuPG with Thunderbird - http://www.enigmail.net/\n\niQCVAwUBUcokFZlgi5GaxT1NAQJ+HQP7Bs387bwW6sXrOx98Y2bkQBJfciaS/eyD\nHvHho9xfoOcaCwuigh2lI78i2vxoVUa30sM0m/g4+isyJZDVLpbUENhy3bx0MAD/\n4YAjJXdwScDI15m6xvAf706BDst2kXcWw/pudZQiX4Kw9YEs7rUWvdPS5BE6PXbK\nQyCcBcrH7fo=\n=+cZD\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Pieter Wuille",
                "date": "2013-06-25T23:34:41",
                "message_text_only": "On Wed, Jun 26, 2013 at 01:13:25AM +0200, Jesus Cea wrote:\n> \"splash\" banner shows \"0.8.3-BETA\".\n\nJust like every release ever, and probably until we reach 1.0.\n\n-- \nPieter"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin-Qt/bitcoind version 0.8.3 released",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Pieter Wuille",
                "Jesus Cea",
                "Gavin Andresen"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 1923
        }
    },
    {
        "title": "[Bitcoin-development] Double-Spending Fast Payments in Bitcoin due to Client versions 0.8.1",
        "thread_messages": [
            {
                "author": "Arthur Gervais",
                "date": "2013-06-27T10:23:34",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nDear Bitcoin developers,\n\nWe would like to report a vulnerability which might lead, under some\nassumptions, to a double-spending attack in a fast payment scenario.\nThe vulnerability has been introduced due to signature encoding\nincompatibilities between versions 0.8.2 (or 0.8.3) and earlier\nBitcoin versions.\n\nPlease find at the following link a detailed description of this\nvulnerability:\nftp://ftp.inf.ethz.ch/pub/publications/tech-reports/7xx/789.pdf\n\nWe contacted and informed Gavin earlier about this problem.\n\nWith best regards,\nArthur Gervais\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG/MacGPG2 v2.0.18 (Darwin)\nComment: GPGTools - http://gpgtools.org\n\niQEcBAEBAgAGBQJRzBKLAAoJEI2AYXeasI8/eNYH/2b45o8JPjuiOXeE0MgiYO4g\nHgGorNBvH3hLlSZkGh/7GxeGWi3tiEq8DKAgqFd8p+1Ay4YVHK86jJMBxAc8lzpx\nTqS6Szrhlx7slamMGhjeem4BJ2RmfVqSRQjidYxwdee8bMQRVH5DiBzndpZwCeHa\nAvlP8ojTUFozOJs5PvjEqE+sDKDe5nDC96uiZyMROK8neoiLZpJzV3+ScTUjLCeB\nzg34wttX80WKpkXJFvq88FTIvO5E42NGP3APnt2J/HZcey4Mi9UIhLt+/TJ7Z07l\nHuxFlzyXdCgRkJWvU13yn8bUP0cbeoox6Cwn7rDAIisVLn4KB9XPThPjfJbKEkg=\n=Y6bs\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2013-06-27T11:04:06",
                "message_text_only": "On Thu, Jun 27, 2013 at 3:23 AM, Arthur Gervais\n<arthur.gervais at inf.ethz.ch> wrote:\n> -----BEGIN PGP SIGNED MESSAGE-----\n> Hash: SHA1\n>\n> Dear Bitcoin developers,\n>\n> We would like to report a vulnerability which might lead, under some\n> assumptions, to a double-spending attack in a fast payment scenario.\n> The vulnerability has been introduced due to signature encoding\n> incompatibilities between versions 0.8.2 (or 0.8.3) and earlier\n> Bitcoin versions.\n>\n> Please find at the following link a detailed description of this\n> vulnerability:\n> ftp://ftp.inf.ethz.ch/pub/publications/tech-reports/7xx/789.pdf\n\nIt would be kind if your paper cited the one of the prior discussions\nof this transaction pattern:\n\nE.g. https://bitcointalk.org/index.php?topic=196990.msg2048297#msg2048297\n(I think there are a couple others)\n\nThe family of transaction patterns you describe is one of the ones I\nspecifically cite as an example of why taking non-reversible actions\non unconfirmed transactions is unsafe (and why most of the Bitcoin\ncommunity resources) council the same.  You can get similar patterns\nabsent changes in the IsStandard rule through a number of other means.\n One obvious one is through concurrent announcement: You announce\nconflicting transactions at the same time to many nodes and one\nexcludes another.  By performing this many times and using chains of\nunconfirmed transactions and seeing which family your victim observes\nyou can create input mixes that are only accepted by very specific\nsubsets of the network."
            },
            {
                "author": "Arthur Gervais",
                "date": "2013-06-27T16:03:37",
                "message_text_only": "On 6/27/13 1:04 PM, Gregory Maxwell wrote:\n> On Thu, Jun 27, 2013 at 3:23 AM, Arthur Gervais\n> <arthur.gervais at inf.ethz.ch> wrote:\n>> -----BEGIN PGP SIGNED MESSAGE-----\n>> Hash: SHA1\n>>\n>> Dear Bitcoin developers,\n>>\n>> We would like to report a vulnerability which might lead, under some\n>> assumptions, to a double-spending attack in a fast payment scenario.\n>> The vulnerability has been introduced due to signature encoding\n>> incompatibilities between versions 0.8.2 (or 0.8.3) and earlier\n>> Bitcoin versions.\n>>\n>> Please find at the following link a detailed description of this\n>> vulnerability:\n>> ftp://ftp.inf.ethz.ch/pub/publications/tech-reports/7xx/789.pdf\n> \n> It would be kind if your paper cited the one of the prior discussions\n> of this transaction pattern:\n> \n> E.g. https://bitcointalk.org/index.php?topic=196990.msg2048297#msg2048297\n> (I think there are a couple others)\n> \n> The family of transaction patterns you describe is one of the ones I\n> specifically cite as an example of why taking non-reversible actions\n> on unconfirmed transactions is unsafe (and why most of the Bitcoin\n> community resources) council the same.  You can get similar patterns\n> absent changes in the IsStandard rule through a number of other means.\n>  One obvious one is through concurrent announcement: You announce\n> conflicting transactions at the same time to many nodes and one\n> excludes another.  By performing this many times and using chains of\n> unconfirmed transactions and seeing which family your victim observes\n> you can create input mixes that are only accepted by very specific\n> subsets of the network.\n> \n\nThank you for the reference! This is indeed a very interesting issue,\naffecting the same Bitcoin version. However we think it is\ncomplementary, since our reported problem has nothing to do with fees,\ndust, nor is it necessary to send the two double-spending transaction at\nthe same time. In our setting, double-spending still works if the second\ntransaction is sent after minutes (and the first transaction has not yet\nbeen included into a block).\n\nClearly, we have outlined the limits of the security of\nzero-confirmation payments in an earlier work.\n\nOur only intention is to raise the awareness for merchants who have to\naccept zero-confirmation transactions. They should be aware of the\nsignature encoding difference between Bitcoin versions and the possible\nconsequences."
            },
            {
                "author": "Gregory Maxwell",
                "date": "2013-06-27T16:13:58",
                "message_text_only": "On Thu, Jun 27, 2013 at 9:03 AM, Arthur Gervais\n<arthur.gervais at inf.ethz.ch> wrote:\n> affecting the same Bitcoin version. However we think it is\n> complementary, since our reported problem has nothing to do with fees,\n> dust, nor is it necessary to send the two double-spending transaction at\n> the same time. In our setting, double-spending still works if the second\n> transaction is sent after minutes (and the first transaction has not yet\n> been included into a block).\n\nIt works just the same for dust based or any other criteria that makes\ntransactions non-standard\u2014 including the double spending working if\nthe second transaction is sent minutes after. Exactly the same code is\nexecuted and the same behavior observed for any case of a non-standard\ntransaction being used to achieve inconsistent forwarding.\n\n> Our only intention is to raise the awareness for merchants who have to\n> accept zero-confirmation transactions.\n\nThat is great and I'm certainly glad to see people doing that.\n\nThough take care it that your focus on signature encoding differences\ndoesn't create a misunderstanding. This isn't only an issue with these\nparticular versions: There is always mining and relay behavior\ninhomogeneity in the network. The level of inhomogeneity changes over\ntime\u2014 I believe its greatest when new reference client software that\nchanges IsStandard but it is never zero as there are large miners with\ncustomized acceptance rules (also mempool state also creates\ninhomogeneity). The greater inhomogeneity results in higher success\nrates which may be important since some service could conceivable only\nbe profitable exploited with a high enough success rate."
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-06-27T16:16:04",
                "message_text_only": "On Thu, Jun 27, 2013 at 12:03 PM, Arthur Gervais\n<arthur.gervais at inf.ethz.ch> wrote:\n> Our only intention is to raise the awareness for merchants who have to\n> accept zero-confirmation transactions. They should be aware of the\n> signature encoding difference between Bitcoin versions and the possible\n> consequences.\n\nCertainly.  Though given current P2P network node version\ndistributions, it is increasing difficult to relay the older version\nof transaction, and will only become more so in the future.\n\nIt also remains the case that merchants who accept zero confirmation\ntransactions are likely already aware of the risk level, and make a\nbusiness decision.  One can see tiny digital downloads often at zero\nconfirmation, but rarely a Porsche or house or bitcoin exchange\ndeposit.\n\n-- \nJeff Garzik\nSenior Software Engineer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            }
        ],
        "thread_summary": {
            "title": "Double-Spending Fast Payments in Bitcoin due to Client versions 0.8.1",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Arthur Gervais",
                "Gregory Maxwell",
                "Jeff Garzik"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 7632
        }
    },
    {
        "title": "[Bitcoin-development] [ANN] Micropayment Channel Implementation",
        "thread_messages": [
            {
                "author": "bitcoin-list at bluematt.me",
                "date": "2013-06-27T12:29:30",
                "message_text_only": "As of today, a full implementation of micropayment channels has been merged\nonto bitcoinj's master branch (to be released in the next version). It is\ndesigned to make it easy for users to create payment channel servers and\nclients based on the design at\nhttps://en.bitcoin.it/wiki/Contracts#Example_7:_Rapidly-adjusted_.28micro.29payments_to_a_pre-determined_party,\nby creating a simple TCP socket and exchanging protobufs to initialize and\nmake payments.\n\nIt supports various levels of abstractions, allowing users to drive the\nstate machines which do basic channel init/verification themselves, allow\nbitcoinj to handle all the complexity of channel management/expiry/etc and\nsimply exchange protobufs over whatever whatever connection they wish to\nmake with the server, or let bitcoinj handle opening a TCP socket and do\nall the work. See\nhttps://code.google.com/p/bitcoinj/wiki/WorkingWithMicropayments for\ndetails on how to use the implementation in bitcoinj.\n\nA more full protocol description will be written up in the form of a BIP as\nthe code matures a bit more (with the hope that other implementations can\nappear), but, generally:\n\n1. Client and server exchange version handshake, and client may\noptionally request that an existing channel be reopened (the channels last\nfor 24 hours by default, so if the connection gets killed, reopening an\nexisting channel is useful).\n2. The protocol described on the wiki is followed, exchanging\n(canonical!) signatures and transactions until a multisignature contract is\nestablished and broadcast which locks money into the channel, and a refund\ntransaction is created and signed which allows the client to spend the\nentire multisignature transaction to wherever they want\n(SIGHASH_NONE|SIGHASH_ANYONECANPAY) after some lock time (by default, 24\nhours). Both client and server store a copy of the channel in their wallet\nso that if the app itself crashes the refund transaction can still be\nbroadcast/the channel can still be resumed. At this point either the whole wallet should be backed up or the total value in payment channels at any\ngiven time should be kept reasonably low (because payment channels are\ndesigned to combine micropayments into confirmable payments, this shouldn't be an issue)\n3. The client increments payments by sending the server new signatures\nspending the multisig contract partially back to themselves and allowing\nthe server to do what they want with the rest\n(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY).\n4. When the client sends a CLOSE message or the channel approaches the\nrefund transaction unlock time, the server adds any necessary fees to the\nlatest payment transaction and broadcasts it, closing the channel, disconnecting the client if the connection is still open and removing the stored channel state from its wallet.\n\nSee https://code.google.com/p/bitcoinj/source/browse/core/src/paymentchannel.proto for the protobuf/protocol description."
            }
        ],
        "thread_summary": {
            "title": "Micropayment Channel Implementation",
            "categories": [
                "Bitcoin-development",
                "ANN"
            ],
            "authors": [
                "bitcoin-list at bluematt.me"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2923
        }
    },
    {
        "title": "[Bitcoin-development] Proposal: MultiBit as default desktop client on bitcoin.org",
        "thread_messages": [
            {
                "author": "Jim",
                "date": "2013-06-27T17:10:53",
                "message_text_only": "Hello Everybody,\n\nOver the last few months we have been steadily adding\nfunctionality to MultiBit including:\n+ encrypted wallets\n+ sign and verify message\n+ stability improvements and bug fixes.\n\nAs a result of these efforts I think MultiBit is now\nsuitable for the entry level Bitcoin user. I propose \nthat we put MultiBit as the default desktop client \non the bitcoin.org \"Choose your wallet\" page.\n\nI think a typical new user comes to bitcoin.org from a \ngoogle search or a Bitcoin news article. We want them to \nperuse the bitcoin.org site and try out a wallet. They \nshould be able to get MultiBit up and running in a tea break. \nThen perhaps they get a colleague to send them some bitcoin \nfrom an Android phone by zapping a QR code. \n\nWe say: \"Welcome to the Bitcoin economy !\"\n\n\nThere is plenty MultiBit cannot do of course. However if\nin the first ten minutes we get the new user interested \nthere is a good chance they will go on to explore other \nBitcoin wallets and solutions. \n\nLet me know if you think this is a good idea (or not!)\nand if you have any questions.\n\nJim\n\nhttps://multibit.org"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-06-27T17:30:21",
                "message_text_only": "On Thu, Jun 27, 2013 at 1:10 PM, Jim <jim618 at fastmail.co.uk> wrote:\n> Hello Everybody,\n>\n> Over the last few months we have been steadily adding\n> functionality to MultiBit including:\n> + encrypted wallets\n> + sign and verify message\n> + stability improvements and bug fixes.\n>\n> As a result of these efforts I think MultiBit is now\n> suitable for the entry level Bitcoin user. I propose\n> that we put MultiBit as the default desktop client\n> on the bitcoin.org \"Choose your wallet\" page.\n>\n> I think a typical new user comes to bitcoin.org from a\n> google search or a Bitcoin news article. We want them to\n> peruse the bitcoin.org site and try out a wallet. They\n> should be able to get MultiBit up and running in a tea break.\n> Then perhaps they get a colleague to send them some bitcoin\n> from an Android phone by zapping a QR code.\n\nThis is definitely a great discussion to have.  Here are some initial,\nunprioritized thoughts.  As an engineer, there is never a clear\nanswer, but a balance of costs and benefits.\n\nArguments in favor of moving away from Bitcoin-Qt/bitcoind for wallet services:\n* Bitcoin-Qt is admittedly a very simple wallet.  I see it's core\nstrengths more as a \"P2P router\" for the public blockchain data.\n* Wallet feature innovation moves more slowly than\nArmory/bitcoinj/blockchain.info.\n* Requires the full blockchain, which is resource-intensive versus SPV.\n\nArguments in favor of retaining Bitcoin-Qt/bitcoind default:\n* More field experience, code review and testing on desktop than others\n* Very real possibility of an overall net reduction of full nodes on P2P network\n\nArguments in favor of multibit default:\n* Good user interface, perhaps more friendly for entry level users as\nyou describe\n* Based on bitcoinj, which has field experience and a very large\ninstalled base thanks to Bitcoin Wallet/Schildbach\n\nArguments against multibit default:\n* Less testing, field experience on desktop\n\nI'm sure others can come up with a few more.\n\n-- \nJeff Garzik\nSenior Software Engineer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Luke-Jr",
                "date": "2013-06-27T18:04:49",
                "message_text_only": "On Thursday, June 27, 2013 5:30:21 PM Jeff Garzik wrote:\n> * Very real possibility of an overall net reduction of full nodes on P2P\n> network\n\nEven a reduction of *nodes at all*, as I've never seen a listening bitcoinj or \nMultiBit node. :/\n\nJim, will MultiBit be adding p2p listening support?\n\n> I'm sure others can come up with a few more.\n\nPossibly against: Does MultiBit still promote Bitcoin misunderstandings with \nmisinformation like \"from\" addresses? (my apologies if I am remembering a \ndifferent client)"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2013-06-27T18:41:56",
                "message_text_only": "On Thu, Jun 27, 2013 at 11:04 AM, Luke-Jr <luke at dashjr.org> wrote:\n> On Thursday, June 27, 2013 5:30:21 PM Jeff Garzik wrote:\n>> * Very real possibility of an overall net reduction of full nodes on P2P\n>> network\n> Even a reduction of *nodes at all*, as I've never seen a listening bitcoinj or\n> MultiBit node. :/\n> Jim, will MultiBit be adding p2p listening support?\n\nWithout validation listening isn't currently very useful. :( Maybe it\ncould be somewhat more with some protocol additions."
            },
            {
                "author": "Jim",
                "date": "2013-06-27T19:18:36",
                "message_text_only": "A few replies, in order of point raised:\n\nJeff:\nArguments against multibit default:\n* Less testing, field experience on desktop\n\nYes this is true - downloads of multibit have typically been around\n1/7th to 1/5th of bitcoin-QT downloads. It helps of course that\nthe bitcoinj networking/ object model is also used by Andreas \nas you note.\n\n\nGreg:\nI think Mike has squashed the deadlocking problems with reentrant \nlocks (primarily in the Wallet). I haven't seen one in at least a month.\n\nWe discussed proxy support on the bitcoinj mailing list a while ago \nand at the time the stumbling block was the Java library used for \nthe networking (Netty) did not support it. Mike or Miron would \nknow better than I if this is still the case.\n\nChange address behaviour will improve significantly when HD\nwallet support goes into multibit/ bitcoinj (I am hoping to get my\nbit done over the summer). Matija Mazi has been working on a \nJava impl of HD wallets so it is coming down the pipe but\nthere is a lot to do yet.\n\nConnections out from MultiBit are:\n+ 4 bitcoind nodes on port 8333\n+ multibit.org (188.138.113.201) for help, current version info\n   (and probably more in future)\n+ the currency ticker will make HTTP gets to the source of\n   whichever exchange(s) you have set up e.g MtGox, CampBX.\n   This calls should disappear if you switch the currency conversion\n   and ticker off.\n\nI think that is all the connections out I make.\n\nMainly due to the exchanges abruptly changing their APIs and\nbreaking things we are planning to put in intermediate \n\"Exchange Data Provider\" servers. Tim Molter is working on this\nin his XChange project. That will enable us to patch the server\nwhen things change and the multibits in the field won't be\naffected. There will probably be a couple of these initially\nfor redundancy.\n\nAlex: Yes I think most users migrate to blockchain.info or,\nmore recently coinbase.com. They are both good wallets\nbut I'd like to keep Bitcoin as P2P as possible.\n\nLuke-Jr\nI think you are right here on the number of full nodes versus\nSPV nodes.\nI don't think we even know yet what are the working ratios of\nfull nodes to SPV nodes. I haven't seen anybody do any \nanalysis on this.\n\nI doubt multibit will ever participate in the Bitcoin network \nother than as an SPV client. All the optimisation is to reduce\ndata traffic - it is effectively a mobile wallet that happens to\nlive on a desktop. It is not really intended to be more than\n\"a wallet for regular people to store and spend their bitcoin\".\n\nIn English the nomenclature for direction of the transactions\nis: \"Sent to\" and \"Received with\". To be honest I \nhaven't transliterated the localisation files to check other\nlanguage packs but the localisers are pretty good in my\nexperience.\n\n\n\n\n\nOn Thu, Jun 27, 2013, at 07:41 PM, Gregory Maxwell wrote:\n> On Thu, Jun 27, 2013 at 11:04 AM, Luke-Jr <luke at dashjr.org> wrote:\n> > On Thursday, June 27, 2013 5:30:21 PM Jeff Garzik wrote:\n> >> * Very real possibility of an overall net reduction of full nodes on P2P\n> >> network\n> > Even a reduction of *nodes at all*, as I've never seen a listening bitcoinj or\n> > MultiBit node. :/\n> > Jim, will MultiBit be adding p2p listening support?\n> \n> Without validation listening isn't currently very useful. :( Maybe it\n> could be somewhat more with some protocol additions.\n> \n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n> \n> Build for Windows Store.\n> \n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n\n-- \nhttps://multibit.org    Money, reinvented"
            },
            {
                "author": "Jim",
                "date": "2013-06-27T19:40:18",
                "message_text_only": "RE: 141.101.113.245\n\nhttp://whois.domaintools.com/141.101.113.245\ngives it as CloudFlare - I suspect it is protecting\nMt Gox when we make our get for currency ticker info.\n\n\nOn Thu, Jun 27, 2013, at 08:18 PM, Jim wrote:\n> A few replies, in order of point raised:\n> \n> Jeff:\n> Arguments against multibit default:\n> * Less testing, field experience on desktop\n> \n> Yes this is true - downloads of multibit have typically been around\n> 1/7th to 1/5th of bitcoin-QT downloads. It helps of course that\n> the bitcoinj networking/ object model is also used by Andreas \n> as you note.\n> \n> \n> Greg:\n> I think Mike has squashed the deadlocking problems with reentrant \n> locks (primarily in the Wallet). I haven't seen one in at least a month.\n> \n> We discussed proxy support on the bitcoinj mailing list a while ago \n> and at the time the stumbling block was the Java library used for \n> the networking (Netty) did not support it. Mike or Miron would \n> know better than I if this is still the case.\n> \n> Change address behaviour will improve significantly when HD\n> wallet support goes into multibit/ bitcoinj (I am hoping to get my\n> bit done over the summer). Matija Mazi has been working on a \n> Java impl of HD wallets so it is coming down the pipe but\n> there is a lot to do yet.\n> \n> Connections out from MultiBit are:\n> + 4 bitcoind nodes on port 8333\n> + multibit.org (188.138.113.201) for help, current version info\n>    (and probably more in future)\n> + the currency ticker will make HTTP gets to the source of\n>    whichever exchange(s) you have set up e.g MtGox, CampBX.\n>    This calls should disappear if you switch the currency conversion\n>    and ticker off.\n> \n> I think that is all the connections out I make.\n> \n> Mainly due to the exchanges abruptly changing their APIs and\n> breaking things we are planning to put in intermediate \n> \"Exchange Data Provider\" servers. Tim Molter is working on this\n> in his XChange project. That will enable us to patch the server\n> when things change and the multibits in the field won't be\n> affected. There will probably be a couple of these initially\n> for redundancy.\n> \n> Alex: Yes I think most users migrate to blockchain.info or,\n> more recently coinbase.com. They are both good wallets\n> but I'd like to keep Bitcoin as P2P as possible.\n> \n> Luke-Jr\n> I think you are right here on the number of full nodes versus\n> SPV nodes.\n> I don't think we even know yet what are the working ratios of\n> full nodes to SPV nodes. I haven't seen anybody do any \n> analysis on this.\n> \n> I doubt multibit will ever participate in the Bitcoin network \n> other than as an SPV client. All the optimisation is to reduce\n> data traffic - it is effectively a mobile wallet that happens to\n> live on a desktop. It is not really intended to be more than\n> \"a wallet for regular people to store and spend their bitcoin\".\n> \n> In English the nomenclature for direction of the transactions\n> is: \"Sent to\" and \"Received with\". To be honest I \n> haven't transliterated the localisation files to check other\n> language packs but the localisers are pretty good in my\n> experience.\n> \n> \n> \n> \n> \n> On Thu, Jun 27, 2013, at 07:41 PM, Gregory Maxwell wrote:\n> > On Thu, Jun 27, 2013 at 11:04 AM, Luke-Jr <luke at dashjr.org> wrote:\n> > > On Thursday, June 27, 2013 5:30:21 PM Jeff Garzik wrote:\n> > >> * Very real possibility of an overall net reduction of full nodes on P2P\n> > >> network\n> > > Even a reduction of *nodes at all*, as I've never seen a listening bitcoinj or\n> > > MultiBit node. :/\n> > > Jim, will MultiBit be adding p2p listening support?\n> > \n> > Without validation listening isn't currently very useful. :( Maybe it\n> > could be somewhat more with some protocol additions.\n> > \n> > ------------------------------------------------------------------------------\n> > This SF.net email is sponsored by Windows:\n> > \n> > Build for Windows Store.\n> > \n> > http://p.sf.net/sfu/windows-dev2dev\n> > _______________________________________________\n> > Bitcoin-development mailing list\n> > Bitcoin-development at lists.sourceforge.net\n> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> \n> \n> -- \n> https://multibit.org    Money, reinvented\n> \n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n> \n> Build for Windows Store.\n> \n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n\n-- \nhttps://multibit.org    Money, reinvented"
            },
            {
                "author": "Jim",
                "date": "2013-06-27T19:50:00",
                "message_text_only": "I missed Greg's point on confirmations.\nIt is definitely a challenge to explain/ visualize both:\n+ has the transaction propagated the network ?\nand\n+ it it confirmed/ buried in a block ?\n\nwhen those words probably don't mean much to\nthe intended audience.\n\nThe transaction status icons I *think* do it\n(explained here:\nhttps://multibit.org/en/help/v0.5/help_transactions.html).\n\nIt basically boils down to:\n1) triangle or square : bad.\n2) filling circle : good\n3) tick mark : great.\n\n\nOn Thu, Jun 27, 2013, at 08:40 PM, Jim wrote:\n> RE: 141.101.113.245\n> \n> http://whois.domaintools.com/141.101.113.245\n> gives it as CloudFlare - I suspect it is protecting\n> Mt Gox when we make our get for currency ticker info.\n> \n> \n> On Thu, Jun 27, 2013, at 08:18 PM, Jim wrote:\n> > A few replies, in order of point raised:\n> > \n> > Jeff:\n> > Arguments against multibit default:\n> > * Less testing, field experience on desktop\n> > \n> > Yes this is true - downloads of multibit have typically been around\n> > 1/7th to 1/5th of bitcoin-QT downloads. It helps of course that\n> > the bitcoinj networking/ object model is also used by Andreas \n> > as you note.\n> > \n> > \n> > Greg:\n> > I think Mike has squashed the deadlocking problems with reentrant \n> > locks (primarily in the Wallet). I haven't seen one in at least a month.\n> > \n> > We discussed proxy support on the bitcoinj mailing list a while ago \n> > and at the time the stumbling block was the Java library used for \n> > the networking (Netty) did not support it. Mike or Miron would \n> > know better than I if this is still the case.\n> > \n> > Change address behaviour will improve significantly when HD\n> > wallet support goes into multibit/ bitcoinj (I am hoping to get my\n> > bit done over the summer). Matija Mazi has been working on a \n> > Java impl of HD wallets so it is coming down the pipe but\n> > there is a lot to do yet.\n> > \n> > Connections out from MultiBit are:\n> > + 4 bitcoind nodes on port 8333\n> > + multibit.org (188.138.113.201) for help, current version info\n> >    (and probably more in future)\n> > + the currency ticker will make HTTP gets to the source of\n> >    whichever exchange(s) you have set up e.g MtGox, CampBX.\n> >    This calls should disappear if you switch the currency conversion\n> >    and ticker off.\n> > \n> > I think that is all the connections out I make.\n> > \n> > Mainly due to the exchanges abruptly changing their APIs and\n> > breaking things we are planning to put in intermediate \n> > \"Exchange Data Provider\" servers. Tim Molter is working on this\n> > in his XChange project. That will enable us to patch the server\n> > when things change and the multibits in the field won't be\n> > affected. There will probably be a couple of these initially\n> > for redundancy.\n> > \n> > Alex: Yes I think most users migrate to blockchain.info or,\n> > more recently coinbase.com. They are both good wallets\n> > but I'd like to keep Bitcoin as P2P as possible.\n> > \n> > Luke-Jr\n> > I think you are right here on the number of full nodes versus\n> > SPV nodes.\n> > I don't think we even know yet what are the working ratios of\n> > full nodes to SPV nodes. I haven't seen anybody do any \n> > analysis on this.\n> > \n> > I doubt multibit will ever participate in the Bitcoin network \n> > other than as an SPV client. All the optimisation is to reduce\n> > data traffic - it is effectively a mobile wallet that happens to\n> > live on a desktop. It is not really intended to be more than\n> > \"a wallet for regular people to store and spend their bitcoin\".\n> > \n> > In English the nomenclature for direction of the transactions\n> > is: \"Sent to\" and \"Received with\". To be honest I \n> > haven't transliterated the localisation files to check other\n> > language packs but the localisers are pretty good in my\n> > experience.\n> > \n> > \n> > \n> > \n> > \n> > On Thu, Jun 27, 2013, at 07:41 PM, Gregory Maxwell wrote:\n> > > On Thu, Jun 27, 2013 at 11:04 AM, Luke-Jr <luke at dashjr.org> wrote:\n> > > > On Thursday, June 27, 2013 5:30:21 PM Jeff Garzik wrote:\n> > > >> * Very real possibility of an overall net reduction of full nodes on P2P\n> > > >> network\n> > > > Even a reduction of *nodes at all*, as I've never seen a listening bitcoinj or\n> > > > MultiBit node. :/\n> > > > Jim, will MultiBit be adding p2p listening support?\n> > > \n> > > Without validation listening isn't currently very useful. :( Maybe it\n> > > could be somewhat more with some protocol additions.\n> > > \n> > > ------------------------------------------------------------------------------\n> > > This SF.net email is sponsored by Windows:\n> > > \n> > > Build for Windows Store.\n> > > \n> > > http://p.sf.net/sfu/windows-dev2dev\n> > > _______________________________________________\n> > > Bitcoin-development mailing list\n> > > Bitcoin-development at lists.sourceforge.net\n> > > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> > \n> > \n> > -- \n> > https://multibit.org    Money, reinvented\n> > \n> > ------------------------------------------------------------------------------\n> > This SF.net email is sponsored by Windows:\n> > \n> > Build for Windows Store.\n> > \n> > http://p.sf.net/sfu/windows-dev2dev\n> > _______________________________________________\n> > Bitcoin-development mailing list\n> > Bitcoin-development at lists.sourceforge.net\n> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> \n> \n> -- \n> https://multibit.org    Money, reinvented\n> \n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n> \n> Build for Windows Store.\n> \n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n\n-- \nhttps://multibit.org    Money, reinvented"
            },
            {
                "author": "Alex Kravets",
                "date": "2013-06-27T21:12:34",
                "message_text_only": "Hi Jim,\n\nOn Thu, Jun 27, 2013 at 12:18 PM, Jim <jim618 at fastmail.co.uk> wrote:\n\n>\n> Alex: Yes I think most users migrate to blockchain.info or,\n> more recently coinbase.com. They are both good wallets\n> but I'd like to keep Bitcoin as P2P as possible.\n>\n\nGuys, being a late comer/outsider (I got into bitcoin in early 2012), I can\ntell you that this particular asylum is definitely run by its inmates.\n\nWhat all the nerdy devs (and I am one so I know) seem unable to comprehend,\nis that regular people out there don't wanna learn all this new stuff and\nnew terminology they simply have no attention span for it.\n\nSimply channelling them to a decent client that\n\n1. Just works (no blockchain downloads and no re-sync)\n2. Allows to retain control of the private keys\n\nWould be HUGE for mass adoption.\n\nOld tired argument about \"Bitcoin needs your nodes\", so we'll channel you\nto get bitcoin-qt client is both manipulative and unnecessary (there's\nplenty of nodes and NAT'ed home nodes which don't mine are mostly useless\nanyways)\n\nP.S. coinbase.com is just another trust-me setup takes your coins in\nexchange for IOUs, whereas blockchain.info does let you to retain control\nof your private keys.\n\nP.P.S. The reason why coinbase has gotten so big is precisely because they\ndon't trouble regular lawyers and doctors with all the nonsense but simply\ngive them a\n\"buy\" and a \"sell\" button.\n\n\n\n\n\n> Luke-Jr\n> I think you are right here on the number of full nodes versus\n> SPV nodes.\n> I don't think we even know yet what are the working ratios of\n> full nodes to SPV nodes. I haven't seen anybody do any\n> analysis on this.\n>\n> I doubt multibit will ever participate in the Bitcoin network\n> other than as an SPV client. All the optimisation is to reduce\n> data traffic - it is effectively a mobile wallet that happens to\n> live on a desktop. It is not really intended to be more than\n> \"a wallet for regular people to store and spend their bitcoin\".\n>\n> In English the nomenclature for direction of the transactions\n> is: \"Sent to\" and \"Received with\". To be honest I\n> haven't transliterated the localisation files to check other\n> language packs but the localisers are pretty good in my\n> experience.\n>\n>\n>\n>\n>\n> On Thu, Jun 27, 2013, at 07:41 PM, Gregory Maxwell wrote:\n> > On Thu, Jun 27, 2013 at 11:04 AM, Luke-Jr <luke at dashjr.org> wrote:\n> > > On Thursday, June 27, 2013 5:30:21 PM Jeff Garzik wrote:\n> > >> * Very real possibility of an overall net reduction of full nodes on\n> P2P\n> > >> network\n> > > Even a reduction of *nodes at all*, as I've never seen a listening\n> bitcoinj or\n> > > MultiBit node. :/\n> > > Jim, will MultiBit be adding p2p listening support?\n> >\n> > Without validation listening isn't currently very useful. :( Maybe it\n> > could be somewhat more with some protocol additions.\n> >\n> >\n> ------------------------------------------------------------------------------\n> > This SF.net email is sponsored by Windows:\n> >\n> > Build for Windows Store.\n> >\n> > http://p.sf.net/sfu/windows-dev2dev\n> > _______________________________________________\n> > Bitcoin-development mailing list\n> > Bitcoin-development at lists.sourceforge.net\n> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n> --\n> https://multibit.org    Money, reinvented\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n\n\n\n-- \nAlex Kravets <http://www.linkedin.com/in/akravets>       def redPill = '\nScala <http://www.scala-lang.org/>\n[[ brutal honesty <http://goo.gl/vwydt> is the best policy ]]\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130627/1571c8d1/attachment.html>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2013-06-27T21:56:46",
                "message_text_only": "On Thu, Jun 27, 2013 at 5:12 PM, Alex Kravets <kravets at gmail.com> wrote:\n> What all the nerdy devs (and I am one so I know) seem unable to comprehend,\n> is that regular people out there don't wanna learn all this new stuff and\n> new terminology they simply have no attention span for it.\n\nBitcoin Wallet for Android is a decentralized client w/ network sync,\nand it works just fine.  Fast, easy to use.\n\n-- \nJeff Garzik\nSenior Software Engineer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Alex Kravets",
                "date": "2013-06-27T22:53:05",
                "message_text_only": "Perhaps there should be two different sections on the web page.\n\nNerds  / Non-Nerds\n\nWith different recommendations for which clients to use.\n\n\nOn Thu, Jun 27, 2013 at 2:56 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:\n\n> On Thu, Jun 27, 2013 at 5:12 PM, Alex Kravets <kravets at gmail.com> wrote:\n> > What all the nerdy devs (and I am one so I know) seem unable to\n> comprehend,\n> > is that regular people out there don't wanna learn all this new stuff and\n> > new terminology they simply have no attention span for it.\n>\n> Bitcoin Wallet for Android is a decentralized client w/ network sync,\n> and it works just fine.  Fast, easy to use.\n>\n> --\n> Jeff Garzik\n> Senior Software Engineer and open source evangelist\n> BitPay, Inc.      https://bitpay.com/\n>\n\n\n\n-- \nAlex Kravets <http://www.linkedin.com/in/akravets>       def redPill = '\nScala <http://www.scala-lang.org/>\n[[ brutal honesty <http://goo.gl/vwydt> is the best policy ]]\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130627/b4e6d949/attachment.html>"
            },
            {
                "author": "Gary Rowe",
                "date": "2013-06-27T22:03:18",
                "message_text_only": "Many people that I have introduced Bitcoin to have balked at the massive\nblockchain download. When I showed them MultiBit (and Bitcoin Wallet) they\nbreathed a sigh of relief and got on with it.\n\nA currency lives or dies by network effects. If we can provide the average\nlow-tech user with a great client experience right from the word go then we\ncan win them over quickly. Once that is accomplished then more techie users\nwill likely go on to use a full node which will continue to strengthen the\nnetwork overall.\n\n\n\nOn 27 June 2013 22:12, Alex Kravets <kravets at gmail.com> wrote:\n\n> Hi Jim,\n>\n> On Thu, Jun 27, 2013 at 12:18 PM, Jim <jim618 at fastmail.co.uk> wrote:\n>\n>>\n>> Alex: Yes I think most users migrate to blockchain.info or,\n>> more recently coinbase.com. They are both good wallets\n>> but I'd like to keep Bitcoin as P2P as possible.\n>>\n>\n> Guys, being a late comer/outsider (I got into bitcoin in early 2012), I\n> can tell you that this particular asylum is definitely run by its inmates.\n>\n> What all the nerdy devs (and I am one so I know) seem unable to\n> comprehend, is that regular people out there don't wanna learn all this new\n> stuff and new terminology they simply have no attention span for it.\n>\n> Simply channelling them to a decent client that\n>\n> 1. Just works (no blockchain downloads and no re-sync)\n> 2. Allows to retain control of the private keys\n>\n> Would be HUGE for mass adoption.\n>\n> Old tired argument about \"Bitcoin needs your nodes\", so we'll channel you\n> to get bitcoin-qt client is both manipulative and unnecessary (there's\n> plenty of nodes and NAT'ed home nodes which don't mine are mostly useless\n> anyways)\n>\n> P.S. coinbase.com is just another trust-me setup takes your coins in\n> exchange for IOUs, whereas blockchain.info does let you to retain control\n> of your private keys.\n>\n> P.P.S. The reason why coinbase has gotten so big is precisely because they\n> don't trouble regular lawyers and doctors with all the nonsense but simply\n> give them a\n> \"buy\" and a \"sell\" button.\n>\n>\n>\n>\n>\n>> Luke-Jr\n>> I think you are right here on the number of full nodes versus\n>> SPV nodes.\n>> I don't think we even know yet what are the working ratios of\n>> full nodes to SPV nodes. I haven't seen anybody do any\n>> analysis on this.\n>>\n>> I doubt multibit will ever participate in the Bitcoin network\n>> other than as an SPV client. All the optimisation is to reduce\n>> data traffic - it is effectively a mobile wallet that happens to\n>> live on a desktop. It is not really intended to be more than\n>> \"a wallet for regular people to store and spend their bitcoin\".\n>>\n>> In English the nomenclature for direction of the transactions\n>> is: \"Sent to\" and \"Received with\". To be honest I\n>> haven't transliterated the localisation files to check other\n>> language packs but the localisers are pretty good in my\n>> experience.\n>>\n>>\n>>\n>>\n>>\n>> On Thu, Jun 27, 2013, at 07:41 PM, Gregory Maxwell wrote:\n>> > On Thu, Jun 27, 2013 at 11:04 AM, Luke-Jr <luke at dashjr.org> wrote:\n>> > > On Thursday, June 27, 2013 5:30:21 PM Jeff Garzik wrote:\n>> > >> * Very real possibility of an overall net reduction of full nodes on\n>> P2P\n>> > >> network\n>> > > Even a reduction of *nodes at all*, as I've never seen a listening\n>> bitcoinj or\n>> > > MultiBit node. :/\n>> > > Jim, will MultiBit be adding p2p listening support?\n>> >\n>> > Without validation listening isn't currently very useful. :( Maybe it\n>> > could be somewhat more with some protocol additions.\n>> >\n>> >\n>> ------------------------------------------------------------------------------\n>> > This SF.net email is sponsored by Windows:\n>> >\n>> > Build for Windows Store.\n>> >\n>> > http://p.sf.net/sfu/windows-dev2dev\n>> > _______________________________________________\n>> > Bitcoin-development mailing list\n>> > Bitcoin-development at lists.sourceforge.net\n>> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>>\n>> --\n>> https://multibit.org    Money, reinvented\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> This SF.net email is sponsored by Windows:\n>>\n>> Build for Windows Store.\n>>\n>> http://p.sf.net/sfu/windows-dev2dev\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>\n>\n>\n> --\n> Alex Kravets <http://www.linkedin.com/in/akravets>       def redPill = '\n> Scala <http://www.scala-lang.org/>\n> [[ brutal honesty <http://goo.gl/vwydt> is the best policy ]]\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130627/18284bb8/attachment.html>"
            },
            {
                "author": "John Dillon",
                "date": "2013-06-28T10:59:32",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nOn Thu, Jun 27, 2013 at 6:41 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n> On Thu, Jun 27, 2013 at 11:04 AM, Luke-Jr <luke at dashjr.org> wrote:\n>> On Thursday, June 27, 2013 5:30:21 PM Jeff Garzik wrote:\n>>> * Very real possibility of an overall net reduction of full nodes on P2P\n>>> network\n>> Even a reduction of *nodes at all*, as I've never seen a listening bitcoinj or\n>> MultiBit node. :/\n>> Jim, will MultiBit be adding p2p listening support?\n>\n> Without validation listening isn't currently very useful. :( Maybe it\n> could be somewhat more with some protocol additions.\n\nPossible non-validation data that can be usefully propagated:\n\n1) Block headers.\n\n2) *Confirmed* transactions linked to an aformentioned blockheader.\n\n3) Proof-of-work/sacrifice limited P2P messages, for instance to\nco-ordinate trust-free-mixes or act as a communication channel for\nmicropayment channels.\n\n4) With UTXO existance proof support propagate transactions\naccompanied by proofs that all inputs exist. This would also allow for\nimplementation of Peter's low-bandwidth decentralized P2Pool proposal.\n\n5) UTXO fraud proofs. (one day)\n\n\nStrictly speaking #2 doesn't even need the protocol to be changed\nactually as it can be handled entirely within the existing INV/getdata\nmechanism. Sure someone could throw away a lot of hashing power and\nget an invalid block propagated, but really so what? SPV nodes should\nalways take confirmations with a grain of salt anyway.\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\n\niQEcBAEBCAAGBQJRzWx8AAoJEEWCsU4mNhiPlTkIAJKzFsT65o6LoU70hbaBsu3g\naBdjYZSCnJ9+qWI2tqqUBedq2etbt71hAfWNnTXvFus+0iVB1HWJClW155319vuH\nXi1m9G3O0NzX1d+cssMPxFBHsl4Rz6XYICrYyVEe2X554Zawdg6I53+1INHRfsBT\n1vmq5Bxgopt0Tk9Vf8HNdRt/IXZJaPYm1PEzJHFppuOvl5+Fpypy3t/QXdsP8puP\nLnRdL7Bxfu3BSWrSRZo7l5Fpww3Y/vdNYCL4jDD/ME+36wi4CUM3psL8lsk81lB4\n3t/ytF4y/adT/dEEtMj7BGWS0TIMMH0NyeCjqBdStiQsVfoowLCVfpuDzouZ6yY=\n=TI1m\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-06-28T09:10:32",
                "message_text_only": "> Arguments in favor of retaining Bitcoin-Qt/bitcoind default:\n> * More field experience, code review and testing on desktop than others\n\nI'm hoping that if we start promoting alternative wallets their dev\ncommunities will get larger. Most bitcoinj code is peer reviewed, but\nnot to the same extent that Bitcoin-Qt is.\n\nWe're obviously not going to stop promoting Bitcoin-Qt as well. I\nthink the distinction should be:\n\n * Want to get started fast? Grab MultiBit and you'll be under way in\na couple of minutes.\n * Want to help out the Bitcoin network? Leave your computer switched\non all the time and run Bitcoin-Qt instead. It will donate some of\nyour computers resources to running the Bitcoin system.\n\nThe MultiBit interface is OK but all desktop wallets could use some\nlove from a friendly UI designer."
            },
            {
                "author": "Gavin Andresen",
                "date": "2013-06-28T14:24:16",
                "message_text_only": "I vote \"yes\" to have MultiBit replace Bitcoin-Qt as the recommended\ndesktop wallet app. I think most users will be happier with it.\n\nIf I'm wrong, it is easy to change back."
            },
            {
                "author": "Mike Hearn",
                "date": "2013-06-30T11:42:31",
                "message_text_only": "Sounds like we have consensus, Saivann, shall we do it?\n\nI'm also going to ask Theymos again to relax the newbie restrictions\nfor the alt client forums. It's probably too hard to get support at\nthe moment and \"email jim\" doesn't scale at all.\n\nOn Fri, Jun 28, 2013 at 4:24 PM, Gavin Andresen <gavinandresen at gmail.com> wrote:\n> I vote \"yes\" to have MultiBit replace Bitcoin-Qt as the recommended\n> desktop wallet app. I think most users will be happier with it.\n>\n> If I'm wrong, it is easy to change back.\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Jim",
                "date": "2013-06-30T15:19:29",
                "message_text_only": "Yeah \"email jim' was never going to work so I have\nbumped up MultiBit support (a bit) by:\n\n+ having a dedicated Support page on the website\n   https://multibit.org/support.html\n   It has fixes and support notes for the most common gotchas.\n+ the in-app help also now has a 'Support' section with \n   \"Troubleshooting' and the commonest gotchas.\n   I've also written more help to cover as much as possible.\n+ Failing that people are directed first to bitcoin.stackchange.com\n   (I have a notification set up for the 'multibit' keyword.\n+ Then finally users are directed to the github issues to search \n   existing or raise a new issue. Gary and Tim often chip in on there to\n   close \n   issues down as well as me.\n\n\n\nOn Sun, Jun 30, 2013, at 12:42 PM, Mike Hearn wrote:\n> Sounds like we have consensus, Saivann, shall we do it?\n> \n> I'm also going to ask Theymos again to relax the newbie restrictions\n> for the alt client forums. It's probably too hard to get support at\n> the moment and \"email jim\" doesn't scale at all.\n> \n> On Fri, Jun 28, 2013 at 4:24 PM, Gavin Andresen <gavinandresen at gmail.com>\n> wrote:\n> > I vote \"yes\" to have MultiBit replace Bitcoin-Qt as the recommended\n> > desktop wallet app. I think most users will be happier with it.\n> >\n> > If I'm wrong, it is easy to change back.\n> >\n> > ------------------------------------------------------------------------------\n> > This SF.net email is sponsored by Windows:\n> >\n> > Build for Windows Store.\n> >\n> > http://p.sf.net/sfu/windows-dev2dev\n> > _______________________________________________\n> > Bitcoin-development mailing list\n> > Bitcoin-development at lists.sourceforge.net\n> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> \n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n> \n> Build for Windows Store.\n> \n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n\n-- \nhttps://multibit.org    Money, reinvented"
            },
            {
                "author": "Gary Rowe",
                "date": "2013-06-30T16:39:02",
                "message_text_only": "I've beefed up the supporting documentation for the website to make it more\naccessible for developers who wish to contribute. It's a Java application\nserving HTML.\n\nIt can be found here: https://github.com/jim618/multibit-website\n\n\nOn 30 June 2013 16:19, Jim <jim618 at fastmail.co.uk> wrote:\n\n> Yeah \"email jim' was never going to work so I have\n> bumped up MultiBit support (a bit) by:\n>\n> + having a dedicated Support page on the website\n>    https://multibit.org/support.html\n>    It has fixes and support notes for the most common gotchas.\n> + the in-app help also now has a 'Support' section with\n>    \"Troubleshooting' and the commonest gotchas.\n>    I've also written more help to cover as much as possible.\n> + Failing that people are directed first to bitcoin.stackchange.com\n>    (I have a notification set up for the 'multibit' keyword.\n> + Then finally users are directed to the github issues to search\n>    existing or raise a new issue. Gary and Tim often chip in on there to\n>    close\n>    issues down as well as me.\n>\n>\n>\n> On Sun, Jun 30, 2013, at 12:42 PM, Mike Hearn wrote:\n> > Sounds like we have consensus, Saivann, shall we do it?\n> >\n> > I'm also going to ask Theymos again to relax the newbie restrictions\n> > for the alt client forums. It's probably too hard to get support at\n> > the moment and \"email jim\" doesn't scale at all.\n> >\n> > On Fri, Jun 28, 2013 at 4:24 PM, Gavin Andresen <gavinandresen at gmail.com\n> >\n> > wrote:\n> > > I vote \"yes\" to have MultiBit replace Bitcoin-Qt as the recommended\n> > > desktop wallet app. I think most users will be happier with it.\n> > >\n> > > If I'm wrong, it is easy to change back.\n> > >\n> > >\n> ------------------------------------------------------------------------------\n> > > This SF.net email is sponsored by Windows:\n> > >\n> > > Build for Windows Store.\n> > >\n> > > http://p.sf.net/sfu/windows-dev2dev\n> > > _______________________________________________\n> > > Bitcoin-development mailing list\n> > > Bitcoin-development at lists.sourceforge.net\n> > > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> >\n> >\n> ------------------------------------------------------------------------------\n> > This SF.net email is sponsored by Windows:\n> >\n> > Build for Windows Store.\n> >\n> > http://p.sf.net/sfu/windows-dev2dev\n> > _______________________________________________\n> > Bitcoin-development mailing list\n> > Bitcoin-development at lists.sourceforge.net\n> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n> --\n> https://multibit.org    Money, reinvented\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130630/37790ab0/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2013-06-27T17:56:54",
                "message_text_only": "On Thu, Jun 27, 2013 at 10:10 AM, Jim <jim618 at fastmail.co.uk> wrote:\n> Let me know if you think this is a good idea (or not!)\n> and if you have any questions.\n\nBeing able to promote a fast SPV desktop wallet would be great!\n\nI went through an cycle of testing on multibit after I saw some\ncomplaints when it went up on the page before without at lot of\ndiscussion. There were a number of issues with it at the time, in\nparticular the frequent deadlocks\u2014 though Mike was saying that those\nshould be fixed.\n\nI see some of the the other things that were concerning for me at the\ntime are still uncorrected though, e.g. no proxy support (so users\ncan't follow our recommended best practices of using it with Tor),\nthat it reuses addresses (esp for change), that it doesn't clearly\ndistinguish confirmation level. It also make repeated https\nconnections to 141.101.113.245? (I'm not seeing the IP in the source,\nand it doesn't have a useful reverse dns entry, so I can't tell what\nits for).  Is there any timeframe for changing any of this stuff?"
            },
            {
                "author": "Alex Kravets",
                "date": "2013-06-27T18:05:47",
                "message_text_only": "Hi guys,\n\nThis would be a big step forward.  Anecdotally I can report that <5% of *\nnon-nerds* who don't abandon Bitcoin after waiting for the initial\nblockchain download and *ongoing* sync on every restart, end up using\nblockchain.info simply because it just works and works on their iPads &\niPhones.\n\nConversely, all the serious nerds end up using Armory and/or Brainwallets\nfor ultimate control.\n\n\n\n\nOn Thu, Jun 27, 2013 at 10:56 AM, Gregory Maxwell <gmaxwell at gmail.com>wrote:\n\n> On Thu, Jun 27, 2013 at 10:10 AM, Jim <jim618 at fastmail.co.uk> wrote:\n> > Let me know if you think this is a good idea (or not!)\n> > and if you have any questions.\n>\n> Being able to promote a fast SPV desktop wallet would be great!\n>\n> I went through an cycle of testing on multibit after I saw some\n> complaints when it went up on the page before without at lot of\n> discussion. There were a number of issues with it at the time, in\n> particular the frequent deadlocks\u2014 though Mike was saying that those\n> should be fixed.\n>\n> I see some of the the other things that were concerning for me at the\n> time are still uncorrected though, e.g. no proxy support (so users\n> can't follow our recommended best practices of using it with Tor),\n> that it reuses addresses (esp for change), that it doesn't clearly\n> distinguish confirmation level. It also make repeated https\n> connections to 141.101.113.245? (I'm not seeing the IP in the source,\n> and it doesn't have a useful reverse dns entry, so I can't tell what\n> its for).  Is there any timeframe for changing any of this stuff?\n>\n>\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n>\n> Build for Windows Store.\n>\n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n\n\n\n-- \nAlex Kravets <http://www.linkedin.com/in/akravets>       def redPill = '\nScala <http://www.scala-lang.org/>\n[[ brutal honesty <http://goo.gl/vwydt> is the best policy ]]\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130627/3a327072/attachment.html>"
            },
            {
                "author": "Caleb James DeLisle",
                "date": "2013-06-27T23:45:59",
                "message_text_only": "On 06/27/2013 01:56 PM, Gregory Maxwell wrote:\n> On Thu, Jun 27, 2013 at 10:10 AM, Jim <jim618 at fastmail.co.uk> wrote:\n>> Let me know if you think this is a good idea (or not!)\n>> and if you have any questions.\n> \n> Being able to promote a fast SPV desktop wallet would be great!\n> \n> I went through an cycle of testing on multibit after I saw some\n> complaints when it went up on the page before without at lot of\n> discussion. There were a number of issues with it at the time, in\n> particular the frequent deadlocks\u2014 though Mike was saying that those\n> should be fixed.\n> \n> I see some of the the other things that were concerning for me at the\n> time are still uncorrected though, e.g. no proxy support (so users\n> can't follow our recommended best practices of using it with Tor),\n\n\nIf I were a Bitcoin dev, I would not want to talk about anonymity or\nTOR because that's likely to attract people with paranoid dilutions\nand they're really terrible users to support :)\n\nAlso yay for promoting fast, easy to use clients for casual users!\n\nThanks,\nCaleb\n\n\n> that it reuses addresses (esp for change), that it doesn't clearly\n> distinguish confirmation level. It also make repeated https\n> connections to 141.101.113.245? (I'm not seeing the IP in the source,\n> and it doesn't have a useful reverse dns entry, so I can't tell what\n> its for).  Is there any timeframe for changing any of this stuff?\n> \n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n> \n> Build for Windows Store.\n> \n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-06-28T09:05:51",
                "message_text_only": "> There were a number of issues with it at the time, in\n> particular the frequent deadlocks\u2014 though Mike was saying that those\n> should be fixed.\n\nYes. There were a number of lock cycles that didn't cause issues so\nmuch when traffic was lower and as Bitcoin got more popular it became\na critical problem. I redid a lot of the concurrency to fix that, and\nnow all the core locks are cycle detecting so regressions should be\ndetected fairly fast. I'm still making changes to the concurrency\ndesign but mostly to improve the API at this point, not fix bugs.\n\nThere is one deadlock I'm still aware of, thanks to Netty. However\nit's very rare and was only reported by someone who kept a server\nrunning for many days in a row. We want to junk Netty soon anyway.\nIt's a network library but it doesn't really add much value for our\nuse case and it turned out to have some serious design issues\ninternally.\n\n> I see some of the the other things that were concerning for me at the\n> time are still uncorrected though, e.g. no proxy support (so users\n> can't follow our recommended best practices of using it with Tor),\n\nYeah. That's not the primary privacy issue with bitcoinj though. I'm\nmuch, much more concerned about leaks via the block chain than the\nnetwork layer. Especially as Tor is basically a giant man in the\nmiddle, without any kind of authentication you can easily end up\nconnected to a sybil network without any idea. I'd be surprised if Tor\nusage was very high amongst Bitcoin users.\n\n> that it reuses addresses (esp for change), that it doesn't clearly\n> distinguish confirmation level.\n\nIt does actually, but the iconography is not very clear. I'm not\nconvinced any users really care about the difference between two and\nthree blocks these days. Maybe exchanges and other security-critical\napplications do, but I doubt desktop users do.\n\nIt's not a library limitation anyway, it's a case of how best to\npresent information to a user who is not familiar with how Bitcoin\nworks. \"Safe\" and \"Not safe\" is still a rather misleading distinction\ngiven the general absence of double spends against mempool\ntransactions, but it's still a lot more meaningful than \"2 confirms\"\nvs \"3 confirms\", something that would just make a new user ask what\nthe heck a confirm is."
            },
            {
                "author": "John Dillon",
                "date": "2013-06-28T10:09:16",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nOn Fri, Jun 28, 2013 at 9:05 AM, Mike Hearn <mike at plan99.net> wrote:\n>> I see some of the the other things that were concerning for me at the\n>> time are still uncorrected though, e.g. no proxy support (so users\n>> can't follow our recommended best practices of using it with Tor),\n>\n> Yeah. That's not the primary privacy issue with bitcoinj though. I'm\n> much, much more concerned about leaks via the block chain than the\n> network layer. Especially as Tor is basically a giant man in the\n> middle, without any kind of authentication you can easily end up\n> connected to a sybil network without any idea. I'd be surprised if Tor\n> usage was very high amongst Bitcoin users.\n\nTor does not act as a particularly effective man in the middle for nodes\nthat support connections to hidden services because while your\nconnections to standard Bitcoin nodes go through your exit node, the\nrouting path for each hidden service peer is independent. Having said\nthat we should offer modes that send your self-generated transactions\nout via Tor, while still maintaining non-Tor connections.\n\nAnyway Sybil attacks aren't all that interesting if you are the one\nsending the funds, and receivers are reasonably well protected simply\nbecause generating false confirmations is extremely expensive and very\ndifficult to do quickly. After all, you always make the assumption that\nnearly all hashing power in existence is honest when you talk about\nreplace-by-fee among other things, and that assumption naturally leads\nto the conclusion that generating false confirmations with a sybil\nattack would take more than long enough that the user would be\nsuspicious that something was wrong long before being defrauded.\n\nI'd be surprised if anyone has ever bothered with a false confirmation\nsybil attack. I wouldn't be the slightest bit surprised if the NSA is\nrecording all the Bitcoin traffic they can for future analysis to find\ntrue transaction origins. Which reminds me, again, we need node-to-node\nconnections to be encrypted to at least protect against network-wide\npassive sniffiing.\n\nRegarding usage I would be interested to hear from those running Bitcoin\nnodes advertising themselves as hidden services.\n\n> It's not a library limitation anyway, it's a case of how best to\n> present information to a user who is not familiar with how Bitcoin\n> works. \"Safe\" and \"Not safe\" is still a rather misleading distinction\n> given the general absence of double spends against mempool\n> transactions, but it's still a lot more meaningful than \"2 confirms\"\n\nFor what it is worth I ran a double-spend generator a month or so ago\nagainst the replace-by-fee node that Peter setup and I found that a\nsmall number of the double-spends did in fact appear to be mined under\nreplace-by-fee rules.\n\nSpecifically the generator would create a transaction from confirmed\ninputs, wait 60-180 seconds (randomized) to allow for full propagation,\nand then create a double-spend if the transaction hadn't already been\nmined. The transactions were randomized to look like normal traffic,\nincluding occasional bets to Satoshidice and similar for fun. (for the\nrecord the script had no way of knowing if a bet won and would happily\nattempt to double-spend wins) Fees for the replacement were power-law\ndistributed IIRC, with some occasionally set to be quite hefty.\n\nThough possibly just an artifact of unusually slow transaction\npropagation it appeared that about 0.25% of hashing power was following\nreplace-by-fee rules. (not including transactions involving gambling, I\nknow Eligius and perhaps others block such transactions from their\nmempools making double-spends easy to accomplish by including\nSatoshidice outputs)\n\nI'm actually surprised by that figure myself given Peter Todd and I\nhaven't made a serious attempt yet to get miners to use replace-by-fee\nrules. An interesting experiment would be to advertise that money is\nbeing given away by such a tx generator in the mining forum, although I\nwould prefer to see solid mempool support for the \"scorched-earth\"\ndouble-spend countermeasure first; Peter sounds like he has some great\nideas there, although as usual I am seeing very little in the way of\ncode. :)\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\n\niQEcBAEBCAAGBQJRzWCOAAoJEEWCsU4mNhiPwhgH/ic/OJMCYwdIuEM2ArSAEQRY\nl5bqafMYMcC/KE9xqZ1HVkLJ9Zg57MQ8VZw95WOsmRgNA0v1xIoCyREjI84QkCIq\nR/hOgS97eJc+XXnPBVoB4Jadq5LQ6jNpJo7cmiLJjCEmE6rTxLZBBT4P3eQw8oIn\nWAd7X7utP7/QAkjhaWB9FsfWT8QZseqpSPv8WucRftsRCABurzuD+eSfpRqYwk2z\nXBD0zO+EyAtu6hB3dRAFhqnhVfEcOLJCtXpm76WO574H4AZ/8EN+HozLJSUtylCq\nj1NZnpj/6pdFh2v5Pid4HEMEvuNNX60u6iXGJ560PUsdKmOh+LEhUBLKd9acJTw=\n=QtjI\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Mike Hearn",
                "date": "2013-06-28T10:20:03",
                "message_text_only": "I suspect what you saw is mining nodes restarting and clearing their\nmempools out rather than an explicit policy of replace by fee.\n\nOn Fri, Jun 28, 2013 at 12:09 PM, John Dillon\n<john.dillon892 at googlemail.com> wrote:\n> -----BEGIN PGP SIGNED MESSAGE-----\n> Hash: SHA256\n>\n> On Fri, Jun 28, 2013 at 9:05 AM, Mike Hearn <mike at plan99.net> wrote:\n>>> I see some of the the other things that were concerning for me at the\n>>> time are still uncorrected though, e.g. no proxy support (so users\n>>> can't follow our recommended best practices of using it with Tor),\n>>\n>> Yeah. That's not the primary privacy issue with bitcoinj though. I'm\n>> much, much more concerned about leaks via the block chain than the\n>> network layer. Especially as Tor is basically a giant man in the\n>> middle, without any kind of authentication you can easily end up\n>> connected to a sybil network without any idea. I'd be surprised if Tor\n>> usage was very high amongst Bitcoin users.\n>\n> Tor does not act as a particularly effective man in the middle for nodes\n> that support connections to hidden services because while your\n> connections to standard Bitcoin nodes go through your exit node, the\n> routing path for each hidden service peer is independent. Having said\n> that we should offer modes that send your self-generated transactions\n> out via Tor, while still maintaining non-Tor connections.\n>\n> Anyway Sybil attacks aren't all that interesting if you are the one\n> sending the funds, and receivers are reasonably well protected simply\n> because generating false confirmations is extremely expensive and very\n> difficult to do quickly. After all, you always make the assumption that\n> nearly all hashing power in existence is honest when you talk about\n> replace-by-fee among other things, and that assumption naturally leads\n> to the conclusion that generating false confirmations with a sybil\n> attack would take more than long enough that the user would be\n> suspicious that something was wrong long before being defrauded.\n>\n> I'd be surprised if anyone has ever bothered with a false confirmation\n> sybil attack. I wouldn't be the slightest bit surprised if the NSA is\n> recording all the Bitcoin traffic they can for future analysis to find\n> true transaction origins. Which reminds me, again, we need node-to-node\n> connections to be encrypted to at least protect against network-wide\n> passive sniffiing.\n>\n> Regarding usage I would be interested to hear from those running Bitcoin\n> nodes advertising themselves as hidden services.\n>\n>> It's not a library limitation anyway, it's a case of how best to\n>> present information to a user who is not familiar with how Bitcoin\n>> works. \"Safe\" and \"Not safe\" is still a rather misleading distinction\n>> given the general absence of double spends against mempool\n>> transactions, but it's still a lot more meaningful than \"2 confirms\"\n>\n> For what it is worth I ran a double-spend generator a month or so ago\n> against the replace-by-fee node that Peter setup and I found that a\n> small number of the double-spends did in fact appear to be mined under\n> replace-by-fee rules.\n>\n> Specifically the generator would create a transaction from confirmed\n> inputs, wait 60-180 seconds (randomized) to allow for full propagation,\n> and then create a double-spend if the transaction hadn't already been\n> mined. The transactions were randomized to look like normal traffic,\n> including occasional bets to Satoshidice and similar for fun. (for the\n> record the script had no way of knowing if a bet won and would happily\n> attempt to double-spend wins) Fees for the replacement were power-law\n> distributed IIRC, with some occasionally set to be quite hefty.\n>\n> Though possibly just an artifact of unusually slow transaction\n> propagation it appeared that about 0.25% of hashing power was following\n> replace-by-fee rules. (not including transactions involving gambling, I\n> know Eligius and perhaps others block such transactions from their\n> mempools making double-spends easy to accomplish by including\n> Satoshidice outputs)\n>\n> I'm actually surprised by that figure myself given Peter Todd and I\n> haven't made a serious attempt yet to get miners to use replace-by-fee\n> rules. An interesting experiment would be to advertise that money is\n> being given away by such a tx generator in the mining forum, although I\n> would prefer to see solid mempool support for the \"scorched-earth\"\n> double-spend countermeasure first; Peter sounds like he has some great\n> ideas there, although as usual I am seeing very little in the way of\n> code. :)\n> -----BEGIN PGP SIGNATURE-----\n> Version: GnuPG v1.4.11 (GNU/Linux)\n>\n> iQEcBAEBCAAGBQJRzWCOAAoJEEWCsU4mNhiPwhgH/ic/OJMCYwdIuEM2ArSAEQRY\n> l5bqafMYMcC/KE9xqZ1HVkLJ9Zg57MQ8VZw95WOsmRgNA0v1xIoCyREjI84QkCIq\n> R/hOgS97eJc+XXnPBVoB4Jadq5LQ6jNpJo7cmiLJjCEmE6rTxLZBBT4P3eQw8oIn\n> WAd7X7utP7/QAkjhaWB9FsfWT8QZseqpSPv8WucRftsRCABurzuD+eSfpRqYwk2z\n> XBD0zO+EyAtu6hB3dRAFhqnhVfEcOLJCtXpm76WO574H4AZ/8EN+HozLJSUtylCq\n> j1NZnpj/6pdFh2v5Pid4HEMEvuNNX60u6iXGJ560PUsdKmOh+LEhUBLKd9acJTw=\n> =QtjI\n> -----END PGP SIGNATURE-----"
            },
            {
                "author": "John Dillon",
                "date": "2013-06-28T10:32:38",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nOn Fri, Jun 28, 2013 at 10:20 AM, Mike Hearn <mike at plan99.net> wrote:\n> I suspect what you saw is mining nodes restarting and clearing their\n> mempools out rather than an explicit policy of replace by fee.\n\nPossibly, but it is a rather short window of opportunity and the mining node\nwould have to be connected directly, to Peter's replace-by-fee node. I also\ntook care to ensure transactions were only ever broadcast once. (I disabled the\nwallet rebroadcast mechanism)\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\n\niQEcBAEBCAAGBQJRzWYWAAoJEEWCsU4mNhiP3fIIAJLFxMnjI4BGRrNLsxs0hXp0\nzDCgiZ6UnZa5JRcd/6KjV3hnPHwweGEjChGfrzY/Fxo4Pga1lQFlp8E8PaFUJq50\nr6LTNJQLW50r5mFkZ6Mkh877WwX/OHBzkp8SqbbD7+dDBV7R9LqLYqLTHgObKxg1\nV9UjGRJiMohW8HLdOzEXOz1ugoBCjR+vyQW5ZD2nZVcQlIhxSIgeC/M46oxMN7pE\nY5EepCQehNPuc1On7TtJ9LlmFJ6Dvsl6dqwKNWMi1lgBTiw7abdTJne2B/KeDyom\nvhGuhmpMLGKKgJns3hne3yQM+Ivi3jLIHKejcoCm1JkSCdjw48XkyGd0V359M3w=\n=qyyq\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Peter Todd",
                "date": "2013-06-30T10:12:39",
                "message_text_only": "On Fri, Jun 28, 2013 at 10:09:16AM +0000, John Dillon wrote:\n> true transaction origins. Which reminds me, again, we need node-to-node\n> connections to be encrypted to at least protect against network-wide\n> passive sniffiing.\n\nAgreed.\n\nSpeaking of, I may have missed it but as far as I can tell Bitmessage\ndoesn't encrypt node-to-node communications, a serious oversight. Any\nattacker that can sniff a large fraction of the network, like the NSA,\ncan easily use this to track down the originating node of any message,\njust like they can do with Bitcoin.\n\n> For what it is worth I ran a double-spend generator a month or so ago\n> against the replace-by-fee node that Peter setup and I found that a\n> small number of the double-spends did in fact appear to be mined under\n> replace-by-fee rules.\n\nAh! I had a feeling that might be you. Were you the person who was\ncreating the 1BTC fee transactions as well?\n\n> Though possibly just an artifact of unusually slow transaction\n> propagation it appeared that about 0.25% of hashing power was following\n> replace-by-fee rules. (not including transactions involving gambling, I\n> know Eligius and perhaps others block such transactions from their\n> mempools making double-spends easy to accomplish by including\n> Satoshidice outputs)\n\nI just got an email from someone saying they had a few Avalons with that\npatch installed actually; that was probably them.\n\n> I'm actually surprised by that figure myself given Peter Todd and I\n> haven't made a serious attempt yet to get miners to use replace-by-fee\n> rules. An interesting experiment would be to advertise that money is\n> being given away by such a tx generator in the mining forum, although I\n> would prefer to see solid mempool support for the \"scorched-earth\"\n> double-spend countermeasure first; Peter sounds like he has some great\n> ideas there, although as usual I am seeing very little in the way of\n> code. :)\n\nKeep in mind it's not just the mempool that needs changing - the network\nprotocol semantics need to change too. For the \"scorched-earth\" strategy\nto work you need nodes tell their peers about the total fees a\ntransaction has attached in addition tot he tx hash. Essentially you are\nadvertising to your peers what would right now be an orphan, and your\npeers need to recursively get dependencies; I'm sure there's a bunch of\nedge cases there that would be need to thought out carefully. It's\nuseful for a lot of things though, for instance when a zero-fee,\nzero-priority tx is given to a merchant who now wants to tell miners to\nmine it anyway due to a child tx.\n\nWhat I'd recommend actually for the nearer term is just adding recursive\nfee evaluation with a depth*breadth anti-DoS limit, adding the rpc and\nGUI adjfee and canceltx commands, adding better wallet support for\nconflicts, (someone is already workng on this) and adding a service bit\nwith preferential peering.\n\nBy preferential peering I mean you set aside a portion of your outgoing\npeer slots for peers with certain bits set and only fill those slots\nwith those peers. In addition you can have DNS seeds return peers with\nspecified service bits set: x0000000000000003.v1.seed.petertodd.org\ncould be nodes with the first and second bits set. (we might want to\ndefine the upper 8 service bits as a service bit version field so we can\nredefine the other 56 in the far off future if required)\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000b2b1f2ca2a2f937c2d93c41a5d089e1d3d4fe6bb663dd25db5\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130630/6b399767/attachment.sig>"
            },
            {
                "author": "Bill Hees",
                "date": "2013-06-28T20:37:04",
                "message_text_only": "There are good, valid arguments in support of promoting both the reference\nclient, Bitcoin-QT, and for offering a lighter-weight alternative. Why not\noutline these arguments on bitcoin.org and provide links to each; or even\nlinks to a variety of alternative wallet solutions alongside descriptions\nof their respective benefits and drawbacks? Is there an advantage to having\na singular \"recommended\" client?\n\n\nOn Fri, Jun 28, 2013 at 1:35 PM, Bill Hees <billhees at gmail.com> wrote:\n\n> There are good, valid arguments in support of promoting both the reference\n> client, Bitcoin-QT, and for offering a lighter-weight alternative. Why not\n> outline these arguments on bitcoin.org and provide links to each; or even\n> links to a variety of alternative wallet solutions alongside descriptions\n> of their respective benefits and drawbacks? Is there an advantage to having\n> a singular \"recommended\" client?\n>\n>\n> On Fri, Jun 28, 2013 at 7:24 AM, Gavin Andresen <gavinandresen at gmail.com>wrote:\n>\n>> I vote \"yes\" to have MultiBit replace Bitcoin-Qt as the recommended\n>> desktop wallet app. I think most users will be happier with it.\n>>\n>> If I'm wrong, it is easy to change back.\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> This SF.net email is sponsored by Windows:\n>>\n>> Build for Windows Store.\n>>\n>> http://p.sf.net/sfu/windows-dev2dev\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130628/09f689ed/attachment.html>"
            },
            {
                "author": "Jim",
                "date": "2013-06-28T20:42:27",
                "message_text_only": "There are already descriptions as you describe on:\nhttp://bitcoin.org/en/choose-your-wallet. \n\nIf you hover over any of the wallet icons you get a description and a\nlink.\n\nPeople being people, we find in practice that the very first wallet link \non the page is what the majority of new users click.\n\n\n\nOn Fri, Jun 28, 2013, at 09:37 PM, Bill Hees wrote:\n> There are good, valid arguments in support of promoting both the\n> reference\n> client, Bitcoin-QT, and for offering a lighter-weight alternative. Why\n> not\n> outline these arguments on bitcoin.org and provide links to each; or even\n> links to a variety of alternative wallet solutions alongside descriptions\n> of their respective benefits and drawbacks? Is there an advantage to\n> having\n> a singular \"recommended\" client?\n> \n> \n> On Fri, Jun 28, 2013 at 1:35 PM, Bill Hees <billhees at gmail.com> wrote:\n> \n> > There are good, valid arguments in support of promoting both the reference\n> > client, Bitcoin-QT, and for offering a lighter-weight alternative. Why not\n> > outline these arguments on bitcoin.org and provide links to each; or even\n> > links to a variety of alternative wallet solutions alongside descriptions\n> > of their respective benefits and drawbacks? Is there an advantage to having\n> > a singular \"recommended\" client?\n> >\n> >\n> > On Fri, Jun 28, 2013 at 7:24 AM, Gavin Andresen <gavinandresen at gmail.com>wrote:\n> >\n> >> I vote \"yes\" to have MultiBit replace Bitcoin-Qt as the recommended\n> >> desktop wallet app. I think most users will be happier with it.\n> >>\n> >> If I'm wrong, it is easy to change back.\n> >>\n> >>\n> >> ------------------------------------------------------------------------------\n> >> This SF.net email is sponsored by Windows:\n> >>\n> >> Build for Windows Store.\n> >>\n> >> http://p.sf.net/sfu/windows-dev2dev\n> >> _______________________________________________\n> >> Bitcoin-development mailing list\n> >> Bitcoin-development at lists.sourceforge.net\n> >> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> >>\n> >\n> >\n> ------------------------------------------------------------------------------\n> This SF.net email is sponsored by Windows:\n> \n> Build for Windows Store.\n> \n> http://p.sf.net/sfu/windows-dev2dev\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n\n-- \nhttps://multibit.org    Money, reinvented"
            }
        ],
        "thread_summary": {
            "title": "Proposal: MultiBit as default desktop client on bitcoin.org",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Luke-Jr",
                "Jim",
                "John Dillon",
                "Caleb James DeLisle",
                "Alex Kravets",
                "Mike Hearn",
                "Bill Hees",
                "Peter Todd",
                "Gregory Maxwell",
                "Gavin Andresen",
                "Gary Rowe"
            ],
            "messages_count": 27,
            "total_messages_chars_count": 64751
        }
    }
]