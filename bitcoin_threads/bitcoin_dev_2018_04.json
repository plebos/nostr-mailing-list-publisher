[
    {
        "title": "[bitcoin-dev] feature: Enhance privacy by change obfuscation",
        "thread_messages": [
            {
                "author": "Damian Williamson",
                "date": "2018-04-01T14:37:13",
                "message_text_only": "I note that Electrum v3.0.6 has an option to use multiple change addresses. It is off by default.\n\n\nRegards,\n\nDamian Williamson\n\n________________________________\nFrom: Eric Voskuil <eric at voskuil.org>\nSent: Monday, 19 March 2018 5:59:28 AM\nTo: Evan Klitzke; Bitcoin Protocol Discussion\nCc: Damian Williamson\nSubject: Re: [bitcoin-dev] feature: Enhance privacy by change obfuscation\n\n> This would be really expensive for the network due to the bloat in UTXO size, a cost everyone has to pay for.\n\nWithout commenting on the merits of this proposal, I\u2019d just like to correct this common misperception. There is no necessary additional cost to the network from the count of unspent outputs. This perception arises from an implementation detail of particular node software. There is no requirement for redundant indexing of unspent outputs.\n\ne\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180401/c0f282f8/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "feature: Enhance privacy by change obfuscation",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Damian Williamson"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1023
        }
    },
    {
        "title": "[bitcoin-dev] Low-bandwidth transaction relay",
        "thread_messages": [
            {
                "author": "Gleb Naumenko",
                "date": "2018-04-02T22:18:07",
                "message_text_only": "Hi all,\nI have a couple of ideas regarding transaction relay protocol and wanted to share it with and probably get some feedback.\n\nI did some emulation and simulation and found out that around 90% of INV messages sent by public-IP nodes are idle (duplicate), obviously because each node creates 8 connections. \u00a0I also realized that sending INV messages is a significant part of the overall bandwidth consumed by a public-IP node. At a larger scale, this will result in people not able to run a public-IP node.\n\nMy idea is in some sense similar to BIP37 but applied to public-IP nodes. Here I want to emphasize that all the nodes will still receive *all* of the transactions. A new protocol should also keep the same zero-trust, robustness, decentralization guarantees and latency.\n\nIdea: while joining the network, a new node agrees on some filter with each of 8 nodes it connects to. So that NewNode <-> Node_A will be used to relay only a subset of transactions, NewNode <-> Node_B for another subset. This will significantly decrease the redundancy.\n\nTo keep the guarantees, I would keep some redundancy (for example, each transaction INV is sent over 2 links).\n\nTo make it robust to attacks, I have 2 extensions in my mind:\n1. Set reconciliation (for a subset of transactions) with *other* nodes. Getting a bloom filter of a subset of the mempool transactions from Node_B may help to figure out whether Node_A is malicious, very slow, etc.\n2. Rotating the filters every N minutes (N < 10)\n\nI can see some issues with latency here, but I believe this problem has a solution.\n\nFeedback is appreciated!\n\nIf you want to look at a draft of the proposal \u2014 please let me know.\nIf there were any similar ideas \u2014 please let me know.\n\nBest,\nGleb\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180402/a990f1dc/attachment.html>"
            },
            {
                "author": "Jim Posen",
                "date": "2018-04-03T17:45:34",
                "message_text_only": "Hey. This idea sounds quite interesting. It'd be helpful to see some more\nnumbers to evaluate it.\n\n- How much bandwidth is consumed by redundant tx INVs currently? What is\nthis as a % of overall bandwidth usage?\n- How would filtering txs through N=2 links affect network propagation?\nThis probably requires simulation to determine.\n- Do you propose setting filters on inbound peers as well?\n\nOn Mon, Apr 2, 2018 at 3:18 PM, Gleb Naumenko via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi all,\n> I have a couple of ideas regarding transaction relay protocol and wanted\n> to share it with and probably get some feedback.\n>\n> I did some emulation and simulation and found out that around 90% of INV\n> messages sent by public-IP nodes are idle (duplicate), obviously because\n> each node creates 8 connections.  I also realized that sending INV messages\n> is a significant part of the overall bandwidth consumed by a public-IP\n> node. At a larger scale, this will result in people not able to run a\n> public-IP node.\n>\n> My idea is in some sense similar to BIP37 but applied to public-IP nodes.\n> Here I want to emphasize that all the nodes will still receive *all* of the\n> transactions. A new protocol should also keep the same zero-trust,\n> robustness, decentralization guarantees and latency.\n>\n> Idea: while joining the network, a new node agrees on some filter with\n> each of 8 nodes it connects to. So that NewNode <-> Node_A will be used to\n> relay only a subset of transactions, NewNode <-> Node_B for another subset.\n> This will significantly decrease the redundancy.\n>\n> To keep the guarantees, I would keep some redundancy (for example, each\n> transaction INV is sent over 2 links).\n>\n> To make it robust to attacks, I have 2 extensions in my mind:\n> 1. Set reconciliation (for a subset of transactions) with *other* nodes.\n> Getting a bloom filter of a subset of the mempool transactions from Node_B\n> may help to figure out whether Node_A is malicious, very slow, etc.\n> 2. Rotating the filters every N minutes (N < 10)\n>\n> I can see some issues with latency here, but I believe this problem has a\n> solution.\n>\n> Feedback is appreciated!\n>\n> If you want to look at a draft of the proposal \u2014 please let me know.\n> If there were any similar ideas \u2014 please let me know.\n>\n> Best,\n> Gleb\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180403/89d5a284/attachment.html>"
            },
            {
                "author": "Gleb Naumenko",
                "date": "2018-04-04T02:10:56",
                "message_text_only": "Yeah, sure.\n\n> How much bandwidth is consumed by redundant tx INVs currently?\nCurrently, for an average public-IP node all INVs consume 0.05 Mbps or 540 megabytes per day. This number is based on current ratio public-IP nodes:private-IP nodes and transaction rate. This number is a sum of both incoming and outgoing aspects. Thus redundant INV\u2019s on average consume 0.044 Mbps or 475 megabytes per day.\n\n> What is this as a % of overall bandwidth usage?\nThis is hard to estimate because overall bandwidth includes helping other nodes to bootstrap from scratch. If we don\u2019t consider this aspect, my very rough estimate, and a short experiment shows that INV\u2019s are around 50% of overall bandwidth (it also depends on different factors like your hardware comparing to other public-IP nodes). I\u2019m going to double-check this number soon.\n\n> How would filtering txs through N=2 links affect network propagation?\nYes, network propagation for a new protocol definitely worth measuring. I\u2019m going to look at it in the near future.\n\n> Do you propose setting filters on inbound peers as well?\nThis is a good question.\nI think some filter may be applied to inbound connections. Theoretically, a symmetrical filter does not make much sense \u2014 it might be eventually the same filter for all of the connections except first 8 outgoing ones, so it\u2019s better to use independent filters.\nHowever, I\u2019m not entirely sure it is needed. Filters on inbound peers will reduce a download aspect. It might be much less critical than upload (if we assume that private-IP nodes hear about transactions later because those have much fewer connections). I think this question needs another experiment.\n\nOn Apr 3, 2018, 10:45 AM -0700, Jim Posen <jim.posen at gmail.com>, wrote:\n> Hey. This idea sounds quite interesting. It'd be helpful to see some more numbers to evaluate it.\n>\n> - How much bandwidth is consumed by redundant tx INVs currently? What is this as a % of overall bandwidth usage?\n> - How would filtering txs through N=2 links affect network propagation? This probably requires simulation to determine.\n> - Do you propose setting filters on inbound peers as well?\n>\n> > On Mon, Apr 2, 2018 at 3:18 PM, Gleb Naumenko via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > > Hi all,\n> > > I have a couple of ideas regarding transaction relay protocol and wanted to share it with and probably get some feedback.\n> > >\n> > > I did some emulation and simulation and found out that around 90% of INV messages sent by public-IP nodes are idle (duplicate), obviously because each node creates 8 connections.\u00a0 I also realized that sending INV messages is a significant part of the overall bandwidth consumed by a public-IP node. At a larger scale, this will result in people not able to run a public-IP node.\n> > >\n> > > My idea is in some sense similar to BIP37 but applied to public-IP nodes. Here I want to emphasize that all the nodes will still receive *all* of the transactions. A new protocol should also keep the same zero-trust, robustness, decentralization guarantees and latency.\n> > >\n> > > Idea: while joining the network, a new node agrees on some filter with each of 8 nodes it connects to. So that NewNode <-> Node_A will be used to relay only a subset of transactions, NewNode <-> Node_B for another subset. This will significantly decrease the redundancy.\n> > >\n> > > To keep the guarantees, I would keep some redundancy (for example, each transaction INV is sent over 2 links).\n> > >\n> > > To make it robust to attacks, I have 2 extensions in my mind:\n> > > 1. Set reconciliation (for a subset of transactions) with *other* nodes. Getting a bloom filter of a subset of the mempool transactions from Node_B may help to figure out whether Node_A is malicious, very slow, etc.\n> > > 2. Rotating the filters every N minutes (N < 10)\n> > >\n> > > I can see some issues with latency here, but I believe this problem has a solution.\n> > >\n> > > Feedback is appreciated!\n> > >\n> > > If you want to look at a draft of the proposal \u2014 please let me know.\n> > > If there were any similar ideas \u2014 please let me know.\n> > >\n> > > Best,\n> > > Gleb\n> > >\n> > >\n> > > _______________________________________________\n> > > bitcoin-dev mailing list\n> > > bitcoin-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> > >\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180403/91b04bda/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2018-04-03T19:05:40",
                "message_text_only": "On Mon, Apr 2, 2018 at 10:18 PM, Gleb Naumenko via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Hi all,\n> I have a couple of ideas regarding transaction relay protocol and wanted to\n> share it with and probably get some feedback.\n\nhttps://bitcointalk.org/index.php?topic=1377345.0\n\nhttps://people.xiph.org/~greg/mempool_sync_relay.txt"
            },
            {
                "author": "Gleb Naumenko",
                "date": "2018-04-04T04:55:45",
                "message_text_only": "Thanks for the links!\n\nBlocksonly is definitely a relevant piece. However, I\u2019m wondering what are the implications, especially at larger scale. For example, transactions processing will be not smooth anymore and will happen every 10 minutes at once. Another question is transaction propagation.\n\nI think what I\u2019ve proposed does not have those implications. Well, propagation is still a concern, but it\u2019s not that extreme. One weakness of my idea is relative complexity comparing to blocksonly.\n\nAnother variation of the idea I described might work without INVs at all \u00a0(then N=1 and transactions are relayed through 1 link only, during the time between blocks) and it would have the same security assumptions as blocksonly.\n\nYour IBLT and BCH-sets proposals sound very promising. I had something like that on mind, but I decided to start with a more conservative protocol.\nIt looks like sync-relay idea has a lot of interesting questions, I\u2019m excited to follow that research.\n\nOn Apr 3, 2018, 12:04 PM -0700, Gregory Maxwell <gmaxwell at gmail.com>, wrote:\n> On Mon, Apr 2, 2018 at 10:18 PM, Gleb Naumenko via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > Hi all,\n> > I have a couple of ideas regarding transaction relay protocol and wanted to\n> > share it with and probably get some feedback.\n>\n>\n>\n> https://bitcointalk.org/index.php?topic=1377345.0\n>\n> https://people.xiph.org/~greg/mempool_sync_relay.txt\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180403/44e266d0/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Low-bandwidth transaction relay",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Jim Posen",
                "Gregory Maxwell",
                "Gleb Naumenko"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 11122
        }
    },
    {
        "title": "[bitcoin-dev] Signature bundles",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2018-04-02T23:46:45",
                "message_text_only": "Hi all!\n\n        Since there's activity on new signature types, I think it's\nworth considering a more flexible alternative to\nSIGHASH_SINGLE|SIGHASH_ANYONECANPAY.  See Usefulness for why.\n\nProposal: Two bits: SIGHASH_BUNDLESTART/SIGHASH_INBUNDLE\n--------\n\nA signature needs to indicate that signs only part of a transaction's\ninputs and outputs (a.k.a. a \"bundle\").  Bundles can be combined\ntogether into larger transactions, and non-bundled signature inputs /\noutputs appended.\n\nTwo per-tx counters are kept: bundle_inputs_used and\nbundle_outputs_used, both starting at 0.\n\nSIGHASH_BUNDLESTART indicates two var_int sit between the sighash flags\nand the signature itself: the first is the number of inputs in this\nbundle starting at bundle_inputs_used, the second is the number of\noutputs starting at bundle_outputs_used.  bundle_inputs_used and\nbundle_outputs_used have these values added, for next time.\n\nSIGHASH_INBUNDLE indicates that this signature applies to the current\nbundle.  The txCopy is reduced to cover only the inputs and\noutputs in the current bundle, and the signature commits to the two\nvar_ints from SIGHASH_BUNDLESTART along with the sighash flags.\n\n(A proper BIP would detail how any weird stuff makes the tx invalid:\ntake that as read).\n\nUsage\n-----\nYou can use this to sign a transaction just like now, with only two\nextra bytes and these SIGHASH flags.  But this transaction can now be\naggregated by pasting on another bundle, or attaching other normal\ninputs and/or outputs.  You can aggregate as many transactions as you\nwant this way.\n\nUsefulness\n----------\n\nOne of the issues we've struck with lightning is trying to guess future\nfees for commitment transactions: we can't rely on getting another\nsignature from our counterparty to increase fees.  Nor can we use\nparent-pays-for-child since the outputs we can spend are timelocked.\n\nThis \"holding a valid tx but I want to add fees later without\nre-signing\" seems like a general problem.  The only current method would\nbe to engineer transactions as a single-input-single-output tx and use\nSIGHASH_SINGLE|SIGHASH_ANYONECANPAY; this is very limiting.\n\nThe other obvious application would be to run public aggregators, which\nwould provide throughput promises (\"if you send me a tx with feerate X,\nI will make sure it goes onchain within a week\").  This service would\nsometimes profit, if it can do so cheaper than it quoted, and sometimes\nhave to add additional fees.  The existence of such services should\nsmooth the current fee cliff by allowing users and services to offer\n\"slow mode\" payment options without requiring interaction.\n\nFeedback welcome!\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2018-04-03T03:57:23",
                "message_text_only": "On Tue, Apr 03, 2018 at 09:16:45AM +0930, Rusty Russell via bitcoin-dev wrote:\n> Proposal: Two bits: SIGHASH_BUNDLESTART/SIGHASH_INBUNDLE\n> --------\n> \n> A signature needs to indicate that signs only part of a transaction's\n> inputs and outputs (a.k.a. a \"bundle\").  Bundles can be combined\n> together into larger transactions, and non-bundled signature inputs /\n> outputs appended.\n\n> Two per-tx counters are kept: bundle_inputs_used and\n> bundle_outputs_used, both starting at 0.\n> \n> SIGHASH_BUNDLESTART indicates two var_int sit between the sighash flags\n> and the signature itself: the first is the number of inputs in this\n> bundle starting at bundle_inputs_used, the second is the number of\n> outputs starting at bundle_outputs_used.  bundle_inputs_used and\n> bundle_outputs_used have these values added, for next time.\n> \n> SIGHASH_INBUNDLE indicates that this signature applies to the current\n> bundle.  The txCopy is reduced to cover only the inputs and\n> outputs in the current bundle, and the signature commits to the two\n> var_ints from SIGHASH_BUNDLESTART along with the sighash flags.\n\nSo suppose you have two bundles you want to combine together, and they\ndidn't pay enough fees, so you have an extra input so you can bump up the\nfees. Your tx looks like:\n\nbundle 1:\n  input 1:   500 bits, signed by key A [pre]\n  input 2:   500 bits, signed by key B [pre]\n  input 3:   500 bits, signed by key C\n  output 1: 1450 bits\nbundle 2:\n  input 3:   600 bits, signed by key D [pre]\n  output 2:  200 bits\n  output 3:  380 bits\nextra:\n  input 4:  2000 bits, signed by key E\n  output 4:  864 bits\n\nKeys A, B and D have pre-signed their respective bundle, but you have\ncontrol over keys C and E at the time you're constructing the transaction.\n\nSo the things you'd have to do when signing would be:\n\n  A,B,C decide on an order for the inputs and outputs (ideally just sort them)\n  Because A turns out to be first, A signs with BUNDLESTART[3,1] INBUNDLE\n  Because B is second, B just signs with INBUNDLE\n\n  D just signs with BUNDLESTART[3,1] INBUNDLE\n\n  And finally they get collected and C and E signs the entire transaction\n  with SIGHASH_ALL\n\nAll bundles have to appear together, before any extra inputs; though they\ncan be reordered arbitrarily prior to adding the SIGHASH_ALL sigs.\n\nIf you've got one bundle that overpays fees and another that underpays,\nyou can safely combine the two only if you can put a SIGHASH_ALL sig in\nthe one that overpays (otherwise miners could just make their own tx of\njust the overpaying bundle).\n\nThis could replace SINGLE|ANYONECANPAY at a cost of an extra couple of\nwitness bytes.\n\nI think BUNDLESTART is arguably redundant -- you could just infer\nBUNDLESTART if you see an INBUNDLE flag when you're not already in\na bundle. Probably better to have the flag to make parsing easier,\nso just have the rule be BUNDLESTART is set for precisely the first\nINBUNDLE signature since the last bundle finished.\n\nShould be straightforward to establish BIP-69-style ordering rules too:\nwithin a bundle, order inputs lexically, then order outputs lexically;\norder bundles lexically by the first input; order remaining inputs\nlexically, then order remaining outputs lexically.\n\nI think the only reason to do bundling like this (rather than just post\nseparate transactions) is to deal with fees? It doesn't seem like you gain\nany privacy -- the inputs/outputs in each bundle are tightly related, and\nyou're only saving about 10 bytes due to sharing a transaction structure.\n\nAnyway, seems like it makes sense. \n\n> One of the issues we've struck with lightning is trying to guess future\n> fees for commitment transactions: we can't rely on getting another\n> signature from our counterparty to increase fees.  Nor can we use\n> parent-pays-for-child since the outputs we can spend are timelocked.\n\nThat doesn't quite work with the HTLC-Success/HTLC-Timeout transactions\nthough, does it? They spend outputs from the commitment transaction\nand need to be pre-signed by your channel partner in order to ensure\nthe output address is correct -- but if the commitment transaction gets\nbundled, its txid will change, so it can't be pre-signed.\n\nFWIW, a dumb idea I had for this problem was to add a zero-value\nanyone-can-spend output to commitment transactions, that can then be\nused with CPFP to bump the fees. Not very nice for UTXO bloat if fee\nbumping isn't needed though, and I presume it would fail to pass the\ndust threshold...\n\nI wonder if it would be plausible to have after-the-fact fee-bumping\nvia special sighash flags at the block level anyway though. Concretely:\nsay you have two transactions, X and Y, that don't pay enough in fees,\nyou then provide a third transaction whose witness is [txid-for-X,\ntxid-for-Y, signature committing to (txid-for-X, txid-for-Y)], and can\nonly be included in a block if X and Y are also in the same block. You\ncould make that fairly concise if you allowed miners to replace txid-for-X\nwith X's offset within the block (or the delta between X's txnum and the\nthird transaction's txnum), though coding that probably isn't terribly\nstraightforward.\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2018-04-03T05:31:24",
                "message_text_only": "Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:\n> If you've got one bundle that overpays fees and another that underpays,\n> you can safely combine the two only if you can put a SIGHASH_ALL sig in\n> the one that overpays (otherwise miners could just make their own tx of\n> just the overpaying bundle).\n\nThis is a potential problem, yes :( And I'm not sure how to solve it,\nunless you do some crazy thing like commit to a set of keys which are\nallowed to bundle, which kind of defeats the generality of outsourcing.\n\n> This could replace SINGLE|ANYONECANPAY at a cost of an extra couple of\n> witness bytes.\n>\n> I think BUNDLESTART is arguably redundant -- you could just infer\n> BUNDLESTART if you see an INBUNDLE flag when you're not already in\n> a bundle. Probably better to have the flag to make parsing easier,\n> so just have the rule be BUNDLESTART is set for precisely the first\n> INBUNDLE signature since the last bundle finished.\n\nIndeed.\n\n>> One of the issues we've struck with lightning is trying to guess future\n>> fees for commitment transactions: we can't rely on getting another\n>> signature from our counterparty to increase fees.  Nor can we use\n>> parent-pays-for-child since the outputs we can spend are timelocked.\n>\n> That doesn't quite work with the HTLC-Success/HTLC-Timeout transactions\n> though, does it? They spend outputs from the commitment transaction\n> and need to be pre-signed by your channel partner in order to ensure\n> the output address is correct -- but if the commitment transaction gets\n> bundled, its txid will change, so it can't be pre-signed.\n\nNot without SIGHASH_NOINPUT, no.\n\n> FWIW, a dumb idea I had for this problem was to add a zero-value\n> anyone-can-spend output to commitment transactions, that can then be\n> used with CPFP to bump the fees. Not very nice for UTXO bloat if fee\n> bumping isn't needed though, and I presume it would fail to pass the\n> dust threshold...\n\nYeah, let's not do that.\n\n> I wonder if it would be plausible to have after-the-fact fee-bumping\n> via special sighash flags at the block level anyway though. Concretely:\n> say you have two transactions, X and Y, that don't pay enough in fees,\n> you then provide a third transaction whose witness is [txid-for-X,\n> txid-for-Y, signature committing to (txid-for-X, txid-for-Y)], and can\n> only be included in a block if X and Y are also in the same block. You\n> could make that fairly concise if you allowed miners to replace txid-for-X\n> with X's offset within the block (or the delta between X's txnum and the\n> third transaction's txnum), though coding that probably isn't terribly\n> straightforward.\n\nWhat would it spend though?  Can't use an existing output, so this\nreally needs to be stashed in an *output script*, say a zero-amount\noutput which is literally a push of txids, and is itself unspendable.\n\n        <txid1>... <txidN>\n\nThat's pretty large though, and it's non-witness data (though\ndiscardable).  How about 'OP_NOP4 <N> <ripemd160-of-last-N-txids>'?\nThen the miner just bundles those tx all together?\n\nCheers,\nRusty."
            },
            {
                "author": "Jim Posen",
                "date": "2018-04-04T23:11:52",
                "message_text_only": "I'll just mention that non-interactive one-way aggregation with BLS\nsignatures solves this problem rather nicely.\n\nOn Mon, Apr 2, 2018 at 10:31 PM, Rusty Russell via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> writes:\n> > If you've got one bundle that overpays fees and another that underpays,\n> > you can safely combine the two only if you can put a SIGHASH_ALL sig in\n> > the one that overpays (otherwise miners could just make their own tx of\n> > just the overpaying bundle).\n>\n> This is a potential problem, yes :( And I'm not sure how to solve it,\n> unless you do some crazy thing like commit to a set of keys which are\n> allowed to bundle, which kind of defeats the generality of outsourcing.\n>\n> > This could replace SINGLE|ANYONECANPAY at a cost of an extra couple of\n> > witness bytes.\n> >\n> > I think BUNDLESTART is arguably redundant -- you could just infer\n> > BUNDLESTART if you see an INBUNDLE flag when you're not already in\n> > a bundle. Probably better to have the flag to make parsing easier,\n> > so just have the rule be BUNDLESTART is set for precisely the first\n> > INBUNDLE signature since the last bundle finished.\n>\n> Indeed.\n>\n> >> One of the issues we've struck with lightning is trying to guess future\n> >> fees for commitment transactions: we can't rely on getting another\n> >> signature from our counterparty to increase fees.  Nor can we use\n> >> parent-pays-for-child since the outputs we can spend are timelocked.\n> >\n> > That doesn't quite work with the HTLC-Success/HTLC-Timeout transactions\n> > though, does it? They spend outputs from the commitment transaction\n> > and need to be pre-signed by your channel partner in order to ensure\n> > the output address is correct -- but if the commitment transaction gets\n> > bundled, its txid will change, so it can't be pre-signed.\n>\n> Not without SIGHASH_NOINPUT, no.\n>\n> > FWIW, a dumb idea I had for this problem was to add a zero-value\n> > anyone-can-spend output to commitment transactions, that can then be\n> > used with CPFP to bump the fees. Not very nice for UTXO bloat if fee\n> > bumping isn't needed though, and I presume it would fail to pass the\n> > dust threshold...\n>\n> Yeah, let's not do that.\n>\n> > I wonder if it would be plausible to have after-the-fact fee-bumping\n> > via special sighash flags at the block level anyway though. Concretely:\n> > say you have two transactions, X and Y, that don't pay enough in fees,\n> > you then provide a third transaction whose witness is [txid-for-X,\n> > txid-for-Y, signature committing to (txid-for-X, txid-for-Y)], and can\n> > only be included in a block if X and Y are also in the same block. You\n> > could make that fairly concise if you allowed miners to replace\n> txid-for-X\n> > with X's offset within the block (or the delta between X's txnum and the\n> > third transaction's txnum), though coding that probably isn't terribly\n> > straightforward.\n>\n> What would it spend though?  Can't use an existing output, so this\n> really needs to be stashed in an *output script*, say a zero-amount\n> output which is literally a push of txids, and is itself unspendable.\n>\n>         <txid1>... <txidN>\n>\n> That's pretty large though, and it's non-witness data (though\n> discardable).  How about 'OP_NOP4 <N> <ripemd160-of-last-N-txids>'?\n> Then the miner just bundles those tx all together?\n>\n> Cheers,\n> Rusty.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180404/12cf9858/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Signature bundles",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Anthony Towns",
                "Jim Posen"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 14650
        }
    },
    {
        "title": "[bitcoin-dev] Optimized Header Sync",
        "thread_messages": [
            {
                "author": "Jim Posen",
                "date": "2018-04-03T05:34:39",
                "message_text_only": "Thank you for your feedback AJ and Riccardo.\n\nNice observation about using nBits from every 2016th block as a short\nspecifier of chain work. You can get some savings from the 4 byte nBits\nencoding over VLQ for total chain work as in my spec.\n\nI tried it out on the current chain. At block height 516,387, there are 258\ntotal checkpoints in the response payload with an interval of 2016. The\nsize of the checkpts message is:\n\n- 9,304 bytes using hash + nBits\n- 10,934 bytes using hash + chain work delta encoded as VLQ\n- 11,030 bytes using hash + chain work total encoded as VLQ\n\nThe saving from using deltas instead of the total seems negligible to me\nespecially considering the additional computation it requires. Going from\ntotal chain work as VLQ to nBits is a 16% savings in the size of a checkpts\nmessage. According to some rather rough benchmarks, it takes ~3us to\ngenerate the message with nBits versus ~105us to generate each message with\nVLQ chain work (including block index lookups and serialization time).\n\nThe downside, however, is that the new P2P message would be tightly coupled\nto a specific parameter in Bitcoin's consensus protocol, and one that is\nchanged in many alt chains. Also, it would require that checkpoints can\nonly be fetched at intervals of 2016, instead of intervals chosen by the\nclients. Being able to specify the interval is a very nice property for\nlonger chains, where a client may select really large intervals, then\nbisect that range even further to request a smaller PoW sample (eg. start\nby fetching every 10,000th, then every 100th).\n\nPersonally, I strongly think using total chain work instead of nBits is the\nright tradeoff and is worth the extra 1KB. I'm curious to hear others'\nopinions. Note that the checkpoints message is only fetched once per peer\nper download from genesis. Subsequent catchups only fetch checkpoints from\nthe locator fork point. I also don't find the caching argument compelling\n-- the time to generate checkpts response messages is fast enough anyway.\n\nI also finally got around to pulling numbers on the space savings from the\nnVersion omission. As a reminder of how this works, three bits in the\nencoding indicator represent a value 1-7 of the distance in block height\nsince another block with the same version. Looking at the current Bitcoin\nmain chain, this is a table of the occurrences of these values:\n\nHeight distance # of Blocks\n1 469537\n2 22301\n3 8833\n4 4368\n5 2633\n6 1630\n7 1114\n                     8+ 5967\nYou can read this as \"469,537 blocks have the same version as their\nparent\", \"22,301 have the same version as their parent's parent\", etc.\nGiven the information in this table, we may consider only allocating 2 bits\nin the encoding header rather than 3.\n\nOn Fri, Mar 30, 2018 at 1:06 AM, Riccardo Casatta <\nriccardo.casatta at gmail.com> wrote:\n\n> Yes, I think the checkpoints and the compressed headers streams should be\n> handled in chunks of 2016 headers and queried by chunk number instead of\n> height, falling back to current method if the chunk is not full yet.\n>\n> This is cache friendly and allows to avoid bit 0 and bit 1 in the bitfield\n> (because they are always 1 after the first header in the chunk of 2016).\n>\n> 2018-03-30 8:14 GMT+02:00 Anthony Towns <aj at erisian.com.au>:\n>\n>> On Thu, Mar 29, 2018 at 05:50:30PM -0700, Jim Posen via bitcoin-dev wrote:\n>> > Taken a step further though, I'm really interested in treating the\n>> checkpoints\n>> > as commitments to chain work [...]\n>>\n>> In that case, shouldn't the checkpoints just be every 2016 blocks and\n>> include the corresponding bits value for that set of blocks?\n>>\n>> That way every node commits to (approximately) how much work their entire\n>> chain has by sending something like 10kB of data (currently), and you\n>> could verify the deltas in each node's chain's target by downloading the\n>> 2016 headers between those checkpoints (~80kB with the proposed compact\n>> encoding?) and checking the timestamps and proof of work match both the\n>> old target and the new target from adjacent checkpoints.\n>>\n>> (That probably still works fine even if there's a hardfork that allows\n>> difficulty to adjust more frequently: a bits value at block n*2016 will\n>> still enforce *some* lower limit on how much work blocks n*2016+{1..2016}\n>> will have to contribute; so will still allow you to estimate how much work\n>> will have been done, it may just be less precise than the estimate you\n>> could\n>> generate now)\n>>\n>> Cheers,\n>> aj\n>>\n>>\n>\n>\n> --\n> Riccardo Casatta - @RCasatta <https://twitter.com/RCasatta>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180402/24414497/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Optimized Header Sync",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Jim Posen"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 4756
        }
    },
    {
        "title": "[bitcoin-dev] proposal: extend WIF format for segwit",
        "thread_messages": [
            {
                "author": "Karl Johan Alm",
                "date": "2018-04-04T06:06:19",
                "message_text_only": "I took the liberty of turning this into a BIP proposal -- the\nformatted version can be seen here:\nhttps://github.com/kallewoof/bips/blob/bip-typed-wif/bip-extended-privkey.mediawiki\n\n<pre>\n  BIP: XXX\n  Layer: Applications\n  Title: Typed Private Keys\n  Author: Karl-Johan Alm <karljohan-alm at garage.co.jp>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-XXX\n  Status: Draft\n  Type: Standards Track\n  Created: 2018-04-04\n  License: CC0-1.0\n</pre>\n\n== Abstract ==\n\nAn extension to the private key (WIF) format to specify what kind of\npublic key the private key corresponds to.\n\n== Motivation ==\n\nThere are several types of public keys which can all be associated\nwith a given private key: P2PKH (legacy <code>1...</code> format),\nP2SH-P2WPKH (SegWit public key inside P2SH), P2WPKH (bech32), etc.\n\nWhile private keys have a 1-byte suffix indicating whether the\ncorresponding public key is compressed (<code>0x01</code>) or not\n(<code>0x00</code>), there is no way of knowing what kind of public\nkeys were associated with the private key. As a result, when importing\na private key, the wallet has to assume all kinds, and keep track of\neach possible alternative.\n\nBy extending the suffix, we can specify what kind of public key was\nassociated with the given private key.\n\n== Specification ==\n\nCurrently, private keys are stored as a uint256 (private key data)\nfollowed by a uint8 (compressed flag). The latter is extended to\nspecify the public key types:\n\n{|class=\"wikitable\" style=\"text-align: center;\"\n|-\n!Value\n!Type\n!Compr\n!Clarification\n|-\n|<code>0x00</code>||P2PKH_UNCOMPRESSED||No||Uncompressed legacy public\nkey. Unknown public key format\n|-\n|<code>0x01</code>||P2PKH_COMPRESSED||Yes||Compressed legacy public\nkey. Unknown public key format\n|-\n|<code>0x80</code>||P2PKH||Yes||Compressed legacy public key. Legacy\npublic key format (<code>1...</code>)\n|-\n|<code>0x81</code>||P2WPKH||Yes||Bech32 format (native Segwit)\n|-\n|<code>0x82</code>||P2WPKH_P2SH||Yes||Segwit nested in BIP16 P2SH\n(<code>3...</code>)\n|-\n|<code>0x85</code>||P2SH|| &mdash; ||Non-Segwit BIP16 P2SH (<code>3...</code>)\n|-\n|<code>0x86</code>||P2WSH|| &mdash; ||Native Segwit P2SH\n|-\n|<code>0x87</code>||P2WSH_P2SH|| &mdash; ||Native Segwit P2SH nested\nin BIP16 P2SH\n|}\n\nWhen a wallet imports a private key, it will have two outcomes:\n\n* the key is using one of the legacy types, in which case all types\nmust be accounted for\n* the key is using one of the extended types, in which case the wallet\nneed only track the specific corresponding public key\n\n== Rationale ==\n\nTODO\n\n== Compatibility ==\n\nThis proposal is not backwards compatible, in that software that does\nnot recognize the new types will not understand the compressed flag.\nIt would be trivial to change this, by keeping the 'uncompressed'\nstate as it is (0) and changing 'compressed' to be 'anything not 0',\nas opposed to 'the value 1'.\n\nThe proposal *is* backwards compatible in that new wallet software\nwill always understand the old WIF format, however. It will, as it\ndoes today, assume that any kind of public key is possible, and will\nhave to track all of them, as it has to today.\n\n== Acknowledgements ==\n\nThis BIP is based on the initial proposal by Thomas Voegtlin\n<thomasv at electrum.org> on the Bitcoin Dev mailing\nlist<ref>https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/015007.html</ref>\nand the Electrum 3.0\nimplementation<ref>https://github.com/spesmilo/electrum/blob/82e88cb89df35288b80dfdbe071da74247351251/RELEASE-NOTES#L95-L108</ref>\n\n== Reference implementation ==\n\nThere is a partial implementation which adds, but does not use, the\ntypes described in this BIP here:\nhttps://github.com/bitcoin/bitcoin/pull/12869\n\n== References ==\n\n<references/>\n\n== Copyright ==\n\nThis document is licensed under the Creative Commons CC0 1.0 Universal license.\n\nOn Mon, Sep 18, 2017 at 12:36 AM, Mark Friedenbach via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Bech32 and WIF payload format are mostly orthogonal issues. You can design a\n> new wallet import format now and later switch it to Bech32.\n>\n> On Sep 17, 2017, at 7:42 AM, AJ West via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Hi I have a small interjection about the point on error correction (excuse\n> me if it seems elementary). Isn't there an argument to be made where a\n> wallet software should never attempt to figure out the 'correct' address, or\n> in this case private key? I don't think it's crazy to suggest somebody could\n> import a slightly erroneous WIF, the software gracefully error-corrects any\n> problem, but then the user copies that error onward such as in their backup\n> processes like a paper wallet. I always hate to advocate against a feature,\n> I'm just worried too much error correcting removes the burden of exactitude\n> and attention of the user (eg. \"I know I can have up to 4 errors\").\n>\n> I'm pretty sure I read those arguments somewhere in a documentation or issue\n> tracker/forum post. Maybe I'm misunderstanding the bigger picture in this\n> particular case, but I was just reminded of that concept (even if it only\n> applies generally).\n>\n> Thanks,\n> AJ West\n>\n> On Sun, Sep 17, 2017 at 4:10 AM, Thomas Voegtlin via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> On 17.09.2017 04:29, Pieter Wuille wrote:\n>> >\n>> > This has been a low-priority thing for me, though, and the computation\n>> > work\n>> > to find a good checksum is significant.\n>> >\n>>\n>> Thanks for the info. I guess this means that a bech32 format for private\n>> keys is not going to happen soon. Even if such a format was available,\n>> the issue would remain for segwit-in-p2sh addresses, which use base58.\n>>\n>> The ambiguity of the WIF format is currently holding me from releasing a\n>> segwit-capable version of Electrum. I believe it is not acceptable to\n>> use the current WIF format with segwit scripts; that would just create\n>> technological debt, forcing wallets to try all possible scripts. There\n>> is a good reason why WIF adds a 0x01 byte for compressed pubkeys; it\n>> makes it unambiguous.\n>>\n>> I see only two options:\n>>  1. Disable private keys export in Electrum Segwit wallets, until a\n>> common WIF extension has been agreed on.\n>>  2. Define my own WIF extension for Electrum, and go ahead with it.\n>>\n>> Defining my own format does make sense for the xpub/xprv format, because\n>> Electrum users need to share master public keys across Electrum wallets.\n>> It makes much less sense for WIF, though, because WIF is mostly used to\n>> import/sweep keys from other wallets.\n>>\n>> I would love to know what other wallet developers are going to do,\n>> especially Core. Are you going to export private keys used in segwit\n>> scripts in the current WIF format?\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Karl-Johan Alm",
                "date": "2018-04-10T02:54:08",
                "message_text_only": "Hello,\n\nI made slight modification to the BIP, dropping the 0x80 jump to 0x10:\nhttps://github.com/kallewoof/bips/blob/bip-typed-wif/bip-extended-privkey.mediawiki\n\nI will make the corresponding changes to the reference implementation shortly.\n\nIf there are no objections I would also like to request a BIP number.\n\n\nOn Wed, Apr 4, 2018 at 3:06 PM, Karl Johan Alm\n<karljohan-alm at garage.co.jp> wrote:\n> I took the liberty of turning this into a BIP proposal -- the\n> formatted version can be seen here:\n> https://github.com/kallewoof/bips/blob/bip-typed-wif/bip-extended-privkey.mediawiki\n>\n> <pre>\n>   BIP: XXX\n>   Layer: Applications\n>   Title: Typed Private Keys\n>   Author: Karl-Johan Alm <karljohan-alm at garage.co.jp>\n>   Comments-Summary: No comments yet.\n>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-XXX\n>   Status: Draft\n>   Type: Standards Track\n>   Created: 2018-04-04\n>   License: CC0-1.0\n> </pre>\n>\n> == Abstract ==\n>\n> An extension to the private key (WIF) format to specify what kind of\n> public key the private key corresponds to.\n>\n> == Motivation ==\n>\n> There are several types of public keys which can all be associated\n> with a given private key: P2PKH (legacy <code>1...</code> format),\n> P2SH-P2WPKH (SegWit public key inside P2SH), P2WPKH (bech32), etc.\n>\n> While private keys have a 1-byte suffix indicating whether the\n> corresponding public key is compressed (<code>0x01</code>) or not\n> (<code>0x00</code>), there is no way of knowing what kind of public\n> keys were associated with the private key. As a result, when importing\n> a private key, the wallet has to assume all kinds, and keep track of\n> each possible alternative.\n>\n> By extending the suffix, we can specify what kind of public key was\n> associated with the given private key.\n>\n> == Specification ==\n>\n> Currently, private keys are stored as a uint256 (private key data)\n> followed by a uint8 (compressed flag). The latter is extended to\n> specify the public key types:\n>\n> {|class=\"wikitable\" style=\"text-align: center;\"\n> |-\n> !Value\n> !Type\n> !Compr\n> !Clarification\n> |-\n> |<code>0x00</code>||P2PKH_UNCOMPRESSED||No||Uncompressed legacy public\n> key. Unknown public key format\n> |-\n> |<code>0x01</code>||P2PKH_COMPRESSED||Yes||Compressed legacy public\n> key. Unknown public key format\n> |-\n> |<code>0x80</code>||P2PKH||Yes||Compressed legacy public key. Legacy\n> public key format (<code>1...</code>)\n> |-\n> |<code>0x81</code>||P2WPKH||Yes||Bech32 format (native Segwit)\n> |-\n> |<code>0x82</code>||P2WPKH_P2SH||Yes||Segwit nested in BIP16 P2SH\n> (<code>3...</code>)\n> |-\n> |<code>0x85</code>||P2SH|| &mdash; ||Non-Segwit BIP16 P2SH (<code>3...</code>)\n> |-\n> |<code>0x86</code>||P2WSH|| &mdash; ||Native Segwit P2SH\n> |-\n> |<code>0x87</code>||P2WSH_P2SH|| &mdash; ||Native Segwit P2SH nested\n> in BIP16 P2SH\n> |}\n>\n> When a wallet imports a private key, it will have two outcomes:\n>\n> * the key is using one of the legacy types, in which case all types\n> must be accounted for\n> * the key is using one of the extended types, in which case the wallet\n> need only track the specific corresponding public key\n>\n> == Rationale ==\n>\n> TODO\n>\n> == Compatibility ==\n>\n> This proposal is not backwards compatible, in that software that does\n> not recognize the new types will not understand the compressed flag.\n> It would be trivial to change this, by keeping the 'uncompressed'\n> state as it is (0) and changing 'compressed' to be 'anything not 0',\n> as opposed to 'the value 1'.\n>\n> The proposal *is* backwards compatible in that new wallet software\n> will always understand the old WIF format, however. It will, as it\n> does today, assume that any kind of public key is possible, and will\n> have to track all of them, as it has to today.\n>\n> == Acknowledgements ==\n>\n> This BIP is based on the initial proposal by Thomas Voegtlin\n> <thomasv at electrum.org> on the Bitcoin Dev mailing\n> list<ref>https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/015007.html</ref>\n> and the Electrum 3.0\n> implementation<ref>https://github.com/spesmilo/electrum/blob/82e88cb89df35288b80dfdbe071da74247351251/RELEASE-NOTES#L95-L108</ref>\n>\n> == Reference implementation ==\n>\n> There is a partial implementation which adds, but does not use, the\n> types described in this BIP here:\n> https://github.com/bitcoin/bitcoin/pull/12869\n>\n> == References ==\n>\n> <references/>\n>\n> == Copyright ==\n>\n> This document is licensed under the Creative Commons CC0 1.0 Universal license.\n>\n> On Mon, Sep 18, 2017 at 12:36 AM, Mark Friedenbach via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> Bech32 and WIF payload format are mostly orthogonal issues. You can design a\n>> new wallet import format now and later switch it to Bech32.\n>>\n>> On Sep 17, 2017, at 7:42 AM, AJ West via bitcoin-dev\n>> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> Hi I have a small interjection about the point on error correction (excuse\n>> me if it seems elementary). Isn't there an argument to be made where a\n>> wallet software should never attempt to figure out the 'correct' address, or\n>> in this case private key? I don't think it's crazy to suggest somebody could\n>> import a slightly erroneous WIF, the software gracefully error-corrects any\n>> problem, but then the user copies that error onward such as in their backup\n>> processes like a paper wallet. I always hate to advocate against a feature,\n>> I'm just worried too much error correcting removes the burden of exactitude\n>> and attention of the user (eg. \"I know I can have up to 4 errors\").\n>>\n>> I'm pretty sure I read those arguments somewhere in a documentation or issue\n>> tracker/forum post. Maybe I'm misunderstanding the bigger picture in this\n>> particular case, but I was just reminded of that concept (even if it only\n>> applies generally).\n>>\n>> Thanks,\n>> AJ West\n>>\n>> On Sun, Sep 17, 2017 at 4:10 AM, Thomas Voegtlin via bitcoin-dev\n>> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>> On 17.09.2017 04:29, Pieter Wuille wrote:\n>>> >\n>>> > This has been a low-priority thing for me, though, and the computation\n>>> > work\n>>> > to find a good checksum is significant.\n>>> >\n>>>\n>>> Thanks for the info. I guess this means that a bech32 format for private\n>>> keys is not going to happen soon. Even if such a format was available,\n>>> the issue would remain for segwit-in-p2sh addresses, which use base58.\n>>>\n>>> The ambiguity of the WIF format is currently holding me from releasing a\n>>> segwit-capable version of Electrum. I believe it is not acceptable to\n>>> use the current WIF format with segwit scripts; that would just create\n>>> technological debt, forcing wallets to try all possible scripts. There\n>>> is a good reason why WIF adds a 0x01 byte for compressed pubkeys; it\n>>> makes it unambiguous.\n>>>\n>>> I see only two options:\n>>>  1. Disable private keys export in Electrum Segwit wallets, until a\n>>> common WIF extension has been agreed on.\n>>>  2. Define my own WIF extension for Electrum, and go ahead with it.\n>>>\n>>> Defining my own format does make sense for the xpub/xprv format, because\n>>> Electrum users need to share master public keys across Electrum wallets.\n>>> It makes much less sense for WIF, though, because WIF is mostly used to\n>>> import/sweep keys from other wallets.\n>>>\n>>> I would love to know what other wallet developers are going to do,\n>>> especially Core. Are you going to export private keys used in segwit\n>>> scripts in the current WIF format?\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>"
            }
        ],
        "thread_summary": {
            "title": "proposal: extend WIF format for segwit",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Karl Johan Alm",
                "Karl-Johan Alm"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 15476
        }
    },
    {
        "title": "[bitcoin-dev] KETAMINE: Multiple vulnerabilities in SecureRandom(), numerous cryptocurrency products affected.",
        "thread_messages": [
            {
                "author": "ketamine at national.shitposting.agency",
                "date": "2018-04-06T19:53:13",
                "message_text_only": "A significant number of past and current cryptocurrency products\ncontain a JavaScript class named SecureRandom(), containing both\nentropy collection and a PRNG. The entropy collection and the RNG\nitself are both deficient to the degree that key material can be\nrecovered by a third party with medium complexity. There are a\nsubstantial number of variations of this SecureRandom() class in\nvarious pieces of software, some with bugs fixed, some with additional\nbugs added. Products that aren't today vulnerable due to moving to\nother libraries may be using old keys that have been previously\ncompromised by usage of SecureRandom().\n\n\nThe most common variations of the library attempts to collect entropy\nfrom window.crypto's CSPRNG, but due to a type error in a comparison\nthis function is silently stepped over without failing. Entropy is\nsubsequently gathered from math.Random (a 48bit linear congruential\ngenerator, seeded by the time in some browsers), and a single\nexecution of a medium resolution timer. In some known configurations\nthis system has substantially less than 48 bits of entropy.\n\nThe core of the RNG is an implementation of RC4 (\"arcfour random\"),\nand the output is often directly used for the creation of private key\nmaterial as well as cryptographic nonces for ECDSA signatures. RC4 is\npublicly known to have biases of several bits, which are likely\nsufficient for a lattice solver to recover a ECDSA private key given a\nnumber of signatures. One popular Bitcoin web wallet re-initialized\nthe RC4 state for every signature which makes the biases bit-aligned,\nbut in other cases the Special K would be manifest itself over\nmultiple transactions.\n\n\nNecessary action:\n\n   * identify and move all funds stored using SecureRandom()\n\n   * rotate all key material generated by, or has come into contact\n     with any piece of software using SecureRandom()\n\n   * do not write cryptographic tools in non-type safe languages\n\n   * don't take the output of a CSPRNG and pass it through RC4\n\n-\n3CJ99vSipFi9z11UdbdZWfNKjywJnY8sT8"
            },
            {
                "author": "Matias Alejo Garcia",
                "date": "2018-04-06T20:51:11",
                "message_text_only": "Source?\n\nOn Fri, Apr 6, 2018 at 4:53 PM, ketamine--- via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> A significant number of past and current cryptocurrency products\n> contain a JavaScript class named SecureRandom(), containing both\n> entropy collection and a PRNG. The entropy collection and the RNG\n> itself are both deficient to the degree that key material can be\n> recovered by a third party with medium complexity. There are a\n> substantial number of variations of this SecureRandom() class in\n> various pieces of software, some with bugs fixed, some with additional\n> bugs added. Products that aren't today vulnerable due to moving to\n> other libraries may be using old keys that have been previously\n> compromised by usage of SecureRandom().\n>\n>\n> The most common variations of the library attempts to collect entropy\n> from window.crypto's CSPRNG, but due to a type error in a comparison\n> this function is silently stepped over without failing. Entropy is\n> subsequently gathered from math.Random (a 48bit linear congruential\n> generator, seeded by the time in some browsers), and a single\n> execution of a medium resolution timer. In some known configurations\n> this system has substantially less than 48 bits of entropy.\n>\n> The core of the RNG is an implementation of RC4 (\"arcfour random\"),\n> and the output is often directly used for the creation of private key\n> material as well as cryptographic nonces for ECDSA signatures. RC4 is\n> publicly known to have biases of several bits, which are likely\n> sufficient for a lattice solver to recover a ECDSA private key given a\n> number of signatures. One popular Bitcoin web wallet re-initialized\n> the RC4 state for every signature which makes the biases bit-aligned,\n> but in other cases the Special K would be manifest itself over\n> multiple transactions.\n>\n>\n> Necessary action:\n>\n>   * identify and move all funds stored using SecureRandom()\n>\n>   * rotate all key material generated by, or has come into contact\n>     with any piece of software using SecureRandom()\n>\n>   * do not write cryptographic tools in non-type safe languages\n>\n>   * don't take the output of a CSPRNG and pass it through RC4\n>\n> -\n> 3CJ99vSipFi9z11UdbdZWfNKjywJnY8sT8\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n\n-- \nMat\u00edas Alejo Garcia\n@ematiu\nRoads? Where we're going, we don't need roads!\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180406/7cdc248c/attachment-0001.html>"
            },
            {
                "author": "Mustafa Al-Bassam",
                "date": "2018-04-09T21:11:02",
                "message_text_only": "Here's the code in question: https://github.com/jasondavies/jsbn/pull/7\n\nBest,\n\nMustafa\n\n\nOn 06/04/18 21:51, Matias Alejo Garcia via bitcoin-dev wrote:\n> Source? \n>\n> On Fri, Apr 6, 2018 at 4:53 PM, ketamine--- via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>\n>     A significant number of past and current cryptocurrency products\n>     contain a JavaScript class named SecureRandom(), containing both\n>     entropy collection and a PRNG. The entropy collection and the RNG\n>     itself are both deficient to the degree that key material can be\n>     recovered by a third party with medium complexity. There are a\n>     substantial number of variations of this SecureRandom() class in\n>     various pieces of software, some with bugs fixed, some with additional\n>     bugs added. Products that aren't today vulnerable due to moving to\n>     other libraries may be using old keys that have been previously\n>     compromised by usage of SecureRandom().\n>\n>\n>     The most common variations of the library attempts to collect entropy\n>     from window.crypto's CSPRNG, but due to a type error in a comparison\n>     this function is silently stepped over without failing. Entropy is\n>     subsequently gathered from math.Random (a 48bit linear congruential\n>     generator, seeded by the time in some browsers), and a single\n>     execution of a medium resolution timer. In some known configurations\n>     this system has substantially less than 48 bits of entropy.\n>\n>     The core of the RNG is an implementation of RC4 (\"arcfour random\"),\n>     and the output is often directly used for the creation of private key\n>     material as well as cryptographic nonces for ECDSA signatures. RC4 is\n>     publicly known to have biases of several bits, which are likely\n>     sufficient for a lattice solver to recover a ECDSA private key given a\n>     number of signatures. One popular Bitcoin web wallet re-initialized\n>     the RC4 state for every signature which makes the biases bit-aligned,\n>     but in other cases the Special K would be manifest itself over\n>     multiple transactions.\n>\n>\n>     Necessary action:\n>\n>       * identify and move all funds stored using SecureRandom()\n>\n>       * rotate all key material generated by, or has come into contact\n>         with any piece of software using SecureRandom()\n>\n>       * do not write cryptographic tools in non-type safe languages\n>\n>       * don't take the output of a CSPRNG and pass it through RC4\n>\n>     -\n>     3CJ99vSipFi9z11UdbdZWfNKjywJnY8sT8\n>     _______________________________________________\n>     bitcoin-dev mailing list\n>     bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>\n>\n>\n>\n>\n> -- \n> Mat\u00edas Alejo Garcia\n> @ematiu\n> Roads? Where we're going, we don't need roads!\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180409/a678381a/attachment.html>"
            },
            {
                "author": "Jason Davies",
                "date": "2018-04-10T00:42:32",
                "message_text_only": "These issues all stem from the RC4-based RNG implementation (with insecure\nfallback entropy) in Tom Wu's jsbn library, published here:\nhttp://www-cs-students.stanford.edu/~tjw/jsbn/\n\nPlease refer to Tom Wu's URL, or this more up-to-date fork of Tom Wu's code\n(published to NPM): https://github.com/andyperlitch/jsbn -- my repository on\nGitHub was only ever intended to be a straight mirror of Tom Wu's code (created\nover 7 years ago!).  I'll probably delete my mirror repository given that there\nare now better JavaScript bignum alternatives, and in light of this report.\n\nJason\n\n> On 9 Apr 2018, at 22:11, mus at musalbas.com wrote:\n> \n> Here's the code in question: https://github.com/jasondavies/jsbn/pull/7\n> \n> Best,\n> \n> Mustafa\n\n--\nJason Davies, http://www.jasondavies.com/"
            },
            {
                "author": "Mustafa Al-Bassam",
                "date": "2018-04-09T21:17:11",
                "message_text_only": "And specifically, here's a version of it that uses Arcfour:\nhttps://gist.github.com/jonls/5230850\n\n\nOn 09/04/18 22:11, Mustafa Al-Bassam wrote:\n>\n> Here's the code in question: https://github.com/jasondavies/jsbn/pull/7\n>\n> Best,\n>\n> Mustafa\n>\n>\n> On 06/04/18 21:51, Matias Alejo Garcia via bitcoin-dev wrote:\n>> Source? \n>>\n>> On Fri, Apr 6, 2018 at 4:53 PM, ketamine--- via bitcoin-dev\n>> <bitcoin-dev at lists.linuxfoundation.org\n>> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>>\n>>     A significant number of past and current cryptocurrency products\n>>     contain a JavaScript class named SecureRandom(), containing both\n>>     entropy collection and a PRNG. The entropy collection and the RNG\n>>     itself are both deficient to the degree that key material can be\n>>     recovered by a third party with medium complexity. There are a\n>>     substantial number of variations of this SecureRandom() class in\n>>     various pieces of software, some with bugs fixed, some with\n>>     additional\n>>     bugs added. Products that aren't today vulnerable due to moving to\n>>     other libraries may be using old keys that have been previously\n>>     compromised by usage of SecureRandom().\n>>\n>>\n>>     The most common variations of the library attempts to collect entropy\n>>     from window.crypto's CSPRNG, but due to a type error in a comparison\n>>     this function is silently stepped over without failing. Entropy is\n>>     subsequently gathered from math.Random (a 48bit linear congruential\n>>     generator, seeded by the time in some browsers), and a single\n>>     execution of a medium resolution timer. In some known configurations\n>>     this system has substantially less than 48 bits of entropy.\n>>\n>>     The core of the RNG is an implementation of RC4 (\"arcfour random\"),\n>>     and the output is often directly used for the creation of private key\n>>     material as well as cryptographic nonces for ECDSA signatures. RC4 is\n>>     publicly known to have biases of several bits, which are likely\n>>     sufficient for a lattice solver to recover a ECDSA private key\n>>     given a\n>>     number of signatures. One popular Bitcoin web wallet re-initialized\n>>     the RC4 state for every signature which makes the biases bit-aligned,\n>>     but in other cases the Special K would be manifest itself over\n>>     multiple transactions.\n>>\n>>\n>>     Necessary action:\n>>\n>>       * identify and move all funds stored using SecureRandom()\n>>\n>>       * rotate all key material generated by, or has come into contact\n>>         with any piece of software using SecureRandom()\n>>\n>>       * do not write cryptographic tools in non-type safe languages\n>>\n>>       * don't take the output of a CSPRNG and pass it through RC4\n>>\n>>     -\n>>     3CJ99vSipFi9z11UdbdZWfNKjywJnY8sT8\n>>     _______________________________________________\n>>     bitcoin-dev mailing list\n>>     bitcoin-dev at lists.linuxfoundation.org\n>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>\n>>\n>>\n>>\n>>\n>> -- \n>> Mat\u00edas Alejo Garcia\n>> @ematiu\n>> Roads? Where we're going, we don't need roads!\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180409/1bd0330e/attachment.html>"
            },
            {
                "author": "Mustafa Al-Bassam",
                "date": "2018-04-09T23:39:15",
                "message_text_only": "The original disclosure didn't contain any information about the library\nin question, so I did some digging.\n\nI think that the vulnerability disclosure is referring to a pre-2013\nversion of jsbn, a JavaScript crypto library. Before it used the CSRNG\nin the Web Crypto API, it tried to use nsIDOMCrypto, but incorrectly did\na string comparison when checking the browser version.\n\nIn practice though, this doesn't really matter, because\nnavigator.appVersion < \"5\" returns true anyway for old browsers. The\nreal issue is that modern browsers don't have window.crypto.random\ndefined, so Bitcoin wallets using a pre-2013 version of jsbn may not be\nusing a CSPRNG, when run on a modern browser.\n\nAs is noted though, even if a CSPRNG is used, the library passes the\noutput of the CSPRNG through RC4, which generates some biased bits,\nleading to possible private key recovery.\n\n\nOn 09/04/18 22:17, Mustafa Al-Bassam via bitcoin-dev wrote:\n>\n> And specifically, here's a version of it that uses Arcfour:\n> https://gist.github.com/jonls/5230850\n>\n>\n> On 09/04/18 22:11, Mustafa Al-Bassam wrote:\n>>\n>> Here's the code in question: https://github.com/jasondavies/jsbn/pull/7\n>>\n>> Best,\n>>\n>> Mustafa\n>>\n>>\n>> On 06/04/18 21:51, Matias Alejo Garcia via bitcoin-dev wrote:\n>>> Source? \n>>>\n>>> On Fri, Apr 6, 2018 at 4:53 PM, ketamine--- via bitcoin-dev\n>>> <bitcoin-dev at lists.linuxfoundation.org\n>>> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>>>\n>>>     A significant number of past and current cryptocurrency products\n>>>     contain a JavaScript class named SecureRandom(), containing both\n>>>     entropy collection and a PRNG. The entropy collection and the RNG\n>>>     itself are both deficient to the degree that key material can be\n>>>     recovered by a third party with medium complexity. There are a\n>>>     substantial number of variations of this SecureRandom() class in\n>>>     various pieces of software, some with bugs fixed, some with\n>>>     additional\n>>>     bugs added. Products that aren't today vulnerable due to moving to\n>>>     other libraries may be using old keys that have been previously\n>>>     compromised by usage of SecureRandom().\n>>>\n>>>\n>>>     The most common variations of the library attempts to collect\n>>>     entropy\n>>>     from window.crypto's CSPRNG, but due to a type error in a comparison\n>>>     this function is silently stepped over without failing. Entropy is\n>>>     subsequently gathered from math.Random (a 48bit linear congruential\n>>>     generator, seeded by the time in some browsers), and a single\n>>>     execution of a medium resolution timer. In some known configurations\n>>>     this system has substantially less than 48 bits of entropy.\n>>>\n>>>     The core of the RNG is an implementation of RC4 (\"arcfour random\"),\n>>>     and the output is often directly used for the creation of\n>>>     private key\n>>>     material as well as cryptographic nonces for ECDSA signatures.\n>>>     RC4 is\n>>>     publicly known to have biases of several bits, which are likely\n>>>     sufficient for a lattice solver to recover a ECDSA private key\n>>>     given a\n>>>     number of signatures. One popular Bitcoin web wallet re-initialized\n>>>     the RC4 state for every signature which makes the biases\n>>>     bit-aligned,\n>>>     but in other cases the Special K would be manifest itself over\n>>>     multiple transactions.\n>>>\n>>>\n>>>     Necessary action:\n>>>\n>>>       * identify and move all funds stored using SecureRandom()\n>>>\n>>>       * rotate all key material generated by, or has come into contact\n>>>         with any piece of software using SecureRandom()\n>>>\n>>>       * do not write cryptographic tools in non-type safe languages\n>>>\n>>>       * don't take the output of a CSPRNG and pass it through RC4\n>>>\n>>>     -\n>>>     3CJ99vSipFi9z11UdbdZWfNKjywJnY8sT8\n>>>     _______________________________________________\n>>>     bitcoin-dev mailing list\n>>>     bitcoin-dev at lists.linuxfoundation.org\n>>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>\n>>>\n>>>\n>>>\n>>>\n>>> -- \n>>> Mat\u00edas Alejo Garcia\n>>> @ematiu\n>>> Roads? Where we're going, we don't need roads!\n>>>\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180410/a4f2aca5/attachment-0001.html>"
            },
            {
                "author": "Jason Davies",
                "date": "2018-04-10T08:51:51",
                "message_text_only": "On 10 Apr 2018, at 00:39, mus at musalbas.com wrote:\n\n> The original disclosure didn't contain any information about the library\n> in question, so I did some digging.\n>\n> I think that the vulnerability disclosure is referring to a pre-2013\n> version of jsbn, a JavaScript crypto library. Before it used the CSRNG\n> in the Web Crypto API, it tried to use nsIDOMCrypto, but incorrectly did\n> a string comparison when checking the browser version.\n>\n> In practice though, this doesn't really matter, because\n> navigator.appVersion < \"5\" returns true anyway for old browsers. The\n> real issue is that modern browsers don't have window.crypto.random\n> defined, so Bitcoin wallets using a pre-2013 version of jsbn may not be\n> using a CSPRNG, when run on a modern browser.\n\nYes, it looks like high-quality entropy via crypto.getRandomValues was only\nadded in Tom Wu's latest version (v1.4) in July 2013.\n\nNote that even with v1.4, it still does not use high-quality entropy for\nInternet Explorer, because getRandomValues is provided under window.msCrypto\nfor that browser.\n\n  http://www-cs-students.stanford.edu/~tjw/jsbn/rng.js\n\n> As is noted though, even if a CSPRNG is used, the library passes the\n> output of the CSPRNG through RC4, which generates some biased bits,\n> leading to possible private key recovery.\n\nI think this is the real issue: even if high-quality entropy is utilised, the\nRNG is RC4-based, which is known to generate biased output.\n\nFinally, note that even Chrome used RC4 for crypto.getRandomValues at one\npoint (as recently as 2015)!\n\n  https://bugs.chromium.org/p/chromium/issues/detail?id=552749\n\n--\nJason Davies, https://www.jasondavies.com/"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2018-04-10T13:15:22",
                "message_text_only": "I used jsbn in the past, then I made some research too\n\nApparently window.crypto.getRandomValues was introduced in jsbn mid 2012\n(according to the wayback machine, but 2012/2013 does not make any\ndifference, see below), was available in Chrome since 2011 (but indeed\nsee \"window.crypto.getRandomValues() uses a weak CSPRNG\"\nhttps://bugs.chromium.org/p/chromium/issues/detail?id=552749 fixed *end\n*of 2015, funny to see that those that did specify the Webcrypto API did\nnot implement it correctly...), in FF in 2013\n(https://website-archive.mozilla.org/www.mozilla.org/firefox_releasenotes/en-US/firefox/21.0/releasenotes/)\n, in IE in 2013 and Safari ~2012/2013, at least that's the official\ndates for the Webcrypto API implementation, maybe something existed\nbefore, but it's not so easy to seek for the history\n\nThe window.crypto.random check is in jsbn since the begining (2006) and\nonly returns true for Netscape browsers before Netscape 5/6, ie Firefox\n(2000), see\nhttps://books.google.fr/books?id=UooAblGoGN8C&pg=PA85&lpg=PA85&dq=browser+appversion+4&source=bl&ots=dVijsOR0ov&sig=6SnElm56-bAvmGlKqUAdoGLAs2A&hl=fr&sa=X&ved=2ahUKEwirhtaqva_aAhUFchQKHQ4JCk4Q6AEwBXoECAAQcQ#v=onepage&q=browser%20appversion%204&f=false)\n\n>From the existing tools, there was not only jsbn, everybody was using\nMath.random (sjcl, cryptoJS, forge, etc) with different implementations\nand everybody did put a note stating that it might be insecure with an\n\"improvement to come\" comment\n\nWe can probably assume that nobody was using Netscape any longer when\nBitcoin started\n\nThe conclusion seems to be that at least all wallets generated by js\ntools inside browsers since bitcoin exists until 2011 are impacted by\nthe Math.random weakness if applicable to the related implementations,\nthe Math.random or RC4 (Chrome) weakness between 2011 and 2013, and RC4\nweakness for Chrome users until end of 2015\n\nAnd all wallets using jsbn are impacted by Math.random and RC4 until\n2013 (or end 2015 for Chrome), then still by the RC4 fallback step after\n\n> Note that even with v1.4, it still does not use high-quality entropy\nfor Internet Explorer, because getRandomValues is provided under\nwindow.msCrypto for that browser\n\nI don't know for that one, what was the issue?\n\nLe 10/04/2018 \u00e0 10:51, Jason Davies via bitcoin-dev a \u00e9crit\u00a0:\n> On 10 Apr 2018, at 00:39, mus at musalbas.com wrote:\n>\n>> The original disclosure didn't contain any information about the library\n>> in question, so I did some digging.\n>>\n>> I think that the vulnerability disclosure is referring to a pre-2013\n>> version of jsbn, a JavaScript crypto library. Before it used the CSRNG\n>> in the Web Crypto API, it tried to use nsIDOMCrypto, but incorrectly did\n>> a string comparison when checking the browser version.\n>>\n>> In practice though, this doesn't really matter, because\n>> navigator.appVersion < \"5\" returns true anyway for old browsers. The\n>> real issue is that modern browsers don't have window.crypto.random\n>> defined, so Bitcoin wallets using a pre-2013 version of jsbn may not be\n>> using a CSPRNG, when run on a modern browser.\n> Yes, it looks like high-quality entropy via crypto.getRandomValues was only\n> added in Tom Wu's latest version (v1.4) in July 2013.\n>\n> Note that even with v1.4, it still does not use high-quality entropy for\n> Internet Explorer, because getRandomValues is provided under window.msCrypto\n> for that browser.\n>\n>   http://www-cs-students.stanford.edu/~tjw/jsbn/rng.js\n>\n>> As is noted though, even if a CSPRNG is used, the library passes the\n>> output of the CSPRNG through RC4, which generates some biased bits,\n>> leading to possible private key recovery.\n> I think this is the real issue: even if high-quality entropy is utilised, the\n> RNG is RC4-based, which is known to generate biased output.\n>\n> Finally, note that even Chrome used RC4 for crypto.getRandomValues at one\n> point (as recently as 2015)!\n>\n>   https://bugs.chromium.org/p/chromium/issues/detail?id=552749\n>\n> --\n> Jason Davies, https://www.jasondavies.com/\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180410/5f3954ea/attachment-0001.html>"
            },
            {
                "author": "Jason Davies",
                "date": "2018-04-10T13:32:36",
                "message_text_only": ">> Note that even with v1.4, it still does not use high-quality entropy for\n>> Internet Explorer, because getRandomValues is provided under window.msCrypto\n>> for that browser.\n>\n> I don't know for that one, what was the issue?\n\nI simply meant that Internet Explorer implements the Web Cryptography API under\nwindow.msCrypto instead of window.crypto.  Thus, unless\nmsCrypto.getRandomValues is used, high-quality entropy will not have been used\nby any of these libraries under Internet Explorer.\n\n--\nJason Davies, https://www.jasondavies.com/"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2018-04-10T13:50:40",
                "message_text_only": "Indeed, this impacts jsbn only normally since all others from the time\ngetRandomValues was available are supposed to implement both\n\n\nLe 10/04/2018 \u00e0 15:32, Jason Davies a \u00e9crit\u00a0:\n>>> Note that even with v1.4, it still does not use high-quality entropy for\n>>> Internet Explorer, because getRandomValues is provided under window.msCrypto\n>>> for that browser.\n>> I don't know for that one, what was the issue?\n> I simply meant that Internet Explorer implements the Web Cryptography API under\n> window.msCrypto instead of window.crypto.  Thus, unless\n> msCrypto.getRandomValues is used, high-quality entropy will not have been used\n> by any of these libraries under Internet Explorer.\n>\n> --\n> Jason Davies, https://www.jasondavies.com/\n>\n\n-- \nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms"
            }
        ],
        "thread_summary": {
            "title": "KETAMINE: Multiple vulnerabilities in SecureRandom(), numerous cryptocurrency products affected.",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ketamine at national.shitposting.agency",
                "Matias Alejo Garcia",
                "Aymeric Vitte",
                "Mustafa Al-Bassam",
                "Jason Davies"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 25873
        }
    },
    {
        "title": "[bitcoin-dev] Few questions regarding ListTransaction",
        "thread_messages": [
            {
                "author": "Maksim Solovjov",
                "date": "2018-04-10T20:29:23",
                "message_text_only": "Hi,\n\nI have few questions regarding ListTransaction RPC call and I hope you can\nhelp me.\nDocumentation for the RPC call is here:\nhttps://bitcoin.org/en/developer-reference#listtransactions\n\n1. What does it mean for a transaction ( with 0 confirmations ) to be\n*trusted* or not?\nThere is such field in the response of ListTransaction\nAs far as I know bitcoin - nothing is trusted unless there are some numbers\nof confirmations.\nHow does this value is set to true or false?\n\n2. When does *confirmations* can be -1 ( conflicted )?\nWhat does it mean to have conflicted transaction?\nIs it about Transaction Malleability? Double Spend? or both?\n\n3. *walletconflicts*. What if I add watch-only address to my bitcoind\nprocess.\nThis address will not be a part of my wallet.\nNow, someone will pay me to this address and someone else will make\nTransaction Malleability ( for the sake of example, lets assume this second\none will be confirmed, not the original one ).\nWill I get a first transaction in *walletconflicts* array when\nListTransaction will return me second transaction in the response?\n\nThank you in advance!\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180410/8b44871c/attachment.html>"
            },
            {
                "author": "Joseph Gleason \u2448",
                "date": "2018-04-10T20:41:07",
                "message_text_only": "2) -1 doesn't mean conflicted, it means the transaction is not only\nunconfirmed buy depends on another unconfirmed transaction.\n\n1) Depends on what you mean by trusted.  If you are giving the user online\naccess to something that costs you next to nothing to revoke if there is a\nproblem later, no problem.  0-conf is great.  If you are pre-pairing\nshipments and will be able to pull the box from the ship stream if there is\na problem, also no problem.  If you are sending some other non-reversible\nthing like crypto, then you might want to be careful.  It really depends on\nthe value of your things and your tolerance of risk.\n\nIn my opinion, an zero-conf transaction is way way better than a credit\ncard preauth or a check in hand.\n\n\n\nOn Tue, Apr 10, 2018 at 1:34 PM Maksim Solovjov via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi,\n>\n> I have few questions regarding ListTransaction RPC call and I hope you can\n> help me.\n> Documentation for the RPC call is here:\n> https://bitcoin.org/en/developer-reference#listtransactions\n>\n> 1. What does it mean for a transaction ( with 0 confirmations ) to be\n> *trusted* or not?\n> There is such field in the response of ListTransaction\n> As far as I know bitcoin - nothing is trusted unless there are some\n> numbers of confirmations.\n> How does this value is set to true or false?\n>\n> 2. When does *confirmations* can be -1 ( conflicted )?\n> What does it mean to have conflicted transaction?\n> Is it about Transaction Malleability? Double Spend? or both?\n>\n> 3. *walletconflicts*. What if I add watch-only address to my bitcoind\n> process.\n> This address will not be a part of my wallet.\n> Now, someone will pay me to this address and someone else will make\n> Transaction Malleability ( for the sake of example, lets assume this second\n> one will be confirmed, not the original one ).\n> Will I get a first transaction in *walletconflicts* array when\n> ListTransaction will return me second transaction in the response?\n>\n> Thank you in advance!\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180410/212bdb4e/attachment.html>"
            },
            {
                "author": "Karl-Johan Alm",
                "date": "2018-04-11T05:21:10",
                "message_text_only": "On Wed, Apr 11, 2018 at 5:29 AM, Maksim Solovjov via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> 1. What does it mean for a transaction ( with 0 confirmations ) to be\n> trusted or not?\n\nIt is trusted if (1) it is final (i.e. it can't be replaced), (2) it\nis not in a block that was reorged out (negative confirmation count),\n(3) the 'spend zero conf change' option is set, (4) it is in the\nmempool, and (5) all inputs are from us.\n\n> 2. When does confirmations can be -1 ( conflicted )?\n> What does it mean to have conflicted transaction?\n> Is it about Transaction Malleability? Double Spend? or both?\n\nA transaction is conflicted if a different transaction exists that\nspends the same inputs. A transaction gets -N confirmations if it is\nmined in a block, and that block is orphaned away, and a different\ntransaction is mined in the new block so that the transaction becomes\na double spend."
            },
            {
                "author": "Karl-Johan Alm",
                "date": "2018-04-11T05:22:42",
                "message_text_only": "Clarification on one part below:\n\nOn Wed, Apr 11, 2018 at 2:21 PM, Karl-Johan Alm\n<karljohan-alm at garage.co.jp> wrote:\n> On Wed, Apr 11, 2018 at 5:29 AM, Maksim Solovjov via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> 1. What does it mean for a transaction ( with 0 confirmations ) to be\n>> trusted or not?\n>\n> It is trusted if (1) it is final (i.e. it can't be replaced), (2) it\n> is not in a block that was reorged out (negative confirmation count),\n> (3) the 'spend zero conf change' option is set, (4) it is in the\n> mempool, and (5) all inputs are from us.\n\n\"can't be replaced\" here means it cannot be replaced through\nconventional means. It is always possible to replace a transaction\nthat has not yet been confirmed, e.g. by asking a miner to mine a\nconflicting transaction directly."
            },
            {
                "author": "Peter Todd",
                "date": "2018-04-11T07:52:25",
                "message_text_only": "On Wed, Apr 11, 2018 at 02:22:42PM +0900, Karl-Johan Alm via bitcoin-dev wrote:\n> Clarification on one part below:\n> \n> On Wed, Apr 11, 2018 at 2:21 PM, Karl-Johan Alm\n> <karljohan-alm at garage.co.jp> wrote:\n> > On Wed, Apr 11, 2018 at 5:29 AM, Maksim Solovjov via bitcoin-dev\n> > <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >> 1. What does it mean for a transaction ( with 0 confirmations ) to be\n> >> trusted or not?\n> >\n> > It is trusted if (1) it is final (i.e. it can't be replaced), (2) it\n> > is not in a block that was reorged out (negative confirmation count),\n> > (3) the 'spend zero conf change' option is set, (4) it is in the\n> > mempool, and (5) all inputs are from us.\n> \n> \"can't be replaced\" here means it cannot be replaced through\n> conventional means. It is always possible to replace a transaction\n> that has not yet been confirmed, e.g. by asking a miner to mine a\n> conflicting transaction directly.\n\nOr via full replace-by-fee, which appears to be used by a significant minority\nof miners:\n\nhttps://github.com/petertodd/bitcoin/tree/replace-by-fee-v0.16.0\n\nIn practice transaction replacement by the sender for any transaction is very\neasy.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180411/31bcf010/attachment.sig>"
            },
            {
                "author": "Karl-Johan Alm",
                "date": "2018-04-11T08:10:43",
                "message_text_only": "On Wed, Apr 11, 2018 at 4:52 PM, Peter Todd <pete at petertodd.org> wrote:\n> Or via full replace-by-fee, which appears to be used by a significant minority\n> of miners:\n\nI was of the impression that final transactions (sequence=0xffffffff)\ncannot be RBF'd."
            },
            {
                "author": "Peter Todd",
                "date": "2018-04-11T09:37:24",
                "message_text_only": "On Wed, Apr 11, 2018 at 05:10:43PM +0900, Karl-Johan Alm wrote:\n> On Wed, Apr 11, 2018 at 4:52 PM, Peter Todd <pete at petertodd.org> wrote:\n> > Or via full replace-by-fee, which appears to be used by a significant minority\n> > of miners:\n> \n> I was of the impression that final transactions (sequence=0xffffffff)\n> cannot be RBF'd.\n\nMy full-replace-by-fee tree ignores that. It also does preferential peering to\nensure it's well connected with likewise peers, and thus the whole network.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180411/ee9bc522/attachment.sig>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-04-11T09:48:39",
                "message_text_only": "Good morning Karl-Johan Alm,\n\nTo clarify:\n\nNothing prevents a miner from completely ignoring nSequence when putting transactions in blocks.\n\nUnconfirmed transactions are, by definition, not recorded in blocks.  So if there is a transaction 0xFFFFFFF nSequence and fee 1000 satoshi, and another conflicting transaction 0xFFFFFFF nSequence and fee 100000000 satoshi, miners can include the latter one even if the first one came to their knowledge first, regardless nSequence.\n\nThus, in the end \"full replace-by-fee\", where nSequence is IGNORED for purposes of replace-by-fee, is expected to become the norm, and we should really be designing our wallets and so on so that we only trust transactions that have confirmations.\n\nThe \"nSequence=0xFFFFFFFF means opt-OUT of RBF\" convention is only followed by fullnodes running standard bitcoind.  Nothing prevents miners from running patched bitcoind that ignores this rule, and connecting with similar peers who also ignore this rule.\n\nRegards,\nZmnSCPxj\n\n\n\u200bSent with ProtonMail Secure Email.\u200b\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n\nOn April 11, 2018 5:37 PM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Wed, Apr 11, 2018 at 05:10:43PM +0900, Karl-Johan Alm wrote:\n> \n> > On Wed, Apr 11, 2018 at 4:52 PM, Peter Todd pete at petertodd.org wrote:\n> > \n> > > Or via full replace-by-fee, which appears to be used by a significant minority\n> > > \n> > > of miners:\n> > \n> > I was of the impression that final transactions (sequence=0xffffffff)\n> > \n> > cannot be RBF'd.\n> \n> My full-replace-by-fee tree ignores that. It also does preferential peering to\n> \n> ensure it's well connected with likewise peers, and thus the whole network.\n> \n> \n> ---------------------------------------------------------------------------------------------------------------------------------------------------------------\n> \n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> \n> bitcoin-dev mailing list\n> \n> bitcoin-dev at lists.linuxfoundation.org\n> \n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Karl-Johan Alm",
                "date": "2018-04-11T10:00:45",
                "message_text_only": "Thanks for clarifying!\n\nOn Wed, Apr 11, 2018 at 6:48 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> Good morning Karl-Johan Alm,\n>\n> To clarify:\n>\n> Nothing prevents a miner from completely ignoring nSequence when putting transactions in blocks.\n>\n> Unconfirmed transactions are, by definition, not recorded in blocks.  So if there is a transaction 0xFFFFFFF nSequence and fee 1000 satoshi, and another conflicting transaction 0xFFFFFFF nSequence and fee 100000000 satoshi, miners can include the latter one even if the first one came to their knowledge first, regardless nSequence.\n>\n> Thus, in the end \"full replace-by-fee\", where nSequence is IGNORED for purposes of replace-by-fee, is expected to become the norm, and we should really be designing our wallets and so on so that we only trust transactions that have confirmations.\n>\n> The \"nSequence=0xFFFFFFFF means opt-OUT of RBF\" convention is only followed by fullnodes running standard bitcoind.  Nothing prevents miners from running patched bitcoind that ignores this rule, and connecting with similar peers who also ignore this rule.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n> Sent with ProtonMail Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>\n> On April 11, 2018 5:37 PM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> On Wed, Apr 11, 2018 at 05:10:43PM +0900, Karl-Johan Alm wrote:\n>>\n>> > On Wed, Apr 11, 2018 at 4:52 PM, Peter Todd pete at petertodd.org wrote:\n>> >\n>> > > Or via full replace-by-fee, which appears to be used by a significant minority\n>> > >\n>> > > of miners:\n>> >\n>> > I was of the impression that final transactions (sequence=0xffffffff)\n>> >\n>> > cannot be RBF'd.\n>>\n>> My full-replace-by-fee tree ignores that. It also does preferential peering to\n>>\n>> ensure it's well connected with likewise peers, and thus the whole network.\n>>\n>>\n>> ---------------------------------------------------------------------------------------------------------------------------------------------------------------\n>>\n>> https://petertodd.org 'peter'[:-1]@petertodd.org\n>>\n>> bitcoin-dev mailing list\n>>\n>> bitcoin-dev at lists.linuxfoundation.org\n>>\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>"
            },
            {
                "author": "Maksim Solovjov",
                "date": "2018-04-11T19:58:45",
                "message_text_only": "OK.\n\nThank you guys for clarification.\n\nOn Wed, Apr 11, 2018 at 1:00 PM, Karl-Johan Alm via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Thanks for clarifying!\n>\n> On Wed, Apr 11, 2018 at 6:48 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> > Good morning Karl-Johan Alm,\n> >\n> > To clarify:\n> >\n> > Nothing prevents a miner from completely ignoring nSequence when putting\n> transactions in blocks.\n> >\n> > Unconfirmed transactions are, by definition, not recorded in blocks.  So\n> if there is a transaction 0xFFFFFFF nSequence and fee 1000 satoshi, and\n> another conflicting transaction 0xFFFFFFF nSequence and fee 100000000\n> satoshi, miners can include the latter one even if the first one came to\n> their knowledge first, regardless nSequence.\n> >\n> > Thus, in the end \"full replace-by-fee\", where nSequence is IGNORED for\n> purposes of replace-by-fee, is expected to become the norm, and we should\n> really be designing our wallets and so on so that we only trust\n> transactions that have confirmations.\n> >\n> > The \"nSequence=0xFFFFFFFF means opt-OUT of RBF\" convention is only\n> followed by fullnodes running standard bitcoind.  Nothing prevents miners\n> from running patched bitcoind that ignores this rule, and connecting with\n> similar peers who also ignore this rule.\n> >\n> > Regards,\n> > ZmnSCPxj\n> >\n> >\n> > Sent with ProtonMail Secure Email.\n> >\n> > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> >\n> > On April 11, 2018 5:37 PM, Peter Todd via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> >> On Wed, Apr 11, 2018 at 05:10:43PM +0900, Karl-Johan Alm wrote:\n> >>\n> >> > On Wed, Apr 11, 2018 at 4:52 PM, Peter Todd pete at petertodd.org wrote:\n> >> >\n> >> > > Or via full replace-by-fee, which appears to be used by a\n> significant minority\n> >> > >\n> >> > > of miners:\n> >> >\n> >> > I was of the impression that final transactions (sequence=0xffffffff)\n> >> >\n> >> > cannot be RBF'd.\n> >>\n> >> My full-replace-by-fee tree ignores that. It also does preferential\n> peering to\n> >>\n> >> ensure it's well connected with likewise peers, and thus the whole\n> network.\n> >>\n> >>\n> >> ------------------------------------------------------------\n> ------------------------------------------------------------\n> ---------------------------------------\n> >>\n> >> https://petertodd.org 'peter'[:-1]@petertodd.org\n> >>\n> >> bitcoin-dev mailing list\n> >>\n> >> bitcoin-dev at lists.linuxfoundation.org\n> >>\n> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n> >\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180411/bc0c76ff/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Few questions regarding ListTransaction",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Peter Todd",
                "ZmnSCPxj",
                "Maksim Solovjov",
                "Karl-Johan Alm",
                "Joseph Gleason \u2448"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 15161
        }
    },
    {
        "title": "[bitcoin-dev] BloomFilter issue with segwit addresses",
        "thread_messages": [
            {
                "author": "Andreas Schildbach",
                "date": "2018-04-13T15:32:15",
                "message_text_only": "Anton, a developer on the bitcoinj maiing list, recently made me aware\n[1] of a compatibility issue between segwit and BIP37 (Bloom Filtering).\n\nThe issue affects only P2WPKH and the special case of transactions\nwithout change outputs (such as when emptying a wallet). In this case,\nneither inputs not outputs contain any data elements that would cause a\nmatch for the filter. The public key, which would match, goes to the\nwitness but not to the input.\n\nMy suggestion was to include an OP_RETURN output with a matching public\nkey in such transactions. Anton confirmed that this workaround is indeed\nworking. But of course it nullifies some of the segwit's size improvements.\n\nI wonder if Bitcoin Core would be willing to extend the BIP37 matching\nrules such that data elements in the witness are also matched against?\n\n\n[1] https://groups.google.com/d/msg/bitcoinj/SJpLgjowc1I/V7u2BavvAwAJ"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2018-04-13T19:12:47",
                "message_text_only": "Hi Andreas\n\nThanks for bringing this up and this seems indeed to be suboptimal.\n\n> I wonder if Bitcoin Core would be willing to extend the BIP37 matching\n> rules such that data elements in the witness are also matched against?\n\nBitcoin Core is not an identity that can be \u201ewilling to extend\u201c (or reject) a feature.\nSomeone needs to come up with a proposal (pull request).\n\nMaybe an extension for BIP37 would make sense (*meh*).\nJust inserting the witness data into the bloom filter seems to be an easy solution (CBloomFilter::IsRelevantAndUpdate())\n\n/jonas\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180413/1dd52b17/attachment.sig>"
            },
            {
                "author": "Jim Posen",
                "date": "2018-04-13T22:15:50",
                "message_text_only": "Why not add the outpoints owned by the wallet to the filter and watch for\nthose instead of elements in the input script or witness data?\n\nOn Fri, Apr 13, 2018 at 12:12 PM, Jonas Schnelli via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi Andreas\n>\n> Thanks for bringing this up and this seems indeed to be suboptimal.\n>\n> > I wonder if Bitcoin Core would be willing to extend the BIP37 matching\n> > rules such that data elements in the witness are also matched against?\n>\n> Bitcoin Core is not an identity that can be \u201ewilling to extend\u201c (or\n> reject) a feature.\n> Someone needs to come up with a proposal (pull request).\n>\n> Maybe an extension for BIP37 would make sense (*meh*).\n> Just inserting the witness data into the bloom filter seems to be an easy\n> solution (CBloomFilter::IsRelevantAndUpdate())\n>\n> /jonas\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180413/cedc5780/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2018-04-14T16:14:04",
                "message_text_only": "Note that this would compound the privacy leak that Jonas Nick used to\nidentify address clusters via the bloom filters in one of his publications.\nBy reducing the false positives when matching you can get very detailed\nclusters. Then again we know that bloom filters aren't good for privacy\nanyway, so this might be a non-issue.\n\nOn Sat, Apr 14, 2018, 00:17 Jim Posen via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Why not add the outpoints owned by the wallet to the filter and watch for\n> those instead of elements in the input script or witness data?\n>\n> On Fri, Apr 13, 2018 at 12:12 PM, Jonas Schnelli via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi Andreas\n>>\n>> Thanks for bringing this up and this seems indeed to be suboptimal.\n>>\n>> > I wonder if Bitcoin Core would be willing to extend the BIP37 matching\n>> > rules such that data elements in the witness are also matched against?\n>>\n>> Bitcoin Core is not an identity that can be \u201ewilling to extend\u201c (or\n>> reject) a feature.\n>> Someone needs to come up with a proposal (pull request).\n>>\n>> Maybe an extension for BIP37 would make sense (*meh*).\n>> Just inserting the witness data into the bloom filter seems to be an easy\n>> solution (CBloomFilter::IsRelevantAndUpdate())\n>>\n>> /jonas\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180414/1e06e952/attachment.html>"
            },
            {
                "author": "Jim Posen",
                "date": "2018-04-14T19:46:01",
                "message_text_only": "To Christian's point about privacy, I'll take this opportunity to\nshamelessly review beg on https://github.com/bitcoin/bitcoin/pull/12254,\nthe PR for BIP 158 implementation (but not 157).\n\nOn Sat, Apr 14, 2018 at 9:14 AM, Christian Decker <\ndecker.christian at gmail.com> wrote:\n\n> Note that this would compound the privacy leak that Jonas Nick used to\n> identify address clusters via the bloom filters in one of his publications.\n> By reducing the false positives when matching you can get very detailed\n> clusters. Then again we know that bloom filters aren't good for privacy\n> anyway, so this might be a non-issue.\n>\n> On Sat, Apr 14, 2018, 00:17 Jim Posen via bitcoin-dev <bitcoin-dev at lists.\n> linuxfoundation.org> wrote:\n>\n>> Why not add the outpoints owned by the wallet to the filter and watch for\n>> those instead of elements in the input script or witness data?\n>>\n>> On Fri, Apr 13, 2018 at 12:12 PM, Jonas Schnelli via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Hi Andreas\n>>>\n>>> Thanks for bringing this up and this seems indeed to be suboptimal.\n>>>\n>>> > I wonder if Bitcoin Core would be willing to extend the BIP37 matching\n>>> > rules such that data elements in the witness are also matched against?\n>>>\n>>> Bitcoin Core is not an identity that can be \u201ewilling to extend\u201c (or\n>>> reject) a feature.\n>>> Someone needs to come up with a proposal (pull request).\n>>>\n>>> Maybe an extension for BIP37 would make sense (*meh*).\n>>> Just inserting the witness data into the bloom filter seems to be an\n>>> easy solution (CBloomFilter::IsRelevantAndUpdate())\n>>>\n>>> /jonas\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180414/085832a7/attachment.html>"
            },
            {
                "author": "Andreas Schildbach",
                "date": "2018-04-15T18:37:45",
                "message_text_only": "Yes, I guess the quicker filter exhaustion must be the reason why\nbitcoinj doesn't make use of outpoints in filters for standard\ntransactions. I'll look into if I can change that.\n\n\nOn 04/14/2018 06:14 PM, Christian Decker via bitcoin-dev wrote:\n> Note that this would compound the privacy leak that Jonas Nick used to\n> identify address clusters via the bloom filters in one of his\n> publications. By reducing the false positives when matching you can get\n> very detailed clusters. Then again we know that bloom filters aren't\n> good for privacy anyway, so this might be a non-issue.\n> \n> On Sat, Apr 14, 2018, 00:17 Jim Posen via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> \n>     Why not add the outpoints owned by the wallet to the filter and\n>     watch for those instead of elements in the input script or witness data?\n> \n>     On Fri, Apr 13, 2018 at 12:12 PM, Jonas Schnelli via bitcoin-dev\n>     <bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> \n>         Hi Andreas\n> \n>         Thanks for bringing this up and this seems indeed to be suboptimal.\n> \n>         > I wonder if Bitcoin Core would be willing to extend the BIP37 matching\n>         > rules such that data elements in the witness are also matched against?\n> \n>         Bitcoin Core is not an identity that can be \u201ewilling to extend\u201c\n>         (or reject) a feature.\n>         Someone needs to come up with a proposal (pull request).\n> \n>         Maybe an extension for BIP37 would make sense (*meh*).\n>         Just inserting the witness data into the bloom filter seems to\n>         be an easy solution (CBloomFilter::IsRelevantAndUpdate())\n> \n>         /jonas\n> \n>         _______________________________________________\n>         bitcoin-dev mailing list\n>         bitcoin-dev at lists.linuxfoundation.org\n>         <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> \n>     _______________________________________________\n>     bitcoin-dev mailing list\n>     bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2018-04-13T22:52:23",
                "message_text_only": "As I understand it, the plan is to deprecated and remove BIP37 entirely once \nBIP158 is implemented and deployed.\n\nIn the meantime, Bitcoin Knots supports the MSG_FILTERED_WITNESS_BLOCK \nextension to download witness data. (Note that light clients currently have no \nway to verify the witness data is correct.)\n\nAs far as matching goes, why not look for the specific COutPoints? That should \nwork already with standard BIP37.\n\nLuke\n\n\nOn Friday 13 April 2018 3:32:15 PM Andreas Schildbach via bitcoin-dev wrote:\n> Anton, a developer on the bitcoinj maiing list, recently made me aware\n> [1] of a compatibility issue between segwit and BIP37 (Bloom Filtering).\n> \n> The issue affects only P2WPKH and the special case of transactions\n> without change outputs (such as when emptying a wallet). In this case,\n> neither inputs not outputs contain any data elements that would cause a\n> match for the filter. The public key, which would match, goes to the\n> witness but not to the input.\n> \n> My suggestion was to include an OP_RETURN output with a matching public\n> key in such transactions. Anton confirmed that this workaround is indeed\n> working. But of course it nullifies some of the segwit's size improvements.\n> \n> I wonder if Bitcoin Core would be willing to extend the BIP37 matching\n> rules such that data elements in the witness are also matched against?\n> \n> \n> [1] https://groups.google.com/d/msg/bitcoinj/SJpLgjowc1I/V7u2BavvAwAJ\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "BloomFilter issue with segwit addresses",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Andreas Schildbach",
                "Luke Dashjr",
                "Jim Posen",
                "Jonas Schnelli",
                "Christian Decker"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 11142
        }
    },
    {
        "title": "[bitcoin-dev] Numerifides - Proposal for Decentralized trust/authority on Bitcoin blockchain",
        "thread_messages": [
            {
                "author": "Tyler H",
                "date": "2018-04-21T12:35:28",
                "message_text_only": "Greetings,\n\nI have been working on a proposal called Numerifides which would provide a\ngeneral method to register human-readable names and arbitrary data (such as\nusername->GPG key, domain->IP address, Lightning node Alias-> URI, etc).\nHere are the key highlights:\n\n--New transaction type called \"numerifides\" transactions\n--Lock up Bitcoin for a certain amount of time to make the mappings valid,\ndiscourage \"namesquatting\"\n--Transaction puzzle attached to transactions to allow community consensus\nrevocation of highly contested names or \"squatted\" name mappings.\n--Transactions are RBF so if name is contentious or miners wish to censor,\none honest greedy miner can include the censored user's high-fee\ntransaction)\n--Solves Zooko's triangle of Secure, Decentralized and Human Meaningful\n\nFull working spec is here: https://github.com/tyzbit/numerifides\n\nI'd love feedback and possible enhancements, as I know this early rough\ndraft does have a lot of room for improvement (I also think it would be\nremiss to incentivize filling blocks with data like this, and a possible\nchange proposed on the lightning-dev list by ZmnSCPxj is a P2WSH defining\nthe mapping that is gossiped about outside of the Bitcoin network, but I'd\nlike to hear all comments).\n\nThank you for your time.\nTyler Hawkins\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180421/60d32e11/attachment.html>"
            },
            {
                "author": "Tyler H",
                "date": "2018-04-25T06:58:45",
                "message_text_only": "Hello again,\n\nI've reworked this idea a bit as alluded to previously.  The key highlights\nof Numerifides are now:\n\n- Transaction is a normal transaction paying to a script hash with a\nCHECKSEQUENCEVERIFY encumbrance.\n- Users \"mine\" their registrations to produce TXIDs with Proof of Work\nattached (providing for a way to secure and \"commandeer\" names).\n- Secondary network for gossiping name->data mappings, that is rooted from\nthe numerifide transactions on the Bitcoin blockchain.\n\nThe \"mining\" is done simply by incrementing a nonce in the registration\ndata (off-chain).  This prevents \"namesquatting\" like we see on Namecoin.\n\nThere is an easy formula that uses the Timelock, Proof of Work and amount\nof Bitcoin locked that determines which transactions are authoritative for\na given name mapping.\n\nhttps://github.com/tyzbit/numerifides#technical-proposal\n\nFeedback and criticism appreciated,\nTyler\n\nOn Sat, Apr 21, 2018 at 8:35 AM Tyler H <tyzbit at gmail.com> wrote:\n\n> Greetings,\n>\n> I have been working on a proposal called Numerifides which would provide a\n> general method to register human-readable names and arbitrary data (such as\n> username->GPG key, domain->IP address, Lightning node Alias-> URI, etc).\n> Here are the key highlights:\n>\n> --New transaction type called \"numerifides\" transactions\n> --Lock up Bitcoin for a certain amount of time to make the mappings valid,\n> discourage \"namesquatting\"\n> --Transaction puzzle attached to transactions to allow community consensus\n> revocation of highly contested names or \"squatted\" name mappings.\n> --Transactions are RBF so if name is contentious or miners wish to censor,\n> one honest greedy miner can include the censored user's high-fee\n> transaction)\n> --Solves Zooko's triangle of Secure, Decentralized and Human Meaningful\n>\n> Full working spec is here: https://github.com/tyzbit/numerifides\n>\n> I'd love feedback and possible enhancements, as I know this early rough\n> draft does have a lot of room for improvement (I also think it would be\n> remiss to incentivize filling blocks with data like this, and a possible\n> change proposed on the lightning-dev list by ZmnSCPxj is a P2WSH defining\n> the mapping that is gossiped about outside of the Bitcoin network, but I'd\n> like to hear all comments).\n>\n> Thank you for your time.\n> Tyler Hawkins\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180425/27290ddb/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Numerifides - Proposal for Decentralized trust/authority on Bitcoin blockchain",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tyler H"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3975
        }
    },
    {
        "title": "[bitcoin-dev] Multi-signature and multi-coin HD wallet in one BIP32 derivation path (new BIP)",
        "thread_messages": [
            {
                "author": "Paul Brown",
                "date": "2018-04-25T09:35:03",
                "message_text_only": "Hi\n\nI have written a new BIP describing a BIP32 derivation path that supports a single or multi-signature and multi-coin wallet from a single master seed.  It combines BIP44 and BIP45 and adds in a self-describing structure in the derivation path for multiple multi-sig combinations within the single wallet along with an extended public key export file format for public key distribution between parties.  I can particularly see this being useful for multiple Lightning Network 2of2 accounts for different payment channels.\n\nThe BIP can be found here: https://github.com/gluexchange/bip/blob/master/bip-0046.mediawiki\n\nI appreciate that this might be re-hashing old ground as BIP44 in particular has been widely adopted, however, BIP44 does leave itself open to a lot of interpretation from a wallet portability perspective such as:\n\n- What address format is expected when discovering balances and creating transactions?\n- Does the master seed represent a single-sig or multi-sig wallet?\n- If multi-sig, how many cosigners and what are their extended public keys (so that the wallet can generate the correctly formatted redeem script with public keys in the right order)?\n- If multi-sig, how do you prevent collisions on the same address index (in a wallet that is occasionally connected)?\n\nBIP45 solves the collision that occurs when the individual parties in a multi-sig group each give out a new address from a wallet, where the wallet hasn't been able to sync to mark the address as 'used' (this could happen if they gave out addresses independently at the same time).  It uses a cosigner index in the derivation path so that each party has their own path to their addresses.  However, BIP45 drops the multi-coin support that BIP44 has.\n\nThis is a useful discussion on the problems of a collision and the merits of separating cosigners in the derivation path: https://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg05188.html\n\nFor the purposes of the BIP text (and the example paths used to generate keys) I've temporarily assigned it the number 46.  It looks like that is available and seemed somewhat appropriate given that it builds on the good work of BIP44 and BIP45.\n\nPaul Brown\n\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180425/eb57c1c2/attachment.html>"
            },
            {
                "author": "Clark Moody",
                "date": "2018-04-25T14:35:57",
                "message_text_only": "Thanks for the proposal, Paul.\n\n*> - What address format is expected when discovering balances and creating\ntransactions?*\n\nYour solution does not solve your first bullet point, since the xpub\nencoding looks no different than any other xpub (BIP 44, 45, 49, etc). At\nthe least, you should propose new version bytes to change the \"xpub\" in the\nencoding to some other string.\n\nAlternatively, I would suggest that you use the xpub serialization format\ndescribed in SLIP-0032 (\nhttps://github.com/satoshilabs/slips/blob/master/slip-0032.md). It includes\nthe derivation path within the xpub itself and uses Bech32 for encoding.\n\nGiven a normal xpub with no additional information, a wallet must scan the\naddress space for the various formats. SLIP-0032 solves this bootstrapping\nproblem and avoids the UX nightmare of users being required to know to\nwhich BIP number the xpub conforms.\n\nAlso, @luke-jr will give you a hard time to self-assigning a BIP number ;-)\n\nThanks\n\n\n\n-Clark\n\nOn Wed, Apr 25, 2018 at 4:35 AM, Paul Brown via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi\n>\n>\n>\n> I have written a new BIP describing a BIP32 derivation path that supports\n> a single or multi-signature and multi-coin wallet from a single master\n> seed.  It combines BIP44 and BIP45 and adds in a self-describing structure\n> in the derivation path for multiple multi-sig combinations within the\n> single wallet along with an extended public key export file format for\n> public key distribution between parties.  I can particularly see this being\n> useful for multiple Lightning Network 2of2 accounts for different payment\n> channels.\n>\n>\n>\n> The BIP can be found here: https://github.com/gluexchange/bip/blob/master/\n> bip-0046.mediawiki\n>\n>\n>\n> I appreciate that this might be re-hashing old ground as BIP44 in\n> particular has been widely adopted, however, BIP44 does leave itself open\n> to a lot of interpretation from a wallet portability perspective such as:\n>\n>\n>\n> - What address format is expected when discovering balances and creating\n> transactions?\n>\n> - Does the master seed represent a single-sig or multi-sig wallet?\n>\n> - If multi-sig, how many cosigners and what are their extended public keys\n> (so that the wallet can generate the correctly formatted redeem script with\n> public keys in the right order)?\n>\n> - If multi-sig, how do you prevent collisions on the same address index\n> (in a wallet that is occasionally connected)?\n>\n>\n>\n> BIP45 solves the collision that occurs when the individual parties in a\n> multi-sig group each give out a new address from a wallet, where the wallet\n> hasn\u2019t been able to sync to mark the address as \u2018used\u2019 (this could happen\n> if they gave out addresses independently at the same time).  It uses a\n> cosigner index in the derivation path so that each party has their own path\n> to their addresses.  However, BIP45 drops the multi-coin support that BIP44\n> has.\n>\n>\n>\n> This is a useful discussion on the problems of a collision and the merits\n> of separating cosigners in the derivation path:\n> https://www.mail-archive.com/bitcoin-development@lists.\n> sourceforge.net/msg05188.html\n>\n>\n>\n> For the purposes of the BIP text (and the example paths used to generate\n> keys) I\u2019ve temporarily assigned it the number 46.  It looks like that is\n> available and seemed somewhat appropriate given that it builds on the good\n> work of BIP44 and BIP45.\n>\n>\n>\n> Paul Brown\n>\n>\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180425/14fbc624/attachment-0001.html>"
            },
            {
                "author": "Paul Brown",
                "date": "2018-04-25T16:44:55",
                "message_text_only": "Hi Clark,\n\nThanks very much for the feedback, it is most appreciated.\n\nThe BIP does state that the address format would be bech32 serialized, using P2WPKH and P2WSH, however, I take your point as you would need to know it\u2019s a BIP \u201846\u2019 to know to use bech32 P2WPKH or P2WSH.  SLIP-0032 serialization format does solve it from the point of view of knowing which BIP the xpub is associated and therefore by association what address format to use.  Makes perfect sense and probably a good change to make to the proposed BIP.\n\nAlso, the nice thing about SLIP-0032 is that the serialization format additionally provides that extra check that the correct xpubs are distributed between parties where say, distributing a 3of5 xpub means you can check that the bytes at depth 3 and 4 represent the 3of5 path.\n\nAh yes, it was a little presumptuous of me to pick 46 for the BIP but in my defence I needed a \u2018real\u2019 number to generate the paths with \ud83d\ude0a\n\nPaul\n\n\n\nFrom: clarkmoody at gmail.com <clarkmoody at gmail.com> On Behalf Of Clark Moody\nSent: 25 April 2018 15:36\nTo: Paul Brown <paul at 345.systems>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>\nSubject: Re: [bitcoin-dev] Multi-signature and multi-coin HD wallet in one BIP32 derivation path (new BIP)\n\nThanks for the proposal, Paul.\n\n> - What address format is expected when discovering balances and creating transactions?\n\nYour solution does not solve your first bullet point, since the xpub encoding looks no different than any other xpub (BIP 44, 45, 49, etc). At the least, you should propose new version bytes to change the \"xpub\" in the encoding to some other string.\n\nAlternatively, I would suggest that you use the xpub serialization format described in SLIP-0032 (https://github.com/satoshilabs/slips/blob/master/slip-0032.md). It includes the derivation path within the xpub itself and uses Bech32 for encoding.\n\nGiven a normal xpub with no additional information, a wallet must scan the address space for the various formats. SLIP-0032 solves this bootstrapping problem and avoids the UX nightmare of users being required to know to which BIP number the xpub conforms.\n\nAlso, @luke-jr will give you a hard time to self-assigning a BIP number ;-)\n\nThanks\n\n\n\n-Clark\n\nOn Wed, Apr 25, 2018 at 4:35 AM, Paul Brown via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\nHi\n\nI have written a new BIP describing a BIP32 derivation path that supports a single or multi-signature and multi-coin wallet from a single master seed.  It combines BIP44 and BIP45 and adds in a self-describing structure in the derivation path for multiple multi-sig combinations within the single wallet along with an extended public key export file format for public key distribution between parties.  I can particularly see this being useful for multiple Lightning Network 2of2 accounts for different payment channels.\n\nThe BIP can be found here: https://github.com/gluexchange/bip/blob/master/bip-0046.mediawiki\n\nI appreciate that this might be re-hashing old ground as BIP44 in particular has been widely adopted, however, BIP44 does leave itself open to a lot of interpretation from a wallet portability perspective such as:\n\n- What address format is expected when discovering balances and creating transactions?\n- Does the master seed represent a single-sig or multi-sig wallet?\n- If multi-sig, how many cosigners and what are their extended public keys (so that the wallet can generate the correctly formatted redeem script with public keys in the right order)?\n- If multi-sig, how do you prevent collisions on the same address index (in a wallet that is occasionally connected)?\n\nBIP45 solves the collision that occurs when the individual parties in a multi-sig group each give out a new address from a wallet, where the wallet hasn\u2019t been able to sync to mark the address as \u2018used\u2019 (this could happen if they gave out addresses independently at the same time).  It uses a cosigner index in the derivation path so that each party has their own path to their addresses.  However, BIP45 drops the multi-coin support that BIP44 has.\n\nThis is a useful discussion on the problems of a collision and the merits of separating cosigners in the derivation path: https://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg05188.html\n\nFor the purposes of the BIP text (and the example paths used to generate keys) I\u2019ve temporarily assigned it the number 46.  It looks like that is available and seemed somewhat appropriate given that it builds on the good work of BIP44 and BIP45.\n\nPaul Brown\n\n\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180425/cdad8bec/attachment-0001.html>"
            },
            {
                "author": "Paul Brown",
                "date": "2018-04-26T14:05:06",
                "message_text_only": "Hi\n\nI realised after I sent my previous response that the encoding was wrong and that my smiley face at the end of the BIP number comment got turned into a ? and the tongue in cheek context was lost :-(\n\nAnyway, back onto subject.  I've been thinking some more on the SLIP-0032 adoption in this proposal and specifically the address format to use when generating addresses.\n\nMy proposal states bech32 serialized addresses (P2WPKH or P2WSH), however, I wonder whether there is some merit in extending the derivation path with an additional level below coin type to represent the address format, with the value determined by the context of the coin type value in the derivation path (0x00 for P2WPKH bech32, 0x01 for P2PKH base58 if coin type is Bitcoin, 0x00 for Ethereum account format if coin type is Ether, etc).  A separate spec similar to SLIP-0044 could be created that defines the list of address formats and the derivation path values.\n\nWhen importing root master seeds or distributing the xpub's for each cosigner to each party the discovery process in the proposal would need extending to try each address format in turn to determine whether there is a 'hit' when checking balances.  It does mean that the import process is slower however the additional flexibility of supporting multiple address formats possibly outweighs this.  I'm just thinking that having a rule to follow during discovery, particularly where non-Bitcoin coins are concerned, is more explicit than leaving it open to the wallet implementer to figure out (for altcoins, what address format to use?).\n\nIt also means that future address formats are supported as they are simply added to the new spec list for the coin type (can be done by anyone, similar to the way SLIP-0044 works now) - it doesn't require a new BIP to support.  For example, if address format was a derivation level in BIP44, would BIP49 and BIP84 be needed?\n\nI'm somewhat musing out loud here, but I like the idea of being able to mostly self-discover as much as possible and reducing or eliminating the need for proprietary metadata attached to the wallet.\n\nCheers\nPaul\n\nFrom: clarkmoody at gmail.com <clarkmoody at gmail.com> On Behalf Of Clark Moody\nSent: 25 April 2018 15:36\nTo: Paul Brown <paul at 345.systems>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>\nSubject: Re: [bitcoin-dev] Multi-signature and multi-coin HD wallet in one BIP32 derivation path (new BIP)\n\nThanks for the proposal, Paul.\n\n>\u00a0- What address format is expected when discovering balances and creating transactions?\n\nYour solution does not solve your first bullet point, since the xpub encoding looks no different than any other xpub (BIP 44, 45, 49, etc). At the least, you should propose new version bytes to change the \"xpub\" in the encoding to some other string.\n\nAlternatively, I would suggest that you use the xpub serialization format described in SLIP-0032 (https://github.com/satoshilabs/slips/blob/master/slip-0032.md). It includes the derivation path within the xpub itself and uses Bech32 for encoding.\n\nGiven a normal xpub with no additional information, a wallet must scan the address space for the various formats. SLIP-0032 solves this bootstrapping problem and avoids the UX nightmare of users being required to know to which BIP number the xpub conforms.\n\nAlso, @luke-jr will give you a hard time to self-assigning a BIP number ;-)\n\nThanks\n\n\n\n\n-Clark\n\nOn Wed, Apr 25, 2018 at 4:35 AM, Paul Brown via bitcoin-dev <mailto:bitcoin-dev at lists.linuxfoundation.org> wrote:\nHi\n\u00a0\nI have written a new BIP describing a BIP32 derivation path that supports a single or multi-signature and multi-coin wallet from a single master seed.\u00a0 It combines BIP44 and BIP45 and adds in a self-describing structure in the derivation path for multiple multi-sig combinations within the single wallet along with an extended public key export file format for public key distribution between parties.\u00a0 I can particularly see this being useful for multiple Lightning Network 2of2 accounts for different payment channels.\n\u00a0\nThe BIP can be found here: https://github.com/gluexchange/bip/blob/master/bip-0046.mediawiki\n\u00a0\nI appreciate that this might be re-hashing old ground as BIP44 in particular has been widely adopted, however, BIP44 does leave itself open to a lot of interpretation from a wallet portability perspective such as:\n\u00a0\n- What address format is expected when discovering balances and creating transactions?\n- Does the master seed represent a single-sig or multi-sig wallet?\n- If multi-sig, how many cosigners and what are their extended public keys (so that the wallet can generate the correctly formatted redeem script with public keys in the right order)?\n- If multi-sig, how do you prevent collisions on the same address index (in a wallet that is occasionally connected)?\n\u00a0\nBIP45 solves the collision that occurs when the individual parties in a multi-sig group each give out a new address from a wallet, where the wallet hasn\u2019t been able to sync to mark the address as \u2018used\u2019 (this could happen if they gave out addresses independently at the same time).\u00a0 It uses a cosigner index in the derivation path so that each party has their own path to their addresses.\u00a0 However, BIP45 drops the multi-coin support that BIP44 has.\n\u00a0\nThis is a useful discussion on the problems of a collision and the merits of separating cosigners in the derivation path: https://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg05188.html\n\u00a0\nFor the purposes of the BIP text (and the example paths used to generate keys) I\u2019ve temporarily assigned it the number 46.\u00a0 It looks like that is available and seemed somewhat appropriate given that it builds on the good work of BIP44 and BIP45.\n\u00a0\nPaul Brown\n\u00a0\n\u00a0\n\n_______________________________________________\nbitcoin-dev mailing list\nmailto:bitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "Multi-signature and multi-coin HD wallet in one BIP32 derivation path (new BIP)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Clark Moody",
                "Paul Brown"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 17172
        }
    },
    {
        "title": "[bitcoin-dev] eltoo: A Simplified update Mechanism for Lightning and Off-Chain Contracts",
        "thread_messages": [
            {
                "author": "Christian Decker",
                "date": "2018-04-30T15:41:38",
                "message_text_only": "(cross-posting to bitcoin-dev since this serves as motivation behind the\nsighash_noinput proposal)\n\n> TL;DR: we announce a new, simple, update mechanism for off-chain protocols,\n> see the announcement [1] and the paper [2] :-)\n\nA little over a year ago, the three Lightning Network implementation\nteams joined forces to work on a common specification for the protocol\nstack. Now that both that specification and our three implementations\nare becoming stable and usable, it is time to look forward: to further\nimprove the protocol, to add new features, to simplify, and to fix\ndownsides.\n\nOne of the core innovations that enabled Lightning in the first place was an\noff-chain update mechanism to renegotiate a new state and ensure that the old\nstate can not be settled on-chain. Today, we're excited to release our latest\nresearch paper on a new, simplified, update mechanism for layer 2 protocols,\ncalled eltoo.\n\neltoo is a drop-in replacement for the penalty based invalidation\nmechanism that is used today in the Lightning specification. It is\nsimilar in many ways to the sequence number mechanism that was already\npresent in the original Bitcoin implementation. But, while sequence\nnumbers were unenforceable on the blockchain, eltoo is enforceable by\noverriding subsequent states on-chain.\n\nUnlike the current mechanism used in Lightning so far, it is not penalty\nbased, i.e., publishing an old state does not result in the faulty node\nto automatically lose funds, and is most similar to the duplex\nmicropayment channels construction. It is a symmetric scheme, i.e., all\nparticipants share an identical set of transactions, and it ensures that the\nlast agreed upon state is settled on-chain, with similar tradeoffs as\ntoday's Lightning (timelock vs. online requirement).\n\neltoo addresses some of the issues we encountered while speficying and\nimplementing the Lightning Network. For example outsourcing becomes very\nsimple since old states becoming public can't hurt us anymore. We\ncompletely remove the need to estimate fees ahead of time. The\nconstruction allows us to attach fees when settling, and even allows for\nfees to be bumped using CPFP or RBF.\n\nBeyond Lightning, eltoo can be used as a generic update mechanism for an\noff-chain contract, for a larger number of participants. This was not\npossible in the current update mechanism since reactions to a\nmisbehaving participant needed to be tailore to that participant. This\nenables other protocols such as the channel factories, and in\ncombination with Schnorr signatures allows for very large off-chain\ncontracts with minimal on-chain footprint.\n\nBefore we can implement eltoo, we need a minor change to Bitcoin: the\nintroduction of the SIGHASH_NOINPUT flag for signatures. This was first\ndiscussed a few months ago in the context of watchtowers to help secure\nLightning channels, but was not formally proposed. A formal proposal may\nnow be found in the eltoo paper.\n\nWe invite the community to consider our proposal and to participate in\nits discussion. We hope to arrive at a consensus for the usage of\nSIGHASH_NOINPUT, so that it can be accepted and included in a future\nsoft fork of Bitcoin Script. Doing so will put us on the road to a more\nreliable and simpler Lightning Network, incorporating a new update\nmechanism that can also be used for many other applications.\n\nThe full official announcement can be found at [1] and the paper with the full\ndetails can be found at [2].\n\nLooking forward to the communities feedback,\nChristian\n\n[1] https://blockstream.com/2018/04/30/eltoo-next-lightning.html\n[2] https://blockstream.com/eltoo.pdf"
            },
            {
                "author": "Jim Posen",
                "date": "2018-04-30T23:00:55",
                "message_text_only": "This construction is pretty neat and seems to solve a lot of problems. I\nfind the use of CLTV with past timestamps to provide ordering in particular\nto be quite clever.\n\nIf my understanding is correct though, this construction would\nsignificantly increase the safe CLTV delta requirements because HTLCs\ncannot be timed out immediately on the settlement transaction. Consider a\ncase where node B receives an HTLC from A and forwards to C. If the HTLC\noffered to C times out and C does not fail the HTLC off-chain, Lightning\ncurrently guarantees that the CLTV delta is sufficient that I may close the\nchannel to C on-chain and claim the timed-out HTLC before my upstream HTLC\nto A times out. If the CLTV delta is too small, I may fail the upstream\nHTLC as soon as it times out, and then C may still claim the downstream\nHTLC with the preimage on-chain. With eltoo, when B closes the downstream\nchannel on-chain, it must wait the CSV timeout on the update transaction\nbefore locking in the timed-out HTLC. This effectively means the CLTV delta\nhas to be greater than the CSV timeout, plus some extra (whereas it is\ncurrently safe to make it significantly shorter). Is that true or am I\nmissing something?\n\nOn Mon, Apr 30, 2018 at 8:41 AM, Christian Decker via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> (cross-posting to bitcoin-dev since this serves as motivation behind the\n> sighash_noinput proposal)\n>\n> > TL;DR: we announce a new, simple, update mechanism for off-chain\n> protocols,\n> > see the announcement [1] and the paper [2] :-)\n>\n> A little over a year ago, the three Lightning Network implementation\n> teams joined forces to work on a common specification for the protocol\n> stack. Now that both that specification and our three implementations\n> are becoming stable and usable, it is time to look forward: to further\n> improve the protocol, to add new features, to simplify, and to fix\n> downsides.\n>\n> One of the core innovations that enabled Lightning in the first place was\n> an\n> off-chain update mechanism to renegotiate a new state and ensure that the\n> old\n> state can not be settled on-chain. Today, we're excited to release our\n> latest\n> research paper on a new, simplified, update mechanism for layer 2\n> protocols,\n> called eltoo.\n>\n> eltoo is a drop-in replacement for the penalty based invalidation\n> mechanism that is used today in the Lightning specification. It is\n> similar in many ways to the sequence number mechanism that was already\n> present in the original Bitcoin implementation. But, while sequence\n> numbers were unenforceable on the blockchain, eltoo is enforceable by\n> overriding subsequent states on-chain.\n>\n> Unlike the current mechanism used in Lightning so far, it is not penalty\n> based, i.e., publishing an old state does not result in the faulty node\n> to automatically lose funds, and is most similar to the duplex\n> micropayment channels construction. It is a symmetric scheme, i.e., all\n> participants share an identical set of transactions, and it ensures that\n> the\n> last agreed upon state is settled on-chain, with similar tradeoffs as\n> today's Lightning (timelock vs. online requirement).\n>\n> eltoo addresses some of the issues we encountered while speficying and\n> implementing the Lightning Network. For example outsourcing becomes very\n> simple since old states becoming public can't hurt us anymore. We\n> completely remove the need to estimate fees ahead of time. The\n> construction allows us to attach fees when settling, and even allows for\n> fees to be bumped using CPFP or RBF.\n>\n> Beyond Lightning, eltoo can be used as a generic update mechanism for an\n> off-chain contract, for a larger number of participants. This was not\n> possible in the current update mechanism since reactions to a\n> misbehaving participant needed to be tailore to that participant. This\n> enables other protocols such as the channel factories, and in\n> combination with Schnorr signatures allows for very large off-chain\n> contracts with minimal on-chain footprint.\n>\n> Before we can implement eltoo, we need a minor change to Bitcoin: the\n> introduction of the SIGHASH_NOINPUT flag for signatures. This was first\n> discussed a few months ago in the context of watchtowers to help secure\n> Lightning channels, but was not formally proposed. A formal proposal may\n> now be found in the eltoo paper.\n>\n> We invite the community to consider our proposal and to participate in\n> its discussion. We hope to arrive at a consensus for the usage of\n> SIGHASH_NOINPUT, so that it can be accepted and included in a future\n> soft fork of Bitcoin Script. Doing so will put us on the road to a more\n> reliable and simpler Lightning Network, incorporating a new update\n> mechanism that can also be used for many other applications.\n>\n> The full official announcement can be found at [1] and the paper with the\n> full\n> details can be found at [2].\n>\n> Looking forward to the communities feedback,\n> Christian\n>\n> [1] https://blockstream.com/2018/04/30/eltoo-next-lightning.html\n> [2] https://blockstream.com/eltoo.pdf\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180430/b6a46771/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "eltoo: A Simplified update Mechanism for Lightning and Off-Chain Contracts",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Jim Posen",
                "Christian Decker"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 9048
        }
    },
    {
        "title": "[bitcoin-dev] BIP sighash_noinput",
        "thread_messages": [
            {
                "author": "Christian Decker",
                "date": "2018-04-30T16:29:53",
                "message_text_only": "Hi all,\n\nI'd like to pick up the discussion from a few months ago, and propose a new\nsighash flag, `SIGHASH_NOINPUT`, that removes the commitment to the previous\noutput. This was previously mentioned on the list by Joseph Poon [1], but was\nnever formally proposed, so I wrote a proposal [2].\n\nWe have long known that `SIGHASH_NOINPUT` would be a great fit for Lightning.\nThey enable simple watch-towers, i.e., outsource the need to watch the\nblockchain for channel closures, and react appropriately if our counterparty\nmisbehaves. In addition to this we just released the eltoo [3,4] paper which\ndescribes a simplified update mechanism that can be used in Lightning, and other\noff-chain contracts, with any number of participants.\n\nBy not committing to the previous output being spent by the transaction, we can\nrebind an input to point to any outpoint with a matching output script and\nvalue. The binding therefore is no longer explicit through a reference, but\nthrough script compatibility, and the transaction ID reference in the input is a\nhint to validators. The sighash flag is meant to enable some off-chain use-cases\nand should not be used unless the tradeoffs are well-known. In particular we\nsuggest using contract specific key-pairs, in order to avoid having any unwanted\nrebinding opportunities.\n\nThe proposal is very minimalistic, and simple. However, there are a few things\nwhere we'd like to hear the input of the wider community with regards to the\nimplementation details though. We had some discussions internally on whether to\nuse a separate opcode or a sighash flag, some feeling that the sighash flag\ncould lead to some confusion with existing wallets, but given that we have\n`SIGHASH_NONE`, and that existing wallets will not sign things with unknown\nflags, we decided to go the sighash way. Another thing is that we still commit\nto the amount of the outpoint being spent. The rationale behind this is that,\nwhile rebinding to outpoints with the same value maintains the value\nrelationship between input and output, we will probably not want to bind to\nsomething with a different value and suddenly pay a gigantic fee.\n\nThe deployment part of the proposal is left vague on purpose in order not to\ncollide with any other proposals. It should be possible to introduce it by\nbumping the segwit script version and adding the new behavior.\n\nI hope the proposal is well received, and I'm looking forward to discussing\nvariants and tradeoffs here. I think the applications we proposed so far are\nquite interesting, and I'm sure there are many more we can enable with this\nchange.\n\nCheers,\nChristian\n\n[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-February/012460.html\n[2] https://github.com/cdecker/bips/blob/noinput/bip-xyz.mediawiki\n[3] https://blockstream.com/2018/04/30/eltoo-next-lightning.html\n[4] https://blockstream.com/eltoo.pdf"
            },
            {
                "author": "Dario Sneidermanis",
                "date": "2018-04-30T18:25:42",
                "message_text_only": "Something like this might also be useful for several use cases related to\nRBF. For example:\n\nAlice sends Bob an RBF-activated transaction T1 with the intention of\nbumping its fee if necessary. Bob wants to send these funds to Carol, but\ncannot wait until T1 confirms, so he crafts a transaction T2 that spends T1\nusing SIGHASH_NOINPUT, and pays Carol. Carol can now make sure she receives\nthe money even if Alice fee-bumps T1, as long as the outputs of the\nreplaced transactions are compatible.\n\nExtra care should be taken to avoid rebinding, maybe by including an extra\ninput in T2 that doesn't use SIGHASH_NOINPUT.\n\nOn Mon, Apr 30, 2018 at 1:29 PM, Christian Decker via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi all,\n>\n> I'd like to pick up the discussion from a few months ago, and propose a new\n> sighash flag, `SIGHASH_NOINPUT`, that removes the commitment to the\n> previous\n> output. This was previously mentioned on the list by Joseph Poon [1], but\n> was\n> never formally proposed, so I wrote a proposal [2].\n>\n> We have long known that `SIGHASH_NOINPUT` would be a great fit for\n> Lightning.\n> They enable simple watch-towers, i.e., outsource the need to watch the\n> blockchain for channel closures, and react appropriately if our\n> counterparty\n> misbehaves. In addition to this we just released the eltoo [3,4] paper\n> which\n> describes a simplified update mechanism that can be used in Lightning, and\n> other\n> off-chain contracts, with any number of participants.\n>\n> By not committing to the previous output being spent by the transaction,\n> we can\n> rebind an input to point to any outpoint with a matching output script and\n> value. The binding therefore is no longer explicit through a reference, but\n> through script compatibility, and the transaction ID reference in the\n> input is a\n> hint to validators. The sighash flag is meant to enable some off-chain\n> use-cases\n> and should not be used unless the tradeoffs are well-known. In particular\n> we\n> suggest using contract specific key-pairs, in order to avoid having any\n> unwanted\n> rebinding opportunities.\n>\n> The proposal is very minimalistic, and simple. However, there are a few\n> things\n> where we'd like to hear the input of the wider community with regards to\n> the\n> implementation details though. We had some discussions internally on\n> whether to\n> use a separate opcode or a sighash flag, some feeling that the sighash flag\n> could lead to some confusion with existing wallets, but given that we have\n> `SIGHASH_NONE`, and that existing wallets will not sign things with unknown\n> flags, we decided to go the sighash way. Another thing is that we still\n> commit\n> to the amount of the outpoint being spent. The rationale behind this is\n> that,\n> while rebinding to outpoints with the same value maintains the value\n> relationship between input and output, we will probably not want to bind to\n> something with a different value and suddenly pay a gigantic fee.\n>\n> The deployment part of the proposal is left vague on purpose in order not\n> to\n> collide with any other proposals. It should be possible to introduce it by\n> bumping the segwit script version and adding the new behavior.\n>\n> I hope the proposal is well received, and I'm looking forward to discussing\n> variants and tradeoffs here. I think the applications we proposed so far\n> are\n> quite interesting, and I'm sure there are many more we can enable with this\n> change.\n>\n> Cheers,\n> Christian\n>\n> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> 2016-February/012460.html\n> [2] https://github.com/cdecker/bips/blob/noinput/bip-xyz.mediawiki\n> [3] https://blockstream.com/2018/04/30/eltoo-next-lightning.html\n> [4] https://blockstream.com/eltoo.pdf\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180430/4b977159/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP sighash_noinput",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Dario Sneidermanis",
                "Christian Decker"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 6977
        }
    }
]