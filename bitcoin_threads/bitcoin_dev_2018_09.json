[
    {
        "title": "[bitcoin-dev] Selfish Mining Prevention",
        "thread_messages": [
            {
                "author": "Andrew",
                "date": "2018-09-01T00:11:19",
                "message_text_only": "As I understand, selfish mining is an attack where miners collude to\nmine at a lower hashrate then with all miners working independently.\nWhat are the current strategies used to prevent this and what are the\nfuture plans?\n\nOne idea I have is to let the block reward get \"modulated\" according\nto peak hashrate. Say p is the peak hashrate for 365 periods (1 year)\nconsisting of 144 blocks, h is the hashrate of the last 144 block (1\nday) period, and r is the base subsidy (12.5 BTC currently). You can\nthen make the max block reward 0.5 r (1 + h/p). So if hashrate is at\npeak you get the full reward. Otherwise you get less, down to a min of\n0.5 r.\n\nIf miners were to collude to mine at a lower than peak hashrate, then\nthey may be able to do it profitably for 144 blocks, but after that,\nthe reward would get modulated and it wouldn't be so much in their\ninterest to continue mining at the lower hashrate.\n\nWhat flaws are there with this? I know it could be controversial due\nto easier mining present for early miners, so maybe it would have to\nbe done in combination with a new more dynamic difficulty adjustment\nalgorithm. But I don't see how hashrate can continue rising\nindefinitely, so a solution should be made for selfish mining.\n\nAlso when subsidies stop and a fee market is needed, I guess a portion\nof the fees can be withheld for later if hashrate is not at peak.\n\n\n-- \nPGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647"
            },
            {
                "author": "Andrew",
                "date": "2018-09-13T23:19:37",
                "message_text_only": "I discussed this more at bitcointalk:\nhttps://bitcointalk.org/index.php?topic=4998410.0\n\nThe attacks I'm interested in preventing are not only selfish mining\nand collusion, but also more subtle attacks like block withholding,\nand in general anything that aims to drive out the competition in\norder to increase hashrate fraction. I also scrapped the idea of\nchanging the block subsidies, and I am only focuses on fees.\n\nYou can read more about the motivation and details in the bitcointalk\nthread, but my proposal in short would be to add the concept of\n\"reserve fees\". When a user makes a transaction, for each txout\nscript, they can add parameters that specify the fraction of the total\nfee that is held in \"reserve\" and the time it is held in \"reserve\"\n(can set a limit of 2016 blocks). This \"reserve\" part of the fee will\nbe paid to miners if the hashrate rises. So if hashrate is currently h\nand peak hashrate (from past year) is p, then for each period (1 day),\na new hashrate is calculated h1, and if h1 > h, then the fraction\n(h1-h)/p from the reserve fees created in the past 2016 blocks will be\nreleased to miners for that period (spread out over the 144 blocks in\nthat period). And this will keep happening as long as hashrate keeps\nrising, until the \"contract\" expires, and the leftover part can be\nused by the owner of the unspent output, but it can only be used for\npaying fees, not as inputs for future transactions (to save on block\nspace).\n\nThis should incentivize miners to not drive out the competition, since\nif they do, there will be less of these reserve fees given to miners.\nYes in the end the miners will get all the fees, but with rising\nhashrate they get an unconditional subsidy that does not require\ntransactions, thus more space for transactions with fees.\n\nI can make a formal BIP and pull request, but I need to know if there\nis interest in this. Now fees don't play such a large part of the\nblock reward, but they will get more important, and this change\nwouldn't force anything (would be voluntary by each user), just miners\nhave to agree to it with a soft fork (so they don't spend from the\nanyone-can-spend outputs used for reserve fees). Resource requirements\nfor validation are quite small I believe.\n\nOn Sat, Sep 1, 2018 at 12:11 AM, Andrew <onelineproof at gmail.com> wrote:\n> As I understand, selfish mining is an attack where miners collude to\n> mine at a lower hashrate then with all miners working independently.\n> What are the current strategies used to prevent this and what are the\n> future plans?\n>\n> One idea I have is to let the block reward get \"modulated\" according\n> to peak hashrate. Say p is the peak hashrate for 365 periods (1 year)\n> consisting of 144 blocks, h is the hashrate of the last 144 block (1\n> day) period, and r is the base subsidy (12.5 BTC currently). You can\n> then make the max block reward 0.5 r (1 + h/p). So if hashrate is at\n> peak you get the full reward. Otherwise you get less, down to a min of\n> 0.5 r.\n>\n> If miners were to collude to mine at a lower than peak hashrate, then\n> they may be able to do it profitably for 144 blocks, but after that,\n> the reward would get modulated and it wouldn't be so much in their\n> interest to continue mining at the lower hashrate.\n>\n> What flaws are there with this? I know it could be controversial due\n> to easier mining present for early miners, so maybe it would have to\n> be done in combination with a new more dynamic difficulty adjustment\n> algorithm. But I don't see how hashrate can continue rising\n> indefinitely, so a solution should be made for selfish mining.\n>\n> Also when subsidies stop and a fee market is needed, I guess a portion\n> of the fees can be withheld for later if hashrate is not at peak.\n>\n>\n> --\n> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647\n\n\n\n-- \nPGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647"
            },
            {
                "author": "Moral Agent",
                "date": "2018-09-14T14:49:16",
                "message_text_only": "You might be interested in an idea I wrote about that is in a similar\nspirit here:\n\nhttps://medium.com/coinmonks/taming-large-miners-with-helper-blocks-6ae67ac242f6\n\n>From the article:\n\nWhen a block is solved, it randomly selects one satoshi from the utxo set\nand gives whomever controls that satoshi the power to generate a \u201cHelper\nBlock\u201d. The Helper Block commits to a subset of transactions for inclusion\nin the next block. A miner can accept the Helper Block by including the\nsuggested transactions and giving the associated transaction fees to a\npayment address specified in the Helper Block. Miners who do not use a\nHelper Block must satisfy a 25% higher difficulty.\n\nOn Fri, Sep 14, 2018 at 9:56 AM Andrew via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I discussed this more at bitcointalk:\n> https://bitcointalk.org/index.php?topic=4998410.0\n>\n> The attacks I'm interested in preventing are not only selfish mining\n> and collusion, but also more subtle attacks like block withholding,\n> and in general anything that aims to drive out the competition in\n> order to increase hashrate fraction. I also scrapped the idea of\n> changing the block subsidies, and I am only focuses on fees.\n>\n> You can read more about the motivation and details in the bitcointalk\n> thread, but my proposal in short would be to add the concept of\n> \"reserve fees\". When a user makes a transaction, for each txout\n> script, they can add parameters that specify the fraction of the total\n> fee that is held in \"reserve\" and the time it is held in \"reserve\"\n> (can set a limit of 2016 blocks). This \"reserve\" part of the fee will\n> be paid to miners if the hashrate rises. So if hashrate is currently h\n> and peak hashrate (from past year) is p, then for each period (1 day),\n> a new hashrate is calculated h1, and if h1 > h, then the fraction\n> (h1-h)/p from the reserve fees created in the past 2016 blocks will be\n> released to miners for that period (spread out over the 144 blocks in\n> that period). And this will keep happening as long as hashrate keeps\n> rising, until the \"contract\" expires, and the leftover part can be\n> used by the owner of the unspent output, but it can only be used for\n> paying fees, not as inputs for future transactions (to save on block\n> space).\n>\n> This should incentivize miners to not drive out the competition, since\n> if they do, there will be less of these reserve fees given to miners.\n> Yes in the end the miners will get all the fees, but with rising\n> hashrate they get an unconditional subsidy that does not require\n> transactions, thus more space for transactions with fees.\n>\n> I can make a formal BIP and pull request, but I need to know if there\n> is interest in this. Now fees don't play such a large part of the\n> block reward, but they will get more important, and this change\n> wouldn't force anything (would be voluntary by each user), just miners\n> have to agree to it with a soft fork (so they don't spend from the\n> anyone-can-spend outputs used for reserve fees). Resource requirements\n> for validation are quite small I believe.\n>\n> On Sat, Sep 1, 2018 at 12:11 AM, Andrew <onelineproof at gmail.com> wrote:\n> > As I understand, selfish mining is an attack where miners collude to\n> > mine at a lower hashrate then with all miners working independently.\n> > What are the current strategies used to prevent this and what are the\n> > future plans?\n> >\n> > One idea I have is to let the block reward get \"modulated\" according\n> > to peak hashrate. Say p is the peak hashrate for 365 periods (1 year)\n> > consisting of 144 blocks, h is the hashrate of the last 144 block (1\n> > day) period, and r is the base subsidy (12.5 BTC currently). You can\n> > then make the max block reward 0.5 r (1 + h/p). So if hashrate is at\n> > peak you get the full reward. Otherwise you get less, down to a min of\n> > 0.5 r.\n> >\n> > If miners were to collude to mine at a lower than peak hashrate, then\n> > they may be able to do it profitably for 144 blocks, but after that,\n> > the reward would get modulated and it wouldn't be so much in their\n> > interest to continue mining at the lower hashrate.\n> >\n> > What flaws are there with this? I know it could be controversial due\n> > to easier mining present for early miners, so maybe it would have to\n> > be done in combination with a new more dynamic difficulty adjustment\n> > algorithm. But I don't see how hashrate can continue rising\n> > indefinitely, so a solution should be made for selfish mining.\n> >\n> > Also when subsidies stop and a fee market is needed, I guess a portion\n> > of the fees can be withheld for later if hashrate is not at peak.\n> >\n> >\n> > --\n> > PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647\n>\n>\n>\n> --\n> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180914/22e64f75/attachment-0001.html>"
            },
            {
                "author": "Andrew",
                "date": "2018-09-14T17:30:02",
                "message_text_only": "(reposting to whole list instead of just him) @Moral Agent:\nInteresting proposal though it introduces some elements\nof proof of stake so it would be more controversial in my view. Also,\nsomething needs to be explained about how this would not create an\nattack where difficulty is frequently dropping by 25%, and suddenly we\nfind ourselves with a very low difficulty and PoW attacks can easily\nhappen. I need to analyse your proposal more, but I prefer to discuss\nit on your blog instead of here just to limit the side topics and\nfocus only on my proposal.\n\nNo one has yet given me a good reason for why not to support my proposal...\n\nOn Fri, Sep 14, 2018 at 2:49 PM, Moral Agent <ethan.scruples at gmail.com> wrote:\n> You might be interested in an idea I wrote about that is in a similar spirit\n> here:\n>\n> https://medium.com/coinmonks/taming-large-miners-with-helper-blocks-6ae67ac242f6\n>\n> From the article:\n>\n> When a block is solved, it randomly selects one satoshi from the utxo set\n> and gives whomever controls that satoshi the power to generate a \u201cHelper\n> Block\u201d. The Helper Block commits to a subset of transactions for inclusion\n> in the next block. A miner can accept the Helper Block by including the\n> suggested transactions and giving the associated transaction fees to a\n> payment address specified in the Helper Block. Miners who do not use a\n> Helper Block must satisfy a 25% higher difficulty.\n>\n> On Fri, Sep 14, 2018 at 9:56 AM Andrew via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> I discussed this more at bitcointalk:\n>> https://bitcointalk.org/index.php?topic=4998410.0\n>>\n>> The attacks I'm interested in preventing are not only selfish mining\n>> and collusion, but also more subtle attacks like block withholding,\n>> and in general anything that aims to drive out the competition in\n>> order to increase hashrate fraction. I also scrapped the idea of\n>> changing the block subsidies, and I am only focuses on fees.\n>>\n>> You can read more about the motivation and details in the bitcointalk\n>> thread, but my proposal in short would be to add the concept of\n>> \"reserve fees\". When a user makes a transaction, for each txout\n>> script, they can add parameters that specify the fraction of the total\n>> fee that is held in \"reserve\" and the time it is held in \"reserve\"\n>> (can set a limit of 2016 blocks). This \"reserve\" part of the fee will\n>> be paid to miners if the hashrate rises. So if hashrate is currently h\n>> and peak hashrate (from past year) is p, then for each period (1 day),\n>> a new hashrate is calculated h1, and if h1 > h, then the fraction\n>> (h1-h)/p from the reserve fees created in the past 2016 blocks will be\n>> released to miners for that period (spread out over the 144 blocks in\n>> that period). And this will keep happening as long as hashrate keeps\n>> rising, until the \"contract\" expires, and the leftover part can be\n>> used by the owner of the unspent output, but it can only be used for\n>> paying fees, not as inputs for future transactions (to save on block\n>> space).\n>>\n>> This should incentivize miners to not drive out the competition, since\n>> if they do, there will be less of these reserve fees given to miners.\n>> Yes in the end the miners will get all the fees, but with rising\n>> hashrate they get an unconditional subsidy that does not require\n>> transactions, thus more space for transactions with fees.\n>>\n>> I can make a formal BIP and pull request, but I need to know if there\n>> is interest in this. Now fees don't play such a large part of the\n>> block reward, but they will get more important, and this change\n>> wouldn't force anything (would be voluntary by each user), just miners\n>> have to agree to it with a soft fork (so they don't spend from the\n>> anyone-can-spend outputs used for reserve fees). Resource requirements\n>> for validation are quite small I believe.\n>>\n>> On Sat, Sep 1, 2018 at 12:11 AM, Andrew <onelineproof at gmail.com> wrote:\n>> > As I understand, selfish mining is an attack where miners collude to\n>> > mine at a lower hashrate then with all miners working independently.\n>> > What are the current strategies used to prevent this and what are the\n>> > future plans?\n>> >\n>> > One idea I have is to let the block reward get \"modulated\" according\n>> > to peak hashrate. Say p is the peak hashrate for 365 periods (1 year)\n>> > consisting of 144 blocks, h is the hashrate of the last 144 block (1\n>> > day) period, and r is the base subsidy (12.5 BTC currently). You can\n>> > then make the max block reward 0.5 r (1 + h/p). So if hashrate is at\n>> > peak you get the full reward. Otherwise you get less, down to a min of\n>> > 0.5 r.\n>> >\n>> > If miners were to collude to mine at a lower than peak hashrate, then\n>> > they may be able to do it profitably for 144 blocks, but after that,\n>> > the reward would get modulated and it wouldn't be so much in their\n>> > interest to continue mining at the lower hashrate.\n>> >\n>> > What flaws are there with this? I know it could be controversial due\n>> > to easier mining present for early miners, so maybe it would have to\n>> > be done in combination with a new more dynamic difficulty adjustment\n>> > algorithm. But I don't see how hashrate can continue rising\n>> > indefinitely, so a solution should be made for selfish mining.\n>> >\n>> > Also when subsidies stop and a fee market is needed, I guess a portion\n>> > of the fees can be withheld for later if hashrate is not at peak.\n>> >\n>> >\n>> > --\n>> > PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647\n>>\n>>\n>>\n>> --\n>> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n\n\n-- \nPGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647"
            },
            {
                "author": "Damian Williamson",
                "date": "2018-09-15T05:29:20",
                "message_text_only": ">This \"reserve\" part of the fee will be paid to miners if the hashrate rises.\n\n\nAnticipating ongoing hashrate rise shows that you have not yet thought about moving outside of the current greed model, a model wherein mining will consume all available resources within the colony's objective just to spread as far as possible with each new miner bringing diminishing individual returns and shortening the life of Earth for no additional gain. Greed model := bacteria.\n\n________________________________\nFrom: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Andrew via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nSent: Friday, 14 September 2018 9:19:37 AM\nTo: Bitcoin Dev\nSubject: Re: [bitcoin-dev] Selfish Mining Prevention\n\nI discussed this more at bitcointalk:\nhttps://bitcointalk.org/index.php?topic=4998410.0\n\nThe attacks I'm interested in preventing are not only selfish mining\nand collusion, but also more subtle attacks like block withholding,\nand in general anything that aims to drive out the competition in\norder to increase hashrate fraction. I also scrapped the idea of\nchanging the block subsidies, and I am only focuses on fees.\n\nYou can read more about the motivation and details in the bitcointalk\nthread, but my proposal in short would be to add the concept of\n\"reserve fees\". When a user makes a transaction, for each txout\nscript, they can add parameters that specify the fraction of the total\nfee that is held in \"reserve\" and the time it is held in \"reserve\"\n(can set a limit of 2016 blocks). This \"reserve\" part of the fee will\nbe paid to miners if the hashrate rises. So if hashrate is currently h\nand peak hashrate (from past year) is p, then for each period (1 day),\na new hashrate is calculated h1, and if h1 > h, then the fraction\n(h1-h)/p from the reserve fees created in the past 2016 blocks will be\nreleased to miners for that period (spread out over the 144 blocks in\nthat period). And this will keep happening as long as hashrate keeps\nrising, until the \"contract\" expires, and the leftover part can be\nused by the owner of the unspent output, but it can only be used for\npaying fees, not as inputs for future transactions (to save on block\nspace).\n\nThis should incentivize miners to not drive out the competition, since\nif they do, there will be less of these reserve fees given to miners.\nYes in the end the miners will get all the fees, but with rising\nhashrate they get an unconditional subsidy that does not require\ntransactions, thus more space for transactions with fees.\n\nI can make a formal BIP and pull request, but I need to know if there\nis interest in this. Now fees don't play such a large part of the\nblock reward, but they will get more important, and this change\nwouldn't force anything (would be voluntary by each user), just miners\nhave to agree to it with a soft fork (so they don't spend from the\nanyone-can-spend outputs used for reserve fees). Resource requirements\nfor validation are quite small I believe.\n\nOn Sat, Sep 1, 2018 at 12:11 AM, Andrew <onelineproof at gmail.com> wrote:\n> As I understand, selfish mining is an attack where miners collude to\n> mine at a lower hashrate then with all miners working independently.\n> What are the current strategies used to prevent this and what are the\n> future plans?\n>\n> One idea I have is to let the block reward get \"modulated\" according\n> to peak hashrate. Say p is the peak hashrate for 365 periods (1 year)\n> consisting of 144 blocks, h is the hashrate of the last 144 block (1\n> day) period, and r is the base subsidy (12.5 BTC currently). You can\n> then make the max block reward 0.5 r (1 + h/p). So if hashrate is at\n> peak you get the full reward. Otherwise you get less, down to a min of\n> 0.5 r.\n>\n> If miners were to collude to mine at a lower than peak hashrate, then\n> they may be able to do it profitably for 144 blocks, but after that,\n> the reward would get modulated and it wouldn't be so much in their\n> interest to continue mining at the lower hashrate.\n>\n> What flaws are there with this? I know it could be controversial due\n> to easier mining present for early miners, so maybe it would have to\n> be done in combination with a new more dynamic difficulty adjustment\n> algorithm. But I don't see how hashrate can continue rising\n> indefinitely, so a solution should be made for selfish mining.\n>\n> Also when subsidies stop and a fee market is needed, I guess a portion\n> of the fees can be withheld for later if hashrate is not at peak.\n>\n>\n> --\n> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647\n\n\n\n--\nPGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180915/f9bfeed9/attachment.html>"
            },
            {
                "author": "Andrew",
                "date": "2018-09-15T16:01:19",
                "message_text_only": "@Moral Agent: No problem. I did ask in the first post what the current\nplans are for selfish miner prevention. So if anyone has any other\nrelevant ideas (not just for selfish mining but for making mining more\ndecentralized and competetive), then please post it, but I just prefer\nto focus on my proposal more than others.\n\n@Damian: I think you are concerned that this will incentivize more\nglobal resource consumption and will be detrimental to our\nenvironment? Personally, I believe centralization of energy does more\nharm to the environment rather than total energy consumption. If\nBitcoin helps \"power\" to become more decentralized, then I wouldn't be\nsurprised if total (global) energy consumption actually decreases. The\ndebt based economy is forcing us to continuously grow and use up more\nresources, and collectivism is turning individuals into\nsuper-organisms capable of doing much more harm to the environment\nthan can be done by one or a just a few individuals working\nindependently. In my proposal, I actually allow for changing\nenvironmental conditions by measuring only the peak hashrate of the\npast year, and not the full history of blocks.\n\nOn Sat, Sep 15, 2018 at 5:29 AM, Damian Williamson <willtech at live.com.au> wrote:\n>>This \"reserve\" part of the fee will be paid to miners if the hashrate\n>> rises.\n>\n>\n> Anticipating ongoing hashrate rise shows that you have not yet thought about\n> moving outside of the current greed model, a model wherein mining will\n> consume all available resources within the colony's objective just to spread\n> as far as possible with each new miner bringing diminishing individual\n> returns and shortening the life of Earth for no additional gain. Greed model\n> := bacteria.\n>\n> ________________________________\n> From: bitcoin-dev-bounces at lists.linuxfoundation.org\n> <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Andrew via\n> bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> Sent: Friday, 14 September 2018 9:19:37 AM\n> To: Bitcoin Dev\n> Subject: Re: [bitcoin-dev] Selfish Mining Prevention\n>\n> I discussed this more at bitcointalk:\n> https://bitcointalk.org/index.php?topic=4998410.0\n>\n> The attacks I'm interested in preventing are not only selfish mining\n> and collusion, but also more subtle attacks like block withholding,\n> and in general anything that aims to drive out the competition in\n> order to increase hashrate fraction. I also scrapped the idea of\n> changing the block subsidies, and I am only focuses on fees.\n>\n> You can read more about the motivation and details in the bitcointalk\n> thread, but my proposal in short would be to add the concept of\n> \"reserve fees\". When a user makes a transaction, for each txout\n> script, they can add parameters that specify the fraction of the total\n> fee that is held in \"reserve\" and the time it is held in \"reserve\"\n> (can set a limit of 2016 blocks). This \"reserve\" part of the fee will\n> be paid to miners if the hashrate rises. So if hashrate is currently h\n> and peak hashrate (from past year) is p, then for each period (1 day),\n> a new hashrate is calculated h1, and if h1 > h, then the fraction\n> (h1-h)/p from the reserve fees created in the past 2016 blocks will be\n> released to miners for that period (spread out over the 144 blocks in\n> that period). And this will keep happening as long as hashrate keeps\n> rising, until the \"contract\" expires, and the leftover part can be\n> used by the owner of the unspent output, but it can only be used for\n> paying fees, not as inputs for future transactions (to save on block\n> space).\n>\n> This should incentivize miners to not drive out the competition, since\n> if they do, there will be less of these reserve fees given to miners.\n> Yes in the end the miners will get all the fees, but with rising\n> hashrate they get an unconditional subsidy that does not require\n> transactions, thus more space for transactions with fees.\n>\n> I can make a formal BIP and pull request, but I need to know if there\n> is interest in this. Now fees don't play such a large part of the\n> block reward, but they will get more important, and this change\n> wouldn't force anything (would be voluntary by each user), just miners\n> have to agree to it with a soft fork (so they don't spend from the\n> anyone-can-spend outputs used for reserve fees). Resource requirements\n> for validation are quite small I believe.\n>\n> On Sat, Sep 1, 2018 at 12:11 AM, Andrew <onelineproof at gmail.com> wrote:\n>> As I understand, selfish mining is an attack where miners collude to\n>> mine at a lower hashrate then with all miners working independently.\n>> What are the current strategies used to prevent this and what are the\n>> future plans?\n>>\n>> One idea I have is to let the block reward get \"modulated\" according\n>> to peak hashrate. Say p is the peak hashrate for 365 periods (1 year)\n>> consisting of 144 blocks, h is the hashrate of the last 144 block (1\n>> day) period, and r is the base subsidy (12.5 BTC currently). You can\n>> then make the max block reward 0.5 r (1 + h/p). So if hashrate is at\n>> peak you get the full reward. Otherwise you get less, down to a min of\n>> 0.5 r.\n>>\n>> If miners were to collude to mine at a lower than peak hashrate, then\n>> they may be able to do it profitably for 144 blocks, but after that,\n>> the reward would get modulated and it wouldn't be so much in their\n>> interest to continue mining at the lower hashrate.\n>>\n>> What flaws are there with this? I know it could be controversial due\n>> to easier mining present for early miners, so maybe it would have to\n>> be done in combination with a new more dynamic difficulty adjustment\n>> algorithm. But I don't see how hashrate can continue rising\n>> indefinitely, so a solution should be made for selfish mining.\n>>\n>> Also when subsidies stop and a fee market is needed, I guess a portion\n>> of the fees can be withheld for later if hashrate is not at peak.\n>>\n>>\n>> --\n>> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647\n>\n>\n>\n> --\n> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n\n\n-- \nPGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647"
            },
            {
                "author": "Damian Williamson",
                "date": "2018-09-15T22:45:55",
                "message_text_only": "I see what you say, however, since the proposal as I have read it says \"And this will keep happening as long as hashrate keeps rising,\" - what actually happens in the case hashrate stagnates or falls?\n\n\nI would prefer to see (not only with your proposal) greater bias toward hashrate being exponentially more uneconomical the more it rises to stifle greed. The current level of mining already greatly exceeds that necessary for the stability of the network and far lower hashrates are completely acceptible provided the network is protected from large switch-ons, which I say is achievable.\n\n\nI do have other thoughts to approach greed that I have not yet made formal on this list, much unrelated to your proposal, but, I see freedom of use of Bitcoin needing to be censorship resistant but not necessarily mining provided it is protected enough or free or flexible enough to allow for, say, 50k globally distributed standard mining hardware units to exist operating at any one time profitably. That said, I am PoW only and not PoS orientated.\n\n________________________________\nFrom: akaramaoun at gmail.com <akaramaoun at gmail.com> on behalf of Andrew <onelineproof at gmail.com>\nSent: Sunday, 16 September 2018 2:01:19 AM\nTo: Damian Williamson\nCc: Bitcoin Protocol Discussion\nSubject: Re: [bitcoin-dev] Selfish Mining Prevention\n\n@Moral Agent: No problem. I did ask in the first post what the current\nplans are for selfish miner prevention. So if anyone has any other\nrelevant ideas (not just for selfish mining but for making mining more\ndecentralized and competetive), then please post it, but I just prefer\nto focus on my proposal more than others.\n\n@Damian: I think you are concerned that this will incentivize more\nglobal resource consumption and will be detrimental to our\nenvironment? Personally, I believe centralization of energy does more\nharm to the environment rather than total energy consumption. If\nBitcoin helps \"power\" to become more decentralized, then I wouldn't be\nsurprised if total (global) energy consumption actually decreases. The\ndebt based economy is forcing us to continuously grow and use up more\nresources, and collectivism is turning individuals into\nsuper-organisms capable of doing much more harm to the environment\nthan can be done by one or a just a few individuals working\nindependently. In my proposal, I actually allow for changing\nenvironmental conditions by measuring only the peak hashrate of the\npast year, and not the full history of blocks.\n\nOn Sat, Sep 15, 2018 at 5:29 AM, Damian Williamson <willtech at live.com.au> wrote:\n>>This \"reserve\" part of the fee will be paid to miners if the hashrate\n>> rises.\n>\n>\n> Anticipating ongoing hashrate rise shows that you have not yet thought about\n> moving outside of the current greed model, a model wherein mining will\n> consume all available resources within the colony's objective just to spread\n> as far as possible with each new miner bringing diminishing individual\n> returns and shortening the life of Earth for no additional gain. Greed model\n> := bacteria.\n>\n> ________________________________\n> From: bitcoin-dev-bounces at lists.linuxfoundation.org\n> <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Andrew via\n> bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> Sent: Friday, 14 September 2018 9:19:37 AM\n> To: Bitcoin Dev\n> Subject: Re: [bitcoin-dev] Selfish Mining Prevention\n>\n> I discussed this more at bitcointalk:\n> https://bitcointalk.org/index.php?topic=4998410.0\n>\n> The attacks I'm interested in preventing are not only selfish mining\n> and collusion, but also more subtle attacks like block withholding,\n> and in general anything that aims to drive out the competition in\n> order to increase hashrate fraction. I also scrapped the idea of\n> changing the block subsidies, and I am only focuses on fees.\n>\n> You can read more about the motivation and details in the bitcointalk\n> thread, but my proposal in short would be to add the concept of\n> \"reserve fees\". When a user makes a transaction, for each txout\n> script, they can add parameters that specify the fraction of the total\n> fee that is held in \"reserve\" and the time it is held in \"reserve\"\n> (can set a limit of 2016 blocks). This \"reserve\" part of the fee will\n> be paid to miners if the hashrate rises. So if hashrate is currently h\n> and peak hashrate (from past year) is p, then for each period (1 day),\n> a new hashrate is calculated h1, and if h1 > h, then the fraction\n> (h1-h)/p from the reserve fees created in the past 2016 blocks will be\n> released to miners for that period (spread out over the 144 blocks in\n> that period). And this will keep happening as long as hashrate keeps\n> rising, until the \"contract\" expires, and the leftover part can be\n> used by the owner of the unspent output, but it can only be used for\n> paying fees, not as inputs for future transactions (to save on block\n> space).\n>\n> This should incentivize miners to not drive out the competition, since\n> if they do, there will be less of these reserve fees given to miners.\n> Yes in the end the miners will get all the fees, but with rising\n> hashrate they get an unconditional subsidy that does not require\n> transactions, thus more space for transactions with fees.\n>\n> I can make a formal BIP and pull request, but I need to know if there\n> is interest in this. Now fees don't play such a large part of the\n> block reward, but they will get more important, and this change\n> wouldn't force anything (would be voluntary by each user), just miners\n> have to agree to it with a soft fork (so they don't spend from the\n> anyone-can-spend outputs used for reserve fees). Resource requirements\n> for validation are quite small I believe.\n>\n> On Sat, Sep 1, 2018 at 12:11 AM, Andrew <onelineproof at gmail.com> wrote:\n>> As I understand, selfish mining is an attack where miners collude to\n>> mine at a lower hashrate then with all miners working independently.\n>> What are the current strategies used to prevent this and what are the\n>> future plans?\n>>\n>> One idea I have is to let the block reward get \"modulated\" according\n>> to peak hashrate. Say p is the peak hashrate for 365 periods (1 year)\n>> consisting of 144 blocks, h is the hashrate of the last 144 block (1\n>> day) period, and r is the base subsidy (12.5 BTC currently). You can\n>> then make the max block reward 0.5 r (1 + h/p). So if hashrate is at\n>> peak you get the full reward. Otherwise you get less, down to a min of\n>> 0.5 r.\n>>\n>> If miners were to collude to mine at a lower than peak hashrate, then\n>> they may be able to do it profitably for 144 blocks, but after that,\n>> the reward would get modulated and it wouldn't be so much in their\n>> interest to continue mining at the lower hashrate.\n>>\n>> What flaws are there with this? I know it could be controversial due\n>> to easier mining present for early miners, so maybe it would have to\n>> be done in combination with a new more dynamic difficulty adjustment\n>> algorithm. But I don't see how hashrate can continue rising\n>> indefinitely, so a solution should be made for selfish mining.\n>>\n>> Also when subsidies stop and a fee market is needed, I guess a portion\n>> of the fees can be withheld for later if hashrate is not at peak.\n>>\n>>\n>> --\n>> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647\n>\n>\n>\n> --\n> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n\n\n--\nPGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180915/4a1d493e/attachment.html>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2018-09-16T23:20:05",
                "message_text_only": "Hash rate cannot get \u201cmore uneconomical\u201d. Mining will always seek a return equal to the cost of capital, as does all production, and the energy expended will always be fundamentally a function of the fee level and energy price. Fee level is determined by variable demand for a fixed supply of confirmation.\n\nWhen you say greed you are simply referring to economically-rational behavior. It canny be eliminated, nor would that be a benefit.\n\nWRT energy consumption, there is nothing that can be done to reduce it except for people to stop using Bitcoin or for energy to get more expensive.\n\ne\n\n> On Sep 15, 2018, at 15:45, Damian Williamson via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> I see what you say, however, since the proposal as I have read it says \"And this will keep happening as long as hashrate keeps rising,\" - what actually happens in the case hashrate stagnates or falls?\n> \n> I would prefer to see (not only with your proposal) greater bias toward hashrate being exponentially more uneconomical the more it rises to stifle greed. The current level of mining already greatly exceeds that necessary for the stability of the network and far lower hashrates are completely acceptible provided the network is protected from large switch-ons, which I say is achievable.\n> \n> I do have other thoughts to approach greed that I have not yet made formal on this list, much unrelated to your proposal, but, I see freedom of use of Bitcoin needing to be censorship resistant but not necessarily mining provided it is protected enough or free or flexible enough to allow for, say, 50k globally distributed standard mining hardware units to exist operating at any one time profitably. That said, I am PoW only and not PoS orientated.\n>  \n> From: akaramaoun at gmail.com <akaramaoun at gmail.com> on behalf of Andrew <onelineproof at gmail.com>\n> Sent: Sunday, 16 September 2018 2:01:19 AM\n> To: Damian Williamson\n> Cc: Bitcoin Protocol Discussion\n> Subject: Re: [bitcoin-dev] Selfish Mining Prevention\n>  \n> @Moral Agent: No problem. I did ask in the first post what the current\n> plans are for selfish miner prevention. So if anyone has any other\n> relevant ideas (not just for selfish mining but for making mining more\n> decentralized and competetive), then please post it, but I just prefer\n> to focus on my proposal more than others.\n> \n> @Damian: I think you are concerned that this will incentivize more\n> global resource consumption and will be detrimental to our\n> environment? Personally, I believe centralization of energy does more\n> harm to the environment rather than total energy consumption. If\n> Bitcoin helps \"power\" to become more decentralized, then I wouldn't be\n> surprised if total (global) energy consumption actually decreases. The\n> debt based economy is forcing us to continuously grow and use up more\n> resources, and collectivism is turning individuals into\n> super-organisms capable of doing much more harm to the environment\n> than can be done by one or a just a few individuals working\n> independently. In my proposal, I actually allow for changing\n> environmental conditions by measuring only the peak hashrate of the\n> past year, and not the full history of blocks.\n> \n> On Sat, Sep 15, 2018 at 5:29 AM, Damian Williamson <willtech at live.com.au> wrote:\n> >>This \"reserve\" part of the fee will be paid to miners if the hashrate\n> >> rises.\n> >\n> >\n> > Anticipating ongoing hashrate rise shows that you have not yet thought about\n> > moving outside of the current greed model, a model wherein mining will\n> > consume all available resources within the colony's objective just to spread\n> > as far as possible with each new miner bringing diminishing individual\n> > returns and shortening the life of Earth for no additional gain. Greed model\n> > := bacteria.\n> >\n> > ________________________________\n> > From: bitcoin-dev-bounces at lists.linuxfoundation.org\n> > <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Andrew via\n> > bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> > Sent: Friday, 14 September 2018 9:19:37 AM\n> > To: Bitcoin Dev\n> > Subject: Re: [bitcoin-dev] Selfish Mining Prevention\n> >\n> > I discussed this more at bitcointalk:\n> > https://bitcointalk.org/index.php?topic=4998410.0\n> >\n> > The attacks I'm interested in preventing are not only selfish mining\n> > and collusion, but also more subtle attacks like block withholding,\n> > and in general anything that aims to drive out the competition in\n> > order to increase hashrate fraction. I also scrapped the idea of\n> > changing the block subsidies, and I am only focuses on fees.\n> >\n> > You can read more about the motivation and details in the bitcointalk\n> > thread, but my proposal in short would be to add the concept of\n> > \"reserve fees\". When a user makes a transaction, for each txout\n> > script, they can add parameters that specify the fraction of the total\n> > fee that is held in \"reserve\" and the time it is held in \"reserve\"\n> > (can set a limit of 2016 blocks). This \"reserve\" part of the fee will\n> > be paid to miners if the hashrate rises. So if hashrate is currently h\n> > and peak hashrate (from past year) is p, then for each period (1 day),\n> > a new hashrate is calculated h1, and if h1 > h, then the fraction\n> > (h1-h)/p from the reserve fees created in the past 2016 blocks will be\n> > released to miners for that period (spread out over the 144 blocks in\n> > that period). And this will keep happening as long as hashrate keeps\n> > rising, until the \"contract\" expires, and the leftover part can be\n> > used by the owner of the unspent output, but it can only be used for\n> > paying fees, not as inputs for future transactions (to save on block\n> > space).\n> >\n> > This should incentivize miners to not drive out the competition, since\n> > if they do, there will be less of these reserve fees given to miners.\n> > Yes in the end the miners will get all the fees, but with rising\n> > hashrate they get an unconditional subsidy that does not require\n> > transactions, thus more space for transactions with fees.\n> >\n> > I can make a formal BIP and pull request, but I need to know if there\n> > is interest in this. Now fees don't play such a large part of the\n> > block reward, but they will get more important, and this change\n> > wouldn't force anything (would be voluntary by each user), just miners\n> > have to agree to it with a soft fork (so they don't spend from the\n> > anyone-can-spend outputs used for reserve fees). Resource requirements\n> > for validation are quite small I believe.\n> >\n> > On Sat, Sep 1, 2018 at 12:11 AM, Andrew <onelineproof at gmail.com> wrote:\n> >> As I understand, selfish mining is an attack where miners collude to\n> >> mine at a lower hashrate then with all miners working independently.\n> >> What are the current strategies used to prevent this and what are the\n> >> future plans?\n> >>\n> >> One idea I have is to let the block reward get \"modulated\" according\n> >> to peak hashrate. Say p is the peak hashrate for 365 periods (1 year)\n> >> consisting of 144 blocks, h is the hashrate of the last 144 block (1\n> >> day) period, and r is the base subsidy (12.5 BTC currently). You can\n> >> then make the max block reward 0.5 r (1 + h/p). So if hashrate is at\n> >> peak you get the full reward. Otherwise you get less, down to a min of\n> >> 0.5 r.\n> >>\n> >> If miners were to collude to mine at a lower than peak hashrate, then\n> >> they may be able to do it profitably for 144 blocks, but after that,\n> >> the reward would get modulated and it wouldn't be so much in their\n> >> interest to continue mining at the lower hashrate.\n> >>\n> >> What flaws are there with this? I know it could be controversial due\n> >> to easier mining present for early miners, so maybe it would have to\n> >> be done in combination with a new more dynamic difficulty adjustment\n> >> algorithm. But I don't see how hashrate can continue rising\n> >> indefinitely, so a solution should be made for selfish mining.\n> >>\n> >> Also when subsidies stop and a fee market is needed, I guess a portion\n> >> of the fees can be withheld for later if hashrate is not at peak.\n> >>\n> >>\n> >> --\n> >> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647\n> >\n> >\n> >\n> > --\n> > PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> \n> \n> -- \n> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180916/71c3ed59/attachment-0001.html>"
            },
            {
                "author": "Andrew",
                "date": "2018-09-17T13:18:53",
                "message_text_only": "> I see what you say, however, since the proposal as I have read it says \"And this will keep happening as long as hashrate keeps rising,\" - what actually happens in the case hashrate stagnates or falls?\n\nIn general, a target hashrate can be set by users (can be less or more\nthan the peak hashrate). As long as hashrate is rising and still\ndidn't reach the target, miners will incrementally get the reserve\nfees. Once the \"contract\" times out, the remaining part can be used as\nfees by the users who created the reserve fee \"contract\". So if\nhashrate remains the same or falls, then users get the reserve fees\nback.\n\nI agree that we can't stop people from being greedy. If they are not\nBitcoin mining, they will try to put their energy to earn in some\nother way...The hashrate is related the demand for Bitcoin (price) and\nthe amount of fees/subsidies the miners will get paid. For every level\nof mining rewards (based on demand) there exists a limit on the\nhashrate. Once hashrate gets large enough, no new miners (additional\nhashrate) will want to join since their share of the hashrate is too\nsmall to make a profit.\n\nAlso with merge mining and proof of space we can be quite efficient in\nthe future. But of course I sympathize with the \"don't be greedy\"\nphilosophy, and it can be good to educate people to use less resources\nthan they need, just I think it's a bit outside of the scope of what\nthe Bitcoin software protocol does."
            },
            {
                "author": "Moral Agent",
                "date": "2018-09-14T18:00:29",
                "message_text_only": "Thank you, and my apologies. I should have sent that link just to you and\nnot put everyone on cc.\n\nOn Fri, Sep 14, 2018 at 1:30 PM Andrew <onelineproof at gmail.com> wrote:\n\n> (reposting to whole list instead of just him) @Moral Agent:\n> Interesting proposal though it introduces some elements\n> of proof of stake so it would be more controversial in my view. Also,\n> something needs to be explained about how this would not create an\n> attack where difficulty is frequently dropping by 25%, and suddenly we\n> find ourselves with a very low difficulty and PoW attacks can easily\n> happen. I need to analyse your proposal more, but I prefer to discuss\n> it on your blog instead of here just to limit the side topics and\n> focus only on my proposal.\n>\n> No one has yet given me a good reason for why not to support my proposal...\n>\n> On Fri, Sep 14, 2018 at 2:49 PM, Moral Agent <ethan.scruples at gmail.com>\n> wrote:\n> > You might be interested in an idea I wrote about that is in a similar\n> spirit\n> > here:\n> >\n> >\n> https://medium.com/coinmonks/taming-large-miners-with-helper-blocks-6ae67ac242f6\n> >\n> > From the article:\n> >\n> > When a block is solved, it randomly selects one satoshi from the utxo set\n> > and gives whomever controls that satoshi the power to generate a \u201cHelper\n> > Block\u201d. The Helper Block commits to a subset of transactions for\n> inclusion\n> > in the next block. A miner can accept the Helper Block by including the\n> > suggested transactions and giving the associated transaction fees to a\n> > payment address specified in the Helper Block. Miners who do not use a\n> > Helper Block must satisfy a 25% higher difficulty.\n> >\n> > On Fri, Sep 14, 2018 at 9:56 AM Andrew via bitcoin-dev\n> > <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >>\n> >> I discussed this more at bitcointalk:\n> >> https://bitcointalk.org/index.php?topic=4998410.0\n> >>\n> >> The attacks I'm interested in preventing are not only selfish mining\n> >> and collusion, but also more subtle attacks like block withholding,\n> >> and in general anything that aims to drive out the competition in\n> >> order to increase hashrate fraction. I also scrapped the idea of\n> >> changing the block subsidies, and I am only focuses on fees.\n> >>\n> >> You can read more about the motivation and details in the bitcointalk\n> >> thread, but my proposal in short would be to add the concept of\n> >> \"reserve fees\". When a user makes a transaction, for each txout\n> >> script, they can add parameters that specify the fraction of the total\n> >> fee that is held in \"reserve\" and the time it is held in \"reserve\"\n> >> (can set a limit of 2016 blocks). This \"reserve\" part of the fee will\n> >> be paid to miners if the hashrate rises. So if hashrate is currently h\n> >> and peak hashrate (from past year) is p, then for each period (1 day),\n> >> a new hashrate is calculated h1, and if h1 > h, then the fraction\n> >> (h1-h)/p from the reserve fees created in the past 2016 blocks will be\n> >> released to miners for that period (spread out over the 144 blocks in\n> >> that period). And this will keep happening as long as hashrate keeps\n> >> rising, until the \"contract\" expires, and the leftover part can be\n> >> used by the owner of the unspent output, but it can only be used for\n> >> paying fees, not as inputs for future transactions (to save on block\n> >> space).\n> >>\n> >> This should incentivize miners to not drive out the competition, since\n> >> if they do, there will be less of these reserve fees given to miners.\n> >> Yes in the end the miners will get all the fees, but with rising\n> >> hashrate they get an unconditional subsidy that does not require\n> >> transactions, thus more space for transactions with fees.\n> >>\n> >> I can make a formal BIP and pull request, but I need to know if there\n> >> is interest in this. Now fees don't play such a large part of the\n> >> block reward, but they will get more important, and this change\n> >> wouldn't force anything (would be voluntary by each user), just miners\n> >> have to agree to it with a soft fork (so they don't spend from the\n> >> anyone-can-spend outputs used for reserve fees). Resource requirements\n> >> for validation are quite small I believe.\n> >>\n> >> On Sat, Sep 1, 2018 at 12:11 AM, Andrew <onelineproof at gmail.com> wrote:\n> >> > As I understand, selfish mining is an attack where miners collude to\n> >> > mine at a lower hashrate then with all miners working independently.\n> >> > What are the current strategies used to prevent this and what are the\n> >> > future plans?\n> >> >\n> >> > One idea I have is to let the block reward get \"modulated\" according\n> >> > to peak hashrate. Say p is the peak hashrate for 365 periods (1 year)\n> >> > consisting of 144 blocks, h is the hashrate of the last 144 block (1\n> >> > day) period, and r is the base subsidy (12.5 BTC currently). You can\n> >> > then make the max block reward 0.5 r (1 + h/p). So if hashrate is at\n> >> > peak you get the full reward. Otherwise you get less, down to a min of\n> >> > 0.5 r.\n> >> >\n> >> > If miners were to collude to mine at a lower than peak hashrate, then\n> >> > they may be able to do it profitably for 144 blocks, but after that,\n> >> > the reward would get modulated and it wouldn't be so much in their\n> >> > interest to continue mining at the lower hashrate.\n> >> >\n> >> > What flaws are there with this? I know it could be controversial due\n> >> > to easier mining present for early miners, so maybe it would have to\n> >> > be done in combination with a new more dynamic difficulty adjustment\n> >> > algorithm. But I don't see how hashrate can continue rising\n> >> > indefinitely, so a solution should be made for selfish mining.\n> >> >\n> >> > Also when subsidies stop and a fee market is needed, I guess a portion\n> >> > of the fees can be withheld for later if hashrate is not at peak.\n> >> >\n> >> >\n> >> > --\n> >> > PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647\n> >>\n> >>\n> >>\n> >> --\n> >> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647\n> >> _______________________________________________\n> >> bitcoin-dev mailing list\n> >> bitcoin-dev at lists.linuxfoundation.org\n> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n>\n> --\n> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180914/c57899e8/attachment.html>"
            },
            {
                "author": "Zawy",
                "date": "2018-09-17T14:09:23",
                "message_text_only": "The 51% problem is deep. Any discussion of a solution to it should\nbegin with a link to an article that shows a profound discovery has\nbeen made. Selfish mining prevention and pollution should be on\nbitcoin-discussion, but it appears that list is not active.\n\nThe problem with Andrew's idea below is that it is a positive feedback\nloop that amplifies oscillations. If h goes up or down due to price\nchanges or random solvetime variation, then the net reward goes in the\nsame direction, which motivates miners to cause h to go even further\nin the same direction, which is a positive feedback loop until some\nlimit is reached. To make matters worse, miner profit motivation in\nchoosing which coin to mine is a non-linear function: a 30% drop in\ndifficulty (or 30% increase in this reward function) in an alt coin\ncan cause a 300% increase in hashrate.\n\nAverage of 144 past blocks to determine h are needed so that it does\nnot vary too much.  A selfish mine of 72 blocks would result in only a\n12.5% loss compared to not using this pro-oscillation function. I've\ntried similar reward functions in trying to reduce on-off mining.\n\nThere may also be a problem of issuing too many or too few coins,\ndepending on how fast h rises in the long term.\n\nAn alternative is to increase difficulty with this or a similar\nfunction instead of reward. From a miner's perspective, there is not a\ndifference (they are only interested in the (price+fees)/difficulty\nratio. This would have the same problems.\n\nThe problem has been solved to the best of our ability by the Nakamoto\nconsensus. The math is straightforward, so you can't get around it's\nfailings unless it's a profound solution or we shift trust to some\nplace else. Currently we have to choose and trust a small group of\ncoins (or 1) to be the best choice(s), and to trust that the reward\nplus fees we pay for mining (compared to coin value) is enough to\nprevent a 51% attack.\n\n> Say p is the peak hashrate for 365 periods (1 year)\n> consisting of 144 blocks, h is the hashrate of the last 144 block (1\n> day) period, and r is the base subsidy (12.5 BTC currently). You can\n> then make the max block reward 0.5 r (1 + h/p). So if hashrate is at\n> peak you get the full reward. Otherwise you get less, down to a min of"
            },
            {
                "author": "Andrew",
                "date": "2018-09-18T20:26:16",
                "message_text_only": "@ Eric: Yes I forgot to mention that cost (in addition to price) also\ndetermines the profitability of mining and thus the total hashpower. I\ndisagree with your assessment of merge mining as really what matters\nis opportunity cost of honestly mining vs attacking, and one reason we\nare currently safe from other networks attacking is that SHA256 is\nASIC friendly and currently the main network utilising this (the\nASICs) is Bitcoin mining. It would be hard for people computing prime\nnumbers to quickly switch to Bitcoin mining, since they would need the\nASICs. But if you really want to discuss this then I suggest opening a\nnew thread here or bitcointalk since this is off-topic from my thread.\nAlso there is a discussion about merge mining here:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-January/003981.html\n\nOn Mon, Sep 17, 2018 at 2:09 PM, Zawy via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> The 51% problem is deep. Any discussion of a solution to it should\n> begin with a link to an article that shows a profound discovery has\n> been made. Selfish mining prevention and pollution should be on\n> bitcoin-discussion, but it appears that list is not active.\n>\n> The problem with Andrew's idea below is that it is a positive feedback\n> loop that amplifies oscillations. If h goes up or down due to price\n> changes or random solvetime variation, then the net reward goes in the\n> same direction, which motivates miners to cause h to go even further\n> in the same direction, which is a positive feedback loop until some\n> limit is reached. To make matters worse, miner profit motivation in\n> choosing which coin to mine is a non-linear function: a 30% drop in\n> difficulty (or 30% increase in this reward function) in an alt coin\n> can cause a 300% increase in hashrate.\n>\n> Average of 144 past blocks to determine h are needed so that it does\n> not vary too much.  A selfish mine of 72 blocks would result in only a\n> 12.5% loss compared to not using this pro-oscillation function. I've\n> tried similar reward functions in trying to reduce on-off mining.\n>\n> There may also be a problem of issuing too many or too few coins,\n> depending on how fast h rises in the long term.\n>\n> An alternative is to increase difficulty with this or a similar\n> function instead of reward. From a miner's perspective, there is not a\n> difference (they are only interested in the (price+fees)/difficulty\n> ratio. This would have the same problems.\n\n@Zawy: Are you talking about my proposal to modulate the subsidies?\nBecause if you read my second post you see that I scrapped that part\nas it can be disruptive, and I am only proposing to let users have\nmore control over how their fees are spent. A certain portion of fees\nis put in reserve and gets allocated to miners based on hashrate\nconditions, and once the \"contract\" expires, the remaining part goes\nback to the user for future fee payments. I understand it is unclear\nwhether this will cause a significant benefit (I can work on\nsimulations if I have time), but what could possibly go wrong with\ngiving users more choice over how their fees are spent?\n\nAlso if you see my post, I am not just trying to prevent Selfish\nMining (33%) or 51% attacks, but in general any types of attacks that\ntry to drive away mining competition (like block withholding attacks,\nnetworking attacks, etc).\n\nSomeone on bitcointalk was also worried about a positive feedback\nloop, and I think my answer remains valid:\n\"First, I think a price drop will be slightly offset by the lower rate\nof coins being mined. Also, confirmation times will get longer: Both\nthe time to get a block will increase and the number of confirmations\nneeded to have enough work done on the chain so that your transaction\nis considered safe. The fees would likely rise and this would increase\nrewards to miners, especially in a fee-market dominated future.\" Merge\nmining can also help to smooth hashrate so it doesn't depend so much\non price, but even without merge mining it is not so clear that a\nthere would be a destructive feedback loop and that's where\nsimulations / math equations would help.\n\nYour idea of increasing difficulty, I haven't thought about much, but\nI don't think it's the same effect. When you increase the difficulty,\nthe reward per block remains the same, only reward per real time\nfalls, but it could also have the negative effect of incentivizing\nselfish mining or timestamp attacks to reverse the increased\ndifficulty. Though actually timestamp attacks would sort of be\ndis-incentivized if underestimates of hashrate led to lower rewards.\n\nObviously I will not work on a pull request if there is no strong\ninterest for this. I think it is a harmless addition, so if I have\ntime I can work on simulations to try to prove that there is a\nsignificant benefit with doing this.\n\n\n-- \nPGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647"
            },
            {
                "author": "Eric Voskuil",
                "date": "2018-09-17T15:40:30",
                "message_text_only": "> Also with merge mining and proof of space we can be quite efficient in the future.\n\nProof of memory (space) is just proof of work with extra steps. It does not reduce energy consumption.\n\nhttps://github.com/libbitcoin/libbitcoin/wiki/Proof-of-Memory-Facade\n\nMerge mining is non-dedicated cost, so also does not improve energy efficiency. The irreducible *cost* is what matters.\n\nhttps://github.com/libbitcoin/libbitcoin/wiki/Dedicated-Cost-Principle\n\ne\n\nOn Sep 17, 2018, at 06:18, Andrew <onelineproof at gmail.com> wrote:\n\n>> I see what you say, however, since the proposal as I have read it says \"And this will keep happening as long as hashrate keeps rising,\" - what actually happens in the case hashrate stagnates or falls?\n> \n> In general, a target hashrate can be set by users (can be less or more\n> than the peak hashrate). As long as hashrate is rising and still\n> didn't reach the target, miners will incrementally get the reserve\n> fees. Once the \"contract\" times out, the remaining part can be used as\n> fees by the users who created the reserve fee \"contract\". So if\n> hashrate remains the same or falls, then users get the reserve fees\n> back.\n> \n> I agree that we can't stop people from being greedy. If they are not\n> Bitcoin mining, they will try to put their energy to earn in some\n> other way...The hashrate is related the demand for Bitcoin (price) and\n> the amount of fees/subsidies the miners will get paid. For every level\n> of mining rewards (based on demand) there exists a limit on the\n> hashrate. Once hashrate gets large enough, no new miners (additional\n> hashrate) will want to join since their share of the hashrate is too\n> small to make a profit.\n> \n> Also with merge mining and proof of space we can be quite efficient in\n> the future. But of course I sympathize with the \"don't be greedy\"\n> philosophy, and it can be good to educate people to use less resources\n> than they need, just I think it's a bit outside of the scope of what\n> the Bitcoin software protocol does.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180917/8bcba278/attachment.html>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2018-09-17T19:36:15",
                "message_text_only": "> Once hashrate gets large enough, no new miners (additional\nhashrate) will want to join since their share of the hashrate is too\nsmall to make a profit.\n\nThe share (hash power) of a miner is proportional to capital investment, not the newness of that investment. The efficiency of a new mine (inclusive of pooling pressures) can certainly be sufficient to outperform other miners, resulting in the departure of the latter, thus not preventing the entry of the former.\n\nThe point you should be making here is that energy consumption is regulated by the cost of capital (in addition to reward value and the cost of energy).\n\nNote that higher efficiency mining does not reduce energy consumption, nor does variation in the necessary cost of mining hardware. The total energy cost is the control, not the hash rate. This is of course why proof-of-memory (space) is pointless. It simply shifts most of the energy cost to hardware manufacture, shipment, etc.\n\ne\n\nOn Sep 17, 2018, at 06:18, Andrew <onelineproof at gmail.com> wrote:\n\n>> I see what you say, however, since the proposal as I have read it says \"And this will keep happening as long as hashrate keeps rising,\" - what actually happens in the case hashrate stagnates or falls?\n> \n> In general, a target hashrate can be set by users (can be less or more\n> than the peak hashrate). As long as hashrate is rising and still\n> didn't reach the target, miners will incrementally get the reserve\n> fees. Once the \"contract\" times out, the remaining part can be used as\n> fees by the users who created the reserve fee \"contract\". So if\n> hashrate remains the same or falls, then users get the reserve fees\n> back.\n> \n> I agree that we can't stop people from being greedy. If they are not\n> Bitcoin mining, they will try to put their energy to earn in some\n> other way...The hashrate is related the demand for Bitcoin (price) and\n> the amount of fees/subsidies the miners will get paid. For every level\n> of mining rewards (based on demand) there exists a limit on the\n> hashrate. Once hashrate gets large enough, no new miners (additional\n> hashrate) will want to join since their share of the hashrate is too\n> small to make a profit.\n> \n> Also with merge mining and proof of space we can be quite efficient in\n> the future. But of course I sympathize with the \"don't be greedy\"\n> philosophy, and it can be good to educate people to use less resources\n> than they need, just I think it's a bit outside of the scope of what\n> the Bitcoin software protocol does."
            }
        ],
        "thread_summary": {
            "title": "Selfish Mining Prevention",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Zawy",
                "Eric Voskuil",
                "Andrew",
                "Damian Williamson",
                "Moral Agent"
            ],
            "messages_count": 14,
            "total_messages_chars_count": 64152
        }
    },
    {
        "title": "[bitcoin-dev] Testnet3 Reest",
        "thread_messages": [
            {
                "author": "rhavar at protonmail.com",
                "date": "2018-09-01T14:47:53",
                "message_text_only": "I think I mentioned it before, but seems semi-relevant to this thread so I'd like to throw my vote behind pretty tiny blocks on testnet (like max 50-100k weight) to try help simulate a fee-market like situation.\n\n(Although lately there's been a lot of testnet spam and full blocks, which has really made testing easier. But I don't know how long this situation will last)\n\n\n-Ryan\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn August 30, 2018 7:06 PM, Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Thu, Aug 30, 2018 at 11:21 PM Johnson Lau via bitcoin-dev\n> bitcoin-dev at lists.linuxfoundation.org wrote:\n>\n> > A public testnet is still useful so in articles people could make references to these transactions.\n> > Maybe we could have 2 testnets at the same time, with one having a smaller block size?\n>\n> I would much rather have a signed blocks testnet, with a predictable\n> structured reorg pattern* (and a config flag so you can make your node\n> ignore all blocks that are going to get reorged out in a reorg of nth\n> or larger). There are many applications where the mined testnet just\n> doesn't give you anything useful... it's too stable when you want it\n> to be a bit unstable and too wildly unstable when you want a bit of\n> stability-- e.g. there are very few test cases where a 20,000 block\n> reorg does anything useful for you; yet they happen on testnet.\n>\n> We looked at doing this previously in Bitcoin core and jtimon had some\n> patches, but the existing approach increased the size of the\n> blockindex objects in memory while not in signed testnet mode. This\n> could probably have been fixed by turning one of the fields like the\n> merkel root into a union of it's normal value and a pointer a\n> look-aside block index that is used only in signed block testnet mode.\n>\n> Obviously such a mode wouldn't be a replacement for an ordinary\n> testnet, but it would be a useful middle ground between regtest (that\n> never sees anything remotely surprising and can't easily be used for\n> collaborative testing) and full on testnet where your attempts to test\n> against ordinary noise require you cope your entirely universe being\n> removed from existence and replaced by something almost but not quite\n> entirely different at the whim of some cthulhuian blind idiot god.\n>\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Karl-Johan Alm",
                "date": "2018-09-05T03:00:39",
                "message_text_only": "On Fri, Aug 31, 2018 at 9:43 PM Gregory Maxwell via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> We looked at doing this previously in Bitcoin core and jtimon had some\n> patches,  but the existing approach increased the size of the\n> blockindex objects in memory  while not in signed testnet mode.   This\n> could probably have been fixed by turning one of the fields like the\n> merkel root into a union of it's normal value and a pointer a\n> look-aside block index that is used only in signed block testnet mode.\n\nI am currently working on an implementation that simply puts a global\nmapping of block hash to signature that is transparently\n(de)serialized in the block header.\n\nWe were looking into various ways to stuff the signature into the\nactual header itself without changing its size, but this looked like\nit required truncating the prevblock/merkleroots and such, which\nseemed a bit too invasive.\n\nI don't think my approach with a global mapping to sig differs in any\nmeaningful way from your suggested union, but corrections welcome.\n\nThe code is here: https://github.com/kallewoof/bitcoin/tree/signet\n\nI believe jtimon is interested in helping out, and Jeremy Rubin has\nalso said he wants to help."
            }
        ],
        "thread_summary": {
            "title": "Testnet3 Reest",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "rhavar at protonmail.com",
                "Karl-Johan Alm"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3675
        }
    },
    {
        "title": "[bitcoin-dev] Guiding transaction fees towards a more censorship resistant outcome",
        "thread_messages": [
            {
                "author": "Ruben Somsen",
                "date": "2018-09-01T17:26:54",
                "message_text_only": "When a user creates a transaction with a fee attached, they are\nincentivizing miners to add this transaction to the blockchain. The\ntask is usually not very specific -- as long as it ends up in a valid\nchain with the most Proof-of-Work, miners get paid. The payment is an\nincentive for miners to act in the way that users desire.\n\nTo the user, there\u2019s an individual benefit: their transaction gets\nadded. To the network, there\u2019s a shared benefit: all fees add to the\nsecurity of other transactions in the chain. Miners can choose to\nignore the incentives, but they would be leaving money on the table\n(and eventually get replaced by more competitive miners).\n\nTransactions from Bitcoin Core are slightly more specific about what\nthey ask miners to do. Every transaction is only valid at a block\nheight that is one higher than the last block. This incentivizes\nminers to build on top of the last block, instead of going back and\nreorganizing the blockchain. This is especially important in a future\nscenario where the fee reward is larger than the block reward.\n\nBIP 115* by Luke-jr is even more specific. It enables users to create\ntransactions which are only valid if they are mined on top of a\nspecific block. While originally designed as a form of replay\nprotection, it actually serves as a deterrent for miners to reorganize\nthe blockchain. If they orphan a block, it will invalidate\ntransactions that demanded the inclusion of the orphaned block. This\nincreases the cost of intentionally reorganizing the blockchain.\n\nCoinjoin**, the act of combining payments of multiple users into a\nsingle transaction, can be seen as yet another method for users to be\nmore specific. The fate of their payments are now intertwined with\nthat of others. If miners wish to censor a single payment, they have\nto reject the entire transaction, and the associated fee amount.\nTechniques like mimblewimble simplify this process, by making coinjoin\nnon-interactive.\n\nThis brings us to a theoretical scenario where:\n\n- every block contains only a single coinjoin transaction\n- the validity of this transaction depends on the inclusion of a\nspecific previous block\n- the block reward is negligible compared to transaction fees\n\nIn this scenario, if miners wish to undo a specific transaction that\nhappened two blocks ago, they would have to create three empty blocks\n(receiving negligible compensation) in order to overtake the longest\nchain. And even then, users can still refuse to let their new\ntransactions be mined on top of the empty blocks, disincentivizing\nsuch behavior completely.\n\nWhile not easy to achieve in practice (e.g. resolving natural forks\nbecomes more complicated), it demonstrates that users can become more\nempowered than they are today, benefitting censorship resistance***.\nIt is this line of thinking that I wish to convey. Perhaps it may\ninspire further ideas in this direction.\n\n-- Ruben Somsen\n\n\n* BIP 115: https://github.com/bitcoin/bips/blob/master/bip-0115.mediawiki\n\n** Coinjoin: https://bitcointalk.org/index.php?topic=279249.0\n\n*** Risk sharing principle:\nhttps://github.com/libbitcoin/libbitcoin/wiki/Risk-Sharing-Principle"
            },
            {
                "author": "Damian Williamson",
                "date": "2018-09-06T08:48:34",
                "message_text_only": "Humour me please,\n\n\nWhere you say \"create transactions which are only valid if they are mined on top of a specific block.\" - in practice, does that usually means at any height above a specific block?\n\n________________________________\nFrom: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Ruben Somsen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nSent: Sunday, 2 September 2018 3:26:54 AM\nTo: bitcoin-dev at lists.linuxfoundation.org\nSubject: [bitcoin-dev] Guiding transaction fees towards a more censorship resistant outcome\n\nWhen a user creates a transaction with a fee attached, they are\nincentivizing miners to add this transaction to the blockchain. The\ntask is usually not very specific -- as long as it ends up in a valid\nchain with the most Proof-of-Work, miners get paid. The payment is an\nincentive for miners to act in the way that users desire.\n\nTo the user, there\u2019s an individual benefit: their transaction gets\nadded. To the network, there\u2019s a shared benefit: all fees add to the\nsecurity of other transactions in the chain. Miners can choose to\nignore the incentives, but they would be leaving money on the table\n(and eventually get replaced by more competitive miners).\n\nTransactions from Bitcoin Core are slightly more specific about what\nthey ask miners to do. Every transaction is only valid at a block\nheight that is one higher than the last block. This incentivizes\nminers to build on top of the last block, instead of going back and\nreorganizing the blockchain. This is especially important in a future\nscenario where the fee reward is larger than the block reward.\n\nBIP 115* by Luke-jr is even more specific. It enables users to create\ntransactions which are only valid if they are mined on top of a\nspecific block. While originally designed as a form of replay\nprotection, it actually serves as a deterrent for miners to reorganize\nthe blockchain. If they orphan a block, it will invalidate\ntransactions that demanded the inclusion of the orphaned block. This\nincreases the cost of intentionally reorganizing the blockchain.\n\nCoinjoin**, the act of combining payments of multiple users into a\nsingle transaction, can be seen as yet another method for users to be\nmore specific. The fate of their payments are now intertwined with\nthat of others. If miners wish to censor a single payment, they have\nto reject the entire transaction, and the associated fee amount.\nTechniques like mimblewimble simplify this process, by making coinjoin\nnon-interactive.\n\nThis brings us to a theoretical scenario where:\n\n- every block contains only a single coinjoin transaction\n- the validity of this transaction depends on the inclusion of a\nspecific previous block\n- the block reward is negligible compared to transaction fees\n\nIn this scenario, if miners wish to undo a specific transaction that\nhappened two blocks ago, they would have to create three empty blocks\n(receiving negligible compensation) in order to overtake the longest\nchain. And even then, users can still refuse to let their new\ntransactions be mined on top of the empty blocks, disincentivizing\nsuch behavior completely.\n\nWhile not easy to achieve in practice (e.g. resolving natural forks\nbecomes more complicated), it demonstrates that users can become more\nempowered than they are today, benefitting censorship resistance***.\nIt is this line of thinking that I wish to convey. Perhaps it may\ninspire further ideas in this direction.\n\n-- Ruben Somsen\n\n\n* BIP 115: https://apc01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fbitcoin%2Fbips%2Fblob%2Fmaster%2Fbip-0115.mediawiki&amp;data=02%7C01%7C%7C48403f77efc14613e89b08d611f5980c%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636716143839246019&amp;sdata=req4KYOcztXLAG%2Fu4RrmhLREGBF28JNTe45pO86kRd4%3D&amp;reserved=0\n\n** Coinjoin: https://apc01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fbitcointalk.org%2Findex.php%3Ftopic%3D279249.0&amp;data=02%7C01%7C%7C48403f77efc14613e89b08d611f5980c%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636716143839246019&amp;sdata=d%2B06jxrKubWhLwoInFEgo8eHvI9f1j74QN8WH7xrVos%3D&amp;reserved=0\n\n*** Risk sharing principle:\nhttps://apc01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Flibbitcoin%2Flibbitcoin%2Fwiki%2FRisk-Sharing-Principle&amp;data=02%7C01%7C%7C48403f77efc14613e89b08d611f5980c%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636716143839246019&amp;sdata=NA3HxqI5PnuyaI9hyCaw0rcaFsrhD%2FXQB8biWJXej8g%3D&amp;reserved=0\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://apc01.safelinks.protection.outlook.com/?url=https%3A%2F%2Flists.linuxfoundation.org%2Fmailman%2Flistinfo%2Fbitcoin-dev&amp;data=02%7C01%7C%7C48403f77efc14613e89b08d611f5980c%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636716143839246019&amp;sdata=9P7UetPmKWngjgjNPE0%2BAMgdzuL2DgqBLoLti82f23M%3D&amp;reserved=0\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180906/43a9fa13/attachment.html>"
            },
            {
                "author": "Ruben Somsen",
                "date": "2018-09-06T17:35:24",
                "message_text_only": "Hi Damian,\n\n>Where you say \"create transactions which are only valid if they are mined on top of a specific block.\" - in practice, does that usually means at any height above a specific block?\n\nThose details aren't important for the point I was trying to make.\nBIP115 allows the transaction to be mined at any height, which is\nprobably as far as you can take this, realistically. What I think\nyou'll find in practice, is that the more specific you are in how you\nwant your transaction to be mined, the higher the chance that your\ntransaction will inadvertently become unmineable.\n\nA perhaps more general point that I realized after posting, is that\nfee pressure towards censorship resistance happens naturally if the\nsystem provides anonymity. If the target transaction that miners wish\nto censor is indistinguishable from other anonymous transactions, then\nminers will have no choice but to censor every anonymous transaction,\nso the end result is very similar to what I imagined linking\ntransactions would do.\n\n-- Ruben Somsen\nOn Thu, Sep 6, 2018 at 5:48 PM Damian Williamson <willtech at live.com.au> wrote:\n>\n> Humour me please,\n>\n>\n> Where you say \"create transactions which are only valid if they are mined on top of a specific block.\" - in practice, does that usually means at any height above a specific block?\n>\n> ________________________________\n> From: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Ruben Somsen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> Sent: Sunday, 2 September 2018 3:26:54 AM\n> To: bitcoin-dev at lists.linuxfoundation.org\n> Subject: [bitcoin-dev] Guiding transaction fees towards a more censorship resistant outcome\n>\n> When a user creates a transaction with a fee attached, they are\n> incentivizing miners to add this transaction to the blockchain. The\n> task is usually not very specific -- as long as it ends up in a valid\n> chain with the most Proof-of-Work, miners get paid. The payment is an\n> incentive for miners to act in the way that users desire.\n>\n> To the user, there\u2019s an individual benefit: their transaction gets\n> added. To the network, there\u2019s a shared benefit: all fees add to the\n> security of other transactions in the chain. Miners can choose to\n> ignore the incentives, but they would be leaving money on the table\n> (and eventually get replaced by more competitive miners).\n>\n> Transactions from Bitcoin Core are slightly more specific about what\n> they ask miners to do. Every transaction is only valid at a block\n> height that is one higher than the last block. This incentivizes\n> miners to build on top of the last block, instead of going back and\n> reorganizing the blockchain. This is especially important in a future\n> scenario where the fee reward is larger than the block reward.\n>\n> BIP 115* by Luke-jr is even more specific. It enables users to create\n> transactions which are only valid if they are mined on top of a\n> specific block. While originally designed as a form of replay\n> protection, it actually serves as a deterrent for miners to reorganize\n> the blockchain. If they orphan a block, it will invalidate\n> transactions that demanded the inclusion of the orphaned block. This\n> increases the cost of intentionally reorganizing the blockchain.\n>\n> Coinjoin**, the act of combining payments of multiple users into a\n> single transaction, can be seen as yet another method for users to be\n> more specific. The fate of their payments are now intertwined with\n> that of others. If miners wish to censor a single payment, they have\n> to reject the entire transaction, and the associated fee amount.\n> Techniques like mimblewimble simplify this process, by making coinjoin\n> non-interactive.\n>\n> This brings us to a theoretical scenario where:\n>\n> - every block contains only a single coinjoin transaction\n> - the validity of this transaction depends on the inclusion of a\n> specific previous block\n> - the block reward is negligible compared to transaction fees\n>\n> In this scenario, if miners wish to undo a specific transaction that\n> happened two blocks ago, they would have to create three empty blocks\n> (receiving negligible compensation) in order to overtake the longest\n> chain. And even then, users can still refuse to let their new\n> transactions be mined on top of the empty blocks, disincentivizing\n> such behavior completely.\n>\n> While not easy to achieve in practice (e.g. resolving natural forks\n> becomes more complicated), it demonstrates that users can become more\n> empowered than they are today, benefitting censorship resistance***.\n> It is this line of thinking that I wish to convey. Perhaps it may\n> inspire further ideas in this direction.\n>\n> -- Ruben Somsen\n>\n>\n> * BIP 115: https://apc01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fbitcoin%2Fbips%2Fblob%2Fmaster%2Fbip-0115.mediawiki&amp;data=02%7C01%7C%7C48403f77efc14613e89b08d611f5980c%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636716143839246019&amp;sdata=req4KYOcztXLAG%2Fu4RrmhLREGBF28JNTe45pO86kRd4%3D&amp;reserved=0\n>\n> ** Coinjoin: https://apc01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fbitcointalk.org%2Findex.php%3Ftopic%3D279249.0&amp;data=02%7C01%7C%7C48403f77efc14613e89b08d611f5980c%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636716143839246019&amp;sdata=d%2B06jxrKubWhLwoInFEgo8eHvI9f1j74QN8WH7xrVos%3D&amp;reserved=0\n>\n> *** Risk sharing principle:\n> https://apc01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Flibbitcoin%2Flibbitcoin%2Fwiki%2FRisk-Sharing-Principle&amp;data=02%7C01%7C%7C48403f77efc14613e89b08d611f5980c%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636716143839246019&amp;sdata=NA3HxqI5PnuyaI9hyCaw0rcaFsrhD%2FXQB8biWJXej8g%3D&amp;reserved=0\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://apc01.safelinks.protection.outlook.com/?url=https%3A%2F%2Flists.linuxfoundation.org%2Fmailman%2Flistinfo%2Fbitcoin-dev&amp;data=02%7C01%7C%7C48403f77efc14613e89b08d611f5980c%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636716143839246019&amp;sdata=9P7UetPmKWngjgjNPE0%2BAMgdzuL2DgqBLoLti82f23M%3D&amp;reserved=0"
            }
        ],
        "thread_summary": {
            "title": "Guiding transaction fees towards a more censorship resistant outcome",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Damian Williamson",
                "Ruben Somsen"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 14489
        }
    },
    {
        "title": "[bitcoin-dev] Schnorr signatures BIP",
        "thread_messages": [
            {
                "author": "Andrew Poelstra",
                "date": "2018-09-03T00:05:18",
                "message_text_only": "On Wed, Aug 29, 2018 at 08:09:36AM -0400, Erik Aronesty wrote:\n> Note:\n> \n> This spec cannot be used directly with a shamir scheme to produce\n> single-round threshold multisigs, because shares of point R would need to\n> be broadcast to share participants in order to produce valid single\n> signatures.\n> \n> (R, s) schemes can still be used \"online\", if share participants publish\n> the R(share).... but, not sure if it matter much, this choice eliminates\n> offline multiparty signing in exchange for batch validation.\n>\n\nPlease stop with this FUD. No tradeoff was made. There are no non-interactive\nSchnorr signatures.\n\n\nAndrew\n \n\n-- \nAndrew Poelstra\nMathematics Department, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\n\"A goose alone, I suppose, can know the loneliness of geese\n who can never find their peace,\n whether north or south or west or east\"\n       --Joanna Newsom\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180903/cec88ce8/attachment-0001.sig>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2018-09-05T12:26:14",
                "message_text_only": "Why would you call it FUD?   All the weird hemming and hawing about it is\nreally strange to me.  The more I look into it and speak to professors\nabout i, the more it seems \"so trivial nobody really talks about it\".\n\n1. Generate an M of N shared public key (done in advance of signing ....\nthis gets you the bitcoin address)\n2. Generate signature fragments (this can be done offline, with no\ncommunication between participants)\n\nDetailed explanation with code snippets:\n\nhttps://medium.com/@simulx/an-m-of-n-bitcoin-multisig-scheme-e7860ab34e7f\n\n\n\nOn Sun, Sep 2, 2018 at 8:05 PM Andrew Poelstra <apoelstra at wpsoftware.net>\nwrote:\n\n> On Wed, Aug 29, 2018 at 08:09:36AM -0400, Erik Aronesty wrote:\n> > Note:\n> >\n> > This spec cannot be used directly with a shamir scheme to produce\n> > single-round threshold multisigs, because shares of point R would need to\n> > be broadcast to share participants in order to produce valid single\n> > signatures.\n> >\n> > (R, s) schemes can still be used \"online\", if share participants publish\n> > the R(share).... but, not sure if it matter much, this choice eliminates\n> > offline multiparty signing in exchange for batch validation.\n> >\n>\n> Please stop with this FUD. No tradeoff was made. There are no\n> non-interactive\n> Schnorr signatures.\n>\n>\n> Andrew\n>\n>\n> --\n> Andrew Poelstra\n> Mathematics Department, Blockstream\n> Email: apoelstra at wpsoftware.net\n> Web:   https://www.wpsoftware.net/andrew\n>\n> \"A goose alone, I suppose, can know the loneliness of geese\n>  who can never find their peace,\n>  whether north or south or west or east\"\n>        --Joanna Newsom\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180905/c41fdcc4/attachment-0001.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2018-09-05T15:35:14",
                "message_text_only": "On Wed, Sep 5, 2018 at 1:49 PM Erik Aronesty via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Detailed explanation with code snippets:\n>\n> https://medium.com/@simulx/an-m-of-n-bitcoin-multisig-scheme-[snip]\n\nThis appears to be a repost of the broken scheme you posted about on\nBitcointalk, but then failed to respond to the response.\n\nhttps://bitcointalk.org/index.php?topic=4973123.0\n\n> The more I look into it and speak to professors about i, the more it seems \"so trivial nobody really talks about it\".\n\nI think you might be falling into the trap of ignoring feedback you\ndon't like and and accepting that which sounds like \"yea yea,\nsomething like that\".\n\nSomething \"like that\" does work: and is expressly and explicitly\nanticipated by the BIP but to be both secure and functional requires\nproper delineation (E.g. musig) _and_ interaction. What you're\nproposing is continually vague.  My best efforts at making sense of\nwhat you've written indicate that either it's non-interactive and\nnot-actually functional at all,  OR it's interactive and just a less\nsecure subset (no proper delinearization to prevent rogue key attacks)\nof what we already propose.\n\nWhen Poelstra suggests a CAS implementation he means something like\nthis Sage notebook: http://bitcoin.ninja/secp256k1.ecdsa.sage  This\nprovides for a method of communicating in both directions which is\ncompletely precise."
            },
            {
                "author": "Erik Aronesty",
                "date": "2018-09-11T16:34:11",
                "message_text_only": "To answer points:\n\n- I switched to the medium article so that I could correct, edit and\nimprove things to make them more clear.\n- I responded to feedback by modifying the protocol to make it work - not\nby ignoring it.\n- I coded it up in python so I could be sure it worked, because I was\nconcerned that it was broken\n- Yes, coding it up showed me that it's definitely interactive, and no\ndifferent than a \"standard shnorr sig\" in any meaningful way regarding the\nsecurity\n- No special protocol support is needed over Schnorr signing itself.  The\ne, s version can be made at least as secure as schnorr + DLP.  I haven't\nresearched the R,s version.\n- An M-1 rogue-key attack would require the attacker would to either\n\n  - attack the hash function to produce a predictable R based on a known\nmesage\n  - attack the DLP to influence x or k\n\nNeither attack gives any particular advantage to someone who has M-1 keys.\n\nI haven't tested whether the R,s version is susceptible though.\n\n\nOn Thu, Sep 6, 2018 at 9:15 AM Gregory Maxwell via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Wed, Sep 5, 2018 at 1:49 PM Erik Aronesty via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > Detailed explanation with code snippets:\n> >\n> > https://medium.com/@simulx/an-m-of-n-bitcoin-multisig-scheme-[snip]\n>\n> This appears to be a repost of the broken scheme you posted about on\n> Bitcointalk, but then failed to respond to the response.\n>\n> https://bitcointalk.org/index.php?topic=4973123.0\n>\n> > The more I look into it and speak to professors about i, the more it\n> seems \"so trivial nobody really talks about it\".\n>\n> I think you might be falling into the trap of ignoring feedback you\n> don't like and and accepting that which sounds like \"yea yea,\n> something like that\".\n>\n> Something \"like that\" does work: and is expressly and explicitly\n> anticipated by the BIP but to be both secure and functional requires\n> proper delineation (E.g. musig) _and_ interaction. What you're\n> proposing is continually vague.  My best efforts at making sense of\n> what you've written indicate that either it's non-interactive and\n> not-actually functional at all,  OR it's interactive and just a less\n> secure subset (no proper delinearization to prevent rogue key attacks)\n> of what we already propose.\n>\n> When Poelstra suggests a CAS implementation he means something like\n> this Sage notebook: http://bitcoin.ninja/secp256k1.ecdsa.sage  This\n> provides for a method of communicating in both directions which is\n> completely precise.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180911/20ed54de/attachment-0001.html>"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2018-09-05T13:05:59",
                "message_text_only": "On Wed, Sep 05, 2018 at 08:26:14AM -0400, Erik Aronesty wrote:\n> Why would you call it FUD?   All the weird hemming and hawing about it is\n> really strange to me.  The more I look into it and speak to professors\n> about i, the more it seems \"so trivial nobody really talks about it\".\n> \n> 1. Generate an M of N shared public key (done in advance of signing ....\n> this gets you the bitcoin address)\n> 2. Generate signature fragments (this can be done offline, with no\n> communication between participants)\n> \n> Detailed explanation with code snippets:\n> \n> https://medium.com/@simulx/an-m-of-n-bitcoin-multisig-scheme-e7860ab34e7f\n>\n\nThe hemming and hawing is because you've been repeatedly told that your\nscheme doesn't work, and to please implement it in some computer algebra\nsystem so that you can see that (or so we can see where your mistake is),\nand you instead continue to post incomplete/incoherent copies of the same\nthing across multiple mediums - Reddit, this list, Bitcointalk, Medium,\netc ad nauseum.\n\nIt's distracting and offensive to people who have spent a lot of time and\nenergy thinking about this stuff, and more importantly it causes confusion\nin the public eye. Phrasings like \"weird hemming and hawing\" suggest that\nwe don't know/don't care about some insight you have, which is not true.\nThis is why your posts are FUD.\n\nFor example, in your linked post I looked at every single instance of the\ncharacter 'k' and *not one of them* defined the value 'k' from which 'R'\nis derived in the signing procedure.\n\n\nOf course there is no possible value, individual signers cannot learn 'R'\nat signing time without interaction, and your whole scheme is broken. Given\nthe number of times you've been told this, I find it hard to believe that\nthis was an honest mistake.\n\n\n\nAndrew\n\n\n\n-- \nAndrew Poelstra\nResearch Director, Mathematics Department, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\n\"Make it stop, my love; we were wrong to try\n Never saw what we could unravel in traveling light\n Nor how the trip debrides like a stack of slides\n All we saw was that time is taller than space is wide\"\n       --Joanna Newsom\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180905/8174ffbf/attachment.sig>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2018-09-05T13:14:55",
                "message_text_only": "Correct, there is an interaction step to deduce G*k, when signing, each\nparticipant has to publishes G*ki. I didn't talk about it.   That doesn't\nbreak it, but you're correct, it's not non-interactive.\n\nOn Wed, Sep 5, 2018 at 9:06 AM Andrew Poelstra <apoelstra at wpsoftware.net>\nwrote:\n\n> On Wed, Sep 05, 2018 at 08:26:14AM -0400, Erik Aronesty wrote:\n> > Why would you call it FUD?   All the weird hemming and hawing about it is\n> > really strange to me.  The more I look into it and speak to professors\n> > about i, the more it seems \"so trivial nobody really talks about it\".\n> >\n> > 1. Generate an M of N shared public key (done in advance of signing ....\n> > this gets you the bitcoin address)\n> > 2. Generate signature fragments (this can be done offline, with no\n> > communication between participants)\n> >\n> > Detailed explanation with code snippets:\n> >\n> >\n> https://medium.com/@simulx/an-m-of-n-bitcoin-multisig-scheme-e7860ab34e7f\n> >\n>\n> The hemming and hawing is because you've been repeatedly told that your\n> scheme doesn't work, and to please implement it in some computer algebra\n> system so that you can see that (or so we can see where your mistake is),\n> and you instead continue to post incomplete/incoherent copies of the same\n> thing across multiple mediums - Reddit, this list, Bitcointalk, Medium,\n> etc ad nauseum.\n>\n> It's distracting and offensive to people who have spent a lot of time and\n> energy thinking about this stuff, and more importantly it causes confusion\n> in the public eye. Phrasings like \"weird hemming and hawing\" suggest that\n> we don't know/don't care about some insight you have, which is not true.\n> This is why your posts are FUD.\n>\n> For example, in your linked post I looked at every single instance of the\n> character 'k' and *not one of them* defined the value 'k' from which 'R'\n> is derived in the signing procedure.\n>\n>\n> Of course there is no possible value, individual signers cannot learn 'R'\n> at signing time without interaction, and your whole scheme is broken. Given\n> the number of times you've been told this, I find it hard to believe that\n> this was an honest mistake.\n>\n>\n>\n> Andrew\n>\n>\n>\n> --\n> Andrew Poelstra\n> Research Director, Mathematics Department, Blockstream\n> Email: apoelstra at wpsoftware.net\n> Web:   https://www.wpsoftware.net/andrew\n>\n> \"Make it stop, my love; we were wrong to try\n>  Never saw what we could unravel in traveling light\n>  Nor how the trip debrides like a stack of slides\n>  All we saw was that time is taller than space is wide\"\n>        --Joanna Newsom\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180905/c737fbbf/attachment-0001.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2018-09-11T17:00:25",
                "message_text_only": "On Tue, Sep 11, 2018 at 4:34 PM Erik Aronesty <erik at q32.com> wrote:\n\n> To answer points:\n>\n> - I switched to the medium article so that I could correct, edit and\n> improve things to make them more clear.\n> - I responded to feedback by modifying the protocol to make it work - not\n> by ignoring it.\n>\n\nTo this moment there remains no response at your post.\nhttps://bitcointalk.org/index.php?topic=4973123.0\n\nI'm not sure how I am supposted to have figured out that you wrote a\nsomewhat different repost of it elsewhere...\n\n- An M-1 rogue-key attack would require the attacker would to either\n>\n>   - attack the hash function to produce a predictable R based on a known\n> mesage\n>   - attack the DLP to influence x or k\n>\n> Neither attack gives any particular advantage to someone who has M-1 keys.\n>\n\nYou keep asserting this. It isn't true. Asserting it more does not make it\nany more true.  I already explained how to attack this style of signature\n(e.g. in the BCT thread).\n\nSet aside your 'interpolation' for a moment, and imagine that you construct\na 2 of 2 signature by just adding the keys.  Your tell me your key, P1  and\nthen I tell you that my key P2 which I derived by computing -P1  + xG.   We\nnow compute P = P1 + P2 = P1 + -P1 + xG = xG ... and now in spite adding P1\nwith an unknown discrete log, I know the discrete log of P with respect to\nG and I did not need to violate the standard DL security assumption to\nachieve that.\n\nWith the 'interpolation' in effect the same attack applies but its\nexecution is somewhat more complex: instead of adding the negation of P1  I\nmust add a number of multiplicities of P1 (like P1*2, P1*3, P1*4...)\nselected so that their interpolation coefficients add up to -1. Finding a\nsuitable subset requires solving a randomized modular subset sum problem\nand Wagner's algorithm provides a computationally tractable solution to it.\n\nThe potential of rogue keys applies to both the keys themselves and to the\nnonces. There are several ways to prevent these attacks, the musig paper\ndescribes a delinearization technique which doesn't require additional\ninteraction or communication.\n\nI haven't tested whether the R,s version is susceptible though.\n>\n\nThere is a perfect bijection between the two encodings which is easily\ncomputable, so they're the same thing from an abstract security perspective.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180911/6d4ebd71/attachment.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2018-09-11T17:20:01",
                "message_text_only": "Greg,\n\nI added, stripped out, and added analogous musig delinearization 3 times in\nresponse to stuff posted here.  I'm adding it back now. Not sure why my\nhead is thick around that issue.\n\nThe security advantages of a redistributable threshold system are huge.\nIf a system isn't redistributable, then a single lost or compromised key\nresults in lost coins... meaning the system is essetntially unusable.\n\nI'm actually worried that Bitcoin releases a multisig that encourages loss.\n\n\n\n\nOn Tue, Sep 11, 2018 at 1:00 PM Gregory Maxwell <greg at xiph.org> wrote:\n\n> On Tue, Sep 11, 2018 at 4:34 PM Erik Aronesty <erik at q32.com> wrote:\n>\n>> To answer points:\n>>\n>> - I switched to the medium article so that I could correct, edit and\n>> improve things to make them more clear.\n>> - I responded to feedback by modifying the protocol to make it work - not\n>> by ignoring it.\n>>\n>\n> To this moment there remains no response at your post.\n> https://bitcointalk.org/index.php?topic=4973123.0\n>\n> I'm not sure how I am supposted to have figured out that you wrote a\n> somewhat different repost of it elsewhere...\n>\n> - An M-1 rogue-key attack would require the attacker would to either\n>>\n>>   - attack the hash function to produce a predictable R based on a known\n>> mesage\n>>   - attack the DLP to influence x or k\n>>\n>> Neither attack gives any particular advantage to someone who has M-1 keys.\n>>\n>\n> You keep asserting this. It isn't true. Asserting it more does not make it\n> any more true.  I already explained how to attack this style of signature\n> (e.g. in the BCT thread).\n>\n> Set aside your 'interpolation' for a moment, and imagine that you\n> construct a 2 of 2 signature by just adding the keys.  Your tell me your\n> key, P1  and then I tell you that my key P2 which I derived by computing\n> -P1  + xG.   We now compute P = P1 + P2 = P1 + -P1 + xG = xG ... and now in\n> spite adding P1 with an unknown discrete log, I know the discrete log of P\n> with respect to G and I did not need to violate the standard DL security\n> assumption to achieve that.\n>\n> With the 'interpolation' in effect the same attack applies but its\n> execution is somewhat more complex: instead of adding the negation of P1  I\n> must add a number of multiplicities of P1 (like P1*2, P1*3, P1*4...)\n> selected so that their interpolation coefficients add up to -1. Finding a\n> suitable subset requires solving a randomized modular subset sum problem\n> and Wagner's algorithm provides a computationally tractable solution to it.\n>\n> The potential of rogue keys applies to both the keys themselves and to the\n> nonces. There are several ways to prevent these attacks, the musig paper\n> describes a delinearization technique which doesn't require additional\n> interaction or communication.\n>\n> I haven't tested whether the R,s version is susceptible though.\n>>\n>\n> There is a perfect bijection between the two encodings which is easily\n> computable, so they're the same thing from an abstract security perspective.\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180911/1dad3a33/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2018-09-11T17:27:09",
                "message_text_only": "On Tue, Sep 11, 2018 at 5:20 PM Erik Aronesty <erik at q32.com> wrote:\n> The security advantages of a redistributable threshold system are huge.   If a system isn't redistributable, then a single lost or compromised key results in lost coins... meaning the system is essetntially unusable.\n>\n> I'm actually worried that Bitcoin releases a multisig that encourages loss.\n\nThere is no \"non- edistributiable multisig\" proposed for Bitcoin\nanywhere that I am aware of."
            },
            {
                "author": "Erik Aronesty",
                "date": "2018-09-11T17:37:59",
                "message_text_only": "- Musig, by being M of M, is inherently prone to loss.\n\n- Having the senders of the G*x pubkey shares sign their messages with the\nassociated private key share should be sufficient to prevent them from\nusing wagner's algorithm to attack the combined key.   Likewise, the G*k\nnonce fragments should also be signed with the pubkey shares.\n\n\n\nOn Tue, Sep 11, 2018 at 1:27 PM Gregory Maxwell <greg at xiph.org> wrote:\n\n> On Tue, Sep 11, 2018 at 5:20 PM Erik Aronesty <erik at q32.com> wrote:\n> > The security advantages of a redistributable threshold system are huge.\n>  If a system isn't redistributable, then a single lost or compromised key\n> results in lost coins... meaning the system is essetntially unusable.\n> >\n> > I'm actually worried that Bitcoin releases a multisig that encourages\n> loss.\n>\n> There is no \"non- edistributiable multisig\" proposed for Bitcoin\n> anywhere that I am aware of.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180911/d39149db/attachment.html>"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2018-09-13T18:46:50",
                "message_text_only": "On Tue, Sep 11, 2018 at 01:37:59PM -0400, Erik Aronesty via bitcoin-dev wrote:\n> - Musig, by being M of M, is inherently prone to loss.\n>\n\nIt has always been possible to create M-of-N threshold MuSig signatures for any\nM, N with 0 < M \u2264 N. This is (a) obvious, (b) in our paper, (c) implemented at\n\nhttps://github.com/apoelstra/secp256k1/blob/2018-04-taproot/src/modules/musig/main_impl.h \n\n-- \nAndrew Poelstra\nResearch Director, Mathematics Department, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\n\"Make it stop, my love; we were wrong to try\n Never saw what we could unravel in traveling light\n Nor how the trip debrides like a stack of slides\n All we saw was that time is taller than space is wide\"\n       --Joanna Newsom\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180913/ca7797a6/attachment.sig>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2018-09-13T20:20:36",
                "message_text_only": "The paper refers to either:\n\n  a) building up threshold signatures via concatenation, or. implicitly -\nin Bitcoin -\n  b) by indicating that of M of N are valid, and requiring a validator to\nvalidate one of the permutations of M that signed - as opposed to a scheme,\nlike a polynomial function, where the threshold is built in to the system.\n\nMaybe there's another mechanism in there that I'm not aware of - because\nit's just too simple to mention?\n\n- Erik\n\n\n\n\n\n\nOn Thu, Sep 13, 2018 at 2:46 PM Andrew Poelstra <apoelstra at wpsoftware.net>\nwrote:\n\n> On Tue, Sep 11, 2018 at 01:37:59PM -0400, Erik Aronesty via bitcoin-dev\n> wrote:\n> > - Musig, by being M of M, is inherently prone to loss.\n> >\n>\n> It has always been possible to create M-of-N threshold MuSig signatures\n> for any\n> M, N with 0 < M \u2264 N. This is (a) obvious, (b) in our paper, (c)\n> implemented at\n>\n>\n> https://github.com/apoelstra/secp256k1/blob/2018-04-taproot/src/modules/musig/main_impl.h\n>\n> --\n> Andrew Poelstra\n> Research Director, Mathematics Department, Blockstream\n> Email: apoelstra at wpsoftware.net\n> Web:   https://www.wpsoftware.net/andrew\n>\n> \"Make it stop, my love; we were wrong to try\n>  Never saw what we could unravel in traveling light\n>  Nor how the trip debrides like a stack of slides\n>  All we saw was that time is taller than space is wide\"\n>        --Joanna Newsom\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180913/88497b38/attachment.html>"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2018-09-14T14:38:02",
                "message_text_only": "Hi Erik,\n\n\nSorry, you're right - I thought we mentioned m-of-n as a footnote but that was\nactually in the earlier pre-MuSig version of our multisig paper.\n\nThreshold signatures -are- mentioned in the BIP which started this thread, though.\nAt https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki we say\n\n    \"Further, by combining Schnorr signatures with Pedersen Secret Sharing,\n     it is possible to obtain an interactive threshold signature scheme that\n     ensures that signatures can only be produced by arbitrary but predetermined\n     sets of signers. For example, k-of-n threshold signatures can be realized\n     this way. Furthermore, it is possible to replace the combination of\n     participant keys in this scheme with MuSig, though the security of that\n     combination still needs analysis. \n\nand this combination of MuSig and VSS is exactly what is implemented in my code.\n\n\n\nCheers\nAndrew\n\n\n\nOn Thu, Sep 13, 2018 at 04:20:36PM -0400, Erik Aronesty wrote:\n> The paper refers to either:\n> \n>   a) building up threshold signatures via concatenation, or. implicitly -\n> in Bitcoin -\n>   b) by indicating that of M of N are valid, and requiring a validator to\n> validate one of the permutations of M that signed - as opposed to a scheme,\n> like a polynomial function, where the threshold is built in to the system.\n> \n> Maybe there's another mechanism in there that I'm not aware of - because\n> it's just too simple to mention?\n> \n> - Erik\n> \n> \n> \n> \n> \n> \n> On Thu, Sep 13, 2018 at 2:46 PM Andrew Poelstra <apoelstra at wpsoftware.net>\n> wrote:\n> \n> > On Tue, Sep 11, 2018 at 01:37:59PM -0400, Erik Aronesty via bitcoin-dev\n> > wrote:\n> > > - Musig, by being M of M, is inherently prone to loss.\n> > >\n> >\n> > It has always been possible to create M-of-N threshold MuSig signatures\n> > for any\n> > M, N with 0 < M \u2264 N. This is (a) obvious, (b) in our paper, (c)\n> > implemented at\n> >\n> >\n> > https://github.com/apoelstra/secp256k1/blob/2018-04-taproot/src/modules/musig/main_impl.h\n> >\n> > --\n> > Andrew Poelstra\n> > Research Director, Mathematics Department, Blockstream\n> > Email: apoelstra at wpsoftware.net\n> > Web:   https://www.wpsoftware.net/andrew\n> >\n> > \"Make it stop, my love; we were wrong to try\n> >  Never saw what we could unravel in traveling light\n> >  Nor how the trip debrides like a stack of slides\n> >  All we saw was that time is taller than space is wide\"\n> >        --Joanna Newsom\n> >\n> >\n\n-- \nAndrew Poelstra\nResearch Director, Mathematics Department, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\n\"Make it stop, my love; we were wrong to try\n Never saw what we could unravel in traveling light\n Nor how the trip debrides like a stack of slides\n All we saw was that time is taller than space is wide\"\n       --Joanna Newsom\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180914/498c9bc5/attachment.sig>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2018-09-11T17:51:01",
                "message_text_only": "On Tue, Sep 11, 2018 at 5:38 PM Erik Aronesty <erik at q32.com> wrote:\n>\n> - Musig, by being M of M, is inherently prone to loss.\n\nM of M is a particular threshold.   If you want M of M (there are\nplenty of cases where M of M _must_ be used) then you get the\nconsequences of M of M, which presumably you want.\n\nThis has nothing to do with musig.  If you want a threshold other than\nM of M then you use a threshold other than M of M.\n\nNo one is under the impression that M of M is somehow a replacement\nfor other thresholds.  We've spent more time talking about M of M in\nsome writeups in the past because it's exactly the case you need for\nsignature aggregation in Bitcoin and because it's a simpler case to\nexplain.\n\n> - Having the senders of the G*x pubkey shares sign their messages with the associated private key share should be sufficient to prevent them from using wagner's algorithm to attack the combined key.\n\nYes, that is one possibility which is described in the musig paper,\nbut it requires users communicate an extra signature per key.  So, for\nexample, if used with aggregate signature it would completely\neliminate the communications efficiency gains from aggregation, making\naggregation worse than pointless.  It also has somewhat worse failure\nproperties than delinearization, because a signer that fails to\nvalidate other's share signatures behaves behaves exactly the same as\na correct one, on honest inputs.  That approach has its uses but I\nthink that in any case where delinearization can be used it's a better\noption."
            },
            {
                "author": "Erik Aronesty",
                "date": "2018-09-11T18:30:13",
                "message_text_only": ">  That approach has its uses but I think that in any case where\ndelinearization can be used it's a better option.\n\nI agree, communication efficiency is a concern for some applications, and I\ncan think of cases where delinearization is the better option as well.\n\nFor users that want an \"M of N\" scheme that\n\na) doesn't cost more to send funds\nb) allows them to lose a device and keep their coins\nc) allows them to establish and validate the scheme safely\n\n...  a simple, \"verified signer\" threshold scheme is probably the best\nsolution.\n\n\n\n\nOn Tue, Sep 11, 2018 at 1:51 PM Gregory Maxwell <greg at xiph.org> wrote:\n\n> On Tue, Sep 11, 2018 at 5:38 PM Erik Aronesty <erik at q32.com> wrote:\n> >\n> > - Musig, by being M of M, is inherently prone to loss.\n>\n> M of M is a particular threshold.   If you want M of M (there are\n> plenty of cases where M of M _must_ be used) then you get the\n> consequences of M of M, which presumably you want.\n>\n> This has nothing to do with musig.  If you want a threshold other than\n> M of M then you use a threshold other than M of M.\n>\n> No one is under the impression that M of M is somehow a replacement\n> for other thresholds.  We've spent more time talking about M of M in\n> some writeups in the past because it's exactly the case you need for\n> signature aggregation in Bitcoin and because it's a simpler case to\n> explain.\n>\n> > - Having the senders of the G*x pubkey shares sign their messages with\n> the associated private key share should be sufficient to prevent them from\n> using wagner's algorithm to attack the combined key.\n>\n> Yes, that is one possibility which is described in the musig paper,\n> but it requires users communicate an extra signature per key.  So, for\n> example, if used with aggregate signature it would completely\n> eliminate the communications efficiency gains from aggregation, making\n> aggregation worse than pointless.  It also has somewhat worse failure\n> properties than delinearization, because a signer that fails to\n> validate other's share signatures behaves behaves exactly the same as\n> a correct one, on honest inputs.  That approach has its uses but I\n> think that in any case where delinearization can be used it's a better\n> option.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180911/28f34718/attachment.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2018-09-20T21:12:42",
                "message_text_only": "It would be helpful to add the intermediate 'e' values computed to the\nfirst four test vectors.\n\nOn Fri, Jul 6, 2018 at 2:08 PM, Pieter Wuille via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello everyone,\n>\n> Here is a proposed BIP for 64-byte elliptic curve Schnorr signatures,\n> over the same curve as is currently used in ECDSA:\n> https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki\n>\n> It is simply a draft specification of the signature scheme itself. It\n> does not concern consensus rules, aggregation, or any other\n> integration into Bitcoin - those things are left for other proposals,\n> which can refer to this scheme if desirable. Standardizing the\n> signature scheme is a first step towards that, and as it may be useful\n> in other contexts to have a common Schnorr scheme available, it is its\n> own informational BIP.\n>\n> If accepted, we'll work on more production-ready reference\n> implementations and tests.\n>\n> This is joint work with several people listed in the document.\n>\n> Cheers,\n>\n> --\n> Pieter\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180920/b4f3bef3/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Schnorr signatures BIP",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Andrew Poelstra",
                "Russell O'Connor",
                "Erik Aronesty",
                "Gregory Maxwell"
            ],
            "messages_count": 16,
            "total_messages_chars_count": 30814
        }
    },
    {
        "title": "[bitcoin-dev] Reinterpretations of contracts in different pay-to-contract schemes",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2018-09-03T09:26:35",
                "message_text_only": "Good morning all,\n\nI am wondering if there is the possibility of an issue arising when different pay-to-contract schemes are used on Bitcoin.\n\nSpecifically, I wonder, if it may be possible to reinterpret the byte serialization of a contract under one scheme as the byte serialization of a different contract under another scheme.  The user may expect to have committed to a contract under the first scheme, but is rudely made aware that she has also committed to a different contract under a scheme she is unaware of.\n\nFor instance, if some independent protocol uses pay-to-contract, it may be possible for the contract to be reinterpreted as a Bitcoin SCRIPT under Taproot, leading to a contract that can be reinterpreted as a Bitcoin SCRIPT and allowing a Bitcoin-level UTXO to be stolen without knowledge of the private key.\n\nI thought of this a little while ago and mentioned it here:https://github.com/rgb-org/spec/issues/61\n\nNow, it may be possible to use the hash of the contract, but if Taproot uses a hash of the script also and the same hash function is used, then the bytes of the contract could be reinterpreted as a Bitcoin SCRIPT program, possibly leading to a trivial-to-solve SCRIPT with enough hacking.\n\nIf this is indeed a concern, then I propose, that pay-to-contract schemes should pay to the below tweak:\n\n     Q = P + SHA256d(P || Scheme || C) * G\n\nWhere `Scheme` is 256 bits (32 bytes) scheme identifier.  For Taproot, it could be the genesis block ID.  Then other pay-to-contract schemes must ensure that they use a `Scheme` ID that is different with high probability from other `Scheme` IDs, in order to ensure that reinterpretation of contracts is impossible.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180903/3ef6b93b/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Reinterpretations of contracts in different pay-to-contract schemes",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1892
        }
    },
    {
        "title": "[bitcoin-dev] Overhauled BIP151",
        "thread_messages": [
            {
                "author": "Jonas Schnelli",
                "date": "2018-09-03T12:16:19",
                "message_text_only": "Hi\n\nDuring work on the implementation of BIP151 [1] I figured out that the current\npublished proposal could be further optimized.\n\nI wrote an overhauled BIP151 specification with some \u2013 partially radical \u2013\nchanges.\n\nNow it\u2019s unclear to me if this should be published under a new BIP nr. or if it\nis acceptable to change the existing 151 proposal.\nIf a new BIP number would be required, I think withdrawing BIP151 should be\ndone (which somehow indicates we should alter 151).\n\nThe only BIP151 implementation I\u2019m aware of is the one from Armory [2].\nBCoins implementation has been removed [3].\n\nThe new proposal draft is available here:\nhttps://gist.github.com/jonasschnelli/c530ea8421b8d0e80c51486325587c52\n\nMajor changes\n=============\n- the encryption handshake no longer requires the v1 protocol, it\u2019s a pure\n  32bytes-per-side \u201epseudorandom\" key exchange that happens before anything else.\n- the multi message envelope has been removed.\n- a new NODE_ENCRYPTED service bit\n- the key derivation and what communication direction uses what key is now more\n  specific\n- the length of a packet uses now a 3-byte integer with 23 available bits\n- introduction of short-command-ID (ex.: uint8_t 13 == INV, etc.) which result in\n  some v2 messages require less bandwidth then v1\n- rekeying doesn\u2019t require a message and can be signaled in the most\n  significant bit in the packet-size field\n\n\nPoints that are in discussion and may be added to the BIP (or to a new one):\n\nHybrid NewHope key exchange\n===========================\nThe current ECDH key exchange is vulnerable to Shor\u2019s algorithm and is thus not\nconsidered quantum-safe.\nFollowing TORs approach [4] by adding a NewHope [5] key-exchange the handshake\nprotocol would very likely make the encryption PQ safe with little costs.\nThere is also a straight forward implementation [6] from the NewHope team that\nhas been submitted to NIST PQC project.\n\nInefficiency of ChaCha20Poly1305 at openssh\n========================================\nThe proposed AEAD could eventually be further optimized.\nChaCha20Poly1305 at openssh uses at least three rounds of ChaCha20 which\neventually can be reduced to two (messages below <=64 bytes [inv, ping,\npong,...] only require one round of ChaCha20, but two for the Poly1305 key and\nthe message length encryption where the Poly1305 key chacha round \u201ethrows away\u201c\n32 bytes).\n\n\nI would suggest that we don\u2019t rehash discussions about the general\nconcept of encrypting the traffic. This has already been discussed [7][8].\n\nI hope we can limit this thread to discuss further ideas for optimisation as well as\ntechnical details of the published proposal or its implementation.\n\n\n[1] https://github.com/bitcoin/bitcoin/pull/14032\n[2] https://github.com/goatpig/BitcoinArmory/pull/510\n[3] https://github.com/bcoin-org/bcoin/commit/41af7acfd68b0492a6442865afd439300708e662\n[4] https://gitweb.torproject.org/user/isis/torspec.git/plain/proposals/XXX-newhope-hybrid-handshake.txt?h=draft/newhope\n[5] https://eprint.iacr.org/2015/1092\n[6] https://github.com/newhopecrypto/newhope\n\n[7] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013565.html\n[8] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-June/012826.html\n\n\nThanks\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180903/82a75538/attachment-0001.sig>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2018-09-04T01:37:30",
                "message_text_only": "Without commenting on the other merits of either proposal, the addition of the service flag resolves bip151\u2019s previously-discussed lack of backward compatibility.\n\ne\n\n> On Sep 3, 2018, at 21:16, Jonas Schnelli via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Hi\n> \n> During work on the implementation of BIP151 [1] I figured out that the current\n> published proposal could be further optimized.\n> \n> I wrote an overhauled BIP151 specification with some \u2013 partially radical \u2013\n> changes.\n> \n> Now it\u2019s unclear to me if this should be published under a new BIP nr. or if it\n> is acceptable to change the existing 151 proposal.\n> If a new BIP number would be required, I think withdrawing BIP151 should be\n> done (which somehow indicates we should alter 151).\n> \n> The only BIP151 implementation I\u2019m aware of is the one from Armory [2].\n> BCoins implementation has been removed [3].\n> \n> The new proposal draft is available here:\n> https://gist.github.com/jonasschnelli/c530ea8421b8d0e80c51486325587c52\n> \n> Major changes\n> =============\n> - the encryption handshake no longer requires the v1 protocol, it\u2019s a pure\n>  32bytes-per-side \u201epseudorandom\" key exchange that happens before anything else.\n> - the multi message envelope has been removed.\n> - a new NODE_ENCRYPTED service bit\n> - the key derivation and what communication direction uses what key is now more\n>  specific\n> - the length of a packet uses now a 3-byte integer with 23 available bits\n> - introduction of short-command-ID (ex.: uint8_t 13 == INV, etc.) which result in\n>  some v2 messages require less bandwidth then v1\n> - rekeying doesn\u2019t require a message and can be signaled in the most\n>  significant bit in the packet-size field\n> \n> \n> Points that are in discussion and may be added to the BIP (or to a new one):\n> \n> Hybrid NewHope key exchange\n> ===========================\n> The current ECDH key exchange is vulnerable to Shor\u2019s algorithm and is thus not\n> considered quantum-safe.\n> Following TORs approach [4] by adding a NewHope [5] key-exchange the handshake\n> protocol would very likely make the encryption PQ safe with little costs.\n> There is also a straight forward implementation [6] from the NewHope team that\n> has been submitted to NIST PQC project.\n> \n> Inefficiency of ChaCha20Poly1305 at openssh\n> ========================================\n> The proposed AEAD could eventually be further optimized.\n> ChaCha20Poly1305 at openssh uses at least three rounds of ChaCha20 which\n> eventually can be reduced to two (messages below <=64 bytes [inv, ping,\n> pong,...] only require one round of ChaCha20, but two for the Poly1305 key and\n> the message length encryption where the Poly1305 key chacha round \u201ethrows away\u201c\n> 32 bytes).\n> \n> \n> I would suggest that we don\u2019t rehash discussions about the general\n> concept of encrypting the traffic. This has already been discussed [7][8].\n> \n> I hope we can limit this thread to discuss further ideas for optimisation as well as\n> technical details of the published proposal or its implementation.\n> \n> \n> [1] https://github.com/bitcoin/bitcoin/pull/14032\n> [2] https://github.com/goatpig/BitcoinArmory/pull/510\n> [3] https://github.com/bcoin-org/bcoin/commit/41af7acfd68b0492a6442865afd439300708e662\n> [4] https://gitweb.torproject.org/user/isis/torspec.git/plain/proposals/XXX-newhope-hybrid-handshake.txt?h=draft/newhope\n> [5] https://eprint.iacr.org/2015/1092\n> [6] https://github.com/newhopecrypto/newhope\n> \n> [7] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013565.html\n> [8] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-June/012826.html\n> \n> \n> Thanks\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Tim Ruffing",
                "date": "2018-09-06T23:23:21",
                "message_text_only": "Hi Jonas,\n\nGreat to see progress in this area. I have quite a few comments.\n\nPost-quantum key exchange\n=========================\nI think that's overkill. Bitcoin has huge problems in the presence of a quantum computer, and the\nconfidentiality of the P2P messages is the most minor one. If there is a quantum computer and\nBitcoin remains in its current form, then people should probably stop using it.\n\nNow you can argue that the attacker is storing encrypted traffic today to decrypt it later. Sure,\nbut if that's your threat model then Bitcoin is probably not the right tool for you. (And if\nyou insist that Bitcoin is the right tool, then you can and probably should use it over Tor\nanyway.) Given the fact that essentially all information in Bitcoin will be public in some way,\nthere are probably cheaper attacks (MITM, traffic analysis).\n\nIt's not worth the hassle, would hinder adoption, and it has the potential to create a wrong\nimpression of \"bulletproof\" security. Even worse, there will be too many people that will suddenly\nassume that Bitcoin is post-quantum secure.\n\nKey exchange indistinguishable from random\n==========================================\nI would rather love to see a simple ECDH key exchange as currently used but with an encoding of\npublic key that provides indistinguishability from random bitstrings. \"Elligator\" does not work\nbut \"Elligator Squared\" [1] does the job for secp256k1 -- it just doubles the size of the public\nkey. Together with the encrypted packet lengths, the entire data stream looks like random then,\nwhich is pretty useful against censorship resistance for example. (The only exception is that the\nstream will never start with the magic bytes.)\n\nKey derivation\n==============\nThe key derivation can be improved. It should include each peer's understanding of its role,\ni.e., requester (or \"initiator\" is the more common term) or responder. At the moment, an attacker\ncan create a situation where two peers think they're in the same session (with the same session\nid) but they're actually not. Also, it's possible for an attacker to rerandomize the public keys.\nThat's nothing bad by itself but anything which restricts the flexibility of the attacker without\nadding complexity is a good idea. Something like\n   \"salt = BitcoinSharedSecret||INITIATOR_PUBKEY||RESPONDER_PUBKEY\" should just avoid this issue.\n\nRe-keying\n=========\nThe problem with signalling re-keying in the length field is that the length field is not covered\nby the MAC. So the attacker can flip the signalling bit. The resulting protocol is probably still\nsecure but the malleability is certainly not desirable.\n\nDeterministic rekeying rules may be better. Otherwise there will be implementations that rekey\nevery 10 seconds and implementations that just don't rekey at all (rendering the 10 s rekeying\ninterval in the opposite direction useless). Different policies also make it possible to\nfingerprint implementations. Another problem is that people will set their policies arbitrarily.\nWhat's better: 5 min or 30 min? I don't know, but both are reasonable choices. (Thats's very much\nlike discussions about ciphers... What's better AES-GCM or ChaCha20/Poly1305? I don't know, but\nagain both are reasonable choices.)\n\nSymmetric crypto\n================\nYou call it chacha20-poly1305 at bitcoin but what's the difference to the openssh then? Is the\nidea to save a call to chacha here as you mentioned?\n\nI didn't think about this in detail: maybe there are a few meaningful cases where padding could\nhide the message length without too much overhead. (I'm not convinced, just a random thought.)\n\nMisc\n====\n\"The ID/string mapping is a peer to peer arrangement and MAY be negotiated between the\nrequesting and responding peer.\" I think that's overly complicated. I suggest it should just be\nwritten in stone, again to avoid complexity and to avoid fingerprinting. New implementations are\nnecessary anyway, so maybe just use IDs for anything? ASCII is nice if you want to debug your code\nor some random network failure but that's hard anyway when encryption is used.\n\nIn general, the entire thing is a little bit underspecified. (I'm aware it's just a draft.)\nA few examples:\n - What should a peer do if the MAC verification fails?\n - What should a peer do if it receives an even key?\n - \"Processing the message before the authentication succeeds (MAC verified) MUST not be done.\"\n That should also apply to the ciphertext. (Or: What is a \"message\"?). It may be a good idea to\n to refer to the openssh document or steal from it; it does a pretty good job.\n - \"Both peers MUST keep track of the message sequence number (uint32) of sent and received\n messages for building a 64-bit symmetric cipher IV.\" I think you mean nonce when you say IV?\n - What is the initial value of the sequence number?\n - How is a 64-bit nonce formed from one (two?) uint32?\n - What if the uint32 overflows?\n - \"Re-Keying interval is a peer policy with a minimum timespan of 10 seconds.\" What if I receive\n too many re-keying requests? Nothing or should I raise the DoS score?\n - \"The Re-Keying must be done after every 1GB of data sent or received\" Hm, every peer updates its\n own sending key, so this should just read \"sent\" instead of \"sent or received\"?\n\nPseudocode could probably help here.\n\n[1] https://eprint.iacr.org/2014/043.pdf"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2018-09-07T02:31:15",
                "message_text_only": "On Thu, Sep 6, 2018 at 11:33 PM Tim Ruffing via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Now you can argue that the attacker is storing encrypted traffic today to decrypt it later.\n\nThat is the argument. We know for that state level parties are storing\nunimaginable amounts of data for future decryption, that threat isn't\ntheoretical.\n\n> Sure,\n> but if that's your threat model then Bitcoin is probably not the right tool for you. (And if\n\nWhy not?\n\n> you insist that Bitcoin is the right tool, then you can and probably should use it over Tor\n> anyway.)\n\nCurrently, Tor provides _no confidentiality at all_ in that threat\nmodel.  Part of why I think this enhancement is interesting is because\nwithout it BIP151 doesn't actually add anything for those p2p\nconnections running over Tor, but with it -- it at least adds some\nlong term confidentiality hedge.\n\n> It's not worth the hassle, would hinder adoption,\n\nWhy do you say this?\n\n> impression of \"bulletproof\" security. Even worse, there will be too many people that will suddenly\n> assume that Bitcoin is post-quantum secure.\n\nPeople already make that claim with respect to public key hashing.  I\ndon't think \"we shouldn't improve security because someone will\nmistake an improvement for perfection\" is an an especially interesting\nargument.\n\n> Key exchange indistinguishable from random\n> ==========================================\n> I would rather love to see a simple ECDH key exchange as currently used but with an encoding of\n> public key that provides indistinguishability from random bitstrings. \"Elligator\" does not work\n> but \"Elligator Squared\" [1] does the job for secp256k1 -- it just doubles the size of the public\n\nHere is where I turn the argument around on you:   This requires\nwriting a non-trivial amount of moderately complex new cryptographic\ncode (which is not the case for PQ schemes-- that merely requires\ndropping in pre-existing code) and yet I am not aware of any attack\nmodel that this which would any improvement in actually delivered\nsecurity:  Bitcoin traffic is _trivially_ identifiable by its traffic\npatterns.\n\n(Blockstream  previously wrote the SW forward transform for asset\ngeneration, but this requires the inverse too, as well as glue code.\nIt also isn't clear to me if it's possible to make this construction\nconstant time, which would be okay for BIP151 purposes but if we\nwanted to have a generic uniform encoder in libsecp256k1 I think we'd\nprefer it be constant time? maybe?)\n\nThe scheme in the BIP thus far achieves the property that there are no\nfixed bytes for brain-dead byte matching DPI traffic filtering or\nanti-virus to match on (or accidentally false positive on).  AV false\npositives are already an existing problem with the current protocol\nand any fixed bytes in the communication are at risk for false\npositives or targeted filtering.   And achieving that property\nrequires basically nothing: a test for the first byte of a generated\nserialized pubkey and a negate on the private key if it was wrong.\n\n> key. Together with the encrypted packet lengths, the entire data stream looks like random then,\n\nNo, it doesn't-- due to traffic analysis.  Including, for example, the\npattern that 64-bytes must be sent in each direction, before further\ndata continues, bursts of traffic coinciding with blocks newly found\non the network, etc.\n\nI don't believe that indistinguishable keys are actually useful\noutside of the context of things like stegnographic embedding-- cases\nwhere protocol 'metadata' doesn't tell you that a key is there\nregardless.\n\nI suppose if the code already existed to do it I might as well go\n\"okay, sure why not\", it's not going to harm anything (the added\ncomputation time to generate the uniform encoding would probably be no\nmore than a 10% slowdown).  I wouldn't argue against it on the basis\nthat someone might believe it resulted in anti-censorship properties\nthat it doesn't have ... even though it's clearly the case... because\nI categorically reject that form of argument. :)\n\nI think your view on the two distinctive proposals is askew: PQ\nagreement has a clear benefit under a plausible threat model and is\nquite easy to implement... while uniform encoding is somewhat harder\nto implement (though admittedly not very hard) but doesn't appear to\nprovide a concrete benefit under any threat model that I'm currently\naware of...\n\n> The key derivation can be improved. It should include each peer's understanding of its role,\n> i.e., requester (or \"initiator\" is the more common term) or responder. At the moment, an attacker\n> can create a situation where two peers think they're in the same session (with the same session\n> id) but they're actually not. Also, it's possible for an attacker to rerandomize the public keys.\n> That's nothing bad by itself but anything which restricts the flexibility of the attacker without\n> adding complexity is a good idea. Something like\n>    \"salt = BitcoinSharedSecret||INITIATOR_PUBKEY||RESPONDER_PUBKEY\" should just avoid this issue.\n\nI also prefer the contributory key model, but Pieter proved me on IRC\nlast week that the attack form that I was concerned about was not\npossible.\n\nDo you actually have an attack in mind that you can spell out here?  I\ndon't see a harm in changing that, but given that I'd already twice\ntalked myself out of proposing the same thing, I'd like to understand\nif I'm missing something. :)\n\n> Re-keying\n> =========\n> The problem with signalling re-keying in the length field is that the length field is not covered\n> by the MAC.\n\nIt's AAD data in the mac, unless I misunderstand the protocol.\n\n> Deterministic rekeying rules may be better. Otherwise there will be implementations that rekey\n> every 10 seconds\n\nThat would be pretty harmless, since the rekeying operation costs\nsimilar to one message decryption.\n\n> and implementations that just don't rekey at all (rendering the 10 s rekeying\n> interval in the opposite direction useless).\n\nThe protocol requires rekeying at least after a given amount of data\nis transmitted. Peers that violate that can be disconnected. But it\ncould be unfortunately infrequent.\n\n> Different policies also make it possible to\n> fingerprint implementations.\n\nI agree that is a good point.\n\nPersonally I'd prefer that we used a ciphersuite that effectively\n\"rekeyed\" every message-- along the lines of the constructions\ndescribed https://blog.cr.yp.to/20170723-random.html   Unfortunately I\nwas unable to find _any_ well analyized  authenticated encryption mode\nthat has the fast erasure property.   It's too bad because it would be\ntrivial to adhoc one (e.g. use the extra 32 bytes from the poly1305\nchacha run to update the keys for the next message).\n\n> What's better: 5 min or 30 min? I don't know, but both are reasonable choices. (Thats's very much\n\nIt doesn't much matter, except for fingerprinting reasons.\n\n> like discussions about ciphers... What's better AES-GCM or ChaCha20/Poly1305? I don't know, but\n> again both are reasonable choices.)\n\nHere we have a very clear motiviation.  On devices without hardware\nAES/clmul constant time AES-GCM is _terribly slow_ compared to\nChaCha20/Poly1305. Performance on the slowest devices is where the\nthe ones where the ciphersuite choice likely matters at all (because\nit could actually make a meaningful difference in their system's\nability to keep up), and the slowest devices that I'm aware of users\ncommonly using are also devices without good AES-GCM performance.\nUnfortunately.\n\nOn fast desktop hardware the performance of AES-GCM and\nChaCha20/Poly1305 is also fairly close.\n\nSo when it matters, chacha20/poly1305 is higher performance by a wide\nmargin.  (Too bad, because otherwise I'd much rather use AES-GCM)\n\n> I didn't think about this in detail: maybe there are a few meaningful cases where padding could\n> hide the message length without too much overhead. (I'm not convinced, just a random thought.)\n\nThis can be done at the message level. E.g. new TX messages that round\ntx sizes up to the next multiple. I don't think useful low overhead\npadding is otherwise possible.\n\n\n> written in stone, again to avoid complexity and to avoid fingerprinting.\n\nWriting things in stone is a great way to never finish a protocol.\nRight now we know we have new upcoming proposals for messages where\nthe overhead matters, e.g. we need a replacement addr message ASAP,\nand there is ongoing work for transaction relay that would also\nbenefit from low overhead.\n\nThe norm in Bitcoin is to ignore messages you don't know how to parse\nanyways,  so there is no complexity that arises from \"may negotiate\"\nitself-- only from actually making use of that possibility in the\nfuture, so the merits of any particular usage could be decided when\nsomething wants to actually use it.  The purpose of pointing out \"may\nnegotiate\" is, I think, primarily to avoid a debate about who would\nassign numbers from this limited space in the future-- and the answer\njust is that they're implementation defined (e.g. by the BIPs using\nthem).\n\n> necessary anyway, so maybe just use IDs for anything? ASCII is nice if you want to debug your code\n> or some random network failure but that's hard anyway when encryption is used.\n\nRight, encryption kills external analysers in any case. It's also easy\nto just logprintf traffic (this is open source software after all),\nwhich doesn't have a decoding problem.\n\n>  - \"The Re-Keying must be done after every 1GB of data sent or received\" Hm, every peer updates its\n>  own sending key, so this should just read \"sent\" instead of \"sent or received\"?\n\nI think it says 'received there' mostly because it's implicitly\ntelling you that you can hang up on someone who violates it. I agree\nit would be more consistent to express it sending side there."
            },
            {
                "author": "Jonas Schnelli",
                "date": "2018-09-07T08:34:13",
                "message_text_only": "Hi Tim\n\nThanks for the feedback.\n\nI agree with all of Gregs answers.\n\n> key. Together with the encrypted packet lengths, the entire data stream looks like random then,\n> which is pretty useful against censorship resistance for example. (The only exception is that the\n> stream will never start with the magic bytes.)\n\nAll-or-none censorship attacks are out of scope for BIP151.\nWe won\u2019t achieve DPI robustness in this proposal and I think it should not be part of the p2p protocol.\n\nI think all-or-one censorship situations require an additional layer like TOR with OBFS4 (where AFAIK Eligator is used).\nEventually Core does directly support non-tor routed pluggable transports (it's partially already possible via SOCK proxy, but not on a gossip and plugin-launch level).\n\nThis does not exclude that we should obfuscate the key exchange as good as we can without blowing up the implementation too much.\n\nThe proposed encryption adds a robustness to the thread model with very little costs and low risks.\n\n>   \"salt = BitcoinSharedSecret||INITIATOR_PUBKEY||RESPONDER_PUBKEY\" should just avoid this issue.\n\nThis is a good point and I\u2019d like to see more concrete examples how this (the non dynamic salt) could be exploited.\n\n> Re-keying\n> =========\n> The problem with signalling re-keying in the length field is that the length field is not covered\n> by the MAC. So the attacker can flip the signalling bit. The resulting protocol is probably still\n> secure but the malleability is certainly not desirable.\n\nIn ChaCha20Poly1305 at openssh, the length field is AAD, encrypted with a different key and part of the MAC.\n\n> \n> Deterministic rekeying rules may be better. Otherwise there will be implementations that rekey\n> every 10 seconds and implementations that just don't rekey at all (rendering the 10 s rekeying\n> interval in the opposite direction useless). Different policies also make it possible to\n> fingerprint implementations. Another problem is that people will set their policies arbitrarily.\n> What's better: 5 min or 30 min? I don't know, but both are reasonable choices. (Thats's very much\n> like discussions about ciphers... What's better AES-GCM or ChaCha20/Poly1305? I don't know, but\n> again both are reasonable choices.)\n\nThe Rekey cost is two times a double-SHA256,\u2026 the costs of a rekey is similar to one or two v1 INV message creations.\n\n> \n> Symmetric crypto\n> ================\n> You call it chacha20-poly1305 at bitcoin but what's the difference to the openssh then? Is the\n> idea to save a call to chacha here as you mentioned?\n> \n> I didn't think about this in detail: maybe there are a few meaningful cases where padding could\n> hide the message length without too much overhead. (I'm not convinced, just a random thought.)\n\nI think a new message type that could contain message + pad would be trivial.\nWould this again be to obfuscate traffic patterns? Anti DPI is not the scope of BIP151.\n\n> \n> Misc\n> ====\n> \"The ID/string mapping is a peer to peer arrangement and MAY be negotiated between the\n> requesting and responding peer.\" I think that's overly complicated. I suggest it should just be\n> written in stone, again to avoid complexity and to avoid fingerprinting. New implementations are\n> necessary anyway, so maybe just use IDs for anything? ASCII is nice if you want to debug your code\n> or some random network failure but that's hard anyway when encryption is used.\n\nI wanted to avoid too much central planing here and only cover the ones where it's most efficient (small messages that are used often).\nThe ASCII commands are in itself somehow pseude-robust against collision.\nFor a 1MB block message, using a 1-byte short ID (rather then a 6-byte ASCII command) would reduce the bandwidth requirement insignificant (99.99952%).\n\nIf we would always have used short IDs in the past, there could have been a collision between XTIN, compact, sendheaders or so.\n\n> \n> In general, the entire thing is a little bit underspecified. (I'm aware it's just a draft.)\n> A few examples:\n> - What should a peer do if the MAC verification fails?\n> - What should a peer do if it receives an even key?\n> - \"Processing the message before the authentication succeeds (MAC verified) MUST not be done.\"\n> That should also apply to the ciphertext. (Or: What is a \"message\"?). It may be a good idea to\n> to refer to the openssh document or steal from it; it does a pretty good job.\n> - \"Both peers MUST keep track of the message sequence number (uint32) of sent and received\n> messages for building a 64-bit symmetric cipher IV.\" I think you mean nonce when you say IV?\n> - What is the initial value of the sequence number?\n\nGood points. Will make them more clear in the BIP.\nI was under the false impression that it is obvious to disconnect in those cases.\n\n> - How is a 64-bit nonce formed from one (two?) uint32?\n\nThat\u2019s specified in ChaCha20Poly1305 at openssh (\"a nonce consisting of the packet sequence number encoded as a uint64\u201c).\nBut I\u2019ll specified that more clear.\n\n> - What if the uint32 overflows?\n\nThe max data before rekey is 1GB, AFAIK it is impossible to overflow.\n\n> - \"Re-Keying interval is a peer policy with a minimum timespan of 10 seconds.\" What if I receive\n> too many re-keying requests? Nothing or should I raise the DoS score?\n\nCurrent implementation proposal does a disconnect. With the risk of fingerprinting options, I think we can leave this open to the implementation?\n\n> - \"The Re-Keying must be done after every 1GB of data sent or received\" Hm, every peer updates its\n> own sending key, so this should just read \"sent\" instead of \"sent or received\u201c?\n\nYes. Should probably be \u201esent\u201c,\u2026 and eventually a paragraph that states that a peer should disconnect if the remote peer did not rekey within that limit.\n\n> Pseudocode could probably help here.\n\nAgree. Will try to add.\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180907/348e23e8/attachment.sig>"
            },
            {
                "author": "Tim Ruffing",
                "date": "2018-09-07T13:00:08",
                "message_text_only": "On Fri, 2018-09-07 at 02:31 +0000, Gregory Maxwell wrote:\n> Currently, Tor provides _no confidentiality at all_ in that threat\n> model.  Part of why I think this enhancement is interesting is\n> because\n> without it BIP151 doesn't actually add anything for those p2p\n> connections running over Tor, but with it -- it at least adds some\n> long term confidentiality hedge.\n> \nOkay, sure, I was assuming that Tor will deploy it at some point. No\nidea what the status is.\n\n> > It's not worth the hassle, would hinder adoption,\n> \n> Why do you say this?\nMy assumption is that NewHope is harder to implement. If you just \ndrop-in existing code, it's not. And I've neither implemented NewHope\nnor Elligator Squared, so I may just be wrong.\n\n> \n> > impression of \"bulletproof\" security. Even worse, there will be too\n> > many people that will suddenly\n> > assume that Bitcoin is post-quantum secure.\n> \n> People already make that claim with respect to public key hashing.  I\n> don't think \"we shouldn't improve security because someone will\n> mistake an improvement for perfection\" is an an especially\n> interesting\n> argument.\n\nI don't like the argument either but I think it's real.\n\n> (Blockstream  previously wrote the SW forward transform for asset\n> generation, but this requires the inverse too, as well as glue code.\n> It also isn't clear to me if it's possible to make this construction\n> constant time, which would be okay for BIP151 purposes but if we\n> wanted to have a generic uniform encoder in libsecp256k1 I think we'd\n> prefer it be constant time? maybe?)\nNo idea if it can be made constant time but yeah I think it's not\ncrucial in this case.\n\n> \n> I don't believe that indistinguishable keys are actually useful\n> outside of the context of things like stegnographic embedding-- cases\n> where protocol 'metadata' doesn't tell you that a key is there\n> regardless.\n\nI wasn't specific but my point is that these are indeed interesting\nfuture directions. You can easily make the traffic look like any other\nprotocol which uses encryption. That's a really useful property if you\nwant to avoid censorship, even if traffic analysis still works. That's\ntrue even if this it's not in the scope of this BIP, which is of course\nthe case.\n\nIf you ask me, that is more interesting than protecting against\npotential decryption of P2P connections in a few decades. But I don't\nhave a definitive argument for this of course.\n\n\n> I also prefer the contributory key model, but Pieter proved me on IRC\n> last week that the attack form that I was concerned about was not\n> possible.\n> \n> Do you actually have an attack in mind that you can spell out\n> here?  I\n> don't see a harm in changing that, but given that I'd already twice\n> talked myself out of proposing the same thing, I'd like to understand\n> if I'm missing something. :)\n\nI don't have a harmful example but here is harmless one (that you\nprobably know because it's really the simplest one can think of):\n\nA             M             B \n   -- aG -->\n                 <-- bG --\n                  -- aG -->\n  <-- bG --\n\nNow A and B share the same session id but any attempt to communicate\nwill fail because they both think that they're the initiator. Of course\nthat's not a big deal because M is in neither of those sessions. So\nit's not an attack but it's a weird property of the key exchange. But I\nthink it's desirable to avoid such things if the cost to do so is very\nlow.\n\nAlso, here is a better argument:\n\nA             M             B \n   -- aG -->\n                 <-- bG --\n  <-- xG --\n                  -- yG -->\n\nAfter B's message, M's goal is create a collision of the session ids.\nSince M can freely choose x and y, that's a birthday attack on the hash\nfunction and needs 2^(l/2) work if the session id is l bits long.\n\nTelegram has (had?) the same issue:\nhttps://www.alexrad.me/discourse/a-264-attack-on-telegram-and-why-a-super-villain-doesnt-need-it-to-read-your-telegram-chats.html\n\nWith the other variant, M cannot collect both aG and bG upfront:\n\nA             M             B \n   -- aG -->\n                  -- yG -->\n                 <-- bG --\n  <-- xG --\n\nNow M can only choose x, so this is a second-preimage attack and takes\n2^l work. So with the this variant, you can have a session id that's\nonly half the size. That's a real difference if session ids are meant\nto be comparable by humans, e.g., over the phone. \n\n(I think) it's possible to even go further with a 3-way handshake:\nA                M                B \n   -- H(aG) -->\n                    -- H(yG) -->\n                   <--  bG   --\n  <--  xG   --\n   --  aG   -->\n                    --  yG   -->\n\nHere M has no flexibility at all, so the probability of a successful\nattack against a single key exchange is just 2^(-l). This is similar to\nZRTP. I'm not saying that we should do this, it's something worth\nnoting that.\n\n  \n> \n> > Re-keying\n> > =========\n> > The problem with signalling re-keying in the length field is that\n> > the length field is not covered\n> > by the MAC.\n> \n> It's AAD data in the mac, unless I misunderstand the protocol.\n\nOh nevermind.\n\n> Personally I'd prefer that we used a ciphersuite that effectively\n> \"rekeyed\" every message-- along the lines of the constructions\n> described https://blog.cr.yp.to/20170723-random.html   Unfortunately\n> I\n> was unable to find _any_ well analyized  authenticated encryption\n> mode\n> that has the fast erasure property.   It's too bad because it would\n> be\n> trivial to adhoc one (e.g. use the extra 32 bytes from the poly1305\n> chacha run to update the keys for the next message).\n\nThat adhoc construction is a very interesting idea. Hm... Just fyi, the\nclosest that comes to my mind is:\nhttps://core.ac.uk/download/pdf/20880831.pdf\n\n> The norm in Bitcoin is to ignore messages you don't know how to parse\n> anyways,  so there is no complexity that arises from \"may negotiate\"\n> itself-- only from actually making use of that possibility in the\n> future, so the merits of any particular usage could be decided when\n> something wants to actually use it.  The purpose of pointing out \"may\n> negotiate\" is, I think, primarily to avoid a debate about who would\n> assign numbers from this limited space in the future-- and the answer\n> just is that they're implementation defined (e.g. by the BIPs using\n> them).\n\nYeah, my point was not to write the entire list in stone. That was not\nreally clear from my message, sorry. Of course, new message types can\nbe added later. But I don't see a big advantage in allowing both ASCII\nstrings and short IDs. So I wanted to say that the usage of short IDs\nshould be written stone.\n\nOn Fri, 2018-09-07 at 10:34 +0200, Jonas Schnelli wrote:\n> \n> > I didn't think about this in detail: maybe there are a few\n> meaningful cases where padding could\n> > hide the message length without too much overhead. (I'm not\n> convinced, just a random thought.)\n> \n> I think a new message type that could contain message + pad would be\n> trivial.\n> Would this again be to obfuscate traffic patterns? Anti DPI is not\n> the scope of BIP151.\n\nWell, it's indeed to obfuscate traffic patterns but primarily for\nconfidentiality. If I see the length of the message, I can guess the\nmessage type fairly well for example. (That's not no matter if my goal\nas an attacker is to break your privacy or to censor your connection.\nOf course more confidentiality helps also against DPI/censorship but\nthat was not my point here.)\n\n> I was under the false impression that it is obvious to disconnect in\n> those cases.\n\nYeah I think it's by far the most natural thing to do but it may be\nbetter to make it explicit.\n\nTim"
            }
        ],
        "thread_summary": {
            "title": "Overhauled BIP151",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tim Ruffing",
                "Eric Voskuil",
                "Gregory Maxwell",
                "Jonas Schnelli"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 36172
        }
    },
    {
        "title": "[bitcoin-dev] SIGHASH2 for version 1 witness programme",
        "thread_messages": [
            {
                "author": "Christian Decker",
                "date": "2018-09-03T13:53:33",
                "message_text_only": "Johnson Lau <jl2012 at xbt.hk> writes:\n\n> Great, I\u2019ll revise it.\n>\n> Follow-up questions:\n>\n> 1. Is there any useful case which one would like to use NOINPUT with\n> scriptCode and/or scriptPubKey committed? (Note that with\n> taproot/MAST, scriptCode and scriptPubKey are not\n> interchangeable. scriptPubKey commits to all branches, and scriptCode\n> is just one script branch). If yes, we could make this configurable.\n\nThere is the poor man's malleability fix that you get if you make only\nthe previous outpoint rewritable, but that use-case is better covered by\nsegwit already, and since both of our proposals would be for segwit\noutputs only, I don't see a point in doing that.\n\n> 2. Which of the following approaches is better?\n> A) sign scriptPubKey in every cases except NOINPUT\n> B) sign the type (P2SH-segwit vs. Native-segwit) of scriptPubKey in every cases, including NOINPUT\n> C) all of the above\n> D) none of the above\n\nWhat do we effectively gain by committing to the scriptPubkey type? Is\nthe concern here that we might run into ambiguity about whether this is\na MAST, P2SH, or similar output, allowing an attacker to sideload\nunwanted effects?\n\n> Option B is very easy to implement as SignatureHash() could\n> distinguish the type by the size of scriptSig in TxTo. Option A is\n> more complicated as GenericTransactionSignatureChecker needs to know\n> the scriptPubKey.\n>\n> If the only reason for doing this is to allow hardware wallet to\n> distinguish the segwit type, option B is probably enough. This is also\n> compatible with eltoo.\n\nAgreed on compatibility :-)\n\n> Option A is useful when a hardware wallet reuses the same public key\n> in different scripts, but it couldn\u2019t be applied to NOINPUT\n>\n> 3. Is the proposed DUALOUTPUT somehow useful for eltoo? Eltoo use\n> NOINPUT|SINGLE to allow fee pumping, since it is an\n> one-input-one-output tx. This is not possible with the existing LN as\n> the tx is one-input-two-output. If we had DUALOUTPUT which signs the\n> matched and last output, fee-pumping would be possible in the existing\n> LN.\n\nThat's a very strange concept, but it strongly relies on the structure\nof the commitment, having two outputs. As soon as we have HTLCs included\nin the commitment we no longer have 2 outputs (2 for the endpoints, and\n1 as a base for the two-phase HTLC resolution), so this would be a\nrather brittle fix or would require major restructuring of LN imho.\n\nCheers,\nChristian"
            }
        ],
        "thread_summary": {
            "title": "SIGHASH2 for version 1 witness programme",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Christian Decker"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2427
        }
    },
    {
        "title": "[bitcoin-dev] Extending BIP174 for HTLCs",
        "thread_messages": [
            {
                "author": "Alex Bosworth",
                "date": "2018-09-04T03:24:01",
                "message_text_only": "I've been experimenting with a format tag for BIP 174 to help support\nHTLC scripts I've been working with.\n\nNot sure on the best format for this, but what I have been thinking\nabout is a new input type that defines elements that should be\ninserted in the final p2sh/p2wsh stack such as a preimage or a refund\npath flag.\n\nType: Additional Stack Element ADDITIONAL_STACK_ELEMENT = 0xXX\n\nKey: The index in the stack to insert a value (uint32 LE)\n\n{0xXX}|{Stack index}\n\nValue: The value to push into the stack for a redeem script or witness\nscript at the specified index.\n\n{value}\n\nSo my flow is:\n\n1. Create blank PSBT (attaching locktime, anticipating final weight to\nadjust outputs for fees)\n2. Update with redeem scripts and/or witness scripts\n3. Update with sighashes\n4. Sign: generate partial signature\n5. Attach additional stack elements for the required non-signature elements\n6. Finalize to create the final scriptsig and/or witness\n7. Extract the signed transaction for broadcast\n\nThis may be overkill or overly generic, has anyone else thought of how\nto use PSBTs in an HTLC context?\n\n-- \nSent from my iPhone"
            },
            {
                "author": "Pieter Wuille",
                "date": "2018-09-04T16:57:28",
                "message_text_only": "On Tue, Sep 4, 2018, 04:32 Alex Bosworth via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I've been experimenting with a format tag for BIP 174 to help support\n> HTLC scripts I've been working with.\n>\n\nI've been thinking about this as well.\n\nA useful way to look at it IMHO is to see a hash as the analogue of a\npublic key, and the preimage as the analogue of a signature.\n\nThat would suggest adding two fields to PSBT:\n* A request for the preimage of a given hash (similar to the pubkey/path\nfield currently)\n* A revealed preimage for a given hash (similar to the partial signature\nfield currently).\n\nThe workflow would in this case would be:\n* An updater recognizes an output/script as being one that requires a\npreimage, and adds a preimage request field to the input (along with pubkey\nfields for all involved keys).\n* A \"signer\" who knows the preimage sees the request field, verifies he's\nwilling to divulge the secret, and adds a preimage field (along with any\nsignatures he may be able to create).\n* A finalizer who is compatible with the type of hashlock script combines\nall signatures and preimages into a final scriptSig/witness stack.\n\nAn obvious difficulty is having updaters and finalizers which are\ncompatible with all possible variations of hashlocks and other scripts.\n\nNot sure on the best format for this, but what I have been thinking\n> about is a new input type that defines elements that should be\n> inserted in the final p2sh/p2wsh stack such as a preimage or a refund\n> path flag.\n>\n\nThat's one approach to reducing the complexity of the finalizer: adding\ninformation about the composition of the scriptSig to the PSBT itself.\nHowever, I don't think that approach scales very well (you'd need new\nfields for all kinds of new script constructions). In particular, dealing\nwith multiple possible satisfactions may complicate things, especially when\nthe number of combinations is intractable.\n\nI've been working on another approach that doesn't involve changes to PSBT,\nbut instead uses an easily-parsable subset of script (which includes\nand/or/threshold/pubkey/locktimes/hashlocks). I hope to publish something\nsoon about it.\n\nCheers,\n\n-- \nPieter\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180904/5dd946d0/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Extending BIP174 for HTLCs",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Pieter Wuille",
                "Alex Bosworth"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3487
        }
    },
    {
        "title": "[bitcoin-dev] A BIP proposal for transactions that are 'cancellable'",
        "thread_messages": [
            {
                "author": "Alejandro Ranchal Pedrosa",
                "date": "2018-09-06T09:19:24",
                "message_text_only": "Hello everyone,\n\nWe would like to propose a new BIP to extend OP_CSV (and/or OP_CLTV) in\norder for these to allow and interpret negative values. This way,\ntaking the example shown in BIP 112:\n\nHASH160 <revokehash> EQUAL\nIF\n \u00a0\u00a0\u00a0 <Bob's pubkey>\nELSE\n \u00a0\u00a0\u00a0 \"24h\" CHECKSEQUENCEVERIFY DROP\n \u00a0\u00a0\u00a0 <Alice's pubkey>\nENDIF\nCHECKSIG\n\nthat gives ownership only to Bob for the first 24 hours and then to\nwhichever spends first, we basically propose using the negative bit value:\n\nHASH160 <revokehash> EQUAL\nIF\n \u00a0\u00a0\u00a0 <Bob's pubkey>\nELSE\n \u00a0\u00a0\u00a0 \"-24h\" CHECKSEQUENCEVERIFY DROP\n \u00a0\u00a0\u00a0 <Alice's pubkey>\nENDIF\nCHECKSIG\n\nmeaning that both would have ownership for the first 24 hours, but\nafter that only Bob would own such coins. Its implementation should\nnot be too tedious, and in fact it simply implies considering negative\nvalues that are at the moment discarded as for the specification of\nBIP-112, leaving the sign bit unused.\n\nThis, we argue, an increase the fairness of the users, and can at times\nbe more cost-effective for users to do rather than trying a Replace-By-Fee\ntransaction, should they want to modify such payment.\n\nWe would like to have a discussion about this before proposing the\nBIP, for which we are preparing the text.\n\nYou can find our paper discussing it here:\nhttps://hal-cea.archives-ouvertes.fr/cea-01867357 (find attached as well)\n\nBest,\n\n-- \nAlejandro Ranchal Pedrosa, \u00d6nder G\u00fcrcan and Sara Tucci-Piergiovanni\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: Gurcan2018. On Cancellation of Transactions in Bitcoin-like Blockchains.pdf\nType: application/pdf\nSize: 785407 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180906/187528f6/attachment-0001.pdf>"
            },
            {
                "author": "Matt Corallo",
                "date": "2018-09-06T13:31:58",
                "message_text_only": "I think a simple approach to what you want to accomplish is to simply have a multisig option with a locktime pre-signed transaction which is broadcastable at the 24h mark and has different spendability. This avoids introducing reorg-induced invalidity.\n\nOn September 6, 2018 9:19:24 AM UTC, Alejandro Ranchal Pedrosa via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>Hello everyone,\n>\n>We would like to propose a new BIP to extend OP_CSV (and/or OP_CLTV) in\n>order for these to allow and interpret negative values. This way,\n>taking the example shown in BIP 112:\n>\n>HASH160 <revokehash> EQUAL\n>IF\n> \u00a0\u00a0\u00a0 <Bob's pubkey>\n>ELSE\n> \u00a0\u00a0\u00a0 \"24h\" CHECKSEQUENCEVERIFY DROP\n> \u00a0\u00a0\u00a0 <Alice's pubkey>\n>ENDIF\n>CHECKSIG\n>\n>that gives ownership only to Bob for the first 24 hours and then to\n>whichever spends first, we basically propose using the negative bit\n>value:\n>\n>HASH160 <revokehash> EQUAL\n>IF\n> \u00a0\u00a0\u00a0 <Bob's pubkey>\n>ELSE\n> \u00a0\u00a0\u00a0 \"-24h\" CHECKSEQUENCEVERIFY DROP\n> \u00a0\u00a0\u00a0 <Alice's pubkey>\n>ENDIF\n>CHECKSIG\n>\n>meaning that both would have ownership for the first 24 hours, but\n>after that only Bob would own such coins. Its implementation should\n>not be too tedious, and in fact it simply implies considering negative\n>values that are at the moment discarded as for the specification of\n>BIP-112, leaving the sign bit unused.\n>\n>This, we argue, an increase the fairness of the users, and can at times\n>be more cost-effective for users to do rather than trying a\n>Replace-By-Fee\n>transaction, should they want to modify such payment.\n>\n>We would like to have a discussion about this before proposing the\n>BIP, for which we are preparing the text.\n>\n>You can find our paper discussing it here:\n>https://hal-cea.archives-ouvertes.fr/cea-01867357 (find attached as\n>well)\n>\n>Best,\n>\n>-- \n>Alejandro Ranchal Pedrosa, \u00d6nder G\u00fcrcan and Sara Tucci-Piergiovanni\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180906/4ff7a84e/attachment-0001.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2018-09-06T15:16:34",
                "message_text_only": "Functionality such as this does not currently exist not because no one\nthought of it before, but because it has been proposed many times\nbefore and determined to be harmful.  The existing design of CLTV/CSV\nwere carefully constructed to make it impossible for a transaction to\ngo from valid to invalid based on the time. The most naive\nconstruction-- e.g. push the current time/height on the stack-- would\nhave that property and was specifically avoided.\n\nWhen a spend goes from valid to invalid it means that a reorganization\nwill destroy coins even completely absent any dishonest actions of the\ncoins prior owner in the coins recent casual history. Effectively a\ncoin with any kind of non-monotone validity event in its recent\nhistory functions like a recently generated coin: a coin that reorgs\ndestroy. Bitcoin addresses the issue for recently generated coins by\nnot permitting their use for 100 blocks.  I've yet to see an argument\nfor a use case for non-monotone validity that still sounds useful once\nthe negative effects are addressed (e.g. by subjecting coins that have\ngone through them to a maturity limitation)."
            },
            {
                "author": "Brandon Smith",
                "date": "2018-09-06T20:32:44",
                "message_text_only": "I made a similar proposal about 7 months ago, and documented some of the\ndiscussion points here:\n\nhttps://github.com/reardencode/bips/blob/reverselocktime/bip-0zzz.mediawiki\n\nOn 2018-09-06 (Thu) at 15:16:34 +0000, Gregory Maxwell via bitcoin-dev wrote:\n> Functionality such as this does not currently exist not because no one\n> thought of it before, but because it has been proposed many times\n> before and determined to be harmful.  The existing design of CLTV/CSV\n> were carefully constructed to make it impossible for a transaction to\n> go from valid to invalid based on the time. The most naive\n> construction-- e.g. push the current time/height on the stack-- would\n> have that property and was specifically avoided.\n> \n> When a spend goes from valid to invalid it means that a reorganization\n> will destroy coins even completely absent any dishonest actions of the\n> coins prior owner in the coins recent casual history. Effectively a\n> coin with any kind of non-monotone validity event in its recent\n> history functions like a recently generated coin: a coin that reorgs\n> destroy. Bitcoin addresses the issue for recently generated coins by\n> not permitting their use for 100 blocks.  I've yet to see an argument\n> for a use case for non-monotone validity that still sounds useful once\n> the negative effects are addressed (e.g. by subjecting coins that have\n> gone through them to a maturity limitation).\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Terry McLaughlin",
                "date": "2018-09-07T05:02:29",
                "message_text_only": "Please help me guide me in the direction I need to go\n\nOn Thursday, September 6, 2018, Brandon Smith via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I made a similar proposal about 7 months ago, and documented some of the\n> discussion points here:\n>\n> https://github.com/reardencode/bips/blob/reverselocktime/bip-0zzz.\n> mediawiki\n>\n> On 2018-09-06 (Thu) at 15:16:34 +0000, Gregory Maxwell via bitcoin-dev\n> wrote:\n> > Functionality such as this does not currently exist not because no one\n> > thought of it before, but because it has been proposed many times\n> > before and determined to be harmful.  The existing design of CLTV/CSV\n> > were carefully constructed to make it impossible for a transaction to\n> > go from valid to invalid based on the time. The most naive\n> > construction-- e.g. push the current time/height on the stack-- would\n> > have that property and was specifically avoided.\n> >\n> > When a spend goes from valid to invalid it means that a reorganization\n> > will destroy coins even completely absent any dishonest actions of the\n> > coins prior owner in the coins recent casual history. Effectively a\n> > coin with any kind of non-monotone validity event in its recent\n> > history functions like a recently generated coin: a coin that reorgs\n> > destroy. Bitcoin addresses the issue for recently generated coins by\n> > not permitting their use for 100 blocks.  I've yet to see an argument\n> > for a use case for non-monotone validity that still sounds useful once\n> > the negative effects are addressed (e.g. by subjecting coins that have\n> > gone through them to a maturity limitation).\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180907/3fc1ce9c/attachment.html>"
            },
            {
                "author": "Alejandro Ranchal Pedrosa",
                "date": "2018-09-07T07:12:40",
                "message_text_only": "Hi all,\n\nThank you for the link, and also to Gregory for the remarks. I did not \nknow about this previous proposal. I think the last paragraph of future \nwork is interesting:\n\n\"It may be interesting to add enhance OP_CHECKSEQUENCEVERIFY \n<https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki> to \nallow outputs that are spendable by Alice until time foo, always \nspendable by Bob, and spendable by Joe only after time bar, or other \nsuch cases\"\n\nPerhaps it would allow this functionality, while keeping the validity of \ncoins, if the new OP_zzz took an additional argument than suggested, \nsuch that the first one is the timelimit for Alice to keep the coin (say \nin the first 24 hours), and after those 24 hours the ownership goes to \nthe third argument, say Bob.\n\nThat is, it is not possible to use only specifying the owner in the \nfirst 24 hours. Would this be considered harmful?\n\nBest,\n\nAlejandro.\n\nOn 9/6/18 10:32 PM, Brandon Smith wrote:\n> ade a similar proposal about 7 months ago, and documented some of the\n> discussion points here:\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180907/f3f28537/attachment.html>"
            },
            {
                "author": "Brandon Smith",
                "date": "2018-09-07T12:51:35",
                "message_text_only": "I believe you may be missing the overall points in the \"Nail In the\nCoffin\" and \"Temporary Discussion\" sections. In summary:\n\n1: Any UTXO spending a script with an expiration must be treated\nsimilarly to Coinbase (I proposed a solution to this, but it's complex\nand may have unforeseen implications).\n\n2: All existing software assumes that a transaction once valid stays\nvalid. Any proposal to change this must ensure that existing wallets and\nusers aren't immediately open to being scammed by malicious actors\nsending low fee expiring transactions.\n\nThe more tenable ways to move forward on improving the ecosystem around\ndelayed transactions and refunds are: Lightning, improved fee\nestimation, and improved mempool eviction / re-propagation resistance.\n\nThe original reason that I began looking into this is because I noticed\nthat during high fee periods, transactions could re-propagate between\nmempools of differing policies resulting in coins being stuck unusable\nfor far longer than the expected 1-2 week eviction. I don't know of any\nconcrete work going into investigating or improving this.\n\nHTH,\n\n--Brandon\n\nOn 2018-09-07 (Fri) at 09:12:40 +0200, Alejandro Ranchal Pedrosa wrote:\n> Hi all,\n> \n> Thank you for the link, and also to Gregory for the remarks. I did not \n> know about this previous proposal. I think the last paragraph of future \n> work is interesting:\n> \n> \"It may be interesting to add enhance OP_CHECKSEQUENCEVERIFY \n> <https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki> to \n> allow outputs that are spendable by Alice until time foo, always \n> spendable by Bob, and spendable by Joe only after time bar, or other \n> such cases\"\n> \n> Perhaps it would allow this functionality, while keeping the validity of \n> coins, if the new OP_zzz took an additional argument than suggested, \n> such that the first one is the timelimit for Alice to keep the coin (say \n> in the first 24 hours), and after those 24 hours the ownership goes to \n> the third argument, say Bob.\n> \n> That is, it is not possible to use only specifying the owner in the \n> first 24 hours. Would this be considered harmful?\n> \n> Best,\n> \n> Alejandro.\n> \n> On 9/6/18 10:32 PM, Brandon Smith wrote:\n> > ade a similar proposal about 7 months ago, and documented some of the\n> > discussion points here:"
            },
            {
                "author": "TUCCI Sara",
                "date": "2018-09-07T13:47:17",
                "message_text_only": "Hello Gregory, all\n  Thank you so much for your feedback. Our main objective in the research paper was in fact to study the \"what-if\" situation in which Bitcoin offered the cancellation of the transaction from the user's point of view. Our main interest was the model of the user-agents and quantify the possible \"satisfaction\" that the user can obtain while also quantifying a possible greater satisfaction with the respect to the current situation. When we wrote the document, we thought about the \"implementability\" of the cancellation through non-monotonous validity to obtain a more realistic model, but being very cautious in proposing or claiming any kind of mechanism. Of course we never thought that nobody ever proposed it before, that's why when we finished writing the paper, many questions remained unanswered and we decided to send you the document, to get your opinion, which is very useful for improving  the current model.\nAlthough Bitcoin will never implement the mechanism because arguments for non-monotonous validity use case will not emerge, I think this type of study can be useful to conclude on that opportunity or as Brandon suggested to move to other approaches, like Lightning (even though even for Lightning several limitations still there exist !). \n\nSara\n\nP.S.\nSorry for possible multiple copies of the message, I needed to subscribe to the mailing list and to repost __\n\n\ufeffOn 07/09/2018, 14:51, \"Brandon Smith\" <freedom at reardencode.com> wrote:\n\n    I believe you may be missing the overall points in the \"Nail In the\n    Coffin\" and \"Temporary Discussion\" sections. In summary:\n    \n    1: Any UTXO spending a script with an expiration must be treated\n    similarly to Coinbase (I proposed a solution to this, but it's complex\n    and may have unforeseen implications).\n    \n    2: All existing software assumes that a transaction once valid stays\n    valid. Any proposal to change this must ensure that existing wallets and\n    users aren't immediately open to being scammed by malicious actors\n    sending low fee expiring transactions.\n    \n    The more tenable ways to move forward on improving the ecosystem around\n    delayed transactions and refunds are: Lightning, improved fee\n    estimation, and improved mempool eviction / re-propagation resistance.\n    \n    The original reason that I began looking into this is because I noticed\n    that during high fee periods, transactions could re-propagate between\n    mempools of differing policies resulting in coins being stuck unusable\n    for far longer than the expected 1-2 week eviction. I don't know of any\n    concrete work going into investigating or improving this.\n    \n    HTH,\n    \n    --Brandon\n    \n    On 2018-09-07 (Fri) at 09:12:40 +0200, Alejandro Ranchal Pedrosa wrote:\n    > Hi all,\n    > \n    > Thank you for the link, and also to Gregory for the remarks. I did not \n    > know about this previous proposal. I think the last paragraph of future \n    > work is interesting:\n    > \n    > \"It may be interesting to add enhance OP_CHECKSEQUENCEVERIFY \n    > <https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki> to \n    > allow outputs that are spendable by Alice until time foo, always \n    > spendable by Bob, and spendable by Joe only after time bar, or other \n    > such cases\"\n    > \n    > Perhaps it would allow this functionality, while keeping the validity of \n    > coins, if the new OP_zzz took an additional argument than suggested, \n    > such that the first one is the timelimit for Alice to keep the coin (say \n    > in the first 24 hours), and after those 24 hours the ownership goes to \n    > the third argument, say Bob.\n    > \n    > That is, it is not possible to use only specifying the owner in the \n    > first 24 hours. Would this be considered harmful?\n    > \n    > Best,\n    > \n    > Alejandro.\n    > \n    > On 9/6/18 10:32 PM, Brandon Smith wrote:\n    > > ade a similar proposal about 7 months ago, and documented some of the\n    > > discussion points here:"
            },
            {
                "author": "vizeet srivastava",
                "date": "2018-09-06T16:14:59",
                "message_text_only": "I feel it is breaking a principle that if a transaction is valid it remains\nvalid. There might be dangerous repercussions to breaking that rule. For\ninstance chain of transaction become invalid which might lead to losses.\n\nOn Thu 6 Sep, 2018, 6:37 PM Alejandro Ranchal Pedrosa via bitcoin-dev, <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello everyone,\n>\n> We would like to propose a new BIP to extend OP_CSV (and/or OP_CLTV) in\n> order for these to allow and interpret negative values. This way,\n> taking the example shown in BIP 112:\n>\n> HASH160 <revokehash> EQUAL\n> IF\n>      <Bob's pubkey>\n> ELSE\n>      \"24h\" CHECKSEQUENCEVERIFY DROP\n>      <Alice's pubkey>\n> ENDIF\n> CHECKSIG\n>\n> that gives ownership only to Bob for the first 24 hours and then to\n> whichever spends first, we basically propose using the negative bit value:\n>\n> HASH160 <revokehash> EQUAL\n> IF\n>      <Bob's pubkey>\n> ELSE\n>      \"-24h\" CHECKSEQUENCEVERIFY DROP\n>      <Alice's pubkey>\n> ENDIF\n> CHECKSIG\n>\n> meaning that both would have ownership for the first 24 hours, but\n> after that only Bob would own such coins. Its implementation should\n> not be too tedious, and in fact it simply implies considering negative\n> values that are at the moment discarded as for the specification of\n> BIP-112, leaving the sign bit unused.\n>\n> This, we argue, an increase the fairness of the users, and can at times\n> be more cost-effective for users to do rather than trying a Replace-By-Fee\n> transaction, should they want to modify such payment.\n>\n> We would like to have a discussion about this before proposing the\n> BIP, for which we are preparing the text.\n>\n> You can find our paper discussing it here:\n> https://hal-cea.archives-ouvertes.fr/cea-01867357 (find attached as well)\n>\n> Best,\n>\n> --\n> Alejandro Ranchal Pedrosa, \u00d6nder G\u00fcrcan and Sara Tucci-Piergiovanni\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180906/287712d4/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2018-09-06T16:33:38",
                "message_text_only": "I think you misunderstood my proposal. What you'd do is the transaction\nis spendable by either Bob OR (Bob AND Alice) and before\nbroadcast/during construction/whatever sign a new transaction that\nspends it and is only spendable by Alice, but is timelocked for 24\nhours. At the 24h mark, Alice broadcasts the transaction and once it is\nconfirmed only Alice can claim the money.\n\nOn 09/06/18 10:59, Alejandro Ranchal Pedrosa wrote:\n> Dear Matt,\n> \n> Notice that what you suggest has some substantial differences. With your\n> suggestion of a multisig option with a 24h timelock, once you give Alice\n> the chance to spend that UTXO without a negative timelock (as we argue),\n> by means of, say, a transaction that she can use, you cannot enforce\n> that this is not used by Alice after the 24hs. Perhaps it is possible,\n> tweaking the Lightning Channel design of Breach Remedy txs, to penalize\n> Alice if she does this, but this requires Bob to check the Blockchain in\n> case he needs to publish a proof-of-fraud, think of adding extra funds\n> to the transaction to account for penalization, etc.\n> \n> Feel free to correct me if I got it wrong in your email.\n> \n> Best,\n> Alejandro.\n> \n> \n> On Thu, Sep 6, 2018 at 3:32 PM Matt Corallo <lf-lists at mattcorallo.com\n> <mailto:lf-lists at mattcorallo.com>> wrote:\n> \n>     I think a simple approach to what you want to accomplish is to\n>     simply have a multisig option with a locktime pre-signed transaction\n>     which is broadcastable at the 24h mark and has different\n>     spendability. This avoids introducing reorg-induced invalidity.\n> \n>     On September 6, 2018 9:19:24 AM UTC, Alejandro Ranchal Pedrosa via\n>     bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> \n>         Hello everyone,\n> \n>         We would like to propose a new BIP to extend OP_CSV (and/or OP_CLTV) in\n>         order for these to allow and interpret negative values. This way,\n>         taking the example shown in BIP 112:\n> \n>         HASH160 <revokehash> EQUAL\n>         IF\n>          \u00a0\u00a0\u00a0 <Bob's pubkey>\n>         ELSE\n>          \u00a0\u00a0\u00a0 \"24h\" CHECKSEQUENCEVERIFY DROP\n>          \u00a0\u00a0\u00a0 <Alice's pubkey>\n>         ENDIF\n>         CHECKSIG\n> \n>         that gives ownership only to Bob for the first 24 hours and then to\n>         whichever spends first, we basically propose using the negative bit value:\n> \n>         HASH160 <revokehash> EQUAL\n>         IF\n>          \u00a0\u00a0\u00a0 <Bob's pubkey>\n>         ELSE\n>          \u00a0\u00a0\u00a0 \"-24h\" CHECKSEQUENCEVERIFY DROP\n>          \u00a0\u00a0\u00a0 <Alice's pubkey>\n>         ENDIF\n>         CHECKSIG\n> \n>         meaning that both would have ownership for the first 24 hours, but\n>         after that only Bob would own such coins. Its implementation should\n>         not be too tedious, and in fact it simply implies considering negative\n>         values that are at the moment discarded as for the specification of\n>         BIP-112, leaving the sign bit unused.\n> \n>         This, we argue, an increase the fairness of the users, and can at times\n>         be more cost-effective for users to do rather than trying a Replace-By-Fee\n>         transaction, should they want to modify such payment.\n> \n>         We would like to have a discussion about this before proposing the\n>         BIP, for which we are preparing the text.\n> \n>         You can find our paper discussing it here:\n>         https://hal-cea.archives-ouvertes.fr/cea-01867357 (find attached as well)\n> \n>         Best,\n>"
            },
            {
                "author": "Alejandro Ranchal Pedrosa",
                "date": "2018-09-07T07:07:25",
                "message_text_only": "Yes I agree with what you mean but this requires Alice to broadcast an \nadditional transaction. Also, Alice is supposed to be able to 'cancel' \nthe transaction in the first 24hours, not after them.\n\nBest,\n\nAlejandro.\n\nOn 9/6/18 6:33 PM, Matt Corallo wrote:\n> I think you misunderstood my proposal. What you'd do is the transaction\n> is spendable by either Bob OR (Bob AND Alice) and before\n> broadcast/during construction/whatever sign a new transaction that\n> spends it and is only spendable by Alice, but is timelocked for 24\n> hours. At the 24h mark, Alice broadcasts the transaction and once it is\n> confirmed only Alice can claim the money.\n>\n> On 09/06/18 10:59, Alejandro Ranchal Pedrosa wrote:\n>> Dear Matt,\n>>\n>> Notice that what you suggest has some substantial differences. With your\n>> suggestion of a multisig option with a 24h timelock, once you give Alice\n>> the chance to spend that UTXO without a negative timelock (as we argue),\n>> by means of, say, a transaction that she can use, you cannot enforce\n>> that this is not used by Alice after the 24hs. Perhaps it is possible,\n>> tweaking the Lightning Channel design of Breach Remedy txs, to penalize\n>> Alice if she does this, but this requires Bob to check the Blockchain in\n>> case he needs to publish a proof-of-fraud, think of adding extra funds\n>> to the transaction to account for penalization, etc.\n>>\n>> Feel free to correct me if I got it wrong in your email.\n>>\n>> Best,\n>> Alejandro.\n>>\n>>\n>> On Thu, Sep 6, 2018 at 3:32 PM Matt Corallo <lf-lists at mattcorallo.com\n>> <mailto:lf-lists at mattcorallo.com>> wrote:\n>>\n>>      I think a simple approach to what you want to accomplish is to\n>>      simply have a multisig option with a locktime pre-signed transaction\n>>      which is broadcastable at the 24h mark and has different\n>>      spendability. This avoids introducing reorg-induced invalidity.\n>>\n>>      On September 6, 2018 9:19:24 AM UTC, Alejandro Ranchal Pedrosa via\n>>      bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org\n>>      <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>>\n>>          Hello everyone,\n>>\n>>          We would like to propose a new BIP to extend OP_CSV (and/or OP_CLTV) in\n>>          order for these to allow and interpret negative values. This way,\n>>          taking the example shown in BIP 112:\n>>\n>>          HASH160 <revokehash> EQUAL\n>>          IF\n>>           \u00a0\u00a0\u00a0 <Bob's pubkey>\n>>          ELSE\n>>           \u00a0\u00a0\u00a0 \"24h\" CHECKSEQUENCEVERIFY DROP\n>>           \u00a0\u00a0\u00a0 <Alice's pubkey>\n>>          ENDIF\n>>          CHECKSIG\n>>\n>>          that gives ownership only to Bob for the first 24 hours and then to\n>>          whichever spends first, we basically propose using the negative bit value:\n>>\n>>          HASH160 <revokehash> EQUAL\n>>          IF\n>>           \u00a0\u00a0\u00a0 <Bob's pubkey>\n>>          ELSE\n>>           \u00a0\u00a0\u00a0 \"-24h\" CHECKSEQUENCEVERIFY DROP\n>>           \u00a0\u00a0\u00a0 <Alice's pubkey>\n>>          ENDIF\n>>          CHECKSIG\n>>\n>>          meaning that both would have ownership for the first 24 hours, but\n>>          after that only Bob would own such coins. Its implementation should\n>>          not be too tedious, and in fact it simply implies considering negative\n>>          values that are at the moment discarded as for the specification of\n>>          BIP-112, leaving the sign bit unused.\n>>\n>>          This, we argue, an increase the fairness of the users, and can at times\n>>          be more cost-effective for users to do rather than trying a Replace-By-Fee\n>>          transaction, should they want to modify such payment.\n>>\n>>          We would like to have a discussion about this before proposing the\n>>          BIP, for which we are preparing the text.\n>>\n>>          You can find our paper discussing it here:\n>>          https://hal-cea.archives-ouvertes.fr/cea-01867357 (find attached as well)\n>>\n>>          Best,\n>>"
            }
        ],
        "thread_summary": {
            "title": "A BIP proposal for transactions that are 'cancellable'",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Terry McLaughlin",
                "Alejandro Ranchal Pedrosa",
                "TUCCI Sara",
                "Gregory Maxwell",
                "Matt Corallo",
                "vizeet srivastava",
                "Brandon Smith"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 25835
        }
    },
    {
        "title": "[bitcoin-dev] Multisignature for bip-schnorr",
        "thread_messages": [
            {
                "author": "Jonas Nick",
                "date": "2018-09-07T08:11:56",
                "message_text_only": "Your multisignature writeup appears to be vulnerable to key cancellation\nattacks because the aggregated public key is just the sum of public keys (and\nthere is no proof of knowledge of the individual secret keys). Therefore, in a\nmultisignature between Alice and an attacker, the attacker can choose their key\nto be -alice_key+attacker_key resulting in an aggregated key for which the\nattacker can sign alone (without requiring Alice's partial signature). The\nSchnorr BIP links to the MuSig paper which describes a secure key aggregation\nscheme. See https://eprint.iacr.org/2018/068\n\nOn 8/7/18 6:35 AM, nakagat via bitcoin-dev wrote:\n> Hi all,\n> \n> I wrote a multisignature procedure using bip-schnorr.\n> \n> If you have time to review and give feedback, I\u2019d really appreciate it.\n> Thanks in advance!\n> \n> Multisignature\n> https://gist.github.com/tnakagawa/0c3bc74a9a44bd26af9b9248dfbe598b\n> \n> Original\n> https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki#Multisignatures_and_Threshold_Signatures\n>"
            },
            {
                "author": "nakagat",
                "date": "2018-09-12T06:00:17",
                "message_text_only": "Hi Jonas\n\nThank you for your comment.\n\nI wrote a new text.\nhttps://gist.github.com/tnakagawa/e6cec9a89f698997dc58a09db541e1eb\n\nIf you have time, please review this.\n2018\u5e749\u67087\u65e5(\u91d1) 17:09 Jonas Nick <jonasdnick at gmail.com>:\n>\n> Your multisignature writeup appears to be vulnerable to key cancellation\n> attacks because the aggregated public key is just the sum of public keys (and\n> there is no proof of knowledge of the individual secret keys). Therefore, in a\n> multisignature between Alice and an attacker, the attacker can choose their key\n> to be -alice_key+attacker_key resulting in an aggregated key for which the\n> attacker can sign alone (without requiring Alice's partial signature). The\n> Schnorr BIP links to the MuSig paper which describes a secure key aggregation\n> scheme. See https://eprint.iacr.org/2018/068\n>\n> On 8/7/18 6:35 AM, nakagat via bitcoin-dev wrote:\n> > Hi all,\n> >\n> > I wrote a multisignature procedure using bip-schnorr.\n> >\n> > If you have time to review and give feedback, I\u2019d really appreciate it.\n> > Thanks in advance!\n> >\n> > Multisignature\n> > https://gist.github.com/tnakagawa/0c3bc74a9a44bd26af9b9248dfbe598b\n> >\n> > Original\n> > https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki#Multisignatures_and_Threshold_Signatures\n> >"
            }
        ],
        "thread_summary": {
            "title": "Multisignature for bip-schnorr",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "nakagat",
                "Jonas Nick"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2297
        }
    },
    {
        "title": "[bitcoin-dev] bustapay BIP :: a practical sender/receiver coinjoin protocol",
        "thread_messages": [
            {
                "author": "Sjors Provoost",
                "date": "2018-09-10T12:30:46",
                "message_text_only": "> Op 30 aug. 2018, om 22:24 heeft Ryan Havar via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:\n> \n> ==Motivation==\n> \n> One of the most powerful heuristic's employed by those whose goal is to undermine\n> bitcoin's fungiblity has been to assume all inputs of a transaction are signed by\n> a single party. In the few cases this assumption does not hold, it is generally\n> readibly recognizable (e.g. traditional coinjoins have a very obvious structure,\n> or multisig outputs are most frequently validated onchain).\n\nIn addition to mixers, custodial wallets and exchanges also contribute to breaking this heuristic; even though there\u2019s a single entity signing multiple inputs, that entity doesn\u2019t represent a single owner of the funds. As with mixers, exchanges and custodial wallets can sometimes be spotted as well, but we don\u2019t know what percentage is missed.\n\nBreaking this heuristic at scale would be good, but do we know to what degree it\u2019s already broken? Is there any empirical research measuring its accuracy and false positive rate?\n\n> Should bustapay enjoy widespread adoption, a \"v2\" specification\n> will be created with desired extensions.\n\nI would not put future promises in a BIP. Rather, explain how extension might work.\n\n> ==Specification==\n> \n> A bustapay payment is made from a sender to a receiver.\n> \n> Step 1. Sender creates a bitcoin transaction paying the receiver\n> \n> This transaction must be fully valid, signed and all inputs must use segwit. This transaction is known as the \"template transaction\u201d.\n\nUsing PSBT?\n\n> This transaction must not be propagated on the bitcoin network.\n\nThis can\u2019t be guaranteed, and even after step 5 a reorg could cause it to get confirmed. It\u2019s useful to explain why this doesn\u2019t matter.\n\n> \n> Step 2. Sender gives the \"template transaction\" to the receiver\n> \n> This would generally be done as an HTTP POST.\n> The exact URL to submit it to could be specified with a bip21 encoded address. Such as bitcoin:2NABbUr9yeRCp1oUCtVmgJF8HGRCo3ifpTT?bustapay=https://bp.bustabit.com/submit <https://bp.bustabit.com/submit> and the HTTP body should be the raw transaction hex encoded as text.\n\nThis seems too detailed. If you want to specify the message protocol, maybe that can have it\u2019s own section where you list each of the messages, the URL, parameters and encoding. Then you can keep this overview section shorter.\n\nThe use of HTTPS kind of forces sender and recipient to use a 3rd party service, even though this could done bilaterally. What if the payment request contained a (single-use) Onion URL an expiration date? The recipient would have to keep a hidden service up until the expiration date, though the sender could try again if there\u2019s temporary reachability issue.\n\nAdding a (onion) URL to the the payment request also makes gradual adoption easier, because recipients don\u2019t need to worry if senders support this protocol.\n\n> Step 3. Receiver processes the transaction and returns a partially signed coinjoin\n> \n> The receiver validates the transaction is valid, pays himself and is eligible for propation. The receiver then adds one of his own inputs (known as the \"contributed input\") and increase the output that pays himself by the contributed input amount. Doing so will invalidate the \"template transaction\"'s original input signatures, so the sender needs to return this \"partial transaction\" back to the receiver to sign. This is returned as a hex-encoded raw transaction a response to the original HTTP POST request.\n\n> * Bustapay could be abused by a malicious party to query if you own a deposit address or not. So never accept a bustapay transaction that pays an already used deposit address\n\n\nIndeed, once the recipient adds funds, they reveal more about themselves to the sender then they would otherwise. I think that needs more elaboration.\n\nI assume the transaction in step (1) is some sort of collateral to insure they\u2019re not just trying to extract private information from you? However if fees are low they could still double-spend it after the recipient revealed their address, especially because the recipient has no way of RBF\u2019ing the original (though CPFP could help). Perhaps require that the original transaction pays a fee based on the expected size of the final transaction?\n\n> \n> Notes for sending applications:\n> \n> * The HTTP response must *not* be trusted. It should be fully validated that no unexpected changes have been made to the transaction.\n\nNot trusting anything is obvious. :-) It\u2019s better to explicitly state what exactly needs to be verified (amounts, destinations, inputs, etc), and maybe list a few obvious shenanigans to watch out for.\n\nA more general concern is that the sender can\u2019t know for sure the recipient really supports this protocol, so it should assume that whatever information it pings to some API could be used maliciously. In what ways could it be abused?\n\nSjors\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180910/d1d40a7e/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180910/d1d40a7e/attachment.sig>"
            },
            {
                "author": "rhavar at protonmail.com",
                "date": "2018-09-10T15:49:29",
                "message_text_only": "Thanks Sjors,\nIt's nice to get hear feedback like that, it'll help make me clear some stuff up. Right now I've been working on getting a reference client for both sending and receiving, while juggling some stuff in real life.\n\nBut here is the evolving document:\nhttps://github.com/RHavar/bips/blob/master/bip-bustapay.mediawiki\n\n> Breaking this heuristic at scale would be good, but do we know to what degree it\u2019s already broken? Is there any empirical research measuring its accuracy and false positive rate?\n\nNot that I'm aware of. However from what I've seen of chainalysis, it's eerily accurate. I've seen it cluster wallets that it really shouldn't have been able to do. (address-reuse is actually the biggest culprit here, we really need to working on reducing stopping this with stuff like bip32 based address books, wallet warnings on reused addresses, etc.). As for false positives of block-chain analysis, under normal circumstances it probably shouldn't suffer any. Although it was pretty easy to confuse it with specially crafted coinjoin transactions, although a few months later seemed to realize and decluster the wallets again.\n\n> In addition to mixers, custodial wallets and exchanges also contribute to breaking this heuristic\n\nWell, kind of I guess. From a block-chain analysis point of view you'd be trying to figure out the transaction was to/from coinbase, rather than \"coinbase on behalf of client XYZ\". I guess the former is better than the later, but I think it'd be preferable if no one knew all together.\n\n> Using PSBT?\n\nI've got this feedback a lot, and I think it's definitely the way to go in the future. But at the moment compatibility and libraries are just not there that I'd like to stick with raw transactions for now.\n\n> The use of HTTPS kind of forces sender and recipient to use a 3rd party service, even though this could done bilaterally.\n\nI don't really understand this point. I just used https as an example, as I suspect that's what every merchant will want to use. I don't really mean to specify the protocol though, if the client/server support  it (e.g. onion)  then it should be fine.\n\n> I assume the transaction in step (1) is some sort of collateral to insure they\u2019re not just trying to extract private information from you?\n\nIt's not really designed as a sort of collateral, but as a way to prevent someone costlessly learning about one of your inputs. The cost is that of spending a utxo. An attacker can always trivially double spend the \"template transaction\" because from the network's point of view the \"template transaction\" will come after an alternate (say, non-rbf) spend.  But in practice I don't think this is a problem, because it still imposes a cost on the attacker.\n\n> In what ways could it be abused?\n\nI just want to make it clear that senders can't blindly sign a transaction without verifying it. The most important thing to verify is the output amounts/addresses -- but I will make it more explicit.\n\nThanks once again for your feedback\n\n-Ryan\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Monday, 10 September 2018 05:30, Sjors Provoost <sjors at sprovoost.nl> wrote:\n\n>> Op 30 aug. 2018, om 22:24 heeft Ryan Havar via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:\n>>\n>> ==Motivation==\n>>\n>> One of the most powerful heuristic's employed by those whose goal is to undermine\n>> bitcoin's fungiblity has been to assume all inputs of a transaction are signed by\n>> a single party. In the few cases this assumption does not hold, it is generally\n>> readibly recognizable (e.g. traditional coinjoins have a very obvious structure,\n>> or multisig outputs are most frequently validated onchain).\n>\n> In addition to mixers, custodial wallets and exchanges also contribute to breaking this heuristic; even though there\u2019s a single entity signing multiple inputs, that entity doesn\u2019t represent a single owner of the funds. As with mixers, exchanges and custodial wallets can sometimes be spotted as well, but we don\u2019t know what percentage is missed.\n>\n> Breaking this heuristic at scale would be good, but do we know to what degree it\u2019s already broken? Is there any empirical research measuring its accuracy and false positive rate?\n>\n>> Should bustapay enjoy widespread adoption, a \"v2\" specification\n>> will be created with desired extensions.\n>\n> I would not put future promises in a BIP. Rather, explain how extension might work.\n>\n>> ==Specification==\n>>\n>> A bustapay payment is made from a sender to a receiver.\n>>\n>> Step 1. Sender creates a bitcoin transaction paying the receiver\n>>\n>> This transaction must be fully valid, signed and all inputs must use segwit. This transaction is known as the \"template transaction\u201d.\n>\n> Using PSBT?\n>\n>> This transaction must not be propagated on the bitcoin network.\n>\n> This can\u2019t be guaranteed, and even after step 5 a reorg could cause it to get confirmed. It\u2019s useful to explain why this doesn\u2019t matter.\n>\n>> Step 2. Sender gives the \"template transaction\" to the receiver\n>>\n>> This would generally be done as an HTTP POST.\n>\n>> The exact URL to submit it to could be specified with a bip21 encoded address. Such as bitcoin:2NABbUr9yeRCp1oUCtVmgJF8HGRCo3ifpTT?bustapay=https://bp.bustabit.com/submit and the HTTP body should be the raw transaction hex encoded as text.\n>\n> This seems too detailed. If you want to specify the message protocol, maybe that can have it\u2019s own section where you list each of the messages, the URL, parameters and encoding. Then you can keep this overview section shorter.\n>\n> The use of HTTPS kind of forces sender and recipient to use a 3rd party service, even though this could done bilaterally. What if the payment request contained a (single-use) Onion URL an expiration date? The recipient would have to keep a hidden service up until the expiration date, though the sender could try again if there\u2019s temporary reachability issue.\n>\n> Adding a (onion) URL to the the payment request also makes gradual adoption easier, because recipients don\u2019t need to worry if senders support this protocol.\n>\n>> Step 3. Receiver processes the transaction and returns a partially signed coinjoin\n>>\n>> The receiver validates the transaction is valid, pays himself and is eligible for propation. The receiver then adds one of his own inputs (known as the \"contributed input\") and increase the output that pays himself by the contributed input amount. Doing so will invalidate the \"template transaction\"'s original input signatures, so the sender needs to return this \"partial transaction\" back to the receiver to sign. This is returned as a hex-encoded raw transaction a response to the original HTTP POST request.\n>\n>> * Bustapay could be abused by a malicious party to query if you own a deposit address or not. So never accept a bustapay transaction that pays an already used deposit address\n>\n> Indeed, once the recipient adds funds, they reveal more about themselves to the sender then they would otherwise. I think that needs more elaboration.\n>\n> I assume the transaction in step (1) is some sort of collateral to insure they\u2019re not just trying to extract private information from you? However if fees are low they could still double-spend it after the recipient revealed their address, especially because the recipient has no way of RBF\u2019ing the original (though CPFP could help). Perhaps require that the original transaction pays a fee based on the expected size of the final transaction?\n>\n>> Notes for sending applications:\n>>\n>> * The HTTP response must *not* be trusted. It should be fully validated that no unexpected changes have been made to the transaction.\n>\n> Not trusting anything is obvious. :-) It\u2019s better to explicitly state what exactly needs to be verified (amounts, destinations, inputs, etc), and maybe list a few obvious shenanigans to watch out for.\n>\n> A more general concern is that the sender can\u2019t know for sure the recipient really supports this protocol, so it should assume that whatever information it pings to some API could be used maliciously. In what ways could it be abused?\n>\n> Sjors\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180910/1a3909de/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "bustapay BIP :: a practical sender/receiver coinjoin protocol",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "rhavar at protonmail.com",
                "Sjors Provoost"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 13658
        }
    },
    {
        "title": "[bitcoin-dev] RFC: BIP 322: Generic Signed Message Format",
        "thread_messages": [
            {
                "author": "Karl-Johan Alm",
                "date": "2018-09-11T04:41:57",
                "message_text_only": "Hi.\n\n[note: BIP number was assigned to PR before this email was sent; I did\nnot self-assign the BIP number]\n\nBelow is a proposal to extend the existing sign/verifymessage format\nto a more generalized variant relying on the script verification\nmechanism in Bitcoin itself for message signing/verification, based on\nthe original discussion\n(https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015818.html)\n.\n\nPR is here: https://github.com/bitcoin/bips/pull/725\n\nA formatted version of this text can be seen here:\nhttps://github.com/kallewoof/bips/blob/bip-generic-signmessage/bip-generic-signmessage.mediawiki\n\nNote: I am not sure how to best deal with CLTV/CSV stuff here, ultimately.\n\nNote 2: I have received suggestions from several people to use a\nBitcoin transaction instead. If someone could explain why this is\nbeneficial, it would be very helpful. I'm not against it, just feels\nlike the whole transaction part is unnecessary complexity/overhead.\n\n---\n<pre>\n  BIP: 322\n  Layer: Applications\n  Title: Generic Signed Message Format\n  Author: Karl-Johan Alm <karljohan-alm at garage.co.jp>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0322\n  Status: Draft\n  Type: Standards Track\n  Created: 2018-09-10\n  License: CC0-1.0\n</pre>\n\n== Abstract ==\n\nA standard for interoperable generic signed messages based on the\nBitcoin Script format.\n\n== Motivation ==\n\nThe current message signing standard only works for P2PKH (1...)\naddresses. By extending it to use a Bitcoin Script based approach, it\ncould be made more generic without causing a too big burden on\nimplementers, who most likely have access to Bitcoin Script\ninterpreters already.\n\n== Specification ==\n\nA new structure <code>SignatureProof</code> is added, which is a\nsimple serializable scriptSig & witnessProgram container.\n\nTwo actions \"Sign\" and \"Verify\" are defined.\n\n=== SignatureProof container ===\n\n{|class=\"wikitable\" style=\"text-align: center;\"\n|-\n!Type\n!Length\n!Name\n!Comment\n|-\n|Uint32||4||flags||standard flags (1-to-1 with standard flags in Bitcoin Core)\n|-\n|VarInt||1-8||msglen||Number of bytes in message string, excluding NUL\ntermination\n|-\n|Char*||[msglen]||msg||The message being signed for all subjects,\nexcluding NUL termination\n|-\n|Uint8||1||entries||Number of proof entries<ref><strong>Why support\nmultiple proofs?</strong> In particular with proof of funds, it is\nnon-trivial to check a large number of individual proofs (one per\nUTXO) for duplicates. Software could be written to do so, but it seems\nmore efficient to build this check into the specification\nitself.</ref>\n|}\n\nThe above is followed by [entries] number of signature entries:\n\n{|class=\"wikitable\" style=\"text-align: center;\"\n|-\n!Type\n!Length\n!Name\n!Comment\n|-\n|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n|-\n|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n|-\n|VarInt||1-8||witlen||Number of bytes in witness program data\n|-\n|Uint8*||[witlen]||wit||Witness program\n|}\n\nIn some cases, the scriptsig may be empty (scriptsiglen=0).\n\n=== Signing ===\n\nThe \"Sign\" action takes as input a scriptPubKey and a message (e.g.\n\"hello world\"). It succeeds or fails.\n\n# FAIL if scriptPubKey already exists in scriptPubKeys set, otherwise\ninsert it<ref><strong>Why track duplicates?</strong> Because a 3-entry\nproof is not proving 3 scriptPubKeys unless they are all distinct, or\nunless they are proving different UTXO:s (see Future Extensions)</ref>\n# Derive the private key privkey for the scriptPubKey, or FAIL\n# Define the message pre-image as the sequence \"Bitcoin Message:\"\nconcatenated with the message, encoded in UTF-8 using Normalization\nForm Compatibility Decomposition (NFKD)\n# Let sighash = sha256(sha256(scriptPubKey || pre-image))\n# Generate a signature sig with privkey=privkey, sighash=sighash\n\nRepeat the above operation for each scriptPubKey, retaining the\nscriptPubKeys set. As noted, if the same scriptPubKey appears more\nthan once, the sign operation must fail.\n\n=== Verifying ===\n\nThe \"Verify\" action takes as input a standard flags value, a\nscriptPubKey, a message, a script sig, and a witness program.\nIt emits one of INCONCLUSIVE, VALID, INVALID, or ERROR.\n\n# Return ERROR if scriptPubKey already exists in scriptPubKeys set,\notherwise insert it\n# If one or more of the standard flags are unknown, return INCONCLUSIVE\n# Define the message pre-image as the sequence \"Bitcoin Message:\"\nconcatenated with the message, encoded in UTF-8 using Normalization\nForm Compatibility Decomposition (NFKD).\n# Let sighash = sha256(sha256(scriptPubKey || pre-image))\n# Verify Script with flags=standard flags, scriptSig=script sig,\nscriptPubKey=scriptPubKey, witness=witness program, and\nsighash=sighash\n# Return VALID if verify succeeds, otherwise return INVALID\n\nRepeat the above operation for each scriptPubKey, retaining the\nscriptPubKeys set. As noted, if the same scriptPubKey appears more\nthan once, the verify operation must fail with an ERROR.\n\n* If a verification call returns ERROR or INVALID, return ERROR or\nINVALID immediately, ignoring as yet unverified entries.\n* After all verifications complete, return INCONCLUSIVE if any\nverification call returned INCONCLUSIVE.\n* Return VALID if and only if every verification returned VALID.\n\n== Future Extensions ==\n\n=== Proof of Funds ===\n\nThe specification can be extended to handle proof of funds in the\nfollowing manner:\n\n* Let the message be prefixed with \"POF:\", followed by a\nnewline-terminated string<ref><strong>Why not just the UTXO\ndata?</strong> We want the verifier to be able to challenge the prover\nwith a custom message to sign, or anyone can reuse the POF proof for a\nset of UTXO:s once they have seen it, and the funds have not yet been\nspent</ref>, followed by [entries] series of hex-encoded transaction\nID:vout pairs, separated by a single space (\" \") character\n* Fail if the number of txid:vout pairs is not exactly equal to [entries]\n* Retain the message as is for all sighash operations (i.e. all sign\nand verify operations should sign and verify the entire list of\nUTXO:s)<ref><strong>Why use same sighash?</strong> The prover is\nproving that they have a set of UTXO:s at their disposal. Taking a\nsub-set of the proofs and turning them into a new proof should not be\nvalid.</ref>\n* Add a verification that the txid/vout is a valid UTXO according to a\nsynced up Bitcoin node, and that its corresponding scriptPubKey\nmatches the one given by the proof. Return ERROR if scriptPubKey\nmismatch, and SPENT error if spent\n* Extend the scriptPubKeys set check to only fail if the same\nscriptPubKey and proof-of-funds txid/vout combination is encountered\n\n== Compatibility ==\n\nThis specification is not backwards compatible with the legacy\nsignmessage/verifymessage specification. However, legacy addresses\n(1...) may be used in this implementation without any problems.\n\n== Rationale ==\n\n<references/>\n\n== Reference implementation ==\n\nTo do.\n\n== Acknowledgements ==\n\nTODO\n\n== References ==\n\n# Original mailing list thread:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015818.html\n\n== Copyright ==\n\nThis document is licensed under the Creative Commons CC0 1.0 Universal license.\n---\n\n-Kalle."
            },
            {
                "author": "Karl-Johan Alm",
                "date": "2018-09-12T07:56:25",
                "message_text_only": "Greetings,\n\n(The quoted proposal is already outdated, and I recommend you check\nout the up to date formatted version here:\nhttps://github.com/kallewoof/bips/blob/bip-generic-signmessage/bip-0322.mediawiki\nThe PR with comments is here: https://github.com/bitcoin/bips/pull/725)\n\nA big part of the feedback boils down to conflicts of opinion related\nto whether or not proofs should be given as transactions or not.\n\nI am attempting to write down the pros and cons below, some of which\nare contradictory/complementary based on multiple people's opinions.\n\nPros of using transaction format:\n1. works out of the box with existing HSM:s, some of which may be\npurposefully built to not be upgradable for security reasons (unless\nsighash modified; see below)\n2. easier to incorporate into existing software\n3. forward compatible with bitcoin extensions (e.g. mimblewimble,\nconfidential transactions, etc)\n4. HSM:s *should* be blind to whether or not a transaction or a\nmessage or proof of funds is being signed (see Con #3)\n\nCons:\n1. dangerous if challenger is able to convince prover to sign a\nmessage that corresponds to an actual transaction; modifying sighash\nis suggested, but defeats pro #1 above; can define in tx to have txin\nas sighash to guarantee invalid on chain\n2. unupgraded software are unable to make distinction between message\nsign and transaction sign\n3. if HSM:s do not support it and do not support upgrading, this is by\ndesign, and message signing should be explicitly supported or not be\npossible (see Pro #4)\n4. severely cripples UX for hardware wallets that actually show the\ncontents of the transaction during the signing\n\nIf anyone has comments on this, it would be tremendously appreciated.\n\nThere is also a divided opinion on whether an \"OP_MESSAGEONLY\" opcode\nshould be introduced, but I'd like to address the above first, if\npossible.\nOn Tue, Sep 11, 2018 at 1:41 PM Karl-Johan Alm\n<karljohan-alm at garage.co.jp> wrote:\n>\n> Hi.\n>\n> [note: BIP number was assigned to PR before this email was sent; I did\n> not self-assign the BIP number]\n>\n> Below is a proposal to extend the existing sign/verifymessage format\n> to a more generalized variant relying on the script verification\n> mechanism in Bitcoin itself for message signing/verification, based on\n> the original discussion\n> (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015818.html)\n> .\n>\n> PR is here: https://github.com/bitcoin/bips/pull/725\n>\n> A formatted version of this text can be seen here:\n> https://github.com/kallewoof/bips/blob/bip-generic-signmessage/bip-generic-signmessage.mediawiki\n>\n> Note: I am not sure how to best deal with CLTV/CSV stuff here, ultimately.\n>\n> Note 2: I have received suggestions from several people to use a\n> Bitcoin transaction instead. If someone could explain why this is\n> beneficial, it would be very helpful. I'm not against it, just feels\n> like the whole transaction part is unnecessary complexity/overhead.\n>\n> ---\n> <pre>\n>   BIP: 322\n>   Layer: Applications\n>   Title: Generic Signed Message Format\n>   Author: Karl-Johan Alm <karljohan-alm at garage.co.jp>\n>   Comments-Summary: No comments yet.\n>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0322\n>   Status: Draft\n>   Type: Standards Track\n>   Created: 2018-09-10\n>   License: CC0-1.0\n> </pre>\n>\n> == Abstract ==\n>\n> A standard for interoperable generic signed messages based on the\n> Bitcoin Script format.\n>\n> == Motivation ==\n>\n> The current message signing standard only works for P2PKH (1...)\n> addresses. By extending it to use a Bitcoin Script based approach, it\n> could be made more generic without causing a too big burden on\n> implementers, who most likely have access to Bitcoin Script\n> interpreters already.\n>\n> == Specification ==\n>\n> A new structure <code>SignatureProof</code> is added, which is a\n> simple serializable scriptSig & witnessProgram container.\n>\n> Two actions \"Sign\" and \"Verify\" are defined.\n>\n> === SignatureProof container ===\n>\n> {|class=\"wikitable\" style=\"text-align: center;\"\n> |-\n> !Type\n> !Length\n> !Name\n> !Comment\n> |-\n> |Uint32||4||flags||standard flags (1-to-1 with standard flags in Bitcoin Core)\n> |-\n> |VarInt||1-8||msglen||Number of bytes in message string, excluding NUL\n> termination\n> |-\n> |Char*||[msglen]||msg||The message being signed for all subjects,\n> excluding NUL termination\n> |-\n> |Uint8||1||entries||Number of proof entries<ref><strong>Why support\n> multiple proofs?</strong> In particular with proof of funds, it is\n> non-trivial to check a large number of individual proofs (one per\n> UTXO) for duplicates. Software could be written to do so, but it seems\n> more efficient to build this check into the specification\n> itself.</ref>\n> |}\n>\n> The above is followed by [entries] number of signature entries:\n>\n> {|class=\"wikitable\" style=\"text-align: center;\"\n> |-\n> !Type\n> !Length\n> !Name\n> !Comment\n> |-\n> |VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n> |-\n> |Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n> |-\n> |VarInt||1-8||witlen||Number of bytes in witness program data\n> |-\n> |Uint8*||[witlen]||wit||Witness program\n> |}\n>\n> In some cases, the scriptsig may be empty (scriptsiglen=0).\n>\n> === Signing ===\n>\n> The \"Sign\" action takes as input a scriptPubKey and a message (e.g.\n> \"hello world\"). It succeeds or fails.\n>\n> # FAIL if scriptPubKey already exists in scriptPubKeys set, otherwise\n> insert it<ref><strong>Why track duplicates?</strong> Because a 3-entry\n> proof is not proving 3 scriptPubKeys unless they are all distinct, or\n> unless they are proving different UTXO:s (see Future Extensions)</ref>\n> # Derive the private key privkey for the scriptPubKey, or FAIL\n> # Define the message pre-image as the sequence \"Bitcoin Message:\"\n> concatenated with the message, encoded in UTF-8 using Normalization\n> Form Compatibility Decomposition (NFKD)\n> # Let sighash = sha256(sha256(scriptPubKey || pre-image))\n> # Generate a signature sig with privkey=privkey, sighash=sighash\n>\n> Repeat the above operation for each scriptPubKey, retaining the\n> scriptPubKeys set. As noted, if the same scriptPubKey appears more\n> than once, the sign operation must fail.\n>\n> === Verifying ===\n>\n> The \"Verify\" action takes as input a standard flags value, a\n> scriptPubKey, a message, a script sig, and a witness program.\n> It emits one of INCONCLUSIVE, VALID, INVALID, or ERROR.\n>\n> # Return ERROR if scriptPubKey already exists in scriptPubKeys set,\n> otherwise insert it\n> # If one or more of the standard flags are unknown, return INCONCLUSIVE\n> # Define the message pre-image as the sequence \"Bitcoin Message:\"\n> concatenated with the message, encoded in UTF-8 using Normalization\n> Form Compatibility Decomposition (NFKD).\n> # Let sighash = sha256(sha256(scriptPubKey || pre-image))\n> # Verify Script with flags=standard flags, scriptSig=script sig,\n> scriptPubKey=scriptPubKey, witness=witness program, and\n> sighash=sighash\n> # Return VALID if verify succeeds, otherwise return INVALID\n>\n> Repeat the above operation for each scriptPubKey, retaining the\n> scriptPubKeys set. As noted, if the same scriptPubKey appears more\n> than once, the verify operation must fail with an ERROR.\n>\n> * If a verification call returns ERROR or INVALID, return ERROR or\n> INVALID immediately, ignoring as yet unverified entries.\n> * After all verifications complete, return INCONCLUSIVE if any\n> verification call returned INCONCLUSIVE.\n> * Return VALID if and only if every verification returned VALID.\n>\n> == Future Extensions ==\n>\n> === Proof of Funds ===\n>\n> The specification can be extended to handle proof of funds in the\n> following manner:\n>\n> * Let the message be prefixed with \"POF:\", followed by a\n> newline-terminated string<ref><strong>Why not just the UTXO\n> data?</strong> We want the verifier to be able to challenge the prover\n> with a custom message to sign, or anyone can reuse the POF proof for a\n> set of UTXO:s once they have seen it, and the funds have not yet been\n> spent</ref>, followed by [entries] series of hex-encoded transaction\n> ID:vout pairs, separated by a single space (\" \") character\n> * Fail if the number of txid:vout pairs is not exactly equal to [entries]\n> * Retain the message as is for all sighash operations (i.e. all sign\n> and verify operations should sign and verify the entire list of\n> UTXO:s)<ref><strong>Why use same sighash?</strong> The prover is\n> proving that they have a set of UTXO:s at their disposal. Taking a\n> sub-set of the proofs and turning them into a new proof should not be\n> valid.</ref>\n> * Add a verification that the txid/vout is a valid UTXO according to a\n> synced up Bitcoin node, and that its corresponding scriptPubKey\n> matches the one given by the proof. Return ERROR if scriptPubKey\n> mismatch, and SPENT error if spent\n> * Extend the scriptPubKeys set check to only fail if the same\n> scriptPubKey and proof-of-funds txid/vout combination is encountered\n>\n> == Compatibility ==\n>\n> This specification is not backwards compatible with the legacy\n> signmessage/verifymessage specification. However, legacy addresses\n> (1...) may be used in this implementation without any problems.\n>\n> == Rationale ==\n>\n> <references/>\n>\n> == Reference implementation ==\n>\n> To do.\n>\n> == Acknowledgements ==\n>\n> TODO\n>\n> == References ==\n>\n> # Original mailing list thread:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015818.html\n>\n> == Copyright ==\n>\n> This document is licensed under the Creative Commons CC0 1.0 Universal license.\n> ---\n>\n> -Kalle."
            }
        ],
        "thread_summary": {
            "title": "RFC: BIP 322: Generic Signed Message Format",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Karl-Johan Alm"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 16751
        }
    },
    {
        "title": "[bitcoin-dev] Suggestion for a universal bitcoin value scale",
        "thread_messages": [
            {
                "author": "Karl-Johan Alm",
                "date": "2018-09-12T06:13:56",
                "message_text_only": "A potential problem is that it would be a new attack vector to simply\ncolor something to appear as e.g. 10x more than it really is, if\neveryone started using this system.\nOn Sun, Aug 19, 2018 at 5:27 AM Martin Damgaard via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Hi bitcoin-dev at lists.linuxfoundation.org\n>\n> Here is my humble attempt to make a contribution to the impressive work that you all are doing.\n>\n> I am unfamiliar with the normal BIP procedures. I have therefore just tried to follow the example of BIP 176 by Jimmy Song, in order make something similar. I suggest a universal bitcoin value color scale, for tackling the same decimal problem, as identified by the BIP 176 proposal.\n>\n> I have attached the document in three different formats (*.rtf, *.pdf and *.docx) as I do not know your preferred format. I hope you will find my suggestion useful.\n>\n>\n>\n> Thank you and all the best\n>\n> Martin Damgaard\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "damgaard.martin at gmail.com",
                "date": "2018-09-12T06:32:10",
                "message_text_only": "A very good point. I have realized the immature nature of my suggestion due to this and a number of other good remarks, and will like to retract the initial suggestion.  \nThank you and all the best \nMartin Damgaard\n\nFra: Karl-Johan Alm\nSendt: 12. september 2018 08:14\nTil: damgaard.martin at gmail.com; Bitcoin Protocol Discussion\nEmne: Re: [bitcoin-dev] Suggestion for a universal bitcoin value scale\n\nA potential problem is that it would be a new attack vector to simply\ncolor something to appear as e.g. 10x more than it really is, if\neveryone started using this system.\nOn Sun, Aug 19, 2018 at 5:27 AM Martin Damgaard via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Hi bitcoin-dev at lists.linuxfoundation.org\n>\n> Here is my humble attempt to make a contribution to the impressive work that you all are doing.\n>\n> I am unfamiliar with the normal BIP procedures. I have therefore just tried to follow the example of BIP 176 by Jimmy Song, in order make something similar. I suggest a universal bitcoin value color scale, for tackling the same decimal problem, as identified by the BIP 176 proposal.\n>\n> I have attached the document in three different formats (*.rtf, *.pdf and *.docx) as I do not know your preferred format. I hope you will find my suggestion useful.\n>\n>\n>\n> Thank you and all the best\n>\n> Martin Damgaard\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180912/8120c4fb/attachment.html>"
            },
            {
                "author": "Clark Moody",
                "date": "2018-09-12T14:54:15",
                "message_text_only": "This is the sort of thing I expect to emerge from the places that use\nBitcoin \"on the street.\" We should be watching how local wallet software\ndisplays bitcoin amounts, letting the standards write themselves over time.\nThe units debate (bits, millibits, etc) has been going on nearly as long as\nI've known about Bitcoin and yet most tools display standard bitcoin\namounts (1 unit = 1e8 satoshi).\n\n\n-Clark\n\n\nOn Wed, Sep 12, 2018 at 8:41 AM Martin Damgaard via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> A very good point. I have realized the immature nature of my suggestion\n> due to this and a number of other good remarks, and will like to retract\n> the initial suggestion.\n>\n> Thank you and all the best\n>\n> Martin Damgaard\n>\n>\n>\n> *Fra: *Karl-Johan Alm <karljohan-alm at garage.co.jp>\n> *Sendt: *12. september 2018 08:14\n> *Til: *damgaard.martin at gmail.com; Bitcoin Protocol Discussion\n> <bitcoin-dev at lists.linuxfoundation.org>\n> *Emne: *Re: [bitcoin-dev] Suggestion for a universal bitcoin value scale\n>\n>\n>\n> A potential problem is that it would be a new attack vector to simply\n>\n> color something to appear as e.g. 10x more than it really is, if\n>\n> everyone started using this system.\n>\n> On Sun, Aug 19, 2018 at 5:27 AM Martin Damgaard via bitcoin-dev\n>\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> >\n>\n> > Hi bitcoin-dev at lists.linuxfoundation.org\n>\n> >\n>\n> > Here is my humble attempt to make a contribution to the impressive work\n> that you all are doing.\n>\n> >\n>\n> > I am unfamiliar with the normal BIP procedures. I have therefore just\n> tried to follow the example of BIP 176 by Jimmy Song, in order make\n> something similar. I suggest a universal bitcoin value color scale, for\n> tackling the same decimal problem, as identified by the BIP 176 proposal.\n>\n> >\n>\n> > I have attached the document in three different formats (*.rtf, *.pdf\n> and *.docx) as I do not know your preferred format. I hope you will find my\n> suggestion useful.\n>\n> >\n>\n> >\n>\n> >\n>\n> > Thank you and all the best\n>\n> >\n>\n> > Martin Damgaard\n>\n> >\n>\n> > _______________________________________________\n>\n> > bitcoin-dev mailing list\n>\n> > bitcoin-dev at lists.linuxfoundation.org\n>\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180912/c2479290/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Suggestion for a universal bitcoin value scale",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Clark Moody",
                "damgaard.martin at gmail.com",
                "Karl-Johan Alm"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 5505
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Core 0.16.3 released",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2018-09-18T21:07:35",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nBitcoin Core version 0.16.3 is now available from:\n\n  <https://bitcoincore.org/bin/bitcoin-core-0.16.3/>\n\nor through bittorrent\n\n    magnet:?xt=urn:btih:a6015029671a445a7a07026b3e4a0fe54c2b2df3&dn=bitcoin-core-0.16.3&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969&tr=udp%3A%2F%2Fzer0day.ch%3A1337&tr=udp%3A%2F%2Fexplodie.org%3A6969\n\nThis is a new minor version release, with various bugfixes.\n\nPlease report bugs using the issue tracker at GitHub:\n\n  <https://github.com/bitcoin/bitcoin/issues>\n\nTo receive security and update notifications, please subscribe to:\n\n  <https://bitcoincore.org/en/list/announcements/join/>\n\nHow to Upgrade\n==============\n\nIf you are running an older version, shut it down. Wait until it has completely\nshut down (which might take a few minutes for older versions), then run the\ninstaller (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)\nor `bitcoind`/`bitcoin-qt` (on Linux).\n\nThe first time you run version 0.15.0 or newer, your chainstate database will be converted to a\nnew format, which will take anywhere from a few minutes to half an hour,\ndepending on the speed of your machine.\n\nNote that the block database format also changed in version 0.8.0 and there is no\nautomatic upgrade code from before version 0.8 to version 0.15.0 or higher. Upgrading\ndirectly from 0.7.x and earlier without re-downloading the blockchain is not supported.\nHowever, as usual, old wallet versions are still supported.\n\nDowngrading warning\n- -------------------\n\nWallets created in 0.16 and later are not compatible with versions prior to 0.16\nand will not work if you try to use newly created wallets in older versions. Existing\nwallets that were created with older versions are not affected by this.\n\nCompatibility\n==============\n\nBitcoin Core is extensively tested on multiple operating systems using\nthe Linux kernel, macOS 10.8+, and Windows Vista and later. Windows XP is not supported.\n\nBitcoin Core should also work on most other Unix-like systems but is not\nfrequently tested on them.\n\nNotable changes\n===============\n\nDenial-of-Service vulnerability\n- -------------------------------\n\nA denial-of-service vulnerability (CVE-2018-17144) exploitable by miners has\nbeen discovered in Bitcoin Core versions 0.14.0 up to 0.16.2. It is recommended\nto upgrade any of the vulnerable versions to 0.16.3 as soon as possible.\n\n0.16.3 change log\n- ------------------\n\n### Consensus\n- - #14249 `696b936` Fix crash bug with duplicate inputs within a transaction (TheBlueMatt, sdaftuar)\n\n### RPC and other APIs\n- - #13547 `212ef1f` Make `signrawtransaction*` give an error when amount is needed but missing (ajtowns)\n\n### Miscellaneous\n- - #13655 `1cdbea7` bitcoinconsensus: invalid flags error should be set to `bitcoinconsensus_err` (afk11)\n\n### Documentation\n- - #13844 `11b9dbb` correct the help output for -prune (hebasto)\n\nCredits\n=======\n\nThanks to everyone who directly contributed to this release:\n\n- - Anthony Towns\n- - Hennadii Stepanov\n- - Matt Corallo\n- - Suhas Daftuar\n- - Thomas Kerin\n- - Wladimir J. van der Laan\n\nAnd to those that reported security issues:\n\n- - (anonymous reporter)\n\n-----BEGIN PGP SIGNATURE-----\n\niQEzBAEBCgAdFiEEnerg3HBjJJ+wVHRoHkrtYphs0l0FAluhaKgACgkQHkrtYphs\n0l1r5gf+IVeOOWeZd61ARt+0pfy2KnDRgKh7x0RJ7AFl6mWyply21zUQQx+Q6leB\nP0IkzH31ssA9oKMUW6J0s8VavQ22OqHwbqrPRDXazf7auJ81jeR6Tmfkev4xg5fC\njyRQH4klctT0jDT1P+vtMejP50iqRxDC3TP9X9sXKZupGyHQuhu8XoXGZ1JF+PEX\nBa/sLiz3+d/0n6KiplI4ycnEZC5Q2hRw4O4c/2wjIdqd5hEhSH2ylmztYs2TM388\nNoaPEIL9niIjwAUI4bBYNebwyRStcqoK4JEdZhvM1aXd39eymPsYUTtUcr5HL9n6\nzFo8I0CXoVWT0bOGsubmo58/o2xcSg==\n=9rAz\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.16.3 released",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Wladimir J. van der Laan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3807
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Core update notice",
        "thread_messages": [
            {
                "author": "Pieter Wuille",
                "date": "2018-09-19T00:06:17",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nHello all,\n\nBitcoin Core 0.16.3 was just released with a fix for\nCVE-2018-17144:\nhttps://bitcoincore.org/en/2018/09/18/release-0.16.3/\n\nWe urge all network participants to upgrade to 0.16.3[*] as soon\nas possible.\n\n[*] For those who build from source, the 0.14, 0.15, 0.16, 0.17,\nand master branches on GitHub (https://github.com/bitcoin/bitcoin)\nare fixed as well.\n\n- --\nPieter\n-----BEGIN PGP SIGNATURE-----\n\niQIzBAEBCgAdFiEErGYmFy4AqCz/rolypjbpdjH3Z+AFAluhkogACgkQpjbpdjH3\nZ+AZFg//a1UzupFYJPwM8iFWycIk3iU6VijgvuoeWv4Bq+BHxw/UtVsyI5XA4X/M\n27wm7RtHQvgP/5BcWOTyXtX3WorKAVs3y6Ha3Ib67DEWUQ7HmWex1H5iSShO3PS0\nlle1mwfqRY0/vC/zjIqqXiGrTstvy7Et6evTqc2zrsJrsc5pxyKxehYb0dtaR+9e\nCzoioYhUWcYxy0LCtMztVBUlts8OfMK1xhpCDCk/XIVoJEqJuW5/wmux9tR0sxoJ\nelEVdRGPrNfQ4lPQXDin8oUuRQ/bdfjncOu+CEWS6LgIIUXdWbzehxLpG80jCvzM\nId7ALPsTgazfj0y8EUyBlkrwlgHHIxGpHfxUJyybWMvJmjbRCQpIMKSTNsuY4DxD\nmi8p2ZTfM03k7nLZbiZZdI3sGw6eACrTIx38tS+MiC8Hr69lHClTww8Q4qsMqHHd\nX/eOQXLTtPzLeN9m5SmoFGFlHyHFMs+hMrhzIpig9n+sZbrYvDBOJlw28t3tYGKR\nZ/WfpIUot6HdWJjsNkf3BLZF12BB/iwe2AplYYqUE8N8b6mJvbA2PkcXNbgAGexR\nySGl/CTMrpDKE5/m7cjP3h/5CSQ5M4YBPI3HijCWJQ/fSoAq9VTz0x+9V3pJyiDf\nfSSdJa7QhS3flBcQ3HlrXaLBaosHoT3PHf4d16iyR6fvcn4s4HQ=\n=nubz\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core update notice",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Pieter Wuille"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1260
        }
    },
    {
        "title": "[bitcoin-dev] [bitcoin-core-dev] Bitcoin Core update notice",
        "thread_messages": [
            {
                "author": "gb",
                "date": "2018-09-21T22:39:46",
                "message_text_only": "If the bugfix can be backported to earlier versions why is the\nhype/hysteria about \"everybody\" must immediately upgrade to 0.16.3\ncurrently being spread on the forums/reddit?\n\nhttps://bitcointalk.org/index.php?topic=5034070.0\nhttps://old.reddit.com/r/Bitcoin/comments/9hp90p/1775_nodes_out_of_9616_185_are_currently_on/\n\nI don't see any effort to correct this misinformation either.\n\nRegards.\n\nOn Tue, 2018-09-18 at 17:06 -0700, Pieter Wuille via bitcoin-core-dev\nwrote:\n> Hello all,\n> \n> Bitcoin Core 0.16.3 was just released with a fix for\n> CVE-2018-17144:\n> https://bitcoincore.org/en/2018/09/18/release-0.16.3/\n> \n> We urge all network participants to upgrade to 0.16.3[*] as soon\n> as possible.\n> \n> [*] For those who build from source, the 0.14, 0.15, 0.16, 0.17,\n> and master branches on GitHub (https://github.com/bitcoin/bitcoin)\n> are fixed as well.\n> \n> --\n> Pieter\n> _______________________________________________\n> bitcoin-core-dev mailing list\n> bitcoin-core-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-core-dev"
            },
            {
                "author": "Andrew Chow",
                "date": "2018-09-22T04:56:13",
                "message_text_only": "The backported versions have not been released yet. They are still going\nthrough the gitian build process. 0.16.3 was the first one to be\nreleased so that is the one that everyone is being recommended to\nupgrade to. Regardless, you should upgrade to a patched version, whether\nthat is 0.14.3, 0.15.2, or 0.16.3. It is not misinformation that\neverybody must upgrade.\n\n\nOn 09/21/2018 06:39 PM, gb via bitcoin-dev wrote:\n> If the bugfix can be backported to earlier versions why is the\n> hype/hysteria about \"everybody\" must immediately upgrade to 0.16.3\n> currently being spread on the forums/reddit?\n>\n> https://bitcointalk.org/index.php?topic=5034070.0\n> https://old.reddit.com/r/Bitcoin/comments/9hp90p/1775_nodes_out_of_9616_185_are_currently_on/\n>\n> I don't see any effort to correct this misinformation either.\n>\n> Regards.\n>\n> On Tue, 2018-09-18 at 17:06 -0700, Pieter Wuille via bitcoin-core-dev\n> wrote:\n>> Hello all,\n>>\n>> Bitcoin Core 0.16.3 was just released with a fix for\n>> CVE-2018-17144:\n>> https://bitcoincore.org/en/2018/09/18/release-0.16.3/\n>>\n>> We urge all network participants to upgrade to 0.16.3[*] as soon\n>> as possible.\n>>\n>> [*] For those who build from source, the 0.14, 0.15, 0.16, 0.17,\n>> and master branches on GitHub (https://github.com/bitcoin/bitcoin)\n>> are fixed as well.\n>>\n>> --\n>> Pieter\n>> _______________________________________________\n>> bitcoin-core-dev mailing list\n>> bitcoin-core-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-core-dev\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2018-09-22T04:59:53",
                "message_text_only": "On Sat, Sep 22, 2018 at 4:25 AM gb via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> If the bugfix can be backported to earlier versions why is the\n\nHave been backported, not merely can be.\n\n> hype/hysteria about \"everybody\" must immediately upgrade to 0.16.3\n> currently being spread on the forums/reddit?\n\nFor instructions to be effective they need to be concise.  Presenting\npeople with a complex decision tree is not a way to maximize wellfare.\n\nThe few parties that would be better off on some other version already\nknow that they have some reason to not run the latest stable, and can\ndo more research to find out their other options.   The announcement\nposted on the bitcoin core site, I think is adequately clear but if\nyou see an opportunity to improve it, please make suggestions.\n\n> I don't see any effort to correct this misinformation either.\n\nIt's decent advice, not misinformation.  You can run the fixed earlier\nversions but they have other issues, I wouldn't recommend anyone run\nolder versions generally.\n\nReasoning about risk is complicated. For example, when people were\ntalking about only the crash component of the issue there were some\npeople stating \"I don't care if I go down, an unlikely delay in\nprocessing payments would not be a problem.\"  But, in fact, a network\nexploitable crash is pretty dangerous: an attacker can carve up the\nnetwork into partitions that will produce long valid forks and reorg\nagainst each other, enabling double-spends.   The best one sentence\nadvice available is to upgrade to the latest version. You'd probably\nhave to get up to two page explanations discussing trade-offs before\nit makes sense to talk about running a fixed 0.14 or what not.\n\nTheymos' language is stronger than I would have chosen, but I think\nit's language that errors on the side of protecting people from harm."
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core update notice",
            "categories": [
                "bitcoin-dev",
                "bitcoin-core-dev"
            ],
            "authors": [
                "Andrew Chow",
                "Gregory Maxwell",
                "gb"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 4653
        }
    },
    {
        "title": "[bitcoin-dev] SLIP-0039: Shamir's Secret-Sharing for Mnemonic Codes",
        "thread_messages": [
            {
                "author": "Andrew Kozlik",
                "date": "2018-09-20T16:19:56",
                "message_text_only": "Hello everyone,\n\nWe are currently writing a new specification for splitting BIP-32 master\nseeds into multiple mnemonics using Shamir's secret sharing scheme. We\nwould be interested in getting your feedback with regard to the\nhigh-level design of the new spec:\nhttps://github.com/satoshilabs/slips/blob/master/slip-0039.md\nPlease focus your attention on the section entitled \"Master secret\nderivation functions\", which proposes several different solutions. Note\nthat there is a Design Rationale section at the very end of the\ndocument, which should answer some of the questions you may have. The\ndocument is a work in progress and we are aware that some technical\ndetails have not been fully specified. These will be completed once the\nhigh level design has been settled.\n\nThanks,\n\nAndrew Kozlik\nTREZOR Team"
            },
            {
                "author": "Christopher Allen",
                "date": "2018-09-21T19:29:33",
                "message_text_only": "On Fri, Sep 21, 2018 at 11:18 AM Andrew Kozlik via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> We are currently writing a new specification for splitting BIP-32 master\n> seeds into multiple mnemonics using Shamir's secret sharing scheme. We\n> would be interested in getting your feedback with regard to the\n> high-level design of the new spec:\n> https://github.com/satoshilabs/slips/blob/master/slip-0039.md\n> Please focus your attention on the section entitled \"Master secret\n> derivation functions\", which proposes several different solutions. Note\n> that there is a Design Rationale section at the very end of the\n> document, which should answer some of the questions you may have. The\n> document is a work in progress and we are aware that some technical\n> details have not been fully specified. These will be completed once the\n> high level design has been settled.\n>\n\nI and a number of companies & communities I am involved with are very\ninterested in this.\n\nA challenge is that Shamir Secret Sharing has subtleties. To quote Greg\nMaxwell:\n\n> I think Shamir Secret Sharing (and a number of other things, RNGs for\nexample), suffer from a property where they are just complex enough that\npeople are excited to implement them often for little good reason, and then\nthey are complex enough (or have few enough reasons to invest significant\ntime) they implement them poorly\u201d.\n\nSome questions for you:\n\n* What other teams or communities besides Trezor are committed to\nstandardizing a Shamir Secret Sharing Scheme? I can say that the\n#RebootingWebOfTrust community (meeting again for the 7th time next week in\nToronto https://rwot7.eventbrite.com) are very interested.\n\n* Where do you want to hold discussions on this? Do people object to having\nthis discussion on this mailing list? Or should it be issues in SLIPS repo\nor on some other mailing list?\n\n* Presuming a successful split of secrets, I don\u2019t know all the adversarial\nproblems that are associated with recovery of a SSS. As this would be an\ninteractive event, I presume an attacker can DOS a request to reassemble\nkeys (so maybe some the of integrity of each share vs all is required). And\nof course there are the biggest problems:  impersonation of a reassembly\nrequest and a MitM of a reassembly request. Are there other attacks? Are\nyou trying to mitigate any of these?\n\nTwo comments:\n\n* The Lightning Network community has added to their BIP32 mnemonics the\nability to have a birthday in the seed, to make it easier  to scan the\nblockchain for keys, as well as a byte with some way to know how to derive\nkeys paths for it. I don\u2019t seee a BOLT for this (it was mentioned in\nhttps://bitcoin.stackexchange.com/questions/74805/what-is-birthday-in-the-context-of-bip39-lightning-seed-generation)\n I would suggest that you also get some of their latest thoughts and\nincorporate them.\n\n* I worked with Chris Vickery while at Blockstrham on various possible ways\nto improve mnemonic word lists. I\u2019m not suggesting that you necessarily go\nas far as we did to try to create a mnemonic that is iambic pentameter\npoetry (inspired by\nhttps://www.isi.edu/natural-language/mt/memorize-random-60.pdf), however,\nwe did find sources for words that are concrete (for example table is more\nconcrete than truth\nhttp://crr.ugent.be/papers/Brysbaert_Warriner_Kuperman_BRM_Concreteness_ratings.pdf\n) or have strong emotional valence attachment (truth is more emotional than\ntable), both of which make can words more memorable. I also found lists of\nwords that are hard to pronounce unless you are English native, and\neliminated them from my own list.\n\nAmong the results of this was a new BIP-39 2048 word compatible word list\nfiltered for memorability (concreteness & emotional valence) and\nsuitability for iambic pentameter, which is located:\n\n\nhttps://github.com/ChristopherA/iambic-mnemonic/blob/master/word-lists/iambic-wordlist.json\n\n\n\u2026which was created from the repo at\n\n    https://github.com/ChristopherA/password_poem\n\nYou can a number of other word lists that I\u2019ve collected here\nhttps://github.com/ChristopherA/iambic-mnemonic/blob/master/word-lists/\n\nIf you want to replicate what we did with your own criteria, you may want\nto incorporate information from the CMU dictitionary\nhttp://www.speech.cs.cmu.edu/cgi-bin/cmudict, the top 5000 words\nhttps://github.com/ChristopherA/password_poem/blob/master/top5000.json,\n concrete word lists\nhttp://crr.ugent.be/papers/Concreteness_ratings_Brysbaert_et_al_BRM.txt and\nemotional words  (valence) http://crr.ugent.be/archives/1003\n\n\u2014 Christopher Allen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180921/6018e9cd/attachment-0001.html>"
            },
            {
                "author": "vizeet srivastava",
                "date": "2018-09-22T04:54:24",
                "message_text_only": "I see one benefit which i am looking for. I may not need to use all public\nkeys in p2sh script instead i can use p2pkh and retrieve funds by using\nthreshold number of keys..so in case i loose a public key along with\nprivate key i still may have other public key private key pairs to\nretrieve. For me it sounds interesting. I need to understand how it is\ngoing to get implemented in more detail.\n\nOn Sat 22 Sep, 2018, 9:53 AM Christopher Allen via bitcoin-dev, <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Fri, Sep 21, 2018 at 11:18 AM Andrew Kozlik via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> We are currently writing a new specification for splitting BIP-32 master\n>> seeds into multiple mnemonics using Shamir's secret sharing scheme. We\n>> would be interested in getting your feedback with regard to the\n>> high-level design of the new spec:\n>> https://github.com/satoshilabs/slips/blob/master/slip-0039.md\n>> Please focus your attention on the section entitled \"Master secret\n>> derivation functions\", which proposes several different solutions. Note\n>> that there is a Design Rationale section at the very end of the\n>> document, which should answer some of the questions you may have. The\n>> document is a work in progress and we are aware that some technical\n>> details have not been fully specified. These will be completed once the\n>> high level design has been settled.\n>>\n>\n> I and a number of companies & communities I am involved with are very\n> interested in this.\n>\n> A challenge is that Shamir Secret Sharing has subtleties. To quote Greg\n> Maxwell:\n>\n> > I think Shamir Secret Sharing (and a number of other things, RNGs for\n> example), suffer from a property where they are just complex enough that\n> people are excited to implement them often for little good reason, and then\n> they are complex enough (or have few enough reasons to invest significant\n> time) they implement them poorly\u201d.\n>\n> Some questions for you:\n>\n> * What other teams or communities besides Trezor are committed to\n> standardizing a Shamir Secret Sharing Scheme? I can say that the\n> #RebootingWebOfTrust community (meeting again for the 7th time next week in\n> Toronto https://rwot7.eventbrite.com) are very interested.\n>\n> * Where do you want to hold discussions on this? Do people object to\n> having this discussion on this mailing list? Or should it be issues in\n> SLIPS repo or on some other mailing list?\n>\n> * Presuming a successful split of secrets, I don\u2019t know all the\n> adversarial problems that are associated with recovery of a SSS. As this\n> would be an interactive event, I presume an attacker can DOS a request to\n> reassemble keys (so maybe some the of integrity of each share vs all is\n> required). And of course there are the biggest problems:  impersonation of\n> a reassembly request and a MitM of a reassembly request. Are there other\n> attacks? Are you trying to mitigate any of these?\n>\n> Two comments:\n>\n> * The Lightning Network community has added to their BIP32 mnemonics the\n> ability to have a birthday in the seed, to make it easier  to scan the\n> blockchain for keys, as well as a byte with some way to know how to derive\n> keys paths for it. I don\u2019t seee a BOLT for this (it was mentioned in\n> https://bitcoin.stackexchange.com/questions/74805/what-is-birthday-in-the-context-of-bip39-lightning-seed-generation)\n>  I would suggest that you also get some of their latest thoughts and\n> incorporate them.\n>\n> * I worked with Chris Vickery while at Blockstrham on various possible\n> ways to improve mnemonic word lists. I\u2019m not suggesting that you\n> necessarily go as far as we did to try to create a mnemonic that is iambic\n> pentameter poetry (inspired by\n> https://www.isi.edu/natural-language/mt/memorize-random-60.pdf), however,\n> we did find sources for words that are concrete (for example table is more\n> concrete than truth\n> http://crr.ugent.be/papers/Brysbaert_Warriner_Kuperman_BRM_Concreteness_ratings.pdf\n> ) or have strong emotional valence attachment (truth is more emotional than\n> table), both of which make can words more memorable. I also found lists of\n> words that are hard to pronounce unless you are English native, and\n> eliminated them from my own list.\n>\n> Among the results of this was a new BIP-39 2048 word compatible word list\n> filtered for memorability (concreteness & emotional valence) and\n> suitability for iambic pentameter, which is located:\n>\n>\n> https://github.com/ChristopherA/iambic-mnemonic/blob/master/word-lists/iambic-wordlist.json\n>\n>\n> \u2026which was created from the repo at\n>\n>     https://github.com/ChristopherA/password_poem\n>\n> You can a number of other word lists that I\u2019ve collected here\n> https://github.com/ChristopherA/iambic-mnemonic/blob/master/word-lists/\n>\n> If you want to replicate what we did with your own criteria, you may want\n> to incorporate information from the CMU dictitionary\n> http://www.speech.cs.cmu.edu/cgi-bin/cmudict, the top 5000 words\n> https://github.com/ChristopherA/password_poem/blob/master/top5000.json,\n>  concrete word lists\n> http://crr.ugent.be/papers/Concreteness_ratings_Brysbaert_et_al_BRM.txt\n> and emotional words  (valence) http://crr.ugent.be/archives/1003\n>\n> \u2014 Christopher Allen\n>\n>\n>\n>\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180922/daf55cc6/attachment-0001.html>"
            },
            {
                "author": "Andrew Kozlik",
                "date": "2018-09-26T12:12:40",
                "message_text_only": "Thanks for your input Christopher. Since we already have the discussion\nabout your comments running under the issues in the SLIPs repo on Github\n(https://github.com/satoshilabs/slips/issues), let's continue it there.\n\nAndrew Kozlik\n\n\nOn 21.9.2018 21:29, Christopher Allen wrote:\n> On Fri, Sep 21, 2018 at 11:18 AM Andrew Kozlik via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>\n>     We are currently writing a new specification for splitting BIP-32\n>     master\n>     seeds into multiple mnemonics using Shamir's secret sharing scheme. We\n>     would be interested in getting your feedback with regard to the\n>     high-level design of the new spec:\n>     https://github.com/satoshilabs/slips/blob/master/slip-0039.md\n>     Please focus your attention on the section entitled \"Master secret\n>     derivation functions\", which proposes several different solutions.\n>     Note\n>     that there is a Design Rationale section at the very end of the\n>     document, which should answer some of the questions you may have. The\n>     document is a work in progress and we are aware that some technical\n>     details have not been fully specified. These will be completed\n>     once the\n>     high level design has been settled.\n>\n>\n> I and a number of companies & communities I am involved with are very\n> interested in this.\u00a0\n>\n> A challenge is that Shamir Secret Sharing has subtleties. To quote\n> Greg Maxwell:\n>\n> > I think Shamir Secret Sharing (and a number of other things, RNGs\n> for example), suffer from a property where they are just complex\n> enough that people are excited to implement them often for little good\n> reason, and then they are complex enough (or have few enough reasons\n> to invest significant time) they implement them poorly\u201d.\n>\n> Some questions for you:\n>\n> * What other teams or communities besides Trezor are committed to\n> standardizing a Shamir Secret Sharing Scheme? I can say that the\n> #RebootingWebOfTrust community (meeting again for the 7th time next\n> week in Toronto https://rwot7.eventbrite.com) are very interested.\n>\n> * Where do you want to hold discussions on this? Do people object to\n> having this discussion on this mailing list? Or should it be\u00a0issues in\n> SLIPS repo or on some other mailing list?\u00a0\n>\n> * Presuming a successful split of secrets, I don\u2019t know all the\n> adversarial problems that are associated with recovery of a SSS. As\n> this would be an interactive event, I presume an attacker can DOS a\n> request to reassemble keys (so maybe some the of integrity of each\n> share vs all is required). And of course there are the biggest\n> problems: \u00a0impersonation of a reassembly request and a MitM of a\n> reassembly request. Are there other attacks? Are you trying to\n> mitigate any of these?\n>\n> Two comments:\n>\n> * The Lightning Network community has added to their BIP32 mnemonics\n> the ability to have a birthday in the seed, to make it easier \u00a0to scan\n> the blockchain for keys, as well as a byte with some way to know how\n> to derive keys paths for it. I don\u2019t seee a BOLT for this (it was\n> mentioned\n> in\u00a0https://bitcoin.stackexchange.com/questions/74805/what-is-birthday-in-the-context-of-bip39-lightning-seed-generation)\n> \u00a0I would suggest that you also get some of their latest thoughts and\n> incorporate them.\n>\n> * I worked with Chris Vickery while at Blockstrham on various possible\n> ways to improve mnemonic word lists. I\u2019m not suggesting that you\n> necessarily go as far as we did to try to create a mnemonic that is\n> iambic pentameter poetry (inspired by\n> https://www.isi.edu/natural-language/mt/memorize-random-60.pdf),\n> however, we did find sources for words that are concrete (for example\n> table is more concrete than truth\n> http://crr.ugent.be/papers/Brysbaert_Warriner_Kuperman_BRM_Concreteness_ratings.pdf\n> ) or have strong emotional valence attachment (truth is more emotional\n> than table), both of which make can words more memorable. I also found\n> lists of words that are hard to pronounce unless you are English\n> native, and eliminated them from my own list.\u00a0\n>\n> Among the results of this was a new BIP-39 2048 word compatible word\n> list filtered for memorability (concreteness & emotional valence) and\n> suitability for iambic pentameter, which is located:\n>\n> \u00a0 \u00a0\n> https://github.com/ChristopherA/iambic-mnemonic/blob/master/word-lists/iambic-wordlist.json\u00a0\n>\n> \u2026which was created from the repo at\n>\n> \u00a0 \u00a0 https://github.com/ChristopherA/password_poem\n>\n> You can a number of other word lists that I\u2019ve collected here\n> https://github.com/ChristopherA/iambic-mnemonic/blob/master/word-lists/\n>\n> If you want to replicate what we did with your own criteria, you may\n> want to incorporate information from the CMU\n> dictitionary\u00a0http://www.speech.cs.cmu.edu/cgi-bin/cmudict, the top\n> 5000\n> words\u00a0https://github.com/ChristopherA/password_poem/blob/master/top5000.json,\n> \u00a0concrete word lists\n> http://crr.ugent.be/papers/Concreteness_ratings_Brysbaert_et_al_BRM.txt\n> and emotional words \u00a0(valence)\u00a0http://crr.ugent.be/archives/1003\n>\n> \u2014 Christopher Allen\n>\n>\n>\n>\n>\n>\n>\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180926/8bf2bddf/attachment-0001.html>"
            },
            {
                "author": "Ignacio Berrozpe",
                "date": "2018-09-24T19:49:08",
                "message_text_only": "Hi Andrew\n\nPlease allow me to comment on your work, as I happened to publish an\narticle 5 months ago proposing SSS to split bitcoins private keys into\nshares that could be encoded directly using BIP-0039 mnemonic words. While\ncryptographically much simpler than your proposal, the proposal had the\ncharacteristic that it could be applied directly to existing private keys\nbackups, by splitting the keys into SSS shares that could benefit from the\nexisting BIP-0039 mnemonic to encode directly the shares. I thought it\nwould be a simple path for hardware wallets providers such as Trezor into\nproviding a better/more secure alternative the existing BIP-0039 privatekey\nbackups of 24 words.\n\nThe article can be found here, and I've enclosed a simplified version\n\nhttps://privatekeys.org/2018/04/24/k-of-m-private-key-generation-and-backup-in-bitcoin-wallets/\n\nMind two questions? Your proposed work provides a way to split the\npre-secret into SSS shares, a format of encoding the shares, and finally\nseveral methods to derive the master secret from the pre-secret. Would you\nenvision standarizing these different topics under the same proposal? Also,\nhave you thought of a way to deal with the existing legacy privatekeys\nalready encoded into BIP-0039, or stored in other formats, and how to\nmigrate them securely into a schema of encoded SSS shares?\n\nBest regards\nIgnacio Berrozpe\n\n\n\n\n\n\n\nOn Fri, Sep 21, 2018 at 8:18 PM Andrew Kozlik via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello everyone,\n>\n> We are currently writing a new specification for splitting BIP-32 master\n> seeds into multiple mnemonics using Shamir's secret sharing scheme. We\n> would be interested in getting your feedback with regard to the\n> high-level design of the new spec:\n> https://github.com/satoshilabs/slips/blob/master/slip-0039.md\n> Please focus your attention on the section entitled \"Master secret\n> derivation functions\", which proposes several different solutions. Note\n> that there is a Design Rationale section at the very end of the\n> document, which should answer some of the questions you may have. The\n> document is a work in progress and we are aware that some technical\n> details have not been fully specified. These will be completed once the\n> high level design has been settled.\n>\n> Thanks,\n>\n> Andrew Kozlik\n> TREZOR Team\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180924/9bc30814/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: KofM  Private Key Generation and Backup in Bitcoin Wallets _ Submit.rtf\nType: application/msword\nSize: 1074372 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180924/9bc30814/attachment-0001.doc>"
            },
            {
                "author": "Andrew Kozlik",
                "date": "2018-09-26T13:44:16",
                "message_text_only": "Thank you for your input Ignacio. Looking at your proposal, I see that\nits main feature is that it makes one of the shares privileged in the\nsense that it must always take part in the reconstruction of the master\nsecret, while the remaining shares follow the K-of-M scheme. This is an\ninteresting idea.\n\nTo answer your questions:\n\n> Your proposed work provides a way to split the pre-secret into SSS\n> shares, a format of encoding the shares, and finally several methods\n> to derive the master secret from the pre-secret. Would you envision\n> standarizing these different topics under the same proposal?\nWe intend standardize the encoding format, splitting of the pre-master\nsecret into shares and the derivation of the master secret from the\npre-master secret in a single document. However, note that only one of\nthe four proposed master secret derivation functions will be selected\nfor the final version.\n\n> Also, have you thought of a way to deal with the existing legacy\n> privatekeys already encoded into BIP-0039, or stored in other formats,\n> and how to migrate them securely into a schema of encoded SSS shares?\nThree of the four proposed master secret derivation functions are\nsymmetric, which means that they allow users to migrate any existing\nmaster secret (including a BIP-0039 mnemonic) to the new scheme.\n\nThanks,\nAndrew Kozlik\n\n\nOn 24.9.2018 21:49, Ignacio Berrozpe wrote:\n> Hi Andrew\n>\n> Please allow me to comment on your work, as I happened to publish an\n> article 5 months ago proposing SSS to split bitcoins private keys into\n> shares that could be encoded directly using BIP-0039 mnemonic words.\n> While cryptographically much simpler than your proposal, the proposal\n> had the characteristic that it could be applied directly to existing\n> private keys backups, by splitting the keys into SSS shares that could\n> benefit from the existing BIP-0039 mnemonic to encode directly the\n> shares. I thought it would be a simple path for hardware wallets\n> providers such as Trezor into providing a better/more secure\n> alternative the existing BIP-0039 privatekey backups of 24 words.\n>\n> The article can be found here, and I've enclosed a simplified version\n>\n> https://privatekeys.org/2018/04/24/k-of-m-private-key-generation-and-backup-in-bitcoin-wallets/\n>\n> Mind two questions? Your proposed work provides a way to split the\n> pre-secret into SSS shares, a format of encoding the shares, and\n> finally several methods to derive the master secret from the\n> pre-secret. Would you envision standarizing these different topics\n> under the same proposal? Also, have you thought of a way to deal with\n> the existing legacy privatekeys already encoded into BIP-0039, or\n> stored in other formats, and how to migrate them securely into a\n> schema of encoded SSS shares?\n>\n> Best regards\n> Ignacio Berrozpe\n>\n>\n>\n>\n>\n>\n>\n> On Fri, Sep 21, 2018 at 8:18 PM Andrew Kozlik via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>\n>     Hello everyone,\n>\n>     We are currently writing a new specification for splitting BIP-32\n>     master\n>     seeds into multiple mnemonics using Shamir's secret sharing scheme. We\n>     would be interested in getting your feedback with regard to the\n>     high-level design of the new spec:\n>     https://github.com/satoshilabs/slips/blob/master/slip-0039.md\n>     Please focus your attention on the section entitled \"Master secret\n>     derivation functions\", which proposes several different solutions.\n>     Note\n>     that there is a Design Rationale section at the very end of the\n>     document, which should answer some of the questions you may have. The\n>     document is a work in progress and we are aware that some technical\n>     details have not been fully specified. These will be completed\n>     once the\n>     high level design has been settled.\n>\n>     Thanks,\n>\n>     Andrew Kozlik\n>     TREZOR Team\n>\n>\n>     _______________________________________________\n>     bitcoin-dev mailing list\n>     bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180926/006223da/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "SLIP-0039: Shamir's Secret-Sharing for Mnemonic Codes",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Ignacio Berrozpe",
                "Andrew Kozlik",
                "vizeet srivastava",
                "Christopher Allen"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 23939
        }
    },
    {
        "title": "[bitcoin-dev] Proposal to replace full blockchain with recent history plus UTXO Set",
        "thread_messages": [
            {
                "author": "Dave Scotese",
                "date": "2018-09-22T01:49:47",
                "message_text_only": "I've been working on an idea that relieves full nodes of storing the entire\nblockchain. Open source software generally relies on the fact that \"enough\"\npeople agree that it's secure. Bitcoin software works that way too. So if\nyou understand enough to see that a UTXO set is valid at a certain block\nheight, and there are enough other people who agree and that set is\nrecognizable by humans, then we can use that UTXO set and ditch the\nblockchain that existed up to that point. It would save a lot of storage\nand make it a lot easier to run a full node.\n\nHave you reviewed the source code from which your wallets were compiled?\nAt some point, we all trust third parties, but generally (at least among\npeople who understand Bitcoin) they are large composite groups so that no\nsmall group or individual can profit from cheating.\n\nI look forward to answering any concerns and also to any offers of help.   I\nused block 542324 of the Bitcoin blockchain to make a memorable experience\nusing the game of life. I wrote a script for the open-source Game-of-Life\nsoftware Golly and shared it in the paste at https://pastebin.com/k5Ssc0qk.\nIt produces the image at https://imgur.com/a/rwIQuVz. If someone can tell\nme how to get a UTXO Set from the bitcoin client, I'll send them $50 of\nbitcoin. Then I could get the SHA256 hash of that set and try to make a\nrecognizable checkpoint for the Bitcoin blockchain. If someone runs Golly\nand shares a video of the game playing out (into the apron-shaped image),\nI'll send them $50 of bitcoin too.\n\nIn a few decades when the blockchain has grown to a few terabytes and the\nUTXO Set is still just a few gigabytes, I'd like to see more people start\nrunning full nodes without the hassle of a long wait and loads of storage\nspace. That's what stops me from running one.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180921/90e3c480/attachment.html>"
            },
            {
                "author": "Dave Scotese",
                "date": "2018-09-25T15:47:28",
                "message_text_only": "The image at imgur and the pastebin both reference block 542324 but the\ncorrect block is 542322.  As the pastebin shows, the decimal and hex\nrepresentations I gave for the block height did not match, and this is\nwhy.  If you use the Merkle root for block 542322 instead of 542324, you'll\nbe able to see the correct Game of Life play out and make the apron image.\n\nDave.\n\nOn Fri, Sep 21, 2018 at 6:49 PM Dave Scotese <dscotese at litmocracy.com>\nwrote:\n\n> I've been working on an idea that relieves full nodes of storing the\n> entire blockchain. Open source software generally relies on the fact that\n> \"enough\" people agree that it's secure. Bitcoin software works that way\n> too. So if you understand enough to see that a UTXO set is valid at a\n> certain block height, and there are enough other people who agree and that\n> set is recognizable by humans, then we can use that UTXO set and ditch the\n> blockchain that existed up to that point. It would save a lot of storage\n> and make it a lot easier to run a full node.\n>\n> Have you reviewed the source code from which your wallets were compiled?\n> At some point, we all trust third parties, but generally (at least among\n> people who understand Bitcoin) they are large composite groups so that no\n> small group or individual can profit from cheating.\n>\n> I look forward to answering any concerns and also to any offers of help.   I\n> used block 542324 of the Bitcoin blockchain to make a memorable experience\n> using the game of life. I wrote a script for the open-source Game-of-Life\n> software Golly and shared it in the paste at https://pastebin.com/k5Ssc0qk.\n> It produces the image at https://imgur.com/a/rwIQuVz. If someone can tell\n> me how to get a UTXO Set from the bitcoin client, I'll send them $50 of\n> bitcoin. Then I could get the SHA256 hash of that set and try to make a\n> recognizable checkpoint for the Bitcoin blockchain. If someone runs Golly\n> and shares a video of the game playing out (into the apron-shaped image),\n> I'll send them $50 of bitcoin too.\n>\n> In a few decades when the blockchain has grown to a few terabytes and the\n> UTXO Set is still just a few gigabytes, I'd like to see more people start\n> running full nodes without the hassle of a long wait and loads of storage\n> space. That's what stops me from running one.\n>\n>\n\n-- \nI like to provide some work at no charge to prove my value. Do you need a\ntechie?\nI own Litmocracy <http://www.litmocracy.com> and Meme Racing\n<http://www.memeracing.net> (in alpha).\nI'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which\nnow accepts Bitcoin.\nI also code for The Dollar Vigilante <http://dollarvigilante.com/>.\n\"He ought to find it more profitable to play by the rules\" - Satoshi\nNakamoto\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180925/f5facd70/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Proposal to replace full blockchain with recent history plus UTXO Set",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Dave Scotese"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 4904
        }
    },
    {
        "title": "[bitcoin-dev] Fwd: [bitcoin-core-dev] On the initial notice of CVE-2018-17144",
        "thread_messages": [
            {
                "author": "Bryan Bishop",
                "date": "2018-09-22T17:54:12",
                "message_text_only": "---------- Forwarded message ----------\nFrom: Gregory Maxwell via bitcoin-core-dev <\nbitcoin-core-dev at lists.linuxfoundation.org>\nDate: Sat, Sep 22, 2018 at 12:12 PM\nSubject: [bitcoin-core-dev] On the initial notice of CVE-2018-17144\nTo: bitcoin-core-dev at lists.linuxfoundation.org\n\n\nFor some reason I don't understand, Andrea Suisani is stating on\ntwitter that the the report by awemany was a report of an inflation\nbug, contrary to the timeline we published.   This is not the case:\nthe report specifically stated that inflation was not possible because\nthe node crashed. It also described a reproduction of the crash, but\nnot of inflation.\n\nI generally understand how someone could be confused about what a\nreport they hadn't seen said, but I'm confused in this case because\nAndrea Suisani was copied on the report to us. So I'm not sure what is\nup with that, perhaps the message got lost in email.  If the reporter\nknew the bug permitted inflation, they still specifically reported\notherwise to us.\n\nSince people are also expressing doubt that awemany was actually the\nauthor of the report, I'll include it here in its entity to aid\npeople's validation of the claim(s). There is a better test for the\ncrash issue include in master branch of the Bitcoin repository, the\nreporter's reproduction instructions here are only included for\ncompleteness.\n\nCheers,\n\n\nDate: Mon, 17 Sep 2018 14:57:46 +0000\nTo: Pieter Wuille <pieter.wuille at gmail.com>, deadalnix\n<deadalnix at gmail.com>, Andrea Suisani <sickpig at gmail.com>, Gregory\nMaxwell <gmaxwell at gmail.com>, \"Wladimir J. van der Laan\"\n<laanwj at gmail.com>\nFrom: beardnboobies <beardnboobies at protonmail.com>\nSubject: Zero day exploit in Bitcoin ABC and Bitcoin Core\n\nDear Bitcoiners,\n\nPlease find attached an encrypted description of a crashing zero day\nexploit for Bitcoin Core as well as Bitcoin ABC. This has not been\nreproduced for Bitcoin Unlimited, though for advisory reasons, I am\nsending it to one of their members that I could find a PGP key for as\nwell.\n\nPlease forward this to any party who might have a valid interest,\nincluding Bitcoin miners.\n\nThank you very much.\n\n===\n\nProblem description:\n\nThe following, miner-exploitable zero day has been found in Bitcoin ABC as\nwell as in Bitcoin Core:\n\nDuplicate inputs are not checked in CheckBlock,\nonly when they are accepted into the mempool.\n\nThis creates a problem insofar as a transaction might bypass\nthe mempool when it is included in a block, for example if\nit is transmitted as an extra transaction along with a compact\nblock.\n\nA later assertion assert(is_spent) in SpendCoins (in validation.cpp)\nseems to prevent the worse outcome of monetary inflation by\nthe comparatively better result of crashing the node.\n\nTo reproduce (Description is for Bitcoin ABC, but applies similarly to\nBitcoin Core):\n\nCreate one instance of ABC bitcoind without the patch below\napplied (A) and create on instance of ABC with the patch applied (B).\nThe patch removes sending of transactions and testing for double-spent\ninputs for the attacker node.\n\nRun both in regtest mode and point them to different data directories,\nlike so and connect them together:\nA: ./bitcoind -regtest -rpcport=15000 -listen -debug -datadir=/tmp/abc.1\nB: ./bitcoind -regtest -rpcport=15001 -connect=localhost -debug\n-datadir=/tmp/abc.2\n\nNow on the prepared attacker node B, create a bunch of blocks and a\ntransaction\nthat double-spends its input, like  so for example:\n\n> ./bitcoin-cli -regtest -datadir=/tmp/abc.2 -rpcport=15001 generate 200\n\n> ./bitcoin-cli -regtest -datadir=/tmp/abc.2 -rpcport=15001 getnewaddress\n<address>\n\n> ./bitcoin-cli -regtest -datadir=/tmp/abc.2 -rpcport=15001 sendtoaddress\n<address>\n<resulting-txid>\n\n> ./bitcoin-tx -regtest -create in=<resulting-txid>:<vout>\nin=<resulting-txid>:<vout> outaddr=99.9:<address>\n<resulting-txn-hex>\n\nThe double entry of the input here is not a typo. This is the desired\ndouble-spend.\n\nSign the resulting transaction hex like so:\n\n> ./bitcoin-cli -regtest -datadir=/tmp/abc.2 -rpcport=15001\nsignrawtransaction <txid>\n<signed-txn-hex>\n\nFor Core, this step needs to be adapted to signrawtransactionwithkey.\nAnd send the result into the small regtest test netwrok:\n> ./bitcoin-cli -regtest -datadir=/tmp/abc.2 -rpcport=15001\nsendrawtransaction <signed-txn-hex>\n\nVoila, your node A should have just aborted like this:\n\nbitcoind: validation.cpp:1083: void SpendCoins(CCoinsViewCache&, const\nCTransaction&, CTxUndo&, int): Assertion `is_spent' failed.\nAborted (core dumped)\n\nIf you like this work or want to pay out a bounty for finding a zero day,\nplease do so in BCH to this address. Thank you very much in advance.\n\nbitcoincash:qr5yuq3q40u7mxwqz6xvamkfj8tg45wyus7fhqzug5\n\n\nThe patch for ABC:\n\ndiff --git a/src/consensus/tx_verify.cpp b/src/consensus/tx_verify.cpp\nindex ee909deb9..ff7942361 100644\n--- a/src/consensus/tx_verify.cpp\n+++ b/src/consensus/tx_verify.cpp\n@@ -229,7 +229,7 @@ static bool CheckTransactionCommon(const CTransaction\n&tx,\n\n     // Check for duplicate inputs - note that this check is slow so we\nskip it\n     // in CheckBlock\n-    if (fCheckDuplicateInputs) {\n+    if (0) {\n         std::set<COutPoint> vInOutPoints;\n         for (const auto &txin : tx.vin) {\n             if (!vInOutPoints.insert(txin.prevout).second) {\ndiff --git a/src/net_processing.cpp b/src/net_processing.cpp\nindex e4ecc793c..ee1cc3cda 100644\n--- a/src/net_processing.cpp\n+++ b/src/net_processing.cpp\n@@ -1269,12 +1269,6 @@ static void ProcessGetData(const Config\n&config, CNode *pfrom,\n                             // however we MUST always provide at least\nwhat the\n                             // remote peer needs.\n                             typedef std::pair<unsigned int, uint256>\nPairType;\n-                            for (PairType &pair : merkleBlock.vMatchedTxn)\n{\n-                                connman->PushMessage(\n-                                    pfrom,\n-                                    msgMaker.Make(NetMsgType::TX,\n-                                                  *block.vtx[pair.first]));\n-                            }\n                         }\n                         // else\n                         // no response\n@@ -1321,25 +1315,6 @@ static void ProcessGetData(const Config\n&config, CNode *pfrom,\n                 bool push = false;\n                 auto mi = mapRelay.find(inv.hash);\n                 int nSendFlags = 0;\n-                if (mi != mapRelay.end()) {\n-                    connman->PushMessage(\n-                        pfrom,\n-                        msgMaker.Make(nSendFlags, NetMsgType::TX,\n*mi->second));\n-                    push = true;\n-                } else if (pfrom->timeLastMempoolReq) {\n-                    auto txinfo = mempool.info(inv.hash);\n-                    // To protect privacy, do not answer getdata using the\n-                    // mempool when that TX couldn't have been INVed\nin reply to\n-                    // a MEMPOOL request.\n-                    if (txinfo.tx &&\n-                        txinfo.nTime <= pfrom->timeLastMempoolReq) {\n-                        connman->PushMessage(pfrom,\n-                                             msgMaker.Make(nSendFlags,\n-                                                           NetMsgType::TX,\n-                                                           *txinfo.tx));\n-                        push = true;\n-                    }\n-                }\n                 if (!push) {\n                     vNotFound.push_back(inv);\n                 }\ndiff --git a/src/validation.cpp b/src/validation.cpp\nindex a31546432..a9edbb956 100644\n--- a/src/validation.cpp\n+++ b/src/validation.cpp\n@@ -1080,7 +1080,7 @@ void SpendCoins(CCoinsViewCache &view, const\nCTransaction &tx, CTxUndo &txundo,\n     for (const CTxIn &txin : tx.vin) {\n         txundo.vprevout.emplace_back();\n         bool is_spent = view.SpendCoin(txin.prevout,\n&txundo.vprevout.back());\n-        assert(is_spent);\n+        //assert(is_spent);\n     }\n }\n\n\n----\nThe same patch for Core:\n\ndiff --git a/src/consensus/tx_verify.cpp b/src/consensus/tx_verify.cpp\nindex 0628ec1d4..a06f77f8b 100644\n--- a/src/consensus/tx_verify.cpp\n+++ b/src/consensus/tx_verify.cpp\n@@ -181,7 +181,7 @@ bool CheckTransaction(const CTransaction& tx,\nCValidationState &state, bool fChe\n     }\n\n     // Check for duplicate inputs - note that this check is slow so\nwe skip it in CheckBlock\n-    if (fCheckDuplicateInputs) {\n+    if (0) {\n         std::set<COutPoint> vInOutPoints;\n         for (const auto& txin : tx.vin)\n         {\ndiff --git a/src/net_processing.cpp b/src/net_processing.cpp\nindex b48a3bd22..9b7fb5839 100644\n--- a/src/net_processing.cpp\n+++ b/src/net_processing.cpp\n@@ -1219,8 +1219,6 @@ void static ProcessGetBlockData(CNode* pfrom,\nconst CChainParams& chainparams, c\n                     // Thus, the protocol spec specified allows for\nus to provide duplicate txn here,\n                     // however we MUST always provide at least what\nthe remote peer needs\n                     typedef std::pair<unsigned int, uint256> PairType;\n-                    for (PairType& pair : merkleBlock.vMatchedTxn)\n-                        connman->PushMessage(pfrom,\nmsgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX,\n*pblock->vtx[pair.first]));\n                 }\n                 // else\n                     // no response\n@@ -1284,18 +1282,6 @@ void static ProcessGetData(CNode* pfrom, const\nCChainParams& chainparams, CConnm\n             bool push = false;\n             auto mi = mapRelay.find(inv.hash);\n             int nSendFlags = (inv.type == MSG_TX ?\nSERIALIZE_TRANSACTION_NO_WITNESS : 0);\n-            if (mi != mapRelay.end()) {\n-                connman->PushMessage(pfrom, msgMaker.Make(nSendFlags,\nNetMsgType::TX, *mi->second));\n-                push = true;\n-            } else if (pfrom->timeLastMempoolReq) {\n-                auto txinfo = mempool.info(inv.hash);\n-                // To protect privacy, do not answer getdata using\nthe mempool when\n-                // that TX couldn't have been INVed in reply to a\nMEMPOOL request.\n-                if (txinfo.tx && txinfo.nTime <=\npfrom->timeLastMempoolReq) {\n-                    connman->PushMessage(pfrom,\nmsgMaker.Make(nSendFlags, NetMsgType::TX, *txinfo.tx));\n-                    push = true;\n-                }\n-            }\n             if (!push) {\n                 vNotFound.push_back(inv);\n             }\ndiff --git a/src/validation.cpp b/src/validation.cpp\nindex 947192be0..66536af24 100644\n--- a/src/validation.cpp\n+++ b/src/validation.cpp\n@@ -1315,7 +1315,7 @@ void UpdateCoins(const CTransaction& tx,\nCCoinsViewCache& inputs, CTxUndo &txund\n         for (const CTxIn &txin : tx.vin) {\n             txundo.vprevout.emplace_back();\n             bool is_spent = inputs.SpendCoin(txin.prevout,\n&txundo.vprevout.back());\n-            assert(is_spent);\n+            //assert(is_spent);\n         }\n     }\n     // add outputs\n_______________________________________________\nbitcoin-core-dev mailing list\nbitcoin-core-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-core-dev\n\n\n\n-- \n- Bryan\nhttp://heybryan.org/\n1 512 203 0507\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180922/422a36a3/attachment-0001.html>"
            },
            {
                "author": "sickpig at gmail.com",
                "date": "2018-09-22T19:22:20",
                "message_text_only": "Gregory,\n\n> For some reason I don't understand, Andrea Suisani is stating on\n> twitter that the the report by awemany was a report of an inflation\n> bug, contrary to the timeline we published.\n\nguess that the fact you don't understand it, it's probably related to the fact\nthat you didn't read properly the tweet you are referring to, for reference this\nthe tweet URL https://twitter.com/sickpig/status/1043530088636194816\n\nThis is the text of such a tweet:\n\n\"He [awemany] *did not* mention the inflation bug in the email, still\nhe has proof\nhe was aware of that before sending out the report\"\n\nthen tweet continue referring a reddit post where awemany while trying\nto prove he  was the original author of the report, included a timestamped note\ncontaining the following text:\n\n    BitcoinABC does not check for duplicate inputs when processing a block,\n    only when inserting a transaction into the mempool.\n\n    This is dangerous as blocks can be generated with duplicate transactions\n    and then sent through e.g. compact block missing transactions and avoid\n    hitting the mempool, creating money out of thin air.\n\n  /u/awemany\n\nthis the timeline of the timestamping process:\n\nhttps://originstamp.org/s/5c45a1ba957362a2ba97c9f8c48d4d59d4fa990945b7094a8d2a98c3a91ed9b6\n\nas you can see the note was submitted to originstamp.org before the\nreport email was sent.\n\n>  This is not the case:\n> the report specifically stated that inflation was not possible because\n> the node crashed. It also described a reproduction of the crash, but\n> not of inflation.\n\nFurthermore as you should be aware, having been copied on the report,\nawemany specifically\nsaid that \"[the assert(is_spent)] *seems* to prevent the worse outcome\nof monetary inflation\"\n\nI guess that in the hurry of informing you and other people involved of the DoS\nvector he identified and proved, he decided to give priority to\ninforming Core about that\nrather than waiting and continue exploring the idea he had about exploiting the\ncode to create coins out of thin air."
            },
            {
                "author": "Gregory Maxwell",
                "date": "2018-09-22T20:49:04",
                "message_text_only": "On Sat, Sep 22, 2018 at 7:22 PM sickpig at gmail.com <sickpig at gmail.com> wrote:\n> > For some reason I don't understand, Andrea Suisani is stating on\n> > twitter that the the report by awemany was a report of an inflation\n> > bug, contrary to the timeline we published.\n>\n> guess that the fact you don't understand it, it's probably related to the fact\n> that you didn't read properly the tweet you are referring to, for reference this\n> the tweet URL https://twitter.com/sickpig/status/1043530088636194816\n>\n> This is the text of such a tweet\n\nOKAY.  The only tweet I was shown was this one:\n\nhttps://twitter.com/sickpig/status/1043428373530390528\n\nIt doesn't many any mention to him not reporting it and I encountered\nit in the context of another person citing it to claim it had been\nreported.\n\n> Furthermore as you should be aware, having been copied on the report,\n> awemany specifically\n> said that \"[the assert(is_spent)] *seems* to prevent the worse outcome\n> of monetary inflation\"\n\nYes, in fact I referred to the that specifically in my message as well\nas including his entire message in my post.\n\n> I guess that in the hurry of informing you and other people involved of the DoS\n> vector he identified and proved, he decided to give priority to\n> informing Core about that\n> rather than waiting and continue exploring the idea he had about exploiting the\n> code to create coins out of thin air.\n\nI'm unclear what you're now stating. Are you stating that awemany knew\nthat it could\ncause inflation but indicated otherwise to us or are you stating that\nhe did not know and\nin the abundance of caution he sent the report as fast as possible\nbefore making that\ndetermination?\n\nI'm just asking because I'm confused by your response; I don't think\nit's particularly important one way or another."
            }
        ],
        "thread_summary": {
            "title": "Fwd: On the initial notice of CVE-2018-17144",
            "categories": [
                "bitcoin-dev",
                "bitcoin-core-dev"
            ],
            "authors": [
                "Bryan Bishop",
                "sickpig at gmail.com",
                "Gregory Maxwell"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 15189
        }
    },
    {
        "title": "[bitcoin-dev] URI scheme with optional bech32 address",
        "thread_messages": [
            {
                "author": "shiva sitamraju",
                "date": "2018-09-25T06:59:48",
                "message_text_only": "Hi,\n\nI am not sure why this wasn't discussed more but it seemed like a very good\nidea to me\nhttps://www.reddit.com/r/Bitcoin/comments/9iivej/its_been_like_a_year_and_bech32_adoption_remains/\n\nQR code is very important for network wide adoption. The problem is bech32\nqr code isn't backward compatible and noone is going to show two QR codes.\nEveryone is going safe with P2SH address qr code.\n\nExample of proposed URI. I want not sure of technically best encoding, but\nthis is just for ideas\n\nbitcoin:3BnsWZiTdYVrqiPh2RP3q9Y3ZqvhbCN2it?bech32=bc1q5u92yq20hss4rc99mfu23h4dxkxn4uuyqd5dzy\nbitcoin:3BnsWZiTdYVrqiPh2RP3q9Y3ZqvhbCN2it?keyhash=a70aa2014fbc2151e0a5da78a8dead358d3af384\nbitcoin:3BnsWZiTdYVrqiPh2RP3q9Y3ZqvhbCN2it?amount=0.123&bech32=bc1q5u92yq20hss4rc99mfu23h4dxkxn4uuyqd5dzy\n\nAs merchants/exchanges adopt this QR code, wallets that support bech32 can\nchose to autopay to bech32 address  (for lower tx fee). This can create a\nnetwork effect as more people start using bech32 and when we reach enough\nwallet adoption, people can shift to just showing bech32 QR codes\n\n\n-- \nShiva S\nCEO @ Blockonomics <https://www.blockonomics.co>\nDecentralized and Permissionless Payments\nJoin us on Telegram <https://t.me/BlockonomicsCo>\nView our Welcome Guide\n<https://www.blockonomics.co/docs/blockonomics-brochure.pdf>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180925/66ec4bcb/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "URI scheme with optional bech32 address",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "shiva sitamraju"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1494
        }
    },
    {
        "title": "[bitcoin-dev] Trivia on the history of compact fraud proofs and anti censorship.",
        "thread_messages": [
            {
                "author": "Gregory Maxwell",
                "date": "2018-09-25T16:09:17",
                "message_text_only": "It's generally not /too/ important where ideas come from, even in our\nopen source non-patent encumbering world the only compensation people\nget for sharing a good idea is the credit they receive. Most of the\ntime people are still happy to see their ideas further developed, even\nif credit isn't sufficiently given.\n\nBut I'm particularly disappointed when attribution gets withheld in\nthe furtherance of political attaks. In some cases people have adopted\npublic positions that e.g. Bitcoin developers don't care about\nscalability and then show that, by comparison, they care by publishing\nwork explaining/elaborating the scaling work of Bitcoin devs, but to\nmaintain consistency with their claims go through an extended effort\nto avoid attributing them.\n\nIn two cases so far, I've painstakingly walked through an idea with a\npolitical opponent in the Bitcoin space in private, only to have them\nturn around and present the ideas I argued into their heads as novel\ninventions without a shred of credit to me or the Bitcoin development\ncommunity.\n\nOne of them was the case of Peter R and the subchains paper, which I\npreviously forwarded to the list the correspondence between myself and\nhim where I argued the concept of preconsensus as part of his disproof\nof the orphaning-controls-capacity claim.\n\nThe other is on compact fraud proofs with Justus Ranvier (again, a BU\nperson). I promptly complained directly to Justus when I saw him doing\nit. I'm now forwarding to the list for posterity, because after almost\ntwo years and several pings, I was never even given a response.\n\nThis came up to my attention today because V. Buterin published a\npaper on lite client security ( https://arxiv.org/pdf/1809.09044.pdf )\nthat was apparently unaware of proposals from our community on sampled\nanti-withholding[1]. ... and this paper cites Justus' writeup as both\nthe only example of fraud proofs previously, and evidence that\nsampling coded data was not previously considered.\n\n[1] e.g. https://download.wpsoftware.net/bitcoin/wizards/2015-04-18.html\nstarting at \"The improvement we have is this\". Error coded\nanti-withholding been discussed many times-- and I've been pretty\nbummed that I've been unable to excite people much about the idea,\nhopefully that will change with the eth hype machine behind it--, but\nthis particular citation is while not the earliest or clearest\ndescription, perfect for this case since the context is that it's a\ncomplaint that the same author was failing to cite our communities\npast efforts on fraud proofs, and as a result they weren't aware of\nthe state of the art like anti-withholding.\n\n---------- Forwarded message ---------\nFrom: Gregory Maxwell <gmaxwell at gmail.com>\nDate: Fri, Nov 25, 2016 at 9:46 PM\nSubject: A plea for ethical behavior\nTo: Justus Ranvier <justusranvier at gmail.com>\n\n\nhttps://www.reddit.com/r/btc/comments/5evvth/fraud_proofs/\n\nI spent _hours_ explaining how this technology would work to you on\nreddit in private message, walking you through arguments on it.\nPointing out some of the details.\n\nI also originally introduced the idea of compact fraud proofs to the\ncommunity (though the general idea was that of Bitcoin's creator,\nwithout the compact-- just the unworkable kind) and was the first\nperson to enumerate the missing components for it.\n\nYet, the idea here is attribute solely to you, leaving me erased from history.\n\nThis isn't right.  It is especially offensive because the same parties\naffiliated with BU use this plagiarism as a proof point that they are\nscaling innovators while I am not, -- the height of absurdity when\nthey do it with ideas I invented and introduced to them.\n\nMike Hearn didn't have the integrity to credit Matt for the invention\nof thinblocks; instead he was happy to have other people misrepresent\nthe history, I think you are a better person than him and hope you\nwill say something.\n\n------"
            }
        ],
        "thread_summary": {
            "title": "Trivia on the history of compact fraud proofs and anti censorship.",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Gregory Maxwell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3883
        }
    },
    {
        "title": "[bitcoin-dev] [bitcoin-discuss] Proposal to replace full blockchain with recent history plus UTXO Set",
        "thread_messages": [
            {
                "author": "Damian Williamson",
                "date": "2018-09-25T21:55:49",
                "message_text_only": "A fairly decent rework would be needed but it seems that the idea has merit initially.\n\n\nAs it is now, it is not only that a utxo exists but, that the transaction it references and the block it is within can also be fully validated.\n\n\nSo, if a utxo block set type existed then by consensus every so often a bunch of blocks containing just the validated utxo set to a given height, say 100,000 blocks below the current blockheight, and necessary header data could be appended onto the valid chain and nodes would be free to drop all preceding blocks. I suspect that many wouldn't and that even many new nodes would still desire to download the full blockchain but, for the use case you mention it would make sense.\n\n\nIf done [right/wrong] it may even make Satoshi's fortune spendable. Something to watch out for.\n\n________________________________\nFrom: bitcoin-discuss-bounces at lists.linuxfoundation.org <bitcoin-discuss-bounces at lists.linuxfoundation.org> on behalf of Dave Scotese via bitcoin-discuss <bitcoin-discuss at lists.linuxfoundation.org>\nSent: Wednesday, 26 September 2018 1:46:54 AM\nTo: Bitcoin Discuss\nSubject: Re: [bitcoin-discuss] Proposal to replace full blockchain with recent history plus UTXO Set\n\nThe image at imgur and the pastebin both reference block 542324 but the correct block is 542322.  As the pastebin shows, the decimal and hex representations I gave for the block height did not match, and this is why.  If you use the Merkle root for block 542322 instead of 542324, you'll be able to see the correct Game of Life play out and make the apron image.\n\nDave.\n\nOn Sun, Sep 23, 2018 at 11:38 AM Dave Scotese <dscotese at litmocracy.com<mailto:dscotese at litmocracy.com>> wrote:\nI thought I didn't have access to the dev list and so intended to post the following proposal to this discussion list, but used the wrong email address.  Anyway, my email did get into the dev list (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-September/016420.html) but I'll repeat it here:\n\nI've been working on an idea that relieves full nodes of storing the entire blockchain. Open source software generally relies on the fact that \"enough\" people agree that it's secure. Bitcoin software works that way too. So if you understand enough to see that a UTXO set is valid at a certain block height, and there are enough other people who agree and that set is recognizable by humans, then we can use that UTXO set and ditch the blockchain that existed up to that point. It would save a lot of storage and make it a lot easier to run a full node.\n\nHave you reviewed the source code from which your wallets were compiled? At some point, we all trust third parties, but generally (at least among people who understand Bitcoin) they are large composite groups so that no small group or individual can profit from cheating.\n\nI look forward to answering any concerns and also to any offers of help.   I used block 542324 of the Bitcoin blockchain to make a memorable experience using the game of life. I wrote a script for the open-source Game-of-Life software Golly and shared it in the paste at https://pastebin.com/k5Ssc0qk. It produces the image at https://imgur.com/a/rwIQuVz. If someone can tell me how to get a UTXO Set from the bitcoin client, I'll send them $50 of bitcoin. Then I could get the SHA256 hash of that set and try to make a recognizable checkpoint for the Bitcoin blockchain. If someone runs Golly and shares a video of the game playing out (into the apron-shaped image), I'll send them $50 of bitcoin too.\n\nIn a few decades when the blockchain has grown to a few terabytes and the UTXO Set is still just a few gigabytes, I'd like to see more people start running full nodes without the hassle of a long wait and loads of storage space. That's what stops me from running one.\n\n\n--\nI like to provide some work at no charge to prove my value. Do you need a techie?\nI own Litmocracy<http://www.litmocracy.com> and Meme Racing<http://www.memeracing.net> (in alpha).\nI'm the webmaster for The Voluntaryist<http://www.voluntaryist.com> which now accepts Bitcoin.\nI also code for The Dollar Vigilante<http://dollarvigilante.com/>.\n\"He ought to find it more profitable to play by the rules\" - Satoshi Nakamoto\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180925/2f640b46/attachment-0001.html>"
            },
            {
                "author": "CryptAxe",
                "date": "2018-09-26T00:00:03",
                "message_text_only": "Feel free to take a look at my implementation of UTXO loading (for core\n~0.16.99) here:\nhttps://github.com/DriveNetTESTDRIVE/DriveNet/commit/60189ea9a23865180e25207ecf66f95d84f642c6\n\n\nNote that this has consensus implications, and that there are bugs (some of\nwhich are fixed in later commits to that repository)\n\n\nOn Tue, Sep 25, 2018 at 4:56 PM Damian Williamson via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> A fairly decent rework would be needed but it seems that the idea has\n> merit initially.\n>\n>\n> As it is now, it is not only that a utxo exists but, that the transaction\n> it references and the block it is within can also be fully validated.\n>\n>\n> So, if a utxo block set type existed then by consensus every so often a\n> bunch of blocks containing just the validated utxo set to a given height,\n> say 100,000 blocks below the current blockheight, and necessary header data\n> could be appended onto the valid chain and nodes would be free to drop all\n> preceding blocks. I suspect that many wouldn't and that even many new nodes\n> would still desire to download the full blockchain but, for the use case\n> you mention it would make sense.\n>\n>\n> If done [right/wrong] it may even make Satoshi's fortune spendable.\n> Something to watch out for.\n> ------------------------------\n> *From:* bitcoin-discuss-bounces at lists.linuxfoundation.org <\n> bitcoin-discuss-bounces at lists.linuxfoundation.org> on behalf of Dave\n> Scotese via bitcoin-discuss <bitcoin-discuss at lists.linuxfoundation.org>\n> *Sent:* Wednesday, 26 September 2018 1:46:54 AM\n> *To:* Bitcoin Discuss\n> *Subject:* Re: [bitcoin-discuss] Proposal to replace full blockchain with\n> recent history plus UTXO Set\n>\n> The image at imgur and the pastebin both reference block 542324 but the\n> correct block is 542322.  As the pastebin shows, the decimal and hex\n> representations I gave for the block height did not match, and this is\n> why.  If you use the Merkle root for block 542322 instead of 542324, you'll\n> be able to see the correct Game of Life play out and make the apron image.\n>\n> Dave.\n>\n> On Sun, Sep 23, 2018 at 11:38 AM Dave Scotese <dscotese at litmocracy.com>\n> wrote:\n>\n> I thought I didn't have access to the dev list and so intended to post the\n> following proposal to this discussion list, but used the wrong email\n> address.  Anyway, my email did get into the dev list (\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-September/016420.html)\n> but I'll repeat it here:\n>\n> I've been working on an idea that relieves full nodes of storing the\n> entire blockchain. Open source software generally relies on the fact that\n> \"enough\" people agree that it's secure. Bitcoin software works that way\n> too. So if you understand enough to see that a UTXO set is valid at a\n> certain block height, and there are enough other people who agree and that\n> set is recognizable by humans, then we can use that UTXO set and ditch the\n> blockchain that existed up to that point. It would save a lot of storage\n> and make it a lot easier to run a full node.\n>\n> Have you reviewed the source code from which your wallets were compiled?\n> At some point, we all trust third parties, but generally (at least among\n> people who understand Bitcoin) they are large composite groups so that no\n> small group or individual can profit from cheating.\n>\n> I look forward to answering any concerns and also to any offers of help.\n> I used block 542324 of the Bitcoin blockchain to make a memorable\n> experience using the game of life. I wrote a script for the open-source\n> Game-of-Life software Golly and shared it in the paste at\n> https://pastebin.com/k5Ssc0qk. It produces the image at\n> https://imgur.com/a/rwIQuVz. If someone can tell me how to get a UTXO Set\n> from the bitcoin client, I'll send them $50 of bitcoin. Then I could get\n> the SHA256 hash of that set and try to make a recognizable checkpoint for\n> the Bitcoin blockchain. If someone runs Golly and shares a video of the\n> game playing out (into the apron-shaped image), I'll send them $50 of\n> bitcoin too.\n>\n> In a few decades when the blockchain has grown to a few terabytes and the\n> UTXO Set is still just a few gigabytes, I'd like to see more people start\n> running full nodes without the hassle of a long wait and loads of storage\n> space. That's what stops me from running one.\n>\n>\n>\n> --\n> I like to provide some work at no charge to prove my value. Do you need a\n> techie?\n> I own Litmocracy <http://www.litmocracy.com> and Meme Racing\n> <http://www.memeracing.net> (in alpha).\n> I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com>\n> which now accepts Bitcoin.\n> I also code for The Dollar Vigilante <http://dollarvigilante.com/>.\n> \"He ought to find it more profitable to play by the rules\" - Satoshi\n> Nakamoto\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180925/13bd5761/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Proposal to replace full blockchain with recent history plus UTXO Set",
            "categories": [
                "bitcoin-dev",
                "bitcoin-discuss"
            ],
            "authors": [
                "Damian Williamson",
                "CryptAxe"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 9608
        }
    },
    {
        "title": "[bitcoin-dev] CVE-2018-17144 disclosure (inflation vulnerability) (copy-paste)",
        "thread_messages": [
            {
                "author": "Bryan Bishop",
                "date": "2018-09-26T03:40:32",
                "message_text_only": "It has been informed to me that the writeup for the recent\nvulnerability was not distributed to this mailing list. Please find\ndetails at the following blog post:\n\nhttps://bitcoincore.org/en/2018/09/20/notice/\n\nI believe a release notice was posted but not information about the bug,\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-September/016413.html\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-September/016414.html\n\nThere was also further discussion here:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-September/016424.html\n\nAlso, around the time those emails were sent, there was a mailing list\nmoderator queue bug and nobody was able to approve emails including\nmyself. This bug was subsequently resolved by Linux Foundation.\n\nThe remainder of this email is copy-paste from the bitcoincore.org\npage linked above.\n\n=== Full disclosure ===\n\nCVE-2018-17144, a fix for which was released on September 18th in\nBitcoin Core versions 0.16.3 and 0.17.0rc4, includes both a Denial of\nService component and a critical inflation vulnerability. It was\noriginally reported to several developers working on Bitcoin Core, as\nwell as projects supporting other cryptocurrencies, including ABC and\nUnlimited on September 17th as a Denial of Service bug only, however\nwe quickly determined that the issue was also an inflation\nvulnerability with the same root cause and fix.\n\nIn order to encourage rapid upgrades, the decision was made to\nimmediately patch and disclose the less serious Denial of Service\nvulnerability, concurrently with reaching out to miners, businesses,\nand other affected systems while delaying publication of the full\nissue to give times for systems to upgrade. On September 20th a post\nin a public forum reported the full impact and although it was quickly\nretracted the claim was further circulated.\n\nAt this time we believe over half of the Bitcoin hashrate has upgraded\nto patched nodes. We are unaware of any attempts to exploit this\nvulnerability.\n\nHowever, it still remains critical that affected users upgrade and\napply the latest patches to ensure no possibility of large\nreorganizations, mining of invalid blocks, or acceptance of invalid\ntransactions occurs.\n\n=== Technical details ===\n\nIn Bitcoin Core 0.14, an optimization was added (Bitcoin Core PR\n#9049) which avoided a costly check during initial pre-relay block\nvalidation that multiple inputs within a single transaction did not\nspend the same input twice which was added in 2012 (PR #443). While\nthe UTXO-updating logic has sufficient knowledge to check that such a\ncondition is not violated in 0.14 it only did so in a sanity check\nassertion and not with full error handling (it did, however, fully\nhandle this case twice in prior to 0.8).\n\nThus, in Bitcoin Core 0.14.X, any attempts to double-spend a\ntransaction output within a single transaction inside of a block will\nresult in an assertion failure and a crash, as was originally\nreported.\n\nIn Bitcoin Core 0.15, as a part of a larger redesign to simplify\nunspent transaction output tracking and correct a resource exhaustion\nattack the assertion was changed subtly. Instead of asserting that the\noutput being marked spent was previously unspent, it only asserts that\nit exists.\n\nThus, in Bitcoin Core 0.15.X, 0.16.0, 0.16.1, and 0.16.2, any attempts\nto double-spend a transaction output within a single transaction\ninside of a block where the output being spent was created in the same\nblock, the same assertion failure will occur (as exists in the test\ncase which was included in the 0.16.3 patch). However, if the output\nbeing double-spent was created in a previous block, an entry will\nstill remain in the CCoin map with the DIRTY flag set and having been\nmarked as spent, resulting in no such assertion. This could allow a\nminer to inflate the supply of Bitcoin as they would be then able to\nclaim the value being spent twice.\n\n=== Timeline ===\n\nTimeline for September 17, 2018: (all times UTC)\n\n14:57 anonymous reporter reports crash bug to: Pieter Wuille, Greg\nMaxwell, Wladimir Van Der Laan of Bitcoin Core, deadalnix of Bitcoin\nABC, and sickpig of Bitcoin Unlimited.\n15:15 Greg Maxwell shares the original report with Cory Fields, Suhas\nDaftuar, Alex Morcos and Matt Corallo\n17:47 Matt Corallo identifies inflation bug\n19:15 Matt Corallo first tries to reach slushpool CEO to have a line\nof communication open to apply a patch quickly\n19:29 Greg Maxwell timestamps the hash of a test-case which\ndemonstrates the inflation vulnerability\n(a47344b7dceddff6c6cc1c7e97f1588d99e6dba706011b6ccc2e615b88fe4350)\n20:15 John Newbery and James O\u2019Beirne are informed of the\nvulnerability so they can assist in alerting companies to a pending\npatch for a DoS vulnerability\n20:30 Matt Corallo speaks with slushpool CTO and CEO and shares patch\nwith disclosure of the Denial of Service\n20:48 slushpool confirmed upgraded\n21:08 Alert was sent to Bitcoin ABC that a patch will be posted\npublicly by 22:00\n21:30 (approx) Responded to original reporter with an acknowledgment\n21:57 Bitcoin Core PR 14247 published with patch and test\ndemonstrating the Denial of Service bug\n21:58 Bitcoin ABC publishes their patch\n22:07 Advisory email with link to Bitcoin Core PR and patch goes out\nto Optech members, among others\n23:21 Bitcoin Core version 0.17.0rc4 tagged\n\nSeptember 18, 2018:\n\n00:24 Bitcoin Core version 0.16.3 tagged\n20:44 Bitcoin Core release binaries and release announcements were available\n21:47 Bitcointalk and reddit have public banners urging people to upgrade\n\nSeptember 19, 2018:\n\n14:06 The mailing list distributes an additional message urging people\nto upgrade by Pieter Wuille\n\nSeptember 20, 2018:\n\n19:50 David Jaenson independently discovered the vulnerability, and it\nwas reported to the Bitcoin Core security contact email.\n\n\n\n- Bryan\nhttp://heybryan.org/\n1 512 203 0507"
            }
        ],
        "thread_summary": {
            "title": "CVE-2018-17144 disclosure (inflation vulnerability) (copy-paste)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Bryan Bishop"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5859
        }
    },
    {
        "title": "[bitcoin-dev] BIP sighash_noinput",
        "thread_messages": [
            {
                "author": "Jonas Nick",
                "date": "2018-09-26T09:36:57",
                "message_text_only": "> At the risk of bikeshedding, shouldn't NOINPUT also zero out the\n> hashSequence so that its behaviour is consistent with ANYONECANPAY?\n\nThere is a good reason for not doing that. If NOINPUT would sign the\nhashSequence then it would be possible to get rid of OP_CSV in eltoo update\nscripts. As a result update scripts could be taprootified because the more\ncommon branch (settlement) would be just a 2-of-2 multisig. Applying taproot\nwould then make unilateral settlement look like a single pubkey spend and avoid\nhaving to reveal the unexecuted (update) branch.\n\nEltoo update transaction outputs consist of two branches, update and\nsettlement, where the update branch can be spend by a more recent update\ntransaction if an obsolete update transaction ends up spending the funding\noutput. The settlement branch is a 2-of-2 multisig with a relative timelock\nusing OP_CSV. Removing OP_CSV is possible because both parties signature is\nrequired to spend the update transaction. They will only sign if the input has\nthe right sequence numbers which is sufficient to enforce the timeout (BIP68) -\nassuming they are covered by the signature.\n\nThere's a catch: hashSequence includes the sequence numbers of all transaction\ninputs. That's not a problem for eltoo because settlement transactions only\nhave one input. The update mechanism with update transactions relies on being\nable to bump the fee by unilaterally adding inputs and and change outputs to\nthe transaction. That's also not a problem because update spends do not use\nrelative timelocks and they are signed with SINGLE. So whenever NOINPUT is\ncombined SINGLE the hashSequence should be zeroed. This is in fact what a\nminimal change to the current NOINPUT implementation would naturally do (see\nbelow). However, that's error-prone when using NOINPUT in other contexts so in\ngeneral it would be better if NOINPUT would only sign the sequence number of\nthe corresponding input.\n\nAnother downside of this approach is that you can never rebind to an output\nwith an OP_CSV that requires a larger sequence number, unless you also sign\nwith SIGHASH_SINGLE. It's difficult to imagine application where this would be\nan issue.\n\nThis is the modification to the NOINPUT implementation\n(https://github.com/cdecker/bitcoin/commits/noinput) which makes eltoo\nunilateral closes taprootifiable:\n+++ b/src/script/interpreter.cpp\n@@ -1223,7 +1223,7 @@ uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsig\n             hashPrevouts = cacheready ? cache->hashPrevouts : GetPrevoutHash(txTo);\n         }\n\n-        if (!(nHashType & SIGHASH_ANYONECANPAY) && (nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE && !noinput) {\n+        if (!(nHashType & SIGHASH_ANYONECANPAY) && (nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE) {\n             hashSequence = cacheready ? cache->hashSequence : GetSequenceHash(txTo);\n         }\n\nOn 5/1/18 4:58 PM, Russell O'Connor via bitcoin-dev wrote:\n> At the risk of bikeshedding, shouldn't NOINPUT also zero out the\n> hashSequence so that its behaviour is consistent with ANYONECANPAY?\n> \n> On Mon, Apr 30, 2018 at 12:29 PM, Christian Decker via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n>> Hi all,\n>>\n>> I'd like to pick up the discussion from a few months ago, and propose a new\n>> sighash flag, `SIGHASH_NOINPUT`, that removes the commitment to the\n>> previous\n>> output. This was previously mentioned on the list by Joseph Poon [1], but\n>> was\n>> never formally proposed, so I wrote a proposal [2].\n>>\n>> We have long known that `SIGHASH_NOINPUT` would be a great fit for\n>> Lightning.\n>> They enable simple watch-towers, i.e., outsource the need to watch the\n>> blockchain for channel closures, and react appropriately if our\n>> counterparty\n>> misbehaves. In addition to this we just released the eltoo [3,4] paper\n>> which\n>> describes a simplified update mechanism that can be used in Lightning, and\n>> other\n>> off-chain contracts, with any number of participants.\n>>\n>> By not committing to the previous output being spent by the transaction,\n>> we can\n>> rebind an input to point to any outpoint with a matching output script and\n>> value. The binding therefore is no longer explicit through a reference, but\n>> through script compatibility, and the transaction ID reference in the\n>> input is a\n>> hint to validators. The sighash flag is meant to enable some off-chain\n>> use-cases\n>> and should not be used unless the tradeoffs are well-known. In particular\n>> we\n>> suggest using contract specific key-pairs, in order to avoid having any\n>> unwanted\n>> rebinding opportunities.\n>>\n>> The proposal is very minimalistic, and simple. However, there are a few\n>> things\n>> where we'd like to hear the input of the wider community with regards to\n>> the\n>> implementation details though. We had some discussions internally on\n>> whether to\n>> use a separate opcode or a sighash flag, some feeling that the sighash flag\n>> could lead to some confusion with existing wallets, but given that we have\n>> `SIGHASH_NONE`, and that existing wallets will not sign things with unknown\n>> flags, we decided to go the sighash way. Another thing is that we still\n>> commit\n>> to the amount of the outpoint being spent. The rationale behind this is\n>> that,\n>> while rebinding to outpoints with the same value maintains the value\n>> relationship between input and output, we will probably not want to bind to\n>> something with a different value and suddenly pay a gigantic fee.\n>>\n>> The deployment part of the proposal is left vague on purpose in order not\n>> to\n>> collide with any other proposals. It should be possible to introduce it by\n>> bumping the segwit script version and adding the new behavior.\n>>\n>> I hope the proposal is well received, and I'm looking forward to discussing\n>> variants and tradeoffs here. I think the applications we proposed so far\n>> are\n>> quite interesting, and I'm sure there are many more we can enable with this\n>> change.\n>>\n>> Cheers,\n>> Christian\n>>\n>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n>> 2016-February/012460.html\n>> [2] https://github.com/cdecker/bips/blob/noinput/bip-xyz.mediawiki\n>> [3] https://blockstream.com/2018/04/30/eltoo-next-lightning.html\n>> [4] https://blockstream.com/eltoo.pdf\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-09-26T19:45:49",
                "message_text_only": "In BIP143, the nSequence of the same input is always signed, with any hashtype. Why do you need to sign the sequence of other inputs?\n\n> On 26 Sep 2018, at 5:36 PM, Jonas Nick via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n>> At the risk of bikeshedding, shouldn't NOINPUT also zero out the\n>> hashSequence so that its behaviour is consistent with ANYONECANPAY?\n> \n> There is a good reason for not doing that. If NOINPUT would sign the\n> hashSequence then it would be possible to get rid of OP_CSV in eltoo update\n> scripts. As a result update scripts could be taprootified because the more\n> common branch (settlement) would be just a 2-of-2 multisig. Applying taproot\n> would then make unilateral settlement look like a single pubkey spend and avoid\n> having to reveal the unexecuted (update) branch.\n> \n> Eltoo update transaction outputs consist of two branches, update and\n> settlement, where the update branch can be spend by a more recent update\n> transaction if an obsolete update transaction ends up spending the funding\n> output. The settlement branch is a 2-of-2 multisig with a relative timelock\n> using OP_CSV. Removing OP_CSV is possible because both parties signature is\n> required to spend the update transaction. They will only sign if the input has\n> the right sequence numbers which is sufficient to enforce the timeout (BIP68) -\n> assuming they are covered by the signature.\n> \n> There's a catch: hashSequence includes the sequence numbers of all transaction\n> inputs. That's not a problem for eltoo because settlement transactions only\n> have one input. The update mechanism with update transactions relies on being\n> able to bump the fee by unilaterally adding inputs and and change outputs to\n> the transaction. That's also not a problem because update spends do not use\n> relative timelocks and they are signed with SINGLE. So whenever NOINPUT is\n> combined SINGLE the hashSequence should be zeroed. This is in fact what a\n> minimal change to the current NOINPUT implementation would naturally do (see\n> below). However, that's error-prone when using NOINPUT in other contexts so in\n> general it would be better if NOINPUT would only sign the sequence number of\n> the corresponding input.\n> \n> Another downside of this approach is that you can never rebind to an output\n> with an OP_CSV that requires a larger sequence number, unless you also sign\n> with SIGHASH_SINGLE. It's difficult to imagine application where this would be\n> an issue.\n> \n> This is the modification to the NOINPUT implementation\n> (https://github.com/cdecker/bitcoin/commits/noinput) which makes eltoo\n> unilateral closes taprootifiable:\n> +++ b/src/script/interpreter.cpp\n> @@ -1223,7 +1223,7 @@ uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsig\n>             hashPrevouts = cacheready ? cache->hashPrevouts : GetPrevoutHash(txTo);\n>         }\n> \n> -        if (!(nHashType & SIGHASH_ANYONECANPAY) && (nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE && !noinput) {\n> +        if (!(nHashType & SIGHASH_ANYONECANPAY) && (nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE) {\n>             hashSequence = cacheready ? cache->hashSequence : GetSequenceHash(txTo);\n>         }\n> \n> On 5/1/18 4:58 PM, Russell O'Connor via bitcoin-dev wrote:\n>> At the risk of bikeshedding, shouldn't NOINPUT also zero out the\n>> hashSequence so that its behaviour is consistent with ANYONECANPAY?\n>> \n>"
            },
            {
                "author": "Jonas Nick",
                "date": "2018-09-26T20:40:02",
                "message_text_only": "Oh, I missed that that's still the case with NOINPUT - thanks for pointing it\nout. In that case there's no reason to sign the other inputs' sequence and\nthat's even better because the current NOINPUT proposal already enables\ntaprootifiability of eltoo unilateral closings.\n\nOn 9/26/18 7:45 PM, Johnson Lau wrote:\n> In BIP143, the nSequence of the same input is always signed, with any hashtype. Why do you need to sign the sequence of other inputs?\n> \n>> On 26 Sep 2018, at 5:36 PM, Jonas Nick via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> At the risk of bikeshedding, shouldn't NOINPUT also zero out the\n>>> hashSequence so that its behaviour is consistent with ANYONECANPAY?\n>>\n>> There is a good reason for not doing that. If NOINPUT would sign the\n>> hashSequence then it would be possible to get rid of OP_CSV in eltoo update\n>> scripts. As a result update scripts could be taprootified because the more\n>> common branch (settlement) would be just a 2-of-2 multisig. Applying taproot\n>> would then make unilateral settlement look like a single pubkey spend and avoid\n>> having to reveal the unexecuted (update) branch.\n>>\n>> Eltoo update transaction outputs consist of two branches, update and\n>> settlement, where the update branch can be spend by a more recent update\n>> transaction if an obsolete update transaction ends up spending the funding\n>> output. The settlement branch is a 2-of-2 multisig with a relative timelock\n>> using OP_CSV. Removing OP_CSV is possible because both parties signature is\n>> required to spend the update transaction. They will only sign if the input has\n>> the right sequence numbers which is sufficient to enforce the timeout (BIP68) -\n>> assuming they are covered by the signature.\n>>\n>> There's a catch: hashSequence includes the sequence numbers of all transaction\n>> inputs. That's not a problem for eltoo because settlement transactions only\n>> have one input. The update mechanism with update transactions relies on being\n>> able to bump the fee by unilaterally adding inputs and and change outputs to\n>> the transaction. That's also not a problem because update spends do not use\n>> relative timelocks and they are signed with SINGLE. So whenever NOINPUT is\n>> combined SINGLE the hashSequence should be zeroed. This is in fact what a\n>> minimal change to the current NOINPUT implementation would naturally do (see\n>> below). However, that's error-prone when using NOINPUT in other contexts so in\n>> general it would be better if NOINPUT would only sign the sequence number of\n>> the corresponding input.\n>>\n>> Another downside of this approach is that you can never rebind to an output\n>> with an OP_CSV that requires a larger sequence number, unless you also sign\n>> with SIGHASH_SINGLE. It's difficult to imagine application where this would be\n>> an issue.\n>>\n>> This is the modification to the NOINPUT implementation\n>> (https://github.com/cdecker/bitcoin/commits/noinput) which makes eltoo\n>> unilateral closes taprootifiable:\n>> +++ b/src/script/interpreter.cpp\n>> @@ -1223,7 +1223,7 @@ uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsig\n>>             hashPrevouts = cacheready ? cache->hashPrevouts : GetPrevoutHash(txTo);\n>>         }\n>>\n>> -        if (!(nHashType & SIGHASH_ANYONECANPAY) && (nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE && !noinput) {\n>> +        if (!(nHashType & SIGHASH_ANYONECANPAY) && (nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE) {\n>>             hashSequence = cacheready ? cache->hashSequence : GetSequenceHash(txTo);\n>>         }\n>>\n>> On 5/1/18 4:58 PM, Russell O'Connor via bitcoin-dev wrote:\n>>> At the risk of bikeshedding, shouldn't NOINPUT also zero out the\n>>> hashSequence so that its behaviour is consistent with ANYONECANPAY?\n>>>\n>>\n> \n>"
            }
        ],
        "thread_summary": {
            "title": "BIP sighash_noinput",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Jonas Nick",
                "Johnson Lau"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 14045
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Core 0.14.3 released",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2018-09-28T15:37:28",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nBitcoin Core version *0.14.3* is now available from:\n\n  <https://bitcoincore.org/bin/bitcoin-core-0.14.3/>\n\nor through bitorrent:\n\n  magnet:?xt=urn:btih:171edf5f51820900f24fc72620deaa07ee497dee&dn=bitcoin-core-0.14.3&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969&tr=udp%3A%2F%2Fzer0day.ch%3A1337&tr=udp%3A%2F%2Fexplodie.org%3A6969\n\nThis is a new minor version release, including various bugfixes and\nperformance improvements.\n\nPlease report bugs using the issue tracker at github:\n\n  <https://github.com/bitcoin/bitcoin/issues>\n\nTo receive security and update notifications, please subscribe to:\n\n  <https://bitcoincore.org/en/list/announcements/join/>\n\nCompatibility\n==============\n\nBitcoin Core is extensively tested on multiple operating systems using\nthe Linux kernel, macOS 10.8+, and Windows Vista and later.\n\nMicrosoft ended support for Windows XP on [April 8th, 2014](https://www.microsoft.com/en-us/WindowsForBusiness/end-of-xp-support),\nNo attempt is made to prevent installing or running the software on Windows XP, you\ncan still do so at your own risk but be aware that there are known instabilities and issues.\nPlease do not report issues about Windows XP to the issue tracker.\n\nBitcoin Core should also work on most other Unix-like systems but is not\nfrequently tested on them.\n\nNotable changes\n===============\n\nDenial-of-Service vulnerability CVE-2018-17144\n -------------------------------\n\nA denial-of-service vulnerability exploitable by miners has been discovered in\nBitcoin Core versions 0.14.0 up to 0.16.2. It is recommended to upgrade any of\nthe vulnerable versions to 0.14.3, 0.15.2 or 0.16.3 as soon as possible.\n\nKnown Bugs\n==========\n\nSince 0.14.0 the approximate transaction fee shown in Bitcoin-Qt when using coin\ncontrol and smart fee estimation does not reflect any change in target from the\nsmart fee slider. It will only present an approximate fee calculated using the\ndefault target. The fee calculated using the correct target is still applied to\nthe transaction and shown in the final send confirmation dialog.\n\n0.14.3 Change log\n=================\n\nDetailed release notes follow. This overview includes changes that affect\nbehavior, not code moves, refactors and string updates. For convenience in locating\nthe code changes and accompanying discussion, both the pull request and\ngit merge commit are mentioned.\n\n### Consensus\n- - #14247 `52965fb` Fix crash bug with duplicate inputs within a transaction (TheBlueMatt, sdaftuar)\n \n### RPC and other APIs\n\n- - #10445 `87a21d5` Fix: make CCoinsViewDbCursor::Seek work for missing keys (Pieter Wuille, Gregory Maxwell)\n- - #9853 Return correct error codes in setban(), fundrawtransaction(), removeprunedfunds(), bumpfee(), blockchain.cpp (John Newbery)\n\n\n### P2P protocol and network code\n\n- - #10234 `d289b56` [net] listbanned RPC and QT should show correct banned subnets (John Newbery)\n\n### Build system\n\n\n### Miscellaneous\n\n- - #10451 `3612219` contrib/init/bitcoind.openrcconf: Don't disable wallet by default (Luke Dashjr)\n- - #10250 `e23cef0` Fix some empty vector references (Pieter Wuille)\n- - #10196 `d28d583` PrioritiseTransaction updates the mempool tx counter (Suhas Daftuar)\n- - #9497 `e207342` Fix CCheckQueue IsIdle (potential) race condition and remove dangerous constructors. (Jeremy Rubin)\n\n### GUI\n\n- - #9481 `7abe7bb` Give fallback fee a reasonable indent (Luke Dashjr)\n- - #9481 `3e4d7bf` Qt/Send: Figure a decent warning colour from theme (Luke Dashjr)\n- - #9481 `e207342` Show more significant warning if we fall back to the default fee (Jonas Schnelli)\n\n### Wallet\n\n- - #10308 `28b8b8b` Securely erase potentially sensitive keys/values (tjps)\n- - #10265 `ff13f59` Make sure pindex is non-null before possibly referencing in LogPrintf call. (Karl-Johan Alm)\n\nCredits\n=======\n\nThanks to everyone who directly contributed to this release:\n\n- - Cory Fields\n- - CryptAxe\n- - fanquake\n- - Jeremy Rubin\n- - John Newbery\n- - Jonas Schnelli\n- - Gregory Maxwell\n- - Karl-Johan Alm\n- - Luke Dashjr\n- - MarcoFalke\n- - Matt Corallo\n- - Mikerah\n- - Pieter Wuille\n- - practicalswift\n- - Suhas Daftuar\n- - Thomas Snider\n- - Tjps\n- - Wladimir J. van der Laan\n\nAnd to those that reported security issues:\n\n- - awemany (for CVE-2018-17144, previously credited as \"anonymous reporter\")\n\n-----BEGIN PGP SIGNATURE-----\n\niQEzBAEBCgAdFiEEnerg3HBjJJ+wVHRoHkrtYphs0l0FAluuSowACgkQHkrtYphs\n0l3XtggArfc/1tCcIunvUIyooq7nb27AwltySOBFCFH/R1v6mcSN6ZHAEKC3uBA6\nWkhrGChV8XqNELKau7w1riubPjMHNTj0k4+DBtaDNN41EAF+1bhHWbxQ4006tZHb\nWN2coxX+iNPI9uj3m0MnbulZpy+c7w1azO8eULcZjkqkccRBl6p4Y3uePr7CbbKU\n/h517ziI7UwYChKsF3tC7CX+3vDi7oyfZd5QCKmtEFicS4j0UADtsLdF2GlMkpyD\nyffAq/jpDXrIMWXrseZe60UPTijaA2mokk8/SdGy0hKn9Qx/VB0EIYKVPMD4gDUg\niSFcmsELYzBzk01Jg29GLzCbI7rQYw==\n=MOiO\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.14.3 released",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Wladimir J. van der Laan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 4954
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Core 0.15.2 released",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2018-09-28T15:38:34",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nBitcoin Core version *0.15.2* is now available from:\n\n  <https://bitcoincore.org/bin/bitcoin-core-0.15.2/>\n\nor through bittorrent:\n\n  magnet:?xt=urn:btih:c0a23591e04ce45dd6349f3abc34df948c45537c&dn=bitcoin-core-0.15.2&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969&tr=udp%3A%2F%2Fzer0day.ch%3A1337&tr=udp%3A%2F%2Fexplodie.org%3A6969\n\nThis is a new minor version release, including various bugfixes and\nperformance improvements, as well as updated translations.\n\nPlease report bugs using the issue tracker at GitHub:\n\n  <https://github.com/bitcoin/bitcoin/issues>\n\nTo receive security and update notifications, please subscribe to:\n\n  <https://bitcoincore.org/en/list/announcements/join/>\n\nHow to Upgrade\n==============\n\nIf you are running an older version, shut it down. Wait until it has completely\nshut down (which might take a few minutes for older versions), then run the \ninstaller (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)\nor `bitcoind`/`bitcoin-qt` (on Linux).\n\nThe first time you run version 0.15.0 or higher, your chainstate database will\nbe converted to a new format, which will take anywhere from a few minutes to\nhalf an hour, depending on the speed of your machine.\n\nThe file format of `fee_estimates.dat` changed in version 0.15.0. Hence, a\ndowngrade from version 0.15 or upgrade to version 0.15 will cause all fee\nestimates to be discarded.\n\nNote that the block database format also changed in version 0.8.0 and there is no\nautomatic upgrade code from before version 0.8 to version 0.15.0. Upgrading\ndirectly from 0.7.x and earlier without redownloading the blockchain is not supported.\nHowever, as usual, old wallet versions are still supported.\n\nDowngrading warning\n- -------------------\n\nThe chainstate database for this release is not compatible with previous\nreleases, so if you run 0.15 and then decide to switch back to any\nolder version, you will need to run the old release with the `-reindex-chainstate`\noption to rebuild the chainstate data structures in the old format.\n\nIf your node has pruning enabled, this will entail re-downloading and\nprocessing the entire blockchain.\n\nCompatibility\n==============\n\nBitcoin Core is extensively tested on multiple operating systems using\nthe Linux kernel, macOS 10.8+, and Windows Vista and later. Windows XP is not supported.\n\nBitcoin Core should also work on most other Unix-like systems but is not\nfrequently tested on them.\n\n\nNotable changes\n===============\n\nDenial-of-Service vulnerability CVE-2018-17144\n- -------------------------------\n\nA denial-of-service vulnerability exploitable by miners has been discovered in\nBitcoin Core versions 0.14.0 up to 0.16.2. It is recommended to upgrade any of\nthe vulnerable versions to 0.15.2 or 0.16.3 as soon as possible.\n\n0.15.2 Change log\n=================\n\n### Build system\n\n- - #11995 `9bb1a16` depends: Fix Qt build with XCode 9.2(fanquake)\n- - #12946 `93b9a61` depends: Fix Qt build with XCode 9.3(fanquake)\n- - #13544 `9fd3e00` depends: Update Qt download url (fanquake)\n- - #11847 `cb7ef31` Make boost::multi_index comparators const (sdaftuar)\n\n### Consensus\n- - #14247 `4b8a3f5` Fix crash bug with duplicate inputs within a transaction (TheBlueMatt, sdaftuar)\n \n### RPC\n- - #11676 `7af2457` contrib/init: Update openrc-run filename (Luke Dashjr)\n- - #11277 `7026845` Fix uninitialized URI in batch RPC requests (Russell Yanofsky)\n \n### Wallet\n- - #11289 `3f1db56` Wrap dumpwallet warning and note scripts aren't dumped (MeshCollider)\n- - #11289 `42ea47d` Add wallet backup text to import*, add* and dumpwallet RPCs (MeshCollider)\n- - #11590 `6372a75` [Wallet] always show help-line of wallet encryption calls (Jonas Schnelli)\n\n### bitcoin-tx\n\n- - #11554 `a69cc07` Sanity-check script sizes in bitcoin-tx (TheBlueMatt)\n\n### Tests\n- - #11277 `3a6cdd4` Add test for multiwallet batch RPC calls (Russell Yanofsky)\n- - #11647 `1c8c7f8` Add missing batch rpc calls to python coverage logs (Russell Yanofsky)\n- - #11277 `1036c43` Add missing multiwallet rpc calls to python coverage logs (Russell Yanofsky)\n- - #11277 `305f768` Limit AuthServiceProxyWrapper.\\_\\_getattr\\_\\_ wrapping (Russell Yanofsky)\n- - #11277 `2eea279` Make AuthServiceProxy.\\_batch method usable (Russell Yanofsky)\n\nCredits\n=======\n\nThanks to everyone who directly contributed to this release:\n\n- - fanquake\n- - Jonas Schnelli\n- - Luke Dashjr\n- - Matt Corallo\n- - MeshCollider\n- - Russell Yanofsky\n- - Suhas Daftuar\n- - Wladimir J. van der Laan\n\nAnd to those that reported security issues:\n\n- - awemany (for CVE-2018-17144, previously credited as \"anonymous reporter\")\n\n-----BEGIN PGP SIGNATURE-----\n\niQEzBAEBCgAdFiEEnerg3HBjJJ+wVHRoHkrtYphs0l0FAluuSdQACgkQHkrtYphs\n0l30rwgApv6HCvWRnKCfoXTYjIFaBXoxFU8/SPlms/3YYvc5JF8/+DeVXfYgd1nW\nMgw1j0I3m52Am5JmV368uSpbfQYoUSUkWuZX62al9AXC8EBEbqPBWkeIJgvD3cpS\nvZC3kpwphR7jS7Rt7HK1+IZl6sgA9iGD2ZlWZ2AjRdUM3/GZ0RrziMG7IVLeG0oh\nCjUDqle4Ws/YyvSNcbLHWKzwW+bHmihVm4Xy+h9086tM11t9EkN0m3i5YoELipjW\nkeYX/y8a43wbzE15DX7bJNRJjjITLty0rQxxWuMvoHOix4xvDs1UYiYxtfoYSOnf\nuqh1/mCkDwF7hiFb0ZxcgXdw3W2WoA==\n=b4Fn\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.15.2 released",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Wladimir J. van der Laan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5259
        }
    }
]