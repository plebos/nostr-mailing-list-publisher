[
    {
        "title": "[Bitcoin-development] (space) efficient reusable addr via weil pairing IBE (Re: Bait for reusable addresses)",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2014-02-02T02:36:51",
                "message_text_only": "On Sat, Jan 25, 2014 at 05:19:01PM +0100, Adam Back wrote:\n> I think I figured out a proof of existance for a space efficient way to do\n> better than bloom filters/prefix/bloom-bait.  (Must have been dreaming on it\n> as I woke up with the idea following Peter's suggestion to try prove instead\n> if its possible or not:).\n> \n> I wrote up the details here:\n> \n> https://bitcointalk.org/index.php?topic=431756.new\n\nOne of the main reasons I post to the bitcoin-development mailing list\nrather than the forum is because the mailing list is archived by many\ndifferent, independent, parties. The forum is not - as an example\narchive.org didn't have that URL until I manually told it to archive it.\n\nSo I'm taking the liberty of reposting your two posts there below:\n\n[quote author=adam3us link=topic=431756.msg4729682#msg4729682\ndate=1390660452]\nSo have been talking with Greg Maxwell, Peter Todd, Jeremy Spillman,\nMike Hearn, Bytecoin and others about reusable addresses.\n\nThere is a summary of the situation here\nhttp://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg03792.html\nand I had posed th question of whether it was possible to do better at\nall with Peter Todd:\n\n[quote author=adam3us on bitcoin-dev]\nNow while it would be clearly a very nice win if reusable addresses\ncould be  made SPV-like in network characteristics and privacy, but we\ndont have a plausible mechanism yet IMO.  Close as we got was Greg's\nenhancement of my/your \"bloom bait\"/\"prefix\" concept to make multiple\ncandidate baits to provide some ambiguity (still allows elimination,\njust slightly less of it).\n\nIf we can find some efficient crypto to solve that last one, we could\neven adopt them generally if it was efficient enough without needing\ninteractive one-use address release\n[/quote]\n\nand Peter proposed also the related problem of proving something about\nthat existence or not of a solution to that problem.\n\nI think I have a proof-of-concept solution that proves by example we can\ndo better in space efficiency, linkability defense and non-interactivity\nthan my bloom bait, Peter Todds related prefix; and Greg Maxwell's\nextended bloom bait described\nhttp://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg03705.html.\n\nSo the idea is to use an IBE scheme as a building block in analogous way\nto my 1996 problem statement for NIFS and 1998 observation that a novel\nuse for an IBE scheme can provide a generic solution to NIFS, and the\narrival in 2001 of the first efficient / sensible trapdoor steepness (*)\nIBE with the introduction of the Weil Pairing problem by Dan Boneh and\nMatt Franklin described here\nhttp://en.wikipedia.org/wiki/Boneh%E2%80%93Franklin_scheme.\n\nGreg summarized IBE as follows on IRC:\n\n[quote]\n(for those who may) not be familar with IBE stuff: The idea is that the\nuser has a master private key, which results in a master public key.\nAnyone can take a prior block hash and combine it with the master public\nkey to get a session pubkey which could be used to encrypt a chaincode\nincluded in an OP_RETURN.   Using the master private key the user can\nderrive the session private key, which can then be used to recognize\ntransactions using the same session key.\n\nIn IBE (identity based encryption) this is all used a bit differently:\nthe master keys are held by a CA, and the session ID is your email\naddress, and now anyone can make a public key for you\u2014 but you need the\nCA's help to get your private key)\n[/quote]\n\nBasically as Greg said your public key is your address (an email\naddress, a block hash, whatever is convenient and unique) and from that\nand the master public key of the IBE server, the server can compute a\nprivate key corresponding to that.  The master public is usually\nconsidered to be a system-wide domain parameter.   Naturally enough\nbecause a side effect of this is that the IBE server can decrypt\neveryones email people were never too excited about the prospect.\n\nHowever my 1998 NIFS observation is by acting as your own IBE server\n(each user creates their own master public server key) they can create a\nsequence (NIFS) or set (bitcoin reusable address) of public keys with\ninteresting and publicly derivable properties!\n\nIt is my conclusion from 1996 that to solve this with DL directly at\nleast in the NIFS case appears to be not possible.\n\n\nSo basically the reusable address becomes an IBE public key, the\nexisting public derivation via DH or EC Elgamal/ECIES or whatever\nvariant (bytecoins, mine, Peter Todd/Amir Taaki's) arrives at a factor\nthat can be recovered.  So with my variant (random sender generated\nmultiplication factor encrypted with ECIES) you could encrypt the factor\nwith a pub=IBE-extract(master pub, id=previous block hash) using the\nprevious block hash as the \"identity\" and the users own self-owned IBE\n\"server\".\n\nFor Bytecoin & Peter Todd/Amir Taaki EC DH version using input or\nauxilliary addresses to save space its not even necessary to send the\nfactor, its already sent.  So then you send a separate message to do\nwith secure delegatable filtering, a more secure/more space efficient\nbloom filter/prefix replacement, and this is a more flexible structure.\n\nSo the secure delegatable filter is you separately add an encrypted\nbloom bait Greg suggested (eg 1byte prefix communicated with public\naddress.)  And you can even combine that with Greg's extended bloom bait\nabove to add anonymity set within the block.\n\nConsequently you can now securely and very network/space efficiently\nsecurely delegate searching a block by computing the private key for the\nIBE pub key that any sender would use for that block, and sending it as\na query to a random (or node-capture defended random selected node).\nThe node can decrypt the encrypted bloom baits with it, but remains\npowerless to correlate with bloom baits to other payments received by\nthe same user in bother blocks.\n\n(In practice you might need an epoch not block or overlapping test\nbecause the user does not have full assurance of their tx ending up in\nthe pending block).\n\nAbout weil pairing, and new hardness crypto risk, this is also the\nhardness assumption under some ZK-SNARKs as I think used in zerocash,\nand while ZK-SNARK introduces its own complexity/crypto system risk on\ntop; in my view weil pairing is slightly lower assurance/review not so\nwidely used relative to EC DL problem.  Anyway the interesting thing to\nsay about that is in the event this scheme got broken in the future it\nfalls back to the scheme that is being proposed using prefix.  Ie its no\nworse than that from linkability and likely would retain some cost even\nif broken-- asymmetric crypto breaks are usually somewhat gradual.\n\nThis looks more expensive and non-indexable though I didnt look to see\nif there is any ciphertext only or batch precomputation that could be\nsqueezed out of it.\n\nObviously its more CPU intensive and some eg fee mechanism to prevent\nnode DoS could be nice, but it seems to demonstrate a proof by existence\nthat it is possible to do better.\n\n\nFinally I think it maybe within possibility to do further than this\nbecause it is not technically necessary to delegate decryption, only to\ndelegate filtering, which can be a simpler requirement.\n\nAdam\n\n(*) There was an earlier scheme by Maurer et al if I recall, but to get\na 1024-bit security margin you had to perform a discrete log attack on a\n512-bit prime, so the key generation cost was immense, hence \"sensible\ntrapdoor steepness\" thats very shallow in tems of work difference\nbetween setup cost and crypto system strength.\n[/quote]\n\n------\n\n[quote author=adam3us link=topic=431756.msg4732503#msg4732503\ndate=1390669542]\n[quote author=Mike Hearn link=topic=431756.msg4730986#msg4730986\ndate=1390664867]\nYou would need epochs for another reason. Recall that with Bloom\nfiltering the remote node is asked for blocks in batches of 500 at a\ntime and the remote end handles updating the filter as transactions are\nmatched. This is to avoid the performance hit of a network round-trip\nfor every block.\n[/quote]\n\nI see I dont think I realized that aspect of how bloom query works.  So\nyou then with IBE-based filtering could send multiple keys, one for each\nblock; but you are implicitly linked by being in one query, so you'd\njust as well mark your key with your preferred epoch size and sender\nuses epoch number in the query.\n\nI think Greg is pointing out on IRC that by having a fairly small epoch\nyou can choose later to go down to that epoch size or scale up by\nsending multiple epoch keys in a batch, a privacy/network round-trip\ntrade off.\n\nRe my other problem with epochs (\"In practice you might need an epoch\nnot block or overlapping test because the user does not have full\nassurance of their tx ending up in the pending block\") I think that\nmaybe fixable, if the blocknumber is chosen by the sender, and\ncommunicated in enough bits to be mostly unambiguous in the message.\nThen the node can index them by sen block num and no ambiguity.\n\nIt could be that another way to partly obscure ownership of queries\nwould be to relay queries and responses and mix other peoples queries\nwith your own in a batch, however as we are considering the SPV client\ncase relaying other peoples queries seems hard to gather query traffic\non demand and to use more bandwidth than it saves relative just issuing\nsmaller batches.\n\nYou could have relaying in the network eg using the embedded Tor but\nwaiting for queries to mix with adds latency, and suffers flood attacks\non mix-nets (send fake encrypted query traffic to flush out a tx, that\nhas no-anon set vs the person doing the flooding who can distinguish\ntheir own queries).\n\nAdam\n\n[/quote]\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140201/b8c8c0cb/attachment.sig>"
            },
            {
                "author": "Jeremy Spilman",
                "date": "2014-02-02T09:16:20",
                "message_text_only": ">\n> Consequently you can now securely and very network/space efficiently\n> securely delegate searching a block by computing the private key for the\n> IBE pub key that any sender would use for that block, and sending it as\n> a query to a random (or node-capture defended random selected node).\n> The node can decrypt the encrypted bloom baits with it, but remains\n> powerless to correlate with bloom baits to other payments received by\n> the same user in bother blocks.\n>\n\nI'm not sure I've fully wrapped my head around it.\n\n   d/Q        - Identity key\n   E          - Generate an epoch-pubkey: E = Q * H1(epoch)\n   r/P        - Ephemeral privkey/pubkey, or discoverable from inputs\n   S = r * K  - Shared secret (ECDE)\n\nPayer derives an encryption key H(S), and encrypts M, which is a 1 byte  \nbloom bait.\n\nFor each epoch, payee generates e = d * H1(epoch) and provides the key to  \na full node for monitoring. So you are providing a per-block or per-epoch  \nprivate key, along with the block ID or epoch ID that the key corresponds  \nto.\n\nThe full node then uses this privkey to decrypt the same byte in all the  \ntransactions in that epoch/block which match the expected layout/template,  \ne.g. given a certain length OP_RETURN, pull the specific byte and decrypt.\n\nThis decrypted byte is then in turn used as bloom bait which may or may  \nnot cause the transaction to be sent back to the SPV client.\n\nAm I right in saying the full node has no idea if decryption is  \n'succeeding' it just feeds the resultant bait into the bloom filter and  \nthe transaction may match or not? So we do get some level of repudiation  \nby the SPV client -- the server doesn't know exactly which transactions  \nbelong to the SPV client.\n\nThe bloom bait specified in the reusable address is still making the  \nbandwidth/privacy trade-off, it just doesn't become public information,  \nbecause it's protected by another factor?\n\nWhat encryption scheme is being used here?\n\n-=-=-=-==\n\nAnother approach (inspired by IBE) which narrows the discoverability of  \ntransactions to the nodes that your SPV client is actually communicating  \nwith, for the specific blocks/epochs that you specify, would be to use  \nPEKS.\n\nPEKS(Q, W) for a public key Q and a keyword W produces a searchable  \nencryption of the word W.\n\nThe payee holding 'd' (privkey for Q) can create a trapdoor which allows a  \nserver to search for transactions with W, where the searching party only  \nknows if a match is found or not.\n\nPayer:\n\n   d/Q   - Longstanding / identity privkey/pubkey\n   r/P   - Ephemeral privkey/pubkey, or discoverable from inputs\n   W     - Searchable Keyword\n   H1    - Hash function, {0, 1} \u2217 \u2192 G1\n   H2    - Hash function, G2 \u2192 {0, 1}p\n\nSecret, as usual per ECDH:\n\n   S = r * Q\n\nFor payer to create the searchable encryption of W for Q, called 'Sw':\n\n   Sw = H2(e(H1(W), S))\n   OP_RETURN P, Sw\n\nFor payee to search for a given 'W', payee calculates a trapdoor 'Tw':\n\n   Tw = d * H1(W)\n\nFor a searcher, given a Trapdoor (Tw), check each Transaction (P, Sw):\n\n   H2(e(Tw, P)) ==? Sw\n   If the values match, the keyword matches\n\nWithout getting into the concepts of e(g,g) and binomial pairing, I think  \nof it this way:\n\n   Sw = H2(r * Q * H1(W)), but recall: rQ == dP, so...\n      = H2(d * P * H1(W)), which can be written\n      = H2(d * H1(W) * P)\n\nSevers finds all transactions with 'P' on relevant parts of the  \nblockchain, multiplies by the provided trapdoor 'Tw', applies 'H2', and  \nchecks for a matching 'Sw' in the transaction;\n\n   Tw = d * H1(W)\n   Sw = H2(Tw * P)\n        H2(d * H1(W) * P)\n\nPEKS is vulnerable to an offline keyword guessing attack, where you can  \ndiscover the value of the keyword being searched, if the keyword is low  \nentropy. The server/attacker can figure out the value of W, but they can't  \ngenerate their own trapdoors to search for other keywords.\n\nBut in this case, the 'keyword' can simply be the block ID / epoch ID  \nitself, not a secret value at all. In other words, the server can only  \nsearch for your transactions within the blocks/epochs that you specify.\n\nUsing blockID/epochID as W, this would allow a server to find all  \ntransactions belonging to the payer for that blockID / epochID. The SPV  \nclient would simply provide the trapdoor for each block/epoch to be  \nsearched.\n\nThere are extensions to PEKS which provide for 'fuzzy' matching but they  \nare 'fuzzy' within the scope of Q, not across different Q, so that doesn't  \nhelp provide any repudiation. So I see this as only slightly improving  \nPeter's original proposal of providing 'Q' to the searcher, but if you  \nwant repudiation, not as good as Adam's solution.\n\nPerfunctory disclaimer... Hopefully this is close to correct, but please  \ndon't anyone actually try to implement this!\n\nThanks,\nJeremy"
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-02T12:26:10",
                "message_text_only": "On Sun, Feb 02, 2014 at 01:16:20AM -0800, Jeremy Spilman wrote:\n> >\n> >Consequently you can now securely and very network/space efficiently\n> >securely delegate searching a block by computing the private key for the\n> >IBE pub key that any sender would use for that block, and sending it as\n> >a query to a random (or node-capture defended random selected node).\n> >The node can decrypt the encrypted bloom baits with it, but remains\n> >powerless to correlate with bloom baits to other payments received by\n> >the same user in bother blocks.\n> >\n> \n> I'm not sure I've fully wrapped my head around it.\n> \n>   d/Q        - Identity key\n>   E          - Generate an epoch-pubkey: E = Q * H1(epoch)\n>   r/P        - Ephemeral privkey/pubkey, or discoverable from inputs\n>   S = r * K  - Shared secret (ECDE)\n\nThere needs to be two separate payor pubkeys, which I called elsewhere\nthe \"Filter\" and \"Recover\" pubkeys - the latter I think corresponds to\nwhat you meant by identity key. From those two pubkeys two separate\nshared secrets are derived.\n\nThe key idea is that you can encrypt a short string of zeros with the\n\"Filter\" pubkey using ECDH and place the resulting \"filter bait\" in the\ntransaction. This lets the payor give the secret key corresponding to\nthat pubkey to a semi-trusted third party. That third party can then\ntrial decrypt all filter bait seen in transactions in the blockchain,\nand every time the decrypted string has a sufficient number of zeros\nit's considered a filter pass and the transaction is given to the payor.\nFor n zero bits one in 2^n transactions will match at random, which sets\nyour false positive rate.\n\nBasically think of it as a way to outsource the work required for\nzero-prefix stealth addresses, but with (less) of a sacrifice of\nanonymity compared to just giving the third-party your recovery pubkey.\nIdentity-based encryption only comes into it because it's nice to be\nable to further limit what transactions the server knows about to\nspecific time intervals rather than forver into the future.\n\nInterestingly both schemes can be used at once - a short public prefix\ncombined with a second private filter. What's interesting there is that\nthe public prefix can do a first-pass filtering, with the second private\nfilter relatively long but still providing plausible deniability - you\ncan always claim 100% of the matching transactions were false positives\nbecause you didn't receive any funds!\n\n> The full node then uses this privkey to decrypt the same byte in all\n> the transactions in that epoch/block which match the expected\n> layout/template, e.g. given a certain length OP_RETURN, pull the\n> specific byte and decrypt.\n> \n> This decrypted byte is then in turn used as bloom bait which may or\n> may not cause the transaction to be sent back to the SPV client.\n\nThere's no bloom filters involved; as I said before \"bloom bait\" is a\nmisleading name. \"Filter bait\" is a better term given it's a generic\nconcept.\n\n> What encryption scheme is being used here?\n\nXOR with the ECDH-calculated nonce is fine. (run the nonce though a hash\nfunction first)\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140202/873aaab8/attachment.sig>"
            },
            {
                "author": "Adam Back",
                "date": "2014-02-02T15:26:24",
                "message_text_only": "I think you Peter & Jeremy figured it out - dont disagree with the\nexplanation details.\n\nAnd it seems better explained between the two posts than I did.  I think\nPeter is right that you do not need an explicit prefix, the prefix after\ndecryption can be a chosen number of leading 0s and this gives a tunable\namount of false positives.  You already have privacy becaue the query is\nonly revealed to the semi-trusted full node, and its query scope is limited\nto one or a chosen batch of blocks.  But you can if desired add additional\nambiguity as Peter described by reducing the number of bits of 0 in the\ndecrypted block.  There is no need for matching a specific prefix as its\nalready a recipient specific calculation.  (It means the actual encrypted\nvalue where it is chosen would have to mimic false positives: random with\nn-bits of trailing 0s and expected probability distribution).\n\nIt should be compatible for combining with sharding or public prefixes, as\nPeter mentioned but for short public prefixes those still has some (reduced)\nblockchain ledger logged possibility to reduce anonymity set when combined\nwith flow analysis.\n\nMaybe you could vary a public prefix per block.  Eg the public prefix for a\ngiven user is the LSBits of the per block IBE derived pubic key for a given\nuser.  I am not sure if that helps or hinders.  Maybe it hurts anonymity set\nbecause the analyst (Eve) is given multiple chances over time to exclude an\nanalysed flow candidate.\n\nIt would desirable to find a non-IBE way to do this.  (And more\ncomputationally efficient / precomputable / indexable)\n\nOr you could use different address types depending on the circumstance:\none-use, stealth, or IBE.  Kind of difficult to automate that (to know what\nthe user is planning to do with it) and avoid user confusion.  Clearly users\nare quite confused and the convenient and understandable thing is to have a\n(safely) reusable address.\n\nAdam\n\nOn Sun, Feb 02, 2014 at 07:26:10AM -0500, Peter Todd wrote:\n>On Sun, Feb 02, 2014 at 01:16:20AM -0800, Jeremy Spilman wrote:\n>> >\n>> >Consequently you can now securely and very network/space efficiently\n>> >securely delegate searching a block by computing the private key for the\n>> >IBE pub key that any sender would use for that block, and sending it as\n>> >a query to a random (or node-capture defended random selected node).\n>> >The node can decrypt the encrypted bloom baits with it, but remains\n>> >powerless to correlate with bloom baits to other payments received by\n>> >the same user in bother blocks.\n>> >\n>>\n>> I'm not sure I've fully wrapped my head around it.\n>>\n>>   d/Q        - Identity key\n>>   E          - Generate an epoch-pubkey: E = Q * H1(epoch)\n>>   r/P        - Ephemeral privkey/pubkey, or discoverable from inputs\n>>   S = r * K  - Shared secret (ECDE)\n>\n>There needs to be two separate payor pubkeys, which I called elsewhere\n>the \"Filter\" and \"Recover\" pubkeys - the latter I think corresponds to\n>what you meant by identity key. From those two pubkeys two separate\n>shared secrets are derived.\n>\n>The key idea is that you can encrypt a short string of zeros with the\n>\"Filter\" pubkey using ECDH and place the resulting \"filter bait\" in the\n>transaction. This lets the payor give the secret key corresponding to\n>that pubkey to a semi-trusted third party. That third party can then\n>trial decrypt all filter bait seen in transactions in the blockchain,\n>and every time the decrypted string has a sufficient number of zeros\n>it's considered a filter pass and the transaction is given to the payor.\n>For n zero bits one in 2^n transactions will match at random, which sets\n>your false positive rate.\n>\n>Basically think of it as a way to outsource the work required for\n>zero-prefix stealth addresses, but with (less) of a sacrifice of\n>anonymity compared to just giving the third-party your recovery pubkey.\n>Identity-based encryption only comes into it because it's nice to be\n>able to further limit what transactions the server knows about to\n>specific time intervals rather than forver into the future.\n>\n>Interestingly both schemes can be used at once - a short public prefix\n>combined with a second private filter. What's interesting there is that\n>the public prefix can do a first-pass filtering, with the second private\n>filter relatively long but still providing plausible deniability - you\n>can always claim 100% of the matching transactions were false positives\n>because you didn't receive any funds!\n>\n>> The full node then uses this privkey to decrypt the same byte in all\n>> the transactions in that epoch/block which match the expected\n>> layout/template, e.g. given a certain length OP_RETURN, pull the\n>> specific byte and decrypt.\n>>\n>> This decrypted byte is then in turn used as bloom bait which may or\n>> may not cause the transaction to be sent back to the SPV client.\n>\n>There's no bloom filters involved; as I said before \"bloom bait\" is a\n>misleading name. \"Filter bait\" is a better term given it's a generic\n>concept.\n>\n>> What encryption scheme is being used here?\n>\n>XOR with the ECDH-calculated nonce is fine. (run the nonce though a hash\n>function first)\n>\n>-- \n>'peter'[:-1]@petertodd.org\n>000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0"
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-02T11:55:31",
                "message_text_only": "> On Sat, Jan 25, 2014 at 05:19:01PM +0100, Adam Back wrote:\n> [quote author=adam3us link=topic=431756.msg4729682#msg4729682\n> date=1390660452]\n> So have been talking with Greg Maxwell, Peter Todd, Jeremy Spillman,\n> Mike Hearn, Bytecoin and others about reusable addresses.\n> \n> There is a summary of the situation here\n> http://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg03792.html\n> and I had posed th question of whether it was possible to do better at\n> all with Peter Todd:\n\nYou're explanation is a bit long-winded, so I'll start with a simplified\nECC-based version first and later explain how identity-based encryption\napplies to the problem; I have a feeling not many non-crypt-experts\nspent the time to figure out what you're talking about; do check if what\nI've written below is correct:\n\nSo Alice wants to pay Bob, who is bandwidth constrained and frequently\noffline. Meanwhile Ivan has a full node, but can't really be trusted.\nMeanwhile Eve is busy trying to piece together everyones' financial\ndetails.\n\nBob publicly publishes three pubkeys, Filter, Recover, and Spend, along\nwith a short n-bit prefix p. When Alice needs to pay Bob she creates a\nephemeral keypair and uses ECDH *two* shared secrets, n_f and n_r, from\nBob's Filter and Recover pubkeys respectively. She makes a transaction\nthat pays Bob by deriving pubkey Spend_{n_f} from the Spend and n_r\nnonce.  She also uses the Filter nonce and the prefix to derive a\nencrypted prefix p'=n_f^p and puts that prefix and the cleartext\nephemeral pubkey in the transaction as data.\n\nWhen Bob wants to find that transaction he gives the prefix and Filter\nsecret key to Ivan, who then scans the blockchain. For every transaction\nhe computes n_f=ECDH(Filter_sec, Ephm_pub), extracts the encrypted\nprefix p' from the transaction, and checks if p'=n_f^p If so he gives\nthat transaction to Bob who can then use his Recover secret key to check\nif the transaction was in fact for him. (note how the prefix can\nactually always be simply a given length of zeros)\n\nBecause Bob's prefix is short Ivan only learns probabalistic information\nabout what transactions might be Bob's. Eve doesn't know the Filter\nsecret key, and thus learns nothing at all from the blockchain data. On\nthe other hand after getting the key once Ivan can forever after get\nthat probability information about what transactions might be Bob's.\n\nWhat we'd really like is for there to be some way for Alice to derive a\ntime-limited Filter pubkey from some public random beacon with value\nR_i, such as the Bitcoin blockchain, such that each defined time\ninterval uses a different key. Bob would then only give Ivan the secret\nkey(s) for the time interval(s) in question.\n\nUnfortunately ECDSA doesn't have a way to do this. The closest thing\navailable is BIP32-style key derivation, however it has the property\nthat given a derived secret key and known master pubkey the master\nsecret key can be derived. Thus Ivan can simply try every public Filter\nkey/epoch tweak he knows about until he finds Q,d' st. (d+d')G=Q+d'G\nFrom that he can recover d, reducing the security to where we started.\n(or put another way, Ivan can store every (d+d') secret key he is asked\nto search with, and test it against every public key he learns about\nlater)\n\nIdentity-based cryptograhy however can do that. Bob publishes a (single)\nmaster public key, and anyone can derive public keys based on that\nmaster key and the random beacon value R_i. Bob can then derive the\ncorresponding secret key, but unlike with ECDSA, that secret key *can't*\nbe used to derive the master private key. Having said that, it can of\ncourse be linked to that key, so every query that Bob makes gives Ivan\nsome knowledge about what transactions might be in Bob's wallet.\n\nProblem is, who the hell has a production-ready Weil pairing library\nkicking around? (is this read? http://crypto.stanford.edu/pbc/) Also,\nWeil pairing is not yet trustworthy:\n\n    < gmaxwell> (IMO thats how we should be using pairing in\n    cryptosystems: for lower value applications, and solving things that\n    can't be solved any other way)\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140202/ce7414ce/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "(space) efficient reusable addr via weil pairing IBE (Re: Bait for reusable addresses)",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Adam Back",
                "Jeremy Spilman",
                "Peter Todd"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 27980
        }
    },
    {
        "title": "[Bitcoin-development] BIP70: Canceling Payments",
        "thread_messages": [
            {
                "author": "Tim Tuxworth",
                "date": "2014-02-03T18:08:47",
                "message_text_only": "The process described in BIP70 might be ok for a simple \"happy path\" \nscenario, but what if things don't work so smoothly. I'm not talking \nhere about technical issues, but _very common_ business scenarios such as:\n\ne.g. Merchant cancels request before payment is sent, such as when:-\n- the merchant realizes that they charged the wrong amount\n- the merchant realizes that they send the payment request to the wrong \ncustomer\n...\n\ne.g. the Merchant or Customer decides to cancel the transaction after \nthe payment request is sent because:-\n- the customer decides to pay by some other mechanism like cash or \ncredit/debit\n- the customer doesn't have sufficient funds and decides not to purchase\n- the customer changes their mind and decides not to purchase\n...\n\nIt strikes me that a \"Cancel Payment Request\" message is required\nand a \"Reject Payment Request\" may also be required (or maybe use the \nsame message for both).\n\nTim Tuxworth"
            },
            {
                "author": "Christophe Biocca",
                "date": "2014-02-03T18:49:07",
                "message_text_only": "Over http, the merchant doesn't have the ability to reach out to the\nconsumer's bitcoin wallet on their own. So sending \"Cancel Payment\nRequest\" to the user is impossible.\n\nIf the customer doesn't want to send, nothing ever needs to happen. So\nsending a \"Reject Payment Request\" to the merchant is useless.\n\nThe unhappy path scenario with Payment Requests (customer paid, but\nfor whatever reason that payment is no longer valid) can be simply\nsolved in 1 of 2 ways:\n\nIf the merchant realizes the mistake, they can refund the money.\nIf the customer realizes the problem, they can contact the merchant,\nprovide the signed request, and ask the merchant to return the funds.\n\nWhat isn't covered?\n\nOn Mon, Feb 3, 2014 at 1:08 PM, Tim Tuxworth <tim at go-taxi.biz> wrote:\n> The process described in BIP70 might be ok for a simple \"happy path\"\n> scenario, but what if things don't work so smoothly. I'm not talking\n> here about technical issues, but _very common_ business scenarios such as:\n>\n> e.g. Merchant cancels request before payment is sent, such as when:-\n> - the merchant realizes that they charged the wrong amount\n> - the merchant realizes that they send the payment request to the wrong\n> customer\n> ...\n>\n> e.g. the Merchant or Customer decides to cancel the transaction after\n> the payment request is sent because:-\n> - the customer decides to pay by some other mechanism like cash or\n> credit/debit\n> - the customer doesn't have sufficient funds and decides not to purchase\n> - the customer changes their mind and decides not to purchase\n> ...\n>\n> It strikes me that a \"Cancel Payment Request\" message is required\n> and a \"Reject Payment Request\" may also be required (or maybe use the\n> same message for both).\n>\n> Tim Tuxworth\n>\n> ------------------------------------------------------------------------------\n> Managing the Performance of Cloud-Based Applications\n> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> Read the Whitepaper.\n> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Tim Tuxworth Founder Go-taxi.biz",
                "date": "2014-02-03T20:30:58",
                "message_text_only": "Is BIP70 limited to http only?\n\nWhat about face to face scenarios, or realtime like ticket sales or gambling, and socket and/or bluetooth type connections?\n\nTim Tuxworth\nFounder Go-Taxi.biz\n\n<div>-------- Original message --------</div><div>From: Christophe Biocca <christophe.biocca at gmail.com> </div><div>Date:2014/02/03  10:49 AM  (GMT-08:00) </div><div>To: Tim Tuxworth <tim at go-taxi.biz> </div><div>Cc: bitcoin-development at lists.sourceforge.net </div><div>Subject: Re: [Bitcoin-development] BIP70: Canceling Payments </div><div>\n</div>Over http, the merchant doesn't have the ability to reach out to the\nconsumer's bitcoin wallet on their own. So sending \"Cancel Payment\nRequest\" to the user is impossible.\n\nIf the customer doesn't want to send, nothing ever needs to happen. So\nsending a \"Reject Payment Request\" to the merchant is useless.\n\nThe unhappy path scenario with Payment Requests (customer paid, but\nfor whatever reason that payment is no longer valid) can be simply\nsolved in 1 of 2 ways:\n\nIf the merchant realizes the mistake, they can refund the money.\nIf the customer realizes the problem, they can contact the merchant,\nprovide the signed request, and ask the merchant to return the funds.\n\nWhat isn't covered?\n\nOn Mon, Feb 3, 2014 at 1:08 PM, Tim Tuxworth <tim at go-taxi.biz> wrote:\n> The process described in BIP70 might be ok for a simple \"happy path\"\n> scenario, but what if things don't work so smoothly. I'm not talking\n> here about technical issues, but _very common_ business scenarios such as:\n>\n> e.g. Merchant cancels request before payment is sent, such as when:-\n> - the merchant realizes that they charged the wrong amount\n> - the merchant realizes that they send the payment request to the wrong\n> customer\n> ...\n>\n> e.g. the Merchant or Customer decides to cancel the transaction after\n> the payment request is sent because:-\n> - the customer decides to pay by some other mechanism like cash or\n> credit/debit\n> - the customer doesn't have sufficient funds and decides not to purchase\n> - the customer changes their mind and decides not to purchase\n> ...\n>\n> It strikes me that a \"Cancel Payment Request\" message is required\n> and a \"Reject Payment Request\" may also be required (or maybe use the\n> same message for both).\n>\n> Tim Tuxworth\n>\n> ------------------------------------------------------------------------------\n> Managing the Performance of Cloud-Based Applications\n> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> Read the Whitepaper.\n> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140203/278866eb/attachment.html>"
            },
            {
                "author": "Andreas Schildbach",
                "date": "2014-02-03T21:25:53",
                "message_text_only": "Have a look at my post \"Payment Protocol for Face-to-face payments\". In\nshort: I implemented BIP70 using combinations of either QR-code or NFC\nplus Bluetooth. You can download a working preview app from:\n\nhttps://github.com/schildbach/bitcoin-wallet/releases/tag/v3.30-bitcoinj0.11\n\n\nOn 02/03/2014 09:30 PM, Tim Tuxworth Founder Go-taxi.biz wrote:\n> Is BIP70 limited to http only?\n> \n> What about face to face scenarios, or realtime like ticket sales or\n> gambling, and socket and/or bluetooth type connections?\n> \n> Tim Tuxworth\n> Founder Go-Taxi.biz\n> \n> \n> -------- Original message --------\n> From: Christophe Biocca\n> Date:2014/02/03 10:49 AM (GMT-08:00)\n> To: Tim Tuxworth\n> Cc: bitcoin-development at lists.sourceforge.net\n> Subject: Re: [Bitcoin-development] BIP70: Canceling Payments\n> \n> Over http, the merchant doesn't have the ability to reach out to the\n> consumer's bitcoin wallet on their own. So sending \"Cancel Payment\n> Request\" to the user is impossible.\n> \n> If the customer doesn't want to send, nothing ever needs to happen. So\n> sending a \"Reject Payment Request\" to the merchant is useless.\n> \n> The unhappy path scenario with Payment Requests (customer paid, but\n> for whatever reason that payment is no longer valid) can be simply\n> solved in 1 of 2 ways:\n> \n> If the merchant realizes the mistake, they can refund the money.\n> If the customer realizes the problem, they can contact the merchant,\n> provide the signed request, and ask the merchant to return the funds.\n> \n> What isn't covered?\n> \n> On Mon, Feb 3, 2014 at 1:08 PM, Tim Tuxworth <tim at go-taxi.biz> wrote:\n>> The process described in BIP70 might be ok for a simple \"happy path\"\n>> scenario, but what if things don't work so smoothly. I'm not talking\n>> here about technical issues, but _very common_ business scenarios such as:\n>>\n>> e.g. Merchant cancels request before payment is sent, such as when:-\n>> - the merchant realizes that they charged the wrong amount\n>> - the merchant realizes that they send the payment request to the wrong\n>> customer\n>> ...\n>>\n>> e.g. the Merchant or Customer decides to cancel the transaction after\n>> the payment request is sent because:-\n>> - the customer decides to pay by some other mechanism like cash or\n>> credit/debit\n>> - the customer doesn't have sufficient funds and decides not to purchase\n>> - the customer changes their mind and decides not to purchase\n>> ...\n>>\n>> It strikes me that a \"Cancel Payment Request\" message is required\n>> and a \"Reject Payment Request\" may also be required (or maybe use the\n>> same message for both).\n>>\n>> Tim Tuxworth\n>>\n>>\n> ------------------------------------------------------------------------------\n>> Managing the Performance of Cloud-Based Applications\n>> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n>> Read the Whitepaper.\n>>\n> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> \n> \n> ------------------------------------------------------------------------------\n> Managing the Performance of Cloud-Based Applications\n> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> Read the Whitepaper.\n> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk\n> \n> \n> \n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Christophe Biocca",
                "date": "2014-02-03T20:37:55",
                "message_text_only": "It's not limited to HTTP. I was pointing out that unsolicited\nmerchant-to-consumer messages don't work on HTTP (and a lot of other\nsituations), and so you can't add a need for it to the payment\nprotocol (since it wouldn't be usable in the majority of cases).\n\nOn Mon, Feb 3, 2014 at 3:30 PM, Tim Tuxworth Founder Go-taxi.biz\n<tim at go-taxi.biz> wrote:\n> Is BIP70 limited to http only?\n>\n> What about face to face scenarios, or realtime like ticket sales or\n> gambling, and socket and/or bluetooth type connections?\n>\n> Tim Tuxworth\n> Founder Go-Taxi.biz\n>\n>\n> -------- Original message --------\n> From: Christophe Biocca\n> Date:2014/02/03 10:49 AM (GMT-08:00)\n> To: Tim Tuxworth\n> Cc: bitcoin-development at lists.sourceforge.net\n> Subject: Re: [Bitcoin-development] BIP70: Canceling Payments\n>\n> Over http, the merchant doesn't have the ability to reach out to the\n> consumer's bitcoin wallet on their own. So sending \"Cancel Payment\n> Request\" to the user is impossible.\n>\n> If the customer doesn't want to send, nothing ever needs to happen. So\n> sending a \"Reject Payment Request\" to the merchant is useless.\n>\n> The unhappy path scenario with Payment Requests (customer paid, but\n> for whatever reason that payment is no longer valid) can be simply\n> solved in 1 of 2 ways:\n>\n> If the merchant realizes the mistake, they can refund the money.\n> If the customer realizes the problem, they can contact the merchant,\n> provide the signed request, and ask the merchant to return the funds.\n>\n> What isn't covered?\n>\n> On Mon, Feb 3, 2014 at 1:08 PM, Tim Tuxworth <tim at go-taxi.biz> wrote:\n>> The process described in BIP70 might be ok for a simple \"happy path\"\n>> scenario, but what if things don't work so smoothly. I'm not talking\n>> here about technical issues, but _very common_ business scenarios such as:\n>>\n>> e.g. Merchant cancels request before payment is sent, such as when:-\n>> - the merchant realizes that they charged the wrong amount\n>> - the merchant realizes that they send the payment request to the wrong\n>> customer\n>> ...\n>>\n>> e.g. the Merchant or Customer decides to cancel the transaction after\n>> the payment request is sent because:-\n>> - the customer decides to pay by some other mechanism like cash or\n>> credit/debit\n>> - the customer doesn't have sufficient funds and decides not to purchase\n>> - the customer changes their mind and decides not to purchase\n>> ...\n>>\n>> It strikes me that a \"Cancel Payment Request\" message is required\n>> and a \"Reject Payment Request\" may also be required (or maybe use the\n>> same message for both).\n>>\n>> Tim Tuxworth\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> Managing the Performance of Cloud-Based Applications\n>> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n>> Read the Whitepaper.\n>>\n>> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            }
        ],
        "thread_summary": {
            "title": "BIP70: Canceling Payments",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Tim Tuxworth Founder Go-taxi.biz",
                "Tim Tuxworth",
                "Christophe Biocca",
                "Andreas Schildbach"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 12923
        }
    },
    {
        "title": "[Bitcoin-development] bitcoinj 0.11 released, with p2sh, bip39 and payment protocol support",
        "thread_messages": [
            {
                "author": "Mike Hearn",
                "date": "2014-02-04T12:01:12",
                "message_text_only": "Hello,\n\nI'm pleased to announce the release of bitcoinj 0.11, a library for writing Bitcoin applications that run on the JVM. BitcoinJ is widely used across the Bitcoin community; some users include Bitcoin Wallet for Android, MultiBit, Hive, blockchain.info, the biteasy.com block explorer (written in Lisp!), Circle, Neo/Bee (Cypriot payment network), bitpos.me, Bitcoin Touch, BlueMatt's relay network and DNS crawler, academic advanced contracts research and more.\n\nThe release-0.11 git tag is signed by Andreas Schildbach's GPG key. The commit hash is 410d4547a7dd. This paragraph is signed by the same Bitcoin key as with previous releases (check their release announcements to establish continuity). Additionally, this email is signed using DKIM and for the first time, a key that was ID verified by the Swiss government.\n\nKey: 16vSNFP5Acsa6RBbjEA7QYCCRDRGXRFH4m\nSignature for last paragraph: H3DvWBqFHPxKW/cdYUdZ6OHjbq6ZtC5PHK4ebpeiE+FqTHyRLJ58BItbC0R2vo77h+DthpQigdEZ0V8ivSM7VIg=\n\nNotable changes and new features\n\nThanks to Ken Sedgwick, an implementation of BIP39 (\"Mnemonic code for generating deterministic keys\") has been added. This is compatible with the latest Trezor implementation.\nThanks to Mike Belshe, the wallet can now send to P2SH addresses.\nThanks to Matt Corallo, the network layer was rewritten from scratch. It no longer depends on Netty, and it now supports both blocking and non-blocking sockets. In practice that means Java's built in support for transparent SSL and SOCKS becomes available again, which in turn means connecting via Tor is now possible. The new framework is lightweight, easy to understand and has been running a DNS seed crawler for some months now.\nThanks to Kevin Greene, we've added some support for the BIP70 payment protocol. Wallet authors can now consume payment requests, check their signatures and submit payments with the new easy to use PaymentSession class. The wallet-tool command line UI has support and an article explains how to use it.\nThanks to Miron Cuperman, the wallet can now watch arbitrary addresses and scripts. The wallet could previously watch an address as long as the public key was known. Now it's possible to watch for addresses even when the public key is not known.\nAlso thanks to Miron, Bloom filtering was also improved. The system now tracks false positive rates and cleans the filter when FP rates get too high. Unfortunately, some privacy bugs in Bloom filtering remain, which could (amongst other things) allow a malicious remote peer to test whether you own a particular key.\nThanks to Alex Taylor (bitpos.me), a new PostgreSQL based pruning block store was added. This block store is fast, and indexes the UTXO set, allowing for fast lookup of the balance of any given address.\nA Java 8 based wallet template app is now included. The template is designed for people writing contract based applications. It provides a simple app that can be copy/pasted, which connects to the P2P network, manages a wallet, and provides a GUI that shows progress, balance, address+qrcode for receiving money and has a button that is used to empty the wallet out. It's designed to have an attractive and modern look, with tasteful animations and artwork.\nMicropayment channels got many big improvements to the API and implementation. The release in 0.10 can be seen as a beta, in this release the micropayments code has been taken for a test drive for a couple of real apps and many rough edges polished as a result.\nThe default USER_THREAD executor can now be replaced, allowing a 1-line switch of all callbacks onto a thread of your choice instead of needing to override each callback, each time. This should simplify and clean up the GUI code of wallet apps significantly.\nThe WalletTool command line app has a more convenient user interface now.\nA new DNS seed has been added. The seed is run by Christian Decker, from ETH Zurich.\nbitcoinj 0.11 will shortly be available via Maven Central. Please use the dependency verifier plugin and/or check the PGP signatures on the uploads, if you use this!\nSmaller improvements\n\nWe finished adding nullity annotations to the API. You should now be able to assume that any method not annotated with @Nullable won't ever return null values.\nThe WalletAppKit got a bunch of new features and convenience APIs.\nThe wallet will now create inputs with dummy signatures if the private key for an output is missing, rather than throwing an exception. You can then edit the input later to substitute in a real signature. This is useful when the signing is being done elsewhere, outside of the library.\nIn full verification mode, execution of scripts (i.e. checking signatures) can now be switched off. This is useful if you trust the source of the chain and just want to calculate the UTXO set.\nThe wallet risk analysis code is now pluggable, better documented and checks for finality in a more sensible way.\nVarious memory usage and flow control optimisations were made to allow much larger wallets to sync on Android.\nThe transaction broadcast algorithm was changed to be more robust.\nDouble spend handling in the wallet was improved.\nGenerated signatures now use canonical S values. This will aid a future hard-forking rule change which bans malleable signatures.\nSome fixes were made for enable usage with the Orchid Tor library. Further support for Tor is planned for future releases.\nNotable bug fixes\n\nSome hard-forking full verification bugs were fixed.\nThanks to Miron, PeerGroup now performs exponential backoff for peer connections, for instance if we cannot connect to them or if they disconnect us. This resolves an annoying bug in which if the library was configured with a single peer that was down, it would spin in a tight loop consuming battery.\nAPI changes\n\nSome functionality of the Wallet class was moved into separate classes under the wallet package.\nThe micropayments API and protocol changed. New clients/servers are not compatible with apps running against previous releases.\nThe Wallet sendCoins/completeTx methods no longer return booleans or null to indicate failure, they now throw InsufficientMoneyException or a subclass if the transaction cannot be completed. The exception object typically contains information on how much money is missing.\nSome mis-named methods in the HD key derivation API were renamed.\nThe WalletEventListener interface has an extra method for watching scripts now.\nPeer discovery classes moved under the net.discovery package\nAny APIs that relied on Netty are now different.\nNew documentation\n\nAn article on the networking API\nInfo on testing your apps, and how to use regtest mode to make a private Bitcoin network that allows you to mine blocks instantly.\nA reference table showing which API's implement which Bitcoin Improvement Proposals (BIPs).\nPlease note that as I am no longer employed by Google, after 0.11 signing the Google contributor license agreement will no longer be necessary. I look forward to welcoming contributions from Andreas Schildbach now this requirement has gone away. Also, in future I plan to re-namespace the library from com.google.bitcoin to org.bitcoinj - auto-migration scripts will be provided when this is done.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140204/fe4e53f6/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: smime.p7s\nType: application/pkcs7-signature\nSize: 7453 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140204/fe4e53f6/attachment.p7s>"
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-04T13:03:13",
                "message_text_only": "On Tue, Feb 04, 2014 at 01:01:12PM +0100, Mike Hearn wrote:\n> Hello,\n> \n> I'm pleased to announce the release of bitcoinj 0.11, a library for writing Bitcoin applications that run on the JVM. BitcoinJ is widely used across the Bitcoin community; some users include Bitcoin Wallet for Android, MultiBit, Hive, blockchain.info, the biteasy.com block explorer (written in Lisp!), Circle, Neo/Bee (Cypriot payment network), bitpos.me, Bitcoin Touch, BlueMatt's relay network and DNS crawler, academic advanced contracts research and more.\n> \n> The release-0.11 git tag is signed by Andreas Schildbach's GPG key. The commit hash is 410d4547a7dd. This paragraph is signed by the same Bitcoin key as with previous releases (check their release announcements to establish continuity). Additionally, this email is signed using DKIM and for the first time, a key that was ID verified by the Swiss government.\n> \n> Key: 16vSNFP5Acsa6RBbjEA7QYCCRDRGXRFH4m\n> Signature for last paragraph: H3DvWBqFHPxKW/cdYUdZ6OHjbq6ZtC5PHK4ebpeiE+FqTHyRLJ58BItbC0R2vo77h+DthpQigdEZ0V8ivSM7VIg=\n\nThe above makes for a great homework problem for budding cryptographers:\nWhy did the three forms of signature, DKIM, long-lived bitcoin address,\nand Official Swiss Government Identity fail to let you actually verify\nyou have the right code? (but make for great security theater)\n\nBonus question: Who has the smallest work-factor for such an attack?\n\nTwo rewards of 25mBTC for correct responses to each question from a\ncrypto newbie.\n\n> Thanks to Mike Belshe, the wallet can now send to P2SH addresses.\n\nThanks\n\n> Generated signatures now use canonical S values. This will aid a future hard-forking rule change which bans malleable signatures.\n\nSoft-forking rule change.\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140204/dea3f133/attachment.sig>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-02-04T13:13:12",
                "message_text_only": "Hah, good point. If nobody completes the homework, I'll post a fixed\nversion tomorrow :)\n\n\nOn Tue, Feb 4, 2014 at 2:03 PM, Peter Todd <pete at petertodd.org> wrote:\n\n> On Tue, Feb 04, 2014 at 01:01:12PM +0100, Mike Hearn wrote:\n> > Hello,\n> >\n> > I'm pleased to announce the release of bitcoinj 0.11, a library for\n> writing Bitcoin applications that run on the JVM. BitcoinJ is widely used\n> across the Bitcoin community; some users include Bitcoin Wallet for\n> Android, MultiBit, Hive, blockchain.info, the biteasy.com block explorer\n> (written in Lisp!), Circle, Neo/Bee (Cypriot payment network), bitpos.me,\n> Bitcoin Touch, BlueMatt's relay network and DNS crawler, academic advanced\n> contracts research and more.\n> >\n> > The release-0.11 git tag is signed by Andreas Schildbach's GPG key. The\n> commit hash is 410d4547a7dd. This paragraph is signed by the same Bitcoin\n> key as with previous releases (check their release announcements to\n> establish continuity). Additionally, this email is signed using DKIM and\n> for the first time, a key that was ID verified by the Swiss government.\n> >\n> > Key: 16vSNFP5Acsa6RBbjEA7QYCCRDRGXRFH4m\n> > Signature for last paragraph:\n> H3DvWBqFHPxKW/cdYUdZ6OHjbq6ZtC5PHK4ebpeiE+FqTHyRLJ58BItbC0R2vo77h+DthpQigdEZ0V8ivSM7VIg=\n>\n> The above makes for a great homework problem for budding cryptographers:\n> Why did the three forms of signature, DKIM, long-lived bitcoin address,\n> and Official Swiss Government Identity fail to let you actually verify\n> you have the right code? (but make for great security theater)\n>\n> Bonus question: Who has the smallest work-factor for such an attack?\n>\n> Two rewards of 25mBTC for correct responses to each question from a\n> crypto newbie.\n>\n> > Thanks to Mike Belshe, the wallet can now send to P2SH addresses.\n>\n> Thanks\n>\n> > Generated signatures now use canonical S values. This will aid a future\n> hard-forking rule change which bans malleable signatures.\n>\n> Soft-forking rule change.\n>\n> --\n> 'peter'[:-1]@petertodd.org\n> 000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140204/22905784/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-04T13:17:23",
                "message_text_only": "On Tue, Feb 04, 2014 at 02:13:12PM +0100, Mike Hearn wrote:\n> Hah, good point. If nobody completes the homework, I'll post a fixed\n> version tomorrow :)\n\nHeh, here's another 25mBTC while we're at it:\n\nhttps://github.com/opentimestamps/opentimestamps-client/commit/288f3c17626974de7eaef4f1c9b5cd93eecf40f6\n\nWhy is that a bad idea?\n\nBonus question: What was I smoking? (hint: where do I live?)\n\n> On Tue, Feb 4, 2014 at 2:03 PM, Peter Todd <pete at petertodd.org> wrote:\n> \n> > On Tue, Feb 04, 2014 at 01:01:12PM +0100, Mike Hearn wrote:\n> > > Hello,\n> > >\n> > > I'm pleased to announce the release of bitcoinj 0.11, a library for\n> > writing Bitcoin applications that run on the JVM. BitcoinJ is widely used\n> > across the Bitcoin community; some users include Bitcoin Wallet for\n> > Android, MultiBit, Hive, blockchain.info, the biteasy.com block explorer\n> > (written in Lisp!), Circle, Neo/Bee (Cypriot payment network), bitpos.me,\n> > Bitcoin Touch, BlueMatt's relay network and DNS crawler, academic advanced\n> > contracts research and more.\n> > >\n> > > The release-0.11 git tag is signed by Andreas Schildbach's GPG key. The\n> > commit hash is 410d4547a7dd. This paragraph is signed by the same Bitcoin\n> > key as with previous releases (check their release announcements to\n> > establish continuity). Additionally, this email is signed using DKIM and\n> > for the first time, a key that was ID verified by the Swiss government.\n> > >\n> > > Key: 16vSNFP5Acsa6RBbjEA7QYCCRDRGXRFH4m\n> > > Signature for last paragraph:\n> > H3DvWBqFHPxKW/cdYUdZ6OHjbq6ZtC5PHK4ebpeiE+FqTHyRLJ58BItbC0R2vo77h+DthpQigdEZ0V8ivSM7VIg=\n> >\n> > The above makes for a great homework problem for budding cryptographers:\n> > Why did the three forms of signature, DKIM, long-lived bitcoin address,\n> > and Official Swiss Government Identity fail to let you actually verify\n> > you have the right code? (but make for great security theater)\n> >\n> > Bonus question: Who has the smallest work-factor for such an attack?\n> >\n> > Two rewards of 25mBTC for correct responses to each question from a\n> > crypto newbie.\n> >\n> > > Thanks to Mike Belshe, the wallet can now send to P2SH addresses.\n> >\n> > Thanks\n> >\n> > > Generated signatures now use canonical S values. This will aid a future\n> > hard-forking rule change which bans malleable signatures.\n> >\n> > Soft-forking rule change.\n> >\n> > --\n> > 'peter'[:-1]@petertodd.org\n> > 000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0\n> >\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140204/32b91c27/attachment.sig>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-02-04T14:43:31",
                "message_text_only": "On Tue, Feb 4, 2014 at 8:17 AM, Peter Todd <pete at petertodd.org> wrote:\n> Bonus question: What was I smoking? (hint: where do I live?)\n\nCryptographers smoke... hash, right?\n\n(couldn't resist)\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-04T14:46:40",
                "message_text_only": "On Tue, Feb 04, 2014 at 09:43:31AM -0500, Jeff Garzik wrote:\n> On Tue, Feb 4, 2014 at 8:17 AM, Peter Todd <pete at petertodd.org> wrote:\n> > Bonus question: What was I smoking? (hint: where do I live?)\n> \n> Cryptographers smoke... hash, right?\n> \n> (couldn't resist)\n\n<groan>\n\nI think we have a winner; as you can see Jeff must be a great father.\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140204/df60701e/attachment.sig>"
            },
            {
                "author": "Natanael",
                "date": "2014-02-04T15:17:47",
                "message_text_only": "Because it's trivial to create collisions! You can choose exactly what\noutput you want. That's why XOR is a very bad digest scheme.\n\n- Sent from my phone\nDen 4 feb 2014 14:20 skrev \"Peter Todd\" <pete at petertodd.org>:\n\n> On Tue, Feb 04, 2014 at 02:13:12PM +0100, Mike Hearn wrote:\n> > Hah, good point. If nobody completes the homework, I'll post a fixed\n> > version tomorrow :)\n>\n> Heh, here's another 25mBTC while we're at it:\n>\n>\n> https://github.com/opentimestamps/opentimestamps-client/commit/288f3c17626974de7eaef4f1c9b5cd93eecf40f6\n>\n> Why is that a bad idea?\n>\n> Bonus question: What was I smoking? (hint: where do I live?)\n>\n> > On Tue, Feb 4, 2014 at 2:03 PM, Peter Todd <pete at petertodd.org> wrote:\n> >\n> > > On Tue, Feb 04, 2014 at 01:01:12PM +0100, Mike Hearn wrote:\n> > > > Hello,\n> > > >\n> > > > I'm pleased to announce the release of bitcoinj 0.11, a library for\n> > > writing Bitcoin applications that run on the JVM. BitcoinJ is widely\n> used\n> > > across the Bitcoin community; some users include Bitcoin Wallet for\n> > > Android, MultiBit, Hive, blockchain.info, the biteasy.com block\n> explorer\n> > > (written in Lisp!), Circle, Neo/Bee (Cypriot payment network),\n> bitpos.me,\n> > > Bitcoin Touch, BlueMatt's relay network and DNS crawler, academic\n> advanced\n> > > contracts research and more.\n> > > >\n> > > > The release-0.11 git tag is signed by Andreas Schildbach's GPG key.\n> The\n> > > commit hash is 410d4547a7dd. This paragraph is signed by the same\n> Bitcoin\n> > > key as with previous releases (check their release announcements to\n> > > establish continuity). Additionally, this email is signed using DKIM\n> and\n> > > for the first time, a key that was ID verified by the Swiss government.\n> > > >\n> > > > Key: 16vSNFP5Acsa6RBbjEA7QYCCRDRGXRFH4m\n> > > > Signature for last paragraph:\n> > >\n> H3DvWBqFHPxKW/cdYUdZ6OHjbq6ZtC5PHK4ebpeiE+FqTHyRLJ58BItbC0R2vo77h+DthpQigdEZ0V8ivSM7VIg=\n> > >\n> > > The above makes for a great homework problem for budding\n> cryptographers:\n> > > Why did the three forms of signature, DKIM, long-lived bitcoin address,\n> > > and Official Swiss Government Identity fail to let you actually verify\n> > > you have the right code? (but make for great security theater)\n> > >\n> > > Bonus question: Who has the smallest work-factor for such an attack?\n> > >\n> > > Two rewards of 25mBTC for correct responses to each question from a\n> > > crypto newbie.\n> > >\n> > > > Thanks to Mike Belshe, the wallet can now send to P2SH addresses.\n> > >\n> > > Thanks\n> > >\n> > > > Generated signatures now use canonical S values. This will aid a\n> future\n> > > hard-forking rule change which bans malleable signatures.\n> > >\n> > > Soft-forking rule change.\n> > >\n> > > --\n> > > 'peter'[:-1]@petertodd.org\n> > > 000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0\n> > >\n>\n> --\n> 'peter'[:-1]@petertodd.org\n> 000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0\n>\n>\n> ------------------------------------------------------------------------------\n> Managing the Performance of Cloud-Based Applications\n> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> Read the Whitepaper.\n>\n> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140204/a609d169/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-04T16:04:14",
                "message_text_only": "On Tue, Feb 04, 2014 at 04:17:47PM +0100, Natanael wrote:\n> Because it's trivial to create collisions! You can choose exactly what\n> output you want. That's why XOR is a very bad digest scheme.\n\nYou're close, but not quite.\n\nSo, imagine you have a merkle tree, and you're trying to timestamp some\ndata at the bottom of the tree. Now you can successfully timestamp the\ntop digest in the Bitcoin blockchain right, and be sure that digest\nexisted before some time. But what about the digests at the bottom of\nthe tree? What can an attacker do exactly to make a fake timestamp if\nthe tree is using XOR rather than a proper hash function?\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140204/9a607aa4/attachment.sig>"
            },
            {
                "author": "Jeremy Spilman",
                "date": "2014-02-05T07:57:36",
                "message_text_only": "Well the point of the Merkle tree is that if I all you have is the top,  \nand all I give you is a leaf node and the siblings of all parents of that  \nleaf, then by simply hashing you can check if the node was actually  \npresent in the tree.\n\nThe only reason this works is because it's hard for an attacker to come up  \nwith the list of values which would ultimately hash together to produce  \nthe expected top value. But if the hash function is actually just XOR, it  \nbecomes completely trivial for me to claim any value I want was in the  \ntree.\n\n1) Pick the fake value you want to claim was in the tree (leaf node)\n2) Choose some random values to fake the depth in the tree\n3) Calculate the last value as 'Prev (x) Top'\n4) When your victim goes to verify set membership, they will get the top  \nvalue they expected\n\n\n\nOn Tue, 04 Feb 2014 08:04:14 -0800, Peter Todd <pete at petertodd.org> wrote:\n\n> On Tue, Feb 04, 2014 at 04:17:47PM +0100, Natanael wrote:\n>> Because it's trivial to create collisions! You can choose exactly what\n>> output you want. That's why XOR is a very bad digest scheme.\n>\n> You're close, but not quite.\n>\n> So, imagine you have a merkle tree, and you're trying to timestamp some\n> data at the bottom of the tree. Now you can successfully timestamp the\n> top digest in the Bitcoin blockchain right, and be sure that digest\n> existed before some time. But what about the digests at the bottom of\n> the tree? What can an attacker do exactly to make a fake timestamp if\n> the tree is using XOR rather than a proper hash function?"
            },
            {
                "author": "Brooks Boyd",
                "date": "2014-02-05T15:09:31",
                "message_text_only": "On Tue, Feb 4, 2014 at 10:04 AM, Peter Todd <pete at petertodd.org> wrote:\n>\n> On Tue, Feb 04, 2014 at 04:17:47PM +0100, Natanael wrote:\n> > Because it's trivial to create collisions! You can choose exactly what\n> > output you want. That's why XOR is a very bad digest scheme.\n>\n> You're close, but not quite.\n>\n> So, imagine you have a merkle tree, and you're trying to timestamp some\n> data at the bottom of the tree. Now you can successfully timestamp the\n> top digest in the Bitcoin blockchain right, and be sure that digest\n> existed before some time. But what about the digests at the bottom of\n> the tree? What can an attacker do exactly to make a fake timestamp if\n> the tree is using XOR rather than a proper hash function?\n>\n\nGiven a tree like:\n\n      G\n     / \\\n    E   F\n   / \\\n  C   D\n / \\\nA   B\n\nWhere G is the root hash and A is the legitimate data that was included in\nthe tree, the legitimate user provides B, D and F along with A to prove A\nis part of the tree G.\n\nNow an attacker could just make up an arbitrary set of values that XOR\ntogether into G, like:\n\n  G\n / \\\nZ   Y\n\nAnd could therefore claim Z is part of tree G by providing Y. But if A is\nalso trying to prove its a part of G, we know the first level of the tree\nmust be E and F. It cannot also be Z and Y, so one of the two users is\nlying and the deceit is obvious, though not obvious which user is lying.\n\nAn attacker could look more convincing by using the data passed with A as a\nstarting point:\n\n        G\n       / \\\n      E   F\n     / \\\n    /   \\\n   /     \\\n  C       D\n / \\     / \\\nA   B   Z   Y\n\nInstead of working off of G, work of the lowest branch provided by A in its\nverification (D, in this case), and create the fake data Z, and calculate Y\nsuch that Z XOR Y == D (which is just Z XOR D). Now the attacker can claim\nZ is part of G by supplying Y, C, and F. The tree looks valid (it can\ncoexist with the proof provided by A, at least until someone else claims to\nbe a descendant of the D node as well), and since G was verified by\ntimestamp, looks like Z existed before that timestamp, when really it could\nbe added at any time by calculating Z XOR D.\n\nBrooks\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140205/25eaf6b2/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-07T09:21:41",
                "message_text_only": "Thanks for the great response! I had about a dozen or so people contact\nme with solutions for one or more questions, and even a anonymous\ndonation of 75mBTC to cover the rewards.\n\nI'll start with my summaries of those solutions:\n\nOn Tue, Feb 04, 2014 at 08:03:13AM -0500, Peter Todd wrote:\n> On Tue, Feb 04, 2014 at 01:01:12PM +0100, Mike Hearn wrote:\n> > Hello,\n> > \n> > I'm pleased to announce the release of bitcoinj 0.11, a library for writing Bitcoin applications that run on the JVM. BitcoinJ is widely used across the Bitcoin community; some users include Bitcoin Wallet for Android, MultiBit, Hive, blockchain.info, the biteasy.com block explorer (written in Lisp!), Circle, Neo/Bee (Cypriot payment network), bitpos.me, Bitcoin Touch, BlueMatt's relay network and DNS crawler, academic advanced contracts research and more.\n> > \n> > The release-0.11 git tag is signed by Andreas Schildbach's GPG key. The commit hash is 410d4547a7dd. This paragraph is signed by the same Bitcoin key as with previous releases (check their release announcements to establish continuity). Additionally, this email is signed using DKIM and for the first time, a key that was ID verified by the Swiss government.\n> > \n> > Key: 16vSNFP5Acsa6RBbjEA7QYCCRDRGXRFH4m\n> > Signature for last paragraph: H3DvWBqFHPxKW/cdYUdZ6OHjbq6ZtC5PHK4ebpeiE+FqTHyRLJ58BItbC0R2vo77h+DthpQigdEZ0V8ivSM7VIg=\n> \n> The above makes for a great homework problem for budding cryptographers:\n> Why did the three forms of signature, DKIM, long-lived bitcoin address,\n> and Official Swiss Government Identity fail to let you actually verify\n> you have the right code? (but make for great security theater)\n\nSo as most people correctly guessed, the problem here is that Mike\ntruncated the git commit hash; normally it's 160 bits long, but he only\ngave 48 of those bits. To understand why this is a problem, recall that\nwhat a cryptographic hash does is it takes a arbitrary block of data,\nthe message, and returns a fixed length bit string, the message digest\nor simply digest. With git the message essentially your source code and\ncommit history, and the digest is the git commit hash. Critically for a\ncryptographic hash to be secure the mapping between messages and digests\nmust be random - it must not be infeasible to find two messages with the\nsame digest. (this is called a preimage attack)\n\nThe problem is that 48 bits just isn't that many bits. An attacker can\ntake the bitcoinj sourcecode and modify it to do something malicious\nlike generate private keys insecurely. Then they can keep modifying it\nuntil the last 48-bits of the commit hash match Mike's message. (this\ncalled a partial preimage attack) Each modification has a 1 in 2^48\nchance of succeeding. You can calculate the attackers chances exactly\nwith the Binominal distribution, but a good enough approximation is\nthey'd have to make about 2^48 attempts.\n\nThat's not a very big number! Here's a nice visual comparison of how\nlong 48 bits is, compared to the partial preimage the Bitcoin network\ncracks every 10 minutes:\n\n0000000000000001512b077de3cc7ec88d1d65dc474a52a9ac9ac14ac34d7ac8\n410d4547a7dd\n\nLiterally tens of thousands of times harder. This problem is similar to\npassword cracking, and they're getting speeds like ten million attempts\nper second per CPU core. Just do the math: 2^48/10million/second/core =\n46 Core Weeks. Now I can rent 32-core servers at Amazon EC2 for as\nlittle as $0.27 per hour (spot requests) which gives me a cost for the\nattack of about $100; my time to actually do it will cost more than\nthat.\n\n\nBut that calculation is missing the point; the extra bytes are really\ncheap, so you can just use a simple rule of thumb: If a partial-preimage\nattack is what you are trying to prevent, then in cryptography an\naccepted number of bits to use is 128. Maybe just 80 bits would be\nenough, or even just 64 bits, but pretty much everyone agrees 128 is\nsafe and conservative. But read on, because even 128 bits isn't safe\nenough against another type of attack...\n\n\nA second issue that a few people noticed was that Mike just said\n\"Andreas Schildbach's GPG key\", rather than specifying the fingerprint\nof the key. By now I'd expect Mike to be confident as to what PGP key\nis actually the correct one for the human Andreas Schildbach, so there's\nabsolutely no reason not state what that key is, either in the release\nnotes, or by signing the key with Mike's (non-existant?) PGP key.\nPreferably both.\n\n> Bonus question: Who has the smallest work-factor for such an attack?\n\nNo-one got this one correct or even tried!\n\nWhat if Mike Hearn himself were the attacker? For instance, US officials\nwanted to shutdown the gambling site SatoshiDice, which reportedly uses\nthe bitcoinj library. One way to do this would be to seize the funds\nheld by SatoshiDice, putting them out of business. If they could trick\nSatoshiDice into using a version of bitcoinj with a broken PRNG, they\ncould simply wait until funds had moved into addresses generated by that\nPRNG, and/or ECC signatures were created with a known k value. (leaking\nthe private key)\n\nBut how to pull that off? The bitcoinj sourcecode is public, so they\ncan't just backdoor bitcoinj directly - everyone would find out. What\nthey need is a way to trick SatoshiDice into installing a bugged\nversion, without leaving any evidence.\n\nWith Mike Hearn's help they can calculate a pair of hashes, each with a\nn-bit prefix, but with only sqrt(2^n) work. This is called a\nsecond-preimage attack, and takes advantage of the birthday paradox,\nwhich as you may recall, is that in a room of just 23 people, there is a\n50% chance that two them share the same birthday.\n\nNow the US government continually generates pairs of slightly different\ngit commits, one being the honest code, the other with the backdoor.\nGenerating these pairs is simple enough, just change something\ninsignificant like the exact timestamp of last few commits. Every hash\ngenerated is saved in a big hashtable, as well as compared with all\npre-existing hashes. In this case they'll just need to do about 2^24\ntries to succeed, only 24 million attempts, which is frankly pretty\ntrivial.\n\nNow that they have two collissions they have Mike release bitcoinj as\nbefore to the public, and at the same time they intercept the internet\nconnections of the people suspected to be the SatoshiDice developers.\nFor the latter a MITM attack is performed, secretly replacing the good\ncopy of bitcoinj they download with the backdoored copy. The developers\ndon't notice anything unusual, because both copies appear to have the\nsame commit hash!\n\nThe beauty of this technique is provided the disclosed hash isn't too\nlong, it's still plausible that a powerful government agency brute\nforced the thing even if the backdoored code is leaked. With 48 bits\nthat's obviously trivial, but even a 64-bit collision could be made at\nthe cost of only a few million dollars. Thus, Mike Hearn has plausible\ndeniability and can claim innocence.\n\nMoral of the story is if a second-pre-image attack is a threat, you need\nto use a lot of bits. Even a full SHA-1 commit hash is only 160 bits,\nwhich gives sqrt(2^160) or 2^80 security, so anything less than the full\ngit commit hash is risky. Industry standard is to use at least 160 bits,\nand preferably you should always just use the full 256 bits that SHA-256\nor similar provides unless you have a really good reason not too.\n\n\nOn Tue, Feb 04, 2014 at 08:17:23AM -0500, Peter Todd wrote:\n> On Tue, Feb 04, 2014 at 02:13:12PM +0100, Mike Hearn wrote:\n> > Hah, good point. If nobody completes the homework, I'll post a fixed\n> > version tomorrow :)\n> \n> Heh, here's another 25mBTC while we're at it:\n> \n> https://github.com/opentimestamps/opentimestamps-client/commit/288f3c17626974de7eaef4f1c9b5cd93eecf40f6\n> \n> Why is that a bad idea?\n\nBrooks Boyd already posted a great writeup, so I'm going to reference\nhis instead:\nhttp://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg03882.html\n\n\nIn closing I think it's important that we all remember we're writing\nsoftware that handles money and the incentives to sneak backdoors into\nsaid software are enormous, and every worse, universal. Everyone can\nprofit pretty directly from stealing cash, so the \"Bad guys\" we're up\nagainst range from your \"Russian hackers\" to the US government and\neveryone in between.\n\nFortunately the nature of attacks is that for an attack to succeed,\neverything has to go right, but for it to fail, you only need a single\nperson to notice something is wrong. This is why the Bitcoin Core\ndevelopment effort consists of multiple people, mutually verifying each\nother's work, and signing code with OpenPGP keys that in turn are\nverifiable via numerous different paths. Of course, many users will\nnaturally not bother with that effort and outsoruce their trust to a\nsingle person or certificate authority, but the more advanced users with\nmore stringent security needs, such as developers at exchanges and big\nmerchants, can validate the code through the indepdent multiple\nindependent paths OpenPGP signatures provide. Bitcoinj would do well to\ngive their users that kind of security.\n\nSo in the spirit of community auditing, I'll give one last 25mBTC reward\nout; I'll sneak in another obvious security flaw into something I write\nin the future, and I want to see if you guys catch it.\n\n\nAs for the winners, I went by timestamp on the first email or other\ncontact I got, and rewarded better descriptions where it wasn't clear.\nFirst of all I'm awarding the first bonus question to Vitalik, who in\nperson at the Toronto Bitcoin Meetup noticed the issue immediately. He's\nno crypto-newbie, but at that point I had to give it to someone! Jeff\nGarzik will receive nothing for his answer, as it would be morally wrong\nto encourage further dad jokes.\n\nBrooks Boyd wins for #3, and thanks for the solid write up! Finally, #1\nhad a lot of submissions, but the earliest really clear answere was\nprivately emailed to me. Dunno if they want to be named publicly, but\nhere's the SHA256 hash of their email address for bragging rights:\n\n49bf07a9ce1421effe887509a361b62283ed269d328bd3be12334f8cce7a0acd\n\n\nFinally, it'd be really awesome to have some concrete examples of git\ncommits with these preimage and second-preimage attacks applied. So, I'm\npledging 250mBTC to anyone who creates a tool that can run on Ubuntu\nLinux that takes two git commits, and brute-forces some not trivially\nnoticed nonce within those commits - I suggest the timestamp - to make\nsome subset of their hash collide.\n\nA fast C or C++ inner loop would be ideal - being able to create\nreasonably long collisions, best yet against arbitrary bit masks, would\nbe an excellent way to show people why they need to be careful. Contact\nme if you want to take this on.\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140207/bcdc7570/attachment.sig>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-02-07T10:48:17",
                "message_text_only": "Here\u2019s a new release announcement with full ID\u2019s this time:\n\nThe v0.11 tag is signed by Andreas Schildbach\u2019s GPG key (fingerprint E944 AE66 7CF9 60B1 004B C32F CA66 2BE1 8B87 7A60). The commit hash is 410d4547a7dd20745f637313ed54d04d08d28687.\n\nKey: 16vSNFP5Acsa6RBbjEA7QYCCRDRGXRFH4m\nSignature: IFXzt4ZdWFEpLrAXRDnQS6ZKJYGmyHDHtyAgeg/2/EaTvg41jSsUQW8rq19evT2UNp+eP0+OWgWM7iDKrTv11DY=\n\nIt\u2019s worth noting that this problem crops up in other contexts too. For instance, it\u2019s very common for people to identify PGP keys by a short identifier.\n\nAs it happens I do have a PGP key, fingerprint C85A AB0F 7A1C CCA3 2BFC EECC F2E4 861C 9988 816F, and I just signed Andreas\u2019 key with it. However, as I\u2019m not myself well connected in the web of trust, that doesn\u2019t add a whole lot. But now that my key is effectively signed out of band by SwissSign so if people wanted to manually trace a trust path across systems, they could. I am skeptical anyone will :-)\n\nNote that thanks to Gary Rowe, there is a Maven dependency checker plugin that verifies the (full) hashes of library dependencies. It could be better integrated but it provides another backstop.\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: smime.p7s\nType: application/pkcs7-signature\nSize: 7453 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140207/927761b1/attachment.p7s>"
            }
        ],
        "thread_summary": {
            "title": "bitcoinj 0.11 released, with p2sh, bip39 and payment protocol support",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Natanael",
                "Mike Hearn",
                "Peter Todd",
                "Brooks Boyd",
                "Jeremy Spilman"
            ],
            "messages_count": 12,
            "total_messages_chars_count": 36983
        }
    },
    {
        "title": "[Bitcoin-development] Modular PoW",
        "thread_messages": [
            {
                "author": "Jeremy Hahn",
                "date": "2014-02-05T21:25:48",
                "message_text_only": "Relocating this conversation to the dev list. Feedback / continued \ndiscussion welcome.\n\nhttps://github.com/bitcoin/bitcoin/issues/3624"
            }
        ],
        "thread_summary": {
            "title": "Modular PoW",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeremy Hahn"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 135
        }
    },
    {
        "title": "[Bitcoin-development] Multi Input/Output Transaction Problems",
        "thread_messages": [
            {
                "author": "Crypto Fish",
                "date": "2014-02-07T17:33:12",
                "message_text_only": "So, I'm having some problems getting a multi input/multi output transaction\nworking. My code below works with 1 input and 2 output, but when adding\nmore inputs/outputs the transaction gets rejected. I'm sure whatever I'm\ndoing wrong in pretty simple, any ideas?\n\nCode works for this (1 input, 2 outputs):\n\nCTransaction(hash=01a3204517476812df2c2f77735a72a6d3e7eb8b9a5d5330ca433dd875fc4c3c,\nver=1, vin.size=2, vout.size=4, nLockTime=0)\n\nCTxIn(COutPoint(6ee4049d6c75d6450e961446d28760207bd7036e2aa692afb80bb34245d3df84,\n0), scriptSig=304502204cdfd276ff9c53bb)\n    CTxOut(nValue=4.00000000, scriptPubKey=OP_DUP OP_HASH160 b07e181ce438)\n    CTxOut(nValue=1.00000000, scriptPubKey=OP_DUP OP_HASH160 bf7484e469c8)\n\nCode doesn't work for this (2 input, 4 outputs):\n\nCTransaction(hash=01a3204517476812df2c2f77735a72a6d3e7eb8b9a5d5330ca433dd875fc4c3c,\nver=1, vin.size=2, vout.size=4, nLockTime=0)\n\nCTxIn(COutPoint(6ee4049d6c75d6450e961446d28760207bd7036e2aa692afb80bb34245d3df84,\n1), scriptSig=304502204aef3f393c273835)\n\nCTxIn(COutPoint(6ee4049d6c75d6450e961446d28760207bd7036e2aa692afb80bb34245d3df84,\n0), scriptSig=304502204cdfd276ff9c53bb)\n    CTxOut(nValue=4.00000000, scriptPubKey=OP_DUP OP_HASH160 bf7484e469c8)\n    CTxOut(nValue=491.00000000, scriptPubKey=OP_DUP OP_HASH160 0796b7f3430f)\n    CTxOut(nValue=4.00000000, scriptPubKey=OP_DUP OP_HASH160 b07e181ce438)\n    CTxOut(nValue=1.00000000, scriptPubKey=OP_DUP OP_HASH160 bf7484e469c8)\n\nPseudo code showing working transaction:\n\n    // These are how the vout's are made\n    CScript scriptPubKey;\n    scriptPubKey.SetDestination(address);\n    CScript s;\n    s << OP_DUP << OP_HASH160 << scriptPubKey.GetID() << OP_EQUALVERIFY <<\nOP_CHECKSIG;\n\n    CTxOut out(nValue, s);\n\n    ---------------\n\n\n    CTransaction txNew;\n    txNew.vin.clear();\n    txNew.vout.clear();\n\n    // vin and vout are already populated\n    for(unsigned int i = 0; i < vout.size(); i++){\n        txNew.vout.push_back(vout[i]);\n    }\n\n    //add all vins\n    for(unsigned int i = 0; i < vin.size(); i++){\n        txNew.vin.push_back(vin[i]);\n    }\n\n    //add all vins\n    for(unsigned int i = 0; i < vin.size(); i++){\n        // this is signed with 2 separate keys for each vin\n        if(!SignSignature(*keystore, prevPubKey, txNew, i,\nint(SIGHASH_ALL|SIGHASH_ANYONECANPAY)))\n            printf('signing failed!\\n');\n\n        // I was told I might need to serialize the inputs? Not sure how\nthat would work\n    }\n\n    RelayTransaction(txNew, txNew.Hash());\n\n\n---\n\nCryptoFish\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140207/99d7ccc3/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Multi Input/Output Transaction Problems",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Crypto Fish"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2675
        }
    },
    {
        "title": "[Bitcoin-development] Payment Protocol for Face-to-face Payments",
        "thread_messages": [
            {
                "author": "Andreas Schildbach",
                "date": "2014-02-07T23:15:43",
                "message_text_only": "I have refreshed the Bitcoin Wallet preview version with beta version\n3.32. It now implements BIP72 aka \"URI extension for payment protocol\".\n\nThere is one important deviation from the standard though: Bitcoin URI\naddress and amount fields need to correspond to the data from the\npayment request. The makes sure the signature really signs the URI\n(which you've gotten directly from the payee) and not a malicious\npayment request introduced by a MITM. Note the memo isn't protected like\nthat, so it can still be MITM'ed.\n\nI know this means that for the time being Bitcoin URIs must be\n\"backwards compatible\". That should not be an issue since we will be in\ntransition phase for many months anyway. Until then, I hope we will have\nagreed on a more sophisticated approach, e.g. a separate hash in the URI.\n\nSource:\nhttps://github.com/schildbach/bitcoin-wallet/commits/v3.32\n\nBinaries:\nhttps://github.com/schildbach/bitcoin-wallet/releases/tag/v3.32\n(also published to the corresponding channels on Google Play)\n\n\nOn 01/30/2014 11:46 AM, Andreas Schildbach wrote:\n> Just a small update. I merged the code to my bitcoinj-0.11 branch and\n> put up binary .apk files for experimentation. Just make sure to tick\n> \"BIP70 for tap-to-pay/scan-to-pay\" in the labs settings.\n> \n> Source:\n> https://github.com/schildbach/bitcoin-wallet/commits/bitcoinj-0.11\n> \n> Binaries:\n> https://github.com/schildbach/bitcoin-wallet/releases/tag/v3.30-bitcoinj0.11\n> \n> \n> On 01/27/2014 12:59 PM, Andreas Schildbach wrote:\n>> As promised I'd like to present my work done on leveraging the payment\n>> protocol for face-to-face payments. The general assumption is that\n>> individuals don't own X.509 certificates. Their devices may be only\n>> badly connected to the internet or in some cases not at all. I've\n>> implemented a prototype on a branch of Bitcoin Wallet. It is using\n>> bitcoinj 0.11 (not released).\n>>\n>> https://github.com/schildbach/bitcoin-wallet/commits/payment-protocol\n> \n> \n> \n> ------------------------------------------------------------------------------\n> WatchGuard Dimension instantly turns raw network data into actionable \n> security intelligence. It gives you real-time visual feedback on key\n> security issues and trends.  Skip the complicated setup - simply import\n> a virtual appliance and go from zero to informed in seconds.\n> http://pubads.g.doubleclick.net/gampad/clk?id=123612991&iu=/4140/ostg.clktrk\n>"
            }
        ],
        "thread_summary": {
            "title": "Payment Protocol for Face-to-face Payments",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Andreas Schildbach"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2410
        }
    },
    {
        "title": "[Bitcoin-development] Extension for BIP-0070 to support recurring payments",
        "thread_messages": [
            {
                "author": "Stephane Brossier",
                "date": "2014-02-08T02:57:40",
                "message_text_only": "Mike and all,\n\nPierre and I just committed a prototype implementation of the recurring payment protocol using bitcoinj. You can find the diff on our fork: \nhttps://github.com/killbill/bitcoinj/commit/40c657c4191498f12539c60316116aa68af368a7\n\nWe did not write the server (merchant side), but wanted to have some feedback before going deeper (merchant implementation and tests). We did our best to build it on top of the existing BIP-0070 protocol-- only a few additions in the messages, but no new calls and no new uri scheme. We created a new package 'recurring' where most of the new code lives.\n\nAt a high level:\n\n1. Creation of the subscription:\n\nThe initial handshake for creating the subscription is exactly similar to the one for the payment protocol (PaymentRequest is used to provide the contract)\n\n2. Wallet can decide to poll the merchants for its active subscriptions.\n\nHere the flow is exactly similar to the payment protocol but the wallet receives a callback to verify the payment matches the contract and should go through.\n\nPlease give us some feedback whenever you have the chance. In the meantime we will start implementing the merchant side and test the code.\n\nCheers!\n\n\n\nOn Jan 31, 2014, at 10:13 AM, Mike Hearn <mike at plan99.net> wrote:\n\n> That looks OK at a very high level. Things you probably want to think about:\n> How to trigger it off the existing payment protocol (no new top level messages or mime types or uri extensions please)\n> Data structures to define the payment schedule\n> Do you allow pre-submission of time locked transactions or not?\n> I think as you prototype these things will become clearer.  You could try prototyping either in Bitcoin Core (C++) or bitcoinj (java, look at the PaymentSession class).\n> \n> \n> \n> On Wed, Jan 29, 2014 at 3:47 AM, Stephane Brossier <stephane at kill-bill.org> wrote:\n> From what I have seen so far, there seems to be an agreement that this is a nice feature to add.  We are pretty new to that community and so we don't know exactly what the process is, and in particular how we reach consensus via email. I am certainly open to follow 'the way' if there is one, but one solution would be to follow Mike's suggestion on providing a (prototype) implementation first and then defining/refining the BIP. Odinn also suggested a possible retribution for our time through crowd-sourcing which I am interested to pursue if that makes sense.\n> \n> \n> We have quite some experience on the subscription side of things and while we are growing our knowledge on the Bitcoin technology (and ecosystem at large) we would benefit from:\n> * some feedbacks on the high level proposal\n> * additional requirements we might have missed\n> \n> So, below is a high level description of what we have in mind. If this sounds reasonable, we could start working on an implementation.\n> \n> \n>  \n> I. Abstract\n> ---------------\n> \n> This describes a protocol to enable recurring payments in bitcoins and can be seen as an extension of BIP-0070. The main goal here is to have the customer subscribe to a service of some kind (that is, agreeing on the terms of that subscription contract), and then have the wallet make recurring payments without any intervention from the customer as long as the payments match what the customer agreed on paying.\n> \n> An example of such service would be an online streaming website, to which a user pays a fixed recurring monthly fee to access videos (a.k.a. resources). Note that there is also usage based billing: for example, the user may need to purchase additional access for premium videos (overage charges). This type of billing is more complicated and there are many variations to it used in the industry (pre-paid, \u2026). For the sake of discussion, we\u2019ll focus on fixed recurring payments only, but we will keep usage in mind to make sure the protocol will be able to support it as well.\n> \n> \n> II. Motivation\n> ------------------\n> \n> Subscription based services have been growing in the past few years and so the intent it to make it possible for customers to pay in bitcoins. \n> \n> Bitcoin\u2019s push model presents new advantages for the customer compared to traditional payment methods: the user has control over the subscription (for example, there is no need to call the merchant to explicitly cancel the credit card payments). It also opens the door to subscription management tools in wallets (e.g. Hive apps), which would give user an overview of what they are paying each month.\n> \n> \n> III. Flow of Operations\n> ----------------------------------------\n> \n> \n> Creation of the subscription:\n> - - - - - - - - - - - - - - - - - - - - - - \n> \n> 1. The customer clicks 'subscribe' -> A message is sent to the merchant.\n> 2. The merchant sends back a message to the wallet with the details of the subscription such as the amount to be paid. In reality, there will be more information but for the purpose of the prototype implementation this is sufficient.\n> 3. The wallet prompts the customer for authorization.\n> 4. The customer authorizes (or denies) it.\n> 5. The wallet sends the confirmation to the merchant.\n> 6. The merchant confirms the subscription was created.\n> \n> Ongoing payments:\n> - - - - - - - - - - - - - - - -\n> \n> From that time on and since Bitcoin is a 'push' model, the wallet is responsible to poll the merchant for due payments associated with that subscription. Note that the merchant could specify hints to the wallet on when to poll (specific dates) or not during the registration of the subscription.\n> \n> Note that we can't simply have the wallet push X bitcoins every month: the user account on the merchant side may have gotten credits, invoice adjustments, etc. since the last invoice, so the amount to pay for a given billing period may be lower than the regular amount. It could even be zero if the user decides to make a one-time payment to the merchant directly using a different wallet. Hence, the wallet needs to get the latest invoice balance to make sure how much it should pay. This also opens the door for the support of overage charges.\n> \n> \n> Quick note on the implementation on the merchant side: an entitlement system is a piece of logic on the merchant side which grants the user access to certain resources depending on the account status (unpaid invoices, etc.). This goes often hand in hand with a dunning system, which progressively restricts access as the user's account is more and more overdue. Since wallets can be offline for an extended period of time, payments may be missed and lead to an overdue state (e.g. extra fees, service degraded). It is the responsibility of the customer to ensure the wallet is up often enough for payments to happen.\n> \n> \n> In that recurring phase where the wallet polls the merchant, the wallet is responsible to check that payments match the subscription contract; that is, the amount, frequency of payments, \u2026 match what the customer agreed on. If so, the payment is made without asking for explicit approval from customer, and the flow is similar to BIP-0070: The message is sent to the merchant, and in parallel, a transaction is sent to the btcnet. The merchant sends an ACK to the wallet and of course checks the states of the transactions on the btcnet to mark that payment as successful.\n> \n> Subscription change (optional):\n> - - - - - - - - - - - - - - - - - - - - - - - - \n> \n> Optionally we could implement a change in the ongoing subscription to address the upgrade/downgrade scenarios. Of course, we could also simply support a cancellation followed by a creation of a new subscription, but having that as a one atomic message is probably better. The steps are very similar to the initial registration.\n> \n> 1. The customer clicks 'upgrade', 'downgrade', \u2026 -> A msg is sent to the merchant.\n> 2. The merchant sends back a msg to the wallet with the detail of the NEW subscription. \n> 3. The wallet prompts the customer for authorization.\n> 4. The customer authorizes (or denies) it.\n> 5. The wallet sends the confirmation to the merchant.\n> 6. The merchant confirms the change in the subscription.\n> \n> Cancellation of the subscription:\n> - - - - - - - - - - - - - - - - - - - - - - - - - \n> \n> The cancellation is initiated from the customer:\n> \n> 1. The customer clicks 'cancel' -> The wallet is informed that it  should not accept any new payment associated to that subscription.\n> 2. The wallet sends a message to the merchant to inform about the cancellation.\n> 3. The merchant confirms the subscription was cancelled.\n> \n> \n> \n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140207/6ca3ee7f/attachment.html>"
            },
            {
                "author": "Stephane Brossier",
                "date": "2014-02-09T02:48:06",
                "message_text_only": "Mike, Gavin,\n\n\nWe started to work on the merchant side to test the integration of our prototype for the recurring payments. We modified the 'Payment Request Generator' from Gavin to include a new check box 'set recurring'. We forked the code and checked in our modification here: https://github.com/killbill/paymentrequest/commit/e530f6ec528266aacfd076d7c3154ad39267c3f3\n\nWe also found a few issues with the code diff that we sent yesterday for bitcoinj and checked in the bug fixes  in our fork-- so the diff sent yesterday is slightly outdated.\n\nSo at this point we have a working prototype for bitcoinj and we are waiting for your feedbacks. We also started to look at integrating the protocol in Kill Bill to check that what is proposed supports indeed the business cases of a full recurring billing platform.\n\nHope to hear from you guys soon!\n\n\nOn Feb 7, 2014, at 6:57 PM, Stephane Brossier <stephane at kill-bill.org> wrote:\n\n> Mike and all,\n> \n> Pierre and I just committed a prototype implementation of the recurring payment protocol using bitcoinj. You can find the diff on our fork: \n> https://github.com/killbill/bitcoinj/commit/40c657c4191498f12539c60316116aa68af368a7\n> \n> We did not write the server (merchant side), but wanted to have some feedback before going deeper (merchant implementation and tests). We did our best to build it on top of the existing BIP-0070 protocol-- only a few additions in the messages, but no new calls and no new uri scheme. We created a new package 'recurring' where most of the new code lives.\n> \n> At a high level:\n> \n> 1. Creation of the subscription:\n> \n> The initial handshake for creating the subscription is exactly similar to the one for the payment protocol (PaymentRequest is used to provide the contract)\n> \n> 2. Wallet can decide to poll the merchants for its active subscriptions.\n> \n> Here the flow is exactly similar to the payment protocol but the wallet receives a callback to verify the payment matches the contract and should go through.\n> \n> Please give us some feedback whenever you have the chance. In the meantime we will start implementing the merchant side and test the code.\n> \n> Cheers!\n> \n> \n> \n> On Jan 31, 2014, at 10:13 AM, Mike Hearn <mike at plan99.net> wrote:\n> \n>> That looks OK at a very high level. Things you probably want to think about:\n>> How to trigger it off the existing payment protocol (no new top level messages or mime types or uri extensions please)\n>> Data structures to define the payment schedule\n>> Do you allow pre-submission of time locked transactions or not?\n>> I think as you prototype these things will become clearer.  You could try prototyping either in Bitcoin Core (C++) or bitcoinj (java, look at the PaymentSession class).\n>> \n>> \n>> \n>> On Wed, Jan 29, 2014 at 3:47 AM, Stephane Brossier <stephane at kill-bill.org> wrote:\n>> From what I have seen so far, there seems to be an agreement that this is a nice feature to add.  We are pretty new to that community and so we don't know exactly what the process is, and in particular how we reach consensus via email. I am certainly open to follow 'the way' if there is one, but one solution would be to follow Mike's suggestion on providing a (prototype) implementation first and then defining/refining the BIP. Odinn also suggested a possible retribution for our time through crowd-sourcing which I am interested to pursue if that makes sense.\n>> \n>> \n>> We have quite some experience on the subscription side of things and while we are growing our knowledge on the Bitcoin technology (and ecosystem at large) we would benefit from:\n>> * some feedbacks on the high level proposal\n>> * additional requirements we might have missed\n>> \n>> So, below is a high level description of what we have in mind. If this sounds reasonable, we could start working on an implementation.\n>> \n>> \n>>  \n>> I. Abstract\n>> ---------------\n>> \n>> This describes a protocol to enable recurring payments in bitcoins and can be seen as an extension of BIP-0070. The main goal here is to have the customer subscribe to a service of some kind (that is, agreeing on the terms of that subscription contract), and then have the wallet make recurring payments without any intervention from the customer as long as the payments match what the customer agreed on paying.\n>> \n>> An example of such service would be an online streaming website, to which a user pays a fixed recurring monthly fee to access videos (a.k.a. resources). Note that there is also usage based billing: for example, the user may need to purchase additional access for premium videos (overage charges). This type of billing is more complicated and there are many variations to it used in the industry (pre-paid, \u2026). For the sake of discussion, we\u2019ll focus on fixed recurring payments only, but we will keep usage in mind to make sure the protocol will be able to support it as well.\n>> \n>> \n>> II. Motivation\n>> ------------------\n>> \n>> Subscription based services have been growing in the past few years and so the intent it to make it possible for customers to pay in bitcoins. \n>> \n>> Bitcoin\u2019s push model presents new advantages for the customer compared to traditional payment methods: the user has control over the subscription (for example, there is no need to call the merchant to explicitly cancel the credit card payments). It also opens the door to subscription management tools in wallets (e.g. Hive apps), which would give user an overview of what they are paying each month.\n>> \n>> \n>> III. Flow of Operations\n>> ----------------------------------------\n>> \n>> \n>> Creation of the subscription:\n>> - - - - - - - - - - - - - - - - - - - - - - \n>> \n>> 1. The customer clicks 'subscribe' -> A message is sent to the merchant.\n>> 2. The merchant sends back a message to the wallet with the details of the subscription such as the amount to be paid. In reality, there will be more information but for the purpose of the prototype implementation this is sufficient.\n>> 3. The wallet prompts the customer for authorization.\n>> 4. The customer authorizes (or denies) it.\n>> 5. The wallet sends the confirmation to the merchant.\n>> 6. The merchant confirms the subscription was created.\n>> \n>> Ongoing payments:\n>> - - - - - - - - - - - - - - - -\n>> \n>> From that time on and since Bitcoin is a 'push' model, the wallet is responsible to poll the merchant for due payments associated with that subscription. Note that the merchant could specify hints to the wallet on when to poll (specific dates) or not during the registration of the subscription.\n>> \n>> Note that we can't simply have the wallet push X bitcoins every month: the user account on the merchant side may have gotten credits, invoice adjustments, etc. since the last invoice, so the amount to pay for a given billing period may be lower than the regular amount. It could even be zero if the user decides to make a one-time payment to the merchant directly using a different wallet. Hence, the wallet needs to get the latest invoice balance to make sure how much it should pay. This also opens the door for the support of overage charges.\n>> \n>> \n>> Quick note on the implementation on the merchant side: an entitlement system is a piece of logic on the merchant side which grants the user access to certain resources depending on the account status (unpaid invoices, etc.). This goes often hand in hand with a dunning system, which progressively restricts access as the user's account is more and more overdue. Since wallets can be offline for an extended period of time, payments may be missed and lead to an overdue state (e.g. extra fees, service degraded). It is the responsibility of the customer to ensure the wallet is up often enough for payments to happen.\n>> \n>> \n>> In that recurring phase where the wallet polls the merchant, the wallet is responsible to check that payments match the subscription contract; that is, the amount, frequency of payments, \u2026 match what the customer agreed on. If so, the payment is made without asking for explicit approval from customer, and the flow is similar to BIP-0070: The message is sent to the merchant, and in parallel, a transaction is sent to the btcnet. The merchant sends an ACK to the wallet and of course checks the states of the transactions on the btcnet to mark that payment as successful.\n>> \n>> Subscription change (optional):\n>> - - - - - - - - - - - - - - - - - - - - - - - - \n>> \n>> Optionally we could implement a change in the ongoing subscription to address the upgrade/downgrade scenarios. Of course, we could also simply support a cancellation followed by a creation of a new subscription, but having that as a one atomic message is probably better. The steps are very similar to the initial registration.\n>> \n>> 1. The customer clicks 'upgrade', 'downgrade', \u2026 -> A msg is sent to the merchant.\n>> 2. The merchant sends back a msg to the wallet with the detail of the NEW subscription. \n>> 3. The wallet prompts the customer for authorization.\n>> 4. The customer authorizes (or denies) it.\n>> 5. The wallet sends the confirmation to the merchant.\n>> 6. The merchant confirms the change in the subscription.\n>> \n>> Cancellation of the subscription:\n>> - - - - - - - - - - - - - - - - - - - - - - - - - \n>> \n>> The cancellation is initiated from the customer:\n>> \n>> 1. The customer clicks 'cancel' -> The wallet is informed that it  should not accept any new payment associated to that subscription.\n>> 2. The wallet sends a message to the merchant to inform about the cancellation.\n>> 3. The merchant confirms the subscription was cancelled.\n>> \n>> \n>> \n> \n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140208/c439679a/attachment.html>"
            },
            {
                "author": "Kevin Greene",
                "date": "2014-02-11T10:00:53",
                "message_text_only": "Figured I would have a crack at reviewing this since Mike is out for a bit.\nIt was great running into you guys at the bitcoin fair in SF! Small world :)\n\nI like how simple this is. You just give it an url to fetch the next\npayment request and a date to fetch it.\n\nWhat should happen if the client tries to fetch the PaymentRequest early or\nlate? Does it become valid after some date and stay valid for some length\nof time? Also, what should happen if the client tries to consume the same\nPaymentRequest twice (or multiple times) during the same period?\n\nI do not think daily/weekly/monthly is flexible enough. What do you think\nabout having a concrete start time and end time when the next\nPaymentRequest will be valid? This also prevents the wallet from having to\nremember when it last sent a payment and getting skewed over time.\n\nWhen a wallet hits the polling_url to download the next PaymentRequest, it\nseems we need a way to communicate an error code to the wallet, for example\nif the server canceled the contract without the wallet knowing. Perhaps a\nseparate polling_status_url, with a corresponding ACK message to indicate\nif the PaymentRequest is available. What do you think of that idea?\n\nOne high-level comment -- the wallet in this design doesn't have any way of\nknowing when the payments are supposed to end. I feel this is important to\nshow to the user before they start their wallet polling infinitely.\n\n\n\n\nOn Sat, Feb 8, 2014 at 6:48 PM, Stephane Brossier <stephane at kill-bill.org>wrote:\n\n> Mike, Gavin,\n>\n>\n> We started to work on the merchant side to test the integration of our\n> prototype for the recurring payments. We modified the 'Payment Request\n> Generator' from Gavin to include a new check box 'set recurring'. We forked\n> the code and checked in our modification here:\n> https://github.com/killbill/paymentrequest/commit/e530f6ec528266aacfd076d7c3154ad39267c3f3\n>\n> We also found a few issues with the code diff that we sent yesterday for\n> bitcoinj and checked in the bug fixes  in our fork-- so the diff sent\n> yesterday is slightly outdated.\n>\n> So at this point we have a working prototype for bitcoinj and we are\n> waiting for your feedbacks. We also started to look at integrating the\n> protocol in Kill Bill to check that what is proposed supports indeed the\n> business cases of a full recurring billing platform.\n>\n> Hope to hear from you guys soon!\n>\n>\n> On Feb 7, 2014, at 6:57 PM, Stephane Brossier <stephane at kill-bill.org>\n> wrote:\n>\n> Mike and all,\n>\n> Pierre and I just committed a prototype implementation of the recurring\n> payment protocol using bitcoinj. You can find the diff on our fork:\n>\n> https://github.com/killbill/bitcoinj/commit/40c657c4191498f12539c60316116aa68af368a7\n>\n> We did not write the server (merchant side), but wanted to have some\n> feedback before going deeper (merchant implementation and tests). We did\n> our best to build it on top of the existing BIP-0070 protocol-- only a few\n> additions in the messages, but no new calls and no new uri scheme. We\n> created a new package 'recurring' where most of the new code lives.\n>\n> At a high level:\n>\n> 1. Creation of the subscription:\n>\n> The initial handshake for creating the subscription is exactly similar to\n> the one for the payment protocol (PaymentRequest is used to provide the\n> contract)\n>\n> 2. Wallet can decide to poll the merchants for its active subscriptions.\n>\n> Here the flow is exactly similar to the payment protocol but the wallet\n> receives a callback to verify the payment matches the contract and should\n> go through.\n>\n> Please give us some feedback whenever you have the chance. In the meantime\n> we will start implementing the merchant side and test the code.\n>\n> Cheers!\n>\n>\n>\n> On Jan 31, 2014, at 10:13 AM, Mike Hearn <mike at plan99.net> wrote:\n>\n> That looks OK at a very high level. Things you probably want to think\n> about:\n>\n>    - How to trigger it off the existing payment protocol (no new top\n>    level messages or mime types or uri extensions please)\n>    - Data structures to define the payment schedule\n>    - Do you allow pre-submission of time locked transactions or not?\n>\n> I think as you prototype these things will become clearer.  You could try\n> prototyping either in Bitcoin Core (C++) or bitcoinj (java, look at the\n> PaymentSession class).\n>\n>\n>\n> On Wed, Jan 29, 2014 at 3:47 AM, Stephane Brossier <stephane at kill-bill.org\n> > wrote:\n>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>> *From what I have seen so far, there seems to be an agreement that this\n>> is a nice feature to add. We are pretty new to that community and so we\n>> don't know exactly what the process is, and in particular how we reach\n>> consensus via email. I am certainly open to follow 'the way' if there is\n>> one, but one solution would be to follow Mike's suggestion on providing a\n>> (prototype) implementation first and then defining/refining the BIP. Odinn\n>> also suggested a possible retribution for our time through crowd-sourcing\n>> which I am interested to pursue if that makes sense. We have quite some\n>> experience on the subscription side of things and while we are growing our\n>> knowledge on the Bitcoin technology (and ecosystem at large) we would\n>> benefit from: * some feedbacks on the high level proposal * additional\n>> requirements we might have missed So, below is a high level description of\n>> what we have in mind. If this sounds reasonable, we could start working on\n>> an implementation. I. Abstract --------------- This describes a protocol to\n>> enable recurring payments in bitcoins and can be seen as an extension of\n>> BIP-0070. The main goal here is to have the customer subscribe to a service\n>> of some kind (that is, agreeing on the terms of that subscription\n>> contract), and then have the wallet make recurring payments without any\n>> intervention from the customer as long as the payments match what the\n>> customer agreed on paying. An example of such service would be an online\n>> streaming website, to which a user pays a fixed recurring monthly fee to\n>> access videos (a.k.a. resources). Note that there is also usage based\n>> billing: for example, the user may need to purchase additional access for\n>> premium videos (overage charges). This type of billing is more complicated\n>> and there are many variations to it used in the industry (pre-paid, ...). For\n>> the sake of discussion, we'll focus on fixed recurring payments only, but\n>> we will keep usage in mind to make sure the protocol will be able to\n>> support it as well. II. Motivation ------------------ Subscription based\n>> services have been growing in the past few years and so the intent it to\n>> make it possible for customers to pay in bitcoins. Bitcoin's push model\n>> presents new advantages for the customer compared to traditional payment\n>> methods: the user has control over the subscription (for example, there is\n>> no need to call the merchant to explicitly cancel the credit card\n>> payments). It also opens the door to subscription management tools in\n>> wallets (e.g. Hive apps), which would give user an overview of what they\n>> are paying each month. III. Flow of\n>> Operations----------------------------------------*\n>>\n>>\n>>\n>>\n>> * Creation of the subscription: - - - - - - - - - - - - - - - - - - - - -\n>> - 1. The customer clicks 'subscribe' -> A message is sent to the merchant.\n>> 2. The merchant sends back a message to the wallet with the details of the\n>> subscription such as the amount to be paid. In reality, there will be more\n>> information but for the purpose of the prototype implementation this is\n>> sufficient. 3. The wallet prompts the customer for authorization. 4. The\n>> customer authorizes (or denies) it. 5. The wallet sends the confirmation to\n>> the merchant. 6. The merchant confirms the subscription was created.\n>> Ongoing payments: *\n>>\n>> *- - - - - - - - - - - - - - - - *\n>>\n>>\n>>\n>>\n>>\n>>\n>> * From that time on and since Bitcoin is a 'push' model, the wallet is\n>> responsible to poll the merchant for due payments associated with that\n>> subscription. Note that the merchant could specify hints to the wallet on\n>> when to poll (specific dates) or not during the registration of the\n>> subscription. Note that we can't simply have the wallet push X bitcoins\n>> every month: the user account on the merchant side may have gotten credits,\n>> invoice adjustments, etc. since the last invoice, so the amount to pay for\n>> a given billing period may be lower than the regular amount. It could even\n>> be zero if the user decides to make a one-time payment to the merchant\n>> directly using a different wallet. Hence, the wallet needs to get the\n>> latest invoice balance to make sure how much it should pay. This also opens\n>> the door for the support of overage charges. Quick note on the\n>> implementation on the merchant side: an entitlement system is a piece of\n>> logic on the merchant side which grants the user access to certain\n>> resources depending on the account status (unpaid invoices, etc.). This\n>> goes often hand in hand with a dunning system, which progressively\n>> restricts access as the user's account is more and more overdue. Since\n>> wallets can be offline for an extended period of time, payments may be\n>> missed and lead to an overdue state (e.g. extra fees, service degraded). It\n>> is the responsibility of the customer to ensure the wallet is up often\n>> enough for payments to happen. In that recurring phase where the wallet\n>> polls the merchant, the wallet is responsible to check that payments match\n>> the subscription contract; that is, the amount, frequency of payments, ...\n>> match what the customer agreed on. If so, the payment is made without\n>> asking for explicit approval from customer, and the flow is similar to\n>> BIP-0070: The message is sent to the merchant, and in parallel, a\n>> transaction is sent to the btcnet. The merchant sends an ACK to the wallet\n>> and of course checks the states of the transactions on the btcnet to mark\n>> that payment as successful. Subscription change (optional): *\n>>\n>> *- - - - - - - - - - - - - - - - - - - - - - - - *\n>>\n>>\n>> * Optionally we could implement a change in the ongoing subscription to\n>> address the upgrade/downgrade scenarios. Of course, we could also simply\n>> support a cancellation followed by a creation of a new subscription, but\n>> having that as a one atomic message is probably better. The steps are very\n>> similar to the initial registration. 1. The customer clicks 'upgrade',\n>> 'downgrade', ... -> A msg is sent to the merchant. 2. The merchant sends back\n>> a msg to the wallet with the detail of the NEW subscription. 3. The wallet\n>> prompts the customer for authorization. 4. The customer authorizes (or\n>> denies) it. 5. The wallet sends the confirmation to the merchant. 6. The\n>> merchant confirms the change in the subscription. Cancellation of the\n>> subscription: *\n>>\n>> *- - - - - - - - - - - - - - - - - - - - - - - - - *\n>>\n>>\n>>\n>> * The cancellation is initiated from the customer: 1. The customer clicks\n>> 'cancel' -> The wallet is informed that it  should not accept any new\n>> payment associated to that subscription. 2. The wallet sends a message to\n>> the merchant to inform about the cancellation. 3. The merchant confirms the\n>> subscription was cancelled. *\n>>\n>\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140211/6c0620d6/attachment.html>"
            },
            {
                "author": "Stephane Brossier",
                "date": "2014-02-11T18:01:23",
                "message_text_only": "Hi Kevin,\n\nOn Feb 11, 2014, at 2:00 AM, Kevin Greene <kgreenek at gmail.com> wrote:\n\n> Figured I would have a crack at reviewing this since Mike is out for a bit. It was great running into you guys at the bitcoin fair in SF! Small world :)\n\nIndeed! It was great meeting you! It's always nice to meet people in person...\n\n> I like how simple this is. You just give it an url to fetch the next payment request and a date to fetch it.\n> \n> What should happen if the client tries to fetch the PaymentRequest early or late?\n\nIf the client tries to fetch too early, then  the merchant will return a PaymentRequest with no output (there is nothing to pay yet). If it fetches too late, this is merchant specific. It could be that the service got discontinued -- extreme case -- or that there are now multiple PaymentRequest pending or that the merchant decided to aggregate those into one. In that scenario, it could lead to a case where the amount to pay goes beyond the contract and the wallet would refuse to make the recurring payment.\n\n> Does it become valid after some date and stay valid for some length of time?\n\nThe protocol we sketched does not include (yet) an expiration date. At this point the contract is fairly minimal, and we could envision adding more parameters such as expiration date. So at this point the behavior would be dictated by the merchant.\n\n> Also, what should happen if the client tries to consume the same PaymentRequest twice (or multiple times) during the same period?\n\nThe merchant initiates the PaymentRequest and is in charge to make sure they match the invoices that the client should pay. On the client side, the wallet is responsible to verify that the contract is respected, so if a merchant were to issue multiple times the same PaymentRequest, the wallet would detect it goes beyond the bonds defined in the contract and would refuse to make the additional Payments.\n\n> I do not think daily/weekly/monthly is flexible enough. What do you think about having a concrete start time and end time when the next PaymentRequest will be valid?\n\nI agree that daily/weekly/monthly may not be flexible enough. However specifying a fixed date may be very tricky because in some cases a monthly subscription may start on a 31st of a month, and depending on the month, the due date will vary -- could be 30th, 28th, 29th, ... Also note that the frequency (daily/weekly/monthly) is not used as a polling interval, but is only used to verify the contract is respected. \n\nThere are multiple viable options to specify that contract and ideally we could/should support multiple schemes; different merchants could use different schemes, and the client would decide wether or not he is ready to accept the terms that will later be enforced by the wallet. But of course all this flexibility goes against simplicity and so this is tradeoff...\n\n\n> This also prevents the wallet from having to remember when it last sent a payment and getting skewed over time.\n\nToday, our current prototype is polling every day -- which is the lowest granularity we introduced -- and so there is no risk of getting skewed.\n\n\n> When a wallet hits the polling_url to download the next PaymentRequest, it seems we need a way to communicate an error code to the wallet, for example if the server canceled the contract without the wallet knowing. Perhaps a separate polling_status_url, with a corresponding ACK message to indicate if the PaymentRequest is available. What do you think of that idea?\n\nI think reporting such errors to the wallet would make complete sense. However i am not clear why we would a separate url for that?\n\n> One high-level comment -- the wallet in this design doesn't have any way of knowing when the payments are supposed to end. I feel this is important to show to the user before they start their wallet polling infinitely.\n\nSubscriptions are non ending by definition, but at any time the client (through the wallet) or the merchant can decide to terminate the subscriptions -- we did not yet implement cancellation in that prototype but we are planning to add it later this week. Think of your Netflix subscriptions, this is never ending (evergreen) until you decide to terminate it or Netflix does it (abuse, bills not paid,...)\n\nThanks for taking a look!\n\n> \n> On Sat, Feb 8, 2014 at 6:48 PM, Stephane Brossier <stephane at kill-bill.org> wrote:\n> Mike, Gavin,\n> \n> \n> We started to work on the merchant side to test the integration of our prototype for the recurring payments. We modified the 'Payment Request Generator' from Gavin to include a new check box 'set recurring'. We forked the code and checked in our modification here: https://github.com/killbill/paymentrequest/commit/e530f6ec528266aacfd076d7c3154ad39267c3f3\n> \n> We also found a few issues with the code diff that we sent yesterday for bitcoinj and checked in the bug fixes  in our fork-- so the diff sent yesterday is slightly outdated.\n> \n> So at this point we have a working prototype for bitcoinj and we are waiting for your feedbacks. We also started to look at integrating the protocol in Kill Bill to check that what is proposed supports indeed the business cases of a full recurring billing platform.\n> \n> Hope to hear from you guys soon!\n> \n> \n> On Feb 7, 2014, at 6:57 PM, Stephane Brossier <stephane at kill-bill.org> wrote:\n> \n>> Mike and all,\n>> \n>> Pierre and I just committed a prototype implementation of the recurring payment protocol using bitcoinj. You can find the diff on our fork: \n>> https://github.com/killbill/bitcoinj/commit/40c657c4191498f12539c60316116aa68af368a7\n>> \n>> We did not write the server (merchant side), but wanted to have some feedback before going deeper (merchant implementation and tests). We did our best to build it on top of the existing BIP-0070 protocol-- only a few additions in the messages, but no new calls and no new uri scheme. We created a new package 'recurring' where most of the new code lives.\n>> \n>> At a high level:\n>> \n>> 1. Creation of the subscription:\n>> \n>> The initial handshake for creating the subscription is exactly similar to the one for the payment protocol (PaymentRequest is used to provide the contract)\n>> \n>> 2. Wallet can decide to poll the merchants for its active subscriptions.\n>> \n>> Here the flow is exactly similar to the payment protocol but the wallet receives a callback to verify the payment matches the contract and should go through.\n>> \n>> Please give us some feedback whenever you have the chance. In the meantime we will start implementing the merchant side and test the code.\n>> \n>> Cheers!\n>> \n>> \n>> \n>> On Jan 31, 2014, at 10:13 AM, Mike Hearn <mike at plan99.net> wrote:\n>> \n>>> That looks OK at a very high level. Things you probably want to think about:\n>>> How to trigger it off the existing payment protocol (no new top level messages or mime types or uri extensions please)\n>>> Data structures to define the payment schedule\n>>> Do you allow pre-submission of time locked transactions or not?\n>>> I think as you prototype these things will become clearer.  You could try prototyping either in Bitcoin Core (C++) or bitcoinj (java, look at the PaymentSession class).\n>>> \n>>> \n>>> \n>>> On Wed, Jan 29, 2014 at 3:47 AM, Stephane Brossier <stephane at kill-bill.org> wrote:\n>>> From what I have seen so far, there seems to be an agreement that this is a nice feature to add.   We are pretty new to that community and so we don't know exactly what the process is, and in particular how we reach consensus via email. I am certainly open to follow 'the way' if there is one, but one solution would be to follow Mike's suggestion on providing a (prototype) implementation first and then defining/refining the BIP. Odinn also suggested a possible retribution for our time through crowd-sourcing which I am interested to pursue if that makes sense.\n>>> \n>>> \n>>> We have quite some experience on the subscription side of things and while we are growing our knowledge on the Bitcoin technology (and ecosystem at large) we would benefit from:\n>>> * some feedbacks on the high level proposal\n>>> * additional requirements we might have missed\n>>> \n>>> So, below is a high level description of what we have in mind. If this sounds reasonable, we could start working on an implementation.\n>>> \n>>> \n>>>  \n>>> I. Abstract\n>>> ---------------\n>>> \n>>> This describes a protocol to enable recurring payments in bitcoins and can be seen as an extension of BIP-0070. The main goal here is to have the customer subscribe to a service of some kind (that is, agreeing on the terms of that subscription contract), and then have the wallet make recurring payments without any intervention from the customer as long as the payments match what the customer agreed on paying.\n>>> \n>>> An example of such service would be an online streaming website, to which a user pays a fixed recurring monthly fee to access videos (a.k.a. resources). Note that there is also usage based billing: for example, the user may need to purchase additional access for premium videos (overage charges). This type of billing is more complicated and there are many variations to it used in the industry (pre-paid, \u2026). For the sake of discussion, we\u2019ll focus on fixed recurring payments only, but we will keep usage in mind to make sure the protocol will be able to support it as well.\n>>> \n>>> \n>>> II. Motivation\n>>> ------------------\n>>> \n>>> Subscription based services have been growing in the past few years and so the intent it to make it possible for customers to pay in bitcoins. \n>>> \n>>> Bitcoin\u2019s push model presents new advantages for the customer compared to traditional payment methods: the user has control over the subscription (for example, there is no need to call the merchant to explicitly cancel the credit card payments). It also opens the door to subscription management tools in wallets (e.g. Hive apps), which would give user an overview of what they are paying each month.\n>>> \n>>> \n>>> III. Flow of Operations\n>>> ----------------------------------------\n>>> \n>>> \n>>> Creation of the subscription:\n>>> - - - - - - - - - - - - - - - - - - - - - - \n>>> \n>>> 1. The customer clicks 'subscribe' -> A message is sent to the merchant.\n>>> 2. The merchant sends back a message to the wallet with the details of the subscription such as the amount to be paid. In reality, there will be more information but for the purpose of the prototype implementation this is sufficient.\n>>> 3. The wallet prompts the customer for authorization.\n>>> 4. The customer authorizes (or denies) it.\n>>> 5. The wallet sends the confirmation to the merchant.\n>>> 6. The merchant confirms the subscription was created.\n>>> \n>>> Ongoing payments:\n>>> - - - - - - - - - - - - - - - -\n>>> \n>>> From that time on and since Bitcoin is a 'push' model, the wallet is responsible to poll the merchant for due payments associated with that subscription. Note that the merchant could specify hints to the wallet on when to poll (specific dates) or not during the registration of the subscription.\n>>> \n>>> Note that we can't simply have the wallet push X bitcoins every month: the user account on the merchant side may have gotten credits, invoice adjustments, etc. since the last invoice, so the amount to pay for a given billing period may be lower than the regular amount. It could even be zero if the user decides to make a one-time payment to the merchant directly using a different wallet. Hence, the wallet needs to get the latest invoice balance to make sure how much it should pay. This also opens the door for the support of overage charges.\n>>> \n>>> \n>>> Quick note on the implementation on the merchant side: an entitlement system is a piece of logic on the merchant side which grants the user access to certain resources depending on the account status (unpaid invoices, etc.). This goes often hand in hand with a dunning system, which progressively restricts access as the user's account is more and more overdue. Since wallets can be offline for an extended period of time, payments may be missed and lead to an overdue state (e.g. extra fees, service degraded). It is the responsibility of the customer to ensure the wallet is up often enough for payments to happen.\n>>> \n>>> \n>>> In that recurring phase where the wallet polls the merchant, the wallet is responsible to check that payments match the subscription contract; that is, the amount, frequency of payments, \u2026 match what the customer agreed on. If so, the payment is made without asking for explicit approval from customer, and the flow is similar to BIP-0070: The message is sent to the merchant, and in parallel, a transaction is sent to the btcnet. The merchant sends an ACK to the wallet and of course checks the states of the transactions on the btcnet to mark that payment as successful.\n>>> \n>>> Subscription change (optional):\n>>> - - - - - - - - - - - - - - - - - - - - - - - - \n>>> \n>>> Optionally we could implement a change in the ongoing subscription to address the upgrade/downgrade scenarios. Of course, we could also simply support a cancellation followed by a creation of a new subscription, but having that as a one atomic message is probably better. The steps are very similar to the initial registration.\n>>> \n>>> 1. The customer clicks 'upgrade', 'downgrade', \u2026 -> A msg is sent to the merchant.\n>>> 2. The merchant sends back a msg to the wallet with the detail of the NEW subscription. \n>>> 3. The wallet prompts the customer for authorization.\n>>> 4. The customer authorizes (or denies) it.\n>>> 5. The wallet sends the confirmation to the merchant.\n>>> 6. The merchant confirms the change in the subscription.\n>>> \n>>> Cancellation of the subscription:\n>>> - - - - - - - - - - - - - - - - - - - - - - - - - \n>>> \n>>> The cancellation is initiated from the customer:\n>>> \n>>> 1. The customer clicks 'cancel' -> The wallet is informed that it  should not accept any new payment associated to that subscription.\n>>> 2. The wallet sends a message to the merchant to inform about the cancellation.\n>>> 3. The merchant confirms the subscription was cancelled.\n>>> \n>>> \n>>> \n>> \n> \n> \n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140211/f7dc5236/attachment.html>"
            },
            {
                "author": "Kevin Greene",
                "date": "2014-02-12T06:32:18",
                "message_text_only": "Thanks for humoring my questions!\n\n>I think reporting such errors to the wallet would make complete sense.\nHowever i am not clear why we would a separate url for that?\n\nHmm, thinking about this more, adding a simple status_code in\nPaymentRequest would be a much easier way to achieve this. However,\ncontinuing to think about this even more, maybe the simple memo field along\nwith an empty set of outputs is enough already.\n\nIn bitcoinj, right now the code will throw a\nPaymentRequestException.InvalidOutputs exception if the set of outputs is\nempty with a message of \"No Outputs\". There isn't a good way to tell the\ndifference between a payment request that had no outputs and a payment\nrequest that had some invalid output(s).\n\n*Question to everyone:*\nHow does bitcoin-qt handle a PaymentRequest with no outputs?\n\n\n\nOn Tue, Feb 11, 2014 at 10:01 AM, Stephane Brossier\n<stephane at kill-bill.org>wrote:\n\n> Hi Kevin,\n>\n> On Feb 11, 2014, at 2:00 AM, Kevin Greene <kgreenek at gmail.com> wrote:\n>\n> Figured I would have a crack at reviewing this since Mike is out for a\n> bit. It was great running into you guys at the bitcoin fair in SF! Small\n> world :)\n>\n>\n> Indeed! It was great meeting you! It's always nice to meet people in\n> person...\n>\n> I like how simple this is. You just give it an url to fetch the next\n> payment request and a date to fetch it.\n>\n> What should happen if the client tries to fetch the PaymentRequest early\n> or late?\n>\n>\n> If the client tries to fetch too early, then  the merchant will return a\n> PaymentRequest with no output (there is nothing to pay yet). If it fetches\n> too late, this is merchant specific. It could be that the service got\n> discontinued -- extreme case -- or that there are now multiple\n> PaymentRequest pending or that the merchant decided to aggregate those into\n> one. In that scenario, it could lead to a case where the amount to pay goes\n> beyond the contract and the wallet would refuse to make the recurring\n> payment.\n>\n> Does it become valid after some date and stay valid for some length of\n> time?\n>\n>\n> The protocol we sketched does not include (yet) an expiration date. At\n> this point the contract is fairly minimal, and we could envision adding\n> more parameters such as expiration date. So at this point the behavior\n> would be dictated by the merchant.\n>\n> Also, what should happen if the client tries to consume the same\n> PaymentRequest twice (or multiple times) during the same period?\n>\n>\n> The merchant initiates the PaymentRequest and is in charge to make sure\n> they match the invoices that the client should pay. On the client side, the\n> wallet is responsible to verify that the contract is respected, so if a\n> merchant were to issue multiple times the same PaymentRequest, the wallet\n> would detect it goes beyond the bonds defined in the contract and would\n> refuse to make the additional Payments.\n>\n> I do not think daily/weekly/monthly is flexible enough. What do you think\n> about having a concrete start time and end time when the next\n> PaymentRequest will be valid?\n>\n>\n> I agree that daily/weekly/monthly may not be flexible enough. However\n> specifying a fixed date may be very tricky because in some cases a monthly\n> subscription may start on a 31st of a month, and depending on the month,\n> the due date will vary -- could be 30th, 28th, 29th, ... Also note that the\n> frequency (daily/weekly/monthly) is not used as a polling interval, but is\n> only used to verify the contract is respected.\n>\n> There are multiple viable options to specify that contract and ideally we\n> could/should support multiple schemes; different merchants could use\n> different schemes, and the client would decide wether or not he is ready to\n> accept the terms that will later be enforced by the wallet. But of course\n> all this flexibility goes against simplicity and so this is tradeoff...\n>\n>\n> This also prevents the wallet from having to remember when it last sent a\n> payment and getting skewed over time.\n>\n>\n> Today, our current prototype is polling every day -- which is the lowest\n> granularity we introduced -- and so there is no risk of getting skewed.\n>\n>\n> When a wallet hits the polling_url to download the next PaymentRequest, it\n> seems we need a way to communicate an error code to the wallet, for example\n> if the server canceled the contract without the wallet knowing. Perhaps a\n> separate polling_status_url, with a corresponding ACK message to indicate\n> if the PaymentRequest is available. What do you think of that idea?\n>\n>\n> I think reporting such errors to the wallet would make complete sense.\n> However i am not clear why we would a separate url for that?\n>\n>  One high-level comment -- the wallet in this design doesn't have any way\n> of knowing when the payments are supposed to end. I feel this is important\n> to show to the user before they start their wallet polling infinitely.\n>\n>\n> Subscriptions are non ending by definition, but at any time the client\n> (through the wallet) or the merchant can decide to terminate the\n> subscriptions -- we did not yet implement cancellation in that prototype\n> but we are planning to add it later this week. Think of your Netflix\n> subscriptions, this is never ending (evergreen) until you decide to\n> terminate it or Netflix does it (abuse, bills not paid,...)\n>\n> Thanks for taking a look!\n>\n>\n> On Sat, Feb 8, 2014 at 6:48 PM, Stephane Brossier <stephane at kill-bill.org>wrote:\n>\n>> Mike, Gavin,\n>>\n>>\n>> We started to work on the merchant side to test the integration of our\n>> prototype for the recurring payments. We modified the 'Payment Request\n>> Generator' from Gavin to include a new check box 'set recurring'. We forked\n>> the code and checked in our modification here:\n>> https://github.com/killbill/paymentrequest/commit/e530f6ec528266aacfd076d7c3154ad39267c3f3\n>>\n>> We also found a few issues with the code diff that we sent yesterday for\n>> bitcoinj and checked in the bug fixes  in our fork-- so the diff sent\n>> yesterday is slightly outdated.\n>>\n>> So at this point we have a working prototype for bitcoinj and we are\n>> waiting for your feedbacks. We also started to look at integrating the\n>> protocol in Kill Bill to check that what is proposed supports indeed the\n>> business cases of a full recurring billing platform.\n>>\n>> Hope to hear from you guys soon!\n>>\n>>\n>> On Feb 7, 2014, at 6:57 PM, Stephane Brossier <stephane at kill-bill.org>\n>> wrote:\n>>\n>> Mike and all,\n>>\n>> Pierre and I just committed a prototype implementation of the recurring\n>> payment protocol using bitcoinj. You can find the diff on our fork:\n>>\n>> https://github.com/killbill/bitcoinj/commit/40c657c4191498f12539c60316116aa68af368a7\n>>\n>> We did not write the server (merchant side), but wanted to have some\n>> feedback before going deeper (merchant implementation and tests). We did\n>> our best to build it on top of the existing BIP-0070 protocol-- only a few\n>> additions in the messages, but no new calls and no new uri scheme. We\n>> created a new package 'recurring' where most of the new code lives.\n>>\n>> At a high level:\n>>\n>> 1. Creation of the subscription:\n>>\n>> The initial handshake for creating the subscription is exactly similar to\n>> the one for the payment protocol (PaymentRequest is used to provide the\n>> contract)\n>>\n>> 2. Wallet can decide to poll the merchants for its active subscriptions.\n>>\n>> Here the flow is exactly similar to the payment protocol but the wallet\n>> receives a callback to verify the payment matches the contract and should\n>> go through.\n>>\n>> Please give us some feedback whenever you have the chance. In the\n>> meantime we will start implementing the merchant side and test the code.\n>>\n>> Cheers!\n>>\n>>\n>>\n>> On Jan 31, 2014, at 10:13 AM, Mike Hearn <mike at plan99.net> wrote:\n>>\n>> That looks OK at a very high level. Things you probably want to think\n>> about:\n>>\n>>    - How to trigger it off the existing payment protocol (no new top\n>>    level messages or mime types or uri extensions please)\n>>    - Data structures to define the payment schedule\n>>    - Do you allow pre-submission of time locked transactions or not?\n>>\n>> I think as you prototype these things will become clearer.  You could try\n>> prototyping either in Bitcoin Core (C++) or bitcoinj (java, look at the\n>> PaymentSession class).\n>>\n>>\n>>\n>> On Wed, Jan 29, 2014 at 3:47 AM, Stephane Brossier <\n>> stephane at kill-bill.org> wrote:\n>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>> *From what I have seen so far, there seems to be an agreement that this\n>>> is a nice feature to add. We are pretty new to that community and so we\n>>> don't know exactly what the process is, and in particular how we reach\n>>> consensus via email. I am certainly open to follow 'the way' if there is\n>>> one, but one solution would be to follow Mike's suggestion on providing a\n>>> (prototype) implementation first and then defining/refining the BIP. Odinn\n>>> also suggested a possible retribution for our time through crowd-sourcing\n>>> which I am interested to pursue if that makes sense. We have quite some\n>>> experience on the subscription side of things and while we are growing our\n>>> knowledge on the Bitcoin technology (and ecosystem at large) we would\n>>> benefit from: * some feedbacks on the high level proposal * additional\n>>> requirements we might have missed So, below is a high level description of\n>>> what we have in mind. If this sounds reasonable, we could start working on\n>>> an implementation. I. Abstract --------------- This describes a protocol to\n>>> enable recurring payments in bitcoins and can be seen as an extension of\n>>> BIP-0070. The main goal here is to have the customer subscribe to a service\n>>> of some kind (that is, agreeing on the terms of that subscription\n>>> contract), and then have the wallet make recurring payments without any\n>>> intervention from the customer as long as the payments match what the\n>>> customer agreed on paying. An example of such service would be an online\n>>> streaming website, to which a user pays a fixed recurring monthly fee to\n>>> access videos (a.k.a. resources). Note that there is also usage based\n>>> billing: for example, the user may need to purchase additional access for\n>>> premium videos (overage charges). This type of billing is more complicated\n>>> and there are many variations to it used in the industry (pre-paid, ...). For\n>>> the sake of discussion, we'll focus on fixed recurring payments only, but\n>>> we will keep usage in mind to make sure the protocol will be able to\n>>> support it as well. II. Motivation ------------------ Subscription based\n>>> services have been growing in the past few years and so the intent it to\n>>> make it possible for customers to pay in bitcoins. Bitcoin's push model\n>>> presents new advantages for the customer compared to traditional payment\n>>> methods: the user has control over the subscription (for example, there is\n>>> no need to call the merchant to explicitly cancel the credit card\n>>> payments). It also opens the door to subscription management tools in\n>>> wallets (e.g. Hive apps), which would give user an overview of what they\n>>> are paying each month. III. Flow of\n>>> Operations----------------------------------------*\n>>>\n>>>\n>>>\n>>>\n>>> * Creation of the subscription: - - - - - - - - - - - - - - - - - - - -\n>>> - - 1. The customer clicks 'subscribe' -> A message is sent to the\n>>> merchant. 2. The merchant sends back a message to the wallet with the\n>>> details of the subscription such as the amount to be paid. In reality,\n>>> there will be more information but for the purpose of the prototype\n>>> implementation this is sufficient. 3. The wallet prompts the customer for\n>>> authorization. 4. The customer authorizes (or denies) it. 5. The wallet\n>>> sends the confirmation to the merchant. 6. The merchant confirms the\n>>> subscription was created. Ongoing payments: *\n>>>\n>>> *- - - - - - - - - - - - - - - - *\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>> * From that time on and since Bitcoin is a 'push' model, the wallet is\n>>> responsible to poll the merchant for due payments associated with that\n>>> subscription. Note that the merchant could specify hints to the wallet on\n>>> when to poll (specific dates) or not during the registration of the\n>>> subscription. Note that we can't simply have the wallet push X bitcoins\n>>> every month: the user account on the merchant side may have gotten credits,\n>>> invoice adjustments, etc. since the last invoice, so the amount to pay for\n>>> a given billing period may be lower than the regular amount. It could even\n>>> be zero if the user decides to make a one-time payment to the merchant\n>>> directly using a different wallet. Hence, the wallet needs to get the\n>>> latest invoice balance to make sure how much it should pay. This also opens\n>>> the door for the support of overage charges. Quick note on the\n>>> implementation on the merchant side: an entitlement system is a piece of\n>>> logic on the merchant side which grants the user access to certain\n>>> resources depending on the account status (unpaid invoices, etc.). This\n>>> goes often hand in hand with a dunning system, which progressively\n>>> restricts access as the user's account is more and more overdue. Since\n>>> wallets can be offline for an extended period of time, payments may be\n>>> missed and lead to an overdue state (e.g. extra fees, service degraded). It\n>>> is the responsibility of the customer to ensure the wallet is up often\n>>> enough for payments to happen. In that recurring phase where the wallet\n>>> polls the merchant, the wallet is responsible to check that payments match\n>>> the subscription contract; that is, the amount, frequency of payments, ...\n>>> match what the customer agreed on. If so, the payment is made without\n>>> asking for explicit approval from customer, and the flow is similar to\n>>> BIP-0070: The message is sent to the merchant, and in parallel, a\n>>> transaction is sent to the btcnet. The merchant sends an ACK to the wallet\n>>> and of course checks the states of the transactions on the btcnet to mark\n>>> that payment as successful. Subscription change (optional): *\n>>>\n>>> *- - - - - - - - - - - - - - - - - - - - - - - - *\n>>>\n>>>\n>>> * Optionally we could implement a change in the ongoing subscription to\n>>> address the upgrade/downgrade scenarios. Of course, we could also simply\n>>> support a cancellation followed by a creation of a new subscription, but\n>>> having that as a one atomic message is probably better. The steps are very\n>>> similar to the initial registration. 1. The customer clicks 'upgrade',\n>>> 'downgrade', ... -> A msg is sent to the merchant. 2. The merchant sends back\n>>> a msg to the wallet with the detail of the NEW subscription. 3. The wallet\n>>> prompts the customer for authorization. 4. The customer authorizes (or\n>>> denies) it. 5. The wallet sends the confirmation to the merchant. 6. The\n>>> merchant confirms the change in the subscription. Cancellation of the\n>>> subscription: *\n>>>\n>>> *- - - - - - - - - - - - - - - - - - - - - - - - - *\n>>>\n>>>\n>>>\n>>> * The cancellation is initiated from the customer: 1. The customer\n>>> clicks 'cancel' -> The wallet is informed that it  should not accept any\n>>> new payment associated to that subscription. 2. The wallet sends a message\n>>> to the merchant to inform about the cancellation. 3. The merchant confirms\n>>> the subscription was cancelled. *\n>>>\n>>\n>>\n>>\n>>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140211/2b958bf7/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-02-11T16:24:12",
                "message_text_only": "Hey guys,\n\nI'm on vacation now so won't be able to take a look until I'm back in a\ncouple of weeks but the approach sounds reasonable based on your\ndescription.\nOn 8 Feb 2014 08:28, \"Stephane Brossier\" <stephane at kill-bill.org> wrote:\n\n> Mike and all,\n>\n> Pierre and I just committed a prototype implementation of the recurring\n> payment protocol using bitcoinj. You can find the diff on our fork:\n>\n> https://github.com/killbill/bitcoinj/commit/40c657c4191498f12539c60316116aa68af368a7\n>\n> We did not write the server (merchant side), but wanted to have some\n> feedback before going deeper (merchant implementation and tests). We did\n> our best to build it on top of the existing BIP-0070 protocol-- only a few\n> additions in the messages, but no new calls and no new uri scheme. We\n> created a new package 'recurring' where most of the new code lives.\n>\n> At a high level:\n>\n> 1. Creation of the subscription:\n>\n> The initial handshake for creating the subscription is exactly similar to\n> the one for the payment protocol (PaymentRequest is used to provide the\n> contract)\n>\n> 2. Wallet can decide to poll the merchants for its active subscriptions.\n>\n> Here the flow is exactly similar to the payment protocol but the wallet\n> receives a callback to verify the payment matches the contract and should\n> go through.\n>\n> Please give us some feedback whenever you have the chance. In the meantime\n> we will start implementing the merchant side and test the code.\n>\n> Cheers!\n>\n>\n>\n> On Jan 31, 2014, at 10:13 AM, Mike Hearn <mike at plan99.net> wrote:\n>\n> That looks OK at a very high level. Things you probably want to think\n> about:\n>\n>    - How to trigger it off the existing payment protocol (no new top\n>    level messages or mime types or uri extensions please)\n>    - Data structures to define the payment schedule\n>    - Do you allow pre-submission of time locked transactions or not?\n>\n> I think as you prototype these things will become clearer.  You could try\n> prototyping either in Bitcoin Core (C++) or bitcoinj (java, look at the\n> PaymentSession class).\n>\n>\n>\n> On Wed, Jan 29, 2014 at 3:47 AM, Stephane Brossier <stephane at kill-bill.org\n> > wrote:\n>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>> *From what I have seen so far, there seems to be an agreement that this\n>> is a nice feature to add. We are pretty new to that community and so we\n>> don't know exactly what the process is, and in particular how we reach\n>> consensus via email. I am certainly open to follow 'the way' if there is\n>> one, but one solution would be to follow Mike's suggestion on providing a\n>> (prototype) implementation first and then defining/refining the BIP. Odinn\n>> also suggested a possible retribution for our time through crowd-sourcing\n>> which I am interested to pursue if that makes sense. We have quite some\n>> experience on the subscription side of things and while we are growing our\n>> knowledge on the Bitcoin technology (and ecosystem at large) we would\n>> benefit from: * some feedbacks on the high level proposal * additional\n>> requirements we might have missed So, below is a high level description of\n>> what we have in mind. If this sounds reasonable, we could start working on\n>> an implementation. I. Abstract --------------- This describes a protocol to\n>> enable recurring payments in bitcoins and can be seen as an extension of\n>> BIP-0070. The main goal here is to have the customer subscribe to a service\n>> of some kind (that is, agreeing on the terms of that subscription\n>> contract), and then have the wallet make recurring payments without any\n>> intervention from the customer as long as the payments match what the\n>> customer agreed on paying. An example of such service would be an online\n>> streaming website, to which a user pays a fixed recurring monthly fee to\n>> access videos (a.k.a. resources). Note that there is also usage based\n>> billing: for example, the user may need to purchase additional access for\n>> premium videos (overage charges). This type of billing is more complicated\n>> and there are many variations to it used in the industry (pre-paid, \u2026). For\n>> the sake of discussion, we\u2019ll focus on fixed recurring payments only, but\n>> we will keep usage in mind to make sure the protocol will be able to\n>> support it as well. II. Motivation ------------------ Subscription based\n>> services have been growing in the past few years and so the intent it to\n>> make it possible for customers to pay in bitcoins. Bitcoin\u2019s push model\n>> presents new advantages for the customer compared to traditional payment\n>> methods: the user has control over the subscription (for example, there is\n>> no need to call the merchant to explicitly cancel the credit card\n>> payments). It also opens the door to subscription management tools in\n>> wallets (e.g. Hive apps), which would give user an overview of what they\n>> are paying each month. III. Flow of\n>> Operations----------------------------------------*\n>>\n>>\n>>\n>>\n>> * Creation of the subscription: - - - - - - - - - - - - - - - - - - - - -\n>> - 1. The customer clicks 'subscribe' -> A message is sent to the merchant.\n>> 2. The merchant sends back a message to the wallet with the details of the\n>> subscription such as the amount to be paid. In reality, there will be more\n>> information but for the purpose of the prototype implementation this is\n>> sufficient. 3. The wallet prompts the customer for authorization. 4. The\n>> customer authorizes (or denies) it. 5. The wallet sends the confirmation to\n>> the merchant. 6. The merchant confirms the subscription was created.\n>> Ongoing payments: *\n>>\n>> *- - - - - - - - - - - - - - - - *\n>>\n>>\n>>\n>>\n>>\n>>\n>> * From that time on and since Bitcoin is a 'push' model, the wallet is\n>> responsible to poll the merchant for due payments associated with that\n>> subscription. Note that the merchant could specify hints to the wallet on\n>> when to poll (specific dates) or not during the registration of the\n>> subscription. Note that we can't simply have the wallet push X bitcoins\n>> every month: the user account on the merchant side may have gotten credits,\n>> invoice adjustments, etc. since the last invoice, so the amount to pay for\n>> a given billing period may be lower than the regular amount. It could even\n>> be zero if the user decides to make a one-time payment to the merchant\n>> directly using a different wallet. Hence, the wallet needs to get the\n>> latest invoice balance to make sure how much it should pay. This also opens\n>> the door for the support of overage charges. Quick note on the\n>> implementation on the merchant side: an entitlement system is a piece of\n>> logic on the merchant side which grants the user access to certain\n>> resources depending on the account status (unpaid invoices, etc.). This\n>> goes often hand in hand with a dunning system, which progressively\n>> restricts access as the user's account is more and more overdue. Since\n>> wallets can be offline for an extended period of time, payments may be\n>> missed and lead to an overdue state (e.g. extra fees, service degraded). It\n>> is the responsibility of the customer to ensure the wallet is up often\n>> enough for payments to happen. In that recurring phase where the wallet\n>> polls the merchant, the wallet is responsible to check that payments match\n>> the subscription contract; that is, the amount, frequency of payments, \u2026\n>> match what the customer agreed on. If so, the payment is made without\n>> asking for explicit approval from customer, and the flow is similar to\n>> BIP-0070: The message is sent to the merchant, and in parallel, a\n>> transaction is sent to the btcnet. The merchant sends an ACK to the wallet\n>> and of course checks the states of the transactions on the btcnet to mark\n>> that payment as successful. Subscription change (optional): *\n>>\n>> *- - - - - - - - - - - - - - - - - - - - - - - - *\n>>\n>>\n>> * Optionally we could implement a change in the ongoing subscription to\n>> address the upgrade/downgrade scenarios. Of course, we could also simply\n>> support a cancellation followed by a creation of a new subscription, but\n>> having that as a one atomic message is probably better. The steps are very\n>> similar to the initial registration. 1. The customer clicks 'upgrade',\n>> 'downgrade', \u2026 -> A msg is sent to the merchant. 2. The merchant sends back\n>> a msg to the wallet with the detail of the NEW subscription. 3. The wallet\n>> prompts the customer for authorization. 4. The customer authorizes (or\n>> denies) it. 5. The wallet sends the confirmation to the merchant. 6. The\n>> merchant confirms the change in the subscription. Cancellation of the\n>> subscription: *\n>>\n>> *- - - - - - - - - - - - - - - - - - - - - - - - - *\n>>\n>>\n>>\n>> * The cancellation is initiated from the customer: 1. The customer clicks\n>> 'cancel' -> The wallet is informed that it  should not accept any new\n>> payment associated to that subscription. 2. The wallet sends a message to\n>> the merchant to inform about the cancellation. 3. The merchant confirms the\n>> subscription was cancelled. *\n>>\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140211/e4c7d1b9/attachment.html>"
            },
            {
                "author": "Kevin Greene",
                "date": "2014-02-12T06:37:00",
                "message_text_only": "Sending this again and truncating since apparently the message body was too\nlong.\n\nThanks for humoring my questions!\n\n>I think reporting such errors to the wallet would make complete sense.\nHowever i am not clear why we would a separate url for that?\n\nHmm, thinking about this more, adding a simple status_code in\nPaymentRequest would be a much easier way to achieve this. However,\ncontinuing to think about this even more, maybe the simple memo field along\nwith an empty set of outputs is enough already.\n\nIn bitcoinj, right now the code will throw a\nPaymentRequestException.InvalidOutputs exception if the set of outputs is\nempty with a message of \"No Outputs\". Because of that, there isn't a good\nway to tell the difference between a payment request that had no outputs\nand a payment request that had some invalid output(s).\n\n*Question to everyone:*\nHow does bitcoin-qt handle a PaymentRequest with no outputs?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140211/e0972311/attachment.html>"
            },
            {
                "author": "Stephane Brossier",
                "date": "2014-02-14T20:28:24",
                "message_text_only": "Kevin,\n\nWe did a second iteration on the prototype to implement subscription cancellation and upgrade/downgrade. We checked in both the bitcoinj and php server to be able to test it.\nWe also worked on our side of the merchant implementation (Kill Bill) to feel confident that the protocol will support advanced business cases. At this point it is looking promising, but more work is needed to conclude.\n\nWe wanted to follow up on a few pervious points you raised:\n\n> However, continuing to think about this even more, maybe the simple memo field along with an empty set of outputs is enough already.\n\nFrom our merchant side (Kill Bill), we do indeed use this field to report successes or errors. Maybe it would be useful to extend PaymentACK with a boolean success field (so the wallet doesn't commit the transaction in case of failures)?\n\n> One high-level comment -- the wallet in this design doesn't have any way of knowing when the payments are supposed to end. I feel this is important to show to the user before they start their wallet polling infinitely.\n\nWe extended our RecurringPaymentDetails message to support this use case, as it solves the problem of subscription changes and cancellations for free.\n\nWe introduced the concept of a subscription, referred to by a unique id (the tuple merchant_id,subscription_id should be globally unique), which has multiple contracts (RecurringPaymentContract). Besides payment bounds, each contract has a validity period: generally, a subscription will have a unique active contract at a given time and potentially one or more pending ones.\n\nFor example, say you are on the gold plan (1 BTC/mo.) and want to downgrade to a bronze plan (0.5 BTC/mo.) at your next billing date. Wshen you click \"Downgrade\" on the merchant site, you will update your wallet with two contracts: the current valid one until your next billing date (for up to 1 BTC), and a pending one, starting at your next billing date (for up to 0.5 BTC/mo. and without an ending date).\nUpon cancellation of the bronze plan, the end date of the contract will be updated and polling will stop eventually.\n\nAll of this contract metadata is returned to the wallet so the user can make an informed decision.\n\n\nThanks for your feedbacks!\n\nS.\n\n\nOn Feb 11, 2014, at 10:37 PM, Kevin Greene <kgreenek at gmail.com> wrote:\n\n> Sending this again and truncating since apparently the message body was too long.\n> \n> Thanks for humoring my questions!\n> \n> >I think reporting such errors to the wallet would make complete sense. However i am not clear why we would a separate url for that?\n> \n> Hmm, thinking about this more, adding a simple status_code in PaymentRequest would be a much easier way to achieve this. However, continuing to think about this even more, maybe the simple memo field along with an empty set of outputs is enough already.\n> \n> In bitcoinj, right now the code will throw a PaymentRequestException.InvalidOutputs exception if the set of outputs is empty with a message of \"No Outputs\". Because of that, there isn't a good way to tell the difference between a payment request that had no outputs and a payment request that had some invalid output(s).\n> \n> Question to everyone:\n> How does bitcoin-qt handle a PaymentRequest with no outputs?\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140214/3987523b/attachment.html>"
            },
            {
                "author": "Stephane Brossier",
                "date": "2014-02-24T18:04:21",
                "message_text_only": "Mike,\n\n\nJust want to follow up with you and the community in general regarding the BIP0070 extension for recurring billing. At this point we have a working prototype that we checked-in in our fork of bitcoinj (https://github.com/killbill/bitcoinj). We tested it by extending the php 'payment server' from Gavin which we also check-in in a fork (https://github.com/killbill/paymentrequest). I think it does not make much sense from our side to invest more efforts until we hear some feedbacks.\n\nOnce we agree/integrate any feedbacks you guys may have-- a proposal for next steps would be:\n* Turn that into a actual BIP so as to detail how that works, \n* Write some more serious unit tests\n* Merge back code into bitconj trunk\n\nDown the line write the C++ code, but of course that would assume BIP0070 is also implemented in C++ as we rely on it.\n\nI understand you guys may have more important matters to solve these days with the recent malleability issue, but i want to make it clear that we are waiting for feedbacks to make additional progress.\n\nThanks!\n\nS.\n\n\n\n\nOn Feb 14, 2014, at 12:28 PM, Stephane Brossier <stephane at kill-bill.org> wrote:\n\n> Kevin,\n> \n> We did a second iteration on the prototype to implement subscription cancellation and upgrade/downgrade. We checked in both the bitcoinj and php server to be able to test it.\n> We also worked on our side of the merchant implementation (Kill Bill) to feel confident that the protocol will support advanced business cases. At this point it is looking promising, but more work is needed to conclude.\n> \n> We wanted to follow up on a few pervious points you raised:\n> \n> > However, continuing to think about this even more, maybe the simple memo field along with an empty set of outputs is enough already.\n> \n> From our merchant side (Kill Bill), we do indeed use this field to report successes or errors. Maybe it would be useful to extend PaymentACK with a boolean success field (so the wallet doesn't commit the transaction in case of failures)?\n> \n> > One high-level comment -- the wallet in this design doesn't have any way of knowing when the payments are supposed to end. I feel this is important to show to the user before they start their wallet polling infinitely.\n> \n> We extended our RecurringPaymentDetails message to support this use case, as it solves the problem of subscription changes and cancellations for free.\n> \n> We introduced the concept of a subscription, referred to by a unique id (the tuple merchant_id,subscription_id should be globally unique), which has multiple contracts (RecurringPaymentContract). Besides payment bounds, each contract has a validity period: generally, a subscription will have a unique active contract at a given time and potentially one or more pending ones.\n> \n> For example, say you are on the gold plan (1 BTC/mo.) and want to downgrade to a bronze plan (0.5 BTC/mo.) at your next billing date. Wshen you click \"Downgrade\" on the merchant site, you will update your wallet with two contracts: the current valid one until your next billing date (for up to 1 BTC), and a pending one, starting at your next billing date (for up to 0.5 BTC/mo. and without an ending date).\n> Upon cancellation of the bronze plan, the end date of the contract will be updated and polling will stop eventually.\n> \n> All of this contract metadata is returned to the wallet so the user can make an informed decision.\n> \n> \n> Thanks for your feedbacks!\n> \n> S.\n> \n> \n> On Feb 11, 2014, at 10:37 PM, Kevin Greene <kgreenek at gmail.com> wrote:\n> \n>> Sending this again and truncating since apparently the message body was too long.\n>> \n>> Thanks for humoring my questions!\n>> \n>> >I think reporting such errors to the wallet would make complete sense. However i am not clear why we would a separate url for that?\n>> \n>> Hmm, thinking about this more, adding a simple status_code in PaymentRequest would be a much easier way to achieve this. However, continuing to think about this even more, maybe the simple memo field along with an empty set of outputs is enough already.\n>> \n>> In bitcoinj, right now the code will throw a PaymentRequestException.InvalidOutputs exception if the set of outputs is empty with a message of \"No Outputs\". Because of that, there isn't a good way to tell the difference between a payment request that had no outputs and a payment request that had some invalid output(s).\n>> \n>> Question to everyone:\n>> How does bitcoin-qt handle a PaymentRequest with no outputs?\n> \n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140224/d3d56e7d/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-02-25T16:29:44",
                "message_text_only": "Hey there,\n\nSo the essence of this protocol is as follows:\n\nenum PaymentFrequencyType {\n        WEEKLY = 1;\n        MONTHLY = 2;\n        QUARTERLY = 3;\n        ANNUAL = 4;\n}\nmessage RecurringPaymentDetails {\n        // Namespace for the merchant such as org.foo.bar\n        required string merchant_id = 1;\n        // Id for the recurring subscription\n        required bytes subscription_id = 2;\n        // Contracts associated with a given subscription\n        repeated RecurringPaymentContract contracts = 3;\n}\nmessage RecurringPaymentContract {\n        // Unique id for a given contract\n        required bytes contract_id = 1;\n        // URL to poll to get the next PaymentRequest\n        required string polling_url = 2;\n        // Timestamp; when this contract starts\n        required uint64 starts = 3;\n        // Timestamp; when this contract should be considered invalid\n        optional uint64 ends = 4;\n        // Expected payment frequency\n        optional PaymentFrequencyType payment_frequency_type = 5;\n        // Max payment amount within that frequency (e.g. no more than\n5 BTC per month)\n        optional uint64 max_payment_per_period  = 6;\n        // Max payment amount (e.g. no more than 3 BTC per payment)\n        optional uint64 max_payment_amount = 7;\n}\n\nI have the following comments:\n\n   1. There's no need to serialize RecurringPaymentDetails as bytes here.\n   It's done that way outside of PaymentDetails in order to support digital\n   signatures over protobufs that may have extensions the wallet app isn't\n   aware of, but it's a pain and inside PaymentDetails (and therefore for most\n   extensions) it shouldn't be necessary. So you can just use \"optional\n   RecurringPamentDetails recurring_payments = 8;\"\n\n   2. There's only 4 possibilities here for recurrences. That seems rather\n   restrictive. Is the cost of being more expressive really so high? Why not\n   allow more flexible specification of periods?\n\n   3. If there's no payment_frequency_type field then what happens? A quirk\n   of protobufs to be aware of is that making an enum field \"required\" can\n   hurt backwards compatibility. Because it will be expressed using a\n   languages underlying enum type, if there's a new enum member added later\n   old software that attempts to deserialize this will throw exceptions\n   because the new \"unknown\" member would be unrepresentable in the old model.\n   Making the field optional avoids this problem (it will be treated as\n   missing instead) but means software needs to be written to know what to do\n   when it can't read the enum value / sees enum values from the future.\n\n   4. I assume the amounts are specified in terms of satoshi, and\n   timestamps are UNIX time, but better to make that explicit.\n\n   5. Seems there's an implicit value constraint that max_payment_amount <=\n   max_payment_per_period. What happens if that constraint is violated? Best\n   to document that.\n\n   6. What's the \"merchant ID\" namespace thing about? What's it for? What\n   happens if I set my competitors merchant ID there?\n\n   7. What's the \"subscription ID\"? Is this stuff not duplicative/redundant\n   with the existing merchant_data field?\n\n   8. In what situations would you have >1 contract per payment request?\n   I'm not sure I understand why it's repeated. Presumably if there are zero\n   contracts included the data should be ignored, or an error thrown and the\n   entire payment request rejected? Which should it be?\n\n   9. It's unclear to me given such a contract when the payment should\n   actually occur. For instance if it's \"monthly\" then what day in the month\n   would the payment occur?\n\n   10. You'll notice I moved the comments to be above the field\n   definitions. I know the current proto isn't done that way, but let's change\n   it - long comments are good and putting them above the field definitions\n   encourages people to write enough detail without being put off by line\n   length constraints\n\n\nI think the next step would be to talk to BitPay/get Jeff+Stephen involved\nbecause I know they have customers that really want recurring payments, and\nthose guys will have a clearer idea of customer requirements than we do. I\nfeel uncomfortable with designing or reviewing in a vacuum without some\nactual people who would use it chiming in, as I don't really know much\nabout the underlying business processes.\n\nI have some other comments about the bitcoinj implementation specifically -\nfor instance, we don't have a \"wallet directory\" concept: everything goes\ninto the wallet file. So we'll need to think about how to structure the\ncode to allow that. Also, just using a background polling thread is likely\nnot flexible enough, as on some platforms you can't stay running all the\ntime (e.g. Android) without upsetting people, but the underlying OS can\nwake you up at the right times, so wallet apps should have an ability to\ncontrol wakeup tasks. But we can discuss that over on the bitcoinj list\nspecifically. Let's keep this thread for the general protocol design.\n\nBIP 70 is indeed implemented in Bitcoin Core on the C++ side, so that isn't\na concern. It could be done there too.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140225/bb748c61/attachment.html>"
            },
            {
                "author": "Drak",
                "date": "2014-02-25T18:40:03",
                "message_text_only": "Forgive me if I missed it, but the spec doesnt look like it can handle only\nhandle periods of per week, per month, per quarter rather than 'n period'.\nI take Paypal as a reference example for subscription payments where you\ncan set recurring to every: n days, n weeks, n months, n years. That way a\nquarterly payment is every 3 months. This fine granularity is necessary\nbecause sometime a payment scheme can be per 4 weekly rather than per\nmonthly.\n\nSo in summary the spec needs daily as an option, and to specify the\nrecurring cycle as every n*period (one of daily, weekly, monthly, yearly):\nand you can drop quarterly since it's just expressed as per 3*monthly.\n\nDrak\n\n\nOn 25 February 2014 16:29, Mike Hearn <mike at plan99.net> wrote:\n\n> Hey there,\n>\n> So the essence of this protocol is as follows:\n>\n> enum PaymentFrequencyType {\n>\n>         WEEKLY = 1;\n>\n>         MONTHLY = 2;\n>\n>         QUARTERLY = 3;\n>\n>         ANNUAL = 4;\n> }\n> message RecurringPaymentDetails {\n>         // Namespace for the merchant such as org.foo.bar\n>\n>         required string merchant_id = 1;\n>\n>         // Id for the recurring subscription\n>         required bytes subscription_id = 2;\n>\n>         // Contracts associated with a given subscription\n>\n>         repeated RecurringPaymentContract contracts = 3;\n>\n> }\n> message RecurringPaymentContract {\n>\n>         // Unique id for a given contract\n>\n>         required bytes contract_id = 1;\n>\n>         // URL to poll to get the next PaymentRequest\n>\n>         required string polling_url = 2;\n>\n>         // Timestamp; when this contract starts\n>         required uint64 starts = 3;\n>\n>         // Timestamp; when this contract should be considered invalid\n>\n>         optional uint64 ends = 4;\n>\n>         // Expected payment frequency\n>         optional PaymentFrequencyType payment_frequency_type = 5;\n>\n>         // Max payment amount within that frequency (e.g. no more than 5 BTC per month)\n>\n>         optional uint64 max_payment_per_period  = 6;\n>\n>         // Max payment amount (e.g. no more than 3 BTC per payment)\n>\n>         optional uint64 max_payment_amount = 7;\n>\n> }\n>\n> I have the following comments:\n>\n>    1. There's no need to serialize RecurringPaymentDetails as bytes here.\n>    It's done that way outside of PaymentDetails in order to support digital\n>    signatures over protobufs that may have extensions the wallet app isn't\n>    aware of, but it's a pain and inside PaymentDetails (and therefore for most\n>    extensions) it shouldn't be necessary. So you can just use \"optional\n>    RecurringPamentDetails recurring_payments = 8;\"\n>\n>    2. There's only 4 possibilities here for recurrences. That seems\n>    rather restrictive. Is the cost of being more expressive really so high?\n>    Why not allow more flexible specification of periods?\n>\n>    3. If there's no payment_frequency_type field then what happens? A\n>    quirk of protobufs to be aware of is that making an enum field \"required\"\n>    can hurt backwards compatibility. Because it will be expressed using a\n>    languages underlying enum type, if there's a new enum member added later\n>    old software that attempts to deserialize this will throw exceptions\n>    because the new \"unknown\" member would be unrepresentable in the old model.\n>    Making the field optional avoids this problem (it will be treated as\n>    missing instead) but means software needs to be written to know what to do\n>    when it can't read the enum value / sees enum values from the future.\n>\n>    4. I assume the amounts are specified in terms of satoshi, and\n>    timestamps are UNIX time, but better to make that explicit.\n>\n>    5. Seems there's an implicit value constraint that max_payment_amount\n>    <= max_payment_per_period. What happens if that constraint is violated?\n>    Best to document that.\n>\n>    6. What's the \"merchant ID\" namespace thing about? What's it for? What\n>    happens if I set my competitors merchant ID there?\n>\n>    7. What's the \"subscription ID\"? Is this stuff not\n>    duplicative/redundant with the existing merchant_data field?\n>\n>    8. In what situations would you have >1 contract per payment request?\n>    I'm not sure I understand why it's repeated. Presumably if there are zero\n>    contracts included the data should be ignored, or an error thrown and the\n>    entire payment request rejected? Which should it be?\n>\n>    9. It's unclear to me given such a contract when the payment should\n>    actually occur. For instance if it's \"monthly\" then what day in the month\n>    would the payment occur?\n>\n>    10. You'll notice I moved the comments to be above the field\n>    definitions. I know the current proto isn't done that way, but let's change\n>    it - long comments are good and putting them above the field definitions\n>    encourages people to write enough detail without being put off by line\n>    length constraints\n>\n>\n> I think the next step would be to talk to BitPay/get Jeff+Stephen involved\n> because I know they have customers that really want recurring payments, and\n> those guys will have a clearer idea of customer requirements than we do. I\n> feel uncomfortable with designing or reviewing in a vacuum without some\n> actual people who would use it chiming in, as I don't really know much\n> about the underlying business processes.\n>\n> I have some other comments about the bitcoinj implementation specifically\n> - for instance, we don't have a \"wallet directory\" concept: everything goes\n> into the wallet file. So we'll need to think about how to structure the\n> code to allow that. Also, just using a background polling thread is likely\n> not flexible enough, as on some platforms you can't stay running all the\n> time (e.g. Android) without upsetting people, but the underlying OS can\n> wake you up at the right times, so wallet apps should have an ability to\n> control wakeup tasks. But we can discuss that over on the bitcoinj list\n> specifically. Let's keep this thread for the general protocol design.\n>\n> BIP 70 is indeed implemented in Bitcoin Core on the C++ side, so that\n> isn't a concern. It could be done there too.\n>\n>\n>\n> ------------------------------------------------------------------------------\n> Flow-based real-time traffic analytics software. Cisco certified tool.\n> Monitor traffic, SLAs, QoS, Medianet, WAAS etc. with NetFlow Analyzer\n> Customize your own dashboards, set traffic alerts and generate reports.\n> Network behavioral analysis & security monitoring. All-in-one tool.\n>\n> http://pubads.g.doubleclick.net/gampad/clk?id=126839071&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140225/02825c0e/attachment.html>"
            },
            {
                "author": "Jeremy Spilman",
                "date": "2014-02-25T19:03:24",
                "message_text_only": ">\n> So in summary the spec needs daily as an option, and to specify the  \n> recurring cycle as every n*period >(one of daily, weekly, monthly,  \n> yearly): and you can drop quarterly since it's just expressed as per  \n> >3*monthly.\n\nIf you're going to go the direction of a {unitType, unitsPerInterval}  \ntuple, then I think the only two units you could ever want are minutes and  \nmonths. All other standard units of time can be expressed in terms of  \nthose two, right?\n\nAlso consider changing \"optional uint64 ends = 4;\" to be a interval count  \ninstead of a UTC timestamp, to avoid any ambiguity over how the 'while'  \nloop should be implemented."
            },
            {
                "author": "Christophe Biocca",
                "date": "2014-02-25T19:06:20",
                "message_text_only": "Given the enormous number of variations on time periods for a\nrecurring payment, might it be better to simple allow a list of\ntimestamps? It costs almost nothing, bandwidth wise, and shifts the\nthinking to the merchant platform. That doesn't give you an infinite\ntime frame, but you just get a new list of timestamps every time you\npay the service.\n\nContinuing that thought, is a \"next_payment_time\" field with each\nincremental transaction enough to cover everything?\n\nOn Tue, Feb 25, 2014 at 1:40 PM, Drak <drak at zikula.org> wrote:\n> Forgive me if I missed it, but the spec doesnt look like it can handle only\n> handle periods of per week, per month, per quarter rather than 'n period'. I\n> take Paypal as a reference example for subscription payments where you can\n> set recurring to every: n days, n weeks, n months, n years. That way a\n> quarterly payment is every 3 months. This fine granularity is necessary\n> because sometime a payment scheme can be per 4 weekly rather than per\n> monthly.\n>\n> So in summary the spec needs daily as an option, and to specify the\n> recurring cycle as every n*period (one of daily, weekly, monthly, yearly):\n> and you can drop quarterly since it's just expressed as per 3*monthly.\n>\n> Drak\n>\n>\n> On 25 February 2014 16:29, Mike Hearn <mike at plan99.net> wrote:\n>>\n>> Hey there,\n>>\n>> So the essence of this protocol is as follows:\n>>\n>>\n>> enum PaymentFrequencyType {\n>>         WEEKLY = 1;\n>>         MONTHLY = 2;\n>>         QUARTERLY = 3;\n>>         ANNUAL = 4;\n>> }\n>> message RecurringPaymentDetails {\n>>         // Namespace for the merchant such as org.foo.bar\n>>         required string merchant_id = 1;\n>>\n>>\n>>         // Id for the recurring subscription\n>>         required bytes subscription_id = 2;\n>>\n>>\n>>         // Contracts associated with a given subscription\n>>         repeated RecurringPaymentContract contracts = 3;\n>>\n>>\n>> }\n>> message RecurringPaymentContract {\n>>\n>>\n>>         // Unique id for a given contract\n>>         required bytes contract_id = 1;\n>>\n>>\n>>         // URL to poll to get the next PaymentRequest\n>>         required string polling_url = 2;\n>>\n>>\n>>         // Timestamp; when this contract starts\n>>         required uint64 starts = 3;\n>>\n>>\n>>         // Timestamp; when this contract should be considered invalid\n>>         optional uint64 ends = 4;\n>>\n>>\n>>         // Expected payment frequency\n>>         optional PaymentFrequencyType payment_frequency_type = 5;\n>>\n>>\n>>         // Max payment amount within that frequency (e.g. no more than 5\n>> BTC per month)\n>>         optional uint64 max_payment_per_period  = 6;\n>>\n>>\n>>         // Max payment amount (e.g. no more than 3 BTC per payment)\n>>         optional uint64 max_payment_amount = 7;\n>>\n>>\n>> }\n>>\n>> I have the following comments:\n>>\n>> There's no need to serialize RecurringPaymentDetails as bytes here. It's\n>> done that way outside of PaymentDetails in order to support digital\n>> signatures over protobufs that may have extensions the wallet app isn't\n>> aware of, but it's a pain and inside PaymentDetails (and therefore for most\n>> extensions) it shouldn't be necessary. So you can just use \"optional\n>> RecurringPamentDetails recurring_payments = 8;\"\n>>\n>> There's only 4 possibilities here for recurrences. That seems rather\n>> restrictive. Is the cost of being more expressive really so high? Why not\n>> allow more flexible specification of periods?\n>>\n>> If there's no payment_frequency_type field then what happens? A quirk of\n>> protobufs to be aware of is that making an enum field \"required\" can hurt\n>> backwards compatibility. Because it will be expressed using a languages\n>> underlying enum type, if there's a new enum member added later old software\n>> that attempts to deserialize this will throw exceptions because the new\n>> \"unknown\" member would be unrepresentable in the old model. Making the field\n>> optional avoids this problem (it will be treated as missing instead) but\n>> means software needs to be written to know what to do when it can't read the\n>> enum value / sees enum values from the future.\n>>\n>> I assume the amounts are specified in terms of satoshi, and timestamps are\n>> UNIX time, but better to make that explicit.\n>>\n>> Seems there's an implicit value constraint that max_payment_amount <=\n>> max_payment_per_period. What happens if that constraint is violated? Best to\n>> document that.\n>>\n>> What's the \"merchant ID\" namespace thing about? What's it for? What\n>> happens if I set my competitors merchant ID there?\n>>\n>> What's the \"subscription ID\"? Is this stuff not duplicative/redundant with\n>> the existing merchant_data field?\n>>\n>> In what situations would you have >1 contract per payment request? I'm not\n>> sure I understand why it's repeated. Presumably if there are zero contracts\n>> included the data should be ignored, or an error thrown and the entire\n>> payment request rejected? Which should it be?\n>>\n>> It's unclear to me given such a contract when the payment should actually\n>> occur. For instance if it's \"monthly\" then what day in the month would the\n>> payment occur?\n>>\n>> You'll notice I moved the comments to be above the field definitions. I\n>> know the current proto isn't done that way, but let's change it - long\n>> comments are good and putting them above the field definitions encourages\n>> people to write enough detail without being put off by line length\n>> constraints\n>>\n>>\n>> I think the next step would be to talk to BitPay/get Jeff+Stephen involved\n>> because I know they have customers that really want recurring payments, and\n>> those guys will have a clearer idea of customer requirements than we do. I\n>> feel uncomfortable with designing or reviewing in a vacuum without some\n>> actual people who would use it chiming in, as I don't really know much about\n>> the underlying business processes.\n>>\n>> I have some other comments about the bitcoinj implementation specifically\n>> - for instance, we don't have a \"wallet directory\" concept: everything goes\n>> into the wallet file. So we'll need to think about how to structure the code\n>> to allow that. Also, just using a background polling thread is likely not\n>> flexible enough, as on some platforms you can't stay running all the time\n>> (e.g. Android) without upsetting people, but the underlying OS can wake you\n>> up at the right times, so wallet apps should have an ability to control\n>> wakeup tasks. But we can discuss that over on the bitcoinj list\n>> specifically. Let's keep this thread for the general protocol design.\n>>\n>> BIP 70 is indeed implemented in Bitcoin Core on the C++ side, so that\n>> isn't a concern. It could be done there too.\n>>\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> Flow-based real-time traffic analytics software. Cisco certified tool.\n>> Monitor traffic, SLAs, QoS, Medianet, WAAS etc. with NetFlow Analyzer\n>> Customize your own dashboards, set traffic alerts and generate reports.\n>> Network behavioral analysis & security monitoring. All-in-one tool.\n>>\n>> http://pubads.g.doubleclick.net/gampad/clk?id=126839071&iu=/4140/ostg.clktrk\n>>\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>\n>\n> ------------------------------------------------------------------------------\n> Flow-based real-time traffic analytics software. Cisco certified tool.\n> Monitor traffic, SLAs, QoS, Medianet, WAAS etc. with NetFlow Analyzer\n> Customize your own dashboards, set traffic alerts and generate reports.\n> Network behavioral analysis & security monitoring. All-in-one tool.\n> http://pubads.g.doubleclick.net/gampad/clk?id=126839071&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Stephane Brossier",
                "date": "2014-02-26T03:53:08",
                "message_text_only": "Hi Mike, Jeremy, Drak,\n\nBefore going through your questions, I would like to bring some clarity on a few key elements in that protocol. There are really two aspects to it:\nThe contract negotiation; when the user first subscribes, it is prompted by a contract that will define the payment bounds associated with that subscription. \nOnce accepted, the wallet is in charge and the user does not have to interact anymore -- this is the point of the recurring payment protocol. The wallet will poll the merchant and issue payments as they are requested by the merchant as long as they stay within the bounds of what was specified by the contract (and accepted by the customer).\n\nI think it would help to explain how we ended up with the type of contract we introduced in that protocol. In an ideal world and in a NON recurring scheme, the contract should simply be the exact amount to be paid. In our case the exact amount may not be completely known in advance -- for e.g taxes, shipping, pro-rations, \u2026 and so we decided to introduce first a max amount per payment, and also a max amount per period. It is up to the merchant to decide whether to specify none, any or both bounds (max amount per payment and max amount per period). By specifying both, the contract is tighter and the client would feel safer to accept it. In the extreme case, by specifying none, the client would be presented with a contract to pay whatever is requested -- probably not a good option in the Bitcoin world unless there is a high sense of trust with the merchant.   \n\nFrom reading your comments, it appears we have not been clear on how that frequency (PaymentFrequencyType) is being used. Its sole purpose is to define the max amount per period in the contract. The frequency of the payment is implicitly dictated by the merchant but not specified in the protocol by design: the wallet has to poll with a fine granularity (ideally each day when it is up) to understand if there is something pending. In the same way, a specified amount was not enough in the contract, we feel it would be restrictive to specify in advance when payments are due. There are a lot of complex scenarios in the billing space, and having the wallet poll the merchant to inquire for pending payments is the most flexible option and the contract is there to ensure the client will not be abused. To give a concrete example, imagine a data plan where you pay a base recurring price of $70 per month, but you are charged $10 per GB of data used beyond your included limit. If you exceed your limit on the 15th and the 23rd of a given month, two extra payment attempts will be requested by the merchant, that you couldn\u2019t predict (this scenario is often referred to as usage billing with Prepay Credits and Top-up, where the customer pays in advance for blocks of N units, and once they are consumed another N are purchased).\n\n\nSee answers in your questions inlined below:\n\n> \n> I have the following comments:\n> There's no need to serialize RecurringPaymentDetails as bytes here. It's done that way outside of PaymentDetails in order to support digital signatures over protobufs that may have extensions the wallet app isn't aware of, but it's a pain and inside PaymentDetails (and therefore for most extensions) it shouldn't be necessary. So you can just use \"optional RecurringPamentDetails recurring_payments = 8;\"\n> \n\nOK, we'll fix it.\n\n\n> There's only 4 possibilities here for recurrences. That seems rather restrictive. Is the cost of being more expressive really so high? Why not allow more flexible specification of periods?\n> If there's no payment_frequency_type field then what happens? A quirk of protobufs to be aware of is that making an enum field \"required\" can hurt backwards compatibility. Because it will be expressed using a languages underlying enum type, if there's a new enum member added later old software that attempts to deserialize this will throw exceptions because the new \"unknown\" member would be unrepresentable in the old model. Making the field optional avoids this problem (it will be treated as missing instead) but means software needs to be written to know what to do when it can't read the enum value / sees enum values from the future.\n> \n\nI hope the explanation above answers the questions.\n\n> I assume the amounts are specified in terms of satoshi, and timestamps are UNIX time, but better to make that explicit.\n> \n\nYes.\n\n> Seems there's an implicit value constraint that max_payment_amount <= max_payment_per_period. What happens if that constraint is violated? Best to document that.\n> \n\nAs explained above, contract would define none, 1 or both conditions.  First the merchant should not return such 'conditions' but if it does the client should not accept the contract. If the client decides to accept it anyway, then the wallet just verifies both conditions are met separately regardless of whether there is such violation and if so, makes the payment.\n\n> What's the \"merchant ID\" namespace thing about? What's it for? What happens if I set my competitors merchant ID there?\n\nI agree, we can easily get rid of it.\n\n> What's the \"subscription ID\"? Is this stuff not duplicative/redundant with the existing merchant_data field?\n\nIn an ideal world the merchant should return unique subscriptionId (UUID for instance). That subscriptionId is used in the code to identify the contracts associated with the subscription. The merchant_data if i understand correctly the payment protocol is opaque from the client point of view, so it cannot be used by the client for that purpose. \n> In what situations would you have >1 contract per payment request? I'm not sure I understand why it's repeated. Presumably if there are zero contracts included the data should be ignored, or an error thrown and the entire payment request rejected? Which should it be?\n> \n\n\nThere are many example where that could  happen; for instance if you subscribe to a service,  then later decide to downgrade to a lower product. The merchant may decide to only let you downgrade at the end of your paid period-- to avoid generating extra credit-- and in that situation you end up with two contracts: One for the current product you are in and one for the future product you will end up on when the downgrade becomes effective.\n\n\n> It's unclear to me given such a contract when the payment should actually occur. For instance if it's \"monthly\" then what day in the month would the payment occur?\n> \n\nAs outlined above in the introduction, the protocol is designed in such a way that the wallet does not have to know what is the exact date when payment should occur, but instead polls the merchant for pending payments. There are many situations when specifying an exact payment date is not an option so that flexibility is essential. A simple example would be for a customer who started subscribing on the 31th of a month. Since there will be months with 28/29/30 days, the payment date would change depending on the month.\n\n\n\n\n> You'll notice I moved the comments to be above the field definitions. I know the current proto isn't done that way, but let's change it - long comments are good and putting them above the field definitions encourages people to write enough detail without being put off by line length constraints\n> \n\nFine.\n\n\n> I think the next step would be to talk to BitPay/get Jeff+Stephen involved because I know they have customers that really want recurring payments, and those guys will have a clearer idea of customer requirements than we do. I feel uncomfortable with designing or reviewing in a vacuum without some actual people who would use it chiming in, as I don't really know much about the underlying business processes.\n\n\nWe are totally open to receive feedbacks from them.. How do we bring them in the discussion?\n\n> \n> I have some other comments about the bitcoinj implementation specifically - for instance, we don't have a \"wallet directory\" concept: everything goes into the wallet file. So we'll need to think about how to structure the code to allow that. Also, just using a background polling thread is likely not flexible enough, as on some platforms you can't stay running all the time (e.g. Android) without upsetting people, but the underlying OS can wake you up at the right times, so wallet apps should have an ability to control wakeup tasks. But we can discuss that over on the bitcoinj list specifically. Let's keep this thread for the general protocol design.\n\nOk that makes sense.\n\n> \n> BIP 70 is indeed implemented in Bitcoin Core on the C++ side, so that isn't a concern. It could be done there too.\n> \n\nGreat to know.\n\n\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140225/e95b3c10/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-02-26T10:30:46",
                "message_text_only": "Thanks for the explanation. I agree that makes sense, and you did actually\nexplain this before, I just didn't connect the dots :)\n\nThe accompanying BIP should explain all this, so the rationale for the\ndesign and how you use it is made clear to developers.\n\nI've CCd Jeff and Stephen on this thread, so they can go review it and\nweigh in with any comments. They may want to go back to customers who\nrequested this feature and ask if it'd satisfy their needs.\n\n\nOn Wed, Feb 26, 2014 at 9:23 AM, Stephane Brossier\n<stephane at kill-bill.org>wrote:\n\n>\n>\n>\n>\n>\n>\n> *Hi Mike, Jeremy, Drak,Before going through your questions, I would like\n> to bring some clarity on a few key elements in that protocol. There are\n> really two aspects to it: 1. The contract negotiation; when the user first\n> subscribes, it is prompted by a contract that will define the payment\n> bounds associated with that subscription. 2. Once accepted, the wallet is\n> in charge and the user does not have to interact anymore -- this is the\n> point of the recurring payment protocol. The wallet will poll the merchant\n> and issue payments as they are requested by the merchant as long as they\n> stay within the bounds of what was specified by the contract (and accepted\n> by the customer).I think it would help to explain how we ended up with the\n> type of contract we introduced in that protocol. In an ideal world and in a\n> NON recurring scheme, the contract should simply be the exact amount to be\n> paid. In our case the exact amount may not be completely known in advance\n> -- for e.g taxes, shipping, pro-rations, \u2026 and so we decided to introduce\n> first a max amount per payment, and also a max amount per period. It is up\n> to the merchant to decide whether to specify none, any or both bounds (max\n> amount per payment and max amount per period). By specifying both, the\n> contract is tighter and the client would feel safer to accept it. In the\n> extreme case, by specifying none, the client would be presented with a\n> contract to pay whatever is requested -- probably not a good option in the\n> Bitcoin world unless there is a high sense of trust with the merchant.\n>   From reading your comments, it appears we have not been clear on how that\n> frequency (PaymentFrequencyType) is being used. Its sole purpose is to\n> define the max amount per period in the contract. The frequency of the\n> payment is implicitly dictated by the merchant but not specified in the\n> protocol by design: the wallet has to poll with a fine granularity (ideally\n> each day when it is up) to understand if there is something pending. In the\n> same way, a specified amount was not enough in the contract, we feel it\n> would be restrictive to specify in advance when payments are due. There are\n> a lot of complex scenarios in the billing space, and having the wallet poll\n> the merchant to inquire for pending payments is the most flexible option\n> and the contract is there to ensure the client will not be abused. To give\n> a concrete example, imagine a data plan where you pay a base recurring\n> price of $70 per month, but you are charged $10 per GB of data used beyond\n> your included limit. If you exceed your limit on the 15th and the 23rd of a\n> given month, two extra payment attempts will be requested by the merchant,\n> that you couldn\u2019t predict (this scenario is often referred to as usage\n> billing with Prepay Credits and Top-up, where the customer pays in advance\n> for blocks of N units, and once they are consumed another N are purchased).*\n>\n>\n> *See answers in your questions inlined below:*\n>\n>\n> I have the following comments:\n>\n>    1. There's no need to serialize RecurringPaymentDetails as bytes here.\n>    It's done that way outside of PaymentDetails in order to support digital\n>    signatures over protobufs that may have extensions the wallet app isn't\n>    aware of, but it's a pain and inside PaymentDetails (and therefore for most\n>    extensions) it shouldn't be necessary. So you can just use \"optional\n>    RecurringPamentDetails recurring_payments = 8;\"\n>\n>\n>\n> OK, we'll fix it.\n>\n>\n>\n>    1. There's only 4 possibilities here for recurrences. That seems\n>    rather restrictive. Is the cost of being more expressive really so high?\n>    Why not allow more flexible specification of periods?\n>\n>\n>    1. If there's no payment_frequency_type field then what happens? A\n>    quirk of protobufs to be aware of is that making an enum field \"required\"\n>    can hurt backwards compatibility. Because it will be expressed using a\n>    languages underlying enum type, if there's a new enum member added later\n>    old software that attempts to deserialize this will throw exceptions\n>    because the new \"unknown\" member would be unrepresentable in the old model.\n>    Making the field optional avoids this problem (it will be treated as\n>    missing instead) but means software needs to be written to know what to do\n>    when it can't read the enum value / sees enum values from the future.\n>\n>\n>\n> I hope the explanation above answers the questions.\n>\n>\n>    1. I assume the amounts are specified in terms of satoshi, and\n>    timestamps are UNIX time, but better to make that explicit.\n>\n>\n>\n> Yes.\n>\n>\n>    1. Seems there's an implicit value constraint that max_payment_amount\n>    <= max_payment_per_period. What happens if that constraint is violated?\n>    Best to document that.\n>\n>\n>\n> As explained above, contract would define none, 1 or both conditions.\n>  First the merchant should not return such 'conditions' but if it does the\n> client should not accept the contract. If the client decides to accept it\n> anyway, then the wallet just verifies both conditions are met separately\n> regardless of whether there is such violation and if so, makes the payment.\n>\n>\n>    1. What's the \"merchant ID\" namespace thing about? What's it for? What\n>    happens if I set my competitors merchant ID there?\n>\n>\n> I agree, we can easily get rid of it.\n>\n>\n>    1. What's the \"subscription ID\"? Is this stuff not\n>    duplicative/redundant with the existing merchant_data field?\n>\n>\n> In an ideal world the merchant should return unique subscriptionId (UUID\n> for instance). That subscriptionId is used in the code to identify the\n> contracts associated with the subscription. The merchant_data if i\n> understand correctly the payment protocol is opaque from the client point\n> of view, so it cannot be used by the client for that purpose.\n>\n>\n>    1. In what situations would you have >1 contract per payment request?\n>    I'm not sure I understand why it's repeated. Presumably if there are zero\n>    contracts included the data should be ignored, or an error thrown and the\n>    entire payment request rejected? Which should it be?\n>\n>\n>\n>\n> There are many example where that could  happen; for instance if you\n> subscribe to a service,  then later decide to downgrade to a lower product.\n> The merchant may decide to only let you downgrade at the end of your paid\n> period-- to avoid generating extra credit-- and in that situation you end\n> up with two contracts: One for the current product you are in and one for\n> the future product you will end up on when the downgrade becomes effective.\n>\n>\n>\n>    1. It's unclear to me given such a contract when the payment should\n>    actually occur. For instance if it's \"monthly\" then what day in the month\n>    would the payment occur?\n>\n>\n>\n> As outlined above in the introduction, the protocol is designed in such a\n> way that the wallet does not have to know what is the exact date when\n> payment should occur, but instead polls the merchant for pending payments.\n> There are many situations when specifying an exact payment date is not an\n> option so that flexibility is essential. A simple example would be for a\n> customer who started subscribing on the 31th of a month. Since there will\n> be months with 28/29/30 days, the payment date would change depending on\n> the month.\n>\n>\n>\n>\n>\n>    1. You'll notice I moved the comments to be above the field\n>    definitions. I know the current proto isn't done that way, but let's change\n>    it - long comments are good and putting them above the field definitions\n>    encourages people to write enough detail without being put off by line\n>    length constraints\n>\n>\n>\n> Fine.\n>\n>\n> I think the next step would be to talk to BitPay/get Jeff+Stephen involved\n> because I know they have customers that really want recurring payments, and\n> those guys will have a clearer idea of customer requirements than we do. I\n> feel uncomfortable with designing or reviewing in a vacuum without some\n> actual people who would use it chiming in, as I don't really know much\n> about the underlying business processes.\n>\n>\n>\n> We are totally open to receive feedbacks from them.. How do we bring them\n> in the discussion?\n>\n>\n> I have some other comments about the bitcoinj implementation specifically\n> - for instance, we don't have a \"wallet directory\" concept: everything goes\n> into the wallet file. So we'll need to think about how to structure the\n> code to allow that. Also, just using a background polling thread is likely\n> not flexible enough, as on some platforms you can't stay running all the\n> time (e.g. Android) without upsetting people, but the underlying OS can\n> wake you up at the right times, so wallet apps should have an ability to\n> control wakeup tasks. But we can discuss that over on the bitcoinj list\n> specifically. Let's keep this thread for the general protocol design.\n>\n>\n> Ok that makes sense.\n>\n>\n> BIP 70 is indeed implemented in Bitcoin Core on the C++ side, so that\n> isn't a concern. It could be done there too.\n>\n>\n> Great to know.\n>\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140226/88923335/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Extension for BIP-0070 to support recurring payments",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Kevin Greene",
                "Mike Hearn",
                "Christophe Biocca",
                "Jeremy Spilman",
                "Stephane Brossier",
                "Drak"
            ],
            "messages_count": 15,
            "total_messages_chars_count": 117921
        }
    },
    {
        "title": "[Bitcoin-development] Embedded consensus system upgrade procedures",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2014-02-09T17:12:14",
                "message_text_only": "The Problem\n===========\n\nWe have an embedded consensus system and we want to be able to upgrade\nit with new rules. There inevitably will be a transition period where\nsome users use clients that interpret the new rules, while others only\ninterpret the old rules. Since we only rely on the host consensus system\nfor timestamped proof-of-publication the the miner-vote soft-fork\nupgrade mechanism;(1) there are no validating miners in the system to\nwhome trust can be outsourced.\n\nWe have a problem: messages encoding actions, such as moving as asset\nfrom one owner to another, can be published on the the blockchain\naccording to new and old rules simultaneously, double-spending the\nasset. Potentially a user with the old v1 software may be tricked into\naccepting an asset when the consensus of the v2 software is that the\nasset has already been spent, and the v1-visible transaction is invalid.\n\n\nSolution\n========\n\nSplit actions into a separate \"decrement\" and \"increment\" operations,\nand ensure that v1 software can see the \"decrement\" of a balance, spend\nof a transaction output etc. even if it does not see the corresponding\nincrement operation. This solves the double-spend problem and ensures v1\nusers can't be ripped off. With obvious analogy to the PoW case, we will\nrefer to this general principle as a embedded consensus system\nsoft-fork.\n\nNote how with the Colored Coins technology this principle happens\nimplicitly and with miner validation: colored coins are valid\ntransaction outputs known to the host consensus system and moving them\nfrom one owner to another is guaranteed to result in the desctruction of\nthe colored coin from the point of view of any older software version.\nOlder software that does not support the newer colored coin kernel\nspecified by the new asset definition will simply see the respective\ncoins be destroyed in invalid transactions. Note how this implies that\nasset definitions created by issuers should be careful to ensure that\nkernels chosen should be designed such that the actioned specified by\none kernel can-not be interpreted differently by another; kernels should\nbe clearly incompatible with each other.\n\n\nBalance-based systems\n=====================\n\nMastercoin is a balance-based system where transactions increment and\ndecrement balances. Being balance-based, and lacking pruning, an even\nsimplier \"scorched earth\" approach will be used where each address is\nassociated with a maximum version number seen by transactions signed by\nthe address. Addresses with a max version number higher than what the\nsoftware understands are considered to be null and have no value of any\nkind. (counterparty would be wise to do the same)\n\n\nUpgrading implementation\n========================\n\nImplementations should record in their databases the blockhash\nassociated with transactions that were not recognized yet affected the\nstate of the consensus. For instance a colored coin implementation\nshould record the blockhash and transaction ID where a given coin was\ndestroyed in an invalid transaction; after upgrading these \"last\ntransaction understood\" markers can be used to replay blockchain data to\narrive at the new consensus.\n\nSimilarly in the case of the Mastercoin system balances associated with\naddresses that have been frozen should be still allowed to increment so\nthat replaying blockchain data from the last recognized transaction\narrives at a upgraded consensus.\n\nAs an aside, any embedded consensus system would be wise to have a way\nof generating a master digest representing the state of the consensus in\nthe database. The Bitcoin Core gettxoutsetinfo command is a good model,\nwhich provides hash_serialized, a digest representing the entire UTXO\nset. In all systems this is useful for ensuring that different\nimplementations and instances have in fact arrived at a consensus.\n\n\n1) BIP-16, Pay to Script Hash,\n   https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140209/af0f5c1e/attachment.sig>"
            },
            {
                "author": "Luke-Jr",
                "date": "2014-02-09T17:25:41",
                "message_text_only": "On Sunday, February 09, 2014 5:12:14 PM Peter Todd wrote:\n> We have an embedded consensus system and we want to be able to upgrade\n> it with new rules.\n\nThis asserts a central authority and gives developers too much power."
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-09T18:09:38",
                "message_text_only": "On Sun, Feb 09, 2014 at 05:25:41PM +0000, Luke-Jr wrote:\n> On Sunday, February 09, 2014 5:12:14 PM Peter Todd wrote:\n> > We have an embedded consensus system and we want to be able to upgrade\n> > it with new rules.\n> \n> This asserts a central authority and gives developers too much power.\n\nPlease, the rule change only can happen if users accept it.\n\nIf anything my proposed mechanism makes it even harder for developers to\nimpose anything by fiat: the spending your digital asset under new rules\ndecreases the amount available of it to trade with users who chose to\naccept only the old rules. Since there is no safety concern involved,\nthe process is safe for both groups, developers can't plea to the\ncommunity that \"OMG the sky will fall and you'll be all defrauded if you\ndon't upgrade right now!!!\" Instead they'll be forced to make it clear\nthat if the community doesn't accept the new rules, whatever assets\nyou've moved to the new system may become forever worthless.\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140209/ac8bba1c/attachment.sig>"
            },
            {
                "author": "Troy Benjegerdes",
                "date": "2014-02-09T18:11:32",
                "message_text_only": "On Sun, Feb 09, 2014 at 05:25:41PM +0000, Luke-Jr wrote:\n> On Sunday, February 09, 2014 5:12:14 PM Peter Todd wrote:\n> > We have an embedded consensus system and we want to be able to upgrade\n> > it with new rules.\n> \n> This asserts a central authority and gives developers too much power.\n\nI don't quite see how, There is nothing that 'forces' me to upgrade,\nunless I have chosen to run an operating system (MacOS, Windows, Android)\nthat have automatic don't-ask-the-user update mechanisms.\n\nThe bigger problem with 'asset transfer' of assets which do not exist \nsoley in the blockchain is including the consensus of relevant local and\ndistributed legal jurisdictions.\n\nFor example, just because the 'colored coin' and blockchain consensus is\nthat I 'electronically' signed a mortgage document giving some random \ninternet company the rights to foreclose on my home does not mean that \nmy local county Judge or Sheriff are going to do anything if the internet\ncompany cannot produce the original paper document with ink signature.\n\nThe only 'assertion' of central authority here is people who download and\nrun the code and submit to whatever the code asserts they are supposed to do.\n\nAt least with the 'central authority' of the big-business bitcoin developer\ncabal I can read the code before I submit to it's central authority, and\nthis is a significant improvement over amgibuous legislation or proprietary\nhigh-frequency trading algorithms."
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-09T18:38:31",
                "message_text_only": "On Sun, Feb 09, 2014 at 12:11:32PM -0600, Troy Benjegerdes wrote:\n> On Sun, Feb 09, 2014 at 05:25:41PM +0000, Luke-Jr wrote:\n> > On Sunday, February 09, 2014 5:12:14 PM Peter Todd wrote:\n> > > We have an embedded consensus system and we want to be able to upgrade\n> > > it with new rules.\n> > \n> > This asserts a central authority and gives developers too much power.\n> \n> I don't quite see how, There is nothing that 'forces' me to upgrade,\n> unless I have chosen to run an operating system (MacOS, Windows, Android)\n> that have automatic don't-ask-the-user update mechanisms.\n> \n> The bigger problem with 'asset transfer' of assets which do not exist \n> soley in the blockchain is including the consensus of relevant local and\n> distributed legal jurisdictions.\n> \n> For example, just because the 'colored coin' and blockchain consensus is\n> that I 'electronically' signed a mortgage document giving some random \n> internet company the rights to foreclose on my home does not mean that \n> my local county Judge or Sheriff are going to do anything if the internet\n> company cannot produce the original paper document with ink signature.\n> \n> The only 'assertion' of central authority here is people who download and\n> run the code and submit to whatever the code asserts they are supposed to do.\n> \n> At least with the 'central authority' of the big-business bitcoin developer\n> cabal I can read the code before I submit to it's central authority, and\n> this is a significant improvement over amgibuous legislation or proprietary\n> high-frequency trading algorithms.\n\nStandard Disclaimer: Digital asset transfer systems are fundementally\nfancy accounting systems; no amount of code can, by itself, make data\nrepresent a physical or legal entity. Only consensus and/or authorities\nin the \"real world\" can do that. Crypto-currencies are only a partial\nexception to that rule, and only because a scarce asset that can be\ntransferred digitally appears to have potential to be broadly useful.\n\nThose considering investing in or otherwise devoting resources to the\ncreation of digital asset transfer systems should be warned that their\nvalue in general remains unproven and losing some or all of your\ninvestment is very possible, even probable. I myself have doubts that\nthese systems serve real-world business needs, but the only way to find\nout is to build them and see.\n\nPeter Todd\nChief Scientist\nMastercoin\n\n\nAnyway, the best we can do is build good tools. Dwelling on the\nunderlying metaphysical nature of what those tools may or may not do\nfrom a social perspective is frankly off-topic on this email list.\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140209/c3d887d7/attachment.sig>"
            },
            {
                "author": "Troy Benjegerdes",
                "date": "2014-02-09T19:02:49",
                "message_text_only": "> > The only 'assertion' of central authority here is people who download and\n> > run the code and submit to whatever the code asserts they are supposed to do.\n> > \n> > At least with the 'central authority' of the big-business bitcoin developer\n> > cabal I can read the code before I submit to it's central authority, and\n> > this is a significant improvement over amgibuous legislation or proprietary\n> > high-frequency trading algorithms.\n> \n> Standard Disclaimer: Digital asset transfer systems are fundementally\n> fancy accounting systems; no amount of code can, by itself, make data\n> represent a physical or legal entity. Only consensus and/or authorities\n> in the \"real world\" can do that. Crypto-currencies are only a partial\n> exception to that rule, and only because a scarce asset that can be\n> transferred digitally appears to have potential to be broadly useful.\n\nHow do I document in the embedded consensus system what the ruling in\na small-claims court about the ownership of a contested asset was?\n\nGood accounting systems (such as mercurial, and proper double-entry \nfinancial accounting tools) allow reverting a bad commit, or bad data\nentry, while maintaining records of the history. Not as good accounting\nsystems (like git) allow you to re-write history. What's the equivalent\nuser interface, process, and wire protocol for reversing a fraudulent\ntransaction while maintaining a full audit trail?\n\nCourts can't legislate our code, and we can't expect them to download\nand trust our 'distributed de-centralized' digital asset tracking system\nthat will be downloaded from a single centralized developer website\nunless we meet them at least halfway, and probably need to propose model\nmunicipal and county ordinances that go along with our code releases.\n\n> Those considering investing in or otherwise devoting resources to the\n> creation of digital asset transfer systems should be warned that their\n> value in general remains unproven and losing some or all of your\n> investment is very possible, even probable. I myself have doubts that\n> these systems serve real-world business needs, but the only way to find\n> out is to build them and see.\n\nI would agree 100% that we need to build them, test the code, use them,\nand then *try them in court*, and make sure we can explain in very simple\nplain language what an 'embedded consensus system' is to the distributed \nde-centralized local court systems."
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2014-02-15T14:43:08",
                "message_text_only": "Not a lawyer, but I don't see what would prevent me from writing contracts like:\n\n\"I owe the holder of this contract 10 usd\" (IOU)\n\n\"I owe the holder of this contract 10 usd in beer\" (voucher)\n\n\"I owe the holder of this p2p asset 10 usd in beer\" (p2p voucher)\n\nOf course, there must be a legal contract outside of the chain for\nthis contracts to be enforceable.\nSome p2p assets will have them and other's won't. Say Alice pays the\ndinner (20 usd) and her friend Bob pays her half of the price in p2p\nusd not legally enforceable IOUs issued by him (10 bob:USD).\nThat's not legally enforceable, so what?\nIf Bob doesn't pay back Alice would lose 10 usd and would not accept\nbob's IOUs anymore, much like it would had happen with a verbal IOU.\nThe difference is that Alice can sell those bob:USD to other people\nwho trust Bob.\n\nDifferent p2p assets have different legal needs.\n\nIn any case, I think Peter summarized it very well:\n\n\"[...]no amount of code can, **by itself**, make data\nrepresent a physical or legal entity. Only consensus and/or authorities\nin the \"real world\" can do that.\"\n\n\nOn 2/9/14, Troy Benjegerdes <hozer at hozed.org> wrote:\n>> > The only 'assertion' of central authority here is people who download\n>> > and\n>> > run the code and submit to whatever the code asserts they are supposed\n>> > to do.\n>> >\n>> > At least with the 'central authority' of the big-business bitcoin\n>> > developer\n>> > cabal I can read the code before I submit to it's central authority,\n>> > and\n>> > this is a significant improvement over amgibuous legislation or\n>> > proprietary\n>> > high-frequency trading algorithms.\n>>\n>> Standard Disclaimer: Digital asset transfer systems are fundementally\n>> fancy accounting systems; no amount of code can, by itself, make data\n>> represent a physical or legal entity. Only consensus and/or authorities\n>> in the \"real world\" can do that. Crypto-currencies are only a partial\n>> exception to that rule, and only because a scarce asset that can be\n>> transferred digitally appears to have potential to be broadly useful.\n>\n> How do I document in the embedded consensus system what the ruling in\n> a small-claims court about the ownership of a contested asset was?\n>\n> Good accounting systems (such as mercurial, and proper double-entry\n> financial accounting tools) allow reverting a bad commit, or bad data\n> entry, while maintaining records of the history. Not as good accounting\n> systems (like git) allow you to re-write history. What's the equivalent\n> user interface, process, and wire protocol for reversing a fraudulent\n> transaction while maintaining a full audit trail?\n>\n> Courts can't legislate our code, and we can't expect them to download\n> and trust our 'distributed de-centralized' digital asset tracking system\n> that will be downloaded from a single centralized developer website\n> unless we meet them at least halfway, and probably need to propose model\n> municipal and county ordinances that go along with our code releases.\n>\n>> Those considering investing in or otherwise devoting resources to the\n>> creation of digital asset transfer systems should be warned that their\n>> value in general remains unproven and losing some or all of your\n>> investment is very possible, even probable. I myself have doubts that\n>> these systems serve real-world business needs, but the only way to find\n>> out is to build them and see.\n>\n> I would agree 100% that we need to build them, test the code, use them,\n> and then *try them in court*, and make sure we can explain in very simple\n> plain language what an 'embedded consensus system' is to the distributed\n> de-centralized local court systems.\n>\n> ------------------------------------------------------------------------------\n> Managing the Performance of Cloud-Based Applications\n> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> Read the Whitepaper.\n> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n\n\n-- \nJorge Tim\u00f3n\n\nhttp://freico.in/"
            }
        ],
        "thread_summary": {
            "title": "Embedded consensus system upgrade procedures",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Luke-Jr",
                "Troy Benjegerdes",
                "Jorge Tim\u00f3n",
                "Peter Todd"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 16915
        }
    },
    {
        "title": "[Bitcoin-development] Decentralized digital asset exchange with honest pricing and market depth",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2014-02-09T18:04:58",
                "message_text_only": "Alex Mizrahi recently outlined a mechanism(1) based on SIGHASH_SINGLE\nthat allows colored coins and similar embedded consensus system assets\nto be securely transferred to another party in exchange for Bitcoins\natomically. In summary his p2p 2-step-trade mechanism operates as\nfollows:\n\nAlice controls a colored txout and wishes to sell it for 1BTC. Bob\nwishes to buy that txout.\n\nAlice signs a scriptSig using SIGHASH_SINGLE|ANYONECANPAY for a\ntransaction with a that time. (albeit a offer floor) single input, the\ncolored txout, and a single output with a scriptPubKey she controls and\nnValue=1 This transaction is not valid as the value out is greater than\nthe value in.\n\nShe gives this partial transaction to Bob. He can now complete the\ntransaction by providing one or more inputs with a sum value >=1BTC, one\noutput for the colored coins to be directed to, and optionally any other\noutputs required. (for instance for change)\n\nBob signs his inputs with SIGHASH_ALL and broadcasts the transaction,\ncompleting the trade.\n\nWhat Alice has signed, the first txin scriptSig, guarantees that if the\ncolored txout is spent she will receive 1BTC. Meanwhile what Bob has\nsigned, all other txin scriptSigs, sign the colored input and output,\nguaranteeing that he will receive his coin in exchange for his money.\nThus the trade is trust free and atomic.\n\n\nDecentralized markets and honest pricing\n========================================\n\nWe can extend Mizrahi's 2-step-trade mechanism to create a decentralized\nmarketplace. First of all, remember that traders wishing to sell their\nassets want to be sure that their assets offers reach the 100% of the\naudience who may wish to buy said assets; an attacker may try to\nmanipulate the market to depress the price of an asset by hiding offers\nfrom potential buyers. Similarly buyers want assurance that the offers\nthey are responding to represent all offers available.\n\nProof-of-publication(2) offers a solution. Alice can embed her\nincomplete transaction as data in a second, valid, transaction. She\nbroadcasts this secondary transaction to some agreed upon blockchain,\neither the one the colored coin is in, or potentially a secondary system\nwith suitable proof-of-publication security. Bidders such as Bob can now\nscan the blockchain for offers with an acceptable price. (the offers can\nmake use of techniques like prefix filters to allow Bob to only scan\npart of the blockchain, although Bob needs to know the status of all\nassets of the type he is interested in anyway)\n\nThere is still some potential for manipulation with very recent offers,\nparticularly those embedded in unconfirmed transactions. However\ntypically markets have a large number of long-standing offers, which in\nthis case would be committed to the blockchain with one or more\nconfirmations.\n\nInterestingly such a system can also provide honest historical pricing\ninformation: any offer that goes unfilled for one or more blocks has (in\ntheory) been honestly published to 100% of those watching the blockchain\nat that time. Thus we can assume the unfufilled offers at any\ngiven block height are honest information about the market at that time\nhistorically.\n\nThe overhead involved involved in Alice publishing the offer is roughly\na doubling of the overall transaction fees consumed. (remember that the\noffer transaction is incomplete, and about half the size of the\nacceptance transaction)\n\n\nApplication to other embedded consensus systems\n===============================================\n\nAny embedded consensus system can make use of the 2-step-trade mechanism\nso long as it is possible to create transactions where spending a single\ntransaction output moves an asset appropriately.\n\nUnfortunately extending this to circumstances where more than one input\nneeds to be spent, or more than out output needs to be created, is\ndifficult. SIGHASH_SINGLE by itself results in a signature where the\nindex of the output is signed, but the contents - scriptPubKey and\nnValue - of all other outputs is not signed. Meanwhile all transaction\ninputs are signed and changes to that set, other than modifying the\nnSequence value in each CTxIn, is not possible.\n\nIf there was a SIGHASH mode that merely truncated vin and vout based on\nthe index of the scriptSig we could commit to data in either, but\nunfortunately we can't do that.\n\nAn alternative could be to create a mechanism where some embedded data\nsignified the creation of a temporary transfer txout, where spending\nthat txout made the underlying change desired in the consensus state\natomically.\n\n\n1) Alex Mizrahi, color kernel design considerations, Jan 7th 2014,\n   Colored coins (BitcoinX) mailing list,\n   https://groups.google.com/d/msg/bitcoinx/pON4XCIBeV4/IvzwkU8Vch0J\n\n2) Peter Todd, [Bitcoin-development] Disentangling Crypto-Coin Mining:\n   Timestamping, Proof-of-Publication, and Validation, Nov 19 2013,\n   https://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg03307.html\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140209/8c5bec2d/attachment.sig>"
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-09T20:44:34",
                "message_text_only": "On Sun, Feb 09, 2014 at 01:04:58PM -0500, Peter Todd wrote:\n> Alex Mizrahi recently outlined a mechanism(1) based on SIGHASH_SINGLE\n> that allows colored coins and similar embedded consensus system assets\n> to be securely transferred to another party in exchange for Bitcoins\n> atomically. In summary his p2p 2-step-trade mechanism operates as\n> follows:\n\nI'm told there's probably at least one if not more earlier\nattributions/reinventions for the 2-step-trade protocol using\nSIGHASH_SINGLE. Please reply with them if you have them so we can give\ncredit where credit is due.\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000001465bc2730ffed7493d166d18d288f6cf15e8cdb5d4a3c7b1\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140209/ce15a7d6/attachment.sig>"
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-10T19:32:47",
                "message_text_only": "On Sun, Feb 09, 2014 at 03:44:34PM -0500, Peter Todd wrote:\n> On Sun, Feb 09, 2014 at 01:04:58PM -0500, Peter Todd wrote:\n> > Alex Mizrahi recently outlined a mechanism(1) based on SIGHASH_SINGLE\n> > that allows colored coins and similar embedded consensus system assets\n> > to be securely transferred to another party in exchange for Bitcoins\n> > atomically. In summary his p2p 2-step-trade mechanism operates as\n> > follows:\n> \n> I'm told there's probably at least one if not more earlier\n> attributions/reinventions for the 2-step-trade protocol using\n> SIGHASH_SINGLE. Please reply with them if you have them so we can give\n> credit where credit is due.\n\nGot this:\n\nMessage-ID: <52418EBA.3080602 at monetize.io>\nDate: Tue, 24 Sep 2013 06:08:10 -0700\nFrom: Mark Friedenbach <mark at monetize.io>\nOrganization: Monetize.io Inc.\nTo: Meni Rosenfeld <meni at bitcoil.co.il>\nSubject: Re: Freimarkets and investment\n\nIf assets were tagged you could do a very limited form of pre-signed offers:\n\nin: 10 btc SINGLE|ANYONECANPAY\nout: 1 AAA\n\nThese are composable, in that you can append the inputs and outputs of\nmultiple offers together and result in a valid transaction. However this\nis pretty much the limit of what is possible without adding new SIGHASH\nmodes, and if you're going to hard-fork to add tagging, then you might\nas well go the whole distance with explicit hierarchical\nsub-transactions as we did with Freimarkets.\n\nCheers,\nMark\n\nOn 9/24/13 5:44 AM, Meni Rosenfeld wrote:\n> Hi Jorge,\n> \n> The video was sent to me by Amos Meiri, I think eToro funded its production.\n> \n> Maybe I don't understand SIGHASH_ANYONECANPAY very well. In the\n> transaction, there will be an output of 1 \"my stock\" to an initially\n> unknown address. Can I provide a signature for my input of 1 \"my stock\"\n> that will be valid even with the output details provided later?\n> \n> In any case, I think that's out of scope for the presentation.\n> \n> Meni\n> \n> On 24/09/2013 13:10, Jorge Tim\u00f3n wrote:\n>> Yes, it's a nice presentation.\n>> I love the video with the chameleons that you link at the end !!\n>>\n>> As a little sugestion, I think the biggest advantage of tagging is not\n>> inflatable assets, it's open binding orders. Even without granular\n>> subtransactions as freimarket has, you could sign your input (say,\n>> representing 1 \"My stock\") and only the output you're interested in\n>> (say 100 bitstampUSD to myAddress) with SIGHASH_SINGLE |\n>> SIGHASH_ANYONECANPAY.\n>>\n>> Without tagging, you need to know where the inputs come from to check\n>> they're really bitstampUSD, because the network won't enforce the \"100\n>> bistampUSD\" in your output, any uncolored coins filling the btc\n>> quantity you wanted to represent those 100 usd will be ok, for miners.\n>>\n>> Goog luck with the talk, I'm eager to hear it.\n>>\n>> By the way, Mark, the explanation of the blockchain image sounds a\n>> little bit like hashcasttle, no? well, just merged mining every new\n>> asset, sounds like jaromil's freecoin too.\n>>\n>>\n>> On 9/24/13, Meni Rosenfeld <meni at bitcoil.co.il> wrote:\n>>> Hi Mark,\n>>>\n>>> We currently have a more general mathematical framework for the concept of\n>>> colored coins - a color is a combination of initial state and a kernel\n>>> function that maps input colors to output colors. Order-based coloring is\n>>> one such kernel function, tagging is another. As long as you can point at an\n>>> output and say what its color is, we call it a colored coin system.\n>>>\n>>> The blockchain image is a stand-in for \"using a new block chain for each\n>>> asset\".\n>>>\n>>> Meni\n>>>\n>>> On 24/09/2013 00:42, Mark Friedenbach wrote:\n> Hi Meni,\n> \n> I did call Freimarkets \"colored coins\" in the early days, but the term\n> colored coin itself within the community seems to have become\n> identified with the specific proposal of assigning value to specific\n> satoshis, and running an order based coloring algorithm to determine\n> asset flow, e.g. Bitcoin-X. Freimarkets allows issuance of entirely\n> new assets and has explicit tagging of outputs, so we decided to avoid\n> the phrase \"colored coin\" so as to keep from confusing people. But as\n> an academic, yes you are correct.\n> \n> You presentation looks great. BTW, what's the first logo for the\n> \"Alternative token systems\" slide? Or is that just a stand-in for the\n> block chain?\n> \n> Mark\n> \n> On 9/23/13 12:24 PM, Meni Rosenfeld wrote:\n>>>>>> Hi,\n>>>>>>\n>>>>>> As you might know I'm giving a talk about Colored Coins in\n>>>>>> Amsterdam.\n>>>>>>\n>>>>>> My presentation is available at\n>>>>>> https://bitcoil.co.il/files/Colored Coins.pptx (I'm not posting\n>>>>>> this link publicly until after the talk).\n>>>>>>\n>>>>>> I'll be happy for any feedback.\n>>>>>>\n>>>>>> I'm listing Freimarkets as an implementation of Colored Coins. It\n>>>>>> doesn't look like you're identifying with the term, but it does fit\n>>>>>> the definition (and though it does obviously do much more than\n>>>>>> just implement colored coins.)\n>>>>>>\n>>>>>> Thanks, Meni\n>>>>\n>>>\n>>\n> \n\n-- \n'peter'[:-1]@petertodd.org\n0000000076654614e7bf72ac80d47c57bca12503989f4d602538d3cd7892ca7d\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140210/a482ab35/attachment.sig>"
            },
            {
                "author": "Troy Benjegerdes",
                "date": "2014-02-11T17:59:19",
                "message_text_only": "Is there any code that does this? I would like to develop a multicoin-qt\nwallet that runs on two blockchains from one binary, and allows trading\nusing this mechanism between the two chains.\n\nOn Mon, Feb 10, 2014 at 02:32:47PM -0500, Peter Todd wrote:\n> On Sun, Feb 09, 2014 at 03:44:34PM -0500, Peter Todd wrote:\n> > On Sun, Feb 09, 2014 at 01:04:58PM -0500, Peter Todd wrote:\n> > > Alex Mizrahi recently outlined a mechanism(1) based on SIGHASH_SINGLE\n> > > that allows colored coins and similar embedded consensus system assets\n> > > to be securely transferred to another party in exchange for Bitcoins\n> > > atomically. In summary his p2p 2-step-trade mechanism operates as\n> > > follows:\n> > \n> > I'm told there's probably at least one if not more earlier\n> > attributions/reinventions for the 2-step-trade protocol using\n> > SIGHASH_SINGLE. Please reply with them if you have them so we can give\n> > credit where credit is due.\n> \n> Got this:\n> \n> Message-ID: <52418EBA.3080602 at monetize.io>\n> Date: Tue, 24 Sep 2013 06:08:10 -0700\n> From: Mark Friedenbach <mark at monetize.io>\n> Organization: Monetize.io Inc.\n> To: Meni Rosenfeld <meni at bitcoil.co.il>\n> Subject: Re: Freimarkets and investment\n> \n> If assets were tagged you could do a very limited form of pre-signed offers:\n> \n> in: 10 btc SINGLE|ANYONECANPAY\n> out: 1 AAA\n> \n> These are composable, in that you can append the inputs and outputs of\n> multiple offers together and result in a valid transaction. However this\n> is pretty much the limit of what is possible without adding new SIGHASH\n> modes, and if you're going to hard-fork to add tagging, then you might\n> as well go the whole distance with explicit hierarchical\n> sub-transactions as we did with Freimarkets.\n> \n> Cheers,\n> Mark\n> \n> On 9/24/13 5:44 AM, Meni Rosenfeld wrote:\n> > Hi Jorge,\n> > \n> > The video was sent to me by Amos Meiri, I think eToro funded its production.\n> > \n> > Maybe I don't understand SIGHASH_ANYONECANPAY very well. In the\n> > transaction, there will be an output of 1 \"my stock\" to an initially\n> > unknown address. Can I provide a signature for my input of 1 \"my stock\"\n> > that will be valid even with the output details provided later?\n> > \n> > In any case, I think that's out of scope for the presentation.\n> > \n> > Meni\n> > \n> > On 24/09/2013 13:10, Jorge Tim\u00f3n wrote:\n> >> Yes, it's a nice presentation.\n> >> I love the video with the chameleons that you link at the end !!\n> >>\n> >> As a little sugestion, I think the biggest advantage of tagging is not\n> >> inflatable assets, it's open binding orders. Even without granular\n> >> subtransactions as freimarket has, you could sign your input (say,\n> >> representing 1 \"My stock\") and only the output you're interested in\n> >> (say 100 bitstampUSD to myAddress) with SIGHASH_SINGLE |\n> >> SIGHASH_ANYONECANPAY.\n> >>\n> >> Without tagging, you need to know where the inputs come from to check\n> >> they're really bitstampUSD, because the network won't enforce the \"100\n> >> bistampUSD\" in your output, any uncolored coins filling the btc\n> >> quantity you wanted to represent those 100 usd will be ok, for miners.\n> >>\n> >> Goog luck with the talk, I'm eager to hear it.\n> >>\n> >> By the way, Mark, the explanation of the blockchain image sounds a\n> >> little bit like hashcasttle, no? well, just merged mining every new\n> >> asset, sounds like jaromil's freecoin too.\n> >>\n> >>\n> >> On 9/24/13, Meni Rosenfeld <meni at bitcoil.co.il> wrote:\n> >>> Hi Mark,\n> >>>\n> >>> We currently have a more general mathematical framework for the concept of\n> >>> colored coins - a color is a combination of initial state and a kernel\n> >>> function that maps input colors to output colors. Order-based coloring is\n> >>> one such kernel function, tagging is another. As long as you can point at an\n> >>> output and say what its color is, we call it a colored coin system.\n> >>>\n> >>> The blockchain image is a stand-in for \"using a new block chain for each\n> >>> asset\".\n> >>>\n> >>> Meni\n> >>>\n> >>> On 24/09/2013 00:42, Mark Friedenbach wrote:\n> > Hi Meni,\n> > \n> > I did call Freimarkets \"colored coins\" in the early days, but the term\n> > colored coin itself within the community seems to have become\n> > identified with the specific proposal of assigning value to specific\n> > satoshis, and running an order based coloring algorithm to determine\n> > asset flow, e.g. Bitcoin-X. Freimarkets allows issuance of entirely\n> > new assets and has explicit tagging of outputs, so we decided to avoid\n> > the phrase \"colored coin\" so as to keep from confusing people. But as\n> > an academic, yes you are correct.\n> > \n> > You presentation looks great. BTW, what's the first logo for the\n> > \"Alternative token systems\" slide? Or is that just a stand-in for the\n> > block chain?\n> > \n> > Mark\n> > \n> > On 9/23/13 12:24 PM, Meni Rosenfeld wrote:\n> >>>>>> Hi,\n> >>>>>>\n> >>>>>> As you might know I'm giving a talk about Colored Coins in\n> >>>>>> Amsterdam.\n> >>>>>>\n> >>>>>> My presentation is available at\n> >>>>>> https://bitcoil.co.il/files/Colored Coins.pptx (I'm not posting\n> >>>>>> this link publicly until after the talk).\n> >>>>>>\n> >>>>>> I'll be happy for any feedback.\n> >>>>>>\n> >>>>>> I'm listing Freimarkets as an implementation of Colored Coins. It\n> >>>>>> doesn't look like you're identifying with the term, but it does fit\n> >>>>>> the definition (and though it does obviously do much more than\n> >>>>>> just implement colored coins.)\n> >>>>>>\n> >>>>>> Thanks, Meni\n> >>>>\n> >>>\n> >>\n> > \n> \n> -- \n> 'peter'[:-1]@petertodd.org\n> 0000000076654614e7bf72ac80d47c57bca12503989f4d602538d3cd7892ca7d\n\n\n\n> ------------------------------------------------------------------------------\n> Androi apps run on BlackBerry 10\n> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.\n> Now with support for Jelly Bean, Bluetooth, Mapview and more.\n> Get your Android app in front of a whole new audience.  Start now.\n> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk\n\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-14T05:21:59",
                "message_text_only": "On Tue, Feb 11, 2014 at 11:59:19AM -0600, Troy Benjegerdes wrote:\n> Is there any code that does this? I would like to develop a multicoin-qt\n> wallet that runs on two blockchains from one binary, and allows trading\n> using this mechanism between the two chains.\n\nCross-chain trading is a different thing entirely; it doesn't allow for\nthe clever 2-party-trade trick. (as far as I know)\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000000c34e2307bf2d8e1de9db0351acfe7320a08826a5de3c146a\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140214/51eae451/attachment.sig>"
            },
            {
                "author": "Troy Benjegerdes",
                "date": "2014-02-17T05:47:51",
                "message_text_only": "On Fri, Feb 14, 2014 at 12:21:59AM -0500, Peter Todd wrote:\n> On Tue, Feb 11, 2014 at 11:59:19AM -0600, Troy Benjegerdes wrote:\n> > Is there any code that does this? I would like to develop a multicoin-qt\n> > wallet that runs on two blockchains from one binary, and allows trading\n> > using this mechanism between the two chains.\n> \n> Cross-chain trading is a different thing entirely; it doesn't allow for\n> the clever 2-party-trade trick. (as far as I know)\n\nIs there a simple way to do cross-chain trades that doesn't need a third \nchain to somehow facilitate things?"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2014-02-27T23:48:33",
                "message_text_only": "First of all, sorry for the delayed answer.\n\nOn 2/10/14, Peter Todd <pete at petertodd.org> wrote:\n> Got this:\n[...]\nThank you, I knew this wasn't new for us but I doubted we had written\nit anywhere.\nAs said in those mails, being only able to offer AAA for BTC and not\nBTC for AAA nor AAA for BBB is enough of a limitation to justify a\nhardfork IMO.\n\nOn 2/17/14, Troy Benjegerdes <hozer at hozed.org> wrote:\n> Is there a simple way to do cross-chain trades that doesn't need a third\n> chain to somehow facilitate things?\n\nThese are the two methods I know for cross-chain trading (no third\nchain needed in any of them):\n\nhttps://en.bitcoin.it/wiki/Contracts#Example_5:_Trading_across_chains\nhttps://bitcointalk.org/index.php?topic=321228\n\nOn 2/14/14, Peter Todd <pete at petertodd.org> wrote:\n> You're assuming the seller cares about fairness - why should they? They\n> offered a price for an asset and someone bought it; exactly which buyer\n> willing to buy at that price was able to complete the trade is\n> irrelevant to them. What they do care about is being sure that at\n> whatever given price they offered 100% of the buyers willing to buy at\n> that price actually see the offer in a reasonable amount of time - at\n> the best price the seller will get there will be only a single buyer\n> after all so you need that solid proof that said buyer was actually able\n> to get the offer.\n\nIn fact, I don't think the seller will care enough about this to pay\nthe proof of publication fee either. Assuming sellers can either\nbroadcast the order on a bitmessage-like network or use your proof of\npublication scheme, the later will be always be more expensive. So my\nprediction is that most people will just use the simplest, fastest and\ncheapest method, but I guess only time can tell.\nI don't think this will be a tragedy, because like we discussed on\nIRC, I don't think the primary goal of markets is price discovery, but\ntrade itself.\n\nAbout historic data, the actual trades are always public, and some\nkind of \"archivers\" could collect and maintain old orders for historic\nbid and asks, etc.\n\nAs an aside, nLockTime would be nice not to always have to\ndouble-spend the inputs of an order to cancel it.\n\n-- \nJorge Tim\u00f3n\n\nhttp://freico.in/"
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-28T01:37:19",
                "message_text_only": "On Fri, Feb 28, 2014 at 12:48:33AM +0100, Jorge Tim\u00f3n wrote:\n> First of all, sorry for the delayed answer.\n> \n> On 2/10/14, Peter Todd <pete at petertodd.org> wrote:\n> > Got this:\n> [...]\n> Thank you, I knew this wasn't new for us but I doubted we had written\n> it anywhere.\n> As said in those mails, being only able to offer AAA for BTC and not\n> BTC for AAA nor AAA for BBB is enough of a limitation to justify a\n> hardfork IMO.\n\nAs usual, you don't need a hardfork.\n\nAnyway, one-sided trade is sufficient to get a functioning marketplace\nup and running and test out the many other issues with this stuff prior\nto forking anything.\n\n> On 2/14/14, Peter Todd <pete at petertodd.org> wrote:\n> > You're assuming the seller cares about fairness - why should they? They\n> > offered a price for an asset and someone bought it; exactly which buyer\n> > willing to buy at that price was able to complete the trade is\n> > irrelevant to them. What they do care about is being sure that at\n> > whatever given price they offered 100% of the buyers willing to buy at\n> > that price actually see the offer in a reasonable amount of time - at\n> > the best price the seller will get there will be only a single buyer\n> > after all so you need that solid proof that said buyer was actually able\n> > to get the offer.\n> \n> In fact, I don't think the seller will care enough about this to pay\n> the proof of publication fee either. Assuming sellers can either\n> broadcast the order on a bitmessage-like network or use your proof of\n> publication scheme, the later will be always be more expensive. So my\n> prediction is that most people will just use the simplest, fastest and\n> cheapest method, but I guess only time can tell.\n\nYou can make the same argument against Bitcoin itself you know...\n\nA Bitmessage-like network would be trivial to front-run via a sybil\nattack. It's the fundemental problem with marketplaces - the data\nthey're trying to publish has to be public.\n\n> I don't think this will be a tragedy, because like we discussed on\n> IRC, I don't think the primary goal of markets is price discovery, but\n> trade itself.\n>\n> About historic data, the actual trades are always public, and some\n> kind of \"archivers\" could collect and maintain old orders for historic\n> bid and asks, etc.\n\nAnd again, how do you know that record is honest? Fact is without\nproof-of-publication you just don't.\n\n> As an aside, nLockTime would be nice not to always have to\n> double-spend the inputs of an order to cancel it.\n\nYou mean a reverse nLockTime that makes a transaction invalid after a\ncertain amount of time - that's dangerous in a reorg unfortunately as it\ncan make transactions permenantly invalid.\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000000b52709f0485161e764ac0198960885ccab019a978322cc6e\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140227/58a08669/attachment.sig>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2014-02-28T17:49:52",
                "message_text_only": "On 2/28/14, Peter Todd <pete at petertodd.org> wrote:\n> As usual, you don't need a hardfork.\n>\n> Anyway, one-sided trade is sufficient to get a functioning marketplace\n> up and running and test out the many other issues with this stuff prior\n> to forking anything.\n\nI'm totally FOR experimenting with this as it is and I'm happy that\nAlex/Killerstorm is working on \"regular\" colored coins.\n\n> You can make the same argument against Bitcoin itself you know...\n>\n> A Bitmessage-like network would be trivial to front-run via a sybil\n> attack. It's the fundemental problem with marketplaces - the data\n> they're trying to publish has to be public.\n\nI don't see the Bitcoin analogy...\nAnyway, I still don't think the seller cares, if he sells at the price\nhe was asking, what would he care about \"front running\" those parallel\nnetworks.\nI've seen many street markets without \"public information\" and they\nwork just well.\n\n>> I don't think this will be a tragedy, because like we discussed on\n>> IRC, I don't think the primary goal of markets is price discovery, but\n>> trade itself.\n>>\n>> About historic data, the actual trades are always public, and some\n>> kind of \"archivers\" could collect and maintain old orders for historic\n>> bid and asks, etc.\n>\n> And again, how do you know that record is honest? Fact is without\n> proof-of-publication you just don't.\n\nWell, the trades that appeared in the chain actually occurred.\nBuying to yourself at fake prices? Be careful, the miner could just\nseparate the order and fill it himself. Or anyone paying a higher fee,\nfor that matter.\nAgain, you haven't addressed why the seller cares more about \"accurate\nhistoric market data\" than just his own fees and sell.\n\n> You mean a reverse nLockTime that makes a transaction invalid after a\n> certain amount of time - that's dangerous in a reorg unfortunately as it\n> can make transactions permenantly invalid.\n\nYes, I'm aware this is a concern for many people and that's why I\nbring it up when there's an useful use case (we have several important\nuses in freimarkets).\nProbably this belongs to another thread or just #wizards, but if I\nremember correctly, the last discussion we had about this, I think\nwith you and gmaxwell, was more or less like this:\n\n-Valid transactions could get invalid with a regorg\n-Just like with any transaction if a double-spend appears, this just\nmeans that you would need to wait for expiry transactions to be\nsomewhat buried to accept payments from it.\n-That introduces fungibility problems.\n-True, but doesn't seem a particularly difficult problem (I think we\nactually drafted some potential solutions, like introducing a maturity\nrule for expiry transactions) and the advantages outweigh that\npotential problem IMO.\n\nSo in summary, I feel like before actually solving the problem we need\nto rise more awareness on how nice and necessary nExpiryTime would be.\nAnyway, sorry, I just wanted to point out another use, a deeper\ndiscussion about this belongs to another thread.\n\n-- \nJorge Tim\u00f3n\n\nhttp://freico.in/"
            },
            {
                "author": "Dan Carter",
                "date": "2014-02-12T16:34:48",
                "message_text_only": "I'm not sure how well this would work.\n\nSure it would provide honest historical pricing, but those who wait for \npublication confirmation may be at a disadvantage -- to get the best \ndeal possible Bob would connect to as many nodes as he could, examine \nthe stream of unconfirmed asks coming in and sign the best ones before \nsomeone else does.  The network would gravitate towards an O(n^2) fully \nconnected network, because being fully connected means one is fully \naware of all unconfirmed asks at any moment so one can make the best \njudgement and buy before someone else does.\n\nThe seller needs a guarantee that all bidders can act on the ask \ntransaction simultaneously. Maybe the partial ask transaction could be \ntime-locked with a network propagation delay, there would be multiple \nbidder responses and the winner is chosen by lottery (and fee priority) \nby the bitcoin/alt-coin miner who confirms the atomic transaction in \ntheir block.  That would eliminate the advantage to being fully \nconnected as it would no longer matter that one can act first, so you \nhave a more sane network.\n\nOn 2014-02-09 10:04 AM, Peter Todd wrote:\n> Proof-of-publication(2) offers a solution. Alice can embed her\n> incomplete transaction as data in a second, valid, transaction. She\n> broadcasts this secondary transaction to some agreed upon blockchain,\n> either the one the colored coin is in, or potentially a secondary system\n> with suitable proof-of-publication security. Bidders such as Bob can now\n> scan the blockchain for offers with an acceptable price. (the offers can\n> make use of techniques like prefix filters to allow Bob to only scan\n> part of the blockchain, although Bob needs to know the status of all\n> assets of the type he is interested in anyway)"
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-14T05:20:36",
                "message_text_only": "On Wed, Feb 12, 2014 at 08:34:48AM -0800, Dan Carter wrote:\n> I'm not sure how well this would work.\n> \n> Sure it would provide honest historical pricing, but those who wait for \n> publication confirmation may be at a disadvantage -- to get the best \n> deal possible Bob would connect to as many nodes as he could, examine \n> the stream of unconfirmed asks coming in and sign the best ones before \n> someone else does.  The network would gravitate towards an O(n^2) fully \n> connected network, because being fully connected means one is fully \n> aware of all unconfirmed asks at any moment so one can make the best \n> judgement and buy before someone else does.\n> \n> The seller needs a guarantee that all bidders can act on the ask \n> transaction simultaneously. Maybe the partial ask transaction could be \n> time-locked with a network propagation delay, there would be multiple \n> bidder responses and the winner is chosen by lottery (and fee priority) \n> by the bitcoin/alt-coin miner who confirms the atomic transaction in \n> their block.  That would eliminate the advantage to being fully \n> connected as it would no longer matter that one can act first, so you \n> have a more sane network.\n\nYou're assuming the seller cares about fairness - why should they? They\noffered a price for an asset and someone bought it; exactly which buyer\nwilling to buy at that price was able to complete the trade is\nirrelevant to them. What they do care about is being sure that at\nwhatever given price they offered 100% of the buyers willing to buy at\nthat price actually see the offer in a reasonable amount of time - at\nthe best price the seller will get there will be only a single buyer\nafter all so you need that solid proof that said buyer was actually able\nto get the offer.\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000000c34e2307bf2d8e1de9db0351acfe7320a08826a5de3c146a\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140214/06fddd97/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Decentralized digital asset exchange with honest pricing and market depth",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Dan Carter",
                "Troy Benjegerdes",
                "Jorge Tim\u00f3n",
                "Peter Todd"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 31403
        }
    },
    {
        "title": "[Bitcoin-development] [RFC] [BIP proposal] Dealing with malleability",
        "thread_messages": [
            {
                "author": "Pieter Wuille",
                "date": "2014-02-09T23:33:02",
                "message_text_only": "Hello all,\n\nit was something I planned to do since a long time, but with the\nrecent related issues popping up, I finally got around to writing a\nBIP about how we can get rid of transaction malleability over time.\n\nThe proposed document is here: https://gist.github.com/sipa/8907691\n\nI expect most rules to not be controversial. Maybe rules 1 and 3, as\nthey require modifications to wallet software (Bitcoin Core 0.9 and\nBitcoinJ already implement it, though) and potentially invalidate some\nscript functionality. However, these new rules remain optional and\ncontrolled by an nVersion increase.\n\nComments please!\n\n-- \nPieter"
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-10T03:00:48",
                "message_text_only": "On Mon, Feb 10, 2014 at 12:33:02AM +0100, Pieter Wuille wrote:\n> Hello all,\n> \n> it was something I planned to do since a long time, but with the\n> recent related issues popping up, I finally got around to writing a\n> BIP about how we can get rid of transaction malleability over time.\n> \n> The proposed document is here: https://gist.github.com/sipa/8907691\n> \n> I expect most rules to not be controversial. Maybe rules 1 and 3, as\n> they require modifications to wallet software (Bitcoin Core 0.9 and\n> BitcoinJ already implement it, though) and potentially invalidate some\n> script functionality. However, these new rules remain optional and\n> controlled by an nVersion increase.\n> \n> Comments please!\n\nYou should probably add making CHECKMULTISIG require the dummy value to\nbe exactly equal to OP_FALSE; verifying that in the transaction itself is\nlaborious. A more subtle example is we may want both CHECKSIG and\nCHECKMULTISIG to fail the transaction if the signature is invalid but\nnot exactly equal to OP_FALSE; some transaction forms are significantly\nmore compact if you can have failed signatures, but that's a source of\nmalleability. (are there counter examples people can think of?)\n\n\nBut as I said on IRC, I'm a bit hesitant to bake in assumptions about\nmalleability when we have no solid idea if ECC signatures are or are not\nmalleable on a fundemental level; if \"whack-a-mole\" anti-malleability is\nall we've got it could be ugly if a break is found. Similarly, we may\nfind we missed something, or some needed change makes the malleability\nrules difficult to work with for some new script type that is required.\n\nI'd rather see a new CHECKSIG mode for the case where malleability\nabsolutely must be eliminated - certain multi-party protocols - and fix\nwallet software instead. (the malleability problems people see are\nclosely related to inability to handle double-spends and reorgs) But I\ncan easily see that being an impossible goal engineering wise...\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000001465bc2730ffed7493d166d18d288f6cf15e8cdb5d4a3c7b1\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140209/a2c80f9b/attachment.sig>"
            },
            {
                "author": "Rune Kj\u00e6r Svendsen",
                "date": "2014-02-12T15:12:25",
                "message_text_only": "Instead of trying to remove the possibility of transaction\nmalleability, would it make sense to define a new, \"canonical\ntransaction hash/ID\" (cTxID), which would be a hash of the part of the\ntransaction data which we know is not malleable, and have clients use\nthis cTxID internally, thus making the traditional transaction hash\nirrelevant for a client to function correctly?\n\nWe already have a non-malleable transaction hash: the hash that is\nsigned, ie. the transaction with each scriptSig replaced by the\nscriptPubKey it redeems. This could be the cTxID.\n\nOr is this simply a too fundamental change to the way bitcoin-qt (and\nall other clients) work in order to be feasible?\n\nAs far as I can see, it completely solves the issue of not having a\ncanonical ID for a transaction, but it also increases the\ncomputational requirements for a node. For one, as far as I can see,\nit requires the node to index all transactions, because in order to\ncalculate a cTxID, it would be necessary to fetch all transactions\nreferred to by the transaction in question, in order to pull in the\nscriptPubKeys that are redeemed.\n\n\nOn Mon, Feb 10, 2014 at 4:00 AM, Peter Todd <pete at petertodd.org> wrote:\n> On Mon, Feb 10, 2014 at 12:33:02AM +0100, Pieter Wuille wrote:\n>> Hello all,\n>>\n>> it was something I planned to do since a long time, but with the\n>> recent related issues popping up, I finally got around to writing a\n>> BIP about how we can get rid of transaction malleability over time.\n>>\n>> The proposed document is here: https://gist.github.com/sipa/8907691\n>>\n>> I expect most rules to not be controversial. Maybe rules 1 and 3, as\n>> they require modifications to wallet software (Bitcoin Core 0.9 and\n>> BitcoinJ already implement it, though) and potentially invalidate some\n>> script functionality. However, these new rules remain optional and\n>> controlled by an nVersion increase.\n>>\n>> Comments please!\n>\n> You should probably add making CHECKMULTISIG require the dummy value to\n> be exactly equal to OP_FALSE; verifying that in the transaction itself is\n> laborious. A more subtle example is we may want both CHECKSIG and\n> CHECKMULTISIG to fail the transaction if the signature is invalid but\n> not exactly equal to OP_FALSE; some transaction forms are significantly\n> more compact if you can have failed signatures, but that's a source of\n> malleability. (are there counter examples people can think of?)\n>\n>\n> But as I said on IRC, I'm a bit hesitant to bake in assumptions about\n> malleability when we have no solid idea if ECC signatures are or are not\n> malleable on a fundemental level; if \"whack-a-mole\" anti-malleability is\n> all we've got it could be ugly if a break is found. Similarly, we may\n> find we missed something, or some needed change makes the malleability\n> rules difficult to work with for some new script type that is required.\n>\n> I'd rather see a new CHECKSIG mode for the case where malleability\n> absolutely must be eliminated - certain multi-party protocols - and fix\n> wallet software instead. (the malleability problems people see are\n> closely related to inability to handle double-spends and reorgs) But I\n> can easily see that being an impossible goal engineering wise...\n>\n> --\n> 'peter'[:-1]@petertodd.org\n> 0000000000000001465bc2730ffed7493d166d18d288f6cf15e8cdb5d4a3c7b1\n>\n> ------------------------------------------------------------------------------\n> Managing the Performance of Cloud-Based Applications\n> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> Read the Whitepaper.\n> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Alan Reiner",
                "date": "2014-02-12T16:22:19",
                "message_text_only": "I think the solution is simply to encourage Bitcoin software developers to\ndesign their software to use this static ID, instead of the full\ntransaction hash.    If MtGox had talked those IDs instead of the TX ID,\ntheir software would've correctly identified the mutated transactions and\nthere would be  no problem.\n\nArmory is slightly different, since it doesn't deal with the same stuff as\nexchanges do.  But it didn't have any problems with malleability because it\ndoesn't track anything by ID, it only pays attention to whether inputs and\noutputs are related to your wallets.  It's not necessarily hard to do it\nthis way, people just have to be aware of it.\n\n-Alan\n\nSent from my overpriced smartphone\nOn Feb 12, 2014 10:15 AM, \"Rune Kj\u00e6r Svendsen\" <runesvend at gmail.com> wrote:\n\n> Instead of trying to remove the possibility of transaction\n> malleability, would it make sense to define a new, \"canonical\n> transaction hash/ID\" (cTxID), which would be a hash of the part of the\n> transaction data which we know is not malleable, and have clients use\n> this cTxID internally, thus making the traditional transaction hash\n> irrelevant for a client to function correctly?\n>\n> We already have a non-malleable transaction hash: the hash that is\n> signed, ie. the transaction with each scriptSig replaced by the\n> scriptPubKey it redeems. This could be the cTxID.\n>\n> Or is this simply a too fundamental change to the way bitcoin-qt (and\n> all other clients) work in order to be feasible?\n>\n> As far as I can see, it completely solves the issue of not having a\n> canonical ID for a transaction, but it also increases the\n> computational requirements for a node. For one, as far as I can see,\n> it requires the node to index all transactions, because in order to\n> calculate a cTxID, it would be necessary to fetch all transactions\n> referred to by the transaction in question, in order to pull in the\n> scriptPubKeys that are redeemed.\n>\n>\n> On Mon, Feb 10, 2014 at 4:00 AM, Peter Todd <pete at petertodd.org> wrote:\n> > On Mon, Feb 10, 2014 at 12:33:02AM +0100, Pieter Wuille wrote:\n> >> Hello all,\n> >>\n> >> it was something I planned to do since a long time, but with the\n> >> recent related issues popping up, I finally got around to writing a\n> >> BIP about how we can get rid of transaction malleability over time.\n> >>\n> >> The proposed document is here: https://gist.github.com/sipa/8907691\n> >>\n> >> I expect most rules to not be controversial. Maybe rules 1 and 3, as\n> >> they require modifications to wallet software (Bitcoin Core 0.9 and\n> >> BitcoinJ already implement it, though) and potentially invalidate some\n> >> script functionality. However, these new rules remain optional and\n> >> controlled by an nVersion increase.\n> >>\n> >> Comments please!\n> >\n> > You should probably add making CHECKMULTISIG require the dummy value to\n> > be exactly equal to OP_FALSE; verifying that in the transaction itself is\n> > laborious. A more subtle example is we may want both CHECKSIG and\n> > CHECKMULTISIG to fail the transaction if the signature is invalid but\n> > not exactly equal to OP_FALSE; some transaction forms are significantly\n> > more compact if you can have failed signatures, but that's a source of\n> > malleability. (are there counter examples people can think of?)\n> >\n> >\n> > But as I said on IRC, I'm a bit hesitant to bake in assumptions about\n> > malleability when we have no solid idea if ECC signatures are or are not\n> > malleable on a fundemental level; if \"whack-a-mole\" anti-malleability is\n> > all we've got it could be ugly if a break is found. Similarly, we may\n> > find we missed something, or some needed change makes the malleability\n> > rules difficult to work with for some new script type that is required.\n> >\n> > I'd rather see a new CHECKSIG mode for the case where malleability\n> > absolutely must be eliminated - certain multi-party protocols - and fix\n> > wallet software instead. (the malleability problems people see are\n> > closely related to inability to handle double-spends and reorgs) But I\n> > can easily see that being an impossible goal engineering wise...\n> >\n> > --\n> > 'peter'[:-1]@petertodd.org\n> > 0000000000000001465bc2730ffed7493d166d18d288f6cf15e8cdb5d4a3c7b1\n> >\n> >\n> ------------------------------------------------------------------------------\n> > Managing the Performance of Cloud-Based Applications\n> > Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> > Read the Whitepaper.\n> >\n> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk\n> > _______________________________________________\n> > Bitcoin-development mailing list\n> > Bitcoin-development at lists.sourceforge.net\n> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> >\n>\n>\n> ------------------------------------------------------------------------------\n> Android apps run on BlackBerry 10\n> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.\n> Now with support for Jelly Bean, Bluetooth, Mapview and more.\n> Get your Android app in front of a whole new audience.  Start now.\n>\n> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140212/5c046193/attachment.html>"
            },
            {
                "author": "Allen Piscitello",
                "date": "2014-02-12T16:38:18",
                "message_text_only": "While that solution does work for many use cases, it does make it much\nharder to do anything needing chained transactions.  Granted, this is the\nshort term solution for current implementations, but having a transaction\nidentifier that does not change does open up other use cases.\n\nFor example, Alice wants to send coins to a multisignature address with\nBob, such that both parties are required to spend the coins.  Alice also\nrequires for Bob to send coins to this address as well before they will\nproceed.  Alice cannot guarantee that Bob will cooperate (and vice versa),\nso before she broadcasts the transaction to send to A+B, she sends Bob a\ntransaction that spends her incoming transaction back to herself, but has a\ntime lock of far into the future.  Bob signs this, returns it to Alice, and\nshe broadcasts her funding transaction.  At this point, Bob disappears,\nloses his key, or just decides to spite Alice and her coins are locked.\n Since she has a refund transaction, she can broadcast it in a month and\nget her coins back.  Except her funding transaction has been modified such\nthat the txhash is different, so her refund is now invalid.  She would need\nBob to issue a new refund as soon as her funding transaction hits the\nblockchain if it is modified, which defeats the point of the trustless\nrefund transaction.\n\nLonger term it would be more ideal have a canonical identifier for the\ntransaction before it even gets to the chain to support these use cases,\neven if wallets are able to properly identify the status of it's\ntransactions.  Obviously this is a difficult problem to solve and cannot be\nimplemented without breaking changes, but it would be a nice goal to be\nable to completely remove malleability.  There are other important use\ncases where having a unique identifier just for internal accounting is\ninsufficient.\n\n-Allen\n\n\nOn Wed, Feb 12, 2014 at 10:22 AM, Alan Reiner <etotheipi at gmail.com> wrote:\n\n> I think the solution is simply to encourage Bitcoin software developers to\n> design their software to use this static ID, instead of the full\n> transaction hash.    If MtGox had talked those IDs instead of the TX ID,\n> their software would've correctly identified the mutated transactions and\n> there would be  no problem.\n>\n> Armory is slightly different, since it doesn't deal with the same stuff as\n> exchanges do.  But it didn't have any problems with malleability because it\n> doesn't track anything by ID, it only pays attention to whether inputs and\n> outputs are related to your wallets.  It's not necessarily hard to do it\n> this way, people just have to be aware of it.\n>\n> -Alan\n>\n> Sent from my overpriced smartphone\n> On Feb 12, 2014 10:15 AM, \"Rune Kj\u00e6r Svendsen\" <runesvend at gmail.com>\n> wrote:\n>\n>> Instead of trying to remove the possibility of transaction\n>> malleability, would it make sense to define a new, \"canonical\n>> transaction hash/ID\" (cTxID), which would be a hash of the part of the\n>> transaction data which we know is not malleable, and have clients use\n>> this cTxID internally, thus making the traditional transaction hash\n>> irrelevant for a client to function correctly?\n>>\n>> We already have a non-malleable transaction hash: the hash that is\n>> signed, ie. the transaction with each scriptSig replaced by the\n>> scriptPubKey it redeems. This could be the cTxID.\n>>\n>> Or is this simply a too fundamental change to the way bitcoin-qt (and\n>> all other clients) work in order to be feasible?\n>>\n>> As far as I can see, it completely solves the issue of not having a\n>> canonical ID for a transaction, but it also increases the\n>> computational requirements for a node. For one, as far as I can see,\n>> it requires the node to index all transactions, because in order to\n>> calculate a cTxID, it would be necessary to fetch all transactions\n>> referred to by the transaction in question, in order to pull in the\n>> scriptPubKeys that are redeemed.\n>>\n>>\n>> On Mon, Feb 10, 2014 at 4:00 AM, Peter Todd <pete at petertodd.org> wrote:\n>> > On Mon, Feb 10, 2014 at 12:33:02AM +0100, Pieter Wuille wrote:\n>> >> Hello all,\n>> >>\n>> >> it was something I planned to do since a long time, but with the\n>> >> recent related issues popping up, I finally got around to writing a\n>> >> BIP about how we can get rid of transaction malleability over time.\n>> >>\n>> >> The proposed document is here: https://gist.github.com/sipa/8907691\n>> >>\n>> >> I expect most rules to not be controversial. Maybe rules 1 and 3, as\n>> >> they require modifications to wallet software (Bitcoin Core 0.9 and\n>> >> BitcoinJ already implement it, though) and potentially invalidate some\n>> >> script functionality. However, these new rules remain optional and\n>> >> controlled by an nVersion increase.\n>> >>\n>> >> Comments please!\n>> >\n>> > You should probably add making CHECKMULTISIG require the dummy value to\n>> > be exactly equal to OP_FALSE; verifying that in the transaction itself\n>> is\n>> > laborious. A more subtle example is we may want both CHECKSIG and\n>> > CHECKMULTISIG to fail the transaction if the signature is invalid but\n>> > not exactly equal to OP_FALSE; some transaction forms are significantly\n>> > more compact if you can have failed signatures, but that's a source of\n>> > malleability. (are there counter examples people can think of?)\n>> >\n>> >\n>> > But as I said on IRC, I'm a bit hesitant to bake in assumptions about\n>> > malleability when we have no solid idea if ECC signatures are or are not\n>> > malleable on a fundemental level; if \"whack-a-mole\" anti-malleability is\n>> > all we've got it could be ugly if a break is found. Similarly, we may\n>> > find we missed something, or some needed change makes the malleability\n>> > rules difficult to work with for some new script type that is required.\n>> >\n>> > I'd rather see a new CHECKSIG mode for the case where malleability\n>> > absolutely must be eliminated - certain multi-party protocols - and fix\n>> > wallet software instead. (the malleability problems people see are\n>> > closely related to inability to handle double-spends and reorgs) But I\n>> > can easily see that being an impossible goal engineering wise...\n>> >\n>> > --\n>> > 'peter'[:-1]@petertodd.org\n>> > 0000000000000001465bc2730ffed7493d166d18d288f6cf15e8cdb5d4a3c7b1\n>> >\n>> >\n>> ------------------------------------------------------------------------------\n>> > Managing the Performance of Cloud-Based Applications\n>> > Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n>> > Read the Whitepaper.\n>> >\n>> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk\n>> > _______________________________________________\n>> > Bitcoin-development mailing list\n>> > Bitcoin-development at lists.sourceforge.net\n>> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>> >\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> Android apps run on BlackBerry 10\n>> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.\n>> Now with support for Jelly Bean, Bluetooth, Mapview and more.\n>> Get your Android app in front of a whole new audience.  Start now.\n>>\n>> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>\n>\n> ------------------------------------------------------------------------------\n> Android apps run on BlackBerry 10\n> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.\n> Now with support for Jelly Bean, Bluetooth, Mapview and more.\n> Get your Android app in front of a whole new audience.  Start now.\n>\n> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140212/af6a7c54/attachment.html>"
            },
            {
                "author": "Alan Reiner",
                "date": "2014-02-12T16:44:13",
                "message_text_only": "Agreed.  I'm not suggesting that malleability shouldn't be fixed or isn't a\nproblem.  I would love to be able to leverage chained TX for Bitcoin\ncontracts.  But that in its current state it doesn't have to be complicated\nto deal with  it.\n\nChanging the protocol to use these static IDs is a pretty fundamental\nchange that would never happen in Bitcoin.   But they can still be useful\nat the application level to mitigate these issues.\n\nSent from my overpriced smartphone\nOn Feb 12, 2014 11:38 AM, \"Allen Piscitello\" <allen.piscitello at gmail.com>\nwrote:\n\n> While that solution does work for many use cases, it does make it much\n> harder to do anything needing chained transactions.  Granted, this is the\n> short term solution for current implementations, but having a transaction\n> identifier that does not change does open up other use cases.\n>\n> For example, Alice wants to send coins to a multisignature address with\n> Bob, such that both parties are required to spend the coins.  Alice also\n> requires for Bob to send coins to this address as well before they will\n> proceed.  Alice cannot guarantee that Bob will cooperate (and vice versa),\n> so before she broadcasts the transaction to send to A+B, she sends Bob a\n> transaction that spends her incoming transaction back to herself, but has a\n> time lock of far into the future.  Bob signs this, returns it to Alice, and\n> she broadcasts her funding transaction.  At this point, Bob disappears,\n> loses his key, or just decides to spite Alice and her coins are locked.\n>  Since she has a refund transaction, she can broadcast it in a month and\n> get her coins back.  Except her funding transaction has been modified such\n> that the txhash is different, so her refund is now invalid.  She would need\n> Bob to issue a new refund as soon as her funding transaction hits the\n> blockchain if it is modified, which defeats the point of the trustless\n> refund transaction.\n>\n> Longer term it would be more ideal have a canonical identifier for the\n> transaction before it even gets to the chain to support these use cases,\n> even if wallets are able to properly identify the status of it's\n> transactions.  Obviously this is a difficult problem to solve and cannot be\n> implemented without breaking changes, but it would be a nice goal to be\n> able to completely remove malleability.  There are other important use\n> cases where having a unique identifier just for internal accounting is\n> insufficient.\n>\n> -Allen\n>\n>\n> On Wed, Feb 12, 2014 at 10:22 AM, Alan Reiner <etotheipi at gmail.com> wrote:\n>\n>> I think the solution is simply to encourage Bitcoin software developers\n>> to design their software to use this static ID, instead of the full\n>> transaction hash.    If MtGox had talked those IDs instead of the TX ID,\n>> their software would've correctly identified the mutated transactions and\n>> there would be  no problem.\n>>\n>> Armory is slightly different, since it doesn't deal with the same stuff\n>> as exchanges do.  But it didn't have any problems with malleability because\n>> it doesn't track anything by ID, it only pays attention to whether inputs\n>> and outputs are related to your wallets.  It's not necessarily hard to do\n>> it this way, people just have to be aware of it.\n>>\n>> -Alan\n>>\n>> Sent from my overpriced smartphone\n>> On Feb 12, 2014 10:15 AM, \"Rune Kj\u00e6r Svendsen\" <runesvend at gmail.com>\n>> wrote:\n>>\n>>> Instead of trying to remove the possibility of transaction\n>>> malleability, would it make sense to define a new, \"canonical\n>>> transaction hash/ID\" (cTxID), which would be a hash of the part of the\n>>> transaction data which we know is not malleable, and have clients use\n>>> this cTxID internally, thus making the traditional transaction hash\n>>> irrelevant for a client to function correctly?\n>>>\n>>> We already have a non-malleable transaction hash: the hash that is\n>>> signed, ie. the transaction with each scriptSig replaced by the\n>>> scriptPubKey it redeems. This could be the cTxID.\n>>>\n>>> Or is this simply a too fundamental change to the way bitcoin-qt (and\n>>> all other clients) work in order to be feasible?\n>>>\n>>> As far as I can see, it completely solves the issue of not having a\n>>> canonical ID for a transaction, but it also increases the\n>>> computational requirements for a node. For one, as far as I can see,\n>>> it requires the node to index all transactions, because in order to\n>>> calculate a cTxID, it would be necessary to fetch all transactions\n>>> referred to by the transaction in question, in order to pull in the\n>>> scriptPubKeys that are redeemed.\n>>>\n>>>\n>>> On Mon, Feb 10, 2014 at 4:00 AM, Peter Todd <pete at petertodd.org> wrote:\n>>> > On Mon, Feb 10, 2014 at 12:33:02AM +0100, Pieter Wuille wrote:\n>>> >> Hello all,\n>>> >>\n>>> >> it was something I planned to do since a long time, but with the\n>>> >> recent related issues popping up, I finally got around to writing a\n>>> >> BIP about how we can get rid of transaction malleability over time.\n>>> >>\n>>> >> The proposed document is here: https://gist.github.com/sipa/8907691\n>>> >>\n>>> >> I expect most rules to not be controversial. Maybe rules 1 and 3, as\n>>> >> they require modifications to wallet software (Bitcoin Core 0.9 and\n>>> >> BitcoinJ already implement it, though) and potentially invalidate some\n>>> >> script functionality. However, these new rules remain optional and\n>>> >> controlled by an nVersion increase.\n>>> >>\n>>> >> Comments please!\n>>> >\n>>> > You should probably add making CHECKMULTISIG require the dummy value to\n>>> > be exactly equal to OP_FALSE; verifying that in the transaction itself\n>>> is\n>>> > laborious. A more subtle example is we may want both CHECKSIG and\n>>> > CHECKMULTISIG to fail the transaction if the signature is invalid but\n>>> > not exactly equal to OP_FALSE; some transaction forms are significantly\n>>> > more compact if you can have failed signatures, but that's a source of\n>>> > malleability. (are there counter examples people can think of?)\n>>> >\n>>> >\n>>> > But as I said on IRC, I'm a bit hesitant to bake in assumptions about\n>>> > malleability when we have no solid idea if ECC signatures are or are\n>>> not\n>>> > malleable on a fundemental level; if \"whack-a-mole\" anti-malleability\n>>> is\n>>> > all we've got it could be ugly if a break is found. Similarly, we may\n>>> > find we missed something, or some needed change makes the malleability\n>>> > rules difficult to work with for some new script type that is required.\n>>> >\n>>> > I'd rather see a new CHECKSIG mode for the case where malleability\n>>> > absolutely must be eliminated - certain multi-party protocols - and fix\n>>> > wallet software instead. (the malleability problems people see are\n>>> > closely related to inability to handle double-spends and reorgs) But I\n>>> > can easily see that being an impossible goal engineering wise...\n>>> >\n>>> > --\n>>> > 'peter'[:-1]@petertodd.org\n>>> > 0000000000000001465bc2730ffed7493d166d18d288f6cf15e8cdb5d4a3c7b1\n>>> >\n>>> >\n>>> ------------------------------------------------------------------------------\n>>> > Managing the Performance of Cloud-Based Applications\n>>> > Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n>>> > Read the Whitepaper.\n>>> >\n>>> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk\n>>> > _______________________________________________\n>>> > Bitcoin-development mailing list\n>>> > Bitcoin-development at lists.sourceforge.net\n>>> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>> >\n>>>\n>>>\n>>> ------------------------------------------------------------------------------\n>>> Android apps run on BlackBerry 10\n>>> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.\n>>> Now with support for Jelly Bean, Bluetooth, Mapview and more.\n>>> Get your Android app in front of a whole new audience.  Start now.\n>>>\n>>> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk\n>>> _______________________________________________\n>>> Bitcoin-development mailing list\n>>> Bitcoin-development at lists.sourceforge.net\n>>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>>\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> Android apps run on BlackBerry 10\n>> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.\n>> Now with support for Jelly Bean, Bluetooth, Mapview and more.\n>> Get your Android app in front of a whole new audience.  Start now.\n>>\n>> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140212/aab9621c/attachment.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2014-02-12T20:27:52",
                "message_text_only": "On 02/12/2014 08:44 AM, Alan Reiner wrote:\n> Changing the protocol to use these static IDs is a pretty fundamental\n> change that would never happen in Bitcoin.   But they can still be\n> useful at the application level to mitigate these issues.\n\nNot to mention that it would be potentially very insecure to have\nconsensus depend on data (scriptSigs) which are not hashed in the Merkle\nstructure of a block.\n\nNot that anyone on this list has suggested such a change, but I've seen\nit raised multiple times on the forum....\n\nMark"
            },
            {
                "author": "Luke-Jr",
                "date": "2014-02-12T22:52:30",
                "message_text_only": "On Wednesday, February 12, 2014 8:27:52 PM Mark Friedenbach wrote:\n> On 02/12/2014 08:44 AM, Alan Reiner wrote:\n> > Changing the protocol to use these static IDs is a pretty fundamental\n> > change that would never happen in Bitcoin.   But they can still be\n> > useful at the application level to mitigate these issues.\n> \n> Not to mention that it would be potentially very insecure to have\n> consensus depend on data (scriptSigs) which are not hashed in the Merkle\n> structure of a block.\n> \n> Not that anyone on this list has suggested such a change, but I've seen\n> it raised multiple times on the forum....\n\nThis would be a problem if it was used in the merkle tree, but I'm pretty sure \nusing it for input selection would be pretty safe. One could even avoid the \nindex by simply using the hashScript as the sole input value; then even \nCoinJoins would be safe without breaking chains of transactions (although this \nwould break address reuse entirely - but I don't see that as a problem in a \ntheoretical world). One of those things that an altcoin could improve upon \nBitcoin with... ;)"
            },
            {
                "author": "Alex Morcos",
                "date": "2014-02-13T00:39:11",
                "message_text_only": "I apologize if this has been discussed many times before.\n\nAs a long term solution to malleable transactions, wouldn't it be possible\nto modify the signatures to be of the entire transaction.  Why do you have\nto zero out the inputs?  I can see that this would be a hard fork, and\nmaybe it would be somewhat tricky to extract signatures first (since you\ncan sign everything except the signatures), but it would seem to me that\nthis is an important enough change to consider making.\n\n\n\n\n\n\n\n\nOn Wed, Feb 12, 2014 at 5:52 PM, Luke-Jr <luke at dashjr.org> wrote:\n\n> On Wednesday, February 12, 2014 8:27:52 PM Mark Friedenbach wrote:\n> > On 02/12/2014 08:44 AM, Alan Reiner wrote:\n> > > Changing the protocol to use these static IDs is a pretty fundamental\n> > > change that would never happen in Bitcoin.   But they can still be\n> > > useful at the application level to mitigate these issues.\n> >\n> > Not to mention that it would be potentially very insecure to have\n> > consensus depend on data (scriptSigs) which are not hashed in the Merkle\n> > structure of a block.\n> >\n> > Not that anyone on this list has suggested such a change, but I've seen\n> > it raised multiple times on the forum....\n>\n> This would be a problem if it was used in the merkle tree, but I'm pretty\n> sure\n> using it for input selection would be pretty safe. One could even avoid the\n> index by simply using the hashScript as the sole input value; then even\n> CoinJoins would be safe without breaking chains of transactions (although\n> this\n> would break address reuse entirely - but I don't see that as a problem in a\n> theoretical world). One of those things that an altcoin could improve upon\n> Bitcoin with... ;)\n>\n>\n> ------------------------------------------------------------------------------\n> Android apps run on BlackBerry 10\n> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.\n> Now with support for Jelly Bean, Bluetooth, Mapview and more.\n> Get your Android app in front of a whole new audience.  Start now.\n>\n> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140212/1bd41008/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-02-13T00:47:05",
                "message_text_only": "On Wed, Feb 12, 2014 at 4:39 PM, Alex Morcos <morcos at gmail.com> wrote:\n> I apologize if this has been discussed many times before.\n\nIt has been, but there are probably many people like you who have not\nbothered researching who may also be curious.\n\n> As a long term solution to malleable transactions, wouldn't it be possible\n> to modify the signatures to be of the entire transaction.  Why do you have\n> to zero out the inputs?  I can see that this would be a hard fork, and maybe\n> it would be somewhat tricky to extract signatures first (since you can sign\n> everything except the signatures), but it would seem to me that this is an\n> important enough change to consider making.\n\nBecause doing so would be both unnecessary and ineffective.\n\nUnnecessary because we can very likely eliminate malleability without\nchanging what is signed. It will take time, but we have been\nincrementally moving towards that, e.g. v0.8 made many kinds of\nnon-canonical encoding non-standard.\n\nIneffective\u2014 at least as you describe it\u2014 because the signatures\n_themselves_ are malleable."
            },
            {
                "author": "Michael Gronager",
                "date": "2014-02-19T14:11:51",
                "message_text_only": "Why introduce a new transaction version for this purpose ? Wouldn't it be more elegant to simply let:\n\n1. the next bitcoin version \"prettify\" all relayed transactions as deterministic transactions fulfilling the scheme 1-6 effectively blocking any malleability attack? If miners would upgrade then all transactions in blocks would have a deterministic hash. \n\n2. In a version later one could block relay of non deterministic transactions, as well as the acceptance of blocks with non-confirming transactions.\n\nTo non-standard conforming clients this \"prettify\" change of hash would be seen as a constant malleability attack, but given the \"prettify\" code it is to fix any client into producing only conforming transactions, just by running the transaction through it before broadcast.\n\nThere is a possible fork risk in step 2. above - if a majority of miners still havn't upgraded to 1 when 2 is introduced. We could monitor % non conforming transaction in a block and only introduce 2. once that number is sufficiently small for a certain duration - criteria:\n* Switch on forcing of unmalleable transactions in blocks when there has been only conforming transactions for 1000 blocks.\n\n\nOn Feb 13, 2014, at 1:47 AM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n\n> On Wed, Feb 12, 2014 at 4:39 PM, Alex Morcos <morcos at gmail.com> wrote:\n>> I apologize if this has been discussed many times before.\n> \n> It has been, but there are probably many people like you who have not\n> bothered researching who may also be curious.\n> \n>> As a long term solution to malleable transactions, wouldn't it be possible\n>> to modify the signatures to be of the entire transaction.  Why do you have\n>> to zero out the inputs?  I can see that this would be a hard fork, and maybe\n>> it would be somewhat tricky to extract signatures first (since you can sign\n>> everything except the signatures), but it would seem to me that this is an\n>> important enough change to consider making.\n> \n> Because doing so would be both unnecessary and ineffective.\n> \n> Unnecessary because we can very likely eliminate malleability without\n> changing what is signed. It will take time, but we have been\n> incrementally moving towards that, e.g. v0.8 made many kinds of\n> non-canonical encoding non-standard.\n> \n> Ineffective\u2014 at least as you describe it\u2014 because the signatures\n> _themselves_ are malleable.\n> \n> ------------------------------------------------------------------------------\n> Android apps run on BlackBerry 10\n> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.\n> Now with support for Jelly Bean, Bluetooth, Mapview and more.\n> Get your Android app in front of a whole new audience.  Start now.\n> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 496 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140219/95dc03a4/attachment.sig>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2014-02-19T14:38:19",
                "message_text_only": "On Wed, Feb 19, 2014 at 3:11 PM, Michael Gronager <gronager at mac.com> wrote:\n> Why introduce a new transaction version for this purpose ? Wouldn't it be more elegant to simply let:\n>\n> 1. the next bitcoin version \"prettify\" all relayed transactions as deterministic transactions fulfilling the scheme 1-6 effectively blocking any malleability attack? If miners would upgrade then all transactions in blocks would have a deterministic hash.\n\nI consider actively mutating other's transactions worse than not\nrelaying them. If we want people to make their software deal with\nmalleability, either will work.\n\nRegarding deterministic hash: that's impossible. Some signature hash\ntypes are inherently (and intentionally) malleable. I don't think we\nshould pretend to want to change that. The purpose is making\nnon-malleability a choice the sender of a transaction can make.\n\nMost of the rules actually are enforced by IsStandard already now.\nOnly #1 and #7 aren't. #1 affects the majority of all transactions, so\nchanging it right now would be painful. #7 only affects multisig.\n\n> 2. In a version later one could block relay of non deterministic transactions, as well as the acceptance of blocks with non-confirming transactions.\n>\n> To non-standard conforming clients this \"prettify\" change of hash would be seen as a constant malleability attack, but given the \"prettify\" code it is to fix any client into producing only conforming transactions, just by running the transaction through it before broadcast.\n>\n> There is a possible fork risk in step 2. above - if a majority of miners still havn't upgraded to 1 when 2 is introduced. We could monitor % non conforming transaction in a block and only introduce 2. once that number is sufficiently small for a certain duration - criteria:\n> * Switch on forcing of unmalleable transactions in blocks when there has been only conforming transactions for 1000 blocks.\n\nThe problem in making these rules into consensus rule (affecting\ntx/block validity) is that some rules (in particular #3) may not be\nwanted by everyone, as they effectively limit the possibilities of the\nscript language further. As it is ultimately only about protecting\nsenders who care about non-malleability, introducing a new transaction\nversion is a very neat way of accomplishing that. The new block\nversion number is only there to coordinate the rollout, and choosing\nan automatic forking point.\n\n-- \nPieter"
            },
            {
                "author": "Michael Gronager",
                "date": "2014-02-19T20:28:24",
                "message_text_only": "Twisting your words a bit I read:\n\n* you want to support relay of transactions that can be changed on the fly, but you consider it wrong to modify them.\n* #3 is already not forwarded, but you still find it relevant to support it.\n\nRational use cases of #3 will be pretty hard to find given the fact that they can be changed on the fly. We are down to inclusion in blocks by miners for special purposes - or did I miss out something?\n\nI think that we could guarantee fewer incidents by making version 1 transactions unmalleable and then optionally introduce a version 3 that supported the malleability feature. That way most existing problematic implementations would be fixed and no doors were closed for people experimenting with other stuff - tx v 3 would probably then be called experimental transactions.\n\n/M\n\n\nOn Feb 19, 2014, at 3:38 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n\n> On Wed, Feb 19, 2014 at 3:11 PM, Michael Gronager <gronager at mac.com> wrote:\n>> Why introduce a new transaction version for this purpose ? Wouldn't it be more elegant to simply let:\n>> \n>> 1. the next bitcoin version \"prettify\" all relayed transactions as deterministic transactions fulfilling the scheme 1-6 effectively blocking any malleability attack? If miners would upgrade then all transactions in blocks would have a deterministic hash.\n> \n> I consider actively mutating other's transactions worse than not\n> relaying them. If we want people to make their software deal with\n> malleability, either will work.\n> \n> Regarding deterministic hash: that's impossible. Some signature hash\n> types are inherently (and intentionally) malleable. I don't think we\n> should pretend to want to change that. The purpose is making\n> non-malleability a choice the sender of a transaction can make.\n> \n> Most of the rules actually are enforced by IsStandard already now.\n> Only #1 and #7 aren't. #1 affects the majority of all transactions, so\n> changing it right now would be painful. #7 only affects multisig.\n> \n>> 2. In a version later one could block relay of non deterministic transactions, as well as the acceptance of blocks with non-confirming transactions.\n>> \n>> To non-standard conforming clients this \"prettify\" change of hash would be seen as a constant malleability attack, but given the \"prettify\" code it is to fix any client into producing only conforming transactions, just by running the transaction through it before broadcast.\n>> \n>> There is a possible fork risk in step 2. above - if a majority of miners still havn't upgraded to 1 when 2 is introduced. We could monitor % non conforming transaction in a block and only introduce 2. once that number is sufficiently small for a certain duration - criteria:\n>> * Switch on forcing of unmalleable transactions in blocks when there has been only conforming transactions for 1000 blocks.\n> \n> The problem in making these rules into consensus rule (affecting\n> tx/block validity) is that some rules (in particular #3) may not be\n> wanted by everyone, as they effectively limit the possibilities of the\n> script language further. As it is ultimately only about protecting\n> senders who care about non-malleability, introducing a new transaction\n> version is a very neat way of accomplishing that. The new block\n> version number is only there to coordinate the rollout, and choosing\n> an automatic forking point.\n> \n> -- \n> Pieter\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 496 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140219/f91a05d2/attachment.sig>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-02-19T20:39:07",
                "message_text_only": "On Wed, Feb 19, 2014 at 12:28 PM, Michael Gronager <gronager at mac.com> wrote:\n> Twisting your words a bit I read:\n>\n> * you want to support relay of transactions that can be changed on the fly, but you consider it wrong to modify them.\n> * #3 is already not forwarded, but you still find it relevant to support it.\n>\n> Rational use cases of #3 will be pretty hard to find given the fact that they can be changed on the fly. We are down to inclusion in blocks by miners for special purposes - or did I miss out something?\n\nYou did. See the other sighash flags.\n\n> I think that we could guarantee fewer incidents by making version 1 transactions unmalleable and then optionally introduce a version 3 that supported the malleability feature. That way most existing problematic implementations would be fixed and no doors were closed for people experimenting with other stuff - tx v 3 would probably then be called experimental transactions.\n\nIn exchange you make the behavior basically impossible do deploy\nwithout first blocking all ongoing transactions. This seems foolish.\nAll signers need to be updated to change their behavior to be\nanti-malleability compatible, they can change their version at the\nsame time... and leave things actually working for the things which\ncan't be easily updated."
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-19T20:49:32",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nWhile we might be able to get away with a retroactive change in meaning right now in the future that won't be so easy. There are lots if proposed applications for nLockTime-using protocols that depend on transactions (or parts of transactions) being possible to mine as is. Making existing transactions impossible to mine in the future will break those types of applications. We might as well use this as a learning experience for what a version bump would look like infrastructures wise.\n\nNote how the above is a particularly bad example of gmaxwell's generic \"don't break things\" objection. Equally, remember that lots of infrastructure *does* handle malleability just fine already.\n\nOn February 19, 2014 3:28:24 PM EST, Michael Gronager <gronager at mac.com> wrote:\n>Twisting your words a bit I read:\n>\n>* you want to support relay of transactions that can be changed on the\n>fly, but you consider it wrong to modify them.\n>* #3 is already not forwarded, but you still find it relevant to\n>support it.\n>\n>Rational use cases of #3 will be pretty hard to find given the fact\n>that they can be changed on the fly. We are down to inclusion in blocks\n>by miners for special purposes - or did I miss out something?\n>\n>I think that we could guarantee fewer incidents by making version 1\n>transactions unmalleable and then optionally introduce a version 3 that\n>supported the malleability feature. That way most existing problematic\n>implementations would be fixed and no doors were closed for people\n>experimenting with other stuff - tx v 3 would probably then be called\n>experimental transactions.\n>\n>/M\n>\n>\n>On Feb 19, 2014, at 3:38 PM, Pieter Wuille <pieter.wuille at gmail.com>\n>wrote:\n>\n>> On Wed, Feb 19, 2014 at 3:11 PM, Michael Gronager <gronager at mac.com>\n>wrote:\n>>> Why introduce a new transaction version for this purpose ? Wouldn't\n>it be more elegant to simply let:\n>>>\n>>> 1. the next bitcoin version \"prettify\" all relayed transactions as\n>deterministic transactions fulfilling the scheme 1-6 effectively\n>blocking any malleability attack? If miners would upgrade then all\n>transactions in blocks would have a deterministic hash.\n>>\n>> I consider actively mutating other's transactions worse than not\n>> relaying them. If we want people to make their software deal with\n>> malleability, either will work.\n>>\n>> Regarding deterministic hash: that's impossible. Some signature hash\n>> types are inherently (and intentionally) malleable. I don't think we\n>> should pretend to want to change that. The purpose is making\n>> non-malleability a choice the sender of a transaction can make.\n>>\n>> Most of the rules actually are enforced by IsStandard already now.\n>> Only #1 and #7 aren't. #1 affects the majority of all transactions,\n>so\n>> changing it right now would be painful. #7 only affects multisig.\n>>\n>>> 2. In a version later one could block relay of non deterministic\n>transactions, as well as the acceptance of blocks with non-confirming\n>transactions.\n>>>\n>>> To non-standard conforming clients this \"prettify\" change of hash\n>would be seen as a constant malleability attack, but given the\n>\"prettify\" code it is to fix any client into producing only conforming\n>transactions, just by running the transaction through it before\n>broadcast.\n>>>\n>>> There is a possible fork risk in step 2. above - if a majority of\n>miners still havn't upgraded to 1 when 2 is introduced. We could\n>monitor % non conforming transaction in a block and only introduce 2.\n>once that number is sufficiently small for a certain duration -\n>criteria:\n>>> * Switch on forcing of unmalleable transactions in blocks when there\n>has been only conforming transactions for 1000 blocks.\n>>\n>> The problem in making these rules into consensus rule (affecting\n>> tx/block validity) is that some rules (in particular #3) may not be\n>> wanted by everyone, as they effectively limit the possibilities of\n>the\n>> script language further. As it is ultimately only about protecting\n>> senders who care about non-malleability, introducing a new\n>transaction\n>> version is a very neat way of accomplishing that. The new block\n>> version number is only there to coordinate the rollout, and choosing\n>> an automatic forking point.\n>>\n>> --\n>> Pieter\n>\n>\n>\n>------------------------------------------------------------------------\n>\n>------------------------------------------------------------------------------\n>Managing the Performance of Cloud-Based Applications\n>Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n>Read the Whitepaper.\n>http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk\n>\n>------------------------------------------------------------------------\n>\n>_______________________________________________\n>Bitcoin-development mailing list\n>Bitcoin-development at lists.sourceforge.net\n>https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n-----BEGIN PGP SIGNATURE-----\nVersion: APG v1.0.9\n\niQFQBAEBCAA6BQJTBRjcMxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8\ncGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhbuuCADHHZvCbWNR+hj3lq2u\nXjr8POSsMWk4XorvLftgXSzAzypr7n0BP7+fmz/v0J98XfeOHxf8NHB2VXzFMCzI\nmstYyFC+gdsPf9eIMoN2S9EB9d4Lh1Y7Zv5BGqopuHCUIVMpzk2QDaFlLe+gW8Ai\np4Yv/jGib8ym1ahJ24nZ89l7Psa+uXDw8N2VX5PcyDNVRwzuXwa0h2Kix/gt8uJb\nRV5Sj3duxUE6mOGN07j6lPu9VcrtD0ydvAO3DoEJqkBqjhbC33h05H96KPQKuGcg\n5DOKXUV5ChW5CF3DH5HN/LdduLgbTevtLbkBhdLKo+z5GKaU7Qpc5i6dIeAKl3uA\nKCQE\n=DiAE\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-02-19T21:05:03",
                "message_text_only": "dOn Wed, Feb 19, 2014 at 12:49 PM, Peter Todd <pete at petertodd.org> wrote:\n> While we might be able to get away with a retroactive change in meaning right now in the future that won't be so easy. There are lots if proposed applications for nLockTime-using protocols that depend on transactions (or parts of transactions) being possible to mine as is. Making existing transactions impossible to mine in the future will break those types of applications. We might as well use this as a learning experience for what a version bump would look like infrastructures wise.\n\nFor some reason it took me a couple reads to get this so I thought I'd\nrestate it in a more blunt form.\n\nThere may exist people today who have send funds to addresses,\nauthored nlocktime releases, and destroyed the key the funds are at\nnow in order to achieve a timelock.  This might be a foolish thing to\ndo, but it's the kind of thing that you have to worry about when\npotentially breaking existing transactions.\n\n(This kind of us is, fwiw, another example of why ANYONE_CAN_PAY is useful)."
            },
            {
                "author": "Pieter Wuille",
                "date": "2014-02-19T21:11:14",
                "message_text_only": "On Wed, Feb 19, 2014 at 9:28 PM, Michael Gronager <gronager at mac.com> wrote:\n> I think that we could guarantee fewer incidents by making version 1 transactions unmalleable and then optionally introduce a version 3 that supported the malleability feature. That way most existing problematic implementations would be fixed and no doors were closed for people experimenting with other stuff - tx v 3 would probably then be called experimental transactions.\n\nJust to be clear: this change is not directly intended to avoid\n\"incidents\". It will take way too long to deploy this. Software should\ndeal with malleability. This is a longer-term solution intended to\nprovide non-malleability guarantees for clients that a) are upgraded\nto use them  b) willing to restrict their functionality. As there are\nseveral intended use cases for malleable transactions (the sighash\nflags pretty directly are a way to signify what malleabilities are\n*wanted*), this is not about outlawing malleability.\n\nWhile we could right now make all these rules non-standard, and\nschedule a soft fork in a year or so to make them illegal, it would\nmean removing potential functionality that can only be re-enabled\nthrough a hard fork. This is significantly harder, so we should think\nabout it very well in advance.\n\nAbout new transaction and block versions: this allows implementing and\nautomatically scheduling a softfork without waiting for wallets to\nupgrade. The non-DER signature change was discussed for over two\nyears, and implemented almost a year ago, and we still notice wallets\nthat don't support it. We can't expect every wallet to be instantly\nmodified (what about hardware wallets like the Trezor, for example?\nthey may not just be able to be upgraded). Nor is it necessary: if\nyour software only spends confirmed change, and tracks all debits\ncorrectly, there is no need.\n\n-- \nPieter"
            },
            {
                "author": "Natanael",
                "date": "2014-02-20T00:22:15",
                "message_text_only": "Regarding chains of transactions intended to be published at once together,\nwouldn't it be easier to add a \"only-mine-with-child flag\"?\n\nThat way the parent transactions aren't actually valid unless spent\ntogether with the transaction that depends on it, and only the original\nwill have a child referencing it.\n\nThen malleability is not an issue at all for transaction chains if you only\nneed to broadcast your full transaction chain once, and don't need to\nextend it in two or more occasions, *after* broadcasting subchains to the\nnetwork, from the same set of pregenerated transactions.\n\nIf you need to broadcast pregenerated subchains separately, then you need\nthe last child in the chain to be non-malleable.\n\nThis would require all miners to start to respect it at once in order to\navoid forking the network.\n\n- Sent from my phone\nDen 19 feb 2014 22:13 skrev \"Pieter Wuille\" <pieter.wuille at gmail.com>:\n\n> On Wed, Feb 19, 2014 at 9:28 PM, Michael Gronager <gronager at mac.com>\n> wrote:\n> > I think that we could guarantee fewer incidents by making version 1\n> transactions unmalleable and then optionally introduce a version 3 that\n> supported the malleability feature. That way most existing problematic\n> implementations would be fixed and no doors were closed for people\n> experimenting with other stuff - tx v 3 would probably then be called\n> experimental transactions.\n>\n> Just to be clear: this change is not directly intended to avoid\n> \"incidents\". It will take way too long to deploy this. Software should\n> deal with malleability. This is a longer-term solution intended to\n> provide non-malleability guarantees for clients that a) are upgraded\n> to use them  b) willing to restrict their functionality. As there are\n> several intended use cases for malleable transactions (the sighash\n> flags pretty directly are a way to signify what malleabilities are\n> *wanted*), this is not about outlawing malleability.\n>\n> While we could right now make all these rules non-standard, and\n> schedule a soft fork in a year or so to make them illegal, it would\n> mean removing potential functionality that can only be re-enabled\n> through a hard fork. This is significantly harder, so we should think\n> about it very well in advance.\n>\n> About new transaction and block versions: this allows implementing and\n> automatically scheduling a softfork without waiting for wallets to\n> upgrade. The non-DER signature change was discussed for over two\n> years, and implemented almost a year ago, and we still notice wallets\n> that don't support it. We can't expect every wallet to be instantly\n> modified (what about hardware wallets like the Trezor, for example?\n> they may not just be able to be upgraded). Nor is it necessary: if\n> your software only spends confirmed change, and tracks all debits\n> correctly, there is no need.\n>\n> --\n> Pieter\n>\n>\n> ------------------------------------------------------------------------------\n> Managing the Performance of Cloud-Based Applications\n> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> Read the Whitepaper.\n>\n> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140220/d3b847d3/attachment.html>"
            },
            {
                "author": "Allen Piscitello",
                "date": "2014-02-20T01:29:05",
                "message_text_only": "This is somewhat problematic in my use case since some parts need to be in\nthe chain earlier than others and have the same ID as expected.\n\nhttps://bitcointalk.org/index.php?topic=260898.10\n\nI haven't gone back to see if there are any ways around it, but the main\nproblem here is I need the Contract TX to be in the chain much earlier than\nredeeming, but I need the refund transaction to be in the chain much\nearlier.  Perhaps there are some tricks to pull off to get it to work, but\nI haven't been working on this for a while so I'm a bit rusty in that area.\n\nThis might be helpful enough to help a lot of use cases, but shouldn't be\nfinal.\n\n-Allen\n\nOn Wed, Feb 19, 2014 at 6:22 PM, Natanael <natanael.l at gmail.com> wrote:\n\n> Regarding chains of transactions intended to be published at once\n> together, wouldn't it be easier to add a \"only-mine-with-child flag\"?\n>\n> That way the parent transactions aren't actually valid unless spent\n> together with the transaction that depends on it, and only the original\n> will have a child referencing it.\n>\n> Then malleability is not an issue at all for transaction chains if you\n> only need to broadcast your full transaction chain once, and don't need to\n> extend it in two or more occasions, *after* broadcasting subchains to the\n> network, from the same set of pregenerated transactions.\n>\n> If you need to broadcast pregenerated subchains separately, then you need\n> the last child in the chain to be non-malleable.\n>\n> This would require all miners to start to respect it at once in order to\n> avoid forking the network.\n>\n> - Sent from my phone\n> Den 19 feb 2014 22:13 skrev \"Pieter Wuille\" <pieter.wuille at gmail.com>:\n>\n> On Wed, Feb 19, 2014 at 9:28 PM, Michael Gronager <gronager at mac.com>\n>> wrote:\n>> > I think that we could guarantee fewer incidents by making version 1\n>> transactions unmalleable and then optionally introduce a version 3 that\n>> supported the malleability feature. That way most existing problematic\n>> implementations would be fixed and no doors were closed for people\n>> experimenting with other stuff - tx v 3 would probably then be called\n>> experimental transactions.\n>>\n>> Just to be clear: this change is not directly intended to avoid\n>> \"incidents\". It will take way too long to deploy this. Software should\n>> deal with malleability. This is a longer-term solution intended to\n>> provide non-malleability guarantees for clients that a) are upgraded\n>> to use them  b) willing to restrict their functionality. As there are\n>> several intended use cases for malleable transactions (the sighash\n>> flags pretty directly are a way to signify what malleabilities are\n>> *wanted*), this is not about outlawing malleability.\n>>\n>> While we could right now make all these rules non-standard, and\n>> schedule a soft fork in a year or so to make them illegal, it would\n>> mean removing potential functionality that can only be re-enabled\n>> through a hard fork. This is significantly harder, so we should think\n>> about it very well in advance.\n>>\n>> About new transaction and block versions: this allows implementing and\n>> automatically scheduling a softfork without waiting for wallets to\n>> upgrade. The non-DER signature change was discussed for over two\n>> years, and implemented almost a year ago, and we still notice wallets\n>> that don't support it. We can't expect every wallet to be instantly\n>> modified (what about hardware wallets like the Trezor, for example?\n>> they may not just be able to be upgraded). Nor is it necessary: if\n>> your software only spends confirmed change, and tracks all debits\n>> correctly, there is no need.\n>>\n>> --\n>> Pieter\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> Managing the Performance of Cloud-Based Applications\n>> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n>> Read the Whitepaper.\n>>\n>> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>\n>\n> ------------------------------------------------------------------------------\n> Managing the Performance of Cloud-Based Applications\n> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> Read the Whitepaper.\n>\n> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140219/42627c75/attachment.html>"
            },
            {
                "author": "Natanael",
                "date": "2014-02-20T07:50:51",
                "message_text_only": "You could pregenerate entire \"trees\" of alternative outcomes where you pick\none branch / chain to broadcast based on the real world events as they\nhappen.\n\nBut I see another problem regarding use of oracles, if you have a P2SH\naddress with 2-of-3 signatures or similar in the chain, amd some\ntransactions following it, then the oracle needs to pregenerate both\ntransactions for both outcomes in advance. But the oracle probably don't\nwant to actually share it in advance to any third party before the event\nhappened.\n\nThis can be solved if the oracle only shares the transaction hash in\nadvance and then hands out a Zero-knowledge proof of that transaction with\nthe given hash is following the agreed upon rules, so you can trust the\ntransaction chain anyway and still being able to pregenerate a full tree of\ntransactions.\n\nAnd then the oracle will release one of the possible transactions after the\nevent in question has happened, so you can broadcast the chain of choice.\n\nThis unfortunately breaks down if the number of possible outcomes becomes\ntoo many as you would need to both generate and store a tree of possible\noutcomes that is massive.\n\n- Sent from my phone\nDen 20 feb 2014 02:29 skrev \"Allen Piscitello\" <allen.piscitello at gmail.com>:\n\n> This is somewhat problematic in my use case since some parts need to be in\n> the chain earlier than others and have the same ID as expected.\n>\n> https://bitcointalk.org/index.php?topic=260898.10\n>\n> I haven't gone back to see if there are any ways around it, but the main\n> problem here is I need the Contract TX to be in the chain much earlier than\n> redeeming, but I need the refund transaction to be in the chain much\n> earlier.  Perhaps there are some tricks to pull off to get it to work, but\n> I haven't been working on this for a while so I'm a bit rusty in that area.\n>\n> This might be helpful enough to help a lot of use cases, but shouldn't be\n> final.\n>\n> -Allen\n>\n> On Wed, Feb 19, 2014 at 6:22 PM, Natanael <natanael.l at gmail.com> wrote:\n>\n>> Regarding chains of transactions intended to be published at once\n>> together, wouldn't it be easier to add a \"only-mine-with-child flag\"?\n>>\n>> That way the parent transactions aren't actually valid unless spent\n>> together with the transaction that depends on it, and only the original\n>> will have a child referencing it.\n>>\n>> Then malleability is not an issue at all for transaction chains if you\n>> only need to broadcast your full transaction chain once, and don't need to\n>> extend it in two or more occasions, *after* broadcasting subchains to the\n>> network, from the same set of pregenerated transactions.\n>>\n>> If you need to broadcast pregenerated subchains separately, then you need\n>> the last child in the chain to be non-malleable.\n>>\n>> This would require all miners to start to respect it at once in order to\n>> avoid forking the network.\n>>\n>> - Sent from my phone\n>> Den 19 feb 2014 22:13 skrev \"Pieter Wuille\" <pieter.wuille at gmail.com>:\n>>\n>> On Wed, Feb 19, 2014 at 9:28 PM, Michael Gronager <gronager at mac.com>\n>>> wrote:\n>>> > I think that we could guarantee fewer incidents by making version 1\n>>> transactions unmalleable and then optionally introduce a version 3 that\n>>> supported the malleability feature. That way most existing problematic\n>>> implementations would be fixed and no doors were closed for people\n>>> experimenting with other stuff - tx v 3 would probably then be called\n>>> experimental transactions.\n>>>\n>>> Just to be clear: this change is not directly intended to avoid\n>>> \"incidents\". It will take way too long to deploy this. Software should\n>>> deal with malleability. This is a longer-term solution intended to\n>>> provide non-malleability guarantees for clients that a) are upgraded\n>>> to use them  b) willing to restrict their functionality. As there are\n>>> several intended use cases for malleable transactions (the sighash\n>>> flags pretty directly are a way to signify what malleabilities are\n>>> *wanted*), this is not about outlawing malleability.\n>>>\n>>> While we could right now make all these rules non-standard, and\n>>> schedule a soft fork in a year or so to make them illegal, it would\n>>> mean removing potential functionality that can only be re-enabled\n>>> through a hard fork. This is significantly harder, so we should think\n>>> about it very well in advance.\n>>>\n>>> About new transaction and block versions: this allows implementing and\n>>> automatically scheduling a softfork without waiting for wallets to\n>>> upgrade. The non-DER signature change was discussed for over two\n>>> years, and implemented almost a year ago, and we still notice wallets\n>>> that don't support it. We can't expect every wallet to be instantly\n>>> modified (what about hardware wallets like the Trezor, for example?\n>>> they may not just be able to be upgraded). Nor is it necessary: if\n>>> your software only spends confirmed change, and tracks all debits\n>>> correctly, there is no need.\n>>>\n>>> --\n>>> Pieter\n>>>\n>>>\n>>> ------------------------------------------------------------------------------\n>>> Managing the Performance of Cloud-Based Applications\n>>> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n>>> Read the Whitepaper.\n>>>\n>>> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk\n>>> _______________________________________________\n>>> Bitcoin-development mailing list\n>>> Bitcoin-development at lists.sourceforge.net\n>>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>>\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> Managing the Performance of Cloud-Based Applications\n>> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n>> Read the Whitepaper.\n>>\n>> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140220/00054c41/attachment.html>"
            },
            {
                "author": "Michael Gronager",
                "date": "2014-02-20T10:59:22",
                "message_text_only": "As I see the BIP it is basically stressing that ver 1 transactions are malleable.\n\nIt then addresses the need for unmalleable transactions for e.g. spending unconfirmed outputs in a deterministic way (i.e. no 3rd party can sabotage) - this transaction type is defined as ver 3.\n\nA lot of clients today spend unconfirmed outputs (even bitcoin-qt) and as such make an implicit assumption that this is kind of safe, which it is not - it can be intervened and sabotaged through tx malleability.\n\nWhat I suggested was to ensure that a subclass of version 1 transactions become unmalleable - namely those with sighash=all. Note that only the sender can modify the sighash as it is part of the hash signed. So instead of defining a version 3, we could constrain version 1 txes with sighash=all to have a unmalleable hash. If you e.g. would like to still have a sighash=all type of transaction with malleable features you can simply use that sighash=all today is checked for using sighash&0x1f=sighash_all, so just OR'ing with 0x20 or 0x40 will get you the 'old' feature.\n\nI do however buy the argument of Peter and Gregory that there might exist unpublished transactions out there that does not even conform to the DER rules etc, and as such we cannot forbid them from being mined, nor can we timestamp them and include 'only the old ones'. Hence we cannot change the consensus rule for version 1 transactions - and only changing the relay rules will not provide a certain guarantee.\n\nSo, I think the two line argument for the BIP is as follows:\n1. We cannot change the consensus rules for version 1 transactions as that might invalidate unpublished non-standard transactions (= voiding peoples money, which is a line we don't want to cross)\n2. The prime usecase for unmalleable transactions is being able to spend unconfirmed outputs - this is done today by almost all clients, but it is really broken. Hence a need for a fix asap.\n\nI am all in favor for the BIP, but I expect the realistic timeline for enforced version 3 transactions is roughly one year, which is better than two, but it would have been nice to get it faster...\n\n/M\n\n\nOn Feb 19, 2014, at 10:11 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n\n> On Wed, Feb 19, 2014 at 9:28 PM, Michael Gronager <gronager at mac.com> wrote:\n>> I think that we could guarantee fewer incidents by making version 1 transactions unmalleable and then optionally introduce a version 3 that supported the malleability feature. That way most existing problematic implementations would be fixed and no doors were closed for people experimenting with other stuff - tx v 3 would probably then be called experimental transactions.\n> \n> Just to be clear: this change is not directly intended to avoid\n> \"incidents\". It will take way too long to deploy this. Software should\n> deal with malleability. This is a longer-term solution intended to\n> provide non-malleability guarantees for clients that a) are upgraded\n> to use them  b) willing to restrict their functionality. As there are\n> several intended use cases for malleable transactions (the sighash\n> flags pretty directly are a way to signify what malleabilities are\n> *wanted*), this is not about outlawing malleability.\n> \n> While we could right now make all these rules non-standard, and\n> schedule a soft fork in a year or so to make them illegal, it would\n> mean removing potential functionality that can only be re-enabled\n> through a hard fork. This is significantly harder, so we should think\n> about it very well in advance.\n> \n> About new transaction and block versions: this allows implementing and\n> automatically scheduling a softfork without waiting for wallets to\n> upgrade. The non-DER signature change was discussed for over two\n> years, and implemented almost a year ago, and we still notice wallets\n> that don't support it. We can't expect every wallet to be instantly\n> modified (what about hardware wallets like the Trezor, for example?\n> they may not just be able to be upgraded). Nor is it necessary: if\n> your software only spends confirmed change, and tracks all debits\n> correctly, there is no need.\n> \n> -- \n> Pieter\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 496 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140220/d16136fe/attachment.sig>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-02-20T14:08:59",
                "message_text_only": "We've done forking changes before much faster than a year and that was with\nless experience. If we want, we can get this done within months.\nOn 20 Feb 2014 16:30, \"Michael Gronager\" <gronager at mac.com> wrote:\n\n> As I see the BIP it is basically stressing that ver 1 transactions are\n> malleable.\n>\n> It then addresses the need for unmalleable transactions for e.g. spending\n> unconfirmed outputs in a deterministic way (i.e. no 3rd party can sabotage)\n> - this transaction type is defined as ver 3.\n>\n> A lot of clients today spend unconfirmed outputs (even bitcoin-qt) and as\n> such make an implicit assumption that this is kind of safe, which it is not\n> - it can be intervened and sabotaged through tx malleability.\n>\n> What I suggested was to ensure that a subclass of version 1 transactions\n> become unmalleable - namely those with sighash=all. Note that only the\n> sender can modify the sighash as it is part of the hash signed. So instead\n> of defining a version 3, we could constrain version 1 txes with sighash=all\n> to have a unmalleable hash. If you e.g. would like to still have a\n> sighash=all type of transaction with malleable features you can simply use\n> that sighash=all today is checked for using sighash&0x1f=sighash_all, so\n> just OR'ing with 0x20 or 0x40 will get you the 'old' feature.\n>\n> I do however buy the argument of Peter and Gregory that there might exist\n> unpublished transactions out there that does not even conform to the DER\n> rules etc, and as such we cannot forbid them from being mined, nor can we\n> timestamp them and include 'only the old ones'. Hence we cannot change the\n> consensus rule for version 1 transactions - and only changing the relay\n> rules will not provide a certain guarantee.\n>\n> So, I think the two line argument for the BIP is as follows:\n> 1. We cannot change the consensus rules for version 1 transactions as that\n> might invalidate unpublished non-standard transactions (= voiding peoples\n> money, which is a line we don't want to cross)\n> 2. The prime usecase for unmalleable transactions is being able to spend\n> unconfirmed outputs - this is done today by almost all clients, but it is\n> really broken. Hence a need for a fix asap.\n>\n> I am all in favor for the BIP, but I expect the realistic timeline for\n> enforced version 3 transactions is roughly one year, which is better than\n> two, but it would have been nice to get it faster...\n>\n> /M\n>\n>\n> On Feb 19, 2014, at 10:11 PM, Pieter Wuille <pieter.wuille at gmail.com>\n> wrote:\n>\n> > On Wed, Feb 19, 2014 at 9:28 PM, Michael Gronager <gronager at mac.com>\n> wrote:\n> >> I think that we could guarantee fewer incidents by making version 1\n> transactions unmalleable and then optionally introduce a version 3 that\n> supported the malleability feature. That way most existing problematic\n> implementations would be fixed and no doors were closed for people\n> experimenting with other stuff - tx v 3 would probably then be called\n> experimental transactions.\n> >\n> > Just to be clear: this change is not directly intended to avoid\n> > \"incidents\". It will take way too long to deploy this. Software should\n> > deal with malleability. This is a longer-term solution intended to\n> > provide non-malleability guarantees for clients that a) are upgraded\n> > to use them  b) willing to restrict their functionality. As there are\n> > several intended use cases for malleable transactions (the sighash\n> > flags pretty directly are a way to signify what malleabilities are\n> > *wanted*), this is not about outlawing malleability.\n> >\n> > While we could right now make all these rules non-standard, and\n> > schedule a soft fork in a year or so to make them illegal, it would\n> > mean removing potential functionality that can only be re-enabled\n> > through a hard fork. This is significantly harder, so we should think\n> > about it very well in advance.\n> >\n> > About new transaction and block versions: this allows implementing and\n> > automatically scheduling a softfork without waiting for wallets to\n> > upgrade. The non-DER signature change was discussed for over two\n> > years, and implemented almost a year ago, and we still notice wallets\n> > that don't support it. We can't expect every wallet to be instantly\n> > modified (what about hardware wallets like the Trezor, for example?\n> > they may not just be able to be upgraded). Nor is it necessary: if\n> > your software only spends confirmed change, and tracks all debits\n> > correctly, there is no need.\n> >\n> > --\n> > Pieter\n>\n>\n>\n> ------------------------------------------------------------------------------\n> Managing the Performance of Cloud-Based Applications\n> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> Read the Whitepaper.\n>\n> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140220/41fc69a7/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-02-20T14:15:21",
                "message_text_only": "On Thu, Feb 20, 2014 at 6:08 AM, Mike Hearn <mike at plan99.net> wrote:\n> We've done forking changes before much faster than a year and that was with\n> less experience. If we want, we can get this done within months.\n\nYou mean P2SH... which your implementation has only picked up support\nfor in the last month or so?"
            },
            {
                "author": "Gavin Andresen",
                "date": "2014-02-20T14:29:40",
                "message_text_only": "I think we should get Pieter's proposal done and implemented quickly. I\nagree with Mike, it doesn't have to take a long time for the core network\nto fully support this.\n\nGetting wallets to start generating transaction.version=3 might take years,\nbut that is OK.\n\n-- \n--\nGavin Andresen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140220/5383f456/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-02-20T14:36:39",
                "message_text_only": "On Thu, Feb 20, 2014 at 6:29 AM, Gavin Andresen <gavinandresen at gmail.com> wrote:\n> I think we should get Pieter's proposal done and implemented quickly. I\n> agree with Mike, it doesn't have to take a long time for the core network to\n> fully support this.\n>\n> Getting wallets to start generating transaction.version=3 might take years,\n> but that is OK.\n\nSure I'm all for doing what Pieter suggested\u2014 it's basically the plan\nwe've been executing for some time already but with the version check\nto make it sane to complete.\n\nMy reserved sounding comments were relative to the proposals to do\nthings with nversion=1 transactions, frankly I think thats completely\ninsane. Though while we're on the subject of reservations, I am far\nfrom confident that we've uncovered all the possible malleability\nroutes\u2014 that list gained a new, never before discussed entry, when\nPieter was writing it a couple weeks ago.  We also have no proof of\nthe absence of further algebraic malleability in DSA (though I think\nits somewhat unlikely, a solid proof of it has been somewhat elusive)."
            },
            {
                "author": "Gavin Andresen",
                "date": "2014-02-20T14:58:30",
                "message_text_only": "Great, I'm hearing rough consensus to proceed with Pieter's plan.\n\nRE: far from confident on malleability routes:  I'm reasonably confident\nthat we can squash malleability for IsStandard, SIGHASH_ALL transactions. A\nproper proof of DSA signature un-malleability (or an lower bound for how\nmuch work it would be to create a valid doppleganger signature) would be\ngreat, but I don't think it is necessary to proceed.\n\n\nOn Thu, Feb 20, 2014 at 9:36 AM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n\n> On Thu, Feb 20, 2014 at 6:29 AM, Gavin Andresen <gavinandresen at gmail.com>\n> wrote:\n> > I think we should get Pieter's proposal done and implemented quickly. I\n> > agree with Mike, it doesn't have to take a long time for the core\n> network to\n> > fully support this.\n> >\n> > Getting wallets to start generating transaction.version=3 might take\n> years,\n> > but that is OK.\n>\n> Sure I'm all for doing what Pieter suggested-- it's basically the plan\n> we've been executing for some time already but with the version check\n> to make it sane to complete.\n>\n> My reserved sounding comments were relative to the proposals to do\n> things with nversion=1 transactions, frankly I think thats completely\n> insane. Though while we're on the subject of reservations, I am far\n> from confident that we've uncovered all the possible malleability\n> routes-- that list gained a new, never before discussed entry, when\n> Pieter was writing it a couple weeks ago.  We also have no proof of\n> the absence of further algebraic malleability in DSA (though I think\n> its somewhat unlikely, a solid proof of it has been somewhat elusive).\n>\n\n\n\n-- \n--\nGavin Andresen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140220/3a8746e1/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2014-02-20T15:11:27",
                "message_text_only": "I hereby request a BIP number.\n\n\nOn Thu, Feb 20, 2014 at 3:58 PM, Gavin Andresen <gavinandresen at gmail.com> wrote:\n> Great, I'm hearing rough consensus to proceed with Pieter's plan.\n>\n> RE: far from confident on malleability routes:  I'm reasonably confident\n> that we can squash malleability for IsStandard, SIGHASH_ALL transactions. A\n> proper proof of DSA signature un-malleability (or an lower bound for how\n> much work it would be to create a valid doppleganger signature) would be\n> great, but I don't think it is necessary to proceed.\n>\n>\n> On Thu, Feb 20, 2014 at 9:36 AM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n>>\n>> On Thu, Feb 20, 2014 at 6:29 AM, Gavin Andresen <gavinandresen at gmail.com>\n>> wrote:\n>> > I think we should get Pieter's proposal done and implemented quickly. I\n>> > agree with Mike, it doesn't have to take a long time for the core\n>> > network to\n>> > fully support this.\n>> >\n>> > Getting wallets to start generating transaction.version=3 might take\n>> > years,\n>> > but that is OK.\n>>\n>> Sure I'm all for doing what Pieter suggested-- it's basically the plan\n>> we've been executing for some time already but with the version check\n>> to make it sane to complete.\n>>\n>> My reserved sounding comments were relative to the proposals to do\n>> things with nversion=1 transactions, frankly I think thats completely\n>> insane. Though while we're on the subject of reservations, I am far\n>> from confident that we've uncovered all the possible malleability\n>> routes-- that list gained a new, never before discussed entry, when\n>> Pieter was writing it a couple weeks ago.  We also have no proof of\n>> the absence of further algebraic malleability in DSA (though I think\n>> its somewhat unlikely, a solid proof of it has been somewhat elusive).\n>\n>\n>\n>\n> --\n> --\n> Gavin Andresen\n>\n> ------------------------------------------------------------------------------\n> Managing the Performance of Cloud-Based Applications\n> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> Read the Whitepaper.\n> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-02-20T15:24:17",
                "message_text_only": "On Thu, Feb 20, 2014 at 7:11 AM, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n> I hereby request a BIP number.\n\n62 assigned."
            },
            {
                "author": "Mike Hearn",
                "date": "2014-02-21T06:07:42",
                "message_text_only": "No, I was thinking of the height in coinbase change. At any rate, p2sh was\nsupported by the consensus code in bitcoinj for a long time already, since\nit was first written.\n\nSupport for sending to such addresses in the wallet appeared once an app\nthat wanted that support also appeared, which seems OK - the market for\nwallets is very competitive so there will always be some skew in what\nfeatures are worked on in what order. V3 transactions are a consensus\nchange that wallets will pick up at different times like any other feature.\nOn 20 Feb 2014 19:45, \"Gregory Maxwell\" <gmaxwell at gmail.com> wrote:\n\n> On Thu, Feb 20, 2014 at 6:08 AM, Mike Hearn <mike at plan99.net> wrote:\n> > We've done forking changes before much faster than a year and that was\n> with\n> > less experience. If we want, we can get this done within months.\n>\n> You mean P2SH... which your implementation has only picked up support\n> for in the last month or so?\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/7742db8c/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-02-21T06:30:25",
                "message_text_only": "On Thu, Feb 20, 2014 at 10:07 PM, Mike Hearn <mike at plan99.net> wrote:\n> No, I was thinking of the height in coinbase change. At any rate, p2sh was\n> supported by the consensus code in bitcoinj for a long time already, since\n> it was first written.\n>\n> Support for sending to such addresses in the wallet appeared once an app\n> that wanted that support also appeared, which seems OK - the market for\n> wallets is very competitive so there will always be some skew in what\n> features are worked on in what order. V3 transactions are a consensus change\n> that wallets will pick up at different times like any other feature.\n\nWe're in agreement.  I had mistakenly believed you were supporting the\ndiscussion about trying to force these constraints on current version\ntransactions, in which case \"wallets will pick up at different times\"\nis an absolute deal breaker.  :)"
            },
            {
                "author": "Jeremy Spilman",
                "date": "2014-02-19T19:15:39",
                "message_text_only": "> Longer term it would be more ideal have a canonical identifier for the  \n> transaction before it even gets to the chain to support these use cases,  \n> even if >wallets are able to properly identify the status of it's  \n> transactions.  \n> -Allen\n>\n>\n\nOne possible work-around to get back trusted transaction chaining for  \npayment channels and locked refunds from multi-sig would be to make the  \ninitial transaction include zero fee, and depend on child-pays-for-parent  \nin order to get the first and follow-on transactions into a block. This of  \ncourse only works for protocols where the parties don't need the initial  \nfunding transaction to actually hit the blockchain right away.\n\nBut this relies on two assumptions; 1) that miners won't include a  \nzero-fee transaction in the blockchain, and 2) that miners actually  \nimplement child-pays-for-parent. It's definitely not the same security  \nas-if you had immutable txid, but it's something to consider.\n\n1) Mutants may cause wallet spam and difficulty calculating balance (and  \nwallets will evolve to deal with it)\n2) Mutants cause DoS because they can interfere with your own transaction  \nchains, which for example makes batch off-line processing much more  \ndifficult\n3) Mutants introduce a 3rd party attacker into any two-party protocol that  \nrelies on chains\n\nThere's a lot to digest in the 'v3' transaction/block proposal. It sounds  \nlike there may be some uncertainty over whether we can *prove* that v3  \ntransactions in v3 blocks would actually be guaranteed immutable with  \nthese changes?\n\nIf we cannot fully prove a Tx is immutable, then is it actually worth  \ntaking steps to make it seem immutable, or is that just a false sense of  \nsecurity in the cases where chained transactions were actually expected to  \nbe reliable? Under that thinking, maybe it's best to accept mutants as a  \nfact of life, and only consider protocols and techniques that cannot be  \nbroken by mutants.\n\nIn what cases does reducing the sources of malleability, but not  \nnecessarily eliminating from a security proof perspective, actually help?  \nBasically, if we don't know that we will succeed, isn't there really no  \npoint in trying?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140219/d695d83f/attachment.html>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-02-12T17:13:03",
                "message_text_only": "On Wed, Feb 12, 2014 at 10:12 AM, Rune Kj\u00e6r Svendsen\n<runesvend at gmail.com> wrote:\n> Instead of trying to remove the possibility of transaction\n> malleability, would it make sense to define a new, \"canonical\n> transaction hash/ID\" (cTxID),\n\nYes, that is one proposal:  https://github.com/sipa/bitcoin/commits/normtxid\n\nBut it is not a complete solution for all transaction types.\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Pieter Wuille",
                "date": "2014-02-12T17:21:39",
                "message_text_only": "It's also not necessary for wallet software - it's really just for\nhuman consumption.\n\nA wallet can easily detect inputs being respent in another\ntransaction. You don't need a static hash for that (which wouldn't\nneed with all hash types, non-malleability double spends, ...).\n\nOn Wed, Feb 12, 2014 at 6:13 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:\n> On Wed, Feb 12, 2014 at 10:12 AM, Rune Kj\u00e6r Svendsen\n> <runesvend at gmail.com> wrote:\n>> Instead of trying to remove the possibility of transaction\n>> malleability, would it make sense to define a new, \"canonical\n>> transaction hash/ID\" (cTxID),\n>\n> Yes, that is one proposal:  https://github.com/sipa/bitcoin/commits/normtxid\n>\n> But it is not a complete solution for all transaction types.\n>\n> --\n> Jeff Garzik\n> Bitcoin core developer and open source evangelist\n> BitPay, Inc.      https://bitpay.com/\n>\n> ------------------------------------------------------------------------------\n> Android apps run on BlackBerry 10\n> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.\n> Now with support for Jelly Bean, Bluetooth, Mapview and more.\n> Get your Android app in front of a whole new audience.  Start now.\n> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-02-12T18:03:21",
                "message_text_only": "On Wed, Feb 12, 2014 at 7:12 AM, Rune Kj\u00e6r Svendsen <runesvend at gmail.com> wrote:\n> Instead of trying to remove the possibility of transaction\n> malleability, would it make sense to define a new, \"canonical\n> transaction hash/ID\" (cTxID), which would be a hash of the part of the\n> transaction data which we know is not malleable, and have clients use\n> this cTxID internally, thus making the traditional transaction hash\n> irrelevant for a client to function correctly?\n\nThis is fine and good. But it only scratches the surface of the\nproblems created by malleability, especially for fancier transaction\nprotocols.\n\nMutation allows you to invalidate a chain of unconfirmed transaction\nby mutating the parent. This breaks any protocol which depends on\ncreating a precomputed nlocked time refund transaction.\n\nSo a canonical ID can be used to prevent some buggy behavior it\ndoesn't actually fix the problem. Fortunately the non-fixed parts\naren't too critical today.\n\nOn Wed, Feb 12, 2014 at 8:22 AM, Alan Reiner <etotheipi at gmail.com> wrote:\n> I think the solution is simply to encourage Bitcoin software developers to\n> design their software to use this static ID, instead of the full transaction\n> hash.    If MtGox had talked those IDs instead of the TX ID, their software\n> would've correctly identified the mutated transactions and there would be\n> no problem.\n\nThis is incorrect.  MtGox was automatically issuing replacement\ntransactions resulting in double payments.\n\nWhen you attempt to replace/reissue/cancel a transaction you __MUST__\ndouble-spend the original transaction. If the original transaction has\nnot been conflicted then it is possible someone will pull the original\ntransaction out of a hat and both your replacement and the original\nwill be confirmed.  It is not safe at any time to look to see if the\noriginal has been confirmed yet, and if not reissue\u2014 not because\nmutation may mean you're looking in the wrong place\u2014 but because the\nstate of the world could change nano-seconds after you looked.\n\nIf you do double-spend the original then there is no chance that both\nwill go through, you'll have atomic exclusion and only one transaction\nor the other will be confirmed."
            },
            {
                "author": "Luke-Jr",
                "date": "2014-02-10T04:39:28",
                "message_text_only": "On Sunday, February 09, 2014 11:33:02 PM Pieter Wuille wrote:\n> The proposed document is here: https://gist.github.com/sipa/8907691\n\nRule 3 & 4 are already enforced.\n\nAFAIK nVersion==3 transactions are not currently considered non-standard?\n\nLuke"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2014-02-12T16:56:35",
                "message_text_only": "On 02/10/2014 12:33 AM, Pieter Wuille wrote:\n> The proposed document is here: https://gist.github.com/sipa/8907691\n\nIf we are bumping nVersion, how about dropping DER encoding completely\nand using just 64 bytes directly for signature?\n\nAlso using 2 different variable integer encodings (in addition to what\nDER already does) is very confusing.\n\n-- \nBest Regards / S pozdravom,\n\nPavol Rusnak <stick at gk2.sk>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2014-02-12T17:22:50",
                "message_text_only": "On Wed, Feb 12, 2014 at 5:56 PM, Pavol Rusnak <stick at gk2.sk> wrote:\n> On 02/10/2014 12:33 AM, Pieter Wuille wrote:\n>> The proposed document is here: https://gist.github.com/sipa/8907691\n>\n> If we are bumping nVersion, how about dropping DER encoding completely\n> and using just 64 bytes directly for signature?\n\nThat would be a hard fork. Certainly something to be discussed if we\never introduce a version-2 scripting language, but that's a long-term\nthing.\n\n-- \nPieter"
            },
            {
                "author": "Alan Reiner",
                "date": "2014-02-12T18:21:23",
                "message_text_only": "We're talking about two slightly different things.  If their system had\ntracked by inputs and outputs (or some kind of static ID) , their system\nwouldn't have been issuing refunds/replacements/cancellations in the first\nplace.\n\nI agree with you that the reissuing code should also guarantee that both TX\ncan't be valid... But really their system should do both.   Without the I/O\nbased tracking their bookkeeping will be off, regardless of the reissuing\ncode,  because they can't properly associate outgoing transactions with\ncustomer accounts/actions.\n\nSent from my overpriced smartphone\nOn Feb 12, 2014 1:06 PM, \"Gregory Maxwell\" <gmaxwell at gmail.com> wrote:\n\nOn Wed, Feb 12, 2014 at 7:12 AM, Rune Kj\u00e6r Svendsen <runesvend at gmail.com>\nwrote:\n> Instead of trying to remove the possibility of transaction\n> malleability, would it make sense to define a new, \"canonical\n> transaction hash/ID\" (cTxID), which would be a hash of the part of the\n> transaction data which we know is not malleable, and have clients use\n> this cTxID internally, thus making the traditional transaction hash\n> irrelevant for a client to function correctly?\n\nThis is fine and good. But it only scratches the surface of the\nproblems created by malleability, especially for fancier transaction\nprotocols.\n\nMutation allows you to invalidate a chain of unconfirmed transaction\nby mutating the parent. This breaks any protocol which depends on\ncreating a precomputed nlocked time refund transaction.\n\nSo a canonical ID can be used to prevent some buggy behavior it\ndoesn't actually fix the problem. Fortunately the non-fixed parts\naren't too critical today.\n\nOn Wed, Feb 12, 2014 at 8:22 AM, Alan Reiner <etotheipi at gmail.com> wrote:\n> I think the solution is simply to encourage Bitcoin software developers to\n> design their software to use this static ID, instead of the full\ntransaction\n> hash.    If MtGox had talked those IDs instead of the TX ID, their\nsoftware\n> would've correctly identified the mutated transactions and there would be\n> no problem.\n\nThis is incorrect.  MtGox was automatically issuing replacement\ntransactions resulting in double payments.\n\nWhen you attempt to replace/reissue/cancel a transaction you __MUST__\ndouble-spend the original transaction. If the original transaction has\nnot been conflicted then it is possible someone will pull the original\ntransaction out of a hat and both your replacement and the original\nwill be confirmed.  It is not safe at any time to look to see if the\noriginal has been confirmed yet, and if not reissue-- not because\nmutation may mean you're looking in the wrong place-- but because the\nstate of the world could change nano-seconds after you looked.\n\nIf you do double-spend the original then there is no chance that both\nwill go through, you'll have atomic exclusion and only one transaction\nor the other will be confirmed.\n\n------------------------------------------------------------------------------\nAndroid apps run on BlackBerry 10\nIntroducing the new BlackBerry 10.2.1 Runtime for Android apps.\nNow with support for Jelly Bean, Bluetooth, Mapview and more.\nGet your Android app in front of a whole new audience.  Start now.\nhttp://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk\n_______________________________________________\nBitcoin-development mailing list\nBitcoin-development at lists.sourceforge.net\nhttps://lists.sourceforge.net/lists/listinfo/bitcoin-development\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140212/332272c2/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Dealing with malleability",
            "categories": [
                "Bitcoin-development",
                "RFC",
                "BIP proposal"
            ],
            "authors": [
                "Jeff Garzik",
                "Luke-Jr",
                "Michael Gronager",
                "Natanael",
                "Mike Hearn",
                "Pavol Rusnak",
                "Pieter Wuille",
                "Peter Todd",
                "Alan Reiner",
                "Rune Kj\u00e6r Svendsen",
                "Alex Morcos",
                "Gregory Maxwell",
                "Mark Friedenbach",
                "Gavin Andresen",
                "Jeremy Spilman",
                "Allen Piscitello"
            ],
            "messages_count": 38,
            "total_messages_chars_count": 97482
        }
    },
    {
        "title": "[Bitcoin-development] Malware authors and best practices for addressing the issue from development / licensing perspective or other",
        "thread_messages": [
            {
                "author": "Odinn Cyberguerrilla",
                "date": "2014-02-10T00:31:51",
                "message_text_only": "Hello,\n\nI have a request, which is how do developers address the circumstance in\nwhich someone utilizes your code as part of some effort to deprive (or\nsteal as the case may be) someone of their bitcoin?\n\nThis hasn't happened to me, but I have posed a question about it at\nbitcointalk:\n\nhttps://bitcointalk.org/index.php?topic=454903.msg5045596#msg5045596\n\nIt was prompted by the apparent use of sx by a malware author who then\ngenerated something called Stealthbit (which is malware, and which no-one\nshould touch).  [fortunately I have not tried to access or use\nStealthbit.)  However, this is a question that also touches on bitcoin\ndevelopment generally, due to that (it's happened before, it will happen\nagain, etc.) people may end up using bitcoin code (if they haven't\nalready) to develop something else that would then be used expressly to\ndeprive someone of their bitcoins (such as steal them, but I am not\nthinking only of theft here).  My question for developers is:  Given that\ncode is open source and anything can be done with it, good or bad, what\nare common development approaches to mitigate or potentially prevent\nmalware authors from being able to easily appropriate the code you\ndevelop?\n\nI realize this question may sound dumb and out of place being that it is\npretty obvious that code which is developed in a free, open source context\ncan technically be used for anything.  However, beyond suggesting that\npeople just go to bitcoin.org for wallet technology, what can be done in\nthe development community that would lessen the likelihood that the code\nyou develop might be \"misappropriated?\"  Please note: I am not sure how\nthis issue might be approached from a development perspective, or license\n(MIT, Affero GPL, etc.) perspective, or any other perspective.. I'm just\nasking the question.  I support bitcoin and other decentralized currency\nefforts including walled development such as darkwallet, and I appreciate\nwhat you all are doing.  Maybe I'm asking the wrong question and it should\nbe put another way, but I hope you will rephrase my question(s) in a way\nthat makes more sense in the context of the list discussion here.\n\nThanks for your work."
            }
        ],
        "thread_summary": {
            "title": "Malware authors and best practices for addressing the issue from development / licensing perspective or other",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Odinn Cyberguerrilla"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2175
        }
    },
    {
        "title": "[Bitcoin-development] MtGox blames bitcoin",
        "thread_messages": [
            {
                "author": "Drak",
                "date": "2014-02-10T11:28:28",
                "message_text_only": "What is the official response from the Bitcoin Core developers about\nMtGox's assertion that their problems are due to a fault of bitcoin, as\nopposed to a fault of their own?\n\nThe technical analysis preluding this mess, was that MtGox was at fault for\ntheir faulty wallet implementation.\n\nDrak\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140210/dd667928/attachment.html>"
            },
            {
                "author": "sickpig at gmail.com",
                "date": "2014-02-10T11:54:36",
                "message_text_only": "Hi,\n\nOn Mon, Feb 10, 2014 at 12:28 PM, Drak <drak at zikula.org> wrote:\n> What is the official response from the Bitcoin Core developers about MtGox's\n> assertion that their problems are due to a fault of bitcoin, as opposed to a\n> fault of their own?\n>\n> The technical analysis preluding this mess, was that MtGox was at fault for\n> their faulty wallet implementation.\n\nthis seems a fair explanation of what happened:\n\nhttp://www.reddit.com/r/Bitcoin/comments/1x93tf/some_irc_chatter_about_what_is_going_on_at_mtgox/cf99yac"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-02-10T12:25:34",
                "message_text_only": "On Mon, Feb 10, 2014 at 3:28 AM, Drak <drak at zikula.org> wrote:\n> What is the official response from the Bitcoin Core developers about MtGox's\n> assertion that their problems are due to a fault of bitcoin, as opposed to a\n> fault of their own?\n>\n> The technical analysis preluding this mess, was that MtGox was at fault for\n> their faulty wallet implementation.\n\nIn the real world fault seldom falls in a single place. Bitcoin is at\nfault\u2014 in many places\u2014 for making it harder for implementers to get\nthings right.   MtGox is at fault for not implementing in a way that\ncopes with behaviors in the Bitcoin protocol which have been known\nsince at least 2011.\n(https://en.bitcoin.it/wiki/Transaction_Malleability).\n\nNot that Bitcoin-QT handles Malleability fantastically\u2014 but because it\ntracks inputs it will still detect the mutant transactions.\n\nAn interesting point which I haven't pointed out elsewhere is that for\nthe question of basic funds safety in re-issuing a transaction\nmallablity is basically irrelevant.\n\nSay you pay someone and it doesn't go through (or it does and you\ndon't see it because its been mutated and your software can't detect\nthat), and they ask you to reissue.... if you reissue without\ndouble-spending any of the original inputs you are at risk of getting\nrobbed. This is true with or without malleability.  Without the\ndouble-spend of at least one input the original transaction could just\ngo through in addition to your reissue.\n\nSay that you do make sure to double spend at least one input\u2014  then\nthe result is funds safe safe, regardless of if a mutation happened.\n\nSay you want to support _canceling_ a payment (send me the goat\ninstead!) rather than reissue you still must double-spend the\nattempted payment to cancel it, since it still might go through if you\ndon't.  And the double spend works to protect this case regardless of\nif the transaction was mutated.\n\nFor support and accounting purposes you absolutely do need tools to\nidentify mutated transactions, so long as mutation exists... so we\nought to provide some better tools there.  But I can't think a case\nwhere mutation handling is necessary or sufficient for cancellation\nsecurity, but\u2014 rather\u2014 input tracking appears to be both necessary and\nsufficient in all cancellation cases.\n\nThis helps explain why Bitcoin-QT\u2014 whos mutation handling kinda\nstinks\u2014 doesn't ever end up in a really bad situation with mutants: it\ntracks inputs pretty well.\n\nIn any case, I've always been happy to help out Mtgox with technical\nissues. Having some specs for a stable transaction ID would probably\nbe helpful to many applications, even if it isn't the critical key you\nneed for cancellation security.  Removing mallability entirely has\nbeen a soft long term goal, and there were recently (as in today) some\nposts about it\u2014 look at the list archives... though it won't happen\nfast since all signers/wallets will need to be updated."
            },
            {
                "author": "Isidor Zeuner",
                "date": "2014-02-10T14:40:03",
                "message_text_only": ">\n> What is the official response from the Bitcoin Core developers about\n> MtGox's assertion that their problems are due to a fault of bitcoin, as\n> opposed to a fault of their own?\n>\n> The technical analysis preluding this mess, was that MtGox was at fault for\n> their faulty wallet implementation.\n>\n\nI'm not a core developer, but I would certainly hope that those\nwho have commit access to the Bitcoin repository don't let\nthemselves be pressured by a company holding back user funds in order\nto get a patch included into the Bitcoin source code.\n\nI think this is less a matter of whose fault it is if a company\nrunning a custom wallet implementation has problems peering with a\nnetwork mostly running another, community-based wallet\nimplementation. It is a matter of common sense that it's just not\npractical to try to quickly apply an update to a distributed network,\nwhich may possibly cause problems with peering and consensus\nfinding. When working with a protocol based on mutual agreement of a\nlarge user base, a single entity like MtGox would be better off trying\nto have their preferred changes implemented slowly if at all, while\nsolving their immediate issues on their side. Problems with\ntransactions being accepted can often be solved by changing the wallet\nclient's way of peering with other nodes, without changing the\nprotocol at all.\n\nThinking this further, I am kind of surprised that something like this\ncan even become an issue worth discussing. I never heard of a bank\nwhich would try to create pressure by suspending money withdrawals\nuntil the TCP/IP protocol is changed to match their preferences.\n\nBest regards,\n\nIsidor Zeuner"
            },
            {
                "author": "Troy Benjegerdes",
                "date": "2014-02-10T16:30:55",
                "message_text_only": "On Mon, Feb 10, 2014 at 03:40:03PM +0100, Isidor Zeuner wrote:\n> >\n> > What is the official response from the Bitcoin Core developers about\n> > MtGox's assertion that their problems are due to a fault of bitcoin, as\n> > opposed to a fault of their own?\n> >\n> > The technical analysis preluding this mess, was that MtGox was at fault for\n> > their faulty wallet implementation.\n> >\n> \n> I'm not a core developer, but I would certainly hope that those\n> who have commit access to the Bitcoin repository don't let\n> themselves be pressured by a company holding back user funds in order\n> to get a patch included into the Bitcoin source code.\n\nThis isn't about developers.\n\nThis is about venture capitalists taking lots of money from unsuspecting\ninvestors, and MtGox is in a psy-ops PR-war with multiple other exchanges\nand lots of places that would like to take their market share and money.\n\nWhy do you want the 'official' PR-spin-war response approved by the official\nbitcoin developer PR-firm, who's probably being paid by competitors to MtGox?\n\nName me one single person with commit access to the bitcoin github repository\nwho is *independent* of any venture capital or other 'investment' connections.\n\nFortunately for the rest of us, any dumb farmer can create a copycatcoin\n\nHell, if MtGox hosted their *own* fork of bitcoin I'd run that in a heartbeat.\n\n\nAnd for full disclosure, I am available for consulting if anyone would like \nassistance setting up and hosting an independent source code repository that\nincludes good automated regression tests.\n\n\n-- Troy"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-02-10T16:45:03",
                "message_text_only": "On Mon, Feb 10, 2014 at 8:30 AM, Troy Benjegerdes <hozer at hozed.org> wrote:\n> Name me one single person with commit access to the bitcoin github repository\n> who is *independent* of any venture capital or other 'investment' connections.\n\nI am, unless you count the fact that I own some Bitcoin and some\nmining hardware as \"'investment' connections\" (and that case your\ncomments are worthless).\n\n(By not naming anyone else I don't mean to imply there are no others,\nbut I don't want to speak for anyone else. Nor would I necessarily\nexpect the other part(ies|y) to step forward, since this mostly\nappears to be an invitation to step up and be attacked.)"
            },
            {
                "author": "Troy Benjegerdes",
                "date": "2014-02-10T18:25:06",
                "message_text_only": "On Mon, Feb 10, 2014 at 08:45:03AM -0800, Gregory Maxwell wrote:\n> On Mon, Feb 10, 2014 at 8:30 AM, Troy Benjegerdes <hozer at hozed.org> wrote:\n> > Name me one single person with commit access to the bitcoin github repository\n> > who is *independent* of any venture capital or other 'investment' connections.\n> \n> I am, unless you count the fact that I own some Bitcoin and some\n> mining hardware as \"'investment' connections\" (and that case your\n> comments are worthless).\n> \n> (By not naming anyone else I don't mean to imply there are no others,\n> but I don't want to speak for anyone else. Nor would I necessarily\n> expect the other part(ies|y) to step forward, since this mostly\n> appears to be an invitation to step up and be attacked.)\n\nThank you.\n\nI also appreciate your commentary[1], and willingness to list your investment\nposition. What I'm concerned about are people who have signed non-disclosure \nagreements or who's salary/equity/whatever depend on people who are experts\nat manipulating markets to take naive investors money.\n\nIndependent is also a state of mind as much as it is about financial connections.\n\nWhat pisses me off here is that a huge amount of wealth just changed hands based\non MtGox's press release, and it stinks of insider trading. I still maintain the\nbest outcome would be for MtGox to AGPLv3 release their code, and then those of \nus that understand it would be able to have a public technical discussion about\nhow to fix it, and MtGox would still maintain their intellectual property\nownership position.\n\nThis, however, cuts off a significant revenue stream for people who take money\nmaking market bets 5 minutes before the information goes public, so I expect\nthe likelyhood of such an outbreak of sanity is quite low.\n\n[1] http://www.cryptocoinsnews.com/2014/02/10/mt-gox-blames-bitcoin-core-developer-greg-maxwell-responds/\n\n\nDISCLAIMER: I have a significant emotional investment in copyleft/viral copyright\ndevelopment models, and I expect to take a lot of money charging people to write\ncode I give away for free. I also occasionally make money from cryptocurrency\nmining, but only when I can sell it in functional and transparent markets."
            },
            {
                "author": "Jameson Lopp",
                "date": "2014-02-10T18:45:58",
                "message_text_only": "You have plenty of good points, but they are not relevant to this mailing list. I suggest you take them elsewhere.\n--\nJameson Lopp\nSoftware Engineer\nBronto Software, Inc\n\nOn 02/10/2014 01:25 PM, Troy Benjegerdes wrote:\n> On Mon, Feb 10, 2014 at 08:45:03AM -0800, Gregory Maxwell wrote:\n>> On Mon, Feb 10, 2014 at 8:30 AM, Troy Benjegerdes <hozer at hozed.org> wrote:\n>>> Name me one single person with commit access to the bitcoin github repository\n>>> who is *independent* of any venture capital or other 'investment' connections.\n>>\n>> I am, unless you count the fact that I own some Bitcoin and some\n>> mining hardware as \"'investment' connections\" (and that case your\n>> comments are worthless).\n>>\n>> (By not naming anyone else I don't mean to imply there are no others,\n>> but I don't want to speak for anyone else. Nor would I necessarily\n>> expect the other part(ies|y) to step forward, since this mostly\n>> appears to be an invitation to step up and be attacked.)\n> \n> Thank you.\n> \n> I also appreciate your commentary[1], and willingness to list your investment\n> position. What I'm concerned about are people who have signed non-disclosure \n> agreements or who's salary/equity/whatever depend on people who are experts\n> at manipulating markets to take naive investors money.\n> \n> Independent is also a state of mind as much as it is about financial connections.\n> \n> What pisses me off here is that a huge amount of wealth just changed hands based\n> on MtGox's press release, and it stinks of insider trading. I still maintain the\n> best outcome would be for MtGox to AGPLv3 release their code, and then those of \n> us that understand it would be able to have a public technical discussion about\n> how to fix it, and MtGox would still maintain their intellectual property\n> ownership position.\n> \n> This, however, cuts off a significant revenue stream for people who take money\n> making market bets 5 minutes before the information goes public, so I expect\n> the likelyhood of such an outbreak of sanity is quite low.\n> \n> [1] http://www.cryptocoinsnews.com/2014/02/10/mt-gox-blames-bitcoin-core-developer-greg-maxwell-responds/\n> \n> \n> DISCLAIMER: I have a significant emotional investment in copyleft/viral copyright\n> development models, and I expect to take a lot of money charging people to write\n> code I give away for free. I also occasionally make money from cryptocurrency\n> mining, but only when I can sell it in functional and transparent markets.\n> \n> ------------------------------------------------------------------------------\n> Android&trade; apps run on BlackBerry&reg;10\n> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.\n> Now with support for Jelly Bean, Bluetooth, Mapview and more.\n> Get your Android app in front of a whole new audience.  Start now.\n> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Gavin Andresen",
                "date": "2014-02-10T18:53:16",
                "message_text_only": "RE: taking discussion elsewhere:\n\nYes, please, the purpose of this mailing list is technical discussions to\nencourage interoperability of Bitcoin implementations, improve ease-of-use\nand security, etc.\n\n-- \n--\nGavin Andresen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140210/165de986/attachment.html>"
            },
            {
                "author": "Troy Benjegerdes",
                "date": "2014-02-10T19:07:03",
                "message_text_only": "If you've got any ideas for a better forum, let me know.\n\nMtGox is one of the largest public faces of the code being developed here. If\nthe public perception is that this is a bitcoin protocol flaw, then we need\nsome damned strong and compelling public arguments about why it ain't so. But\nafter some thought, that's not the critical issue I want to raise on this list.\n\nIf something about the implementation, the protocol, of bitcoin-qt or bitcoind\nmakes it easy for an attacker to mutate transactions and hard for an 'end-user'\nsuch as MtGox to confirm payments, then we've got a fundamental user-interface\nflaw.\n\nWe can get all indignant about RTFM or telling the users they are idiots, but\nthat's not really going to be good for long-term adoption and use.\n\nMy opinion is part of the development process should be to react to public\nperceptions of how the code is being used (and mis-used), and how the market is\nbeing manipulated, and try to improve it so the whole system is stable,\npredictable, and friendly to users.\n\n\nOn Mon, Feb 10, 2014 at 01:45:58PM -0500, Jameson Lopp wrote:\n> You have plenty of good points, but they are not relevant to this mailing list. I suggest you take them elsewhere.\n> --\n> Jameson Lopp\n> Software Engineer\n> Bronto Software, Inc\n> \n> On 02/10/2014 01:25 PM, Troy Benjegerdes wrote:\n> > On Mon, Feb 10, 2014 at 08:45:03AM -0800, Gregory Maxwell wrote:\n> >> On Mon, Feb 10, 2014 at 8:30 AM, Troy Benjegerdes <hozer at hozed.org> wrote:\n> >>> Name me one single person with commit access to the bitcoin github repository\n> >>> who is *independent* of any venture capital or other 'investment' connections.\n> >>\n> >> I am, unless you count the fact that I own some Bitcoin and some\n> >> mining hardware as \"'investment' connections\" (and that case your\n> >> comments are worthless).\n> >>\n> >> (By not naming anyone else I don't mean to imply there are no others,\n> >> but I don't want to speak for anyone else. Nor would I necessarily\n> >> expect the other part(ies|y) to step forward, since this mostly\n> >> appears to be an invitation to step up and be attacked.)\n> > \n> > Thank you.\n> > \n> > I also appreciate your commentary[1], and willingness to list your investment\n> > position. What I'm concerned about are people who have signed non-disclosure \n> > agreements or who's salary/equity/whatever depend on people who are experts\n> > at manipulating markets to take naive investors money.\n> > \n> > Independent is also a state of mind as much as it is about financial connections.\n> > \n> > What pisses me off here is that a huge amount of wealth just changed hands based\n> > on MtGox's press release, and it stinks of insider trading. I still maintain the\n> > best outcome would be for MtGox to AGPLv3 release their code, and then those of \n> > us that understand it would be able to have a public technical discussion about\n> > how to fix it, and MtGox would still maintain their intellectual property\n> > ownership position.\n> > \n> > This, however, cuts off a significant revenue stream for people who take money\n> > making market bets 5 minutes before the information goes public, so I expect\n> > the likelyhood of such an outbreak of sanity is quite low.\n> > \n> > [1] http://www.cryptocoinsnews.com/2014/02/10/mt-gox-blames-bitcoin-core-developer-greg-maxwell-responds/\n> > \n> > \n> > DISCLAIMER: I have a significant emotional investment in copyleft/viral copyright\n> > development models, and I expect to take a lot of money charging people to write\n> > code I give away for free. I also occasionally make money from cryptocurrency\n> > mining, but only when I can sell it in functional and transparent markets.\n> > \n> > ------------------------------------------------------------------------------\n> > Android&trade; apps run on BlackBerry&reg;10\n> > Introducing the new BlackBerry 10.2.1 Runtime for Android apps.\n> > Now with support for Jelly Bean, Bluetooth, Mapview and more.\n> > Get your Android app in front of a whole new audience.  Start now.\n> > http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk\n> > _______________________________________________\n> > Bitcoin-development mailing list\n> > Bitcoin-development at lists.sourceforge.net\n> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> > \n> \n> ------------------------------------------------------------------------------\n> Androi apps run on BlackBerry 10\n> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.\n> Now with support for Jelly Bean, Bluetooth, Mapview and more.\n> Get your Android app in front of a whole new audience.  Start now.\n> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-10T19:23:08",
                "message_text_only": "On Mon, Feb 10, 2014 at 01:07:03PM -0600, Troy Benjegerdes wrote:\n> If you've got any ideas for a better forum, let me know.\n\nYour political conversations would be welcome at unsystem at lists.dyne.org\n\nSee you there.\n\n-- \n'peter'[:-1]@petertodd.org\n0000000077ddbd0b6faa6d6fe50cdc7808dea5db5b538f85b736ede8515c54c7\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140210/eb5d602f/attachment.sig>"
            },
            {
                "author": "naman naman",
                "date": "2014-02-10T19:30:21",
                "message_text_only": "Hi guys,\n\nPlease check this thread\nhttps://bitcointalk.org/index.php?topic=458608.0for a possible attack\nscenario.\n\nAlready mailed Gavin, Mike Hearn and Adam about this :\n\nSee if it makes sense.\n\n\nOn Tue, Feb 11, 2014 at 12:53 AM, Peter Todd <pete at petertodd.org> wrote:\n\n> On Mon, Feb 10, 2014 at 01:07:03PM -0600, Troy Benjegerdes wrote:\n> > If you've got any ideas for a better forum, let me know.\n>\n> Your political conversations would be welcome at unsystem at lists.dyne.org\n>\n> See you there.\n>\n> --\n> 'peter'[:-1]@petertodd.org\n> 0000000077ddbd0b6faa6d6fe50cdc7808dea5db5b538f85b736ede8515c54c7\n>\n>\n> ------------------------------------------------------------------------------\n> Androi apps run on BlackBerry 10\n> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.\n> Now with support for Jelly Bean, Bluetooth, Mapview and more.\n> Get your Android app in front of a whole new audience.  Start now.\n>\n> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140211/304f18df/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-10T19:40:32",
                "message_text_only": "On Tue, Feb 11, 2014 at 01:00:21AM +0530, naman naman wrote:\n> Hi guys,\n> \n> Please check this thread\n> https://bitcointalk.org/index.php?topic=458608.0for a possible attack\n> scenario.\n> \n> Already mailed Gavin, Mike Hearn and Adam about this :\n> \n> See if it makes sense.\n\nThat's basically what appears to have happened with Mt. Gox.\n\nPreventing the attack is as simple as training your customer service\npeople to ask the customer if their wallet software shows a payment to a\nspecific address of a specific amount at some approximate time. Making\nexact payment amounts unique - add a few satoshis - is a trivial if\nslightly ugly way of making sure payments can be identified uniquely\nover the phone. That the procedure at Mt. Gox let front-line customer\nservice reps manually send funds to customers without a proper\ninvestigation of why the funds didn't arrive was a serious mistake on\ntheir part.\n\nUltimately this is more of a social engineering attack than a technical\none, and a good example of why well-thought-out payment protocols are\nhelpful. Though the BIP70 payment protocol doesn't yet handle busines to\nindividual, or individual to indivudal, payments a future iteration can\nand this kind of problem will be less of an issue.\n\nSimilarly stealth addresses have an inherent per-tx unique identifier,\nthe derived pubkey, which a UI might be able to take advantage of.\n\n-- \n'peter'[:-1]@petertodd.org\n0000000076654614e7bf72ac80d47c57bca12503989f4d602538d3cd7892ca7d\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140210/eff54755/attachment.sig>"
            },
            {
                "author": "Drak",
                "date": "2014-02-10T16:49:21",
                "message_text_only": "Well done Gavin for quickly setting the record straight[1] officially as\nproject lead. MtGox tried to blame their issues by throwing Bitcoin under a\nbus and I am glad there has been a public rebuttal showing up their\nincompetence which is doing harm to the bitcoin eco system. Basically, yes\nthere are issues, but MtGox should have worked around it.\n\nAlso thanks to Gregory for also writing[2] about the matter.\n\nDrak\n\n[1] https://bitcoinfoundation.org/blog/?p=418\n[2]\nhttp://www.cryptocoinsnews.com/2014/02/10/mt-gox-blames-bitcoin-core-developer-greg-maxwell-responds/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140210/f7a24071/attachment.html>"
            },
            {
                "author": "naman naman",
                "date": "2014-02-11T20:42:02",
                "message_text_only": "I was talking about a DOS attack in\nhttps://bitcointalk.org/index.php?topic=458608.0 (ofcourse only applicable\nto entitys doing the tracking with txids).\n\nAmazing how I did not get a response from any of the devs (except Greg's\nresponse\nhttps://bitcointalk.org/index.php?topic=458608.msg5063789#msg5063789 but\nthat too was short and not concerning the attack scenario plausibiity as I\nreplied to him).\n\nToday they are apparently at work here\nhttps://github.com/bitcoin/bitcoin/pull/3651\n\nAmazing how nobody acknowledges it until later when the attack already\nhappens. The devs need to show some greater level of responsibility.\n\nDon't get me wrong - I am not trying to claim credit for the attack scheme\ndescribed (though I do not know of any other place where this was mentioned\nearlier as an attack scheme), but I am trying to make the point that people\nshould just be around and at least make others feel that their concerns are\nbeing read. Now putting this on some place like reddit will only give the\ncommunity a bad name.\n\nOn a lighter note I messaged some of the devs (as my previous mail says)\nsaying the attack should be called \"thenoblebot\" attack (after my handle,\nwhich would inspire me to pursue crypto studies further). It was meant to\nbe a lame joke. But I had no idea how it would start causing so much\ndisruption in the ecosystem.\n\nRegards\nthenoblebot\n\n\nOn Tue, Feb 11, 2014 at 2:03 AM, Vocatus Gate <vocatus.gate at gmail.com>wrote:\n\n>  It's quite simple, really:\n>\n> Unique transaction == (Inputs+Outputs+ReceivingAddress)\n>\n> Problem solved. Simply don't rely on TxID for tracking. Can we put this\n> issue to rest and move on?\n>\n>\n>\n>\n> On 2014-02-10 12:40 PM, Peter Todd wrote:\n>\n> On Tue, Feb 11, 2014 at 01:00:21AM +0530, naman naman wrote:\n>\n>  Hi guys,\n>\n> Please check this threadhttps://bitcointalk.org/index.php?topic=458608.0for a possible attack\n> scenario.\n>\n> Already mailed Gavin, Mike Hearn and Adam about this :\n>\n> See if it makes sense.\n>\n>  That's basically what appears to have happened with Mt. Gox.\n>\n> Preventing the attack is as simple as training your customer service\n> people to ask the customer if their wallet software shows a payment to a\n> specific address of a specific amount at some approximate time. Making\n> exact payment amounts unique - add a few satoshis - is a trivial if\n> slightly ugly way of making sure payments can be identified uniquely\n> over the phone. That the procedure at Mt. Gox let front-line customer\n> service reps manually send funds to customers without a proper\n> investigation of why the funds didn't arrive was a serious mistake on\n> their part.\n>\n> Ultimately this is more of a social engineering attack than a technical\n> one, and a good example of why well-thought-out payment protocols are\n> helpful. Though the BIP70 payment protocol doesn't yet handle busines to\n> individual, or individual to indivudal, payments a future iteration can\n> and this kind of problem will be less of an issue.\n>\n> Similarly stealth addresses have an inherent per-tx unique identifier,\n> the derived pubkey, which a UI might be able to take advantage of.\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> Androi apps run on BlackBerry 10\n> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.\n> Now with support for Jelly Bean, Bluetooth, Mapview and more.\n> Get your Android app in front of a whole new audience.  Start now.http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk\n>\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing listBitcoin-development at lists.sourceforge.nethttps://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140212/2c00092c/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-02-11T20:49:49",
                "message_text_only": "On Tue, Feb 11, 2014 at 12:42 PM, naman naman <namanhd at gmail.com> wrote:\n> I was talking about a DOS attack in\n> https://bitcointalk.org/index.php?topic=458608.0 (ofcourse only applicable\n> to entitys doing the tracking with txids).\n>\n> Amazing how I did not get a response from any of the devs (except Greg's\n> response\n> https://bitcointalk.org/index.php?topic=458608.msg5063789#msg5063789 but\n> that too was short and not concerning the attack scenario plausibiity as I\n> replied to him).\n\nTry paying a consultant if your ego demands that you have a technical\nexpert to entertain your musing with immediate response.\n\nMy response was absolutely relevant.\n\nIf you reissue a transaction without respending the prior transactions\ncoins, you will end up double paying. Only spending the inputs in\nquestion can prevent the prior transaction (itself or in other form)\nfrom going through.\n\nOnce you respend the inputs there is no risk of actually losing funds\ndue to an issue regardless of how you track coins in your higher level\napplication."
            },
            {
                "author": "naman naman",
                "date": "2014-02-11T20:56:50",
                "message_text_only": "Gregory Maxwell says : \"Try paying a consultant if your ego demands that\nyou have a technical\nexpert to entertain your musing with immediate response.\"\n\nI don't know why your resorting to such an adhominem. But I have already\nsaid that you were the only one who responded. Your response was correct as\nis reflected in the conversation on the forums. No doubting that. But it\ndoes not address the full scope of the attack where a small pool would\nintentionally (or out of whatever reason) make the hash invalid for the txs\nthey recieve. So that leaves a whole lot of businesses in the lurch who\nhave relied on txid (albeit wrongly that) for their tracking purposes.\nThats all I'm trying to say, without blaming anyone.\n\nHope it makes sense.\n\n\nOn Wed, Feb 12, 2014 at 2:19 AM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n\n> On Tue, Feb 11, 2014 at 12:42 PM, naman naman <namanhd at gmail.com> wrote:\n> > I was talking about a DOS attack in\n> > https://bitcointalk.org/index.php?topic=458608.0 (ofcourse only\n> applicable\n> > to entitys doing the tracking with txids).\n> >\n> > Amazing how I did not get a response from any of the devs (except Greg's\n> > response\n> > https://bitcointalk.org/index.php?topic=458608.msg5063789#msg5063789 but\n> > that too was short and not concerning the attack scenario plausibiity as\n> I\n> > replied to him).\n>\n> Try paying a consultant if your ego demands that you have a technical\n> expert to entertain your musing with immediate response.\n>\n> My response was absolutely relevant.\n>\n> If you reissue a transaction without respending the prior transactions\n> coins, you will end up double paying. Only spending the inputs in\n> question can prevent the prior transaction (itself or in other form)\n> from going through.\n>\n> Once you respend the inputs there is no risk of actually losing funds\n> due to an issue regardless of how you track coins in your higher level\n> application.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140212/3f232766/attachment.html>"
            },
            {
                "author": "naman naman",
                "date": "2014-02-13T12:20:55",
                "message_text_only": "Hi guys,\n\nI with all thats happening now I think (yea no hard proof) most of it is\nbeing done on purpose (transaction mutation) by some pool/entity.\nI have posted here https://bitcointalk.org/index.php?topic=463350.0 of how\nto go about finding out if its some pool doing it. This does in no way\nsolve \"fix\" the malleability issue BUT IMHO it might help \"alleviate\" the\nproblem we are facing at a network level.\nPlease have a look if possible.\n\nKind Regards,\nthenoblebot\n\n\nOn Wed, Feb 12, 2014 at 2:26 AM, naman naman <namanhd at gmail.com> wrote:\n\n> Gregory Maxwell says : \"Try paying a consultant if your ego demands that\n> you have a technical\n>\n> expert to entertain your musing with immediate response.\"\n>\n> I don't know why your resorting to such an adhominem. But I have already\n> said that you were the only one who responded. Your response was correct as\n> is reflected in the conversation on the forums. No doubting that. But it\n> does not address the full scope of the attack where a small pool would\n> intentionally (or out of whatever reason) make the hash invalid for the txs\n> they recieve. So that leaves a whole lot of businesses in the lurch who\n> have relied on txid (albeit wrongly that) for their tracking purposes.\n> Thats all I'm trying to say, without blaming anyone.\n>\n> Hope it makes sense.\n>\n>\n> On Wed, Feb 12, 2014 at 2:19 AM, Gregory Maxwell <gmaxwell at gmail.com>wrote:\n>\n>> On Tue, Feb 11, 2014 at 12:42 PM, naman naman <namanhd at gmail.com> wrote:\n>> > I was talking about a DOS attack in\n>> > https://bitcointalk.org/index.php?topic=458608.0 (ofcourse only\n>> applicable\n>> > to entitys doing the tracking with txids).\n>> >\n>> > Amazing how I did not get a response from any of the devs (except Greg's\n>> > response\n>> > https://bitcointalk.org/index.php?topic=458608.msg5063789#msg5063789but\n>> > that too was short and not concerning the attack scenario plausibiity\n>> as I\n>> > replied to him).\n>>\n>> Try paying a consultant if your ego demands that you have a technical\n>> expert to entertain your musing with immediate response.\n>>\n>> My response was absolutely relevant.\n>>\n>> If you reissue a transaction without respending the prior transactions\n>> coins, you will end up double paying. Only spending the inputs in\n>> question can prevent the prior transaction (itself or in other form)\n>> from going through.\n>>\n>> Once you respend the inputs there is no risk of actually losing funds\n>> due to an issue regardless of how you track coins in your higher level\n>> application.\n>>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140213/4b7aa898/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "MtGox blames bitcoin",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Troy Benjegerdes",
                "Isidor Zeuner",
                "sickpig at gmail.com",
                "Peter Todd",
                "Gregory Maxwell",
                "Gavin Andresen",
                "naman naman",
                "Jameson Lopp",
                "Drak"
            ],
            "messages_count": 18,
            "total_messages_chars_count": 32583
        }
    },
    {
        "title": "[Bitcoin-development] Malleability and MtGox's announcement",
        "thread_messages": [
            {
                "author": "Pieter Wuille",
                "date": "2014-02-10T12:28:42",
                "message_text_only": "Hi all,\n\nI was a bit surprised to see MtGox's announcement. The malleability of\ntransactions was known for years already (see for example the wiki\narticle on it, https://en.bitcoin.it/wiki/Transaction_Malleability it,\nor mails on this list from 2012 and 2013). I don't consider it a very\nbig problem, but it does make it harder for infrastructure to interact\nwith Bitcoin. If we'd design Bitcoin today, I'm sure we would try to\navoid it altogether to make life easier for everyone.\n\nBut we can't just change all infrastructure that exists today. We're\nslowly working towards making malleability harder (and hopefully\nimpossible someday), but this will take a long time. For example, 0.8\nnot supporting non-DER encoded signatures was a step in that direction\n(and ironically, the trigger that caused MtGox's initial problems\nhere). In any case, this will take years, and nobody should wait for\nthis.\n\nThere seem to be two more direct problems here.\n* Wallets which deal badly with modified txids.\n* Services that use the transaction id to detect unconfirming transactions.\n\nThe first is something that needs to be done correctly in software -\nit just needs to be aware of malleability.\n\nThe second is something I was unaware of and would have advised\nagainst. If you plan on reissuing a transaction because on old version\ndoesn't confirm, make sure to make it a double spend of the first one\n- so that not both can confirm.\n\nI certainly don't like press making this sound like a problem in the\nBitcoin protocol or clients. I think this is an issue that needs to be\nsolved at the layer above - the infrastructure building on the Bitcoin\nsystem. Despite that, I do think that we (as a community, not just\ndevelopers) can benefit from defining a standard way to identify\ntransactions unambiguously. This is something Mark Karpeles suggested\na few days ago, and my proposal is this:\n\nWe define the normalized transaction id as SHA256^2(normalized_tx +\n0x01000000), where normalized_tx is the transaction with all input\nscripts replaced by empty scripts. This is exactly what would be\nsigned inside transaction signatures using SIGHASH_ALL (except not\nsubstituting the previous scriptPubKey to be signed, and not dealing\nwith the input being signed specially). An implementation is here:\nhttps://github.com/sipa/bitcoin/commits/normtxid.\n\nNote that this is not a solution for all problems related to\nmalleability, but maybe it can make people more aware of it, in\ntangible way.\n\n-- \nPieter"
            },
            {
                "author": "Troy Benjegerdes",
                "date": "2014-02-10T16:14:02",
                "message_text_only": "Okay, why the everloving FUCK is there not someone on this list with a\n@mtgox.com address talking about this?\n\nI started using bitcoin because I could audit the code, and when the\ndeveloper cabal does stuff 'off-list' what you do is hand over market \nmanipulation power to the selected cabal of company insiders who are\ndiscussing things 'off-list'. \n\nThe people having a 'private' discussion about how to solve this are\nTAKING MONEY from everyone else, by having access to insider information.\n\nI don't think any of the developers actually have a clue this is the \nresult, because a good chunk of them are employed by for-profit companies\nfunded by venture capital, and VC lawyers are very good at writing \nemployment contracts that provide plausible deniability of insider \ntrading.\n\nThe press MAKES MONEY (okay, takes money) by manipulating markets,\nand venture capitalists pay lots of money to ensure the market is\nmanipulated in ways they can profit from.\n\nPrivate market manipulation is one of the costs of anonymity and privacy,\nand I don't really like paying for some off-list discussion of what appears\nto be a serious scalability and usability problem.\n\nBitcoin is such a powerful tool because it broadcasts transactions to\nthe network for everyone to see. \n\nCan we please broadcast some more technical details to this mailing list,\nincluding exactly what MtGox is doing, and how they wish to resolve it?\n\nIf you gave me the entire code stack that MtGox runs on under an AGPLv3\nlicense, I'm pretty sure I, along with everyone else here could come up\nwith a workable solution. I think a code release would be a huge win \nfor MtGox as well, and would cement their position as market leader in\ntransparent cryptocurrency trading.\n\nOtherwise we are just a bunch of dinghys getting capsized one by one\nin a sea of market-manipulating white whales. Isn't the closed door\nmarket manipulation of the big banks one of the reasons we all started\nusing Bitcoin in the first place?\n\nWhy do revolutions always put the same old bullshit back in power?\n\nWhat we need is some transparent code evolution.\n\nOn Mon, Feb 10, 2014 at 01:28:42PM +0100, Pieter Wuille wrote:\n> Hi all,\n> \n> I was a bit surprised to see MtGox's announcement. The malleability of\n> transactions was known for years already (see for example the wiki\n> article on it, https://en.bitcoin.it/wiki/Transaction_Malleability it,\n> or mails on this list from 2012 and 2013). I don't consider it a very\n> big problem, but it does make it harder for infrastructure to interact\n> with Bitcoin. If we'd design Bitcoin today, I'm sure we would try to\n> avoid it altogether to make life easier for everyone.\n> \n> But we can't just change all infrastructure that exists today. We're\n> slowly working towards making malleability harder (and hopefully\n> impossible someday), but this will take a long time. For example, 0.8\n> not supporting non-DER encoded signatures was a step in that direction\n> (and ironically, the trigger that caused MtGox's initial problems\n> here). In any case, this will take years, and nobody should wait for\n> this.\n> \n> There seem to be two more direct problems here.\n> * Wallets which deal badly with modified txids.\n> * Services that use the transaction id to detect unconfirming transactions.\n> \n> The first is something that needs to be done correctly in software -\n> it just needs to be aware of malleability.\n> \n> The second is something I was unaware of and would have advised\n> against. If you plan on reissuing a transaction because on old version\n> doesn't confirm, make sure to make it a double spend of the first one\n> - so that not both can confirm.\n> \n> I certainly don't like press making this sound like a problem in the\n> Bitcoin protocol or clients. I think this is an issue that needs to be\n> solved at the layer above - the infrastructure building on the Bitcoin\n> system. Despite that, I do think that we (as a community, not just\n> developers) can benefit from defining a standard way to identify\n> transactions unambiguously. This is something Mark Karpeles suggested\n> a few days ago, and my proposal is this:\n> \n> We define the normalized transaction id as SHA256^2(normalized_tx +\n> 0x01000000), where normalized_tx is the transaction with all input\n> scripts replaced by empty scripts. This is exactly what would be\n> signed inside transaction signatures using SIGHASH_ALL (except not\n> substituting the previous scriptPubKey to be signed, and not dealing\n> with the input being signed specially). An implementation is here:\n> https://github.com/sipa/bitcoin/commits/normtxid.\n> \n> Note that this is not a solution for all problems related to\n> malleability, but maybe it can make people more aware of it, in\n> tangible way.\n> \n> -- \n> Pieter\n> \n> ------------------------------------------------------------------------------\n> Managing the Performance of Cloud-Based Applications\n> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> Read the Whitepaper.\n> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Nick Simpson",
                "date": "2014-02-10T16:57:03",
                "message_text_only": "You must be new here. MtGox very rarely comments on things like this publicly, outside of irc or their website. \n\nSecond, MtGox problem is a MtGox problem. You have no right to demand access to their private code. If you feel wronged as a customer, sue them. Otherwise, they have no obligation to you.\n\nI believe you are \"barking up the wrong tree\".\n\nRespectfully,\n\nNick\n\nOn February 10, 2014 10:14:02 AM CST, Troy Benjegerdes <hozer at hozed.org> wrote:\n>Okay, why the everloving FUCK is there not someone on this list with a\n>@mtgox.com address talking about this?\n>\n>I started using bitcoin because I could audit the code, and when the\n>developer cabal does stuff 'off-list' what you do is hand over market \n>manipulation power to the selected cabal of company insiders who are\n>discussing things 'off-list'. \n>\n>The people having a 'private' discussion about how to solve this are\n>TAKING MONEY from everyone else, by having access to insider\n>information.\n>\n>I don't think any of the developers actually have a clue this is the \n>result, because a good chunk of them are employed by for-profit\n>companies\n>funded by venture capital, and VC lawyers are very good at writing \n>employment contracts that provide plausible deniability of insider \n>trading.\n>\n>The press MAKES MONEY (okay, takes money) by manipulating markets,\n>and venture capitalists pay lots of money to ensure the market is\n>manipulated in ways they can profit from.\n>\n>Private market manipulation is one of the costs of anonymity and\n>privacy,\n>and I don't really like paying for some off-list discussion of what\n>appears\n>to be a serious scalability and usability problem.\n>\n>Bitcoin is such a powerful tool because it broadcasts transactions to\n>the network for everyone to see. \n>\n>Can we please broadcast some more technical details to this mailing\n>list,\n>including exactly what MtGox is doing, and how they wish to resolve it?\n>\n>If you gave me the entire code stack that MtGox runs on under an AGPLv3\n>license, I'm pretty sure I, along with everyone else here could come up\n>with a workable solution. I think a code release would be a huge win \n>for MtGox as well, and would cement their position as market leader in\n>transparent cryptocurrency trading.\n>\n>Otherwise we are just a bunch of dinghys getting capsized one by one\n>in a sea of market-manipulating white whales. Isn't the closed door\n>market manipulation of the big banks one of the reasons we all started\n>using Bitcoin in the first place?\n>\n>Why do revolutions always put the same old bullshit back in power?\n>\n>What we need is some transparent code evolution.\n>\n>On Mon, Feb 10, 2014 at 01:28:42PM +0100, Pieter Wuille wrote:\n>> Hi all,\n>> \n>> I was a bit surprised to see MtGox's announcement. The malleability\n>of\n>> transactions was known for years already (see for example the wiki\n>> article on it, https://en.bitcoin.it/wiki/Transaction_Malleability\n>it,\n>> or mails on this list from 2012 and 2013). I don't consider it a very\n>> big problem, but it does make it harder for infrastructure to\n>interact\n>> with Bitcoin. If we'd design Bitcoin today, I'm sure we would try to\n>> avoid it altogether to make life easier for everyone.\n>> \n>> But we can't just change all infrastructure that exists today. We're\n>> slowly working towards making malleability harder (and hopefully\n>> impossible someday), but this will take a long time. For example, 0.8\n>> not supporting non-DER encoded signatures was a step in that\n>direction\n>> (and ironically, the trigger that caused MtGox's initial problems\n>> here). In any case, this will take years, and nobody should wait for\n>> this.\n>> \n>> There seem to be two more direct problems here.\n>> * Wallets which deal badly with modified txids.\n>> * Services that use the transaction id to detect unconfirming\n>transactions.\n>> \n>> The first is something that needs to be done correctly in software -\n>> it just needs to be aware of malleability.\n>> \n>> The second is something I was unaware of and would have advised\n>> against. If you plan on reissuing a transaction because on old\n>version\n>> doesn't confirm, make sure to make it a double spend of the first one\n>> - so that not both can confirm.\n>> \n>> I certainly don't like press making this sound like a problem in the\n>> Bitcoin protocol or clients. I think this is an issue that needs to\n>be\n>> solved at the layer above - the infrastructure building on the\n>Bitcoin\n>> system. Despite that, I do think that we (as a community, not just\n>> developers) can benefit from defining a standard way to identify\n>> transactions unambiguously. This is something Mark Karpeles suggested\n>> a few days ago, and my proposal is this:\n>> \n>> We define the normalized transaction id as SHA256^2(normalized_tx +\n>> 0x01000000), where normalized_tx is the transaction with all input\n>> scripts replaced by empty scripts. This is exactly what would be\n>> signed inside transaction signatures using SIGHASH_ALL (except not\n>> substituting the previous scriptPubKey to be signed, and not dealing\n>> with the input being signed specially). An implementation is here:\n>> https://github.com/sipa/bitcoin/commits/normtxid.\n>> \n>> Note that this is not a solution for all problems related to\n>> malleability, but maybe it can make people more aware of it, in\n>> tangible way.\n>> \n>> -- \n>> Pieter\n>> \n>>\n>------------------------------------------------------------------------------\n>> Managing the Performance of Cloud-Based Applications\n>> Take advantage of what the Cloud has to offer - Avoid Common\n>Pitfalls.\n>> Read the Whitepaper.\n>>\n>http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>------------------------------------------------------------------------------\n>Managing the Performance of Cloud-Based Applications\n>Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n>Read the Whitepaper.\n>http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk\n>_______________________________________________\n>Bitcoin-development mailing list\n>Bitcoin-development at lists.sourceforge.net\n>https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140210/7dc4dfba/attachment.html>"
            },
            {
                "author": "Troy Benjegerdes",
                "date": "2014-02-10T18:02:58",
                "message_text_only": "A bitcoin problem is not really my problem, and if MtGox's investors \ncan't seem to understand the value of publishing their code, I'll \nbe happy to take their money as it leaves bitcoin for more distributed\nand transparent cryptocurrency ecosystems.\n\nI feel some sort of moral obligation to point out to this community \nwhen something stupid is going on, and if you think a MtGox problem \nis not a Bitcoin problem then I can't really help you, all I can do\nis point out my observations and facts as I see them, and then execute\ntrades to relieve those who choose to ignore these facts of their money.\n\nHappy trading\n\n\nOn Mon, Feb 10, 2014 at 10:57:03AM -0600, Nick Simpson wrote:\n> You must be new here. MtGox very rarely comments on things like this publicly, outside of irc or their website. \n> \n> Second, MtGox problem is a MtGox problem. You have no right to demand access to their private code. If you feel wronged as a customer, sue them. Otherwise, they have no obligation to you.\n> \n> I believe you are \"barking up the wrong tree\".\n> \n> Respectfully,\n> \n> Nick\n> \n> On February 10, 2014 10:14:02 AM CST, Troy Benjegerdes <hozer at hozed.org> wrote:\n> >Okay, why the everloving FUCK is there not someone on this list with a\n> >@mtgox.com address talking about this?\n> >\n> >I started using bitcoin because I could audit the code, and when the\n> >developer cabal does stuff 'off-list' what you do is hand over market \n> >manipulation power to the selected cabal of company insiders who are\n> >discussing things 'off-list'. \n> >\n> >The people having a 'private' discussion about how to solve this are\n> >TAKING MONEY from everyone else, by having access to insider\n> >information.\n> >\n> >I don't think any of the developers actually have a clue this is the \n> >result, because a good chunk of them are employed by for-profit\n> >companies\n> >funded by venture capital, and VC lawyers are very good at writing \n> >employment contracts that provide plausible deniability of insider \n> >trading.\n> >\n> >The press MAKES MONEY (okay, takes money) by manipulating markets,\n> >and venture capitalists pay lots of money to ensure the market is\n> >manipulated in ways they can profit from.\n> >\n> >Private market manipulation is one of the costs of anonymity and\n> >privacy,\n> >and I don't really like paying for some off-list discussion of what\n> >appears\n> >to be a serious scalability and usability problem.\n> >\n> >Bitcoin is such a powerful tool because it broadcasts transactions to\n> >the network for everyone to see. \n> >\n> >Can we please broadcast some more technical details to this mailing\n> >list,\n> >including exactly what MtGox is doing, and how they wish to resolve it?\n> >\n> >If you gave me the entire code stack that MtGox runs on under an AGPLv3\n> >license, I'm pretty sure I, along with everyone else here could come up\n> >with a workable solution. I think a code release would be a huge win \n> >for MtGox as well, and would cement their position as market leader in\n> >transparent cryptocurrency trading.\n> >\n> >Otherwise we are just a bunch of dinghys getting capsized one by one\n> >in a sea of market-manipulating white whales. Isn't the closed door\n> >market manipulation of the big banks one of the reasons we all started\n> >using Bitcoin in the first place?\n> >\n> >Why do revolutions always put the same old bullshit back in power?\n> >\n> >What we need is some transparent code evolution.\n> >\n> >On Mon, Feb 10, 2014 at 01:28:42PM +0100, Pieter Wuille wrote:\n> >> Hi all,\n> >> \n> >> I was a bit surprised to see MtGox's announcement. The malleability\n> >of\n> >> transactions was known for years already (see for example the wiki\n> >> article on it, https://en.bitcoin.it/wiki/Transaction_Malleability\n> >it,\n> >> or mails on this list from 2012 and 2013). I don't consider it a very\n> >> big problem, but it does make it harder for infrastructure to\n> >interact\n> >> with Bitcoin. If we'd design Bitcoin today, I'm sure we would try to\n> >> avoid it altogether to make life easier for everyone.\n> >> \n> >> But we can't just change all infrastructure that exists today. We're\n> >> slowly working towards making malleability harder (and hopefully\n> >> impossible someday), but this will take a long time. For example, 0.8\n> >> not supporting non-DER encoded signatures was a step in that\n> >direction\n> >> (and ironically, the trigger that caused MtGox's initial problems\n> >> here). In any case, this will take years, and nobody should wait for\n> >> this.\n> >> \n> >> There seem to be two more direct problems here.\n> >> * Wallets which deal badly with modified txids.\n> >> * Services that use the transaction id to detect unconfirming\n> >transactions.\n> >> \n> >> The first is something that needs to be done correctly in software -\n> >> it just needs to be aware of malleability.\n> >> \n> >> The second is something I was unaware of and would have advised\n> >> against. If you plan on reissuing a transaction because on old\n> >version\n> >> doesn't confirm, make sure to make it a double spend of the first one\n> >> - so that not both can confirm.\n> >> \n> >> I certainly don't like press making this sound like a problem in the\n> >> Bitcoin protocol or clients. I think this is an issue that needs to\n> >be\n> >> solved at the layer above - the infrastructure building on the\n> >Bitcoin\n> >> system. Despite that, I do think that we (as a community, not just\n> >> developers) can benefit from defining a standard way to identify\n> >> transactions unambiguously. This is something Mark Karpeles suggested\n> >> a few days ago, and my proposal is this:\n> >> \n> >> We define the normalized transaction id as SHA256^2(normalized_tx +\n> >> 0x01000000), where normalized_tx is the transaction with all input\n> >> scripts replaced by empty scripts. This is exactly what would be\n> >> signed inside transaction signatures using SIGHASH_ALL (except not\n> >> substituting the previous scriptPubKey to be signed, and not dealing\n> >> with the input being signed specially). An implementation is here:\n> >> https://github.com/sipa/bitcoin/commits/normtxid.\n> >> \n> >> Note that this is not a solution for all problems related to\n> >> malleability, but maybe it can make people more aware of it, in\n> >> tangible way.\n> >> \n> >> -- \n> >> Pieter\n> >> \n> >>\n> >------------------------------------------------------------------------------\n> >> Managing the Performance of Cloud-Based Applications\n> >> Take advantage of what the Cloud has to offer - Avoid Common\n> >Pitfalls.\n> >> Read the Whitepaper.\n> >>\n> >http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk\n> >> _______________________________________________\n> >> Bitcoin-development mailing list\n> >> Bitcoin-development at lists.sourceforge.net\n> >> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> >\n> >------------------------------------------------------------------------------\n> >Managing the Performance of Cloud-Based Applications\n> >Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> >Read the Whitepaper.\n> >http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk\n> >_______________________________________________\n> >Bitcoin-development mailing list\n> >Bitcoin-development at lists.sourceforge.net\n> >https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Oliver Egginger",
                "date": "2014-02-10T19:47:47",
                "message_text_only": "Am 10.02.2014 13:28, schrieb Pieter Wuille:\n> Hi all,\n> \n> I was a bit surprised to see MtGox's announcement. The malleability of\n> transactions was known for years already (see for example the wiki\n> article on it, https://en.bitcoin.it/wiki/Transaction_Malleability it,\n> or mails on this list from 2012 and 2013). I don't consider it a very\n> big problem, but it does make it harder for infrastructure to interact\n> with Bitcoin. If we'd design Bitcoin today, I'm sure we would try to\n> avoid it altogether to make life easier for everyone.\n\nSorry, I'm not a developer, but I have got a question. It's a little bit\noff-topic and can't maybe answered easy.\n\nAs I understand this attack someone renames the transaction ID before\nbeing confirmed in the blockchain. Not easy but if he is fast enough it\nshould be possible. With a bit of luck for the attacker the new\ntransaction is added to the block chain and the original transaction is\ndiscarded as double-spend. Right?\n\nUp to this point the attacker has nothing gained. But next the attacker\nstressed the Gox support and refers to the original transaction ID. Gox\nwas then probably fooled in such cases and has refunded already paid\nBitcoins to the attackers (virtual) Gox-wallet.\n\nSo far everything is clear. But what I do not understand: Why apparently\nhad so many customers of Gox payment defaults or severely delayed\npayments? I would imagine that the attacker may have doubled not only\nhis own transaction (maybe for obfuscating the fraud). But then all\ntransfers would still have go through anyway. And a normal customers\nwould have been satisfied. Most people observe only their wallets, I\nthink. What am I missing here?\n\nSorry, is perhaps a silly question. But maybe you can put me on the\nright track.\n\nregards\nOliver"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-02-10T20:40:03",
                "message_text_only": "On Mon, Feb 10, 2014 at 11:47 AM, Oliver Egginger <bitcoin at olivere.de> wrote:\n> As I understand this attack someone renames the transaction ID before\n> being confirmed in the blockchain. Not easy but if he is fast enough it\n> should be possible. With a bit of luck for the attacker the new\n> transaction is added to the block chain and the original transaction is\n> discarded as double-spend. Right?\n>\n> Up to this point the attacker has nothing gained. But next the attacker\n> stressed the Gox support and refers to the original transaction ID. Gox\n> was then probably fooled in such cases and has refunded already paid\n> Bitcoins to the attackers (virtual) Gox-wallet.\n\nAt this point the attack should fail. Before crediting the funds back Gox\nshould form a new transaction moving at least one of the coins the prior\ntransaction was spending and wait for that transaction to confirm.\n\nWithout performing this step\u2014 even if there were no malleability at all\nyou'd have the risk that someone would go resurrect the old transaction\nand get a miner to mine it. Then it goes through.\n\nWith performing it, even if they missed the mutated transaction in the chain\ntheir cancellation transaction could not confirm (because its a double spend).\n\n> So far everything is clear. But what I do not understand: Why apparently\n> had so many customers of Gox payment defaults or severely delayed\n> payments?\n\nBack in September a lot of people were having stuck transactions and\nwhen I looked it was because Mtgox was spending immature coins: newly\ngenerated coins which cannot be spent for 100 blocks since their creation.\n(A rule since Bitcoin's started)\n\nThen later it was noticed that they were producing transactions with invalid\nDER encodings (excessively padded signatures). The Bitcoin network used\nto accept these transactions, but in order to more towards eliminating\nmalleability\nBitcoin 0.8 and later will not relay and mine them.\n\nThen after people started using mutation to fix those excessively padded\ntransactions and/or someone was exploiting Gox's behavior\u2014 it seems that\nGox's wallet may have been in a state where it thought a lot of coins weren't\nspent that were and was reusing them in new transansactions... this one\nis harder to tell externally\u2014 I saw it appeared to be producing a LOT of\ndouble spends with different destinations, but I'm guessing as to the exact\ncause."
            },
            {
                "author": "Tier Nolan",
                "date": "2014-02-10T20:47:46",
                "message_text_only": "On Mon, Feb 10, 2014 at 7:47 PM, Oliver Egginger <bitcoin at olivere.de> wrote:\n\n> As I understand this attack someone renames the transaction ID before\n> being confirmed in the blockchain. Not easy but if he is fast enough it\n> should be possible. With a bit of luck for the attacker the new\n> transaction is added to the block chain and the original transaction is\n> discarded as double-spend. Right?\n>\n\nNo, the problem was that the transaction MtGox produced was poorly\nformatted.\n\nIt wouldn't cause a block containing the transaction to be rejected, but\nthe default client wouldn't relay the transaction or add it into a block.\n\nThis means that transaction stalls.\n\nIf the attacker has a direct connection to MtGox, they can receive the\ntransaction directly.\n\nThe attacker would fix the formatting (which changes the transaction id,\nbut doesn't change the signature) and then forward it to the network, as\nnormal.\n\nThe old transaction never propagates correctly.\n\nUp to this point the attacker has nothing gained. But next the attacker\n> stressed the Gox support and refers to the original transaction ID. Gox\n> was then probably fooled in such cases and has refunded already paid\n> Bitcoins to the attackers (virtual) Gox-wallet.\n>\n\nThey sent out the transaction a second time.\n\nThe right solution is that the new transaction should re-spend at least one\nof the coins that the first transaction spent.  That way only one can\npossibly be accepted.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140210/a1da9e05/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-02-10T20:55:21",
                "message_text_only": "On Mon, Feb 10, 2014 at 12:47 PM, Tier Nolan <tier.nolan at gmail.com> wrote:\n> If the attacker has a direct connection to MtGox, they can receive the\n> transaction directly.\nMtGox had a php script that returned base64 data for all their stalled\ntransactions.\n\nNot just attackers used that, some people trying to unstick their\ntransactions tried manually fixing them with honest intent and no idea\nit would potentially confuse mtgox's software."
            },
            {
                "author": "Troy Benjegerdes",
                "date": "2014-02-10T17:54:17",
                "message_text_only": "I cannot judge the competence of code I've never seen, so I have no\nposition on that.\n\nWhat I HAVE seen quite clearly is both overt and covert market \nmanipulation under cover of blame for 'the developers', or 'the exchange'\n\nYou're doing it yourself with the phrase 'incompetence'. When you run an\nexchange of that volume, then maybe you might be in a position to say so,\nbut if you were *invested* in a competitor to MtGox you'd make a lot of\nmoney calling them incompetent, wouldn't you?\n\nI'm looking to drum up some consulting business by making my observations\nabout market manipulation public, and if I can't drum up any business, at\nleast I can speak my mind free of any non-disclsosure agreements.\n\nWhat do you stand to gain from your statements on this list?\n\n\nOn another note, is there any third-party archive of bitcointalk.org?\nI much prefer mailing lists because *I* have an archive.\n\nOn Mon, Feb 10, 2014 at 11:39:19AM -0500, Christophe Biocca wrote:\n> The bug MtGox is blaming has been documented on the wiki for years.\n> Mark Karpeles was on IRC publicly discussing the topic\n> https://bitcointalk.org/index.php?topic=458076.msg5052255#msg5052255\n> MtGox's incompetence has been on public display since day 1.\n> \n> I'm not sure what critical information you think secret cabals are\n> keeping from you.\n> \n> On Mon, Feb 10, 2014 at 11:14 AM, Troy Benjegerdes <hozer at hozed.org> wrote:\n> > Okay, why the everloving FUCK is there not someone on this list with a\n> > @mtgox.com address talking about this?\n> >\n> > I started using bitcoin because I could audit the code, and when the\n> > developer cabal does stuff 'off-list' what you do is hand over market\n> > manipulation power to the selected cabal of company insiders who are\n> > discussing things 'off-list'.\n> >\n> > The people having a 'private' discussion about how to solve this are\n> > TAKING MONEY from everyone else, by having access to insider information.\n> >\n> > I don't think any of the developers actually have a clue this is the\n> > result, because a good chunk of them are employed by for-profit companies\n> > funded by venture capital, and VC lawyers are very good at writing\n> > employment contracts that provide plausible deniability of insider\n> > trading.\n> >\n> > The press MAKES MONEY (okay, takes money) by manipulating markets,\n> > and venture capitalists pay lots of money to ensure the market is\n> > manipulated in ways they can profit from.\n> >\n> > Private market manipulation is one of the costs of anonymity and privacy,\n> > and I don't really like paying for some off-list discussion of what appears\n> > to be a serious scalability and usability problem.\n> >\n> > Bitcoin is such a powerful tool because it broadcasts transactions to\n> > the network for everyone to see.\n> >\n> > Can we please broadcast some more technical details to this mailing list,\n> > including exactly what MtGox is doing, and how they wish to resolve it?\n> >\n> > If you gave me the entire code stack that MtGox runs on under an AGPLv3\n> > license, I'm pretty sure I, along with everyone else here could come up\n> > with a workable solution. I think a code release would be a huge win\n> > for MtGox as well, and would cement their position as market leader in\n> > transparent cryptocurrency trading.\n> >\n> > Otherwise we are just a bunch of dinghys getting capsized one by one\n> > in a sea of market-manipulating white whales. Isn't the closed door\n> > market manipulation of the big banks one of the reasons we all started\n> > using Bitcoin in the first place?\n> >\n> > Why do revolutions always put the same old bullshit back in power?\n> >\n> > What we need is some transparent code evolution.\n> >\n> > On Mon, Feb 10, 2014 at 01:28:42PM +0100, Pieter Wuille wrote:\n> >> Hi all,\n> >>\n> >> I was a bit surprised to see MtGox's announcement. The malleability of\n> >> transactions was known for years already (see for example the wiki\n> >> article on it, https://en.bitcoin.it/wiki/Transaction_Malleability it,\n> >> or mails on this list from 2012 and 2013). I don't consider it a very\n> >> big problem, but it does make it harder for infrastructure to interact\n> >> with Bitcoin. If we'd design Bitcoin today, I'm sure we would try to\n> >> avoid it altogether to make life easier for everyone.\n> >>\n> >> But we can't just change all infrastructure that exists today. We're\n> >> slowly working towards making malleability harder (and hopefully\n> >> impossible someday), but this will take a long time. For example, 0.8\n> >> not supporting non-DER encoded signatures was a step in that direction\n> >> (and ironically, the trigger that caused MtGox's initial problems\n> >> here). In any case, this will take years, and nobody should wait for\n> >> this.\n> >>\n> >> There seem to be two more direct problems here.\n> >> * Wallets which deal badly with modified txids.\n> >> * Services that use the transaction id to detect unconfirming transactions.\n> >>\n> >> The first is something that needs to be done correctly in software -\n> >> it just needs to be aware of malleability.\n> >>\n> >> The second is something I was unaware of and would have advised\n> >> against. If you plan on reissuing a transaction because on old version\n> >> doesn't confirm, make sure to make it a double spend of the first one\n> >> - so that not both can confirm.\n> >>\n> >> I certainly don't like press making this sound like a problem in the\n> >> Bitcoin protocol or clients. I think this is an issue that needs to be\n> >> solved at the layer above - the infrastructure building on the Bitcoin\n> >> system. Despite that, I do think that we (as a community, not just\n> >> developers) can benefit from defining a standard way to identify\n> >> transactions unambiguously. This is something Mark Karpeles suggested\n> >> a few days ago, and my proposal is this:\n> >>\n> >> We define the normalized transaction id as SHA256^2(normalized_tx +\n> >> 0x01000000), where normalized_tx is the transaction with all input\n> >> scripts replaced by empty scripts. This is exactly what would be\n> >> signed inside transaction signatures using SIGHASH_ALL (except not\n> >> substituting the previous scriptPubKey to be signed, and not dealing\n> >> with the input being signed specially). An implementation is here:\n> >> https://github.com/sipa/bitcoin/commits/normtxid.\n> >>\n> >> Note that this is not a solution for all problems related to\n> >> malleability, but maybe it can make people more aware of it, in\n> >> tangible way.\n> >>\n> >> --\n> >> Pieter\n> >>\n> >> ------------------------------------------------------------------------------\n> >> Managing the Performance of Cloud-Based Applications\n> >> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> >> Read the Whitepaper.\n> >> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk\n> >> _______________________________________________\n> >> Bitcoin-development mailing list\n> >> Bitcoin-development at lists.sourceforge.net\n> >> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> >\n> > ------------------------------------------------------------------------------\n> > Managing the Performance of Cloud-Based Applications\n> > Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> > Read the Whitepaper.\n> > http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk\n> > _______________________________________________\n> > Bitcoin-development mailing list\n> > Bitcoin-development at lists.sourceforge.net\n> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            }
        ],
        "thread_summary": {
            "title": "Malleability and MtGox's announcement",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Troy Benjegerdes",
                "Tier Nolan",
                "Gregory Maxwell",
                "Oliver Egginger",
                "Nick Simpson",
                "Pieter Wuille"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 35370
        }
    },
    {
        "title": "[Bitcoin-development] Framework for modular input selection policy for Bitcoin wallets",
        "thread_messages": [
            {
                "author": "Justus Ranvier",
                "date": "2014-02-11T06:05:25",
                "message_text_only": "One of the areas that isn't as well developed as it could be in terms of\nwallet design is fine-grained control over input selection policy.\n\nCoin control is great when a human is manually crafting transactions,\nbut that's not really a very scalable solution.\n\nThe attached image is a possible way to stack different independent\nselection algorithms. If wallets implemented something like this, it\nwould be easy for other programs to implement new application-specific\nalgorithms that would not need to completely reinvent the wheel.\n\nAs an example, voting pools in Open-Transactions will implement cold\nstorage in a FIFO manner, meaning that UTXOs will be clustered into\ngroups which should be consumed in a specific sequence. Within that\nconstraint, however, they still want to minimize transaction size.\n\nIf wallets were designed to make selection policy modular, they'd only\nneed to implement their FIFO algorithm and stack it in before the\ndefault algorithm. Surely this capability would be useful to other\nprojects as well.\n\nIt would also allow people who want to prioritize privacy over\ntransaction cost to easily modify the behavior of their clients and\nwould make it easier to incorporate new tx construction algorithms like\nCoinJoin.\n\nLink to the image in case attachment is stripped:\nhttp://i.imgur.com/Fkkq7pI.png\n-- \nSupport online privacy by using email encryption whenever possible.\nLearn how here: http://www.youtube.com/watch?v=bakOKJFtB-k\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0x1B438BF4.asc\nType: application/pgp-keys\nSize: 21174 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140211/c6ac92c8/attachment.bin>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 538 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140211/c6ac92c8/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Framework for modular input selection policy for Bitcoin wallets",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Justus Ranvier"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2012
        }
    },
    {
        "title": "[Bitcoin-development] working with the blockchain: transaction fees & sum(inputs) != sum(outputs) (newbie questions)",
        "thread_messages": [
            {
                "author": "Denis Andrejew",
                "date": "2014-02-14T12:20:45",
                "message_text_only": "Hi all!\n\nI'm new to development with bitcoin and I have a question for you guys:\n\nWhat I'm trying to do is read the blockchain in order to find all unspent\noutputs. I'm using bitcoind via rpc as my source of information about the\nblockchain.\n\nNow one thing that I don't understand fully yet when working with the\ntransaction data I'm being given is:\n\nHow do transaction fees work? More specifically: I can see that there is\noften a gap between the sum of the ins and the sum of the outs in a\ntransaction and I understand that this is the transaction fee. But how can\nthe miner spend it if it is not assigned as an output of any transaction?\nIs there special code somewhere that keeps track of all the btc not spent\nin all the transactions of a block and allows the miner's address (ie the\naddress in the first tx of that block) to spend that? But if so, how would\nthat work then? I should be finding transactions then where the sum of the\nouputs is higher than the sum of the inputs and one of the inputs should\nhave the miner's address attached to it or what?\n\nI am a bit confused about this part. Other than that it's quite fascinating\nto see how bitcoin works and work with it. :)\n\nSo if one of you could kindly explain to me the technical view of\ntransaction fees (i.e. how exactly do I find them and account for them in\nthe blockchain), that would be brilliant!\n\nAnd the other question would be this one (directly related):\n\nWhat are the cases where the sum of the input values (from the referenced\ntransactions) can be different from the sum of the output values?\n\nThese cases I have found and understand:\n\n1) \"coinbase\" transactions that \"print money\" have no inputs, only 50/25\ncoins output (less in the future)\n2) transaction fees when in > out\n\nAre there other cases?\n\nThanks,\nDenis\n\n\"Be the change you want to see in the world.\" (Mahatma Gandhi)\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140214/bf2c5aec/attachment.html>"
            },
            {
                "author": "Wladimir",
                "date": "2014-02-14T12:42:56",
                "message_text_only": ">\n> Is there special code somewhere that keeps track of all the btc not spent\n> in all the transactions of a block and allows the miner's address (ie the\n> address in the first tx of that block) to spend that?\n>\n\nSomething like that:\nEvery block has a coinbase transaction at the beginning.\nThe coinbase transaction is special, in that it can pay coins to its\noutputs without having to specify an input.\n\nThe total value of the outputs of the coinbase transaction can be at most\nthe block value (the fixed amount per block) + the fees (summed over all\ntransactions in the block).\n\nThis is checked in ConnectBlock in\nhttps://github.com/bitcoin/bitcoin/blob/master/src/main.cpp#L1711\nThe value of the coinbase transaction is being checked on line 1731.\n\nBut if so, how would that work then? I should be finding transactions then\n> where the sum of the ouputs is higher than the sum of the inputs and one of\n> the inputs should have the miner's address attached to it or what?\n>\n\nThe only transactions in which the sum of the outputs can be larger than\nthe sum of the inputs are the aforementioned coinbase transactions (which\ncannot have inputs).\n\nThe outputs from the coinbase transaction can be spent as any other output.\n\nWladimir\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140214/f5b662dd/attachment.html>"
            },
            {
                "author": "Denis Andrejew",
                "date": "2014-02-14T20:56:56",
                "message_text_only": "Thanks Wladimir, perfect info!\n\nMark, sounds good. But most likely this DB is keeping this information only\nfor the current state of the blockchain and what I need really is to be\nable to get the unspent outputs (and calculate the balance for all\naddresses) for any particular block I happen to be interested in :)\n\n- Denis\n\n\"Be the change you want to see in the world.\" (Mahatma Gandhi)\n\n\nOn Fri, Feb 14, 2014 at 5:42 PM, Mark Friedenbach <mark at monetize.io> wrote:\n\n> On 02/14/2014 04:20 AM, Denis Andrejew wrote:\n> > What I'm trying to do is read the blockchain in order to find all\n> > unspent outputs. I'm using bitcoind via rpc as my source of\n> > information about the blockchain.\n>\n> By the way, bitcoind keeps this information in a special LevelDB\n> database in the chainstate directory. It would be rather simple to\n> iterate over the database for the list of al unspent outputs.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140214/0e563299/attachment.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2014-02-14T23:01:41",
                "message_text_only": "Still straightforward: get a list of transaction hashes for the block\nfrom bitcoind, then query these transactions from the UTXO changestate\ndatabase.\n\nOn 02/14/2014 12:56 PM, Denis Andrejew wrote:\n> Thanks Wladimir, perfect info!\n> \n> Mark, sounds good. But most likely this DB is keeping this\n> information only for the current state of the blockchain and what I\n> need really is to be able to get the unspent outputs (and calculate\n> the balance for all addresses) for any particular block I happen to\n> be interested in :)\n> \n> - Denis\n> \n> \"Be the change you want to see in the world.\" (Mahatma Gandhi)\n> \n> \n> On Fri, Feb 14, 2014 at 5:42 PM, Mark Friedenbach\n> <mark at monetize.io <mailto:mark at monetize.io>> wrote:\n> \n> On 02/14/2014 04:20 AM, Denis Andrejew wrote:\n>> What I'm trying to do is read the blockchain in order to find\n>> all unspent outputs. I'm using bitcoind via rpc as my source of \n>> information about the blockchain.\n> \n> By the way, bitcoind keeps this information in a special LevelDB \n> database in the chainstate directory. It would be rather simple to \n> iterate over the database for the list of al unspent outputs.\n> \n>"
            }
        ],
        "thread_summary": {
            "title": "working with the blockchain: transaction fees & sum(inputs) != sum(outputs) (newbie questions)",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Denis Andrejew",
                "Wladimir",
                "Mark Friedenbach"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 5685
        }
    },
    {
        "title": "[Bitcoin-development] Testnet block explorer",
        "thread_messages": [
            {
                "author": "Melvin Carvalho",
                "date": "2014-02-16T13:45:23",
                "message_text_only": "On 27 December 2013 19:05, Mike Hearn <mike at plan99.net> wrote:\n\n> For a long time the only block explorer for testnet has been the original\n> blockexplorer.com, which is unfortunately often broken / behind / slow\n> and not really maintained any more.\n>\n> There is now a new one, here:\n>\n> https://www.biteasy.com/testnet/blocks\n>\n> There's also a REST/JSON API for it.\n>\n> Please note one curiosity of this block explorer is that the coinbase tx\n> doesn't necessarily come first in the listing (it's sorted by \"time\n> received\", see).\n>\n> Other interesting thing to note: this site is built using bitcoinj. The\n> author can be contacted on IRC sometimes using the nick damethos.\n>\n\nSome more information on testnet3 explorers ...\n\nHere is a free software testnet explorer based on javascript/node\n\nhttp://test.bitcore.io/\n\nI've been working on a testnet explorer, but I think I will fork this and\nadd semantic web style markup attributes to the HTML.\n\nAlso a message I got from blockr.io \"yes testnet will be added. I cannot\ngive you an estimate on when, but it'll probably happen in couple of weeks\n(hopefully sooner).\"\n\n\n>\n>\n> ------------------------------------------------------------------------------\n> Rapidly troubleshoot problems before they affect your business. Most IT\n> organizations don't have a clear picture of how application performance\n> affects their revenue. With AppDynamics, you get 100% visibility into your\n> Java,.NET, & PHP application. Start your 15-day FREE TRIAL of AppDynamics\n> Pro!\n> http://pubads.g.doubleclick.net/gampad/clk?id=84349831&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140216/dd6344fe/attachment.html>"
            },
            {
                "author": "Matias Alejo Garcia",
                "date": "2014-02-16T14:49:40",
                "message_text_only": "Hi Melvin / Mike,\n\nIve been working on Bitcore and Insight next to a BitPay team for the last\nfew weeks. We are happy to receive patches, suggestions and bug reports\nfrom you guys at:\n\nhttps://github.com/bitpay/insight\n\nInsight also provides some blockchain query capabilities at its\nREST/Websockets API described on the Readme document.\n\nPlease note that Insight is meant as a software package that you can\ndownload, install and use next to a trusted bitcoind instance.\nlive.bitcore.io / test.bitcore.io are just demo installations.\n\nbest,\nmat\u00edas\n\n\n\n\nOn Sun, Feb 16, 2014 at 10:45 AM, Melvin Carvalho\n<melvincarvalho at gmail.com>wrote:\n\n>\n>\n>\n> On 27 December 2013 19:05, Mike Hearn <mike at plan99.net> wrote:\n>\n>> For a long time the only block explorer for testnet has been the original\n>> blockexplorer.com, which is unfortunately often broken / behind / slow\n>> and not really maintained any more.\n>>\n>> There is now a new one, here:\n>>\n>> https://www.biteasy.com/testnet/blocks\n>>\n>> There's also a REST/JSON API for it.\n>>\n>> Please note one curiosity of this block explorer is that the coinbase tx\n>> doesn't necessarily come first in the listing (it's sorted by \"time\n>> received\", see).\n>>\n>> Other interesting thing to note: this site is built using bitcoinj. The\n>> author can be contacted on IRC sometimes using the nick damethos.\n>>\n>\n> Some more information on testnet3 explorers ...\n>\n> Here is a free software testnet explorer based on javascript/node\n>\n> http://test.bitcore.io/\n>\n> I've been working on a testnet explorer, but I think I will fork this and\n> add semantic web style markup attributes to the HTML.\n>\n> Also a message I got from blockr.io \"yes testnet will be added. I cannot\n> give you an estimate on when, but it'll probably happen in couple of weeks\n> (hopefully sooner).\"\n>\n>\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> Rapidly troubleshoot problems before they affect your business. Most IT\n>> organizations don't have a clear picture of how application performance\n>> affects their revenue. With AppDynamics, you get 100% visibility into your\n>> Java,.NET, & PHP application. Start your 15-day FREE TRIAL of AppDynamics\n>> Pro!\n>>\n>> http://pubads.g.doubleclick.net/gampad/clk?id=84349831&iu=/4140/ostg.clktrk\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>>\n>\n>\n> ------------------------------------------------------------------------------\n> Android apps run on BlackBerry 10\n> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.\n> Now with support for Jelly Bean, Bluetooth, Mapview and more.\n> Get your Android app in front of a whole new audience.  Start now.\n>\n> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n\n\n-- \nMat\u00edas Alejo Garcia\nCinemaKi.com\nSkype/Twitter: @ematiu\nRoads? Where we're going, we don't need roads!\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140216/20ac0eef/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Testnet block explorer",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Melvin Carvalho",
                "Matias Alejo Garcia"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 5383
        }
    },
    {
        "title": "[Bitcoin-development] bitcoind json API (gettx/raw) (newbie questions #2)",
        "thread_messages": [
            {
                "author": "Denis Andrejew",
                "date": "2014-02-18T00:01:40",
                "message_text_only": "Hey everybody,\n\nhere's another question that I have:\n\nI'd like a small bit of clarification about the gettx / getrawtransaction\n(decoded) api call. I understand that I can find the address that a\ntransaction output is directed at / available to for future use sits in the\nvout array in the scriptPubKey.addresses array. I'm a little uncertain as\nto why that piece of information would be typed as an array when all it\never seems to contain is one (not more, not less) address(es).\n\nAre there any cases of transactions right now that don't contain exactly 1\nitem in that array, i.e. more or less than a single address (per single\nvout element, not per tx)? Or is the thinking behind this array to somehow\nmake the data structure more extensible for potential future use? But then\nI can't think of any use cases where it appears to make any sense to put\nmore than 1 address there...\n\nOr am I even asking the wrong questions? For spending those coins, i.e.\nusing them in a future transaction it's all about owning the public/private\nkey that is contained in the vout script, right? So the address doesn't\nreally matter and it could be 2 or more (or none at all?) addresses in\nthere, and what matters is just that the next guy has the key to spending\nthose coins... ?\n\nOnce again I'm coming to these questions from a project where I'm trying to\ncalculate unspent outputs and from that balances for all accounts and I'm\nnot sure yet what other special cases there might be in the blockchain that\nI need to be aware of and handle properly in order to (re-)produce accurate\ndata!\n\nThanks for your help, much appreciated!\n- Denis\n\n\"Be the change you want to see in the world.\" (Mahatma Gandhi)\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140218/b71995c6/attachment.html>"
            },
            {
                "author": "Odinn Cyberguerrilla",
                "date": "2014-02-18T08:17:15",
                "message_text_only": "> Hey everybody,\n>\n> here's another question that I have:\n>\n> I'd like a small bit of clarification about the gettx / getrawtransaction\n> (decoded) api call. I understand that I can find the address that a\n> transaction output is directed at / available to for future use sits in\n> the\n> vout array in the scriptPubKey.addresses array. I'm a little uncertain as\n> to why that piece of information would be typed as an array when all it\n> ever seems to contain is one (not more, not less) address(es).\n>\n> Are there any cases of transactions right now that don't contain exactly 1\n> item in that array, i.e. more or less than a single address (per single\n> vout element, not per tx)? Or is the thinking behind this array to somehow\n> make the data structure more extensible for potential future use? But then\n> I can't think of any use cases where it appears to make any sense to put\n> more than 1 address there...\n\nThis might be such a use case, just maybe --> https://coinb.in/multisig\nAlso I recommend checking out http://abis.io\nThese may be things you are thinking about in the context of this.\n\n> Or am I even asking the wrong questions? For spending those coins, i.e.\n> using them in a future transaction it's all about owning the\n> public/private\n> key that is contained in the vout script, right? So the address doesn't\n> really matter and it could be 2 or more (or none at all?) addresses in\n> there, and what matters is just that the next guy has the key to spending\n> those coins... ?\n>\n> Once again I'm coming to these questions from a project where I'm trying\n> to\n> calculate unspent outputs and from that balances for all accounts and I'm\n> not sure yet what other special cases there might be in the blockchain\n> that\n> I need to be aware of and handle properly in order to (re-)produce\n> accurate\n> data!\n>\n> Thanks for your help, much appreciated!\n> - Denis\n>\n> \"Be the change you want to see in the world.\" (Mahatma Gandhi)\n> ------------------------------------------------------------------------------\n> Managing the Performance of Cloud-Based Applications\n> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> Read the Whitepaper.\n> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk_______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            }
        ],
        "thread_summary": {
            "title": "bitcoind json API (gettx/raw) (newbie questions #2)",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Denis Andrejew",
                "Odinn Cyberguerrilla"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 4319
        }
    },
    {
        "title": "[Bitcoin-development] BIP70 proposed changes",
        "thread_messages": [
            {
                "author": "Andreas Schildbach",
                "date": "2014-02-18T17:31:04",
                "message_text_only": "I'm starting a thread on proposed changes on BIP70 based on my\nexperience in implementing the payment protocol in Bitcoin Wallet:\n\n- certificate chain in pki_data: I think it should be required that is\nmost contain the first certificate PLUS all intermediate certificates\n(if any), but NOT the root certificate. Reason: We want to be able to\nverify offline.\n\n- definition of timezone: Its not clear if times (e.g. expires) are in\nUTC or local. I suggest to require UTC. If if we can't agree on this,\nthere should be a sentence about timezones in the spec.\n\n(probably more to be added...)"
            },
            {
                "author": "Ryan X. Charles",
                "date": "2014-02-18T19:14:24",
                "message_text_only": "Here are my complementary thoughts after working on the payment protocol\non the merchant side at BitPay.\n\nThe most important missing piece of the payment protocol is that is has\nno concept of the status of a payment after it has been made. What if\nthe payment is too little? Too much? What if it is never confirmed? What\nif it is confirmed, but very late? These are regular occurrences at\nBitPay (although hopefully they will be a lot fewer after the payment\nprotocol is widely adopted).\n\nOne way to handle this would be to add another type of message, say with\ncontent-type bitcoin-paymentstatus, that can return the merchant's view\nof the status of the transaction(s). Are the transactions under or\noverpaid? Are they confirmed? How many confirmations? Is the payment\n\"accepted\" even if the transactions aren't confirmed?\n\nI think it would be great if wallets could check the status of a\npayment, and if anything goes wrong, request a refund, all within the\npayment protocol.\n\nThe payment protocol is also the perfect opportunity to implement merge\navoidance to increase customer and merchant privacy. The merchant can\nsimply deliver multiple outputs in the payment details, say 10 or so,\nand the customer can spend multiple outputs to those outputs in separate\ntransactions. It would be great if BitPay could work with wallet authors\nto make merge avoidance a reality in the near-term.\n\nMerge avoidance would increase the need to have a bitcoin-paymentstatus\nmessage since it's possible that some, but not all, of the transactions\nwould confirm, and so knowing the status of payment would be a complex\nquestion that should be handled automatically by the software.\n\nOn an unrelated note, X.509 is a terrible standard that should be\nabandoned as quickly as possible. BitPay is working on a new standard\nbased on bitcoin-like addresses for authentication. It would be great if\nwe could work with the community to establish a complete, decentralized\nauthentication protocol. The sooner we can evolve beyond X.509 the better.\n\nOne more thing. The new bitcoin URI in BIP 72 is extremely long and\nmakes for very dense QR codes. BitPay has proposed a new standard, BIP\n73, for shorter URIs and less dense QR codes. We hope wallet authors\nwill implement this better standard.\n\nMy response to Andreas' thoughts:\n\nOn 2/18/14, 12:31 PM, Andreas Schildbach wrote:\n> I'm starting a thread on proposed changes on BIP70 based on my\n> experience in implementing the payment protocol in Bitcoin Wallet:\n> \n> - certificate chain in pki_data: I think it should be required that is\n> most contain the first certificate PLUS all intermediate certificates\n> (if any), but NOT the root certificate. Reason: We want to be able to\n> verify offline.\n\nSo long as the root certificate remains an optional addition, this seems\nlike a good idea. My experience with tls in node is that it is required\nfor the root certificate to be present, so we don't want to require that\nthe root certificate be absent, since that would make it painful to make\ncode that is interoperable between the two. IIRC setting\nrejectUnauthorized=true will reject connections that do not deliver the\nroot certificate, so allowing the root certificate to be present would\nbe compatible with this and presumably other tls code.\n\nWould be great if someone with more experience with tls weighed in on\nwhether the root certificate can/should be present.\n\n> \n> - definition of timezone: Its not clear if times (e.g. expires) are in\n> UTC or local. I suggest to require UTC. If if we can't agree on this,\n> there should be a sentence about timezones in the spec.\n\nThe world needs to abandon timezones altogether for everything and only\nuse UTC. So, agreed. Require UTC.\n\n> \n> (probably more to be added...)\n> \n> \n> ------------------------------------------------------------------------------\n> Managing the Performance of Cloud-Based Applications\n> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> Read the Whitepaper.\n> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> \n\n-- \nRyan X. Charles\nSoftware Engineer, BitPay\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0xA11B4DDE.asc\nType: application/pgp-keys\nSize: 5627 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140218/00805bee/attachment.bin>"
            },
            {
                "author": "Gavin Andresen",
                "date": "2014-02-18T20:15:45",
                "message_text_only": "Fantastic feedback, thanks Ryan and Andreas!\n\nPlease don't let me being busy get in the way of progress, so submit pull\nrequests to the BIP (the UTC timezone issue seems obvious and\nnon-controversial) or write up draft specs for extensions.\n\nRE: wallets checking the status of payment:  excellent idea. A URL that can\nbe polled to check payment processing status sounds like the right thing to\ndo.\n\nThat feels very similar to the proposal for recurring payments; I think\nthey would be separate mechanisms, but maybe their specs could share some\nof the same concepts / field names....\n\n\nOn Tue, Feb 18, 2014 at 2:14 PM, Ryan X. Charles <ryan at bitpay.com> wrote:\n\n> Here are my complementary thoughts after working on the payment protocol\n> on the merchant side at BitPay.\n>\n> The most important missing piece of the payment protocol is that is has\n> no concept of the status of a payment after it has been made. What if\n> the payment is too little? Too much? What if it is never confirmed? What\n> if it is confirmed, but very late? These are regular occurrences at\n> BitPay (although hopefully they will be a lot fewer after the payment\n> protocol is widely adopted).\n>\n> One way to handle this would be to add another type of message, say with\n> content-type bitcoin-paymentstatus, that can return the merchant's view\n> of the status of the transaction(s). Are the transactions under or\n> overpaid? Are they confirmed? How many confirmations? Is the payment\n> \"accepted\" even if the transactions aren't confirmed?\n>\n> I think it would be great if wallets could check the status of a\n> payment, and if anything goes wrong, request a refund, all within the\n> payment protocol.\n>\n> The payment protocol is also the perfect opportunity to implement merge\n> avoidance to increase customer and merchant privacy. The merchant can\n> simply deliver multiple outputs in the payment details, say 10 or so,\n> and the customer can spend multiple outputs to those outputs in separate\n> transactions. It would be great if BitPay could work with wallet authors\n> to make merge avoidance a reality in the near-term.\n>\n> Merge avoidance would increase the need to have a bitcoin-paymentstatus\n> message since it's possible that some, but not all, of the transactions\n> would confirm, and so knowing the status of payment would be a complex\n> question that should be handled automatically by the software.\n>\n> On an unrelated note, X.509 is a terrible standard that should be\n> abandoned as quickly as possible. BitPay is working on a new standard\n> based on bitcoin-like addresses for authentication. It would be great if\n> we could work with the community to establish a complete, decentralized\n> authentication protocol. The sooner we can evolve beyond X.509 the better.\n>\n> One more thing. The new bitcoin URI in BIP 72 is extremely long and\n> makes for very dense QR codes. BitPay has proposed a new standard, BIP\n> 73, for shorter URIs and less dense QR codes. We hope wallet authors\n> will implement this better standard.\n>\n> My response to Andreas' thoughts:\n>\n> On 2/18/14, 12:31 PM, Andreas Schildbach wrote:\n> > I'm starting a thread on proposed changes on BIP70 based on my\n> > experience in implementing the payment protocol in Bitcoin Wallet:\n> >\n> > - certificate chain in pki_data: I think it should be required that is\n> > most contain the first certificate PLUS all intermediate certificates\n> > (if any), but NOT the root certificate. Reason: We want to be able to\n> > verify offline.\n>\n> So long as the root certificate remains an optional addition, this seems\n> like a good idea. My experience with tls in node is that it is required\n> for the root certificate to be present, so we don't want to require that\n> the root certificate be absent, since that would make it painful to make\n> code that is interoperable between the two. IIRC setting\n> rejectUnauthorized=true will reject connections that do not deliver the\n> root certificate, so allowing the root certificate to be present would\n> be compatible with this and presumably other tls code.\n>\n> Would be great if someone with more experience with tls weighed in on\n> whether the root certificate can/should be present.\n>\n> >\n> > - definition of timezone: Its not clear if times (e.g. expires) are in\n> > UTC or local. I suggest to require UTC. If if we can't agree on this,\n> > there should be a sentence about timezones in the spec.\n>\n> The world needs to abandon timezones altogether for everything and only\n> use UTC. So, agreed. Require UTC.\n>\n> >\n> > (probably more to be added...)\n> >\n> >\n> >\n> ------------------------------------------------------------------------------\n> > Managing the Performance of Cloud-Based Applications\n> > Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> > Read the Whitepaper.\n> >\n> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk\n> > _______________________________________________\n> > Bitcoin-development mailing list\n> > Bitcoin-development at lists.sourceforge.net\n> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> >\n>\n> --\n> Ryan X. Charles\n> Software Engineer, BitPay\n>\n>\n> ------------------------------------------------------------------------------\n> Managing the Performance of Cloud-Based Applications\n> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> Read the Whitepaper.\n>\n> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n\n\n-- \n--\nGavin Andresen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140218/560522b2/attachment.html>"
            },
            {
                "author": "Andreas Schildbach",
                "date": "2014-02-18T21:40:13",
                "message_text_only": "On 02/18/2014 08:14 PM, Ryan X. Charles wrote:\n\n> The most important missing piece of the payment protocol is that is has\n> no concept of the status of a payment after it has been made. What if\n> the payment is too little? Too much? What if it is never confirmed? What\n> if it is confirmed, but very late? These are regular occurrences at\n> BitPay (although hopefully they will be a lot fewer after the payment\n> protocol is widely adopted).\n\nI would like to understand why this happens at BitPay? If this is\nbecause people use cut and paste to copy the address and then type the\namount by hand... well this kind of usage will go away.\n\nA program (like an app) should be capable of paying the exact amount. If\nnot, that's a bug of the app not the protocol.\n\n> On an unrelated note, X.509 is a terrible standard that should be\n> abandoned as quickly as possible.\n\n+1\n\n> BitPay is working on a new standard\n> based on bitcoin-like addresses for authentication. It would be great if\n> we could work with the community to establish a complete, decentralized\n> authentication protocol.\n\nSounds interesting, let us know as soon as you have anything.\n\n>> - certificate chain in pki_data: I think it should be required that is\n>> most contain the first certificate PLUS all intermediate certificates\n>> (if any), but NOT the root certificate. Reason: We want to be able to\n>> verify offline.\n>\n> So long as the root certificate remains an optional addition, this seems\n> like a good idea.\n\nIn which case does it make sense to duplicate the root cert? I'm asking\nbecause it should already be present in the trusted root store, right?\n\nMaybe can you tell about which measures you needed to take to get X.509\nworking? To me it felt there very several problems.\n\n> My experience with tls in node is that it is required\n\nTLS? We're not using that for pki_data -- its just a byte array.\n\n>> - definition of timezone: Its not clear if times (e.g. expires) are in\n>> UTC or local. I suggest to require UTC. If if we can't agree on this,\n>> there should be a sentence about timezones in the spec.\n>\n> The world needs to abandon timezones altogether for everything and only\n> use UTC. So, agreed. Require UTC.\n\n--> https://github.com/bitcoin/bips/pull/20"
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-02-19T14:10:49",
                "message_text_only": "On Tue, Feb 18, 2014 at 4:40 PM, Andreas Schildbach\n<andreas at schildbach.de> wrote:\n> On 02/18/2014 08:14 PM, Ryan X. Charles wrote:\n>> BitPay is working on a new standard\n>> based on bitcoin-like addresses for authentication. It would be great if\n>> we could work with the community to establish a complete, decentralized\n>> authentication protocol.\n>\n> Sounds interesting, let us know as soon as you have anything.\n\nSINs.  See https://en.bitcoin.it/wiki/Identity_protocol_v1\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-02-19T16:44:00",
                "message_text_only": "Thanks for the feedback guys!\n\nI would also like to understand the problems you've been having with\ncertificates in node.js. FYI the CA cert is *not* supposed to be included,\nthis matches what the code in Bitcoin Core and bitcoinj expects. It may be\nthat Bitcoin Core accepts a redundant CA cert being provided, but if so\nthat'd fall in the category of openssl being generous. If there are issues\nhere, it sounds like an issue with node and not the spec. I'm not even sure\nwhy it would matter - certs are just byte arrays so if node can sign a hash\nwith a private key, the rest should be easy.\n\nWith regards to the PKI I'd appreciate it if we don't go around that circle\nagain. Please remember one of the primary goals of all of this is to show\nto the user on their hardware wallet a meaningful name. Almost all\nmerchants on the Internet already went through the process of associating a\npublic key with their name, using X.509.\n\nWhilst for now your payment requests will have to be signed as BitPay, this\nisn't ideal for the longer term and I'd like to design a protocol extension\nto allow merchants to delegate their signature authority to you. In this\nway they would be able to sign a secondary key with their own ssl key as\npart of the enrolment process, and after that you could sign payment\nrequests on their behalf. Kind of like a Bitcoin  specific subcert (and\nthere would be no reason to use X.509 format for that).\n\nRe: feedback url. How is this different to a result code in PaymentAck\nwhich already caused much debate? Surely we want a payment to either work\nout boy work and for that decision to be made immediately? Your invoice\npage switches to a completed state once you see a tx be broadcast so that's\nthe \"done\" state today even if there are caveats. I'd like to see a status\ncode added to PaymentAck so receivers can reject payments if they are bad\nin some way.\n On 19 Feb 2014 19:41, \"Jeff Garzik\" <jgarzik at bitpay.com> wrote:\n\n> On Tue, Feb 18, 2014 at 4:40 PM, Andreas Schildbach\n> <andreas at schildbach.de> wrote:\n> > On 02/18/2014 08:14 PM, Ryan X. Charles wrote:\n> >> BitPay is working on a new standard\n> >> based on bitcoin-like addresses for authentication. It would be great if\n> >> we could work with the community to establish a complete, decentralized\n> >> authentication protocol.\n> >\n> > Sounds interesting, let us know as soon as you have anything.\n>\n> SINs.  See https://en.bitcoin.it/wiki/Identity_protocol_v1\n>\n> --\n> Jeff Garzik\n> Bitcoin core developer and open source evangelist\n> BitPay, Inc.      https://bitpay.com/\n>\n>\n> ------------------------------------------------------------------------------\n> Managing the Performance of Cloud-Based Applications\n> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> Read the Whitepaper.\n>\n> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140219/26590536/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-18T21:47:22",
                "message_text_only": "On Tue, Feb 18, 2014 at 02:14:24PM -0500, Ryan X. Charles wrote:\n> The payment protocol is also the perfect opportunity to implement merge\n> avoidance to increase customer and merchant privacy. The merchant can\n> simply deliver multiple outputs in the payment details, say 10 or so,\n> and the customer can spend multiple outputs to those outputs in separate\n> transactions. It would be great if BitPay could work with wallet authors\n> to make merge avoidance a reality in the near-term.\n> \n> Merge avoidance would increase the need to have a bitcoin-paymentstatus\n> message since it's possible that some, but not all, of the transactions\n> would confirm, and so knowing the status of payment would be a complex\n> question that should be handled automatically by the software.\n\nNote that merge-avoidance implemented in conjunction CoinJoin doesn't\nhave this problem - the CoinJoin'd transaction either does or doesn't\nconfirm. Meanwhile being able to avoid merges, or more precisely, being\nable to be flexible with them, makes achiving good value-privacy much\neasier.\n\nSecondly merge-flexibility also makes cut-thru payments possible. For\nexample BitPay can direct customers paying for goods to pay to addresses\ncontrolled by merchants and other parties who are owed money by BitPay.\nThis skips a step, saving on transction fees as well as increasing\nprivacy. Notably in this case the only parties that have to deal with\naccounting complexity are BitPay and the merchants - consumers' wallet\nsoftware needs no changes beyond generic payment protocol support, and\nnotably you can even use this technique without the payment protocol.\n\nSee my post \"DarkWallet Best Practices\" for more info:\n\nhttp://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg03508.html\n\n> On an unrelated note, X.509 is a terrible standard that should be\n> abandoned as quickly as possible. BitPay is working on a new standard\n> based on bitcoin-like addresses for authentication. It would be great if\n> we could work with the community to establish a complete, decentralized\n> authentication protocol. The sooner we can evolve beyond X.509 the better.\n\nWhat specifically do you dislike about X.509? The technical standard or\nthe infrastructure around it? (IE the centralized authorities)\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000051ad2df596f45df71320fb44b3c5f1b50231a591ffeb1d24\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140218/debb3f9f/attachment.sig>"
            },
            {
                "author": "Bernd Jendrissek",
                "date": "2014-02-18T23:41:36",
                "message_text_only": "[Ick, resending to list due to From: snafu(s)]\n\nOn Tue, Feb 18, 2014 at 11:47 PM, Peter Todd <pete at petertodd.org> wrote:\n> What specifically do you dislike about X.509? The technical standard or\n> the infrastructure around it? (IE the centralized authorities)\n\nI'm not the one who was complaining, but what I dislike is that a\ncertificate can have only one issuer. Cross-signing doesn't address my\ndislike: it's different enough from being a certificate's single\nissuer that it leaves too much power in the CAs' hands, IMHO.\n\nIt isn't so much the centralization per se that I object to, but the\nway that the technical standard encourages concentration in the\ninfrastructure. See\nhttp://lair.fifthhorseman.net/~dkg/tls-centralization/#Why_does_the_architecture_encourage_concentration%3F\n\nI've been (slowly) working on a patch to allow pki_data to contain\nmore than just the single certificate chain that the\nsingle-issuer-only format insists on, but I'm making as many steps\nback as forward, being unsure of the right way to do it. Implementing\nan OpenPGP-based pki_type would probably be better, but hacking x509+*\nseems like a lower-hanging fruit."
            },
            {
                "author": "Derber",
                "date": "2014-02-18T22:02:34",
                "message_text_only": "Any possibility of a UNIX UTC timestamp field in the customer payment\nmessage?\n\nFor many transactions, the exact time of payment is when it is 'made' by\nthe customer and not when 'requested' by the retailer or later mined. The\nblockchain time is an aggregate for the block and can differ significantly\nfrom transaction time so its value is limited.\n\nSmall slices of time can greatly impact the transaction value.  If we are\nultimately taxed as a currency, an exact time will for the transaction will\nimpact US GAAP accounting and the transaction's tax accounting. A time\nfield may also support 'first come first served' retailer programs and time\nsensitive promotions.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140218/ed97e9f2/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-02-21T15:34:31",
                "message_text_only": ">\n> One more thing. The new bitcoin URI in BIP 72 is extremely long and\n> makes for very dense QR codes.\n\n\nBIP 73 seems OK except that existing wallets that can scan QR codes will\nchoke. One reason the new URIs are long is for backwards compatibility.\n\nOne thing that makes the URI smaller is not escaping the payment URL -\nbitcoinj/Bitcoin Wallet at least does not require it, and it reduces the\nsize of the QR code by a non-trivial amount.\n\nRemoving the https:// and just defaulting to it also saves some bytes.\n\nFinally, BitPay is using rather long invoice IDs. Do you really need an ID\nlike JkLdFhQVFqmUurXpPXZcRp? That's a really huge ID space and the invoices\nexpire fast. So you could potentially implement a short mapping on the\nserver side and make much smaller IDs that way.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/353ad9f4/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP70 proposed changes",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Derber",
                "Andreas Schildbach",
                "Mike Hearn",
                "Peter Todd",
                "Ryan X. Charles",
                "Bernd Jendrissek",
                "Gavin Andresen"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 22741
        }
    },
    {
        "title": "[Bitcoin-development] Transaction malleability in the core code: update",
        "thread_messages": [
            {
                "author": "Gavin Andresen",
                "date": "2014-02-20T15:40:34",
                "message_text_only": "A quick update on the state of transaction malleability work in\nBitcoind/Bitcoin-Qt (aka Bitcoin Core). This is not about longer-term\nmalleability issues, just the very short-term work being done (or already\ndone) to the reference implementation.\n\nFirst, the problems:\n\nWe've had a longstanding TODO to improve the way the core code deals with\ndouble-spends. From the core code's point of view, malleable transactions\nare just one particular form of double-spend.\n\nImproving double-spend handling never made it to the top of the TODO list,\nbecause the cases where it happened involved doing unsupported things (like\ncopying your wallet.dat to another machine and then spending on both\nmachines).\n\nAnd because there is a heavy-handed workaround if a wallet becomes confused\nbecause of a double-spend:  restore all of the keys, rescan for\ntransactions confirmed in the blockchain, and any outputs tied up in\ndouble-spends get released. Coins (really, unspent transaction outputs)\nwere never permanently lost, but they could be tied up and unspendable when\nassociated with a 0-confirmation transaction that would never confirm.\n\nSo, work in progress or done:\n\nhttps://github.com/bitcoin/bitcoin/pull/3659\nhttps://github.com/bitcoin/bitcoin/pull/3674\n\nThese implements a kinder, gentler sledgehammer (-zapwallettxes) to fix a\nconfused wallet. If you have a wallet with 0-confirmation transactions that\nare tying up bitcoins these should fix it.\n\n\nhttps://github.com/bitcoin/bitcoin/pull/3651\nhttps://github.com/bitcoin/bitcoin/pull/3657\nhttps://github.com/bitcoin/bitcoin/pull/3676\n\nThese three merged pull requests implement a new command-line option:\n-nospendzeroconfchange .  The best way to get a wallet confused is to spend\nzero-confirmation change outputs that you created yourself; if the\ntransaction creating the change gets mutated, then the subsequent\ntransaction is invalid and will never confirm.\n\nThe core code spends unconfirmed change only as a last resort. If you are a\nservice using bitcoind that generates a lot of transactions then best\npractice would be to run with -nospendzeroconfchange, and use \"sendmany\" to\nbatch payments only after previous payments have confirmed.\n\nhttps://github.com/bitcoin/bitcoin/pull/3025\n\nThis tightens up the IsStandard() rule, so the easiest-to-implement method\nof mutating transactions is blocked. Many big mining pools are already\nrunning this patch.\n\nhttps://github.com/bitcoin/bitcoin/pull/3669\nhttps://github.com/bitcoin/bitcoin/pull/3671\nhttps://github.com/bitcoin/bitcoin/pull/3694\n\nThese three get at the root of the problem; they rework the core wallet\ncode to implement \"handle double spends better.\"  See the pull requests for\ndetails.\n\nHow can you help:\n\nTesting and code review is, as always, the bottleneck for getting out a\nrelease with these changes.\n\nWe have a chronic problem with people running Bitcoin services on top of\nthe core code waiting until there is an \"official\" release, and then\nassuming that somebody else has done the hard work of reviewing and testing\nthe changes.\n\nYOU SHOULD NOT BE MAKING THAT ASSUMPTION!  Your particular RPC call usage\nmight trigger some edge-case bug that was missed, or perhaps the size of\nyour wallet triggers a performance problem introduced by a fix.\n\nOr, in other words: do not treat the core development team as if we were a\ncommercial company that sold you a software library. That is not how open\nsource works; if you are making a profit using the software, you are\nexpected to help develop, debug, test, and review it.\n\n-- \n--\nGavin Andresen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140220/6ba57731/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Transaction malleability in the core code: update",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Gavin Andresen"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3737
        }
    },
    {
        "title": "[Bitcoin-development] Base-32 error correction coding",
        "thread_messages": [
            {
                "author": "Mark Friedenbach",
                "date": "2014-02-21T02:41:05",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nWhat follows is a proposed BIP for human-friendly base-32\nserialization with error correction encoding. A formatted version is\nviewable as part of a gist with related code:\n\nhttps://gist.github.com/maaku/8996338#file-bip-ecc32-mediawiki\n\nAn implementation of this BIP and associated APIs is made available as\na pull request, with comprehensive testing:\n\nhttps://github.com/bitcoin/bitcoin/pull/3713\n\nThis format is anticipated to be useful for helpdesk-related data\n(e.g. the proposed normalized transaction ID), and future wallet\nbackup & paper wallet serialization formats.\n\n\n== Abstract ==\n\nThe BIP proposes an human-centered encoding format for base-32 data\nserialization. It differs from the presumptive default hexadecimal or\nbase58 encodings in the following ways:\n\n1. Visually distinctive in that it includes the full range of\nalphanumeric digits in its base-32 encoding, except the characters 0,\nl, v, and 2. which are too easily confused with 1, i, u, r, or z in\nfont or handwriting.\n\n2. Automatic correction of up to 1 transcription error per 31 coded\ndigits (130 bits of payload data). For a 256-bit hash or secret key,\nthis enables seamless recovery from up to two transcription errors so\nlong as they occur in separate halves of the coded representation.\n\n3. Highly probable detection of errors beyond the error correction\nthreshold, with a false negative rate on the order of 25 bits, or 1 in\n33 million likelihood.\n\n4. Case-insensitive encoding ensures that it may be displayed in an\neasier to read uniform case, and it is faster and more comfortable to\nvocally read off a base-32 encoded number than the alternatives of\nhexadecimal or base58.\n\nIn addition to the error correction code transformation of base-32\ndata, a padding scheme is specified for extending numbers or bit\nvectors of any length to a multiple of 5 bits suitable for base-32\nencoding.\n\n== z-base-32 ==\n\nThe bitcoin reference client already has one implementation of base-32\nencoding following the RFC 3548 standard, using the following alphabet:\n\n    const char *pbase32 = \"abcdefghijklmnopqrstuvwxyz234567\";\n\nFor error correction coded strings this BIP specifies usage of Phil\nZimmermann's z-base-32 encoding alphabet[], which provides better\nresistance to transcriptive errors than the RFC 3548 standard:\n\n    const char *pzbase32 = \"ybndrfg8ejkmcpqxot1uwisza345h769\";\n\nThe same RFC 3548 coder is used for z-base-32, except that unnecessary\n'=' padding characters are stripped before performing the alphabet\nsubstitution. For example, the hexadecimal string 'ae653be0049be3' is\nRFC 3548 encoded as 'vzstxyaetprq====', and z-base-32 encoded as\n'i31uzayruxto'.\n\n== CRC-5-USB error correction coding ==\n\nHerein we describe an error correction encoding using cyclic\nredundancy check polynomial division[], which requires 5 error\ncorrection digits per 26 digits of input, instead of the theoretically\noptimal 4, but is much, much easier to implement correctly then\navailable non-patented error correction codes. Cyclic redundancy check\npolynomial division provides a very straightforward, patent-free\nmechanism for reliably detecting transcription errors in input, and\nperforming up to 1-digit corrections per 26 digit block.\n\n=== Encoding ===\n\nThe input to this error correction encoder is a sequence of 26 base-32\ndigits. These digits are decoded into 5-bit unsigned integers with\nvalues equal to their offset into the base-32 alphabet string. If the\ninput is less than 26 digits in length, it is extended with\nzero-valued digits. If For example, the string 'vzstxyaetprq' using\nthe RFC 3548 alphabet becomes the code point sequence:\n\n    <21 25 18 19 23 24 0 4 19 15 17 16 0 0 0 0 0 0 0 0 0 0 0 0 0 0>'\n     |--------------input-------------|---------padding----------|\n\nExpositionally it helps to think of this array as a 26-element column\nvector of 5-bit binary integers:\n\n    <0b10101\n     0b11001\n     0b10010\n     0b10011\n     0b10111\n     0b11000\n     0b00000\n     0b00100\n     0b10011\n     0b01111\n     0b10001\n     0b10000\n     ... 14 zero elements ...>\n\nIf we explode the bits of each element into 5, 1-bit columns, we get a\n26 x 5 matrix:\n\n    <1 0 1 0 1\n     1 1 0 0 1\n     1 0 0 1 0\n     1 0 0 1 1\n     1 0 1 1 1\n     1 1 0 0 0\n     0 0 0 0 0\n     0 0 1 0 0\n     1 0 0 1 1\n     0 1 1 1 1\n     1 0 0 0 1\n     1 0 0 0 0\n     ... 14 x 5 zero elements ...>\n\nThe array is then transposed, such that we get a 5 x 26 matrix where\neach row represents the 5th, 4th, 3rd, 2nd, or 1st bit, respectfully,\nof each element:\n\n    <1 1 1 1 1 1 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n     0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n     1 0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n     0 0 1 1 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n     1 1 0 1 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0>\n     |---------input--------|----------padding---------|\n\nWe then use each of these rows separately as input into a cyclic\nredundancy check polynomial division operation, using the CRC-5-USB\ngenerating polynomial <code>x^5 + x^2 + 1</code>. The result is 5\nelement column vector:\n\n    <10111\n     01000\n     10010\n     00111\n     00110>\n\nThe elements of this vector are then exploded horizontally, and\naffixed to the end of the bit matrix.\n\n    <1 1 1 1 1 1 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1\n     0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0\n     1 0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0\n     0 0 1 1 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1\n     1 1 0 1 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0>\n     |---------input--------|----------padding----------|--crc---|\n\nAt this point, calculating the CRC checksum for each row should result\nin zero:\n\n    <0 0 0 0 0>\n\nNow we reverse the process in order to encode the output. First the\npadding bits are removed:\n\n    <1 1 1 1 1 1 0 0 1 0 1 1 1 0 1 1 1\n     0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0\n     1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0\n     0 0 1 1 1 0 0 0 1 1 0 0 0 0 1 1 1\n     1 1 0 1 1 0 0 0 1 1 1 0 0 0 1 1 0>\n     |---------input--------|--crc---|\n\nThen the matrix is once again transposed, to yield an (l+5) x 5\nmatrix, where l is the number of digits in the original input:\n\n<1 0 1 0 1  -\n 1 1 0 0 1  |\n 1 0 0 1 0  |\n 1 0 0 1 1  |\n 1 0 1 1 1  i\n 1 1 0 0 0  n\n 0 0 0 0 0  p\n 0 0 1 0 0  u\n 1 0 0 1 1  t\n 0 1 1 1 1  |\n 1 0 0 0 1  |\n 1 0 0 0 0  -\n 1 0 1 0 0  -\n 0 1 0 0 0  c\n 1 0 0 1 1  r\n 1 0 1 1 1  c\n 1 0 0 1 0> -\n\nAnd the rows are imploded:\n\n    <21 25 18 19 23 24 0 4 19 15 17 16 20 8 19 23 18>'\n     |--------------input-------------|----crc-----|\n\nAnd the result is converted into z-base-32: 'i31uzayruxtoweuz1'.\n\n=== Decoding and error recovery ===\n\nThe process of decoding and error detection and recovery is similar to\nencoding, and this section will not explain steps that were adequately\ncovered in the encoder description.\n\nFirst, the input is converted from z-base-32 into a sequence of up to\n31 (26+5) 5-bit integers, with zero-valued padding inserted between\nthe end of the input and the 5-digit checksum. Using our running\nexample of 'i31uzayruxtoweuz1', this result is the following:\n\n    <21 25 18 19 23 24 0 4 19 15 17 16 0 0 0 0 0 0 0 0 0 0 0 0 0 0 20\n8 19 23 18>'\n\n|--------------input-------------|----------padding----------|----crc-----|\n\nThe binary representation of each element is exploded horizontally,\nand the matrix transposed to yield the following 5 x 31 bit matrix:\n\n    <1 1 1 1 1 1 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1\n     0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0\n     1 0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0\n     0 0 1 1 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1\n     1 1 0 1 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0>\n     |---------input--------|----------padding----------|--crc---|\n\nA CRC calculation of each row should yield zero if the encoded string\nwas transcribed correctly. If, however, a digit was wrong, that would\nresult in some or all of the bits of the corresponding column being\nflipped. A property of the CRC generating polynomial used is that in\nthe case of a single digit error, each row with a flipped bit would\nresult in the same checksum, and that checksum value can be used as\nthe index into a table indicating which bit was flipped:\n\n    // EC[0] has no meaning, because offsets are 1-based\n    const unsigned char EC[32] =\n        { 32,  4,  3, 17,  2, 30, 16, 24,\n           1,  6, 29,  8, 15, 27, 23, 12,\n           0, 25,  5, 18, 28, 13,  7,  9,\n          14, 10, 26, 19, 22, 21, 11, 20 };\n\nIf all checksum values are zero, the decoder assumes the input is\ncorrect. If all non-zero checksum values are equal valued, the decoder\nassumes the corresponding digit was transcribed incorrectly and flips\nthe bit in that column of the rows with non-zero checksums.\n\nIf any of the five checksum values are non-zero, and not equal to each\nother, then there is an unrecoverable error in the input. The\nprobability of two or more digits being incorrect and yet by chance\nthe checksums being zero or equal valued is less than 1 in 33 million.\n\nNow that errors have been detected and single-digit errors corrected,\nthe padding bits and CRC checksum bits are removed. The matrix is\ntransposed, it's rows imploded, and the resulting sequence of up to 26\ncharacters converted into base-32 using the RFC 3548 alphabet:\n'vzstxyaetprq'.\n\n== CodedBase32 integer encoding ==\n\nAlthough providing an error correction coder for base-32 data\ninteresting and useful in contexts where base-32 is already deployed,\nmany applications involve encoding of integers which are powers of two\nin length. This section provides a standard scheme for the encoding of\nany sized bitstring into a multiple of 5 bits in length, suitable for\ndirect encoding into base-32.\n\nFirst the size in bits of the integer is rounded up to the next\nhighest power of two greater than or equal to 128. This value with a\nfactor of 128 removed is known as <code>n</code>, and its base-2\nlogorithm as <code>e</code>. Pseudocode:\n\n    int n = max(next_power_of_two(BITS), 128) / 128;\n    int e = log2(n);\n\nA total of <code>2*n</code> padding bits are prefixed to the\nbitstring. These consist of <code>e</code> 1 bits, a single 0 bit, and\n<code>2*n-e-1</code> user-specified bits (the \"extra\" field).\n\nThe bitstring is now a multiple of 5 in length and can be directly\nconverted into base-32.\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.14 (GNU/Linux)\nComment: GPGTools - http://gpgtools.org\nComment: Using GnuPG with Thunderbird - http://www.enigmail.net/\n\niQIcBAEBAgAGBQJTBry9AAoJEAdzVfsmodw45UwP/1kjvfFMe0I+F+0Ma+sl8o3a\nU3/FlyOapIL8wZPyjXItts7/5V8kPOSPiEjnG/Oes7eBmiod2UYy+73qIHaHI6Ug\n88OMjX8hSHYz+EfxrUkb8Uiios4FNS6vo/SVjELR8vLiQoJ30T4l56QMJvMle1wj\n+GDdHjNfL0F9NzqA7WY1rRRXllBCmDfLUeYS3raOx9tmGgfj/4h451RLwXouIwT6\noBMBIJzkGLHi//0SF+xlNJb/zebD421qXLgg28ci0fz+bxMEtPM7HktCpHS+pzUu\nV211rA3eP6/gb617SHD7XcxROubpsZ0y1ieaCzjfrQ0NUDqEkYyydDh4rf2AF99R\nODwy8bDNikhN62480Gd2PuqKftf66tUdycXMcnC9Cwe3Ejli+RKBGnTBh5ekPO3+\nPmu/vgILuL8WojOKcAnMSk0tvA+w0kBf/b7mUzLsBpJfOMxtk3KgKrWWbuxotz0C\nVKGVICpvtrA87jpOqB36Hn1tFYRknCX9PCzPEENpJg/aK26xNTid4jtbg9MhopdS\nGuH4SBNYvvgq7VkCbq5zggh37npgHy/mmBhAmDw7ecBPw/O9jtGEUSFbSTMoaL5s\nhK5WTlsSNvvuAaFlv0qvreI1gQiJBhR9+JuZfFS1fzBXWcmDf7n8kqkbLOQr6nVJ\nO6AhIj7iHRCNfSTuhElY\n=ZHxf\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Jim Paris",
                "date": "2014-02-24T18:29:31",
                "message_text_only": "Mark Friedenbach wrote:\n> What follows is a proposed BIP for human-friendly base-32\n> serialization with error correction encoding.\n...\n> 2. Automatic correction of up to 1 transcription error per 31 coded\n> digits (130 bits of payload data). For a 256-bit hash or secret key,\n> this enables seamless recovery from up to two transcription errors so\n> long as they occur in separate halves of the coded representation.\n\nCan we do better than correcting single transcription errors?  I'd\nimagine that transposition of two adjacent characters, or insertion or\ndeletion of a single character, would be very common.  At the very\nleast, a transposition could be corrected by interleaving the two\n\"halves of the coded representation\", e.g.:\n\n   ABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABAB\n\ninsead of\n   \n   AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\n\nJim"
            }
        ],
        "thread_summary": {
            "title": "Base-32 error correction coding",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jim Paris",
                "Mark Friedenbach"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 12267
        }
    },
    {
        "title": "[Bitcoin-development] Bitcoin Core trial balloon: splitting blockchain engine and wallet",
        "thread_messages": [
            {
                "author": "Jeff Garzik",
                "date": "2014-02-21T06:09:55",
                "message_text_only": "[Meta: \"Bitcoin Core\" is the newfangled branding of bitcoind /\nBitcoin-Qt reference implementation, in case you wondering.]\n\nSeveral sites, including BitPay, use bitcoind outside the standard\nrole of wallet software.  bitcoind can be used purely for payment\nnetwork access and management.  I call this the \"border router\" role.\nUpcoming version 0.9 will feature the ability to disable the bitcoind\nwallet at compile time or runtime. This permits a more optimized\nborder router profile, reducing process size by 40-200MB according to\nsome reports.\n\nRecent IRC discussion have floated a rough proposal for a wallet\nnext-step:  Running the Bitcoin Core wallet as a separate process, a\nseparate binary, from the blockchain engine.  The wallet process would\ncommunicate with the blockchain engine using existing RPC and P2P\nchannels, becoming a real SPV client.  This accomplishes a\nlongstanding security goal of sandboxing away wallet keys and\nsensitive data from the network-exposed P2P engine, in a separate\nprocess, among other benefits.\n\nSimple forking was explored a bit.  I did some hacking in that\ndirection, as it seemed potentially lightweight and somewhat easy to\nme: https://github.com/jgarzik/bitcoin/tree/fork  fork+pipe is fine\nfor Linux and OSX/BSD.  However, Windows requires an exec-like\nsolution to create a new process.  MSDN does give us a Unix-pipe-like\nsolution: http://msdn.microsoft.com/en-us/library/edze9h7e%28v=vs.80%29.aspx\n Others pointed to boost interprocess communication APIs, which come\nwith their own set of caveats.  Such a solution would involve a brand\nnew IPC protocol, and lots of brand new glue code.\n\nSeparate programs seems better.  Windows forces us to achieve process\nseparation via exec-like method.  We already have IPC: RPC + P2P.\nModern OS's make localhost sockets just about as fast as other IPCs\nmethods.  Linux, at least, employs zero-copy for localhost sockets in\nmany situations, similar to the kernel's pipe tricks.\n\nPieter has been working on headers-first sync:\nhttps://github.com/bitcoin/bitcoin/pull/2964  Moving along this\nwallet/blockchain engine split requires upping the review&test\nbandwidth on Pieter's PRs, such as\nhttps://github.com/bitcoin/bitcoin/pull/3514\n\nUnsure how much of the separate-binary discussion Gavin saw, so cc'd\nfor emphasis.\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-02-21T06:27:02",
                "message_text_only": "Bear in mind a separate process doesn't buy you anything without a sandbox,\nand those are expensive (in terms of complexity).\nOn 21 Feb 2014 11:40, \"Jeff Garzik\" <jgarzik at bitpay.com> wrote:\n\n> [Meta: \"Bitcoin Core\" is the newfangled branding of bitcoind /\n> Bitcoin-Qt reference implementation, in case you wondering.]\n>\n> Several sites, including BitPay, use bitcoind outside the standard\n> role of wallet software.  bitcoind can be used purely for payment\n> network access and management.  I call this the \"border router\" role.\n> Upcoming version 0.9 will feature the ability to disable the bitcoind\n> wallet at compile time or runtime. This permits a more optimized\n> border router profile, reducing process size by 40-200MB according to\n> some reports.\n>\n> Recent IRC discussion have floated a rough proposal for a wallet\n> next-step:  Running the Bitcoin Core wallet as a separate process, a\n> separate binary, from the blockchain engine.  The wallet process would\n> communicate with the blockchain engine using existing RPC and P2P\n> channels, becoming a real SPV client.  This accomplishes a\n> longstanding security goal of sandboxing away wallet keys and\n> sensitive data from the network-exposed P2P engine, in a separate\n> process, among other benefits.\n>\n> Simple forking was explored a bit.  I did some hacking in that\n> direction, as it seemed potentially lightweight and somewhat easy to\n> me: https://github.com/jgarzik/bitcoin/tree/fork  fork+pipe is fine\n> for Linux and OSX/BSD.  However, Windows requires an exec-like\n> solution to create a new process.  MSDN does give us a Unix-pipe-like\n> solution:\n> http://msdn.microsoft.com/en-us/library/edze9h7e%28v=vs.80%29.aspx\n>  Others pointed to boost interprocess communication APIs, which come\n> with their own set of caveats.  Such a solution would involve a brand\n> new IPC protocol, and lots of brand new glue code.\n>\n> Separate programs seems better.  Windows forces us to achieve process\n> separation via exec-like method.  We already have IPC: RPC + P2P.\n> Modern OS's make localhost sockets just about as fast as other IPCs\n> methods.  Linux, at least, employs zero-copy for localhost sockets in\n> many situations, similar to the kernel's pipe tricks.\n>\n> Pieter has been working on headers-first sync:\n> https://github.com/bitcoin/bitcoin/pull/2964  Moving along this\n> wallet/blockchain engine split requires upping the review&test\n> bandwidth on Pieter's PRs, such as\n> https://github.com/bitcoin/bitcoin/pull/3514\n>\n> Unsure how much of the separate-binary discussion Gavin saw, so cc'd\n> for emphasis.\n>\n> --\n> Jeff Garzik\n> Bitcoin core developer and open source evangelist\n> BitPay, Inc.      https://bitpay.com/\n>\n>\n> ------------------------------------------------------------------------------\n> Managing the Performance of Cloud-Based Applications\n> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> Read the Whitepaper.\n>\n> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/64ccb077/attachment.html>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-02-21T06:50:35",
                "message_text_only": "RE \"doesn't buy you anything\"   Today, when unlocked, plaintext\nprivate keys reside in the same address space as the blockchain engine\n(BCE).  Process separation increases the difficulty of accessing key\ndata from the BCE, even presuming a normal, no-chroot, same-uid,\nparent-child process relationship.  The attack surface is clearly\nchanged from \"one buffer overflow can touch this data.\"\n\nRegardless, the split makes sense given existing modularity and coding\ndirections.  I wouldn't micro-focus on the \"sandbox\" word.\n\nOn Fri, Feb 21, 2014 at 1:27 AM, Mike Hearn <mike at plan99.net> wrote:\n> Bear in mind a separate process doesn't buy you anything without a sandbox,\n> and those are expensive (in terms of complexity).\n>\n> On 21 Feb 2014 11:40, \"Jeff Garzik\" <jgarzik at bitpay.com> wrote:\n>>\n>> [Meta: \"Bitcoin Core\" is the newfangled branding of bitcoind /\n>> Bitcoin-Qt reference implementation, in case you wondering.]\n>>\n>> Several sites, including BitPay, use bitcoind outside the standard\n>> role of wallet software.  bitcoind can be used purely for payment\n>> network access and management.  I call this the \"border router\" role.\n>> Upcoming version 0.9 will feature the ability to disable the bitcoind\n>> wallet at compile time or runtime. This permits a more optimized\n>> border router profile, reducing process size by 40-200MB according to\n>> some reports.\n>>\n>> Recent IRC discussion have floated a rough proposal for a wallet\n>> next-step:  Running the Bitcoin Core wallet as a separate process, a\n>> separate binary, from the blockchain engine.  The wallet process would\n>> communicate with the blockchain engine using existing RPC and P2P\n>> channels, becoming a real SPV client.  This accomplishes a\n>> longstanding security goal of sandboxing away wallet keys and\n>> sensitive data from the network-exposed P2P engine, in a separate\n>> process, among other benefits.\n>>\n>> Simple forking was explored a bit.  I did some hacking in that\n>> direction, as it seemed potentially lightweight and somewhat easy to\n>> me: https://github.com/jgarzik/bitcoin/tree/fork  fork+pipe is fine\n>> for Linux and OSX/BSD.  However, Windows requires an exec-like\n>> solution to create a new process.  MSDN does give us a Unix-pipe-like\n>> solution:\n>> http://msdn.microsoft.com/en-us/library/edze9h7e%28v=vs.80%29.aspx\n>>  Others pointed to boost interprocess communication APIs, which come\n>> with their own set of caveats.  Such a solution would involve a brand\n>> new IPC protocol, and lots of brand new glue code.\n>>\n>> Separate programs seems better.  Windows forces us to achieve process\n>> separation via exec-like method.  We already have IPC: RPC + P2P.\n>> Modern OS's make localhost sockets just about as fast as other IPCs\n>> methods.  Linux, at least, employs zero-copy for localhost sockets in\n>> many situations, similar to the kernel's pipe tricks.\n>>\n>> Pieter has been working on headers-first sync:\n>> https://github.com/bitcoin/bitcoin/pull/2964  Moving along this\n>> wallet/blockchain engine split requires upping the review&test\n>> bandwidth on Pieter's PRs, such as\n>> https://github.com/bitcoin/bitcoin/pull/3514\n>>\n>> Unsure how much of the separate-binary discussion Gavin saw, so cc'd\n>> for emphasis.\n>>\n>> --\n>> Jeff Garzik\n>> Bitcoin core developer and open source evangelist\n>> BitPay, Inc.      https://bitpay.com/\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> Managing the Performance of Cloud-Based Applications\n>> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n>> Read the Whitepaper.\n>>\n>> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-02-21T10:41:06",
                "message_text_only": "I'm not sure it does really - typical C/C++ exploits let you run arbitrary\ncode, at which point you can quite easily ptrace the other process and do\nwhatever you want with it, or read /proc/pid/mem etc. But process\nseparation is certainly a prerequisite for sandboxing so I'm not arguing\nagainst such a change, just pointing out that it requires some work to\nreally get the benefits. Also an SPV Bitcoin Core would obviously be of\ntremendous utility all by itself ...\n\n\nOn Fri, Feb 21, 2014 at 12:20 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:\n\n> RE \"doesn't buy you anything\"   Today, when unlocked, plaintext\n> private keys reside in the same address space as the blockchain engine\n> (BCE).  Process separation increases the difficulty of accessing key\n> data from the BCE, even presuming a normal, no-chroot, same-uid,\n> parent-child process relationship.  The attack surface is clearly\n> changed from \"one buffer overflow can touch this data.\"\n>\n> Regardless, the split makes sense given existing modularity and coding\n> directions.  I wouldn't micro-focus on the \"sandbox\" word.\n>\n> On Fri, Feb 21, 2014 at 1:27 AM, Mike Hearn <mike at plan99.net> wrote:\n> > Bear in mind a separate process doesn't buy you anything without a\n> sandbox,\n> > and those are expensive (in terms of complexity).\n> >\n> > On 21 Feb 2014 11:40, \"Jeff Garzik\" <jgarzik at bitpay.com> wrote:\n> >>\n> >> [Meta: \"Bitcoin Core\" is the newfangled branding of bitcoind /\n> >> Bitcoin-Qt reference implementation, in case you wondering.]\n> >>\n> >> Several sites, including BitPay, use bitcoind outside the standard\n> >> role of wallet software.  bitcoind can be used purely for payment\n> >> network access and management.  I call this the \"border router\" role.\n> >> Upcoming version 0.9 will feature the ability to disable the bitcoind\n> >> wallet at compile time or runtime. This permits a more optimized\n> >> border router profile, reducing process size by 40-200MB according to\n> >> some reports.\n> >>\n> >> Recent IRC discussion have floated a rough proposal for a wallet\n> >> next-step:  Running the Bitcoin Core wallet as a separate process, a\n> >> separate binary, from the blockchain engine.  The wallet process would\n> >> communicate with the blockchain engine using existing RPC and P2P\n> >> channels, becoming a real SPV client.  This accomplishes a\n> >> longstanding security goal of sandboxing away wallet keys and\n> >> sensitive data from the network-exposed P2P engine, in a separate\n> >> process, among other benefits.\n> >>\n> >> Simple forking was explored a bit.  I did some hacking in that\n> >> direction, as it seemed potentially lightweight and somewhat easy to\n> >> me: https://github.com/jgarzik/bitcoin/tree/fork  fork+pipe is fine\n> >> for Linux and OSX/BSD.  However, Windows requires an exec-like\n> >> solution to create a new process.  MSDN does give us a Unix-pipe-like\n> >> solution:\n> >> http://msdn.microsoft.com/en-us/library/edze9h7e%28v=vs.80%29.aspx\n> >>  Others pointed to boost interprocess communication APIs, which come\n> >> with their own set of caveats.  Such a solution would involve a brand\n> >> new IPC protocol, and lots of brand new glue code.\n> >>\n> >> Separate programs seems better.  Windows forces us to achieve process\n> >> separation via exec-like method.  We already have IPC: RPC + P2P.\n> >> Modern OS's make localhost sockets just about as fast as other IPCs\n> >> methods.  Linux, at least, employs zero-copy for localhost sockets in\n> >> many situations, similar to the kernel's pipe tricks.\n> >>\n> >> Pieter has been working on headers-first sync:\n> >> https://github.com/bitcoin/bitcoin/pull/2964  Moving along this\n> >> wallet/blockchain engine split requires upping the review&test\n> >> bandwidth on Pieter's PRs, such as\n> >> https://github.com/bitcoin/bitcoin/pull/3514\n> >>\n> >> Unsure how much of the separate-binary discussion Gavin saw, so cc'd\n> >> for emphasis.\n> >>\n> >> --\n> >> Jeff Garzik\n> >> Bitcoin core developer and open source evangelist\n> >> BitPay, Inc.      https://bitpay.com/\n> >>\n> >>\n> >>\n> ------------------------------------------------------------------------------\n> >> Managing the Performance of Cloud-Based Applications\n> >> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> >> Read the Whitepaper.\n> >>\n> >>\n> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk\n> >> _______________________________________________\n> >> Bitcoin-development mailing list\n> >> Bitcoin-development at lists.sourceforge.net\n> >> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n> --\n> Jeff Garzik\n> Bitcoin core developer and open source evangelist\n> BitPay, Inc.      https://bitpay.com/\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/d754e4fd/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-21T11:06:02",
                "message_text_only": "On Fri, Feb 21, 2014 at 04:11:06PM +0530, Mike Hearn wrote:\n> On Fri, Feb 21, 2014 at 12:20 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:\n> \n> > RE \"doesn't buy you anything\"   Today, when unlocked, plaintext\n> > private keys reside in the same address space as the blockchain engine\n> > (BCE).  Process separation increases the difficulty of accessing key\n> > data from the BCE, even presuming a normal, no-chroot, same-uid,\n> > parent-child process relationship.  The attack surface is clearly\n> > changed from \"one buffer overflow can touch this data.\"\n> >\n> > Regardless, the split makes sense given existing modularity and coding\n> > directions.  I wouldn't micro-focus on the \"sandbox\" word.\n>\n> I'm not sure it does really - typical C/C++ exploits let you run arbitrary\n> code, at which point you can quite easily ptrace the other process and do\n> whatever you want with it, or read /proc/pid/mem etc. But process\n> separation is certainly a prerequisite for sandboxing so I'm not arguing\n> against such a change, just pointing out that it requires some work to\n> really get the benefits. Also an SPV Bitcoin Core would obviously be of\n> tremendous utility all by itself ...\n\nThe seccomp mechanism would work well here - it's a syscall whitelister,\nwhich makes ptrace useless, among other things. Used by Chrome as of v23\nto sandbox the renderers.\n\nWe'd probably need to use it with chroot and whitelist the open() call\nso that the existing code can create new blockfiles and do whatever\nleveldb does.\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000112c53364597954e79cc38f1ba7826a6420ad22a6f3be2932\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/28b1def7/attachment.sig>"
            },
            {
                "author": "Dustin D. Trammell",
                "date": "2014-02-22T01:04:12",
                "message_text_only": "On Fri, 2014-02-21 at 01:09 -0500, Jeff Garzik wrote:\n> Recent IRC discussion have floated a rough proposal for a wallet\n> next-step:  Running the Bitcoin Core wallet as a separate process, a\n> separate binary, from the blockchain engine.  The wallet process would\n> communicate with the blockchain engine using existing RPC and P2P\n> channels, becoming a real SPV client.  This accomplishes a\n> longstanding security goal of sandboxing away wallet keys and\n> sensitive data from the network-exposed P2P engine, in a separate\n> process, among other benefits.\n\nPLEASE.\n\nFor those of us that prefer the reference software and also manage\nmultiple wallets, having to store a copy of the blockchain for each one\neats up disk space quite quickly.  If I could run a local blockchain\nserver (or a local network one, even) and then have whichever wallet I\nstart up use that instead of maintain its own copy of the blockchain, my\nworld would be much, much happier.\n\nSandboxing keys and sensitive wallet data away from the attack surface\nintroduced by the network interfaces into another separate process is\nalso a good security move.  Don't forget to sanitize your IPC inputs (:\n\nThanks,\n\n-- \nDustin D. Trammell\ndtrammell at dustintrammell.com\nhttp://www.dustintrammell.com\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: This is a digitally signed message part\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/c850e81c/attachment.sig>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-02-22T02:08:19",
                "message_text_only": "On Fri, Feb 21, 2014 at 8:04 PM, Dustin D. Trammell\n<dtrammell at dustintrammell.com> wrote:\n> For those of us that prefer the reference software and also manage\n> multiple wallets, having to store a copy of the blockchain for each one\n> eats up disk space quite quickly.  If I could run a local blockchain\n> server (or a local network one, even) and then have whichever wallet I\n> start up use that instead of maintain its own copy of the blockchain, my\n> world would be much, much happier.\n\nYou mean running multiple wallets simultaneously?  Agreed.\n\nMultiple wallets, used serially, works fine today.  I manage multiple\nwallets using symlink replacement.\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core trial balloon: splitting blockchain engine and wallet",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Mike Hearn",
                "Dustin D. Trammell",
                "Peter Todd"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 18890
        }
    },
    {
        "title": "[Bitcoin-development] Fwd: Bitcoin Core trial balloon: splitting blockchain engine and wallet",
        "thread_messages": [
            {
                "author": "Wladimir",
                "date": "2014-02-21T06:43:36",
                "message_text_only": "On Fri, Feb 21, 2014 at 7:27 AM, Mike Hearn <mike at plan99.net> wrote:\n\n> Bear in mind a separate process doesn't buy you anything without a\n> sandbox, and those are expensive (in terms of complexity).\n>\nSandboxing in user space is complex, agreed,\n\nThe most straightforward way would be to run the blockchain daemon as a\nsystem service (with its own uid/gid and set of Apparmor/SELinux\nrestrictions) and the wallet daemon as the user.\n\nThis would also allow sharing one blockchain daemon between multiple users\nand wallet processes (not necessarily on the same machine), something I've\nwanted to be able to do for a long time.\n\nWladimir\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/b96c1925/attachment.html>"
            },
            {
                "author": "William Yager",
                "date": "2014-02-21T06:50:01",
                "message_text_only": "Running the network part of the core as a system service might make sense for server implementations, but it\u2019s a pain in the rear for most users. \n\nThat said, I think segregating the two processes is a great idea. Let\u2019s just try to avoid some complicated scheme that involves necessarily running things under multiple users.\n\nWill\n\nOn Feb 21, 2014, at 0:43, Wladimir <laanwj at gmail.com> wrote:\n\n> The most straightforward way would be to run the blockchain daemon as a system service (with its own uid/gid and set of Apparmor/SELinux restrictions) and the wallet daemon as the user.\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/65630db5/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 495 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/65630db5/attachment.sig>"
            },
            {
                "author": "Wladimir",
                "date": "2014-02-21T06:54:01",
                "message_text_only": "On Fri, Feb 21, 2014 at 7:50 AM, William Yager <will.yager at gmail.com> wrote:\n\n> Running the network part of the core as a system service might make sense\n> for server implementations, but it\u2019s a pain in the rear for most users.\n>\n\nCome on, making it a possibility doesn't affect other kinds of use cases in\nany way. Are you just arguing for the sake of arguing?\n\nWladimir\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/d393af47/attachment.html>"
            },
            {
                "author": "Dustin D. Trammell",
                "date": "2014-02-22T01:09:00",
                "message_text_only": "On Fri, 2014-02-21 at 07:43 +0100, Wladimir wrote:\n> The most straightforward way would be to run the blockchain daemon as\n> a system service (with its own uid/gid and set of Apparmor/SELinux\n> restrictions) and the wallet daemon as the user.\n\nThis assumes you as a user have the rights to do so.  This would be\npreferred, but in some cases may not be possible.  Perhaps it should be\noptional?\n\n> This would also allow sharing one blockchain daemon between multiple\n> users and wallet processes (not necessarily on the same machine),\n> something I've wanted to be able to do for a long time.\n\nAgreed (:\n\n-- \nDustin D. Trammell\ndtrammell at dustintrammell.com\nhttp://www.dustintrammell.com\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 198 bytes\nDesc: This is a digitally signed message part\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/9cc5f046/attachment.sig>"
            },
            {
                "author": "Wladimir",
                "date": "2014-02-22T06:53:33",
                "message_text_only": "On Sat, Feb 22, 2014 at 2:09 AM, Dustin D. Trammell <\ndtrammell at dustintrammell.com> wrote:\n\n> On Fri, 2014-02-21 at 07:43 +0100, Wladimir wrote:\n> > The most straightforward way would be to run the blockchain daemon as\n> > a system service (with its own uid/gid and set of Apparmor/SELinux\n> > restrictions) and the wallet daemon as the user.\n>\n> This assumes you as a user have the rights to do so.  This would be\n> preferred, but in some cases may not be possible.  Perhaps it should be\n> optional?\n>\n\nNo! I'm proposing that we force everyone to do it. Using all means\nnecessary. There should be regular audits that everyone is running the\nsoftware exactly in my configuration, and if not, a special task force will\ntake care that spankings are carried out on the spot.\n\nRepeated offenders will lose their BitLicense.\n</s>\n\nPlease stop kicking this dead horse. It was just a random idea. Maybe a way\nhow Linux distributions could structure it, but it may or may not apply in\nyour case. And that's fine, this is free software development, you can do\nwhatever you want!\n\nLet's try to bring this discussion back to its original intention: for\nanyone that wants to concretely help this along, please help reviewing and\ntesting the pull requests that jgarzik mentions.\n\nWladimir\nBTW: All of those patches are helpful for monolithic-bitcoind as well as\nthey (lay the groundwork for) speeding up block synchronization.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140222/b0c5a3ef/attachment.html>"
            },
            {
                "author": "James Hartig",
                "date": "2014-02-24T22:16:12",
                "message_text_only": "Setting aside all security benefits (which the user can obviously choose to\nimplement or ignore), a major benefit here is being able to have multiple\nwallets use the same blockchain process. I have 3 different bitcoind\nprocesses running on the same server to utilize multiple wallets. Using\nthem serially isn't an option in my case. Also, peers can run the cheaper\nprocess instead of having the wallet functionality which isn't even used.\n\nOn the security front, this doesn't seem to be any less secure and it gives\nthe user the flexibility to make it as secure as they feel comfortable. If\nthey want to run them both as the same user with no SELinux or file\nprotections (this isn't stopping or encouraging that) they're already doing\nthat now with bitcoind, albeit with possibly a larger attack surface.\n\nThanks,\n--\nJames Hartig\nSoftware Engineer @ Grooveshark.com\nhttp://twitter.com/jameshartig\n\n\n\n\n\nOn Sat, Feb 22, 2014 at 1:53 AM, Wladimir <laanwj at gmail.com> wrote:\n\n>\n> On Sat, Feb 22, 2014 at 2:09 AM, Dustin D. Trammell <\n> dtrammell at dustintrammell.com> wrote:\n>\n>> On Fri, 2014-02-21 at 07:43 +0100, Wladimir wrote:\n>> > The most straightforward way would be to run the blockchain daemon as\n>> > a system service (with its own uid/gid and set of Apparmor/SELinux\n>> > restrictions) and the wallet daemon as the user.\n>>\n>> This assumes you as a user have the rights to do so.  This would be\n>> preferred, but in some cases may not be possible.  Perhaps it should be\n>> optional?\n>>\n>\n> No! I'm proposing that we force everyone to do it. Using all means\n> necessary. There should be regular audits that everyone is running the\n> software exactly in my configuration, and if not, a special task force will\n> take care that spankings are carried out on the spot.\n>\n> Repeated offenders will lose their BitLicense.\n> </s>\n>\n> Please stop kicking this dead horse. It was just a random idea. Maybe a\n> way how Linux distributions could structure it, but it may or may not apply\n> in your case. And that's fine, this is free software development, you can\n> do whatever you want!\n>\n> Let's try to bring this discussion back to its original intention: for\n> anyone that wants to concretely help this along, please help reviewing and\n> testing the pull requests that jgarzik mentions.\n>\n> Wladimir\n> BTW: All of those patches are helpful for monolithic-bitcoind as well as\n> they (lay the groundwork for) speeding up block synchronization.\n>\n>\n>\n> ------------------------------------------------------------------------------\n> Managing the Performance of Cloud-Based Applications\n> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.\n> Read the Whitepaper.\n>\n> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140224/efb926ae/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Fwd: Bitcoin Core trial balloon: splitting blockchain engine and wallet",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "James Hartig",
                "William Yager",
                "Dustin D. Trammell",
                "Wladimir"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 8181
        }
    },
    {
        "title": "[Bitcoin-development] getpeerinfo results",
        "thread_messages": [
            {
                "author": "Ronald Hoffman",
                "date": "2014-02-22T02:56:10",
                "message_text_only": "I noticed that the 'services' field appears to be garbled in the latest\nsource code level from github.  Bitcoind is connected to my Java node\nserver at 127.0.0.1:8333.  I thought I was sending a bad 'version' message\nbut I get the correct results using 0.8.6.  So it appears that something\nchanged in 0.9.0.\n\nHere is bitcoin-cli talking to bitcoind (0.9.0)\n\n$ bitcoin-cli getpeerinfo\n[\n    {\n        \"addr\" : \"127.0.0.1:8333\",\n        \"services\" : \"0000000164x\",\n        \"lastsend\" : 1393036635,\n        \"lastrecv\" : 1393036635,\n        \"bytessent\" : 100169,\n        \"bytesrecv\" : 53633565,\n        \"conntime\" : 1393036133,\n        \"pingtime\" : 0.00000000,\n        \"version\" : 70002,\n        \"subver\" : \"/JavaBitcoin:1.0/\",\n        \"inbound\" : false,\n        \"startingheight\" : 287125,\n        \"banscore\" : 0,\n        \"syncnode\" : true\n    }\n]\n\nHere is the same bitcoin-cli talking to bidcoind (0.8.6)\n\n$ bitcoin-cli getpeerinfo\n[\n    {\n        \"addr\" : \"127.0.0.1:8333\",\n        \"services\" : \"00000001\",\n        \"lastsend\" : 1393037165,\n        \"lastrecv\" : 1393037165,\n        \"bytessent\" : 77494,\n        \"bytesrecv\" : 13054,\n        \"conntime\" : 1393037135,\n        \"version\" : 70002,\n        \"subver\" : \"/JavaBitcoin:1.0/\",\n        \"inbound\" : false,\n        \"startingheight\" : 287126,\n        \"banscore\" : 0,\n        \"syncnode\" : true\n    }\n]\n\nRon\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/1acd415c/attachment.html>"
            },
            {
                "author": "Wladimir",
                "date": "2014-02-22T08:08:43",
                "message_text_only": "On Sat, Feb 22, 2014 at 3:56 AM, Ronald Hoffman\n<ronald.hoffman6 at gmail.com>wrote:\n\n> I noticed that the 'services' field appears to be garbled in the latest\n> source code level from github.  Bitcoind is connected to my Java node\n> server at 127.0.0.1:8333.  I thought I was sending a bad 'version'\n> message but I get the correct results using 0.8.6.  So it appears that\n> something changed in 0.9.0.\n>\n\nThis warrants an issue on github:\nhttps://github.com/bitcoin/bitcoin/issues/new\n\n\n> Here is bitcoin-cli talking to bitcoind (0.9.0)\n>\n> $ bitcoin-cli getpeerinfo\n> [\n>     {\n>         \"addr\" : \"127.0.0.1:8333\",\n>         \"services\" : \"0000000164x\",\n>\n\nWhat git revision are you testing with? Built with what compiler on which\nplatform?\n\nDo all peers in getpeerinfo show up garbled, or just yours? Does it\nliterally show as \"164x\"?\n\nI just tried getpeerinfo locally and all my peers show as: \"\"services\" :\n\"00000001\" as expected.\n\nWladimir\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140222/87ec0606/attachment.html>"
            },
            {
                "author": "Wladimir",
                "date": "2014-02-22T08:54:14",
                "message_text_only": "On Sat, Feb 22, 2014 at 9:08 AM, Wladimir <laanwj at gmail.com> wrote:\n\n> On Sat, Feb 22, 2014 at 3:56 AM, Ronald Hoffman <ronald.hoffman6 at gmail.com\n> > wrote:\n>\n>> I noticed that the 'services' field appears to be garbled in the latest\n>> source code level from github.  Bitcoind is connected to my Java node\n>> server at 127.0.0.1:8333.  I thought I was sending a bad 'version'\n>> message but I get the correct results using 0.8.6.  So it appears that\n>> something changed in 0.9.0.\n>>\n>\n> This warrants an issue on github:\n> https://github.com/bitcoin/bitcoin/issues/new\n>\n\nI think I found (and fixed) the problem already. This is some windows\ninttypes.h bordercase. Can you test with this?:\n\nhttps://github.com/bitcoin/bitcoin/pull/3729\n\nWladimir\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140222/c9c37e5f/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "getpeerinfo results",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Ronald Hoffman",
                "Wladimir"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 3600
        }
    },
    {
        "title": "[Bitcoin-development] On OP_RETURN in upcoming 0.9 release",
        "thread_messages": [
            {
                "author": "Jeff Garzik",
                "date": "2014-02-24T16:03:04",
                "message_text_only": "An update in forthcoming 0.9 release includes a change to make\nOP_RETURN standard, permitted a small amount of metadata to be\nattached to a transaction:\nhttps://github.com/bitcoin/bitcoin/pull/2738\n\nThere was always going to be some level of controversy attached to\nthis.  However, some issues, perceptions and questions are bubbling\nup, and it seemed fair to cover them on the list, not just IRC.\n\n1) FAQ:  Why 80 bytes of data?  This is the leading programmer\nquestion, and it was not really documented well at all.  Simple\nanswer:  2x SHA256 or 1x SHA512, plus some tiny bit of metadata.  Some\nschemes are of the nature \"BOND<hash>\" rather than just plain hash.\nA common IRC proposal seems to lean towards reducing that from 80.\nI'll leave it to the crowd to argue about size from there. I do think\nregular transactions should have the ability to include some metadata.\n\n2) Endorsement of chain data storage.  Listening to bitcoin conference\ncorridor discussions, reading forum posts and the occasional article\nhave over-simplified the situation to \"core devs endorse data storage\nover blockchain!  let me start uploading my naughty movie collection!\nIM over blockchain, woo hoo!\"\n\nNothing could be further from the truth.  It's a way to make data\n/less damaging/, not an endorsement of data storage in chain as a good\nidea.  MasterCoin and other projects were doing -even worse- things,\nsuch as storing data in forever-unspendable TX outputs, bloating the\nUTXO for eternity.\n\nIt seems reasonable to have a release note to this effect in the 0.9\nrelease announcement, IMO.\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Pieter Wuille",
                "date": "2014-02-24T16:16:32",
                "message_text_only": "On Mon, Feb 24, 2014 at 5:03 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:\n\n> I do think\n> regular transactions should have the ability to include some metadata.\n\nand\n\n> 2) Endorsement of chain data storage.\n>\n> Nothing could be further from the truth.\n\nThese two statements are in direct contradiction with each other.\n\n-- \nPieter"
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-02-24T16:32:52",
                "message_text_only": "Not really -- a MasterCoin transaction or JPEG\n\nOn Mon, Feb 24, 2014 at 11:16 AM, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n> On Mon, Feb 24, 2014 at 5:03 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:\n>\n>> I do think\n>> regular transactions should have the ability to include some metadata.\n>\n> and\n>\n>> 2) Endorsement of chain data storage.\n>>\n>> Nothing could be further from the truth.\n>\n> These two statements are in direct contradiction with each other.\n>\n> --\n> Pieter\n\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-02-24T16:33:27",
                "message_text_only": "(fscking 'send' hotkey in GMail)\n\nNot really - a MasterCoin or JPEG image transaction is not a \"regular\"\ntransaction.\n\nOn Mon, Feb 24, 2014 at 11:16 AM, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n> On Mon, Feb 24, 2014 at 5:03 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:\n>\n>> I do think\n>> regular transactions should have the ability to include some metadata.\n>\n> and\n>\n>> 2) Endorsement of chain data storage.\n>>\n>> Nothing could be further from the truth.\n>\n> These two statements are in direct contradiction with each other.\n>\n> --\n> Pieter\n\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Wladimir",
                "date": "2014-02-24T16:39:37",
                "message_text_only": "On Mon, Feb 24, 2014 at 5:03 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:\n\n> A common IRC proposal seems to lean towards reducing that from 80.\n> I'll leave it to the crowd to argue about size from there. I do think\n> regular transactions should have the ability to include some metadata.\n>\n\nI'd be in favor of bringing it down to 40 for 0.9.\n\nThat'd be enough for <8 byte header/identifier><32 byte hash>.\n\n80, as the standard line length, is almost asking for \"insert your graffiti\nmessage here\". I also see no need for 64 bytes hashes such as SHA512 in the\ncontext of bitcoin, as that only offers 256-bit security (at most) in the\nfirst place.\n\nAnd if this is not abused, these kind of transactions become popular, and\nmore space is really needed, the limit can always be increased in a future\nversion.\n\nWladimir\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140224/4ca2e66e/attachment.html>"
            },
            {
                "author": "Gavin Andresen",
                "date": "2014-02-24T16:45:16",
                "message_text_only": "40 bytes is small enough to never require an OP_PUSHDATA1, too, which will\nmake writing the OP_RETURN-as-standard BIP simpler.\n\n\nOn Mon, Feb 24, 2014 at 11:39 AM, Wladimir <laanwj at gmail.com> wrote:\n\n>\n> On Mon, Feb 24, 2014 at 5:03 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:\n>\n>> A common IRC proposal seems to lean towards reducing that from 80.\n>> I'll leave it to the crowd to argue about size from there. I do think\n>> regular transactions should have the ability to include some metadata.\n>>\n>\n> I'd be in favor of bringing it down to 40 for 0.9.\n>\n> That'd be enough for <8 byte header/identifier><32 byte hash>.\n>\n> 80, as the standard line length, is almost asking for \"insert your\n> graffiti message here\". I also see no need for 64 bytes hashes such as\n> SHA512 in the context of bitcoin, as that only offers 256-bit security (at\n> most) in the first place.\n>\n> And if this is not abused, these kind of transactions become popular, and\n> more space is really needed, the limit can always be increased in a future\n> version.\n>\n> Wladimir\n>\n\n\n\n-- \n--\nGavin Andresen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140224/9c038dc0/attachment.html>"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2014-02-24T16:50:09",
                "message_text_only": "On 02/24/2014 05:45 PM, Gavin Andresen wrote:\n> 40 bytes is small enough to never require an OP_PUSHDATA1, too\n\nSo are 75 bytes. (I'm not trying to push anything. Just saying ...)\n\n-- \nBest Regards / S pozdravom,\n\nPavol Rusnak <stick at gk2.sk>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2014-02-24T17:23:12",
                "message_text_only": "Given our standardization on 128-bit security / 256-bit primitives, I\ncan't think of any crypto related data payload which requires more than\n40 bytes. Even DER encoded compressed public keys will fit in there. A\nsignature won't fit, but why would you need one in there?\n\nThere's no need to design for 64-byte hashes, and the 80-char line\nlength comparison is a good point. As an Engineer I'd want to have a\nlittle more room as a 32-byte hash or EC point + 8 bytes identifying\nprefix data is the bare minimum, but it is also very important that we\nsend a message: This is for payment related applications like stealth\naddresses only. Don't burden everybody by putting your junk on the block\nchain.\n\nOn 02/24/2014 08:39 AM, Wladimir wrote:\n> \n> On Mon, Feb 24, 2014 at 5:03 PM, Jeff Garzik <jgarzik at bitpay.com\n> <mailto:jgarzik at bitpay.com>> wrote:\n> \n>     A common IRC proposal seems to lean towards reducing that from 80.\n>     I'll leave it to the crowd to argue about size from there. I do think\n>     regular transactions should have the ability to include some metadata.\n> \n> \n> I'd be in favor of bringing it down to 40 for 0.9.\n> \n> That'd be enough for <8 byte header/identifier><32 byte hash>.\n> \n> 80, as the standard line length, is almost asking for \"insert your\n> graffiti message here\". I also see no need for 64 bytes hashes such as\n> SHA512 in the context of bitcoin, as that only offers 256-bit security\n> (at most) in the first place.\n> \n> And if this is not abused, these kind of transactions become popular,\n> and more space is really needed, the limit can always be increased in a\n> future version.\n> \n> Wladimir\n> \n> \n> ------------------------------------------------------------------------------\n> Flow-based real-time traffic analytics software. Cisco certified tool.\n> Monitor traffic, SLAs, QoS, Medianet, WAAS etc. with NetFlow Analyzer\n> Customize your own dashboards, set traffic alerts and generate reports.\n> Network behavioral analysis & security monitoring. All-in-one tool.\n> http://pubads.g.doubleclick.net/gampad/clk?id=126839071&iu=/4140/ostg.clktrk\n> \n> \n> \n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Andreas Petersson",
                "date": "2014-02-24T23:06:30",
                "message_text_only": "Regarding 80 bytes vs smaller: The objectives should be that if you are\ndetermined to put some extra data in the blockchain, OP_RETURN should be\nthe superior alternative. if a user can include more data with less fees\nusing a multisig TX, then this will happen.\n\neventually dust-limit rules will not be the deciding factor here, since\ni suspect block propagation times will have a stronger effect on\neffective fees. therefore a slightly larger payload than the biggest\nmultisig TX is the right answer. - that would be >= 64x3 bytes = 192 bytes.\n(this is my understanding of how large a 3-of-3 multisig tx can be, plus\n1.5 bits encoded in the \"n\" parameter)"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-02-24T23:13:28",
                "message_text_only": "On Mon, Feb 24, 2014 at 3:06 PM, Andreas Petersson <andreas at petersson.at> wrote:\n> Regarding 80 bytes vs smaller: The objectives should be that if you are\n> determined to put some extra data in the blockchain, OP_RETURN should be\n> the superior alternative. if a user can include more data with less fees\n> using a multisig TX, then this will happen.\n>\n> eventually dust-limit rules will not be the deciding factor here, since\n> i suspect block propagation times will have a stronger effect on\n> effective fees. therefore a slightly larger payload than the biggest\n> multisig TX is the right answer. - that would be >= 64x3 bytes = 192 bytes.\n> (this is my understanding of how large a 3-of-3 multisig tx can be, plus\n> 1.5 bits encoded in the \"n\" parameter)\n\nAt least there is no ambiguity that such usage is abusive. Adoption of\nthe practices matters too. Right now I've seen a lot of people\npromoting data storage as a virtuous use, and gearing up to directly\nstore data when a commitment would work.\n\nIf it turns out that encouraging people to use hashes is a lost cause\nit can always be further relaxed in the future, going the other way is\nmuch harder."
            },
            {
                "author": "Luke-Jr",
                "date": "2014-02-24T23:13:38",
                "message_text_only": "On Monday, February 24, 2014 11:06:30 PM Andreas Petersson wrote:\n> Regarding 80 bytes vs smaller: The objectives should be that if you are\n> determined to put some extra data in the blockchain, OP_RETURN should be\n> the superior alternative. if a user can include more data with less fees\n> using a multisig TX, then this will happen.\n> \n> eventually dust-limit rules will not be the deciding factor here, since\n> i suspect block propagation times will have a stronger effect on\n> effective fees. therefore a slightly larger payload than the biggest\n> multisig TX is the right answer. - that would be >= 64x3 bytes = 192 bytes.\n> (this is my understanding of how large a 3-of-3 multisig tx can be, plus\n> 1.5 bits encoded in the \"n\" parameter)\n\nPerhaps I ought to redo my data carrier configuration option as a max size?\n\nLuke"
            },
            {
                "author": "Troy Benjegerdes",
                "date": "2014-02-28T05:25:23",
                "message_text_only": "To each his own, but if I say \"Please don't charge me for YOUR privacy\nby putting junk like stealth addresses in the blockchain\", I think I'd\nget laughed out of most rooms.\n\nEither the transaction fees are sufficient to pay the cost for whatever\nrandom junk anyone wants to put there, or they are not, and if they are\nnot, then I suggest you re-think the fee structure rather than trying\nto pre-regulate me putting 80 character pithy quotes in the blockhain.\n\n\nOn Mon, Feb 24, 2014 at 09:23:12AM -0800, Mark Friedenbach wrote:\n> Given our standardization on 128-bit security / 256-bit primitives, I\n> can't think of any crypto related data payload which requires more than\n> 40 bytes. Even DER encoded compressed public keys will fit in there. A\n> signature won't fit, but why would you need one in there?\n> \n> There's no need to design for 64-byte hashes, and the 80-char line\n> length comparison is a good point. As an Engineer I'd want to have a\n> little more room as a 32-byte hash or EC point + 8 bytes identifying\n> prefix data is the bare minimum, but it is also very important that we\n> send a message: This is for payment related applications like stealth\n> addresses only. Don't burden everybody by putting your junk on the block\n> chain.\n> \n> On 02/24/2014 08:39 AM, Wladimir wrote:\n> > \n> > On Mon, Feb 24, 2014 at 5:03 PM, Jeff Garzik <jgarzik at bitpay.com\n> > <mailto:jgarzik at bitpay.com>> wrote:\n> > \n> >     A common IRC proposal seems to lean towards reducing that from 80.\n> >     I'll leave it to the crowd to argue about size from there. I do think\n> >     regular transactions should have the ability to include some metadata.\n> > \n> > \n> > I'd be in favor of bringing it down to 40 for 0.9.\n> > \n> > That'd be enough for <8 byte header/identifier><32 byte hash>.\n> > \n> > 80, as the standard line length, is almost asking for \"insert your\n> > graffiti message here\". I also see no need for 64 bytes hashes such as\n> > SHA512 in the context of bitcoin, as that only offers 256-bit security\n> > (at most) in the first place.\n> > \n> > And if this is not abused, these kind of transactions become popular,\n> > and more space is really needed, the limit can always be increased in a\n> > future version.\n> > \n> > Wladimir\n> > \n> > \n> > ------------------------------------------------------------------------------\n> > Flow-based real-time traffic analytics software. Cisco certified tool.\n> > Monitor traffic, SLAs, QoS, Medianet, WAAS etc. with NetFlow Analyzer\n> > Customize your own dashboards, set traffic alerts and generate reports.\n> > Network behavioral analysis & security monitoring. All-in-one tool.\n> > http://pubads.g.doubleclick.net/gampad/clk?id=126839071&iu=/4140/ostg.clktrk\n> > \n> > \n> > \n> > _______________________________________________\n> > Bitcoin-development mailing list\n> > Bitcoin-development at lists.sourceforge.net\n> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> > \n> \n> ------------------------------------------------------------------------------\n> Flow-based real-time traffic analytics software. Cisco certified tool.\n> Monitor traffic, SLAs, QoS, Medianet, WAAS etc. with NetFlow Analyzer\n> Customize your own dashboards, set traffic alerts and generate reports.\n> Network behavioral analysis & security monitoring. All-in-one tool.\n> http://pubads.g.doubleclick.net/gampad/clk?id=126839071&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n-- \n----------------------------------------------------------------------------\nTroy Benjegerdes                 'da hozer'                  hozer at hozed.org\n7 elements      earth::water::air::fire::mind::spirit::soul        grid.coop\n\n      Never pick a fight with someone who buys ink by the barrel,\n         nor try buy a hacker who makes money by the megahash"
            },
            {
                "author": "Warren Togami Jr.",
                "date": "2014-02-28T14:42:14",
                "message_text_only": "On Thu, Feb 27, 2014 at 7:25 PM, Troy Benjegerdes <hozer at hozed.org> wrote:\n\n>\n> Either the transaction fees are sufficient to pay the cost for whatever\n> random junk anyone wants to put there, or they are not, and if they are\n> not, then I suggest you re-think the fee structure rather than trying\n> to pre-regulate me putting 80 character pithy quotes in the blockhain.\n>\n>\nhttps://github.com/litecoin-project/litecoin/commit/db4d8e21d99551bef4c807aa1534a074e4b7964d\n\nIn one way in particular, the transaction fees per kilobyte completely\nfailed to account for the actual cost to the network.  If Bitcoin had\nadopted a common-sense rule like this, I would have had no reason to join\nLitecoin development last year.  This is one of the few economic design\nflaws that Satoshi overlooked in the original design.\n\nAs much as I personally hate the idea of data storage in the blockchain,\nthis at least discourages the creation of permanent UTXO.\n\nWarren Togami\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140228/9c9281f9/attachment.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2014-02-28T19:25:27",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nTransaction fees are a DoS mitigating cost to the person making the\ntransaction, but they are generally not paid to the people who\nactually incur costs in validating the blockchain. Actual transaction\nprocessing costs are an externality that is completely unpaid for.\n\nWhen I add a 1Kb transaction to the blockchain, there is an attached\nfee which probabilistically goes to one of the miners. But every other\nfull node on the network also receives this transaction, processes it,\nand adds it to local storage. From now until the heat death of the\nuniverse that 1Kb of data will be redundantly stored and transmitted\nto every single person who validates the block chain. None of these\ncountless people are reimbursed for their storage, bandwidth, and\nprocessing costs. Not even a single satoshi.\n\nYes, transaction fees are broken. But it is their very nature which is\nbroken (sending coins to the miners, not the greater validator set),\nand no little tweak like the one Warren links to will fix this.\n\nBut, in the absence of a reformed fee regime - which it is not clear\nis even possible - one could at least make the hand-wavey argument\nthat people who validate the block chain receive benefit from it as a\npayment network. Therefore processing of the block chain is \"paid for\"\nby the utility it provides once fully synced.\n\nHowever even this weak argument does not extend to general data\nstorage. If you want to put all of wikileaks or whatever in the block\nchain, then you are extracting a rent from every full node which is\nforced to process and store this data for eternity without\ncompensation or derived utility. You are extorting users of the\npayment network into providing a storage service at no cost, because\nthe alternative (losing bitcoin as a payment network) would cost them\nmore.\n\nThat is not ethical behavior. That is not behavior which responsible\ndevelopers should allow in the reference client.\n\nMark\n\nOn 02/28/2014 06:42 AM, Warren Togami Jr. wrote:\n> On Thu, Feb 27, 2014 at 7:25 PM, Troy Benjegerdes <hozer at hozed.org \n> <mailto:hozer at hozed.org>> wrote:\n> \n> \n> Either the transaction fees are sufficient to pay the cost for\n> whatever random junk anyone wants to put there, or they are not,\n> and if they are not, then I suggest you re-think the fee structure\n> rather than trying to pre-regulate me putting 80 character pithy\n> quotes in the blockhain.\n> \n> \n> https://github.com/litecoin-project/litecoin/commit/db4d8e21d99551bef4c807aa1534a074e4b7964d\n>\n>  In one way in particular, the transaction fees per kilobyte\n> completely failed to account for the actual cost to the network.\n> If Bitcoin had adopted a common-sense rule like this, I would have\n> had no reason to join Litecoin development last year.  This is one\n> of the few economic design flaws that Satoshi overlooked in the\n> original design.\n> \n> As much as I personally hate the idea of data storage in the\n> blockchain, this at least discourages the creation of permanent\n> UTXO.\n> \n> Warren Togami\n> \n> \n> ------------------------------------------------------------------------------\n>\n> \nFlow-based real-time traffic analytics software. Cisco certified tool.\n> Monitor traffic, SLAs, QoS, Medianet, WAAS etc. with NetFlow\n> Analyzer Customize your own dashboards, set traffic alerts and\n> generate reports. Network behavioral analysis & security\n> monitoring. All-in-one tool. \n> http://pubads.g.doubleclick.net/gampad/clk?id=126839071&iu=/4140/ostg.clktrk\n>\n> \n> \n> \n> _______________________________________________ Bitcoin-development\n> mailing list Bitcoin-development at lists.sourceforge.net \n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> \n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.14 (GNU/Linux)\nComment: GPGTools - http://gpgtools.org\nComment: Using GnuPG with Thunderbird - http://www.enigmail.net/\n\niQIcBAEBAgAGBQJTEOKjAAoJEAdzVfsmodw4vGIQAJ9OQvHl1+dIaDelrf03lGIf\nkQsiuB4JG1rRghsZZiW4NixPbB/Bdm4+m4pep01eiVOPXa+/32AgWVzSYyyMVRYB\noTu24ITgtCu5vkjiHyzSavFnqsi+zMxVpscUekA6l6Tkr3RBNnrIssMiazYc+Bkx\nfP2vZehmPHQtp09WkapZ3DMqbMzQ7qPTGlKd1V+9X4S5uUNTdfT6JkC0HIqUSdVQ\nPHjjbuulgkdz4b7A6C2dE5kwXVKF9YFHL3zEtObfWDCiyY8wf2XHYI6nVGLbyQeN\nnrYCsMH99lUy+zmnbccqSPKhe0p5IaBLauk75zcLxEfzxuKVTvVg2LCaCXQaworv\nvBoAURdrB2pCfK8dZ7mllVLLLcNk+iOG0NDZHYE9e884OBfeuaG/zNgmgOD8GC1H\nFaDkIpm79x/i3ti3h8vdZPeY0fWdI8yuD9aCQZtvONM9hXdd7Qb07eHqIk7tY/In\n7h6zdq27GQUdWN37yslxtDENY2q3yQ39+fjMGQEKVIE6rNwDyjurMCNHAWJp0hZO\n7S/rDe2W2tHGPYakscHQh1g/uMAEEb4mGGc5yrfWxyOn5eb9OZiZb8RVXlnDwwH9\nqr8qwLJ1b0Uxo981lyEmnLZSpCpAZvDLpjmocqirycNZpvyPnJJbE809vS/koD3d\nOutJkMja4TBuqaMSdKEI\n=KbW/\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Justus Ranvier",
                "date": "2014-02-28T19:36:31",
                "message_text_only": "On 02/28/2014 07:25 PM, Mark Friedenbach wrote:\n> Transaction fees are a DoS mitigating cost to the person making the\n> transaction, but they are generally not paid to the people who\n> actually incur costs in validating the blockchain. Actual transaction\n> processing costs are an externality that is completely unpaid for.\n\nWhat that means is the network layer is broken and needs to be fixed.\n\nBitcoin is the blockchain, not the P2P network. If the existing network\nis not incentive compatible, then that's the root cause which should be\naddressed.\n\nThere's no reason to enshrine the broken behavior and use it as a\nroadblock to stop progress.\n\n\n-- \nSupport online privacy by using email encryption whenever possible.\nLearn how here: http://www.youtube.com/watch?v=bakOKJFtB-k\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0x1B438BF4.asc\nType: application/pgp-keys\nSize: 21191 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140228/28259854/attachment.bin>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 555 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140228/28259854/attachment.sig>"
            },
            {
                "author": "Drak",
                "date": "2014-02-28T20:10:32",
                "message_text_only": "On 28 February 2014 14:42, Warren Togami Jr. <wtogami at gmail.com> wrote:\n\n>\n> https://github.com/litecoin-project/litecoin/commit/db4d8e21d99551bef4c807aa1534a074e4b7964d\n>\n> In one way in particular, the transaction fees per kilobyte completely\n> failed to account for the actual cost to the network.  If Bitcoin had\n> adopted a common-sense rule like this, I would have had no reason to join\n> Litecoin development last year.  This is one of the few economic design\n> flaws that Satoshi overlooked in the original design.\n>\n\nIs there any particular reason that patch would not make it into bitcoin if\nsubmitted?\n\nDrak\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140228/c3739720/attachment.html>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-02-24T17:10:26",
                "message_text_only": "This PR reduces the size to 40 bytes:\nhttps://github.com/bitcoin/bitcoin/pull/3737\n\n(Note - this is not intended to close the discussion... please do keep\nsending in feedback)\n\nOn Mon, Feb 24, 2014 at 11:03 AM, Jeff Garzik <jgarzik at bitpay.com> wrote:\n> An update in forthcoming 0.9 release includes a change to make\n> OP_RETURN standard, permitted a small amount of metadata to be\n> attached to a transaction:\n> https://github.com/bitcoin/bitcoin/pull/2738\n>\n> There was always going to be some level of controversy attached to\n> this.  However, some issues, perceptions and questions are bubbling\n> up, and it seemed fair to cover them on the list, not just IRC.\n>\n> 1) FAQ:  Why 80 bytes of data?  This is the leading programmer\n> question, and it was not really documented well at all.  Simple\n> answer:  2x SHA256 or 1x SHA512, plus some tiny bit of metadata.  Some\n> schemes are of the nature \"BOND<hash>\" rather than just plain hash.\n> A common IRC proposal seems to lean towards reducing that from 80.\n> I'll leave it to the crowd to argue about size from there. I do think\n> regular transactions should have the ability to include some metadata.\n>\n> 2) Endorsement of chain data storage.  Listening to bitcoin conference\n> corridor discussions, reading forum posts and the occasional article\n> have over-simplified the situation to \"core devs endorse data storage\n> over blockchain!  let me start uploading my naughty movie collection!\n> IM over blockchain, woo hoo!\"\n>\n> Nothing could be further from the truth.  It's a way to make data\n> /less damaging/, not an endorsement of data storage in chain as a good\n> idea.  MasterCoin and other projects were doing -even worse- things,\n> such as storing data in forever-unspendable TX outputs, bloating the\n> UTXO for eternity.\n>\n> It seems reasonable to have a release note to this effect in the 0.9\n> release announcement, IMO.\n>\n> --\n> Jeff Garzik\n> Bitcoin core developer and open source evangelist\n> BitPay, Inc.      https://bitpay.com/\n\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Jeremy Spilman",
                "date": "2014-02-24T22:12:10",
                "message_text_only": "On Mon, 24 Feb 2014 09:10:26 -0800, Jeff Garzik <jgarzik at bitpay.com> wrote:\n> This PR reduces the size to 40 bytes:\n> https://github.com/bitcoin/bitcoin/pull/3737\n\nJust quickly GLANCED at it, but if I understand correctly how the template  \nmatching code works, that will change max size of the <data> to 40 bytes  \nbut does not do anything to enforce most-efficient encoding.\n\n   else if (opcode2 == OP_SMALLDATA)\n   {\n       // small pushdata, <= MAX_OP_RETURN_RELAY bytes\n       if (vch1.size() > MAX_OP_RETURN_RELAY)\n          break;\n   }\n\nThis code was a bit hard for me to parse since it's not actually requiring  \nany data, just disallowing more than a certain number of bytes of data. So  \na bare OP_RETURN would be allowed as well, for whatever good that will do.\n\nIf you want to strictly require no PUSHDATA, perhaps you could do:\n\n   else if (opcode2 == OP_SMALLDATA)\n   {\n       // small pushdata, <= MAX_OP_RETURN_RELAY bytes\n       if (opcode1 >= OP_PUSHDATA1 || vch1.size() > MAX_OP_RETURN_RELAY)\n          break;\n   }\n\nThanks,\nJeremy"
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-02-24T22:50:50",
                "message_text_only": "Sure, no objection to that.\n\n\nOn Mon, Feb 24, 2014 at 5:12 PM, Jeremy Spilman <jeremy at taplink.co> wrote:\n> On Mon, 24 Feb 2014 09:10:26 -0800, Jeff Garzik <jgarzik at bitpay.com> wrote:\n>>\n>> This PR reduces the size to 40 bytes:\n>> https://github.com/bitcoin/bitcoin/pull/3737\n>\n>\n> Just quickly GLANCED at it, but if I understand correctly how the template\n> matching code works, that will change max size of the <data> to 40 bytes but\n> does not do anything to enforce most-efficient encoding.\n>\n>   else if (opcode2 == OP_SMALLDATA)\n>   {\n>       // small pushdata, <= MAX_OP_RETURN_RELAY bytes\n>       if (vch1.size() > MAX_OP_RETURN_RELAY)\n>          break;\n>   }\n>\n> This code was a bit hard for me to parse since it's not actually requiring\n> any data, just disallowing more than a certain number of bytes of data. So a\n> bare OP_RETURN would be allowed as well, for whatever good that will do.\n>\n> If you want to strictly require no PUSHDATA, perhaps you could do:\n>\n>   else if (opcode2 == OP_SMALLDATA)\n>   {\n>       // small pushdata, <= MAX_OP_RETURN_RELAY bytes\n>       if (opcode1 >= OP_PUSHDATA1 || vch1.size() > MAX_OP_RETURN_RELAY)\n>          break;\n>   }\n>\n> Thanks,\n> Jeremy\n>\n\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            }
        ],
        "thread_summary": {
            "title": "On OP_RETURN in upcoming 0.9 release",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Luke-Jr",
                "Troy Benjegerdes",
                "Wladimir",
                "Andreas Petersson",
                "Warren Togami Jr.",
                "Pavol Rusnak",
                "Jeremy Spilman",
                "Gregory Maxwell",
                "Gavin Andresen",
                "Mark Friedenbach",
                "Pieter Wuille",
                "Drak",
                "Justus Ranvier"
            ],
            "messages_count": 19,
            "total_messages_chars_count": 27076
        }
    },
    {
        "title": "[Bitcoin-development] On OP_RETURN in upcoming 0.9",
        "thread_messages": [
            {
                "author": "Tamas Blummer",
                "date": "2014-02-24T18:13:29",
                "message_text_only": "It costs at least 5430 satoshis to create an output at the moment. \nIs the same spam limit applied if the script is OP_RETURN?\nIf not, I would be concerned od opening a cheap spam.\n\nTamas Blummer\n\nOn Mon, Feb 24, 2014 at 11:39 AM, Wladimir <laanwj at gmail.com> wrote:\n\n> \n> And if this is not abused, these kind of transactions become popular, and\n> more space is really needed, the limit can always be increased in a future\n> version.\n> \n> Wladimir\n> \n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140224/926df719/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 495 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140224/926df719/attachment.sig>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2014-02-24T22:35:57",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nOP_RETURN outputs are provably unspendable *and* not included in the\nUTXO set, so they're not dust (the client makes this check and handles\nTX_NULL_DATA outputs separately).\n\nOn 02/24/2014 10:13 AM, Tamas Blummer wrote:\n> It costs at least 5430 satoshis to create an output at the moment.\n>  Is the same spam limit applied if the script is OP_RETURN? If not,\n> I would be concerned od opening a cheap spam.\n> \n> Tamas Blummer\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.14 (GNU/Linux)\nComment: GPGTools - http://gpgtools.org\nComment: Using GnuPG with Thunderbird - http://www.enigmail.net/\n\niQIcBAEBAgAGBQJTC8lNAAoJEAdzVfsmodw4vpAP/1/wJFRq9x3rhETtUlS/3+F3\nUrgBhfNDP7rq1P9wqZm20cssF0VcG+SVG94m/kH/H8cfJsjGB3/NW2IGxf9J6wOT\nvWiGqz4b7lkh5nywBe0TK0smkqMFtyNAESX1WdJpdNLAd5OK/wj2X7Dl3/r7K9tk\nSN1Oi4nlQD+GkbQBNeqf659BKlFAIYONl9SrPXvrEoSuTm0CjFLsST3Go3El0tyx\nrLrApXCAR+iGs9bZONdkC3rRWGGa3V8HLNeCyBaLA7dsipnk2kMsjbrLB9NZU54L\nDz07e1oelFJErsbYKD+AQy3KiZ4+7dZRoi9FtPqlXtCGAObW0fi5Rm2HDzCG+iMU\nf+6xgCCyyP++fET/EnJj1Jxjrn6suoAl2hjZLpaGgJ67lsxq5rqmXetID5X+cGRU\nHX6Ar5+LIjRixfoCF3dJoZT0Ko1S0b58oRzyapwbB+2Fi0/G7ujEwErWE33ARXad\nvTYznlAXG5YzIrjAJUF3PG3MlbaX4TWywJxRCMRcTQC7Ak+dP2cdOBuzvLdAsYXG\nxcmqfl3ETH5xLxLWYnzNplTkt9ENs8UHrG0StWOyCg4+MG8yC/jPFp6qzRlAaZEv\nvFsIPGD+jzftrqBQ1GgjbG8bofUYCMnYRKQtQ377GNw8s8wVASb8CxyI8yhXKpdv\nzdCwIlvHM0A8CofmDDot\n=6Jux\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "On OP_RETURN in upcoming 0.9",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Tamas Blummer",
                "Mark Friedenbach"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2351
        }
    },
    {
        "title": "[Bitcoin-development] Fee drop",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2014-02-25T04:41:16",
                "message_text_only": "So, just to be clear, we're adding, say, a memory limited mempool or\nsomething prior to release so this fee drop doesn't open up an obvious\nlow-risk DDoS exploit.... right? As we all know, the network bandwidth\nDoS attack mitigation strategy relies on transactions we accept to\nmempools getting mined, and the clearance rate of the new low-fee\ntransactions is going to be pretty small; we've already had problems in\nthe past with mempool growth in periods of high demand. Equally it\nshould be obvious to people how you can create large groups of low-fee\ntransactions, and then cheaply double-spend them with higher fee\ntransactions to suck up network bandwidth - just like I raised for the\nequally foolish double-spend propagation pull-req.\n\nOf course, there's also the problem that we're basically lying to people\nabout whether or not Bitcoin is a good medium for microtransactions.\nIt's not. Saying otherwise by releasing software that has known and\nobvious DoS attack vulnerabilities that didn't exist in the previous\nversion is irresponsible on multiple levels.\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000000b28e2818c4d8019fb71e33ec2d223f5e09394a89caccf4e2\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140224/83183399/attachment.sig>"
            },
            {
                "author": "naman naman",
                "date": "2014-02-25T07:34:41",
                "message_text_only": "I quite agree with Peter, anything that can be exploited will be exploited,\njust like malleability was.\n\n\nOn Tue, Feb 25, 2014 at 10:11 AM, Peter Todd <pete at petertodd.org> wrote:\n\n> So, just to be clear, we're adding, say, a memory limited mempool or\n> something prior to release so this fee drop doesn't open up an obvious\n> low-risk DDoS exploit.... right? As we all know, the network bandwidth\n> DoS attack mitigation strategy relies on transactions we accept to\n> mempools getting mined, and the clearance rate of the new low-fee\n> transactions is going to be pretty small; we've already had problems in\n> the past with mempool growth in periods of high demand. Equally it\n> should be obvious to people how you can create large groups of low-fee\n> transactions, and then cheaply double-spend them with higher fee\n> transactions to suck up network bandwidth - just like I raised for the\n> equally foolish double-spend propagation pull-req.\n>\n> Of course, there's also the problem that we're basically lying to people\n> about whether or not Bitcoin is a good medium for microtransactions.\n> It's not. Saying otherwise by releasing software that has known and\n> obvious DoS attack vulnerabilities that didn't exist in the previous\n> version is irresponsible on multiple levels.\n>\n> --\n> 'peter'[:-1]@petertodd.org\n> 0000000000000000b28e2818c4d8019fb71e33ec2d223f5e09394a89caccf4e2\n>\n>\n> ------------------------------------------------------------------------------\n> Flow-based real-time traffic analytics software. Cisco certified tool.\n> Monitor traffic, SLAs, QoS, Medianet, WAAS etc. with NetFlow Analyzer\n> Customize your own dashboards, set traffic alerts and generate reports.\n> Network behavioral analysis & security monitoring. All-in-one tool.\n>\n> http://pubads.g.doubleclick.net/gampad/clk?id=126839071&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140225/e62944d2/attachment.html>"
            },
            {
                "author": "Odinn Cyberguerrilla",
                "date": "2014-02-25T12:40:03",
                "message_text_only": "> So, just to be clear, we're adding, say, a memory limited mempool or\n> something prior to release so this fee drop doesn't open up an obvious\n> low-risk DDoS exploit.... right? As we all know, the network bandwidth\n> DoS attack mitigation strategy relies on transactions we accept to\n> mempools getting mined, and the clearance rate of the new low-fee\n> transactions is going to be pretty small; we've already had problems in\n> the past with mempool growth in periods of high demand. Equally it\n> should be obvious to people how you can create large groups of low-fee\n> transactions, and then cheaply double-spend them with higher fee\n> transactions to suck up network bandwidth - just like I raised for the\n> equally foolish double-spend propagation pull-req.\n\nIt's good that the core devs keep doing good work on these topics, thanks.\n\n>\n> Of course, there's also the problem that we're basically lying to people\n> about whether or not Bitcoin is a good medium for microtransactions.\n\nI don't hear anyone lying.\n\n\n> It's not.\n\nActually, it is, and comparatively speaking, Bitcoin is better than the\nmost common alternatives in use by people around the world.  There are\nobvious issues (dust, how to handle fee issues moving forward, one could\nblather on forever about that), but again, I think core devs have done\nfairly well and will probably continue to do so along with many others. \nThat's just my own 0.00004 BTC though (my way of saying, at time of\nposting this, \"my own 2 cents\").\n\n>Saying otherwise by releasing software that has known and\n> obvious DoS attack vulnerabilities that didn't exist in the previous\n> version is irresponsible on multiple levels.\n\nThat was not very specific.  Could you be more specific?\n\n>\n> --\n> 'peter'[:-1]@petertodd.org\n> 0000000000000000b28e2818c4d8019fb71e33ec2d223f5e09394a89caccf4e2\n> ------------------------------------------------------------------------------\n> Flow-based real-time traffic analytics software. Cisco certified tool.\n> Monitor traffic, SLAs, QoS, Medianet, WAAS etc. with NetFlow Analyzer\n> Customize your own dashboards, set traffic alerts and generate reports.\n> Network behavioral analysis & security monitoring. All-in-one tool.\n> http://pubads.g.doubleclick.net/gampad/clk?id=126839071&iu=/4140/ostg.clktrk_______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-02-25T12:55:18",
                "message_text_only": "Given that the fee drop puts fees in \"real\" (i.e. dollar) terms back to\nwhere they were some months ago, it seems odd to claim this is creating\nvulnerabilities that didn't exist in the previous version. The cost of an\nattack would be the same as before.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140225/51e0f2da/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-25T14:49:22",
                "message_text_only": "On Tue, Feb 25, 2014 at 06:25:18PM +0530, Mike Hearn wrote:\n> Given that the fee drop puts fees in \"real\" (i.e. dollar) terms back to\n> where they were some months ago, it seems odd to claim this is creating\n> vulnerabilities that didn't exist in the previous version. The cost of an\n> attack would be the same as before.\n\nNo it's not. The cost is only incurred in the transactions actually get\nmined, and unlike before the drop appears to be well under the\nbreak-even orphan cost of transactions; we've got no reason to think the\nclearance rate of these low-fee transactions will be significant.\n\n\nBut anyway, mostly I'm writing this to register my strong opposition\nknowing full well that I don't expect it to change your minds.\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000000eb671d932a8d310e8ab963c53b2be8a27bd5de2a712c2f59\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140225/952b63e3/attachment.sig>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-02-25T16:55:58",
                "message_text_only": "There are two possibilities.\n\nOne is that the value of transactions with the new lower fee is outweighed\nby increased orphan costs and miners refuse to include them en-masse.\nWallet authors lose the staring match and go back to setting higher fees\nuntil such a time as block propagation is optimised and the orphan costs go\ndown. Nodes that are encountering memory pressure can increase their min\nrelay fee locally until their usage fits inside their resources. It's\nannoying to do this by hand but by no means infeasible.\n\nThe other is that the total value of transactions even with the lower fee\nis not outweighed by orphan costs. The value of a transaction is higher\nthan its simple monetary value - the fact that Bitcoin is useful, growing\nand considered cheap also has a value which is impossible to calculate, but\nwe know it's there (because Bitcoin does not exist in a vacuum and has\ncompetitors). In this case miners stop including lots of useful\ntransactions that represent desired economic activity and are put under\npressure by the community to change their policies. If all miners do this\nand making small blocks is considered errant behaviour, then we're back to\nthe same situation we're in today.\n\nThe possibility you're worried about - that someone does a DoS attack by\nflooding the network with small transactions - is only an issue in the\nfirst situation, and it is by no means the easiest or cheapest way to DoS\nBitcoin. We all want to see more DoS resistance but basically any change to\nBitcoin can be objected to on anti-DoS grounds at the moment, and this will\nremain the case until someone steps up to spend significant time on\nresource scheduling and code audits.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140225/1ab5018a/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-25T17:13:34",
                "message_text_only": "On Tue, Feb 25, 2014 at 10:25:58PM +0530, Mike Hearn wrote:\n\nWell, I've done my responsible disclosure, and I've got better things to\ndo than argue with wishful thinking.\n\n> There are two possibilities.\n> \n> One is that the value of transactions with the new lower fee is outweighed\n> by increased orphan costs and miners refuse to include them en-masse.\n> Wallet authors lose the staring match and go back to setting higher fees\n> until such a time as block propagation is optimised and the orphan costs go\n> down. Nodes that are encountering memory pressure can increase their min\n> relay fee locally until their usage fits inside their resources. It's\n> annoying to do this by hand but by no means infeasible.\n> \n> The other is that the total value of transactions even with the lower fee\n> is not outweighed by orphan costs. The value of a transaction is higher\n> than its simple monetary value - the fact that Bitcoin is useful, growing\n> and considered cheap also has a value which is impossible to calculate, but\n> we know it's there (because Bitcoin does not exist in a vacuum and has\n> competitors). In this case miners stop including lots of useful\n> transactions that represent desired economic activity and are put under\n> pressure by the community to change their policies. If all miners do this\n> and making small blocks is considered errant behaviour, then we're back to\n> the same situation we're in today.\n> \n> The possibility you're worried about - that someone does a DoS attack by\n> flooding the network with small transactions - is only an issue in the\n> first situation, and it is by no means the easiest or cheapest way to DoS\n> Bitcoin. We all want to see more DoS resistance but basically any change to\n> Bitcoin can be objected to on anti-DoS grounds at the moment, and this will\n> remain the case until someone steps up to spend significant time on\n> resource scheduling and code audits.\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000000445db8e568846d542c86ab395137b32b2a05577afcc7c6a3\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140225/f44181ab/attachment.sig>"
            },
            {
                "author": "Jeremy Spilman",
                "date": "2014-02-25T18:09:23",
                "message_text_only": "If I understand correctly, the risk here is this would open a historically  \nlarge discrepancy between MIN_RELAY and the expected minimum fee to  \nactually obtain block inclusion. I don't know if that's true, but I think  \nthat's what Peter is saying makes it different this time.\n\nThe relay network does anti-spam with MIN_RELAY and MIN_DUST, but of  \ncourse only transactions which hit the blockchain actually PAY the fee, so  \nthis allows lower-cost spam in the true dollar sense.\n\nI guess it comes down to how 'sharp' the edge is between staying above  \nMIN_RELAY and staying OUT of the blockchain. In the worst case, there's a  \ncompletely deterministic boundary, so an attacker can generate an infinite  \nnumber of transactions which are guaranteed never to see the inside of a  \nblock, and so therefore completely free for the attacker, and all of which  \nthe network will relay (by default).\n\nOn Tue, 25 Feb 2014 08:55:58 -0800, Mike Hearn <mike at plan99.net> wrote:\n> Nodes that are encountering memory pressure can increase their min relay  \n> fee locally until their usage fits inside their resources. It's annoying  \n> to do this >by hand but by no means infeasible.\n\nPerhaps this is just another way to think of the floating fee problem.  \nWhat does MIN_RELAY need to be so that my local resources stay within some  \nreasonable limit (and 'reasonable' means different things to different  \nnodes).\n\nWe have an input gate on transactions entering mempool, we persist  \nmempool, and I don't know the specifics but, I assume there's some  \nexpiration policy other than block inclusion to clear out a Tx from  \nmempool. But are transactions prioritized in any way after they make it  \ninto mempool today?\n\nHow closely should mempool selection align with the expected block  \ninclusion? I think if they align perfectly in theory that means optimal  \nmempool resource allocation. For example, a miner would push out cheaper  \ntransactions which they were previously hashing against to make room for  \nhigher fee transactions (bsaed on max block size or orphan rate  \nprojections), but do we do the same for mempool? E.g.\n\n   - After hitting X number of transactions, the fee has to be larger than  \na transaction in mempool in order to get in,\n   - That in turn that ejects a random transaction which paid less fees  \nthan the incoming Tx from mempool\n   - We would have to consider how ejection would work with chains of  \nunconfirmed transactions (cumulative average fee/kb?) but again in this  \ncase, you would want to 'do what miners would do' if you could\n\nThanks,\nJeremy\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140225/2bd6429a/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2014-02-28T11:18:26",
                "message_text_only": "On Tue, Feb 25, 2014 at 10:09:23AM -0800, Jeremy Spilman wrote:\n> If I understand correctly, the risk here is this would open a\n> historically large discrepancy between MIN_RELAY and the expected\n> minimum fee to actually obtain block inclusion. I don't know if\n> that's true, but I think that's what Peter is saying makes it\n> different this time.\n\nThat's exactly the problem.\n\nOf course every time we make a new transaction type standard we also run\nthat risk, but at least it's a temporary situation and we can expect to\nget hashing power on-board fairly quickly. With such a low MIN_RELAY\nthat's not true, and in an absolute sense, the funds required to DoS\nattack the network are fairly low.\n\n> On Tue, 25 Feb 2014 08:55:58 -0800, Mike Hearn <mike at plan99.net> wrote:\n> >Nodes that are encountering memory pressure can increase their min\n> >relay fee locally until their usage fits inside their resources.\n> >It's annoying to do this >by hand but by no means infeasible.\n> \n> Perhaps this is just another way to think of the floating fee\n> problem. What does MIN_RELAY need to be so that my local resources\n> stay within some reasonable limit (and 'reasonable' means different\n> things to different nodes).\n> \n> We have an input gate on transactions entering mempool, we persist\n> mempool, and I don't know the specifics but, I assume there's some\n> expiration policy other than block inclusion to clear out a Tx from\n> mempool. But are transactions prioritized in any way after they make\n> it into mempool today?\n\nThere's currently no expiration policy at all; that's the root of the\nDoS problem I was referring too.\n\n> How closely should mempool selection align with the expected block\n> inclusion? I think if they align perfectly in theory that means\n> optimal mempool resource allocation. For example, a miner would push\n> out cheaper transactions which they were previously hashing against\n> to make room for higher fee transactions (bsaed on max block size or\n> orphan rate projections), but do we do the same for mempool? E.g.\n> \n>   - After hitting X number of transactions, the fee has to be larger\n> than a transaction in mempool in order to get in,\n>   - That in turn that ejects a random transaction which paid less\n> fees than the incoming Tx from mempool\n>   - We would have to consider how ejection would work with chains of\n> unconfirmed transactions (cumulative average fee/kb?) but again in\n> this case, you would want to 'do what miners would do' if you could\n\nHave you seen the mempool superblock design that keeps getting\nsuggested? jgarzik has the most recent write-up here:\nhttps://github.com/bitcoin/bitcoin/issues/3723\n\nI was working on a relatively ambitious version of it last summer that\ncalculated the fee/KB for transactions, including depedencies, and then\nsimply ordered the mempool with highest fee/KB first. The idea was you\ncould then easily limit the total size of the mempool and drop\ntransactions with the lowest fee/KB first. Transactions that paid less\nthan the lowest fee/KB in a max-size mempool simply would not get\nrelayed at all. Pity had to put it off for higher-priority work.\n\nWhat's interesting is how this makes zero-conf transactions even less\nsafe: all you have to do to double-spend one (or more!) that pay X\nfee/KB is broadcast enough transactions paying X+e fee/KB to push out\nthe unconfirmed tx from mepools around the network, then broadcast your\ndouble-spend. Obviously the economics of this are going to make attacks\nfrequently profitable, especially if you can attack multiple targets at\nonce. You can of course have schemes where you don't entirely drop\ntransactions, saving, say, the inputs they spend and a transaction id,\n(so a rebroadcast can succeed) but that just reduces the effectiveness\nof the attack by a constant factor and makes it possible to get into\ncomplex situations where your funds are locked and unspendable.\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000011ffdfe2bfdf8f1f983bebfa160670b85afeebbd815fdf484\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140228/c9dec419/attachment.sig>"
            },
            {
                "author": "Odinn Cyberguerrilla",
                "date": "2014-02-25T22:43:58",
                "message_text_only": "Am suggesting a (possible) mitigation of [possible flooding, etc], via\nsome kind of discussion (potentially process BIP, related to bundling and\n/ or randomization) not now, but down the road.  However, needs more\nthought and analysis (you mentioned code audit?) before it could be\nfloated around or acted on in any way shape or form.  Thanks for this\ndiscussion, things to think about.... am watching, listening (...)\n\n> There are two possibilities.\n>\n> One is that the value of transactions with the new lower fee is outweighed\n> by increased orphan costs and miners refuse to include them en-masse.\n> Wallet authors lose the staring match and go back to setting higher fees\n> until such a time as block propagation is optimised and the orphan costs\n> go\n> down. Nodes that are encountering memory pressure can increase their min\n> relay fee locally until their usage fits inside their resources. It's\n> annoying to do this by hand but by no means infeasible.\n>\n> The other is that the total value of transactions even with the lower fee\n> is not outweighed by orphan costs. The value of a transaction is higher\n> than its simple monetary value - the fact that Bitcoin is useful, growing\n> and considered cheap also has a value which is impossible to calculate,\n> but\n> we know it's there (because Bitcoin does not exist in a vacuum and has\n> competitors). In this case miners stop including lots of useful\n> transactions that represent desired economic activity and are put under\n> pressure by the community to change their policies. If all miners do this\n> and making small blocks is considered errant behaviour, then we're back to\n> the same situation we're in today.\n>\n> The possibility you're worried about - that someone does a DoS attack by\n> flooding the network with small transactions - is only an issue in the\n> first situation, and it is by no means the easiest or cheapest way to DoS\n> Bitcoin. We all want to see more DoS resistance but basically any change\n> to\n> Bitcoin can be objected to on anti-DoS grounds at the moment, and this\n> will\n> remain the case until someone steps up to spend significant time on\n> resource scheduling and code audits.\n>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-02-26T22:51:32",
                "message_text_only": "Just pushed out a mempool janitor change to\nhttps://github.com/bitcoin/bitcoin/pull/3753   The goal was to create\na simple bolt-on change, and /not/ rewrite the mempool code.\n\nI'll be running some metrics on what does and does not get into the\nmempools of my public nodes for 48 hours, ending Friday ~midnight EST.\n\nOn Mon, Feb 24, 2014 at 11:41 PM, Peter Todd <pete at petertodd.org> wrote:\n> So, just to be clear, we're adding, say, a memory limited mempool or\n> something prior to release so this fee drop doesn't open up an obvious\n> low-risk DDoS exploit.... right? As we all know, the network bandwidth\n> DoS attack mitigation strategy relies on transactions we accept to\n> mempools getting mined, and the clearance rate of the new low-fee\n> transactions is going to be pretty small; we've already had problems in\n> the past with mempool growth in periods of high demand. Equally it\n> should be obvious to people how you can create large groups of low-fee\n> transactions, and then cheaply double-spend them with higher fee\n> transactions to suck up network bandwidth - just like I raised for the\n> equally foolish double-spend propagation pull-req.\n>\n> Of course, there's also the problem that we're basically lying to people\n> about whether or not Bitcoin is a good medium for microtransactions.\n> It's not. Saying otherwise by releasing software that has known and\n> obvious DoS attack vulnerabilities that didn't exist in the previous\n> version is irresponsible on multiple levels.\n>\n> --\n> 'peter'[:-1]@petertodd.org\n> 0000000000000000b28e2818c4d8019fb71e33ec2d223f5e09394a89caccf4e2\n>\n> ------------------------------------------------------------------------------\n> Flow-based real-time traffic analytics software. Cisco certified tool.\n> Monitor traffic, SLAs, QoS, Medianet, WAAS etc. with NetFlow Analyzer\n> Customize your own dashboards, set traffic alerts and generate reports.\n> Network behavioral analysis & security monitoring. All-in-one tool.\n> http://pubads.g.doubleclick.net/gampad/clk?id=126839071&iu=/4140/ostg.clktrk\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Troy Benjegerdes",
                "date": "2014-02-28T04:50:51",
                "message_text_only": "On Mon, Feb 24, 2014 at 11:41:16PM -0500, Peter Todd wrote:\n> So, just to be clear, we're adding, say, a memory limited mempool or\n> something prior to release so this fee drop doesn't open up an obvious\n> low-risk DDoS exploit.... right? As we all know, the network bandwidth\n> DoS attack mitigation strategy relies on transactions we accept to\n> mempools getting mined, and the clearance rate of the new low-fee\n> transactions is going to be pretty small; we've already had problems in\n> the past with mempool growth in periods of high demand. Equally it\n> should be obvious to people how you can create large groups of low-fee\n> transactions, and then cheaply double-spend them with higher fee\n> transactions to suck up network bandwidth - just like I raised for the\n> equally foolish double-spend propagation pull-req.\n> \n> Of course, there's also the problem that we're basically lying to people\n> about whether or not Bitcoin is a good medium for microtransactions.\n> It's not. Saying otherwise by releasing software that has known and\n> obvious DoS attack vulnerabilities that didn't exist in the previous\n> version is irresponsible on multiple levels.\n\nWell, if your investors take money with market manipulating news stories,\nthis is absolutely the responsible thing to do to increase shareholder\nvalue with a future opportunity to cause a crash-on-demand.\n\nBesides, if you really want microtransactions, you should be using an\naltcoin with faster block times, smaller market cap, and larger 'human'\nreadable currency supply.\n\nThat being said, I'd say include the change, we all know about it. What\nwould be nice would be some exploits and attack signatures for what the\nDOS will look like when it hits so that those of us paying attention\ncan make some money trading in anticipation of the market crash instead\nof just the guys paying for the attack.\n\nThe real killer feature of Bitcoin is that we can learn from it's mistakes\n(and bitcoin can learn from the copycatcoins), instead of one-size-fits\nall fiat.\n\n-- \n----------------------------------------------------------------------------\nTroy Benjegerdes                 'da hozer'                  hozer at hozed.org\n7 elements      earth::water::air::fire::mind::spirit::soul        grid.coop\n\n      Never pick a fight with someone who buys ink by the barrel,\n         nor try buy a hacker who makes money by the megahash"
            }
        ],
        "thread_summary": {
            "title": "Fee drop",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Troy Benjegerdes",
                "Odinn Cyberguerrilla",
                "Mike Hearn",
                "Peter Todd",
                "Jeremy Spilman",
                "naman naman"
            ],
            "messages_count": 12,
            "total_messages_chars_count": 25783
        }
    },
    {
        "title": "[Bitcoin-development] BIP70 extension to allow for identity delegation",
        "thread_messages": [
            {
                "author": "Mike Hearn",
                "date": "2014-02-28T11:46:49",
                "message_text_only": "Now we're starting to see the first companies deploy BIP70, we're\nencountering a need for identity delegation. This need was long foreseen by\nthe way: it's not in BIP70 because, well, we had to draw the line for v1\nsomewhere, and this is an issue that mostly affects payment processors. But\nI figured I'd start a thread anyway because people keep asking me about it\n:)\n\n*Objective*\n\nIdentity delegation means that a payment request can be signed by someone\nwho is not holding the certified private key. The most obvious use case for\nthis is payment processors like BitPay and Coinbase who currently have to\nsign payment requests as themselves. Other use cases might involve\nuntrusted sales agents who want to be able to accept payment as their\nemployer, but cannot be trusted with a long-term valuable secret, e.g.\nbecause they take their phone into areas with high crime rates.\n\nThe lack of this is ok for v1 but not great, because:\n\n1) It requires the name of the *actual* recipient to be put in the memo\nfield, otherwise you don't have the nice receipt-like properties. The memo\nfield is just plain text though, it doesn't have any exploitable structure.\n\n2) It gives a confusing UI, the user thinks they're paying e.g. Overstock\nbut their wallet UI tells them they're paying Coinbase\n\n3) Whilst these payment processors currently verify merchants so the\nsecurity risk is low, in future a lighter-weight model or competing sites\nthat allow open signups would give a weak security situation:  a hacker who\ncompromised your computer could sign up for some popular payment processor\nunder a false identity (or no identity), and wait until you use your hacked\ncomputer to make a payment to someone else using the same payment\nprocessor. They could then do an identity swap of the real payment request\nfor one of their own, and your Trezor would still look the same. Avoiding\nthis is a major motivation for the entire system!\n\nAlso it just looks more professional if the name you see in the wallet UI\nis correct.\n\n*Proposed implementation*\n\nWe can fix this with a simple extension:\n\nenum KeyType {\n  SECP256K1 = 1\n}\n\nmessage ExtensionCert {\n  required bytes signature = 1;\n  required bytes public_key = 2;\n  required KeyType key_type = 3;\n  required uint32 expiry_time = 4;\n  optional string memo = 5;\n}\n\n// modification\nmessage X509Certificates {\n  repeated bytes certificate = 1;\n  repeated ExtensionCert extended_certs = 2;\n}\n\nmessage PaymentRequest {\n  // new field\n  optional bytes extended_signature = 6;\n}\n\nThis allow us to define a so-called *extended certificate*, which is\nconceptually the same as an X.509 certificate except simpler and Bitcoin\nspecific. To create one, you just format a ExtensionCert message with an\nECDSA public key from the payment processor (PP), set signature to an empty\narray and then sign it using your SSL private key. Obviously the resulting\n(most likely RSA) signature then goes into the signature field of the\nExtensionCert. The memo field could optionally indicate the purpose of this\ncert, like \"Delegation to BitPay\" but I don't think it'd ever appear in the\nUI, rather, it should be there for debugging purposes.\n\nThe new ExtensionCert can then be provided back to the PP who adds it to\nthe X509Certificates message. In the PaymentRequest, there are now\n*two* signature\nfields (this is for backwards compatibility). Because of how the mechanism\nis designed they should not interfere with each other - old implementations\nthat don't understand the new extended_signature field will drop it during\nreserialization to set signature to the empty array, and thus signature\nshould not cover that field. On the other hand, extended_signature would\ncover signature. Thus, for full backwards compatibility, you would:\n\n1) Sign the payment request using the PP's SSL cert, i.e. sign as\ncoinbase.com\n\n2) Then sign again using the PP's delegated ECDSA key, i.e. sign as the\nmerchant\n\nThe finished protobuf would show up in old clients as signed by\ncoinbase.comand by new clients as signed by\noverstock.com even though Overstock did not provide their SSL key to\ncoinbase.\n\nIf you have *only* an ExtensionCert and not any X.509 cert of your own,\nthen you cannot of course make backwards compatible signatures in this way,\nand in that case you would miss out the signature field and set the\npki_type to a new value:  \"x509+sha256+excert\". Old wallets would see that\nthey don't understand this pki_type and treat the request as unverified.\n\nFor maximum security the merchant may choose to set very short expiry times\n(like, a day) and then have a cron job that uploads a new ExtensionCert at\nthe end of each expiry period. This means in the case of PP compromise, the\nsystem reseals very fast.\n\n*Alternatives considered*\n\nWe could always use a new pki_type and not bother with the two signature\nfields. However, this means old wallets will show payment requests as\nuntrusted during the transition period. Some signing is still better than\nnone, security-wise.\n\nWe could attempt to fix the above by introducing a use of User-Agent field\nto the case where a payment request is fetched via HTTP, so the server can\ncustomise the PaymentRequest according to the capabilities of the client.\nHowever, sometimes payment requests are not fetched via HTTP, for example,\nthey may be attached to an email, sent via an IM network or sent over a\nBluetooth socket. Nonetheless this may be a useful thing to consider for\nfuture cases where the protocol may not be extended in a backwards\ncompatible manner.\n\nWe could create the extension cert as an X.509 cert, rather than a custom\ntype. However most CA's set path length constraints on their intermediate\ncerts that forbid this kind of extension (I forgot why, possibly some kind\nof anti-DoS mitigation). Also re-using X.509 for the extension cert would\nopen up the risk of it being accepted by a bogus SSL stack that didn't\ncheck the key usage constraints extension, and that would allow for SSL\ndelegation as well. It seems safer to just use a different format that\ndefinitely won't be accepted.\n\n\n\nFeedback welcome.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140228/35b5bc97/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP70 extension to allow for identity delegation",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Mike Hearn"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 6262
        }
    }
]