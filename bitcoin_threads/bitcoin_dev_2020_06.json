[
    {
        "title": "[bitcoin-dev] Design for a CoinSwap implementation for massively improving Bitcoin privacy and fungibility",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-01T02:34:03",
                "message_text_only": "Good morning Ruben,\n\n\n>\n> That assumes there will be a second transaction. With SAS I believe we can avoid that, and make it look like this:\n>\n> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0+---+\n> \u00a0 \u00a0 Alice ---| \u00a0 |--- Bob\n> \u00a0 \u00a0 Alice ---| \u00a0 |\n> \u00a0 \u00a0 \u00a0 Bob ---| \u00a0 |\n> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0+---+\n\nIf Alice is paying to a non-SAS aware payee that just provides an onchain address (i.e. all current payees today), then the 2-of-2 output it gets from the swap (both of whose keys it learns at the end of the swap) is **not** the payee onchain address.\nAnd it cannot just hand over both private keys, because the payee will still want unambiguous ownership of the entire UTXO.\nSo it needs a second transaction anyway.\n(with Schnorr then Alice and payee Carol can act as a single entity/taker to Bob, a la Lightning Nodelets using Composable MuSig, but that is a pretty big increase in protocol complexity)\n\nIf Alice does not want to store the remote-generated privkey as well, and use only an HD key, then it also has to make the second transaction.\nAlice might want to provide the same assurances as current wallets that memorizing a 12-word or so mnemonic is sufficient backup for all the funds (other than funds currently being swapped), and so would not want to leave any funds in a 2-of-2.\n\nIf Bob is operating as a maker, then it also cannot directly use the 2-of-2 output it gets from the swap, and has to make a new 2-of-2 output, for the *next* taker that arrives to request its services.\n\nSo there is always going to be a second transaction in a SwapMarket system, I think.\n\n\nWhat SAS / private key turnover gets us is that there is not a *third* transaction to move from a 1-of-1 to the next address that makers and takers will be moving anyway, and that the protocol does not have to add communication provisions for special things like adding maker inputs or specifying all destination addresses for the second stage and so on, because those can be done unilaterally once the private key is turned over.\n\n\n> >A thing I have been trying to work out is whether SAS can be done with more than one participant, like in S6\n>\n> S6 requires timelocks for each output in order to function, so I doubt it can be made to work with SAS.\n\nHmmm right right.\n\nNaively it seems both chaining SAS/private key turnover to multiple makers, and a multi-maker S6 augmented with private key turnover, would result in the same number of transactions onchain, but I probably have to go draw some diagrams or something first.\n\nBut S6 has the mild advantage that all the funding transactions paying to 2-of-2s *can* appear on the same block, whereas chaining swaps will have a particular order of when the transactions appear onchain, which might be used to derive the order of swaps.\nOn the other hand, funds claiming in S6 is also ordered in time, so someone paying attention to the mempool could guess as well the order of swaps.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Ruben Somsen",
                "date": "2020-06-01T10:19:38",
                "message_text_only": "Hi ZmnSCPxj,\n\n>If Alice is paying to a non-SAS aware payee\n\nYeah, I agree that this use case is not possible without a third\ntransaction (preferably from the timelocked side, in the case of SAS). My\npoint was merely that you can swap and simultaneously merge some of your\noutputs into the post-swap non-timelocked output, though perhaps that is\nnot very useful.\n\nCheers,\nRuben\n\n\n\nOn Mon, Jun 1, 2020 at 4:34 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Ruben,\n>\n>\n> >\n> > That assumes there will be a second transaction. With SAS I believe we\n> can avoid that, and make it look like this:\n> >\n> >              +---+\n> >     Alice ---|   |--- Bob\n> >     Alice ---|   |\n> >       Bob ---|   |\n> >              +---+\n>\n> If Alice is paying to a non-SAS aware payee that just provides an onchain\n> address (i.e. all current payees today), then the 2-of-2 output it gets\n> from the swap (both of whose keys it learns at the end of the swap) is\n> **not** the payee onchain address.\n> And it cannot just hand over both private keys, because the payee will\n> still want unambiguous ownership of the entire UTXO.\n> So it needs a second transaction anyway.\n> (with Schnorr then Alice and payee Carol can act as a single entity/taker\n> to Bob, a la Lightning Nodelets using Composable MuSig, but that is a\n> pretty big increase in protocol complexity)\n>\n> If Alice does not want to store the remote-generated privkey as well, and\n> use only an HD key, then it also has to make the second transaction.\n> Alice might want to provide the same assurances as current wallets that\n> memorizing a 12-word or so mnemonic is sufficient backup for all the funds\n> (other than funds currently being swapped), and so would not want to leave\n> any funds in a 2-of-2.\n>\n> If Bob is operating as a maker, then it also cannot directly use the\n> 2-of-2 output it gets from the swap, and has to make a new 2-of-2 output,\n> for the *next* taker that arrives to request its services.\n>\n> So there is always going to be a second transaction in a SwapMarket\n> system, I think.\n>\n>\n> What SAS / private key turnover gets us is that there is not a *third*\n> transaction to move from a 1-of-1 to the next address that makers and\n> takers will be moving anyway, and that the protocol does not have to add\n> communication provisions for special things like adding maker inputs or\n> specifying all destination addresses for the second stage and so on,\n> because those can be done unilaterally once the private key is turned over.\n>\n>\n> > >A thing I have been trying to work out is whether SAS can be done with\n> more than one participant, like in S6\n> >\n> > S6 requires timelocks for each output in order to function, so I doubt\n> it can be made to work with SAS.\n>\n> Hmmm right right.\n>\n> Naively it seems both chaining SAS/private key turnover to multiple\n> makers, and a multi-maker S6 augmented with private key turnover, would\n> result in the same number of transactions onchain, but I probably have to\n> go draw some diagrams or something first.\n>\n> But S6 has the mild advantage that all the funding transactions paying to\n> 2-of-2s *can* appear on the same block, whereas chaining swaps will have a\n> particular order of when the transactions appear onchain, which might be\n> used to derive the order of swaps.\n> On the other hand, funds claiming in S6 is also ordered in time, so\n> someone paying attention to the mempool could guess as well the order of\n> swaps.\n>\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200601/aee5c117/attachment.html>"
            },
            {
                "author": "Chris Belcher",
                "date": "2020-06-02T22:24:19",
                "message_text_only": "Hello ZmnSCPxj,\n\nOn 31/05/2020 03:30, ZmnSCPxj via bitcoin-dev wrote:\n> Good morning Ruben and Chris,\n\n> I am not in fact convinced that PayJoin-with-CoinSwap adds *that* much privacy.\n> \n> These transactions:\n> \n>              +---+  +---+\n>     Alice ---|   |--|   |--- Bob\n>     Alice ---|   |  |   |\n>       Bob ---|   |  +---+\n>              +---+\n> \n> Are not really much different in coin ownership analysis from these:\n> \n>              +---+    +---+\n>     Alice ---|   |----|   |--- Bob\n>     Alice ---|   | +--|   |\n>              +---+ |  +---+\n>       Bob ---------+\n\nThe main benefit of PayJoin-with-CoinSwap is it breaks the\ncommon-input-ownership heuristic, which is a major widely used\nheuristic. It would be a big win if that heuristic could be broken.\n\nPayJoin-with-CoinSwap would be useful if Alice is trying to recover some\nprivacy which was previously degraded, for example if she is spending\nfrom a reused address or from an address linked to her identity. If she\ndoes a PayJoin with the reused address then some other economic entity\nwould have his activity linked with Alice's.\n\nJust the fact that PayJoin-with-CoinSwap exists would improve privacy\nfor people who don't use it, for example if someone buys bitcoin from an\nexchange that knows their identity and then co-spends it with other\ncoins they obtained another way. The fact that PayJoin exists means an\nadversary cannot assume for sure that this user really owns that other\naddress which was co-spent. This doesn't apply for regular CoinSwap,\nwhich only ever breaks the transaction graph heuristic, so in our\nexample the destination the coins are sent *to* would be uncertain, but\nthat the co-spent inputs are owned by the same person would be certain\nin a world where PayJoin didn't exist.\n\n> It also removes the need for Bob to reveal additional UTXOs to Alice during the swap protocol; yes PoDLE mitigates the privacy probing attack that Alice can mount on Bob, but it is helpful to remember this is \"only\" a mitigation.\n\nOpening up the possibility of spying for free is a real downside for\nPayJoin-with-CoinSwap. Using decoy UTXOs as described in my design\ndocument, rather than PoDLE, seems like a better way of resisting these\nattacks. This is because at the cost of a little bit more bandwidth and\nCPU its possible to make the probability of an attacker successfully\nguessing the maker's real UTXOs to be as low as you want.\n\n> But S6 has the mild advantage that all the funding transactions paying to 2-of-2s *can* appear on the same block, whereas chaining swaps will have a particular order of when the transactions appear onchain, which might be used to derive the order of swaps.\nOn the other hand, funds claiming in S6 is also ordered in time, so\nsomeone paying attention to the mempool could guess as well the order of\nswaps.\n\nI think this is wrong, and that it's possible for the funding\ntransactions of chained/routed swaps to all be in the same block as well.\n\nIn CoinSwap it's possible to get DOS'd without the other side spending\nmoney if you broadcast your funding transaction first and the other side\nsimply disappears. You'd get your money back but you have to waste time\nand spend miner fees. The other side didn't spend money to do this, not\neven miner fees.\n\n>From the point of view of us as a maker in the route, we know we won't\nget DOS'd like this for free if we only broadcast our funding\ntransaction once we've seen the other side's funding transaction being\nbroadcast first. This should work as long as the two transactions have a\nsimilar fee rate. There might be an attack involving hash power: If the\nother side has a small amount of hash power and mines only their funding\ntransaction in a manner similar to a finney attack, then our funding\ntransaction should get mined very soon afterwards by another miner and\nthe protocol will continue as normal. If the other side has knowledge of\nthe preimage and uses it to do CPFP and take the money, then we can\nlearn that preimage and do our own CPFP to get our money back too.\n\nSo in a routed coinswap setup it should be possible for Alice the taker\nto broadcast her funding transaction first, which will lead to all the\nmakers broadcasting their funding transactions as well once they see the\nother side has broadcast first. Then it would be possible for all those\nfunding transactions to be confirmed in the same block.\n\nI hope I haven't missed anything, because if this doesn't work and each\nmaker must wait for confirmations, then the UX of routed CoinSwap would\ndegrade: a CoinSwap route of 5 makers would require at least 5 blocks to\nbe mined.\n\nOf course this setup can leak the ordering of the routes because the\nfunding transaction would appear in the mempool in that order, but this\ncould be beaten if some Alices choose to intentionally spread out the\nfunding transaction broadcasts among multiple blocks for privacy reasons.\n\nAn interesting tangent could be to see if it's possible to make private\nkey handover work with S6. A nice side-effect of private key handover is\nthat the transfer of possession of the coins happens off-chain, so then\npaying attention to the mempool won't help an adversary much.\n\n\nRegards,\nChris Belcher"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-03T04:53:52",
                "message_text_only": "Good morning Chris,\n\n> > Good morning Ruben and Chris,\n>\n> > I am not in fact convinced that PayJoin-with-CoinSwap adds that much privacy.\n> > These transactions:\n> >\n> >              +---+  +---+\n> >     Alice ---|   |--|   |--- Bob\n> >     Alice ---|   |  |   |\n> >       Bob ---|   |  +---+\n> >              +---+\n> >\n> >\n> > Are not really much different in coin ownership analysis from these:\n> >\n> >              +---+    +---+\n> >     Alice ---|   |----|   |--- Bob\n> >     Alice ---|   | +--|   |\n> >              +---+ |  +---+\n> >       Bob ---------+\n> >\n>\n> The main benefit of PayJoin-with-CoinSwap is it breaks the\n> common-input-ownership heuristic, which is a major widely used\n> heuristic. It would be a big win if that heuristic could be broken.\n>\n> PayJoin-with-CoinSwap would be useful if Alice is trying to recover some\n> privacy which was previously degraded, for example if she is spending\n> from a reused address or from an address linked to her identity. If she\n> does a PayJoin with the reused address then some other economic entity\n> would have his activity linked with Alice's.\n>\n> Just the fact that PayJoin-with-CoinSwap exists would improve privacy\n> for people who don't use it, for example if someone buys bitcoin from an\n> exchange that knows their identity and then co-spends it with other\n> coins they obtained another way. The fact that PayJoin exists means an\n> adversary cannot assume for sure that this user really owns that other\n> address which was co-spent. This doesn't apply for regular CoinSwap,\n> which only ever breaks the transaction graph heuristic, so in our\n> example the destination the coins are sent to would be uncertain, but\n> that the co-spent inputs are owned by the same person would be certain\n> in a world where PayJoin didn't exist.\n\nAlice can do PayJoin with a payee Carol that supports normal PayJoin, for similar overall results.\n\nThough I suppose there is a mild advantage still with supporting it on the funding tx of the first transaction, as you noted.\n\n> > But S6 has the mild advantage that all the funding transactions paying to 2-of-2s can appear on the same block, whereas chaining swaps will have a particular order of when the transactions appear onchain, which might be used to derive the order of swaps.\n>\n> On the other hand, funds claiming in S6 is also ordered in time, so\n> someone paying attention to the mempool could guess as well the order of\n> swaps.\n>\n> I think this is wrong, and that it's possible for the funding\n> transactions of chained/routed swaps to all be in the same block as well.\n>\n> In CoinSwap it's possible to get DOS'd without the other side spending\n> money if you broadcast your funding transaction first and the other side\n> simply disappears. You'd get your money back but you have to waste time\n> and spend miner fees. The other side didn't spend money to do this, not\n> even miner fees.\n>\n> From the point of view of us as a maker in the route, we know we won't\n> get DOS'd like this for free if we only broadcast our funding\n> transaction once we've seen the other side's funding transaction being\n> broadcast first. This should work as long as the two transactions have a\n> similar fee rate. There might be an attack involving hash power: If the\n> other side has a small amount of hash power and mines only their funding\n> transaction in a manner similar to a finney attack, then our funding\n> transaction should get mined very soon afterwards by another miner and\n> the protocol will continue as normal. If the other side has knowledge of\n> the preimage and uses it to do CPFP and take the money, then we can\n> learn that preimage and do our own CPFP to get our money back too.\n\nHow about RBF?\n\nA taker Alice can broadcast the funding tx spending its own funds.\nThe funding tx spends funds controlled unilaterally by Alice.\nAlice can sign a replacement transaction for those funds, spending them to an address with unilateral control, and making the funding tx output with all the obligations attached never get confirmed in the first place.\n\nThe chances may be small --- Bob can certainly monitor for Alice broadcasting a replacement and counter-broadcast its own replacement --- but the risk still exists.\nTANSTAAGM (There Aint No Such Thing As A Global Mempool) also means Alice could arrange the replacement by other means, such as not using the RBF-enabled flag, broadcasting the self-paying replacement near miner nodes, and broadcasting the CoinSwap-expected funding tx near the Bob fullnode; Bob fullnode will then reject attempts to replace it, but miners will also reject the CoinSwap-expected funding tx and it will not confirm anyway.\n\n\nWith the pre-SAS 4-tx setup, this potentially allows Alice to steal the funds of Bob; after Alice gets its funding-tx-replacement confirmed together with the Bob honest-funding-tx, Alice can use the contract transaction and publish the preimage to take the Bob funds.\nSince the Alice-side funding tx has been replaced, knowledge of the hash preimage will not help Bob any: the Alice funding tx has been replaced and Bob cannot use the preimage to claim it (it does not exist).\n\n\nWith SAS Alice cannot outright steal the Bob funds, but the Bob funds will now be locked in a 2-of-2 and Alice can take it hostage (either Bob gives up on the funds, i.e. donates its value to all HODLers, or Bob gives most of the value to Alice).\n\n\nFor the avoidance of theft, it is probably better for Bob to wait for Alice-side funding tx to confirm, probably deeply because reorgs suck.\n\nThis at least makes it costly to perform this attack; you have to lock more of your funds longer in order to induce a competitor to lock its funds.\n\n\nCome to think of it, the same issue probably holds for S6 as well, the funding tx with the longest timelock has to confirm first before the next is even broadcast, bleah.\n\n\n> An interesting tangent could be to see if it's possible to make private\n> key handover work with S6. A nice side-effect of private key handover is\n> that the transfer of possession of the coins happens off-chain, so then\n> paying attention to the mempool won't help an adversary much.\n\nIt certainly seems quite possible; each participant in S6 has a fixed \"previous\" and \"next\" participant.\n\nOf course, this requires a secure tunnel, and my understanding of your plan for SwapMarket is that the taker Alice serves as the broadcast medium between all makers and itself.\nSo, in an S6 sequence of Alice -> Bob1 -> Bob2 -> Alice, after Alice provides the preimage, Bob2 encrypts the private key being handed over in an asymmetric encryption that only Alice can open (e.g. using some known pubkey of Alice, there are many to choose from), Bob1 similarly encrypts its privkey for Bob2, and Alice encrypts the private key to Bob1, and Alice can then broadcast all those data to all participants, and only the correct participant will be able to decrypt it.\n\n---\n\nOn another privacy-related note, S6 mildly leaks to each maker its position in the route, via the timelocks.\nEach Bob has to know the timelocks it is offered and which it will offer to the next participant, and the timelocks will be larger the further away that Bob is from the Alice taker.\nThis is a mild privacy leak, one that seems unremovable to me.\n(It also exists in Lightning Network as well: we suggest the use of \"shadow routes\" to artificially increase the distance of forwarding nodes, as a mitigation.)\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-03T14:50:01",
                "message_text_only": "Good morning Chris again,\n\n\n> For the avoidance of theft, it is probably better for Bob to wait for Alice-side funding tx to confirm, probably deeply because reorgs suck.\n\n\nOver in Lightning-land, we have a concept called \"irrevocably committed\".\nThis is a state where a newly-created contract can no longer be cancelled, by publishing an older state.\nIn Lightning, there is a short timeframe where a new state, and its directly previous state, are both still valid, until the previous state is revoked.\nOnly once the previous state (that does not contain the contract) has been revoked, and only the latest state is valid, can a forwarding node actually forward the payment.\n\n\nThis is roughly equivalent to the funding tx for the CoinSwap being confirmed.\nUntil a transaction is confirmed, the UTXOs it spends (i.e. the previous state) can still be validly spent by other alternate transactions.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-04T16:37:53",
                "message_text_only": "Good morning yet again Chris,\n\n> > For the avoidance of theft, it is probably better for Bob to wait for Alice-side funding tx to confirm, probably deeply because reorgs suck.\n\nI realized that the *other* improvement I proposed in the [CoinSwapCS issue](https://github.com/AdamISZ/CoinSwapCS/issues/53) would help with this.\nSpecifically, `nLockTime`-protected Backouts.\n\nSuppose we have an S6 route as so, with Alice as taker and Bob1 and Bob2 as makers:\n\n    Alice -> Bob1 -> Bob2 -> Alice\n\nWe assume here that Bob1 and Bob2 directly talk to Alice and that if Bob1 wants to talk to Bob2 it is done via Alice, so in the below if we say \"Bob1 sends to Bob2\" we imply that this is done via Alice.\n\n1.  Alice solicits fresh pubkeys from Bob1 and Bob2.\n2.  Alice gives timeouts L1 and L2 to Bob1, and L2 and L3 to Bob2, such that L1 > L2 > L3, as well as negotiated amount, fees, etc.\n3.  Alice creates (but does NOT sign) a funding tx paying to Alice && Bob1 and gives the txid to Bob1.\n4.  Bob1 creates and signs a tx spending from the Alice funding tx and paying to Alice, with `nLockTime = L1`, and gives the signature to Alice.\n5.  Bob1 creates (but does NOT sign) a funding tx paying to Bob1 && Bob2 and gives the txid to Bob2.\n6.  Bob2 creates and signs a tx spending from the Bob1 funding tx and paying to Bob1, with `nLockTime = L2`, and gives the signature to Bob1.\n7.  Bob2 creates (but does NOT sign) a funding tx paying to Bob2 && Alice and gives the txid to Alice.\n8.  Alice creates and signs a tx spending from the Bob2 funding tx and paying to Bob2, with `nLockTime = L3`, and gives the signature to Bob2.\n9.  Alice signals everyone to sign their respecting funding txes and broadcast them.\n\nThe rest of the CoinSwap protocol executes as normal once the funding txes are deeply confirmed.\nThe only thing that Bob1 (resp. Bob2) needs to wait for is that the signatures for the incoming HTLC / PTLC have been received before forwarding to the next hop.\nThis allows all funding txes to be confirmed in the same block, or even in some suitable random order (by having Alice send the signal out at different times/blocks to different makers).\n\nThe `nLockTime`d backout transactions are sufficient to allow everyone to recover their funds unilaterally in case one of the other funding txes do not confirm.\n\nA similar technique can be done for SAS as well, but this removes the lack of encumbrance in the LTC-side output of SAS, which removes the advantage of having an otherwise unencumbered output.\n\nIn effect, the above creates Spilman unidirectional payment channels along the route, bringing the fiddly timing details offchain where it is less visible to observers.\n\n--\n\nHowever, note that this still allows a form of griefing attack.\nBasically, Alice can induce Bob1 and Bob2 to lock their funds for some time, by completing the above ritual, but not signing and broadcasting its own funding tx.\nBob1 and Bob2 will have been induced to lock their funds for L2 and L3, respectively, while Alice only has to RBF away its own funding tx.\n\nAlice might do this if it is actually another maker and it wants to take out its competitors Bob1 and Bob2, reducing their available liquidity for a time and cornering the SwapMarket.\n\n\nThis can be mitigated by replacing step 9 with:\n\n9.  Alice gives its signed funding tx to Bob1.\n10.  Bob1 gives its signed funding tx to Bob2.\n11.  Bob2 gives its signed funding tx to Alice.\n12.  Alice signals everyone to broadcast their funding txes.\n\nThen Bob1 (resp. Bob2) can monitor the mempool/blockchain and check as well if its outgoing funding tx has been broadcast/confirmed, and if so broadcast the incoming funding tx.\nOr better, if Bob1 (resp. Bob2) does not receive the Alice signal fast enough, it will broadcast its incoming funding tx anyway.\n\nThis is only a mitigation: Alice could have pre-prepared a replacement to the funding tx that it broadcasts near miners just before it signals Bob1 and Bob2 to broadcast all transactions.\n\nFor full protection against griefing attacks, Bob1 (resp. Bob2) have to wait for the incoming funding tx to be confirmed deeply before broadcasting its outgoing funding tx as well.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Chris Belcher",
                "date": "2020-06-05T22:39:47",
                "message_text_only": "Good day ZmnSCPxj,\n\n>>> But S6 has the mild advantage that all the funding transactions paying to 2-of-2s can appear on the same block, whereas chaining swaps will have a particular order of when the transactions appear onchain, which might be used to derive the order of swaps.\n>>\n>> On the other hand, funds claiming in S6 is also ordered in time, so\n>> someone paying attention to the mempool could guess as well the order of\n>> swaps.\n>>\n>> I think this is wrong, and that it's possible for the funding\n>> transactions of chained/routed swaps to all be in the same block as well.\n>>\n>> In CoinSwap it's possible to get DOS'd without the other side spending\n>> money if you broadcast your funding transaction first and the other side\n>> simply disappears. You'd get your money back but you have to waste time\n>> and spend miner fees. The other side didn't spend money to do this, not\n>> even miner fees.\n>>\n>> From the point of view of us as a maker in the route, we know we won't\n>> get DOS'd like this for free if we only broadcast our funding\n>> transaction once we've seen the other side's funding transaction being\n>> broadcast first. This should work as long as the two transactions have a\n>> similar fee rate. There might be an attack involving hash power: If the\n>> other side has a small amount of hash power and mines only their funding\n>> transaction in a manner similar to a finney attack, then our funding\n>> transaction should get mined very soon afterwards by another miner and\n>> the protocol will continue as normal. If the other side has knowledge of\n>> the preimage and uses it to do CPFP and take the money, then we can\n>> learn that preimage and do our own CPFP to get our money back too.\n> \n> How about RBF?\n> \n> A taker Alice can broadcast the funding tx spending its own funds.\n> The funding tx spends funds controlled unilaterally by Alice.\n> Alice can sign a replacement transaction for those funds, spending them to an address with unilateral control, and making the funding tx output with all the obligations attached never get confirmed in the first place.\n> \n> The chances may be small --- Bob can certainly monitor for Alice broadcasting a replacement and counter-broadcast its own replacement --- but the risk still exists.\n> TANSTAAGM (There Aint No Such Thing As A Global Mempool) also means Alice could arrange the replacement by other means, such as not using the RBF-enabled flag, broadcasting the self-paying replacement near miner nodes, and broadcasting the CoinSwap-expected funding tx near the Bob fullnode; Bob fullnode will then reject attempts to replace it, but miners will also reject the CoinSwap-expected funding tx and it will not confirm anyway.\n> \n> \n> With the pre-SAS 4-tx setup, this potentially allows Alice to steal the funds of Bob; after Alice gets its funding-tx-replacement confirmed together with the Bob honest-funding-tx, Alice can use the contract transaction and publish the preimage to take the Bob funds.\n> Since the Alice-side funding tx has been replaced, knowledge of the hash preimage will not help Bob any: the Alice funding tx has been replaced and Bob cannot use the preimage to claim it (it does not exist).\n> \n> \n> With SAS Alice cannot outright steal the Bob funds, but the Bob funds will now be locked in a 2-of-2 and Alice can take it hostage (either Bob gives up on the funds, i.e. donates its value to all HODLers, or Bob gives most of the value to Alice).\n> \n> \n> For the avoidance of theft, it is probably better for Bob to wait for Alice-side funding tx to confirm, probably deeply because reorgs suck.\n> \n> This at least makes it costly to perform this attack; you have to lock more of your funds longer in order to induce a competitor to lock its funds.\n> \n> \n> Come to think of it, the same issue probably holds for S6 as well, the funding tx with the longest timelock has to confirm first before the next is even broadcast, bleah.\n\nYour RBF observation actually blows my idea out of the water. Not just\nbecause of RBF but because of an attack by a miner.\n\nSupposing that Alice starts with knowledge of the hash preimage, if she\nuses RBF to make her funding transaction never confirm but allows Bob's\nfunding transaction to confirm, then Alice can use her preimage to take\nthe money from Bob's funding transaction. Bob will learn the value of\nthe preimage but it won't be much good to him because Alice's funding\ntransaction isn't valid anymore. Alice will get money from her funding\ntransaction and also money from Bob's funding transaction.\n\nBecause of this attack, it's pretty clear that a CoinSwap peer who\nstarts _without_ knowledge of the preimage must wait for the other\nside's funding transaction to actually confirm, perhaps even with\nmultiple confirmations if they fear that the other side has access to\nhashpower. For example, a miner could play the role of Alice and use\nthis attack to almost-risklessly steal Bob's coins using a finney attack.\n\nThat also seems to mean that a N-party routed CoinSwap requires at least\nN blocks to be mined for all the funding transactions to be mined, which\nis a slight setback for user experience. (Although even with today's\nexisting privacy tech, users must hang around waiting for coinjoins to\nbe signed, or waiting for multiple coinjoins to be confirmed.\nBlockchains are inherently slow and we can't get around that.)\n\n\n>>> For the avoidance of theft, it is probably better for Bob to wait for Alice-side funding tx to confirm, probably deeply because reorgs suck.\n> \n> I realized that the *other* improvement I proposed in the [CoinSwapCS issue](https://github.com/AdamISZ/CoinSwapCS/issues/53) would help with this.\n> Specifically, `nLockTime`-protected Backouts.\n> \n> Suppose we have an S6 route as so, with Alice as taker and Bob1 and Bob2 as makers:\n> \n>     Alice -> Bob1 -> Bob2 -> Alice\n> \n> We assume here that Bob1 and Bob2 directly talk to Alice and that if Bob1 wants to talk to Bob2 it is done via Alice, so in the below if we say \"Bob1 sends to Bob2\" we imply that this is done via Alice.\n> \n> 1.  Alice solicits fresh pubkeys from Bob1 and Bob2.\n> 2.  Alice gives timeouts L1 and L2 to Bob1, and L2 and L3 to Bob2, such that L1 > L2 > L3, as well as negotiated amount, fees, etc.\n> 3.  Alice creates (but does NOT sign) a funding tx paying to Alice && Bob1 and gives the txid to Bob1.\n> 4.  Bob1 creates and signs a tx spending from the Alice funding tx and paying to Alice, with `nLockTime = L1`, and gives the signature to Alice.\n> 5.  Bob1 creates (but does NOT sign) a funding tx paying to Bob1 && Bob2 and gives the txid to Bob2.\n> 6.  Bob2 creates and signs a tx spending from the Bob1 funding tx and paying to Bob1, with `nLockTime = L2`, and gives the signature to Bob1.\n> 7.  Bob2 creates (but does NOT sign) a funding tx paying to Bob2 && Alice and gives the txid to Alice.\n> 8.  Alice creates and signs a tx spending from the Bob2 funding tx and paying to Bob2, with `nLockTime = L3`, and gives the signature to Bob2.\n> 9.  Alice signals everyone to sign their respecting funding txes and broadcast them.\n> \n> The rest of the CoinSwap protocol executes as normal once the funding txes are deeply confirmed.\n> The only thing that Bob1 (resp. Bob2) needs to wait for is that the signatures for the incoming HTLC / PTLC have been received before forwarding to the next hop.\n> This allows all funding txes to be confirmed in the same block, or even in some suitable random order (by having Alice send the signal out at different times/blocks to different makers).\n> \n> The `nLockTime`d backout transactions are sufficient to allow everyone to recover their funds unilaterally in case one of the other funding txes do not confirm.\n> \n> A similar technique can be done for SAS as well, but this removes the lack of encumbrance in the LTC-side output of SAS, which removes the advantage of having an otherwise unencumbered output.\n> \n> In effect, the above creates Spilman unidirectional payment channels along the route, bringing the fiddly timing details offchain where it is less visible to observers.\n\nI think I'm having trouble understanding this, does it work like this:\n\nSay we're in the 2-party coinswap case (Alice and Bob)\n\nWe have Alice's funding transaction:\n   Alice UTXO ---> 2of2 multisig (Alice+Bob)\n\nAnd we have the regular contract transaction\n   2of2 multisig (Alice+Bob) ---> Alice+timelock1 OR Bob+hashlock\n\nAnd you propose a second pre-signed transaction?\n   2of2 multisig (Alice+Bob) ---> Bob+timelock2\n\nWhere timelock2 > timelock1\n\nIf that's the protocol, then it's vulnerable to an attack. Once the\npreimage is revealed we should be in a situation where Bob can\nunilaterally get his coins back by broadcasting the regular contract\ntransaction and using the preimage to immediately get his coins. That\nmeans Alice will be happy to hand over her private key, just to save\nminer fees and improve privacy. But if the second pre-signed transaction\nexists then Alice could do an attack where she broadcasts it and gets it\nmined (perhaps more successfully if she has some hashpower). Once it's\nmined then the regular contract transaction becomes invalid and Bob\ncan't get his money, in other words Bob doesn't have unilateral control\nover those coins."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-06T01:40:18",
                "message_text_only": "Good morning Chris,\n\n> I think I'm having trouble understanding this, does it work like this:\n>\n> Say we're in the 2-party coinswap case (Alice and Bob)\n>\n> We have Alice's funding transaction:\n> Alice UTXO ---> 2of2 multisig (Alice+Bob)\n>\n> And we have the regular contract transaction\n> 2of2 multisig (Alice+Bob) ---> Alice+timelock1 OR Bob+hashlock\n>\n> And you propose a second pre-signed transaction?\n> 2of2 multisig (Alice+Bob) ---> Bob+timelock2\n\nNo, it is:\n\n2of2 multisig (Alice+Bob) --(nLockTime=locktime1)-> Alice\n\nThe timelock is  imposed as a `nLockTime`, not as an `OP_CLTV` (so not in the output of the tx, but part of the tx), and the backout returns the funds to Alice, not sends it to Bob.\nThis transaction is created *before* the contract transaction.\n\nThe order is:\n\n* Create (but not sign) Alice funding tx (Alice --> Alice+Bob).\n* Create and sign Alice backout transaction (Alice+Bob -(nLockTime=locktime1)-> Alice).\n* Create (but not sign) Bob funding tx (Bob --> Alice+Bob+sharedSecret).\n* Create and sign Bob backout transaction (Alice+Bob+sharedSecret -(nLocktime=locktime2)-> Bob) where timelock2 < timelock1.\n* Sign and broadcast funding txes.\n  * At this point, even if Bob funding tx is confirmed but Alice funding tx is not, Bob can recover funds with the backout, but Alice cannot steal the funds (since there is no hashlock branch at this point).\n* When Alice funding tx is confirmed, create and sign contract transaction (Alice+Bob --> Alice+timelock1 OR Bob+hashlock).\n* When Bob funding tx is confirmed and Bob has received the Alice contract transaction, create and sign Bob contract transaction (Alice+Bob+sharedSecret --> Bob+timelock2 OR Alice+hashlock).\n* Continue as normal.\n\nIn effect, the backout transaction creates a temporary Spilman unidirectional time-bound channel.\nWe just reuse the same timelock on the HTLC we expect to instantiate, as the time bound of the Spilman channel; the timelock exists anyway, we might as well reuse it for the Spilman.\n\nCreation of the contract tx invalidates the backout tx (the backout tx is `nLockTime`d, the contract tx has no such encumbrance), but the backout allows Alice and Bob to fund their txes simultaneously without risk of race loss.\nHowever, they do still have to wait for (deep) confirmation before signing contract transactions, and Bob has to wait for the incoming contract transaction as well before it signs its outgoing contract transaction.\n\nThe protocol is trivially extendable with more than one Bob.\n\nThe insight basically is that we can split CoinSwap into a \"channel establishment\" phase and \"HTLC forwarding\" phase followed by \"HTLC resolution\" and \"private key handover\".\nHTLC forwarding and HTLC resolution are \"done offchain\" in the channels, and channel establishment can be done in any order, including reverse.\n\nIndeed, the Spilman channel need not have the same timelock as the HTLC it will eventually host: it could have a shorter timelock, since the contract transaction has no `nLockTime` it can be instantiated (with loss of privacy due to the nonstandard script) before the Spilman timeout.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-06T03:59:30",
                "message_text_only": "Good morning again Chris,\n\nI am uncertain if you are aware, but some years ago somebody claimed that 2p-ECDSA could use Scriptless Script as well over on lightning-dev.\n\n* https://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180426/fe978423/attachment-0001.pdf\n* https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-April/001221.html\n\nI cannot claim to follow the math enough to say it is actually secure, but the idea does exist.\n\nIf this is sufficiently secure, we can fold the Spilman backout into the scriptless script swap as well.\n\n* Alice creates secret keypairs A[0] = a[0] * G, A[1] = a[1] * G\n* Bob creates secret keypairs B[0] = b[0] * G, B[1] = b[1] * G\n* Alice creates (but does not sign) funding from Alice -> A[0] && B[0]\n* Bob provides partial signature for A[0] && B[0] -(nLockTime=locktime1)-> Alice to Alice and Alice completes this signature and stashes it.\n* Bob creates (but does not sign) funding from Bob -> A[1] && B[1]\n* Alice provides partial signature for A[1] && B[1] -(nLockTime=lockTime2)-> Bob to Bob and Bob completes this signature and stashes it.\n* Alice and Bob sign and broadcast their funding transactions.\n  * This can safely be done in any order; Bob will refuse to continue with the protocol until it sees Alice funding is confirmed, and will abort if locktime2 is too near.\n* Alice waits for Bob funding tx to confirm.\n* Alice provides a 2p-ECDSA adaptor signature for A[1] && B[1] --> Alice; the adaptor signature, when completed, reveals the secret a[0] to Bob.\n* Bob waits for Alice funding tx to confirm.\n* Bob provides the partial signature for the given adaptor signature for A[1] && B[1] --> Alice and  Alice completes this signature and stashes it.\n* Alice gives a[0] outright to Bob.\n* Bob gives b[1] outright to Alice.\n* Alice spends the A[1] && B[1] output before locktime2.\n* Bob spends the A[0] && B[0] output before locktime1.\n\nI also pointed out the griefing problem in Lightning also applies to SwapMarket.\nBob can limit the griefing problem by requiring that locktime2 <= now + 12, and requiring that locktime1 >= now + 60.\nThis means that Alice has to lock its funds for 10 hours if it forces Bob to lock its funds for 2 hours, making it undesirable as an attack on competing makers.\nThis does prevent chaining (no maker is going to accept the outgoing), but if Alice wants chaining it can always use the private key handed over to immediately start a funding tx with another Bob.\n\n(This is not a good solution for griefing in the Lightning Network since channels are intended to be reused there, whereas the Spilman channels in CoinSwap exist only to allow funding transactions to confirm in any order onchain, and are used only for the specific swap; in Lightning the forwarding node has an incentive to release the incoming HTLC immediately instead of imposing the incoming wait time since the funding can be reused for a different payment, but in CoinSwap it cannot be reused anyway, so it could just let the incoming timelock lapse instead of releasing that encumbrance as would be done in Lightning.)\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-06T04:25:11",
                "message_text_only": "Good morning a third time Chris,\n\nNow unrelated to the funding order, but one of the reasons why timeliness is desirable for CoinSwap is that if possible, we want to ensure that sends from a user wallet are not correlatable with receives into that wallet.\nThus, there is the strong suggestion that before sending to a payee, the user wallet should swap, then use the swapped funds to pay the payee, i.e. swap-on-pay.\nJoinMarket does this in `sendpayment.py`, for example, and this is the recommended way to perform payments out of the JoinMarket wallet.\n\nLet me propose an alternative: swap-on-receive+swap-on-change.\n\nZeroLink already suggests that wallets maintain two internal wallets: a pre-mix wallet and a post-mix wallet.\nWith swap-on-receive, when the user wants a receive address, the wallet gets it from the pre-mix wallet address.\nThen, when wallet notices any unspent funds on any pre-mix wallet address, the wallet automatically swaps it into the post-mix wallet.\nThis is swap-on-receive.\nLong-term HODLing goes into post-mix wallet addresses.\n\nThen, when sending, the wallet selects from the post-mix wallet coins, and spends those coins directly into the payee address.\nIf there is no exact amount, it has to have change.\nThe change output does *not* go to the pre-mix or post-mix wallet address.\nInstead, it goes to a 2-of-2 funding outpoint for a new swap immediately.\n\nThis lets the payee receive its funds quickly, as soon as the transaction confirms, without waiting for the CoinSwap to complete.\nOf course, the user now has to be online to *fully* receive funds (the user cannot spend the funds until it is in the post-mix wallet).\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Chris Belcher",
                "date": "2020-06-10T10:15:36",
                "message_text_only": "Good morning ZmnSCPxj,\n\nOn 06/06/2020 02:40, ZmnSCPxj wrote:\n> Good morning Chris,\n> \n>> I think I'm having trouble understanding this, does it work like this:\n>>\n>> Say we're in the 2-party coinswap case (Alice and Bob)\n>>\n>> We have Alice's funding transaction:\n>> Alice UTXO ---> 2of2 multisig (Alice+Bob)\n>>\n>> And we have the regular contract transaction\n>> 2of2 multisig (Alice+Bob) ---> Alice+timelock1 OR Bob+hashlock\n>>\n>> And you propose a second pre-signed transaction?\n>> 2of2 multisig (Alice+Bob) ---> Bob+timelock2\n> \n> No, it is:\n> \n> 2of2 multisig (Alice+Bob) --(nLockTime=locktime1)-> Alice\n> \n> The timelock is  imposed as a `nLockTime`, not as an `OP_CLTV` (so not in the output of the tx, but part of the tx), and the backout returns the funds to Alice, not sends it to Bob.\n> This transaction is created *before* the contract transaction.\n> \n> The order is:\n> \n> * Create (but not sign) Alice funding tx (Alice --> Alice+Bob).\n> * Create and sign Alice backout transaction (Alice+Bob -(nLockTime=locktime1)-> Alice).\n> * Create (but not sign) Bob funding tx (Bob --> Alice+Bob+sharedSecret).\n> * Create and sign Bob backout transaction (Alice+Bob+sharedSecret -(nLocktime=locktime2)-> Bob) where timelock2 < timelock1.\n> * Sign and broadcast funding txes.\n>   * At this point, even if Bob funding tx is confirmed but Alice funding tx is not, Bob can recover funds with the backout, but Alice cannot steal the funds (since there is no hashlock branch at this point).\n> * When Alice funding tx is confirmed, create and sign contract transaction (Alice+Bob --> Alice+timelock1 OR Bob+hashlock).\n> * When Bob funding tx is confirmed and Bob has received the Alice contract transaction, create and sign Bob contract transaction (Alice+Bob+sharedSecret --> Bob+timelock2 OR Alice+hashlock).\n> * Continue as normal.\n> \n> In effect, the backout transaction creates a temporary Spilman unidirectional time-bound channel.\n> We just reuse the same timelock on the HTLC we expect to instantiate, as the time bound of the Spilman channel; the timelock exists anyway, we might as well reuse it for the Spilman.\n> \n> Creation of the contract tx invalidates the backout tx (the backout tx is `nLockTime`d, the contract tx has no such encumbrance), but the backout allows Alice and Bob to fund their txes simultaneously without risk of race loss.\n> However, they do still have to wait for (deep) confirmation before signing contract transactions, and Bob has to wait for the incoming contract transaction as well before it signs its outgoing contract transaction.\n> \n> The protocol is trivially extendable with more than one Bob.\n> \n> The insight basically is that we can split CoinSwap into a \"channel establishment\" phase and \"HTLC forwarding\" phase followed by \"HTLC resolution\" and \"private key handover\".\n> HTLC forwarding and HTLC resolution are \"done offchain\" in the channels, and channel establishment can be done in any order, including reverse.\n> \n> Indeed, the Spilman channel need not have the same timelock as the HTLC it will eventually host: it could have a shorter timelock, since the contract transaction has no `nLockTime` it can be instantiated (with loss of privacy due to the nonstandard script) before the Spilman timeout.\n> \n> Regards,\n> ZmnSCPxj\n> \n\nThanks for the explanation. I understand now, and I understand how this\nmakes it possible for all funding transactions in a coinswap route to be\nconfirmed in the same block.\n\nHowever, I think this also breaks private key handover. Here's why:\n\nRecall that in a Alice/Bob coinswap we have two funding transactions\n(Alice --> multisig(Alice, Bob) and Bob --> multisig(Bob,Alice)), and\ntwo contract transactions (multisig(Alice, Bob) -->\nAlice+OP_CSV_timelock OR Bob+hashlock and multisig(Bob,Alice -->\nBob+OP_CSV_timelock OR Alice+hashlock). After the hashlock preimage\nbecomes known to all then Alice and Bob give their multisig privkey to\nthe other party.\n\nBob now has both privkeys in the multisig(Alice,Bob) so he can sign any\ntransaction he wants spending from it, but the contract transaction\nstill exists. So until Bob actually spends from the multisig he must\nalways be watching the blockchain, and if Alice broadcasts the contract\ntransaction then Bob must immediately spend from it using the hash\npreimage branch. If Bob waits too long and the OP_CSV timelock value\npasses then Alice can steal Bob's money by spending with that path. The\nOP_CSV timelock only starts ticking when the contract transaction\nactually confirms, and this is crucial for making privkey handover\npractical because it means the coins in the multisig can stay unspent\nindefinitely.\n\nHowever, I think this does not apply to the scheme you described which\nuses nLockTime, because after the privkeys are handed over Alice's\nbackout transaction (Alice+Bob -(nLockTime=locktime1)-> Alice) still\nexists, and Alice could broadcast it. Once locktime1 passes then Alice\ncan steal Bob's coins by broadcasting even though Bob holds both\nprivkeys to that multisig. And using relative nLockTime doesn't help\neither because its timelock will start ticking down from when the\nfunding transaction is confirmed, not when the contract transaction is\nconfirmed, and so the coins in the multisig cant remain unspent\nindefinitely.\n\nSo fundamentally I think privkey handover gets broken here because it\nrequires relative timelocks. And those the relative timelocks need to\nstart ticking down only after a contract transaction is confirmed.\n\n\n> I am uncertain if you are aware, but some years ago somebody claimed that 2p-ECDSA could use Scriptless Script as well over on lightning-dev.\n\nI was aware. In such a scheme we'd still require the other building\nblocks like fidelity bonds, multi-transaction and routing. So I was\nthinking to code the project using the simplest hash-time-locked\ncontracts and once it all works we can add things like ECDSA-2P\nscriptless scripts or schnorr signatures when they get added. Making the\nSpilman channel scheme work with that is an interesting idea, thanks for\nthe thought.\n\n> Let me propose an alternative: swap-on-receive+swap-on-change.\n\nThat's an interesting point, thanks for the thought. This scheme might\nnot be appropriate for every threat model and use case.\nFor example, if someone wants to use bitcoin just as a foreign currency\nfor its privacy and censorship-resistant properties. So for example if\nthey want to pay for a VPN anonymously, so they buy bitcoins and\nimmediately send all of them to the VPN merchant. The swap-on-receive\nwouldn't be appropriate for them because they'll be doing a coinswap\nstraight away to the VPN merchant. So perhaps this plan could be an\noptional mode of operation (which may or may not be the default). The\nscheme obviously is useful when bitcoin is being used more as a\nday-to-day money.\n\n\nRegards\nCB"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-10T10:58:03",
                "message_text_only": "Good morning Chris,\n\n> > Let me propose an alternative: swap-on-receive+swap-on-change.\n>\n> That's an interesting point, thanks for the thought. This scheme might\n> not be appropriate for every threat model and use case.\n> For example, if someone wants to use bitcoin just as a foreign currency\n> for its privacy and censorship-resistant properties. So for example if\n> they want to pay for a VPN anonymously, so they buy bitcoins and\n> immediately send all of them to the VPN merchant. The swap-on-receive\n> wouldn't be appropriate for them because they'll be doing a coinswap\n> straight away to the VPN merchant. So perhaps this plan could be an\n> optional mode of operation (which may or may not be the default). The\n> scheme obviously is useful when bitcoin is being used more as a\n> day-to-day money.\n\n\nNo, I think you misunderstand my proposal.\n\nIf the user is doing swap-on-receive, the user already has an anonymous UTXO, they can just transfer it directly in full to the VPN without using a CoinSwap.\n\nThe number of CoinSwaps involved is the same: one.\n\nSo the difference is:\n\n* swap-on-receive:\n  * I get some coins from an exchange, giving them my contact information and bank information and all the places I have ever inhabited in my entire existence and an unfertilized egg sample and an archive of my diary and let them invasively scan my cognitive substrate.\n  * I send the coins to my CoinSwap wallet.\n  * The CoinSwap wallet automaticaly CoinSwaps the coins into a new UTXO.\n    * One CoinSwap.\n  * I tell the CoinSwap wallet to send it all to the VPN.\n    * My CoinSwap wallet knows my coins are already cleaned, so it creates a plain 1-input 1-output transaction directly to the VPN address.\n\n* swap-on-pay:\n  * I get some coins from an exchange, giving them my contact information and bank information and all the places I have ever inhabited in my entire existence and an unfertilized egg sample and an archive of my diary and let them invasively scan my cognitive substrate.\n  * I send the coins to my CoinSwap wallet.\n  * I tell the CoinSwap wallet to send it all to the VPN.\n    * My CoinSwap wallet automatically arranges a CoinSwap into the VPN address.\n      * One CoinSwap.\n\nSo in both cases the same expected number of CoinSwaps is done, i.e. one.\n\nNote that there are still details like how much onchain fees are and how much CoinSwap maker fees are and etc etc but they exist for both flows anyway.\nSo I would still be buying slightly more than my target amount, and if there is any change I could just designate it to be added to the mining fees or a donation to ZmnSCPxj, because ZmnSCPxj is so awesome.\n\nWhat swap-on-receive+swap-on-change instead does is just amortize the timing of the CoinSwaps, so that you CoinSwap as soon as you receive, instead of as soon as you have to pay, so that sending payments is as fast as non-CoinSwap onchain wallets.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Chris Belcher",
                "date": "2020-06-10T11:19:53",
                "message_text_only": "Hello ZmnSCPxj,\n\nOn 10/06/2020 11:58, ZmnSCPxj wrote:\n> Good morning Chris,\n> \n>>> Let me propose an alternative: swap-on-receive+swap-on-change.\n>>\n>> That's an interesting point, thanks for the thought. This scheme might\n>> not be appropriate for every threat model and use case.\n>> For example, if someone wants to use bitcoin just as a foreign currency\n>> for its privacy and censorship-resistant properties. So for example if\n>> they want to pay for a VPN anonymously, so they buy bitcoins and\n>> immediately send all of them to the VPN merchant. The swap-on-receive\n>> wouldn't be appropriate for them because they'll be doing a coinswap\n>> straight away to the VPN merchant. So perhaps this plan could be an\n>> optional mode of operation (which may or may not be the default). The\n>> scheme obviously is useful when bitcoin is being used more as a\n>> day-to-day money.\n> \n> \n> No, I think you misunderstand my proposal.\n> \n> If the user is doing swap-on-receive, the user already has an anonymous UTXO, they can just transfer it directly in full to the VPN without using a CoinSwap.\n> \n> The number of CoinSwaps involved is the same: one.\n> \n> So the difference is:\n> \n> * swap-on-receive:\n>   * I get some coins from an exchange, giving them my contact information and bank information and all the places I have ever inhabited in my entire existence and an unfertilized egg sample and an archive of my diary and let them invasively scan my cognitive substrate.\n>   * I send the coins to my CoinSwap wallet.\n>   * The CoinSwap wallet automaticaly CoinSwaps the coins into a new UTXO.\n>     * One CoinSwap.\n>   * I tell the CoinSwap wallet to send it all to the VPN.\n>     * My CoinSwap wallet knows my coins are already cleaned, so it creates a plain 1-input 1-output transaction directly to the VPN address.\n> \n> * swap-on-pay:\n>   * I get some coins from an exchange, giving them my contact information and bank information and all the places I have ever inhabited in my entire existence and an unfertilized egg sample and an archive of my diary and let them invasively scan my cognitive substrate.\n>   * I send the coins to my CoinSwap wallet.\n>   * I tell the CoinSwap wallet to send it all to the VPN.\n>     * My CoinSwap wallet automatically arranges a CoinSwap into the VPN address.\n>       * One CoinSwap.\n> \n> So in both cases the same expected number of CoinSwaps is done, i.e. one.\n> \n> Note that there are still details like how much onchain fees are and how much CoinSwap maker fees are and etc etc but they exist for both flows anyway.\n> So I would still be buying slightly more than my target amount, and if there is any change I could just designate it to be added to the mining fees or a donation to ZmnSCPxj, because ZmnSCPxj is so awesome.\n> \n> What swap-on-receive+swap-on-change instead does is just amortize the timing of the CoinSwaps, so that you CoinSwap as soon as you receive, instead of as soon as you have to pay, so that sending payments is as fast as non-CoinSwap onchain wallets.\n> \n> \n> Regards,\n> ZmnSCPxj\n> \n\nRight, I get it. Good explanation.\n\nIn your swap-on-receive example the exchange also can't tell how long\nyour coins remain unspent in your wallet, which they could in\nswap-on-pay. This is very useful information for an exchange because it\ntells them about what hodlers are doing, and they might trade against\nthem. (e.g. opening big short positions right after they see many long\nterm hodl'd coins being moved)"
            },
            {
                "author": "Mr. Lee Chiffre",
                "date": "2020-06-10T00:43:40",
                "message_text_only": ">\n> === Combining multi-transaction with routing ===\n>\n> Routing and multi-transaction must be combined to get both benefits. If\n> Alice owns multiple UTXOs (of value 6 BTC, 8 BTC and 1 BTC) then this is\n> easy with this configuration:\n>\n>              Alice\n>     (6 BTC) (8 BTC) (1 BTC)\n>        |       |       |\n>        |       |       |\n>        v       v       v\n>               Bob\n>     (5 BTC) (5 BTC) (5 BTC)\n>        |       |       |\n>        |       |       |\n>        v       v       v\n>             Charlie\n>     (9 BTC) (5 BTC) (1 BTC)\n>        |       |       |\n>        |       |       |\n>        v       v       v\n>             Dennis\n>     (7 BTC) (4 BTC) (4 BTC)\n>        |       |       |\n>        |       |       |\n>        v       v       v\n>              Alice\n>\n\n\n\n\n\n\nGreat work Chris and you have my respects for your contributions to\nBitcoin. A concern I have with bitcoin is scalability and privacy. Both\nare important. The reasons people bash on Monero is also the same issue\nBitcoin has. The very large transaction size to achieve acceptable privacy\non a distributed financial network. Im not shilling Monero here. I am only\nsaying that bitcoin transactions with similar privacy properties are at\nleast equally as large as Monero transactions. Coinjoin on Monero can be\ncompared to ring signatures in Monero from the view of using decoys to\nhelp conceal the source. From this proposal is this to say that\ntransactions will be at least 12 times larger in size to achieve the\nproperty of privacy that bitcoin is currently missing?\n\nAnother thing to consider is that if coinswaps cannot be sent as a payment\nthen a coinswap needs to take place after every transaction to keep the\nprivacy and unlinkability from your other bitcoin transactions.\n\nI always thought that CoinSwap would be and is a very much needed thing\nthat needs developed. The ability to swap coins with other people in a\ntrustless way and way that is not linkable to the public blockchain. But\nhow can this be scalable at all with the multiple branches and layers?\nThis is a good idea in theory but my concern would be the scalability\nissues this creates.\n\nDo you have any comments on this?\nThank you\n\n\n-- \nlee.chiffre at secmail.pro\nPGP 97F0C3AE985A191DA0556BCAA82529E2025BDE35"
            },
            {
                "author": "Mr. Lee Chiffre",
                "date": "2020-06-10T00:46:41",
                "message_text_only": "> Coinjoin on Monero can be\n> compared to ring signatures in Monero from the view of using decoys to\n> help conceal the source. From this proposal is this to say that\n> transactions will be at least 12 times larger in size to achieve the\n> property of privacy that bitcoin is currently missing?\n>\n\n\nThis was a typo. Coinjoin on BITCOIN, can be compared to ring signatures\nin Monero form the view of using decoys to help conceal the source.\n\n\nThe same thing that makes monero transactions large and a scalability\nconcern is the same thing that bitcoin suffers from with using privacy\nfocused transactions."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-10T07:09:04",
                "message_text_only": "Good morning Mr. Lee,\n\n\n> > === Combining multi-transaction with routing ===\n> > Routing and multi-transaction must be combined to get both benefits. If\n> > Alice owns multiple UTXOs (of value 6 BTC, 8 BTC and 1 BTC) then this is\n> > easy with this configuration:\n> >\n> >              Alice\n> >     (6 BTC) (8 BTC) (1 BTC)\n> >        |       |       |\n> >        |       |       |\n> >        v       v       v\n> >               Bob\n> >     (5 BTC) (5 BTC) (5 BTC)\n> >        |       |       |\n> >        |       |       |\n> >        v       v       v\n> >             Charlie\n> >     (9 BTC) (5 BTC) (1 BTC)\n> >        |       |       |\n> >        |       |       |\n> >        v       v       v\n> >             Dennis\n> >     (7 BTC) (4 BTC) (4 BTC)\n> >        |       |       |\n> >        |       |       |\n> >        v       v       v\n> >              Alice\n> >\n>\n> Great work Chris and you have my respects for your contributions to\n> Bitcoin. A concern I have with bitcoin is scalability and privacy. Both\n> are important. The reasons people bash on Monero is also the same issue\n> Bitcoin has. The very large transaction size to achieve acceptable privacy\n> on a distributed financial network. Im not shilling Monero here. I am only\n> saying that bitcoin transactions with similar privacy properties are at\n> least equally as large as Monero transactions. Coinjoin on Monero can be\n> compared to ring signatures in Monero from the view of using decoys to\n> help conceal the source. From this proposal is this to say that\n> transactions will be at least 12 times larger in size to achieve the\n> property of privacy that bitcoin is currently missing?\n\nCoinSwap lets you buy privacy at whatever rate is manageable for you.\nYou can buy a simple non-routed non-multitransaction CoinSwap, for example, instead of larger sections like the above, depending on your privacy needs.\nEven doing a non-routed non-multitransaction CoinSwap would help fungibility of those doing more complex setups, because the tiny CoinSwaps you make are made of \"the same things\" that the more complex CoinSwaps are made of.\n\n>\n> Another thing to consider is that if coinswaps cannot be sent as a payment\n> then a coinswap needs to take place after every transaction to keep the\n> privacy and unlinkability from your other bitcoin transactions.\n>\n> I always thought that CoinSwap would be and is a very much needed thing\n> that needs developed. The ability to swap coins with other people in a\n> trustless way and way that is not linkable to the public blockchain. But\n> how can this be scalable at all with the multiple branches and layers?\n> This is a good idea in theory but my concern would be the scalability\n> issues this creates.\n>\n> Do you have any comments on this?\n> Thank you\n\nOverall, multiple mixing techniques cover a wide range of cost and privacy.\n\n* PayJoins are cheap and almost free (you are coordinating with only one other participant who is strongly incentivized to cooperate with you, and making a single overall tx) but buys you only a small dollop of privacy (transaction can be misinterpreted by chain analysis, but probabilistic analysis can be \"reasonably accurate\" for a few transactions).\n* Equal-valued CoinJoins are slightly more expensive than PayJoins but give a good amount of privacy (you are coordinating with multiple participants, and probably paying coordination/participation fees, but *which* output is yours will give probabilistic analysis a run for its money, although it is obvious that you *did* participate in a CoinJoin).\n* CoinSwaps are a good bit more expensive than equal-valud CoinJoins but give a significant amount of privacy for their cost (you are coordinating with multiple participants and paying coordination/participation fees *and* you run the risk of getting your funds timelocked in case of network communications problems or active hacking attempts, but it is hard for chain analysis to even *realize* that a CoinSwap even occurred, i.e. it is steganographic).\n\nChris argues that CoinSwap gives better privacy:cost ratios than equal-valued CoinJoins, you can wait and see if he gives more supporting arguments regarding this, but overall the various mixing tech exists to give choice on how much privacy you buy.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Chris Belcher",
                "date": "2020-06-10T11:15:03",
                "message_text_only": "Hello Lee,\n\nThanks for the review.\n\nOn 10/06/2020 01:43, Mr. Lee Chiffre wrote:\n> \n>>\n>> === Combining multi-transaction with routing ===\n>>\n>> Routing and multi-transaction must be combined to get both benefits. If\n>> Alice owns multiple UTXOs (of value 6 BTC, 8 BTC and 1 BTC) then this is\n>> easy with this configuration:\n>>\n>>              Alice\n>>     (6 BTC) (8 BTC) (1 BTC)\n>>        |       |       |\n>>        |       |       |\n>>        v       v       v\n>>               Bob\n>>     (5 BTC) (5 BTC) (5 BTC)\n>>        |       |       |\n>>        |       |       |\n>>        v       v       v\n>>             Charlie\n>>     (9 BTC) (5 BTC) (1 BTC)\n>>        |       |       |\n>>        |       |       |\n>>        v       v       v\n>>             Dennis\n>>     (7 BTC) (4 BTC) (4 BTC)\n>>        |       |       |\n>>        |       |       |\n>>        v       v       v\n>>              Alice\n>>\n> \n> \n> \n> \n> \n> \n> Great work Chris and you have my respects for your contributions to\n> Bitcoin. A concern I have with bitcoin is scalability and privacy. Both\n> are important. The reasons people bash on Monero is also the same issue\n> Bitcoin has. The very large transaction size to achieve acceptable privacy\n> on a distributed financial network. Im not shilling Monero here. I am only\n> saying that bitcoin transactions with similar privacy properties are at\n> least equally as large as Monero transactions. Coinjoin on Monero can be\n> compared to ring signatures in Monero from the view of using decoys to\n> help conceal the source. From this proposal is this to say that\n> transactions will be at least 12 times larger in size to achieve the\n> property of privacy that bitcoin is currently missing?\n> \n> Another thing to consider is that if coinswaps cannot be sent as a payment\n> then a coinswap needs to take place after every transaction to keep the\n> privacy and unlinkability from your other bitcoin transactions.\n> \n> I always thought that CoinSwap would be and is a very much needed thing\n> that needs developed. The ability to swap coins with other people in a\n> trustless way and way that is not linkable to the public blockchain. But\n> how can this be scalable at all with the multiple branches and layers?\n> This is a good idea in theory but my concern would be the scalability\n> issues this creates.\n> \n> Do you have any comments on this?\n> Thank you\n> \n\nYou are right to be concerned about scalability.\n\nHere's a few of my thoughts on this:\n\nAn issue with Monero (or any cryptocurrency based on the ring signature\ninput signing scheme) isn't just that transactions are bigger in bytes.\nMonero full nodes can't know when a TXO has been spent, so pruning is\nimpossible in Monero and the list of TXOs perpetually grows, this is\nunlike in bitcoin where full nodes know if a UTXO has been spent and so\ncan delete it in pruning. The storage space needed for Bitcoin's UTXO\nset sometimes actually gets smaller.\n\nNote that Monero software actually has a feature called \"pruning\" so\nsometimes the terminology gets confused when people say \"wait, Monero\n_does_ have pruning\". But this pruning doesn't do the same thing as\nBitcoin's pruning, the disk space still grows as O(TXOcount) which is\nmuch faster compared to Bitcoin's O(UTXOcount).\n\nAnd when designing this CoinSwap system I've been careful to make sure\nit doesn't break pruning (or other resources saving features, for\nexample CoinSwap can be made to work with the blocksonly feature of\nBitcoin Core). So bitcoin-with-CoinSwap's scalability isnt anywhere near\nas bad as Monero's.\n\nYou're right to talk about decoys. Decoys are not a good way to obtain\nprivacy because they can be broken by repeated interactions.. I really\nlike this talk about why decoys are not a good solution to privacy in\nmany cases:\n\ntalk: https://www.youtube.com/watch?v=YgtF7psIKWg&feature=youtu.be&t=3701\ntranscript:\nhttps://tokyo2018.scalingbitcoin.org/transcript/tokyo2018/how-much-privacy-is-enough\n\nEqual-output CoinJoins also work with decoys. Like in JoinMarket you\ncould analyze those CoinJoins to say that the inputs and outputs of the\nmakers in a CoinJoin are actually just decoys. Fixed-denomination\nCoinJoins like in Wasabi or Samourai also use much more block space\nbecause of the reduced divisibility, for example Wasabi coinjoins can\nonly be done with about 0.1 BTC, so if you want to mix 1 BTC then you\nhave to do 10 such CoinJoins, costing 10 times the block space.\n\nCoinSwap doesn't work by adding decoys, it improves privacy in the same\nway as Lightning: by moving information off-chain.\n\nYou could perhaps analyze CoinSwap as using decoys if you say that the\ndecoys are almost every other bitcoin transaction happening on the\nblockchain, and that can be almost as big as you want. One full block\nhas about 3000 outputs, so if you wait a day between the CoinSwap\nfunding and spending transactions then that's 144*3000 = 432000 decoys\n(this calculation is simplified, but it's a good starting point). If\nCoinJoin or Monero transactions had that many decoys they would be\nhundreds of MB each.\n\n\nBecause CoinSwap transactions can look exactly the same as regular\ntransactions, they would improve the privacy of users even if they don't\nuse CoinSwap.\n\nSo on twitter sometimes I see people talking about \"making every spend a\nCoinJoin\". The suggestion would be very costly in block space, and isn't\nnecessary for CoinSwap. I think perhaps 5% of transactions being\nCoinSwaps or PayJoin-with-CoinSwap (as long as they were spread roughly\nequally across the economy) would be enough to destroy the transaction\ngraph heuristic and common-input-ownership heuristic. Then anyone\nanalyzing the blockchain couldn't be sure when they see coins going from\naddress A to B that the ownership actually went from A to B, or that if\nthey see multiple inputs they don't know whether those inputs are\nactually owned by the same entity.\n\nAlso, CoinSwaps could be used as payment. For example take this 1-hop\nCoinSwap where Alice owns 10 BTC and wants to deposit 5 BTC into her\nexchange account.\n\n      (3 BTC) -->     (5 BTC) --> Exchange\nAlice (1 BTC) --> Bob (4 BTC) --> Alice change1\n      (6 BTC) -->     (1 BTC) --> Alice change2\n\nSo on the last hop Alice sends 5 BTC as payment to the exchange (to\ndeposit) and the remaining outputs go back to Alice as change. The\nexchange can't see Alice's UTXOs that she just spent, and also can't see\nAlice's change outputs.\n\n\nAdditionally, even in the example you use where 12 times as much block\nspace is used as normal, this is still cheaper than Equal-Output\nCoinjoins. For example with JoinMarket a single CoinJoin is\napproximately 12 times bigger than a regular bitcoin transaction, and to\nget good privacy using JoinMarket's tumbler algorithm the user typically\ncreates 7-15 of those CoinJoins. And even then those CoinJoins are very\nobvious and don't improve the privacy of people who don't use them,\nmeaning we have to advocate the expensive and impractical slogan \"make\nevery spend a CoinJoin\". And they also don't provide as much privacy as\nCoinSwap would, because their anonymity set is smaller than CoinSwap's.\n\n\nFinally, we know that blockchains don't scale, and so its widely\nexpected that most day-to-day bitcoin transactions will happen off-chain\non something like Lightning network, which also brings us privacy.\nCoinSwap then is mostly useful for the situations where on-chain\ntransfers are still needed, and also because good on-chain privacy is\nnecessary for Lightning to really be private, because otherwise the\non-chain channel UTXOs can be tracked."
            },
            {
                "author": "Jonas Nick",
                "date": "2020-06-19T15:33:09",
                "message_text_only": "> [...] we can use 2-party ECDSA to create 2-of-2 multisignature addresses that\n> look the same as regular single-signature addresses[2]. Even the old-style\n> p2pkh addresses starting with 1 can be CoinSwap addresses.\n\nProbably worth considering that p2pkh, p2wpkh and p2sh are vulnerable to the\n(well-known) birthday attack with 2^80 operations on average if they encode a\nmultisig policy [0]. This is a large number but not the security margin we are\nused to.\n\nIt is possible to reduce the feasibility of the attack by requiring 2^80\ninteractions instead of purely offline operations. This works by adding a\ncommitment round for all public keys involved in the policy. Now in order to\ntest whether a public key results in a collision, the attacker must first engage\nin a commitment protocol with that public key. The \"Fast Secure Two-Party ECDSA\nSigning\" protocol by Lindell [1] already has such a commitment round (for\nreasons unrelated to Bitcoin). For example, the Gotham City two-party ECDSA\nwallet [2] has this security model because it builds on the Lindell scheme and\nuses p2sh-p2wpkh.\n\n[0] https://bitcoin.stackexchange.com/questions/54841/birthday-attack-on-p2sh\n[1] https://eprint.iacr.org/2017/552.pdf\n[2] https://github.com/KZen-networks/gotham-city\n\n\nOn 5/25/20 1:21 PM, Chris Belcher via bitcoin-dev wrote:\n> === Abstract ===\n> \n> Imagine a future where a user Alice has bitcoins and wants to send them\n> with maximal privacy, so she creates a special kind of transaction. For\n> anyone looking at the blockchain her transaction appears completely\n> normal with her coins seemingly going from address A to address B. But\n> in reality her coins end up in address Z which is entirely unconnected\n> to either A or B.\n> \n> Now imagine another user, Carol, who isn't too bothered by privacy and\n> sends her bitcoin using a regular wallet which exists today. But because\n> Carol's transaction looks exactly the same as Alice's, anybody analyzing\n> the blockchain must now deal with the possibility that Carol's\n> transaction actually sent her coins to a totally unconnected address. So\n> Carol's privacy is improved even though she didn't change her behaviour,\n> and perhaps had never even heard of this software.\n> \n> In a world where advertisers, social media and other companies want to\n> collect all of Alice's and Carol's data, such privacy improvement would\n> be incredibly valuable. And also the doubt added to every transaction\n> would greatly boost the fungibility of bitcoin and so make it a better\n> form of money.\n> \n> This undetectable privacy can be developed today by implementing\n> CoinSwap, although by itself that isn't enough. There must be many\n> building blocks which together make a good system. The software could be\n> standalone as a kind of bitcoin mixing app, but it could also be a\n> library that existing wallets can implement allowing their users to send\n> Bitcoin transactions with much greater privacy.\n> \n> == CoinSwap ==\n> \n> Like CoinJoin, CoinSwap was invented in 2013 by Greg Maxwell[1]. Unlike\n> CoinJoin it is relatively complicated to implement and so far has not\n> been deployed. But the idea holds great promise, and fixes many of the\n> problems of some kinds of CoinJoins. CoinSwap is the next step for\n> on-chain bitcoin privacy.\n> \n> CoinSwap is a way of trading one coin for another coin in a\n> non-custodial way. It is closely related to the idea of an atomic swap.\n> Alice and Bob can trade coins with each other by first sending to a\n> CoinSwap address and having those coins then sent to Bob:\n> \n>     Alice's Address 1 ----> CoinSwap Address 1 ----> Bob's Address 1\n> \n> An entirely separate set of transactions gives Bob's coins to Alice in\n> return:\n> \n>     Bob's Address 2 ----> CoinSwap Address 2 ----> Alice's Address 2\n> \n> Where the symbol ----> is a bitcoin transaction.\n> \n> Privacy is improved because an observer of the blockchain cannot link\n> Alice's Address 1 to Alice's Address 2, as there is no transaction\n> between them. Alice's Address 2 could either be an address in Alice's\n> wallet, or the address of someone else she wants to transfer money to.\n> CoinSwap therefore breaks the transaction graph heuristic, which is the\n> assumption that if a transaction A -> B is seen then the ownership of\n> funds actually went from A to B.\n> \n> CoinSwap doesnt break any of bitcoin's assumptions or features like an\n> auditable supply or pruning. It can be built on today's bitcoin without\n> any new soft forks.\n> \n> CoinSwap can't improve privacy much on its own, so it requires other\n> building block to create a truly private system.\n> \n> === ECDSA-2P ===\n> \n> The original CoinSwap idea uses 2-of-2 multisig. We can get a slightly\n> bigger anonymity set by using 2-of-3 multisigs with a fake third public\n> key. For a much greater anonymity set we can use 2-party ECDSA to create\n> 2-of-2 multisignature addresses that look the same as regular\n> single-signature addresses[2]. Even the old-style p2pkh addresses\n> starting with 1 can be CoinSwap addresses.\n> \n> Because the transactions blend in with the rest of bitcoin, an\n> application based on CoinSwap would provide much more privacy than the\n> existing equal-output coinjoin apps (JoinMarket, Wasabi Wallet and\n> Samourai Wallet's Whirlpool). CoinSwaps would also be cheaper for the\n> same amount of privacy, as CoinJoin users usually create multiple\n> CoinJoins to get effective privacy, for example JoinMarket's tumbler\n> script does between 7-12 coinjoins (which are bigger than regular\n> transactions too) when run with default parameters.\n> \n> Schnorr signatures with Musig provide a much easier way to create\n> invisible 2-of-2 multisig, but it is not as suitable for CoinSwap. This\n> is because the anonymity set for ECDSA would be much greater. All\n> addresses today are ECDSA, and none are schnorr. We'd have to wait for\n> schnorr to be added to bitcoin and then wait for users to adopt it. We\n> see with segwit that even after nearly 3 years that segwit adoption is\n> only about 60%, and segwit actually has a sizeable financial incentive\n> for adoption via lower fees. Schnorr when used for single-sig doesn't\n> have such an incentive, as Schnorr single-sig costs the same size as\n> today's p2wpkh, so we can expect adoption to be even slower. (Of course\n> there is an incentive for multisig transactions, but most transactions\n> are single-sig). As schnorr adoption increases this CoinSwap system\n> could start to use it, but for a long time I suspect it will mostly be\n> using ECDSA for a greater anonymity set.\n> \n> === Liquidity market ===\n> \n> We can create a liquidity market for CoinSwap very similar to how\n> JoinMarket works for CoinJoins. In our example above Alice would be a\n> market taker and Bob would be a market maker. The taker Alice pays a fee\n> to the maker Bob in return for choosing the amount of a CoinSwap and\n> when it happens. This allows an excellent user experience because Alice\n> can create CoinSwaps for any size she wants, at any time she wants.\n> Right now in JoinMarket there is liquidity to create CoinJoins of sizes\n> up to about 200 BTC, and we can expect a similar kind of thing with\n> CoinSwap.\n> \n> \n> === Multi-transaction CoinSwaps to avoid amount correlation ===\n> \n> This CoinSwap is vulnerable to amount correlation:\n> \n>     AliceA (15 BTC) ----> CoinSwap AddressA ----> BobA (15 BTC)\n>     BobB (15 BTC) ----> CoinSwap AddressB ----> AliceB (15 BTC)\n> \n> Where AliceA, AliceB are addresses belonging to Alice. BobA, BobB are\n> addresses belonging to Bob. If an adversary starts tracking at address\n> AliceA they could unmix this CoinSwap easily by searching the entire\n> blockchain for other transactions with amounts close to 15 BTC, which\n> would lead them to address AliceB. We can beat this amount correlation\n> attack by creating multi-transaction CoinSwaps. For example:\n> \n>     AliceA (15 BTC) ----> CoinSwap AddressA ----> BobA (15 BTC)\n> \n>     BobB (7 BTC) ----> CoinSwap AddressB ----> AliceB (7 BTC)\n>     BobC (5 BTC) ----> CoinSwap AddressC ----> AliceC (5 BTC)\n>     BobD (3 BTC) ----> CoinSwap AddressD ----> AliceD (3 BTC)\n> \n> Now in the multi-transaction CoinSwap, the market taker Alice has given\n> 10 BTC and got back three transactions which add up to the same amount,\n> but nowhere on the blockchain is there an output where Alice received\n> exactly 15 BTC.\n> \n> === Routing CoinSwaps to avoid a single points of trust ===\n> \n> In the original CoinSwap idea there are only two parties Alice and Bob,\n> so when they CoinSwap Bob will know exactly where the Alice's coins\n> went. This means Bob is a single point of failure in Alice's privacy,\n> and Alice must trust him not to spy on her.\n> \n> To spread out and decentralize the trust, we can create CoinSwaps where\n> Alice's payment is routed through many Bobs.\n> \n>     AliceA ====> Bob ====> Charlie ====> Dennis ====> AliceB\n> \n> Where the symbol ====> means one CoinSwap. In this situation Alice will\n> be a market taker in the liquidity market, and all the other entities\n> (Bob, Charlie, Dennis) will be market makers. Only Alice will know the\n> entire route, and the makers will only know the previous and next\n> bitcoin addresses along the route.\n> \n> This could be made to work by Alice handling almost everything about the\n> CoinSwap on the other maker's behalf. The makers wouldn't have TCP\n> connections between each other, but only to Alice, and she would relay\n> CoinSwap-relevant information between them. The other makers are not\n> aware whether their incoming coins came from Alice herself or the\n> previous maker in Alice's route.\n> \n> \n> === Combining multi-transaction with routing ===\n> \n> Routing and multi-transaction must be combined to get both benefits. If\n> Alice owns multiple UTXOs (of value 6 BTC, 8 BTC and 1 BTC) then this is\n> easy with this configuration:\n> \n>              Alice\n>     (6 BTC) (8 BTC) (1 BTC)\n>        |       |       |\n>        |       |       |\n>        v       v       v\n>               Bob\n>     (5 BTC) (5 BTC) (5 BTC)\n>        |       |       |\n>        |       |       |\n>        v       v       v\n>             Charlie\n>     (9 BTC) (5 BTC) (1 BTC)\n>        |       |       |\n>        |       |       |\n>        v       v       v\n>             Dennis\n>     (7 BTC) (4 BTC) (4 BTC)\n>        |       |       |\n>        |       |       |\n>        v       v       v\n>              Alice\n> \n> Where the downward arrow symbol is a single CoinSwap hash-time-locked\n> contract. Each hop uses multiple transactions so no maker (Bob, Charlie,\n> Dennis) is able to use amount correlation to find addresses not directly\n> related to them, but at each hop the total value adds up to the same\n> amount 15 BTC. And all 3 makers must collude in order to track the\n> source and destination of the bitcoins.\n> \n> If Alice starts with only a single UTXO then the above configuration is\n> still vulnerable to amount correlation. One of the later makers (e.g.\n> Dennis) knows that the total coinswap amount is 15 BTC, and could search\n> the blockchain to find Alice's single UTXO. In such a situation Alice\n> must use a branching configuration:\n> \n>                           Alice\n>                          (15 BTC)\n>                             |\n>                             |\n>                             v\n>                            Bob\n>                           /   \\\n>                          /     \\\n>              <-----------       ----------->\n>              |                             |\n>   (2 BTC) (2 BTC) (2 BTC)        (3 BTC) (3 BTC) (3 BTC)\n>              |                             |\n>              |                             |\n>              v                             v\n>           Charlie                       Dennis\n>   (1 BTC) (2 BTC) (3 BTC)       (5 BTC) (3 BTC) (1 BTC)\n>      |       |       |             |       |       |\n>      |       |       |             |       |       |\n>      v       v       v             v       v       v\n>           Edward                          Fred\n>   (4 BTC) (1 BTC) (1 BTC)       (4 BTC) (2 BTC) (1 BTC)\n>      |       |       |             |       |       |\n>      |       |       |             |       |       |\n>      v       v       v             v       v       v\n>            Alice                         Alice\n> \n> In this diagram, Alice sends 15 BTC to Bob via CoinSwap who sends 6 BTC\n> on to Charlie and the remaining 9 BTC to Dennis. Charlie and Dennis do a\n> CoinSwap with Edward and Fred who forward the coins to Alice. None of\n> the makers except Bob know the full 15 BTC amount and so can't search\n> the blockchain backwards for Alice's initial UTXO. Because of multiple\n> transactions Bob cannot look forward to search for the amounts he sent 6\n> BTC and 9 BTC. A minimum of 3 makers in this example need to collude to\n> know the source and destination of the coins.\n> \n> Another configuration is branch merging, which Alice would find useful\n> if she has two or more UTXOs for which there must not be evidence that\n> they're owned by the same entity, and so they must not be spent together\n> in the same transaction.\n> \n>            Alice                         Alice\n>           (9 BTC)                       (6 BTC)\n>              |                             |\n>              |                             |\n>              v                             v\n>             Bob                         Charlie\n>   (4 BTC) (3 BTC) (2 BTC)       (1 BTC) (2 BTC) (3 BTC)\n>      |       |       |             |       |       |\n>      |       |       |             |       |       |\n>       \\       \\       \\           /       /       /\n>        \\       \\       \\         /       /       /\n>         \\       \\       \\       /       /       /\n>          >------->-------\\     /-------<-------<\n>                           \\   /\n>                           Alice\n>                          (15 BTC)\n> \n> In this diagram Alice sends the two UTXOs (9 BTC and 6 BTC) to two\n> different makers, who forward it onto Alice. Because the two UTXOs have\n> been transferred to different makers they will likely never be co-spent.\n> \n> These complex multi-transaction routed coinswaps are only for the\n> highest threat models where the makers themselves are adversaries. In\n> practice most users would probably choose to use just one or two hops.\n> \n> \n> === Breaking change output and wallet fingerprinting heuristics ===\n> \n> Equal-output CoinJoins easily leak change addresses (unless they are\n> sweeps with no change). CoinSwap doesn't have this flaw which allows us\n> to break some of the weaker change output heuristics[3].\n> \n> For example address reuse. If an output address has been reused it is\n> very likely to be a payment output, not a change output. In a CoinSwap\n> application we can break this heuristic by having makers randomly with\n> some probability send their change to an address they've used before.\n> That will make the heuristics think that the real change address is\n> actually the payment address, and the real payment is actually the\n> change, and could result in an analyzer of the blockchain grouping the\n> payment address inside the maker's own wallet cluster.\n> \n> Another great heuristic to break is the script type heuristic. If the\n> maker's input are all in p2sh-p2wpkh addresses, and their payment\n> address is also of type p2sh-p2wpkh, then the maker could with some\n> probability set the change address to a different type such as p2wpkh.\n> This could trick a chain analyzer in a similar way.\n> \n> === Fidelity bonds ===\n> \n> Anybody can enter the CoinSwap market as a maker, so there is a danger\n> of sybil attacks. This is when an adversary deploys huge numbers of\n> maker bots. If the taker Alice chooses maker bots which are all\n> controlled by the same person then that person can deanonymize Alice's\n> transaction by tracking the coins along the route.\n> \n> A solution to this is fidelity bonds. This is a mechanism where bitcoin\n> value is deliberately sacrificed to make a cryptographic identity\n> expensive to obtain. The sacrifice is done in a way that can be proven\n> to a third party. One way to create a fidelity bond is to lock up\n> bitcoins in a time-locked address. We can code the taker bots to behave\n> in a way that creates market pressure for maker bot operators to publish\n> fidelity bonds. These fidelity bonds can be created anonymously by\n> anyone who owns bitcoin.\n> \n> Fidelity bonds are a genuine sacrifice which can't be faked, they can be\n> compared to proof-of-work which backs bitcoin mining. Then for a sybil\n> attacker to be successful they would have to lock up a huge value in\n> bitcoin for a long time. I've previously analyzed fidelity bonds for\n> JoinMarket[4], and using realistic numbers I calculate that such a\n> system would require about 55000 BTC (around 500 million USD at today's\n> price) to be locked up for 6 months in time-locked addresses. This is a\n> huge amount and provides strong sybil resistance.\n> \n> ==== Who goes first ====\n> \n> Fidelity bonds also solve the \"who goes first\" problem in CoinSwap.\n> \n> This problem happens because either Alice or Bob must broadcast their\n> funding transaction first, but if the other side halts the protocol then\n> they can cause Alice or Bob's to waste time and miner fees as they're\n> forced to use the contract transactions to get their money back. This is\n> a DOS attack. If a malicious CoinSwapper could keep halting the protocol\n> they could stop an honest user from doing a CoinSwap indefinitely.\n> Fidelity bonds solve this by having the fidelity bond holder go second.\n> If the fidelity bond holder halts the protocol then their fidelity bond\n> can be avoid by the user in all later CoinSwaps. And the malicious\n> CoinSwapper could pack the orderbook with their sybils without\n> sacrificing a lot of value for fidelity bonds.\n> \n> As a concrete example, Alice is a taker and Bob is a maker. Bob\n> publishes a fidelity bond. Alice \"goes first\" by sending her coins into\n> a 2-of-2 multisig between her and Bob. When Bob sees the transaction is\n> confirmed he broadcasts his own transactions into another 2-of-2\n> multisig. If Bob is actually malicious and halts the protocol then he\n> will cost Alice some time and money, but Alice will refuse to ever\n> CoinSwap with Bob's fidelity bond again.\n> \n> If DOS becomes a big problem even with fidelity bonds, then its possible\n> to have Alice request a \"DOS proof\" from Bob before broadcasting, which\n> is a set of data containing transactions, merkle proofs and signatures\n> which are a contract where Bob promises to broadcast his own transaction\n> if Alice does so first. If Alice gets DOSed then she can share this DOS\n> proof publicly. The proof will have enough information to convince\n> anyone else that the DOS really happened, and it means that nobody else\n> will ever CoinSwap with Bob's fidelity bond either (or at least assign\n> some kind of ban score to lower the probability). I doubt it will come\n> to this so I haven't expanded the idea much, but theres a longer writeup\n> in the reference[5].\n> \n> === Private key handover ===\n> \n> The original proposal for CoinSwap involved four transactions. Two to\n> pay into the multisig addresses and two to pay out. We can do better\n> than this with private key handover[6]. This is an observation that once\n> the CoinSwap preimage is revealed, Alice and Bob don't have to sign each\n> other's multisig spend, instead they could hand over their private key\n> to the other party. The other party will know both keys of the 2-of-2\n> multisig and therefore have unilateral control of the coins. Although\n> they would still need to watch the chain and respond in case a\n> hash-time-locked contract transaction is broadcasted.\n> \n> As well as saving block space, it also improves privacy because the\n> coins could stay unspent for a long time, potentially indefinitely.\n> While in the original coinswap proposal an analyst of the chain would\n> always see a funding transaction followed closely in time by a\n> settlement transaction, and this could be used as a fingerprint.\n> \n> We can go even further than private key handover using a scheme called\n> SAS: Succinct Atomic Swap[7]. This scheme uses adapter signatures[8] to\n> create a similar outcome to CoinSwap-with-private-key-handover, but only\n> one party in the CoinSwap must watch and respond to blockchain events\n> until they spend the coin. The other party just gets unilateral control\n> of their coins without needing to watch and respond.\n> \n> \n> === PayJoin with CoinSwap ===\n> \n> CoinSwap can be combined with CoinJoin. In original CoinSwap, Alice\n> might pay into a CoinSwap address with a regular transaction spending\n> multiple of her own inputs:\n> \n>     AliceInputA (1 BTC) ----> CoinSwap Address (3 BTC)\n>     AliceInputB (2 BTC)\n> \n> This leaks information that all of those inputs are owned by the same\n> person. We can make this example transaction a CoinJoin by involving\n> Bob's inputs too. CoinJoin requires interaction but because Alice and\n> Bob are already interacting to follow the CoinSwap protocol, so it's not\n> too hard to have them interact a bit more to do a CoinJoin too. The\n> CoinJoin transaction which funds the CoinSwap address would look like this:\n> \n>     AliceInputA (1 BTC) ----> CoinSwap Address (7 BTC)\n>     AliceInputB (2 BTC)\n>     BobInputA   (4 BTC)\n> \n> Alice's and Bob's inputs are both spent in a same transaction, which\n> breaks the common-input-ownership heuristic. This form of CoinJoin is\n> most similar to the PayJoin protocol or CoinJoinXT protocol. As with the\n> rest of this design, this protocol does not have any special patterns\n> and so is indistinguishable from any regular bitcoin transaction.\n> \n> To make this work Bob the maker needs to provide two unrelated UTXOs,\n> one that is CoinSwapped and the other CoinJoined.\n> \n> ==== Using decoy UTXOs to protecting from leaks ====\n> \n> If Bob the maker was just handing out inputs for CoinJoins to any Alice\n> who asked, then malicious Alice's could constantly poll Bob to learn his\n> UTXO and then halt the protocol. Malicious Alice could learn all of\n> Bob's UTXOs and easily unmix future CoinSwaps by watching their future\n> spends.\n> \n> To defend against this attack we have Bob maintain a list of \"decoy\n> UTXOs\", which are UTXOs that Bob found by scanning recent blocks. Then\n> when creating the CoinJoin, Bob doesn't just send his own input but\n> sends perhaps 50 or 100 other inputs which don't belong to him. For the\n> protocol to continue Alice must partially-sign many CoinJoin\n> transactions; one for each of those inputs, and send them back to Bob.\n> Then Bob can sign the transaction which contains his genuine input and\n> broadcast it. If Alice is actually a malicious spy she won't learn Bob's\n> input for sure but will only know 100 other inputs, the majority of\n> which have nothing to do with Bob. By the time malicious Alice learns\n> Bob's true UTXO its already too late because its been spent and Alice is\n> locked into the CoinSwap protocol, requiring time, miner fees and\n> CoinSwap fees to get out.\n> \n> This method of decoy UTXOs has already been written about in the\n> original PayJoin designs from 2018[9][10].\n> \n> === Creating a communication network using federated message boards ===\n> \n> Right now JoinMarket uses public IRC networks for communication. This is\n> subpar for a number of reasons, and we can do better.\n> \n> I propose that there be a small number of volunteer-operated HTTP\n> servers run on Tor hidden services. Their URLs are included in the\n> CoinSwap software by default. They can be called message board servers.\n> Makers are also servers run on hidden services, and to advertise\n> themselves they connect to these message board servers to post the\n> makers own .onion address. To protect from spam, makers must provide a\n> fidelity bond before being allowed to write to the HTTP server.\n> \n> Takers connect to all these HTTP message boards and download the list of\n> all known maker .onion addresses. They connect to each maker's onion to\n> obtain parameters like offered coinswap fee and maximum coinswap size.\n> This is equivalent to downloading the orderbook on JoinMarket. Once\n> takers have chosen which makers they'll do a CoinSwap with, they\n> communicate with those maker again directly through their .onion address\n> to transmit the data needed to create CoinSwaps.\n> \n> These HTTP message board servers can be run quite cheaply, which is\n> required as they'd be volunteer run. They shouldn't require much\n> bandwidth or disk space, as they are well-protected from spam with the\n> fidelity bond requirement. The system can also tolerate temporary\n> downtimes so the servers don't need to be too reliable either. It's easy\n> to imagine the volunteers running them on a raspberry pi in their own\n> home. These message board servers are similar in some ways to the DNS\n> seeds used by Bitcoin Core to find its first peers on bitcoin's p2p\n> network. If the volunteers ever lose interest or disappear, then the\n> community of users could find new volunteer operators and add those URLs\n> to the default list.\n> \n> In order to censor a maker, _all_ the message board servers would have\n> to co-operate to censor him. If censorship is happening on a large scale\n> (for example if the message board servers only display sybil makers run\n> by themselves) then takers could also notice a drop in the total value\n> of all fidelity bonds.\n> \n> \n> == How are CoinSwap and Lightning Network different? ==\n> \n> CoinSwap and Lightning Network have many similarities, so it's natural\n> to ask why are they different, and why do we need a CoinSwap system at\n> all if we already have Lightning?\n> \n> === CoinSwap can be adopted unilaterally and is on-chain ===\n> \n> Today we see some centralized exchange not supporting so-called\n> ``privacy altcoins'' because of regulatory compliance concerns. We also\n> see some exchanges frowning upon or blocking CoinJoin transaction they\n> detect[11]. (There is some debate over whether the exchanges really\n> blocked transactions because they were CoinJoin, but the principle\n> remains that equal-output CoinJoins are inherently visible as such).\n> It's possible that those exchanges will never adopt Lightning because of\n> its privacy features.\n> \n> Such a refusal would simply not be possible with CoinSwap, because it is\n> fundamentally an on-chain technology. CoinSwap users pay to bitcoin\n> addresses, not Lightning invoices. Anybody who accepts bitcoin today\n> will accept CoinSwap. And because CoinSwap transactions can be made\n> indistinguishable from regular transactions, it would be very difficult\n> to even determine whether they got paid via a CoinSwap or not. So\n> CoinSwap is not a replacement for Lightning, instead it is a replacement\n> for on-chain privacy technology such as equal-output CoinJoins which are\n> implemented today in JoinMarket, Wasabi Wallet and Samourai Wallet.\n> Ideally this design, if implemented, would be possible to include into\n> the many already-existing bitcoin wallets, and so the CoinSwaps would be\n> accessible to everyone.\n> \n> This feature of CoinSwap will in turn help Lightning Network, because\n> those censoring exchanges won't be able to stop transactions with\n> undetectable privacy no matter what they do. When they realize this\n> they'll likely just implement Lightning Network anyway regardless of the\n> privacy.\n> \n> Bitcoin needs on-chain privacy as well, otherwise the bad privacy can\n> leak into layer-2 solutions.\n> \n> === Different ways of solving liquidity ===\n> \n> Lightning Network cannot support large payment amounts. Liquidity in\n> payment channels on the Lightning network is a scarce resource. Nodes\n> which relay lightning payments always take care that a payment does not\n> exhaust their liquidity. Users of Lightning today must often be aware of\n> inbound liquidity, outbound liquidity and channel rebalancing. There\n> even exist services today which sell Lightning liquidity.\n> \n> This CoinSwap design solves its liquidity problem in a completely\n> different way. Because of the liquidity market similar to JoinMarket,\n> all the required liquidity is always available. There are never any\n> concerns about exhausting channel capacity or a route not being found,\n> because such liquidity is simply purchased from the liquidity market\n> right before it is used.\n> \n> It is still early days for Lightning, and liquidity has been a known\n> issue since the start. Many people are confident that the liquidity\n> issue will be improved. Yet it seems hard to imagine that Lightning\n> Network will ever reliably route payments of 200 BTC to any node in the\n> network (and it doesn't have to to be successful), yet on JoinMarket\n> today as I write these words there are offers to create CoinJoins with\n> amounts up to around 200 BTC. We can expect similar large amounts to be\n> sendable in CoinSwap. The liquidity market as a solution is known to\n> work and has been working for years.\n> \n> === Sybil resistance ===\n> \n> CoinSwap can support fidelity bonds and so can be made much more\n> resistant to sybil attacks. We saw in the earlier section that realistic\n> numbers from JoinMarket imply a sybil attacker would have to lock up\n> hundreds of millions of USD worth of bitcoin to successfully deanonymize\n> users.\n> \n> It's difficult to compare this to the cost of a sybil attack in\n> Lightning network as such attacks are hard to analyze. For example, the\n> attacker needs to convince users to route payments through the\n> attacker's own nodes, and maybe they could do this, but putting numbers\n> on it is hard. Even so it is very likely that the true cost is much less\n> than 500 million USD locked up for months because Lightning nodes can be\n> set up for not more than the cost of hardware and payment channel\n> capacity, while CoinSwap makers would require expensive fidelity bond\n> sacrifices.\n> \n> As this CoinSwap design would cost much more sybil attack, its privacy\n> would be much greater in this respect.\n> \n> \n> == How are CoinSwap, PayJoin and PaySwap different? ==\n> \n> PayJoin can also be indistinguishable from regular bitcoin transaction,\n> so why don't we all just that and not go further?\n> \n> The answer is the threat models. PayJoin works by having the customer\n> and merchant together co-operate to increase both their privacy. It\n> works if the adversary of both of them is a passive observer of the\n> blockchain.\n> \n> PayJoin doesnt help a customer at all if the user's adversary is the\n> merchant. This situation happens all the time today, for example\n> exchanges spying on their customers. CoinSwap can help in this\n> situation, as it doesn't assume or require that the second party is your\n> friend. The same argument applies to PaySwap.\n> \n> Obviously PayJoin and PaySwap are still very useful, but they operate\n> under different threat models.\n> \n> \n> == Conclusion ==\n> \n> CoinSwap is a promising privacy protocol because it breaks the\n> transaction graph heuristic, but it cant work on its own. In order to\n> create a truly private system of sending transactions which would\n> improve bitcoin's fungibility, CoinSwap must be combined with a couple\n> of other building blocks:\n> \n> * ECDSA-2P\n> * Liquidity market\n> * Routed CoinSwaps\n> * Multi-transaction CoinSwaps\n> * Breaking change output heuristics\n> * Fidelity bonds\n> * PayJoin with CoinSwap\n> * Federated message boards protected from spam with fidelity bonds\n> \n> CoinSwap transactions could be made to look just like any other regular\n> bitcoin transaction, with no distinguishing fingerprint. This would make\n> them invisible.\n> \n> I intend to create this CoinSwap software. It will be almost completely\n> decentralized and available for all to use for free. The design is\n> published here for review. If you want to help support development I\n> accept donations at https://bitcoinprivacy.me/coinswap-donations\n> \n> \n> == References ==\n> \n> - [1] \"CoinSwap: Transaction graph disjoint trustless trading\"\n> https://bitcointalk.org/index.php?topic=321228.0\n> \n> - [2]\n> http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/scriptless-ecdsa/\n> \n> - [3] https://en.bitcoin.it/wiki/Privacy#Change_address_detection\n> \n> - [4] \"Design for improving JoinMarket's resistance to sybil attacks\n> using fidelity bonds\"\n> https://gist.github.com/chris-belcher/18ea0e6acdb885a2bfbdee43dcd6b5af/\n> \n> - [5] https://github.com/AdamISZ/CoinSwapCS/issues/50\n> \n> - [6] https://github.com/AdamISZ/CoinSwapCS/issues/53\n> \n> - [7]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-May/017846.html\n> \n> - [8]\n> https://github.com/ElementsProject/scriptless-scripts/blob/master/md/atomic-swap.md\n> \n> - [9]\n> https://blockstream.com/2018/08/08/en-improving-privacy-using-pay-to-endpoint/\n> \n> - [10] https://medium.com/@nopara73/pay-to-endpoint-56eb05d3cac6\n> \n> - [11]\n> https://cointelegraph.com/news/binance-returns-frozen-btc-after-user-promises-not-to-use-coinjoin\n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            }
        ],
        "thread_summary": {
            "title": "Design for a CoinSwap implementation for massively improving Bitcoin privacy and fungibility",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Chris Belcher",
                "ZmnSCPxj",
                "Mr. Lee Chiffre",
                "Jonas Nick",
                "Ruben Somsen"
            ],
            "messages_count": 18,
            "total_messages_chars_count": 102532
        }
    },
    {
        "title": "[bitcoin-dev] Announcing Bitcoin Wallet Tracker",
        "thread_messages": [
            {
                "author": "Nadav Ivgi",
                "date": "2020-06-01T08:10:50",
                "message_text_only": "Hi Antoine,\n\nI designed both APIs, so they definitely do share some similarities.\n\nIt's difficult to compare their performance directly, since\nesplora-electrs keeps a full index of everything, while bwt tracks\nyour wallet addresses only.\n\nIf you're only interested in your wallet addresses and don't have a\n*really* huge number of them, bwt will definitely perform better, as\nit can avoid a lot of unnecessary indexing work. If you do have a lot\nof addresses, esplora-electrs will be better suited for the job, as\nits designed to deal with high volumes of data and does not rely on\nthe bitcoind wallet functionality, which was not designed for this.\n\nI'm not sure where the line for \"really huge\" crosses exactly though,\nI have not put this to the test. Definitely if you're tracking\nmillions of addresses, probably also for hundreds of thousands,\npossibly even less?\n\nAPI design wise, the main differences between the two are:\n\n- Esplora provides every bit of information one might want to know\nabout transactions/blocks, while bwt intentionally tries to reduce\nthis to the subset useful in the context of app development.\n\n- bwt provides wallet-contextual information, like key origins next to\naddresses and the net change inflicted on the wallet's balance by\ntransactions.\n\n- Esplora doesn't provide real-time updates (yet), while bwt provides\nthem using two different mechanisms (SSE and Web Hooks).\n\nNadav\n\n\n\nOn Sun, May 31, 2020 at 5:56 PM darosior <darosior at protonmail.com> wrote:\n>\n> Hi,\n>\n> I gave a quick look to the http API, and it seems very similar to Esplora's. So I wonder : how does\n> bwt compares to Esplora, performance-wise ?\n>\n> Thanks!\n> Antoine\n>\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> Le samedi, mai 30, 2020 4:16 PM, Nadav Ivgi via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n>\n> Hi all,\n>\n> I recently released bwt [0], an HD wallet indexer implemented in Rust, using\n> a model similar to that of Electrum Personal Server.\n>\n> It uses the bitcoind wallet functionality to do the heavy lifting and builds\n> additional indexes on top of that, which can be queried using the Electrum\n> RPC protocol, as well as a more modern, developer-friendly HTTP REST API.\n>\n> The electrum server can also be used as an electrum plugin [1], which\n> integrates the server straight into the electrum client. From the user's\n> perspective, this allows connecting electrum directly to a full node.\n>\n> The HTTP API is my take on a modern design for a wallet tracking API aimed\n> at app developers. Some use-cases include using it as a backend for wallets\n> (similarly to Samuari's Dojo) or to track deposits to a watch-only xpub\n> (similarly to BTCPay's NBXplorer).\n>\n> Compared to using the bitcoind RPC directly, bwt provides:\n>\n> - The ability to track an xpub and automatically have new addresses derived\n>   and imported as needed, according to the gap limit.\n>\n> - Two additional indexes, one for looking up the transaction history of\n>   addresses, and another one for looking up txo spends (a map of\n>   funding_txid:vout => spending_txid:vin).\n>\n> - Real-time updates using Server-Sent Events [2] (a long-lived streaming HTTP\n>   connection) or Web Hooks [3] (an HTTP request sent to a configured URL).\n>   The updates being sent [4] directly provide information about the funded\n>   and spent wallet txos, instead of the client figuring it out from the tx.\n>\n> - Some API conveniences and simplifications, like including key origin\n>   information directly alongside inputs/outputs [5], the ability to specify\n>   key origins in place of addresses (eg. GET /hd/15cb9edc/8/utxos), a compact\n>   history format [6], and an easy way to catch-up with missed events [7].\n>   Unless explicitly asked for, the API omits information about non-wallet\n>   inputs/outputs and protocol-level details like scriptsig and witnesses,\n>   which are typically not needed for higher-level app development.\n>\n> The indexer is designed in a way that minimizes RPC requests to bitcoind. By\n> using labels to store key origin information, it is able to index incoming\n> transactions using the information available from `listtransactions` alone\n> (plus 3 extra rpc requests that don't grow with the number of transactions),\n> but requires 1 additional rpc call per outgoing transaction (to learn which\n> prevouts were spent). It can index 10k incoming txs in under a second, or a\n> mixture of 5k/5k in under 5 seconds. The index is currently entirely in-\n> memory and does not get persisted. The indexer logic can be seen in [8].\n>\n> One major item on the roadmap that I'm hoping to tackle soon is support for\n> output script descriptors.\n>\n> If anyone is interested in contributing, the README has some useful developer\n> resources [9] and a handy script for setting up a development environment.\n>\n> This is an early alpha release, recommended for use with testnet/regtest.\n>\n> All feedback welcome!\n>\n> Cheers,\n> Nadav\n>\n> [0] https://github.com/shesek/bwt\n> [1] https://github.com/shesek/bwt#electrum-plugin\n> [2] https://github.com/shesek/bwt#server-sent-events\n> [3] https://github.com/shesek/bwt#web-hooks\n> [4] https://github.com/shesek/bwt#event-categories\n> [5] https://github.com/shesek/bwt#wallet-transaction-format\n> [6] https://github.com/shesek/bwt#get-txssinceblock-heightcompact\n> [7] https://github.com/shesek/bwt#catching-up-with-missed-events--re-org-detection\n> [8] https://github.com/shesek/bwt/blob/master/src/indexer.rs (sync_transactions and load_transactions_since)\n> [9] https://github.com/shesek/bwt#developing\n>\n>"
            }
        ],
        "thread_summary": {
            "title": "Announcing Bitcoin Wallet Tracker",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Nadav Ivgi"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5559
        }
    },
    {
        "title": "[bitcoin-dev] TLA+ specification for Succint Atomic Swap",
        "thread_messages": [
            {
                "author": "Dmitry Petukhov",
                "date": "2020-06-01T11:38:54",
                "message_text_only": "I've finished specifying the full Succint Atomic Swap contract in TLA+.\n\nI believe the specification [1] now covers all relevant behaviors of\nthe participants. It even has an option to enable 'non-rational'\nbehavior, so that it can be shown that the transactions that are there\nto punish bad behavior can actually be used. If you examine the spec\nand find that I failed to specify some relevant behavior, please tell.\n\nThe specification can be used to exhaustively check safety properties\nof the model (such as no participant can take both coins, unless in\nexplicitly specified circumstances), and temporal properties (such as\ncontract always end up in an explicitly specified 'finished' state).\n\nThe specification can also be used to *show* (but not automatically\ncheck at the moment) the hyperproperties of the model, such as what\ntransactions can ever be confirmed in at least one the execution path,\nmax/min/avg values for various stats, etc. The information on these\nhyperproperties can be printed out during model checking, and can be\nexamined manually or with help of additional scripts (if one willing to\nwrite some).\n\nThe model has some limitations, like only having one miner, and not\nmodelling fees and mempool priorities. More than one miner needed to\nintroduce reorgs in the model, but I believe that reorgs are relevant\nonly if we cannot say that \"one block in the model means 6 bitcoin\nblocks\" (or whatever reorg safety limit is acceptable). I also believe\nthat the fees and mempool priorities are a lower-level concern, because\nthe task to confirm the transaction in time is the same for different\nstages of the contract and for different transactions, and therefore\nthis can be modelled separately.\n\nThe goal of creating this specification was to evaluate the suitability\nof TLA+ for modelling of the smart contracts in UTXO-based\nblockchain systems. I believe that the presented spec shows that it is\nindeed feasible to do such modelling and TLA+ is a suitable tool for\nspecifying and for checking such specifications (Although having ability\nto automatically check hyperproperties using TLA+ expressions would be\nnice).\n\nI hope that this spec can be used as a basis for specs for other\ncontracts, and that using TLA+ can make designing safe contracts for\nUTXO-based systems easier. I also hope that this will help to increase\ninterest in using formal methods in this area.\n\nI tried to make the parts of the spec that deal with things like mining\nand mempool to not depend on the concrete contract logic, in\nexpectation that this logic can be reused afterwards for the specs of\nother contracts. I did not make specific effort to factor out this\ngeneric logic into separate module though, because I think that more\nvarious contract specifications need to be designed and analyzed to\nunderstand what is really generic and what should lay with concrete\ncontract logic. When more knowledge is created regarding this, there\ncould be a module that contract specifications can use to avoid\nexplicitly specifying the generic blockchain-related logic.\n\nThanks to Ruben Somsen for designing this contract and\nproviding helpful description and diagram that made it possible to\ncreate this formal specification.\n\n[1] https://github.com/dgpv/SASwap_TLAplus_spec"
            }
        ],
        "thread_summary": {
            "title": "TLA+ specification for Succint Atomic Swap",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Dmitry Petukhov"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3266
        }
    },
    {
        "title": "[bitcoin-dev] SAS: Succinct Atomic Swap",
        "thread_messages": [
            {
                "author": "Dmitry Petukhov",
                "date": "2020-06-03T09:04:25",
                "message_text_only": "I made a version of the TLA+ spec according to the suggested variant,\nas I understood it from your description. This version is in\nthe separate branch in the SASwap repo, 'variant_ZmnSCPxj' [1]\n\nIf I understood and specified your variant correctly, there is a\ndeadlock possible after step 9, if Bob fails to publish success tx in\ntime. After refund tx becomes spendable, Alice cannot publish it via\nmempool, because Bob can learn her secret and has a chance invalidate\nher refund tx by giving his success tx to friendly miner, while taking\nback the locked LTC because both secrets are known. At the same time,\nBob cannot publish success tx via mempool, because then Alice can do\nthe same thing, invalidating his success tx with refund tx via friednly\nminer.\n\nThere is a possibility that this deadlock can be resolved if one\nparticipant indeed has possibility to confirm their tx directly,\nbypassing the mempool, so the counterparty won't learn the secret until\ntransaction is in the block. But then this just raises the cost of the\nattack because the counterparty will need to invalidate (orphan) the\nwhole block instead of just a transaction in the mempool, after\nlearning the other secret from the recent block.\n\n[1] https://github.com/dgpv/SASwap_TLAplus_spec/tree/variant_ZmnSCPxj\n\n\u0412 Tue, 12 May 2020 04:41:43 +0000\nZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Ruben,\n> \n> > Hi ZmnSCPxj,\n> >\n> > Thanks for your feedback :)\n> >  \n> > > CoinSwap for privacy is practically a \"cross\" chain atomic swap\n> > > with the same chain and token for both sides of the swap  \n> >\n> > I agree, I didn't mean to imply that was new, only that this\n> > protocol makes it more efficient.\n> >  \n> \n> Indeed; basically, any innovations in cross-chain swaps can be\n> adapted to a CoinSwap (though not necessarily vice-versa, if a\n> CoinSwap innovation requires certain specific blockchain features).\n> \n> > > \"Instead, Bob simply hands secretBob to Alice\" is basically the\n> > > same as private key turnover  \n> >\n> > Thanks for the link. I will add it to the links at the bottom of the\n> > write-up, as I agree it's related. Do note there are a few key\n> > differences:\n> >\n> > -   The swap is set up in an \"asymmetric\" way with only timelocks\n> > on one side, so on the other side the swap never expires\n> >  \n> \n> An interesting setup.\n> \n> So I was wondering why something like this would not work instead:\n> \n> 0.  Alice has BTC, Bob has LTC, they agree on exchange rates and two\n> future timelock L1 and L2 such that L1 < L2. 1.  Alice creates\n> keypairs Alice[0] Alice[1] Alice[2], Bob creates Bob[0] Bob[1]\n> Bob[2], and share the pubkeys. 2.  Alice creates, but does not sign,\n> a funding tx on BTC whose output requires Alice[0] && Bob[0]. 3.  Bob\n> creates a backout transaction spending the BTC funding txo, with an\n> absolute timelock L1, whose output goes to Alice[2], then provides to\n> Alice a signature for Bob[0] and requires an adaptor such that\n> completing the signature with Alice[0] reveals Alice[1].\n> \n>                          nLockTime L1\n>     BTC funding txo ---> Alice[0] && Bob[0]    --->  Alice[2]\n>                              reveals Alice[1]\n> \n> 4.  Alice creates a timeout transaction spending the BTC funding txo,\n> with an absolute timelock L2, whose output goes to Bob[2], then\n> provides to Bob a signature for Alice[0] and requires an adaptor such\n> that completing the signature with Bob[0] reveals Bob[1].\n> \n>                          nLockTime L2\n>     BTC funding txo ---> Alice[0] && Bob[0]    --->  Bob[2]\n>                              reveals Bob[1]\n> \n> 5.  Alice signs the BTC funding tx and broadcasts it.\n> 6.  Alice and Bob wait for the BTC funding tx to be confirmed.\n> 7.  Bob creates an LTC funding tx whose output requires Alice[1] &&\n> Bob[1]. 8.  Alice and Bob wait for the LTC funding tx to be confirmed.\n> 9.  Alice creates a success transaction spending the BTC funding txo,\n> with no practical absolute timelock (current blockheight + 1), whose\n> output goes to Bob[2], then provides to Bob a signature for Alice[0]\n> and requires an adaptor such that completing the signature with\n> Bob[0] reveals Bob[1].\n> \n>                          nLockTime now\n>     BTC funding txo ---> Alice[0] && Bob[0]    --->  Bob[2]\n>                              reveals Bob[1]\n> \n> 10.  Bob gives the secret key of Bob[1] to Alice.\n> 11.  Alice gives the secret key of Alice[0] to Bob.\n> 12.  Bob claims the BTC funding txo before L1.\n> \n> Aborts and stalls:\n> \n> * Aborts before step 5 are safe: no money is ever committed yet.\n>   Stalls before step 5 can be promoted to aborts.\n> * If aborted between step 5 and step 8, Alice reclaims her BTC via\n> the backout transaction. Since Bob did not confirm any locked funds\n> in LTC, revealing Alice[1] does not give Bob any extra funds it did\n> not already have. If Bob stalls before step 8 Alice can abort at L1\n> using the backout transaction.\n> * If Alice stalls at step 9, Bob can force the completion using the\n> timeout transaction at L2, revealing Bob[1] and claiming the BTC.\n> * If Alice instead aborts at step 9 using the backout transaction at\n> L1, Bob learns Alice[1] and can reclaim its LTC.\n> * Steps 10 and 11 are optional and \"only\" give Alice and Bob extra\n> flexibility in what they can do with the funds (such as sweeping\n> multiple swaps, RBFing, performing another swap, etc.), i.e. private\n> key turnover. Bob can always claim the BTC funding txo before L1 by\n> signing and broadcasting the success transaction.\n> \n> Would this not work?\n> It requires that at least one chain involved supports witness\n> segregation, in order to allow signing a dependent transaction before\n> signing what it spends.\n> \n> This has the advantage of using only absolute timelocks, which are\n> better for privacy since ordinary wallets like Bitcoin Core and\n> C-Lightning use absolute timelocks for ordinary spends onchain.\n> \n> \n> >\n> > Unfortunately this does not hold for the revoke transaction. It\n> > would be a bit awkward if Alice had a high fee copy after the\n> > protocol completes. She could send it to the blockchain and\n> > essentially Bob would be paying for it. I'm not as concerned about\n> > the other transactions, because those could all be bumped with CPFP\n> > if needed, but having different feerates would be nice.\n> >\n> > And a general comment about privacy: it seems inevitable that some\n> > information will be leaked if the protocol does not complete\n> > cooperatively. As long as the cooperative case is not traceable,\n> > that seems about as good as it can get. That's my view, at least.\n> > I'd be curious to hear if you see that differently.  \n> \n> \n> If the above counterproposal would work, it seems to me that all\n> abort and stall scenarios \"just\" involve an absolute-timelock\n> `SIGHASH_ALL` signed transaction, so it might not be so inevitable.\n> \n> In addition, the above counterproposal has the transaction signatures\n> be completed by whoever ends up getting the money, so will rationally\n> use the version with the best feerate.\n> \n> While leaking information in case of uncooperative abort is\n> acceptable, it still seems to me that in this case, we can have a\n> solution where an uncooperative abort has no information leak. My\n> thesis is that, if relative locktimes are used as often as absolute\n> locktimes for block-sniping-prevention and a decent Scriptless Script\n> system, then all protocol aborts should be doable with no information\n> leaks, at the cost of pre-signing a bunch of timelocked transactions.\n> \n> ---\n> \n> A sidenote as well, that if Alice typically uses an HD wallet, the\n> UTXO on the LTC side would not be in that HD, and if Alice wants to\n> cold-store the LTC, it should move the money as well into an HD\n> pubkey.\n> \n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-03T14:36:46",
                "message_text_only": "Good morning Dmitry,\n\n> I made a version of the TLA+ spec according to the suggested variant,\n> as I understood it from your description. This version is in\n> the separate branch in the SASwap repo, 'variant_ZmnSCPxj' [1]\n>\n> If I understood and specified your variant correctly, there is a\n> deadlock possible after step 9, if Bob fails to publish success tx in\n> time. After refund tx becomes spendable, Alice cannot publish it via\n> mempool, because Bob can learn her secret and has a chance invalidate\n> her refund tx by giving his success tx to friendly miner, while taking\n> back the locked LTC because both secrets are known. At the same time,\n> Bob cannot publish success tx via mempool, because then Alice can do\n> the same thing, invalidating his success tx with refund tx via friednly\n> miner.\n\nIndeed, this is precisely the issue Ruben pointed out.\n\nRationally, neither side will want this condition due to the deadlock and Bob will strive to avoid this, having a short real-world timeout after which Bob will force publication of the success tx if Alice does not respond in time.\nThere *is* a reason why it says \"Bob claims the BTC funding txo before L1.\"\n\nOf course, computers do crash occasionally, I am informed, so complete accidents may occur that way.\nThis can be mitigated by running multiple servers who are given copies of the success tx, and which will publish it regardless after a short sidereal time duration, unless countermanded by the main server (i,e, a dead man switch system).\nWith sufficient distribution the probability of this occurring can drop to negligible levels compared to other theoretical attacks.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "SAS: Succinct Atomic Swap",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Dmitry Petukhov"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 9680
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Core 0.20.0 released",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2020-06-03T10:48:54",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\n0.20.0 Release Notes\n====================\n\nBitcoin Core version 0.20.0 is now available from:\n\n  <https://bitcoincore.org/bin/bitcoin-core-0.20.0/>\n\nOr through BitTorrent:\n\n    magnet:?xt=urn:btih:1845a0c66b6a728e183b9bd8c5d8c1611dddaaa3&dn=bitcoin-core-0.20.0&tr=https%3A%2F%2Fopenbittorrent.com%2F&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337%2Fannounce&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969%2Fannounce&tr=udp%3A%2F%2Fexplodie.org%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.torrent.eu.org%3A451%2Fannounce&tr=udp%3A%2F%2Ftracker.bitcoin.sprovoost.nl%3A6969\n\nThis release includes new features, various bug fixes and performance\nimprovements, as well as updated translations.\n\nPlease report bugs using the issue tracker at GitHub:\n\n  <https://github.com/bitcoin/bitcoin/issues>\n\nTo receive security and update notifications, please subscribe to:\n\n  <https://bitcoincore.org/en/list/announcements/join/>\n\nHow to Upgrade\n==============\n\nIf you are running an older version, shut it down. Wait until it has completely\nshut down (which might take a few minutes in some cases), then run the\ninstaller (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)\nor `bitcoind`/`bitcoin-qt` (on Linux).\n\nUpgrading directly from a version of Bitcoin Core that has reached its EOL is\npossible, but it might take some time if the data directory needs to be migrated. Old\nwallet versions of Bitcoin Core are generally supported.\n\nCompatibility\n==============\n\nBitcoin Core is supported and extensively tested on operating systems\nusing the Linux kernel, macOS 10.12+, and Windows 7 and newer.  Bitcoin\nCore should also work on most other Unix-like systems but is not as\nfrequently tested on them.  It is not recommended to use Bitcoin Core on\nunsupported systems.\n\n- From Bitcoin Core 0.20.0 onwards, macOS versions earlier than 10.12 are no\nlonger supported. Additionally, Bitcoin Core does not yet change appearance\nwhen macOS \"dark mode\" is activated.\n\nKnown Bugs\n==========\n\nThe process for generating the source code release (\"tarball\") has changed in an\neffort to make it more complete, however, there are a few regressions in\nthis release:\n\n- - The generated `configure` script is currently missing, and you will need to\n  install autotools and run `./autogen.sh` before you can run\n  `./configure`. This is the same as when checking out from git.\n\n- - Instead of running `make` simply, you should instead run\n  `BITCOIN_GENBUILD_NO_GIT=1 make`.\n\nNotable changes\n===============\n\nP2P and network changes\n- -----------------------\n\n#### Removal of BIP61 reject network messages from Bitcoin Core\n\nThe `-enablebip61` command line option to enable BIP61 has been removed.\n(#17004)\n\nThis feature has been disabled by default since Bitcoin Core version 0.18.0.\nNodes on the network can not generally be trusted to send valid messages\n(including reject messages), so this should only ever be used when\nconnected to a trusted node.  Please use the alternatives recommended\nbelow if you rely on this removed feature:\n\n- - Testing or debugging of implementations of the Bitcoin P2P network protocol\n  should be done by inspecting the log messages that are produced by a recent\n  version of Bitcoin Core. Bitcoin Core logs debug messages\n  (`-debug=<category>`) to a stream (`-printtoconsole`) or to a file\n  (`-debuglogfile=<debug.log>`).\n\n- - Testing the validity of a block can be achieved by specific RPCs:\n\n  - `submitblock`\n\n  - `getblocktemplate` with `'mode'` set to `'proposal'` for blocks with\n    potentially invalid POW\n\n- - Testing the validity of a transaction can be achieved by specific RPCs:\n\n  - `sendrawtransaction`\n\n  - `testmempoolaccept`\n\n- - Wallets should not assume a transaction has propagated to the network\n  just because there are no reject messages.  Instead, listen for the\n  transaction to be announced by other peers on the network.  Wallets\n  should not assume a lack of reject messages means a transaction pays\n  an appropriate fee.  Instead, set fees using fee estimation and use\n  replace-by-fee to increase a transaction's fee if it hasn't confirmed\n  within the desired amount of time.\n\nThe removal of BIP61 reject message support also has the following minor RPC\nand logging implications:\n\n- - `testmempoolaccept` and `sendrawtransaction` no longer return the P2P reject\n  code when a transaction is not accepted to the mempool. They still return the\n  verbal reject reason.\n\n- - Log messages that previously reported the reject code when a transaction was\n  not accepted to the mempool now no longer report the reject code. The reason\n  for rejection is still reported.\n\nUpdated RPCs\n- ------------\n\n- - The RPCs which accept descriptors now accept the new `sortedmulti(...)` descriptor\n  type which supports multisig scripts where the public keys are sorted\n  lexicographically in the resulting script.  (#17056)\n\n- - The `walletprocesspsbt` and `walletcreatefundedpsbt` RPCs now include\n  BIP32 derivation paths by default for public keys if we know them.\n  This can be disabled by setting the `bip32derivs` parameter to\n  `false`.  (#17264)\n\n- - The `bumpfee` RPC's parameter `totalFee`, which was deprecated in\n  0.19, has been removed.  (#18312)\n\n- - The `bumpfee` RPC will return a PSBT when used with wallets that have\n  private keys disabled.  (#16373)\n\n- - The `getpeerinfo` RPC now includes a `mapped_as` field to indicate the\n  mapped Autonomous System used for diversifying peer selection. See the\n  `-asmap` configuration option described below in _New Settings_.  (#16702)\n\n- - The `createmultisig` and `addmultisigaddress` RPCs now return an\n  output script descriptor for the newly created address.  (#18032)\n\nBuild System\n- ------------\n\n- - OpenSSL is no longer used by Bitcoin Core.  (#17265)\n\n- - BIP70 support has been fully removed from Bitcoin Core. The\n  `--enable-bip70` option remains, but it will throw an error during configure.\n  (#17165)\n\n- - glibc 2.17 or greater is now required to run the release binaries. This\n  retains compatibility with RHEL 7, CentOS 7, Debian 8 and Ubuntu 14.04 LTS. (#17538)\n\n- - The source code archives that are provided with gitian builds no longer contain\n  any autotools artifacts. Therefore, to build from such source, a user\n  should run the `./autogen.sh` script from the root of the unpacked archive.\n  This implies that `autotools` and other required packages are installed on the\n  user's system. (#18331)\n\nNew settings\n- ------------\n\n- - New `rpcwhitelist` and `rpcwhitelistdefault` configuration parameters\n  allow giving certain RPC users permissions to only some RPC calls.\n  (#12763)\n\n- - A new `-asmap` configuration option has been added to diversify the\n  node's network connections by mapping IP addresses Autonomous System\n  Numbers (ASNs) and then limiting the number of connections made to any\n  single ASN.  See [issue #16599](https://github.com/bitcoin/bitcoin/issues/16599),\n  [PR #16702](https://github.com/bitcoin/bitcoin/pull/16702), and the\n  `bitcoind help` for more information.  This option is experimental and\n  subject to removal or breaking changes in future releases, so the\n  legacy /16 prefix mapping of IP addresses remains the default.  (#16702)\n\nUpdated settings\n- ----------------\n\n- - All custom settings configured when Bitcoin Core starts are now\n  written to the `debug.log` file to assist troubleshooting.  (#16115)\n\n- - Importing blocks upon startup via the `bootstrap.dat` file no longer\n  occurs by default. The file must now be specified with\n  `-loadblock=<file>`.  (#17044)\n\n- - The `-debug=db` logging category has been renamed to\n  `-debug=walletdb` to distinguish it from `coindb`.  The `-debug=db`\n  option has been deprecated and will be removed in the next major\n  release.  (#17410)\n\n- - The `-walletnotify` configuration parameter will now replace any `%w`\n  in its argument with the name of the wallet generating the\n  notification.  This is not supported on Windows. (#13339)\n\nRemoved settings\n- ----------------\n\n- - The `-whitelistforcerelay` configuration parameter has been removed after\n  it was discovered that it was rendered ineffective in version 0.13 and\n  hasn't actually been supported for almost four years.  (#17985)\n\nGUI changes\n- -----------\n\n- - The \"Start Bitcoin Core on system login\" option has been removed on macOS.\n  (#17567)\n\n- - In the Peers window, the details for a peer now displays a `Mapped AS`\n  field to indicate the mapped Autonomous System used for diversifying\n  peer selection. See the `-asmap` configuration option in _New\n  Settings_, above.  (#18402)\n\n- - A \"known bug\" [announced](https://bitcoincore.org/en/releases/0.18.0/#wallet-gui)\n  in the release notes of version 0.18 has been fixed.  The issue\n  affected anyone who simultaneously used multiple Bitcoin Core wallets\n  and the GUI coin control feature. (#18894)\n\n- - For watch-only wallets, creating a new transaction in the Send screen\n  or fee bumping an existing transaction in the Transactions screen will\n  automatically copy a Partially-Signed Bitcoin Transaction (PSBT) to\n  the system clipboard.  This can then be pasted into an external\n  program such as [HWI](https://github.com/bitcoin-core/HWI) for\n  signing.  Future versions of Bitcoin Core should support a GUI option\n  for finalizing and broadcasting PSBTs, but for now the debug console\n  may be used with the `finalizepsbt` and `sendrawtransaction` RPCs.\n  (#16944, #17492)\n\nWallet\n- ------\n\n- - The wallet now by default uses bech32 addresses when using RPC, and\n  creates native segwit change outputs.  (#16884)\n\n- - The way that output trust was computed has been fixed, which affects\n  confirmed/unconfirmed balance status and coin selection.  (#16766)\n\n- - The `gettransaction`, `listtransactions` and `listsinceblock` RPC\n  responses now also include the height of the block that contains the\n  wallet transaction, if any.  (#17437)\n\n- - The `getaddressinfo` RPC has had its `label` field deprecated\n  (re-enable for this release using the configuration parameter\n  `-deprecatedrpc=label`).  The `labels` field is altered from returning\n  JSON objects to returning a JSON array of label names (re-enable\n  previous behavior for this release using the configuration parameter\n  `-deprecatedrpc=labelspurpose`).  Backwards compatibility using the\n  deprecated configuration parameters is expected to be dropped in the\n  0.21 release.  (#17585, #17578)\n\nDocumentation changes\n- ---------------------\n\n- - Bitcoin Core's automatically-generated source code documentation is\n  now available at https://doxygen.bitcoincore.org.  (#17596)\n\nLow-level changes\n=================\n\nUtilities\n- ---------\n\n- - The `bitcoin-cli` utility used with the `-getinfo` parameter now\n  returns a `headers` field with the number of downloaded block headers\n  on the best headers chain (similar to the `blocks` field that is also\n  returned) and a `verificationprogress` field that estimates how much\n  of the best block chain has been synced by the local node.  The\n  information returned no longer includes the `protocolversion`,\n  `walletversion`, and `keypoololdest` fields.  (#17302, #17650)\n\n- - The `bitcoin-cli` utility now accepts a `-stdinwalletpassphrase`\n  parameter that can be used when calling the `walletpassphrase` and\n  `walletpassphrasechange` RPCs to read the passphrase from standard\n  input without echoing it to the terminal, improving security against\n  anyone who can look at your screen.  The existing `-stdinrpcpass`\n  parameter is also updated to not echo the passphrase. (#13716)\n\nCommand line\n- ------------\n\n- - Command line options prefixed with main/test/regtest network names like\n  `-main.port=8333` `-test.server=1` previously were allowed but ignored. Now\n  they trigger \"Invalid parameter\" errors on startup. (#17482)\n\nNew RPCs\n- --------\n\n- - The `dumptxoutset` RPC outputs a serialized snapshot of the current\n  UTXO set.  A script is provided in the `contrib/devtools` directory\n  for generating a snapshot of the UTXO set at a particular block\n  height.  (#16899)\n\n- - The `generatetodescriptor` RPC allows testers using regtest mode to\n  generate blocks that pay an arbitrary output script descriptor.\n  (#16943)\n\nUpdated RPCs\n- ------------\n\n- - The `verifychain` RPC default values are now static instead of\n  depending on the command line options or configuration file\n  (`-checklevel`, and `-checkblocks`). Users can pass in the RPC\n  arguments explicitly when they don't want to rely on the default\n  values. (#18541)\n\n- - The `getblockchaininfo` RPC's `verificationprogress` field will no\n  longer report values higher than 1.  Previously it would occasionally\n  report the chain was more than 100% verified.  (#17328)\n\nTests\n- -----\n\n- - It is now an error to use an unqualified `walletdir=path` setting in\n  the config file if running on testnet or regtest networks. The setting\n  now needs to be qualified as `chain.walletdir=path` or placed in the\n  appropriate `[chain]` section. (#17447)\n\n- - `-fallbackfee` was 0 (disabled) by default for the main chain, but\n  0.0002 by default for the test chains. Now it is 0 by default for all\n  chains. Testnet and regtest users will have to add\n  `fallbackfee=0.0002` to their configuration if they weren't setting it\n  and they want it to keep working like before. (#16524)\n\nBuild system\n- ------------\n\n- - Support is provided for building with the Android Native Development\n  Kit (NDK).  (#16110)\n\n0.20.0 change log\n=================\n\n### Mining\n- - #18742 miner: Avoid stack-use-after-return in validationinterface (MarcoFalke)\n\n### Block and transaction handling\n- - #15283 log: Fix UB with bench on genesis block (instagibbs)\n- - #16507 feefilter: Compute the absolute fee rather than stored rate (instagibbs)\n- - #16688 log: Add validation interface logging (jkczyz)\n- - #16805 log: Add timing information to FlushStateToDisk() (jamesob)\n- - #16902 O(1) `OP_IF/NOTIF/ELSE/ENDIF` script implementation (sipa)\n- - #16945 introduce CChainState::GetCoinsCacheSizeState (jamesob)\n- - #16974 Walk pindexBestHeader back to ChainActive().Tip() if it is invalid (TheBlueMatt)\n- - #17004 Remove REJECT code from CValidationState (jnewbery)\n- - #17080 Explain why `fCheckDuplicateInputs` can not be skipped and remove it (MarcoFalke)\n- - #17328 GuessVerificationProgress: cap the ratio to 1 (darosior)\n- - #17399 Templatize ValidationState instead of subclassing (jkczyz)\n- - #17407 node: Add reference to mempool in NodeContext (MarcoFalke)\n- - #17708 prevector: Avoid misaligned member accesses (ajtowns)\n- - #17850,#17896,#17957,#18021,#18021,#18112 Serialization improvements (sipa)\n- - #17925 Improve UpdateTransactionsFromBlock with Epochs (JeremyRubin)\n- - #18002 Abstract out script execution out of `VerifyWitnessProgram()` (sipa)\n- - #18388 Make VerifyWitnessProgram use a Span stack (sipa)\n- - #18433 serialization: prevent int overflow for big Coin::nHeight (pierreN)\n- - #18500 chainparams: Bump assumed valid hash (MarcoFalke)\n- - #18551 Do not clear validationinterface entries being executed (sipa)\n\n### P2P protocol and network code\n- - #15437 Remove BIP61 reject messages (MarcoFalke)\n- - #16702 Supply and use asmap to improve IP bucketing in addrman (naumenkogs)\n- - #16851 Continue relaying transactions after they expire from mapRelay (ajtowns)\n- - #17164 Avoid allocating memory for addrKnown where we don't need it (naumenkogs)\n- - #17243 tools: add PoissonNextSend method that returns mockable time (amitiuttarwar)\n- - #17251 SocketHandler logs peer id for close and disconnect (Sjors)\n- - #17573 Seed RNG with precision timestamps on receipt of net messages (TheBlueMatt)\n- - #17624 Fix an uninitialized read in ProcessMessage(\u2026, \"tx\", \u2026) when receiving a transaction we already have (practicalswift)\n- - #17754 Don't allow resolving of std::string with embedded NUL characters. Add tests (practicalswift)\n- - #17758 Fix CNetAddr::IsRFC2544 comment + tests (tynes)\n- - #17812 config, net, test: Asmap feature refinements and functional tests (jonatack)\n- - #17951 Use rolling bloom filter of recent block txs for AlreadyHave() check (sdaftuar)\n- - #17985 Remove forcerelay of rejected txs (MarcoFalke)\n- - #18023 Fix some asmap issues (sipa)\n- - #18054 Reference instead of copy in BlockConnected range loop (jonatack)\n- - #18376 Fix use-after-free in tests (vasild)\n- - #18454 Make addr relay mockable, add test (MarcoFalke)\n- - #18458 Add missing `cs_vNodes` lock (MarcoFalke)\n- - #18506 Hardcoded seeds update for 0.20 (laanwj)\n- - #18808 Drop unknown types in getdata (jnewbery)\n- - #18962 Only send a getheaders for one block in an INV (jnewbery)\n\n### Wallet\n- - #13339 Replace %w by wallet name in -walletnotify script (promag)\n- - #15931 Remove GetDepthInMainChain dependency on locked chain interface (ariard)\n- - #16373 bumpfee: Return PSBT when wallet has privkeys disabled (instagibbs)\n- - #16524 Disable -fallbackfee by default (jtimon)\n- - #16766 Make IsTrusted scan parents recursively (JeremyRubin)\n- - #16884 Change default address type to bech32 (instagibbs)\n- - #16911 Only check the hash of transactions loaded from disk (achow101)\n- - #16923 Handle duplicate fileid exception (promag)\n- - #17056 descriptors: Introduce sortedmulti descriptor (achow101)\n- - #17070 Avoid showing GUI popups on RPC errors (MarcoFalke)\n- - #17138 Remove wallet access to some node arguments (jnewbery)\n- - #17237 LearnRelatedScripts only if KeepDestination (promag)\n- - #17260 Split some CWallet functions into new LegacyScriptPubKeyMan (achow101)\n- - #17261 Make ScriptPubKeyMan an actual interface and the wallet to have multiple (achow101)\n- - #17290 Enable BnB coin selection for preset inputs and subtract fee from outputs (achow101)\n- - #17373 Various fixes and cleanup to keypool handling in LegacyScriptPubKeyMan and CWallet (achow101)\n- - #17410 Rename `db` log category to `walletdb` (like `coindb`) (laanwj)\n- - #17444 Avoid showing GUI popups on RPC errors (take 2) (MarcoFalke)\n- - #17447 Make -walletdir network only (promag)\n- - #17537 Cleanup and move opportunistic and superfluous TopUp()s (achow101)\n- - #17553 Remove out of date comments for CalculateMaximumSignedTxSize (instagibbs)\n- - #17568 Fix when sufficient preset inputs and subtractFeeFromOutputs (achow101)\n- - #17677 Activate watchonly wallet behavior for LegacySPKM only (instagibbs)\n- - #17719 Document better -keypool as a look-ahead safety mechanism (ariard)\n- - #17843 Reset reused transactions cache (fjahr)\n- - #17889 Improve CWallet:MarkDestinationsDirty (promag)\n- - #18034 Get the OutputType for a descriptor (achow101)\n- - #18067 Improve LegacyScriptPubKeyMan::CanProvide script recognition (ryanofsky)\n- - #18115 Pass in transactions and messages for signing instead of exporting the private keys (achow101)\n- - #18192,#18546 Bugfix: Wallet: Safely deal with change in the address book (luke-jr)\n- - #18204 descriptors: Improve descriptor cache and cache xpubs (achow101)\n- - #18274 rpc/wallet: Initialize nFeeRequired to avoid using garbage value on failure (kallewoof)\n- - #18312 Remove deprecated fee bumping by totalFee (jonatack)\n- - #18338 Fix wallet unload race condition (promag)\n\n### RPC and other APIs\n- - #12763 Add RPC Whitelist Feature from #12248 (JeremyRubin)\n- - #13716 cli: `-stdinwalletpassphrase` and non-echo stdin passwords (kallewoof)\n- - #16689 Add missing fields to wallet rpc help output (ariard)\n- - #16821 Fix bug where duplicate PSBT keys are accepted (erasmospunk)\n- - #16899 UTXO snapshot creation (dumptxoutset)\n- - #17156 psbt: Check that various indexes and amounts are within bounds (achow101)\n- - #17264 Set default bip32derivs to true for psbt methods (Sjors)\n- - #17283 improve getaddressinfo test coverage, help, code docs (jonatack)\n- - #17302 cli: Add \"headers\" and \"verificationprogress\" to -getinfo (laanwj)\n- - #17318 replace asserts in RPC code with `CHECK_NONFATAL` and add linter (adamjonas)\n- - #17437 Expose block height of wallet transactions (promag)\n- - #17519 Remove unused `COINBASE_FLAGS` (narula)\n- - #17578 Simplify getaddressinfo labels, deprecate previous behavior (jonatack)\n- - #17585 deprecate getaddressinfo label (jonatack)\n- - #17746 Remove vector copy from listtransactions (promag)\n- - #17809 Auto-format RPCResult (MarcoFalke)\n- - #18032 Output a descriptor in createmultisig and addmultisigaddress (achow101)\n- - #18122 Update validateaddress RPCExamples to bech32 (theStack)\n- - #18208 Change RPCExamples to bech32 (yusufsahinhamza)\n- - #18268 Remove redundant types from descriptions (docallag)\n- - #18346 Document an RPCResult for all calls; Enforce at compile time (MarcoFalke)\n- - #18396 Add missing HelpExampleRpc for getblockfilter (theStack)\n- - #18398 Fix broken RPCExamples for waitforblock(height) (theStack)\n- - #18444 Remove final comma for last entry of fixed-size arrays/objects in RPCResult (luke-jr)\n- - #18459 Remove unused getbalances() code (jonatack)\n- - #18484 Correctly compute redeemScript from witnessScript for signrawtransaction (achow101)\n- - #18487 Fix rpcRunLater race in walletpassphrase (promag)\n- - #18499 Make rpc documentation not depend on call-time rpc args (MarcoFalke)\n- - #18532 Avoid initialization-order-fiasco on static CRPCCommand tables (MarcoFalke)\n- - #18541 Make verifychain default values static, not depend on global args (MarcoFalke)\n- - #18809 Do not advertise dumptxoutset as a way to flush the chainstate (MarcoFalke)\n- - #18814 Relock wallet only if most recent callback (promag)\n\n### GUI\n- - #15023 Restore RPC Console to non-wallet tray icon menu (luke-jr)\n- - #15084 Don't disable the sync overlay when wallet is disabled (benthecarman)\n- - #15098 Show addresses for \"SendToSelf\" transactions (hebasto)\n- - #15756 Add shortcuts for tab tools (promag)\n- - #16944 create PSBT with watch-only wallet (Sjors)\n- - #16964 Change sendcoins dialogue Yes to Send (instagibbs)\n- - #17068 Always generate `bitcoinstrings.cpp` on `make translate` (D4nte)\n- - #17096 Rename debug window (Zero-1729)\n- - #17105 Make RPCConsole::TabTypes an enum class (promag)\n- - #17125 Add toolTip and placeholderText to sign message fields (dannmat)\n- - #17165 Remove BIP70 support (fanquake)\n- - #17180 Improved tooltip for send amount field (JeremyCrookshank)\n- - #17186 Add placeholder text to the sign message field (Danny-Scott)\n- - #17195 Send amount placeholder value (JeremyCrookshank)\n- - #17226 Fix payAmount tooltip in SendCoinsEntry (promag)\n- - #17360 Cleaning up hide button tool tip (Danny-Scott)\n- - #17446 Changed tooltip for 'Label' & 'Message' text fields to be more clear (dannmat)\n- - #17453 Fix intro dialog labels when the prune button is toggled (hebasto)\n- - #17474 Bugfix: GUI: Recognise `NETWORK_LIMITED` in formatServicesStr (luke-jr)\n- - #17492 Bump fee returns PSBT on clipboard for watchonly-only wallets (instagibbs)\n- - #17567 Remove macOS start on login code (fanquake)\n- - #17587 Show watch-only balance in send screen (Sjors)\n- - #17694 Disable 3rd-party tx-urls when wallet disabled (brakmic)\n- - #17696 Force set nPruneSize in QSettings after the intro dialog (hebasto)\n- - #17702 Move static placeholder texts to forms (laanwj)\n- - #17826 Log Qt related info (hebasto)\n- - #17886 Restore English translation option (achow101)\n- - #17906 Set CConnman byte counters earlier to avoid uninitialized reads (ryanofsky)\n- - #17935 Hide HD & encryption icons when no wallet loaded (brakmic)\n- - #17998 Shortcut to close ModalOverlay (emilengler)\n- - #18007 Bugfix: GUI: Hide the HD/encrypt icons earlier so they get re-shown if another wallet is open (luke-jr)\n- - #18060 Drop PeerTableModel dependency to ClientModel (promag)\n- - #18062 Fix unintialized WalletView::progressDialog (promag)\n- - #18091 Pass clientmodel changes from walletframe to walletviews (jonasschnelli)\n- - #18101 Fix deprecated QCharRef usage (hebasto)\n- - #18121 Throttle GUI update pace when -reindex (hebasto)\n- - #18123 Fix race in WalletModel::pollBalanceChanged (ryanofsky)\n- - #18160 Avoid Wallet::GetBalance in WalletModel::pollBalanceChanged (promag)\n- - #18360 Bump transifex slug and update English translations for 0.20 (laanwj)\n- - #18402 Display mapped AS in peers info window (jonatack)\n- - #18492 Translations update pre-branch (laanwj)\n- - #18549 Fix Window -> Minimize menu item (hebasto)\n- - #18578 Fix leak in CoinControlDialog::updateView (promag)\n- - #18894 Fix manual coin control with multiple wallets loaded (promag)\n\n### Build system\n- - #16667 Remove mingw linker workaround from win gitian descriptor (fanquake)\n- - #16669 Use new fork of osslsigncode for windows gitian signing (fanquake)\n- - #16949 Only pass --disable-dependency-tracking to packages that understand it (fanquake)\n- - #17008 Bump libevent to 2.1.11 in depends (stefanwouldgo)\n- - #17029 gitian: Various improvements for windows descriptor (dongcarl)\n- - #17033 Disable _FORTIFY_SOURCE when enable-debug (achow101)\n- - #17057 Switch to upstream libdmg-hfsplus (fanquake)\n- - #17066 Remove workaround for ancient libtool (hebasto)\n- - #17074 Added double quotes (mztriz)\n- - #17087 Add variable printing target to Makefiles (dongcarl)\n- - #17118 depends macOS: point --sysroot to SDK (Sjors)\n- - #17231 Fix boost mac cross build with clang 9+ (theuni)\n- - #17265 Remove OpenSSL (fanquake)\n- - #17284 Update retry to current version (RandyMcMillan)\n- - #17308 nsis: Write to correct filename in first place (dongcarl)\n- - #17324,#18099 Update univalue subtree (MarcoFalke)\n- - #17398 Update leveldb to 1.22+ (laanwj)\n- - #17409 Avoid hardcoded libfaketime dir in gitian (MarcoFalke)\n- - #17466 Fix C{,XX} pickup (dongcarl)\n- - #17483 Set gitian arch back to amd64 (MarcoFalke)\n- - #17486 Make Travis catch unused variables (Sjors)\n- - #17538 Bump minimum libc to 2.17 for release binaries (fanquake)\n- - #17542 Create test utility library from src/test/util/ (brakmic)\n- - #17545 Remove libanl.so.1 from ALLOWED_LIBRARIES (fanquake)\n- - #17547 Fix configure report about qr (hebasto)\n- - #17569 Allow export of environ symbols and work around rv64 toolchain issue (laanwj)\n- - #17647 lcov: filter depends from coverage reports (nijynot)\n- - #17658 Add ability to skip building qrencode (fanquake)\n- - #17678 Support for S390X and POWER targets (MarcoFalke)\n- - #17682 util: Update tinyformat to upstream (laanwj)\n- - #17698 Don't configure `xcb_proto` (fanquake)\n- - #17730 Remove Qt networking features (fanquake)\n- - #17738 Remove linking librt for backwards compatibility (fanquake)\n- - #17740 Remove configure checks for win libraries we don't link against (fanquake)\n- - #17741 Included `test_bitcoin-qt` in msvc build (sipsorcery)\n- - #17756 Remove `WINDOWS_BITS` from build system (fanquake)\n- - #17769 Set `AC_PREREQ` to 2.69 (fanquake)\n- - #17880 Add -Wdate-time to Werror flags (fanquake)\n- - #17910 Remove double `LIBBITCOIN_SERVER` linking (fanquake)\n- - #17928 Consistent use of package variable (Bushstar)\n- - #17933 guix: Pin Guix using `guix time-machine` (dongcarl)\n- - #17948 pass -fno-ident in Windows gitian descriptor (fanquake)\n- - #18003 Remove --large-address-aware linker flag (fanquake)\n- - #18004 Don't embed a build-id when building libdmg-hfsplus (fanquake)\n- - #18051 Fix behavior when `ALLOW_HOST_PACKAGES` unset (hebasto)\n- - #18059 Add missing attributes to Win installer (fanquake)\n- - #18104 Skip i686 build by default in guix and gitian (MarcoFalke)\n- - #18107 Add `cov_fuzz` target (MarcoFalke)\n- - #18135 Add --enable-determinism configure flag (fanquake)\n- - #18145 Add Wreturn-type to Werror flags, check on more Travis machines (Sjors)\n- - #18264 Remove Boost Chrono (fanquake)\n- - #18290 Set minimum Automake version to 1.13 (hebasto)\n- - #18320 guix: Remove now-unnecessary gcc make flag (dongcarl)\n- - #18331 Use git archive as source tarball (hebasto)\n- - #18397 Fix libevent linking for `bench_bitcoin` binary (hebasto)\n- - #18426 scripts: `Previous_release`: improve behaviour on failed download (theStack)\n- - #18429 Remove double `LIBBITCOIN_SERVER` from bench-Makefile (brakmic)\n- - #18528 Create `test_fuzz` library from src/test/fuzz/fuzz.cpp (brakmic)\n- - #18558 Fix boost detection for arch armv7l (hebasto)\n- - #18598 gitian: Add missing automake package to gitian-win-signer.yml (achow101)\n- - #18676 Check libevent minimum version in configure script (hebasto)\n- - #18945 Ensure source tarball has leading directory name (laanwj)\n\n### Platform support\n- - #16110 Add Android NDK support (icota)\n- - #16392 macOS toolchain update (fanquake)\n- - #16569 Increase init file stop timeout (setpill)\n- - #17151 Remove OpenSSL PRNG seeding (Windows, Qt only) (fanquake)\n- - #17365 Update README.md with working Android targets and API levels (icota)\n- - #17521 Only use D-Bus with Qt on linux (fanquake)\n- - #17550 Set minimum supported macOS to 10.12 (fanquake)\n- - #17592 Appveyor install libevent[thread] vcpkg (sipsorcery)\n- - #17660 Remove deprecated key from macOS Info.plist (fanquake)\n- - #17663 Pass `-dead_strip_dylibs` to ld on macOS (fanquake)\n- - #17676 Don't use OpenGL in Qt on macOS (fanquake)\n- - #17686 Add `-bind_at_load` to macOS hardened LDFLAGS (fanquake)\n- - #17787 scripts: Add macho pie check to security-check.py (fanquake)\n- - #17800 random: don't special case clock usage on macOS (fanquake)\n- - #17863 scripts: Add macho dylib checks to symbol-check.py (fanquake)\n- - #17899 msvc: Ignore msvc linker warning and update to msvc build instructions (sipsorcery)\n- - #17916 windows: Enable heap terminate-on-corruption (fanquake)\n- - #18082 logging: Enable `thread_local` usage on macos (fanquake)\n- - #18108 Fix `.gitignore` policy in `build_msvc` directory (hebasto)\n- - #18295 scripts: Add macho lazy bindings check to security-check.py (fanquake)\n- - #18358 util: Fix compilation with mingw-w64 7.0.0 (fanquake)\n- - #18359 Fix sysctl() detection on macOS (fanquake)\n- - #18364 random: remove getentropy() fallback for macOS < 10.12 (fanquake)\n- - #18395 scripts: Add pe dylib checking to symbol-check.py (fanquake)\n- - #18415 scripts: Add macho tests to test-security-check.py (fanquake)\n- - #18425 releases: Update with new Windows code signing certificate (achow101)\n- - #18702 Fix ASLR for bitcoin-cli on Windows (fanquake)\n\n### Tests and QA\n- - #12134 Build previous releases and run functional tests (Sjors)\n- - #13693 Add coverage to estimaterawfee and estimatesmartfee (Empact)\n- - #13728 lint: Run the ci lint stage on mac (Empact)\n- - #15443 Add getdescriptorinfo functional test (promag)\n- - #15888 Add `wallet_implicitsegwit` to test the ability to transform keys between address types (luke-jr)\n- - #16540 Add `ASSERT_DEBUG_LOG` to unit test framework (MarcoFalke)\n- - #16597 travis: Run full test suite on native macos (Sjors)\n- - #16681 Use self.chain instead of 'regtest' in all current tests (jtimon)\n- - #16786 add unit test for wallet watch-only methods involving PubKeys (theStack)\n- - #16943 Add generatetodescriptor RPC (MarcoFalke)\n- - #16973 Fix `combine_logs.py` for AppVeyor build (mzumsande)\n- - #16975 Show debug log on unit test failure (MarcoFalke)\n- - #16978 Seed test RNG context for each test case, print seed (MarcoFalke)\n- - #17009, #17018, #17050, #17051, #17071, #17076, #17083, #17093, #17109, #17113, #17136, #17229, #17291, #17357, #17771, #17777, #17917, #17926, #17972, #17989, #17996, #18009, #18029, #18047, #18126, #18176, #18206, #18353, #18363, #18407, #18417, #18423, #18445, #18455, #18565 Add fuzzing harnesses (practicalswift)\n- - #17011 ci: Use busybox utils for one build (MarcoFalke)\n- - #17030 Fix Python Docstring to include all Args (jbampton)\n- - #17041 ci: Run tests on arm (MarcoFalke)\n- - #17069 Pass fuzzing inputs as constant references (practicalswift)\n- - #17091 Add test for loadblock option and linearize scripts (fjahr)\n- - #17108 fix \"tx-size-small\" errors after default address change (theStack)\n- - #17121 Speed up `wallet_backup` by whitelisting peers (immediate tx relay) (theStack)\n- - #17124 Speed up `wallet_address_types` by whitelisting peers (immediate tx relay) (theStack)\n- - #17140 Fix bug in `blockfilter_index_tests` (jimpo)\n- - #17199 use default address type (bech32) for `wallet_bumpfee` tests (theStack)\n- - #17205 ci: Enable address sanitizer (asan) stack-use-after-return checking (practicalswift)\n- - #17206 Add testcase to simulate bitcoin schema in leveldb (adamjonas)\n- - #17209 Remove no longer needed UBSan suppressions (issues fixed). Add documentation (practicalswift)\n- - #17220 Add unit testing for the CompressScript function (adamjonas)\n- - #17225 Test serialisation as part of deserialisation fuzzing. Test round-trip equality where possible (practicalswift)\n- - #17228 Add RegTestingSetup to `setup_common` (MarcoFalke)\n- - #17233 travis: Run unit and functional tests on native arm (MarcoFalke)\n- - #17235 Skip unnecessary fuzzer initialisation. Hold ECCVerifyHandle only when needed (practicalswift)\n- - #17240 ci: Disable functional tests on mac host (MarcoFalke)\n- - #17254 Fix `script_p2sh_tests` `OP_PUSHBACK2/4` missing (adamjonas)\n- - #17267 bench: Fix negative values and zero for -evals flag (nijynot)\n- - #17275 pubkey: Assert CPubKey's ECCVerifyHandle precondition (practicalswift)\n- - #17288 Added TestWrapper class for interactive Python environments (jachiang)\n- - #17292 Add new mempool benchmarks for a complex pool (JeremyRubin)\n- - #17299 add reason checks for non-standard txs in `test_IsStandard` (theStack)\n- - #17322 Fix input size assertion in `wallet_bumpfee.py` (instagibbs)\n- - #17327 Add `rpc_fundrawtransaction` logging (jonatack)\n- - #17330 Add `shrinkdebugfile=0` to regtest bitcoin.conf (sdaftuar)\n- - #17340 Speed up fundrawtransaction test (jnewbery)\n- - #17345 Do not instantiate CAddrDB for static call CAddrDB::Read() (hebasto)\n- - #17362 Speed up `wallet_avoidreuse`, add logging (jonatack)\n- - #17363 add \"diamond\" unit test to MempoolAncestryTests (theStack)\n- - #17366 Reset global args between test suites (MarcoFalke)\n- - #17367 ci: Run non-cross-compile builds natively (MarcoFalke)\n- - #17378 TestShell: Fix typos & implement cleanups (jachiang)\n- - #17384 Create new test library (MarcoFalke)\n- - #17387 `wallet_importmulti`: use addresses of the same type as being imported (achow101)\n- - #17388 Add missing newline in `util_ChainMerge` test (ryanofsky)\n- - #17390 Add `util_ArgParsing` test (ryanofsky)\n- - #17420 travis: Rework `cache_err_msg` (MarcoFalke)\n- - #17423 ci: Make ci system read-only on the git work tree (MarcoFalke)\n- - #17435 check custom ancestor limit in `mempool_packages.py` (theStack)\n- - #17455 Update valgrind suppressions (practicalswift)\n- - #17461 Check custom descendant limit in `mempool_packages.py` (theStack)\n- - #17469 Remove fragile `assert_memory_usage_stable` (MarcoFalke)\n- - #17470 ci: Use clang-8 for fuzzing to run on aarch64 ci systems (MarcoFalke)\n- - #17480 Add unit test for non-standard txs with too large scriptSig (theStack)\n- - #17497 Skip tests when utils haven't been compiled (fanquake)\n- - #17502 Add unit test for non-standard bare multisig txs (theStack)\n- - #17511 Add bounds checks before base58 decoding (sipa)\n- - #17517 ci: Bump to clang-8 for asan build to avoid segfaults on ppc64le (MarcoFalke)\n- - #17522 Wait until mempool is loaded in `wallet_abandonconflict` (MarcoFalke)\n- - #17532 Add functional test for non-standard txs with too large scriptSig (theStack)\n- - #17541 Add functional test for non-standard bare multisig txs (theStack)\n- - #17555 Add unit test for non-standard txs with wrong nVersion (dspicher)\n- - #17571 Add `libtest_util` library to msvc build configuration (sipsorcery)\n- - #17591 ci: Add big endian platform - s390x (elichai)\n- - #17593 Move more utility functions into test utility library (mzumsande)\n- - #17633 Add option --valgrind to run the functional tests under Valgrind (practicalswift)\n- - #17635 ci: Add centos 7 build (hebasto)\n- - #17641 Add unit test for leveldb creation with unicode path (sipsorcery)\n- - #17674 Add initialization order fiasco detection in Travis (practicalswift)\n- - #17675 Enable tests which are incorrectly skipped when running `test_runner.py --usecli` (practicalswift)\n- - #17685 Fix bug in the descriptor parsing fuzzing harness (`descriptor_parse`) (practicalswift)\n- - #17705 re-enable CLI test support by using EncodeDecimal in json.dumps() (fanquake)\n- - #17720 add unit test for non-standard \"scriptsig-not-pushonly\" txs (theStack)\n- - #17767 ci: Fix qemu issues (MarcoFalke)\n- - #17793 ci: Update github actions ci vcpkg cache on msbuild update (hebasto)\n- - #17806 Change filemode of `rpc_whitelist.py` (emilengler)\n- - #17849 ci: Fix brew python link (hebasto)\n- - #17851 Add `std::to_string` to list of locale dependent functions (practicalswift)\n- - #17893 Fix double-negative arg test (hebasto)\n- - #17900 ci: Combine 32-bit build with centos 7 build (theStack)\n- - #17921 Test `OP_CSV` empty stack fail in `feature_csv_activation.py` (theStack)\n- - #17931 Fix `p2p_invalid_messages` failing in Python 3.8 because of warning (elichai)\n- - #17947 add unit test for non-standard txs with too large tx size (theStack)\n- - #17959 Check specific reject reasons in `feature_csv_activation.py` (theStack)\n- - #17984 Add p2p test for forcerelay permission (MarcoFalke)\n- - #18001 Updated appveyor job to checkout a specific vcpkg commit ID (sipsorcery)\n- - #18008 fix fuzzing using libFuzzer on macOS (fanquake)\n- - #18013 bench: Fix benchmarks filters (elichai)\n- - #18018 reset fIsBareMultisigStd after bare-multisig tests (fanquake)\n- - #18022 Fix appveyor `test_bitcoin` build of `*.raw` (MarcoFalke)\n- - #18037 util: Allow scheduler to be mocked (amitiuttarwar)\n- - #18056 ci: Check for submodules (emilengler)\n- - #18069 Replace 'regtest' leftovers by self.chain (theStack)\n- - #18081 Set a name for CI Docker containers (fanquake)\n- - #18109 Avoid hitting some known minor tinyformat issues when fuzzing strprintf(\u2026) (practicalswift)\n- - #18155 Add harness which fuzzes EvalScript and VerifyScript using a fuzzed signature checker (practicalswift)\n- - #18159 Add --valgrind option to `test/fuzz/test_runner.py` for running fuzzing test cases under valgrind (practicalswift)\n- - #18166 ci: Run fuzz testing test cases (bitcoin-core/qa-assets) under valgrind to catch memory errors (practicalswift)\n- - #18172 Transaction expiry from mempool (0xB10C)\n- - #18181 Remove incorrect assumptions in `validation_flush_tests` (MarcoFalke)\n- - #18183 Set `catch_system_errors=no` on boost unit tests (MarcoFalke)\n- - #18195 Add `cost_of_change` parameter assertions to `bnb_search_test` (yancyribbens)\n- - #18209 Reduce unneeded whitelist permissions in tests (MarcoFalke)\n- - #18211 Disable mockforward scheduler unit test for now (MarcoFalke)\n- - #18213 Fix race in `p2p_segwit` (MarcoFalke)\n- - #18224 Make AnalyzePSBT next role calculation simple, correct (instagibbs)\n- - #18228 Add missing syncwithvalidationinterfacequeue (MarcoFalke)\n- - #18247 Wait for both veracks in `add_p2p_connection` (MarcoFalke)\n- - #18249 Bump timeouts to accomodate really slow disks (MarcoFalke)\n- - #18255 Add `bad-txns-*-toolarge` test cases to `invalid_txs` (MarcoFalke)\n- - #18263 rpc: change setmocktime check to use IsMockableChain (gzhao408)\n- - #18285 Check that `wait_until` returns if time point is in the past (MarcoFalke)\n- - #18286 Add locale fuzzer to `FUZZERS_MISSING_CORPORA` (practicalswift)\n- - #18292 fuzz: Add `assert(script == decompressed_script)` (MarcoFalke)\n- - #18299 Update `FUZZERS_MISSING_CORPORA` to enable regression fuzzing for all harnesses in master (practicalswift)\n- - #18300 fuzz: Add option to merge input dir to test runner (MarcoFalke)\n- - #18305 Explain why test logging should be used (MarcoFalke)\n- - #18306 Add logging to `wallet_listsinceblock.py` (jonatack)\n- - #18311 Bumpfee test fix (instagibbs)\n- - #18314 Add deserialization fuzzing of SnapshotMetadata (`utxo_snapshot`) (practicalswift)\n- - #18319 fuzz: Add missing `ECC_Start` to `key_io` test (MarcoFalke)\n- - #18334 Add basic test for BIP 37 (MarcoFalke)\n- - #18350 Fix mining to an invalid target + ensure that a new block has the correct hash internally (TheQuantumPhysicist)\n- - #18378 Bugfix & simplify bn2vch using `int.to_bytes` (sipa)\n- - #18393 Don't assume presence of `__builtin_mul_overflow(\u2026)` in `MultiplicationOverflow(\u2026)` fuzzing harness (practicalswift)\n- - #18406 add executable flag for `rpc_estimatefee.py` (theStack)\n- - #18420 listsinceblock block height checks (jonatack)\n- - #18430 ci: Only clone bitcoin-core/qa-assets when fuzzing (MarcoFalke)\n- - #18438 ci: Use homebrew addon on native macos (hebasto)\n- - #18447 Add coverage for script parse error in ParseScript (pierreN)\n- - #18472 Remove unsafe `BOOST_TEST_MESSAGE` (MarcoFalke)\n- - #18474 check that peer is connected when calling sync_* (MarcoFalke)\n- - #18477 ci: Use focal for fuzzers (MarcoFalke)\n- - #18481 add BIP37 'filterclear' test to p2p_filter.py (theStack)\n- - #18496 Remove redundant `sync_with_ping` after `add_p2p_connection` (jonatack)\n- - #18509 fuzz: Avoid running over all inputs after merging them (MarcoFalke)\n- - #18510 fuzz: Add CScriptNum::getint coverage (MarcoFalke)\n- - #18514 remove rapidcheck integration and tests (fanquake)\n- - #18515 Add BIP37 remote crash bug [CVE-2013-5700] test to `p2p_filter.py` (theStack)\n- - #18516 relax bumpfee `dust_to_fee` txsize an extra vbyte (jonatack)\n- - #18518 fuzz: Extend descriptor fuzz test (MarcoFalke)\n- - #18519 fuzz: Extend script fuzz test (MarcoFalke)\n- - #18521 fuzz: Add `process_messages` harness (MarcoFalke)\n- - #18529 Add fuzzer version of randomized prevector test (sipa)\n- - #18534 skip backwards compat tests if not compiled with wallet (fanquake)\n- - #18540 `wallet_bumpfee` assertion fixup (jonatack)\n- - #18543 Use one node to avoid a race due to missing sync in `rpc_signrawtransaction` (MarcoFalke)\n- - #18561 Properly raise FailedToStartError when rpc shutdown before warmup finished (MarcoFalke)\n- - #18562 ci: Run unit tests sequential once (MarcoFalke)\n- - #18563 Fix `unregister_all_during_call` cleanup (ryanofsky)\n- - #18566 Set `-use_value_profile=1` when merging fuzz inputs (MarcoFalke)\n- - #18757 Remove enumeration of expected deserialization exceptions in ProcessMessage(\u2026) fuzzer (practicalswift)\n- - #18878 Add test for conflicted wallet tx notifications (ryanofsky)\n- - #18975 Remove const to work around compiler error on xenial (laanwj)\n\n### Documentation\n- - #16947 Doxygen-friendly script/descriptor.h comments (ch4ot1c)\n- - #16983 Add detailed info about Bitcoin Core files (hebasto)\n- - #16986 Doxygen-friendly CuckooCache comments (ch4ot1c)\n- - #17022 move-only: Steps for \"before major release branch-off\" (MarcoFalke)\n- - #17026 Update bips.md for default bech32 addresses in 0.20.0 (MarcoFalke)\n- - #17081 Fix Makefile target in benchmarking.md (theStack)\n- - #17102 Add missing indexes/blockfilter/basic to doc/files.md (MarcoFalke)\n- - #17119 Fix broken bitcoin-cli examples (andrewtoth)\n- - #17134 Add switch on enum example to developer notes (hebasto)\n- - #17142 Update macdeploy README to include all files produced by `make deploy` (za-kk)\n- - #17146 github: Add warning for bug reports (laanwj)\n- - #17157 Added instructions for how to add an upsteam to forked repo (dannmat)\n- - #17159 Add a note about backporting (carnhofdaki)\n- - #17169 Correct function name in ReportHardwareRand() (fanquake)\n- - #17177 Describe log files + consistent paths in test READMEs (fjahr)\n- - #17239 Changed miniupnp links to https (sandakersmann)\n- - #17281 Add developer note on `c_str()` (laanwj)\n- - #17285 Bip70 removal follow-up (fjahr)\n- - #17286 Fix help-debug -checkpoints (ariard)\n- - #17309 update MSVC instructions to remove Qt OpenSSL linking (fanquake)\n- - #17339 Add template for good first issues (michaelfolkson)\n- - #17351 Fix some misspellings (RandyMcMillan)\n- - #17353 Add ShellCheck to lint tests dependencies (hebasto)\n- - #17370 Update doc/bips.md with recent changes in master (MarcoFalke)\n- - #17393 Added regtest config for linearize script (gr0kchain)\n- - #17411 Add some better examples for scripted diff (laanwj)\n- - #17503 Remove bitness from bitcoin-qt help message and manpage (laanwj)\n- - #17539 Update and improve Developer Notes (hebasto)\n- - #17561 Changed MiniUPnPc link to https in dependencies.md (sandakersmann)\n- - #17596 Change doxygen URL to doxygen.bitcoincore.org (laanwj)\n- - #17598 Update release process with latest changes (MarcoFalke)\n- - #17617 Unify unix epoch time descriptions (jonatack)\n- - #17637 script: Add keyserver to verify-commits readme (emilengler)\n- - #17648 Rename wallet-tool references to bitcoin-wallet (hel-o)\n- - #17688 Add \"ci\" prefix to CONTRIBUTING.md (hebasto)\n- - #17751 Use recommended shebang approach in documentation code block (hackerrdave)\n- - #17752 Fix directory path for secp256k1 subtree in developer-notes (hackerrdave)\n- - #17772 Mention PR Club in CONTRIBUTING.md (emilengler)\n- - #17804 Misc RPC help fixes (MarcoFalke)\n- - #17819 Developer notes guideline on RPCExamples addresses (jonatack)\n- - #17825 Update dependencies.md (hebasto)\n- - #17873 Add to Doxygen documentation guidelines (jonatack)\n- - #17907 Fix improper Doxygen inline comments (Empact)\n- - #17942 Improve fuzzing docs for macOS users (fjahr)\n- - #17945 Fix doxygen errors (Empact)\n- - #18025 Add missing supported rpcs to doc/descriptors.md (andrewtoth)\n- - #18070 Add note about `brew doctor` (givanse)\n- - #18125 Remove PPA note from release-process.md (fanquake)\n- - #18170 Minor grammatical changes and flow improvements (travinkeith)\n- - #18212 Add missing step in win deployment instructions (dangershony)\n- - #18219 Add warning against wallet.dat re-use (corollari)\n- - #18253 Correct spelling errors in comments (Empact)\n- - #18278 interfaces: Describe and follow some code conventions (ryanofsky)\n- - #18283 Explain rebase policy in CONTRIBUTING.md (MarcoFalke)\n- - #18340 Mention MAKE=gmake workaround when building on a BSD (fanquake)\n- - #18341 Replace remaining literal BTC with `CURRENCY_UNIT` (domob1812)\n- - #18342 Add fuzzing quickstart guides for libFuzzer and afl-fuzz (practicalswift)\n- - #18344 Fix nit in getblockchaininfo (stevenroose)\n- - #18379 Comment fix merkle.cpp (4d55397500)\n- - #18382 note the costs of fetching all pull requests (vasild)\n- - #18391 Update init and reduce-traffic docs for -blocksonly (glowang)\n- - #18464 Block-relay-only vs blocksonly (MarcoFalke)\n- - #18486 Explain new test logging (MarcoFalke)\n- - #18505 Update webchat URLs in README.md (SuriyaaKudoIsc)\n- - #18513 Fix git add argument (HashUnlimited)\n- - #18577 Correct scripted-diff example link (yahiheb)\n- - #18589 Fix naming of macOS SDK and clarify version (achow101)\n\n### Miscellaneous\n- - #15600 lockedpool: When possible, use madvise to avoid including sensitive information in core dumps (luke-jr)\n- - #15934 Merge settings one place instead of five places (ryanofsky)\n- - #16115 On bitcoind startup, write config args to debug.log (LarryRuane)\n- - #16117 util: Replace boost sleep with std sleep (MarcoFalke)\n- - #16161 util: Fix compilation errors in support/lockedpool.cpp (jkczyz)\n- - #16802 scripts: In linearize, search for next position of magic bytes rather than fail (takinbo)\n- - #16889 Add some general std::vector utility functions (sipa)\n- - #17049 contrib: Bump gitian descriptors for 0.20 (MarcoFalke)\n- - #17052 scripts: Update `copyright_header` script to include additional files (GChuf)\n- - #17059 util: Simplify path argument for cblocktreedb ctor (hebasto)\n- - #17191 random: Remove call to `RAND_screen()` (Windows only) (fanquake)\n- - #17192 util: Add `check_nonfatal` and use it in src/rpc (MarcoFalke)\n- - #17218 Replace the LogPrint function with a macro (jkczyz)\n- - #17266 util: Rename decodedumptime to parseiso8601datetime (elichai)\n- - #17270 Feed environment data into RNG initializers (sipa)\n- - #17282 contrib: Remove accounts from bash completion (fanquake)\n- - #17293 Add assertion to randrange that input is not 0 (JeremyRubin)\n- - #17325 log: Fix log message for -par=1 (hebasto)\n- - #17329 linter: Strip trailing / in path for git-subtree-check (jnewbery)\n- - #17336 scripts: Search for first block file for linearize-data with some block files pruned (Rjected)\n- - #17361 scripts: Lint gitian descriptors with shellcheck (hebasto)\n- - #17482 util: Disallow network-qualified command line options (ryanofsky)\n- - #17507 random: mark RandAddPeriodic and SeedPeriodic as noexcept (fanquake)\n- - #17527 Fix CPUID subleaf iteration (sipa)\n- - #17604 util: Make schedulebatchpriority advisory only (fanquake)\n- - #17650 util: Remove unwanted fields from bitcoin-cli -getinfo (malevolent)\n- - #17671 script: Fixed wget call in gitian-build.py (willyko)\n- - #17699 Make env data logging optional (sipa)\n- - #17721 util: Don't allow base58 decoding of non-base58 strings. add base58 tests (practicalswift)\n- - #17750 util: Change getwarnings parameter to bool (jnewbery)\n- - #17753 util: Don't allow base32/64-decoding or parsemoney(\u2026) on strings with embedded nul characters. add tests (practicalswift)\n- - #17823 scripts: Read suspicious hosts from a file instead of hardcoding (sanjaykdragon)\n- - #18162 util: Avoid potential uninitialized read in `formatiso8601datetime(int64_t)` by checking `gmtime_s`/`gmtime_r` return value (practicalswift)\n- - #18167 Fix a violation of C++ standard rules where unions are used for type-punning (TheQuantumPhysicist)\n- - #18225 util: Fail to parse empty string in parsemoney (MarcoFalke)\n- - #18270 util: Fail to parse whitespace-only strings in parsemoney(\u2026) (instead of parsing as zero) (practicalswift)\n- - #18316 util: Helpexamplerpc formatting (jonatack)\n- - #18357 Fix missing header in sync.h (promag)\n- - #18412 script: Fix `script_err_sig_pushonly` error string (theStack)\n- - #18416 util: Limit decimal range of numbers parsescript accepts (pierreN)\n- - #18503 init: Replace `URL_WEBSITE` with `PACKAGE_URL` (MarcoFalke)\n- - #18526 Remove PID file at the very end (hebasto)\n- - #18553 Avoid non-trivial global constants in SHA-NI code (sipa)\n- - #18665 Do not expose and consider `-logthreadnames` when it does not work (hebasto)\n\nCredits\n=======\n\nThanks to everyone who directly contributed to this release:\n\n- - 0xb10c\n- - 251\n- - 4d55397500\n- - Aaron Clauson\n- - Adam Jonas\n- - Albert\n- - Amiti Uttarwar\n- - Andrew Chow\n- - Andrew Toth\n- - Anthony Towns\n- - Antoine Riard\n- - Ava Barron\n- - Ben Carman\n- - Ben Woosley\n- - Block Mechanic\n- - Brian Solon\n- - Bushstar\n- - Carl Dong\n- - Carnhof Daki\n- - Cory Fields\n- - Daki Carnhof\n- - Dan Gershony\n- - Daniel Kraft\n- - dannmat\n- - Danny-Scott\n- - darosior\n- - David O'Callaghan\n- - Dominik Spicher\n- - Elichai Turkel\n- - Emil Engler\n- - emu\n- - Fabian Jahr\n- - fanquake\n- - Filip Gospodinov\n- - Franck Royer\n- - Gast\u00f3n I. Silva\n- - gchuf\n- - Gleb Naumenko\n- - Gloria Zhao\n- - glowang\n- - Gr0kchain\n- - Gregory Sanders\n- - hackerrdave\n- - Harris\n- - hel0\n- - Hennadii Stepanov\n- - ianliu\n- - Igor Cota\n- - James Chiang\n- - James O'Beirne\n- - Jan Beich\n- - Jan Sarenik\n- - Jeffrey Czyz\n- - Jeremy Rubin\n- - JeremyCrookshank\n- - Jim Posen\n- - John Bampton\n- - John L. Jegutanis\n- - John Newbery\n- - Jon Atack\n- - Jon Layton\n- - Jonas Schnelli\n- - Jo\u00e3o Barbosa\n- - Jorge Tim\u00f3n\n- - Karl-Johan Alm\n- - kodslav\n- - Larry Ruane\n- - Luke Dashjr\n- - malevolent\n- - MapleLaker\n- - marcaiaf\n- - MarcoFalke\n- - Marius Kj\u00e6rstad\n- - Mark Erhardt\n- - Mark Tyneway\n- - Martin Erlandsson\n- - Martin Zumsande\n- - Matt Corallo\n- - Matt Ward\n- - Michael Folkson\n- - Michael Polzer\n- - Micky Yun Chan\n- - Neha Narula\n- - nijynot\n- - naumenkogs\n- - NullFunctor\n- - Peter Bushnell\n- - pierrenn\n- - Pieter Wuille\n- - practicalswift\n- - randymcmillan\n- - Rjected\n- - Russell Yanofsky\n- - Samer Afach\n- - Samuel Dobson\n- - Sanjay K\n- - Sebastian Falbesoner\n- - setpill\n- - Sjors Provoost\n- - Stefan Richter\n- - stefanwouldgo\n- - Steven Roose\n- - Suhas Daftuar\n- - Suriyaa Sundararuban\n- - TheCharlatan\n- - Tim Akinbo\n- - Travin Keith\n- - tryphe\n- - Vasil Dimov\n- - Willy Ko\n- - Wilson Ccasihue S\n- - Wladimir J. van der Laan\n- - Yahia Chiheb\n- - Yancy Ribbens\n- - Yusuf Sahin HAMZA\n- - Zakk\n- - Zero\n\nAs well as to everyone that helped with translations on\n[Transifex](https://www.transifex.com/bitcoin/bitcoin/).\n-----BEGIN PGP SIGNATURE-----\n\niQEzBAEBCgAdFiEEnerg3HBjJJ+wVHRoHkrtYphs0l0FAl7XfU4ACgkQHkrtYphs\n0l2cDgf+LRNcSCBQ6drHVobWXZQqRy/l9p5pTJQm5hZBrvuwinCajv45fGQO8nHU\nF/hPAxoRBr6yEAoihOg1iYJxRJc0oH6SZhrgFv+z01+SNQLAzXiHpf/2lGQN97jC\nFLMNGqd/qAsWxQxB2TE5fewsEKQ07aMQvlESlqzIiAWT0YcjBqBlIaR42whdVg3i\nxQT0RYEI606ASWndFa2pTj5jF+/1ll7vBSvel2XMWZb2Y8W/kEYqpaY5Z5VoIpjE\ndRYPUKd8fDJH6cRN/KVwEFMAry/5aF08ZpsqghPAGUoRVuI71jPU/YYwIaBA921k\nUbc+7DrLD4ZgRJau9X+1TglkZTsOjg==\n=6O7i\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.20.0 released",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Wladimir J. van der Laan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 52796
        }
    },
    {
        "title": "[bitcoin-dev] Time-dilation Attacks on the Lightning Network",
        "thread_messages": [
            {
                "author": "Gleb Naumenko",
                "date": "2020-06-03T16:20:09",
                "message_text_only": "Hi! I and Antoine Riard explored time-dilation attacks on Lightning.\n\nWe have a blogpost, which is probably too long to include in the email in full.\nYou can read it here:\u00a0https://discrete-blog.github.io/time-dilation/\nThere\u2019s also a paper we wrote:\u00a0https://arxiv.org/abs/2006.01418\n\n\nWe believe this work should be interesting for anyone curious/excited about LN or other second-layer protocols in Bitcoin. We are very interested in your opinions!\n\nNow, let me share the intro from the post with you (which is really a summary of the work), since it\u2019s about the right size for a mailing list post. Hopefully, it would motivate you to read further.\n\nProtocols on top of the Bitcoin base layer are really cool. They offer tremendous opportunities in terms of scalability, confidentiality, and functionality, at a cost of new security assumptions.\n\nWe all know payment channels have to be monitored, otherwise, the funds can be stolen. That sounds too abstract though. We decided to study what an attacker actually has to do to steal funds from LN users.\n\nMore specifically, we explored how peer-to-peer layer attacks can help with breaking the assumption above. Per time-dilation attacks, an attacker controls the victim\u2019s access to the Bitcoin network (hard, but not impossible) and delays block delivery to the victim. After that, the attacker exploits that the victim can\u2019t access recent blocks in a timely manner. In some cases, it is enough to isolate the victim only for two hours.\n\nThen the attacker makes a couple (totally legit) actions on the Lightning Network towards the victim\u2019s channels, and at the same time commits a different state instead. Since the victim is behind in terms of the latest blockchain tip, they cannot detect this and react as required by the protocol.\n\nWe demonstrate three different ways the attacker can steal funds from the victim, and discuss the feasibility/cost of these attacks. We also explore the broad scope of countermeasures, which may significantly increase the attack cost.\n\nIn short, the takeaways from our work are:\n\n1. Many Lightning users (those with Bitcoin light clients) are currently vulnerable to Eclipse attacks.\n2. Those Lightning users which run Bitcoin Core full nodes are more robust to Eclipse attacks, but the attacks are still possible as recent research suggests.\n3. Eclipse attacks enable stealing funds via time-dilation.\n4. Time-dilation attacks can\u2019t be mitigated with just observing slow block arrival, so there is no simple solution to (3).\n5. Thus, time-dilation is a practical way to steal funds from eclipsed users. Neither it requires hashrate nor targets merchants only. Light client users are a good target because they are easy to attack. Full node users are a good target because they are often used by major hubs (or service providers), and stealing their aggregate liquidiy might justify the high attack cost.\n6. Strong anti-Eclipse measures is the key solution. WatchTowers are cool too.\n\n\nBest,\n\nGleb Naumenko and Antoine Riard\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200603/c9aff631/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-04T02:58:24",
                "message_text_only": "Good morning Gleb and Antoine,\n\nThis is good research, thank you for your work.\n\n> **Targeting Per-Hop Packet Delay** is based on routing via the victim, and the victim should have at least two channels with the attacker.\n\nThe existence of offchain-to-onchain swap services means that the attacker needs only build one channel to the victim for this attack to work.\nRather than route to themselves, the attacker routes to a convenient service providing such a swap service, and receives the stolen funds onchain, with no need even for an incoming channel from a different node.\n(Of note as well, is that the onchain contract provided by such services is the same in spirit as those instantiated in channels of the Lightning Network, thus the same attack schema works on the onchain side.)\n\nIndeed, the attack can be mounted on such a service directly.\n\nEven without such a service, the incoming channel need not be directly connected to the victim.\n\n\n> [Tor is tricky](https://arxiv.org/abs/1410.6079) too\n\nSince the issue here is that eclipsing of Bitcoin nodes is risky, it strikes me that a mitigation would be to run your Bitcoin fullnode on clearnet while running your Lightning node over Tor.\nEclipsing the Lightning node (but not the Bitcoin fullnode it depends on) \"only\" loses you the ability to pay, receive, or route (and thereby earn forwarding fees), but as long as your blockchain view is clear, it should be fine.\n\nOf course, the Lightning node could still be correlated with the Bitcoin node when transactions are broadcast with the attached Bitcoin node (as noted in the paper).\nInstead the Lightning node should probably connect, over Tor, to some random Bitcoin fullnodes / Electrum servers and broadcast txes to them.\n\nAnd this seems to tie with what you propose: that the LN node should use a different view-fullnode from the broadcast-fullnode.\n\n\n> if a node doesn\u2019t observe a block within the last 30 minutes, it attempts to make a new random connection to someone in the network.\n\nA mitigation to this would be to run a background process which sleeps for 20 minutes, then does `bitcoin-cli addnode ${BITCOINNODE} onetry`.\nIt might want to `disconnectnode` any previous node it attempted to connect to.\n\nHowever I note that the help for `addnode` contains the text \"though such peers will not be synced from\", which confuses me, since it also refers to the `-connect` command line option, and `-connect` means you only connect out to the specific nodes, so if those are not synced from.... huh?\n\nAnd of course the interesting part is \"how do we get a `${BITCOINNODE}` that we think is not part of the eclipsing attacker?\"\n\n\n> If a Lightning node is behind in its Bitcoin blockchain view, but Lightning payments between honest nodes are still flowing through it, this node will have a high routing failure rate. This would happen because honest nodes on the routing path would reject the forwarded HTLC for being too close to expired.\n\nI am uncertain this would happen very often.\nIn the first place, the incoming HTLC would have \"reasonable\" timeouts, or else the incoming honest node would not have routed it at all, and the outgoing HTLC would be relative to this incoming one, so the outgoing honest node will still accept this.\n\nThe victim *could* instead check that the absolute timelocks seem very far in the future relative to its own view of the current blockheight.\n(a forwarding node miht want to do that anyway to have an upper bound against griefing attacks)\n\nWhat would definitely increase in failure rate would be payments arising from the victim node; the victim node believes the blockheight to be much lower than it actually is, and either the payee node, or some intermediate node along the route, will claim to have too little time to safely forward the funds.\nThis does not help for nodes which are primarily forwarding nodes.\n\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2020-06-05T10:10:20",
                "message_text_only": "Le 04/06/2020 \u00e0 04:58, ZmnSCPxj via bitcoin-dev a \u00e9crit\u00a0:\n>> [Tor is tricky](https://arxiv.org/abs/1410.6079) too\n> Since the issue here is that eclipsing of Bitcoin nodes is risky, it strikes me that a mitigation would be to run your Bitcoin fullnode on clearnet while running your Lightning node over Tor.\n> Eclipsing the Lightning node (but not the Bitcoin fullnode it depends on) \"only\" loses you the ability to pay, receive, or route (and thereby earn forwarding fees), but as long as your blockchain view is clear, it should be fine.\n>\n> Of course, the Lightning node could still be correlated with the Bitcoin node when transactions are broadcast with the attached Bitcoin node (as noted in the paper).\n> Instead the Lightning node should probably connect, over Tor, to some random Bitcoin fullnodes / Electrum servers and broadcast txes to them.\n>\n> And this seems to tie with what you propose: that the LN node should use a different view-fullnode from the broadcast-fullnode.\n>\n\nThe issue each time there are discussions/research linking to Tor is\nthat it is biased since the beginning because based on a wrong\npostulate: using the Tor network\n\nI will not elaborate on this again, it's an obvious very bad idea to use\nthe Tor network for bitcoin\n\nIt's not a bad idea to use the Tor protocol with no story of exit nodes\nand hidden services, linking again to:\nhttps://github.com/Ayms/node-Tor#phase-4-and-phase-5\n\nAnd new link: http://www.peersm.com/Convergence-2020.pdf \"A universal\nand generic architecture to anonymize any application or protocol and\nturn it into an independent decentralized p2p network inside browsers\nand servers, with browsers acting as servers\"\n\nLN and bitcoin nodes would be relays and/or RDV points and/or clients\nand serving parties, some Tor network nodes could be used in the middle\nalso (relays only) but in any case sybils/eclipse attacks become much\nmore difficult to perform (or unlikely depending on how the peer\ndiscovery system is designed)\n\nbitcoin | node-Tor |bitcoin and LN.pipe(node-Tor)\n\nThen question for possible future tests: is there a simple way to pipe\nthe bitcoin protocol via stdin/stdout? (the socks interface could be\nused but we already saw that it did raise issues)\n\n-- \nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200605/c512ceb6/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-05T11:44:53",
                "message_text_only": "Good morning Aymeric,\n\n> The issue each time there are discussions/research linking to Tor is that it is biased since the beginning because based on a wrong postulate: using the Tor network\n>\n\nWell, in the interest of using the wrong tool for a highly important job, let me present this thought:\n\n* The Tor network is weakened due to its dependence on a limited set of exit nodes.\n* \"Direct\", within-Tor rendezvous points are good, i.e. Tor hidden services.\n* Thus, there is no issue with Tor-to-Tor or clearnet-to-clearnet connections, the issue is with Tor-to-clearnet connections.\n* Of course, no miner is going to run over Tor because latency, so all the miners will be on clearnet.\n* So make your own bridge between Tor and clearnet.\n* Run two fullnodes on your computer (with sufficient ingenuity, you can probably share their block storages, or make one pruning).\n* One fullnode is on the public network but runs in `blocksonly` so it does not propagate any transactions (which might be attached to your public IP).\n* The other fullnode is on the Tor network and has an `-addnode` to the public-network node via `localhost`, which I assume is very hard for an eclipse attacker to get at.\n* Use the Tor-fullnode to propagate your transactions.\n\nOf course, the eclipse attacker can still attack all Tor exit nodes and block outgoing transaction traffic to perform eclipse attacks.\nAnd if you decide to propagate transactions to the public-network node then you pretty much lose your privacy there.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2020-06-05T15:41:48",
                "message_text_only": "Hi,\n\nAs far as I understand your answer is \"let's try to use what exists\",\nthis is not what I am proposing and not the Tor network, no \"standard\"\nexit nodes, different hidden services, decentralized anonymizer network\nunlike the Tor network, nodes are anonymizing themselves\n\nComments below, please let me know what is unclear in the description of\nthe project so I can modify it because all the time I get the impression\nthat it is mixed with the Tor network while it just has a very little to\ndo with it, and I don't get that the simple principle of communicating\nbetween nodes using the Tor protocol without RDV points is never considered\n\nRegards,\n\nLe 05/06/2020 \u00e0 13:44, ZmnSCPxj a \u00e9crit\u00a0:\n> Good morning Aymeric,\n>\n>> The issue each time there are discussions/research linking to Tor is that it is biased since the beginning because based on a wrong postulate: using the Tor network\n>>\n> Well, in the interest of using the wrong tool for a highly important job, let me present this thought:\nThen for an important job people should use the right tool...\n>\n> * The Tor network is weakened due to its dependence on a limited set of exit nodes.\nAnd centralized structure, limited set of nodes to make it short, for\nsome (or a lot) misbehaving, not designed for bitcoin, nothing prevents\nbitcoin from operating its own anonymizer system, which I am proposing\n> * \"Direct\", within-Tor rendezvous points are good, i.e. Tor hidden services.\nGood to a certain extent... if you want to hide that you are operating a\nbitcoin node you can use RDV points (ie hidden services) but if you\ndon't care you just connect anonymized circuits between bitcoin nodes,\nthis is more \"direct\" and does not exist in the Tor network, this\nincludes light clients that can act as relays also\n> * Thus, there is no issue with Tor-to-Tor or clearnet-to-clearnet connections, the issue is with Tor-to-clearnet connections.\nThere are plenty of Tor-to-Tor issues, not theoretical but in the real\nworld, \"Tor-to-clearnet\" can be done outside of the Tor network, ie the\nbitcoin network\n> * Of course, no miner is going to run over Tor because latency, so all the miners will be on clearnet.\nProbably, again I am not proposing a remake of the Tor network, I don't\nsee the use for a miner to hide (neither for a bitcoin node to use RDV\npoints), but they can be part of the global anonymized system, please\nsee below\n> * So make your own bridge between Tor and clearnet.\n> * Run two fullnodes on your computer (with sufficient ingenuity, you can probably share their block storages, or make one pruning).\n> * One fullnode is on the public network but runs in `blocksonly` so it does not propagate any transactions (which might be attached to your public IP).\n> * The other fullnode is on the Tor network and has an `-addnode` to the public-network node via `localhost`, which I assume is very hard for an eclipse attacker to get at.\n> * Use the Tor-fullnode to propagate your transactions.\nYes but one full node should be able to do this alone, ie implement both\ninterfaces, like miners and everybody in fact (or Peersm bridges with\nbittorrent if you look at the history of the project)\n>\n> Of course, the eclipse attacker can still attack all Tor exit nodes and block outgoing transaction traffic to perform eclipse attacks.\n> And if you decide to propagate transactions to the public-network node then you pretty much lose your privacy there.\n\nPlease see the convergence link, it's not based on the assumption that\n\"the more you are the better you can hide and the lesser you can get\nattacked\", this does not work at all, it's based on the assumption that\neven with a reduced set of peers it becomes very difficult to know who\nis doing what and whom is talking to whom, the concept of\nexiting/bridging to clearnet(s) is not clearly detailed in this version\nbut appears on the drawings"
            },
            {
                "author": "Antoine Riard",
                "date": "2020-06-07T22:31:54",
                "message_text_only": "Hi ZmnSCPxj,\n\n> (Of note as well, is that the onchain contract provided by such services\nis the same in spirit as those instantiated in channels of the Lightning\nNetwork, thus the same attack schema works on the onchain side.)\n\nIf you onchain contract uses a timelock and has concurrent transactions\narbiter by this one , it's subject to time-dilation attack. So yes\nsubmarine swaps, or any kind of atomic swap is concerned. We note this in\ndiscussion.\nBut you're right for the attack cost, you don't need a channel to these\nservices, which is also concerning for their attack surface.\n\n> Since the issue here is that eclipsing of Bitcoin nodes is risky, it\nstrikes me that a mitigation would be to run your Bitcoin fullnode on\nclearnet while running your Lightning node over Tor\n\nWe clearly mention that risk of running a Bitcoin node over Tor, where do\nwe recommend running a LN node over Tor ?\n\n>   And this seems to tie with what you propose: that the LN node should\nuse a different view-fullnode from the broadcast-fullnode.\n\nYes in Countermeasures - Link layer diversity, specially if it's easy for\nan attacker to provoke a transaction broadcast by buying a channel to the\nLN node.\n\n> A mitigation to this would be to run a background process which sleeps\nfor 20 minutes, then does `bitcoin-cli addnode ${BITCOINNODE} onetry`.\n\nYeah instead of having every node operator running their own hacky scripts,\nwithout them being bulletproofs on detection, I'm working on getting such\nmitigations directly in Core, easily deployable for everyone.\n\n> The victim *could* instead check that the absolute timelocks seem very\nfar in the future relative to its own view of the current blockheight.\n\nI think you're right it's really dependent on CLTV_delta deployed on the\npath and time-dilation offset. The alternative you're proposing is a good\none, but you shouldn't know where you're in the path and max CLTV is 2048\nblocks IIRC.\n\nThanks for your reading and review,\n\nCheers,\nAntoine\n\nLe mer. 3 juin 2020 \u00e0 22:58, ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> Good morning Gleb and Antoine,\n>\n> This is good research, thank you for your work.\n>\n> > **Targeting Per-Hop Packet Delay** is based on routing via the victim,\n> and the victim should have at least two channels with the attacker.\n>\n> The existence of offchain-to-onchain swap services means that the attacker\n> needs only build one channel to the victim for this attack to work.\n> Rather than route to themselves, the attacker routes to a convenient\n> service providing such a swap service, and receives the stolen funds\n> onchain, with no need even for an incoming channel from a different node.\n> (Of note as well, is that the onchain contract provided by such services\n> is the same in spirit as those instantiated in channels of the Lightning\n> Network, thus the same attack schema works on the onchain side.)\n>\n> Indeed, the attack can be mounted on such a service directly.\n>\n> Even without such a service, the incoming channel need not be directly\n> connected to the victim.\n>\n>\n> > [Tor is tricky](https://arxiv.org/abs/1410.6079) too\n>\n> Since the issue here is that eclipsing of Bitcoin nodes is risky, it\n> strikes me that a mitigation would be to run your Bitcoin fullnode on\n> clearnet while running your Lightning node over Tor.\n> Eclipsing the Lightning node (but not the Bitcoin fullnode it depends on)\n> \"only\" loses you the ability to pay, receive, or route (and thereby earn\n> forwarding fees), but as long as your blockchain view is clear, it should\n> be fine.\n>\n> Of course, the Lightning node could still be correlated with the Bitcoin\n> node when transactions are broadcast with the attached Bitcoin node (as\n> noted in the paper).\n> Instead the Lightning node should probably connect, over Tor, to some\n> random Bitcoin fullnodes / Electrum servers and broadcast txes to them.\n>\n> And this seems to tie with what you propose: that the LN node should use a\n> different view-fullnode from the broadcast-fullnode.\n>\n>\n> > if a node doesn\u2019t observe a block within the last 30 minutes, it\n> attempts to make a new random connection to someone in the network.\n>\n> A mitigation to this would be to run a background process which sleeps for\n> 20 minutes, then does `bitcoin-cli addnode ${BITCOINNODE} onetry`.\n> It might want to `disconnectnode` any previous node it attempted to\n> connect to.\n>\n> However I note that the help for `addnode` contains the text \"though such\n> peers will not be synced from\", which confuses me, since it also refers to\n> the `-connect` command line option, and `-connect` means you only connect\n> out to the specific nodes, so if those are not synced from.... huh?\n>\n> And of course the interesting part is \"how do we get a `${BITCOINNODE}`\n> that we think is not part of the eclipsing attacker?\"\n>\n>\n> > If a Lightning node is behind in its Bitcoin blockchain view, but\n> Lightning payments between honest nodes are still flowing through it, this\n> node will have a high routing failure rate. This would happen because\n> honest nodes on the routing path would reject the forwarded HTLC for being\n> too close to expired.\n>\n> I am uncertain this would happen very often.\n> In the first place, the incoming HTLC would have \"reasonable\" timeouts, or\n> else the incoming honest node would not have routed it at all, and the\n> outgoing HTLC would be relative to this incoming one, so the outgoing\n> honest node will still accept this.\n>\n> The victim *could* instead check that the absolute timelocks seem very far\n> in the future relative to its own view of the current blockheight.\n> (a forwarding node miht want to do that anyway to have an upper bound\n> against griefing attacks)\n>\n> What would definitely increase in failure rate would be payments arising\n> from the victim node; the victim node believes the blockheight to be much\n> lower than it actually is, and either the payee node, or some intermediate\n> node along the route, will claim to have too little time to safely forward\n> the funds.\n> This does not help for nodes which are primarily forwarding nodes.\n>\n>\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200607/45de6e7a/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-08T04:56:56",
                "message_text_only": "Good morning Antoine,\n\n\n> > Since the issue here is that eclipsing of Bitcoin nodes is risky, it strikes me that a mitigation would be to run your Bitcoin fullnode on clearnet while running your Lightning node over Tor\n>\n> We clearly mention that risk of running a Bitcoin node over Tor, where do we recommend running a LN node over Tor ?\n\nNowhere, *I* am the one recommending this.\nRunning both Bitcoin and Lightning nodes on clearnet automatically links them, making them easier to attack, whereas running Lightning on Tor does not.\nOf course, they could still be linked by onchain transaction monitoring, but at least this increases the effort to attack, hopefully it becomes marginally less desirable to attack you.\n\nOn the other hand, you *could* run them on different public IP addresses, if you happen to have more than one; for those who do not even have a single public IP address there is no real choice if you want to let others to connect to you, Tor hidden service is the only Lightning-supported way to be accessible without a public IP.\n\n(There are sections of the world where commodity \"home\" internet connections do not automatically get a public IP, and the privilege of getting one may be an additional cost; though of course if you have no real intent to help support either the Bitcoin or Lightning networks, you do not need a public IP anyway, and with IPv6 it becomes less and less likely that a randomly-chosen entity would be unlucky enough to not get a public IP.)\n\n> > The victim *could* instead check that the absolute timelocks seem very far in the future relative to its own view of the current blockheight.\n> I think you're right it's really dependent on CLTV_delta deployed on the path and time-dilation offset. The alternative you're proposing is a good one, but you shouldn't know where you're in the path and max CLTV is 2048 blocks IIRC.\n\nSeeing an incoming payment that violates the max CLTV is a good indication you have been eclipsed.\n\nOn the other hand, if your Bitcoin node is eclipsed, then it seems likely your Lightning node is also eclipsed (if running over the same hardware) and you might not receive any indication over Lightning that you have been eclipsed anyway.\n\nI suppose we need to identify just exactly *what* ways a node of either type can be eclipsed; it seems that mitigations that protect against one kind of eclipse will not work in general with other kinds of eclipse.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2020-06-08T16:43:27",
                "message_text_only": "Le 08/06/2020 \u00e0 06:56, ZmnSCPxj via bitcoin-dev a \u00e9crit\u00a0:\n> Running both Bitcoin and Lightning nodes on clearnet automatically links them, making them easier to attack, whereas running Lightning on Tor does not.\n> Of course, they could still be linked by onchain transaction monitoring, but at least this increases the effort to attack, hopefully it becomes marginally less desirable to attack you.\nOr makes it easier in fact, correcting what I said in my previous\nanswer, stating a \"yes\" for a mixed bitcoin and/or LN node in clearnet\nand Tor, with or without different IPs, it's probably not difficult for\nthe Tor attacker to identify you (for example pinging the nodes with a\nnew received tx to see who has it in mempool)\n\nSimilar to \"Deanonymizing the VPN peers\"\nhttps://github.com/Ayms/torrent-live, this is not public but the method\nuses the clearnet/VPN \"mixity\" and unexpectedly the more you try to hide\nthe better you can get deanonymized\n\nThe conclusion is always the same: do not use the Tor network for\nservices it is not designed for"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-10T23:34:53",
                "message_text_only": "Good morning Antoine and Gleb,\n\nOne thing I have been idly thinking about would be to have a *separate* software daemon that performs de-eclipsing for your Bitcoin fullnode.\n\nFor example, you could run this deeclipser on the same hardware as your Bitcoin fullnode, and have the deeclipser bind to port 8334.\nThen you set your Bitcoin fullnode with `addnode=localhost:8334` in your `bitcoind.conf`.\n\nYour Bitcoin fullnode would then connect to the deeclipser using normal P2P protocol.\n\nThe deeclipser would periodically, every five minutes or so, check the latest headers known by your fullnode, via the P2P protocol connection your fullnode makes.\nThen it would attempt to discover any blocks with greater blockheight.\n\nThe reason why we have a separate deeclipser process is so that the deeclipser can use a plugin system, and isolate the plugins from the main fullnode software.\nFor example, the deeclipser could query a number of plugins:\n\n* One plugin could just try connecting to some random node, in the hopes of getting a new connection that is not eclipsed.\n* Another plugin could try polling known blockchain explorers and using their APIs over HTTPS, possibly over Tor as well.\n* Another plugin could try connecting to known Electrum servers.\n* New plugins can be developed for new mitigations, such as sending headers over DNS or blocks over mesh or etc.\n\nThen if any plugin discovers a block later than that known by your fullnode, the deeclipser can send an unsolicited `block` or `header` message to your fullnode to update it.\n\nThe advantage of using a plugin system is that it becomes easier to prototype, deploy, and maybe even test new de-eclipsing mitigations.\n\nAt the same time, by running a separate daemon from the fullnode, we provide some amount of process isolation in case some problem with the plugin system exists.\nThe deeclipser could be run by a completely different user, for example, and you might even run multiple deeclipser daemons in the same hardware, with different non-overlapping plugins, so that an exploit of one plugin will only bring down one deeclipser, with other deeclipser daemons remaining functional and still protecting your fullnode.\n\nFinally, by using the P2P protocol, the fullnode you run could be a non-Bitcoin-Core fullnode, such as btcd or rust-bitcoin or whatever other fullnode implementations exist, assuming you actually want to use them for some reason.\n\nWhat do you think?\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Antoine Riard",
                "date": "2020-06-11T09:21:48",
                "message_text_only": "Hi ZmnSCPxj\n\nWell your deeclipser is already WIP ;)\n\nSee my AltNet+Watchdog proposals in Core:\nhttps://github.com/bitcoin/bitcoin/pull/18987/https://github.com/bitcoin/bitcoin/pull/18988\n\nIt's almost covering what you mention, a driver framework to plug\nalternative transports protocols : radio, DNS, even LN Noise, Tor's\nSnowflake... Proposal is a PoC with a multi-threaded process but yes I want\nproduction-design to be a multi-process for the reasons you mentioned.\nDrivers should be developed out-of-tree but with an interface to plug them\nsmoothly (tm).\n\nProposal is more generic than pure LN, like some privacy-concerned users\nmay want to broadcast by default their transactions over radio. But for LN\nsupport it should a) detect network/block issuance anomalies b) dynamically\nreact by closing channels or c) fetch headers/blocks through redundant\ncommunication channels and d) provide emergency transactions broadcast if\nyour time-sensitive transactions are censored.\n\nIt's long-term work so be patient but getting opt-in support in Core would\nmake it far easier for any LN routing/vaulting node to deploy it. In the\nmeanwhile you can have multiple nodes on different infrastructures to serve\nas a backend for your LN node.\n\nBonus: if LN nodes are incentivized to deploy such strong anti-eclipsing\nmeasures to mitigate time-dilation it would benefit base layer p2p security\nnetwork-wise. In case of network partition, your node with link layer\nredundancy will keep it in-sync its connected peers on the same side of the\npartition, even if they don't deploy anything.\n\nI'm sure you have improvements to suggest !\n\nBest,\nAntoine\n\n\nLe mer. 10 juin 2020 \u00e0 19:35, ZmnSCPxj <ZmnSCPxj at protonmail.com> a \u00e9crit :\n\n> Good morning Antoine and Gleb,\n>\n> One thing I have been idly thinking about would be to have a *separate*\n> software daemon that performs de-eclipsing for your Bitcoin fullnode.\n>\n> For example, you could run this deeclipser on the same hardware as your\n> Bitcoin fullnode, and have the deeclipser bind to port 8334.\n> Then you set your Bitcoin fullnode with `addnode=localhost:8334` in your\n> `bitcoind.conf`.\n>\n> Your Bitcoin fullnode would then connect to the deeclipser using normal\n> P2P protocol.\n>\n> The deeclipser would periodically, every five minutes or so, check the\n> latest headers known by your fullnode, via the P2P protocol connection your\n> fullnode makes.\n> Then it would attempt to discover any blocks with greater blockheight.\n>\n> The reason why we have a separate deeclipser process is so that the\n> deeclipser can use a plugin system, and isolate the plugins from the main\n> fullnode software.\n> For example, the deeclipser could query a number of plugins:\n>\n> * One plugin could just try connecting to some random node, in the hopes\n> of getting a new connection that is not eclipsed.\n> * Another plugin could try polling known blockchain explorers and using\n> their APIs over HTTPS, possibly over Tor as well.\n> * Another plugin could try connecting to known Electrum servers.\n> * New plugins can be developed for new mitigations, such as sending\n> headers over DNS or blocks over mesh or etc.\n>\n> Then if any plugin discovers a block later than that known by your\n> fullnode, the deeclipser can send an unsolicited `block` or `header`\n> message to your fullnode to update it.\n>\n> The advantage of using a plugin system is that it becomes easier to\n> prototype, deploy, and maybe even test new de-eclipsing mitigations.\n>\n> At the same time, by running a separate daemon from the fullnode, we\n> provide some amount of process isolation in case some problem with the\n> plugin system exists.\n> The deeclipser could be run by a completely different user, for example,\n> and you might even run multiple deeclipser daemons in the same hardware,\n> with different non-overlapping plugins, so that an exploit of one plugin\n> will only bring down one deeclipser, with other deeclipser daemons\n> remaining functional and still protecting your fullnode.\n>\n> Finally, by using the P2P protocol, the fullnode you run could be a\n> non-Bitcoin-Core fullnode, such as btcd or rust-bitcoin or whatever other\n> fullnode implementations exist, assuming you actually want to use them for\n> some reason.\n>\n> What do you think?\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200611/99324582/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Time-dilation Attacks on the Lightning Network",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Antoine Riard",
                "Gleb Naumenko",
                "Aymeric Vitte"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 32439
        }
    },
    {
        "title": "[bitcoin-dev] Stamping transaction",
        "thread_messages": [
            {
                "author": "Mostafa Sedaghat joo",
                "date": "2020-06-05T12:05:20",
                "message_text_only": "Hi\n\n*stamping transactions* is as simple idea but has huge impact.\nSimply, stamping transaction means putting previous block hash in the\nheader of the transaction. With this simple technique we can *decouple\n*translation from\nthe block.\nI have described my idea here:\nhttps://b00f.github.io/blockchain/stamping_transactions\n\n\nI know bitcoin developers tends to not change the core, but you can\nconsider it for next big change.\n\n\nRegards,\nMostafa\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200605/ad4114d1/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-07T00:40:51",
                "message_text_only": "Good morning Mostafa,\n\nFirst off, the proposed mechanism can be made into a softfork by using an unspendable `scriptPubKey` with 0 output value.\n\nFor example, a stamp could by convention be any 0-value output whose `scriptPubKey` is `<blockhash> OP_0`, which should be unspendable.\n\nPost-softfork nodes would reject blocks where some transaction is stamped and the stamped `<blockhash>` is not within the last N blocks.\nPre-softfork nodes would not see anything special about the unspendable `scriptPubKey` and would just accept it (but would not relay such transactions due to standardness).\n\nEngineering-wise, block validation now needs to memorize the last N block hashes.\n\nThe mempool design currently assumes that a transaction that enters the mempool is always valid unless any UTXOs it spends have been removed.\nThis is important since miner block selection algorithms assume the mempool contains transactions that are currently valid.\nThus, there is the additional need to drop transactions from the mempool if they are stamped with a block that has dropped from the stamp TTL.\n\nAnother issue is incentives.\nThe stamp takes up blockchain space that is paid for by the creator of the transaction.\nFurther, the creator of the transaction gains no advantage from the stamped transaction; it is others who gain an advantage (the stamped transaction is more likely to be dropped from the mempool).\nDiscounting the stamp somehow will probably make this into a hardfork.\nIt might be sneaked into the witness somehow by adding it as a field somewhere in the new parts of Taproot (there is, a new block of data in Taproot that can be used for this), but note that the cost will still be non-zero (and users of this feature will still have a disadvantage in that their transactions are more likely to be dropped from the mempool).\n\nFinally, it is expected to increase bandwidth use since a dropped stamped transaction will probably be rebroadcast with a new stamp, so effectively the transaction is retransmitted again with a different stamp.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Mostafa Sedaghat joo",
                "date": "2020-06-07T07:27:48",
                "message_text_only": "Good day ZmnSCPxj\n\nThank you so much for your time to read my proposal.\nAbout your comments, I do agree with some of them but maybe we need to\ndiscuss more about them.\nYou might agree that any changes (especially a fundamental change like\nstamping transactions) comes with advantages and probably some\ndisadvantages. I believe the advantages of stamping transactions are worth\nhaving it.\n\n\n*The main point of stamping transactions is decoupling transactions from\nthe block. *\n\n*Blockchain size matters*\nSegWit is a good witness that shows blockchain size matters. Nowadays, Data\nstorage is cheap and easy, but that doesn't mean it's a simple matter. If\nyou need to have a data-center to keep a copy of a blockchain, then you are\nfar from a decentralization system.\n\n*A Solution*\nStamping transaction is a simple idea to keep the size of the blockchain as\nsmall as possible. The question that I was looking to answer is how we can\ndecouple the transaction from the blocks.\nWho cares about the transaction that happened 10 years ago. In the real\nworld you may go to your bank and ask them to give you transaction history.\nBut they probably have limits. They might say we just only keep the last 3\nmonths in our system.\n\n*Implementation*\n\n> First off, the proposed mechanism can be made into a softfork by using an\nunspendable `scriptPubKey` with 0 output value.\nSoftFork is not possible here. Because the transaction will not be saved\ninside the block (only tx hashes). Block format needs to be changed.\nTherefore the block will be invalid.\n\n> Engineering-wise, block validation now needs to memorize the last N block\nhashes.\nI don't think we need to memorize the last N block hashes.  We can have\nsomething like:\n```\nCurrent_Height - Height_Of(tx.stamp) <= N\n```\n*Incentives*\nI think Stamping transactions have nothing to do with the\nincentivization mechanism.  Forgive me if I couldn't get your point.\n\n*Mempool*\nIt's bad of me that I don't really know how mempool works in Bitcoin. My\nassumption is that there are some junk transactions (transactions that are\nvalid but have very low or zero fees) inside the mempool. Stamping\ntransactions might help to get rid of them time to time.\n\nBest Regards,\nMostafa\n\n\nOn Sun, Jun 7, 2020 at 8:40 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Mostafa,\n>\n> First off, the proposed mechanism can be made into a softfork by using an\n> unspendable `scriptPubKey` with 0 output value.\n>\n> For example, a stamp could by convention be any 0-value output whose\n> `scriptPubKey` is `<blockhash> OP_0`, which should be unspendable.\n>\n> Post-softfork nodes would reject blocks where some transaction is stamped\n> and the stamped `<blockhash>` is not within the last N blocks.\n> Pre-softfork nodes would not see anything special about the unspendable\n> `scriptPubKey` and would just accept it (but would not relay such\n> transactions due to standardness).\n>\n> Engineering-wise, block validation now needs to memorize the last N block\n> hashes.\n>\n> The mempool design currently assumes that a transaction that enters the\n> mempool is always valid unless any UTXOs it spends have been removed.\n> This is important since miner block selection algorithms assume the\n> mempool contains transactions that are currently valid.\n> Thus, there is the additional need to drop transactions from the mempool\n> if they are stamped with a block that has dropped from the stamp TTL.\n>\n> Another issue is incentives.\n> The stamp takes up blockchain space that is paid for by the creator of the\n> transaction.\n> Further, the creator of the transaction gains no advantage from the\n> stamped transaction; it is others who gain an advantage (the stamped\n> transaction is more likely to be dropped from the mempool).\n> Discounting the stamp somehow will probably make this into a hardfork.\n> It might be sneaked into the witness somehow by adding it as a field\n> somewhere in the new parts of Taproot (there is, a new block of data in\n> Taproot that can be used for this), but note that the cost will still be\n> non-zero (and users of this feature will still have a disadvantage in that\n> their transactions are more likely to be dropped from the mempool).\n>\n> Finally, it is expected to increase bandwidth use since a dropped stamped\n> transaction will probably be rebroadcast with a new stamp, so effectively\n> the transaction is retransmitted again with a different stamp.\n>\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200607/d226099f/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-07T15:01:42",
                "message_text_only": "Good morning Mostafa,\n\n\n> The main point of stamping transactions is decoupling transactions from the block.\u00a0\n>\n> Blockchain size matters\n> SegWit is a good witness that shows blockchain size matters. Nowadays,\u00a0Data storage is cheap and easy, but that doesn't mean it's a simple matter. If you need to have a data-center to keep a copy of a blockchain, then you are far from a decentralization system.\u00a0\n>\n> A Solution\n> Stamping\u00a0transaction is a simple idea to keep the size of the blockchain as small as possible. The question that I was looking to answer is how we can decouple the transaction from the blocks.\n> Who cares about the transaction that happened\u00a010 years ago. In the real world you may go to your bank and ask them to give you transaction\u00a0history. But they probably have limits. They might say we just only keep the last 3 months in our system.\u00a0\n\nStamping transaction is not how you would be able to keep **blockchain** size low.\n\nThe reason why very old history is retained is that, if a new node is brought up, you need to prove to that node that you are in fact the correct owner of the current coins.\nThus the entire history of Bitcoin is needed when starting a new node, and why archive nodes exist.\n\nYou might argue that banks do not do that, and that is because we want to do better than banks; we know that existing currency systems have not only the \"official\" minter, but also many \"unofficial\" minters (commonly called counterfeiters) which dilute the value of the currency.\nIt is this insistence on a full accounting of the provenance for every satoshi that separates Bitcoin from previous currency systems; bank fraud exists, and it hides in such sloppy techniques as deleting old transaction records.\n\nWork has been done to have client-side validation (i.e. the owner of a coin keeps the entire history, and when paying, you hand over the entire history of your coin to the payee, instead of everyone validating every transaction).\nLook up Peter Todd for some initial work on this.\n\n\n> Implementation\n>\n> > First off, the proposed mechanism can be made into a softfork by using an unspendable `scriptPubKey` with 0 output value.\n> SoftFork is not possible here. Because the transaction will not be saved inside the block (only tx hashes). Block format needs to be changed. Therefore the block will be invalid.\n\nThat greatly reduces the chances your proposal will get into Bitcoin; you would need to have very good advantages to counterbalance the tremendous risk that hardforks introduce in the continuity of the coin.\n\nBitcoin has never gone through a hardfork that has not instead created a new cryptocurrency, so any solution that requires a hardfork is going to be unlikely to be accepted by everyone.\n\n> >\u00a0Engineering-wise, block validation now needs to memorize the last N block hashes.\n> I don't think we need to memorize the last N block hashes.\u00a0 We can have something like:\n> ```\n> Current_Height - Height_Of(tx.stamp) <= N\u00a0\n> ```\n\n...\n\n\n`Height_Of()` would basically be a mapping from block hashes to block heights, with the number of elements equal to the height of the blockchain, and thus continuously growing.\nThus, validation is expected to become more expensive as the blockchain grows.\n\nSince stamped transactions have a time-to-live anyway, instead you can use a *set* of the most recent N block hashes.\nThen you simply check if the stamp is in the set.\nThis creates a data structure that is constant in size (at each block, you remove the block from N blocks ago), which is good for validation.\n\n> Incentives\n> I think Stamping transactions have nothing to do with the incentivization\u00a0mechanism.\u00a0 Forgive me if I couldn't get your point.\n\nA stamped tranasction has a stamp, an unstamped transaction has no stamp.\nThe stamped transaction is larger because of the stamp.\nLarger transactions are more expensive because fees.\n\nThus, stamped transactions are more expensive than unstamped transactions.\n\nConvince me why I would make *my* transaction stamped when I can just convince *everyone else* to stamp *their* transactions and use unstamped transactions myself.\n\nIf you propose that all transactions must be stamped in a new version of Bitcoin, then take note that users will prefer to run older versions and never upgrade to the new version that requires stamped transactions.\nWhy should users prefer a more expensive transaction format?\nFor the good of the network?\nThat is precisely an incentives problem: if it is so good for the network, then it should be good for an individual user, because the network is made up of individual users anyway; if individual users are not incentivized to use it, then that fact suggests it might not be as good for the network as you might think.\n\nIf you answer \"the stamp can be discounted\" then be aware that validating the stamp is still a cost on every node, and it is that cost that we want to be reflected in pricing every byte in the transaction.\nFor instance, UTXOs are retained, potentially indefinitely, and the UTXO lookup structure has to be very fast and is referred to at every transaction validation, so outputs (which create new UTXO entries) in SegWit are 4x more expensive than signatures, since signatures are only validated once when the transaction is queued to be put in the mempool.\n\n\n> Mempool\n> It's bad of me that I don't really know how mempool works in Bitcoin. My assumption is that there are some junk transactions (transactions that are valid but have very low or zero fees) inside the mempool. Stamping transactions might help to get rid of them time to time.\u00a0\n\nWhy would you think that stamping reduces mempool size?\n\nIf I wanted to I could just re-send the transaction with a fresh stamp.\nThen the mempool usage would still be the same, and bandwidth use will increase (because the same transaction is now re-broadcast with a fresh stamp, and the added size of the stamps themselves).\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Mostafa Sedaghat joo",
                "date": "2020-06-09T09:34:57",
                "message_text_only": "Good day ZmnSCPxj\n\nAs I said before, I don't expect a hard fork for this change. I wanted to\nshare my thoughts with you guys. Anytime the bitcoin community decides to\nmake a hard-fork, you might consider this change as well.\nI believe decoupling transactions from the block is beautiful.\n\n About transaction verification,\nTransactions have their own way to survive. Owner of the coin can keep the\nhistory of his transactions.\nBut there is no guarantee that ndes should keep all of them from the\ngenesis. It depends. Maybe some nodes want to keep  all the transactions,\nsome part of them and might nothing.\nAlso we can think about check pointing. When a new node connects to the\nnetwork, it doesn't need to validate all the blocks since genesis. It can\nstart validating from a checkpoint.\n\nAnd also adding 32 bits to the header of translation (which won't be saved\ninside the block) is not a big deal.\n\n\nAdios,\nMostafa\n\n\n\nOn Sun, Jun 7, 2020 at 11:01 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Mostafa,\n>\n>\n> > The main point of stamping transactions is decoupling transactions from\n> the block.\n> >\n> > Blockchain size matters\n> > SegWit is a good witness that shows blockchain size matters.\n> Nowadays, Data storage is cheap and easy, but that doesn't mean it's a\n> simple matter. If you need to have a data-center to keep a copy of a\n> blockchain, then you are far from a decentralization system.\n> >\n> > A Solution\n> > Stamping transaction is a simple idea to keep the size of the blockchain\n> as small as possible. The question that I was looking to answer is how we\n> can decouple the transaction from the blocks.\n> > Who cares about the transaction that happened 10 years ago. In the real\n> world you may go to your bank and ask them to give you transaction history.\n> But they probably have limits. They might say we just only keep the last 3\n> months in our system.\n>\n> Stamping transaction is not how you would be able to keep **blockchain**\n> size low.\n>\n> The reason why very old history is retained is that, if a new node is\n> brought up, you need to prove to that node that you are in fact the correct\n> owner of the current coins.\n> Thus the entire history of Bitcoin is needed when starting a new node, and\n> why archive nodes exist.\n>\n> You might argue that banks do not do that, and that is because we want to\n> do better than banks; we know that existing currency systems have not only\n> the \"official\" minter, but also many \"unofficial\" minters (commonly called\n> counterfeiters) which dilute the value of the currency.\n> It is this insistence on a full accounting of the provenance for every\n> satoshi that separates Bitcoin from previous currency systems; bank fraud\n> exists, and it hides in such sloppy techniques as deleting old transaction\n> records.\n>\n> Work has been done to have client-side validation (i.e. the owner of a\n> coin keeps the entire history, and when paying, you hand over the entire\n> history of your coin to the payee, instead of everyone validating every\n> transaction).\n> Look up Peter Todd for some initial work on this.\n>\n>\n> > Implementation\n> >\n> > > First off, the proposed mechanism can be made into a softfork by using\n> an unspendable `scriptPubKey` with 0 output value.\n> > SoftFork is not possible here. Because the transaction will not be saved\n> inside the block (only tx hashes). Block format needs to be changed.\n> Therefore the block will be invalid.\n>\n> That greatly reduces the chances your proposal will get into Bitcoin; you\n> would need to have very good advantages to counterbalance the tremendous\n> risk that hardforks introduce in the continuity of the coin.\n>\n> Bitcoin has never gone through a hardfork that has not instead created a\n> new cryptocurrency, so any solution that requires a hardfork is going to be\n> unlikely to be accepted by everyone.\n>\n> > > Engineering-wise, block validation now needs to memorize the last N\n> block hashes.\n> > I don't think we need to memorize the last N block hashes.  We can have\n> something like:\n> > ```\n> > Current_Height - Height_Of(tx.stamp) <= N\n> > ```\n>\n> ...\n>\n>\n> `Height_Of()` would basically be a mapping from block hashes to block\n> heights, with the number of elements equal to the height of the blockchain,\n> and thus continuously growing.\n> Thus, validation is expected to become more expensive as the blockchain\n> grows.\n>\n> Since stamped transactions have a time-to-live anyway, instead you can use\n> a *set* of the most recent N block hashes.\n> Then you simply check if the stamp is in the set.\n> This creates a data structure that is constant in size (at each block, you\n> remove the block from N blocks ago), which is good for validation.\n>\n> > Incentives\n> > I think Stamping transactions have nothing to do with the\n> incentivization mechanism.  Forgive me if I couldn't get your point.\n>\n> A stamped tranasction has a stamp, an unstamped transaction has no stamp.\n> The stamped transaction is larger because of the stamp.\n> Larger transactions are more expensive because fees.\n>\n> Thus, stamped transactions are more expensive than unstamped transactions.\n>\n> Convince me why I would make *my* transaction stamped when I can just\n> convince *everyone else* to stamp *their* transactions and use unstamped\n> transactions myself.\n>\n> If you propose that all transactions must be stamped in a new version of\n> Bitcoin, then take note that users will prefer to run older versions and\n> never upgrade to the new version that requires stamped transactions.\n> Why should users prefer a more expensive transaction format?\n> For the good of the network?\n> That is precisely an incentives problem: if it is so good for the network,\n> then it should be good for an individual user, because the network is made\n> up of individual users anyway; if individual users are not incentivized to\n> use it, then that fact suggests it might not be as good for the network as\n> you might think.\n>\n> If you answer \"the stamp can be discounted\" then be aware that validating\n> the stamp is still a cost on every node, and it is that cost that we want\n> to be reflected in pricing every byte in the transaction.\n> For instance, UTXOs are retained, potentially indefinitely, and the UTXO\n> lookup structure has to be very fast and is referred to at every\n> transaction validation, so outputs (which create new UTXO entries) in\n> SegWit are 4x more expensive than signatures, since signatures are only\n> validated once when the transaction is queued to be put in the mempool.\n>\n>\n> > Mempool\n> > It's bad of me that I don't really know how mempool works in Bitcoin. My\n> assumption is that there are some junk transactions (transactions that are\n> valid but have very low or zero fees) inside the mempool. Stamping\n> transactions might help to get rid of them time to time.\n>\n> Why would you think that stamping reduces mempool size?\n>\n> If I wanted to I could just re-send the transaction with a fresh stamp.\n> Then the mempool usage would still be the same, and bandwidth use will\n> increase (because the same transaction is now re-broadcast with a fresh\n> stamp, and the added size of the stamps themselves).\n>\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200609/2c5fbf6c/attachment-0001.html>"
            },
            {
                "author": "Chris Riley",
                "date": "2020-06-09T14:16:27",
                "message_text_only": "Hello,\n\nJust a few comments.\n\n>But there is no guarantee that ndes should keep all of them from the\ngenesis. It depends. Maybe some nodes want to keep  all the transactions,\nsome part of them and might nothing.\nThere is no guarantee that nodes keep them all from the genesis now, nodes\ncan turn on pruning if the operator doesn't desire to keep all the\ntransactions from the genesis block\n(https://github.com/bitcoin/bitcoin/blob/v0.11.0/doc/release-notes.md#block-file-pruning).\nLikewise, light clients may not keep any transaction history.\n\n>Also we can think about check pointing. When a new node connects to the\nnetwork, it doesn't need to validate all the blocks since genesis. It can\nstart validating from a checkpoint.\n>Transactions have their own way to survive. Owner of the coin can keep the\nhistory of his transactions.\nThere have been some checkpoint discussions on here too, which have\ndiscussed the pros and cons of them.\nsee, e.g.:\nsite:https://lists.linuxfoundation.org/pipermail/bitcoin-dev/ checkpointand:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-May/016001.html\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017209.html\n\nWithout introducing trusted people, how can you prove that the \"owner\" is\nperson A or B without verification from the genesis block?  For example, A\nor B could claim to be the owner and provide an altered client with an\naltered checkpoint to \"prove\" it.\n\n>Anytime the bitcoin community decides to make a hard-fork, you might\nconsider this change as well\n>From reading the initial bitcoin paper, many proposals etc since and having\nbeen around the \"bitcoin community\" for 9 years, I think that this change\nhas a very, very small chance of ever happening because full transaction\nverification is an important part of the blockchain bank.   Not to say this\nisn't a useful, interesting, informative, and educational discussion, but\nit seems unlikely to happen.  Likewise,  it could lead to something related\nthat would be likely to occur, so full discussions like this are useful.\n\nRegards,  :-)\nChris\n\nOn Tue, Jun 9, 2020 at 7:20 AM Mostafa Sedaghat joo via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good day ZmnSCPxj\n>\n> As I said before, I don't expect a hard fork for this change. I wanted to\n> share my thoughts with you guys. Anytime the bitcoin community decides to\n> make a hard-fork, you might consider this change as well.\n> I believe decoupling transactions from the block is beautiful.\n>\n>  About transaction verification,\n> Transactions have their own way to survive. Owner of the coin can keep the\n> history of his transactions.\n> But there is no guarantee that ndes should keep all of them from the\n> genesis. It depends. Maybe some nodes want to keep  all the transactions,\n> some part of them and might nothing.\n> Also we can think about check pointing. When a new node connects to the\n> network, it doesn't need to validate all the blocks since genesis. It can\n> start validating from a checkpoint.\n>\n> And also adding 32 bits to the header of translation (which won't be saved\n> inside the block) is not a big deal.\n>\n>\n> Adios,\n> Mostafa\n>\n>\n>\n> On Sun, Jun 7, 2020 at 11:01 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n>> Good morning Mostafa,\n>>\n>>\n>> > The main point of stamping transactions is decoupling transactions from\n>> the block.\n>> >\n>> > Blockchain size matters\n>> > SegWit is a good witness that shows blockchain size matters.\n>> Nowadays, Data storage is cheap and easy, but that doesn't mean it's a\n>> simple matter. If you need to have a data-center to keep a copy of a\n>> blockchain, then you are far from a decentralization system.\n>> >\n>> > A Solution\n>> > Stamping transaction is a simple idea to keep the size of the\n>> blockchain as small as possible. The question that I was looking to answer\n>> is how we can decouple the transaction from the blocks.\n>> > Who cares about the transaction that happened 10 years ago. In the real\n>> world you may go to your bank and ask them to give you transaction history.\n>> But they probably have limits. They might say we just only keep the last 3\n>> months in our system.\n>>\n>> Stamping transaction is not how you would be able to keep **blockchain**\n>> size low.\n>>\n>> The reason why very old history is retained is that, if a new node is\n>> brought up, you need to prove to that node that you are in fact the correct\n>> owner of the current coins.\n>> Thus the entire history of Bitcoin is needed when starting a new node,\n>> and why archive nodes exist.\n>>\n>> You might argue that banks do not do that, and that is because we want to\n>> do better than banks; we know that existing currency systems have not only\n>> the \"official\" minter, but also many \"unofficial\" minters (commonly called\n>> counterfeiters) which dilute the value of the currency.\n>> It is this insistence on a full accounting of the provenance for every\n>> satoshi that separates Bitcoin from previous currency systems; bank fraud\n>> exists, and it hides in such sloppy techniques as deleting old transaction\n>> records.\n>>\n>> Work has been done to have client-side validation (i.e. the owner of a\n>> coin keeps the entire history, and when paying, you hand over the entire\n>> history of your coin to the payee, instead of everyone validating every\n>> transaction).\n>> Look up Peter Todd for some initial work on this.\n>>\n>>\n>> > Implementation\n>> >\n>> > > First off, the proposed mechanism can be made into a softfork by\n>> using an unspendable `scriptPubKey` with 0 output value.\n>> > SoftFork is not possible here. Because the transaction will not be\n>> saved inside the block (only tx hashes). Block format needs to be changed.\n>> Therefore the block will be invalid.\n>>\n>> That greatly reduces the chances your proposal will get into Bitcoin; you\n>> would need to have very good advantages to counterbalance the tremendous\n>> risk that hardforks introduce in the continuity of the coin.\n>>\n>> Bitcoin has never gone through a hardfork that has not instead created a\n>> new cryptocurrency, so any solution that requires a hardfork is going to be\n>> unlikely to be accepted by everyone.\n>>\n>> > > Engineering-wise, block validation now needs to memorize the last N\n>> block hashes.\n>> > I don't think we need to memorize the last N block hashes.  We can have\n>> something like:\n>> > ```\n>> > Current_Height - Height_Of(tx.stamp) <= N\n>> > ```\n>>\n>> ...\n>>\n>>\n>> `Height_Of()` would basically be a mapping from block hashes to block\n>> heights, with the number of elements equal to the height of the blockchain,\n>> and thus continuously growing.\n>> Thus, validation is expected to become more expensive as the blockchain\n>> grows.\n>>\n>> Since stamped transactions have a time-to-live anyway, instead you can\n>> use a *set* of the most recent N block hashes.\n>> Then you simply check if the stamp is in the set.\n>> This creates a data structure that is constant in size (at each block,\n>> you remove the block from N blocks ago), which is good for validation.\n>>\n>> > Incentives\n>> > I think Stamping transactions have nothing to do with the\n>> incentivization mechanism.  Forgive me if I couldn't get your point.\n>>\n>> A stamped tranasction has a stamp, an unstamped transaction has no stamp.\n>> The stamped transaction is larger because of the stamp.\n>> Larger transactions are more expensive because fees.\n>>\n>> Thus, stamped transactions are more expensive than unstamped transactions.\n>>\n>> Convince me why I would make *my* transaction stamped when I can just\n>> convince *everyone else* to stamp *their* transactions and use unstamped\n>> transactions myself.\n>>\n>> If you propose that all transactions must be stamped in a new version of\n>> Bitcoin, then take note that users will prefer to run older versions and\n>> never upgrade to the new version that requires stamped transactions.\n>> Why should users prefer a more expensive transaction format?\n>> For the good of the network?\n>> That is precisely an incentives problem: if it is so good for the\n>> network, then it should be good for an individual user, because the network\n>> is made up of individual users anyway; if individual users are not\n>> incentivized to use it, then that fact suggests it might not be as good for\n>> the network as you might think.\n>>\n>> If you answer \"the stamp can be discounted\" then be aware that validating\n>> the stamp is still a cost on every node, and it is that cost that we want\n>> to be reflected in pricing every byte in the transaction.\n>> For instance, UTXOs are retained, potentially indefinitely, and the UTXO\n>> lookup structure has to be very fast and is referred to at every\n>> transaction validation, so outputs (which create new UTXO entries) in\n>> SegWit are 4x more expensive than signatures, since signatures are only\n>> validated once when the transaction is queued to be put in the mempool.\n>>\n>>\n>> > Mempool\n>> > It's bad of me that I don't really know how mempool works in Bitcoin.\n>> My assumption is that there are some junk transactions (transactions that\n>> are valid but have very low or zero fees) inside the mempool. Stamping\n>> transactions might help to get rid of them time to time.\n>>\n>> Why would you think that stamping reduces mempool size?\n>>\n>> If I wanted to I could just re-send the transaction with a fresh stamp.\n>> Then the mempool usage would still be the same, and bandwidth use will\n>> increase (because the same transaction is now re-broadcast with a fresh\n>> stamp, and the added size of the stamps themselves).\n>>\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n>> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200609/158605a4/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Stamping transaction",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Mostafa Sedaghat joo",
                "ZmnSCPxj",
                "Chris Riley"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 30502
        }
    },
    {
        "title": "[bitcoin-dev] BIP OP_CHECKTEMPLATEVERIFY",
        "thread_messages": [
            {
                "author": "Joachim Str\u00f6mbergson",
                "date": "2020-06-07T16:51:10",
                "message_text_only": "Hello everyone,\n\nregarding OP_CTV, I am considering the scaling use case, specifically an exchange (or similar) who wants to batch pay to OP_CTV to many users, and I wonder\n\n1) How do you expect the exchange to communicate the proof of the payment to the user wallets such that they are able to construct the follow up transactions and accept the payment. This is UI question. Do you expect exchanges to provide a certain importable file/blob that the wallet will allow you to entry?\n\n2) Who pays the fees and how for the transaction within the structure that OP_CTVed output is committed to? Say there is a tree structure and I want to get the coin out. Someone needs to send log(N) transactions to the chain in order for me to get access to the final UTXO I am interested in. Who can construct such transaction path and what do they need for it and who pays fees on that (which input)?\n\n3) Depending on 2) above, is it not possible for a malicious entity who is among the many users being paid, but who has very small UTXO there relative to others, to construct this middle transaction and use a very small fee rate in order to DoS other participants. Is it even possible for this attacker to create the middle transaction with RBF disabled?\n\nThank you,\nJoachim\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Tuesday, November 26, 2019 1:50 AM, Jeremy via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Bitcoin Developers,\n>\n> Pleased to announce refinements to the BIP draft for OP_CHECKTEMPLATEVERIFY (replaces previous OP_SECURETHEBAG BIP). Primarily:\n>\n> 1) Changed the name to something more fitting and acceptable to the community\n> 2) Changed the opcode specification to use the argument off of the stack with a primitive constexpr/literal tracker rather than script lookahead\n> 3) Permits future soft-fork updates to loosen or remove \"constexpr\" restrictions\n> 4) More detailed comparison to alternatives in the BIP, and why OP_CHECKTEMPLATEVERIFY should be favored even if a future technique may make it semi-redundant.\n>\n> Please see:\n> BIP:https://github.com/JeremyRubin/bips/blob/ctv/bip-ctv.mediawiki\n> Reference Implementation:https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify\n>\n> I believe this addresses all outstanding feedback on the design of this opcode, unless there are any new concerns with these changes.\n>\n> I'm also planning to host a review workshop in Q1 2020, most likely in San Francisco. Please fill out the form here https://forms.gle/pkevHNj2pXH9MGee9 if you're interested in participating (even if you can't physically attend).\n>\n> And as a \"but wait, there's more\":\n>\n> 1) RPC functions are under preliminary development, to aid in testing and evaluation of OP_CHECKTEMPLATEVERIFY. The new command `sendmanycompacted` shows one way to use OP_CHECKTEMPLATEVERIFY. See: https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify-rpcs. `sendmanycompacted` is still under early design. Standard practices for using OP_CHECKTEMPLATEVERIFY & wallet behaviors may be codified into a separate BIP. This work generalizes even if an alternative strategy is used to achieve the scalability techniques of OP_CHECKTEMPLATEVERIFY.\n> 2) Also under development are improvements to the mempool which will, in conjunction with improvements like package relay, help make it safe to lift some of the mempool's restrictions on longchains specifically for OP_CHECKTEMPLATEVERIFY output trees. See: https://github.com/bitcoin/bitcoin/pull/17268This work offers an improvement irrespective of OP_CHECKTEMPLATEVERIFY's fate.\n>\n> Neither of these are blockers for proceeding with the BIP, as they are ergonomics and usability improvements needed once/if the BIP is activated.\n>\n> See prior mailing list discussions here:\n>\n> * https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016934.html\n> * https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016997.html\n>\n> Thanks to the many developers who have provided feedback on iterations of this design.\n>\n> Best,\n>\n> Jeremy\n> --\n> [@JeremyRubin](https://twitter.com/JeremyRubin)https://twitter.com/JeremyRubin\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200607/a3fd0b6a/attachment-0001.html>"
            },
            {
                "author": "Jeremy",
                "date": "2020-06-07T22:45:16",
                "message_text_only": "Hi Joachim,\n\nFantastic questions!\n\nI think it makes sense to think about it in terms of today, and then in\nterms of a long-dated future where wallets have much richer native\nunderstandings of these things. This helps preserve the purity of the\narguments I'm making with respect to what it would look like today v.s.\nwhat it could look like with strong integration.\n\nToday:\n1) I would expect that exchanges do this as a CTV txn that is one initial\nconfirmation to a single output, and then that output expands to either all\nthe payments in the batch, or to a histogram of single-layer CTVs based on\npriority/amount being spent. E.g, either A -> B -> {C,D,E,F,G...} or\nA->B->{C -> {D,E,F}, G -> {H, I J}, K -> ....}. I would further expect that\nthe entire tree would include fees such that it will get into at least the\nbottom of the mempool. See https://utxos.org/analysis/batching_sim/ for\nmore info. If txns land in the mempool, then users learn about it (even\nwith an un-updated wallet) just like the learn of normal unconfirmed\ntransactions. Even this simple two-step transaction can deliver massive\nbatching savings. OpTech has some coverage of this simple\ncommit-now-distribute-later scheme here\nhttps://bitcoinops.org/en/newsletters/2019/05/29/#proposed-new-opcode-for-transaction-output-commitments\n.\n\nI'd also expect that exchanges in particular already store their outbound\ntransactions in resilient storage (for audit and compliance as well as\nliability protection), so they would likely be able to make this data\navailable to their customers on inquiry if discarded.\n\nI'm all for redundancy, so exchanges can also e.g. send an email with a\nbackup file if they want to. But that's not necessary for it to work today,\nyou can just watch the mempool like wallets already do.\n\nA slightly patched wallet can treat CTV outs as more confirmed (e.g., like\nan own-change address) than a normal unconfirmed out.\n\n2) I would expect that exchanges pay a reasonable amount of fees for the\ntransaction so it can expect to at least get to the bottom range of the\nmempool for children, and top of the mempool for the parent. Your question\nseems to be more about after this phase.\n\nFirst I would note that it is truly O(log(N)), but E[O(1)], because it\namortizes. That is, to claim out all of the outputs is a total overhead of\nO(N), not O(N log N). Fees in this model are paid by CPFP. Because CPFP is\ncurrently *Child* pays for parent and not *Children* pay for parent, we\ndon't (unfortunately) have rational txn selection for this case. Any wallet\ncan construct this spend path by rebroadcasting (if evicted) the parents\nand spending the txn. The exchange can also 'bound' themselves to seeing a\ntransaction to completion by including some change address at the leaf node\nlayer (not much overhead depending on radix).\n\nThus the payer of fees is the person who needs to spend.\n\n3) Not exactly, the middle txns are immutable. but it may be possible to\nconstruct a low-fee longchain which can cause transaction pinning. If you\ndo a shallow tree as described in (1), the current lightning carve should\nhelp to prevent this.\n\nFuture:\n1) Most likely the desirable radix for a tree is something like 4 or 5\nwhich minimizes the amount of work on an individual basis (you can compute\nthis by figuring out how deep the tree would be and the per-tx overheads, 4\nor 5 pop out as being minimal overhead and the benefit is recursive).\nMempool broadcast still should work, but it's possible that for privacy\nreasons it's preferred to not broadcast through mempool. It's also possible\nthat all payouts are into non-interactive lightning channels with N-of-N\ntaproot at each layer, so you receive a proof through your lightning wallet\nand can immediately route payments, and when you want to close\nopportunistically cooperate to reduce chain overhead. You can think of CTV\nas an anchor for bootstrapping these layer two protocols with an on-chain\nbisection algorithm to discover online participants to re-negotiate with. A\nprivacy and scalability win!\n\nI further expect business wallets (like exchanges) to be able to credit\ndeposits from CTV trees without requiring full expansion. This is also a\nprivacy win, and can decrease latency of moving large value funds (e.g.,\nexceeding inter exchange channel balances) and crediting funds for trading.\n\n2) I think we'll eventually converge on a non-destructive way of adding\nfees. RBF is destructive in that you're replacing a TX. CPFP is destructive\nin that you have a spend a coin to drive progress. Without a new opcode you\ncan emulate this with CTV by at nodes in the tree having a consumable\noutput that serves as a CPFP hook/a RBF hook. You can see some discussion\nhere (animated, so use pres mode)\nhttps://docs.google.com/presentation/d/1XDiZOz52XyJc4LDSbiD9_JAaJobyF5QDGtR3O9qD7yg/edit#slide=id.g7d267915e2_0_44.\nThis adds some extra chain weight, but is possible without further\nextension. What I think we'll eventually land on is a way of doing a tx\nthat contributes fee to another tx chain as a passive observer to them.\nWhile this breaks one abstraction around how dependencies between\ntransactions are processed, it also could help resolve some really\ndifficult challenges we face with application-DoS (pinning and other\nattacks) in the mempool beyond CTV. I have a napkin design for how this\ncould work, but nothing quite ready to share yet.\n\n3) Hopefully 2 solves pinning :)\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\n\nOn Sun, Jun 7, 2020 at 9:51 AM Joachim Str\u00f6mbergson <\njoachimstr at protonmail.com> wrote:\n\n> Hello everyone,\n>\n> regarding OP_CTV, I am considering the scaling use case, specifically an\n> exchange (or similar) who wants to batch pay to OP_CTV to many users, and I\n> wonder\n>\n> 1) How do you expect the exchange to communicate the proof of the payment\n> to the user wallets such that they are able to construct the follow up\n> transactions and accept the payment. This is UI question. Do you expect\n> exchanges to provide a certain importable file/blob that the wallet will\n> allow you to entry?\n>\n> 2) Who pays the fees and how for the transaction within the structure that\n> OP_CTVed output is committed to? Say there is a tree structure and I want\n> to get the coin out. Someone needs to send log(N) transactions to the chain\n> in order for me to get access to the final UTXO I am interested in. Who can\n> construct such transaction path and what do they need for it and who pays\n> fees on that (which input)?\n>\n> 3) Depending on 2) above, is it not possible for a malicious entity who is\n> among the many users being paid, but who has very small UTXO there relative\n> to others, to construct this middle transaction and use a very small fee\n> rate in order to DoS other participants. Is it even possible for this\n> attacker to create the middle transaction with RBF disabled?\n>\n> Thank you,\n> Joachim\n>\n>\n>\n> Sent with ProtonMail <https://protonmail.com> Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Tuesday, November 26, 2019 1:50 AM, Jeremy via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Bitcoin Developers,\n>\n> Pleased to announce refinements to the BIP draft for\n> OP_CHECKTEMPLATEVERIFY (replaces previous OP_SECURETHEBAG BIP). Primarily:\n>\n> 1) Changed the name to something more fitting and acceptable to the\n> community\n> 2) Changed the opcode specification to use the argument off of the stack\n> with a primitive constexpr/literal tracker rather than script lookahead\n> 3) Permits future soft-fork updates to loosen or remove \"constexpr\"\n> restrictions\n> 4) More detailed comparison to alternatives in the BIP, and why\n> OP_CHECKTEMPLATEVERIFY should be favored even if a future technique may\n> make it semi-redundant.\n>\n> Please see:\n> BIP: https://github.com/JeremyRubin/bips/blob/ctv/bip-ctv.mediawiki\n> Reference Implementation:\n> https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify\n>\n> I believe this addresses all outstanding feedback on the design of this\n> opcode, unless there are any new concerns with these changes.\n>\n> I'm also planning to host a review workshop in Q1 2020, most likely in San\n> Francisco. Please fill out the form here\n> https://forms.gle/pkevHNj2pXH9MGee9 if you're interested in participating\n> (even if you can't physically attend).\n>\n> And as a \"but wait, there's more\":\n>\n> 1) RPC functions are under preliminary development, to aid in testing and\n> evaluation of OP_CHECKTEMPLATEVERIFY. The new command `sendmanycompacted`\n> shows one way to use OP_CHECKTEMPLATEVERIFY. See:\n> https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify-rpcs.\n> `sendmanycompacted` is still under early design. Standard practices for\n> using OP_CHECKTEMPLATEVERIFY & wallet behaviors may be codified into a\n> separate BIP. This work generalizes even if an alternative strategy is used\n> to achieve the scalability techniques of OP_CHECKTEMPLATEVERIFY.\n> 2) Also under development are improvements to the mempool which will, in\n> conjunction with improvements like package relay, help make it safe to lift\n> some of the mempool's restrictions on longchains specifically for\n> OP_CHECKTEMPLATEVERIFY output trees. See: https://github.com/bitcoin/bitcoin/pull/17268\n> This work offers an improvement irrespective of OP_CHECKTEMPLATEVERIFY's\n> fate.\n>\n>\n> Neither of these are blockers for proceeding with the BIP, as they are\n> ergonomics and usability improvements needed once/if the BIP is activated.\n>\n> See prior mailing list discussions here:\n>\n> *\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016934.html\n> *\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016997.html\n>\n>\n> Thanks to the many developers who have provided feedback on iterations of\n> this design.\n>\n> Best,\n>\n> Jeremy\n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin>\n> <https://twitter.com/JeremyRubin>\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200607/6a0f0136/attachment-0001.html>"
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2020-06-08T06:05:45",
                "message_text_only": "\u0412 Sun, 7 Jun 2020 15:45:16 -0700\nJeremy via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> What I think we'll eventually land on is a way of doing a tx\n> that contributes fee to another tx chain as a passive observer to\n> them. While this breaks one abstraction around how dependencies\n> between transactions are processed, it also could help resolve some\n> really difficult challenges we face with application-DoS (pinning and\n> other attacks) in the mempool beyond CTV. I have a napkin design for\n> how this could work, but nothing quite ready to share yet.\n\nI had an idea of 'Pay for neighbor' transaction where a transaction\nthat is not directly a child of some other transaction can specify that\nit wants to pay the fee for that other transaction(s). It can become\nlike 'ghost child' transaction for them, in what it cannot be mined\nunless its 'ghost parents' are confirmed, too. It will be like CPFP,\nbut without direct dependency via inputs. Such 'PFN' transaction would\nnot spend any coins beside what it specifies in its own inputs, of\ncourse.\n\nThe idea required a hardfork at first, but Anthony Towns suggested\na way to make it into a soft fork (past-taproot) by putting the txids of\n'ghost parents' into taproot annex.\n\nPFN transaction would still be valid if some of 'ghost parents' are\nalready confirmed, so the miners could have more fees than strictly\nnecessary. But this is the same as with CPFP.\n\nLooking at the mempool code, it seems that only a way how parent/child\ntransactions relationships are established will need to be adjusted to\naccount for this 'ghost relationships', and once established, other\nlogic will work as with CPFP. There could be complications regarding\ntransaction package size. But I cannot claim that I understand that\ncode enough to say something about this with certainty."
            }
        ],
        "thread_summary": {
            "title": "BIP OP_CHECKTEMPLATEVERIFY",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Jeremy",
                "Dmitry Petukhov",
                "Joachim Str\u00f6mbergson"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 16304
        }
    },
    {
        "title": "[bitcoin-dev] [was BIP OP_CHECKTEMPLATEVERIFY] Fee Bumping Operation",
        "thread_messages": [
            {
                "author": "Jeremy",
                "date": "2020-06-08T06:43:39",
                "message_text_only": "Broke out to a separate thread.\n\nAt core, the reason why this method *might* work is that it's essentially\njust CPFP but we can guarantee that the link we're examining is always\nexactly one hop away, so we get rid of most of the CPFP graph traversal\nissues.\n\nYour description largely matches my thinking for how something like this\ncould work (pay for neighbor). The issue is that the extant CPFP logic is\nsomewhat brittle and doesn't work as expected (Child not Children, which is\nproblematic for multiple PFN's).\n\n> PFN transaction would still be valid if some of 'ghost parents' are\nalready confirmed, so the miners could have more fees than strictly\nnecessary. But this is the same as with CPFP.\n\nThis is problematic and can't be done as it requires a new index of all\npast txns for consensus.\n\nMy thinking is that a Fee Bump transaction can name a list of TXIDs (Or one\nTXID which implies all ancestors of) that it wishes to be included in a\nblock with. It must be included in that block. A Fee Bump transaction may\nhave no unconfirmed ancestors nor any children. Potentially, it also may\nnot be RBF'd. You treat the Fee Bump Transactions as the lowest descendant\nof whatever it targets and then set it's feerate/total fee based on the\npackage that would have to co-confirm for it to be worth mining. This makes\nit sort like normal transactions for inclusion. You can require some\nminimums for mempool inclusion at all.\n\nIf it's target is confirmed or replaced, it should drop from the mempool.\n\nTransactions in the mempool may set a flag that opts out of CPFP for\ndescendants/blocks any descendants. Channel protocols should set this bit\nto prevent pinning, and then use the Fee Bump to add fees to whatever txns\nneed to go through. If done right you can also layer a coinswap protocol\nwith the fee-bumping txns change so that you are getting a privacy benefit\nat the same time.\n\nBTW the annex *could* be used for this purpose, but it would also be\nacceptable to have it be in some kind of anyone can spend output. Then it\nwould just be a anyone-can-spend tx with OP_CHECK_TXID_IN_BLOCK (or\nOP_CHECK_UTXO_SPENT_IN_BLOCK), and a miner could claim all such outputs at\nthe end of the block. This is worse in terms of on-chain overheads, but\nnice in that it's the minimal semantic change & introduces some general\npurpose functionality.\n\nBut my thoughts are still pretty loose at the moment around it. I suspect\nthat to make fee bumping work nicely would require removing CPFP entirely,\nbut I don't know that to be the case concretely.\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\n\nOn Sun, Jun 7, 2020 at 11:02 PM Dmitry Petukhov <dp at simplexum.com> wrote:\n\n> \u0412 Sun, 7 Jun 2020 15:45:16 -0700\n> Jeremy via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > What I think we'll eventually land on is a way of doing a tx\n> > that contributes fee to another tx chain as a passive observer to\n> > them. While this breaks one abstraction around how dependencies\n> > between transactions are processed, it also could help resolve some\n> > really difficult challenges we face with application-DoS (pinning and\n> > other attacks) in the mempool beyond CTV. I have a napkin design for\n> > how this could work, but nothing quite ready to share yet.\n>\n> I had an idea of 'Pay for neighbor' transaction where a transaction\n> that is not directly a child of some other transaction can specify that\n> it wants to pay the fee for that other transaction(s). It can become\n> like 'ghost child' transaction for them, in what it cannot be mined\n> unless its 'ghost parents' are confirmed, too. It will be like CPFP,\n> but without direct dependency via inputs. Such 'PFN' transaction would\n> not spend any coins beside what it specifies in its own inputs, of\n> course.\n>\n> The idea required a hardfork at first, but Anthony Towns suggested\n> a way to make it into a soft fork (past-taproot) by putting the txids of\n> 'ghost parents' into taproot annex.\n>\n> PFN transaction would still be valid if some of 'ghost parents' are\n> already confirmed, so the miners could have more fees than strictly\n> necessary. But this is the same as with CPFP.\n>\n> Looking at the mempool code, it seems that only a way how parent/child\n> transactions relationships are established will need to be adjusted to\n> account for this 'ghost relationships', and once established, other\n> logic will work as with CPFP. There could be complications regarding\n> transaction package size. But I cannot claim that I understand that\n> code enough to say something about this with certainty.\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200607/520bf867/attachment-0001.html>"
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2020-06-08T07:15:11",
                "message_text_only": "\u0412 Sun, 7 Jun 2020 23:43:39 -0700\nJeremy via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> > PFN transaction would still be valid if some of 'ghost parents' are\n> >  \n> already confirmed, so the miners could have more fees than strictly\n> necessary. But this is the same as with CPFP.\n> \n> This is problematic and can't be done as it requires a new index of\n> all past txns for consensus.\n\nIf the logic would match CPFP, then PFN would be valid if some of the\n'ghost parents' are confirmed, but would be invalid if some of them are\nspent. I believe in this case txindex won't be required.\n\n> My thinking is that a Fee Bump transaction can name a list of TXIDs\n> (Or one TXID which implies all ancestors of) that it wishes to be\n> included in a block with. It must be included in that block. A Fee\n> Bump transaction may have no unconfirmed ancestors nor any children.\n> Potentially, it also may not be RBF'd. You treat the Fee Bump\n> Transactions as the lowest descendant of whatever it targets and then\n> set it's feerate/total fee based on the package that would have to\n> co-confirm for it to be worth mining. This makes it sort like normal\n> transactions for inclusion. You can require some minimums for mempool\n> inclusion at all.\n> \n> If it's target is confirmed or replaced, it should drop from the\n> mempool.\n\nRe \"may not be RBF'd\": What if the sender of PFN tx wants to increase\nthe fee it offers for the 'ghost parents'? RBF-ing PFN tx itself seems\nlike less wasteful way than RBF-ing some of the parents/'ghost parents'\njust for this purpose. Sometimes I think the sender of PFN will not be\neven able to replace any other transactions beside their own PFN tx\n(like when they offer 'fee bumping' service for others)"
            }
        ],
        "thread_summary": {
            "title": "Fee Bumping Operation",
            "categories": [
                "bitcoin-dev",
                "was BIP OP_CHECKTEMPLATEVERIFY"
            ],
            "authors": [
                "Jeremy",
                "Dmitry Petukhov"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 6535
        }
    },
    {
        "title": "[bitcoin-dev] Hash-based accumulators with quick insertion",
        "thread_messages": [
            {
                "author": "Salvatore Ingala",
                "date": "2020-06-08T09:28:28",
                "message_text_only": "Dear all,\n\nI have been working on some constructions for cryptographic accumulators\nthat optimise for quick insertion.\n\nAs a brief background, an accumulator is a data structure that maintains\ncompact commitments to a potentially very large (and dynamic) set, while\nkeeping proofs of membership short. Unsurprisingly, they are getting more\npopular, and one notable application in Bitcoin is to create light-weight\nfull nodes that do not need to store the UTXO set (Utreexo accumulator[1]).\n\nIn this work, I focus on additive accumulators that supports adding new\nelements, but not removing them. My motivation is to support extending\nScript with access to an arbitrarily large portion of the blockchain\nhistory and state (e.g., past blocks, txids, or any more complex state\nobtained from them - with all due care). The additional storage and\ncomputation cost for nodes is small, and the cost (in additional bytesize)\nfor any transaction that wishes to access state committed in the\naccumulator should be just slightly bigger than typical Merkle proofs.\n\nI have focused on:\n- An accumulator with insertion time O(1) and proof size O(log^2 n)\n- A construction with insertion time O(log log n) and proof size O(log n\nlog log n)\n\nAll the performance metrics above are in \"number of hashes\".\n\nYou can find:\n- draft writeup:\nhttps://github.com/bigspider/accumulator/blob/master/docs/paper-draft.pdf\n- sample python code (only for the first construction at this time):\nhttps://github.com/bigspider/accumulator\n\nWhile this is still an unfinished work, the ideas in the draft are\nhopefully clear enough and easy to understand. I wanted to share it at this\nstage as it can benefit from comments to improve the constructions, to\ncover any related work or to find potential applications in Bitcoin (e.g.\nScript, layer2, side chains, etc).\n\nBest,\nSalvatore Ingala\n\n[1] - Thaddeus Dryja, Utreexo: A dynamic hash-based accumulator optimized\nfor the Bitcoin UTXO set - https://eprint.iacr.org/2019/611.pdf\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200608/562ce529/attachment.html>"
            },
            {
                "author": "German Luna",
                "date": "2020-06-08T22:01:09",
                "message_text_only": "Interesting work! I should be fortunate to make time to read it.\n\nI will point out, in case you'd not considered it, that you can support\naddition and removal indirectly by formulating it as a difference of sets.\nSimilar to the collision-resistant replicated data types (CRDTs) concept.\nChecking for membership would simply become CheckMembershipInAdditionSet &&\n!CheckMembershipInRemovalSet, assuming an item could only be added/removed\nonce. You could also perhaps support multiple addition/removal by attaching\na count of how many times it's been added though that might break some of\nthe building blocks in the paper.\n\n-- \nGerm\u00e1n\nMathematician\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200608/6e42c0a7/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Hash-based accumulators with quick insertion",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Salvatore Ingala",
                "German Luna"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3002
        }
    },
    {
        "title": "[bitcoin-dev] Question about PayJoin effectiveness",
        "thread_messages": [
            {
                "author": "Mr. Lee Chiffre",
                "date": "2020-06-10T04:01:44",
                "message_text_only": "I am trying to learn about payjoin. I have a couple concerns on its\neffectiveness. Are my concerns valid or am I missing something?\n\nconcern 1\nIf it is known to be a payjoin transaction anyone could determine the\nsender the recipient and amount right?\n\nLets assume that everyone has a single utxo because payjoin becomes common\nuse and payjoin consolidates utxos through \"snowballing\". If Alice has a\nUTXO of 0.05 btc and Bob has a UTXO of 1.15 btc. Bob can be assumed to\nhave more balance because he is a merchant and his customers payjoin him\npayments alot.\n\nIf Alice and Bob do a payjoin with Alice paying 0.01 btc to Bob, it would\nprobably look like this right?\n\n 0.05---> |____---->1.16\n 1.15---> |    ---->0.04\n\nIt is very obvious here the amount sent and the sender.  Even if Alice did\ncombine another input it would still be very obvious. In this case Alice\nhas another utxo with 0.4 BTC\n\n 0.40---> |\n 0.05---> |____---->1.16\n 1.15---> |    ---->0.44\n\nThis is still obvious that Alice paid Bob 0.01 BTC isn't it?\n\n\n\nconcern 2\nIf there is just one consolidated utxo after each payjoin, would it  be\neasy to break the privacy of transaction chains?\n\nAlice---payjoin--->Bob\nClark---payjoin--->Bob\n\nor\n\nAlice---payjoin--->Bob---payjoin--->Clark\n\nFor exmaple, lets say that Alice payjoins to Bob. Then later on Clark\npayjoins with Bob. Based on the payjoin between Clark and Bob, Clark now\nknows what UTXO was actually Bob's. And can then know which one was\nactually Alices. By transacting a payjoin with someone, they could decloak\nthe payjoins before them right? If so, how far back the chain can they go?\n\nThe issue is not that someone knows the utxos of themselves and the entity\nthey payjoined with. The issue is that someone can figure out the payjoins\nof others before them with the same entity.\n\n\nI surely must be missing something here. What am I not understanding?\n\n-- \nlee.chiffre at secmail.pro\nPGP 97F0C3AE985A191DA0556BCAA82529E2025BDE35"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-10T06:29:08",
                "message_text_only": "Good morning Mr. Lee,\n\n> I am trying to learn about payjoin. I have a couple concerns on its\n> effectiveness. Are my concerns valid or am I missing something?\n>\n> concern 1\n> If it is known to be a payjoin transaction anyone could determine the\n> sender the recipient and amount right?\n>\n> Lets assume that everyone has a single utxo because payjoin becomes common\n> use and payjoin consolidates utxos through \"snowballing\". If Alice has a\n> UTXO of 0.05 btc and Bob has a UTXO of 1.15 btc. Bob can be assumed to\n> have more balance because he is a merchant and his customers payjoin him\n> payments alot.\n>\n> If Alice and Bob do a payjoin with Alice paying 0.01 btc to Bob, it would\n> probably look like this right?\n>\n> 0.05---> |____---->1.16\n> 1.15---> | ---->0.04\n\n\nThere are multiple interpretations:\n\n* The 0.05 owner is paying the 1.15 owner 0.01 BTC.\n* The 1.15 owner is paying the 0.05 owner 1.11 BTC.\n* The 0.05 + 1.15 owner is paying an independent user 1.16 BTC using a non-PayJoin transaction (because for example the payee currently has no coins, i.e. a new user).\n\nIt is this fact of multiple interpretations that is what PayJoin buys you in practice.\n\nYou could argue that paying 0.01 is more likely than paying 1.11 or 1.16, but that still does not give you 100% assurance --- the creators of the transaction are still getting the `100% - probability_of_paying_0.01` benefit, and reducing UTXO set size as well.\n\nYour assertion that this is \"very obvious\" only exists because you already know that Alice is paying 0.01 to Bob, but that is in fact the very thing that is being obscured here.\n\n\n>\n> It is very obvious here the amount sent and the sender. Even if Alice did\n> combine another input it would still be very obvious. In this case Alice\n> has another utxo with 0.4 BTC\n>\n> 0.40---> |\n> 0.05---> |____---->1.16\n> 1.15---> | ---->0.44\n\n\nThis can be interpreted as well multiple ways:\n\n* 0.05 + 1.15 is the same owner who wants to merge coins, and is paying the 0.40 owner 0.04 BTC.\n* 0.40 + 1.15 is the same owner who wants to merge coins, and is paying the 0.05 owner 0.39 BTC.\n* 0.40 + 0.05 is the same owner who wants to merge coins, and is paying the 1.15 owner 0.01 BTC.\n\nYou should probably be shuffling the inputs and outputs, or using BIP39 consistently, so that inputs and outputs do not correlate (i.e. do not necessarily group together all of Alice inputs).\n\n\n>\n> This is still obvious that Alice paid Bob 0.01 BTC isn't it?\n>\n> concern 2\n> If there is just one consolidated utxo after each payjoin, would it be\n> easy to break the privacy of transaction chains?\n>\n> Alice---payjoin--->Bob\n> Clark---payjoin--->Bob\n>\n> or\n>\n> Alice---payjoin--->Bob---payjoin--->Clark\n>\n> For exmaple, lets say that Alice payjoins to Bob. Then later on Clark\n> payjoins with Bob. Based on the payjoin between Clark and Bob, Clark now\n> knows what UTXO was actually Bob's. And can then know which one was\n> actually Alices. By transacting a payjoin with someone, they could decloak\n> the payjoins before them right? If so, how far back the chain can they go?\n>\n> The issue is not that someone knows the utxos of themselves and the entity\n> they payjoined with. The issue is that someone can figure out the payjoins\n> of others before them with the same entity.\n\nIf Clark can hack Alice (even just read-only access to Alice logs), they can go by one more transaction.\n\nIf Clark cannot hack Alice, then that is the sole extent Clark knows: Clark know that Bob transacted with somebody for a resulting N BTC (which is relatively uninteresting, obviously somebody who uses BTC is going to be transacting with random BTC users in BTC), without being sure that Bob was the payer or the payee in that situation.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-10T06:47:28",
                "message_text_only": "Good morning again Mr. Lee,\n\n> > I am trying to learn about payjoin. I have a couple concerns on its\n> > effectiveness. Are my concerns valid or am I missing something?\n> > concern 1\n> > If it is known to be a payjoin transaction anyone could determine the\n> > sender the recipient and amount right?\n> > Lets assume that everyone has a single utxo because payjoin becomes common\n> > use and payjoin consolidates utxos through \"snowballing\". If Alice has a\n> > UTXO of 0.05 btc and Bob has a UTXO of 1.15 btc. Bob can be assumed to\n> > have more balance because he is a merchant and his customers payjoin him\n> > payments alot.\n\n\nIt is also helpful to remember that Bob cannot exist in isolation, and therefore, Bob probably has:\n\n* Employees.\n* Suppliers.\n* Shareholders.\n\nFor example, suppose Bob holds in reserve a 0.05 BTC UTXO in a holding wallet.\n\nThen Bob takes the 1.16 UTXO it got from Alice and transfers 1.12 BTC to the holding wallet:\n\n    Bob merchant wallet 1.16 --___-- 1.17 Bob holding wallet\n    Bob holding wallet  0.05 --   -- 0.04 Bob merchant wallet\n\nThe above looks exactly like one of the \"customer pays Bob\" transactions, but is in fact different.\n\nThen Bob uses the holding wallet to pay out to employees, suppliers, and shareholders, such as in a single large batched transaction, and then leaves behind another 0.05 BTC in the holding wallet (or some random small number of BTC) for the next time Bob has to pay to employees/suppliers/shareholders.\n\nSo the transaction below:\n\n    1.16 --___-- 1.17\n    0.05 --   -- 0.04\n\n*could* be interpreted as the 0.05 owner paying to the 1.16 owner, but in fact that is just Bob preparing the incoming funds from the merchant front-end for processing to send to its own liabilities.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Chris Belcher",
                "date": "2020-06-10T17:49:16",
                "message_text_only": "On 10/06/2020 05:01, Mr. Lee Chiffre via bitcoin-dev wrote:\n> I am trying to learn about payjoin. I have a couple concerns on its\n> effectiveness. Are my concerns valid or am I missing something?\n> \n> concern 1\n> If it is known to be a payjoin transaction anyone could determine the\n> sender the recipient and amount right?\n> \n> Lets assume that everyone has a single utxo because payjoin becomes common\n> use and payjoin consolidates utxos through \"snowballing\". If Alice has a\n> UTXO of 0.05 btc and Bob has a UTXO of 1.15 btc. Bob can be assumed to\n> have more balance because he is a merchant and his customers payjoin him\n> payments alot.\n> \n> If Alice and Bob do a payjoin with Alice paying 0.01 btc to Bob, it would\n> probably look like this right?\n> \n>  0.05---> |____---->1.16\n>  1.15---> |    ---->0.04\n> \n> It is very obvious here the amount sent and the sender.  Even if Alice did\n> combine another input it would still be very obvious. In this case Alice\n> has another utxo with 0.4 BTC\n> \n>  0.40---> |\n>  0.05---> |____---->1.16\n>  1.15---> |    ---->0.44\n> \n> This is still obvious that Alice paid Bob 0.01 BTC isn't it?\n> \n> \n> \n> concern 2\n> If there is just one consolidated utxo after each payjoin, would it  be\n> easy to break the privacy of transaction chains?\n> \n> Alice---payjoin--->Bob\n> Clark---payjoin--->Bob\n> \n> or\n> \n> Alice---payjoin--->Bob---payjoin--->Clark\n> \n> For exmaple, lets say that Alice payjoins to Bob. Then later on Clark\n> payjoins with Bob. Based on the payjoin between Clark and Bob, Clark now\n> knows what UTXO was actually Bob's. And can then know which one was\n> actually Alices. By transacting a payjoin with someone, they could decloak\n> the payjoins before them right? If so, how far back the chain can they go?\n> \n> The issue is not that someone knows the utxos of themselves and the entity\n> they payjoined with. The issue is that someone can figure out the payjoins\n> of others before them with the same entity.\n> \n> \n> I surely must be missing something here. What am I not understanding?\n> \n\nAdding to what other people have written, it's an important point that\nPayJoin breaks the common-input-ownership heuristic. I.E. if PayJoins\nbecome even moderately popular then it will no longer be a safe\nassumption that all the inputs to a transaction are owned by the same\nentity (taking away all the obvious breaks like equal-output-coinjoins).\n\nThis assumption is a huge reason why blockchain surveillance is so\neffective. A good paper on that is here:\nhttps://arxiv.org/abs/1605.06369 (The Unreasonable Effectiveness of\nAddress Clustering Harrigan, Martin & Fretter, Christoph. (2016))\n\nThe assumption is mentioned by Satoshi in the whitepaper where he\nlaments that the privacy loss is unavoidable. (One of the few outright\nerrors in the paper, perhaps the only error). The fact that we have\ntechnology to break this assumption is a massive deal, and that's a big\nvalue-add of PayJoin."
            }
        ],
        "thread_summary": {
            "title": "Question about PayJoin effectiveness",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Chris Belcher",
                "Mr. Lee Chiffre"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 10399
        }
    },
    {
        "title": "[bitcoin-dev] Tainting, CoinJoin, PayJoin, CoinSwap",
        "thread_messages": [
            {
                "author": "nopara73",
                "date": "2020-06-10T12:32:05",
                "message_text_only": "The problem with CoinJoins is that desire for privacy is explicitly\nsignalled by them, so adversaries can consider them \"suspicious.\" PayJoin\nand CoinSwap solve this problem, because they are unnoticeable. I think\nthis logic doesn't stand for scrutiny.\n\n>From here on let's use the terminology of a typical adversary: there are 3\nkinds of coin histories: \"clean\", \"dirty\" and \"suspicious\".\nThe aftermath of you using a \"dirty\" coin is knocks on your door. You using\na \"suspicious\" coin is uncomfortable questions and you using a \"clean\" coin\nis seamless transfer.\n\nIn scenario 1, you start out with a \"clean\" history. By using CoinJoins you\nmake your new coin's history \"suspicious\" so you have no incentive to\nCoinJoin. By using CoinSwap/PayJoin your new coin can be either \"clean\" or\n\"dirty\". What would a \"clean\" coin owner prefer more? Take the risk of\nknocking on the door or answering uncomfortable questions?\n\nIn scenario 2, you start out with a \"dirty\" history. By using CoinJoins you\nmake your new coin's history \"suspicious\" so you have an incentive to\nCoinJoin. By using CoinSwap/PayJoin your new coin can either be \"clean\" or\n\"dirty\". What would a \"dirty\" coin owner prefer more? And here's an\ninsight: you may get knocks on your door for a dirty coin that you have\nnothing to do with. And you can prove this fact to the adversary, but by\ndoing so, you'll also expose that you started out with a \"dirty\" coin to\nbegin with and now the adversary becomes interested in you for a different\nreason.\n\nYou can also examine things assuming full adoption of PJ/CS vs full\nadoption of CJ, but you'll see that full adoption of any of these solves\nthe tainting issue.\n\nSo my current conclusion is that PJ/CS does not only not solve the taint\nproblem, it just alters it and ultimately very similar problems arise for\nthe users. Maybe the goal of unobservable privacy is a fallacy in this\ncontext as it is based on the assumption that desiring privacy is\nsuspicious, so you want to hide the fact that you desire privacy. And the\nsolution to the taint issue is either protocol change or social change\n(decent adoption.)\n\nPS.: Please try to keep the conversation to the Taint Issue as this email\nof mine isn't supposed to be discussing general pros and cons of various\nprivacy techniques.\n\nAny thoughts?\n\n-- \nBest,\n\u00c1d\u00e1m\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200610/ab707108/attachment.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2020-06-10T13:48:55",
                "message_text_only": "A major point of defeating the common input heuristic and others is to make\n\"super-clusters\". A small number of users that \"don't care\" about possibly\ntouching tainted coins can render many chain analysis techniques unworkable\nin practice for enforcement. You don't need 100% coverage to defeat the\nheuristic.\n\nOn Wed, Jun 10, 2020 at 9:40 AM nopara73 via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> The problem with CoinJoins is that desire for privacy is explicitly\n> signalled by them, so adversaries can consider them \"suspicious.\" PayJoin\n> and CoinSwap solve this problem, because they are unnoticeable. I think\n> this logic doesn't stand for scrutiny.\n>\n> From here on let's use the terminology of a typical adversary: there are 3\n> kinds of coin histories: \"clean\", \"dirty\" and \"suspicious\".\n> The aftermath of you using a \"dirty\" coin is knocks on your door. You\n> using a \"suspicious\" coin is uncomfortable questions and you using a\n> \"clean\" coin is seamless transfer.\n>\n> In scenario 1, you start out with a \"clean\" history. By using CoinJoins\n> you make your new coin's history \"suspicious\" so you have no incentive to\n> CoinJoin. By using CoinSwap/PayJoin your new coin can be either \"clean\" or\n> \"dirty\". What would a \"clean\" coin owner prefer more? Take the risk of\n> knocking on the door or answering uncomfortable questions?\n>\n> In scenario 2, you start out with a \"dirty\" history. By using CoinJoins\n> you make your new coin's history \"suspicious\" so you have an incentive to\n> CoinJoin. By using CoinSwap/PayJoin your new coin can either be \"clean\" or\n> \"dirty\". What would a \"dirty\" coin owner prefer more? And here's an\n> insight: you may get knocks on your door for a dirty coin that you have\n> nothing to do with. And you can prove this fact to the adversary, but by\n> doing so, you'll also expose that you started out with a \"dirty\" coin to\n> begin with and now the adversary becomes interested in you for a different\n> reason.\n>\n> You can also examine things assuming full adoption of PJ/CS vs full\n> adoption of CJ, but you'll see that full adoption of any of these solves\n> the tainting issue.\n>\n> So my current conclusion is that PJ/CS does not only not solve the taint\n> problem, it just alters it and ultimately very similar problems arise for\n> the users. Maybe the goal of unobservable privacy is a fallacy in this\n> context as it is based on the assumption that desiring privacy is\n> suspicious, so you want to hide the fact that you desire privacy. And the\n> solution to the taint issue is either protocol change or social change\n> (decent adoption.)\n>\n> PS.: Please try to keep the conversation to the Taint Issue as this email\n> of mine isn't supposed to be discussing general pros and cons of various\n> privacy techniques.\n>\n> Any thoughts?\n>\n> --\n> Best,\n> \u00c1d\u00e1m\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200610/5f548ea7/attachment.html>"
            },
            {
                "author": "Chris Belcher",
                "date": "2020-06-10T20:10:19",
                "message_text_only": "Hello nopara73,\n\nOn 10/06/2020 13:32, nopara73 via bitcoin-dev wrote:\n> The problem with CoinJoins is that desire for privacy is explicitly\n> signalled by them, so adversaries can consider them \"suspicious.\" PayJoin\n> and CoinSwap solve this problem, because they are unnoticeable. I think\n> this logic doesn't stand for scrutiny.\n> \n>>From here on let's use the terminology of a typical adversary: there are 3\n> kinds of coin histories: \"clean\", \"dirty\" and \"suspicious\".\n> The aftermath of you using a \"dirty\" coin is knocks on your door. You using\n> a \"suspicious\" coin is uncomfortable questions and you using a \"clean\" coin\n> is seamless transfer.\n> \n> In scenario 1, you start out with a \"clean\" history. By using CoinJoins you\n> make your new coin's history \"suspicious\" so you have no incentive to\n> CoinJoin. By using CoinSwap/PayJoin your new coin can be either \"clean\" or\n> \"dirty\". What would a \"clean\" coin owner prefer more? Take the risk of\n> knocking on the door or answering uncomfortable questions?\n> \n> In scenario 2, you start out with a \"dirty\" history. By using CoinJoins you\n> make your new coin's history \"suspicious\" so you have an incentive to\n> CoinJoin. By using CoinSwap/PayJoin your new coin can either be \"clean\" or\n> \"dirty\". What would a \"dirty\" coin owner prefer more? And here's an\n> insight: you may get knocks on your door for a dirty coin that you have\n> nothing to do with. And you can prove this fact to the adversary, but by\n> doing so, you'll also expose that you started out with a \"dirty\" coin to\n> begin with and now the adversary becomes interested in you for a different\n> reason.\n> \n> You can also examine things assuming full adoption of PJ/CS vs full\n> adoption of CJ, but you'll see that full adoption of any of these solves\n> the tainting issue.\n> \n> So my current conclusion is that PJ/CS does not only not solve the taint\n> problem, it just alters it and ultimately very similar problems arise for\n> the users. Maybe the goal of unobservable privacy is a fallacy in this\n> context as it is based on the assumption that desiring privacy is\n> suspicious, so you want to hide the fact that you desire privacy. And the\n> solution to the taint issue is either protocol change or social change\n> (decent adoption.)\n> \n> PS.: Please try to keep the conversation to the Taint Issue as this email\n> of mine isn't supposed to be discussing general pros and cons of various\n> privacy techniques.\n> \n> Any thoughts?\n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n\nThere are two concepts here: Taint analysis and the detectableness of\nprivacy protocols.\n\nTaint analysis is quite an old technique, I remember seeing the\nblockchain.info explorer having a tool for calculating a value for taint\nback in 2013, long before any widely-used CoinJoin implementations were\ncreated. I think taint was first created to attack the privacy technique\nof simply sending coins to yourself multiple times. If those coins were\nfor example stolen from an exchange's hot wallet then the taint between\nthe exchange addresses and the later addresses would still be 100% even\nif the thief sent the coins to himself multiple times.\n\nA very important point is that it's difficult to reason about taint\nanalysis algorithms because they are often hypothetical, likely\nclosed-source, not available to the public for review and changing all\nthe time. OP talks about the three categories \"clean\", \"dirty\" and\n\"suspicious\" which is one possibility. I've read about other taint\nanalysis algorithms which result in a numerical score out of 100.\nBlockchain.info's algorithm calculated taint as a number expressing the\nrelation between any two addresses, so it wouldn't make sense to say \"an\naddress\" is tainted, instead you have to talk about a pair of addresses\nbeing tainted with each other. So even though it's hard to reason about\nthe exact algorithm we can still talk about likely situations, and\nimagine what an adversary could do in the worst case or best case.\n\nOne way to resist a likely taint analysis attack is to involve other\nparts of the bitcoin economy in your transactions. For example our\nexchange thief could deposit and then withdraw his stolen coins through\na Bitcoin Casino or other bitcoin service hot wallet. His coins might no\nlonger be 100% tainted from the exchange hack but perhaps have 5%\nexchange hack, 5% bitcoin ATM, 5% mined coins, etc etc. The numbers are\nmade up and they depend on the exact algorithm but the main point is\nthat involving the rest of the bitcoin economy in your transaction is\none practical way to stop taint analysis being a useful attack against\non you.\n\nAnother important point is that taint isn't part of bitcoin's code\nanywhere. It is an external reality that surveillance companies impose\non users. The only reason taint has any influence is because of\ncensorship, for example an exchange which uses the services of a\nsurveillance company has the power to freeze funds (i.e. censor a\ntransaction) if they believe the user's deposit transaction is tainted.\n\nTherefore a way to resist the taint analysis attack is to actually use\nbitcoin as money, I.E. earn bitcoin, spend it with merchants, who then\nspend it with other merchants or pay their employees, where most\nentities along those links actually dont use a taint analysis algorithm.\nThis is a general principle of bitcoin privacy by the way, if every\nentry- and exit-point requires giving up personal information then\nprivacy is dead, regardless of whether we use\nCoinJoin/PayJoin/CoinSwap/whatever in between.\nThis is a good place to again shill this list of peer-to-peer exchanges:\nhttps://github.com/cointastical/P2P-Trading-Exchanges/\n\nSo that's taint.\n\nNow for privacy protocols like CoinJoin. They also involve the rest of\nthe bitcoin economy, because many different users link their coins\ntogether when using CoinJoin/PayJoin/CoinSwap/etc, so such protocols can\nbe a way to resist taint analysis too just like the Bitcoin Casino\nmentioned earlier.\n\nHowever, what I think OP is talking about is the case where taint\nalgorithms are reprogrammed to not just track exchange hack addresses,\nbut also track privacy protocol transactions. So for example if the\nhypothetical taint algorithm comes across an Equal-Output CoinJoin it\nwill assign it a different taint score even if its not linked to an\nexchange hack or anything like that.\n\nSuch a reprogramming wouldn't be possible in undetectable privacy\nprotocols like PayJoin and CoinSwap. They will have the economy-mixing\neffect of reducing taint (just like the Bitcoin Casino example above),\nbut as OP writes that can just lead to the wrong person being under\nsuspicion. And so such protocols on their own cant resist taint analysis\nforever, which is the point is OP making as well.\n\nThe only permanent solution to taint analysis as I've mentioned is to\nuse bitcoin as money, away from centralized choke points that can censor\ntransactions and demand personal information. It's worth pointing out\nthat using bitcoin as money wont help our exchange hacker much, this\nhacker will never be able to buy mansions or sports cars with their\nstolen bitcoin, because the authorities already require proof of the\norigin of funds before, for example, buying a big mansion.\n\nNonetheless, unobservable privacy is also useful for other reasons than\nresisting taint analysis:\n\n* It improves the privacy of people who do not use it.\n* It helps stops censorship of privacy protocols (I.E. miners could one\nday refuse to mine equal-output CoinJoin transactions but still mine\nregular transactions)\n* It typically uses less block space, because information is removed\nfrom the blockchain rather than adding to the blockchain.\n\n\nRegards\n\nChris Belcher"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-10T23:01:46",
                "message_text_only": "Good morning nopara73 and Chris,\n\n\n> One way to resist a likely taint analysis attack is to involve other\n> parts of the bitcoin economy in your transactions. For example our\n> exchange thief could deposit and then withdraw his stolen coins through\n> a Bitcoin Casino or other bitcoin service hot wallet. His coins might no\n> longer be 100% tainted from the exchange hack but perhaps have 5%\n> exchange hack, 5% bitcoin ATM, 5% mined coins, etc etc. The numbers are\n> made up and they depend on the exact algorithm but the main point is\n> that involving the rest of the bitcoin economy in your transaction is\n> one practical way to stop taint analysis being a useful attack against\n> on you.\n>\n> Another important point is that taint isn't part of bitcoin's code\n> anywhere. It is an external reality that surveillance companies impose\n> on users. The only reason taint has any influence is because of\n> censorship, for example an exchange which uses the services of a\n> surveillance company has the power to freeze funds (i.e. censor a\n> transaction) if they believe the user's deposit transaction is tainted.\n\nAdding on to this, we can consider the *economics* of taint.\n\nTainted coins are less valuable than untainted coins.\n\nHowever, as pointed out as well, taint is not a consensus among all Bitcoin users.\nThere are no cryptographic underpinnings that would allow all nodes to agree on their individual taint analysis.\n\nThe people knocking on doors often have limited amounts of reach: there are real economic barriers to the knock-on-doors people being shipped to the other side of the Earth (fuel costs, ammunition costs, sociopolitical knock-on effects....).\n\nThus, suppose I am a miner with N coins.\nAs the coins have no history, they are \"completely clean\", as it were.\n\nAs a miner, I exist somewhere in the universe.\nIt is possible that I exist in some location on Earth (we cannot know; please ignore scurrilous slander that I am somehow existent outside of time and space).\n\nNow suppose you have some tainted coins.\nAs noted, those coins are tainted only within some jurisdiction.\nOutside that jurisdiction, however, they have no taint (taint is not a global consensus).\n\nIf I happen to live outside the jurisdiction where your coins are tainted, and I have some clean freshly-mined coins, I can offer this deal to you:\n\n* Give me N+1 tainted coins for my N clean coins.\n\nNow, again, the premise here is that there exists no global knock-on-doors people who can come to my datacenter and start asking questions to the sysads administering my computational substrate.\n\nIn that case, you might very well take the deal:\n\n* You have not lost economic power, because the tainted coins, in your jurisdiction, are of lower value than N+1 anyway, and might even have value below that of N clean coins.\n* I have gained economic power, because the tainted coins, in my jurisdiction, are not tainted and have the same cleanliness as my fresh mined coins.\n\nThis is a simple example of gains from trade, this time from jurisdictional arbitrage, thus such deals will exist.\n\n--\n\nBut that is specious, as it assumes that there exists no global knock-on-doors people.\nObviously, there could exist one or more entities who are able to ship knocks-on-doors people all over the globe, taking advantage of economies of scale and reinvestment (more knock-on-doors people to knock on doors of people they can extract more economic power from to hire more knock-on-doors people) to achieve practically global coverage.\n\nAgainst this, we must remember that ultimately censorship resistance of the coin is what can protect against such an attacker, which can impose its own non-consensual-but-pretty-damn-important view of taint practically globally.\n\nCensorship resistance requires that owners of coins have control of the keys (your keys your coins) and that they can offer bribes to miners to get their transactions committed (mining fees).\nCustodiality makes it easier for fewer knock-on-doors people to need to be shipped to stop certain activities.\n\nNow, the Bitcoin Casino example is of course an example of not your keys not your coins i.e. custodiality.\n\nFor the purpose of mixing, the \"Bitcoin Casino\" here is simply aggregating multiple UTXOs and then sending them back out to many other new UTXOs.\n\nThis is in fact the same operation that CoinJoin does, it aggregates multiple UTXOs and creates many new UTXOs to different clients with shared taint.\nThe advantage is that CoinJoin is still your keys your coins, you still own the keys with which to sign the CoinJoin transaction, and thus improve censorship resistance of your mixing operation.\n\nFor CoinSwap as well, we can consider that a CoinSwap server could make multiple CoinSwaps with various clients.\nThis leads to the CoinSwap server owning many small UTXOs, which it at some point aggregates into a large UTXO that it then uses to service more clients (for example, it serves many small clients, then has to serve a single large client that wants a single large UTXO for its own purposes).\nThis aggregation again leads to spreading of taint.\nCoinSwap, in this regard, is something like the cofunctor of CoinJoin.\nAgain, the advantage here is that CoinSwap is still your keys your coins, compared to the situation with Bitcoin Casino which is custodial.\n\n(@Chris: I think it would be a good design for SwapMarket makers to avoid spending-together its owned coins when swapping, but if it *does* need to do so (i.e. its coins are all too split up and it becomes unable to serve a client without spending more than one coin in a tx), to spend-together *all* its UTXOs and try to serve as many takers as possible in a single tx, to simulate precisely the batching operations that custodial services use, thus appearing as some new custodial service, without actually *being* custodial.)\n\nThus, we should consider that CoinJoin and CoinSwap improve the censorship resistance, and thus improve our global resistance to a potential global attacker using taint analysis.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Mr. Lee Chiffre",
                "date": "2020-06-11T02:01:41",
                "message_text_only": "Thought provoking. In my opinion bitcoin should be designed in a way to\nwhere there is no distinction between \"clean\" bitcoins and \"dirty\"\nbitcoins. If one bitcoin is considered dirty then all bitcoins should be\nconsidered dirty. Fungibility is important. And bitcoin or its users\nshould not be concerned with pleasing governments. Bitcoin should be or\nremain neutral. The term \"clean\" or \"dirty\" is defined by whatever\ngovernment is in power. Bitcoin is not to please government but to be\nindependent of government control and reliance on government or any other\ncentralized systems. To act as censorship resistant money to give people\nfreedom from tyranny. I'm just saying that if anyone can determine if a\nbitcoin is clean or dirty then I think we are doing something wrong. What\nis great with certain protocols like coinjoin coinswap and payjoin there\nis that plausible deniability that hopefully would spread the entire\n\"taint\" of bitcoin collectively either for real or just as a possibility \nto any blockchain analysis entities (with no real way to tell or interpret\nwith accuracy).\n\nBitcoin should be designed in a way where the only way to stop \"dirty\"\nbitcoins is to reject all bitcoins.\n\nIf \"dirty\" bitcoins is actually a real thing then I guess I could have fun\nby polluting random peoples bitcoin addresses with \"dirty\" coins right? No\nway to prove if it is a self transfer or an unsolicited \"donation\".  I\njust do not see how any bitcoin UTXO censorship could work because of\nplausible deniability.\n\nIf any company actually used UTXO censorship then customers can just use\nservices that are respecting of freedom and do not use censorship."
            },
            {
                "author": "nopara73",
                "date": "2020-06-11T11:20:56",
                "message_text_only": "Thank you all for your replies, I think everyone agrees here how it \"should\nbe\" and indeed I risked my post and my used terminology to further\nlegitimize the thinking of adversaries.\nI'd have one clarification to my original post. It may not be clear why I\nput PJ/CS to the same box. One way of thinking of CoinSwap is to swap coin\nhistories and PayJoin is to share coin histories. For the purposes of this\nattack the consequences are roughly the same so that's why I think it's ok\nto put them under the same umbrella in this discussion, but I wouldn't die\nfor it :)\n\nAnd indeed I perhaps wrongly called this the \"Taint Issue\", maybe it should\nbe called \"Coin Discrimination Issue\" or something like that, not sure if\nwe have a term for this, but I'm sure we should have a term for this as\nunlike some other, so far theoretical attacks on Bitcoin's fungibility, it\nis currently being applied in practice.\n\n\nOn Thu, Jun 11, 2020 at 7:24 AM Mr. Lee Chiffre via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Thought provoking. In my opinion bitcoin should be designed in a way to\n> where there is no distinction between \"clean\" bitcoins and \"dirty\"\n> bitcoins. If one bitcoin is considered dirty then all bitcoins should be\n> considered dirty. Fungibility is important. And bitcoin or its users\n> should not be concerned with pleasing governments. Bitcoin should be or\n> remain neutral. The term \"clean\" or \"dirty\" is defined by whatever\n> government is in power. Bitcoin is not to please government but to be\n> independent of government control and reliance on government or any other\n> centralized systems. To act as censorship resistant money to give people\n> freedom from tyranny. I'm just saying that if anyone can determine if a\n> bitcoin is clean or dirty then I think we are doing something wrong. What\n> is great with certain protocols like coinjoin coinswap and payjoin there\n> is that plausible deniability that hopefully would spread the entire\n> \"taint\" of bitcoin collectively either for real or just as a possibility\n> to any blockchain analysis entities (with no real way to tell or interpret\n> with accuracy).\n>\n> Bitcoin should be designed in a way where the only way to stop \"dirty\"\n> bitcoins is to reject all bitcoins.\n>\n> If \"dirty\" bitcoins is actually a real thing then I guess I could have fun\n> by polluting random peoples bitcoin addresses with \"dirty\" coins right? No\n> way to prove if it is a self transfer or an unsolicited \"donation\".  I\n> just do not see how any bitcoin UTXO censorship could work because of\n> plausible deniability.\n>\n> If any company actually used UTXO censorship then customers can just use\n> services that are respecting of freedom and do not use censorship.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n-- \nBest,\n\u00c1d\u00e1m\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200611/5a9e314c/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Tainting, CoinJoin, PayJoin, CoinSwap",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Chris Belcher",
                "nopara73",
                "ZmnSCPxj",
                "Mr. Lee Chiffre",
                "Greg Sanders"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 24352
        }
    },
    {
        "title": "[bitcoin-dev] CoinPool, exploring generic payment pools for Fun and Privacy",
        "thread_messages": [
            {
                "author": "Antoine Riard",
                "date": "2020-06-11T08:53:08",
                "message_text_only": "Hi list,\n\nWe (Gleb Naumenko + I) think that a wide range of second-layer protocols\n(LN, vaults, inheritance, etc) will be used by average Bitcoin users. We\nare interested in finding and addressing the privacy issues coming from the\nunique fingerprints these protocols bring.\n\nMore specifically, we are interested in answering the following questions:\n1. How bad are privacy leaks from on-chain txn of second-layer protocols\nand how much is leaked via protocol-specific metadatas (LN domain names,\nwatchtowers, ...) ?\n2. How to establish a list of Bitcoin fingerprints and their severity to\ninform protocol designers and clarify threat models ?\n3. What kind of sophisticated heuristics spies may use in the future ?\n4. How to mitigate privacy leaks ? Should each protocol adopt a common\ntoolbox (scriptless scripts, taproot, ...) in its own way or should we\ndesign a confidential-layer to wrap around all of them ?\n5. How to make the solution usable (cheaper, easier to integrate, safer)\nfor a daily basis ?\n\nWe suggest CoinPool: a generic payment pool [0] as a solution to those\nproblems. Although the design we propose is somewhat a scaling solution, we\nwon't focus on this aspect. This work is rather an exploration of *how a\npool construction could serve as a TLS for Bitcoin, enhancing both on-chain\nand off-chain privacy*.\n\n### Motivation: cross-protocols privacy\n\nIt has always been a challenge to make the on-chain UTXO graph more\nprivate. We all know the issues with cleartext amounts, the linkability of\ninputs/outputs, and other metadatas. Combining with p2p-level spying\n(transaction-to-IP mapping) or some other patterns leading to real-world\nidentities enable serious spying.\n\nProtocols on top of Bitcoin (LN, vaults[1], complicated spending conditions\nbased on Miniscript, DLC [2] are even more vulnerable to spying because:\n- each of them brings new unique fingerprint/metadata [3]\n- known spying techniques against second-layer are currently limited to\ntrivial heuristics, but we can't assume spies will always this\nunsophisticated\n\nThere is already a wiki list [4] attempting to cover all issues like that,\nalthough maintaining it would be challenging considering privacy is a\nmoving target.\n\nLet's consider this example: Alice is a well-known LN merchant with a node\ntied to a domain name. She always directs the output of channel closing to\nher vault address. If she has another vault address on-chain with the same\nunique unlocking script (like a CSV timelock with a specific delta) this\ncan be leveraged to cluster her transactions. And since one of her\naddresses is tied to a domain name, all her funds can now be linked to a\nreal-world identity.\n\nIn theory, one may use CoinJoin-like solutions to mask cross-protocol\non-chain transfers. Unfortunately, robust designs like CoinSwap depend on\ntimelocking coins, extensive use of the on-chain space, and paying fees to\nprovide sufficient privacy, as we explain further. These properties imply\nwe can't expect users to be using strong CoinSwaps by default.\n\nThat's why instead of specialized high-latency, high-chain-use\nCoinJoin-style protocols, we propose CoinPool: a low-latency, generic\noff-chain protocol used to be wrapped around any other protocol. CoinPool\nis based on shared UTXO ownership. It may reasonably improve on-chain\nprivacy while avoiding latency and locked liquidity issues. CoinPool may\nalso reduce the on-chain use (thus, help to scale Bitcoin) if participants\ncooperate sufficiently.\n\nWe do believe that CoinSwap and other CoinJoins are of interest, but we\nhave to consider the trade-offs and choose the best tool for a job to make\nprivacy usable with regards to user resources. We will compare CoinPool to\nCoinSwap in more detail later in this write-up.\n\n### Extra-motivation: on-chain scalability\n\nEven though it's not the main focus of this proposal, we also want to\nmention that since CoinPool is a payment pool, it helps with on-chain\nscalability. More specifically:\n1. Shared UTXO ownership allows to represent many outputs as one, reducing\nthe UTXO set in size.\n2. The CoinPool design enables off-chain transfers within the pool, helping\nto save the block space by committing fewer transactions on-chain.\n3. CoinPool provides decent support for batching activities from different\nusers, also helping to have fewer individual transactions on-chain.\n\nSince the CoinPool provides scalability benefits, users will be even\nincentivized to join CoinPools due to the conservative chain resources\nusage and such enjoy privacy as a side-effect.\n\n### CoinPool design\n\nA CoinPool must satisfy the following *non-interactive any-order\nwithdrawal* property: at any point in time and any possible sequence of\nprevious CoinPool events, a participant should be able to move their funds\nfrom the CoinPool to any address the participant wants without cooperation\nwith other CoinPool members.\n\nThe state of a CoinPool is represented by one on-chain UTXO (a funding\nmultisig of all pool participants) and a set of transactions stored by the\nparticipants along with signatures allowing to spend that UTXO. This UTXO\nis a Taproot output, where the leaves in the Merkle tree represent pool\nparticipants.\n\n#### Transactions\n\nA CoinPool UTXO can be spent by two types: Pool_Tx and Split_Tx.\n\nA Pool_Tx enables cooperatives updates of the pool, e.g a participant\nexiting the pool or off-chain internal transfers. This transaction is used\nto spend the key branch of the Taproot tree of the CoinPool UTXO.\nSignatures for a Pool_Tx should be exchanged \"on-demand\", the moment\nparties decide to update the CoinPool state collaboratively, In practice,\nthis would happen upon a request of a pool participant.\n\nA Split_Tx enables a unilateral exit from the CoinPool, in case it's not\npossible to use a cooperative Pool_Tx path. This transaction spends the\nUTXO via the Merkle branch into two outputs:\n- a _withdraw_ output paying to the pool participant who initiated a\ntransaction\n- a _recursive_ output paying to the new instance of a CoinPool, which\ncontains all the same participants except the one who just withdrew\n\nThe design of the unilateral Split_Tx depends on what can be achieved with\nBitcoin Script. The main challenge is to enforce the second output of the\nSplit_tx s that the participant who exists can't take all the funds\nunilaterally. We will talk more about the updates to Bitcoin Script which\nwould allow more advanced pools later (Scaling section).\n\nFor now, we will *focus on the Script capabilities of today*, per which\nspending a Split_Tx requires signatures from all pool participants. Since\nSplit_Tx is a unilateral exit, parties are required to exchange signatures\nfor *any possible state of the pool* in advance, to handle the *any-order\nwithdraw* requirement. The exchange should happen when a pool is created.\n\n#### Operations\n\nThere are three types of operations against a CoinPool: create, update,\nwithdraw.\n\nPer *creation*, participants agree on a pool policy and commit inputs to a\nfunding transaction by sending a corresponding signature, created in a\nsecure \"atomic\" way (so that their funds can't be taken if other pool\nparticipants are unresponsive). Participants also exchange their signatures\nwhich would allow any participant to exit at any given time via a Split_Tx.\n\nPer *update*, participants agree on a new coin distribution within the pool\ntree. They can aggregate and split leaves of the tree, or rotate a target\noutput of a given leaf. E.g, a participant may choose to redirect coins to\na new pool right from the old pool and ask all the parties to agree on this\nupdate. The previous state should then be revoked either via sequence\nnumber (Eltoo) or adding the latest state as a child transaction from any\nprevious Pool_tx.\n\nPer *withdraw*, a participant may submit either a Pool_Tx (after asking all\nthe parties for their signatures) or a Split_Tx (unilaterally). After that,\na new UTXO of the CoinPool would consist of all the remaining participants.\n\nAs an optimization, updates and withdrawals may aggregate changes to\nmultiple leaves within one transaction. A CoinPool may also optionality\nallow new participants to *join* a pool on-the-fly, although trade-offs\nshould be considered.\n\n#### Transaction Tree illustrated\n\nWe illustrate a CoinPool transaction tree with 3 leaves below. We use an\nobvious optimization: if there are only 2 leaves left, the last transaction\ndoesn't have to commit to a new tree [5].\n\n\n                                      Funding_Tx\n\n                                  |\n\n                                              |\n\n                                     [Taproot_T]\n\n\n          |\n\n        ___________________ | ______________________________________\n\n|\n                                                  |\n\n      |\n\n                                  |\n\n\n|\n                                    |\n\n[leaf_A]\n                                           |\n\n    ^\n\n                                    |\n\n\n|\n                                       |\n\nSplit_TxA\n\n___________________ |________________________\n                                                                        /\n             \\\n                                                                 |\n\n|\n\n/\n\\\n|\n|\n\n/\n\\\n[leaf_B]\n  [leaf_C]\n                                              [withdraw_A]\n[Taproot T']\n^\n^\n\n^\n|\n|\n\n|\nSplit_TxB\nSplit_TxC\n\n\nPool_Tx                                                    /\n\\\n/            \\\n\n/              \\\n/\n\\\n/                \\\n\n/                  \\                               [withdraw_B]\n[Taproot T'']\n[withdraw_C]             [Taproot'']\n\n/\n\\\n^\n^\n\n[withdraw_B]\n[withdraw_C]                                                     |\n\n      |\n\nPool_Tx\nPool_tx\n\n/\n\\\n/            \\\n\n/\n\\\n/                \\\n\n           [withdraw_A]\n[withdraw_C]\n[withdraw_A]            [withdraw_B]\n\n\n### Scaling the Pool and the Any-Order problem\n\nA conservative CoinPool indeed does not scale well: it requires generating\npruned Merkle Tree encumbering the _recursive_ output for any combination\nof withdrawals at pool creation. For a tree of Alice, Bob and Carol, they'd\nhave to build (A,B,C), (A,C,B), (B,A,C), (B,C,A), (C,A,B), (C,B,A) trees.\nSince the complexity is quasi-factorial, the conservative CoinPool design\nis impractical for more than 10 leaves.\n\nInstead of operating over every possible alternative statically (via\npre-signing *every* combination), the protocol may rely on the script\ninterpreter to do it dynamically, only enforcing an effective path among\nalternatives.\n\nA new primitive to enable this behavior can be implemented as an\naccumulator, i.e a space-efficient cryptographic set representation\nsupporting testing for inclusion and element deletion.\n\nImplementation of this delete-only accumulator can be done by introducing\nor combining already-proposed primitives like a new sighash flag, using a\nTaproot tree as an accumulator, a committed bitset with templated\noperations, etc, ... The exact design is left for future research.\n\nThis primitive would enable re-committing the updated tree on the\n_recursive_ output, that way preserving balances of other participants,\nindependently of order of withdrawals.\n\nSuch _recursive_ output needs to be spendable by remaining Split_txn. These\ntransactions are pre-signed and their inputs commit to the parent txid. To\nalleviate this issue, Split_tx should be signed through SIGHASH_NOINPUT,\ntherefore enabling _recursive_ output. The spending Tapscript must be\npresent among the set of Taproot tree leaves.\n\n### Intra-pool communication and pool policies\n\nThe CoinPool design assumes participants have to communicate regularly to\nexchange transaction templates and signatures. It happens almost every time\na state of the pools is modified: pool creation, pool update, and\ncooperative withdrawal. Selecting a communication channel (a mixnet,\ncentralized servers, publication boards, ...) should be done considering\nthe threat model, the cost, the expected latency.\n\nEvery instance of a CoinPool may be public (available for new participants\nto join at any time), private (available to join via some out-of-band\ncommunication), or something in the middle (based on anti-Sybil measures we\nwill discuss later).\n\n### Protocol rebinding\n\nSince the conservative CoinPool design every unilateral exit via Split_Tx\nshould be signed by all the parties in advance, every participant joining\nthe pool should define in advance which address the coins will be directed\nto in a unilateral case.\n\nHowever, participants may want to use their CoinPool funds to move their\npool funds to a new scriptPubkey (for example, to open a new LN channel).\nTo avoid using an intermediate single-address on-chain transaction for\nthese cases, participants should be able to rotate the Split_Tx output.\n\nTo avoid asking other participants of the CoinPool to sign a new update, a\nmultisig signature covering the Split_Tx and enforcing covenant semantic\nmay be signed with SIGHASH_SINGLE. That way, at any-time Alice can finalize\nher Split_Tx by adding a new output and signing her with SIGHASH_ALL.\n\nSince unilateral withdrawal from CoinPool is time-locked, integration\ntime-sensitive off-chain protocols (e.g, LN or DLC) must be done with extra\ncare.\n\nLastly, the limitations of the current mempool design should be taken into\naccount while using CoinPools, so that issues like mempool  pinning [6] are\nnot critical.\n\n### Security/Privacy model\n\nSimilarly to CoinJoins, CoinPool provides privacy by breaking payment\nsender/receiver linkability for an on-chain observer.\nCommon-input-ownership, address reuse, change address heuristics can't be\nleveraged. A spy is forced to commit/lock funds to the pool, and\npotentially overcome ant-Sybil measures. Internal CoinPool transfers also\nremain private for an external observer.\n\nThe exact on-chain privacy efficiency of a given CoinPool depends on two\nfactors: intra-pool activities and exit activities. If the parties are\ncooperative, intra-pool transfers never leave a footprint on-chain. Exit\nactivities always hit the chain, but if output rebinding is available, the\nfunds can be sent right to the target receiver outside the pool (e.g, cold\nstorage or even another pool), making on-chain analysis much more difficult\nthan what happens with regular transactions today.\n\nSince it's possible for an attacker to join a pool, we have to consider\nextra Sybil-resistance (beyond just depositing coins). Extra\nSybil-resistance may include a lock on withdrawal. This lock should not\nlimit intra-pool updates, so that honest users are not limited.\nAdditionally, the solutions suggested for CoinJoins may be used (fidelity\nbonds, PoDle, etc).\n\n### User Requirements\n\nCoinPool introduces two requirements on users: one for security, one for\npool performance.\n\nIt requires persistent storage from the user. Since a unilateral withdrawal\nassumes transmitting signatures received from other participants\nbeforehand, these signatures, corresponding Taproot output and Merkle\nbranches should not be lost or corrupted, otherwise a participant won't be\nable to exit the pool without cooperation.\n\nIt also requires hot access to the signing keys, i.e being online to sign\nupdates which introduces a higher security risk.\n\nThese requirements are similar to the requirements for LN and vault\nconstructions, so we believe that the burden on a CoinPool participant is\nreasonable as long as we consider second-layer protocols practical.\n\n### Comparing to CoinSwap\n\nA CoinSwap was recently proposed as a next step for on-chain bitcoin\nprivacy [6]. We will compare CoinPool to  CoinSwap in terms of high-level\nproperties, because there are no deployed CoinSwaps yet.\n\nCoinSwap enables privacy-enhanced (in terms of on-chain footprint)\ntransactions, executed as a non-custodial atomic \"trade\" between two\nparties willing to send someone else (not each other) coins at the same\ntime.\n\nA CoinSwap between two parties cost at least two on-chain transactions.\nHowever, since this minimal design leaks privacy due to the amount\ncorrelation, more advanced CoinSwap constructions should be used, and they\nwould be even more costly.\n\nThe privacy-efficiency of CoinSwaps is thus defined by fees and time-value\nparameters. For these reasons, the lower security requirements are likely\nto be most-widely picked-up by thrift users. Participation in a CoinPool,\nhowever, costs of a funding transaction fee (shared across all\nparticipants), and a cost of the withdrawal (either unilateral or\ncooperative). Off-chain updates within a pool are free.\n\nWith regards to linkability, CoinSwap breaks the UTXO ownership graph,\nCoinPool has similar properties the moment the coins are withdrawn, but the\noff-chain events inside the pool are likely to obfuscate it even further.\nEvery participant can make direct payments during pool lifetime, breaking\nmapping between committed inputs and withdrawn outputs.\n\nCoinPool output will be part of the broader taproot user set, therefore any\nsingle-owned output may be confused as a pool one, hindering further\non-chain analysis even for non-CoinPool users.\n\nWith regards to linkability, CoinSwap completely breaks the link between\ninputs and outputs, while CoinPool just largely obfuscates the link\n(similarly to CoinJoins). CoinPool is capable of breaking the link for\nthose payments happening off-chain (e.g, simple transfers within the pool).\n\nWith regards to requirements, beyond requiring online keys, practical\nCoinPools require new base layers primitives, namely Taproot,\nSIGHASH_NOINPUT and delete-only accumulators. CoinSwap is deployable today,\nalthough the client software should be built.\n\nWith regards to malicious participants, CoinPool provides some privacy (in\nterms of on-chain analysis) if at least one other participant is honest,\nwhich is the same assumption as CoinSwap. More specifying spying cost\nanalysis can be made when comparing particular configurations of a CoinSwap\nand a CoinPools. We invite the community to develop a better model of\nprivacy adversaries, their resources and leverages to refine\nprivacy-enhancing protocols comparisons.\n\nAlthough we claim that different properties of CoinSwaps and CoinPools make\nthem better for different goals, they can benefit from each other: e.g,\nboth of them may rely on Sybil-resistance mechanisms or federated message\nboards for cooperation.\n\n### Conclusion\n\nWe propose CoinPool: a payment pool construction to improve privacy against\non-chain data analysis. More specifically, it helps to hide the unique\nfootprint associated with the use of second-layer protocols.\n\nWe attempted to design CoinPools to make them usable for daily activities,\nas opposed to specialized CoinJoin-style solutions. They usually don't\nrequire paying fees and don't use the on-chain space *per-activity*. If\nthey are widely used, they can also help with on-chain scalability,\nalthough we don't cover this aspect in detail.\n\nCoinPool is a UTXO representing a Taproot tree, in which the leaves\nrepresent the spending conditions for coins in the pool. We designed\nCoinPool around the *non-interactive any-order withdrawal* requirement.\n\nIn the long-term, CoinPool appears as a good candidate for a scalable,\nused-by-default privacy-enhancing technology. We emphasize there are\nseveral challenges deploying CoinPools, the biggest one being scalability.\nMaking them practical requires introducing new on-chain primitives.\n\nThanks to the wider privacy-community and on which of their work this\ndepends heavily.\n\nThanks to the reviewers.\n\nCheers,\n\nGleb + Antoine\n\n\n[0] AFAIK, payment pools have been suggested by Greg Maxwell, although I\ncouldn't find any written evidence. The only description I know have been\nmade to me by Dave Harding during a BitDevs meetup. Yes I'm old enough to\nhave known when meatspace Bitcoin meetup was a thing.\n<https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017793.html>\n\n[1]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017793.html\n\n[2] https://github.com/discreetlogcontracts/dlcspecs/\n\n[3] On protocol usage leak at the on-chain level see\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017633.html,\nfor an illustration see\nhttps://b10c.me/mempool-observations/1-locktime-stairs/\n\n[4] https://en.bitcoin.it/Privacy\n\n[5] . A gist backup if it doesn't survive formatting :\nhttps://gist.github.com/ariard/ab1e4c3a85e4816be21ee0e0f925e86b A common\nnotation to describe transactions tree and their scripts and ease reviewers\nto verify their correctness would be great. Otherwise it's hard to gauge\nthe correctness of this kind of new protocol.\n\n[6] https://bitcoinops.org/en/newsletters/2020/04/29/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200611/43cc1fe6/attachment-0001.html>"
            },
            {
                "author": "Jeremy",
                "date": "2020-06-11T17:21:08",
                "message_text_only": "Stellar work Antoine and Gleb! Really excited to see designs come out on\npayment pools.\n\nI've also been designing some payment pools (I have some not ready code I\ncan share with you guys off list), and I wanted to share what I learned\nhere in case it's useful.\n\nIn my design of payment pools, I don't think the following requirement: \"A\nCoinPool must satisfy the following *non-interactive any-order withdrawal*\nproperty: at any point in time and any possible sequence of previous\nCoinPool events, a participant should be able to move their funds from the\nCoinPool to any address the participant wants without cooperation with\nother CoinPool members.\" is desirable in O(1) space. I think it's much\nbetter to set the requirement to O(log(n)), and this isn't just because of\nwanting to use CTV, although it does help.\n\nLet me describe a quick CTV based payment pool:\n\nBuild a payment pool for N users as N/2 channels between participants\ncreated in a payment tree with a radix of R, where every node has a\nmultisig path for being used as a multi-party channel and the CTV branch\nhas a preset timeout. E.g., with radix 2:\n\n                                      Channel(a,b,c,d,e,f,g,h)\n                                     /                                   \\\n               Channel(a,b,c,d)\nChannel(e,f,g,h)\n                    /\n\\                                                    /                 \\\nChannel(a,b)    Channel(c,d)                          Channel(e,f)\nChannel(g,h)\n\n\nAll of these channels can be constructed and set up non-interatively using\nCTV, and updated interactively. By default payments can happen with minimal\ncoordination of parties by standard lightning channel updates at the leaf\nnodes, and channels can be rebalanced at higher layers with more\nparticipation.\n\n\nNow let's compare the first-person exit non cooperative scenario across\npools:\n\nCTV-Pool:\nWait time: Log(N). At each branch, you must wait for a timeout, and you\nhave to go through log N to make sure there are no updated states. You can\ntrade off wait time/fees by picking different radixes.\nTXN Size: Log(N) 1000 people with radix 4 --> 5 wait periods. 5*4 txn size.\nRadix 20 --> 2 wait periods. 2*20 txn size.\n\nAccumulator-Pool:\nWait Time: O(1)\nTXN Size: Depending on accumulator: O(1), O(log N), O(N) bits. Let's be\nfavorable to Accumulators and assumer O(1), but keep in mind constant may\nbe somewhat large/operations might be expensive in validation for updates.\n\n\nThis *seems* like a clear win for Accumulators. But not so fast. Let's look\nat the case where *everyone* exits non cooperatively from a payment pool.\nWhat is the total work and time?\n\nCTV Pool:\nWait time: Log(N)\nTxn Size: O(N) (no worse than 2x factor overhead with radix 2, higher\nradixes dramatically less overhead)\n\nAccumulator Pool:\nWait time: O(N)\nTxn Size: O(N) (bear in mind *maybe* O(N^2) or O(N log N) if we use an\nsub-optimal accumulator, or validation work may be expensive depending on\nthe new primitive)\n\n\nSo in this context, CTV Pool has a clear benefit. The last recipient can\nalways clear in Log(N) time whereas in the accumulator pool, the last\nrecipient has to wait much much longer. There's no asymptotic difference in\nTx Size, but I suspect that CTV is at least as good or cheaper since it's\njust one tx hash and doesn't depend on implementation.\n\nAnother property that is nice about the CTV pool style is the bisecting\nproperty. Every time you have to do an uncooperative withdrawal, you split\nthe group into R groups. If your group is not cooperating because one\nperson is permanently offline, then Accumulator pools *guarantee* you need\nto go through a full on-chain redemption. Not so with a CTV-style pool, as\nif you have a single failure among [1,2,3,4,5,6,7,8,9,10] channels (let's\nsay channel 8 fails), then with a radix 4 setup your next steps are:\n[1,2,3,4,5,6,7,8,9,10]\n[1,2,3,4,5,6,7,X,9,10]\n[1,2,3,4] [5,6,7,X] [9,10]\n[1,2,3,4] 5 6 7 X [9,10]\n\nSo you only need to do Log(N) chain work to exit the bad actor, but then it\namortizes! A future failure (let's say of 5) only causes 5 to have to close\ntheir channel, and does not affect anyone else.\n\nWith an accumulator based pool, if you re-pool after one failure, a second\nfailure causes another O(N) work. So then total work in that case is\nO(N^2). You can improve the design by making the evict in any order option\nsuch that you can *kick out* a member in any order, that helps solve some\nof this nastiness (rather than them opting to leave). But I'm unclear how\nto make this safe w.r.t. updated states. You could also allow, perhaps, any\nnumber of operators to simultaneously leave in a tx. Also not sure how to\ndo that.\n\n\n\nAvailability:\nWith CTV Pools, you can make a payment if just your immediate conterparty\nis online in your channel. Opportunistically, if people above you are\nonline, you can make channel updates higher up in the tree which have\nbetter timeout properties. You can also create new channels, binding\nyourself to different parties if there is a planned exit.\n\nWith Accumulator pools, you need all parties online to make payments.\n\n\nCooperation Case:\nCTV Pools and Accumulator pools, in a cooperative case, both just act like\na N of N multisig.\n\nPrivacy:\nBecause Accumulator pools always require N signers, it's possible to build\na better privacy model where N parties are essentially managing a chaumian\necash like server for updates, giving good privacy of who initiated\npayments. You *could* do this with CTV pools as well, but I expect users to\nprefer making updates at the 2 party channel layer for low latency, and to\nget privacy benefits out of the routability of the channels and ability to\nconnect to the broader lightning network.\n\n\nTechnical Complexity:\nBoth protocols require new features in Bitcoin. CTV is relatively simple, I\nwould posit that accumulators + sighashnoinput are relatively not simple.\n\nThe actual protocol design for CTV pools is pretty simple and can be\ncompatible with LN, I already have a rudimentary implementation of the\nrequired transactions (but not servers).\n\n\nInteractivity:\n\nIn both designs, the payment pool can be created non-interactively. This is\n*super* important as it means third parties (e.g., an exchange) can\nwithdraw users funds *into* a payment pool.\n\n\nThanks for reading!\n\nJeremy\n\n\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200611/fcf38fb7/attachment.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2020-06-12T23:45:35",
                "message_text_only": "Hi Jeremy,\n\nFor the records, I didn't know between Greg and you was at the origin of\npayment pools. Thanks for your pioneer work here, obviously this draws\ninspiration from OP_CTV use cases and Channel Factories works, even if we\npicked up different assumptions and tried to address another set of issues.\n\nWith regards to scalability, I hit it on my own while inquiring\ncovenanted-Bitcoin contracts for international trade. I mentioned the\nany-order issue on such multi-party complex contracts in a talk last summer\n(https://github.com/ariard/talk-slides/blob/master/advanced-contracts.pdf).\n\n> All of these channels can be constructed and set up non-interatively using\n> CTV, and updated interactively. By default payments can happen with\nminimal\n> coordination of parties by standard lightning channel updates at the leaf\n> nodes, and channels can be rebalanced at higher layers with more\n> participation.\n\nSide review note on OP_CTV: I think it would be great to define\nnon-interactivity better, namely at least between 3 phases: establishment,\noperation, closing.\n\nEven OP_CTV protocols assume interactivity at establishment, at least 1) to\nlearn payees pubkeys endpoint (and internal leaves pubkeys if you want\nupdate at operation) 2) validate transaction tree correctness between\nparticipants.\n\nAt operation, it depends if participants want to dynamically rebalance\nvalue across channels or not. If you desire dynamically rebalancing, assume\ninternal leaves scriptpubkeys are (multisig-all OR OP_CTV'ed merkle_tree).\nUsing OP_CTV is a saving in message rounds for every constant expression\nacross tree updates.\n\nAt closing, depends again if participants have committed update keys or\nnot. If dynamic update, you can prune the whole tree and just commit final\nbalances onchain, either with a O(N) fan-out transaction (N outputs) or a\nO(log(N)) congestion tree (N transactions).\n\nSo I would say the originality of a hashchain covenant like OP_CTV is to\nprovide onchain *immutability* (unforgeability?) of the offchain\ntransaction tree and thus provides instant finality to payees. You can get\nthe same semantic with off-chain covenant, pre-signed set of transactions,\nassuming more communications rounds and performance hit.\n\nThat said, IMO, immutability comes with a security trade-off, namely if any\npayout key committed in your OP_CTV tree gets compromised your funds are at\nstake. And you can't update the tree anymore at the root to rotate keys. I\nthink this should be weighted by anyone designing covenant protocols,\nespecially vaults.\n\n> I don't think the following requirement: \"A\n> CoinPool must satisfy the following *non-interactive any-order withdrawal*\n> property: at any point in time and any possible sequence of previous\n> CoinPool events, a participant should be able to move their funds from the\n> CoinPool to any address the participant wants without cooperation with\n> other CoinPool members.\" is desirable in O(1) space.\n\nWith current design (Pool_tx+Split_tx) it's O(2) space. Pool_tx is similar\nto a commitment tx and thus enables off-chain novation of pool distribution.\n\n> Let's be favorable to Accumulators and assume O(1), but keep in mind\nconstant may\n> be somewhat large/operations might be expensive in validation for updates.\n\nUsing a Merkle Tree as an accumulator should be constant-size in space, but\nlikely it has to be O(log(N) in computation (N set elements). This overhead\nin computation should be accounted for in accumulator sigops to avoid\nnetwork validation resources free-riding, but I think it's a better\ntrade-off minimizing chain footprint.\n\n> So in this context, CTV Pool has a clear benefit. The last recipient can\n> always clear in Log(N) time whereas in the accumulator pool, the last\n> recipient has to wait much much longer. There's no asymptotic difference\nin\n> Tx Size, but I suspect that CTV is at least as good or cheaper since it's\n> just one tx hash and doesn't depend on implementation.\n\nYes I agree CTV pool performs better in the worst-case scenario. In my\nopinon what we should really look on is the probability of withdrawal\nscenarios. I see 2 failure cases:\n* a pool participant being offline, thus halting the pool\n* a pool participant with external protocol requirement to fulfill, like a\nHTLC to timeout onchain\n\nWith regards to 1) we assume that watchtower infra are likely to become\nubiquitous in the future (if you want a secure LN experience), so user\nuptime should be near to 100%. Of course,  it's a new architecture which\ncomes with trade-offs, but interesting to explore.\n\nWith regards to 2) as of today channel-failure-rate (like unilateral close)\nit's still quite important (30% IIRC) so it plays in favor of OP_CTV pool\nbut in the future I expect single-digit\ntherefore making CoinPool far more competitive. Do we envision protocol\nmore time-sensitive than LN in the future (atomic swaps...) ? Hard to gauge.\n\nDo you see other ways to refine model, like integrating out-of-pool\nliquidity needs rate ?\n\nNote, I think for OP_CTV tree, increasing radix increases cooperation\nrequirement and failure, so there should be optimum somewhere.\n\n> If your group is not cooperating because one\n> person is permanently offline, then Accumulator pools *guarantee* you need\n> to go through a full on-chain redemption.\n\nThat's right, that's a current shortcoming of this strawman design, I think\nyou can avoided by adding some timelocks, \"if Alice doesn't anwser after X\ndays, initiate a kick-out\", thus avoiding full onchain unrolling.\n\n> But I'm unclear how\n> to make this safe w.r.t. updated states. You could also allow, perhaps,\nany\n> number of operators to simultaneously leave in a tx. Also not sure how to\n> do that.\n\nI'm still thinking on this too, especially in LN-context, ideally you do\nwant the same thing to kick-out a HTLC of your HTLC-tree while preserving\nthe rest of them. Technically it works, if you assume CSV delay on the\ncommitment/pool_tx and locktime on the HTLC, which is Eltoo tradeoff.\n\n> With Accumulator pools, you need all parties online to make payments.\n\nI think that our shortcoming here, but technically with protocol rebinding\non any withdrawal output of Split_tx, you can have M-of-N channels between\npool participants. Also we should aim to support any kind of protocol at\nthe leaves.\n\n> Because Accumulator pools always require N signers, it's possible to build\n> a better privacy model where N parties are essentially managing a chaumian\n> ecash like server for updates, giving good privacy of who initiated\n> payments.\n\nYes that what I've in mind is something with blind signatures or any\nobfuscation of pool tree construction as privacy optimization. Still you\nwill leak value weight of leaves to an in-pool observer.\n\n> Both protocols require new features in Bitcoin. CTV is relatively simple,\nI\n> would posit that accumulators + sighashnoinput are relatively not simple.\n\nI agree design, review, deployment costs are an order of magnitude higher.\nThat said they are more powerful primitives which would cover use cases\nbeyond pools. A concern with OP_CTV is if we want semantic extensions we\nmay realize they don't rank that well compared to more generic \"base\"\nprimitives.\n\n> In both designs, the payment pool can be created non-interactively. This\nis\n> *super* important as it means third parties (e.g., an exchange) can\n> withdraw users funds *into* a payment pool.\n\nSee my point above, I think we need a better definition of\nnon-interactivity.\n\nThanks for the high-quality review of CoinPool !\n\nAntoine\n\nLe jeu. 11 juin 2020 \u00e0 13:21, Jeremy <jlrubin at mit.edu> a \u00e9crit :\n\n> Stellar work Antoine and Gleb! Really excited to see designs come out on\n> payment pools.\n>\n> I've also been designing some payment pools (I have some not ready code I\n> can share with you guys off list), and I wanted to share what I learned\n> here in case it's useful.\n>\n> In my design of payment pools, I don't think the following requirement: \"A\n> CoinPool must satisfy the following *non-interactive any-order withdrawal*\n> property: at any point in time and any possible sequence of previous\n> CoinPool events, a participant should be able to move their funds from the\n> CoinPool to any address the participant wants without cooperation with\n> other CoinPool members.\" is desirable in O(1) space. I think it's much\n> better to set the requirement to O(log(n)), and this isn't just because of\n> wanting to use CTV, although it does help.\n>\n> Let me describe a quick CTV based payment pool:\n>\n> Build a payment pool for N users as N/2 channels between participants\n> created in a payment tree with a radix of R, where every node has a\n> multisig path for being used as a multi-party channel and the CTV branch\n> has a preset timeout. E.g., with radix 2:\n>\n>                                       Channel(a,b,c,d,e,f,g,h)\n>                                      /                                   \\\n>                Channel(a,b,c,d)\n> Channel(e,f,g,h)\n>                     /\n> \\                                                    /                 \\\n> Channel(a,b)    Channel(c,d)                          Channel(e,f)\n> Channel(g,h)\n>\n>\n> All of these channels can be constructed and set up non-interatively using\n> CTV, and updated interactively. By default payments can happen with minimal\n> coordination of parties by standard lightning channel updates at the leaf\n> nodes, and channels can be rebalanced at higher layers with more\n> participation.\n>\n>\n> Now let's compare the first-person exit non cooperative scenario across\n> pools:\n>\n> CTV-Pool:\n> Wait time: Log(N). At each branch, you must wait for a timeout, and you\n> have to go through log N to make sure there are no updated states. You can\n> trade off wait time/fees by picking different radixes.\n> TXN Size: Log(N) 1000 people with radix 4 --> 5 wait periods. 5*4 txn\n> size. Radix 20 --> 2 wait periods. 2*20 txn size.\n>\n> Accumulator-Pool:\n> Wait Time: O(1)\n> TXN Size: Depending on accumulator: O(1), O(log N), O(N) bits. Let's be\n> favorable to Accumulators and assumer O(1), but keep in mind constant may\n> be somewhat large/operations might be expensive in validation for updates.\n>\n>\n> This *seems* like a clear win for Accumulators. But not so fast. Let's\n> look at the case where *everyone* exits non cooperatively from a payment\n> pool. What is the total work and time?\n>\n> CTV Pool:\n> Wait time: Log(N)\n> Txn Size: O(N) (no worse than 2x factor overhead with radix 2, higher\n> radixes dramatically less overhead)\n>\n> Accumulator Pool:\n> Wait time: O(N)\n> Txn Size: O(N) (bear in mind *maybe* O(N^2) or O(N log N) if we use an\n> sub-optimal accumulator, or validation work may be expensive depending on\n> the new primitive)\n>\n>\n> So in this context, CTV Pool has a clear benefit. The last recipient can\n> always clear in Log(N) time whereas in the accumulator pool, the last\n> recipient has to wait much much longer. There's no asymptotic difference in\n> Tx Size, but I suspect that CTV is at least as good or cheaper since it's\n> just one tx hash and doesn't depend on implementation.\n>\n> Another property that is nice about the CTV pool style is the bisecting\n> property. Every time you have to do an uncooperative withdrawal, you split\n> the group into R groups. If your group is not cooperating because one\n> person is permanently offline, then Accumulator pools *guarantee* you need\n> to go through a full on-chain redemption. Not so with a CTV-style pool, as\n> if you have a single failure among [1,2,3,4,5,6,7,8,9,10] channels (let's\n> say channel 8 fails), then with a radix 4 setup your next steps are:\n> [1,2,3,4,5,6,7,8,9,10]\n> [1,2,3,4,5,6,7,X,9,10]\n> [1,2,3,4] [5,6,7,X] [9,10]\n> [1,2,3,4] 5 6 7 X [9,10]\n>\n> So you only need to do Log(N) chain work to exit the bad actor, but then\n> it amortizes! A future failure (let's say of 5) only causes 5 to have to\n> close their channel, and does not affect anyone else.\n>\n> With an accumulator based pool, if you re-pool after one failure, a second\n> failure causes another O(N) work. So then total work in that case is\n> O(N^2). You can improve the design by making the evict in any order option\n> such that you can *kick out* a member in any order, that helps solve some\n> of this nastiness (rather than them opting to leave). But I'm unclear how\n> to make this safe w.r.t. updated states. You could also allow, perhaps, any\n> number of operators to simultaneously leave in a tx. Also not sure how to\n> do that.\n>\n>\n>\n> Availability:\n> With CTV Pools, you can make a payment if just your immediate conterparty\n> is online in your channel. Opportunistically, if people above you are\n> online, you can make channel updates higher up in the tree which have\n> better timeout properties. You can also create new channels, binding\n> yourself to different parties if there is a planned exit.\n>\n> With Accumulator pools, you need all parties online to make payments.\n>\n>\n> Cooperation Case:\n> CTV Pools and Accumulator pools, in a cooperative case, both just act like\n> a N of N multisig.\n>\n> Privacy:\n> Because Accumulator pools always require N signers, it's possible to build\n> a better privacy model where N parties are essentially managing a chaumian\n> ecash like server for updates, giving good privacy of who initiated\n> payments. You *could* do this with CTV pools as well, but I expect users to\n> prefer making updates at the 2 party channel layer for low latency, and to\n> get privacy benefits out of the routability of the channels and ability to\n> connect to the broader lightning network.\n>\n>\n> Technical Complexity:\n> Both protocols require new features in Bitcoin. CTV is relatively simple,\n> I would posit that accumulators + sighashnoinput are relatively not simple.\n>\n> The actual protocol design for CTV pools is pretty simple and can be\n> compatible with LN, I already have a rudimentary implementation of the\n> required transactions (but not servers).\n>\n>\n> Interactivity:\n>\n> In both designs, the payment pool can be created non-interactively. This\n> is *super* important as it means third parties (e.g., an exchange) can\n> withdraw users funds *into* a payment pool.\n>\n>\n> Thanks for reading!\n>\n> Jeremy\n>\n>\n>\n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin>\n> <https://twitter.com/JeremyRubin>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200612/2afbf136/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-12T08:39:35",
                "message_text_only": "Good morning Antoine and Gleb,\n\nI have not studied the proposal in close detail yet, but anyway, my main takeaway roughly is:\n\n* The core of CoinPool is some kind of multiparticipant (N > 2) offchain update mechanism (Decker-Wattenhofer or Decker-Russell-Osuntokun).\n  * The output at each state of the update mechanism is some kind of splitting construction (which I have not studied in detail).\n  * At each update of the state, all participants must sign off on the new state.\n\nIt seems to me that it would be possible to use a [WabiSabi protocol](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-June/017969.html) during negotiation of a new state.\n\nNow, WabiSabi is a client-server protocol.\nAs all participants in the CoinPool are needed in order to ratify each new state anyway, they can simply elect one of their number by drawing lots, to act as server for a particular state update.\n\nThen the participants can operate as WabiSabi clients.\nEach participant registers the outputs they currently own in the current state, getting credentials that sum up to the correct value.\nThen, during the WabiSabi run, they can exchange credentials among the participants in order to perform value transfers inside the WabiSabi construction.\nThen, at output registration, they register new outputs to put in the next state of the CoinPool.\n\nIn order to hide transfers from the elected WabiSabi server, participants can maintain two coins in every state, and move coins randomly across the two coins they own at each state update, in order to hide \"real\" transfers from the elected server.\n\nThen, after output registration, the participants ratify the new state by signing off on the new state and revoking the previous state, using the update mechanism.\n\nOf course, we should note that one desired feature for CoinPool in the original proposal is that a participant can exit, and the CoinPool would still remain valid, but only for the remaining participants.\n\nThis is arguably a mild privacy leak: every other participant now knows how much that particular participant took out from the CoinPool.\nIndeed, from what I can understand, in order to properly set up the splitting transactions in the first place, at each state every participant needs to know how much each other participant actually owns in the CoinPool at that point in time.\n\nTo hide how much each participant owns in the CoinPool from other participants, we would have to make unilateral closes expose all the current outputs, without trying to identify *which* participant exited the CoinPool, and thus preventing anyone else from figuring out exactly how much each *other* participant actually owns in the CoinPool on exit.\nThat way, output addresses can be to fresh pseudonyms of the participant, removing all linkages of participant to amount they own, and each participant can maintain multiple outputs per state for their own purposes and to mildly obscure exactly how much they own in total.\n\nIf we drop that feature (of being able to exit a participant without closing the *entire* CoinPool), of course, we need to mildly disincentivize a participant closing unilaterally for trivial reasons.\nWe can do this by using `SIGHASH_ANYPREVOUT` to force whoever performs a unilateral close of the CoinPool to pay the onchain fees involved, so that it would have to be a good reason indeed to perform a unilateral close.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Antoine Riard",
                "date": "2020-06-13T00:28:27",
                "message_text_only": "Hi ZmnSCPxj,\n\n> I have not studied the proposal in close detail yet, but anyway, my main\ntakeaway roughly is:\n>\n> * The core of CoinPool is some kind of multiparticipant (N > 2) offchain\nupdate mechanism (Decker-Wattenhofer or Decker-Russell-Osuntokun).\n>   * The output at each state of the update mechanism is some kind of\nsplitting construction (which I have not studied in detail).\n>   * At each update of the state, all participants must sign off on the\nnew state.\n\nOverall, that's a really accurate description. I would add you can embed a\nfunding outpoint of any offchain protocol on the splitting construction,\nmodulo some timelocks shenanigans.\n\n> In order to hide transfers from the elected WabiSabi server, participants\ncan maintain two coins in every state, and move coins randomly across the\ntwo coins they own at each state update, in order to hide \"real\" transfers\nfrom the elected server.\n\nYes I'm quite sure you can reuse WabiSabi as a communication channel\nbetween participants, assuming you support tapscript and merkle branch\ntransports, and server build a tree. Generally, we tried to keep design as\nflexible as we can to reuse privacy tools.\n\n> Indeed, from what I can understand, in order to properly set up the\nsplitting transactions in the first place, at each state every participant\nneeds to know how much each other participant actually owns in the CoinPool\nat that point in time.\n\nYes, that's part of future research, defining better *in-pool* observer.\nSadly, right now, even if you use mask construction inside, it's quite easy\nto trace leaves by value weight. Of course, you can enforce equal-value\nleaves, as for a regular onchain CoinJoin. I think it comes with a higher\nonchain cost in case of pool breakage.\n\n> That way, output addresses can be to fresh pseudonyms of the participant,\nremoving all linkages of participant to amount they own, and each\nparticipant can maintain multiple outputs per state for their own purposes\nand to mildly obscure exactly how much they own in total.\n\nThat's right that an in-pool observer may learn a link between an exit and\nan onchain withdraw. There is a future optimization, if you can swap your\nwithdraw with an already onchain output, therefore breaking heuristics.\n\n> We can do this by using `SIGHASH_ANYPREVOUT` to force whoever performs a\nunilateral close of the CoinPool to pay the onchain fees involved, so that\nit would have to be a good reason indeed to perform a unilateral close.\n\nAbsolutely, for the fee structure, as the withdraw output is at the\ndiscretion of user, I was thinking some CPFP. There is maybe a better\nsolution, haven't spend that much on the exact adequate, incentives-align\nmechanism beyond a \"withdraw-must-pay-its-fees\".\n\nThanks for the high-quality review, as usual ;)\n\nAntoine\n\nLe ven. 12 juin 2020 \u00e0 04:39, ZmnSCPxj <ZmnSCPxj at protonmail.com> a \u00e9crit :\n\n> Good morning Antoine and Gleb,\n>\n> I have not studied the proposal in close detail yet, but anyway, my main\n> takeaway roughly is:\n>\n> * The core of CoinPool is some kind of multiparticipant (N > 2) offchain\n> update mechanism (Decker-Wattenhofer or Decker-Russell-Osuntokun).\n>   * The output at each state of the update mechanism is some kind of\n> splitting construction (which I have not studied in detail).\n>   * At each update of the state, all participants must sign off on the new\n> state.\n>\n> It seems to me that it would be possible to use a [WabiSabi protocol](\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-June/017969.html)\n> during negotiation of a new state.\n>\n> Now, WabiSabi is a client-server protocol.\n> As all participants in the CoinPool are needed in order to ratify each new\n> state anyway, they can simply elect one of their number by drawing lots, to\n> act as server for a particular state update.\n>\n> Then the participants can operate as WabiSabi clients.\n> Each participant registers the outputs they currently own in the current\n> state, getting credentials that sum up to the correct value.\n> Then, during the WabiSabi run, they can exchange credentials among the\n> participants in order to perform value transfers inside the WabiSabi\n> construction.\n> Then, at output registration, they register new outputs to put in the next\n> state of the CoinPool.\n>\n> In order to hide transfers from the elected WabiSabi server, participants\n> can maintain two coins in every state, and move coins randomly across the\n> two coins they own at each state update, in order to hide \"real\" transfers\n> from the elected server.\n>\n> Then, after output registration, the participants ratify the new state by\n> signing off on the new state and revoking the previous state, using the\n> update mechanism.\n>\n> Of course, we should note that one desired feature for CoinPool in the\n> original proposal is that a participant can exit, and the CoinPool would\n> still remain valid, but only for the remaining participants.\n>\n> This is arguably a mild privacy leak: every other participant now knows\n> how much that particular participant took out from the CoinPool.\n> Indeed, from what I can understand, in order to properly set up the\n> splitting transactions in the first place, at each state every participant\n> needs to know how much each other participant actually owns in the CoinPool\n> at that point in time.\n>\n> To hide how much each participant owns in the CoinPool from other\n> participants, we would have to make unilateral closes expose all the\n> current outputs, without trying to identify *which* participant exited the\n> CoinPool, and thus preventing anyone else from figuring out exactly how\n> much each *other* participant actually owns in the CoinPool on exit.\n> That way, output addresses can be to fresh pseudonyms of the participant,\n> removing all linkages of participant to amount they own, and each\n> participant can maintain multiple outputs per state for their own purposes\n> and to mildly obscure exactly how much they own in total.\n>\n> If we drop that feature (of being able to exit a participant without\n> closing the *entire* CoinPool), of course, we need to mildly disincentivize\n> a participant closing unilaterally for trivial reasons.\n> We can do this by using `SIGHASH_ANYPREVOUT` to force whoever performs a\n> unilateral close of the CoinPool to pay the onchain fees involved, so that\n> it would have to be a good reason indeed to perform a unilateral close.\n>\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200612/1cdc8d6b/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-13T00:45:12",
                "message_text_only": "Good morning Antoine,\n\n\n> Yes, that's part of future research, defining better *in-pool* observer. Sadly, right now, even if you use mask construction inside, it's quite easy to trace leaves by value weight. Of course, you can enforce equal-value leaves, as for a regular onchain CoinJoin. I think it comes with a higher onchain cost in case of pool breakage.\n\n\nPerhaps not necessarily.\n\nAn advantage of WabiSabi is I can pretend to be two or more participants.\n\nFor example, I can pretend to be \"Alice\" and \"Bob\", and pretend that \"Alice\" owes a life debt to \"Bob\".\n\nAt initial state setup, I put a 1.0 BTC coin as \"Alice\" and a 0.5 BTC coin as \"Bob\".\n\nNow, at each state update I need to sign as \"Alice\" and \"Bob\".\nHowever, after the first initial state, I can use a new persona \"Bobby\" to *own* my coins, even though I still have to sign as \"Alice\" and \"Bob\" in every state update.\n\nWhat the other pool participants see is that the 1.0 BTC \"Alice\" coin and the 0.5 BTC \"Bob\" coin are merged into the 1.5 BTC \"Bobby\" coin.\nWhat they cannot be sure of is:\n\n* \"Alice\" paid to \"Bob\", who is now pretending to be \"Bobby\".\n* \"Bob\" paid to \"Alice\", who is now pretending to be \"Bobby\".\n* \"Alice\" and \"Bob\" are the same person, and is also pretending to be \"Bobby\".\n\nAll the other participants know is that whoever owns the coin *now* is still part of the pool, but cannot be sure which participant *really* owns which coin, and whether participants are sockpuppets (which is why it should use n-of-n at each state update, incidentally).\n\nIn effect, it \"imports\" the possibility of PayJoin inside the CoinPool construction.\n\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-13T01:20:16",
                "message_text_only": "Good morning Antoine,\n\nBy dropping the requirement that a participant can seamlessly leave the CoinPool, it allows participants to split up their coins among new aliases and to use a different identity for later claiming coins.\nWith WabiSabi, none of the other participants can get a mapping between current-state aliases and the actual participants.\n\nNow, in order to authorize moving coins from an output on the current state to a new output on the next state, obviously the pool needs to get a signature from its current owner.\nIdeally, we would not want to have to implement SCRIPT inside the CoinPool software.\n\nAnd with Taproot, a pubkey can hide one or more SCRIPTs.\nIf we use pubkeys as the identities of owners of coins, then it allows an alias to encode a SCRIPT.\n\nWith the combination of both features, we can instantiate HTLCs (or, with `SIGHASH_ANYPREVOUT`, PTLCs) inside a CoinPool \"alias\" pubkey identity, allowing for interoperation with LN.\n\nNow suppose I have 1.0 BTC in a CoinPool.\nI want to make an HTLC with you (hashlocked to you, timelocked to me), for 0.5 BTC.\n\nI encode the HTLC SCRIPT, and put it into a Taproot whose internal pubkey is a MuSig of fresh identities of mine and yours.\n\nThen, inside the CoinPool, I split my 1.0BTC to a 0.5BTC coin to a fresh identity of mine, and 0.5BTC to our HTLC Taproot.\n\nIf you can acquire the hash, you give it to me, and I am supposed to hand you a partial signature share to the HTLC Taproot that you can later complete and present to the CoinPool in the next update round in order to get the HTLC value.\nIf I do not hand you the signature share even after you hand the hash, you just drop the entire CoinPool onchain, instantiating the HTLC Taproot output onchain, and using the SCRIPT branch to claim using the hash you know.\n\nIf the timelock expires, I ask you to hand over your partial signature to the HTLC Taproot that I can later complete and present to the CoinPool in the next update round to recover the HTLC value.\nIf you do not hand over the signature share, I drop the CoinPool onchain, which instantiates the HTLC Taproot output onchain, and use the SCRIPT branch to claim using the timelock branch.\n\nYou can also ask to abort the HTLC \"early\", before the timelock expires, by handing over your partial signature to the HTLC Taproot, which I can later complete and present to the CoinPool in the next update round.\nThis is equivalent to `update_fail_htlc` in the current LN BOLT spec.\n\nThis allows operation of any SCRIPT, incidentally, without requiring that CoinPool software include a SCRIPT interpreter, only signature validation.\nAny time an output absolutely needs a SCRIPT, we just drop the CoinPool onchain and let onchain handle the SCRIPT interpretation.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-16T05:23:01",
                "message_text_only": "Good morning Antoine, Gleb, and list,\n\nIn some ways, CoinPool is really part of a swarm of ideas:\n\n* CoinPool\n* Multiparticipant (N > 2) channels\n* Channel factories\n* Nodelets\n\nWhat CoinPool and multiparticipant channels buy us is better flexibility with forwarding.\nFor example, if we compare a multiparty channel to a channel factory, suppose there exists three entities A, B, and C in the multiparty construction.\n\nIn a channel factory, each entity has to decide how much of its liquidity to tie up in a channel with a specific other peer in the multiparty construction.\nThis limits the practical payment forwarding when integrated into the Lightning Network.\n\nIn a CoinPool, any of the entities can forward to any of the other entities, without tying their liquidity to a channel specifically with those entities.\n\nHowever, in a CoinPool, once any of the entities goes offline, the entire CoinPool can no longer update.\nThis is in contrast with channel factories, where, if entity C goes offline, the channel between A and B remains useable for forwarding.\nIn other words, channel factories degrade gracefully.\n\nFurther, we already have a decent solution for liquidity redistribution: JIT Routing by Rene Pickhardt.\nThus the liquidity issue with channel factories are somewhat mitigated (and if all participants are online, they also have the option of redistributing channel funds *inside* the factory as well, not just JIT routing), while gaining graceful degradation of the factory.\n\n\nAnother is that pathfinding algorithms work best if graph edges are edges and not in fact some kind of twisted multi-edge that connects more than two nodes together.\n\nOn the other hand, the participants of a CoinPool could create a \"virtual node\" that is a MuSig of their individual keys, and report that as the \"real\" node on LN gossip (each of them pretending to have a large channel with that virtual node), so that the rest of the network only sees edges that link two nodes (and existing pathfinding algos still work seamlessly, never realizing that this node is actually a virtual node that represents a CoinPool).\nThis is basically them creating a sort of Nodelet node, which other nodes cannot make channels to, and which uses channels with the Nodelet node as proxies for the CoinPool as a whole.\n\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "CoinPool, exploring generic payment pools for Fun and Privacy",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Jeremy",
                "Antoine Riard"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 58549
        }
    },
    {
        "title": "[bitcoin-dev] Hiding CoinSwap Makers Among Custodial Services",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-11T11:51:03",
                "message_text_only": "Good morning Chris, and bitcoin-dev (but mostly Chris),\n\n\nI made a random comment regarding taint on bitcoin-dev recently: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-June/017961.html\n\n> For CoinSwap as well, we can consider that a CoinSwap server could make multiple CoinSwaps with various clients.\n> This leads to the CoinSwap server owning many small UTXOs, which it at some point aggregates into a large UTXO that it then uses to service more clients (for example, it serves many small clients, then has to serve a single large client that wants a single large UTXO for its own purposes).\n> This aggregation again leads to spreading of taint.\n\nI want to propose some particular behaviors a SwapMarket maker can engage in, to improve the privacy of its customers.\n\nLet us suppose that individual swaps use some variant of Succinct Atomic Swap.\nTakers take on the role of Alice in the SAS description, makers take on the role of Bob.\nWe may be able to tweak the SAS protocol or some of its parameters for our purposes.\n\nNow, what we will do is to have the maker operate in rounds.\n\nSuppose two takers, T1 and T2, contact the sole maker M in its first ever round.\nT1 and T2 have some coins they want to swap.\nThey arrange things all the way to confirmation of the Alice-side funding tx, and pause just before Bob creates its own funding tx for their individual swaps.\nThe chain now shows these txes/UTXOs:\n\n     42 of T1 --->  42 of T1 & M\n     50 of T2 --->  50 of T2 & M\n    100 of T1 ---> 100 of T1 & M\n\n    200 of M  -\n\nNow the entire point of operating in rounds is precisely so that M can service multiple clients at the same time with a single transaction, i.e. batching.\nSo now M provides its B-side tx and complete the SAS protocols with each of the takers.\nSAS gives unilateral control of the outputs directly to the takers, so we elide the fact that they are really 2-of-2s below:\n\n     42 of T1 --->  42 of T1 & M\n     50 of T2 --->  50 of T2 & M\n    100 of T1 ---> 100 of T1 & M\n\n    200 of M  +-->  11 of M\n              +--> 140 of T1\n              +-->  49 of T2\n\n(M extracted 1 unit from each incoming coin as fee; they also live in a fictional universe where miners mine transactions out of the goodness of their hearts.)\nNow in fact the previous transactions are, after the SAS, solely owned by M the maker.\nNow suppose on the next round, we have 3 new takers, T3, T4, and T5, who offer some coins to M to CoinSwap, leading to more blockchain data:\n\n     42 of T1 --->  42 of T1 & M\n     50 of T2 --->  50 of T2 & M\n    100 of T1 ---> 100 of T1 & M\n\n    200 of M  -+->  11 of M\n               +-> 140 of T1\n               +->  49 of T2\n\n     22 of T3 --->  22 of T3 & M\n     90 of T3 --->  90 of T3 & M\n     11 of T4 --->  11 of T4 & M\n     50 of T4 --->  50 of T4 & M\n     20 of T5 --->  20 of T5 & M\n\nIn order to service all the new takers of this round, M takes the coins that it got from T1 and T2, and uses them to fund a new combined CoinSwap tx:\n\n     42 of T1 --->  42 of T1 & M -+--+-> 110 of T3\n     50 of T2 --->  50 of T2 & M -+  +->  59 of T4\n    100 of T1 ---> 100 of T1 & M -+  +->  14 of T5\n                                     +->   9 of M\n    200 of M  -+->  11 of M\n               +-> 140 of T1\n               +->  49 of T2\n\n     22 of T3 --->  22 of T3 & M\n     90 of T3 --->  90 of T3 & M\n     11 of T4 --->  11 of T4 & M\n     50 of T4 --->  50 of T4 & M\n     15 of T5 --->  15 of T5 & M\n\nThat transaction, we can observe, looks very much like a batched transaction that a custodial service might produce.\n\nNow imagine more rounds, and I think you can begin to imagine that the magic of transaction batching, ported into SwapMarket, would help mitigate the blockchain size issues that CoinSwap has.\n\nMakers are expected to adopt this technique as this reduces the overall cost of transactions they produce, thus they are incentivized to use this technique to increase their profitability.\n\nAt the same time, it spreads taint around and increases the effort that chain analysis must go through to identify what really happened.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Chris Belcher",
                "date": "2020-06-13T13:38:35",
                "message_text_only": "Hello ZmnSCPxj,\n\nOn 11/06/2020 12:51, ZmnSCPxj wrote:\n> Good morning Chris, and bitcoin-dev (but mostly Chris),\n> \n> \n> I made a random comment regarding taint on bitcoin-dev recently: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-June/017961.html\n> \n>> For CoinSwap as well, we can consider that a CoinSwap server could make multiple CoinSwaps with various clients.\n>> This leads to the CoinSwap server owning many small UTXOs, which it at some point aggregates into a large UTXO that it then uses to service more clients (for example, it serves many small clients, then has to serve a single large client that wants a single large UTXO for its own purposes).\n>> This aggregation again leads to spreading of taint.\n> \n> I want to propose some particular behaviors a SwapMarket maker can engage in, to improve the privacy of its customers.\n> \n> Let us suppose that individual swaps use some variant of Succinct Atomic Swap.\n> Takers take on the role of Alice in the SAS description, makers take on the role of Bob.\n> We may be able to tweak the SAS protocol or some of its parameters for our purposes.\n> \n> Now, what we will do is to have the maker operate in rounds.\n> \n> Suppose two takers, T1 and T2, contact the sole maker M in its first ever round.\n> T1 and T2 have some coins they want to swap.\n> They arrange things all the way to confirmation of the Alice-side funding tx, and pause just before Bob creates its own funding tx for their individual swaps.\n> The chain now shows these txes/UTXOs:\n> \n>      42 of T1 --->  42 of T1 & M\n>      50 of T2 --->  50 of T2 & M\n>     100 of T1 ---> 100 of T1 & M\n> \n>     200 of M  -\n> \n> Now the entire point of operating in rounds is precisely so that M can service multiple clients at the same time with a single transaction, i.e. batching.\n> So now M provides its B-side tx and complete the SAS protocols with each of the takers.\n> SAS gives unilateral control of the outputs directly to the takers, so we elide the fact that they are really 2-of-2s below:\n> \n>      42 of T1 --->  42 of T1 & M\n>      50 of T2 --->  50 of T2 & M\n>     100 of T1 ---> 100 of T1 & M\n> \n>     200 of M  +-->  11 of M\n>               +--> 140 of T1\n>               +-->  49 of T2\n> \n> (M extracted 1 unit from each incoming coin as fee; they also live in a fictional universe where miners mine transactions out of the goodness of their hearts.)\n> Now in fact the previous transactions are, after the SAS, solely owned by M the maker.\n> Now suppose on the next round, we have 3 new takers, T3, T4, and T5, who offer some coins to M to CoinSwap, leading to more blockchain data:\n> \n>      42 of T1 --->  42 of T1 & M\n>      50 of T2 --->  50 of T2 & M\n>     100 of T1 ---> 100 of T1 & M\n> \n>     200 of M  -+->  11 of M\n>                +-> 140 of T1\n>                +->  49 of T2\n> \n>      22 of T3 --->  22 of T3 & M\n>      90 of T3 --->  90 of T3 & M\n>      11 of T4 --->  11 of T4 & M\n>      50 of T4 --->  50 of T4 & M\n>      20 of T5 --->  20 of T5 & M\n> \n> In order to service all the new takers of this round, M takes the coins that it got from T1 and T2, and uses them to fund a new combined CoinSwap tx:\n> \n>      42 of T1 --->  42 of T1 & M -+--+-> 110 of T3\n>      50 of T2 --->  50 of T2 & M -+  +->  59 of T4\n>     100 of T1 ---> 100 of T1 & M -+  +->  14 of T5\n>                                      +->   9 of M\n>     200 of M  -+->  11 of M\n>                +-> 140 of T1\n>                +->  49 of T2\n> \n>      22 of T3 --->  22 of T3 & M\n>      90 of T3 --->  90 of T3 & M\n>      11 of T4 --->  11 of T4 & M\n>      50 of T4 --->  50 of T4 & M\n>      15 of T5 --->  15 of T5 & M\n> \n> That transaction, we can observe, looks very much like a batched transaction that a custodial service might produce.\n> \n> Now imagine more rounds, and I think you can begin to imagine that the magic of transaction batching, ported into SwapMarket, would help mitigate the blockchain size issues that CoinSwap has.\n> \n> Makers are expected to adopt this technique as this reduces the overall cost of transactions they produce, thus they are incentivized to use this technique to increase their profitability.\n> \n> At the same time, it spreads taint around and increases the effort that chain analysis must go through to identify what really happened.\n> \n> Regards,\n> ZmnSCPxj\n> \n\nWould it be fair to summarize the idea in this way:\n\nCoinSwappers can slow down the CoinSwap process which will give an\nopportunity for makers to use batching."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-13T14:06:05",
                "message_text_only": "Good morning Chris,\n\n>\n> Would it be fair to summarize the idea in this way:\n>\n> CoinSwappers can slow down the CoinSwap process which will give an\n> opportunity for makers to use batching.\n\nI think so.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Chris Belcher",
                "date": "2020-06-13T23:25:00",
                "message_text_only": "On 13/06/2020 15:06, ZmnSCPxj wrote:\n> Good morning Chris,\n> \n>>\n>> Would it be fair to summarize the idea in this way:\n>>\n>> CoinSwappers can slow down the CoinSwap process which will give an\n>> opportunity for makers to use batching.\n> \n> I think so.\n> \n> Regards,\n> ZmnSCPxj\n> \n\nIt's definitely a good idea. As well as improving privacy by pretending\nto be a service provider which uses batching, it may also be practical\njust because CoinSwap takers will want to slow down the process for\ngreater privacy so that an adversary would have to search more of the\nblockchain to attempt to deanonymize them. Also, by being prepared to\nwait longer the takers will also save miner fees."
            }
        ],
        "thread_summary": {
            "title": "Hiding CoinSwap Makers Among Custodial Services",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Chris Belcher"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 9492
        }
    },
    {
        "title": "[bitcoin-dev] WabiSabi: a building block for coordinated CoinJoins",
        "thread_messages": [
            {
                "author": "Yuval Kogman",
                "date": "2020-06-11T20:40:07",
                "message_text_only": "Hi,\n\nAs part of research into how CoinJoins in general and Wasabi in\nparticular can be improved, we'd like to share a new building block\nwe're calling WabiSabi, which utilizes keyed verification anonymous\ncredentials instead of blind signatures to verify the honest\nparticipation of users in centrally coordinated CoinJoin protocols.\n\nBlind signatures have been used to facilitate centrally coordinated\nCoinJoins, but require standard denominations, each associated with a\nkey, because blind signatures can only convey a single bit of\ninformation from the signer to the verifier (both roles are the\ncoordinator in this setting). Anonymous credentials carry attributes,\nand in our case these are homomorphic value commitments as in\nConfidential Transactions.\n\nNote that this is an early draft with a deliberately narrow scope, and\nonly introduces this abstract building block. At this stage we'd like\nto solicit feedback and criticism about our scheme and inputs with\nregards to its potential applications before proceeding. We do not not\n(yet) address the structure of the CoinJoin transactions, fee\nstructures, or other implementation details, but discussion of these\naspects is welcome.\n\nThe repository is https://github.com/zkSNACKs/WabiSabi, and the latest\nversion is available here:\nhttps://github.com/zkSNACKs/WabiSabi/releases/latest/download/WabiSabi.pdf"
            }
        ],
        "thread_summary": {
            "title": "WabiSabi: a building block for coordinated CoinJoins",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Yuval Kogman"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1362
        }
    },
    {
        "title": "[bitcoin-dev] WabiSabi Inside Batched CoinSwap",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-12T05:43:29",
                "message_text_only": "Introduction\n============\n\nTHIS ENTIRE PROTOCOL IS NOVEL CRYPTO AND HAS NO PROOF THAT IT IS SECURE AND PRIVATE AND WHY WOULD YOU TRUST SOME RANDOM PSEUDONYM ON THE INTERNET SRSLY.\n\nWhile [WabiSabi](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-June/017969.html) is planned for some kind of CoinJoin operation, a limitation is that the use of CoinJoin creates a transaction where the inputs are known to be linked to the outputs, as the generated transaction directly consumes the inputs.\n\nIt would be better if the server in the WabiSabi created outputs from independent outputs it owns, acquired from previous clients.\nThen the outputs would, onchain, be linked to previous clients of the server instead of the current clients.\nThis is precisely the issue that CoinSwap, and the new swap scheme [Succinct Atomic Swaps](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-May/017846.html), can be used to solve.\nBy using [Batched CoinSwap](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-June/017967.html), makers can act as WabiSabi servers, and batched takers can act as WabiSabi clients.\n\nOf course, WabiSabi has the advantage that payments between the clients are obscured from the server.\nBut a naive CoinSwap requires that outputs from the maker be linkable, at least by the maker, to inputs given to the maker, which is precisely the information that WabiSabi seeks to hide from the server.\n\nHowever, by instead using [Signature Selling](https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-July/002077.html) in combination with standard Scriptless Script adaptor signatures, it is possible to arrange for a CoinSwap to occur without the make being able to link outputs to inputs.\n\nSignature Selling\n=================\n\nThe final output of the Schnorr signing process is a pair (R, s) for a pubkey A = a * G and ephemeral nonce R = r * G, where:\n\n    s = r + h(P | R | m) * a\n\nNow, instead of the pair (R, s), the signer can provide (R, s * G).\nThe receiver of (R, s * G) can validate that s * G is correct using the same validation as for Schnorr signatures.\n\n    s * G = R + h(P | R | m) * A\n\nThe receiver of (R, s * G) can then offer a standard Scriptless Script adaptor signature, which when completed, lets them learn s.\nThe receiver may incentivize this by having the completed signature authorize a transaction to the sender of the original (R, s * G), so that the completed signature atomically gives the receiver the correct signature.\n\nThis can be used as a basis for atomic CoinSwap, and which we will use in this proposal.\n\nNote that even in a MuSig case, it is possible for a participant to sell its share of the final signature, after the R exchange phase in MuSig.\n\nWabiSabi\n========\n\nWabiSabi replaces blind signatures with credentials.\nThe primary advantage of credentials is that credentials can include a homomorphic value.\nWe use this homomorphic value to represent a blinded amount.\n\nWabiSabi has a single server that issues credentials, and multiple clients that the server serves.\nClients can exchange value by swapping credentials, then claiming credentials they received from the server and exchanging them for fresh credentials.\nClients hold multiple credentials at a time, and the server consumes (and destroys) a set of credentials and outputs another set of fresh credentials, ensuring that the output value is the same as the input value (minus any fees the server wants to charge for the operation).\n\n>From a high enough vantage point, the WabiSabi process is:\n\n1.  Server issues 0-valued credentials to all clients.\n2.  Clients put in money into the server by providing onchain inputs to the server plus their existing credentials, getting credentials with their input credential value plus the onchain input value.\n3.  Clients swap credentials with each other to perform payments between themselves, then claim the credentials by asking the server to reissue them.\n    * Receiving clients move their amounts among all the credentials they own (via server consume-reissue credential operations) so as to make one of their multiple credentials into a 0-value credential.\n    * Sending clients move their amounts among all the credentials they own so that one of their multiple credentials has the sent value.\n    * The receiving client exchanges its 0-value credential for the sent-value credential from the sending client, by cooperatively making a consume-reissue operation with the server.\n4.  Clients then claim the value in their credentials by providing pubkeys to pay to, and amount, to the server, plus existing credentials, getting back credentials whose total value is minus the onchain output value.\n5.  The server generates the final output set.\n6.  The clients check that the final output set is indeed what they expected (their claimed outputs exist) and ratify the overall transaction.\n    * In the CoinJoin case, the overall transaction is ratified by generating a single transaction that consumes the inputs and generates the output set, then the clients provide signatures to this transaction as ratification.\n\nWabiSabi Inside Batched CoinSwap\n================================\n\nA Batched CoinSwap simply means having multiple takers be serviced in a single transaction by a single maker.\n\nSuppose Alice, Bob, and Carol are takers, and Macky is the maker.\n\nNow suppose that Alice is secretly the princess of a magical kingdom and that Bob saved her life and her entire kingdom, involving a lot of gunfire, explosions, evil wizards, pre-asskicking one-liners, and a bomb that is defused by Bob with just 1 second left on its timer.\nAlice now owes a life debt to Bob and agrees to give all her bitcoins to Bob.\nHowever, because the existence of magic is a secret, they do not want Carol, Macky, or the entire Bitcoin world to know about this Alice-to-Bob transaction.\n\nMacky operates as a WabiSabi server, and Alice, Bob, and Carol operate as WabiSabi clients.\nRather than generate a single CoinJoin transaction, they generate a CoinSwap operation.\n\nFirst, they all agree on future blockheights L1 and L2, where L1 < L2.\n\nThen Alice, Bob, and Carol get the starting 0-value WabiSabi credentials from Macky.\nThey then register inputs in the WabiSabi protocol, and also additionally perform this sub-ritual in order to \"lock in\" the input registration:\n\n* Alice (resp. Bob or Carol) creates (but does *not* sign) a funding transaction from Alice coins to MuSig(Alice, Macky).\n* Alice and Macky create a backout transaction, with `nLockTime` at L2, and complete the plain MuSig signing ritual.\n* Alice broadcasts the original funding transaction.\n\nMacky need not wait for the funding tx to confirm; at a later stage, if it is not confirmed, Macky can cancel the entire ritual and all value transfers within it.\n\nThen, before transitioning to the WabiSabi output registration stage, Macky performs the following ritual with Alice, Bob, and Carol.\n\n* Macky creates (but does *not* sign) a funding transaction from Macky to MuSig(Alice, Bob, Carol, Macky).\n  * The value must be greater than or equal to the total input values; but note that Alice, Bob, and Carol need not check this, as it is automatically implied by the later output ratification phase.\n* Alice, Bob, Carol, and Macky create a backout transaction, with `nLockTime` at L1 (L1 < L2), and complete the composable MuSig signing ritual.\n* Macky broadcasts the original funding transaction.\n\nAgain nobody needs to wait for the Macky funding transaction to come onchain at this point.\n\nAlice can then send Bob all her money by use of WabiSabi inter-client value transfers.\nBob should not consider this value transfer as \"real\" until the entire WabiSabi-in-Batched-CoinSwap ritual is complete, by the way: so for example if Bob is required to marry princess Alice contingent on getting all of the coins of Alice, Bob should avoid the altar until the entire WabiSabi-in-Batched-CoinSwap ritual completes.\n\nThen, output registration can begin.\nIn output registration, Bob and Carol take on new identities, as Bobby and Carolina, respectively.\nAlice, having no funds inside the WabiSabi to reclaim, has no need of the new identity.\n\"Bobby\" claims an output, to be sent to \"Bobby\", as does \"Carolina\".\n\nAt this point, Macky checks the Alice, Bob, and Carol funding transactions were confirmed deeply.\nIf not, Macky aborts the CoinSwap and waits until it can reclaim its funds.\n\nThen, Macky enters the output ratification phase.\nMacky publishes all the outputs registered, which should include the outputs to \"Bobby\", \"Carolina\", and a change output to Macky.\nThis is done by presenting a transaction spending the Macky funding transaction output with MuSig(Alice, Bob, Carol, Macky) and outputting to \"Bobby\", \"Carolina\", and Macky change.\n\nAt this point, Alice, Bob, and Carol check that the Macky funding transaction was confirmed deeply.\nIf not, Alice, Bob, and Carol aborts the CoinSwap and waits until they can reclaim the funds.\n\nThen, Alice, having no outputs, approves the payout transaction.\nBob checks that the \"Bobby\" output exists and is the correct value.\nCarol checks the \"Carolina\" output exists and is the correct value.\nThey also check that the payout transaction would actually be valid (outputs + fees = input, current `nLockTime`, etc.).\n\nIf one of the takers thinks the server misbehaved, they can just refuse to ratify the output.\n\nAlice, Bob, and Carol can now cooperatively ratify the outputs produced by Macky.\nThis is done in a long ritual.\n\n* First, Alice, Bob, Carol, and Macky complete the MuSig signing for the payout transaction all the way to R exchange.\n* Then Alice, Bob, and Carol compute and broadcast their MuSig signature shares s[A], s[B], and s[C] to each other and to Macky.\n* Macky then computes its share s[M], but rather than broadcast it to the takers, broadcasts s[M] * G.\n\nAt this point, the participants now turn their attention to the inputs to the mix.\n\n* Now, Alice (resp. Bob or Carol) knows s[A], s[B], s[C], and s[M] * G for the payout transaction.\n* Alice and Macky create a claim transaction spending from Alice funding output to Macky.\n* Alice and Macky complete the MuSig signing ritual for the Macky claim transaction up to R exchange.\n* Macky gives its share of the Macky claim transaction signature to Alice.\n* Alice provides an adaptor signature for the Macky claim transaction, whose completion would let Alice learn s[M] for the payout transaction.\n\nAfter Macky gets partial adaptor signatures from Alice, Bob, and Carol, it can then broadcast s[M] to Alice, Bob, and Carol, completing the payout transaction, and also complete all the claim transaction it needs.\nIf any of Alice, Bob, or Carol do not provide the partial adaptor signatures for any of the incoming inputs, Macky never broadcasts s[M] and the CoinSwap and all WabiSabi internal value transfers revert.\n\nPrivate Key Handover\n--------------------\n\nIt would be possible to hand over private keys for the Alice, Bob, and Carol funding transaction to Macky, and use a kickoff transaction followed by a `nSequence`-timelocked transactions for backing out.\nThis reduces the onchain space needed when Macky has another new set of clients it wants to serve.\n\nComparison to WabiSabi Inside CoinJoin\n======================================\n\nThe above CoinSwap ritual requires more transactions onchain, and thus more expense.\n\nHowever, it does buy better privacy.\n\n* Carol never learns the inputs of Alice and Bob, and only knows that there are up to 2 other participants in the mix.\n  * Carol only ever signs its own funding transaction output, and the payout transaction; the payout transaction does not reveal the inputs that other participants put into the mix.\n  * For all Carol knows, the two other participants in the mix were sockpuppets of Macky, or were really just one participant using a sockpuppet.\n* Bob never learns the input of Alice.\n  * Bob knows how much Alice gave to Bob and that Alice gave her all to Bob, so in a CoinJoin could have scanned for CoinJoin inputs that sum up to how much Alice gave to Bob.\n  * With CoinSwap, Bob has to scan recent blocks, which hopefully have much larger input sets and require more effort (and hopefully more false positives).\n\nThis is because knowledge of the *other* inputs to the mix is never revealed in a batched CoinSwap, whereas they would be revealed in a CoinJoin.\nAll that participants learn is the inputs from *previous* takers that the maker served in the past."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-12T14:53:59",
                "message_text_only": "Good morning list,\n\n> -   Alice (resp. Bob or Carol) creates (but does not sign) a funding transaction from Alice coins to MuSig(Alice, Macky).\n> -   Alice and Macky create a backout transaction, with `nLockTime` at L2, and complete the plain MuSig signing ritual.\n> -   Alice broadcasts the original funding transaction.\n\nSorry, the taker funding transactions should have the nearer locktime L1, and the maker funding transctions should be the one with the later locktime L2.\nThis forces Macky to claim the incoming funds earlier, and claiming any of them unlocks the outgoing payout transaction.\n\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "WabiSabi Inside Batched CoinSwap",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 13114
        }
    },
    {
        "title": "[bitcoin-dev] Blind Statechains",
        "thread_messages": [
            {
                "author": "Tom Trevethan",
                "date": "2020-06-12T18:11:52",
                "message_text_only": "Hello,\n\nA statechain implementation and service co-signs 'backup' (off-chain)\ntransactions to transfer ownership of a UTXO from one owner to the next. A\nsuggested here\nhttps://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39\n, this service (the statechain entity or SE) can be engineered to be\n'blind' to the transactions it is signing (i.e. it does not and cannot know\nthe details of the transactions it is signing) which can give significant\nprivacy benefits. It would enable more private off-chain coin-swaps, and\nmake collusion more difficult.\n\nThe only downside of a blind SE is that it can no longer enforce the rules\ngoverning the sequence of backup transactions it co-signs as owners can ask\nthe SE to cosign any transaction. So each new owner of a UTXO must receive,\nstore and verify the full sequence of previous owner backup transactions to\nmake sure that no previous owner has asked the SE to sign a transaction\nthat could be used to steal the UTXO. This may end up making wallets more\nbloated and clunky, given that ownership of a UTXO could change hands\nthousands of times off-chain.\n\nIn the case of a multisig, and Schnorr signatures, existing blind Schnorr\nprotocols could be used to implement a blind SE, however we are opting to\nuse two-party ECDSA (because there is no Schnorr yet, and in any case ECDSA\nwill give a much bigger anonymity set). There is no current 2P ECDSA\nprotocol that enables one of the two signers to be completely blinded, but\nit seems that this would require only minor modifications to an existing 2P\nECDSA scheme (outlined here\nhttps://github.com/commerceblock/mercury/blob/master/doc/blind_2p_ecdsa.md\nbased on Lindell 2017 https://eprint.iacr.org/2017/552 ).\n\nAny comments on any of this gratefully received.\n\nTom\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200612/3dbd6277/attachment.html>"
            },
            {
                "author": "Ruben Somsen",
                "date": "2020-06-12T20:35:37",
                "message_text_only": "Hi Tom,\n\nBlind signatures are certainly a nice feature, great to see that you're\nconsidering it.\n\n>So each new owner of a UTXO must receive, store and verify the full\nsequence of previous owner backup transactions to make sure that no\nprevious owner has asked the SE to sign a transaction that could be used to\nsteal the UTXO. This may end up making wallets more bloated and clunky,\ngiven that ownership of a UTXO could change hands thousands of times\noff-chain.\n\nUsers would have to validate the history of the chain regardless, even if\nit wasn't blind, to verify whether the statechain entity hasn't been\ncheating, so the main difference would be in unblinding the data.\n\nOne of my original ideas was to use the transitory key to derive the\nsecrets that blind the signatures (basically like an HD wallet). The\nstatechain entity would then store and serve blind signatures, and any new\nowner would download and unblind/verify them using the transitory key (no\nextensive peer-to-peer transfer needed). It's possible to make the\noff-chain transactions themselves deterministic, so they can just be\ngenerated by the client without any additional data transfer. The only\npotentially unique thing in a transaction is the refund address, but this\ncan be the same key as the ownership key on the statechain, tweaked with\nthe transitory key via Diffie-Hellman (to ensure it's not linkable if it\ngoes on-chain).\n\nThe general downside of this method is that all transactions are exposed to\nanyone who learns the transitory key -- not just for the current\ntransactions (which can always be leaked no matter what you do), but also\nall future transactions in that particular statechain. However, I should\nnote there doesn't actually seem to be much to learn, because the history\nof each statechain is actually quite uninformative. The money just goes\nfrom one pseudonymous owner to the next.\n\nOf course you now have scheme that changes the transitory key with each\nstep, so I instead suggest you introduce a secondary \"blinding key\" to\nachieve what I described.\n\nI'm not sure whether this can also apply to 2P-ECDSA, but with Schnorr the\nstatechain entity wouldn't even learn the address for the funding\ntransaction, so it wouldn't be able to tell which UTXO it controls by\nwatching the blockchain. Ideally, this functionality would be preserved to\nensure the statechain entity can't be aware of the funds it's holding.\n\nAnother thing to note is that you won't know when a statechain has been\npegged out, so pruning will be impossible. You may wish to consider some\nkind of liveness rule where one statechain transaction needs to be made per\nyear. If they miss the deadline, they're just forced on-chain, which is not\nterrible, in any case.\n\nHope this helps!\n\nCheers,\nRuben\n\n\n\nOn Fri, Jun 12, 2020 at 9:23 PM Tom Trevethan via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello,\n>\n> A statechain implementation and service co-signs 'backup' (off-chain)\n> transactions to transfer ownership of a UTXO from one owner to the next. A\n> suggested here\n> https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39\n> , this service (the statechain entity or SE) can be engineered to be\n> 'blind' to the transactions it is signing (i.e. it does not and cannot know\n> the details of the transactions it is signing) which can give significant\n> privacy benefits. It would enable more private off-chain coin-swaps, and\n> make collusion more difficult.\n>\n> The only downside of a blind SE is that it can no longer enforce the rules\n> governing the sequence of backup transactions it co-signs as owners can ask\n> the SE to cosign any transaction. So each new owner of a UTXO must receive,\n> store and verify the full sequence of previous owner backup transactions to\n> make sure that no previous owner has asked the SE to sign a transaction\n> that could be used to steal the UTXO. This may end up making wallets more\n> bloated and clunky, given that ownership of a UTXO could change hands\n> thousands of times off-chain.\n>\n> In the case of a multisig, and Schnorr signatures, existing blind Schnorr\n> protocols could be used to implement a blind SE, however we are opting to\n> use two-party ECDSA (because there is no Schnorr yet, and in any case ECDSA\n> will give a much bigger anonymity set). There is no current 2P ECDSA\n> protocol that enables one of the two signers to be completely blinded, but\n> it seems that this would require only minor modifications to an existing 2P\n> ECDSA scheme (outlined here\n> https://github.com/commerceblock/mercury/blob/master/doc/blind_2p_ecdsa.md\n> based on Lindell 2017 https://eprint.iacr.org/2017/552 ).\n>\n> Any comments on any of this gratefully received.\n>\n> Tom\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200612/c04c1c19/attachment.html>"
            },
            {
                "author": "Tom Trevethan",
                "date": "2020-06-14T22:24:47",
                "message_text_only": "Hi Ruben,\n\nThanks for the comments.\n\n> Users would have to validate the history of the chain regardless, even if\nit wasn't blind, to verify whether the statechain entity hasn't been\ncheating, so the main difference would be in unblinding the data.\n\nMy understanding was that users would need to verify the uniqueness of the\nownership of the previous owner, and verify that the ownership had been\nsigned over (which acts as proof of ownership in case the SE steals) but\nthat backup transaction rules would be enforced by the SE (the SE must be\ntrusted to not collude with a previous owner to sign a 'theft' transaction\nbefore the UTXO is sold on). Even if a new owner verifying that all of the\nprevious backup transactions are correct does not prove that the SE has not\nsigned anything else we don't know about.\n\nIn the case of a blinded SE, we were thinking the way it could work is that\nthe SE would still need to be trusted to state how many times it had\nco-signed. So a new owner would ask the SE how many times it has signed\nsomething (e.g. 27) and then the new owner would need to check that there\nare exactly 27 back up transactions and verify that each one was following\nthe rules. Then when it came to transfer, they would send the 27 + their\nown backup to the new owner, who would then ask the SE again how many it\nhad signed.\n\nYes, the SE can store all of these transactions, encrypted with the current\nowners key, to make the UX easier.\n\n> I'm not sure whether this can also apply to 2P-ECDSA, but with Schnorr\nthe statechain entity wouldn't even learn the address for the funding\ntransaction, so it wouldn't be able to tell which UTXO it controls by\nwatching the blockchain. Ideally, this functionality would be preserved to\nensure the statechain entity can't be aware of the funds it's holding.\n\nYes, that is the aim. Like you mentioned, this may help a lot with legal\nstatus of the SE, but also prevent the SE from being able to link swaps\n(while still performing them atomically).\n\n> Another thing to note is that you won't know when a statechain has been\npegged out, so pruning will be impossible. You may wish to consider some\nkind of liveness rule where one statechain transaction needs to be made per\nyear. If they miss the deadline, they're just forced on-chain, which is not\nterrible, in any case.\n\nInteresting point. I guess it is not in the interest of the owner to tell\nthe SE that they have pegged-out a UTXO (as the SE might be able to\ncorrelate with on-chain txs). Maybe the user wallet can send the SE\na message that the UTXO is pegged out some random interval after it has\nhappened.\n\nCheers,\n\nTom\n\nOn Fri, Jun 12, 2020 at 9:35 PM Ruben Somsen <rsomsen at gmail.com> wrote:\n\n> Hi Tom,\n>\n> Blind signatures are certainly a nice feature, great to see that you're\n> considering it.\n>\n> >So each new owner of a UTXO must receive, store and verify the full\n> sequence of previous owner backup transactions to make sure that no\n> previous owner has asked the SE to sign a transaction that could be used to\n> steal the UTXO. This may end up making wallets more bloated and clunky,\n> given that ownership of a UTXO could change hands thousands of times\n> off-chain.\n>\n> Users would have to validate the history of the chain regardless, even if\n> it wasn't blind, to verify whether the statechain entity hasn't been\n> cheating, so the main difference would be in unblinding the data.\n>\n> One of my original ideas was to use the transitory key to derive the\n> secrets that blind the signatures (basically like an HD wallet). The\n> statechain entity would then store and serve blind signatures, and any new\n> owner would download and unblind/verify them using the transitory key (no\n> extensive peer-to-peer transfer needed). It's possible to make the\n> off-chain transactions themselves deterministic, so they can just be\n> generated by the client without any additional data transfer. The only\n> potentially unique thing in a transaction is the refund address, but this\n> can be the same key as the ownership key on the statechain, tweaked with\n> the transitory key via Diffie-Hellman (to ensure it's not linkable if it\n> goes on-chain).\n>\n> The general downside of this method is that all transactions are exposed\n> to anyone who learns the transitory key -- not just for the current\n> transactions (which can always be leaked no matter what you do), but also\n> all future transactions in that particular statechain. However, I should\n> note there doesn't actually seem to be much to learn, because the history\n> of each statechain is actually quite uninformative. The money just goes\n> from one pseudonymous owner to the next.\n>\n> Of course you now have scheme that changes the transitory key with each\n> step, so I instead suggest you introduce a secondary \"blinding key\" to\n> achieve what I described.\n>\n> I'm not sure whether this can also apply to 2P-ECDSA, but with Schnorr the\n> statechain entity wouldn't even learn the address for the funding\n> transaction, so it wouldn't be able to tell which UTXO it controls by\n> watching the blockchain. Ideally, this functionality would be preserved to\n> ensure the statechain entity can't be aware of the funds it's holding.\n>\n> Another thing to note is that you won't know when a statechain has been\n> pegged out, so pruning will be impossible. You may wish to consider some\n> kind of liveness rule where one statechain transaction needs to be made per\n> year. If they miss the deadline, they're just forced on-chain, which is not\n> terrible, in any case.\n>\n> Hope this helps!\n>\n> Cheers,\n> Ruben\n>\n>\n>\n> On Fri, Jun 12, 2020 at 9:23 PM Tom Trevethan via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hello,\n>>\n>> A statechain implementation and service co-signs 'backup' (off-chain)\n>> transactions to transfer ownership of a UTXO from one owner to the next. A\n>> suggested here\n>> https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39\n>> , this service (the statechain entity or SE) can be engineered to be\n>> 'blind' to the transactions it is signing (i.e. it does not and cannot know\n>> the details of the transactions it is signing) which can give significant\n>> privacy benefits. It would enable more private off-chain coin-swaps, and\n>> make collusion more difficult.\n>>\n>> The only downside of a blind SE is that it can no longer enforce the\n>> rules governing the sequence of backup transactions it co-signs as owners\n>> can ask the SE to cosign any transaction. So each new owner of a UTXO must\n>> receive, store and verify the full sequence of previous owner backup\n>> transactions to make sure that no previous owner has asked the SE to sign a\n>> transaction that could be used to steal the UTXO. This may end up making\n>> wallets more bloated and clunky, given that ownership of a UTXO could\n>> change hands thousands of times off-chain.\n>>\n>> In the case of a multisig, and Schnorr signatures, existing blind Schnorr\n>> protocols could be used to implement a blind SE, however we are opting to\n>> use two-party ECDSA (because there is no Schnorr yet, and in any case ECDSA\n>> will give a much bigger anonymity set). There is no current 2P ECDSA\n>> protocol that enables one of the two signers to be completely blinded, but\n>> it seems that this would require only minor modifications to an existing 2P\n>> ECDSA scheme (outlined here\n>> https://github.com/commerceblock/mercury/blob/master/doc/blind_2p_ecdsa.md\n>> based on Lindell 2017 https://eprint.iacr.org/2017/552 ).\n>>\n>> Any comments on any of this gratefully received.\n>>\n>> Tom\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200614/b23d055a/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Blind Statechains",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tom Trevethan",
                "Ruben Somsen"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 15058
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Knots 0.20.0.knots20200614 released",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2020-06-17T02:18:56",
                "message_text_only": "Bitcoin Knots version 0.20.0.knots20200614 is now available from:\n\n  https://bitcoinknots.org/files/0.20.x/0.20.0.knots20200614/\n\nThis release includes new features, various bug fixes and performance\nimprovements, as well as updated translations.\n\nPlease report bugs using the issue tracker at GitHub:\n\n  https://github.com/bitcoinknots/bitcoin/issues\n\nTo receive security and update notifications, please subscribe to:\n\n  https://bitcoinknots.org/list/announcements/join/\n\nFor the full release notes and change log, see:\n\nhttps://github.com/bitcoinknots/bitcoin/blob/v0.20.0.knots20200614/doc/release-notes.md\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 1528 bytes\nDesc: This is a digitally signed message part.\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200617/26758bcd/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Knots 0.20.0.knots20200614 released",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Luke Dashjr"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 911
        }
    },
    {
        "title": "[bitcoin-dev] [Lightning-dev] RBF Pinning with Counterparties and Competing Interest",
        "thread_messages": [
            {
                "author": "Bastien TEINTURIER",
                "date": "2020-06-19T07:44:11",
                "message_text_only": "Good morning list,\n\nSorry for being (very) late to the party on that subject, but better late\nthan never.\n\nA lot of ideas have been thrown at the problem and are scattered across\nemails, IRC discussions,\nand github issues. I've spent some time putting it all together in one\ngist, hoping that it will\nhelp stir the discussion forward as well as give newcomers all the\nbackground they need to ramp up\non this issue and join the discussion, bringing new ideas to the table.\n\nThe gist is here, and I'd appreciate your feedback if I have wrongly\ninterpreted some of the ideas:\nhttps://gist.github.com/t-bast/22320336e0816ca5578fdca4ad824d12\n\nReaders of this list can probably directly skip to the \"Future work\"\nsection. I believe my\n\"alternative proposal\" should loosely reflect Matt's proposal from the very\nfirst mail of this\nthread; note that I included anchors and new txs only in some places, as I\nthink they aren't\nnecessary everywhere.\n\nMy current state-of-mind (subject to change as I discover more potential\nattacks) is that:\n\n* The proposal to add more anchors and pre-signed txs adds non-negligible\ncomplexity and hurts\nsmall HTLCs, so it would be better if we didn't need it\n* The blind CPFP carve-out trick is a one shot, so you'll likely need to\npay a lot of fees for it\nto work which still makes you lose money in case an attacker targets you\n(but the money goes to\nminers, not to the attacker - unless he is the miner). It's potentially\nhard to estimate what fee\nyou should put into that blind CPFP carve-out because you have no idea what\nthe current fee of the\npinned success transaction package is, so it's unsure if that solution will\nreally work in practice\n* If we take a step back, the only attack we need to protect against is an\nattacker pinning a\npreimage transaction while preventing us from learning that preimage for at\nleast `N` blocks\n(see the gist for the complete explanation). Please correct me if that\nclaim is incorrect as it\nwill invalidate my conclusion! Thus if we have:\n* a high enough `cltv_expiry_delta`\n* [off-chain preimage broadcast](\nhttps://github.com/lightningnetwork/lightning-rfc/issues/783)\n(or David's proposal to do it by sending txs that can be redeemed via only\nthe preimage)\n* LN hubs (or any party commercially investing in running a lightning node)\nparticipating in\nvarious mining pools to help discover preimages\n* decent mitigations for eclipse attacks\n* then the official anchor outputs proposal should be safe enough and is\nmuch simpler?\n\nThank you for reading, I hope the work I put into this gist will be useful\nfor some of you.\n\nBastien\n\nLe ven. 24 avr. 2020 \u00e0 00:47, Matt Corallo via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n>\n>\n> On 4/23/20 8:46 AM, ZmnSCPxj wrote:\n> >>> -   Miners, being economically rational, accept this proposal and\n> include this in a block.\n> >>>\n> >>> The proposal by Matt is then:\n> >>>\n> >>> -   The hashlock branch should instead be:\n> >>> -   B and C must agree, and show the preimage of some hash H (hashlock\n> branch).\n> >>> -   Then B and C agree that B provides a signature spending the\n> hashlock branch, to a transaction with the outputs:\n> >>> -   Normal payment to C.\n> >>> -   Hook output to B, which B can use to CPFP this transaction.\n> >>> -   Hook output to C, which C can use to CPFP this transaction.\n> >>> -   B can still (somehow) not maintain a mempool, by:\n> >>> -   B broadcasts its timelock transaction.\n> >>> -   B tries to CPFP the above hashlock transaction.\n> >>> -   If CPFP succeeds, it means the above hashlock transaction exists\n> and B queries the peer for this transaction, extracting the preimage and\n> claiming the A->B HTLC.\n> >>\n> >> Note that no query is required. The problem has been solved and the\n> preimage-containing transaction should now confirm just fine.\n> >\n> > Ah, right, so it gets confirmed and the `blocksonly` B sees it in a\n> block.\n> >\n> > Even if C hooks a tree of low-fee transactions on its hook output or\n> normal payment, miners will still be willing to confirm this and the B hook\n> CPFP transaction without, right?\n>\n> Correct, once it makes it into the mempool we can CPFP it and all the\n> regular sub-package CPFP calculation will pick it\n> and its descendants up. Of course this relies on it not spending any other\n> unconfirmed inputs.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200619/70e88f70/attachment.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2020-06-19T19:58:46",
                "message_text_only": "On Fri, Jun 19, 2020 at 09:44:11AM +0200, Bastien TEINTURIER via Lightning-dev wrote:\n> The gist is here, and I'd appreciate your feedback if I have wrongly\n> interpreted some of the ideas:\n> https://gist.github.com/t-bast/22320336e0816ca5578fdca4ad824d12\n\nQuoted text below is from the gist:\n\n> The trick to protect against a malicious participant that broadcasts a\n> low-fee HTLC-success or Remote-HTLC-success transaction is that we can\n> always blindly do a CPFP carve-out on them; we know their txid\n\nI think you're assuming here that the attacker broadcast a particular\nstate.  However, in a channel which potentially had thousands of state\nchanges, you'd have to broadcast a blind child for each previous state\n(or at least each previous state that pays the attacker more than the\nlatest state).  That's potentially thousands of transactions times\npotentially dozens of peers---not impossible, but it seems messy.\n\nI think there's a way to accomplish the same goal for less bandwidth and\nzero fees.  The only way your Bitcoin peer will relay your blind child\nis if it already has the parent transaction.  If it has the parent, you\ncan just request it using P2P getdata(type='tx', id=$txid).[1]  You can\nbatch multiple txid requests together (up to 50,000 IIRC) to minimize\noverhead, making the average cost per txid a tiny bit over 36 bytes.\nIf you receive one of the transactions you request, you can extract the\npreimage at no cost to yourself (except bandwidth).  If you don't\nreceive a transaction, then sending a blind child is hopeless\nanyway---your peers won't relay it.\n\nOverall, it's hard for me to guess how effective your proposal would be\nat defeating the attack.  I think the strongman argument for the attack\nwould be that the attacker will be able to perform a targeted relay of\ntheir outdated state to just miners---everyone else on the network\nwill receive the counterparty's honest final-state close.  Unless the\ncounterparty happens to have a connection to a miner's node, the\ncounterparty will neither be able to CPFP fee bump nor use getdata to\nretrieve the preimage.\n\nIt seems to me it's practical for a motivated attacker to research which\nIP addresses belong to miners so that they can target them, whereas\nhonest users won't practically be able to do that research (and, even if\nthey could, it would create a centralizing barrier to new miners\nentering the market if users focused on maintaining connections to\npreviously-known miners).\n\n-Dave\n\n[1] You'd have to be careful to not attempt the getdata too soon after\n    you think the attacker broadcast their old state, but I think that\n    only means waiting a single block, which you have to do anyway to\n    see if the honest final-commitment transaction confirmed.  See\n    https://github.com/bitcoin/bitcoin/pull/18861\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200619/09974bd2/attachment.sig>"
            },
            {
                "author": "David A. Harding",
                "date": "2020-06-19T20:52:20",
                "message_text_only": "On Fri, Jun 19, 2020 at 03:58:46PM -0400, David A. Harding via bitcoin-dev wrote:\n> I think you're assuming here that the attacker broadcast a particular\n> state.  \n\nWhoops, I managed to confuse myself despite looking at Bastien's\nexcellent explainer.  The attacker would be broadcasting the latest\nstate, so the honest counterparty would only need to send one blind\nchild.  However, the blind child will only be relayed by a Bitcoin peer\nif the peer also has the parent transaction (the latest state) and, if\nit has the parent transaction, you should be able to just getdata('tx',\n$txid) that transaction from the peer without CPFPing anything.  That\nwill give you the preimage and so you can immediately resolve the HTLC\nwith the upstream channel.\n\nRevising my conclusion from the previous post:\n\nI think the strongman argument for the attack would be that the attacker\nwill be able to perform a targeted relay of the low-feerate\npreimage-containing transaction to just miners---everyone else on the\nnetwork will receive the honest user's higher-feerate expired-timelock\ntransaction.  Unless the honest user happens to have a connection to a\nminer's node, the user will neither be able to CPFP fee bump nor use\ngetdata to retrieve the preimage.\n\nSorry for the confusion.\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200619/917b77aa/attachment.sig>"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2020-06-20T08:54:03",
                "message_text_only": "Hello Dave and list,\n\nThanks for your quick answers!\n\nThe attacker would be broadcasting the latest\n> state, so the honest counterparty would only need to send one blind\n> child.\n>\n\nExactly, if the attacker submits an outdated transaction he would be\nshooting himself in the foot,\nas we could claim the revocation paths when seeing the transaction in a\nblock and get all the\nchannel funds (since the attacker's outputs will be CSV-locked).\n\nThe only way your Bitcoin peer will relay your blind child\n> is if it already has the parent transaction.\n>\n\nThat's an excellent point that I missed in the blind CPFP carve-out trick!\nI think this makes the\nblind CPFP carve-out quite hard in practice (even using getdata - thanks\nfor detailing that option)...\n\nIn the worst case scenario where most miners' mempools contain the\nattacker's tx and the rest of\nthe network's mempools contains the honest participant's tx, I think there\nisn't much we can do.\nWe're simply missing information, so it looks like the only good solution\nis to avoid being in that\nsituation by having a foot in miners' mempools. Do you think it's\nunreasonable to expect at least\nsome LN nodes to also invest in running nodes in mining pools, ensuring\nthat they learn about\nattackers' txs and can potentially share discovered preimages with the\nnetwork off-chain (by\ngossiping preimages found in the mempool over LN)? I think that these\nrecent attacks show that\nwe need (at least some) off-chain nodes to be somewhat heavily invested in\non-chain operations\n(layers can't be fully decoupled with the current security assumptions -\nmaybe Eltoo will help\nchange that in the future?).\n\nThank you for your time!\nBastien\n\n\n\nLe ven. 19 juin 2020 \u00e0 22:53, David A. Harding <dave at dtrt.org> a \u00e9crit :\n\n> On Fri, Jun 19, 2020 at 03:58:46PM -0400, David A. Harding via bitcoin-dev\n> wrote:\n> > I think you're assuming here that the attacker broadcast a particular\n> > state.\n>\n> Whoops, I managed to confuse myself despite looking at Bastien's\n> excellent explainer.  The attacker would be broadcasting the latest\n> state, so the honest counterparty would only need to send one blind\n> child.  However, the blind child will only be relayed by a Bitcoin peer\n> if the peer also has the parent transaction (the latest state) and, if\n> it has the parent transaction, you should be able to just getdata('tx',\n> $txid) that transaction from the peer without CPFPing anything.  That\n> will give you the preimage and so you can immediately resolve the HTLC\n> with the upstream channel.\n>\n> Revising my conclusion from the previous post:\n>\n> I think the strongman argument for the attack would be that the attacker\n> will be able to perform a targeted relay of the low-feerate\n> preimage-containing transaction to just miners---everyone else on the\n> network will receive the honest user's higher-feerate expired-timelock\n> transaction.  Unless the honest user happens to have a connection to a\n> miner's node, the user will neither be able to CPFP fee bump nor use\n> getdata to retrieve the preimage.\n>\n> Sorry for the confusion.\n>\n> -Dave\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200620/6caf18ec/attachment.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2020-06-20T10:36:47",
                "message_text_only": "On Sat, Jun 20, 2020 at 10:54:03AM +0200, Bastien TEINTURIER wrote:\n> We're simply missing information, so it looks like the only good\n> solution is to avoid being in that situation by having a foot in\n> miners' mempools.\n\nThe problem I have with that approach is that the incentive is to\nconnect to the highest hashrate pools and ignore the long tail of\nsmaller pools and solo miners.  If miners realize people are doing this,\nthey may begin to charge for information about their mempool and the\nlargest miners will likely be able to charge more money per hashrate\nthan smaller miners, creating a centralization force by increasing\nexisting economies of scale.\n\nWorse, information about a node's mempool is partly trusted.  A node can\neasily prove what transactions it has, but it can't prove that it\ndoesn't have a certain transaction.  This implies incumbent pools with a\nlong record of trustworthy behavior may be able to charge more per\nhashrate than a newer pools, creating a reputation-based centralizing\nforce that pushes individual miners towards well-established pools.\n\nThis is one reason I suggested using independent pay-to-preimage\ntransactions[1].  Anyone who knows the preimage can mine the\ntransaction, so it doesn't provide reputational advantage or direct\neconomies of scale---pay-to-preimage is incentive equivalent to paying\nnormal onchain transaction fees.  There is an indirect economy of\nscale---attackers are most likely to send the low-feerate\npreimage-containing transaction to just the largest pools, so small\nminers are unlikely to learn the preimage and thus unlikely to be able\nto claim the payment.  However, if the defense is effective, the attack\nshould rarely happen and so this should not have a significant effect on\nmining profitability---unlike monitoring miner mempools which would have\nto be done continuously and forever.\n\nZmnSCPxj noted that pay-to-preimage doesn't work with PTLCs.[2]  I was\nhoping one of Bitcoin's several inventive cryptographers would come\nalong and describe how someone with an adaptor signature could use that\ninformation to create a pubkey that could be put into a transaction with\na second output that OP_RETURN included the serialized adaptor\nsignature.  The pubkey would be designed to be spendable by anyone with\nthe final signature in a way that revealed the hidden value to the\npubkey's creator, allowing them to resolve the PTLC.  But if that's\nfundamentally not possible, I think we could advocate for making\npay-to-revealed-adaptor-signature possible using something like\nOP_CHECKSIGFROMSTACK.[3]\n\n[1] https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002664.html\n[2] https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002667.html\n[3] https://bitcoinops.org/en/topics/op_checksigfromstack/\n\n> Do you think it's unreasonable to expect at least some LN nodes to\n> also invest in running nodes in mining pools, ensuring that they learn\n> about attackers' txs and can potentially share discovered preimages\n> with the network off-chain (by gossiping preimages found in the\n> mempool over LN)?\n\nIgnoring my concerns about mining centralization and from the\nperspective of just the Lightning Network, that doesn't sound\nunreasonable to me.  But from the perspective of a single LN node, it\nmight make more sense to get the information and *not* share it,\nincreasing your security and allowing you to charge lower routing fees\ncompared to your competitors.  This effect would only be enhanced if\nminers charged for their mempool contents (indeed, to maximize their\nrevenue, miners might require that their mempool subscribers don't share\nthe information---which they could trivially enforce by occasionally\nsending subscribers a preimage specific to the subscriber and seeing if\nit propagated to the public network).\n\n> I think that these recent attacks show that we need (at least some)\n> off-chain nodes to be somewhat heavily invested in on-chain operations\n> (layers can't be fully decoupled with the current security assumptions\n> - maybe Eltoo will help change that in the future?).\n\nI don't see how eltoo helps.  Eltoo helps ensure you reach the final\nchannel state, but this problem involves an abuse of that final state.\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200620/6085153a/attachment-0001.sig>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-20T16:01:16",
                "message_text_only": "Good morning Dave,\n\n> ZmnSCPxj noted that pay-to-preimage doesn't work with PTLCs.[2] I was\n> hoping one of Bitcoin's several inventive cryptographers would come\n> along and describe how someone with an adaptor signature could use that\n> information to create a pubkey that could be put into a transaction with\n> a second output that OP_RETURN included the serialized adaptor\n> signature. The pubkey would be designed to be spendable by anyone with\n> the final signature in a way that revealed the hidden value to the\n> pubkey's creator, allowing them to resolve the PTLC. But if that's\n> fundamentally not possible, I think we could advocate for making\n> pay-to-revealed-adaptor-signature possible using something like\n> OP_CHECKSIGFROMSTACK.[3]\n\n\nNot a cryptographer, I just play one on the Internet, but maybe the pay-for-signature construction could work...?\n\nAssuming a PTLC has a pointlocked branch, which involves signing with MuSig(A, B).\nA offers to B the amount if B reveals the secret `t` behind `T = t * G`; A knows `T` but not `t`.\nThis is done by B handing over `R[B]` and `s'[B]`:\n\n    R = R[A] + R[B] + T\n    s'[B] = r[B] + h(MuSig(A, B) | R | m) * b\n\nThen A provides its partial signature to B.\n\n    s[A] = r[A] + h(MuSig(A, B) | R | m) * a\n\nB has to complete the signature by:\n\n    s = s[A] + s'[B] + t\n\nSince A knows both `s[A]` and `s'[B]`, once it knows `s`, it can compute `t`.\n\n\nNow, we can massage the equation for `s`:\n\n    s = r[A] + h(MuSig(A, B) | R | m) * a + r[B] + h(MuSig(A, B) | R | m) * b + t\n    ; multiply both sides by G\n    s * G = r[A] * G + h(MuSig(A, B) | R | m) * a * G + r[B] * G + h(MuSig(A, B) | R | m) * b * G + t * G\n    ; replace with public points\n    s * G = R[A] + h(MuSig(A, B) | R | m) * A + R[B] + h(MuSig(A, B) | R | m) * B + T\n\nNote that A can compute `s * G` above, because it generated `R[A]`, was given `R[B]` and `T`, and knows who `A` and `B` are.\n\nSo what A needs to do is to offer a fund that can only be claimed by leaking knowledge of `s` behind `s * G`.\nA can do this by creating a new keypair `A[p4s] = a[p4s] * G` and putting a fund into it.\n\nThen A generates an `R[A][p4s] = r[A][p4s] * G`, and computes:\n\n    R[p4s] = R[A][p4s] + s * G\n    s'[A][p4s] = r[A][p4s] + h(A | R[p4s] | m) * a[p4s]\n\nThe signed message could be a signature to `SIGHASH_NONE`, finally an actual use for that flag.\n\nA reveals publicly (in an `OP_RETURN` as you suggest):\n\n* `R[A][p4s]`\n* `s * G`\n* `s'[A][p4s]`\n* `A[p4s]` - Already the Schnorr output pubkey.\n\nIn order to complete the above signature, a third party C has to learn `s` from B.\n\nThe third party has to scan every onchain 1-of-1 signature for an `s` that matches `s * G`, so there is greater processing (point multiplies are more expensive than hashes, also there are more 1-of-1s).\nBut once learned, the third party can complete the signature and claim the funds.\nAnd A then learns `s`, from which it can derive `t`.\n\nThe third party learns about which channel (i.e. the UTXO that was spent to create the PTLC in the first place), but never learns `t` or `T`, which is a small but nice privacy bonus.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-21T02:10:32",
                "message_text_only": "Good morning again,\n\n> Good morning Dave,\n>\n> > ZmnSCPxj noted that pay-to-preimage doesn't work with PTLCs.[2] I was\n> > hoping one of Bitcoin's several inventive cryptographers would come\n> > along and describe how someone with an adaptor signature could use that\n> > information to create a pubkey that could be put into a transaction with\n> > a second output that OP_RETURN included the serialized adaptor\n> > signature. The pubkey would be designed to be spendable by anyone with\n> > the final signature in a way that revealed the hidden value to the\n> > pubkey's creator, allowing them to resolve the PTLC. But if that's\n> > fundamentally not possible, I think we could advocate for making\n> > pay-to-revealed-adaptor-signature possible using something like\n> > OP_CHECKSIGFROMSTACK.[3]\n>\n> <snip>\n>\n> The signed message could be a signature to `SIGHASH_NONE`, finally an actual use for that flag.\n\nIf you are going to embed it in an `OP_RETURN` in the same transaction, you also need `SIGHASH_ANYPREVOUT`, otherwise you cannot embed the adaptor signature for spending from that transaction in the transaction being spent, it also implies `A[p4s] = a[p4s] * G` is a one-time-use keypair.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2020-06-22T07:35:20",
                "message_text_only": "Thanks for the detailed write-up on how it affects incentives and\ncentralization,\nthese are good points. I need to spend more time thinking about them.\n\nThis is one reason I suggested using independent pay-to-preimage\n> transactions[1]\n>\n\nWhile this works as a technical solution, I think it has some incentives\nissues too.\nIn this attack, I believe the miners that hide the preimage tx in their\nmempool have\nto be accomplice with the attacker, otherwise they would share that tx with\nsome of\ntheir peers, and some non-miner nodes would get that preimage tx and be\nable to\ngossip them off-chain (and even relay them to other mempools).\n\nIf they are actively helping the attacker, they wouldn't spend the\npay-to-preimage tx,\nunless they gain more from it than the share the attacker gives them. This\nbecomes\na simple bidding war, and the honest user will always be the losing party\nhere (the\nattacker has nothing to lose). For this reason I'm afraid it wouldn't work\nout in practice\nas well as we'd hope...what do you think? And even if the honest user wins\nthe bidding\nwar, the attack still steals money from that user; it just goes into the\nminer's pocket.\n\nBut from the perspective of a single LN node, it\n> might make more sense to get the information and *not* share it\n>\n\nI think it depends. If this attack becomes doable in practice and we see it\nhappening,\nLN routing nodes and service providers have a very high incentive to thwart\nthese attacks,\nbecause otherwise they'd lose their business as people would leave the\nlightning network.\n\nAs long as enough nodes think that way (with \"enough\" being a very hard to\ndefine quantity),\nthis should mitigate the attack. The only risk would be a big \"exit scam\"\nscenario, but the\ncoordination cost between all these nodes makes that scenario unlikely\n(IMHO).\n\nThanks,\nBastien\n\nLe sam. 20 juin 2020 \u00e0 12:37, David A. Harding <dave at dtrt.org> a \u00e9crit :\n\n> On Sat, Jun 20, 2020 at 10:54:03AM +0200, Bastien TEINTURIER wrote:\n> > We're simply missing information, so it looks like the only good\n> > solution is to avoid being in that situation by having a foot in\n> > miners' mempools.\n>\n> The problem I have with that approach is that the incentive is to\n> connect to the highest hashrate pools and ignore the long tail of\n> smaller pools and solo miners.  If miners realize people are doing this,\n> they may begin to charge for information about their mempool and the\n> largest miners will likely be able to charge more money per hashrate\n> than smaller miners, creating a centralization force by increasing\n> existing economies of scale.\n>\n> Worse, information about a node's mempool is partly trusted.  A node can\n> easily prove what transactions it has, but it can't prove that it\n> doesn't have a certain transaction.  This implies incumbent pools with a\n> long record of trustworthy behavior may be able to charge more per\n> hashrate than a newer pools, creating a reputation-based centralizing\n> force that pushes individual miners towards well-established pools.\n>\n> This is one reason I suggested using independent pay-to-preimage\n> transactions[1].  Anyone who knows the preimage can mine the\n> transaction, so it doesn't provide reputational advantage or direct\n> economies of scale---pay-to-preimage is incentive equivalent to paying\n> normal onchain transaction fees.  There is an indirect economy of\n> scale---attackers are most likely to send the low-feerate\n> preimage-containing transaction to just the largest pools, so small\n> miners are unlikely to learn the preimage and thus unlikely to be able\n> to claim the payment.  However, if the defense is effective, the attack\n> should rarely happen and so this should not have a significant effect on\n> mining profitability---unlike monitoring miner mempools which would have\n> to be done continuously and forever.\n>\n> ZmnSCPxj noted that pay-to-preimage doesn't work with PTLCs.[2]  I was\n> hoping one of Bitcoin's several inventive cryptographers would come\n> along and describe how someone with an adaptor signature could use that\n> information to create a pubkey that could be put into a transaction with\n> a second output that OP_RETURN included the serialized adaptor\n> signature.  The pubkey would be designed to be spendable by anyone with\n> the final signature in a way that revealed the hidden value to the\n> pubkey's creator, allowing them to resolve the PTLC.  But if that's\n> fundamentally not possible, I think we could advocate for making\n> pay-to-revealed-adaptor-signature possible using something like\n> OP_CHECKSIGFROMSTACK.[3]\n>\n> [1]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002664.html\n> [2]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002667.html\n> [3] https://bitcoinops.org/en/topics/op_checksigfromstack/\n>\n> > Do you think it's unreasonable to expect at least some LN nodes to\n> > also invest in running nodes in mining pools, ensuring that they learn\n> > about attackers' txs and can potentially share discovered preimages\n> > with the network off-chain (by gossiping preimages found in the\n> > mempool over LN)?\n>\n> Ignoring my concerns about mining centralization and from the\n> perspective of just the Lightning Network, that doesn't sound\n> unreasonable to me.  But from the perspective of a single LN node, it\n> might make more sense to get the information and *not* share it,\n> increasing your security and allowing you to charge lower routing fees\n> compared to your competitors.  This effect would only be enhanced if\n> miners charged for their mempool contents (indeed, to maximize their\n> revenue, miners might require that their mempool subscribers don't share\n> the information---which they could trivially enforce by occasionally\n> sending subscribers a preimage specific to the subscriber and seeing if\n> it propagated to the public network).\n>\n> > I think that these recent attacks show that we need (at least some)\n> > off-chain nodes to be somewhat heavily invested in on-chain operations\n> > (layers can't be fully decoupled with the current security assumptions\n> > - maybe Eltoo will help change that in the future?).\n>\n> I don't see how eltoo helps.  Eltoo helps ensure you reach the final\n> channel state, but this problem involves an abuse of that final state.\n>\n> -Dave\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200622/09e39b02/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-22T08:15:37",
                "message_text_only": "Good morning Bastien,\n\n> Thanks for the detailed write-up on how it affects incentives and centralization,\n> these are good points. I need to spend more time thinking about them.\n>\n> > This is one reason I suggested using independent pay-to-preimage\n> > transactions[1]\n>\n> While this works as a technical solution, I think it has some incentives issues too.\n> In this attack, I believe the miners that hide the preimage tx in their mempool have\n> to be accomplice with the attacker, otherwise they would share that tx with some of\n> their peers, and some non-miner nodes would get that preimage tx and be able to\n> gossip them off-chain (and even relay them to other mempools).\n\nI believe this is technically possible with current mempool rules, without miners cooperating with the attacker.\n\nBasically, the attacker releases two transactions with near-equal fees, so that neither can RBF the other.\nIt releases the preimage tx near miners, and the timelock tx near non-miners.\n\nNodes at the boundaries between those that receive the preimage tx and the timelock tx will receive both.\nHowever, they will receive one or the other first.\nWhich one they receive first will be what they keep, and they will reject the other (and *not* propagate the other), because the difference in fees is not enough to get past the RBF rules (which requires not just a feerate increase, but also an increase in absolute fee, of at least the minimum relay feerate times transaction size).\n\nBecause they reject the other tx, they do not propagate the other tx, so the boundary between the two txes is inviolate, neither can get past that boundary, this occurs even if everyone is running 100% unmodified Bitcoin Core code.\n\nI am not a mempool expert and my understanding may be incorrect.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2020-06-22T08:25:09",
                "message_text_only": "Hey ZmnSCPxj,\n\nI agree that in theory this looks possible, but doing it in practice with\naccurate control\nof what parts of the network get what tx feels impractical to me (but maybe\nI'm wrong!).\n\nIt feels to me that an attacker who would be able to do this would break\n*any* off-chain\nconstruction that relies on absolute timeouts, so I'm hoping this is\ninsanely hard to\nachieve without cooperation from a miners subset. Let me know if I'm too\noptimistic on\nthis!\n\nCheers,\nBastien\n\nLe lun. 22 juin 2020 \u00e0 10:15, ZmnSCPxj <ZmnSCPxj at protonmail.com> a \u00e9crit :\n\n> Good morning Bastien,\n>\n> > Thanks for the detailed write-up on how it affects incentives and\n> centralization,\n> > these are good points. I need to spend more time thinking about them.\n> >\n> > > This is one reason I suggested using independent pay-to-preimage\n> > > transactions[1]\n> >\n> > While this works as a technical solution, I think it has some incentives\n> issues too.\n> > In this attack, I believe the miners that hide the preimage tx in their\n> mempool have\n> > to be accomplice with the attacker, otherwise they would share that tx\n> with some of\n> > their peers, and some non-miner nodes would get that preimage tx and be\n> able to\n> > gossip them off-chain (and even relay them to other mempools).\n>\n> I believe this is technically possible with current mempool rules, without\n> miners cooperating with the attacker.\n>\n> Basically, the attacker releases two transactions with near-equal fees, so\n> that neither can RBF the other.\n> It releases the preimage tx near miners, and the timelock tx near\n> non-miners.\n>\n> Nodes at the boundaries between those that receive the preimage tx and the\n> timelock tx will receive both.\n> However, they will receive one or the other first.\n> Which one they receive first will be what they keep, and they will reject\n> the other (and *not* propagate the other), because the difference in fees\n> is not enough to get past the RBF rules (which requires not just a feerate\n> increase, but also an increase in absolute fee, of at least the minimum\n> relay feerate times transaction size).\n>\n> Because they reject the other tx, they do not propagate the other tx, so\n> the boundary between the two txes is inviolate, neither can get past that\n> boundary, this occurs even if everyone is running 100% unmodified Bitcoin\n> Core code.\n>\n> I am not a mempool expert and my understanding may be incorrect.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200622/67840048/attachment-0001.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-06-24T08:32:52",
                "message_text_only": "Given transaction relay delays and a network topology that is rather transparent if you look closely enough, I think this is very real and very practical (double-digit % success rate, at least, with some trial and error probably 50+). That said, we all also probably know most of the people who know enough to go from zero to doing this practically next week. As for motivated folks who have lots of time to read code and dig, this seems like something worth fixing in the medium term.\n\nYour observation is what\u2019s largely led me to conclude there isn\u2019t a lot we can do here without a lot of creativity and fundamental rethinking of our approach. One thing I keep harping on is maybe saving the blind-CPFP approach with a) eltoo, and b) some kind of magic transaction relay metadata that allows you to specify \u201cthis spends at least one output on any transaction that spends output X\u201d so that nodes can always apply it properly. But maybe that\u2019s a pipedream of complexity. I know Antoine has other thoughts.\n\nMatt\n\n> On Jun 22, 2020, at 04:04, Bastien TEINTURIER via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \ufeff\n> Hey ZmnSCPxj,\n> \n> I agree that in theory this looks possible, but doing it in practice with accurate control\n> of what parts of the network get what tx feels impractical to me (but maybe I'm wrong!).\n> \n> It feels to me that an attacker who would be able to do this would break *any* off-chain\n> construction that relies on absolute timeouts, so I'm hoping this is insanely hard to\n> achieve without cooperation from a miners subset. Let me know if I'm too optimistic on\n> this!\n> \n> Cheers,\n> Bastien\n> \n>> Le lun. 22 juin 2020 \u00e0 10:15, ZmnSCPxj <ZmnSCPxj at protonmail.com> a \u00e9crit :\n>> Good morning Bastien,\n>> \n>> > Thanks for the detailed write-up on how it affects incentives and centralization,\n>> > these are good points. I need to spend more time thinking about them.\n>> >\n>> > > This is one reason I suggested using independent pay-to-preimage\n>> > > transactions[1]\n>> >\n>> > While this works as a technical solution, I think it has some incentives issues too.\n>> > In this attack, I believe the miners that hide the preimage tx in their mempool have\n>> > to be accomplice with the attacker, otherwise they would share that tx with some of\n>> > their peers, and some non-miner nodes would get that preimage tx and be able to\n>> > gossip them off-chain (and even relay them to other mempools).\n>> \n>> I believe this is technically possible with current mempool rules, without miners cooperating with the attacker.\n>> \n>> Basically, the attacker releases two transactions with near-equal fees, so that neither can RBF the other.\n>> It releases the preimage tx near miners, and the timelock tx near non-miners.\n>> \n>> Nodes at the boundaries between those that receive the preimage tx and the timelock tx will receive both.\n>> However, they will receive one or the other first.\n>> Which one they receive first will be what they keep, and they will reject the other (and *not* propagate the other), because the difference in fees is not enough to get past the RBF rules (which requires not just a feerate increase, but also an increase in absolute fee, of at least the minimum relay feerate times transaction size).\n>> \n>> Because they reject the other tx, they do not propagate the other tx, so the boundary between the two txes is inviolate, neither can get past that boundary, this occurs even if everyone is running 100% unmodified Bitcoin Core code.\n>> \n>> I am not a mempool expert and my understanding may be incorrect.\n>> \n>> Regards,\n>> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200624/7a0b11e4/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "RBF Pinning with Counterparties and Competing Interest",
            "categories": [
                "bitcoin-dev",
                "Lightning-dev"
            ],
            "authors": [
                "Bastien TEINTURIER",
                "ZmnSCPxj",
                "Matt Corallo",
                "David A. Harding"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 36310
        }
    },
    {
        "title": "[bitcoin-dev] Distributed Delegated Pre-Signed Transactions (DDPST)",
        "thread_messages": [
            {
                "author": "Swambo, Jacob",
                "date": "2020-06-22T15:07:41",
                "message_text_only": "I am building a solution for distributed, delegated pre-signed transactions (DDPST). This post introduces what DDPST are and why I think they are relevant for multiple applications. If you are working on application that can benefit from such a construction and want me to use your application in the proof of concept code, please reach out. All feedback is welcome on the concept in general.\n\nPre-signed transactions (PSTs) are utilized in numerous off-chain protocols including Lightning Network, non-custodial trading, Statechains, and custody protocols. PSTs are useful because they enable restricted access to funds and their custody can be *delegated* with limited risk. Compare this with the arbitrary control over funds that comes with access to the private keys. It is conceivable then that a broad class of applications would benefit from a mechanism to securely delegate PSTs. A mechanism to *distribute* custody of PSTs across multiple entities can act as a practical countermeasure for numerous attacks (e.g. denial-of-service, bribery, blackmail, etc.). Moreover, systems of accountability among the custodians, with proofs of correct and incorrect behaviour, form a foundation for engineering incentive structures that align with the objectives of the application at hand. Finally, distributed custody of PSTs could enable new trust models for the privacy of delegated PSTs using multi-party computation.\n\n# Examples\n\nConsider first the example of vault-custody protocols [1], where there is a requirement for a distributed network monitoring and response system to detect breeches and trigger a recovery process. It is critical to protect against denial-of-service (DoS) attacks that seek to compromise a monitoring node in order to force the custody operation into a recovery process. In this attack the adversary broadcasts the recovery transaction and reduces the accessibility of the wallet owner's funds. A method for distributing custody of the recovery transaction offers defence-in-depth, and a method for delegating custody enables outsourcing the monitor and response service (see Watchtower implementations currently under development [2,3]). A further improvement for the protection of PSTs, that comes from distributing custody, is that *proactive* security models can be instanciated such that successful attacks must occur in a limited time-frame [4].\n\nConsider next the example of justice transactions in the current Lightning Network model. Here, it is critical that justice transactions are broadcast in a timely manner in response to detecting that either party is attempting to close the channel with a prior state. Attacks rely on disrupting the broadcast of the justice transaction through, for example, bribing the watchtower to wait. The watchtower can broadcast late and claim that it was an honest failure due to network issues. The victim has no recourse to punish the watchtower nor the malicious channel participant. If instead the justice transaction was distributed among a set of independent watchtowers, and an accountability system was in-place for their actions, a more robust incentive structure could be engineered. Moreover, distributing custody of the justice transaction can provide a new privacy mechanism for both operational security of a business but also to mitigate targeted attacks such as bribery.\n\nBest regards,\nJacob\n\n# References\n\n[1] Jacob Swambo, Spencer Hommel, Bob McElrath, and Bryan Bishop. Custody Protocols Using Bitcoin Vaults. 2020. https://arxiv.org/abs/2005.11776\n\n[2] The eye of satoshi - lightning watchtower. https://github.com/talaia-labs/python-teos\n\n[3] Private altruist watchtowers. https://github.com/lightningnetwork/lnd/blob/master/docs/watchtower.md\n\n[4] Ran Canetti, Rosario Gennaro, and Amir Herzberg. Proactive security: Long-term protection against break-ins. CryptoBytes, 3:1\u20138, 1997.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200622/68d835de/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Distributed Delegated Pre-Signed Transactions (DDPST)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Swambo, Jacob"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 4062
        }
    },
    {
        "title": "[bitcoin-dev] MAD-HTLC",
        "thread_messages": [
            {
                "author": "Stanga",
                "date": "2020-06-23T06:41:56",
                "message_text_only": "Hi all,\n\nWe'd like to bring to your attention our recent result concerning HTLC.\nHere are the technical report and a short post outlining the main points:\n\n* https://arxiv.org/abs/2006.12031\n* https://ittayeyal.github.io/2020-06-22-mad-htlc\n\nEssentially, we find that HTLC security relies on miners being altruistic,\nor at least myopic. This might be enough for some time, but it took us 150\nlines of code to make bitcoind non-myopic.\n\nOn the positive side, we discovered an alternative to HTLC that we call\nMAD-HTLC, which is provably secure -- everyone's best interest is to behave\nas desired.\n\nWe've notified relevant teams in advance.\n\nWe'll appreciate any comments.\n\nBest,\nItay, Ittay, and Matan\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200623/22f976f1/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-23T09:48:27",
                "message_text_only": "Good morning Itay, Ittay, and Matan,\n\nI believe an unstated assumption in Bitcoin is that miners are short-sighted.\n\nThe reasoning for this assumption is:\n\n* Deployment of new mining hardware controlled by others may occur at any time you do not control.\n  * Thus, any transactions you leave on the table are potentially taken by somebody else and not by you.\n  * Sudden changes in hashpower distribution may reduce your expected future earnings, so any future theoretical earnings should be discounted (*in addition to* expected return-on-investment on getting money you can invest *now*).\n\nIt also strikes me that, in a world with RBF and CPFP, the same endpoint (i.e. miners earn the entire fund of the HTLC) is achieved by existing HTLCs, without the additional branch and script opcodes needed by MAD-HTLC.\nFor example, if an HTLC is confirmed but the hashlock-claiming transaction is not being confirmed (because miners are holding it up because Bob is offering a much higher fee in the future for the timelock-claiming transaction), then Alice can, regardless of the reason why it is not being confirmed, bump up the fee with RBF or CPFP.\n\nIf the fee bump offered by Alice is sufficiently large, then miners will start re-preferring the Alice hashlock transaction.\nTo counter this, Bob has to bid up its version higher.\n\nAs the timeout approaches, Alice can bump up its fee until it is just 1 satoshi short of the total fund.\nIt is rational for Alice to do so since at timeout, it can expect to lose the entire fund.\nIn order for Bob to win, it has to beat that fee, at which point it equals or exceeds the total fund, and miners get the total fund (or more).\n\nKnowing this end-point, rational Bob will not even begin this game.\n\nI think this research considers these two endpoints to be distinct:\n\n* Bob misbehaves and the entire fund is punished by miners, leaving miners with the fund and Alice and Bob without money (MAD-HTLC).\n* Bob misbehaves, Alice counters, and the ensuing fee war leads to fees approaching the fund value, leaving miners with the fund and Alice and Bob without money (standard HTLC).\n\nBut in practice I think both endpoints are essentially equivalent.\n\n--\n\nWhat MAD-HTLC can do would be to make different claims:\n\n* Inputs:\n  * Bob 1 BTC - HTLC amount\n  * Bob 1 BTC - Bob fidelity bond\n\n* Cases:\n  * Alice reveals hashlock at any time:\n    * 1 BTC goes to Alice\n    * 1 BTC goes to Bob (fidelity bond refund)\n  * Bob reveals bob-hashlock after time L:\n    * 2 BTC goes to Bob (HTLC refund + fidelity bond refund)\n  * Bob cheated, anybody reveals both hashlock and bob-hashlock:\n    * 2 BTC goes to miner\n\nThis is an actual improvement over HTLC: Bob misbehavior leads to loss of the fidelity bond.\nThe above cases can be assured by requiring both Alice and Bob to sign in the alice-hashlock branch, so that the splitting of the fund is enforced, and SegWit signing so that the dependent transaction is signed before the HTLC-funding transaction is.\nIt can also be implemented with `OP_CHECKTEMPLATEVERIFY`.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Stanga",
                "date": "2020-06-23T12:47:56",
                "message_text_only": "Hi ZmnSCPxj,\n\nThank you for taking the time to respond, these are very good points.\nResponses inline.\n\nOn Tue, Jun 23, 2020 at 12:48 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Itay, Ittay, and Matan,\n>\n> I believe an unstated assumption in Bitcoin is that miners are\n> short-sighted.\n>\n> The reasoning for this assumption is:\n>\n> * Deployment of new mining hardware controlled by others may occur at any\n> time you do not control.\n>   * Thus, any transactions you leave on the table are potentially taken by\n> somebody else and not by you.\n>   * Sudden changes in hashpower distribution may reduce your expected\n> future earnings, so any future theoretical earnings should be discounted\n> (*in addition to* expected return-on-investment on getting money you can\n> invest *now*).\n>\n\nOur analysis assumes constant difficulty, i.e., no significant changes of\nthe miners set. Indeed, hash-rate changes typically occur at a much larger\ngranularity than your average HTLC timeout. For instance, we noticed plenty\nof lightning nodes use timeouts of a day. So, we do not consider\noptimization at infinity, just a day ahead, and within this time frame all\nthe factors you mentioned are not expected to dramatically change.\n\nThat being said, it would be interesting to analyze the effect of miners\njoining during the HTLC duration. Intuitively, this shouldn\u2019t affect the\nresults, as those new miners have the same incentive to wait for the\nhigher-paying tx.\n\n\n>\n> It also strikes me that, in a world with RBF and CPFP, the same endpoint\n> (i.e. miners earn the entire fund of the HTLC) is achieved by existing\n> HTLCs, without the additional branch and script opcodes needed by MAD-HTLC.\n> For example, if an HTLC is confirmed but the hashlock-claiming transaction\n> is not being confirmed (because miners are holding it up because Bob is\n> offering a much higher fee in the future for the timelock-claiming\n> transaction), then Alice can, regardless of the reason why it is not being\n> confirmed, bump up the fee with RBF or CPFP.\n>\n> If the fee bump offered by Alice is sufficiently large, then miners will\n> start re-preferring the Alice hashlock transaction.\n> To counter this, Bob has to bid up its version higher.\n>\n> As the timeout approaches, Alice can bump up its fee until it is just 1\n> satoshi short of the total fund.\n> It is rational for Alice to do so since at timeout, it can expect to lose\n> the entire fund.\n> In order for Bob to win, it has to beat that fee, at which point it equals\n> or exceeds the total fund, and miners get the total fund (or more).\n>\n> Knowing this end-point, rational Bob will not even begin this game.\n>\n> I think this research considers these two endpoints to be distinct:\n>\n> * Bob misbehaves and the entire fund is punished by miners, leaving miners\n> with the fund and Alice and Bob without money (MAD-HTLC).\n> * Bob misbehaves, Alice counters, and the ensuing fee war leads to fees\n> approaching the fund value, leaving miners with the fund and Alice and Bob\n> without money (standard HTLC).\n>\n> But in practice I think both endpoints are essentially equivalent.\n>\n\nThese are not the same scenario, since in HTLC there is a race between\nAlice and Bob. Alice might not wish to pay the full HTLC amount once she\nsees Bob is trying to cheat. She could wait until close to the timeout so\nas to reduce the time Bob can respond. Of course Bob would do the same. So\nthis is an actual race, and Bob takes no risk since his payment is all from\nthe HTLC amount. Mutual destruction is only assured under certain\nassumptions in HTLC. MAD-HTLC achieves security without relying on such\nassumptions.\n\n\n>\n> --\n>\n> What MAD-HTLC can do would be to make different claims:\n>\n> * Inputs:\n>   * Bob 1 BTC - HTLC amount\n>   * Bob 1 BTC - Bob fidelity bond\n>\n> * Cases:\n>   * Alice reveals hashlock at any time:\n>     * 1 BTC goes to Alice\n>     * 1 BTC goes to Bob (fidelity bond refund)\n>   * Bob reveals bob-hashlock after time L:\n>     * 2 BTC goes to Bob (HTLC refund + fidelity bond refund)\n>   * Bob cheated, anybody reveals both hashlock and bob-hashlock:\n>     * 2 BTC goes to miner\n>\n> This is an actual improvement over HTLC: Bob misbehavior leads to loss of\n> the fidelity bond.\n> The above cases can be assured by requiring both Alice and Bob to sign in\n> the alice-hashlock branch, so that the splitting of the fund is enforced,\n> and SegWit signing so that the dependent transaction is signed before the\n> HTLC-funding transaction is.\n> It can also be implemented with `OP_CHECKTEMPLATEVERIFY`.\n\n\nThe cases you present are exactly how MAD-HTLC works. It comprises two\ncontracts (UTXOs):\n* Deposit (holding the intended HTLC tokens), with three redeem paths:\n    - Alice (signature), with preimage \"A\", no timeout\n    - Bob (signature), with preimage \"B\", timeout T\n    - Any entity (miner), with both preimages \"A\" and \"B\", no timeout\n* Collateral (the fidelity bond, doesn't have to be of the same amount)\n    - Bob (signature), no preimage, timeout T\n    - Any entity (miner), with both preimages \"A\" and \"B\", timeout T\n\nOnly Bob initially knows preimage \"B\", and is required to reveal it if he\nwishes to get the Deposit tokens.\n\nConsider first the case where Alice publishes preimage \"A\": Bob can safely\npublish preimage \"B\" and get both the Deposit and Collateral tokens after\nthe timeout.\nNow, consider the case where Alice does not publish preimage \"A\": If Bob\npublishes preimage \"B\" he gets nothing (and so does Alice - this is the\nmutual assured destruction), and if he doesn't, he gets the Collateral\ntokens.\n\nBest,\nIttay\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200623/351a3679/attachment.html>"
            },
            {
                "author": "Stanga",
                "date": "2020-06-23T13:18:35",
                "message_text_only": "Of course the order at the end should have been switched:\n\nConsider first the case where Alice *does not* publish preimage \"A\": Bob\ncan safely publish preimage \"B\" and get both the Deposit and Collateral\ntokens after the timeout.\nNow, consider the case where Alice *publishes* preimage \"A\": If Bob\npublishes preimage \"B\" he gets nothing (and so does Alice - this is the\nmutual assured destruction), and if he doesn't, he gets the Collateral\ntokens.\n\n\nOn Tue, Jun 23, 2020 at 3:47 PM Stanga <stanga at gmail.com> wrote:\n\n> Hi ZmnSCPxj,\n>\n> Thank you for taking the time to respond, these are very good points.\n> Responses inline.\n>\n> On Tue, Jun 23, 2020 at 12:48 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n>> Good morning Itay, Ittay, and Matan,\n>>\n>> I believe an unstated assumption in Bitcoin is that miners are\n>> short-sighted.\n>>\n>> The reasoning for this assumption is:\n>>\n>> * Deployment of new mining hardware controlled by others may occur at any\n>> time you do not control.\n>>   * Thus, any transactions you leave on the table are potentially taken\n>> by somebody else and not by you.\n>>   * Sudden changes in hashpower distribution may reduce your expected\n>> future earnings, so any future theoretical earnings should be discounted\n>> (*in addition to* expected return-on-investment on getting money you can\n>> invest *now*).\n>>\n>\n> Our analysis assumes constant difficulty, i.e., no significant changes of\n> the miners set. Indeed, hash-rate changes typically occur at a much larger\n> granularity than your average HTLC timeout. For instance, we noticed plenty\n> of lightning nodes use timeouts of a day. So, we do not consider\n> optimization at infinity, just a day ahead, and within this time frame all\n> the factors you mentioned are not expected to dramatically change.\n>\n> That being said, it would be interesting to analyze the effect of miners\n> joining during the HTLC duration. Intuitively, this shouldn\u2019t affect the\n> results, as those new miners have the same incentive to wait for the\n> higher-paying tx.\n>\n>\n>>\n>> It also strikes me that, in a world with RBF and CPFP, the same endpoint\n>> (i.e. miners earn the entire fund of the HTLC) is achieved by existing\n>> HTLCs, without the additional branch and script opcodes needed by MAD-HTLC.\n>> For example, if an HTLC is confirmed but the hashlock-claiming\n>> transaction is not being confirmed (because miners are holding it up\n>> because Bob is offering a much higher fee in the future for the\n>> timelock-claiming transaction), then Alice can, regardless of the reason\n>> why it is not being confirmed, bump up the fee with RBF or CPFP.\n>>\n>> If the fee bump offered by Alice is sufficiently large, then miners will\n>> start re-preferring the Alice hashlock transaction.\n>> To counter this, Bob has to bid up its version higher.\n>>\n>> As the timeout approaches, Alice can bump up its fee until it is just 1\n>> satoshi short of the total fund.\n>> It is rational for Alice to do so since at timeout, it can expect to lose\n>> the entire fund.\n>> In order for Bob to win, it has to beat that fee, at which point it\n>> equals or exceeds the total fund, and miners get the total fund (or more).\n>>\n>> Knowing this end-point, rational Bob will not even begin this game.\n>>\n>> I think this research considers these two endpoints to be distinct:\n>>\n>> * Bob misbehaves and the entire fund is punished by miners, leaving\n>> miners with the fund and Alice and Bob without money (MAD-HTLC).\n>> * Bob misbehaves, Alice counters, and the ensuing fee war leads to fees\n>> approaching the fund value, leaving miners with the fund and Alice and Bob\n>> without money (standard HTLC).\n>>\n>> But in practice I think both endpoints are essentially equivalent.\n>>\n>\n> These are not the same scenario, since in HTLC there is a race between\n> Alice and Bob. Alice might not wish to pay the full HTLC amount once she\n> sees Bob is trying to cheat. She could wait until close to the timeout so\n> as to reduce the time Bob can respond. Of course Bob would do the same. So\n> this is an actual race, and Bob takes no risk since his payment is all from\n> the HTLC amount. Mutual destruction is only assured under certain\n> assumptions in HTLC. MAD-HTLC achieves security without relying on such\n> assumptions.\n>\n>\n>>\n>> --\n>>\n>> What MAD-HTLC can do would be to make different claims:\n>>\n>> * Inputs:\n>>   * Bob 1 BTC - HTLC amount\n>>   * Bob 1 BTC - Bob fidelity bond\n>>\n>> * Cases:\n>>   * Alice reveals hashlock at any time:\n>>     * 1 BTC goes to Alice\n>>     * 1 BTC goes to Bob (fidelity bond refund)\n>>   * Bob reveals bob-hashlock after time L:\n>>     * 2 BTC goes to Bob (HTLC refund + fidelity bond refund)\n>>   * Bob cheated, anybody reveals both hashlock and bob-hashlock:\n>>     * 2 BTC goes to miner\n>>\n>> This is an actual improvement over HTLC: Bob misbehavior leads to loss of\n>> the fidelity bond.\n>> The above cases can be assured by requiring both Alice and Bob to sign in\n>> the alice-hashlock branch, so that the splitting of the fund is enforced,\n>> and SegWit signing so that the dependent transaction is signed before the\n>> HTLC-funding transaction is.\n>> It can also be implemented with `OP_CHECKTEMPLATEVERIFY`.\n>\n>\n> The cases you present are exactly how MAD-HTLC works. It comprises two\n> contracts (UTXOs):\n> * Deposit (holding the intended HTLC tokens), with three redeem paths:\n>     - Alice (signature), with preimage \"A\", no timeout\n>     - Bob (signature), with preimage \"B\", timeout T\n>     - Any entity (miner), with both preimages \"A\" and \"B\", no timeout\n> * Collateral (the fidelity bond, doesn't have to be of the same amount)\n>     - Bob (signature), no preimage, timeout T\n>     - Any entity (miner), with both preimages \"A\" and \"B\", timeout T\n>\n> Only Bob initially knows preimage \"B\", and is required to reveal it if he\n> wishes to get the Deposit tokens.\n>\n> Consider first the case where Alice publishes preimage \"A\": Bob can safely\n> publish preimage \"B\" and get both the Deposit and Collateral tokens after\n> the timeout.\n> Now, consider the case where Alice does not publish preimage \"A\": If Bob\n> publishes preimage \"B\" he gets nothing (and so does Alice - this is the\n> mutual assured destruction), and if he doesn't, he gets the Collateral\n> tokens.\n>\n> Best,\n> Ittay\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200623/0f0934c7/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-25T01:38:17",
                "message_text_only": "Good morning Stanga et al,\n\n\n> > Hi ZmnSCPxj,\u00a0\n> >\n> > Thank you for taking the time to respond, these are very good points. Responses inline.\n> >\n> > On Tue, Jun 23, 2020 at 12:48 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> >\n> > > Good morning Itay, Ittay, and Matan,\n> > >\n> > > I believe an unstated assumption in Bitcoin is that miners are short-sighted.\n> > >\n> > > The reasoning for this assumption is:\n> > >\n> > > * Deployment of new mining hardware controlled by others may occur at any time you do not control.\n> > > \u00a0 * Thus, any transactions you leave on the table are potentially taken by somebody else and not by you.\n> > > \u00a0 * Sudden changes in hashpower distribution may reduce your expected future earnings, so any future theoretical earnings should be discounted (*in addition to* expected return-on-investment on getting money you can invest *now*).\n> >\n> > Our analysis assumes constant difficulty, i.e., no significant changes of the miners set. Indeed, hash-rate changes typically occur at a much larger granularity than your average HTLC timeout. For instance, we noticed plenty of lightning nodes use timeouts of a day. So, we do not consider optimization at infinity, just a day ahead, and within this time frame all the factors you mentioned are not expected to dramatically change.\u00a0\n> >\n> > That being said, it would be interesting to analyze the effect of miners joining during the HTLC duration. Intuitively, this shouldn\u2019t affect the results, as those new miners have the same incentive to wait for the higher-paying tx.\n\nWe already know that hashrate tends to trend upwards, and that we do not expect hashrate to fall except for occasional transients.\n\nThe expectation is not that new miners have different incentives.\nInstead, the expectation is that current miners discount future possible gains because in the future, they expect to have less hashrate share than right now.\n\nThe only trustless way for Bob to bribe miners into deferring Alice tx is to attach the bribe to the future confirmation of the Bob tx, thus Bob is offering future-coins, not present-coins like Alice can offer, and the fact that miners expect an overall uptrend in total hashrate (leading to an overall downtrend in their hashrate share) means that miners discount the Bob offered future-coins.\nThe discounting is proportional to the time delay involved, as a larger delay implies greater reduction in hashrate share.\n\nThis discounting is, again, *in addition to* natural discounting a.k.a. \"I will gladly pay you Thursday for a hamburger today\", the hamburger seller will want some pretty stiff assurances plus a bigger payment on Thursday for giving you a hamburger today, due to expected returns on investment.\n\n\n> > \u00a0\n> >\n> > > It also strikes me that, in a world with RBF and CPFP, the same endpoint (i.e. miners earn the entire fund of the HTLC) is achieved by existing HTLCs, without the additional branch and script opcodes needed by MAD-HTLC.\n> > > For example, if an HTLC is confirmed but the hashlock-claiming transaction is not being confirmed (because miners are holding it up because Bob is offering a much higher fee in the future for the timelock-claiming transaction), then Alice can, regardless of the reason why it is not being confirmed, bump up the fee with RBF or CPFP.\n> > >\n> > > If the fee bump offered by Alice is sufficiently large, then miners will start re-preferring the Alice hashlock transaction.\n> > > To counter this, Bob has to bid up its version higher.\n> > >\n> > > As the timeout approaches, Alice can bump up its fee until it is just 1 satoshi short of the total fund.\n> > > It is rational for Alice to do so since at timeout, it can expect to lose the entire fund.\n> > > In order for Bob to win, it has to beat that fee, at which point it equals or exceeds the total fund, and miners get the total fund (or more).\n> > >\n> > > Knowing this end-point, rational Bob will not even begin this game.\n> > >\n> > > I think this research considers these two endpoints to be distinct:\n> > >\n> > > * Bob misbehaves and the entire fund is punished by miners, leaving miners with the fund and Alice and Bob without money (MAD-HTLC).\n> > > * Bob misbehaves, Alice counters, and the ensuing fee war leads to fees approaching the fund value, leaving miners with the fund and Alice and Bob without money (standard HTLC).\n> > >\n> > > But in practice I think both endpoints are essentially equivalent.\n> >\n> > These are not the same scenario, since in HTLC there is a race between Alice and Bob. Alice might not wish to pay the full HTLC amount once she sees Bob is trying to cheat. She could wait until close to the timeout so as to reduce the time Bob can respond. Of course Bob would do the same. So this is an actual race, and Bob takes no risk since his payment is all from the HTLC amount. Mutual destruction is only assured under certain assumptions in HTLC. MAD-HTLC achieves security without relying on such assumptions.\u00a0\n\nAlice already knows that a rational Bob (who it might never interact with again in the future) will take the funds at the locktime L.\nThus, Alice can offer, at time L - 1, the entire fund, minus 1 satoshi, to miners.\nAlice getting 1 satoshi versus 0 satoshi is a no-brainer for Alice.\nBob can only  beat this offer by offering the entire fund, at which point Bob earns nothing and it performed an attack for no benefit.\n\nI and some number of Lightning devs consider this to be sufficient disincentive to Bob not attacking in the first place.\n\n\n> > \u00a0\n> >\n> > > --\n> > >\n> > > What MAD-HTLC can do would be to make different claims:\n> > >\n> > > * Inputs:\n> > > \u00a0 * Bob 1 BTC - HTLC amount\n> > > \u00a0 * Bob 1 BTC - Bob fidelity bond\n> > >\n> > > * Cases:\n> > > \u00a0 * Alice reveals hashlock at any time:\n> > > \u00a0 \u00a0 * 1 BTC goes to Alice\n> > > \u00a0 \u00a0 * 1 BTC goes to Bob (fidelity bond refund)\n> > > \u00a0 * Bob reveals bob-hashlock after time L:\n> > > \u00a0 \u00a0 * 2 BTC goes to Bob (HTLC refund + fidelity bond refund)\n> > > \u00a0 * Bob cheated, anybody reveals both hashlock and bob-hashlock:\n> > > \u00a0 \u00a0 * 2 BTC goes to miner\n> > >\n> > > This is an actual improvement over HTLC: Bob misbehavior leads to loss of the fidelity bond.\n> > > The above cases can be assured by requiring both Alice and Bob to sign in the alice-hashlock branch, so that the splitting of the fund is enforced, and SegWit signing so that the dependent transaction is signed before the HTLC-funding transaction is.\n> > > It can also be implemented with `OP_CHECKTEMPLATEVERIFY`.\n> >\n> > The cases you present are exactly how MAD-HTLC works. It comprises two contracts (UTXOs):\n> > * Deposit (holding the intended HTLC tokens), with three redeem paths:\n> > \u00a0 \u00a0 - Alice (signature), with preimage \"A\", no timeout\n> > \u00a0 \u00a0 - Bob (signature), with preimage \"B\", timeout T\n> > \u00a0 \u00a0 - Any entity (miner), with both preimages \"A\" and \"B\", no timeout\n> > * Collateral (the fidelity bond, doesn't have to be of the same amount)\n> > \u00a0 \u00a0 - Bob (signature), no preimage, timeout T\n> > \u00a0 \u00a0 - Any entity (miner), with both preimages \"A\" and \"B\", timeout T\n> >\n> > Only Bob initially knows preimage \"B\", and is required to reveal it if he wishes to get the Deposit tokens.\n> >\n> > Consider first the case where Alice publishes preimage \"A\": Bob can safely publish preimage \"B\" and get both the Deposit and Collateral tokens after the timeout.\n> > Now, consider the case where Alice does not publish preimage \"A\": If Bob publishes preimage \"B\" he gets nothing (and so does Alice - this is the mutual assured destruction), and if he doesn't, he gets the Collateral tokens.\n\nThank you for the clarification.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Nadav Ivgi",
                "date": "2020-06-25T03:26:41",
                "message_text_only": "> I and some number of Lightning devs consider this to be sufficient\ndisincentive to Bob not attacking in the first place.\n\nAn additional disincentive could be introduced in the form of bribery\nproofs for failed attempts.\n\nIf we assume that \"honest\" users of the LN protocol won't reveal their\ntimelocked transactions before reaching the timelock expiry (they shouldn't\nanyway because standard full node implementations won't relay them), we can\nprove that Bob attempted bribery and failed to an outside observer by\nshowing Bob's signed timelocked transaction, spending an output that was in\nreality spent by a different transaction prior to the locktime expiry,\nwhich should not be possible if Bob had waited.\n\nThese proofs would be gossiped, and lightning network participants could\nchoose not to peer with Bob when they see them. This might require some\nsort of a scoring/reputation scheme that makes it harder for Bob to attack\nwith new throw-away identities to be effective. (i.e. limiting your\nexposure to peers to some BTC amount based on their historical public\nchannels records, using fidelity bonds, etc.)\n\nBob could still send these bribery transactions privately to selected\nminers, but not making them public would greatly reduce the participating\nminers' confidence that there is enough participating hashpower for the\nattack to be profitable.\n\nNadav\n\nOn Thu, Jun 25, 2020 at 4:38 AM ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Stanga et al,\n>\n>\n> > > Hi ZmnSCPxj,\n> > >\n> > > Thank you for taking the time to respond, these are very good points.\n> Responses inline.\n> > >\n> > > On Tue, Jun 23, 2020 at 12:48 PM ZmnSCPxj <ZmnSCPxj at protonmail.com>\n> wrote:\n> > >\n> > > > Good morning Itay, Ittay, and Matan,\n> > > >\n> > > > I believe an unstated assumption in Bitcoin is that miners are\n> short-sighted.\n> > > >\n> > > > The reasoning for this assumption is:\n> > > >\n> > > > * Deployment of new mining hardware controlled by others may occur\n> at any time you do not control.\n> > > >   * Thus, any transactions you leave on the table are potentially\n> taken by somebody else and not by you.\n> > > >   * Sudden changes in hashpower distribution may reduce your\n> expected future earnings, so any future theoretical earnings should be\n> discounted (*in addition to* expected return-on-investment on getting money\n> you can invest *now*).\n> > >\n> > > Our analysis assumes constant difficulty, i.e., no significant changes\n> of the miners set. Indeed, hash-rate changes typically occur at a much\n> larger granularity than your average HTLC timeout. For instance, we noticed\n> plenty of lightning nodes use timeouts of a day. So, we do not consider\n> optimization at infinity, just a day ahead, and within this time frame all\n> the factors you mentioned are not expected to dramatically change.\n> > >\n> > > That being said, it would be interesting to analyze the effect of\n> miners joining during the HTLC duration. Intuitively, this shouldn\u2019t affect\n> the results, as those new miners have the same incentive to wait for the\n> higher-paying tx.\n>\n> We already know that hashrate tends to trend upwards, and that we do not\n> expect hashrate to fall except for occasional transients.\n>\n> The expectation is not that new miners have different incentives.\n> Instead, the expectation is that current miners discount future possible\n> gains because in the future, they expect to have less hashrate share than\n> right now.\n>\n> The only trustless way for Bob to bribe miners into deferring Alice tx is\n> to attach the bribe to the future confirmation of the Bob tx, thus Bob is\n> offering future-coins, not present-coins like Alice can offer, and the fact\n> that miners expect an overall uptrend in total hashrate (leading to an\n> overall downtrend in their hashrate share) means that miners discount the\n> Bob offered future-coins.\n> The discounting is proportional to the time delay involved, as a larger\n> delay implies greater reduction in hashrate share.\n>\n> This discounting is, again, *in addition to* natural discounting a.k.a. \"I\n> will gladly pay you Thursday for a hamburger today\", the hamburger seller\n> will want some pretty stiff assurances plus a bigger payment on Thursday\n> for giving you a hamburger today, due to expected returns on investment.\n>\n>\n> > >\n> > >\n> > > > It also strikes me that, in a world with RBF and CPFP, the same\n> endpoint (i.e. miners earn the entire fund of the HTLC) is achieved by\n> existing HTLCs, without the additional branch and script opcodes needed by\n> MAD-HTLC.\n> > > > For example, if an HTLC is confirmed but the hashlock-claiming\n> transaction is not being confirmed (because miners are holding it up\n> because Bob is offering a much higher fee in the future for the\n> timelock-claiming transaction), then Alice can, regardless of the reason\n> why it is not being confirmed, bump up the fee with RBF or CPFP.\n> > > >\n> > > > If the fee bump offered by Alice is sufficiently large, then miners\n> will start re-preferring the Alice hashlock transaction.\n> > > > To counter this, Bob has to bid up its version higher.\n> > > >\n> > > > As the timeout approaches, Alice can bump up its fee until it is\n> just 1 satoshi short of the total fund.\n> > > > It is rational for Alice to do so since at timeout, it can expect to\n> lose the entire fund.\n> > > > In order for Bob to win, it has to beat that fee, at which point it\n> equals or exceeds the total fund, and miners get the total fund (or more).\n> > > >\n> > > > Knowing this end-point, rational Bob will not even begin this game.\n> > > >\n> > > > I think this research considers these two endpoints to be distinct:\n> > > >\n> > > > * Bob misbehaves and the entire fund is punished by miners, leaving\n> miners with the fund and Alice and Bob without money (MAD-HTLC).\n> > > > * Bob misbehaves, Alice counters, and the ensuing fee war leads to\n> fees approaching the fund value, leaving miners with the fund and Alice and\n> Bob without money (standard HTLC).\n> > > >\n> > > > But in practice I think both endpoints are essentially equivalent.\n> > >\n> > > These are not the same scenario, since in HTLC there is a race between\n> Alice and Bob. Alice might not wish to pay the full HTLC amount once she\n> sees Bob is trying to cheat. She could wait until close to the timeout so\n> as to reduce the time Bob can respond. Of course Bob would do the same. So\n> this is an actual race, and Bob takes no risk since his payment is all from\n> the HTLC amount. Mutual destruction is only assured under certain\n> assumptions in HTLC. MAD-HTLC achieves security without relying on such\n> assumptions.\n>\n> Alice already knows that a rational Bob (who it might never interact with\n> again in the future) will take the funds at the locktime L.\n> Thus, Alice can offer, at time L - 1, the entire fund, minus 1 satoshi, to\n> miners.\n> Alice getting 1 satoshi versus 0 satoshi is a no-brainer for Alice.\n> Bob can only  beat this offer by offering the entire fund, at which point\n> Bob earns nothing and it performed an attack for no benefit.\n>\n> I and some number of Lightning devs consider this to be sufficient\n> disincentive to Bob not attacking in the first place.\n>\n>\n> > >\n> > >\n> > > > --\n> > > >\n> > > > What MAD-HTLC can do would be to make different claims:\n> > > >\n> > > > * Inputs:\n> > > >   * Bob 1 BTC - HTLC amount\n> > > >   * Bob 1 BTC - Bob fidelity bond\n> > > >\n> > > > * Cases:\n> > > >   * Alice reveals hashlock at any time:\n> > > >     * 1 BTC goes to Alice\n> > > >     * 1 BTC goes to Bob (fidelity bond refund)\n> > > >   * Bob reveals bob-hashlock after time L:\n> > > >     * 2 BTC goes to Bob (HTLC refund + fidelity bond refund)\n> > > >   * Bob cheated, anybody reveals both hashlock and bob-hashlock:\n> > > >     * 2 BTC goes to miner\n> > > >\n> > > > This is an actual improvement over HTLC: Bob misbehavior leads to\n> loss of the fidelity bond.\n> > > > The above cases can be assured by requiring both Alice and Bob to\n> sign in the alice-hashlock branch, so that the splitting of the fund is\n> enforced, and SegWit signing so that the dependent transaction is signed\n> before the HTLC-funding transaction is.\n> > > > It can also be implemented with `OP_CHECKTEMPLATEVERIFY`.\n> > >\n> > > The cases you present are exactly how MAD-HTLC works. It comprises two\n> contracts (UTXOs):\n> > > * Deposit (holding the intended HTLC tokens), with three redeem paths:\n> > >     - Alice (signature), with preimage \"A\", no timeout\n> > >     - Bob (signature), with preimage \"B\", timeout T\n> > >     - Any entity (miner), with both preimages \"A\" and \"B\", no timeout\n> > > * Collateral (the fidelity bond, doesn't have to be of the same amount)\n> > >     - Bob (signature), no preimage, timeout T\n> > >     - Any entity (miner), with both preimages \"A\" and \"B\", timeout T\n> > >\n> > > Only Bob initially knows preimage \"B\", and is required to reveal it if\n> he wishes to get the Deposit tokens.\n> > >\n> > > Consider first the case where Alice publishes preimage \"A\": Bob can\n> safely publish preimage \"B\" and get both the Deposit and Collateral tokens\n> after the timeout.\n> > > Now, consider the case where Alice does not publish preimage \"A\": If\n> Bob publishes preimage \"B\" he gets nothing (and so does Alice - this is the\n> mutual assured destruction), and if he doesn't, he gets the Collateral\n> tokens.\n>\n> Thank you for the clarification.\n>\n> Regards,\n> ZmnSCPxj\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200625/86ee66c8/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-25T04:04:09",
                "message_text_only": "Good morning Nadav,\n\n> > I and some number of Lightning devs consider this to be sufficient disincentive to Bob not attacking in the first place.\n>\n> An additional disincentive could be introduced in the form of bribery proofs for failed attempts.\n>\n> If we assume that \"honest\" users of the LN protocol won't reveal their timelocked transactions before reaching the timelock expiry (they shouldn't anyway because standard full node implementations won't relay them), we can prove that Bob attempted bribery and failed to an outside observer by showing Bob's signed timelocked transaction, spending an output that was in reality spent by a different transaction prior to the locktime expiry, which should not be possible if Bob had waited.\n\n\nUnfortunately this could be subject to an inversion of this attack.\n\nAlice can wait for the timelock to expire, then bribe miners to prevent confirmation of the Bob timelocked transaction, getting the Alice hashlocked transaction confirmed.\n\nNow of course you do mention \"prior to the locktime expiry\" but there is now risk at around locktime.\n\nParticularly, \"natural\" orphaned blocks and short-term chainsplits can exist.\nBob might see that the locktime has arrived and broadcast the signed timelocked transaction, then Alice sees the locktime has not yet arrived (due to short-term chainsplits/propagation delays) and broadcast the signed hashlocked transaction, then in the end the Alice side of the short-term chainsplit is what solidifies into reality due to random chance on which miner wins which block.\nThen Bob can now be accused of bribery, even though it acted innocently; it broadcasted the timelock branch due to a natural chainsplit but Alice hashlocked branch got confirmed.\n\nAdditional complications can be added on top to help mitigate this edge case but more complex == worse in general.\nFor example it could \"prior to locktime expiry\" can ignore a few blocks before the actual timelock, but this might allow Bob to mount the attack by initiating its bribery behavior earlier by those few blocks.\n\nFinally, serious attackers would just use new pseudonyms, the important thing is to make pseudonyms valuable and costly to lose, so it is considered sufficient that LN nodes need to have some commitment to the LN in the form of actual channels (which are valuable, potentially money-earning constructs, and costly to set up).\n\nOther HTLC-using systems, such as the \"SwapMarket\" being proposed by Chris Belcher, could use similar disincentivizing; I know Chris is planning a fidelity bond system for SwapMarket makers, for example, which would mimic the properties of LN channels (costly to set up, money-earning).\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Nadav Ivgi",
                "date": "2020-06-25T04:35:51",
                "message_text_only": "Hi ZmnSCPxj,\n\nYou are of course correct. I had considered the effect of reorgs, but the\nemail seemed to be getting too lengthy to mention that too.\n\nYou would need a few spare blocks in which Bob won't be accused of bribery\nas a safety margin, which does reduce the time frame in which Alice can get\nher transaction confirmed in order to have a valid bribery fraud. This\nseems workable if the time frame was long enough (over a few hours should\nbe sufficient, assuming we consider reorgs of over 3-4 blocks to be\nunlikely), but could indeed be problematic if the time frame is already\nshort to begin with.\n\nNadav\n\nOn Thu, Jun 25, 2020 at 7:04 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Nadav,\n>\n> > > I and some number of Lightning devs consider this to be sufficient\n> disincentive to Bob not attacking in the first place.\n> >\n> > An additional disincentive could be introduced in the form of bribery\n> proofs for failed attempts.\n> >\n> > If we assume that \"honest\" users of the LN protocol won't reveal their\n> timelocked transactions before reaching the timelock expiry (they shouldn't\n> anyway because standard full node implementations won't relay them), we can\n> prove that Bob attempted bribery and failed to an outside observer by\n> showing Bob's signed timelocked transaction, spending an output that was in\n> reality spent by a different transaction prior to the locktime expiry,\n> which should not be possible if Bob had waited.\n>\n>\n> Unfortunately this could be subject to an inversion of this attack.\n>\n> Alice can wait for the timelock to expire, then bribe miners to prevent\n> confirmation of the Bob timelocked transaction, getting the Alice\n> hashlocked transaction confirmed.\n>\n> Now of course you do mention \"prior to the locktime expiry\" but there is\n> now risk at around locktime.\n>\n> Particularly, \"natural\" orphaned blocks and short-term chainsplits can\n> exist.\n> Bob might see that the locktime has arrived and broadcast the signed\n> timelocked transaction, then Alice sees the locktime has not yet arrived\n> (due to short-term chainsplits/propagation delays) and broadcast the signed\n> hashlocked transaction, then in the end the Alice side of the short-term\n> chainsplit is what solidifies into reality due to random chance on which\n> miner wins which block.\n> Then Bob can now be accused of bribery, even though it acted innocently;\n> it broadcasted the timelock branch due to a natural chainsplit but Alice\n> hashlocked branch got confirmed.\n>\n> Additional complications can be added on top to help mitigate this edge\n> case but more complex == worse in general.\n> For example it could \"prior to locktime expiry\" can ignore a few blocks\n> before the actual timelock, but this might allow Bob to mount the attack by\n> initiating its bribery behavior earlier by those few blocks.\n>\n> Finally, serious attackers would just use new pseudonyms, the important\n> thing is to make pseudonyms valuable and costly to lose, so it is\n> considered sufficient that LN nodes need to have some commitment to the LN\n> in the form of actual channels (which are valuable, potentially\n> money-earning constructs, and costly to set up).\n>\n> Other HTLC-using systems, such as the \"SwapMarket\" being proposed by Chris\n> Belcher, could use similar disincentivizing; I know Chris is planning a\n> fidelity bond system for SwapMarket makers, for example, which would mimic\n> the properties of LN channels (costly to set up, money-earning).\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200625/b7933c5a/attachment-0001.html>"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2020-06-25T13:12:56",
                "message_text_only": "Good morning list,\n\nThis is an interesting and simple idea, thanks for sharing this paper!\n\nHowever I think there are a couple of important issues (but it could be me\nmisunderstanding):\n\n* the assumption that the mempool is a shared resource is flawed: it's\nentirely possible\n  to have very different mempools in different areas of the network, for a\npotentially long\n  period of time (see the RBF pinning thread [1]), and an attacker can\nleverage this fact\n* a corollary is that Bob may not know that Alice has published her\ntransaction, and will\n  end up publishing his timeout tx, unknowingly giving the two preimages to\nthe miners\n* a corollary of that is a very unhealthy incentive to miners, when they\nreceive an HTLC\n  success tx, to always wait for the timeout before confirming the\ntransaction, in hope that\n  they'll receive the second preimage and will be able to claim the funds\nfor themselves\n  (whereas currently they don't gain anything by waiting before confirming\nthese txs)\n\nTo be fair the paper states that it doesn't address issues of malicious\nminers or an attacker\ncolluding with a miner, but I think that even honest miners now have an\nunhealthy incentive\nregarding htlc success confirmation.\n\nLet me know if I misunderstood something, or if you have ideas on how to\nexplore that\nthreat model in the future.\n\nCheers,\nBastien\n\n[1]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html\n\n\n\nLe jeu. 25 juin 2020 \u00e0 14:45, Nadav Ivgi via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> Hi ZmnSCPxj,\n>\n> You are of course correct. I had considered the effect of reorgs, but the\n> email seemed to be getting too lengthy to mention that too.\n>\n> You would need a few spare blocks in which Bob won't be accused of bribery\n> as a safety margin, which does reduce the time frame in which Alice can get\n> her transaction confirmed in order to have a valid bribery fraud. This\n> seems workable if the time frame was long enough (over a few hours should\n> be sufficient, assuming we consider reorgs of over 3-4 blocks to be\n> unlikely), but could indeed be problematic if the time frame is already\n> short to begin with.\n>\n> Nadav\n>\n> On Thu, Jun 25, 2020 at 7:04 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n>> Good morning Nadav,\n>>\n>> > > I and some number of Lightning devs consider this to be sufficient\n>> disincentive to Bob not attacking in the first place.\n>> >\n>> > An additional disincentive could be introduced in the form of bribery\n>> proofs for failed attempts.\n>> >\n>> > If we assume that \"honest\" users of the LN protocol won't reveal their\n>> timelocked transactions before reaching the timelock expiry (they shouldn't\n>> anyway because standard full node implementations won't relay them), we can\n>> prove that Bob attempted bribery and failed to an outside observer by\n>> showing Bob's signed timelocked transaction, spending an output that was in\n>> reality spent by a different transaction prior to the locktime expiry,\n>> which should not be possible if Bob had waited.\n>>\n>>\n>> Unfortunately this could be subject to an inversion of this attack.\n>>\n>> Alice can wait for the timelock to expire, then bribe miners to prevent\n>> confirmation of the Bob timelocked transaction, getting the Alice\n>> hashlocked transaction confirmed.\n>>\n>> Now of course you do mention \"prior to the locktime expiry\" but there is\n>> now risk at around locktime.\n>>\n>> Particularly, \"natural\" orphaned blocks and short-term chainsplits can\n>> exist.\n>> Bob might see that the locktime has arrived and broadcast the signed\n>> timelocked transaction, then Alice sees the locktime has not yet arrived\n>> (due to short-term chainsplits/propagation delays) and broadcast the signed\n>> hashlocked transaction, then in the end the Alice side of the short-term\n>> chainsplit is what solidifies into reality due to random chance on which\n>> miner wins which block.\n>> Then Bob can now be accused of bribery, even though it acted innocently;\n>> it broadcasted the timelock branch due to a natural chainsplit but Alice\n>> hashlocked branch got confirmed.\n>>\n>> Additional complications can be added on top to help mitigate this edge\n>> case but more complex == worse in general.\n>> For example it could \"prior to locktime expiry\" can ignore a few blocks\n>> before the actual timelock, but this might allow Bob to mount the attack by\n>> initiating its bribery behavior earlier by those few blocks.\n>>\n>> Finally, serious attackers would just use new pseudonyms, the important\n>> thing is to make pseudonyms valuable and costly to lose, so it is\n>> considered sufficient that LN nodes need to have some commitment to the LN\n>> in the form of actual channels (which are valuable, potentially\n>> money-earning constructs, and costly to set up).\n>>\n>> Other HTLC-using systems, such as the \"SwapMarket\" being proposed by\n>> Chris Belcher, could use similar disincentivizing; I know Chris is planning\n>> a fidelity bond system for SwapMarket makers, for example, which would\n>> mimic the properties of LN channels (costly to set up, money-earning).\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200625/845a11e0/attachment.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2020-06-28T16:41:32",
                "message_text_only": "On Tue, Jun 23, 2020 at 03:47:56PM +0300, Stanga via bitcoin-dev wrote:\n> On Tue, Jun 23, 2020 at 12:48 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> > * Inputs:\n> >   * Bob 1 BTC - HTLC amount\n> >   * Bob 1 BTC - Bob fidelity bond\n> >\n> > * Cases:\n> >   * Alice reveals hashlock at any time:\n> >     * 1 BTC goes to Alice\n> >     * 1 BTC goes to Bob (fidelity bond refund)\n> >   * Bob reveals bob-hashlock after time L:\n> >     * 2 BTC goes to Bob (HTLC refund + fidelity bond refund)\n> >   * Bob cheated, anybody reveals both hashlock and bob-hashlock:\n> >     * 2 BTC goes to miner\n> >\n> > [...]\n> \n> The cases you present are exactly how MAD-HTLC works. It comprises two\n> contracts (UTXOs):\n> * Deposit (holding the intended HTLC tokens), with three redeem paths:\n>     - Alice (signature), with preimage \"A\", no timeout\n>     - Bob (signature), with preimage \"B\", timeout T\n>     - Any entity (miner), with both preimages \"A\" and \"B\", no timeout\n> * Collateral (the fidelity bond, doesn't have to be of the same amount)\n>     - Bob (signature), no preimage, timeout T\n>     - Any entity (miner), with both preimages \"A\" and \"B\", timeout T\n\nI'm not these are safe if your counterparty is a miner.  Imagine Bob\noffers Alice a MAD-HTLC.  Alice knows the payment preimage (\"preimage\nA\").  Bob knows the bond preimage (\"preimage B\") and he's the one making\nthe payment and offering the bond.\n\nAfter receiving the HTLC, Alice takes no action on it, so the timelock\nexpires.  Bob publicly broadcasts the refund transaction with the bond\npreimage.  Unbeknownst to Bob, Alice is actually a miner and she uses her\npre-existing knowledge of the payment preimage plus her received\nknowledge of the bond preimage to privately attempt mining a transaction\nthat pays her both the payment (\"deposit\") and the bond (\"collateral\").\n\nAssuming Alice is a non-majority miner, she isn't guaranteed to\nsucceed---her chance of success depends on her percentage of the network\nhashrate and how much fee Bob paid to incentivize other miners to\nconfirm his refund transaction quickly.  However, as long as Alice has a\nnon-trivial amount of hashrate, she will succeed some percentage of the\ntime in executing this type of attack.  Any of her theft attempts that\nfail will leave no public trace, perhaps lulling users into a false\nsense of security.\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200628/eab02c90/attachment.sig>"
            },
            {
                "author": "David A. Harding",
                "date": "2020-06-28T12:15:17",
                "message_text_only": "On Tue, Jun 23, 2020 at 09:41:56AM +0300, Stanga via bitcoin-dev wrote:\n> Hi all,\n> \n> We'd like to bring to your attention our recent result concerning HTLC.\n> Here are the technical report and a short post outlining the main points:\n> \n> * https://arxiv.org/abs/2006.12031\n> * https://ittayeyal.github.io/2020-06-22-mad-htlc\n\nThank you for your interesting research!  Further quotes are from your\npaper:\n\n>      Myopic Miners: This bribery attack relies on all miners\n> being rational, hence considering their utility at game conclu-\n> sion instead of myopically optimizing for the next block. If\n> a portion of the miners are myopic and any of them gets to\n> create a block during the first T \u2212 1 rounds, that miner would\n> include Alice\u2019s transaction and Bob\u2019s bribery attempt would\n> have failed.\n>    In such scenarios the attack succeeds only with a certain\n> probability \u2013 only if a myopic miner does not create a block\n> in the first T \u2212 1 rounds. The success probability therefore\n> decreases exponentially in T . Hence, to incentivize miners\n> to support the attack, Bob has to increase his offered bribe\n> exponentially in T .\n\nThis is a good abstract description, but I think it might be useful for\nreaders of this list who are wondering about the impact of this attack\nto put it in concrete terms.  I'm bad at statistics, but I think the\nprobability of bribery failing (even if Bob offers a bribe with an\nappropriately high feerate) is 1-exp(-b*h) where `b` is the number of\nblocks until timeout and `h` is a percentage of the hashrate controlled\nby so-called myopic miners.  Given that, here's a table of attack\nfailure probabilities:\n\n                     \"Myopic\" hashrate\n     B          1%      10%     33%     50%\n     l       +---------------------------------\n     o  6    |  5.82%   45.12%  86.19%  95.02%\n     c  36   |  30.23%  97.27%  100.00% 100.00%\n     k  144  |  76.31%  100.00% 100.00% 100.00%\n     s  288  |  94.39%  100.00% 100.00% 100.00%\n\nSo, if I understand correctly, even a small amount of \"myopic\" hashrate\nand long timeouts---or modest amounts of hashrate and short\ntimeouts---makes this attack unlikely to succeed (and, even in the cases\nwhere it does succeed, Bob will have to offer a very large bribe to\ncompensate \"rational\" miners for their high chance of losing out on\ngaining any transaction fees).\n\nAdditionally, I think there's the problem of measuring the distribution\nof \"myopic\" hashrate versus \"rational\" hashrate.  \"Rational\" miners need\nto do this in order to ensure they only accept Bob's timelocked bribe if\nit pays a sufficiently high fee.  However, different miners who try to\ntrack what bribes were relayed versus what transactions got mined may\ncome to different conclusions about the relative hashrate of \"myopic\"\nminers, leading some of them to require higher bribes, which may lead\nthose those who estimated a lower relative hash rate to assume the rate\nof \"myopic\" mining in increasing, producing a feedback loop that makes\nother miners think the rate of \"myopic\" miners is increasing.  (And that\nassumes none of the miners is deliberately juking the stats to mislead\nits competitors into leaving money on the table.)\n\nBy comparison, \"myopic\" miners don't need to know anything special about\nthe past.  They can just take the UTXO set, block height, difficulty\ntarget, and last header hash and mine whatever available transactions\nwill give them the greatest next-block revenue.\n\nIn conclusion, I think: \n\n1. Given that all known Bitcoin miners today are \"myopic\", there's no\n   short-term issue (to be clear, you didn't claim there was).\n\n2. A very large percentage of the hashrate would have to implement\n   \"rational\" mining for the attack to become particularly effective.\n   Hopefully, we'd learn about this as it was happening and could adapt\n   before it became an issue.\n\n3. So-called rational mining is probably a lot harder to implement\n   effectively than just 150 loc in Python; it probably requires a lot\n   more careful incentive analysis than just looking at HTLCs.[1]\n\n4. Although I can't offer a proof, my intuition says that \"myopic\"\n   mining is probably very close to optimal in the current subsidy-fee\n   regime.  Optimizing transaction selection only for the next block has\n   already proven to be quite challenging to both software and protocol\n   developers[2] so I can't imagine how much work it would take to build\n   something that effectively optimizes for an unbounded future.  In\n   short, I think so-called myopic mining might actually be the most\n   rational mining we're capable of.\n\nNevertheless, I think your results are interesting and that MAD-HTLC is\na useful tool that might be particularly desirable in contracts that\ninvolve especially high value or especially short timeouts (perhaps\nasset swaps or payment channels used by traders?).  Thank you again for\nposting!\n\n-Dave\n\n[1] For example, your paper says \"[...] the bribing cost required to\n    attack HTLC is independent in T, meaning that simply increasing the\n    timeout does contribute to HTLC\u2019s security.\"  This implies that\n    Alice, after she sees Bob's attempted bribe, could offer a counter\n    bribe that spends all output value to fees (the scorched earth\n    policy ZmnSCPxj describes) with a timelock set to the maximum\n    single-transaction value (block 500 million, due to be mined in\n    about 10 millennia, give or take a few centuries) and miners would\n    hold on to it until then, never mining Bob's lower-feerate bribe.\n    That's ridiculous, but it's understandable in your paper because\n    you're mainly analyzing time periods so short that you don't need to\n    worry much about the time-value-of-money discount (also mentioned by\n    ZmnSCPxj); however, your paper also says that your Python\n    implementation uses the same formulas in your paper to determine\n    whether or not a bribe will profitable, which would obviously be\n    wrong for a 10,000-year timelock.\n\n[2] See the never ending discussions on this list and Lightning-Dev\n    about ancestor mining package size/depth limits and BIP125 opt-in\n    RBF rule #3.\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200628/84e0a79b/attachment.sig>"
            },
            {
                "author": "Tejaswi Nadahalli",
                "date": "2020-06-29T11:57:52",
                "message_text_only": "On Sun, Jun 28, 2020 at 2:16 PM David A. Harding via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> So, if I understand correctly, even a small amount of \"myopic\" hashrate\n> and long timeouts---or modest amounts of hashrate and short\n> timeouts---makes this attack unlikely to succeed (and, even in the cases\n> where it does succeed, Bob will have to offer a very large bribe to\n> compensate \"rational\" miners for their high chance of losing out on\n> gaining any transaction fees).\n>\n\nWe were separately working on a similar problem, and wrote a paper as well:\nhttps://eprint.iacr.org/2020/774 *\n\nWe look at the Alice's-Fees/Bob's-Bribe ratio. We also look at \"strong\" and\n\"weak\" miners in this context. If a miner is weak, their hash-rate is lower\nthan this fees/bribe ratio. If they are strong, their hash rate is more\nthan this fees/bribe ratio. In this setting, it turns out that if there are\nonly strong miners, Bob will win. If there is at least one weak miner,\nAlice has to win, given a reasonable timeout value. We found it awesome\nthat lightning has a parameter called \"channel-reserve_satoshis\", which\ndirectly helps in countering this bribe by giving Alice some leeway in fees.\n\n* Ph.D students want to write papers, unfortunately.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200629/0825c166/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-29T18:05:10",
                "message_text_only": "Good morning Dave, et al.,\n\n\n> >      Myopic Miners: This bribery attack relies on all miners\n> >\n> >\n> > being rational, hence considering their utility at game conclu-\n> > sion instead of myopically optimizing for the next block. If\n> > a portion of the miners are myopic and any of them gets to\n> > create a block during the first T \u2212 1 rounds, that miner would\n> > include Alice\u2019s transaction and Bob\u2019s bribery attempt would\n> > have failed.\n> > In such scenarios the attack succeeds only with a certain\n> > probability \u2013 only if a myopic miner does not create a block\n> > in the first T \u2212 1 rounds. The success probability therefore\n> > decreases exponentially in T . Hence, to incentivize miners\n> > to support the attack, Bob has to increase his offered bribe\n> > exponentially in T .\n>\n> This is a good abstract description, but I think it might be useful for\n> readers of this list who are wondering about the impact of this attack\n> to put it in concrete terms. I'm bad at statistics, but I think the\n> probability of bribery failing (even if Bob offers a bribe with an\n> appropriately high feerate) is 1-exp(-b*h) where `b` is the number of\n> blocks until timeout and `h` is a percentage of the hashrate controlled\n> by so-called myopic miners. Given that, here's a table of attack\n> failure probabilities:\n>\n> \"Myopic\" hashrate\n> B 1% 10% 33% 50%\n> l +---------------------------------\n> o 6 | 5.82% 45.12% 86.19% 95.02%\n> c 36 | 30.23% 97.27% 100.00% 100.00%\n> k 144 | 76.31% 100.00% 100.00% 100.00%\n> s 288 | 94.39% 100.00% 100.00% 100.00%\n>\n> So, if I understand correctly, even a small amount of \"myopic\" hashrate\n> and long timeouts---or modest amounts of hashrate and short\n> timeouts---makes this attack unlikely to succeed (and, even in the cases\n> where it does succeed, Bob will have to offer a very large bribe to\n> compensate \"rational\" miners for their high chance of losing out on\n> gaining any transaction fees).\n>\n> Additionally, I think there's the problem of measuring the distribution\n> of \"myopic\" hashrate versus \"rational\" hashrate. \"Rational\" miners need\n> to do this in order to ensure they only accept Bob's timelocked bribe if\n> it pays a sufficiently high fee. However, different miners who try to\n> track what bribes were relayed versus what transactions got mined may\n> come to different conclusions about the relative hashrate of \"myopic\"\n> miners, leading some of them to require higher bribes, which may lead\n> those those who estimated a lower relative hash rate to assume the rate\n> of \"myopic\" mining in increasing, producing a feedback loop that makes\n> other miners think the rate of \"myopic\" miners is increasing. (And that\n> assumes none of the miners is deliberately juking the stats to mislead\n> its competitors into leaving money on the table.)\n\nA thought occurs to me, that we should not be so hasty to call non-myopic strategy \"rational\".\nLet us consider instead \"myopic\" and \"non-myopic\" strategies in a population of miners.\n\nI contend that in a mixed population of \"myopic\" and \"non-myopic\" miners, the myopic strategy is dominant in the game-theoretic sense, i.e. it might earn less if all miners were myopic, but if most miners were non-myopic and a small sub-population were myopic and there was no easy way for non-myopic miners to punish myopic miners, then the myopic miners will end up earning more (at the expense of the non-myopic miners) and dominate over non-myopic miners.\nSuch dominant result should prevent non-myopic miners from arising in the first place.\n\nThe dominance results from the fact that by accepting the Alice transaction, myopic miners are effectively deducting the fees earned by non-myopic miners by preventing the Bob transaction from being confirmable.\nOn the other hand, even if the non-myopic miners successfully defer the Alice transaction, the myopic miner still has a chance equal to its hashrate of getting the Bob transaction and its attached fee.\nThus, myopic miners impose costs on their non-myopic competitors that non-myopic miners cannot impose their myopic competitors.\nIf even one myopic miner successfully gets the Alice transaction confirmed, all the non-myopic miners lose out on the Bob bribe fee.\n\nSo I think the myopic strategy will be dominant and non-myopic miners will not arise in the first place.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Stanga",
                "date": "2020-06-30T06:28:58",
                "message_text_only": "Hi ZmnSCPxj,\n\nThat's a good point. Basically there are two extremes, if everyone is\nnon-myoptic (rational), they should wait even for a small fee (our mad-htlc\nresult), and if everyone else is myopic (rational), a non-myopic miner\nshould only wait for a fairly large fee, depending on miner sizes and the\ntimeout -- this is analyzed in an earlier paper by Winzer, Herd and Faust\n[1]. In a mixed situation the calculation becomes slightly more involved,\nbut qualitatively it's closer to the Wizner et al. result, namely the bribe\nshould grow exponentially with the timeout, which is bad for the attacker.\nBut mad-htlc avoids myopic assumptions, allowing you to keep your contracts\nsafe either way.\n\nBest,\nIttay\n\n[1] F. Winzer, B. Herd and S. Faust, \"Temporary Censorship Attacks in the\nPresence of Rational Miners\n<https://ieeexplore.ieee.org/abstract/document/8802377>,\" *2019 IEEE\nEuropean Symposium on Security and Privacy Workshops (EuroS&PW)*,\nStockholm, Sweden, 2019, pp. 357-366, doi: 10.1109/EuroSPW.2019.00046.\n\nOn Mon, Jun 29, 2020 at 9:05 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Dave, et al.,\n>\n>\n> > >      Myopic Miners: This bribery attack relies on all miners\n> > >\n> > >\n> > > being rational, hence considering their utility at game conclu-\n> > > sion instead of myopically optimizing for the next block. If\n> > > a portion of the miners are myopic and any of them gets to\n> > > create a block during the first T \u2212 1 rounds, that miner would\n> > > include Alice\u2019s transaction and Bob\u2019s bribery attempt would\n> > > have failed.\n> > > In such scenarios the attack succeeds only with a certain\n> > > probability \u2013 only if a myopic miner does not create a block\n> > > in the first T \u2212 1 rounds. The success probability therefore\n> > > decreases exponentially in T . Hence, to incentivize miners\n> > > to support the attack, Bob has to increase his offered bribe\n> > > exponentially in T .\n> >\n> > This is a good abstract description, but I think it might be useful for\n> > readers of this list who are wondering about the impact of this attack\n> > to put it in concrete terms. I'm bad at statistics, but I think the\n> > probability of bribery failing (even if Bob offers a bribe with an\n> > appropriately high feerate) is 1-exp(-b*h) where `b` is the number of\n> > blocks until timeout and `h` is a percentage of the hashrate controlled\n> > by so-called myopic miners. Given that, here's a table of attack\n> > failure probabilities:\n> >\n> > \"Myopic\" hashrate\n> > B 1% 10% 33% 50%\n> > l +---------------------------------\n> > o 6 | 5.82% 45.12% 86.19% 95.02%\n> > c 36 | 30.23% 97.27% 100.00% 100.00%\n> > k 144 | 76.31% 100.00% 100.00% 100.00%\n> > s 288 | 94.39% 100.00% 100.00% 100.00%\n> >\n> > So, if I understand correctly, even a small amount of \"myopic\" hashrate\n> > and long timeouts---or modest amounts of hashrate and short\n> > timeouts---makes this attack unlikely to succeed (and, even in the cases\n> > where it does succeed, Bob will have to offer a very large bribe to\n> > compensate \"rational\" miners for their high chance of losing out on\n> > gaining any transaction fees).\n> >\n> > Additionally, I think there's the problem of measuring the distribution\n> > of \"myopic\" hashrate versus \"rational\" hashrate. \"Rational\" miners need\n> > to do this in order to ensure they only accept Bob's timelocked bribe if\n> > it pays a sufficiently high fee. However, different miners who try to\n> > track what bribes were relayed versus what transactions got mined may\n> > come to different conclusions about the relative hashrate of \"myopic\"\n> > miners, leading some of them to require higher bribes, which may lead\n> > those those who estimated a lower relative hash rate to assume the rate\n> > of \"myopic\" mining in increasing, producing a feedback loop that makes\n> > other miners think the rate of \"myopic\" miners is increasing. (And that\n> > assumes none of the miners is deliberately juking the stats to mislead\n> > its competitors into leaving money on the table.)\n>\n> A thought occurs to me, that we should not be so hasty to call non-myopic\n> strategy \"rational\".\n> Let us consider instead \"myopic\" and \"non-myopic\" strategies in a\n> population of miners.\n>\n> I contend that in a mixed population of \"myopic\" and \"non-myopic\" miners,\n> the myopic strategy is dominant in the game-theoretic sense, i.e. it might\n> earn less if all miners were myopic, but if most miners were non-myopic and\n> a small sub-population were myopic and there was no easy way for non-myopic\n> miners to punish myopic miners, then the myopic miners will end up earning\n> more (at the expense of the non-myopic miners) and dominate over non-myopic\n> miners.\n> Such dominant result should prevent non-myopic miners from arising in the\n> first place.\n>\n> The dominance results from the fact that by accepting the Alice\n> transaction, myopic miners are effectively deducting the fees earned by\n> non-myopic miners by preventing the Bob transaction from being confirmable.\n> On the other hand, even if the non-myopic miners successfully defer the\n> Alice transaction, the myopic miner still has a chance equal to its\n> hashrate of getting the Bob transaction and its attached fee.\n> Thus, myopic miners impose costs on their non-myopic competitors that\n> non-myopic miners cannot impose their myopic competitors.\n> If even one myopic miner successfully gets the Alice transaction\n> confirmed, all the non-myopic miners lose out on the Bob bribe fee.\n>\n> So I think the myopic strategy will be dominant and non-myopic miners will\n> not arise in the first place.\n>\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200630/809808b9/attachment-0001.html>"
            },
            {
                "author": "Tejaswi Nadahalli",
                "date": "2020-06-30T06:45:09",
                "message_text_only": "Hello ZmnSCPxj (as there would be no better way to start an email to you\n:-),\n\nI posted a reply to Dave in the other sub-thread of this main thread. We\nhave a paper about something similar to what you have said - where we look\nat \"weak\" and \"strong\" miners, and how even if there are a few weak miners,\nthey have a dominating strategy, etc.\n\nOn Mon, Jun 29, 2020 at 8:05 PM ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Dave, et al.,\n>\n>\n> > >      Myopic Miners: This bribery attack relies on all miners\n> > >\n> > >\n> > > being rational, hence considering their utility at game conclu-\n> > > sion instead of myopically optimizing for the next block. If\n> > > a portion of the miners are myopic and any of them gets to\n> > > create a block during the first T \u2212 1 rounds, that miner would\n> > > include Alice\u2019s transaction and Bob\u2019s bribery attempt would\n> > > have failed.\n> > > In such scenarios the attack succeeds only with a certain\n> > > probability \u2013 only if a myopic miner does not create a block\n> > > in the first T \u2212 1 rounds. The success probability therefore\n> > > decreases exponentially in T . Hence, to incentivize miners\n> > > to support the attack, Bob has to increase his offered bribe\n> > > exponentially in T .\n> >\n> > This is a good abstract description, but I think it might be useful for\n> > readers of this list who are wondering about the impact of this attack\n> > to put it in concrete terms. I'm bad at statistics, but I think the\n> > probability of bribery failing (even if Bob offers a bribe with an\n> > appropriately high feerate) is 1-exp(-b*h) where `b` is the number of\n> > blocks until timeout and `h` is a percentage of the hashrate controlled\n> > by so-called myopic miners. Given that, here's a table of attack\n> > failure probabilities:\n> >\n> > \"Myopic\" hashrate\n> > B 1% 10% 33% 50%\n> > l +---------------------------------\n> > o 6 | 5.82% 45.12% 86.19% 95.02%\n> > c 36 | 30.23% 97.27% 100.00% 100.00%\n> > k 144 | 76.31% 100.00% 100.00% 100.00%\n> > s 288 | 94.39% 100.00% 100.00% 100.00%\n> >\n> > So, if I understand correctly, even a small amount of \"myopic\" hashrate\n> > and long timeouts---or modest amounts of hashrate and short\n> > timeouts---makes this attack unlikely to succeed (and, even in the cases\n> > where it does succeed, Bob will have to offer a very large bribe to\n> > compensate \"rational\" miners for their high chance of losing out on\n> > gaining any transaction fees).\n> >\n> > Additionally, I think there's the problem of measuring the distribution\n> > of \"myopic\" hashrate versus \"rational\" hashrate. \"Rational\" miners need\n> > to do this in order to ensure they only accept Bob's timelocked bribe if\n> > it pays a sufficiently high fee. However, different miners who try to\n> > track what bribes were relayed versus what transactions got mined may\n> > come to different conclusions about the relative hashrate of \"myopic\"\n> > miners, leading some of them to require higher bribes, which may lead\n> > those those who estimated a lower relative hash rate to assume the rate\n> > of \"myopic\" mining in increasing, producing a feedback loop that makes\n> > other miners think the rate of \"myopic\" miners is increasing. (And that\n> > assumes none of the miners is deliberately juking the stats to mislead\n> > its competitors into leaving money on the table.)\n>\n> A thought occurs to me, that we should not be so hasty to call non-myopic\n> strategy \"rational\".\n> Let us consider instead \"myopic\" and \"non-myopic\" strategies in a\n> population of miners.\n>\n> I contend that in a mixed population of \"myopic\" and \"non-myopic\" miners,\n> the myopic strategy is dominant in the game-theoretic sense, i.e. it might\n> earn less if all miners were myopic, but if most miners were non-myopic and\n> a small sub-population were myopic and there was no easy way for non-myopic\n> miners to punish myopic miners, then the myopic miners will end up earning\n> more (at the expense of the non-myopic miners) and dominate over non-myopic\n> miners.\n> Such dominant result should prevent non-myopic miners from arising in the\n> first place.\n>\n> The dominance results from the fact that by accepting the Alice\n> transaction, myopic miners are effectively deducting the fees earned by\n> non-myopic miners by preventing the Bob transaction from being confirmable.\n> On the other hand, even if the non-myopic miners successfully defer the\n> Alice transaction, the myopic miner still has a chance equal to its\n> hashrate of getting the Bob transaction and its attached fee.\n> Thus, myopic miners impose costs on their non-myopic competitors that\n> non-myopic miners cannot impose their myopic competitors.\n> If even one myopic miner successfully gets the Alice transaction\n> confirmed, all the non-myopic miners lose out on the Bob bribe fee.\n>\n> So I think the myopic strategy will be dominant and non-myopic miners will\n> not arise in the first place.\n>\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200630/ecf01349/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "MAD-HTLC",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tejaswi Nadahalli",
                "David A. Harding",
                "Stanga",
                "Nadav Ivgi",
                "ZmnSCPxj",
                "Bastien TEINTURIER"
            ],
            "messages_count": 15,
            "total_messages_chars_count": 71316
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin 2-way-pegged childchains via Proof of Burn",
        "thread_messages": [
            {
                "author": "Cloud Strife",
                "date": "2020-06-25T21:43:20",
                "message_text_only": "Hi everyone,\n\nI am hoping to get a critique on a proposal of how to\nconstruct childchains \"on-top\" of Bitcoin without requiring any changes to\nBitcoin itself nor requiring any user or miner to be aware of them.\n\nThe childchain is Bitcoin-aware and simulates the properties of Proof of\nWork by requiring continuous burning of Bitcoin in return for the fees on\nthe childchain.\n\nThe childchain tip is selected by highest total accumulated Bitcoin burnt\n(with goal to simulate total accumulated work) for that full chained set of\nchildchain block commits.\n\nThe only asset on the childchain is a 2-way-peg coin that's secured in\nvalue without oracles or collateral by requiring that each valid child\nchain block must not only burn Bitcoin, but must always use a small % of\nthe burnt amount to deterministically reimburse withdrawals from the\nchildchain.\n\nChildchain -> mainchain :: user burns the child-BTC and is added to\nwithdrawal queue filled as part of validity requirements by childchain\n\"miners\" until filled 1:1 on mainchain or more. Note that occasionally\noverpaying a widthdrawal does not break 1:1 peg as there's no fixed size\n1:1 pool of coins necessary.\n\nmainchain -> childchain :: user burns BTC (independent of mining\nchildchain) and is issued equivalent 1:1 child-BTC on the childchain\n\nWhile childchains are less secure than the mainchain, both the childchain\nsecurity and the 2-way-peg accuracy might be an acceptable option for lower\nvalue tx on scale determined by the burning rate.\n\nChildchains would replace the need for any additional Proof of Work chains\nfor new blockchains to introduce any complexity (e.g. mimblewimble\nchildchain).\n\nThey would effectively use Proof of Work done on Bitcoin as proxy for\nunforgeable costliness and benefit from Bitcoin's censorship resistance and\ndata availability. Large numbers of low value tx that might be priced out\nof using the main chain could possibly in bulk provide enough childchain\nfees combined through childchain miners to afford much higher mainchain\nfees like \"batching for fees\".\n\nIt also has the \"benefits\" claimed by proof of stake like no energy\nconsumption without relying on internal permissions or tokens, trusted\ndistributions, or centralizing mechanisms like staking by simulating proof\nof work. It should allow both growing the Bitcoin ecosystem and replace the\nneed to create alternative cryptocurrencies just to make a new blockchain.\n\nMore detailed write up available here:\nhttps://bitcointalk.org/index.php?topic=5214173.0\n\nI am hoping for a review if there's an overlooked issue or maybe interest\nto create a proof of concept.\n\nThank you\n-CS\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200625/9017f5d1/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-26T00:57:13",
                "message_text_only": "Good morning CS,\n\nThe difficulty is not so much the proof-of-whatever, but rather, the peg itself.\nMy understanding of your pegout from sidechain to mainchain is that this pegout is very low-bandwidth, i.e. only a tiny amount can be pegged out at each mainchain block.\nThis suggests to me that the sidecoin can still drop lower than maincoin during times when overall side-to-main flows are higher than main-to-side flows.\n(atomic swaps cannot *maintain* a peg, they can only follow a peg if it exists; if the peg is weak, atomic swaps cannot strengthen it.\nthis is because atomic swaps allow a non-1:1 exchange rate, as in cross-currency atomic swaps.)\n\n\nIn any case, from my reading of your text, I seem, the goal is scaling (\"acceptable option for lower value tx\").\nI studied sidechains some years ago, and, came to the conclusion that sidechains are not good for scaling.\nWe already know that blockchains do not scale well (excessive bandwidth use, permanent records needed to support newcomers); thus, the scaling solution for cryptocurrency cannot be via **more** blockchains.\nHence, Lightning Network.\n\nIn Lightning Network, every channel is a consensus system between two participants, hence every channel is a 2-of-2 (i.e. requires consensus of both participants to advance).\nWe use atomic swaps to transfer between channels and the blockchain.\nThe channel construction requires reference to an ultimate arbiter of any dispute/non-consensus between the channel participants; this is provided by the blockchain layer off which the channel is based.\n\nThus blockchain for arbitration, channels for scaling.\n\n\nRegards,\nZmnSCPxj\n\n\n> Hi everyone,\n>\n> I am hoping to get a critique on a proposal of how to construct\u00a0childchains\u00a0\"on-top\" of Bitcoin without requiring any changes to Bitcoin itself nor requiring any user or miner to be aware of them.\n>\n> The childchain is Bitcoin-aware and simulates the properties of Proof of Work by requiring continuous burning of Bitcoin in return for the fees on the childchain.\n>\n> The childchain\u00a0tip is selected by highest total accumulated Bitcoin burnt (with goal to simulate total accumulated work) for that full chained set of childchain block commits.\n>\n> The only asset on the childchain\u00a0is a 2-way-peg coin that's secured in value without oracles or collateral by requiring that each valid child chain block must not only burn Bitcoin, but must always use a small % of the burnt amount to deterministically reimburse\u00a0withdrawals from the childchain.\n>\n> Childchain -> mainchain :: user burns the child-BTC and is added to withdrawal queue filled as part of validity requirements by childchain \"miners\" until filled 1:1 on mainchain or more. Note that occasionally overpaying a widthdrawal does not break 1:1 peg as there's no fixed size 1:1 pool of coins necessary.\n>\n> mainchain -> childchain :: user burns BTC (independent of mining childchain) and is issued equivalent 1:1 child-BTC on the childchain\n>\n> While childchains\u00a0are less secure than the mainchain, both the childchain security and the 2-way-peg accuracy might be an acceptable option for lower value tx on scale determined by the burning rate.\u00a0\n>\n> Childchains would replace the need for any additional Proof of Work chains for new blockchains to introduce any complexity (e.g. mimblewimble childchain).\n>\n> They would effectively use Proof of Work done on Bitcoin as proxy for unforgeable costliness and benefit from Bitcoin's censorship resistance and data availability. Large numbers of low value tx that might be priced out of using the main chain could possibly in bulk provide enough childchain fees combined through childchain miners to afford much higher mainchain fees like \"batching for fees\".\n>\n> It also has the \"benefits\" claimed by proof of stake like no energy consumption without relying on internal permissions or tokens, trusted distributions, or centralizing mechanisms like staking by simulating proof of work. It should allow both growing the Bitcoin ecosystem and replace the need to create alternative cryptocurrencies just to make a new blockchain.\n>\n> More detailed write up available here:\u00a0https://bitcointalk.org/index.php?topic=5214173.0\u00a0\u00a0\n>\n> I am hoping for a review if there's an overlooked issue or maybe interest to create a proof of concept.\n>\n> Thank you\n> -CS"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin 2-way-pegged childchains via Proof of Burn",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Cloud Strife"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 7116
        }
    },
    {
        "title": "[bitcoin-dev] Pinning : The Good, The Bad, The Ugly",
        "thread_messages": [
            {
                "author": "Antoine Riard",
                "date": "2020-06-29T00:13:03",
                "message_text_only": "(tl;dr Ideally network mempools should be an efficient marketplace leading\nto discovery of best-feerate blockspace demand by miners. It's not due to\ncurrent anti-DoS rules assumptions and it's quite harmful for shared-utxo\nprotocols like LN)\n\nHello all,\n\nLightning security model relies on the unilateral capability for a channel\nparticipant to confirm transactions, like timing out an outgoing HTLC,\nclaiming an incoming HTLC or punishing a revoked commitment transaction and\nthus enforcing onchain a balance negotiated offchain. This security model\nis actually turning back the double-spend problem to a private matter,\nmaking the duty of each channel participant to timely enforce its balance\nagainst the competing interest of its counterparties. Or laid out\notherwise, contrary to a miner violating a consensus rules, base layer\npeers don't care about your LN node failing to broadcast a justice\ntransaction before the corresponding timelock expiration (CSV delay).\n\nEnsuring effective propagation and timely confirmation of LN transactions\nis so a critical-safety operation.  Its efficiency should be always\nevaluated with regards to base layer network topology, tx-relay propagation\nrules, mempools behaviors, consistent policy applied by majority of nodes\nand ongoing blockspace demand. All these components are direct parameters\nof LN security. Due to the network being public, a malicious channel\ncounterparty do have an incentive to tweak them to steal from you.\n\nThe pinning attacks which have been discussed since a few months are a\ndirect illustration of this model. Before digging into each pinning\nscenario, few properties of the base layer components should be evocated\n[0].\n\nNetwork mempools aren't guaranteed to be convergent, the local order of\nevents determines the next events accepted. I.e Alice may observe tx X, tx\nY, tx Z and Bob may observe tx Z, tx X, tx Y. If tx Z disable-RBF and tx X\ntry to replace Z, Alice accepts X and Bob rejects it. This divergence may\npersevere until a new block.\n\nTx-relay topology can be observed by spying nodes [1]. An attacker can\nexploit this fact to partition network mempools in different subset and\nhamper propagation across them of same-spending output concurrent\ntransactions. If subset X observes Alice commitment transaction and subset\nY observes Bob commitment transaction, Alice's HTLC-timeout spending her\ncommitment won't propagate beyond the X-Y set boundaries. An attacker can\nalways win the propagation race through massive connections or bypassing\ntx-relay privacy timers.\n\nMiners mempools are likely identifiable, you could announce a series of\nconflicting transactions to different subsets of the network and observe\n\"tainted\" block composition to assign to each subset a miner mempool. I'm\nnot aware of any research on this, but it sounds plausible to identify all\npower-miner mempool, i.e the ones likely to mine a block during the block\ndelay of the timelock you're looking to exploit. If you can't bid a\ntransaction in such miner mempools your channel state will stale and your\nfunds may be in danger.\n\n### Scenario 1) HTLC-Preimage Pinning\n\nAs Matt previously explained in his original mail on RBF-pinning, a\nmalicious counterparty has an interest to pin a low-feerate HTLC-preimage\ntransaction in some network mempools and thus preventing a honest\nHTLC-timeout to confirm. For details, refer to Optech newsletter [2].\n\nThis scenario doesn't bear any risk to the attacker, is easy to execute and\nhas double-digit rate of success. You don't assume network topologies\nmanipulation, mempools partitions or LN-node-to-full-node mapping [3] That\nsaid this should be solved by implementing and deploying anchor outputs,\nwhich effectively allows a party to unilaterally bump feerate of its\nHTLC-timeout transactions.\n\n### The Anchor Output Proposal\n\nAnchor Output proposal is a current spec object implemented by the LN dev\ncommunity, it introduces the ability to _unilaterally_ and _dynamically_\nbump feerate of any commitment transaction. It also opened the way to bump\nlocal 2nd-stage transactions.\n\nBeyond solving scenario 1), it makes LN node safe with regards to\nunexpected mempool congestion. If your commitment transaction is stucking\nin network mempools you can bump its feerate by attaching a CPFP on the new\n`to_local` anchor. If the remote commitment gets stuck in network mempools,\nyou're able to bump it by attaching a CPFP on the `to_remote` anchor. This\nshould keep your safe against an unresponsive or lazy counterparty in case\nof onchain funds to claim.\n\nIMO, it comes with a trade-off as it introduces a mapping oracle, i.e a\nlinking vector between a LN node and its full-node. In this case, a spying\nnode may establish a dummy, low-value channel with a probed LN node, break\nit by broadcasting thousands of different versions of the (revoked)\ncommitment and observes which one broadcast a CPFP first on the p2p layer.\nObviously, you can mitigate it by not chasing after low-value HTLC, but\nthat is a small risk of money loss. As of today,  this oracle can be seen\nas acceptable as we have other ones and we may get rid of it in the future.\n\n### Scenario 2a) Revoked Commitment Transaction Pinning\n\nDigging further, we found that there are more concerning scenarios of\npinning, at the commitment-tx level. At a period of low-feerate, a\nmalicious party incessantly updates a channel until to obtain ~10k revoked\ncommitment transactions.\n\nAt a period of mempool-congestion, by having setup a fine-grained\n`dust_limit_satoshis` and at same-time circulary routing HTLCs, our\nmalicious party can inflate absolute fee of its own commitment bounded\nwhile breaking channel in the middle of an update sequence, ensuring it has\na higher-fee than the commitment of the honest counterparty. As channel\nopener, the attacker has the amplitude of malleating the victim's\ncommitment such to keep it equal or under revoked feerate.\n\nThen our malicious party broadcast to each base layer public peer one of\nthe revoked commitment transactions, that way partitioning the network\nmempools in 10k subset. Even assuming anchor output a honest LN node won't\nbe able to confirm the remote commitment through a CPFP, this one failing\nto cross subset boundaries, the parent txid being different at each.\n\nBroadcasting the honest commitment transaction will fail, its feerate being\nknown and malleable it won't RBF already-in-mempool remote commitment\ntransactions. This prevents an honest party to timely timeout an outgoing\nHTLC or an incoming HTLC.\n\nThis scenario does bear a low-risk to the attacker, is easy to execute and\nhas a likely double-digit rate of success once you tune feerate\nmalleability. You assume mempools partitions but not any network topologies\ndiscovery. We underscore there is no current p2p/mempool mechanism to learn\nabout conflicting transactions, even learning about near-topology conflicts\ndon't guarantee you that a propagation path is uniform to make your CPFP\nsuccessful.\n\n### Scenario 2b) Previous-Latest Commitment Transaction Pinning\n\nA variant of commitment-tx pinning is to rely only on valid commitment\ntransactions. Channel update sequence not being atomic, you can legally own\n2 valid commitment transactions. An attacker can successfully map a\nLN-node's full-node and such, announce one of them and the other one to the\nrest of the network. A honest peer will fail to leverage the `to_remote`\nanchor output as its CPFP won't propagate again over network mempools\npartitions.\n\nThis scenario doesn't bear a risk to the attacker, is medium to execute and\nhas a likely double-digit rate of success. You assume mempools partitions\nand inter-layer mapping. How hard is it to map a LN-node to a full-node ?\nActually you can use the fact that a LN-node's full-node is monitoring the\nmempool for a preimage of interest and observe the announcement of such\npreimage on the offchain layer. As post-anchor HTLC-Success transactions\nare malleable you can once again create mass-conflicts to isolate the\nfull-node and improve the probe with high certainty.\n\n### Where Package Relay helps\n\nSolving scenario 2a) and 2b) in the most efficient way is likely to require\npackage relay support on the Core side. Package relay would extend the\nnotion of a mempool package (topologically ordered bundles of transactions)\nto introduce a new class of p2p traffic. So far its implementation has been\ndelayed due to refactoring mempool internals, ensuring a DoS-robust design\nand a p2p PR pipeline already congested.\n\nOnce deployed, a LN node would be able to join a commitment transaction and\na CPFP together and make them evaluated atomically by network mempools such\nto evict any malicious remote commitment assuming a higher feerate.\n\n### Scenario 3) Network-Topology-Aware Pinning for Propagation Obstruction\n\nLet's assume the following base layer tx-relay topology:\n\n                Alice ---> Bob ---> Caroll\n\nAlice wants to send her package relay to Caroll the miner to get her\ncommitment transaction confirmed. A malicious counterparty could throw\nremote commitment W in Bob mempool and remote commitment X in Caroll\nmempool. Transaction W would be attached to a high-fee CPFP Y. Transaction\nX would be attached to a low-fee CPFP Z such that X pins in Caroll mempool.\nCPFP Y and CPFP Z would be crafted such as both incorporating a conflicting\nparent to prevent Bob and Caroll mempool convergence. It looks like the\nfollowing:\n\nBob's mempool:\ntx W ---> tx Y\nparent 1 ---> tx Y\n\nCaroll's mempool:\ntx X ---> tx Z\nparent 2 ---> tx Z\n\nBob's mempool would announce and send package \"tx W + tx Y + parent 1\" to\nCaroll's one and due to parent 1 and parent 2 spending the same output\npackage would be rejected. High-fee package W will prevent Alice to\nsuccessfully broadcast her package to Caroll. This fee can be higher than\nthe maximum one that Alice would pay to confirm her transaction, as due to\nconflicts, it won't be _effectively_ paid by the malicious counterparty.\n\nThis scenario does bear a risk to the attacker only if miner mempools\nhaven't been well-mapped and high-fee package leak into them, is hard to\nexecute but has a likely double-digit rate of success. It assumes mempool\npartitions, network topology knowledge and inter-layer mapping.\n\n### Current Mempool Design Flaws in the lights of Contracting Applications\nwith Competing Interests\n\nScenario 3) does illustrate a current flaw of mempool with regards to\ncontracting applications with competing interests. A counterparty can\nleverage network propagation rules to prevent miners' mempools to discover\nthe best feerate package and thus not having to pay the real fee price to\nsuccessfully obstrucate broadcast of honest package relay spending the same\noutput.\n\nThese network propagation rules, namely RBF opt-in, have been designed to\nprotect network mempools against any DoS but don't protect a single-party\nagainst its shared-utxo co-owners. Amending these rules to enable\nmempool-convergence based on feerate will enable a honest bid market for\ncontracting applications and ensure network-wise higher feerate. Getting\nthis right will require significant study as you may allow total mempool\nfees to decrease when the transactions are near the bottom of the mempool.\nAt first sight, it sounds incentives-compatible, as miner a) gets the\nhighest fee bid b) an attacker does have to compete on feerate to attempt\nstealing.\n\nAssuming a basic package relay to evict low-feerate malicious commitment,\nan alternative proposal could be to introduce outbound tx-relay peers\nrotation to sweep and reach ~80% of the network in less than HTLC\ntimelocks.  Your LN node's full node will _probabilistically_ connect to a\nminer mempool and announce to it the best feerate package. Making the\ntx-relay topology more dynamic would make it harder for an attacker to make\npackage obstruction effective. IMHO, it sounds easier on the\nengineering-side, but likely worse for privacy due to the aggressive\nbroadcast pattern.\n\nAnother alternative could be to have more ad hoc privacy-preserving\nredundant tx-broadcast.\n\nA fourth proposal, Matt's one, is to design some blind-CPFP package relay\nwith a pointer to original funding outpoint to rebind on-the-flight but it\ndoes assume noinput.\n\n### Conclusion\n\nTo the best of my knowledge, assuming mempools congestion levels we have\nseen in the past months, currently deployed LN peers aren't secure against\nscenario 2a) and 2b) to any motivated attackers with a decent knowledge of\nboth layers. Further, ensuring scenario 3) security requires heavy,\nlong-term work at the base layer.\n\nIMO, we should a) go forward with anchor proposal implementation, it comes\nwith trade-off but enables mempool-congestion safety, b) work on package\nrelay to solve commitment-level pinning, c) study best base layer mechanism\nto ensure best feerate package discovery by any miner's mempools and d) in\nthe meanwhile increase delta and deadline timelocks.\n\nThoughts ?\n\nThanks to Matt and t-bast for conversations.\n\nCheers,\n\nAntoine\n\n[0] For newcomers, see also t-bast's great piece on LN's transactions :\nhttps://github.com/t-bast/lightning-docs/blob/master/lightning-txs.md\n\n[1] And current state of opinions is obfuscating tx-relay topology is a\nhard problem\nhttps://github.com/bitcoin/bitcoin/pull/15759#issuecomment-480398802\n\n[2]\nhttps://bitcoinops.org/en/newsletters/2020/04/29/#new-attack-against-ln-payment-atomicity\n\n[3] Obviously all these scenarios do have a setup cost scoping channel\nopening onchain fees and\nrebalancing but it's order(s) of magnitude lower if you can steal from\nmeaningful channels.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200628/42630142/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Pinning : The Good, The Bad, The Ugly",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Antoine Riard"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 13761
        }
    },
    {
        "title": "[bitcoin-dev] Is Bitcoin mempool synchronized?",
        "thread_messages": [
            {
                "author": "Hilda",
                "date": "2020-06-30T19:01:30",
                "message_text_only": "Hi there,\n\n\nI have been assuming Bitcoin system to be well synchronized, including mempools. But after being challenged, I started to think that I actually cannot verify this without knocking the door of every miner in every single second (just a time slice reasonable to me; stop torturing me by asking why). Can anyone share any thoughts with me?\n\n\nThank you,\nHilda\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200701/fc716bba/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Is Bitcoin mempool synchronized?",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Hilda"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 550
        }
    }
]