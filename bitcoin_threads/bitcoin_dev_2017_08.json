[
    {
        "title": "[bitcoin-dev] Structure for Trustless Hybrid Bitcoin Wallets Using P2SH for Recovery Options",
        "thread_messages": [
            {
                "author": "Colin Lacina",
                "date": "2017-08-09T18:49:59",
                "message_text_only": "I believe I have come up with a structure that allows for trustless use of\nhybrid wallets that would allow for someone to use a hybrid wallet without\nhaving to trust it while still allowing for emergency recovery of funds in\nthe case of a lost wallet. It would run off of this TX script:\n\nIF\n     1 <clientRecoveryPubKey> <serverRecoveryPubKey> 2 CHECKMULTISIGVERIFY\nELSE\n     2 <userWalletPubKey> <serverWalletPubKey> 2 CHECKMULTISIG\nENDIF\n\nA typical transaction using this would involve a user signing a TX with\ntheir userWalletPrivKey, authenticating with the server, possibly with 2FA\nusing a phone or something like Authy or Google Authenticator. After\nauthentication, the server signs with their serverWalletPrivKey.\n\nIn case the server goes rogue and starts refusing to sign, the user can use\ntheir userRecoveryPrivKey to send the funds anywhere they choose. Because\nif this, the userRecoveryPrivKey is best suited to cold wallet storage.\n\nIn the more likely event that the user forgets their password and/or looses\naccess to their userWalletPrivKey as well as loses their recovery key, they\nrely on the serverRecoveryPrivKey.\n\nWhen the user first sets up their wallet, they answer some basic identity\ninformation, set up a recovery password, and/or set up recovery questions\nand answers. This information is explicitly NOT sent to serve with the\nexception of recovery questions (although the answers remain with the user,\nnever seeing the server). What is sent to the server is it's 256 bit hash\nused to identify the recovery wallet. The server then creates a 1025 bit\nnonce, encrypts it, stores it, and transmits it to the user's client.\n\nMeanwhile, the user's wallet client generates the serverRecoveryPrivKey.\n\nOnce the client has both the serverRecoveryPrivKey, and the nonce, it uses\nSHA512 on the combination of the identity questions and answers, the\nrecovery password (if used), the recovery questions and answers, and the\nnonce. It uses the resulting hash to encrypt the serverRecoveryPrivKey.\n\nFinally, the already encrypted key is encrypted again for transmission to\nthe server. The server decrypts it, then rencrypts it for long term storage.\n\nWhen the user needs to resort to using this option, they 256 bit hash their\ninformation to build their recovery identifier. The server may, optionally,\nrequest e-mail and or SMS confirmation that user is actually attempting the\nrecovery.\n\nNext, the server decrypts the saved nonce, as well as the first layer of\nencryption on the serverRecoveryPrivKey, then encrypts both for\ntransmission to the user's client. Then the client removes the transmission\nencryption, calculates the 512 bit hash that was used to originally encrypt\nthe serverRecoveryPrivKey by using the provided information and the nonce.\n\nAfter all of that the user can decrypt the airbitzServerRecoveryPrivKey and\nuse it to send a transaction anywhere they choose.\n\nI was thinking this may make a good informational BIP but would like\nfeedback.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170809/9d5ee7a8/attachment-0001.html>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2017-08-09T19:35:26",
                "message_text_only": "Hi Colin\n\n> In case the server goes rogue and starts refusing to sign, the user can use their userRecoveryPrivKey to send the funds anywhere they choose. Because if this, the userRecoveryPrivKey is best suited to cold wallet storage.\n\nWould you then assume that userWalletPubKey is a hot key (stored on the users computer eventually in a browser based local storage container)?\nIn case of an attack on the server responsible for serverWalletPubKey (where also the personal information of the user are stored [including the xpub == amount of funds hold by the user)), wound\u2019t this increase the users risk of being an possible target (False sense of multisig security, comparing to cold storage / HWW keys)?\n\n> In the more likely event that the user forgets their password and/or looses access to their userWalletPrivKey as well as loses their recovery key, they rely on the serverRecoveryPrivKey.\n> \n> When the user first sets up their wallet, they answer some basic identity information, set up a recovery password, and/or set up recovery questions and answers. This information is explicitly NOT sent to serve with the exception of recovery questions (although the answers remain with the user, never seeing the server). What is sent to the server is it's 256 bit hash used to identify the recovery wallet. The server then creates a 1025 bit nonce, encrypts it, stores it, and transmits it to the user's client.\n\nI guess this will result in protecting the funds stored in this transaction entirely on the users identity information and eventually the optional recovery password, though I guess you are adding additional security by protecting via the server nonce from brute-forcing.\n\nWhy 1025bit for the nonce?\nWhy SHA512 instead of SHA256 (I guess you need 256bit symmetric key material for the key encryption)?\nConsidered using a (H)KDF for deriving the symmetric key (even if the server based nonce reduces the possibility of brute-forcing)?\n\nYour modal has probably the TORS (trust on recovery setup) weakness (compared to a HWW where you [should] be protected on compromised systems during private key creation).\n\n</jonas>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170809/12ef5842/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170809/12ef5842/attachment.sig>"
            },
            {
                "author": "Nick ODell",
                "date": "2017-08-09T20:14:18",
                "message_text_only": "Colin,\n\n1) This is a good start for a BIP, but it's missing details. For example,\nthe nonce is encrypted by the server. What key is it encrypted with?\nClarifying ambiguities like this can sometimes reveal weaknesses that you\nwouldn't otherwise think of.\n\n2) What kind of recovery questions are asked? If it's something like \"What\nwas the name of your first pet?\" then what prevents the server from\nstealing the wallet by trying a dictionary of the most common pet names? Is\nthere a mitigation to this, besides picking cryptographically secure\nidentifiers for my pets?\n\n--Nick\n\nOn Wed, Aug 9, 2017 at 12:49 PM, Colin Lacina via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I believe I have come up with a structure that allows for trustless use of\n> hybrid wallets that would allow for someone to use a hybrid wallet without\n> having to trust it while still allowing for emergency recovery of funds in\n> the case of a lost wallet. It would run off of this TX script:\n>\n> IF\n>      1 <clientRecoveryPubKey> <serverRecoveryPubKey> 2 CHECKMULTISIGVERIFY\n> ELSE\n>      2 <userWalletPubKey> <serverWalletPubKey> 2 CHECKMULTISIG\n> ENDIF\n>\n> A typical transaction using this would involve a user signing a TX with\n> their userWalletPrivKey, authenticating with the server, possibly with 2FA\n> using a phone or something like Authy or Google Authenticator. After\n> authentication, the server signs with their serverWalletPrivKey.\n>\n> In case the server goes rogue and starts refusing to sign, the user can\n> use their userRecoveryPrivKey to send the funds anywhere they choose.\n> Because if this, the userRecoveryPrivKey is best suited to cold wallet\n> storage.\n>\n> In the more likely event that the user forgets their password and/or\n> looses access to their userWalletPrivKey as well as loses their recovery\n> key, they rely on the serverRecoveryPrivKey.\n>\n> When the user first sets up their wallet, they answer some basic identity\n> information, set up a recovery password, and/or set up recovery questions\n> and answers. This information is explicitly NOT sent to serve with the\n> exception of recovery questions (although the answers remain with the user,\n> never seeing the server). What is sent to the server is it's 256 bit hash\n> used to identify the recovery wallet. The server then creates a 1025 bit\n> nonce, encrypts it, stores it, and transmits it to the user's client.\n>\n> Meanwhile, the user's wallet client generates the serverRecoveryPrivKey.\n>\n> Once the client has both the serverRecoveryPrivKey, and the nonce, it uses\n> SHA512 on the combination of the identity questions and answers, the\n> recovery password (if used), the recovery questions and answers, and the\n> nonce. It uses the resulting hash to encrypt the serverRecoveryPrivKey.\n>\n> Finally, the already encrypted key is encrypted again for transmission to\n> the server. The server decrypts it, then rencrypts it for long term storage.\n>\n> When the user needs to resort to using this option, they 256 bit hash\n> their information to build their recovery identifier. The server may,\n> optionally, request e-mail and or SMS confirmation that user is actually\n> attempting the recovery.\n>\n> Next, the server decrypts the saved nonce, as well as the first layer of\n> encryption on the serverRecoveryPrivKey, then encrypts both for\n> transmission to the user's client. Then the client removes the transmission\n> encryption, calculates the 512 bit hash that was used to originally encrypt\n> the serverRecoveryPrivKey by using the provided information and the nonce.\n>\n> After all of that the user can decrypt the airbitzServerRecoveryPrivKey\n> and use it to send a transaction anywhere they choose.\n>\n> I was thinking this may make a good informational BIP but would like\n> feedback.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170809/684da748/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Structure for Trustless Hybrid Bitcoin Wallets Using P2SH for Recovery Options",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Nick ODell",
                "Colin Lacina",
                "Jonas Schnelli"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 9911
        }
    },
    {
        "title": "[bitcoin-dev] ScalingBitcoin 2017: Stanford - Call For Proposals Now Open",
        "thread_messages": [
            {
                "author": "Ethan Heilman",
                "date": "2017-08-11T20:36:59",
                "message_text_only": "Dear All,\n\nThe Call for Proposals (CFP) for 'Scaling Bitcoin 2017: Stanford' is now\nopen.\n\nPlease see https://scalingbitcoin.org for details\n\n*Important Dates*\n\nSept 25th - Deadline for submissions to the CFP\n\nOct 16th - Applicant acceptance notification\n\nHope to see you in California (Nov 4-5 2017)\n\nFull CFP can be found at https://scalingbitcoin.org/event/stanford2017#cfp\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170811/da36bbbb/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "ScalingBitcoin 2017: Stanford - Call For Proposals Now Open",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Ethan Heilman"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 559
        }
    },
    {
        "title": "[bitcoin-dev] Would anyone object to adding a dlopen message hook system?",
        "thread_messages": [
            {
                "author": "Erik Aronesty",
                "date": "2017-08-13T18:46:37",
                "message_text_only": "I was thinking about something like this that could add the ability for\nmodule extensions in the core client.\n\nWhen messages are received, modules hooks are called with the message data.\n\n\nThey can then handle, mark the peer invalid, push a message to the peer or\npass through an alternate command.  Also, modules could have their own\nprivate commands prefixed by \"x:\" or something like that.\n\nThe idea is that the base P2P layer is left undisturbed, but there is now a\nway to create \"enhanced features\" that some peers support.\n\nMy end goal is to support using lightning network micropayments to allow\npeople to pay for better node access - creating a market for node services.\n\n\nBut I don't think this should be \"baked in\" to core.   Nor do I think it\nshould be a \"patch\".   It should be a linked-in module, optionally compiled\nand added to bitcoin conf, then loaded via dlopen().    Modules should be\nslightly robust to Bitcoin versions changing out from under them, but not\nif the network layer is changed.   This can be ensured by a) keeping a\nmodule version number, and b) treating module responses as if they were\njust received from the network.   Any module incompatibility should throw\nan exception...ensuring broken peers don't stay online.\n\nIn general I think the core reference would benefit from the ability to\ncreate subnetworks within the Bitcoin ecosystem.   Right now, we have two\nchoices... full node and get slammed with traffic, or listen-only node, and\ndo nothing.\n\nAdding a module/hook system would allow a complex ecosystem of\nparticipation - and it would seem to be far more robust in the long term.\n\nSomething like this???\n\nclass MessageHookIn {\npublic:\n    int hookversion;\n    int64_t nodeid;\n    int nVersion;\n    int64_t serviceflags;\n    const char *strCommand;\n    const char *nodeaddr;\n    const char *vRecv;\n    int vRecvLen;\n    int64_t nTimeReceived;\n};\n\nclass MessageHookOut {\npublic:\n    int hookversion;\n    int misbehaving;\n    const char *logMsg;\n    const char *pushCommand;\n    const unsigned char *pushData;\n    int pushDataLen;\n    const char *passCommand;\n    CDataStream passStream;\n};\n\nclass MessageHook {\npublic:\n    int hookversion;\n    std::string name;\n    typedef bool (*HandlerType)(const MessageHookIn *in, MessageHookOut\n*out);\n    HandlerType handle;\n};\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170813/a3f72611/attachment.html>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2017-08-13T20:00:41",
                "message_text_only": "Hi Erik\n\nThanks for your proposal.\nIn general, modularisation is a good thing, though proposing core to add modules wie dlopen() seems the wrong direction.\nCore already has the problem of running to many things in the same process. The consensus logic, p2p system as well as the wallet AND the GUI do all share the same process (!).\n\nA module approach like you describe would be a security nightmare (and Core is currently in the process of separating out the wallet and the GUI into its own process).\n\nWhat does speak against using the existing IPC interfaces like RPC/ZMQ?\nRPC can be bidirectional using long poll.\n\n/jonas\n\n> I was thinking about something like this that could add the ability for module extensions in the core client.\n> \n> When messages are received, modules hooks are called with the message data.\n> \n> They can then handle, mark the peer invalid, push a message to the peer or pass through an alternate command.  Also, modules could have their own private commands prefixed by \"x:\" or something like that.\n> \n> The idea is that the base P2P layer is left undisturbed, but there is now a way to create \"enhanced features\" that some peers support.\n> \n> My end goal is to support using lightning network micropayments to allow people to pay for better node access - creating a market for node services.\n> \n> But I don't think this should be \"baked in\" to core.   Nor do I think it should be a \"patch\".   It should be a linked-in module, optionally compiled and added to bitcoin conf, then loaded via dlopen().    Modules should be slightly robust to Bitcoin versions changing out from under them, but not if the network layer is changed.   This can be ensured by a) keeping a module version number, and b) treating module responses as if they were just received from the network.   Any module incompatibility should throw an exception...ensuring broken peers don't stay online.\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170813/dec1b7a3/attachment.sig>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-08-13T20:56:39",
                "message_text_only": "Jonas, I think his proposal is to enable extending the P2P layer, e.g.\nadding new message types. Are you suggesting having externalized\nmessage processing? That could be done via RPC/ZMQ while opening up a\nmuch more narrow attack surface than dlopen, although I imagine such\nan interface would require a very complex API specification.\n\nOn Sun, Aug 13, 2017 at 1:00 PM, Jonas Schnelli via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Hi Erik\n>\n> Thanks for your proposal.\n> In general, modularisation is a good thing, though proposing core to add modules wie dlopen() seems the wrong direction.\n> Core already has the problem of running to many things in the same process. The consensus logic, p2p system as well as the wallet AND the GUI do all share the same process (!).\n>\n> A module approach like you describe would be a security nightmare (and Core is currently in the process of separating out the wallet and the GUI into its own process).\n>\n> What does speak against using the existing IPC interfaces like RPC/ZMQ?\n> RPC can be bidirectional using long poll.\n>\n> /jonas\n>\n>> I was thinking about something like this that could add the ability for module extensions in the core client.\n>>\n>> When messages are received, modules hooks are called with the message data.\n>>\n>> They can then handle, mark the peer invalid, push a message to the peer or pass through an alternate command.  Also, modules could have their own private commands prefixed by \"x:\" or something like that.\n>>\n>> The idea is that the base P2P layer is left undisturbed, but there is now a way to create \"enhanced features\" that some peers support.\n>>\n>> My end goal is to support using lightning network micropayments to allow people to pay for better node access - creating a market for node services.\n>>\n>> But I don't think this should be \"baked in\" to core.   Nor do I think it should be a \"patch\".   It should be a linked-in module, optionally compiled and added to bitcoin conf, then loaded via dlopen().    Modules should be slightly robust to Bitcoin versions changing out from under them, but not if the network layer is changed.   This can be ensured by a) keeping a module version number, and b) treating module responses as if they were just received from the network.   Any module incompatibility should throw an exception...ensuring broken peers don't stay online.\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2017-08-15T01:33:34",
                "message_text_only": "Actually the more I think about it, the more I realize that all I need is\nto listen on a new port, and use the RPC api to affect Bitcoin:\n\n- ban a peer (# of hours)\n- unban a peer (# of hours)\n\nAs long as I have those two functions, I can do everything I need.\n\nOn Sun, Aug 13, 2017 at 4:56 PM, Mark Friedenbach <mark at friedenbach.org>\nwrote:\n\n> Jonas, I think his proposal is to enable extending the P2P layer, e.g.\n> adding new message types. Are you suggesting having externalized\n> message processing? That could be done via RPC/ZMQ while opening up a\n> much more narrow attack surface than dlopen, although I imagine such\n> an interface would require a very complex API specification.\n>\n> On Sun, Aug 13, 2017 at 1:00 PM, Jonas Schnelli via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > Hi Erik\n> >\n> > Thanks for your proposal.\n> > In general, modularisation is a good thing, though proposing core to add\n> modules wie dlopen() seems the wrong direction.\n> > Core already has the problem of running to many things in the same\n> process. The consensus logic, p2p system as well as the wallet AND the GUI\n> do all share the same process (!).\n> >\n> > A module approach like you describe would be a security nightmare (and\n> Core is currently in the process of separating out the wallet and the GUI\n> into its own process).\n> >\n> > What does speak against using the existing IPC interfaces like RPC/ZMQ?\n> > RPC can be bidirectional using long poll.\n> >\n> > /jonas\n> >\n> >> I was thinking about something like this that could add the ability for\n> module extensions in the core client.\n> >>\n> >> When messages are received, modules hooks are called with the message\n> data.\n> >>\n> >> They can then handle, mark the peer invalid, push a message to the peer\n> or pass through an alternate command.  Also, modules could have their own\n> private commands prefixed by \"x:\" or something like that.\n> >>\n> >> The idea is that the base P2P layer is left undisturbed, but there is\n> now a way to create \"enhanced features\" that some peers support.\n> >>\n> >> My end goal is to support using lightning network micropayments to\n> allow people to pay for better node access - creating a market for node\n> services.\n> >>\n> >> But I don't think this should be \"baked in\" to core.   Nor do I think\n> it should be a \"patch\".   It should be a linked-in module, optionally\n> compiled and added to bitcoin conf, then loaded via dlopen().    Modules\n> should be slightly robust to Bitcoin versions changing out from under them,\n> but not if the network layer is changed.   This can be ensured by a)\n> keeping a module version number, and b) treating module responses as if\n> they were just received from the network.   Any module incompatibility\n> should throw an exception...ensuring broken peers don't stay online.\n> >\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170814/0700aadc/attachment-0001.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2017-08-15T04:44:52",
                "message_text_only": "The idea is that some peers, when you connect to them will work fine for\nsome time, but you need to find out the rate for services and send a\nmicropayment to maintain the connection.   This creates an optional pay\nlayer for high quality services, and also creates DDOS resistance in this\nfallback layer.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170815/48966697/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Would anyone object to adding a dlopen message hook system?",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Erik Aronesty",
                "Jonas Schnelli",
                "Mark Friedenbach"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 10943
        }
    },
    {
        "title": "[bitcoin-dev] BIP proposal, Pay to Contract BIP43 Application",
        "thread_messages": [
            {
                "author": "omar shibli",
                "date": "2017-08-14T06:05:35",
                "message_text_only": "Hey all,\n\nA lot of us familiar with the pay to contract protocol, and how it uses\ncleverly the homomorphic property of elliptic curve encryption system to\nachieve it.\nUnfortunately, there is no standard specification on how to conduct such\ntransactions in the cyberspace.\n\nWe have developed a basic trade finance application that relies on the\noriginal idea described in the Homomorphic Payment Addresses and the\nPay-to-Contract Protocol paper, yet we have generalized it and made it\nBIP43 complaint.\n\nWe would like to share our method, and get your feedback about it,\nhopefully this effort will result into a standard for the benefit of the\ncommunity.\n\nAbstract idea:\n\nWe define the following levels in BIP32 path.\nm / purpose' / coin_type' / contract_id' / *\n\ncontract_id is is an arbitrary number within the valid range of indices.\n\nThen we define, contract base as following prefix:\nm / purpose' / coin_type' / contract_id'\n\ncontract commitment address is computed as follows:\nhash document using cryptographic hash function of your choice (e.g. blake2)\nmap hash to partial derivation path\nConvert hash to binary array.\nPartition the array into parts, each part length should be 16.\nConvert each part to integer in decimal format.\nConvert each integer to string.\nJoin all strings with slash `/`.\ncompute child public key by chaining the derivation path from step 2 with\ncontract base:\nm/<contract_base>/<hash_derivation_path>\ncompute address\nExample:\n\nmaster private extended key:\nxprv9s21ZrQH143K2JF8RafpqtKiTbsbaxEeUaMnNHsm5o6wCW3z8ySyH4UxFVSfZ8n7ESu7fgir8imbZKLYVBxFPND1pniTZ81vKfd45EHKX73\ncoin type: 0\ncontract id: 7777777\n\ncontract base computation :\n\nderivation path:\nm/999'/0'/7777777'\ncontract base public extended key:\nxpub6CMCS9rY5GKdkWWyoeXEbmJmxGgDcbihofyARxucufdw7k3oc1JNnniiD5H2HynKBwhaem4KnPTue6s9R2tcroqkHv7vpLFBgbKRDwM5WEE\n\nContract content:\nfoo\n\nContract sha256 signature:\n2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\n\nContract partial derivation path:\n11302/46187/26879/50831/63899/17724/7472/16692/4930/11632/25731/49056/63882/24200/25190/59310\n\nContract commitment pub key path:\nm/999'/0'/7777777'/11302/46187/26879/50831/63899/17724/7472/16692/4930/11632/25731/49056/63882/24200/25190/59310\nor\n<contract_base_extended_pub_key>/11302/46187/26879/50831/63899/17724/7472/16692/4930/11632/25731/49056/63882/24200/25190/59310\n\nContract commitment pub key:\nxpub6iQVNpbZxdf9QJC8mGmz7cd3Cswt2itcQofZbKmyka5jdvQKQCqYSDFj8KCmRm4GBvcQW8gaFmDGAfDyz887msEGqxb6Pz4YUdEH8gFuaiS\n\nContract commitment address:\n17yTyx1gXPPkEUN1Q6Tg3gPFTK4dhvmM5R\n\n\nYou can find the full BIP draft in the following link:\nhttps://github.com/commerceblock/pay-to-contract-protocol-specification/blob/master/bip-draft.mediawiki\n\n\nRegards,\nOmar\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170814/73720ef5/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2017-08-15T05:12:11",
                "message_text_only": "This construction appears to me to be completely insecure.\n\n\nSay my pubkey (the result of the derivation path) is P.\n\nWe agree to contract C1.   A payment is made to P + G*H(C1).\n\nBut in secret, I constructed contract C2 and pubkey Q and set P = Q + G*H(C2).\n\nNow I can take that payment (paid to Q + G*(C1) + G*H(C2)) and assert\nit was in act a payment to P' + G*H(C2).   (P' is simply Q + G*H(C1))\n\nI don't see anything in the proposal that addresses this. Am I missing it?\n\nThe applications are also not clear to me, and it doesn't appear to\naddress durability issues (how do you avoid losing your funds if you\nlose the exact contract?).\n\n\n\n\nOn Mon, Aug 14, 2017 at 6:05 AM, omar shibli via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Hey all,\n>\n> A lot of us familiar with the pay to contract protocol, and how it uses\n> cleverly the homomorphic property of elliptic curve encryption system to\n> achieve it.\n> Unfortunately, there is no standard specification on how to conduct such\n> transactions in the cyberspace.\n>\n> We have developed a basic trade finance application that relies on the\n> original idea described in the Homomorphic Payment Addresses and the\n> Pay-to-Contract Protocol paper, yet we have generalized it and made it BIP43\n> complaint.\n>\n> We would like to share our method, and get your feedback about it, hopefully\n> this effort will result into a standard for the benefit of the community.\n>\n> Abstract idea:\n>\n> We define the following levels in BIP32 path.\n> m / purpose' / coin_type' / contract_id' / *\n>\n> contract_id is is an arbitrary number within the valid range of indices.\n>\n> Then we define, contract base as following prefix:\n> m / purpose' / coin_type' / contract_id'\n>\n> contract commitment address is computed as follows:\n> hash document using cryptographic hash function of your choice (e.g. blake2)\n> map hash to partial derivation path\n> Convert hash to binary array.\n> Partition the array into parts, each part length should be 16.\n> Convert each part to integer in decimal format.\n> Convert each integer to string.\n> Join all strings with slash `/`.\n> compute child public key by chaining the derivation path from step 2 with\n> contract base:\n> m/<contract_base>/<hash_derivation_path>\n> compute address\n> Example:\n>\n> master private extended key:\n> xprv9s21ZrQH143K2JF8RafpqtKiTbsbaxEeUaMnNHsm5o6wCW3z8ySyH4UxFVSfZ8n7ESu7fgir8imbZKLYVBxFPND1pniTZ81vKfd45EHKX73\n> coin type: 0\n> contract id: 7777777\n>\n> contract base computation :\n>\n> derivation path:\n> m/999'/0'/7777777'\n> contract base public extended key:\n> xpub6CMCS9rY5GKdkWWyoeXEbmJmxGgDcbihofyARxucufdw7k3oc1JNnniiD5H2HynKBwhaem4KnPTue6s9R2tcroqkHv7vpLFBgbKRDwM5WEE\n>\n> Contract content:\n> foo\n>\n> Contract sha256 signature:\n> 2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\n>\n> Contract partial derivation path:\n> 11302/46187/26879/50831/63899/17724/7472/16692/4930/11632/25731/49056/63882/24200/25190/59310\n>\n> Contract commitment pub key path:\n> m/999'/0'/7777777'/11302/46187/26879/50831/63899/17724/7472/16692/4930/11632/25731/49056/63882/24200/25190/59310\n> or\n> <contract_base_extended_pub_key>/11302/46187/26879/50831/63899/17724/7472/16692/4930/11632/25731/49056/63882/24200/25190/59310\n>\n> Contract commitment pub key:\n> xpub6iQVNpbZxdf9QJC8mGmz7cd3Cswt2itcQofZbKmyka5jdvQKQCqYSDFj8KCmRm4GBvcQW8gaFmDGAfDyz887msEGqxb6Pz4YUdEH8gFuaiS\n>\n> Contract commitment address:\n> 17yTyx1gXPPkEUN1Q6Tg3gPFTK4dhvmM5R\n>\n>\n> You can find the full BIP draft in the following link:\n> https://github.com/commerceblock/pay-to-contract-protocol-specification/blob/master/bip-draft.mediawiki\n>\n>\n> Regards,\n> Omar\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "omar shibli",
                "date": "2017-08-15T16:40:36",
                "message_text_only": "Thank you for your time Gregory, I really appreciate that.\n\nWhat we are describing here is a method to embed cryptographic signatures\ninto a public key based on HD Wallets - BIP32.\nIn a practical application, we should have two cryptographic signatures\nfrom both sides, I don't think in that case your scenario would be an issue.\n\nMore specifically in our application, we do the following construction:\n\ncontract base: m/200'/0'/<contract_number>'\npayment base (merchant commitment):\ncontract_base/<merchant_contract_signature>\npayment address (customer commitment):\ncontract_base/<merchant_contract_signature>/<customer_contract_signature>\n\npayment address funds could be reclaimed only if the\ncustomer_contract_signature is provided by the customer.\n\nIn terms of durability, our app is pretty simple at this point, we don't\nstore anything, we let customer download and manage the files.\n\nI will update the BIP to address your concerns.\n\nOn Tue, Aug 15, 2017 at 8:12 AM, Gregory Maxwell <greg at xiph.org> wrote:\n\n> This construction appears to me to be completely insecure.\n>\n>\n> Say my pubkey (the result of the derivation path) is P.\n>\n> We agree to contract C1.   A payment is made to P + G*H(C1).\n>\n> But in secret, I constructed contract C2 and pubkey Q and set P = Q +\n> G*H(C2).\n>\n> Now I can take that payment (paid to Q + G*(C1) + G*H(C2)) and assert\n> it was in act a payment to P' + G*H(C2).   (P' is simply Q + G*H(C1))\n>\n> I don't see anything in the proposal that addresses this. Am I missing it?\n>\n> The applications are also not clear to me, and it doesn't appear to\n> address durability issues (how do you avoid losing your funds if you\n> lose the exact contract?).\n>\n>\n>\n>\n> On Mon, Aug 14, 2017 at 6:05 AM, omar shibli via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > Hey all,\n> >\n> > A lot of us familiar with the pay to contract protocol, and how it uses\n> > cleverly the homomorphic property of elliptic curve encryption system to\n> > achieve it.\n> > Unfortunately, there is no standard specification on how to conduct such\n> > transactions in the cyberspace.\n> >\n> > We have developed a basic trade finance application that relies on the\n> > original idea described in the Homomorphic Payment Addresses and the\n> > Pay-to-Contract Protocol paper, yet we have generalized it and made it\n> BIP43\n> > complaint.\n> >\n> > We would like to share our method, and get your feedback about it,\n> hopefully\n> > this effort will result into a standard for the benefit of the community.\n> >\n> > Abstract idea:\n> >\n> > We define the following levels in BIP32 path.\n> > m / purpose' / coin_type' / contract_id' / *\n> >\n> > contract_id is is an arbitrary number within the valid range of indices.\n> >\n> > Then we define, contract base as following prefix:\n> > m / purpose' / coin_type' / contract_id'\n> >\n> > contract commitment address is computed as follows:\n> > hash document using cryptographic hash function of your choice (e.g.\n> blake2)\n> > map hash to partial derivation path\n> > Convert hash to binary array.\n> > Partition the array into parts, each part length should be 16.\n> > Convert each part to integer in decimal format.\n> > Convert each integer to string.\n> > Join all strings with slash `/`.\n> > compute child public key by chaining the derivation path from step 2 with\n> > contract base:\n> > m/<contract_base>/<hash_derivation_path>\n> > compute address\n> > Example:\n> >\n> > master private extended key:\n> > xprv9s21ZrQH143K2JF8RafpqtKiTbsbaxEeUaMnNHsm5o6wCW3z8ySyH4Ux\n> FVSfZ8n7ESu7fgir8imbZKLYVBxFPND1pniTZ81vKfd45EHKX73\n> > coin type: 0\n> > contract id: 7777777\n> >\n> > contract base computation :\n> >\n> > derivation path:\n> > m/999'/0'/7777777'\n> > contract base public extended key:\n> > xpub6CMCS9rY5GKdkWWyoeXEbmJmxGgDcbihofyARxucufdw7k3oc1JNnnii\n> D5H2HynKBwhaem4KnPTue6s9R2tcroqkHv7vpLFBgbKRDwM5WEE\n> >\n> > Contract content:\n> > foo\n> >\n> > Contract sha256 signature:\n> > 2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\n> >\n> > Contract partial derivation path:\n> > 11302/46187/26879/50831/63899/17724/7472/16692/4930/11632/\n> 25731/49056/63882/24200/25190/59310\n> >\n> > Contract commitment pub key path:\n> > m/999'/0'/7777777'/11302/46187/26879/50831/63899/17724/\n> 7472/16692/4930/11632/25731/49056/63882/24200/25190/59310\n> > or\n> > <contract_base_extended_pub_key>/11302/46187/26879/50831/\n> 63899/17724/7472/16692/4930/11632/25731/49056/63882/24200/25190/59310\n> >\n> > Contract commitment pub key:\n> > xpub6iQVNpbZxdf9QJC8mGmz7cd3Cswt2itcQofZbKmyka5jdvQKQCqYSDFj\n> 8KCmRm4GBvcQW8gaFmDGAfDyz887msEGqxb6Pz4YUdEH8gFuaiS\n> >\n> > Contract commitment address:\n> > 17yTyx1gXPPkEUN1Q6Tg3gPFTK4dhvmM5R\n> >\n> >\n> > You can find the full BIP draft in the following link:\n> > https://github.com/commerceblock/pay-to-contract-\n> protocol-specification/blob/master/bip-draft.mediawiki\n> >\n> >\n> > Regards,\n> > Omar\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170815/4f5eec39/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP proposal, Pay to Contract BIP43 Application",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "omar shibli",
                "Gregory Maxwell"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 12036
        }
    },
    {
        "title": "[bitcoin-dev] Fwd: Proposal of a new BIP : annual splitting blockchain database to reduce its size.",
        "thread_messages": [
            {
                "author": "\u0410\u043b\u0435\u043a\u0441\u0435\u0439 \u041c\u0443\u0442\u043e\u0432\u043a\u0438\u043d",
                "date": "2017-08-16T16:20:45",
                "message_text_only": "Let me describe the possible improvement of the bitcoin blockchain database\n(BBD)  size in general terms.\n\nWe can implement new routine : annual split of the BBD. Reason is that\n140gb full wallet unconvinience.\n\nBBD splits in two parts :\n1) old blocks before the date of split and\n2) new blocks, starting from first technical block with all rolled totals\non the date of split.\n    (also possible transfer of tiny totals due to their unprofitability to\nthe miners, so we cut long tail of tiny holders)\n3) old blocks packs into annual megablocks and stores in the side archive\nchain for some needs for FBI investigations or other goals.\n\n\nThanks for your attention,\n\nAlexey Mutovkin\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170816/deb9a7b5/attachment.html>"
            },
            {
                "author": "Nick ODell",
                "date": "2017-08-16T16:52:01",
                "message_text_only": "What makes this approach better than the prune option of Bitcoin?\n\nOn Wed, Aug 16, 2017 at 10:20 AM, \u0410\u043b\u0435\u043a\u0441\u0435\u0439 \u041c\u0443\u0442\u043e\u0432\u043a\u0438\u043d via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> Let me describe the possible improvement of the bitcoin blockchain\n> database (BBD)  size in general terms.\n>\n> We can implement new routine : annual split of the BBD. Reason is that\n> 140gb full wallet unconvinience.\n>\n> BBD splits in two parts :\n> 1) old blocks before the date of split and\n> 2) new blocks, starting from first technical block with all rolled totals\n> on the date of split.\n>     (also possible transfer of tiny totals due to their unprofitability to\n> the miners, so we cut long tail of tiny holders)\n> 3) old blocks packs into annual megablocks and stores in the side archive\n> chain for some needs for FBI investigations or other goals.\n>\n>\n> Thanks for your attention,\n>\n> Alexey Mutovkin\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170816/394d6a3f/attachment.html>"
            },
            {
                "author": "\u0410\u043b\u0435\u043a\u0441\u0435\u0439 \u041c\u0443\u0442\u043e\u0432\u043a\u0438\u043d",
                "date": "2017-08-16T17:37:34",
                "message_text_only": "I read about prune option right now, actually i didn't hear about it before.\nYes this option can save some disk space but afaik first (awful N-days\nlasting) synchronization still requires to download full database.\nMy approach also cuts database and replaces all old blocks (except say last\n6 blocks for security reason)\nwith series of blocks with rolled initial totals and optionally purged from\ntiny wallets crap (storing on six thousand current nodes and on the swarm\nof full wallets\n information that John have 100 satosi is too expensive for us and we may\nannually clear that balance as fee for miners or just delete).\n\nSo almost all nodes can hold only the rolled database (i can't estimate\ncompression ration of the rolled database now, i am not advanced user as\nyou can see).\n And only much less amount of archive nodes holds full expanded database.\n\n\n\n\n\n\n\n\n\n\n\n\n2017-08-16 19:52 GMT+03:00 Nick ODell <nickodell at gmail.com>:\n\n> What makes this approach better than the prune option of Bitcoin?\n>\n> On Wed, Aug 16, 2017 at 10:20 AM, \u0410\u043b\u0435\u043a\u0441\u0435\u0439 \u041c\u0443\u0442\u043e\u0432\u043a\u0438\u043d via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>>\n>> Let me describe the possible improvement of the bitcoin blockchain\n>> database (BBD)  size in general terms.\n>>\n>> We can implement new routine : annual split of the BBD. Reason is that\n>> 140gb full wallet unconvinience.\n>>\n>> BBD splits in two parts :\n>> 1) old blocks before the date of split and\n>> 2) new blocks, starting from first technical block with all rolled totals\n>> on the date of split.\n>>     (also possible transfer of tiny totals due to their unprofitability\n>> to the miners, so we cut long tail of tiny holders)\n>> 3) old blocks packs into annual megablocks and stores in the side archive\n>> chain for some needs for FBI investigations or other goals.\n>>\n>>\n>> Thanks for your attention,\n>>\n>> Alexey Mutovkin\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170816/b3e2dc85/attachment.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2017-08-16T18:33:47",
                "message_text_only": "To have a BIP, you need to explain not only *why* you want to do something, \nbut also *what specifically* to do, and *how* to do it. This concept \n(historically known as \"flip the chain\" and/or \"UTXO commitments\") is not new, \nmerely complicated to design and implement.\n\nLuke\n\n\nOn Wednesday 16 August 2017 4:20:45 PM \u0410\u043b\u0435\u043a\u0441\u0435\u0439 \u041c\u0443\u0442\u043e\u0432\u043a\u0438\u043d via bitcoin-dev wrote:\n> Let me describe the possible improvement of the bitcoin blockchain database\n> (BBD)  size in general terms.\n> \n> We can implement new routine : annual split of the BBD. Reason is that\n> 140gb full wallet unconvinience.\n> \n> BBD splits in two parts :\n> 1) old blocks before the date of split and\n> 2) new blocks, starting from first technical block with all rolled totals\n> on the date of split.\n>     (also possible transfer of tiny totals due to their unprofitability to\n> the miners, so we cut long tail of tiny holders)\n> 3) old blocks packs into annual megablocks and stores in the side archive\n> chain for some needs for FBI investigations or other goals.\n> \n> \n> Thanks for your attention,\n> \n> Alexey Mutovkin"
            }
        ],
        "thread_summary": {
            "title": "Fwd: Proposal of a new BIP : annual splitting blockchain database to reduce its size.",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Nick ODell",
                "\u0410\u043b\u0435\u043a\u0441\u0435\u0439 \u041c\u0443\u0442\u043e\u0432\u043a\u0438\u043d",
                "Luke Dashjr"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 5521
        }
    },
    {
        "title": "[bitcoin-dev] Fwd: [Lightning-dev] Lightning in the setting of blockchain hardforks",
        "thread_messages": [
            {
                "author": "Bryan Bishop",
                "date": "2017-08-17T11:31:30",
                "message_text_only": "---------- Forwarded message ----------\nFrom: Christian Decker <decker.christian at gmail.com>\nDate: Thu, Aug 17, 2017 at 5:39 AM\nSubject: Re: [Lightning-dev] Lightning in the setting of blockchain\nhardforks\nTo: Martin Schwarz <martin.schwarz at gmail.com>,\nlightning-dev at lists.linuxfoundation.org\n\n\nHi Martin,\n\nthis is the perfect venue to discuss this, welcome to the mailing list :-)\nLike you I think that using the first forked block as the forkchain's\ngenesis block is the way to go, keeping the non-forked blockchain on the\noriginal genesis hash, to avoid disruption. It may become more difficult in\nthe case one chain doesn't declare itself to be the forked chain.\n\nEven more interesting are channels that are open during the fork. In these\ncases we open a single channel, and will have to settle two. If no replay\nprotection was implemented on the fork, then we can use the last commitment\nto close the channel (updates should be avoided since they now double any\nintended effect), if replay protection was implemented then commitments\nbecome invalid on the fork, and people will lose money.\n\nFun times ahead :-)\n\nCheers,\nChristian\n\nOn Thu, Aug 17, 2017 at 10:53 AM Martin Schwarz <martin.schwarz at gmail.com>\nwrote:\n\n> Dear all,\n>\n> currently the chain_id allows to distinguish blockchains by the hash of\n> their genesis block.\n>\n> With hardforks branching off of the Bitcoin blockchain, how can Lightning\n> work on (or across)\n> distinct, permanent forks of a parent blockchain that share the same\n> genesis block?\n>\n> I suppose changing the definition of chain_id to the hash of the first\n> block of the new\n> branch and requiring replay and wipe-out protection should be sufficient.\n> But can we\n> relax these requirements? Are slow block times an issue? Can we use\n> Lightning to transact\n> on \"almost frozen\" block chains suffering from a sudden loss of hashpower?\n>\n> Has there been any previous discussion or study of Lightning in the\n> setting of hardforks?\n> (Is this the right place to discuss this? If not, where would be the right\n> place?)\n>\n> thanks,\n> Martin\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n\n_______________________________________________\nLightning-dev mailing list\nLightning-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n\n\n\n\n-- \n- Bryan\nhttp://heybryan.org/\n1 512 203 0507\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170817/5c6ec3aa/attachment-0001.html>"
            },
            {
                "author": "Conrad Burchert",
                "date": "2017-08-17T12:48:15",
                "message_text_only": "Some notes:\n\nHardforks like Bitcoin ABC without a malleability fix are very unlikely to\nhave payment channels, so the problem does not exist for those.\n\nThe designers of a hardfork which does have a malleability fix will\nprobably know about payment channels, so they can just build a replay\nprotection that allows the execution of old commitments. That needs some\nkind of timestamping of commitments, which would have to be integrated in\nthe channel design. The easiest way would be to just write the time of\nsigning the commitment in the transaction and the replay protection accepts\nold commitments, but rejects one's which were signed after the hardfork.\nThese timestamps can essentially be one bit (before or after a hardfork)\nand if the replay protection in the hardfork only accepts old commitments\nfor something like a year, then it can be reused for more hardforks later\non. Maybe someone comes up with an interesting way of doing this without\nusing space.\n\nNevertheless hardforking while having channels open will always be a mess\nas an open channel requires you to watch the blockchain. Anybody who is\njust not aware of the hardfork or is updating his client a few days too\nlate, can get his money stolen by an old commitment transaction where he\nforgets to retaliate on the new chain. As other's can likely figure out\nyour client version the risk of retaliation is not too big for an attacker.\n\n\n\n2017-08-17 13:31 GMT+02:00 Bryan Bishop via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org>:\n\n>\n> ---------- Forwarded message ----------\n> From: Christian Decker <decker.christian at gmail.com>\n> Date: Thu, Aug 17, 2017 at 5:39 AM\n> Subject: Re: [Lightning-dev] Lightning in the setting of blockchain\n> hardforks\n> To: Martin Schwarz <martin.schwarz at gmail.com>, lightning-dev at lists.\n> linuxfoundation.org\n>\n>\n> Hi Martin,\n>\n> this is the perfect venue to discuss this, welcome to the mailing list :-)\n> Like you I think that using the first forked block as the forkchain's\n> genesis block is the way to go, keeping the non-forked blockchain on the\n> original genesis hash, to avoid disruption. It may become more difficult in\n> the case one chain doesn't declare itself to be the forked chain.\n>\n> Even more interesting are channels that are open during the fork. In these\n> cases we open a single channel, and will have to settle two. If no replay\n> protection was implemented on the fork, then we can use the last commitment\n> to close the channel (updates should be avoided since they now double any\n> intended effect), if replay protection was implemented then commitments\n> become invalid on the fork, and people will lose money.\n>\n> Fun times ahead :-)\n>\n> Cheers,\n> Christian\n>\n> On Thu, Aug 17, 2017 at 10:53 AM Martin Schwarz <martin.schwarz at gmail.com>\n> wrote:\n>\n>> Dear all,\n>>\n>> currently the chain_id allows to distinguish blockchains by the hash of\n>> their genesis block.\n>>\n>> With hardforks branching off of the Bitcoin blockchain, how can Lightning\n>> work on (or across)\n>> distinct, permanent forks of a parent blockchain that share the same\n>> genesis block?\n>>\n>> I suppose changing the definition of chain_id to the hash of the first\n>> block of the new\n>> branch and requiring replay and wipe-out protection should be sufficient.\n>> But can we\n>> relax these requirements? Are slow block times an issue? Can we use\n>> Lightning to transact\n>> on \"almost frozen\" block chains suffering from a sudden loss of hashpower?\n>>\n>> Has there been any previous discussion or study of Lightning in the\n>> setting of hardforks?\n>> (Is this the right place to discuss this? If not, where would be the\n>> right place?)\n>>\n>> thanks,\n>> Martin\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>\n>\n> --\n> - Bryan\n> http://heybryan.org/\n> 1 512 203 0507 <(512)%20203-0507>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170817/af84de89/attachment.html>"
            },
            {
                "author": "Natanael",
                "date": "2017-08-17T13:38:26",
                "message_text_only": "Couldn't scripts like this have a standardized \"hardfork unroll\" mechanism,\nwhere if a hardfork is activated and signaled to its clients, then those\ncommitments that are only meant for their original chain can be reversed\nand undone just on the hardfork? Then the users involved would just send an\nunroll transaction which is only valid on the hardfork.\n\n- Sent from my phone\n\nDen 17 aug. 2017 14:52 skrev \"Conrad Burchert via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org>:\n\n> Some notes:\n>\n> Hardforks like Bitcoin ABC without a malleability fix are very unlikely to\n> have payment channels, so the problem does not exist for those.\n>\n> The designers of a hardfork which does have a malleability fix will\n> probably know about payment channels, so they can just build a replay\n> protection that allows the execution of old commitments. That needs some\n> kind of timestamping of commitments, which would have to be integrated in\n> the channel design. The easiest way would be to just write the time of\n> signing the commitment in the transaction and the replay protection accepts\n> old commitments, but rejects one's which were signed after the hardfork.\n> These timestamps can essentially be one bit (before or after a hardfork)\n> and if the replay protection in the hardfork only accepts old commitments\n> for something like a year, then it can be reused for more hardforks later\n> on. Maybe someone comes up with an interesting way of doing this without\n> using space.\n>\n> Nevertheless hardforking while having channels open will always be a mess\n> as an open channel requires you to watch the blockchain. Anybody who is\n> just not aware of the hardfork or is updating his client a few days too\n> late, can get his money stolen by an old commitment transaction where he\n> forgets to retaliate on the new chain. As other's can likely figure out\n> your client version the risk of retaliation is not too big for an attacker.\n>\n>\n>\n> 2017-08-17 13:31 GMT+02:00 Bryan Bishop via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org>:\n>\n>>\n>> ---------- Forwarded message ----------\n>> From: Christian Decker <decker.christian at gmail.com>\n>> Date: Thu, Aug 17, 2017 at 5:39 AM\n>> Subject: Re: [Lightning-dev] Lightning in the setting of blockchain\n>> hardforks\n>> To: Martin Schwarz <martin.schwarz at gmail.com>,\n>> lightning-dev at lists.linuxfoundation.org\n>>\n>>\n>> Hi Martin,\n>>\n>> this is the perfect venue to discuss this, welcome to the mailing list :-)\n>> Like you I think that using the first forked block as the forkchain's\n>> genesis block is the way to go, keeping the non-forked blockchain on the\n>> original genesis hash, to avoid disruption. It may become more difficult in\n>> the case one chain doesn't declare itself to be the forked chain.\n>>\n>> Even more interesting are channels that are open during the fork. In\n>> these cases we open a single channel, and will have to settle two. If no\n>> replay protection was implemented on the fork, then we can use the last\n>> commitment to close the channel (updates should be avoided since they now\n>> double any intended effect), if replay protection was implemented then\n>> commitments become invalid on the fork, and people will lose money.\n>>\n>> Fun times ahead :-)\n>>\n>> Cheers,\n>> Christian\n>>\n>> On Thu, Aug 17, 2017 at 10:53 AM Martin Schwarz <martin.schwarz at gmail.com>\n>> wrote:\n>>\n>>> Dear all,\n>>>\n>>> currently the chain_id allows to distinguish blockchains by the hash of\n>>> their genesis block.\n>>>\n>>> With hardforks branching off of the Bitcoin blockchain, how can\n>>> Lightning work on (or across)\n>>> distinct, permanent forks of a parent blockchain that share the same\n>>> genesis block?\n>>>\n>>> I suppose changing the definition of chain_id to the hash of the first\n>>> block of the new\n>>> branch and requiring replay and wipe-out protection should be\n>>> sufficient. But can we\n>>> relax these requirements? Are slow block times an issue? Can we use\n>>> Lightning to transact\n>>> on \"almost frozen\" block chains suffering from a sudden loss of\n>>> hashpower?\n>>>\n>>> Has there been any previous discussion or study of Lightning in the\n>>> setting of hardforks?\n>>> (Is this the right place to discuss this? If not, where would be the\n>>> right place?)\n>>>\n>>> thanks,\n>>> Martin\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>>\n>>\n>>\n>> --\n>> - Bryan\n>> http://heybryan.org/\n>> 1 512 203 0507 <(512)%20203-0507>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170817/95edf34c/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Fwd: Lightning in the setting of blockchain hardforks",
            "categories": [
                "bitcoin-dev",
                "Lightning-dev"
            ],
            "authors": [
                "Bryan Bishop",
                "Natanael",
                "Conrad Burchert"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 12578
        }
    },
    {
        "title": "[bitcoin-dev] [BIP Proposal] Partially Signed Bitcoin Transaction (PSBT) format",
        "thread_messages": [
            {
                "author": "Andrew Chow",
                "date": "2017-08-18T22:11:14",
                "message_text_only": "Hi everyone,\n\nI would like to propose a standard format for unsigned and partially signed\ntransactions.\n\n===Abstract===\n\nThis document proposes a binary transaction format which contains the\ninformation\nnecessary for a signer to produce signatures for the transaction and holds\nthe\nsignatures for an input while the input does not have a complete set of\nsignatures.\nThe signer can be offline as all necessary information will be provided in\nthe\ntransaction.\n\n===Motivation===\n\nCreating unsigned or partially signed transactions to be passed around to\nmultiple\nsigners is currently implementation dependent, making it hard for people\nwho use\ndifferent wallet software from being able to easily do so. One of the goals\nof this\ndocument is to create a standard and extensible format that can be used\nbetween clients to allow\npeople to pass around the same transaction to sign and combine their\nsignatures. The\nformat is also designed to be easily extended for future use which is\nharder to do\nwith existing transaction formats.\n\nSigning transactions also requires users to have access to the UTXOs being\nspent. This transaction\nformat will allow offline signers such as air-gapped wallets and hardware\nwallets\nto be able to sign transactions without needing direct access to the UTXO\nset and without\nrisk of being defrauded.\n\nThe full text can be found here:\nhttps://github.com/achow101/bips/blob/bip-psbt/bip-psbt.mediawiki\n\nAndrew Chow\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170818/3166e8de/attachment.html>"
            },
            {
                "author": "Bryan Bishop",
                "date": "2017-08-21T00:00:19",
                "message_text_only": "On Fri, Aug 18, 2017 at 5:11 PM, Andrew Chow via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> I would like to propose a standard format for unsigned and partially\n> signed transactions.\n>\n\nJust a quick note but perhaps you and other readers would find this thread\n(on hardware wallet BIP drafting) to be tangentially related and useful:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-August/013008.html\n\n- Bryan\nhttp://heybryan.org/\n1 512 203 0507\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170820/693ea647/attachment.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2017-08-21T18:12:47",
                "message_text_only": "Some related thoughts and suggestion for an extension that kanzure\nsuggested I post here:\n\nHardware Wallet attacks by input ownership omission and fix\n----------------------------------------------------------------------------------\nSo a while back I realized that to have HW wallets do safe automated\ncoinjoins(without any user interaction be sure there are no fee dumps or\nhanding money to others) you have to protect yourself from the case of\nsigning one set of inputs while the other owned set is hidden from the\ndevice, then repeating the same action with the two sets reversed.\n\nNote that there is no support for such a mode in HW wallets today, but\ncould possibly greatly increase liquidity of JoinMarket like systems.\n\nFirst signing pass:\n1 BTC (yours, host tells ledger about it) --------\n                                                >   1.5 BTC\n1 BTC (yours, host fails to tell ledger about it)-\n\nSecond signing pass:\n\n1 BTC (yours, host fails to tell ledger) ---------\n                                                >   1.5 BTC\n1 BTC (yours, host tells ledger about it)---------\n\nIn this scenario, you sign the first input, thinking \"great I'm getting 0.5\nBTC for running coinjoin\" when in reality this will simply be re-played\nagain later with the inputs switched, *costing* you 0.5 BTC. (Ledger\ndoesn't support \"negative fees\", but imagine more more inputs are included\nthat aren't yours.)\n\nMore recently I noticed a more common issue along the same lines:\n\nWith Segwit inputs, the entire transaction referred to in the prevout is\ngenerally no longer included for HW wallet signing API. This greatly speeds\nup signing since potentially multiple MBs of transactions are no longer\npassed into the device, but comes with a cost: An attacker can claim\ncertain inputs' value is much lower than it actually is. In the first pass,\nthe host reports the first input's value properly, and the second as lower.\nThe signature on the first input will go through fine(value included in the\nsighash is only for that input), then attacker prompts a restart of\nsigning, reporting the 2nd value properly, and first value improperly low,\nwhich allows the attacker to report the same fee twice on the device. Both\nsignatures over each input are correct, but the user was prompted with an\ninvalid fee amount(too low).\n\nTo fix this I consulted with andytoshi and got something we think works for\nboth cases:\n\n1) When a signing device receives a partially signed transaction, all\ninputs must come with a ownership proof:\n- For the input at address A, a signature over H(A || x) using the key for\nA. 'x' is some private fixed key that only the signing device knows(most\nlikely some privkey along some unique bip32 path).\n- For each input ownership proof, the HW wallet validates each signature\nover the hashed message, then attempts to \"decode\" the hash by applying its\nown 'x'. If the hash doesn't match, it cannot be its own input.\n- Sign for every input that is yours\n\nThis at a minimum makes sure that the wallet's total \"balance\" will not go\ndown more than the reported fee.\n\nBenefits:\n- Still small memory footprint compared to legacy signing\n- Allows user-interactionless coinjoins without putting funds at risk\n- These proofs can be created at any time, collected at the front of any\nCoinJoin like protocol.\n- These proofs can be passed around as additional fields for Partially\nSigned Bitcoin Transactions:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-August/014838.html\n\nOn Sun, Aug 20, 2017 at 5:00 PM, Bryan Bishop via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Fri, Aug 18, 2017 at 5:11 PM, Andrew Chow via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> I would like to propose a standard format for unsigned and partially\n>> signed transactions.\n>>\n>\n> Just a quick note but perhaps you and other readers would find this thread\n> (on hardware wallet BIP drafting) to be tangentially related and useful:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> 2016-August/013008.html\n>\n> - Bryan\n> http://heybryan.org/\n> 1 512 203 0507 <(512)%20203-0507>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170821/27651b93/attachment-0001.html>"
            },
            {
                "author": "Jochen Hoenicke",
                "date": "2017-08-21T21:36:24",
                "message_text_only": "On 21.08.2017 20:12, Greg Sanders via bitcoin-dev wrote:\n> To fix this I consulted with andytoshi and got something we think works\n> for both cases:\n> \n> 1) When a signing device receives a partially signed transaction, all\n> inputs must come with a ownership proof:\n> - For the input at address A, a signature over H(A || x) using the key\n> for A. 'x' is some private fixed key that only the signing device\n> knows(most likely some privkey along some unique bip32 path).\n> - For each input ownership proof, the HW wallet validates each signature\n> over the hashed message, then attempts to \"decode\" the hash by applying\n> its own 'x'. If the hash doesn't match, it cannot be its own input.\n> - Sign for every input that is yours\n\nInteresting, basically a proof of non-ownership :), a proof that the\nhardware wallet doesn't own the address.\n\nBut shouldn't x be public, so that the device can verify the signature?\nCan you expand on this, what is exactly signed with which key and how is\nit checked?\n\nOne also has to make sure that it's not possible to reuse signatures as\nownership proof that were made for a different purpose.\n\n  Jochen"
            },
            {
                "author": "Greg Sanders",
                "date": "2017-08-22T19:26:30",
                "message_text_only": "If 'x' is public, that makes it identifiable and privacy-losing across\ninputs.\n\nTo avoid \"re-use\" I suppose you'd want to sign some message like\n`HMAC(\"ownership proof\", H(A || x) )` instead. Otherwise any signature you\nmake using `A` ends up being used as a proof you don't know the input(this\nseems like just details but to be more clear)...\n\nTo reiterate:\n\nSign `HMAC(\"ownership proof\", H(A || x) )` using `A`. Public verifiers see\n`HMAC(\"ownership proof\", some_random_hash_connected_to_A )` and the HWW\nthat owns that input can recreate `some_random_hash_connected_to_A` by `H(A\n|| x) )`\n\nOn Mon, Aug 21, 2017 at 2:36 PM, Jochen Hoenicke <hoenicke at gmail.com> wrote:\n\n> On 21.08.2017 20:12, Greg Sanders via bitcoin-dev wrote:\n> > To fix this I consulted with andytoshi and got something we think works\n> > for both cases:\n> >\n> > 1) When a signing device receives a partially signed transaction, all\n> > inputs must come with a ownership proof:\n> > - For the input at address A, a signature over H(A || x) using the key\n> > for A. 'x' is some private fixed key that only the signing device\n> > knows(most likely some privkey along some unique bip32 path).\n> > - For each input ownership proof, the HW wallet validates each signature\n> > over the hashed message, then attempts to \"decode\" the hash by applying\n> > its own 'x'. If the hash doesn't match, it cannot be its own input.\n> > - Sign for every input that is yours\n>\n> Interesting, basically a proof of non-ownership :), a proof that the\n> hardware wallet doesn't own the address.\n>\n> But shouldn't x be public, so that the device can verify the signature?\n> Can you expand on this, what is exactly signed with which key and how is\n> it checked?\n>\n> One also has to make sure that it's not possible to reuse signatures as\n> ownership proof that were made for a different purpose.\n>\n>   Jochen\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170822/6e555fac/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Partially Signed Bitcoin Transaction (PSBT) format",
            "categories": [
                "bitcoin-dev",
                "BIP Proposal"
            ],
            "authors": [
                "Andrew Chow",
                "Bryan Bishop",
                "Jochen Hoenicke",
                "Greg Sanders"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 9977
        }
    },
    {
        "title": "[bitcoin-dev] UTXO growth scaling solution proposal",
        "thread_messages": [
            {
                "author": "Thomas Guyot-Sionnest",
                "date": "2017-08-21T13:35:22",
                "message_text_only": "On 21/07/17 03:59 PM, Lucas Clemente Vella via bitcoin-dev wrote:\n> 2017-07-21 16:28 GMT-03:00 Major Kusanagi via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>>:\n> \n>     [...] But the fact is that if we want to make bitcoins last forever,\n>     we have the accept unbounded UTXO growth, which is unscalable. So\n>     the only solution is to limit UTXO growth, meaning bitcoins cannot\n>     last forever. This proposed solution however does not prevent\n>     Bitcoin from lasting forever.\n> \n>  \n> Unless there is a logical contradiction in this phrasing, the proposed\n> solution does not improves scalability:\n>  - \"Bitcoins lasting forever\" implies \"unscalable\";\n>  - \"not prevent Bitcoin from lasting forever\" implies \"Bitcoins lasting\n> forever\";\n>  - Thus: \"not prevent Bitcoin from lasting forever\" implies \"unscalable\".\n> \n> In practice, the only Bitcoin lost would be those whose owners forgot\n> about or has lost the keys, because everyone with a significant amount\n> of Bitcoins would always shift them around before it loses any luster (I\n> wouldn't bother to move my Bitcoins every 10 years). I don't know how to\n> estimate the percentage of UTXO is actually lost/forgotten, but I have\n> the opinion it isn't worth the hassle.\n> \n> As a side note, your estimate talks about block size, which is\n> determines blockchain size, which can be \"safely\" pruned (if you are not\n> considering new nodes might want to join the network, in case the full\n> history is needed to be stored somewhere). But UTXO size, albeit related\n> to the full blockchain size, is the part that currently can not be\n> safely pruned, so I don't see the relevance of the analysis.\n\nI think if we wanted to burn lost/stale coins a better approach would be\nreturning them to miner's as a fee - there will always be lost coins and\nminers will be able to get that additional revenue stream as the mining\nreward halves. I also don't think we need to worry about doing a gradual\nvalue loss neither, we should just put a limit on UTXO age in block\ncount (actually I would round it up to 210k blocks as explained below...).\n\n\nSo lets say for example we decide to keep 5 210k blocks \"generations\"\n(that's over 15 years), then on the first block of the 6th generation\nall UTXO's from the 1st generation are invalidated and returned into a\n\"pool\".\n\nGiven these (values in satoshis):\n\nPool \"P\" (invalided UTXO minus total value reclaimed since last halving)\nLeftover blocks \"B\" (210,000 minus blocks mined since last halving)\n\nThen every mined block can reclaim FLOOR(P/B) satoshi in addition to\nminer's reward and tx fees.\n\nIf the last block of a generation does not get the remainder of the pool\n(FLOOR(P/1) == P) it should get carried over.\n\n\nThis would ensure we can clear old blocks after a few generations and\nthat burnt/lost coins eventually get back in circulation. Also it would\nreduce the reliance of miners on actual TX fees.\n\n\nTo avoid excessive miner reward initially, for the first few iterations\nthe value of B could be increased (I haven't calculated the UTXO size of\nthe first 210k blocks but it could be excessively high...) or the value\neach block can reclaim could be caped (so we would reclaim at an\nartificial capacity until the pool depletes...).\n\n\nRegards,\n\n--\nThomas"
            },
            {
                "author": "Moral Agent",
                "date": "2017-08-21T14:26:35",
                "message_text_only": "A more forgiving option would be to have coins past a certain age evaporate\ninto mining rewards at some rate, rather than all at once. People might\nfind this approach easier to stomach as it avoids the \"I waited 1 block to\nmany and all of my coins vanished\" scenario.\n\nAnother approach would to demand that a certain minimum mining fee be\nincluded that is calculated based on the age of an input like this idea:\nhttps://www.reddit.com/r/Bitcoin/comments/35ilir/prioritizing_utxos_using_a_minimum_mining_fee/\n\nThis would result in the coins continuing to exist but not being\neconomically spendable, and therefore the UTXO information could be\narchived.\n\nOn Mon, Aug 21, 2017 at 9:35 AM, Thomas Guyot-Sionnest via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On 21/07/17 03:59 PM, Lucas Clemente Vella via bitcoin-dev wrote:\n> > 2017-07-21 16:28 GMT-03:00 Major Kusanagi via bitcoin-dev\n> > <bitcoin-dev at lists.linuxfoundation.org\n> > <mailto:bitcoin-dev at lists.linuxfoundation.org>>:\n> >\n> >     [...] But the fact is that if we want to make bitcoins last forever,\n> >     we have the accept unbounded UTXO growth, which is unscalable. So\n> >     the only solution is to limit UTXO growth, meaning bitcoins cannot\n> >     last forever. This proposed solution however does not prevent\n> >     Bitcoin from lasting forever.\n> >\n> >\n> > Unless there is a logical contradiction in this phrasing, the proposed\n> > solution does not improves scalability:\n> >  - \"Bitcoins lasting forever\" implies \"unscalable\";\n> >  - \"not prevent Bitcoin from lasting forever\" implies \"Bitcoins lasting\n> > forever\";\n> >  - Thus: \"not prevent Bitcoin from lasting forever\" implies \"unscalable\".\n> >\n> > In practice, the only Bitcoin lost would be those whose owners forgot\n> > about or has lost the keys, because everyone with a significant amount\n> > of Bitcoins would always shift them around before it loses any luster (I\n> > wouldn't bother to move my Bitcoins every 10 years). I don't know how to\n> > estimate the percentage of UTXO is actually lost/forgotten, but I have\n> > the opinion it isn't worth the hassle.\n> >\n> > As a side note, your estimate talks about block size, which is\n> > determines blockchain size, which can be \"safely\" pruned (if you are not\n> > considering new nodes might want to join the network, in case the full\n> > history is needed to be stored somewhere). But UTXO size, albeit related\n> > to the full blockchain size, is the part that currently can not be\n> > safely pruned, so I don't see the relevance of the analysis.\n>\n> I think if we wanted to burn lost/stale coins a better approach would be\n> returning them to miner's as a fee - there will always be lost coins and\n> miners will be able to get that additional revenue stream as the mining\n> reward halves. I also don't think we need to worry about doing a gradual\n> value loss neither, we should just put a limit on UTXO age in block\n> count (actually I would round it up to 210k blocks as explained below...).\n>\n>\n> So lets say for example we decide to keep 5 210k blocks \"generations\"\n> (that's over 15 years), then on the first block of the 6th generation\n> all UTXO's from the 1st generation are invalidated and returned into a\n> \"pool\".\n>\n> Given these (values in satoshis):\n>\n> Pool \"P\" (invalided UTXO minus total value reclaimed since last halving)\n> Leftover blocks \"B\" (210,000 minus blocks mined since last halving)\n>\n> Then every mined block can reclaim FLOOR(P/B) satoshi in addition to\n> miner's reward and tx fees.\n>\n> If the last block of a generation does not get the remainder of the pool\n> (FLOOR(P/1) == P) it should get carried over.\n>\n>\n> This would ensure we can clear old blocks after a few generations and\n> that burnt/lost coins eventually get back in circulation. Also it would\n> reduce the reliance of miners on actual TX fees.\n>\n>\n> To avoid excessive miner reward initially, for the first few iterations\n> the value of B could be increased (I haven't calculated the UTXO size of\n> the first 210k blocks but it could be excessively high...) or the value\n> each block can reclaim could be caped (so we would reclaim at an\n> artificial capacity until the pool depletes...).\n>\n>\n> Regards,\n>\n> --\n> Thomas\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170821/476f95f6/attachment-0001.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2017-08-21T17:24:09",
                "message_text_only": "1. If it only affects \"old dust\" UTXO's where the # of coins in the UTXO\naren't sufficient to pay some lower quantile of transaction fees, then\nthere can be little argument of theft or loss.\n\n2. There's another use-case for demurrage as well.\n\nComputation power may grow rapidly if quantum computing becomes more\ncommon.  At some point, Bitcoin may have to change the public key format\nfor coins and the POW used.\n\nIn order to do this, old coins will have to transact on the network, moving\ntheir value to a new format, with many more bits in the public key, for\nexample.   But since quantum computing isn't bounded by moore's law, so\nthis may need to be a regular upgrade every X years.   Rather than a\nregular \"bit widening hard fork\", the number of bits needed in a public\naddress format could be scaled to the difficulty of the new quantum hashing\nalgorithm that *also must *now grow in the # of bits over time.   To ensure\nthat coins are secure, those with too few bits must drop off the network.\nSo the timing for old coin demurrage can effectively be based on the\nquantum POW difficulty adjustments.   As long as the subsequent exponential\nrate of computation increase can be reasonably predicted (quantum version\nof moore's law), the new rate of decay can be pegged to a number of years.\n\n\n\nOn Mon, Aug 21, 2017 at 10:26 AM, Moral Agent via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> A more forgiving option would be to have coins past a certain age\n> evaporate into mining rewards at some rate, rather than all at once. People\n> might find this approach easier to stomach as it avoids the \"I waited 1\n> block to many and all of my coins vanished\" scenario.\n>\n> Another approach would to demand that a certain minimum mining fee be\n> included that is calculated based on the age of an input like this idea:\n> https://www.reddit.com/r/Bitcoin/comments/35ilir/\n> prioritizing_utxos_using_a_minimum_mining_fee/\n>\n> This would result in the coins continuing to exist but not being\n> economically spendable, and therefore the UTXO information could be\n> archived.\n>\n> On Mon, Aug 21, 2017 at 9:35 AM, Thomas Guyot-Sionnest via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> On 21/07/17 03:59 PM, Lucas Clemente Vella via bitcoin-dev wrote:\n>> > 2017-07-21 16:28 GMT-03:00 Major Kusanagi via bitcoin-dev\n>> > <bitcoin-dev at lists.linuxfoundation.org\n>> > <mailto:bitcoin-dev at lists.linuxfoundation.org>>:\n>> >\n>> >     [...] But the fact is that if we want to make bitcoins last forever,\n>> >     we have the accept unbounded UTXO growth, which is unscalable. So\n>> >     the only solution is to limit UTXO growth, meaning bitcoins cannot\n>> >     last forever. This proposed solution however does not prevent\n>> >     Bitcoin from lasting forever.\n>> >\n>> >\n>> > Unless there is a logical contradiction in this phrasing, the proposed\n>> > solution does not improves scalability:\n>> >  - \"Bitcoins lasting forever\" implies \"unscalable\";\n>> >  - \"not prevent Bitcoin from lasting forever\" implies \"Bitcoins lasting\n>> > forever\";\n>> >  - Thus: \"not prevent Bitcoin from lasting forever\" implies\n>> \"unscalable\".\n>> >\n>> > In practice, the only Bitcoin lost would be those whose owners forgot\n>> > about or has lost the keys, because everyone with a significant amount\n>> > of Bitcoins would always shift them around before it loses any luster (I\n>> > wouldn't bother to move my Bitcoins every 10 years). I don't know how to\n>> > estimate the percentage of UTXO is actually lost/forgotten, but I have\n>> > the opinion it isn't worth the hassle.\n>> >\n>> > As a side note, your estimate talks about block size, which is\n>> > determines blockchain size, which can be \"safely\" pruned (if you are not\n>> > considering new nodes might want to join the network, in case the full\n>> > history is needed to be stored somewhere). But UTXO size, albeit related\n>> > to the full blockchain size, is the part that currently can not be\n>> > safely pruned, so I don't see the relevance of the analysis.\n>>\n>> I think if we wanted to burn lost/stale coins a better approach would be\n>> returning them to miner's as a fee - there will always be lost coins and\n>> miners will be able to get that additional revenue stream as the mining\n>> reward halves. I also don't think we need to worry about doing a gradual\n>> value loss neither, we should just put a limit on UTXO age in block\n>> count (actually I would round it up to 210k blocks as explained below...).\n>>\n>>\n>> So lets say for example we decide to keep 5 210k blocks \"generations\"\n>> (that's over 15 years), then on the first block of the 6th generation\n>> all UTXO's from the 1st generation are invalidated and returned into a\n>> \"pool\".\n>>\n>> Given these (values in satoshis):\n>>\n>> Pool \"P\" (invalided UTXO minus total value reclaimed since last halving)\n>> Leftover blocks \"B\" (210,000 minus blocks mined since last halving)\n>>\n>> Then every mined block can reclaim FLOOR(P/B) satoshi in addition to\n>> miner's reward and tx fees.\n>>\n>> If the last block of a generation does not get the remainder of the pool\n>> (FLOOR(P/1) == P) it should get carried over.\n>>\n>>\n>> This would ensure we can clear old blocks after a few generations and\n>> that burnt/lost coins eventually get back in circulation. Also it would\n>> reduce the reliance of miners on actual TX fees.\n>>\n>>\n>> To avoid excessive miner reward initially, for the first few iterations\n>> the value of B could be increased (I haven't calculated the UTXO size of\n>> the first 210k blocks but it could be excessively high...) or the value\n>> each block can reclaim could be caped (so we would reclaim at an\n>> artificial capacity until the pool depletes...).\n>>\n>>\n>> Regards,\n>>\n>> --\n>> Thomas\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170821/6c3b768b/attachment.html>"
            },
            {
                "author": "Matthew Beton",
                "date": "2017-08-22T08:19:26",
                "message_text_only": "Okay so I quite like this idea. If we start removing at height 630000 or\n840000 (gives us 4-8 years to develop this solution), it stays nice and\nneat with the halving interval. We can look at this like so:\n\nB - the current block number\nP - how many blocks behind current the coin burning block is. (630000,\n840000, or otherwise.)\n\nEvery time we mine a new block, we go to block (B-P), and check for stale\ncoins. These coins get burnt up and pooled into block B's miner fees. This\nkeeps the mining rewards up in the long term, people are less likely to\nstop mining due to too low fees. It also encourages people to keep moving\ntheir money around the enconomy instead of just hording and leaving it.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170822/05609b11/attachment.html>"
            },
            {
                "author": "Chris Riley",
                "date": "2017-08-22T13:45:12",
                "message_text_only": "This seems to be drifting off into alt-coin discussion.  The idea that we\ncan change the rules and steal coins at a later date because they are\n\"stale\" or someone is \"hoarding\" is antithetical to one of the points of\nbitcoin in that you can no longer control your own money (\"be your own\nbank\") because someone can at a later date take your coins for some reason\nthat is outside your control and solely based on some rationalization by a\nthird party.  Once the rule is established that there are valid reasons why\nsomeone should not have control of their own bitcoins, what other reasons\nwill then be determined to be valid?\n\nI can imagine Hal Finney being revived (he was cryo-preserved at Alcor if\nyou aren't aware) after 100 or 200 years expecting his coins to be there\nonly to find out that his coins were deemed \"stale\" so were \"reclaimed\" (in\nthe current doublespeak - e.g. stolen or confiscated).  Or perhaps he\nlocked some for his children and they are found to be \"stale\" before they\nare available.  He said in March 2013, \"I think they're safe enough\" stored\nin a paper wallet.  Perhaps any remaining coins are no longer \"safe enough.\"\n\nAgain, this seems (a) more about an alt-coin/bitcoin fork or (b) better in\nbitcoin-discuss at best vs bitcoin-dev. I've seen it discussed many times\nsince 2010 and still do not agree with the rational that embracing allowing\nsomeone to steal someone else's coins for any reason is a useful change to\nbitcoin.\n\n\n\n\nOn Tue, Aug 22, 2017 at 4:19 AM, Matthew Beton via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Okay so I quite like this idea. If we start removing at height 630000 or\n> 840000 (gives us 4-8 years to develop this solution), it stays nice and\n> neat with the halving interval. We can look at this like so:\n>\n> B - the current block number\n> P - how many blocks behind current the coin burning block is. (630000,\n> 840000, or otherwise.)\n>\n> Every time we mine a new block, we go to block (B-P), and check for stale\n> coins. These coins get burnt up and pooled into block B's miner fees. This\n> keeps the mining rewards up in the long term, people are less likely to\n> stop mining due to too low fees. It also encourages people to keep moving\n> their money around the enconomy instead of just hording and leaving it.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170822/0237425a/attachment.html>"
            },
            {
                "author": "Matthew Beton",
                "date": "2017-08-22T14:04:49",
                "message_text_only": "Ok, I see your point. I was just thinking about the number of bitcoins tied\nup in wallets in which people lost the keys, but I suppose this isn't so\nmuch of a problem if it's well known that the bitcoins are all tied up. It\nwould be impossible to distinguish between bitcoins people have lost access\nto, and bitcoins that people have just left in the same wallet for a long\ntime.\n\nOn Tue, 22 Aug 2017, 3:45 pm Chris Riley <criley at gmail.com> wrote:\n\n> This seems to be drifting off into alt-coin discussion.  The idea that we\n> can change the rules and steal coins at a later date because they are\n> \"stale\" or someone is \"hoarding\" is antithetical to one of the points of\n> bitcoin in that you can no longer control your own money (\"be your own\n> bank\") because someone can at a later date take your coins for some reason\n> that is outside your control and solely based on some rationalization by a\n> third party.  Once the rule is established that there are valid reasons why\n> someone should not have control of their own bitcoins, what other reasons\n> will then be determined to be valid?\n>\n> I can imagine Hal Finney being revived (he was cryo-preserved at Alcor if\n> you aren't aware) after 100 or 200 years expecting his coins to be there\n> only to find out that his coins were deemed \"stale\" so were \"reclaimed\" (in\n> the current doublespeak - e.g. stolen or confiscated).  Or perhaps he\n> locked some for his children and they are found to be \"stale\" before they\n> are available.  He said in March 2013, \"I think they're safe enough\" stored\n> in a paper wallet.  Perhaps any remaining coins are no longer \"safe enough.\"\n>\n> Again, this seems (a) more about an alt-coin/bitcoin fork or (b) better in\n> bitcoin-discuss at best vs bitcoin-dev. I've seen it discussed many times\n> since 2010 and still do not agree with the rational that embracing allowing\n> someone to steal someone else's coins for any reason is a useful change to\n> bitcoin.\n>\n>\n>\n>\n> On Tue, Aug 22, 2017 at 4:19 AM, Matthew Beton via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Okay so I quite like this idea. If we start removing at height 630000 or\n>> 840000 (gives us 4-8 years to develop this solution), it stays nice and\n>> neat with the halving interval. We can look at this like so:\n>>\n>> B - the current block number\n>> P - how many blocks behind current the coin burning block is. (630000,\n>> 840000, or otherwise.)\n>>\n>> Every time we mine a new block, we go to block (B-P), and check for stale\n>> coins. These coins get burnt up and pooled into block B's miner fees. This\n>> keeps the mining rewards up in the long term, people are less likely to\n>> stop mining due to too low fees. It also encourages people to keep moving\n>> their money around the enconomy instead of just hording and leaving it.\n>>\n> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170822/d6bb3614/attachment-0001.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2017-08-22T14:29:26",
                "message_text_only": "I agree, it is only a good idea in the event of a quantum computing threat\nto the security of Bitcoin.\n\nOn Tue, Aug 22, 2017 at 9:45 AM, Chris Riley via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> This seems to be drifting off into alt-coin discussion.  The idea that we\n> can change the rules and steal coins at a later date because they are\n> \"stale\" or someone is \"hoarding\" is antithetical to one of the points of\n> bitcoin in that you can no longer control your own money (\"be your own\n> bank\") because someone can at a later date take your coins for some reason\n> that is outside your control and solely based on some rationalization by a\n> third party.  Once the rule is established that there are valid reasons why\n> someone should not have control of their own bitcoins, what other reasons\n> will then be determined to be valid?\n>\n> I can imagine Hal Finney being revived (he was cryo-preserved at Alcor if\n> you aren't aware) after 100 or 200 years expecting his coins to be there\n> only to find out that his coins were deemed \"stale\" so were \"reclaimed\" (in\n> the current doublespeak - e.g. stolen or confiscated).  Or perhaps he\n> locked some for his children and they are found to be \"stale\" before they\n> are available.  He said in March 2013, \"I think they're safe enough\" stored\n> in a paper wallet.  Perhaps any remaining coins are no longer \"safe enough.\"\n>\n> Again, this seems (a) more about an alt-coin/bitcoin fork or (b) better in\n> bitcoin-discuss at best vs bitcoin-dev. I've seen it discussed many times\n> since 2010 and still do not agree with the rational that embracing allowing\n> someone to steal someone else's coins for any reason is a useful change to\n> bitcoin.\n>\n>\n>\n>\n> On Tue, Aug 22, 2017 at 4:19 AM, Matthew Beton via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Okay so I quite like this idea. If we start removing at height 630000 or\n>> 840000 (gives us 4-8 years to develop this solution), it stays nice and\n>> neat with the halving interval. We can look at this like so:\n>>\n>> B - the current block number\n>> P - how many blocks behind current the coin burning block is. (630000,\n>> 840000, or otherwise.)\n>>\n>> Every time we mine a new block, we go to block (B-P), and check for stale\n>> coins. These coins get burnt up and pooled into block B's miner fees. This\n>> keeps the mining rewards up in the long term, people are less likely to\n>> stop mining due to too low fees. It also encourages people to keep moving\n>> their money around the enconomy instead of just hording and leaving it.\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170822/f68d99c8/attachment.html>"
            },
            {
                "author": "Thomas Guyot-Sionnest",
                "date": "2017-08-22T17:24:05",
                "message_text_only": "In any case when Hal Finney do not wake up from his 200years\ncryo-preservation (because unfortunately for him 200 years earlier they\ndid not know how to preserve a body well enough to resurrect it) he\nwould find that advance in computer technology made it trivial for\nanyone to steal his coins using the long-obsolete secp256k1 ec curve\n(which was done long before, as soon as it became profitable to crack\ndown the huge stash of coins stale in the early blocks)\n\nI just don't get that argument that you can't be \"your own bank\". The\nonly requirement coming from this would be to move your coins about once\nevery 10 years or so, which you should be able to do if you have your\nprivate keys (you should!). You say it may be something to consider when\ncomputer breakthroughs makes old outputs vulnerable, but I say it's not\n\"if\" but \"when\" it happens, and by telling firsthand people that their\ncoins requires moving every once in a long while you ensure they won't\ndo stupid things or come back 50 years from now and complain their\naddresses have been scavenged.\n\n--\nThomas\n\nOn 22/08/17 10:29 AM, Erik Aronesty via bitcoin-dev wrote:\n> I agree, it is only a good idea in the event of a quantum computing\n> threat to the security of Bitcoin.  \n>\n> On Tue, Aug 22, 2017 at 9:45 AM, Chris Riley via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>\n>     This seems to be drifting off into alt-coin discussion.  The idea\n>     that we can change the rules and steal coins at a later date\n>     because they are \"stale\" or someone is \"hoarding\" is antithetical\n>     to one of the points of bitcoin in that you can no longer control\n>     your own money (\"be your own bank\") because someone can at a later\n>     date take your coins for some reason that is outside your control\n>     and solely based on some rationalization by a third party.  Once\n>     the rule is established that there are valid reasons why someone\n>     should not have control of their own bitcoins, what other reasons\n>     will then be determined to be valid?\n>\n>     I can imagine Hal Finney being revived (he was cryo-preserved at\n>     Alcor if you aren't aware) after 100 or 200 years expecting his\n>     coins to be there only to find out that his coins were deemed\n>     \"stale\" so were \"reclaimed\" (in the current doublespeak - e.g.\n>     stolen or confiscated).  Or perhaps he locked some for his\n>     children and they are found to be \"stale\" before they are\n>     available.  He said in March 2013, \"I think they're safe enough\"\n>     stored in a paper wallet.  Perhaps any remaining coins are no\n>     longer \"safe enough.\"\n>\n>     Again, this seems (a) more about an alt-coin/bitcoin fork or (b)\n>     better in bitcoin-discuss at best vs bitcoin-dev. I've seen it\n>     discussed many times since 2010 and still do not agree with the\n>     rational that embracing allowing someone to steal someone else's\n>     coins for any reason is a useful change to bitcoin.\n>\n>\n>\n>\n>     On Tue, Aug 22, 2017 at 4:19 AM, Matthew Beton via bitcoin-dev\n>     <bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>\n>         Okay so I quite like this idea. If we start removing at height\n>         630000 or 840000 (gives us 4-8 years to develop this\n>         solution), it stays nice and neat with the halving interval.\n>         We can look at this like so:\n>\n>         B - the current block number\n>         P - how many blocks behind current the coin burning block is.\n>         (630000, 840000, or otherwise.)\n>\n>         Every time we mine a new block, we go to block (B-P), and\n>         check for stale coins. These coins get burnt up and pooled\n>         into block B's miner fees. This keeps the mining rewards up in\n>         the long term, people are less likely to stop mining due to\n>         too low fees. It also encourages people to keep moving their\n>         money around the enconomy instead of just hording and leaving it.\n>\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170822/bc4992c0/attachment.html>"
            },
            {
                "author": "Matthew Beton",
                "date": "2017-08-22T17:33:41",
                "message_text_only": "Very true, if Moore's law is still functional in 200 years, computers will\nbe 2^100 times faster (possibly more if quantum computing becomes\ncommonplace), and so old wallets may be easily cracked.\n\nWe will need a way to force people to use newer, higher security wallets,\nand turning coins to mining rewards is better solution than them just being\nhacked.\n\nOn Tue, 22 Aug 2017, 7:24 pm Thomas Guyot-Sionnest <dermoth at aei.ca> wrote:\n\n> In any case when Hal Finney do not wake up from his 200years\n> cryo-preservation (because unfortunately for him 200 years earlier they did\n> not know how to preserve a body well enough to resurrect it) he would find\n> that advance in computer technology made it trivial for anyone to steal his\n> coins using the long-obsolete secp256k1 ec curve (which was done long\n> before, as soon as it became profitable to crack down the huge stash of\n> coins stale in the early blocks)\n>\n> I just don't get that argument that you can't be \"your own bank\". The only\n> requirement coming from this would be to move your coins about once every\n> 10 years or so, which you should be able to do if you have your private\n> keys (you should!). You say it may be something to consider when computer\n> breakthroughs makes old outputs vulnerable, but I say it's not \"if\" but\n> \"when\" it happens, and by telling firsthand people that their coins\n> requires moving every once in a long while you ensure they won't do stupid\n> things or come back 50 years from now and complain their addresses have\n> been scavenged.\n>\n> --\n> Thomas\n>\n>\n> On 22/08/17 10:29 AM, Erik Aronesty via bitcoin-dev wrote:\n>\n> I agree, it is only a good idea in the event of a quantum computing threat\n> to the security of Bitcoin.\n>\n> On Tue, Aug 22, 2017 at 9:45 AM, Chris Riley via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> This seems to be drifting off into alt-coin discussion.  The idea that we\n>> can change the rules and steal coins at a later date because they are\n>> \"stale\" or someone is \"hoarding\" is antithetical to one of the points of\n>> bitcoin in that you can no longer control your own money (\"be your own\n>> bank\") because someone can at a later date take your coins for some reason\n>> that is outside your control and solely based on some rationalization by a\n>> third party.  Once the rule is established that there are valid reasons why\n>> someone should not have control of their own bitcoins, what other reasons\n>> will then be determined to be valid?\n>>\n>> I can imagine Hal Finney being revived (he was cryo-preserved at Alcor if\n>> you aren't aware) after 100 or 200 years expecting his coins to be there\n>> only to find out that his coins were deemed \"stale\" so were \"reclaimed\" (in\n>> the current doublespeak - e.g. stolen or confiscated).  Or perhaps he\n>> locked some for his children and they are found to be \"stale\" before they\n>> are available.  He said in March 2013, \"I think they're safe enough\" stored\n>> in a paper wallet.  Perhaps any remaining coins are no longer \"safe enough.\"\n>>\n>> Again, this seems (a) more about an alt-coin/bitcoin fork or (b) better\n>> in bitcoin-discuss at best vs bitcoin-dev. I've seen it discussed many\n>> times since 2010 and still do not agree with the rational that embracing\n>> allowing someone to steal someone else's coins for any reason is a useful\n>> change to bitcoin.\n>>\n>>\n>>\n>>\n>> On Tue, Aug 22, 2017 at 4:19 AM, Matthew Beton via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Okay so I quite like this idea. If we start removing at height 630000 or\n>>> 840000 (gives us 4-8 years to develop this solution), it stays nice and\n>>> neat with the halving interval. We can look at this like so:\n>>>\n>>> B - the current block number\n>>> P - how many blocks behind current the coin burning block is. (630000,\n>>> 840000, or otherwise.)\n>>>\n>>> Every time we mine a new block, we go to block (B-P), and check for\n>>> stale coins. These coins get burnt up and pooled into block B's miner fees.\n>>> This keeps the mining rewards up in the long term, people are less likely\n>>> to stop mining due to too low fees. It also encourages people to keep\n>>> moving their money around the enconomy instead of just hording and leaving\n>>> it.\n>>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170822/2180b316/attachment-0001.html>"
            },
            {
                "author": "Chris Riley",
                "date": "2017-08-22T18:55:15",
                "message_text_only": "The initial message I replied to stated in part, \"Okay so I quite like this\nidea. If we start removing at height 630000 or 840000 (gives us 4-8 years\nto develop this solution), it stays nice and neat with the halving\ninterval....\"\n\nThat is less than 3 years or less than 7 years  away. Much sooner than it\nis believed QC or Moore's law could impact bitcoin.  Changing bitcoin so as\nto require that early coins start getting \"scavenged\" at that date seems\nunneeded and irresponsible.  Besides, your ECDSA is only revealed when you\nspend the coins which does provide some quantum resistance.  Hal was just\nan example of people putting their coins away expecting them to be there at\nX years in the future, whether it is for himself or for his kids and wife.\n\n:-)\n\n\n\nOn Tue, Aug 22, 2017 at 1:33 PM, Matthew Beton <matthew.beton at gmail.com>\nwrote:\n\n> Very true, if Moore's law is still functional in 200 years, computers will\n> be 2^100 times faster (possibly more if quantum computing becomes\n> commonplace), and so old wallets may be easily cracked.\n>\n> We will need a way to force people to use newer, higher security wallets,\n> and turning coins to mining rewards is better solution than them just being\n> hacked.\n>\n> On Tue, 22 Aug 2017, 7:24 pm Thomas Guyot-Sionnest <dermoth at aei.ca> wrote:\n>\n>> In any case when Hal Finney do not wake up from his 200years\n>> cryo-preservation (because unfortunately for him 200 years earlier they did\n>> not know how to preserve a body well enough to resurrect it) he would find\n>> that advance in computer technology made it trivial for anyone to steal his\n>> coins using the long-obsolete secp256k1 ec curve (which was done long\n>> before, as soon as it became profitable to crack down the huge stash of\n>> coins stale in the early blocks)\n>>\n>> I just don't get that argument that you can't be \"your own bank\". The\n>> only requirement coming from this would be to move your coins about once\n>> every 10 years or so, which you should be able to do if you have your\n>> private keys (you should!). You say it may be something to consider when\n>> computer breakthroughs makes old outputs vulnerable, but I say it's not\n>> \"if\" but \"when\" it happens, and by telling firsthand people that their\n>> coins requires moving every once in a long while you ensure they won't do\n>> stupid things or come back 50 years from now and complain their addresses\n>> have been scavenged.\n>>\n>> --\n>> Thomas\n>>\n>>\n>> On 22/08/17 10:29 AM, Erik Aronesty via bitcoin-dev wrote:\n>>\n>> I agree, it is only a good idea in the event of a quantum computing\n>> threat to the security of Bitcoin.\n>>\n>> On Tue, Aug 22, 2017 at 9:45 AM, Chris Riley via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> This seems to be drifting off into alt-coin discussion.  The idea that\n>>> we can change the rules and steal coins at a later date because they are\n>>> \"stale\" or someone is \"hoarding\" is antithetical to one of the points of\n>>> bitcoin in that you can no longer control your own money (\"be your own\n>>> bank\") because someone can at a later date take your coins for some reason\n>>> that is outside your control and solely based on some rationalization by a\n>>> third party.  Once the rule is established that there are valid reasons why\n>>> someone should not have control of their own bitcoins, what other reasons\n>>> will then be determined to be valid?\n>>>\n>>> I can imagine Hal Finney being revived (he was cryo-preserved at Alcor\n>>> if you aren't aware) after 100 or 200 years expecting his coins to be there\n>>> only to find out that his coins were deemed \"stale\" so were \"reclaimed\" (in\n>>> the current doublespeak - e.g. stolen or confiscated).  Or perhaps he\n>>> locked some for his children and they are found to be \"stale\" before they\n>>> are available.  He said in March 2013, \"I think they're safe enough\" stored\n>>> in a paper wallet.  Perhaps any remaining coins are no longer \"safe enough.\"\n>>>\n>>> Again, this seems (a) more about an alt-coin/bitcoin fork or (b) better\n>>> in bitcoin-discuss at best vs bitcoin-dev. I've seen it discussed many\n>>> times since 2010 and still do not agree with the rational that embracing\n>>> allowing someone to steal someone else's coins for any reason is a useful\n>>> change to bitcoin.\n>>>\n>>>\n>>>\n>>>\n>>> On Tue, Aug 22, 2017 at 4:19 AM, Matthew Beton via bitcoin-dev <\n>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>>> Okay so I quite like this idea. If we start removing at height 630000\n>>>> or 840000 (gives us 4-8 years to develop this solution), it stays nice and\n>>>> neat with the halving interval. We can look at this like so:\n>>>>\n>>>> B - the current block number\n>>>> P - how many blocks behind current the coin burning block is. (630000,\n>>>> 840000, or otherwise.)\n>>>>\n>>>> Every time we mine a new block, we go to block (B-P), and check for\n>>>> stale coins. These coins get burnt up and pooled into block B's miner fees.\n>>>> This keeps the mining rewards up in the long term, people are less likely\n>>>> to stop mining due to too low fees. It also encourages people to keep\n>>>> moving their money around the enconomy instead of just hording and leaving\n>>>> it.\n>>>>\n>>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170822/b9c37929/attachment.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2017-08-22T20:06:01",
                "message_text_only": "> The initial message I replied to stated:\n\nYes, 3 years is silly.  But coin expiration and quantum resistance is\nsomething I've been thinking about for a while, so I tried to steer the\nconversation away from stealing old money for no reason ;).   Plus I like\nthe idea of making Bitcoin \"2000 year proof\".\n\n- I cannot imagine either SHA256 or any of our existing wallet formats\nsurviving 200 years, if we expect both moores law and quantum computing to\nbe a thing.   I would expect the PoW to be rendered obsolete before the\nBitcoin addresses.\n\n - A PoW change using Keccak and a flexible number of bits can be designed\nas a \"future hard fork\".  That is:  the existing POW can be automatically\nrendered obsolete... but only in the event that difficulty rises to the\nlevel of obsolescence.   Then the code for a new algorithm with a flexible\nnumber of bits and a difficulty that can scale for thousands of years can\nthen automatically kick in.\n\n - A new addresses format and signing protocols that use a flexible number\nof bits can be introduced.   The maximum number of supported bits can be\nconfigurable, and trivially changed.   These can be made immediately\navailable but completely optional.\n\n - The POW difficulty can be used to inform the expiration of any addresses\nthat can be compromised within 5 years assuming this power was somehow used\nto compromise them.   Some mechanism for translating global hashpower to\nbrute force attack power can be researched, and consesrvative estimates\nmade.   Right now, it's like \"heat death of the universe\" amount of time to\ncrack with every machine on the planet.   But hey... things change and 2000\nyears is a long time.   This information can be used to inform the\nexpiration and reclamation of old, compromised public addresses.\n\n- Planning a hard fork 100 to 1000 years out is a fun exercise\n\n\n\n\nOn Tue, Aug 22, 2017 at 2:55 PM, Chris Riley <criley at gmail.com> wrote:\n\n> The initial message I replied to stated in part, \"Okay so I quite like\n> this idea. If we start removing at height 630000 or 840000 (gives us 4-8\n> years to develop this solution), it stays nice and neat with the halving\n> interval....\"\n>\n> That is less than 3 years or less than 7 years  away. Much sooner than it\n> is believed QC or Moore's law could impact bitcoin.  Changing bitcoin so as\n> to require that early coins start getting \"scavenged\" at that date seems\n> unneeded and irresponsible.  Besides, your ECDSA is only revealed when you\n> spend the coins which does provide some quantum resistance.  Hal was just\n> an example of people putting their coins away expecting them to be there at\n> X years in the future, whether it is for himself or for his kids and wife.\n>\n> :-)\n>\n>\n>\n> On Tue, Aug 22, 2017 at 1:33 PM, Matthew Beton <matthew.beton at gmail.com>\n> wrote:\n>\n>> Very true, if Moore's law is still functional in 200 years, computers\n>> will be 2^100 times faster (possibly more if quantum computing becomes\n>> commonplace), and so old wallets may be easily cracked.\n>>\n>> We will need a way to force people to use newer, higher security wallets,\n>> and turning coins to mining rewards is better solution than them just being\n>> hacked.\n>>\n>> On Tue, 22 Aug 2017, 7:24 pm Thomas Guyot-Sionnest <dermoth at aei.ca>\n>> wrote:\n>>\n>>> In any case when Hal Finney do not wake up from his 200years\n>>> cryo-preservation (because unfortunately for him 200 years earlier they did\n>>> not know how to preserve a body well enough to resurrect it) he would find\n>>> that advance in computer technology made it trivial for anyone to steal his\n>>> coins using the long-obsolete secp256k1 ec curve (which was done long\n>>> before, as soon as it became profitable to crack down the huge stash of\n>>> coins stale in the early blocks)\n>>>\n>>> I just don't get that argument that you can't be \"your own bank\". The\n>>> only requirement coming from this would be to move your coins about once\n>>> every 10 years or so, which you should be able to do if you have your\n>>> private keys (you should!). You say it may be something to consider when\n>>> computer breakthroughs makes old outputs vulnerable, but I say it's not\n>>> \"if\" but \"when\" it happens, and by telling firsthand people that their\n>>> coins requires moving every once in a long while you ensure they won't do\n>>> stupid things or come back 50 years from now and complain their addresses\n>>> have been scavenged.\n>>>\n>>> --\n>>> Thomas\n>>>\n>>>\n>>> On 22/08/17 10:29 AM, Erik Aronesty via bitcoin-dev wrote:\n>>>\n>>> I agree, it is only a good idea in the event of a quantum computing\n>>> threat to the security of Bitcoin.\n>>>\n>>> On Tue, Aug 22, 2017 at 9:45 AM, Chris Riley via bitcoin-dev <\n>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>>> This seems to be drifting off into alt-coin discussion.  The idea that\n>>>> we can change the rules and steal coins at a later date because they are\n>>>> \"stale\" or someone is \"hoarding\" is antithetical to one of the points of\n>>>> bitcoin in that you can no longer control your own money (\"be your own\n>>>> bank\") because someone can at a later date take your coins for some reason\n>>>> that is outside your control and solely based on some rationalization by a\n>>>> third party.  Once the rule is established that there are valid reasons why\n>>>> someone should not have control of their own bitcoins, what other reasons\n>>>> will then be determined to be valid?\n>>>>\n>>>> I can imagine Hal Finney being revived (he was cryo-preserved at Alcor\n>>>> if you aren't aware) after 100 or 200 years expecting his coins to be there\n>>>> only to find out that his coins were deemed \"stale\" so were \"reclaimed\" (in\n>>>> the current doublespeak - e.g. stolen or confiscated).  Or perhaps he\n>>>> locked some for his children and they are found to be \"stale\" before they\n>>>> are available.  He said in March 2013, \"I think they're safe enough\" stored\n>>>> in a paper wallet.  Perhaps any remaining coins are no longer \"safe enough.\"\n>>>>\n>>>> Again, this seems (a) more about an alt-coin/bitcoin fork or (b) better\n>>>> in bitcoin-discuss at best vs bitcoin-dev. I've seen it discussed many\n>>>> times since 2010 and still do not agree with the rational that embracing\n>>>> allowing someone to steal someone else's coins for any reason is a useful\n>>>> change to bitcoin.\n>>>>\n>>>>\n>>>>\n>>>>\n>>>> On Tue, Aug 22, 2017 at 4:19 AM, Matthew Beton via bitcoin-dev <\n>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>>\n>>>>> Okay so I quite like this idea. If we start removing at height 630000\n>>>>> or 840000 (gives us 4-8 years to develop this solution), it stays nice and\n>>>>> neat with the halving interval. We can look at this like so:\n>>>>>\n>>>>> B - the current block number\n>>>>> P - how many blocks behind current the coin burning block is. (630000,\n>>>>> 840000, or otherwise.)\n>>>>>\n>>>>> Every time we mine a new block, we go to block (B-P), and check for\n>>>>> stale coins. These coins get burnt up and pooled into block B's miner fees.\n>>>>> This keeps the mining rewards up in the long term, people are less likely\n>>>>> to stop mining due to too low fees. It also encourages people to keep\n>>>>> moving their money around the enconomy instead of just hording and leaving\n>>>>> it.\n>>>>>\n>>>>\n>>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170822/7866f6f9/attachment.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-08-22T20:20:41",
                "message_text_only": "A fun exercise to be sure, but perhaps off topic for this list?\n\n> On Aug 22, 2017, at 1:06 PM, Erik Aronesty via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> > The initial message I replied to stated:\n> \n> Yes, 3 years is silly.  But coin expiration and quantum resistance is something I've been thinking about for a while, so I tried to steer the conversation away from stealing old money for no reason ;).   Plus I like the idea of making Bitcoin \"2000 year proof\".\n> \n> - I cannot imagine either SHA256 or any of our existing wallet formats surviving 200 years, if we expect both moores law and quantum computing to be a thing.   I would expect the PoW to be rendered obsolete before the Bitcoin addresses.\n> \n>  - A PoW change using Keccak and a flexible number of bits can be designed as a \"future hard fork\".  That is:  the existing POW can be automatically rendered obsolete... but only in the event that difficulty rises to the level of obsolescence.   Then the code for a new algorithm with a flexible number of bits and a difficulty that can scale for thousands of years can then automatically kick in.\n> \n>  - A new addresses format and signing protocols that use a flexible number of bits can be introduced.   The maximum number of supported bits can be configurable, and trivially changed.   These can be made immediately available but completely optional.\n> \n>  - The POW difficulty can be used to inform the expiration of any addresses that can be compromised within 5 years assuming this power was somehow used to compromise them.   Some mechanism for translating global hashpower to brute force attack power can be researched, and consesrvative estimates made.   Right now, it's like \"heat death of the universe\" amount of time to crack with every machine on the planet.   But hey... things change and 2000 years is a long time.   This information can be used to inform the expiration and reclamation of old, compromised public addresses.\n> \n> - Planning a hard fork 100 to 1000 years out is a fun exercise\n> \n> \n> \n> \n>> On Tue, Aug 22, 2017 at 2:55 PM, Chris Riley <criley at gmail.com> wrote:\n>> The initial message I replied to stated in part, \"Okay so I quite like this idea. If we start removing at height 630000 or 840000 (gives us 4-8 years to develop this solution), it stays nice and neat with the halving interval....\"\n>> \n>> That is less than 3 years or less than 7 years  away. Much sooner than it is believed QC or Moore's law could impact bitcoin.  Changing bitcoin so as to require that early coins start getting \"scavenged\" at that date seems unneeded and irresponsible.  Besides, your ECDSA is only revealed when you spend the coins which does provide some quantum resistance.  Hal was just an example of people putting their coins away expecting them to be there at X years in the future, whether it is for himself or for his kids and wife.  \n>> \n>> :-)\n>> \n>> \n>> \n>>> On Tue, Aug 22, 2017 at 1:33 PM, Matthew Beton <matthew.beton at gmail.com> wrote:\n>>> Very true, if Moore's law is still functional in 200 years, computers will be 2^100 times faster (possibly more if quantum computing becomes commonplace), and so old wallets may be easily cracked.\n>>> \n>>> We will need a way to force people to use newer, higher security wallets, and turning coins to mining rewards is better solution than them just being hacked.\n>>> \n>>> \n>>>> On Tue, 22 Aug 2017, 7:24 pm Thomas Guyot-Sionnest <dermoth at aei.ca> wrote:\n>>>> In any case when Hal Finney do not wake up from his 200years cryo-preservation (because unfortunately for him 200 years earlier they did not know how to preserve a body well enough to resurrect it) he would find that advance in computer technology made it trivial for anyone to steal his coins using the long-obsolete secp256k1 ec curve (which was done long before, as soon as it became profitable to crack down the huge stash of coins stale in the early blocks)\n>>>> \n>>>> I just don't get that argument that you can't be \"your own bank\". The only requirement coming from this would be to move your coins about once every 10 years or so, which you should be able to do if you have your private keys (you should!). You say it may be something to consider when computer breakthroughs makes old outputs vulnerable, but I say it's not \"if\" but \"when\" it happens, and by telling firsthand people that their coins requires moving every once in a long while you ensure they won't do stupid things or come back 50 years from now and complain their addresses have been scavenged.\n>>>> \n>>>> --\n>>>> Thomas\n>>>> \n>>>> \n>>>>> On 22/08/17 10:29 AM, Erik Aronesty via       bitcoin-dev wrote:\n>>>>> I agree, it is only a good idea in the event of a quantum computing threat to the security of Bitcoin.   \n>>>>> \n>>>>>> On Tue, Aug 22, 2017 at 9:45 AM, Chris Riley via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>>>> This seems to be drifting off into alt-coin discussion.  The idea that we can change the rules and steal coins at a later date because they are \"stale\" or someone is \"hoarding\" is antithetical to one of the points of bitcoin in that you can no longer control your own money (\"be your own bank\") because someone can at a later date take your coins for some reason that is outside your control and solely based on some rationalization by a third party.  Once the rule is established that there are valid reasons why someone should not have control of their own bitcoins, what other reasons will then be determined to be valid?\n>>>>>> \n>>>>>> I can imagine Hal Finney being revived (he was cryo-preserved at Alcor if you aren't aware) after 100 or 200 years expecting his coins to be there only to find out that his coins were deemed \"stale\" so were \"reclaimed\" (in the current doublespeak - e.g. stolen or confiscated).  Or perhaps he locked some for his children and they are found to be \"stale\" before they are available.  He said in March 2013, \"I think they're safe enough\" stored in a paper wallet.  Perhaps any remaining coins are no longer \"safe enough.\"\n>>>>>> \n>>>>>> Again, this seems (a) more about an alt-coin/bitcoin fork or (b) better in bitcoin-discuss at best vs bitcoin-dev. I've seen it discussed many times since 2010 and still do not agree with the rational that embracing allowing someone to steal someone else's coins for any reason is a useful change to bitcoin.\n>>>>>> \n>>>>>> \n>>>>>> \n>>>>>> \n>>>>>> On Tue, Aug 22, 2017 at 4:19 AM, Matthew Beton via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>                     wrote:\n>>>>>>> Okay so I quite like this idea. If we start removing at height 630000 or 840000 (gives us 4-8 years to develop this solution), it stays nice and neat with the halving interval. We can look at this like so:\n>>>>>>> \n>>>>>>> B - the current block number\n>>>>>>> P - how many blocks behind current the coin burning block is. (630000, 840000, or otherwise.)\n>>>>>>> \n>>>>>>> Every time we mine a new block, we go to block (B-P), and check for stale coins. These coins get burnt up and pooled into block B's miner fees. This keeps the mining rewards up in the long term, people are less likely to stop                         mining due to too low fees. It also encourages people to keep moving their money around the enconomy instead of just hording and leaving it. \n>>>> \n>> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170822/4be654a2/attachment-0001.html>"
            },
            {
                "author": "Daniele Pinna",
                "date": "2017-08-22T22:17:19",
                "message_text_only": "Also.... how is this not a tax on coin holders? By forcing people to move\ncoins around you would be chipping away at their wealth in the form of\nextorted TX fees.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170823/f6446dee/attachment.html>"
            },
            {
                "author": "Thomas Guyot-Sionnest",
                "date": "2017-08-22T23:27:30",
                "message_text_only": "On 22/08/17 06:17 PM, Daniele Pinna via bitcoin-dev wrote:\n> Also.... how is this not a tax on coin holders? By forcing people to\n> move coins around you would be chipping away at their wealth in the\n> form of extorted TX fees. \n>  \n\nAs if the fee for one tx per decade (or more if we'd like) matters, plus\nit could be very low priority. In fact we could re-allow free\ntransactions based on old priority rules (oldest outputs gets higher\npriority... I would suggest considering reduction in utxo size as well\nbut that's another topic).\n\nActually, to ensure miners allow these transaction one rule could be\nthat the block must contain free transactions on old utxo's (\"old\" TBD)\nto reclaim from the scavenged pool... One side effect is that mining\nempty blocks before previous block TX can be validated would reduce the\nreward.\n\nI'd love to find clever approach where we could somehow make a\nverifiable block check that old tx refresh are included... I haven't put\nmuch thoughts into it yet but if there was a way a two-step transaction\nwhere 1. a fee is paid to register an UTXO refresh (miners would be\nencouraged to accept it and increase their immediate revenue), and 2.\nthe fee must be returned from the pool on a later block. The idea is to\nallow free scavenging of own addresses while discouraging miners from\nrefusing free transactions so they could eventually reclaim the coins. I\ncan't think of a way that limits the burden on consensus rules...\n\n-- \nThomas"
            },
            {
                "author": "Rodney Morris",
                "date": "2017-08-22T22:58:54",
                "message_text_only": "Thomas et.al.\n\nSo, in your minds, anyone who locked up coins using CLTV for their child to\nreceive on their 21st birthday, for the sake of argument, has effectively\nforfeit those coins after the fact?  You are going to force anyone who took\ncoins offline (cryptosteel, paper, doesn't matter) to bring those coins\nback online, with the inherent security risks?\n\nIn my mind, the only sane way to even begin discussing an approach\nimplementing such a thing - where coins \"expire\" after X years - would be\nto give the entire ecosystem X*N years warning, where N > 1.5.  I'd also\nsuggest X would need to be closer to the life span of a human than zero.\nMind you, I'd suggest this \"feature\" would need to be coded and deployed as\na future-hard-fork X*N years ahead of time.  A-la Satoshi's blog post\nregarding increasing block size limit, a good enough approximation would be\nto add a block height check to the code that approximates X*N years, based\non 10 minute blocks.  The transparency around such a change would need to\nbe radical and absolute.\n\nI'd also suggest that, similar to CLTV, it only makes sense to discuss\ncreating a \"never expire\" transaction output, if such a feature were being\nseriously considered.\n\nIf you think discussions around a block size increase were difficult, then\nwe'll need a new word to describe the challenges and vitriol that would\narise in arguments that will follow this discussion should it be seriously\nproposed, IMHO.\n\nI also don't think it's reasonable to conflate the discussion herein with\ndiscussion about what to do when ECC or SHA256 is broken.  The\nweakening/breaking of ECC poses a real risk to the stability of Bitcoin -\nthe possible release of Satoshi's stash being the most obvious example -\nand what to do about that will require serious consideration when the time\ncomes.  Even if the end result is the same - that coins older than \"X\" will\nbe invalidated - everything else important about the scenarios are\ndifferent as far as I can see.\n\nRodney\n\n\n\n>\n>\n> Date: Tue, 22 Aug 2017 13:24:05 -0400\n> From: Thomas Guyot-Sionnest <dermoth at aei.ca>\n> To: Erik Aronesty <erik at q32.com>,       Bitcoin Protocol Discussion\n>         <bitcoin-dev at lists.linuxfoundation.org>,        Chris Riley\n>         <criley at gmail.com>\n> Cc: Matthew Beton <matthew.beton at gmail.com>\n> Subject: Re: [bitcoin-dev] UTXO growth scaling solution proposal\n> Message-ID: <4c39bee6-f419-2e36-62a8-d38171b15558 at aei.ca>\n> Content-Type: text/plain; charset=\"windows-1252\"\n>\n> In any case when Hal Finney do not wake up from his 200years\n> cryo-preservation (because unfortunately for him 200 years earlier they\n> did not know how to preserve a body well enough to resurrect it) he\n> would find that advance in computer technology made it trivial for\n> anyone to steal his coins using the long-obsolete secp256k1 ec curve\n> (which was done long before, as soon as it became profitable to crack\n> down the huge stash of coins stale in the early blocks)\n>\n> I just don't get that argument that you can't be \"your own bank\". The\n> only requirement coming from this would be to move your coins about once\n> every 10 years or so, which you should be able to do if you have your\n> private keys (you should!). You say it may be something to consider when\n> computer breakthroughs makes old outputs vulnerable, but I say it's not\n> \"if\" but \"when\" it happens, and by telling firsthand people that their\n> coins requires moving every once in a long while you ensure they won't\n> do stupid things or come back 50 years from now and complain their\n> addresses have been scavenged.\n>\n> --\n> Thomas\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170823/8ee044f4/attachment.html>"
            },
            {
                "author": "Thomas Guyot-Sionnest",
                "date": "2017-08-22T23:29:41",
                "message_text_only": "I'm just getting the proposal out... if we decide to go forward (pretty\nhuge \"if\" right now) whenever it kicks in after 15, 50 or 100 years\nshould be decided as early as possible.\n\nAre CheckLockTimeVerify transactions accepted yet? I thought most\nspecial transactions were only accepted on Testnet... In any case we\nshould be able to scan the blockchain and look for any such transaction.\nAnd I hate to make this more complex, but maybe re-issuing the tx from\ncoinbase could be an option?\n\n--\nThomas\n\nOn 22/08/17 06:58 PM, Rodney Morris via bitcoin-dev wrote:\n> Thomas et.al <http://et.al>.\n>\n> So, in your minds, anyone who locked up coins using CLTV for their\n> child to receive on their 21st birthday, for the sake of argument, has\n> effectively forfeit those coins after the fact?  You are going to\n> force anyone who took coins offline (cryptosteel, paper, doesn't\n> matter) to bring those coins back online, with the inherent security\n> risks?\n>\n> In my mind, the only sane way to even begin discussing an approach\n> implementing such a thing - where coins \"expire\" after X years - would\n> be to give the entire ecosystem X*N years warning, where N > 1.5.  I'd\n> also suggest X would need to be closer to the life span of a human\n> than zero.  Mind you, I'd suggest this \"feature\" would need to be\n> coded and deployed as a future-hard-fork X*N years ahead of time. \n> A-la Satoshi's blog post regarding increasing block size limit, a good\n> enough approximation would be to add a block height check to the code\n> that approximates X*N years, based on 10 minute blocks.  The\n> transparency around such a change would need to be radical and absolute.\n>\n> I'd also suggest that, similar to CLTV, it only makes sense to discuss\n> creating a \"never expire\" transaction output, if such a feature were\n> being seriously considered.\n>\n> If you think discussions around a block size increase were difficult,\n> then we'll need a new word to describe the challenges and vitriol that\n> would arise in arguments that will follow this discussion should it be\n> seriously proposed, IMHO.\n>\n> I also don't think it's reasonable to conflate the discussion herein\n> with discussion about what to do when ECC or SHA256 is broken.  The\n> weakening/breaking of ECC poses a real risk to the stability of\n> Bitcoin - the possible release of Satoshi's stash being the most\n> obvious example - and what to do about that will require serious\n> consideration when the time comes.  Even if the end result is the same\n> - that coins older than \"X\" will be invalidated - everything else\n> important about the scenarios are different as far as I can see.\n>\n> Rodney\n>\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170822/8c69cf2e/attachment.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-08-23T03:26:19",
                "message_text_only": "Lock time transactions have been valid for over a year now I believe. In any case we can't scan the block chain for usage patterns in UTXOs because P2SH puts the script in the signature on spend.\n\n> On Aug 22, 2017, at 4:29 PM, Thomas Guyot-Sionnest via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> I'm just getting the proposal out... if we decide to go forward (pretty huge \"if\" right now) whenever it kicks in after 15, 50 or 100 years should be decided as early as possible.\n> \n> Are CheckLockTimeVerify transactions accepted yet? I thought most special transactions were only accepted on Testnet... In any case we should be able to scan the blockchain and look for any such transaction. And I hate to make this more complex, but maybe re-issuing the tx from coinbase could be an option?\n> \n> --\n> Thomas\n> \n>> On 22/08/17 06:58 PM, Rodney Morris via bitcoin-dev wrote:\n>> Thomas et.al.\n>> \n>> So, in your minds, anyone who locked up coins using CLTV for their child to receive on their 21st birthday, for the sake of argument, has effectively forfeit those coins after the fact?  You are going to force anyone who took coins offline (cryptosteel, paper, doesn't matter) to bring those coins back online, with the inherent security risks?\n>> \n>> In my mind, the only sane way to even begin discussing an approach implementing such a thing - where coins \"expire\" after X years - would be to give the entire ecosystem X*N years warning, where N > 1.5.  I'd also suggest X would need to be closer to the life span of a human than zero.  Mind you, I'd suggest this \"feature\" would need to be coded and deployed as a future-hard-fork X*N years ahead of time.  A-la Satoshi's blog post regarding increasing block size limit, a good enough approximation would be to add a block height check to the code that approximates X*N years, based on 10 minute blocks.  The transparency around such a change would need to be radical and absolute.\n>> \n>> I'd also suggest that, similar to CLTV, it only makes sense to discuss creating a \"never expire\" transaction output, if such a feature were being seriously considered.\n>> \n>> If you think discussions around a block size increase were difficult, then we'll need a new word to describe the challenges and vitriol that would arise in arguments that will follow this discussion should it be seriously proposed, IMHO.\n>> \n>> I also don't think it's reasonable to conflate the discussion herein with discussion about what to do when ECC or SHA256 is broken.  The weakening/breaking of ECC poses a real risk to the stability of Bitcoin - the possible release of Satoshi's stash being the most obvious example - and what to do about that will require serious consideration when the time comes.  Even if the end result is the same - that coins older than \"X\" will be invalidated - everything else important about the scenarios are different as far as I can see.\n>> \n>> Rodney\n>> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170822/e744e046/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "UTXO growth scaling solution proposal",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Moral Agent",
                "Thomas Guyot-Sionnest",
                "Mark Friedenbach",
                "Daniele Pinna",
                "Erik Aronesty",
                "Matthew Beton",
                "Chris Riley",
                "Rodney Morris"
            ],
            "messages_count": 17,
            "total_messages_chars_count": 65083
        }
    },
    {
        "title": "[bitcoin-dev] bitcoin-dev Digest, Vol 27, Issue 10",
        "thread_messages": [
            {
                "author": "DANIEL YIN",
                "date": "2017-08-22T18:18:13",
                "message_text_only": "> Very true, if Moore's law is still functional in 200 years, computers will\n\n> be 2^100 times faster (possibly more if quantum computing becomes\n> commonplace), and so old wallets may be easily cracked.\n>\n> We will need a way to force people to use newer, higher security wallets,\n> and turning coins to mining rewards is better solution than them just being\n> hacked.\n\nEven in such an event, my personal view is the bitcoin owner should have the\nfreedom to choose upgrade to secure his/her coins or to leave the door\nopen for the first hacker to assume the coins - yet the bitcoin network\nthat he/she trusts should not act like a hacker to assume his/her coins.\n\ndaniel\n\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170822/6c14be2f/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "bitcoin-dev Digest, Vol 27, Issue 10",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "DANIEL YIN"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 856
        }
    },
    {
        "title": "[bitcoin-dev] Solving the Scalability Problem on Bitcoin",
        "thread_messages": [
            {
                "author": "Adam Tamir Shem-Tov",
                "date": "2017-08-26T19:21:16",
                "message_text_only": "<B> Solving the Scalability issue for bitcoin </B> <BR>\n\nI have this idea to solve the scalability problem I wish to make public.\n\nIf I am wrong I hope to be corrected, and if I am right we will all gain by\nit. <BR>\n\nCurrently each block is being hashed, and in its contents are the hash of\nthe block preceding it, this goes back to the genesis block.\n\n<BR>\n\nWhat if we decide, for example, we decide to combine and prune the\nblockchain in its entirety every 999 blocks to one block (Genesis block not\nincluded in count).\n\n<BR>\n\nHow would this work?: Once block 1000 has been created, the network would\nbe waiting for a special \"pruned block\", and until this block was created\nand verified, block 1001 would not be accepted by any nodes.\n\nThis pruned block would prune everything from block 2 to block 1000,\nleaving only the genesis block. Blocks 2 through 1000, would be calculated,\nto create a summed up transaction of all transactions which occurred in\nthese 999 blocks.\n\n<BR>\n\nAnd its hash pointer would be the Genesis block.\n\nThis block would now be verified by the full nodes, which if accepted would\nthen be willing to accept a new block (block 1001, not including the pruned\nblock in the count).\n\n<BR>\n\nThe new block 1001, would use as its hash pointer the pruned block as its\nreference. And the count would begin again to the next 1000. The next\npruned block would be created, its hash pointer will be referenced to the\nGenesis Block. And so on..\n\n<BR>\n\nIn this way the ledger will always be a maximum of 1000 blocks.\n\n<BR>\n<B> A bit more detail: </B>\n<BR>\nAll the outputs needed to verify early transactions will all be in the\npruning block. The only information you lose are of the intermediate\ntransactions, not the final ones the community has already accepted.\n\nFor example:\n\n<BR>\n\nA = 2.3 BTC, B=0, C=1.4. (Block 1)\n\n<BR>\n\nIf A sends 2.3 BTC to B. (Block 2)\n\n<BR>\n\nAnd then B sends 1.5 to C. (Block 3)\n\n<BR>\n\nThe pruning block will report:\n\n<BR>\n\nB = 0.8 and C=2.9. <BR>\n\nThe rest of the information you lose, is irrelevant. No one needs to know\nthat A even existed since it is now empty, nor do they need to know how\nmuch B and C had previously, only what they have now.\n\n<BR>\nNote: The Transaction Chain would also need to be rewritten, to delete all\nintermediate transactions, it will show as though transactions occurred\nfrom the Genesis block directly to the pruned block, as though nothing ever\nexisted in between.\n\n<BR>\n\n<BR>\n\nYou can keep the old blocks on your drive for 10 more blocks or so, just in\ncase a longer block chain is found, but other than that the information it\nholds is useless, since it has all been agreed upon. And the pruning block\nholds all up to date account balances, so cheating is impossible.\n\n<BR>\n\nGranted this pruning block can get extremely large in the future, it will\nnot be the regular size of the other blocks. For example if every account\nhas only 1 satoshi in it, which is the minimum, then the amount of accounts\nwill be at its maximum. Considering a transaction is about 256bytes. That\nwould mean the pruning block would be approximately 500PB, which is 500,000\nTerra-bytes. That is a theoretical scenario, which is not likely to occur.\n(256bytes*23M BTC*100M (satoshis in 1 BTC))\n\n<BR>\n\nA scenario which could be solved by creating a minimum transaction fee of\n100 satoshis, which would insure that even in the most unlikely scenario,\nat worst the pruning block would be 5PB in size.\n\n<BR>\n\nAlso, this pruning block does not even need to be downloaded, it could be\ncreated by already existing information, each full node by itself, by <BR>\n\n1) combining and pruning all previous blocks <BR>\n\n2) using the genesis block as its hash pointer <BR>\n\n3) using a predefined random number \"2\", which will be used by all. A\nrandom number which is normally added to a block to ensure the block's\nhashrate difficulty, is not needed in this case, since all information can\nbe verified by each node by itself through pruning. <BR>\n\n4) Any other information which is needed for the SHA256 hash, for example a\ntimestamp could be copied off the last block in the block chain. <BR>\n\nThese steps will ensure each full node, will get the exact hash code as the\nothers have gotten for this pruning block.\n\n<BR>\n\nAnd as I previously stated the next block will use this hash code as its\nhash reference.\n\n<BR>\n\nBy creating a system like this, the pruning block does not have to be\ncreated last minute, but gradually over time, every time a new block comes\nin, and only when the last block arrives (block 1000), will it be\nfinalized, and hashed.\n\n<BR>\n\nAnd since this block will always be second, it should go by the name\n\"Exodus Block\".\n<BR>\nAdam Shem-Tov\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170826/06e827bb/attachment.html>"
            },
            {
                "author": "Thomas Guyot-Sionnest",
                "date": "2017-08-26T21:31:11",
                "message_text_only": "Pruning is already implemented in the nodes... Once enabled only unspent\ninputs and most recent blocks are kept. IIRC there was also a proposal\nto include UTXO in some blocks for SPV clients to use, but that would be\nadditional to the blockchain data.\n\nImplementing your solution is impossible because there is no way to\ndetermine authenticity of the blockchain mid way. The proof that a block\nhash leads to the genesis block is also a proof of all the work that's\nbeen spent on it (the years of hashing). At the very least we'd have to\nkeep all blocks until a hard-coded checkpoint in the code, which also\nmeans that as nodes upgrades and prune more blocks older nodes will have\ndifficulty syncing the blockchain.\n\nFinally it's not just the addresses and balance you need to save, but\nalso each unspent output block number, tx position and script that are\nrequired for validation on input. That's a lot of data that you're\nsuggesting to save every 1000 blocks (and why 1000?), and as said\nearlier it doesn't even guarantee you can drop older blocks. I'm not\neven going into the details of making it work (hard fork, large block\nsync/verification issues, possible attack vectors opened by this...)\n\nWhat is wrong with the current implementation of node pruning that you\nare trying to solve?\n\n--\nThomas\n\nOn 26/08/17 03:21 PM, Adam Tamir Shem-Tov via bitcoin-dev wrote:\n>\n> <B> Solving the Scalability issue for bitcoin </B> <BR>\n>\n> I have this idea to solve the scalability problem I wish to make public.\n>\n> If I am wrong I hope to be corrected, and if I am right we will all\n> gain by it. <BR>\n>\n> Currently each block is being hashed, and in its contents are the hash\n> of the block preceding it, this goes back to the genesis block.\n>\n> <BR>\n>\n> What if we decide, for example, we decide to combine and prune the\n> blockchain in its entirety every 999 blocks to one block (Genesis\n> block not included in count).\n>\n> <BR>\n>\n> How would this work?: Once block 1000 has been created, the network\n> would be waiting for a special \"pruned block\", and until this block\n> was created and verified, block 1001 would not be accepted by any nodes.\n>\n> This pruned block would prune everything from block 2 to block 1000,\n> leaving only the genesis block. Blocks 2 through 1000, would be\n> calculated, to create a summed up transaction of all transactions\n> which occurred in these 999 blocks.\n>\n> <BR>\n>\n> And its hash pointer would be the Genesis block.\n>\n> This block would now be verified by the full nodes, which if accepted\n> would then be willing to accept a new block (block 1001, not including\n> the pruned block in the count).\n>\n> <BR>\n>\n> The new block 1001, would use as its hash pointer the pruned block as\n> its reference. And the count would begin again to the next 1000. The\n> next pruned block would be created, its hash pointer will be\n> referenced to the Genesis Block. And so on..\n>\n> <BR>\n>\n> In this way the ledger will always be a maximum of 1000 blocks.\n>\n>\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170826/5f836930/attachment-0001.html>"
            },
            {
                "author": "Adam Tamir Shem-Tov",
                "date": "2017-08-26T22:32:17",
                "message_text_only": "Thank you Thomas for your response.\n\n1) Implement solution is impossible... I have given a solution in part II.\nBy adding a Genesis Account which will be the new sender.\n\n2)Keeping older blocks: Yes as I said 10 older blocks should be kept, that\nshould suffice. I am not locked on that number, if you think there is a\nreason to keep more than that, it is open to debate.\n\n3) Why 1000? To be honest, that number came off the top of my head. These\nare minor details, the concept must first be accepted, then we can work on\nthe minor details.\n\n4)Finally it's not just the addresses and balance you need to save...  I\nthink the Idea of the Genesis Account, solves this issue.\n\n5) The problem with node pruning is that it is not standardized, and for a\nnew node to enter the network and to verify the data, it needs to download\nall data and prune it by itself. This will drastically lower the\ninformation needed by the full nodes by getting rid of the junk.  Currently\nwe are around 140GB, that number is getting bigger exponentially, by the\nnumber of users and transactions created. It could reach a Terrabyte sooner\nthan expected, we need to act now.\n\nOn your second email:\nWhen I say account: I mean private-public key.\nThe way bitcoin works, as I understand it, is that the funds are verified\nby showing that they have an origin, this \"origin\" needs to provide a\nsignature, otherwise the transaction won't be accepted.\nIf I am proposing to remove all intermediate origins, then the funds become\nuntraceable and hence unverifiable. To fix that, a new transaction needs to\nreplace old ones. A simplified version: If there was a transaction chain\nA->B->C->D, and I wish to show only A->D, only a transaction like that\nnever actually occurred, it would be impossible to say that it did without\nhaving A's private key, in order to sign this transaction. In order to\ncreate this transaction, I need A's private key. And if I wish this to be\npublicly implemented I need this key to be public, so that any node\ncreating this Exodus Block can sign with it. Hence the Genesis Account. And\nyes, it is not really an account.\n\nOn 27 August 2017 at 00:31, Thomas Guyot-Sionnest <dermoth at aei.ca> wrote:\n\n> Pruning is already implemented in the nodes... Once enabled only unspent\n> inputs and most recent blocks are kept. IIRC there was also a proposal to\n> include UTXO in some blocks for SPV clients to use, but that would be\n> additional to the blockchain data.\n>\n> Implementing your solution is impossible because there is no way to\n> determine authenticity of the blockchain mid way. The proof that a block\n> hash leads to the genesis block is also a proof of all the work that's been\n> spent on it (the years of hashing). At the very least we'd have to keep all\n> blocks until a hard-coded checkpoint in the code, which also means that as\n> nodes upgrades and prune more blocks older nodes will have difficulty\n> syncing the blockchain.\n>\n> Finally it's not just the addresses and balance you need to save, but also\n> each unspent output block number, tx position and script that are required\n> for validation on input. That's a lot of data that you're suggesting to\n> save every 1000 blocks (and why 1000?), and as said earlier it doesn't even\n> guarantee you can drop older blocks. I'm not even going into the details of\n> making it work (hard fork, large block sync/verification issues, possible\n> attack vectors opened by this...)\n>\n> What is wrong with the current implementation of node pruning that you are\n> trying to solve?\n>\n> --\n> Thomas\n>\n> On 26/08/17 03:21 PM, Adam Tamir Shem-Tov via bitcoin-dev wrote:\n>\n> <B> Solving the Scalability issue for bitcoin </B> <BR>\n>\n> I have this idea to solve the scalability problem I wish to make public.\n>\n> If I am wrong I hope to be corrected, and if I am right we will all gain\n> by it. <BR>\n>\n> Currently each block is being hashed, and in its contents are the hash of\n> the block preceding it, this goes back to the genesis block.\n>\n> <BR>\n>\n> What if we decide, for example, we decide to combine and prune the\n> blockchain in its entirety every 999 blocks to one block (Genesis block not\n> included in count).\n>\n> <BR>\n>\n> How would this work?: Once block 1000 has been created, the network would\n> be waiting for a special \"pruned block\", and until this block was created\n> and verified, block 1001 would not be accepted by any nodes.\n>\n> This pruned block would prune everything from block 2 to block 1000,\n> leaving only the genesis block. Blocks 2 through 1000, would be calculated,\n> to create a summed up transaction of all transactions which occurred in\n> these 999 blocks.\n>\n> <BR>\n>\n> And its hash pointer would be the Genesis block.\n>\n> This block would now be verified by the full nodes, which if accepted\n> would then be willing to accept a new block (block 1001, not including the\n> pruned block in the count).\n>\n> <BR>\n>\n> The new block 1001, would use as its hash pointer the pruned block as its\n> reference. And the count would begin again to the next 1000. The next\n> pruned block would be created, its hash pointer will be referenced to the\n> Genesis Block. And so on..\n>\n> <BR>\n>\n> In this way the ledger will always be a maximum of 1000 blocks.\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170827/eac9d2b1/attachment.html>"
            },
            {
                "author": "Thomas Guyot-Sionnest",
                "date": "2017-08-27T05:18:32",
                "message_text_only": "How do you trust your <1000 block blockchain if you don't\ndownload/validate the whole thing? (I know it should be easy to spot\nthat by looking at the blocks/tx or comparing to other nodes, but from a\nprogrammatic point of view this is much harder). You can of course\ninclude a checkpoint in the code to tell which recent block is valid\n(which is already done afaik), but you still need all blocks from that\ncheckpoint to validate the chain (not 10!). If you rely on such\ncheckpoint, why not just include the UTXO's as well so you can start\nmid-way based on code trust?\n\nIndeed pruning doesn't allow you to start mid-way yet but there are much\neasier solutions to that than what you propose.\n\n--\nThomas\n\nOn 26/08/17 06:32 PM, Adam Tamir Shem-Tov wrote:\n> Thank you Thomas for your response.\n>\n> 1) Implement solution is impossible... I have given a solution in part\n> II. By adding a Genesis Account which will be the new sender.\n>\n> 2)Keeping older blocks: Yes as I said 10 older blocks should be kept,\n> that should suffice. I am not locked on that number, if you think\n> there is a reason to keep more than that, it is open to debate.\n>\n> 3) Why 1000? To be honest, that number came off the top of my head.\n> These are minor details, the concept must first be accepted, then we\n> can work on the minor details.\n>\n> 4)Finally it's not just the addresses and balance you need to save... \n> I think the Idea of the Genesis Account, solves this issue.\n>\n> 5) The problem with node pruning is that it is not standardized, and\n> for a new node to enter the network and to verify the data, it needs\n> to download all data and prune it by itself. This will drastically\n> lower the information needed by the full nodes by getting rid of the\n> junk.  Currently we are around 140GB, that number is getting bigger\n> exponentially, by the number of users and transactions created. It\n> could reach a Terrabyte sooner than expected, we need to act now.\n>\n> On your second email:\n> When I say account: I mean private-public key.\n> The way bitcoin works, as I understand it, is that the funds are\n> verified by showing that they have an origin, this \"origin\" needs to\n> provide a signature, otherwise the transaction won't be accepted.\n> If I am proposing to remove all intermediate origins, then the funds\n> become untraceable and hence unverifiable. To fix that, a new\n> transaction needs to replace old ones. A simplified version: If there\n> was a transaction chain A->B->C->D, and I wish to show only A->D, only\n> a transaction like that never actually occurred, it would be\n> impossible to say that it did without having A's private key, in order\n> to sign this transaction. In order to create this transaction, I need\n> A's private key. And if I wish this to be publicly implemented I need\n> this key to be public, so that any node creating this Exodus Block can\n> sign with it. Hence the Genesis Account. And yes, it is not really an\n> account."
            },
            {
                "author": "Btc Ideas",
                "date": "2017-08-27T03:52:57",
                "message_text_only": "I also like only keeping the last \"n\" blocks. Every \"n\" minus all the previous balances are kept, but the transactions are deleted. There's good enough record keeping, and there's excessive. Part of scaling is being able to get the blockchain and sync quickly.\n\nJason\n\n-------- Original Message --------\nOn Aug 27, 2017, 05:31, Thomas Guyot-Sionnest via bitcoin-dev wrote:\n\n> Pruning is already implemented in the nodes... Once enabled only unspent inputs and most recent blocks are kept. IIRC there was also a proposal to include UTXO in some blocks for SPV clients to use, but that would be additional to the blockchain data.\n>\n> Implementing your solution is impossible because there is no way to determine authenticity of the blockchain mid way. The proof that a block hash leads to the genesis block is also a proof of all the work that's been spent on it (the years of hashing). At the very least we'd have to keep all blocks until a hard-coded checkpoint in the code, which also means that as nodes upgrades and prune more blocks older nodes will have difficulty syncing the blockchain.\n>\n> Finally it's not just the addresses and balance you need to save, but also each unspent output block number, tx position and script that are required for validation on input. That's a lot of data that you're suggesting to save every 1000 blocks (and why 1000?), and as said earlier it doesn't even guarantee you can drop older blocks. I'm not even going into the details of making it work (hard fork, large block sync/verification issues, possible attack vectors opened by this...)\n>\n> What is wrong with the current implementation of node pruning that you are trying to solve?\n>\n> --\n> Thomas\n>\n> On 26/08/17 03:21 PM, Adam Tamir Shem-Tov via bitcoin-dev wrote:\n>\n>> <B> Solving the Scalability issue for bitcoin </B> <BR>\n>>\n>> I have this idea to solve the scalability problem I wish to make public.\n>>\n>> If I am wrong I hope to be corrected, and if I am right we will all gain by it. <BR>\n>>\n>> Currently each block is being hashed, and in its contents are the hash of the block preceding it, this goes back to the genesis block.\n>>\n>> <BR>\n>>\n>> What if we decide, for example, we decide to combine and prune the blockchain in its entirety every 999 blocks to one block (Genesis block not included in count).\n>>\n>> <BR>\n>>\n>> How would this work?: Once block 1000 has been created, the network would be waiting for a special \"pruned block\", and until this block was created and verified, block 1001 would not be accepted by any nodes.\n>>\n>> This pruned block would prune everything from block 2 to block 1000, leaving only the genesis block. Blocks 2 through 1000, would be calculated, to create a summed up transaction of all transactions which occurred in these 999 blocks.\n>>\n>> <BR>\n>>\n>> And its hash pointer would be the Genesis block.\n>>\n>> This block would now be verified by the full nodes, which if accepted would then be willing to accept a new block (block 1001, not including the pruned block in the count).\n>>\n>> <BR>\n>>\n>> The new block 1001, would use as its hash pointer the pruned block as its reference. And the count would begin again to the next 1000. The next pruned block would be created, its hash pointer will be referenced to the Genesis Block. And so on..\n>>\n>> <BR>\n>>\n>> In this way the ledger will always be a maximum of 1000 blocks.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170826/6b082a37/attachment.html>"
            },
            {
                "author": "Weiwu",
                "date": "2017-08-27T00:27:49",
                "message_text_only": "On Sat, 26 Aug 2017, Adam Tamir Shem-Tov via bitcoin-dev wrote:\n> For example:\n> \n> A = 2.3 BTC, B=0, C=1.4. (Block 1)\n> \n> If A sends 2.3 BTC to B. (Block 2)\n> \n> And then B sends 1.5 to C. (Block 3)\n> \n> The pruning block will report:\n> \n> B = 0.8 and C=2.9.\n\nYou effecitvely want these two transactions:\n\nA -(2.30)-> B; B -(1.5)-> C;\n\nTo be shorten to one transaction:\n\nA -(0.8)-> B  -(1.5)-> C;\n\nFor that to work a lot of changes has to be done to Bitcoin. For\nsimplicity of the discussion I'll assume all transactions are\nstandard transactions.\n\nFirst, a block has to refer to the hash of the \"balance sheet\" (with\nnonce), not the hash of the previous block. This way, a previous block\ncan be replaced with a smaller one without affecting the hash\nreference. To add problem to this significant change, Bitcoin uses\nUTXO table instead of \"balance sheet\". The difference is that UTXO is\nindexed by transaction ID while a balance sheet is indexed by owner's\npublic keys. The shortening you suggested wouldn't affect the balance\nsheet but would totally replace UTXOs for B and C, and probably even\nA, if A has some changes left.\n\nSecond, Alice has to place a new signature on the shortened\ntransaction. The design challenge is how do we motivate A to do so,\nsince A needs to do it after \"B->C\", at which time Alice's business is\ndone and her wallet offline. Luckily, all bitcoins come from\nminers. Imagine A gets her money from A', and all the way back, the\noriginating A\" must be a miner. We just need to design a different\nreward mechanism, where miners are not only rewarded by finding\nblocks, but also by shortening transactions after his\nexpenses. Whatever new reward mechanism it may be, it will interfer\nwith block hash reference discussed in the previous paragraph.\n\nThird, hash references are stablized by work. This is necessary,\notherwise a smaller block intended to replace a long one will not be\nforced to maintain the same balance sheet. However, because work is\ndone on blocks, shortening can only happen within one block. Normally,\nBob who receives a transaction in a block, will not spend it to Carol\nin the same block, because he wants 6 confirmations before being sure,\ntherefore, there will be little opportunity of shortening in one\nblock. You mentioned the idea of shortening between 1000 blocks - that\nsurely give a lot of opportunities to shorten a large directed\ntransaction graph, but you would abandon the proof of work in those\n999 blocks in between.\n\nThere are three major design issue that needs to be worked out, but\nalmost all unique aspects of Bitcoin will be affected. Just to name a few:\n\n- wallets need to be aware that the UTXO in it may change to some\n   other UTXO with the same sum value.\n\n- nLockTime transactions are affected. Such transactions timed for\n   near future probably can stay by ruling that shortening can only\n   happen after a year; however, those timed for years to come will\n   find itself losing UTXO referenes (e.g. a will).\n\n- I assumed all transactions standard, but if they are not, those who can\n   redeem them will lose the UTXO references to them after shortening.\n\nI am, like you, risking proposing what is already proposed or\nexplaining what is already explained. The thinking around Bitcoin is a\nbig tome!\n\nRegards\nWeiwu Z."
            },
            {
                "author": "Leandro Coutinho",
                "date": "2017-08-27T12:10:19",
                "message_text_only": ">>> 5) The problem with node pruning is that it is not standardized, and\nfor a new node to enter the network and to verify the data, it needs to\ndownload all data and prune it by itself. This will drastically lower the\ninformation needed by the full nodes by getting rid of the junk.  Currently\nwe are around 140GB, that number is getting bigger exponentially, by the\nnumber of users and transactions created. It could reach a Terrabyte sooner\nthan expected, we need to act now.\n\nTo have to download all blockchain for then prune is a big drawback.\nSo I thought about the concept of \"trusted\" nodes, where you could choose\nsome nodes to connect and from which block you want to download. Of course\nthey would do this by their own risk, but there are ways to minimize the\nrisk, like:\n  - check the latest blocks (hashes) if they match what you find in some\nsites, like blockchain.info\n  - download and compare the utxo from all (some) the nodes you are\nconnected\n\nCurrently utxo size is around 2GB and we cant know how fast it will grow (?)\n\nEm 26/08/2017 19:39, \"Adam Tamir Shem-Tov via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> escreveu:\n\nThank you Thomas for your response.\n\n1) Implement solution is impossible... I have given a solution in part II.\nBy adding a Genesis Account which will be the new sender.\n\n2)Keeping older blocks: Yes as I said 10 older blocks should be kept, that\nshould suffice. I am not locked on that number, if you think there is a\nreason to keep more than that, it is open to debate.\n\n3) Why 1000? To be honest, that number came off the top of my head. These\nare minor details, the concept must first be accepted, then we can work on\nthe minor details.\n\n4)Finally it's not just the addresses and balance you need to save...  I\nthink the Idea of the Genesis Account, solves this issue.\n\n5) The problem with node pruning is that it is not standardized, and for a\nnew node to enter the network and to verify the data, it needs to download\nall data and prune it by itself. This will drastically lower the\ninformation needed by the full nodes by getting rid of the junk.  Currently\nwe are around 140GB, that number is getting bigger exponentially, by the\nnumber of users and transactions created. It could reach a Terrabyte sooner\nthan expected, we need to act now.\n\nOn your second email:\nWhen I say account: I mean private-public key.\nThe way bitcoin works, as I understand it, is that the funds are verified\nby showing that they have an origin, this \"origin\" needs to provide a\nsignature, otherwise the transaction won't be accepted.\nIf I am proposing to remove all intermediate origins, then the funds become\nuntraceable and hence unverifiable. To fix that, a new transaction needs to\nreplace old ones. A simplified version: If there was a transaction chain\nA->B->C->D, and I wish to show only A->D, only a transaction like that\nnever actually occurred, it would be impossible to say that it did without\nhaving A's private key, in order to sign this transaction. In order to\ncreate this transaction, I need A's private key. And if I wish this to be\npublicly implemented I need this key to be public, so that any node\ncreating this Exodus Block can sign with it. Hence the Genesis Account. And\nyes, it is not really an account.\n\nOn 27 August 2017 at 00:31, Thomas Guyot-Sionnest <dermoth at aei.ca> wrote:\n\n> Pruning is already implemented in the nodes... Once enabled only unspent\n> inputs and most recent blocks are kept. IIRC there was also a proposal to\n> include UTXO in some blocks for SPV clients to use, but that would be\n> additional to the blockchain data.\n>\n> Implementing your solution is impossible because there is no way to\n> determine authenticity of the blockchain mid way. The proof that a block\n> hash leads to the genesis block is also a proof of all the work that's been\n> spent on it (the years of hashing). At the very least we'd have to keep all\n> blocks until a hard-coded checkpoint in the code, which also means that as\n> nodes upgrades and prune more blocks older nodes will have difficulty\n> syncing the blockchain.\n>\n> Finally it's not just the addresses and balance you need to save, but also\n> each unspent output block number, tx position and script that are required\n> for validation on input. That's a lot of data that you're suggesting to\n> save every 1000 blocks (and why 1000?), and as said earlier it doesn't even\n> guarantee you can drop older blocks. I'm not even going into the details of\n> making it work (hard fork, large block sync/verification issues, possible\n> attack vectors opened by this...)\n>\n> What is wrong with the current implementation of node pruning that you are\n> trying to solve?\n>\n> --\n> Thomas\n>\n> On 26/08/17 03:21 PM, Adam Tamir Shem-Tov via bitcoin-dev wrote:\n>\n> <B> Solving the Scalability issue for bitcoin </B> <BR>\n>\n> I have this idea to solve the scalability problem I wish to make public.\n>\n> If I am wrong I hope to be corrected, and if I am right we will all gain\n> by it. <BR>\n>\n> Currently each block is being hashed, and in its contents are the hash of\n> the block preceding it, this goes back to the genesis block.\n>\n> <BR>\n>\n> What if we decide, for example, we decide to combine and prune the\n> blockchain in its entirety every 999 blocks to one block (Genesis block not\n> included in count).\n>\n> <BR>\n>\n> How would this work?: Once block 1000 has been created, the network would\n> be waiting for a special \"pruned block\", and until this block was created\n> and verified, block 1001 would not be accepted by any nodes.\n>\n> This pruned block would prune everything from block 2 to block 1000,\n> leaving only the genesis block. Blocks 2 through 1000, would be calculated,\n> to create a summed up transaction of all transactions which occurred in\n> these 999 blocks.\n>\n> <BR>\n>\n> And its hash pointer would be the Genesis block.\n>\n> This block would now be verified by the full nodes, which if accepted\n> would then be willing to accept a new block (block 1001, not including the\n> pruned block in the count).\n>\n> <BR>\n>\n> The new block 1001, would use as its hash pointer the pruned block as its\n> reference. And the count would begin again to the next 1000. The next\n> pruned block would be created, its hash pointer will be referenced to the\n> Genesis Block. And so on..\n>\n> <BR>\n>\n> In this way the ledger will always be a maximum of 1000 blocks.\n>\n>\n>\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170827/fbd32ac1/attachment-0001.html>"
            },
            {
                "author": "Matthew Beton",
                "date": "2017-08-27T13:19:25",
                "message_text_only": "I think a slight problem with this is that wallets (often ones made by\nthird party wallet software) do not fully empty. I don't know how often\nthis happens, but some wallets, even if you tell them to send all funds,\nleave a small fraction of bitcoin remaining. If this is the case, it could\nbe detrimental to the 'pruning idea', as wallets with any coins left cannot\nbe pruned. For example:\n\nA has 1 BTC\nA -> B -> C\nIf these wallets are not removing all the BTC, and a fraction is left over,\nB will not be able to be pruned out of the chain. On the other hand, of the\nwallets are completely emptied, the new 'pruned block' will be able to show\nA sending 1btc to C.\n\nThis could be a problem, and so we need a way to persuade people to get\ntheir wallets to send everything instead of leaving a small fraction left\nover. I don't know how problematic this could be, or how frequently this\nhappens, but I'm just putting it out there.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170827/2adc90b5/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Solving the Scalability Problem on Bitcoin",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Btc Ideas",
                "Adam Tamir Shem-Tov",
                "Thomas Guyot-Sionnest",
                "Leandro Coutinho",
                "Matthew Beton",
                "Weiwu"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 31073
        }
    },
    {
        "title": "[bitcoin-dev] Solving the Scalability Problem Part II - Adam Shem-Tov",
        "thread_messages": [
            {
                "author": "Adam Tamir Shem-Tov",
                "date": "2017-08-26T21:01:56",
                "message_text_only": "<B>Solving the Scalability Problem Part II</B>\n--------------------------------------------------------------------\n<BR>\nIn the previous post I showed a way to minimize the blocks on the block\nchain, to lower the amount of space it takes on the hard drive, without\nlosing any relevant information.\nI added a note, saying that the transaction chain needs to be rewritten,\nbut I did not give much detail to it.<BR>\nHere is how that would work:<BR>\n<B>The Genesis Account:</B>\n-----------------------------------------<BR>\nThe problem with changing the transaction and block chain, is that it\ncannot be done without knowing the private key of the sender of the of the\nfunds for each account. There is however a way to circumvent that problem.\nThat is to create a special account called the \u201cGenesis Account\u201d, this\naccount\u2019s Private Key and Public Key will be available to everyone.<BR>\nBut this account will not be able to send or receive any funds in a normal\nblock, it will be blocked--blacklisted. So no one can intentionally use it.\nThe only time this account will be used is in the pruning block, a.k.a\nExodus Block.<BR>\nWhen creating the new pruned block chain and transaction chain, all the\nfunds that are now in accounts must be legitimate, and it would be\ndifficult to legitimize them unless they were sent from a legitimate\naccount, with a public key, and a private key which can be verified. That\nis where the Genesis account comes in. All funds in the Exodus Block will\nshow as though they originated and were sent from the Genesis Account using\nits privatekey to generate each transaction.<BR>\nThe funds which are sent, must match exactly the funds existing in the most\nupdated ledger in block 1000 (the last block as stated in my previous\npost).<BR>\nIn this way the Exodus Block can be verified, and the Genesis Account\ncannot give free money to anyway, because if someone tried to, it would\nfail verification.<BR>\n\n<BR>\nNow the next problem is that the number of Bitcoins keeps expanding and so\nthe funds in the Genesis Account need to expand as well. That can be done\nby showing as though this account is the account which is mining the coins,\nand it will be the only account in the Exodus Block which \u201cmines\u201d the\ncoins, and receives the mining bonus. In the Exodus Block all coins mined\nby the real miners will show as though they were mined by Genesis and sent\nto the miners through a regular transaction.\n\n<BR>\n\nAdam Shem-Tov\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170827/578cf518/attachment.html>"
            },
            {
                "author": "Thomas Guyot-Sionnest",
                "date": "2017-08-26T21:41:34",
                "message_text_only": "I don't think you fully understand the way bitcoin works. There are no\n\"accounts\" and no need to know the private key to change transactions in\nthe chain. What you need is to keep track of all unspent outputs (block\nnumber, index, value and script/witness) so that they can be verified\nonce a transaction refers to it.\n\nEverything you suggest about moving those funds to a \"genesis account\"\nis nonsense and cannot work.\n\n--\nThomas\n\nOn 26/08/17 05:01 PM, Adam Tamir Shem-Tov via bitcoin-dev wrote:\n>\n> <B>Solving the Scalability Problem Part II</B>\n> --------------------------------------------------------------------\n> <BR>\n> In the previous post I showed a way to minimize the blocks on the\n> block chain, to lower the amount of space it takes on the hard drive,\n> without losing any relevant information.\n> I added a note, saying that the transaction chain needs to be\n> rewritten, but I did not give much detail to it.<BR>\n> Here is how that would work:<BR>\n> <B>The Genesis Account:</B>\n> -----------------------------------------<BR>\n> The problem with changing the transaction and block chain, is that it\n> cannot be done without knowing the private key of the sender of the of\n> the funds for each account. There is however a way to circumvent that\n> problem. That is to create a special account called the \u201cGenesis\n> Account\u201d, this account\u2019s Private Key and Public Key will be available\n> to everyone.<BR>\n> But this account will not be able to send or receive any funds in a\n> normal block, it will be blocked--blacklisted. So no one can\n> intentionally use it. The only time this account will be used is in\n> the pruning block, a.k.a Exodus Block.<BR>\n> When creating the new pruned block chain and transaction chain, all\n> the funds that are now in accounts must be legitimate, and it would be\n> difficult to legitimize them unless they were sent from a legitimate\n> account, with a public key, and a private key which can be verified.\n> That is where the Genesis account comes in. All funds in the Exodus\n> Block will show as though they originated and were sent from the\n> Genesis Account using its privatekey to generate each transaction.<BR>\n> The funds which are sent, must match exactly the funds existing in the\n> most updated ledger in block 1000 (the last block as stated in my\n> previous post).<BR>\n> In this way the Exodus Block can be verified, and the Genesis Account\n> cannot give free money to anyway, because if someone tried to, it\n> would fail verification.<BR>\n>\n> <BR>\n> Now the next problem is that the number of Bitcoins keeps expanding\n> and so the funds in the Genesis Account need to expand as well. That\n> can be done by showing as though this account is the account which is\n> mining the coins, and it will be the only account in the Exodus Block\n> which \u201cmines\u201d the coins, and receives the mining bonus. In the Exodus\n> Block all coins mined by the real miners will show as though they were\n> mined by Genesis and sent to the miners through a regular transaction.\n>\n> <BR>\n>\n> Adam Shem-Tov\n>\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170826/6d12fc6c/attachment.html>"
            },
            {
                "author": "Christian Riley",
                "date": "2017-08-26T21:42:16",
                "message_text_only": "There have been a number of similar (identical?) proposals over the years, some were discussed in these threads:\nhttps://bitcointalk.org/index.php?topic=56226.0\nhttps://bitcointalk.org/index.php?topic=505.0\nhttps://bitcointalk.org/index.php?topic=473.0\nhttps://bitcointalk.org/index.php?topic=52859.0\nhttps://bitcointalk.org/index.php?topic=12376.0\nhttps://bitcointalk.org/index.php?topic=74559.15\n\n\n> On Aug 26, 2017, at 5:01 PM, Adam Tamir Shem-Tov via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> <B>Solving the Scalability Problem Part II</B>\n> --------------------------------------------------------------------\n> <BR>\n> In the previous post I showed a way to minimize the blocks on the block chain, to lower the amount of space it takes on the hard drive, without losing any relevant information.\n> I added a note, saying that the transaction chain needs to be rewritten, but I did not give much detail to it.<BR>\n> Here is how that would work:<BR>\n> <B>The Genesis Account:</B>\n> -----------------------------------------<BR>\n> The problem with changing the transaction and block chain, is that it cannot be done without knowing the private key of the sender of the of the funds for each account. There is however a way to circumvent that problem. That is to create a special account called the \u201cGenesis Account\u201d, this account\u2019s Private Key and Public Key will be available to everyone.<BR>\n> But this account will not be able to send or receive any funds in a normal block, it will be blocked--blacklisted. So no one can intentionally use it. The only time this account will be used is in the pruning block, a.k.a Exodus Block.<BR>\n> When creating the new pruned block chain and transaction chain, all the funds that are now in accounts must be legitimate, and it would be difficult to legitimize them unless they were sent from a legitimate account, with a public key, and a private key which can be verified. That is where the Genesis account comes in. All funds in the Exodus Block will show as though they originated and were sent from the Genesis Account using its privatekey to generate each transaction.<BR>\n> The funds which are sent, must match exactly the funds existing in the most updated ledger in block 1000 (the last block as stated in my previous post).<BR>\n> In this way the Exodus Block can be verified, and the Genesis Account cannot give free money to anyway, because if someone tried to, it would fail verification.<BR>\n> <BR>\n> Now the next problem is that the number of Bitcoins keeps expanding and so the funds in the Genesis Account need to expand as well. That can be done by showing as though this account is the account which is mining the coins, and it will be the only account in the Exodus Block which \u201cmines\u201d the coins, and receives the mining bonus. In the Exodus Block all coins mined by the real miners will show as though they were mined by Genesis and sent to the miners through a regular transaction.\n> <BR>\n> Adam Shem-Tov\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170826/8b40bb2d/attachment.html>"
            },
            {
                "author": "Adam Tamir Shem-Tov",
                "date": "2017-08-26T22:26:15",
                "message_text_only": "Thank You Christian for your response.\n\nhttps://bitcointalk.org/index.php?topic=473.0 :  I dont see the relevance.\nhttps://bitcointalk.org/index.php?topic=52859.0 : This idea does not seem\nto talking about trimming the full node. Trimming the full node is the key,\nthe full node is what keeps us secure from hackers. If it can be trimmed\nwithout losing security, that would be good, that is what I am proposing.\nhttps://bitcointalk.org/index.php?topic=12376.0 : Same answer as 505.0.\nhttps://bitcointalk.org/index.php?topic=74559.15 : I think his proposal is\nsimilar to mine, unfortunately for us his predictions were way off. He was\ntrying to fix this problem while believing that in the year 2020 the\nblockchain would be 4GB!!! It is not his fault, his prediction was in 2011.\nBut you can see, by his prediction, which was rational at the time, was way\noff. And it stresses my point, we need to fix this now. Too bad, no one\ntook him seriously back then, when the block chain i was 1GB.\n*https://bitcointalk.org/index.php?topic=56226.0\n<https://bitcointalk.org/index.php?topic=56226.0>*: Another guy with a\nvalid point, who was first acknowledged and then apparently ignored.\n.\nTo summarize, this problem was brought up about 6 years ago, when the\nblockchain was 1GB in size, Now it is about 140GB in size. I think it is\nabout time we stop ignoring this problem, and realize something needs to\nchange, or else the only full-nodes you will have will be with private\nmulti-million dollar companies, because no private citizen will have the\nstorage space to keep it. That would make bitcoin the worst decentralized\nor uncentralized system in history.\n\n\nOn 27 August 2017 at 00:42, Christian Riley <criley at gmail.com> wrote:\n\n> There have been a number of similar (identical?) proposals over the years,\n> some were discussed in these threads:\n> https://bitcointalk.org/index.php?topic=56226.0\n> https://bitcointalk.org/index.php?topic=505.0\n> https://bitcointalk.org/index.php?topic=473.0\n> https://bitcointalk.org/index.php?topic=52859.0\n> https://bitcointalk.org/index.php?topic=12376.0\n> https://bitcointalk.org/index.php?topic=74559.15\n>\n>\n> On Aug 26, 2017, at 5:01 PM, Adam Tamir Shem-Tov via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> <B>Solving the Scalability Problem Part II</B>\n> --------------------------------------------------------------------\n> <BR>\n> In the previous post I showed a way to minimize the blocks on the block\n> chain, to lower the amount of space it takes on the hard drive, without\n> losing any relevant information.\n> I added a note, saying that the transaction chain needs to be rewritten,\n> but I did not give much detail to it.<BR>\n> Here is how that would work:<BR>\n> <B>The Genesis Account:</B>\n> -----------------------------------------<BR>\n> The problem with changing the transaction and block chain, is that it\n> cannot be done without knowing the private key of the sender of the of the\n> funds for each account. There is however a way to circumvent that problem.\n> That is to create a special account called the \u201cGenesis Account\u201d, this\n> account\u2019s Private Key and Public Key will be available to everyone.<BR>\n> But this account will not be able to send or receive any funds in a normal\n> block, it will be blocked--blacklisted. So no one can intentionally use it.\n> The only time this account will be used is in the pruning block, a.k.a\n> Exodus Block.<BR>\n> When creating the new pruned block chain and transaction chain, all the\n> funds that are now in accounts must be legitimate, and it would be\n> difficult to legitimize them unless they were sent from a legitimate\n> account, with a public key, and a private key which can be verified. That\n> is where the Genesis account comes in. All funds in the Exodus Block will\n> show as though they originated and were sent from the Genesis Account using\n> its privatekey to generate each transaction.<BR>\n> The funds which are sent, must match exactly the funds existing in the\n> most updated ledger in block 1000 (the last block as stated in my previous\n> post).<BR>\n> In this way the Exodus Block can be verified, and the Genesis Account\n> cannot give free money to anyway, because if someone tried to, it would\n> fail verification.<BR>\n>\n> <BR>\n> Now the next problem is that the number of Bitcoins keeps expanding and so\n> the funds in the Genesis Account need to expand as well. That can be done\n> by showing as though this account is the account which is mining the coins,\n> and it will be the only account in the Exodus Block which \u201cmines\u201d the\n> coins, and receives the mining bonus. In the Exodus Block all coins mined\n> by the real miners will show as though they were mined by Genesis and sent\n> to the miners through a regular transaction.\n>\n> <BR>\n>\n> Adam Shem-Tov\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170827/56740a4c/attachment-0001.html>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2017-08-27T11:33:04",
                "message_text_only": "Regarding storage space, have you heard about pruning? Probably you should.\n\nOn 27 Aug 2017 12:27 am, \"Adam Tamir Shem-Tov via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Thank You Christian for your response.\n>\n> https://bitcointalk.org/index.php?topic=473.0 :  I dont see the relevance.\n> https://bitcointalk.org/index.php?topic=52859.0 : This idea does not seem\n> to talking about trimming the full node. Trimming the full node is the key,\n> the full node is what keeps us secure from hackers. If it can be trimmed\n> without losing security, that would be good, that is what I am proposing.\n> https://bitcointalk.org/index.php?topic=12376.0 : Same answer as 505.0.\n> https://bitcointalk.org/index.php?topic=74559.15 : I think his proposal\n> is similar to mine, unfortunately for us his predictions were way off. He\n> was trying to fix this problem while believing that in the year 2020 the\n> blockchain would be 4GB!!! It is not his fault, his prediction was in 2011.\n> But you can see, by his prediction, which was rational at the time, was way\n> off. And it stresses my point, we need to fix this now. Too bad, no one\n> took him seriously back then, when the block chain i was 1GB.\n> *https://bitcointalk.org/index.php?topic=56226.0\n> <https://bitcointalk.org/index.php?topic=56226.0>*: Another guy with a\n> valid point, who was first acknowledged and then apparently ignored.\n> .\n> To summarize, this problem was brought up about 6 years ago, when the\n> blockchain was 1GB in size, Now it is about 140GB in size. I think it is\n> about time we stop ignoring this problem, and realize something needs to\n> change, or else the only full-nodes you will have will be with private\n> multi-million dollar companies, because no private citizen will have the\n> storage space to keep it. That would make bitcoin the worst decentralized\n> or uncentralized system in history.\n>\n>\n> On 27 August 2017 at 00:42, Christian Riley <criley at gmail.com> wrote:\n>\n>> There have been a number of similar (identical?) proposals over the\n>> years, some were discussed in these threads:\n>> https://bitcointalk.org/index.php?topic=56226.0\n>> https://bitcointalk.org/index.php?topic=505.0\n>> https://bitcointalk.org/index.php?topic=473.0\n>> https://bitcointalk.org/index.php?topic=52859.0\n>> https://bitcointalk.org/index.php?topic=12376.0\n>> https://bitcointalk.org/index.php?topic=74559.15\n>>\n>>\n>> On Aug 26, 2017, at 5:01 PM, Adam Tamir Shem-Tov via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> <B>Solving the Scalability Problem Part II</B>\n>> --------------------------------------------------------------------\n>> <BR>\n>> In the previous post I showed a way to minimize the blocks on the block\n>> chain, to lower the amount of space it takes on the hard drive, without\n>> losing any relevant information.\n>> I added a note, saying that the transaction chain needs to be rewritten,\n>> but I did not give much detail to it.<BR>\n>> Here is how that would work:<BR>\n>> <B>The Genesis Account:</B>\n>> -----------------------------------------<BR>\n>> The problem with changing the transaction and block chain, is that it\n>> cannot be done without knowing the private key of the sender of the of the\n>> funds for each account. There is however a way to circumvent that problem.\n>> That is to create a special account called the \u201cGenesis Account\u201d, this\n>> account\u2019s Private Key and Public Key will be available to everyone.<BR>\n>> But this account will not be able to send or receive any funds in a\n>> normal block, it will be blocked--blacklisted. So no one can intentionally\n>> use it. The only time this account will be used is in the pruning block,\n>> a.k.a Exodus Block.<BR>\n>> When creating the new pruned block chain and transaction chain, all the\n>> funds that are now in accounts must be legitimate, and it would be\n>> difficult to legitimize them unless they were sent from a legitimate\n>> account, with a public key, and a private key which can be verified. That\n>> is where the Genesis account comes in. All funds in the Exodus Block will\n>> show as though they originated and were sent from the Genesis Account using\n>> its privatekey to generate each transaction.<BR>\n>> The funds which are sent, must match exactly the funds existing in the\n>> most updated ledger in block 1000 (the last block as stated in my previous\n>> post).<BR>\n>> In this way the Exodus Block can be verified, and the Genesis Account\n>> cannot give free money to anyway, because if someone tried to, it would\n>> fail verification.<BR>\n>>\n>> <BR>\n>> Now the next problem is that the number of Bitcoins keeps expanding and\n>> so the funds in the Genesis Account need to expand as well. That can be\n>> done by showing as though this account is the account which is mining the\n>> coins, and it will be the only account in the Exodus Block which \u201cmines\u201d\n>> the coins, and receives the mining bonus. In the Exodus Block all coins\n>> mined by the real miners will show as though they were mined by Genesis and\n>> sent to the miners through a regular transaction.\n>>\n>> <BR>\n>>\n>> Adam Shem-Tov\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170827/9a7e5ee0/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Solving the Scalability Problem Part II - Adam Shem-Tov",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Thomas Guyot-Sionnest",
                "Christian Riley",
                "Jorge Tim\u00f3n",
                "Adam Tamir Shem-Tov"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 20064
        }
    },
    {
        "title": "[bitcoin-dev] Revised - Solving the Scalability Problem on Bitcoin",
        "thread_messages": [
            {
                "author": "Adam Tamir Shem-Tov",
                "date": "2017-08-27T04:09:08",
                "message_text_only": "This is a link to the most updated version of the problem and my proposed\nsolution, granted it still needs work, but this problem needs to be\nresolved quickly. So I hope it will receive the attention it deserves, even\nif the solution comes from somebody else.\nhttps://bitcointalk.org/index.php?topic=2126152.new#new\n\nThe latest version of the day:\n\n*Solving the Scalability issue for Bitcoin  *\n\n*What am I trying to solve?* Currently Bitcoin\u2019s blockchain is around 140GB.\nIn 2011 it took 1GB, and it was predicted back then that in 2020 that size\nwould be 4GB.\nAs you can see it is not yet 2020, and we are way over that predicted size.\nAt our current time, prune nodes which make the block smaller, but they can\nnot be validated without the full node. And this full node is getting\nexponentially bigger, we need to stop that. Because if we don\u2019t no private\ncitizen will have the capability of storing the full node in his computer,\nand all full nodes will be at private multi-million dollar companies. That\nwould literally be the end of decentralization (or non-centralization).\nWhat I am proposing also makes sure the blockchain has a maximum finite\nsize, because today the blockchain can grow to any size without limit while\nit approaches an infinite size!\nToday our blockchain is growing at speed which is much faster than Moore\u2019s\nlaw! This proposal will help set storage growth at a reasonable number.\n\n\n*A short list of what I am about to explain:   Steps that need to be taken:*\n---------------------------------------------------------------------------------------------------------------------\n(The details are not described in this order)\n1) Create a pair of keys, called the Genesis Pair, or Genesis Account, a\nprivate and public key which will be publicly known to all and yet it\u2019s use\nwill be restricted and monitored by all. The key will be the source of all\nfunds (Point A).\n2) Preserve the Genesis Block, its hash code is needed. And personally I\nthink its of historical value.\n3) Combine all Blocks up to the most recent (not including the Genesis\nBlock), and cut out all intermediary transactions, by removing All\ntransactions, and replacing them with new transactions sent from A to every\npublic key which has funds in the most recent block, in the amount they\nhave. And sign these transactions with A\u2019s private-key. And create a new\nblock with this information.\n4) This Combined/Pruned Block should point to the Genesis Block hash, and\nthe next block created should point to the Pruned Blocks hash. The random\nnumber used for this pruned block will be predefined, this random number\nnormally used to meet the hash difficulty requirement in this case is not\nneeded, since no difficulty setting is necessary for this block, and by\npredefining it, this block can be easily identified.\n5) Download the pruned block from another node or create it yourself, the\nhash code will be identical for everyone, since the block will be created\nexactly the same everywhere.\n6) Preserve a certain amount of the most recent blocks, just in case a\nlonger blockchain is discovered, and then the Pruned Block should be\nrecalculated.\n\n---------------------------------------------------------------------------------------------------------------------\n*Now for a more detailed description: *\nI have this idea to solve the scalability problem I wish to make public.\nIf I am wrong I hope to be corrected, and if I am right we will all gain by\nit.\nCurrently each block is being hashed, and in its contents are the hash of\nthe block preceding it, this goes back to the genesis block.\n\nWhat if we decide, for example, we decide to combine and prune the\nblockchain in its entirety every 999 blocks to one block (Genesis block not\nincluded in count).\n\nHow would this work?: Once block 1000 has been created, the network would\nbe waiting for a special \"pruned block\", and until this block was created\nand verified, block 1001 would not be accepted by any nodes.\nThis pruned block would prune everything from block 2 to block 1000,\nleaving only the genesis block. Blocks 2 through 1000, would be calculated,\nto create a summed up transaction of all transactions which occurred in\nthese 999 blocks.\n\nAnd its hash pointer would be the Genesis block.\nThis block would now be verified by the full nodes (or created by them),\nwhich if accepted would then be willing to accept a new block (block 1001,\nnot including the pruned block in the count).\n\nThe new block 1001, would use as its hash pointer the pruned block as its\nreference. And the count would begin again to the next 1000. The next\npruned block would be created, its hash pointer will be referenced to the\nGenesis Block. And so on..\nIn this way the ledger will always be a maximum of 1000 blocks.\n\n A bit more detail:\n\nAll the relevant outputs needed to verify early transactions will all be\npreserved in the pruning block. The only information you lose are of the\nintermediate transactions, not the final ones the community has already\naccepted. Although the origin of the funds could not be known, there\ndestination is preserved, as well a validation that the transactions are\nlegitimate.\nFor example:\n\nA = 2.3 BTC, B=0 BTC, C=1.4 BTC. (Block 1)\nIf A sends 2.3 BTC to B.  (Block 2)\nAnd then B sends 1.5 BTC to C. (Block 3)\nThe pruning block will report:\nA->B = 0.8 BTC and A->C=2.9 BTC.\nThe rest of the information you lose, is irrelevant. No one needs to know,\nwhat exactly happened, who sent who what, or when. All that is needed is\nthe funds currently owned by each key.\n\nNote:  The Transaction Chain would also need to be rewritten, to delete all\nintermediate transactions, it will show as though transactions occurred\nfrom the Genesis block directly to the pruned block, as though nothing ever\nexisted in between. This will be described below in more detail.\n\nYou can keep the old blocks on your drive for 10 more blocks or so, just in\ncase a longer block chain is found, but other than that the information it\nholds is useless, since it has all been agreed upon. And the pruning block\nholds all up to date account balances, so cheating is impossible.\n\nGranted this pruning block can get extremely large in the future, it will\nnot be the regular size of the other blocks. For example if every account\nhas only 1 satoshi in it, which is the minimum, then the amount of accounts\nwill be at its maximum. Considering a transaction is about 256bytes. That\nwould mean the pruning block would be approximately 500PB, which is 500,000\nTerra-bytes. That is a theoretical scenario, which is not likely to occur.\n(256bytes*21M BTC*100M (satoshis in 1 BTC))\n\nA scenario which could be solved by creating a minimum transaction fee of\nfor example: 100 satoshis, which would insure that even in the most\nunlikely scenario, at worst the pruning block would be 5PB in size.\nWhich is still extremely large for today. But without implementing this\nidea the blockchain literally does not have a finite maximum size, and over\ntime approaches infinity!\n\n*Also, this pruning block does not even need to be downloaded, it could be\ncreated by already existing information, each full node by itself, by: *\n1) combining and pruning all previous blocks\n2) using the genesis block as its hash pointer\n3) using a predefined random number \"2\", which will be used by all. A\nrandom number which is normally added to a block to ensure the block's\nhash-rate difficulty, is not needed in this case, since all information can\nbe verified by each node by itself through pruning.\nThis number can also be used to identify this block as the Pruned/Combined\nBlock since it is static.\n4) Any other information which is needed for the SHA256 hash, for example a\ntime-stamp could be copied off the last block in the block chain.\nThese steps will ensure each full node, will get the exact hash code as the\nothers have gotten for this pruning block.\n\nAnd as I previously stated the next block will use this hash code as its\nhash reference.\nBy creating a system like this, the pruning block does not have to be\ncreated last minute, but gradually over time, every time a new block comes\nin, and only when the last block arrives (block 1000), will it be\nfinalized, and hashed.\nAnd since this block will always be second, it should go by the name\n\"Exodus Block\".\n\nAbove, I showed a way to minimize the blocks on the block chain, to lower\nthe amount of space it takes on the hard drive, without losing any relevant\ninformation.\nI added a note, saying that the transaction chain needs to be rewritten,\nbut I did not give much detail to it.\n\nHere is how that would work:\n\n*The Genesis Account (Key Pair):*\n---------------------------------------------------\nThe problem with changing the transaction and block chain, is that it\ncannot be done without knowing the private key of the sender of the of the\nfunds for each account.\nTo illustrate the problem: If we have a series of block chains with a\nstring of transactions that are A\u2192B\u2192C\u2192D, and to simplify the problem, all\nmoney was sent during each transaction, so that no money is left in A or B\nor C. And I was to prune these transactions, by replacing them with A\u2192D.\nOnly this transaction never occurred, nor can anyone create it without A\u2019s\nprivate key.\nThere is however a way to circumvent that problem. That is to create a\nspecial account called the \u201cGenesis Account\u201d, this account\u2019s Private Key\nand Public Key will be available to everyone.\n(Of course, accounts do not really exist in Bitcoin, when I say account\nwhat I really mean is a Private/Public Key pair)\nThis account will be the source of all funds\nBut this account will not be able to send or receive any funds in a normal\nblock, it will be blocked--blacklisted. So no one can intentionally use it.\nThe only time this account will be used is in the pruning block, a.k.a\nExodus Block.\nWhen creating the new pruned block chain and transaction chain, all the\nfunds that are now in accounts must be legitimate, and it would be\ndifficult to legitimize them unless they were sent from a legitimate\nprivate key, which can be verified. That is where the Genesis account comes\nin. All funds in the Exodus Block will show as though they originated and\nwere sent with the Genesis private-key to generate each transaction.\nThe funds which are sent, must match exactly the funds existing in the most\nupdated ledger in block 1000.\nIn this way the Exodus Block can be verified, and the Genesis Account\ncannot give free money to anyway, because if someone tried to, it would\nfail verification.\n\nNow the next problem is that the number of Bitcoins keeps expanding and so\nthe funds in the Genesis Account need to expand as well. That can be done\nby showing as though this account is the account which is mining the coins,\nand it will be the only account in the Exodus Block which \u201cmines\u201d the\ncoins, and receives the mining bonus. In the Exodus Block all coins mined\nby the real miners will show as though they were mined by Genesis and sent\nto the miners through a regular transaction.\n\nI hope this proposal will be implemented as soon as possible so that we can\navoid a problem which is growing by the minute. It was brought up about 6\nyears ago when the blockchain was only 1GB in size, nobody imagined back\nthen that it would grow so quickly, and the problem was ignored.\nToday all solutions implemented have been implemented by software, and not\non the blockchain itself, these solutions are not helpful in the long run.\n\nThe full node needs to be publicly available to everyone, and at this rate,\nnobody will have the hard-drive capacity to store. This will make us more\ndependent on private corporation\u2019s to store the blockchain, which will lead\nus quickly to a centralized currency platform. By then it will be too late,\nand the corporations will have complete control of what happens next.\nPlease take this problem seriously and work with me, to prevent it while we\nstill have some time.\nThe exact details can be worked out at a later time, but for now we need at\nleast an acknowledgment that this problem is dire, and needs to be solved\nin a year\u2019s time. I have presented a solution, if someone has a better one,\nthen let him/her step forward, but in any case a solution needs to be\nimplemented as soon as possible.\n\n*I have given a basic proposal, I am sure there are those among us with\nmore technical understanding to the nuances of how this idea should be\nimplemented. I am counting on their help to see this through.*\n\nAdam Shem-Tov\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170827/8297e345/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Revised - Solving the Scalability Problem on Bitcoin",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Adam Tamir Shem-Tov"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 12632
        }
    },
    {
        "title": "[bitcoin-dev] P2WPKH Scripts, P2PKH Addresses, and Uncompressed Public Keys",
        "thread_messages": [
            {
                "author": "Alex Nagy",
                "date": "2017-08-28T15:29:31",
                "message_text_only": "Let's say Alice has a P2PKH address derived from an uncompressed public key, 1MsHWS1BnwMc3tLE8G35UXsS58fKipzB7a (from https://bitcoin.stackexchange.com/questions/3059/what-is-a-compressed-bitcoin-key).\n\nIf Alice gives Bob 1MsHWS1BnwMc3tLE8G35UXsS58fKipzB7a, is there any way Bob can safely issue Native P2WPKH outputs to Alice?\n\nBIPs 141 and 143 make it very clear that P2WPKH scripts may only derive from compressed public-keys.  Given this restriction, assuming all you have is a P2PKH address - is there any way for Bob to safely issue spendable Native P2WPKH outputs to Alice?\n\nThe problem is Bob as no idea whether Alice's P2PKH address represents a compressed or uncompressed public-key, so Bob cannot safely issue a Native P2WPKH output.\n\nAFAICT all code is supposed to assume P2WPHK outputs are compressed public-key derived.  The conclusion would be that the existing P2PKH address format is generally unsafe to use with SegWit since P2PKH addresses may be derived from uncompressed public-keys.\n\nAm I missing something here?\n\n\n\n\n\nReferencing BIP141 and BIP143, specifically these sections:\n\nhttps://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#New_script_semantics\n\n\"Only compressed public keys are accepted in P2WPKH and P2WSH\"\n\nhttps://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki#Restrictions_on_public_key_type\n\n\"As a default policy, only compressed public keys are accepted in P2WPKH and P2WSH. Each public key passed to a sigop inside version 0 witness program must be a compressed key: the first byte MUST be either 0x02 or 0x03, and the size MUST be 33 bytes. Transactions that break this rule will not be relayed or mined by default.\n\nSince this policy is preparation for a future softfork proposal, to avoid potential future funds loss, users MUST NOT use uncompressed keys in version 0 witness programs.\"\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170828/9facf9a0/attachment.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-08-28T21:33:52",
                "message_text_only": "> On Aug 28, 2017, at 8:29 AM, Alex Nagy via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> If Alice gives Bob 1MsHWS1BnwMc3tLE8G35UXsS58fKipzB7a, is there any way Bob can safely issue Native P2WPKH outputs to Alice?\n> \n\nNo, and the whole issue of compressed vs uncompressed is a red herring. If Alice gives Bob 1MsHWS1BnwMc3tLE8G35UXsS58fKipzB7a, she is saying to Bob \u201cI will accept payment to the scriptPubKey [DUP HASH160 PUSHDATA(20)[e4e517ee07984a4000cd7b00cbcb545911c541c4] EQUALVERIFY CHECKSIG]\u201d.\n\nPayment to any other scriptPubKey may not be recognized by Alice.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170828/80188ca0/attachment.html>"
            },
            {
                "author": "Alex Nagy",
                "date": "2017-08-28T20:55:47",
                "message_text_only": "Thanks Gregory - to be clear should Native P2WPKH scripts only appear in redeem scripts?  From reading the various BIPs it had seemed like Native P2WPKH and Native P2WSH were also valid and identifiable if they were encoded in TxOuts.  The theoretical use case for this would be saving bytes in Txes with many outputs.\n\n-----Original Message-----\nFrom: Gregory Maxwell [mailto:gmaxwell at gmail.com] \nSent: Monday, August 28, 2017 10:04 AM\nTo: Alex Nagy <optimiz3 at hotmail.com>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>\nSubject: Re: [bitcoin-dev] P2WPKH Scripts, P2PKH Addresses, and Uncompressed Public Keys\n\nOn Mon, Aug 28, 2017 at 3:29 PM, Alex Nagy via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> If Alice gives Bob 1MsHWS1BnwMc3tLE8G35UXsS58fKipzB7a, is there any \n> way Bob can safely issue Native P2WPKH outputs to Alice?\n\nAbsolutely not. You can only pay people to a script pubkey that they have specified.\n\nTrying to construct some alternative one that they didn't specify but in theory could spend would be like \"paying someone\" by putting a cheque in a locked safe labeled \"danger radioactive\" that you quietly bury in their back yard.  Or taking the payment envelope they gave you stuffing it with cash after changing the destination name to pig latin and hiding it in the nook of a tree they once climbed as a child.\n\nThere have been technical reasons why some wallets would sometimes display some outputs they didn't generate but could spend, but these cases are flaws-- they're not generic for all cases they could in theory spend, and mostly exist because durability to backup recovery makes it impossible for it to tell what it did or didn't issue.\n\nSo regardless of your query about uncompressed keys, you cannot do what you described: Wallets will not see the payment and may have no mechanism to recover it even if you tell the recipient what you've done. And yes, the use of an uncompressed yet could later render it unspendable."
            },
            {
                "author": "Johnson Lau",
                "date": "2017-08-29T03:30:07",
                "message_text_only": "Yes it is allowed in TxOuts. And yes it is designed to save space. But the problem is Bob can\u2019t assume Alice understands the new TxOuts format. If Bob really wants to save space this way, he should first ask for a new BIP173 address from Alice. Never try to convert a P2PKH address to a P2SH or BIP173 address without the consent of the recipient.\n \n\n> On 29 Aug 2017, at 4:55 AM, Alex Nagy via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Thanks Gregory - to be clear should Native P2WPKH scripts only appear in redeem scripts?  From reading the various BIPs it had seemed like Native P2WPKH and Native P2WSH were also valid and identifiable if they were encoded in TxOuts.  The theoretical use case for this would be saving bytes in Txes with many outputs.\n>"
            }
        ],
        "thread_summary": {
            "title": "P2WPKH Scripts, P2PKH Addresses, and Uncompressed Public Keys",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Alex Nagy",
                "Johnson Lau",
                "Mark Friedenbach"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 5585
        }
    },
    {
        "title": "[bitcoin-dev] \"Compressed\" headers stream",
        "thread_messages": [
            {
                "author": "Riccardo Casatta",
                "date": "2017-08-28T15:50:23",
                "message_text_only": "Hi everyone,\n\nthe Bitcoin headers are probably the most condensed and important piece of\ndata in the world, their demand is expected to grow.\n\nWhen sending a stream of continuous block headers, a common case in IBD and\nin disconnected clients, I think there is a possible optimization of the\ntransmitted data:\nThe headers after the first could avoid transmitting the previous hash\ncause the receiver could compute it by double hashing the previous header\n(an operation he needs to do anyway to verify PoW).\nIn a long stream, for example 2016 headers, the savings in bandwidth are\nabout 32/80 ~= 40%\nwithout compressed headers 2016*80=161280 bytes\nwith compressed headers 80+2015*48=96800 bytes\n\nWhat do you think?\n\n\nIn OpenTimestamps calendars we are going to use this compression to give\nlite-client a reasonable secure proofs (a full node give higher security\nbut isn't feasible in all situations, for example for in-browser\nverification)\nTo speed up sync of a new client Electrum starts with the download of a file\n<https://headers.electrum.org/blockchain_headers> ~36MB containing the\nfirst 477637 headers.\nFor this kind of clients could be useful a common http API with fixed\nposition chunks to leverage http caching. For example /headers/2016/0\nreturns the headers from the genesis to the 2015 header included while\n/headers/2016/1 gives the headers from the 2016th to the 4031.\nOther endpoints could have chunks of 20160 blocks or 201600 such that with\nabout 10 http requests a client could fast sync the headers\n\n\n-- \nRiccardo Casatta - @RCasatta <https://twitter.com/RCasatta>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170828/9d357bb7/attachment.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2017-08-28T16:13:11",
                "message_text_only": "Is there any reason to believe that you need Bitcoin \"full security\" at all\nfor timestamping?\n\nOn Mon, Aug 28, 2017 at 11:50 AM, Riccardo Casatta via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi everyone,\n>\n> the Bitcoin headers are probably the most condensed and important piece of\n> data in the world, their demand is expected to grow.\n>\n> When sending a stream of continuous block headers, a common case in IBD\n> and in disconnected clients, I think there is a possible optimization of\n> the transmitted data:\n> The headers after the first could avoid transmitting the previous hash\n> cause the receiver could compute it by double hashing the previous header\n> (an operation he needs to do anyway to verify PoW).\n> In a long stream, for example 2016 headers, the savings in bandwidth are\n> about 32/80 ~= 40%\n> without compressed headers 2016*80=161280 bytes\n> with compressed headers 80+2015*48=96800 bytes\n>\n> What do you think?\n>\n>\n> In OpenTimestamps calendars we are going to use this compression to give\n> lite-client a reasonable secure proofs (a full node give higher security\n> but isn't feasible in all situations, for example for in-browser\n> verification)\n> To speed up sync of a new client Electrum starts with the download of a\n> file <https://headers.electrum.org/blockchain_headers> ~36MB containing\n> the first 477637 headers.\n> For this kind of clients could be useful a common http API with fixed\n> position chunks to leverage http caching. For example /headers/2016/0\n> returns the headers from the genesis to the 2015 header included while\n> /headers/2016/1 gives the headers from the 2016th to the 4031.\n> Other endpoints could have chunks of 20160 blocks or 201600 such that with\n> about 10 http requests a client could fast sync the headers\n>\n>\n> --\n> Riccardo Casatta - @RCasatta <https://twitter.com/RCasatta>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170828/9d9b76f3/attachment-0001.html>"
            },
            {
                "author": "Riccardo Casatta",
                "date": "2017-08-28T16:25:01",
                "message_text_only": "2017-08-28 18:13 GMT+02:00 Greg Sanders <gsanders87 at gmail.com>:\n\n> Is there any reason to believe that you need Bitcoin \"full security\" at\n> all for timestamping?\n>\n\nThis is a little bit out of the main topic of the email which is the\nsavings in bandwidth in transmitting headers, any comment about that?\n\n\nP.S. As a personal experience timestamping is nowadays used to prove date\nand integrity of private databases containing a lot of value, so yes, in\nthat cases I will go with Bitcoin \"full security\"\n\n\n>\n> On Mon, Aug 28, 2017 at 11:50 AM, Riccardo Casatta via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi everyone,\n>>\n>> the Bitcoin headers are probably the most condensed and important piece\n>> of data in the world, their demand is expected to grow.\n>>\n>> When sending a stream of continuous block headers, a common case in IBD\n>> and in disconnected clients, I think there is a possible optimization of\n>> the transmitted data:\n>> The headers after the first could avoid transmitting the previous hash\n>> cause the receiver could compute it by double hashing the previous header\n>> (an operation he needs to do anyway to verify PoW).\n>> In a long stream, for example 2016 headers, the savings in bandwidth are\n>> about 32/80 ~= 40%\n>> without compressed headers 2016*80=161280 bytes\n>> with compressed headers 80+2015*48=96800 bytes\n>>\n>> What do you think?\n>>\n>>\n>> In OpenTimestamps calendars we are going to use this compression to give\n>> lite-client a reasonable secure proofs (a full node give higher security\n>> but isn't feasible in all situations, for example for in-browser\n>> verification)\n>> To speed up sync of a new client Electrum starts with the download of a\n>> file <https://headers.electrum.org/blockchain_headers> ~36MB containing\n>> the first 477637 headers.\n>> For this kind of clients could be useful a common http API with fixed\n>> position chunks to leverage http caching. For example /headers/2016/0\n>> returns the headers from the genesis to the 2015 header included while\n>> /headers/2016/1 gives the headers from the 2016th to the 4031.\n>> Other endpoints could have chunks of 20160 blocks or 201600 such that\n>> with about 10 http requests a client could fast sync the headers\n>>\n>>\n>> --\n>> Riccardo Casatta - @RCasatta <https://twitter.com/RCasatta>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>\n\n\n-- \nRiccardo Casatta - @RCasatta <https://twitter.com/RCasatta>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170828/989d67aa/attachment.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2017-08-28T16:26:48",
                "message_text_only": "Well, if anything my question may bolster your use-case. If there's a\nheavier chain that is invalid, I kind of doubt it matters for timestamping\nreasons.\n\n/digression\n\nOn Mon, Aug 28, 2017 at 12:25 PM, Riccardo Casatta <\nriccardo.casatta at gmail.com> wrote:\n\n>\n> 2017-08-28 18:13 GMT+02:00 Greg Sanders <gsanders87 at gmail.com>:\n>\n>> Is there any reason to believe that you need Bitcoin \"full security\" at\n>> all for timestamping?\n>>\n>\n> This is a little bit out of the main topic of the email which is the\n> savings in bandwidth in transmitting headers, any comment about that?\n>\n>\n> P.S. As a personal experience timestamping is nowadays used to prove date\n> and integrity of private databases containing a lot of value, so yes, in\n> that cases I will go with Bitcoin \"full security\"\n>\n>\n>>\n>> On Mon, Aug 28, 2017 at 11:50 AM, Riccardo Casatta via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Hi everyone,\n>>>\n>>> the Bitcoin headers are probably the most condensed and important piece\n>>> of data in the world, their demand is expected to grow.\n>>>\n>>> When sending a stream of continuous block headers, a common case in IBD\n>>> and in disconnected clients, I think there is a possible optimization of\n>>> the transmitted data:\n>>> The headers after the first could avoid transmitting the previous hash\n>>> cause the receiver could compute it by double hashing the previous header\n>>> (an operation he needs to do anyway to verify PoW).\n>>> In a long stream, for example 2016 headers, the savings in bandwidth are\n>>> about 32/80 ~= 40%\n>>> without compressed headers 2016*80=161280 bytes\n>>> with compressed headers 80+2015*48=96800 bytes\n>>>\n>>> What do you think?\n>>>\n>>>\n>>> In OpenTimestamps calendars we are going to use this compression to give\n>>> lite-client a reasonable secure proofs (a full node give higher security\n>>> but isn't feasible in all situations, for example for in-browser\n>>> verification)\n>>> To speed up sync of a new client Electrum starts with the download of a\n>>> file <https://headers.electrum.org/blockchain_headers> ~36MB containing\n>>> the first 477637 headers.\n>>> For this kind of clients could be useful a common http API with fixed\n>>> position chunks to leverage http caching. For example /headers/2016/0\n>>> returns the headers from the genesis to the 2015 header included while\n>>> /headers/2016/1 gives the headers from the 2016th to the 4031.\n>>> Other endpoints could have chunks of 20160 blocks or 201600 such that\n>>> with about 10 http requests a client could fast sync the headers\n>>>\n>>>\n>>> --\n>>> Riccardo Casatta - @RCasatta <https://twitter.com/RCasatta>\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>>\n>>\n>\n>\n> --\n> Riccardo Casatta - @RCasatta <https://twitter.com/RCasatta>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170828/2ecd2708/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "\"Compressed\" headers stream",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Riccardo Casatta",
                "Greg Sanders"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 9886
        }
    },
    {
        "title": "[bitcoin-dev] Fwd:  P2WPKH Scripts, P2PKH Addresses, and Uncompressed Public Keys",
        "thread_messages": [
            {
                "author": "Gregory Maxwell",
                "date": "2017-08-28T17:06:04",
                "message_text_only": "On Mon, Aug 28, 2017 at 3:29 PM, Alex Nagy via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> If Alice gives Bob 1MsHWS1BnwMc3tLE8G35UXsS58fKipzB7a, is there any way Bob\n> can safely issue Native P2WPKH outputs to Alice?\n\nAbsolutely not. You can only pay people to a script pubkey that they\nhave specified.\n\nTrying to construct some alternative one that they didn't specify but\nin theory could spend would be like \"paying someone\" by putting a\ncheque in a locked safe labeled \"danger radioactive\" that you quietly\nbury in their back yard.  Or taking the payment envelope they gave you\nstuffing it with cash after changing the destination name to pig latin\nand hiding it in the nook of a tree they once climbed as a child.\n\nThere have been technical reasons why some wallets would sometimes\ndisplay some outputs they didn't generate but could spend, but these\ncases are flaws-- they're not generic for all cases they could in\ntheory spend, and mostly exist because durability to backup recovery\nmakes it impossible for it to tell what it did or didn't issue.\n\nSo regardless of your query about uncompressed keys, you cannot do\nwhat you described: Wallets will not see the payment and may have no\nmechanism to recover it even if you tell the recipient what you've\ndone. And yes, the use of an uncompressed yet could later render it\nunspendable."
            }
        ],
        "thread_summary": {
            "title": "Fwd:  P2WPKH Scripts, P2PKH Addresses, and Uncompressed Public Keys",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Gregory Maxwell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1359
        }
    },
    {
        "title": "[bitcoin-dev] Fwd:  \"Compressed\" headers stream",
        "thread_messages": [
            {
                "author": "Gregory Maxwell",
                "date": "2017-08-28T17:12:15",
                "message_text_only": "On Mon, Aug 28, 2017 at 3:50 PM, Riccardo Casatta via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Hi everyone,\n>\n> the Bitcoin headers are probably the most condensed and important piece of\n> data in the world, their demand is expected to grow.\n>\n> When sending a stream of continuous block headers, a common case in IBD and\n> in disconnected clients, I think there is a possible optimization of the\n> transmitted data:\n> The headers after the first could avoid transmitting the previous hash cause\n> the receiver could compute it by double hashing the previous header (an\n> operation he needs to do anyway to verify PoW).\n> In a long stream, for example 2016 headers, the savings in bandwidth are\n> about 32/80 ~= 40%\n> without compressed headers 2016*80=161280 bytes\n> with compressed headers 80+2015*48=96800 bytes\n>\n> What do you think?\n\nYou are leaving a lot of bytes on the table.\n\nThe bits field can only change every 2016 blocks (4 bytes per header),\nthe timestamp can not be less than the median of the last 11 and is\nusually only a small amount over the last one (saves 2 bytes per\nheader), the block version is usually one of the last few (save 3\nbytes per header).\n\nBut all these things improvements are just a constant factor. I think\nyou want the compact SPV proofs described in the appendix of the\nsidechains whitepaper which creates log scaling proofs."
            }
        ],
        "thread_summary": {
            "title": "Fwd:  \"Compressed\" headers stream",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Gregory Maxwell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1388
        }
    },
    {
        "title": "[bitcoin-dev] Fwd: \"Compressed\" headers stream",
        "thread_messages": [
            {
                "author": "Kalle Rosenbaum",
                "date": "2017-08-28T17:54:59",
                "message_text_only": "2017-08-28 19:12 GMT+02:00 Gregory Maxwell via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org>:\n\n>\n> The bits field can only change every 2016 blocks (4 bytes per header),\n> the timestamp can not be less than the median of the last 11 and is\n> usually only a small amount over the last one (saves 2 bytes per\n> header), the block version is usually one of the last few (save 3\n> bytes per header).\n>\n\n ... and I guess the nonce can be arbitrarily truncated as well, just brute\nforce the missing bits :-P.\n\n\n> But all these things improvements are just a constant factor. I think\n> you want the compact SPV proofs described in the appendix of the\n> sidechains whitepaper which creates log scaling proofs.\n>\n\nI think that my blog post on compact spv proofs can be helpful also. It\ntries to make the pretty compact formulations in the sidechains paper a bit\nmore graspable by normal people.\n\nhttp://popeller.io/index.php/2016/09/15/compact-spv-proofs/\n\nKalle\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170828/90056415/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Fwd: \"Compressed\" headers stream",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Kalle Rosenbaum"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1146
        }
    },
    {
        "title": "[bitcoin-dev] BIP proposal for Lightning-oriented multiaccount multisig HD wallets",
        "thread_messages": [
            {
                "author": "Simone Bronzini",
                "date": "2017-08-29T10:19:10",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nHi all,\nlast month we started looking for feedback (here and on other channels)\nabout a proposal for a new structure to facilitate the management of\ndifferent multisig accounts under the same master key, avoiding key\nreuse but still allowing cosigners to independently generate new\naddresses. While previously multiaccount multisig wallets were little\nused, now that LN is becoming a reality it is extremely important to\nhave a better multiaccount management method to handle multiple payment\nchannels.\nPlease have a look at the draft of the BIP at the link below:\n\nhttps://github.com/chainside/BIP-proposal/blob/master/BIP.mediawiki\n\nAny feedback is highly appreciated, but in particular we would like to\ncollect opinions about the following issues:\n\n1. coin_type level:\nthis level is intended to allow users to manage multiple\ncryptocurrencies or forks of Bitcoin using the same masterkey (similarly\nto BIP44). We have already received some legit objections that, since we\nare talking about a Bitcoin Improvement Proposal,  it shouldn't care\nabout alt-coins. While we can agree with such objections, we also\nbelieve that having a coin_type level improves interoperability with\nmuti-currency wallets (which is good), without any major drawback.\nMoreover, even a Bitcoin maximalist may hold multiple coins for whatever\nreason (short term speculation, testing, etc).\n\n2. SegWit addresses:\nsince mixing SegWit and non-SegWit addresses on the same BIP44 structure\ncould lead to UTXOs not being completely recognised by old wallets,\nBIP49 was proposed to separate the key space. Since this is a new\nproposal, we can assume that wallets implementing it would be\nSegWit-compatible and so there should be no need to differetiate between\nSegWit and non-SegWit pubkeys. Anyway, if someone believes this problem\nstill holds, we thought about two possible solutions:\n    a. Create separate purposes for SegWit and non SegWit addresses\n(this would keep the same standard as BIP44 and BIP49)\n    b. Create a new level on this proposed structure to divide SegWit\nand non SegWit addresses: we would suggest to add this new level between\ncosigner_index and change\n\nWe believe solution b. would be better as it would give the option of\nhaving a multisig wallet with non SegWit-aware cosigners without having\nto use two different subtrees.\n\nThis proposal is a work in progess so we would like to receive some\nfeedback before moving on with proposing it as a BIP draft.\n\nSimone Bronzini\n\n-----BEGIN PGP SIGNATURE-----\nComment: Using GnuPG with Thunderbird - http://www.enigmail.net/\n\niQIzBAEBCAAdFiEErS/wgXh5+C1vqPN/TXSJoN+7oQoFAlmlP2QACgkQTXSJoN+7\noQptgA/7B46/Why5h5/cxWyvgjmuUJ12Rkvh+EtfOUhMX+a8i4PJkLHGB2RibRfR\n/Li1F+QWd2yeqdNO97er8HDGSlouxB7twB0ZMnS/LRPsHTA3Zf4OoD7H/yjj3lcD\nGiJGy4MiHEOfjqaIwd0onUPX9ch5+Mm7aL34vBDdK0/8gm2v+HGO+GAefaUnZTQh\n/CIaM0Th9dDS0xs5wcP3ncNqs1e59MHXOWlh7+zAxfvFio+HHnCbULIe4uct6stC\nQxTNh8naQD4cB7tV9wsEeyuuJQ1gG8/pgN3WgRu5gW9CGpmpsySJgCCftkTZZHeL\neoqGJy5XFbI4CN2wEC2pbWW0xtDNyFq71wUPYNXINn8/7rnSjSl06OKISEk0u1yL\nvhFuR9RSxEge2cS1pDwIwHVNR6pCeZMRwo0tp1OEXnt5VGGpmKengtpcFkFlOVdd\navUueIe8OoFGODco4+f25foB/z/rzyg3REXYX36bZiS6UkUOx4TCGpAzY86i4fDJ\nSTeDy5KMLk1S9rvTNrygxR74DkFMiNkalF3g4VauUlCFmh8iOzEDdtOQ3mLu/pgq\nMXxfxq6ABxeCmQ7LsuBcFc+wN6AVLhrOhIPGyI8EAyaZNIGByqdgZGubvOl0J/gt\nYr4z5fViI7hjJijvooKzFtX0MNnaLBCOlggLpQO58t8En+BiNDE=\n=XgcB\n-----END PGP SIGNATURE-----\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0xB2E60C73.asc\nType: application/pgp-keys\nSize: 15541 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170829/3be6b307/attachment-0001.bin>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0xB2E60C73.asc.sig\nType: application/pgp-signature\nSize: 566 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170829/3be6b307/attachment-0001.sig>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2017-08-29T20:07:43",
                "message_text_only": "> Status: Proposed\n\nThis should only be set after peer review and implementations are complete, \nand you intend that there will be no further changes.\n\n> As registered coin types we propose the ones already used for BIP44, which \ncan be found at the following page.\n\nI suggest just referring to SLIP 44 directly.\n\nYou're missing the Backward Compatibility and Copyright sections.\n\n\n\nOn Tuesday 29 August 2017 10:19:10 AM Simone Bronzini via bitcoin-dev wrote:\n> Hi all,\n> last month we started looking for feedback (here and on other channels)\n> about a proposal for a new structure to facilitate the management of\n> different multisig accounts under the same master key, avoiding key\n> reuse but still allowing cosigners to independently generate new\n> addresses. While previously multiaccount multisig wallets were little\n> used, now that LN is becoming a reality it is extremely important to\n> have a better multiaccount management method to handle multiple payment\n> channels.\n> Please have a look at the draft of the BIP at the link below:\n> \n> https://github.com/chainside/BIP-proposal/blob/master/BIP.mediawiki\n> \n> Any feedback is highly appreciated, but in particular we would like to\n> collect opinions about the following issues:\n> \n> 1. coin_type level:\n> this level is intended to allow users to manage multiple\n> cryptocurrencies or forks of Bitcoin using the same masterkey (similarly\n> to BIP44). We have already received some legit objections that, since we\n> are talking about a Bitcoin Improvement Proposal,  it shouldn't care\n> about alt-coins. While we can agree with such objections, we also\n> believe that having a coin_type level improves interoperability with\n> muti-currency wallets (which is good), without any major drawback.\n> Moreover, even a Bitcoin maximalist may hold multiple coins for whatever\n> reason (short term speculation, testing, etc).\n> \n> 2. SegWit addresses:\n> since mixing SegWit and non-SegWit addresses on the same BIP44 structure\n> could lead to UTXOs not being completely recognised by old wallets,\n> BIP49 was proposed to separate the key space. Since this is a new\n> proposal, we can assume that wallets implementing it would be\n> SegWit-compatible and so there should be no need to differetiate between\n> SegWit and non-SegWit pubkeys. Anyway, if someone believes this problem\n> still holds, we thought about two possible solutions:\n>     a. Create separate purposes for SegWit and non SegWit addresses\n> (this would keep the same standard as BIP44 and BIP49)\n>     b. Create a new level on this proposed structure to divide SegWit\n> and non SegWit addresses: we would suggest to add this new level between\n> cosigner_index and change\n> \n> We believe solution b. would be better as it would give the option of\n> having a multisig wallet with non SegWit-aware cosigners without having\n> to use two different subtrees.\n> \n> This proposal is a work in progess so we would like to receive some\n> feedback before moving on with proposing it as a BIP draft.\n> \n> Simone Bronzini"
            },
            {
                "author": "Simone Bronzini",
                "date": "2017-08-30T12:22:30",
                "message_text_only": "Thanks for your feedback, I fixed what you suggested. As for the purpose\nhow should we move on? We would be inclined to use 46, but of course we\nare open to any other number.\n\n\nOn 29/08/17 22:07, Luke Dashjr via bitcoin-dev wrote:\n>> Status: Proposed\n> This should only be set after peer review and implementations are complete, \n> and you intend that there will be no further changes.\n>\n>> As registered coin types we propose the ones already used for BIP44, which \n> can be found at the following page.\n>\n> I suggest just referring to SLIP 44 directly.\n>\n> You're missing the Backward Compatibility and Copyright sections.\n>\n>\n>\n> On Tuesday 29 August 2017 10:19:10 AM Simone Bronzini via bitcoin-dev wrote:\n>> Hi all,\n>> last month we started looking for feedback (here and on other channels)\n>> about a proposal for a new structure to facilitate the management of\n>> different multisig accounts under the same master key, avoiding key\n>> reuse but still allowing cosigners to independently generate new\n>> addresses. While previously multiaccount multisig wallets were little\n>> used, now that LN is becoming a reality it is extremely important to\n>> have a better multiaccount management method to handle multiple payment\n>> channels.\n>> Please have a look at the draft of the BIP at the link below:\n>>\n>> https://github.com/chainside/BIP-proposal/blob/master/BIP.mediawiki\n>>\n>> Any feedback is highly appreciated, but in particular we would like to\n>> collect opinions about the following issues:\n>>\n>> 1. coin_type level:\n>> this level is intended to allow users to manage multiple\n>> cryptocurrencies or forks of Bitcoin using the same masterkey (similarly\n>> to BIP44). We have already received some legit objections that, since we\n>> are talking about a Bitcoin Improvement Proposal,  it shouldn't care\n>> about alt-coins. While we can agree with such objections, we also\n>> believe that having a coin_type level improves interoperability with\n>> muti-currency wallets (which is good), without any major drawback.\n>> Moreover, even a Bitcoin maximalist may hold multiple coins for whatever\n>> reason (short term speculation, testing, etc).\n>>\n>> 2. SegWit addresses:\n>> since mixing SegWit and non-SegWit addresses on the same BIP44 structure\n>> could lead to UTXOs not being completely recognised by old wallets,\n>> BIP49 was proposed to separate the key space. Since this is a new\n>> proposal, we can assume that wallets implementing it would be\n>> SegWit-compatible and so there should be no need to differetiate between\n>> SegWit and non-SegWit pubkeys. Anyway, if someone believes this problem\n>> still holds, we thought about two possible solutions:\n>>     a. Create separate purposes for SegWit and non SegWit addresses\n>> (this would keep the same standard as BIP44 and BIP49)\n>>     b. Create a new level on this proposed structure to divide SegWit\n>> and non SegWit addresses: we would suggest to add this new level between\n>> cosigner_index and change\n>>\n>> We believe solution b. would be better as it would give the option of\n>> having a multisig wallet with non SegWit-aware cosigners without having\n>> to use two different subtrees.\n>>\n>> This proposal is a work in progess so we would like to receive some\n>> feedback before moving on with proposing it as a BIP draft.\n>>\n>> Simone Bronzini\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0xB2E60C73.asc\nType: application/pgp-keys\nSize: 15541 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170830/8b886086/attachment-0001.bin>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 898 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170830/8b886086/attachment-0001.sig>"
            },
            {
                "author": "Thomas Voegtlin",
                "date": "2017-08-30T10:07:24",
                "message_text_only": "On 29.08.2017 12:19, Simone Bronzini via bitcoin-dev wrote:\n\n> 2. SegWit addresses:\n> since mixing SegWit and non-SegWit addresses on the same BIP44 structure\n> could lead to UTXOs not being completely recognised by old wallets,\n> BIP49 was proposed to separate the key space. \n\nThis will lead to old UTXOs not being recognized by NEW wallets, because\nat some point new wallets will not care about implementing old standards.\n\nThe only way to address this is to get out of bip39 and bip43, and to\ninclude a version number in the mnemonic seed."
            },
            {
                "author": "Simone Bronzini",
                "date": "2017-08-30T12:48:24",
                "message_text_only": "> This will lead to old UTXOs not being recognized by NEW wallets, because\n> at some point new wallets will not care about implementing old standards.\n\nYour observations make perfect sense. That's exactly why we endorse\noption b. in my previous email.\n\n> The only way to address this is to get out of bip39 and bip43, and to\n> include a version number in the mnemonic seed.\n\nAs for the idea of having a versioning on mnemonic seeds, I believe it\nwould be a very useful feature indeed. How about opening a new,\nseparate, topic about it?\n\n\nOn 30/08/17 12:07, Thomas Voegtlin via bitcoin-dev wrote:\n>\n> On 29.08.2017 12:19, Simone Bronzini via bitcoin-dev wrote:\n>\n>> 2. SegWit addresses:\n>> since mixing SegWit and non-SegWit addresses on the same BIP44 structure\n>> could lead to UTXOs not being completely recognised by old wallets,\n>> BIP49 was proposed to separate the key space. \n> This will lead to old UTXOs not being recognized by NEW wallets, because\n> at some point new wallets will not care about implementing old standards.\n>\n> The only way to address this is to get out of bip39 and bip43, and to\n> include a version number in the mnemonic seed.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0xB2E60C73.asc\nType: application/pgp-keys\nSize: 15541 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170830/91b5db27/attachment.bin>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 898 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170830/91b5db27/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "BIP proposal for Lightning-oriented multiaccount multisig HD wallets",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Simone Bronzini",
                "Luke Dashjr",
                "Thomas Voegtlin"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 13512
        }
    },
    {
        "title": "[bitcoin-dev] ZeroLink Fungibility Framework -- Request for Discussion",
        "thread_messages": [
            {
                "author": "Adam Ficsor",
                "date": "2017-08-30T06:45:31",
                "message_text_only": "I've been long working on Bitcoin privacy, mainly on TumbleBit\n<https://github.com/NTumbleBit/NTumbleBit>, HiddenWallet\n<https://github.com/nopara73/HiddenWallet/> and BreezeWallet\n<https://github.com/stratisproject/Breeze/>. ZeroLink is my latest\neffort to gather all the privacy reasearch I'm familiar with,\ncombine/organize them in a coherent and practical way. The main point\nof ZeroLink is that \"nothing is out of its scope\", it is intended to\nprovide complete anonymity on-chain.\nAmongst its many topics, ZeroLink defines mixing technique, coin\nselection, private transaction and balance retrieval, transaction\ninput and output indexing and broadcasting and even includes UX\nrecommendations.\nUsers' privacy should not be breached neither on blockchain level, nor\non network level.\n\nProposal:https://github.com/nopara73/ZeroLink/\n\nIn a nutshell ZeroLink defines a pre-mix wallet, which can be\nincorporated to any Bitcoin wallet without much implementation\noverhead. Post-mix wallets on the other hand have strong privacy\nrequirements, so the mixed out coins will not lose their uniformity.\nThe requirements and recommendations for pre and post-mix wallets\ntogether define the Wallet Privacy Framework.\nCoins from pre-mix wallets to post-mix wallets are moved by mixing.\nMost on-chain mixing techniques, like CoinShuffle, CoinShuffle++ or\nTumbleBit's Classic Tumbler mode can be used. However ZeroLink defines\nits own mixing technique: Chaumian CoinJoin, which is based on Gregory\nMaxwell's 2013 CoinJoin recommendations and ideas\n<https://bitcointalk.org/index.php?topic=279249.0>. I found this\ntechnique to be the most performant, fastest and cheapest one.\n\nRegarding adoption SamouraiWallet <https://github.com/Samourai-Wallet>\nand HiddenWallet <https://github.com/nopara73/HiddenWallet> are going\nto implement and comply with ZeroLink and BreezeWallet\n<https://github.com/stratisproject/Breeze> also shows significant\ninterest.\n\nRegards,\nnopara73\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170830/7706a7dc/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "ZeroLink Fungibility Framework -- Request for Discussion",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Adam Ficsor"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2142
        }
    },
    {
        "title": "[bitcoin-dev] BIP49 Derivation scheme changes",
        "thread_messages": [
            {
                "author": "shiva sitamraju",
                "date": "2017-08-30T07:24:13",
                "message_text_only": "Hi,\n\nI wanted to discuss few changes in BIP49\n\n*- Breaking backwards compatibility *\nThe BIP talks about breaking this, and  but it really doesn't.  I really\nfeel it should completely break this. Here is why\n\nWhat would happen if you recover a wallet  using seed words ?\n  1. Since there is no difference in seed words between segwit/non segwit,\nthe wallet would discover both m/44' and m/49' accounts\n  2. Note that we cannot ask the user to choose an account he wants to\noperate on (Segwit/Non segwit). This is like asking him the HD derivation\npath and a really bad UI\n  3. The wallet now has to constantly monitor both m/44' and m/49' accounts\nfor transactions\n\nBasically we are always stuck with keeping compatibility with older seed\nwords or always asking the user if the seed words came from segwit/non\nsegwit wallet !\n\nHere is my suggestion :\n1. By default all new wallets will be created as segwit  m/49' without\nasking user anything. I think you would agree with me that in future we\nwant most wallet to be default segwit (unless user chooses a non segwit\nfrom advanced options)!\n\n2. Segwit wallet seed words have a different format which is incompatible\nwith previous wallet seed words. This  encodes the information that this\nwallet is segwit in the seed words itself. We need to define a structure\nfor this\n\n\n\n*- XPUB Derivation*\nThis is something not addressed in the BIP yet.\n\n1. Right now you can get an xpub balance/transaction history. With m/49'\nthere is no way to know whether an xpub is from m/44' or m/49'\n\n2. This breaks lots of things. Wallets like electrum/armory/mycelium\n<https://blog.trezor.io/using-mycelium-to-watch-your-trezor-accounts-a836dce0b954>support\nimporting  xpub as a watch only wallet. Also services like blockonomics/\nblockchain.info use xpub for displaying balance/generating merchant\naddresses\n\nLooking forward to hearing your thoughts\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170830/c71c3bec/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP49 Derivation scheme changes",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "shiva sitamraju"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2063
        }
    },
    {
        "title": "[bitcoin-dev] Payment Channel Payouts: An Idea for Improving P2Pool Scalability",
        "thread_messages": [
            {
                "author": "Chris Belcher",
                "date": "2017-08-30T16:15:56",
                "message_text_only": "Pooled mining in bitcoin contributes to miner centralization. P2Pool is\none solution but has bad scalability; additional hashers require the\ncoinbase transaction to be larger, bigger miners joining increase the\nvariance of payouts for everyone else, and smaller miners must pay extra\nto consolidate dust payouts. In this email I propose an improved scheme\nusing payment channels which would allow far more individual hashers to\nmine on p2pool and result in a much lower payout variance.\n\n\n== Intro ==\n\nP2Pool is a decentralized pool that works by creating a P2P network of\nhashers. These hashers work on a chain of shares similar to Bitcoin's\nblockchain. Each hasher works on a block that includes payouts to the\nprevious shares' owners and the node itself. The point of pooling is to\nreduce the variance of payout, even though on average the reward is the\nsame (or less with fees). The demand for insurance, and the liquid\nmarkets for options show that variance does have costs that people are\nwilling to pay to avoid.\n\nHere is an example of a p2pool coinbase transaction:\nhttps://blockchain.info/tx/d1a1e125ed332483b6e8e2f128581efc397582fe4c950dc48fadbc0ea4008022\n\nIt is 5803 bytes in size, which at a fee rate of 350 sat/b is worth\n0.02031050 btc of block space that p2pool cannot sell to any other\ntransaction. As bitcoin inflation goes down and miners are funded more\nby fees, this puts p2pool at more and more of a disadvantage compared to\ntrusted-third-party mining pools.\n\nAs each hasher is paid to their own bitcoin address, this limits the\nnumber of hashers taking part as adding more individual people to the\npayout transaction increases its size. Also small payouts cost a\ndisproportionate amount in miner fees to actually spend, which hurts\nsmall miners who are essential to a decentralized mining ecosystem.\n\nThis could maybe be solved by keeping a separate balance state for each\nuser that is independent from the payouts, and make payouts only when\nthat balance state exceeds some reasonable threshold. But this increases\nthe variance which goes against the aim of pooled mining.\n\n\n== Payment Channels ==\n\nWhat's needed is a way to use off-chain payments where any number of\npayments can be sent to each individual hasher without using the\nblockchain. Then the N of the pay-per-last-N-shares (PPLNS) of p2pool\ncan be increased to something like 6-12 months of shares and so as long\nas a small miner can mine a share every few months they will always get\na payout when p2pool finds a block. The payment channels would be in a\nhub-and-spokes system and would work in a similar way to coinswap,\nlightning network, atomic cross-chain swaps or any other contract\ninvolving hashlocks and timelocks.\n\nThere would still be a sharechain but with hashers paying the entire\nblock reward to a hub. This hub would have a one-way payment channel\nopen to every hasher in p2pool and there would be created a situation\nwhere if the hub gets paid then the hashers cannot fail to get paid.\nBecause cheating is impossible, the hub and hashers will agree to just\nrelease the money to each other without resorting to the blockchain.\n\nThe coinbase address scriptPubKey would be this, block rewards are paid\nto here:\n\n     2of2 multisig\n     hub + successful hasher\n  OR\n     hub pubkey + H(X)\n  OR\n     successful hasher pubkey + OP_CSV 6 months\n\nA 2of2 multisig between the hub and the \"successful\" hasher which found\nthe block, although with a hashlock and timelock. H(X) is a hash value,\nwhere the preimage X is generated randomly by the hub and kept secret,\nbut X will be revealed if the hub spends via that execution path. The\nOP_CSV execution path is there to stop any holdups or ransom, in the\nworst case if the hub stalls then the successful hasher can steal the\nentire coinbase as punishment after 6 months.\n\nEach payment channel address has this scriptPubKey:\n\n     2of2 multisig\n     hub-C + hasher-C\n  OR\n     2of2 multisig + H(X)\n     hub-U + hasher-U\n\nThe pubkeys hub-C/hasher-C refer to 'cooperative' pubkeys.\nHub-U/hasher-U refer to 'uncooperative' pubkeys. Before a hasher starts\nmining the hub will open a one-way payment channel to the hasher, and\npays some bitcoin to it (let's say 0.5btc for example).\n\nThe hashers mine a sharechain, a solved share contains the hasher's\ncooperative and uncooperative pubkey. The hub keeps up with the\nsharechain and announces partially-signed transactions going to each\nhasher. The transactions are updated states of the payment channel, they\npay money to each hasher in proportion to the work that the hasher\ncontributed to the sharechain. The transaction contains a signature\nmatching the hub-U pubkey, the hasher could sign it with their hasher-U\nkey and broadcast except they still need the value of X.\n\nIf a hasher is successful and finds a share that is also a valid bitcoin\nblock, they broadcast it to the network.\n\nNow, the hub can spend the block reward money on its own but only by\nrevealing X. Each hasher could then take that X and combine it with the\npartially-signed transaction and broadcast that to get their money. So\nif the hub gets paid then the hashers cannot fail to get paid. Since\ndefecting is pointless, the hub signs the hub-C signature of the\npartially-signed transaction and sends it to each hasher, then the\nsuccessful hasher signs the 2of2 multisig sending the block reward money\nto the hub. The successful hasher gets a small bonus via an updated\npayment channel state for finding the block, to discourage withholding\nsame as today's p2pool.\n\nThese payment channels can be kept open indefinitely, as new blocks are\nfound by p2pool the hub creates new partially-signed transactions with\nmore money going to each hasher. When the hasher wants to stop mining\nand get the money, they can add their own hasher-C signature and\nbroadcast it to the network.\n\nIf there's ever a problem and the hub has to reveal X, then all the\npayment channels to hashers will have to be closed and reopened with a\nnew X, because their security depends on X being unknown.\n\n\n== Hubs ==\n\nThe hub is a central point of failure. It cannot steal the money, but if\nit gets DDOS'd or just becomes evil then the whole thing would stop\nworking. This problem could be mitigated by having a federated system,\nwhere there are several hubs to choose from and hashers have payment\nchannels open with each of them. It's worth noting that if someone has a\nstrong botnet they could probably DDOS individual p2pool hashers in the\nsame way they DDOS hubs or even centralized mining pools.\n\nThe hub would need to own many bitcoins in order to have payment\nchannels while waiting for blocks to be mined. Maybe 50 times the block\nreward which today would be about 650 bitcoins. The hub should receive a\nsmall percentage of each block reward to provide them with an incentive,\nwe know from JoinMarket that this percentage will probably be around\n0.1% or less for large amounts of bitcoin. Prospostive hub operators\nshould write their bids on a forum somewhere and have their details\nadded to some list on github. Hashers should have an interface for\nblacklisting, whitelisting, lowering and raising priority for certain\nhubs in case the hub operators behave badly.\n\nAs well as the smart contract, there are iterated prisoner's dilemma\neffects between the hub and the hashers. If the hub cooperates it can\nexpect to make a predictable low-risk income from its held bitcoins for\na long time to come, if it does something bad then the hashers can\neasily call off the deal. The hub operator will require a lot of profit\nin order to burn its reputation and future income stream, and by\ndamaging the bitcoin ecosystem it will have indirectly damaged its own\nheld bitcoins. A fair pricing plan will probably have the hub taking a\nsmall percent to start with and then 12 months later that percentage\ngoes up to take into account the hub's improved reputation.\n\n\n== Transaction Selection ==\n\nAll the hashers and hub need to know the exact value of the block reward\nin advance, this means they must know what the miner fees will be. This\nis probably the most serious problem with this proposal.\n\nOne possible way to solve this is to mine transactions into shares and\nso use the sharechain to make all the hashers and hubs come to consensus\nabout exactly which transactions they will mine, and so exactly what the\ntotal miner fee will be. A problem here is that this consensus mechanism\nis slow, immediately after a bitcoin block is found all the p2pool\nhashers will have to wait 30-120 seconds before they know what\ntransactions to mine, so this would make them uncompetitive as a mining\noperation.\n\nAnother way to deal with this is to have the hub just choose all the\ntransactions, announcing the transactions, total miner fee and merkle\nroot for the hashers to mine. This would work but allows the hub to\ncontrol and censor bitcoin transactions, which mostly defeats the point\nof p2pool as an improvement to bitcoin miner centralization.\n\nAnother way is to have the hashers and hub estimate what the total miner\nfee value will be. The estimate could start from the median miner fee of\nthe last few blocks, or from the next 1MB of the mempool. The hub would\nannounce all the partially-signed transactions to every hasher, and then\nperiodically (say every 60 seconds) announce updated versions depending\non how the mempool changes. Let's analyze what happens if the estimated\nand actual rewards are different. If the actual block reward is lower\nthan the estimated reward, then the hub can update the payment channel\nstate to slightly lower values to take that into account when it\nannounces the cooperative hub-C signatures. The hashers can't use the\nhigher channel state without knowing X. The successful hasher will get\ntheir bonus for finding the block which should help in encouraging them\nto actually sign the hub's payout transaction. If the actual block\nreward is higher than the estimated reward, the hub would hopefully\nstill update the hasher's payment channel states because of the\ninterated-prisoners-dilemma effects. But if the actual reward is much\nhigher then the hub may find it profitable to burn its reputation and\ntake the money by revealing X, one situation where this might happen is\nif someone accidently pays a very high miner fee and a hasher mines it\nwithout it being taken into account in the hub's regular payment channel\nstate updates. Apart from that very specific situation, this scheme of\nestimating the total miner fee should work.\n\n\n== Some Notes ==\n\n*) Block rewards are locked for 100 blocks before they can be spent, so\nthe cooperative signatures should be exchanged after 100 blocks just in\ncase the block gets made stale/orphaned. While the hashers are waiting\nfor the 100 reward maturity period, they should mine with another hub as\nthe payout.\n\n*) Today's p2pool has a feature for donating to individual hashers, this\ncould be replicated in the payment channel system by having each share\nalso contain the hasher's bitcoin address for donations (or possibly\ntheir LN payment code)\n\n*) Each hasher should probably be made to pay some bitcoins into the\npayment channel address too, to stop DOSers locking up all the hub's\nbitcoins. If the hasher doesn't find a share within some timeout then\nthe hub should close the payment channel.\n\n*) Now that we have segwit all these payment channel schemes are much\neasier to code.\n\n*) The hashers must keep their money locked up in the payment channel\nfor months before enough collects. This could be a problem because some\nminers don't really want to hold bitcoin long term. I wonder if theres\nsome way to link up these channels to LN so they can sold straight away.\nThey could also use futures contracts to sell the coins today at a\ndiscount and actually deliver the coins later when they close the channel.\n\n\n== References ==\n\n*) https://en.bitcoin.it/wiki/P2Pool how p2pool works\n\n*) https://bitcointalk.org/index.php?topic=18313.msg13057899#msg13057899\nthe scaleability problems of p2pool\n\n*) https://bitcointalk.org/index.php?topic=18313.msg20943086#msg20943086\nmaking the PPLNS window longer\n\n*) book: The Evolution of Co-Operation by Robert Axelrod, for explaining\niterated prisoner's dilemma effects in detail\n\nThanks to the p2pool developer veqtrus for reviewing this"
            }
        ],
        "thread_summary": {
            "title": "Payment Channel Payouts: An Idea for Improving P2Pool Scalability",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Chris Belcher"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 12277
        }
    },
    {
        "title": "[bitcoin-dev] BIP103 to 30MB",
        "thread_messages": [
            {
                "author": "Erik Aronesty",
                "date": "2017-08-30T17:14:22",
                "message_text_only": "If you use this formula, with a decaying percentage, it takes about 100\nyears to get to 30MB, but never goes past that.\n\nSince it never passes 32, we don't have to worry about going past that\never... unless another hard fork is done.   A schedule like this could\nallow block size to scale with tech growth asymptotically.   Might be nice\nto include with other things\n\nP=17%, Pn = P*0.95 X = 1, Xn = X * (1+P)\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170830/cfa727df/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP103 to 30MB",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Erik Aronesty"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 591
        }
    }
]