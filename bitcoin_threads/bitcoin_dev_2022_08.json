[
    {
        "title": "[bitcoin-dev] Regarding setting a lower minrelaytxfee",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2022-08-01T10:30:07",
                "message_text_only": "On Sat, Jul 30, 2022 at 05:24:35PM +0000, alicexbt via bitcoin-dev wrote:\n> However, I think developers should not make any changes in the default minimum fee rate required for relay. If there are incentives for users and miners to change it, they should use non-default value. In case, miners want to experiment with lower fee rate and see if this increases revenue they could try using it on odd dates (even dates remain default) for a month. We all could analyze how this worked for different mining pools and non-default value (lower or higher) could become normal in the future.\n\nWithout a way for lower-fee-rate transactions to get to those miners,\nexperiments like that are pointless.\n\nIf you want to propose things like this, propose a way to get non-standard txs\nto miners, like a hashcash-based alternative broadcast scheme.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220801/1fa155de/attachment.sig>"
            },
            {
                "author": "aliashraf.btc At protonmail",
                "date": "2022-08-01T13:19:05",
                "message_text_only": "> On Sat, Jul 30, 2022 at 05:24:35PM +0000, alicexbt via bitcoin-dev wrote:\n> like a hashcash-based alternative broadcast scheme.\nHi Peter,\nI've been mulling the idea of attaching work to low fee txns, both as a compensation (e.g., in a sidechain, or an alt), and/or as a spam proof. Unfortunately, both suffer from ASICs:\nFor spam proof case, the adversary can easily buy a used/obsolete device to produce lots of spam txns very cheaply, unless you put the bar very high, making it almost impossible for average users to even try.\nThe compensation scenario is pretty off-topic, still, interesting enough for 1 min read:\nWallets commit to the latest blockchain state in the transaction AND attach work.\nIt is considered contribution to the security (illegitimate chains can't include the txn), hence isrewarded by fee discount/exemption depending on the offset of the state they've committed to (the closer, the better) and the amount of work attached.\nFor this to work, block difficulty is calculated inclusive with the work embedded in the txns, it contains. Sophisticated and consequential, yet not infeasible per se.\n\nUnfortunately, this scheme is hard to balance with ASICs in the scene too, for instance, you can't subsidize wallets for their work like with a leverge, because miners can easily do it locally, seizing the subsidies for themselves, long story, not relevant just ignore it.\n\nCheers, Ali\n\n------- Original Message -------\nOn Monday, August 1st, 2022 at 3:00 PM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n\n> On Sat, Jul 30, 2022 at 05:24:35PM +0000, alicexbt via bitcoin-dev wrote:\n>\n> > However, I think developers should not make any changes in the default minimum fee rate required for relay. If there are incentives for users and miners to change it, they should use non-default value. In case, miners want to experiment with lower fee rate and see if this increases revenue they could try using it on odd dates (even dates remain default) for a month. We all could analyze how this worked for different mining pools and non-default value (lower or higher) could become normal in the future.\n>\n>\n> Without a way for lower-fee-rate transactions to get to those miners,\n> experiments like that are pointless.\n>\n> If you want to propose things like this, propose a way to get non-standard txs\n> to miners, like a hashcash-based alternative broadcast scheme.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Peter Todd",
                "date": "2022-08-01T13:37:47",
                "message_text_only": "On Mon, Aug 01, 2022 at 01:19:05PM +0000, aliashraf.btc At protonmail wrote:\n> > On Sat, Jul 30, 2022 at 05:24:35PM +0000, alicexbt via bitcoin-dev wrote:\n> > like a hashcash-based alternative broadcast scheme.\n> Hi Peter,\n> I've been mulling the idea of attaching work to low fee txns, both as a compensation (e.g., in a sidechain, or an alt), and/or as a spam proof. Unfortunately, both suffer from ASICs:\n> For spam proof case, the adversary can easily buy a used/obsolete device to produce lots of spam txns very cheaply, unless you put the bar very high, making it almost impossible for average users to even try.\n> The compensation scenario is pretty off-topic, still, interesting enough for 1 min read:\n> Wallets commit to the latest blockchain state in the transaction AND attach work.\n> It is considered contribution to the security (illegitimate chains can't include the txn), hence isrewarded by fee discount/exemption depending on the offset of the state they've committed to (the closer, the better) and the amount of work attached.\n> For this to work, block difficulty is calculated inclusive with the work embedded in the txns, it contains. Sophisticated and consequential, yet not infeasible per se.\n> \n> Unfortunately, this scheme is hard to balance with ASICs in the scene too, for instance, you can't subsidize wallets for their work like with a leverge, because miners can easily do it locally, seizing the subsidies for themselves, long story, not relevant just ignore it.\n\nWe're not talking about a consensus system here. Just a way to rate-limit\naccess to a broadcast network used by a small minority of nodes. It's\ncompletely ok to simply change the PoW algorithm in the _highly_ unlikely event\nsomeone bothers to build an ASIC for it. Since this isn't a consensu system,\nit's totally ok if multiple versions of the scheme run in parallel.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220801/e69f3291/attachment.sig>"
            },
            {
                "author": "Aaradhya Chauhan",
                "date": "2022-08-03T15:40:34",
                "message_text_only": "So, can we conclude by something, whether or not it would be possible and\nfeasible in the future?\n\nOn Mon, 1 Aug 2022 at 19:08, Peter Todd via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Mon, Aug 01, 2022 at 01:19:05PM +0000, aliashraf.btc At protonmail\n> wrote:\n> > > On Sat, Jul 30, 2022 at 05:24:35PM +0000, alicexbt via bitcoin-dev\n> wrote:\n> > > like a hashcash-based alternative broadcast scheme.\n> > Hi Peter,\n> > I've been mulling the idea of attaching work to low fee txns, both as a\n> compensation (e.g., in a sidechain, or an alt), and/or as a spam proof.\n> Unfortunately, both suffer from ASICs:\n> > For spam proof case, the adversary can easily buy a used/obsolete device\n> to produce lots of spam txns very cheaply, unless you put the bar very\n> high, making it almost impossible for average users to even try.\n> > The compensation scenario is pretty off-topic, still, interesting enough\n> for 1 min read:\n> > Wallets commit to the latest blockchain state in the transaction AND\n> attach work.\n> > It is considered contribution to the security (illegitimate chains can't\n> include the txn), hence isrewarded by fee discount/exemption depending on\n> the offset of the state they've committed to (the closer, the better) and\n> the amount of work attached.\n> > For this to work, block difficulty is calculated inclusive with the work\n> embedded in the txns, it contains. Sophisticated and consequential, yet not\n> infeasible per se.\n> >\n> > Unfortunately, this scheme is hard to balance with ASICs in the scene\n> too, for instance, you can't subsidize wallets for their work like with a\n> leverge, because miners can easily do it locally, seizing the subsidies for\n> themselves, long story, not relevant just ignore it.\n>\n> We're not talking about a consensus system here. Just a way to rate-limit\n> access to a broadcast network used by a small minority of nodes. It's\n> completely ok to simply change the PoW algorithm in the _highly_ unlikely\n> event\n> someone bothers to build an ASIC for it. Since this isn't a consensu\n> system,\n> it's totally ok if multiple versions of the scheme run in parallel.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220803/72f0cd9f/attachment.html>"
            },
            {
                "author": "vjudeu at gazeta.pl",
                "date": "2022-08-03T17:07:08",
                "message_text_only": "It is possible, because you can find nodes that accept low-fee transactions. And on some statistics, for example https://jochen-hoenicke.de/queue/#BTC,24h,weight,0 you can see that zero to one satoshi per virtual byte transactions could take more space than other transactions. You can be convinced that those charts are not fake by running a full node and reaching some nodes with different fee settings. If miners don't want to accept them, well, it is their choice to leave that money on the table. As long as the basic block reward is sufficient, they don't have to accept such low fee transactions, because they can wait instead, to receive them in some batched form.\n\nAlso, some miners could accept only 10 sats/vB or higher, because why not. As long as your transaction will reach enough nodes to be confirmed, you can safely pick lower fees. For now, de-facto standard is one satoshi per virtual byte, but:\n\n1) it is only declared, so you can rely only on declarations, not on hard consensus rules\n2) there is no way to make sure if some transaction was truly rejected by some miner, or maybe it was saved somewhere\n3) you can never be sure if some node is a miner and can enforce those different fee rules or not\n\nSo, you can really judge only by how nodes behave, you cannot make sure in any way if anyone is running some additional rules. And fees are not a part of the consensus, so they can be freely adjusted by each node, and there is no way to make sure, what rules are really executed, you can only assume that, based on what transactions are included in blocks.\n\n\n\nOn 2022-08-03 18:19:12 user Aaradhya Chauhan via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\nSo, can we conclude by something, whether or not it would be possible and feasible in the future?\n\n\nOn Mon, 1 Aug 2022 at 19:08, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\nOn Mon, Aug 01, 2022 at 01:19:05PM +0000, aliashraf.btc At protonmail wrote:\n> > On Sat, Jul 30, 2022 at 05:24:35PM +0000, alicexbt via bitcoin-dev wrote:\n> > like a hashcash-based alternative broadcast scheme.\n> Hi Peter,\n> I've been mulling the idea of attaching work to low fee txns, both as a compensation (e.g., in a sidechain, or an alt), and/or as a spam proof. Unfortunately, both suffer from ASICs:\n> For spam proof case, the adversary can easily buy a used/obsolete device to produce lots of spam txns very cheaply, unless you put the bar very high, making it almost impossible for average users to even try.\n> The compensation scenario is pretty off-topic, still, interesting enough for 1 min read:\n> Wallets commit to the latest blockchain state in the transaction AND attach work.\n> It is considered contribution to the security (illegitimate chains can't include the txn), hence isrewarded by fee discount/exemption depending on the offset of the state they've committed to (the closer, the better) and the amount of work attached.\n> For this to work, block difficulty is calculated inclusive with the work embedded in the txns, it contains. Sophisticated and consequential, yet not infeasible per se.\n>\n> Unfortunately, this scheme is hard to balance with ASICs in the scene too, for instance, you can't subsidize wallets for their work like with a leverge, because miners can easily do it locally, seizing the subsidies for themselves, long story, not relevant just ignore it.\n\nWe're not talking about a consensus system here. Just a way to rate-limit\naccess to a broadcast network used by a small minority of nodes. It's\ncompletely ok to simply change the PoW algorithm in the _highly_ unlikely event\nsomeone bothers to build an ASIC for it. Since this isn't a consensu system,\nit's totally ok if multiple versions of the scheme run in parallel."
            },
            {
                "author": "Aaradhya Chauhan",
                "date": "2022-08-03T18:22:32",
                "message_text_only": "Thank you for answering. I'll check out the link you provided, while also\nplaying around with the fee settings for my own full node, at my home\nserver.\n\nOn Wed, 3 Aug 2022 at 23:02, vjudeu via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> It is possible, because you can find nodes that accept low-fee\n> transactions. And on some statistics, for example\n> https://jochen-hoenicke.de/queue/#BTC,24h,weight,0 you can see that zero\n> to one satoshi per virtual byte transactions could take more space than\n> other transactions. You can be convinced that those charts are not fake by\n> running a full node and reaching some nodes with different fee settings. If\n> miners don't want to accept them, well, it is their choice to leave that\n> money on the table. As long as the basic block reward is sufficient, they\n> don't have to accept such low fee transactions, because they can wait\n> instead, to receive them in some batched form.\n>\n> Also, some miners could accept only 10 sats/vB or higher, because why not.\n> As long as your transaction will reach enough nodes to be confirmed, you\n> can safely pick lower fees. For now, de-facto standard is one satoshi per\n> virtual byte, but:\n>\n> 1) it is only declared, so you can rely only on declarations, not on hard\n> consensus rules\n> 2) there is no way to make sure if some transaction was truly rejected by\n> some miner, or maybe it was saved somewhere\n> 3) you can never be sure if some node is a miner and can enforce those\n> different fee rules or not\n>\n> So, you can really judge only by how nodes behave, you cannot make sure in\n> any way if anyone is running some additional rules. And fees are not a part\n> of the consensus, so they can be freely adjusted by each node, and there is\n> no way to make sure, what rules are really executed, you can only assume\n> that, based on what transactions are included in blocks.\n>\n>\n>\n> On 2022-08-03 18:19:12 user Aaradhya Chauhan via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> So, can we conclude by something, whether or not it would be possible and\n> feasible in the future?\n>\n>\n> On Mon, 1 Aug 2022 at 19:08, Peter Todd via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> On Mon, Aug 01, 2022 at 01:19:05PM +0000, aliashraf.btc At protonmail\n> wrote:\n> > > On Sat, Jul 30, 2022 at 05:24:35PM +0000, alicexbt via bitcoin-dev\n> wrote:\n> > > like a hashcash-based alternative broadcast scheme.\n> > Hi Peter,\n> > I've been mulling the idea of attaching work to low fee txns, both as a\n> compensation (e.g., in a sidechain, or an alt), and/or as a spam proof.\n> Unfortunately, both suffer from ASICs:\n> > For spam proof case, the adversary can easily buy a used/obsolete device\n> to produce lots of spam txns very cheaply, unless you put the bar very\n> high, making it almost impossible for average users to even try.\n> > The compensation scenario is pretty off-topic, still, interesting enough\n> for 1 min read:\n> > Wallets commit to the latest blockchain state in the transaction AND\n> attach work.\n> > It is considered contribution to the security (illegitimate chains can't\n> include the txn), hence isrewarded by fee discount/exemption depending on\n> the offset of the state they've committed to (the closer, the better) and\n> the amount of work attached.\n> > For this to work, block difficulty is calculated inclusive with the work\n> embedded in the txns, it contains. Sophisticated and consequential, yet not\n> infeasible per se.\n> >\n> > Unfortunately, this scheme is hard to balance with ASICs in the scene\n> too, for instance, you can't subsidize wallets for their work like with a\n> leverge, because miners can easily do it locally, seizing the subsidies for\n> themselves, long story, not relevant just ignore it.\n>\n> We're not talking about a consensus system here. Just a way to rate-limit\n> access to a broadcast network used by a small minority of nodes. It's\n> completely ok to simply change the PoW algorithm in the _highly_ unlikely\n> event\n> someone bothers to build an ASIC for it. Since this isn't a consensu\n> system,\n> it's totally ok if multiple versions of the scheme run in parallel.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220803/a9af4854/attachment.html>"
            },
            {
                "author": "Billy Tetrud",
                "date": "2022-08-04T01:21:51",
                "message_text_only": "I agree with Peter, it seems like we don't need a dust limit with full\nblocks. And we should expect blocks to remain full indefinitely.\n\nHowever, if we were to still have a dust limit, it shouldn't be a simple\nconstant. It should be determined by the mempool environment. Eg one could\ndefine the dust limit to be the 5th percentile lowest fee in the last 100\nblocks. Or the 1st percentile. Etc. This way, as the value of bitcoin\nfluctuates (inevitably affecting the fees people are willing to pay), the\ndust limit would automatically adjust to compensate. One might worry that\nin high fee environments, the dust limit calculated this way might make for\ntoo-high dust limits. But I don't think you could really say it would be\n\"too high\" because it would match the actual mempool. We could have a\nmaximum dust limit set if that's a worry tho.\n\nOn Wed, Aug 3, 2022 at 5:35 PM Aaradhya Chauhan via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Thank you for answering. I'll check out the link you provided, while also\n> playing around with the fee settings for my own full node, at my home\n> server.\n>\n> On Wed, 3 Aug 2022 at 23:02, vjudeu via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> It is possible, because you can find nodes that accept low-fee\n>> transactions. And on some statistics, for example\n>> https://jochen-hoenicke.de/queue/#BTC,24h,weight,0 you can see that zero\n>> to one satoshi per virtual byte transactions could take more space than\n>> other transactions. You can be convinced that those charts are not fake by\n>> running a full node and reaching some nodes with different fee settings. If\n>> miners don't want to accept them, well, it is their choice to leave that\n>> money on the table. As long as the basic block reward is sufficient, they\n>> don't have to accept such low fee transactions, because they can wait\n>> instead, to receive them in some batched form.\n>>\n>> Also, some miners could accept only 10 sats/vB or higher, because why\n>> not. As long as your transaction will reach enough nodes to be confirmed,\n>> you can safely pick lower fees. For now, de-facto standard is one satoshi\n>> per virtual byte, but:\n>>\n>> 1) it is only declared, so you can rely only on declarations, not on hard\n>> consensus rules\n>> 2) there is no way to make sure if some transaction was truly rejected by\n>> some miner, or maybe it was saved somewhere\n>> 3) you can never be sure if some node is a miner and can enforce those\n>> different fee rules or not\n>>\n>> So, you can really judge only by how nodes behave, you cannot make sure\n>> in any way if anyone is running some additional rules. And fees are not a\n>> part of the consensus, so they can be freely adjusted by each node, and\n>> there is no way to make sure, what rules are really executed, you can only\n>> assume that, based on what transactions are included in blocks.\n>>\n>>\n>>\n>> On 2022-08-03 18:19:12 user Aaradhya Chauhan via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> So, can we conclude by something, whether or not it would be possible and\n>> feasible in the future?\n>>\n>>\n>> On Mon, 1 Aug 2022 at 19:08, Peter Todd via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> On Mon, Aug 01, 2022 at 01:19:05PM +0000, aliashraf.btc At protonmail\n>> wrote:\n>> > > On Sat, Jul 30, 2022 at 05:24:35PM +0000, alicexbt via bitcoin-dev\n>> wrote:\n>> > > like a hashcash-based alternative broadcast scheme.\n>> > Hi Peter,\n>> > I've been mulling the idea of attaching work to low fee txns, both as a\n>> compensation (e.g., in a sidechain, or an alt), and/or as a spam proof.\n>> Unfortunately, both suffer from ASICs:\n>> > For spam proof case, the adversary can easily buy a used/obsolete\n>> device to produce lots of spam txns very cheaply, unless you put the bar\n>> very high, making it almost impossible for average users to even try.\n>> > The compensation scenario is pretty off-topic, still, interesting\n>> enough for 1 min read:\n>> > Wallets commit to the latest blockchain state in the transaction AND\n>> attach work.\n>> > It is considered contribution to the security (illegitimate chains\n>> can't include the txn), hence isrewarded by fee discount/exemption\n>> depending on the offset of the state they've committed to (the closer, the\n>> better) and the amount of work attached.\n>> > For this to work, block difficulty is calculated inclusive with the\n>> work embedded in the txns, it contains. Sophisticated and consequential,\n>> yet not infeasible per se.\n>> >\n>> > Unfortunately, this scheme is hard to balance with ASICs in the scene\n>> too, for instance, you can't subsidize wallets for their work like with a\n>> leverge, because miners can easily do it locally, seizing the subsidies for\n>> themselves, long story, not relevant just ignore it.\n>>\n>> We're not talking about a consensus system here. Just a way to rate-limit\n>> access to a broadcast network used by a small minority of nodes. It's\n>> completely ok to simply change the PoW algorithm in the _highly_ unlikely\n>> event\n>> someone bothers to build an ASIC for it. Since this isn't a consensu\n>> system,\n>> it's totally ok if multiple versions of the scheme run in parallel.\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220803/8badd1b8/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Regarding setting a lower minrelaytxfee",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Peter Todd",
                "vjudeu at gazeta.pl",
                "aliashraf.btc At protonmail",
                "Billy Tetrud",
                "Aaradhya Chauhan"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 22650
        }
    },
    {
        "title": "[bitcoin-dev] New BIP: Private Payments",
        "thread_messages": [
            {
                "author": "Alfred Hodler",
                "date": "2022-08-01T11:38:29",
                "message_text_only": "Hi Ruben,\n\nI have incorporated your feedback. Using only the first four bytes of the notification code is a very valuable suggestion, so thank you for that. I have added you as a co-author.\n\nIn regards to hiding the recipient in the notification, the purpose is not only to allow Alice to send a notification herself, but also to break the link between the notifier (be that Alice or a third-party service) and Bob. Not doing so would reintroduce the same problem we have with BIP47 and unique per-recipient notification addresses -- namely that of social graph building. The tradeoff, as you noticed, is that light clients have to rely on some kind of OP_RETURN indexing service. I personally consider any inconvenience (to developers, as end users never see this) stemming from that to be acceptable because:\n\n1) it reduces the amount of social metadata on the blockchain\n2) notification services might otherwise be pressured into censoring certain recipients\n3) it allows wallets to decide the level of outsourcing they are comfortable with\n4) adversaries monitoring notifications might see a lot of notifications to someone and use that information to mount an attack\n\nThanks for all the feedback.\n\nAlfred"
            }
        ],
        "thread_summary": {
            "title": "New BIP: Private Payments",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Alfred Hodler"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1209
        }
    },
    {
        "title": "[bitcoin-dev] On a new community process to specify covenants",
        "thread_messages": [
            {
                "author": "Billy Tetrud",
                "date": "2022-08-03T15:37:05",
                "message_text_only": "@Antoine\nI very much like your proposal of an open decentralized process for\ninvestigating the problem and solution spaces. IRC sounds like a reasonable\nplace for this kind of thing to happen. I also agree with Ryan Grant's\ncomment about in-person cut-through (ie cut through the BS and resolve\nmisunderstandings). Perhaps every 3 IRC meetings or so, an in-person meetup\ncan be organized in various locations to facilitate that kind of cut\nthrough.\n\nI would imagine the phases the group could go through is:\n1. Define the phases (these phases). This list of 6 phases could be a\nstarting point, but its probably best to open the floor to whether this\nfeels like a reasonable approach and if more phases are needed or if some\naren't.\n2. Define and prioritize the motivations (ie the various features and\nfunctionality we want out of covenants, like the ones you listed). By\nprioritize, I mostly mean figure out which motivations are most motivating\nto people and rate them by strength of motivation (rather than a ranked\nlist).\n3. Define and prioritize the relevant constraints. These are things to\navoid in any covenant implementation. Constraints that have been brought up\nin the past are things like preventing the possibility of infinite covenant\nrecursion, full enumeration, preventing dynamic state, etc. By prioritize\nhere, it might be useful to categorize them into categories like \"no\ntolerance\", \"some tolerance\", \"no reservations\". Eg it might turn out most\npeople don't have any tolerance for infinite recursion, but don't mind\nnon-full enumeration.\n4. Other criteria? These are other criteria we might want to evaluate\nproposals according to. And some kind of way to prioritize them / evaluate\nthem against each other as trade offs.\n5. Evaluate the proposals based on motivations, constraints, and other\ncriteria. This phase shouldn't involve comparing them to each other.\n6. Produce a set of conclusions/opinions on which proposals are worth\npursuing further. This would be the phase where proposals are compared.\n\nEach phase would probably span over more than one meeting. I imagine each\nphase basically consisting of discussing each individual nominated item (ie\nmotivations, constraints, other criteria, or proposals) sequentially. The\nconsensus reached at the end of each phase would be considered of course a\ngroup consensus of those who participated, not a global consensus, not a\n\"bitcoin community consensus\". After each phase, the results of that phase\nwould be published more widely to get broader community feedback. These\nresults would include what the major opinions are, what level of consensus\neach major opinion has, what the reasons/justifications behind each opinion\nare, and various detailed opinions from individuals. It would be especially\ngreat to have detailed evaluations of each proposal published by various\npeople so anyone can go back and understand their thought process (as\nopposed to a list of names attached to basically a thumbs up or thumbs\ndown). Think like a supreme court decision kind of thing.\n\nThe process doesn't need to be complete after phase 6. Any previous phase\ncould be revisited, but after a phase is revisited, the phases after it\nshould probably be also revisited in order - or at least until its decided\na previous phase needs to be revisited again. Each iteration would solidify\nconsensus more about each phase. I would imagine the group might loop\nthrough phases 2, 3, and 4 a couple times (since constraints might conflict\nwith motivating features). It might be likely that in phase 5 while\nevaluating proposals, people realize that there are additional criteria\nthat should be added and can propose going back to step 4 to do that.\nHopefully we would get to the point where the motivations and constraints\nand relatively solid consensuses and iterations can loop through phases 5\nand 6 until the set of proposals the group thinks is worth pursuing  is\nnarrowed down (ideally to 1 or 2).\n\n\n\n\n\n\nOn Tue, Jul 26, 2022 at 11:47 AM Bram Cohen via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Mon, Jul 25, 2022 at 8:21 PM Antoine Riard <antoine.riard at gmail.com>\n> wrote:\n>\n>> What would be the canonical definition and examples of capabilities in\n>> the Bitcoin context ?\n>>\n>\n> Payments into vaults which can only be accepted by that vault and are\n> guaranteed to be subject to the vault's restrictions (the vault has a\n> capability)\n>\n> Oracles whose validity can be verified on chain (so transactions can\n> depend on what they say. The oracle has a capability)\n>\n> Colored coins whose validity can be verified on chain (the colored coins\n> have a capability)\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220803/101b8a4d/attachment.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-08-09T20:15:35",
                "message_text_only": "Hi Billy,\n\nThanks for your interest in a covenant working group.\n\n> place for this kind of thing to happen. I also agree with Ryan Grant's\n> comment about in-person cut-through (ie cut through the BS and resolve\n> misunderstandings). Perhaps every 3 IRC meetings or so, an in-person\nmeetup\n> can be organized in various locations to facilitate that kind of cut\n> through.\n\nI really appreciate in-person cut-through to resolve misunderstandings and\naccelerate the information synchronization across the stakeholders of a\nproblem space. However, I would like to note it's real work for the\norganizers in terms of time and energy: finding a common date making\nconsensus, an acceptable host country (i.e respecting the travel policy of\nthe widest, e.g organizing Scaling in Israel in 2019 was an issue for some\npassport holders), a standard meeting location, seeking event sponsors,\ncommunicating all those infos well ahead to ease everyone travels, ensuring\ncoffees & foods suiting many different diets, collecting topics of\ndiscussions, etc. Further, even assuming travel support, it can still be a\nprohibitive cost for a lot of participants, e.g if you have to request\nmonths ahead to the host country authorities a dedicated visa for the\nopportunity. I did a bit of in-person meetings organizing in the past, I'm\nclearly not interested in doing it anymore, though it would be cool if\nsomeone would like to do it for covenants in the future.\n\n> I would imagine the phases the group could go through is:\n> 1. Define the phases (these phases). This list of 6 phases could be a\n> starting point, but its probably best to open the floor to whether this\n> feels like a reasonable approach and if more phases are needed or if some\n> aren't.\n> 2. Define and prioritize the motivations (ie the various features and\n> functionality we want out of covenants, like the ones you listed). By\n> prioritize, I mostly mean figure out which motivations are most motivating\n> to people and rate them by strength of motivation (rather than a ranked\n> list).\n> 3. Define and prioritize the relevant constraints. These are things to\n> avoid in any covenant implementation. Constraints that have been brought\nup\n> in the past are things like preventing the possibility of infinite\ncovenant\n> recursion, full enumeration, preventing dynamic state, etc. By prioritize\n> here, it might be useful to categorize them into categories like \"no\n> tolerance\", \"some tolerance\", \"no reservations\". Eg it might turn out most\n> people don't have any tolerance for infinite recursion, but don't mind\n> non-full enumeration.\n> 4. Other criteria? These are other criteria we might want to evaluate\n> proposals according to. And some kind of way to prioritize them / evaluate\n> them against each other as trade offs.\n> 5. Evaluate the proposals based on motivations, constraints, and other\n> criteria. This phase shouldn't involve comparing them to each other.\n> 6. Produce a set of conclusions/opinions on which proposals are worth\n> pursuing further. This would be the phase where proposals are compared.\n\nYes, I think overall a lot is making sense. Though it's good to keep things\nas loose and see how it evaluates with time and new information showing up.\n\nAbout 2., I think one more thing to define is the list of use-cases, I\nwould abstract out features and functionality from use-cases. E.g, I think\nwith the TLUV proposal, the taproot output editing feature enables both\n\"dynamic-amount\" vault and scaling payment pools.\n\nAbout 3., I think this is going to be the hard part. Collecting all the\nconstraints and evaluating the risk tolerance of as-much-as-we-can\ncommunity stakeholders in face of known and plausible risks. E.g, again\nwith TLUV, I think it would make from now on the taproot internal pubkey\nand tree of alternative scripts a kind of \"dynamic state\".\n\nAbout 4. I've quickly come to mind as additional criterias economic\nsimulations of any feature, privacy advantages, toolchain implementations\ncomplexity, evolvability and composability with future features.\n\nAbout 6. I agree I think it's good to withhold comparison further down in\nthe pipe we can, even if there is I would say some criteria-learning\nheuristics by mirroring features against another.\n\n> Each phase would probably span over more than one meeting. I imagine each\n> phase basically consisting of discussing each individual nominated item\n(ie\n> motivations, constraints, other criteria, or proposals) sequentially. The\n> consensus reached at the end of each phase would be considered of course a\n> group consensus of those who participated, not a global consensus, not a\n> \"bitcoin community consensus\". After each phase, the results of that phase\n> would be published more widely to get broader community feedback. These\n> results would include what the major opinions are, what level of consensus\n> each major opinion has, what the reasons/justifications behind each\nopinion\n> are, and various detailed opinions from individuals. It would be\nespecially\n> great to have detailed evaluations of each proposal published by various\n> people so anyone can go back and understand their thought process (as\n> opposed to a list of names attached to basically a thumbs up or thumbs\n> down). Think like a supreme court decision kind of thing.\n\nYeah, again I don't see meetings as bounded in time rather happening\nregularly as we have with LN ones. I guess it's going to take at least a\ngood year for working group participants to take habits and familiarity\nwith the problem space and reach consensus on the process itself. Further,\nI would be even cautious about something restrained like \"group consensus\"\nin Bitcoin FOSS. At best, it's just a snapshot of people's understanding of\nthe technical issues in state X at time T, and that can evaluate quickly in\nfunction of new findings or issues arising. I think it's more interesting\nto seek a lack of consensus in the sense of opposite opinions or blocking\narguments. I wouldn't disqualify thumbs up or thumbs down per se, there are\nmarks of interest in a specific proposal, though I lean to agree that I\nfind more interesting too laid-out evaluations and thought processes.\n\n> The process doesn't need to be complete after phase 6. Any previous phase\n> could be revisited, but after a phase is revisited, the phases after it\n> should probably be also revisited in order - or at least until its decided\n> a previous phase needs to be revisited again. Each iteration would\nsolidify\n> consensus more about each phase. I would imagine the group might loop\n> through phases 2, 3, and 4 a couple times (since constraints might\nconflict\n> with motivating features). It might be likely that in phase 5 while\n> evaluating proposals, people realize that there are additional criteria\n> that should be added and can propose going back to step 4 to do that.\n> Hopefully we would get to the point where the motivations and constraints\n> and relatively solid consensuses and iterations can loop through phases 5\n> and 6 until the set of proposals the group thinks is worth pursuing  is\n> narrowed down (ideally to 1 or 2).\n\nFor sure, in the function of new feedback arising it's good to constantly\nreevaluate proposals. Hopefully, I think any looping should make proposals\nmore formalized and accurate. We might also have the \"easy\" covenants\nmoving faster than the \"hard\" ones across the phases. I believe the\ncovenant problem space might be solved in an evolutionary way, layer by\nlayer akin to how LN moves forward.\n\nLe mer. 3 ao\u00fbt 2022 \u00e0 11:37, Billy Tetrud <billy.tetrud at gmail.com> a \u00e9crit :\n\n> @Antoine\n> I very much like your proposal of an open decentralized process for\n> investigating the problem and solution spaces. IRC sounds like a reasonable\n> place for this kind of thing to happen. I also agree with Ryan Grant's\n> comment about in-person cut-through (ie cut through the BS and resolve\n> misunderstandings). Perhaps every 3 IRC meetings or so, an in-person meetup\n> can be organized in various locations to facilitate that kind of cut\n> through.\n>\n> I would imagine the phases the group could go through is:\n> 1. Define the phases (these phases). This list of 6 phases could be a\n> starting point, but its probably best to open the floor to whether this\n> feels like a reasonable approach and if more phases are needed or if some\n> aren't.\n> 2. Define and prioritize the motivations (ie the various features and\n> functionality we want out of covenants, like the ones you listed). By\n> prioritize, I mostly mean figure out which motivations are most motivating\n> to people and rate them by strength of motivation (rather than a ranked\n> list).\n> 3. Define and prioritize the relevant constraints. These are things to\n> avoid in any covenant implementation. Constraints that have been brought up\n> in the past are things like preventing the possibility of infinite covenant\n> recursion, full enumeration, preventing dynamic state, etc. By prioritize\n> here, it might be useful to categorize them into categories like \"no\n> tolerance\", \"some tolerance\", \"no reservations\". Eg it might turn out most\n> people don't have any tolerance for infinite recursion, but don't mind\n> non-full enumeration.\n> 4. Other criteria? These are other criteria we might want to evaluate\n> proposals according to. And some kind of way to prioritize them / evaluate\n> them against each other as trade offs.\n> 5. Evaluate the proposals based on motivations, constraints, and other\n> criteria. This phase shouldn't involve comparing them to each other.\n> 6. Produce a set of conclusions/opinions on which proposals are worth\n> pursuing further. This would be the phase where proposals are compared.\n>\n> Each phase would probably span over more than one meeting. I imagine each\n> phase basically consisting of discussing each individual nominated item (ie\n> motivations, constraints, other criteria, or proposals) sequentially. The\n> consensus reached at the end of each phase would be considered of course a\n> group consensus of those who participated, not a global consensus, not a\n> \"bitcoin community consensus\". After each phase, the results of that phase\n> would be published more widely to get broader community feedback. These\n> results would include what the major opinions are, what level of consensus\n> each major opinion has, what the reasons/justifications behind each opinion\n> are, and various detailed opinions from individuals. It would be especially\n> great to have detailed evaluations of each proposal published by various\n> people so anyone can go back and understand their thought process (as\n> opposed to a list of names attached to basically a thumbs up or thumbs\n> down). Think like a supreme court decision kind of thing.\n>\n> The process doesn't need to be complete after phase 6. Any previous phase\n> could be revisited, but after a phase is revisited, the phases after it\n> should probably be also revisited in order - or at least until its decided\n> a previous phase needs to be revisited again. Each iteration would solidify\n> consensus more about each phase. I would imagine the group might loop\n> through phases 2, 3, and 4 a couple times (since constraints might conflict\n> with motivating features). It might be likely that in phase 5 while\n> evaluating proposals, people realize that there are additional criteria\n> that should be added and can propose going back to step 4 to do that.\n> Hopefully we would get to the point where the motivations and constraints\n> and relatively solid consensuses and iterations can loop through phases 5\n> and 6 until the set of proposals the group thinks is worth pursuing  is\n> narrowed down (ideally to 1 or 2).\n>\n>\n>\n>\n>\n>\n> On Tue, Jul 26, 2022 at 11:47 AM Bram Cohen via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> On Mon, Jul 25, 2022 at 8:21 PM Antoine Riard <antoine.riard at gmail.com>\n>> wrote:\n>>\n>>> What would be the canonical definition and examples of capabilities in\n>>> the Bitcoin context ?\n>>>\n>>\n>> Payments into vaults which can only be accepted by that vault and are\n>> guaranteed to be subject to the vault's restrictions (the vault has a\n>> capability)\n>>\n>> Oracles whose validity can be verified on chain (so transactions can\n>> depend on what they say. The oracle has a capability)\n>>\n>> Colored coins whose validity can be verified on chain (the colored coins\n>> have a capability)\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220809/23ff7dea/attachment-0001.html>"
            },
            {
                "author": "Billy Tetrud",
                "date": "2022-08-27T21:01:21",
                "message_text_only": ">  I would like to note it's real work for the organizers in terms of time\nand energy: finding a common date making consensus, an acceptable host\ncountry (i.e respecting the travel policy of the widest...\n\nI was actually not thinking one large central in-person meeting, but many\nsmaller decentralized in-person meetings where no one has to travel far.\nThe meetings can be used to foster communication that can then be\nsummarized and/or brought online and discussed with the larger group. Would\ncertainly make all those date/visa/etc issues a lot easier.\n\n>  I would be even cautious about something restrained like \"group\nconsensus\" in Bitcoin FOSS. At best, it's just a snapshot of people's\nunderstanding of the technical issues in state X at time T\n\nFair enough. But I think part of the point here would be to use such a\nsnapshot as an indicator that helps convince others that a particular idea\nhas been discussed, thought through, and has actual well-reasoned support.\nWhatever you call it, it would be a useful set of data points.\n\n>  I believe the covenant problem space might be solved in an evolutionary\nway, layer by layer akin to how LN moves forward.\n\nDefinitely.\n\n\nOn Tue, Aug 9, 2022 at 3:15 PM Antoine Riard <antoine.riard at gmail.com>\nwrote:\n\n> Hi Billy,\n>\n> Thanks for your interest in a covenant working group.\n>\n> > place for this kind of thing to happen. I also agree with Ryan Grant's\n> > comment about in-person cut-through (ie cut through the BS and resolve\n> > misunderstandings). Perhaps every 3 IRC meetings or so, an in-person\n> meetup\n> > can be organized in various locations to facilitate that kind of cut\n> > through.\n>\n> I really appreciate in-person cut-through to resolve misunderstandings and\n> accelerate the information synchronization across the stakeholders of a\n> problem space. However, I would like to note it's real work for the\n> organizers in terms of time and energy: finding a common date making\n> consensus, an acceptable host country (i.e respecting the travel policy of\n> the widest, e.g organizing Scaling in Israel in 2019 was an issue for some\n> passport holders), a standard meeting location, seeking event sponsors,\n> communicating all those infos well ahead to ease everyone travels, ensuring\n> coffees & foods suiting many different diets, collecting topics of\n> discussions, etc. Further, even assuming travel support, it can still be a\n> prohibitive cost for a lot of participants, e.g if you have to request\n> months ahead to the host country authorities a dedicated visa for the\n> opportunity. I did a bit of in-person meetings organizing in the past, I'm\n> clearly not interested in doing it anymore, though it would be cool if\n> someone would like to do it for covenants in the future.\n>\n> > I would imagine the phases the group could go through is:\n> > 1. Define the phases (these phases). This list of 6 phases could be a\n> > starting point, but its probably best to open the floor to whether this\n> > feels like a reasonable approach and if more phases are needed or if some\n> > aren't.\n> > 2. Define and prioritize the motivations (ie the various features and\n> > functionality we want out of covenants, like the ones you listed). By\n> > prioritize, I mostly mean figure out which motivations are most\n> motivating\n> > to people and rate them by strength of motivation (rather than a ranked\n> > list).\n> > 3. Define and prioritize the relevant constraints. These are things to\n> > avoid in any covenant implementation. Constraints that have been brought\n> up\n> > in the past are things like preventing the possibility of infinite\n> covenant\n> > recursion, full enumeration, preventing dynamic state, etc. By prioritize\n> > here, it might be useful to categorize them into categories like \"no\n> > tolerance\", \"some tolerance\", \"no reservations\". Eg it might turn out\n> most\n> > people don't have any tolerance for infinite recursion, but don't mind\n> > non-full enumeration.\n> > 4. Other criteria? These are other criteria we might want to evaluate\n> > proposals according to. And some kind of way to prioritize them /\n> evaluate\n> > them against each other as trade offs.\n> > 5. Evaluate the proposals based on motivations, constraints, and other\n> > criteria. This phase shouldn't involve comparing them to each other.\n> > 6. Produce a set of conclusions/opinions on which proposals are worth\n> > pursuing further. This would be the phase where proposals are compared.\n>\n> Yes, I think overall a lot is making sense. Though it's good to keep\n> things as loose and see how it evaluates with time and new information\n> showing up.\n>\n> About 2., I think one more thing to define is the list of use-cases, I\n> would abstract out features and functionality from use-cases. E.g, I think\n> with the TLUV proposal, the taproot output editing feature enables both\n> \"dynamic-amount\" vault and scaling payment pools.\n>\n> About 3., I think this is going to be the hard part. Collecting all the\n> constraints and evaluating the risk tolerance of as-much-as-we-can\n> community stakeholders in face of known and plausible risks. E.g, again\n> with TLUV, I think it would make from now on the taproot internal pubkey\n> and tree of alternative scripts a kind of \"dynamic state\".\n>\n> About 4. I've quickly come to mind as additional criterias economic\n> simulations of any feature, privacy advantages, toolchain implementations\n> complexity, evolvability and composability with future features.\n>\n> About 6. I agree I think it's good to withhold comparison further down in\n> the pipe we can, even if there is I would say some criteria-learning\n> heuristics by mirroring features against another.\n>\n> > Each phase would probably span over more than one meeting. I imagine each\n> > phase basically consisting of discussing each individual nominated item\n> (ie\n> > motivations, constraints, other criteria, or proposals) sequentially. The\n> > consensus reached at the end of each phase would be considered of course\n> a\n> > group consensus of those who participated, not a global consensus, not a\n> > \"bitcoin community consensus\". After each phase, the results of that\n> phase\n> > would be published more widely to get broader community feedback. These\n> > results would include what the major opinions are, what level of\n> consensus\n> > each major opinion has, what the reasons/justifications behind each\n> opinion\n> > are, and various detailed opinions from individuals. It would be\n> especially\n> > great to have detailed evaluations of each proposal published by various\n> > people so anyone can go back and understand their thought process (as\n> > opposed to a list of names attached to basically a thumbs up or thumbs\n> > down). Think like a supreme court decision kind of thing.\n>\n> Yeah, again I don't see meetings as bounded in time rather happening\n> regularly as we have with LN ones. I guess it's going to take at least a\n> good year for working group participants to take habits and familiarity\n> with the problem space and reach consensus on the process itself. Further,\n> I would be even cautious about something restrained like \"group consensus\"\n> in Bitcoin FOSS. At best, it's just a snapshot of people's understanding of\n> the technical issues in state X at time T, and that can evaluate quickly in\n> function of new findings or issues arising. I think it's more interesting\n> to seek a lack of consensus in the sense of opposite opinions or blocking\n> arguments. I wouldn't disqualify thumbs up or thumbs down per se, there are\n> marks of interest in a specific proposal, though I lean to agree that I\n> find more interesting too laid-out evaluations and thought processes.\n>\n> > The process doesn't need to be complete after phase 6. Any previous phase\n> > could be revisited, but after a phase is revisited, the phases after it\n> > should probably be also revisited in order - or at least until its\n> decided\n> > a previous phase needs to be revisited again. Each iteration would\n> solidify\n> > consensus more about each phase. I would imagine the group might loop\n> > through phases 2, 3, and 4 a couple times (since constraints might\n> conflict\n> > with motivating features). It might be likely that in phase 5 while\n> > evaluating proposals, people realize that there are additional criteria\n> > that should be added and can propose going back to step 4 to do that.\n> > Hopefully we would get to the point where the motivations and constraints\n> > and relatively solid consensuses and iterations can loop through phases 5\n> > and 6 until the set of proposals the group thinks is worth pursuing  is\n> > narrowed down (ideally to 1 or 2).\n>\n> For sure, in the function of new feedback arising it's good to constantly\n> reevaluate proposals. Hopefully, I think any looping should make proposals\n> more formalized and accurate. We might also have the \"easy\" covenants\n> moving faster than the \"hard\" ones across the phases. I believe the\n> covenant problem space might be solved in an evolutionary way, layer by\n> layer akin to how LN moves forward.\n>\n> Le mer. 3 ao\u00fbt 2022 \u00e0 11:37, Billy Tetrud <billy.tetrud at gmail.com> a\n> \u00e9crit :\n>\n>> @Antoine\n>> I very much like your proposal of an open decentralized process for\n>> investigating the problem and solution spaces. IRC sounds like a reasonable\n>> place for this kind of thing to happen. I also agree with Ryan Grant's\n>> comment about in-person cut-through (ie cut through the BS and resolve\n>> misunderstandings). Perhaps every 3 IRC meetings or so, an in-person meetup\n>> can be organized in various locations to facilitate that kind of cut\n>> through.\n>>\n>> I would imagine the phases the group could go through is:\n>> 1. Define the phases (these phases). This list of 6 phases could be a\n>> starting point, but its probably best to open the floor to whether this\n>> feels like a reasonable approach and if more phases are needed or if some\n>> aren't.\n>> 2. Define and prioritize the motivations (ie the various features and\n>> functionality we want out of covenants, like the ones you listed). By\n>> prioritize, I mostly mean figure out which motivations are most motivating\n>> to people and rate them by strength of motivation (rather than a ranked\n>> list).\n>> 3. Define and prioritize the relevant constraints. These are things to\n>> avoid in any covenant implementation. Constraints that have been brought up\n>> in the past are things like preventing the possibility of infinite covenant\n>> recursion, full enumeration, preventing dynamic state, etc. By prioritize\n>> here, it might be useful to categorize them into categories like \"no\n>> tolerance\", \"some tolerance\", \"no reservations\". Eg it might turn out most\n>> people don't have any tolerance for infinite recursion, but don't mind\n>> non-full enumeration.\n>> 4. Other criteria? These are other criteria we might want to evaluate\n>> proposals according to. And some kind of way to prioritize them / evaluate\n>> them against each other as trade offs.\n>> 5. Evaluate the proposals based on motivations, constraints, and other\n>> criteria. This phase shouldn't involve comparing them to each other.\n>> 6. Produce a set of conclusions/opinions on which proposals are worth\n>> pursuing further. This would be the phase where proposals are compared.\n>>\n>> Each phase would probably span over more than one meeting. I imagine each\n>> phase basically consisting of discussing each individual nominated item (ie\n>> motivations, constraints, other criteria, or proposals) sequentially. The\n>> consensus reached at the end of each phase would be considered of course a\n>> group consensus of those who participated, not a global consensus, not a\n>> \"bitcoin community consensus\". After each phase, the results of that phase\n>> would be published more widely to get broader community feedback. These\n>> results would include what the major opinions are, what level of consensus\n>> each major opinion has, what the reasons/justifications behind each opinion\n>> are, and various detailed opinions from individuals. It would be especially\n>> great to have detailed evaluations of each proposal published by various\n>> people so anyone can go back and understand their thought process (as\n>> opposed to a list of names attached to basically a thumbs up or thumbs\n>> down). Think like a supreme court decision kind of thing.\n>>\n>> The process doesn't need to be complete after phase 6. Any previous phase\n>> could be revisited, but after a phase is revisited, the phases after it\n>> should probably be also revisited in order - or at least until its decided\n>> a previous phase needs to be revisited again. Each iteration would solidify\n>> consensus more about each phase. I would imagine the group might loop\n>> through phases 2, 3, and 4 a couple times (since constraints might conflict\n>> with motivating features). It might be likely that in phase 5 while\n>> evaluating proposals, people realize that there are additional criteria\n>> that should be added and can propose going back to step 4 to do that.\n>> Hopefully we would get to the point where the motivations and constraints\n>> and relatively solid consensuses and iterations can loop through phases 5\n>> and 6 until the set of proposals the group thinks is worth pursuing  is\n>> narrowed down (ideally to 1 or 2).\n>>\n>>\n>>\n>>\n>>\n>>\n>> On Tue, Jul 26, 2022 at 11:47 AM Bram Cohen via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> On Mon, Jul 25, 2022 at 8:21 PM Antoine Riard <antoine.riard at gmail.com>\n>>> wrote:\n>>>\n>>>> What would be the canonical definition and examples of capabilities in\n>>>> the Bitcoin context ?\n>>>>\n>>>\n>>> Payments into vaults which can only be accepted by that vault and are\n>>> guaranteed to be subject to the vault's restrictions (the vault has a\n>>> capability)\n>>>\n>>> Oracles whose validity can be verified on chain (so transactions can\n>>> depend on what they say. The oracle has a capability)\n>>>\n>>> Colored coins whose validity can be verified on chain (the colored coins\n>>> have a capability)\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220827/651cda91/attachment-0001.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-08-30T15:46:23",
                "message_text_only": "Hi Billy,\n\n> I was actually not thinking one large central in-person meeting, but many\nsmaller decentralized in-person meetings where no one has to travel far.\nThe meetings can be used to foster communication that can then be\nsummarized and/or brought online and discussed with the larger group. Would\ncertainly make all those date/visa/etc issues a lot easier.\n\nMinimizing travel hurdles for everyone sounds wise. About decentralized\nin-person meetings we already have a wide network of BitDev all around the\nworld that can be opportunities to foster communication on covenant R&D\nadvances. Staying interested in participating in in-person covenant-focus\nmeetings though I won't volunteer to organize them, from my experience it's\na real trade different from Bitcoin research engineering!\n\n> Fair enough. But I think part of the point here would be to use such a\nsnapshot as an indicator that helps convince others that a particular idea\nhas been discussed, thought through, and has actual well-reasoned support.\nWhatever you call it, it would be a useful set of data points.\n\nYeah, collecting, building and maintaining a set of strong data points that\nwould improve the community covenant information-gathering process.\nHowever, I think observing consensus is better left to everyone's personal\njudgement rather than proclaiming it. At best, we can monitor the lack of\nconsensus.\n\nThere is already an ongoing effort to document primitives :\nhttps://github.com/bitcoinops/bitcoinops.github.io/pull/806 and making\nprogress on the use-cases collection soon.\n\n\nLe sam. 27 ao\u00fbt 2022 \u00e0 22:01, Billy Tetrud <billy.tetrud at gmail.com> a\n\u00e9crit :\n\n> >  I would like to note it's real work for the organizers in terms of time\n> and energy: finding a common date making consensus, an acceptable host\n> country (i.e respecting the travel policy of the widest...\n>\n> I was actually not thinking one large central in-person meeting, but many\n> smaller decentralized in-person meetings where no one has to travel far.\n> The meetings can be used to foster communication that can then be\n> summarized and/or brought online and discussed with the larger group. Would\n> certainly make all those date/visa/etc issues a lot easier.\n>\n> >  I would be even cautious about something restrained like \"group\n> consensus\" in Bitcoin FOSS. At best, it's just a snapshot of people's\n> understanding of the technical issues in state X at time T\n>\n> Fair enough. But I think part of the point here would be to use such a\n> snapshot as an indicator that helps convince others that a particular idea\n> has been discussed, thought through, and has actual well-reasoned support.\n> Whatever you call it, it would be a useful set of data points.\n>\n> >  I believe the covenant problem space might be solved in an evolutionary\n> way, layer by layer akin to how LN moves forward.\n>\n> Definitely.\n>\n>\n> On Tue, Aug 9, 2022 at 3:15 PM Antoine Riard <antoine.riard at gmail.com>\n> wrote:\n>\n>> Hi Billy,\n>>\n>> Thanks for your interest in a covenant working group.\n>>\n>> > place for this kind of thing to happen. I also agree with Ryan Grant's\n>> > comment about in-person cut-through (ie cut through the BS and resolve\n>> > misunderstandings). Perhaps every 3 IRC meetings or so, an in-person\n>> meetup\n>> > can be organized in various locations to facilitate that kind of cut\n>> > through.\n>>\n>> I really appreciate in-person cut-through to resolve misunderstandings\n>> and accelerate the information synchronization across the stakeholders of a\n>> problem space. However, I would like to note it's real work for the\n>> organizers in terms of time and energy: finding a common date making\n>> consensus, an acceptable host country (i.e respecting the travel policy of\n>> the widest, e.g organizing Scaling in Israel in 2019 was an issue for some\n>> passport holders), a standard meeting location, seeking event sponsors,\n>> communicating all those infos well ahead to ease everyone travels, ensuring\n>> coffees & foods suiting many different diets, collecting topics of\n>> discussions, etc. Further, even assuming travel support, it can still be a\n>> prohibitive cost for a lot of participants, e.g if you have to request\n>> months ahead to the host country authorities a dedicated visa for the\n>> opportunity. I did a bit of in-person meetings organizing in the past, I'm\n>> clearly not interested in doing it anymore, though it would be cool if\n>> someone would like to do it for covenants in the future.\n>>\n>> > I would imagine the phases the group could go through is:\n>> > 1. Define the phases (these phases). This list of 6 phases could be a\n>> > starting point, but its probably best to open the floor to whether this\n>> > feels like a reasonable approach and if more phases are needed or if\n>> some\n>> > aren't.\n>> > 2. Define and prioritize the motivations (ie the various features and\n>> > functionality we want out of covenants, like the ones you listed). By\n>> > prioritize, I mostly mean figure out which motivations are most\n>> motivating\n>> > to people and rate them by strength of motivation (rather than a ranked\n>> > list).\n>> > 3. Define and prioritize the relevant constraints. These are things to\n>> > avoid in any covenant implementation. Constraints that have been\n>> brought up\n>> > in the past are things like preventing the possibility of infinite\n>> covenant\n>> > recursion, full enumeration, preventing dynamic state, etc. By\n>> prioritize\n>> > here, it might be useful to categorize them into categories like \"no\n>> > tolerance\", \"some tolerance\", \"no reservations\". Eg it might turn out\n>> most\n>> > people don't have any tolerance for infinite recursion, but don't mind\n>> > non-full enumeration.\n>> > 4. Other criteria? These are other criteria we might want to evaluate\n>> > proposals according to. And some kind of way to prioritize them /\n>> evaluate\n>> > them against each other as trade offs.\n>> > 5. Evaluate the proposals based on motivations, constraints, and other\n>> > criteria. This phase shouldn't involve comparing them to each other.\n>> > 6. Produce a set of conclusions/opinions on which proposals are worth\n>> > pursuing further. This would be the phase where proposals are compared.\n>>\n>> Yes, I think overall a lot is making sense. Though it's good to keep\n>> things as loose and see how it evaluates with time and new information\n>> showing up.\n>>\n>> About 2., I think one more thing to define is the list of use-cases, I\n>> would abstract out features and functionality from use-cases. E.g, I think\n>> with the TLUV proposal, the taproot output editing feature enables both\n>> \"dynamic-amount\" vault and scaling payment pools.\n>>\n>> About 3., I think this is going to be the hard part. Collecting all the\n>> constraints and evaluating the risk tolerance of as-much-as-we-can\n>> community stakeholders in face of known and plausible risks. E.g, again\n>> with TLUV, I think it would make from now on the taproot internal pubkey\n>> and tree of alternative scripts a kind of \"dynamic state\".\n>>\n>> About 4. I've quickly come to mind as additional criterias economic\n>> simulations of any feature, privacy advantages, toolchain implementations\n>> complexity, evolvability and composability with future features.\n>>\n>> About 6. I agree I think it's good to withhold comparison further down in\n>> the pipe we can, even if there is I would say some criteria-learning\n>> heuristics by mirroring features against another.\n>>\n>> > Each phase would probably span over more than one meeting. I imagine\n>> each\n>> > phase basically consisting of discussing each individual nominated item\n>> (ie\n>> > motivations, constraints, other criteria, or proposals) sequentially.\n>> The\n>> > consensus reached at the end of each phase would be considered of\n>> course a\n>> > group consensus of those who participated, not a global consensus, not a\n>> > \"bitcoin community consensus\". After each phase, the results of that\n>> phase\n>> > would be published more widely to get broader community feedback. These\n>> > results would include what the major opinions are, what level of\n>> consensus\n>> > each major opinion has, what the reasons/justifications behind each\n>> opinion\n>> > are, and various detailed opinions from individuals. It would be\n>> especially\n>> > great to have detailed evaluations of each proposal published by various\n>> > people so anyone can go back and understand their thought process (as\n>> > opposed to a list of names attached to basically a thumbs up or thumbs\n>> > down). Think like a supreme court decision kind of thing.\n>>\n>> Yeah, again I don't see meetings as bounded in time rather happening\n>> regularly as we have with LN ones. I guess it's going to take at least a\n>> good year for working group participants to take habits and familiarity\n>> with the problem space and reach consensus on the process itself. Further,\n>> I would be even cautious about something restrained like \"group consensus\"\n>> in Bitcoin FOSS. At best, it's just a snapshot of people's understanding of\n>> the technical issues in state X at time T, and that can evaluate quickly in\n>> function of new findings or issues arising. I think it's more interesting\n>> to seek a lack of consensus in the sense of opposite opinions or blocking\n>> arguments. I wouldn't disqualify thumbs up or thumbs down per se, there are\n>> marks of interest in a specific proposal, though I lean to agree that I\n>> find more interesting too laid-out evaluations and thought processes.\n>>\n>> > The process doesn't need to be complete after phase 6. Any previous\n>> phase\n>> > could be revisited, but after a phase is revisited, the phases after it\n>> > should probably be also revisited in order - or at least until its\n>> decided\n>> > a previous phase needs to be revisited again. Each iteration would\n>> solidify\n>> > consensus more about each phase. I would imagine the group might loop\n>> > through phases 2, 3, and 4 a couple times (since constraints might\n>> conflict\n>> > with motivating features). It might be likely that in phase 5 while\n>> > evaluating proposals, people realize that there are additional criteria\n>> > that should be added and can propose going back to step 4 to do that.\n>> > Hopefully we would get to the point where the motivations and\n>> constraints\n>> > and relatively solid consensuses and iterations can loop through phases\n>> 5\n>> > and 6 until the set of proposals the group thinks is worth pursuing  is\n>> > narrowed down (ideally to 1 or 2).\n>>\n>> For sure, in the function of new feedback arising it's good to constantly\n>> reevaluate proposals. Hopefully, I think any looping should make proposals\n>> more formalized and accurate. We might also have the \"easy\" covenants\n>> moving faster than the \"hard\" ones across the phases. I believe the\n>> covenant problem space might be solved in an evolutionary way, layer by\n>> layer akin to how LN moves forward.\n>>\n>> Le mer. 3 ao\u00fbt 2022 \u00e0 11:37, Billy Tetrud <billy.tetrud at gmail.com> a\n>> \u00e9crit :\n>>\n>>> @Antoine\n>>> I very much like your proposal of an open decentralized process for\n>>> investigating the problem and solution spaces. IRC sounds like a reasonable\n>>> place for this kind of thing to happen. I also agree with Ryan Grant's\n>>> comment about in-person cut-through (ie cut through the BS and resolve\n>>> misunderstandings). Perhaps every 3 IRC meetings or so, an in-person meetup\n>>> can be organized in various locations to facilitate that kind of cut\n>>> through.\n>>>\n>>> I would imagine the phases the group could go through is:\n>>> 1. Define the phases (these phases). This list of 6 phases could be a\n>>> starting point, but its probably best to open the floor to whether this\n>>> feels like a reasonable approach and if more phases are needed or if some\n>>> aren't.\n>>> 2. Define and prioritize the motivations (ie the various features and\n>>> functionality we want out of covenants, like the ones you listed). By\n>>> prioritize, I mostly mean figure out which motivations are most motivating\n>>> to people and rate them by strength of motivation (rather than a ranked\n>>> list).\n>>> 3. Define and prioritize the relevant constraints. These are things to\n>>> avoid in any covenant implementation. Constraints that have been brought up\n>>> in the past are things like preventing the possibility of infinite covenant\n>>> recursion, full enumeration, preventing dynamic state, etc. By prioritize\n>>> here, it might be useful to categorize them into categories like \"no\n>>> tolerance\", \"some tolerance\", \"no reservations\". Eg it might turn out most\n>>> people don't have any tolerance for infinite recursion, but don't mind\n>>> non-full enumeration.\n>>> 4. Other criteria? These are other criteria we might want to evaluate\n>>> proposals according to. And some kind of way to prioritize them / evaluate\n>>> them against each other as trade offs.\n>>> 5. Evaluate the proposals based on motivations, constraints, and other\n>>> criteria. This phase shouldn't involve comparing them to each other.\n>>> 6. Produce a set of conclusions/opinions on which proposals are worth\n>>> pursuing further. This would be the phase where proposals are compared.\n>>>\n>>> Each phase would probably span over more than one meeting. I imagine\n>>> each phase basically consisting of discussing each individual nominated\n>>> item (ie motivations, constraints, other criteria, or proposals)\n>>> sequentially. The consensus reached at the end of each phase would be\n>>> considered of course a group consensus of those who participated, not a\n>>> global consensus, not a \"bitcoin community consensus\". After each phase,\n>>> the results of that phase would be published more widely to get broader\n>>> community feedback. These results would include what the major opinions\n>>> are, what level of consensus each major opinion has, what the\n>>> reasons/justifications behind each opinion are, and various detailed\n>>> opinions from individuals. It would be especially great to have detailed\n>>> evaluations of each proposal published by various people so anyone can go\n>>> back and understand their thought process (as opposed to a list of names\n>>> attached to basically a thumbs up or thumbs down). Think like a supreme\n>>> court decision kind of thing.\n>>>\n>>> The process doesn't need to be complete after phase 6. Any previous\n>>> phase could be revisited, but after a phase is revisited, the phases after\n>>> it should probably be also revisited in order - or at least until its\n>>> decided a previous phase needs to be revisited again. Each iteration would\n>>> solidify consensus more about each phase. I would imagine the group might\n>>> loop through phases 2, 3, and 4 a couple times (since constraints might\n>>> conflict with motivating features). It might be likely that in phase 5\n>>> while evaluating proposals, people realize that there are additional\n>>> criteria that should be added and can propose going back to step 4 to do\n>>> that. Hopefully we would get to the point where the motivations and\n>>> constraints and relatively solid consensuses and iterations can loop\n>>> through phases 5 and 6 until the set of proposals the group thinks is worth\n>>> pursuing  is narrowed down (ideally to 1 or 2).\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>> On Tue, Jul 26, 2022 at 11:47 AM Bram Cohen via bitcoin-dev <\n>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>>> On Mon, Jul 25, 2022 at 8:21 PM Antoine Riard <antoine.riard at gmail.com>\n>>>> wrote:\n>>>>\n>>>>> What would be the canonical definition and examples of capabilities in\n>>>>> the Bitcoin context ?\n>>>>>\n>>>>\n>>>> Payments into vaults which can only be accepted by that vault and are\n>>>> guaranteed to be subject to the vault's restrictions (the vault has a\n>>>> capability)\n>>>>\n>>>> Oracles whose validity can be verified on chain (so transactions can\n>>>> depend on what they say. The oracle has a capability)\n>>>>\n>>>> Colored coins whose validity can be verified on chain (the colored\n>>>> coins have a capability)\n>>>>\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>\n>>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220830/aa31a93d/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "On a new community process to specify covenants",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Billy Tetrud",
                "Antoine Riard"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 48505
        }
    },
    {
        "title": "[bitcoin-dev] BIP Proposal: Receiving and Change Derivation Paths in a Single Descriptor",
        "thread_messages": [
            {
                "author": "Billy Tetrud",
                "date": "2022-08-04T01:16:52",
                "message_text_only": "@Dmitry\n>  various software might start to use extra indexes in a tuple for their\nown non-standard purposes\n\nThis will be true regardless of whether the spec allows or doesn't allow\ntuples of length more than 2. In fact, any other tuple other than <1;2>\nwill be nonstandard. We can't prevent people from using standards in\nuse-case-specific ways, and we can't prevent people from creating\nnon-standard extensions of standards.\n\n> Wallet software that wishes to utilize non-standard extra indexes beyond\n'receive' and 'change' should use separate descriptors instead for these\nextra indexes.\n\nWhat benefit would that gain? The wallets would still be doing something\nnon-standard and interpreting those indexes however they want. A descriptor\nformat is simply defining a space of address derivation paths. It is not\ndescribing in any way what each path is intended for - those are\nconventions outside the scope of this BIP IMO. Defining the conventions of\nderivation path indexes should be a separate BIP. Single responsibility\nprinciple.\n\nOn Thu, Jul 28, 2022 at 5:15 AM Dmitry Petukhov via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> The issue with tuples of lenth more than two is that the purpose for\n> indexes beyond 'receive' and 'change' are not established, and\n> therefore various software might start to use extra indexes in a tuple\n> for their own non-standard purposes. This is bound to create\n> incompatibilities where different wallet software that import the same\n> descriptor would use those addresses for different purposes.\n>\n> Even if some auxiliary standard emerges for the meanings of extra\n> indexes, since the indexes in the tuple are listed without omissions (no\n> \"<0;1;;;3>\" allowed), all software will need to be aware of the\n> existence of these purposes and define indexes for them: if one wishes\n> to utilize position 3 in such a tuple, they will need to define an index\n> for position 2 as well.\n>\n> I'd expect that emergence of new widely-used purposes for indexes would\n> be a very rare event, and a separate BIP for each purpose wouldn't be\n> excessive.\n>\n> I'd say that bip-multipath-descs should say that extra indexes are OK\n> for address discovery (for scanning of the addresses of a wallet), but\n> it should say that any interpretation of the purpose of such indexes\n> and deriving new addresses at these indexes are strongly discouraged.\n>\n> Wallet software that wishes to utilize non-standard extra indexes beyond\n> 'receive' and 'change' should use separate descriptors instead for\n> these extra indexes.\n>\n> And when a new established purpose emerges for the next position in the\n> index tuple, a new BIP should be made that defines such position.\n>\n> The BIP for position 3 would naturally come after the BIP for position\n> 2, and thus software that implemnents BIP for position 3 would be aware\n> of the previous BIP and will at least know to choose some index for\n> position 2.\n>\n> \u0412 Wed, 27 Jul 2022 14:58:28 +0000\n> Andrew Chow via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> wrote:\n>\n> > I've updated the BIP text to allow arbitrary length tuples.\n> >\n> > On 07/27/2022 04:44 AM, Pavol Rusnak wrote:\n> >\n> > > On Wed, 27 Jul 2022 at 00:28, Andrew Chow\n> > > <achow101-lists at achow101.com> wrote:\n> > >> However I don't see why this couldn't generalize to any sized\n> > >> tuples. As long as the tuples are all the same length, and the\n> > >> limit is one tuple per key expression, then we don't get any\n> > >> combinatorial blowup issues.\n> > >\n> > > I think it's worthwhile to generalize for any sized tuples. I don't\n> > > have any existing particular use case in mind, because BIP-44,\n> > > BIP-84, etc. are fine with just using <0;1>, but there might be\n> > > some upcoming standards in the future that will want to introduce\n> > > more sub-paths.\n> > >\n> > > --\n> > >\n> > > Best Regards / S pozdravom,\n> > >\n> > > Pavol \"stick\" Rusnak\n> > > Co-Founder, SatoshiLab\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220803/bc75c220/attachment-0001.html>"
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2022-08-04T07:09:33",
                "message_text_only": "\u0412 Wed, 3 Aug 2022 20:16:52 -0500\nBilly Tetrud <billy.tetrud at gmail.com> wrote:\n\n> A descriptor format is simply defining a space of address\n> derivation paths. It is not describing in any way what each path is\n> intended for - those are conventions outside the scope of this BIP\n> IMO. Defining the conventions of derivation path indexes should be a\n> separate BIP. Single responsibility principle.\n\nI see, you're right. I misread the BIP proposal text and missed that it\ndescribes 'receive' and 'change' only as 'common usecase', not as\ndefinitive designations for indexes. Considering this, I too see no need\nto include such conventions in this BIP."
            }
        ],
        "thread_summary": {
            "title": "BIP Proposal: Receiving and Change Derivation Paths in a Single Descriptor",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Billy Tetrud",
                "Dmitry Petukhov"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 4982
        }
    },
    {
        "title": "[bitcoin-dev] BIP-notatether-signedmessage",
        "thread_messages": [
            {
                "author": "Ali Sherief",
                "date": "2022-08-04T12:18:56",
                "message_text_only": "Hi,\n\nI have created a new BIP, called notatether-signedmessage. It can be viewed at https://github.com/ZenulAbidin/bips/blob/master/bip-notatether-signedmessage.mediawiki.\n\nFor those who want a quick summary, it defines a step-by-step process for signing and verifying messages from legacy, native/nested segwit, and taproot addresses. It does not define a new signature format itself, except in the case of Taproot. For those addresses, I have defined a signature format that has 1 byte header/recID, 64 bytes signature, and 32 bytes x coordinate of a public key. This is required to run the BIP340 Schnorr verify algorithm using only the signature - and the header byte is added for backwards compatibility. Otherwise, it completely integrates BIP137 signatures.\n\nI am planning to move that format to its own BIP as soon as possible, in lieu that it is unacceptable to define formats in an Informational BIP.\n\nPlease leave your comments in this mailing list. CC'ing BIP editors.\n\n- Ali"
            },
            {
                "author": "Ali Sherief",
                "date": "2022-08-04T17:54:02",
                "message_text_only": "My sincere apologies, the link returns a 404 (trailing dot). The correct link to the BIP is https://github.com/ZenulAbidin/bips/blob/master/bip-notatether-signedmessage.mediawiki\n\n-Ali\n\n------- Original Message -------\nOn Thursday, August 4th, 2022 at 3:18 PM, Ali Sherief <ali at notatether.com> wrote:\n\n\n> Hi,\n>\n> I have created a new BIP, called notatether-signedmessage. It can be viewed at https://github.com/ZenulAbidin/bips/blob/master/bip-notatether-signedmessage.mediawiki.\n>\n> For those who want a quick summary, it defines a step-by-step process for signing and verifying messages from legacy, native/nested segwit, and taproot addresses. It does not define a new signature format itself, except in the case of Taproot. For those addresses, I have defined a signature format that has 1 byte header/recID, 64 bytes signature, and 32 bytes x coordinate of a public key. This is required to run the BIP340 Schnorr verify algorithm using only the signature - and the header byte is added for backwards compatibility. Otherwise, it completely integrates BIP137 signatures.\n>\n> I am planning to move that format to its own BIP as soon as possible, in lieu that it is unacceptable to define formats in an Informational BIP.\n>\n> Please leave your comments in this mailing list. CC'ing BIP editors.\n>\n> - Ali"
            },
            {
                "author": "Peter (Coinkite Inc)",
                "date": "2022-08-04T18:36:06",
                "message_text_only": "Thanks for doing this, it looks great Ali!\n\nCOLDCARD and other Coinkite products will conform to this spec, if we don't already.\n\nOn Thu, Aug 04, 2022 at 12:18:56PM +0000, Ali Sherief wrote:\n> Hi,\n> \n> I have created a new BIP, called notatether-signedmessage. It can be viewed at https://github.com/ZenulAbidin/bips/blob/master/bip-notatether-signedmessage.mediawiki.\n> \n...\n\n---\n@DocHEX  ||  Coinkite  ||  PGP: A3A31BAD 5A2A5B10\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220804/f034fec4/attachment.sig>"
            },
            {
                "author": "Ali Sherief",
                "date": "2022-08-05T04:05:56",
                "message_text_only": "Yeah, I have a specific reason to advance this first (emphasis on the word first).\n\nI briefly mentioned in the BIP that BIP322 has superior message verification capabilities. This is true, but it suffers from the drawback that wallets are not using it. What they are using right now is a chaotic mixture of legacy address sign/verify and nonstandard segwit sign/verify. Attempting to enforce BIP322 on them in this stage will just create an N+1 problem, so an effort has to be made first to transfer these N signing implementations to a common ground, with as little as possible developer effort - it takes much less time to code the point-by-point steps than designing a class for BIP322 signatures, since the teams behind these wallets have to *agree* on how to code such a change. This ultimately decides whether or not the wallets implement such features as BIP322 or this BIP. [this paragraph is the meat of the reasoning.]\n\nThat is to say, BIP322 is more complex than this BIP (which in no way replaces BIP322), hence it requires a larger design effort on the part of wallet developers to implement. Considering that the vast majority of them already sign messages using the current format, it makes complete sense to make them all conform to this BIP first, then we finish BIP322, and then make wallets use that.\n\nMessage signatures are highly relied upon in some places (just to name a few, at many mining pools e.g. Slushpool, and the Bitcointalk forum), and it is unreasonable to expect users to cling on to an old address format, or use a specific wallet (Electrum) that provides nonstandard signature verification (it does *not* follow BIP137 despite supporting segwit messages, so their signatures are non-portable).\n\nThat is why it is necessary at the present moment to ensure as many wallets are possible are not only using the specification in my BIP to perform message signing and verification, but also implement, at a bare minimum, the legacy and segwit address parts. And the reason I did not mandate this requirement is the BIP is that wallets do not provide legacy addresses, then it makes no sense for them to add the sign/verify code for legacy addresses as well.\n\nThis BIP is kind of like a \"bumper car\", in that it forces compliance with previous BIPs that extend the message signing format, in particular BIP137. I admit that the Taproot signature format should not be located inside this BIP - I want to keep it strictly Informational, but rather, it should be contained in a newer Standards Track BIP that supersedes BIP137 - it's only task is to define everything BIP137 already defines, and  also add the Taproot signing format.\n\nLike I said in the BIP, just making a proposal will not solve all these problems. It will only solve half of them, and the other half has to be solved by getting the other wallet implementations (Armory, Wasabi, BitcoinJ, Samourai, Mycelium, Electrum, and Trezor/Ledger among others) to implement this standard. It is not a difficult task but it's a non-trivial one, and we ought to be at least half-way to the finish line by assigning a number to this.\n\n- Ali\n\n------- Original Message -------\nOn Thursday, August 4th, 2022 at 10:26 PM, Luke Dashjr <luke at dashjr.org> wrote:\n\n\n> Any reason not to just help Kalle out with BIP 322?\n>\n> https://github.com/bitcoin/bips/pull/1347\n>\n>\n> On Thursday 04 August 2022 12:18:56 Ali Sherief via bitcoin-dev wrote:\n>\n> > Hi,\n> >\n> > I have created a new BIP, called notatether-signedmessage. It can be viewed\n> > at\n> > https://github.com/ZenulAbidin/bips/blob/master/bip-notatether-signedmessag\n> > e.mediawiki.\n> >\n> > For those who want a quick summary, it defines a step-by-step process for\n> > signing and verifying messages from legacy, native/nested segwit, and\n> > taproot addresses. It does not define a new signature format itself, except\n> > in the case of Taproot. For those addresses, I have defined a signature\n> > format that has 1 byte header/recID, 64 bytes signature, and 32 bytes x\n> > coordinate of a public key. This is required to run the BIP340 Schnorr\n> > verify algorithm using only the signature - and the header byte is added\n> > for backwards compatibility. Otherwise, it completely integrates BIP137\n> > signatures.\n> >\n> > I am planning to move that format to its own BIP as soon as possible, in\n> > lieu that it is unacceptable to define formats in an Informational BIP.\n> >\n> > Please leave your comments in this mailing list. CC'ing BIP editors.\n> >\n> > - Ali\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Luke Dashjr",
                "date": "2022-08-05T06:51:52",
                "message_text_only": "On Friday 05 August 2022 04:05:56 Ali Sherief wrote:\n> Yeah, I have a specific reason to advance this first (emphasis on the word\n> first).\n>\n> I briefly mentioned in the BIP that BIP322 has superior message\n> verification capabilities. This is true, but it suffers from the drawback\n> that wallets are not using it.\n\nLikely because it is a draft and incomplete.\n\n> Message signatures are highly relied upon in some places (just to name a\n> few, at many mining pools e.g. Slushpool, and the Bitcointalk forum), \n\nI'm not aware of any using the current message signatures _correctly_.\nNote they are not useful for proving that you sent a transaction, nor have the \nability to send a transaction or access to bitcoins.\n\n> This BIP is kind of like a \"bumper car\", in that it forces compliance with\n> previous BIPs that extend the message signing format, in particular BIP137.\n\nBIPs can't force anything, they're just documentation.\n\nIMO, there is no benefit to an additional message signing standard, especially \none that doesn't address the problems with the current standard or (at \npresent) BIP322.\n\nLuke"
            },
            {
                "author": "Ali Sherief",
                "date": "2022-08-05T07:39:38",
                "message_text_only": "> IMO, there is no benefit to an additional message signing standard, especially\n> one that doesn't address the problems with the current standard or (at\n> present) BIP322.\n\nIn that case, I propose the following:\n\n- I scrap the Taproot/Schorr and the two extensions inside the BIP, which will leave it with only parts and formats which have already been standardized (effectively, the legacy and segwit addresses).\n\nBecause here's the thing: The reason why wallets are not implementing sign/verify correctly is because there is no reference manual for doing so. This informational BIP is supposed to solve that problem by providing only a list of instructions for computing ECSDA sign/verify correctly.\n\nAlso, it is not visible right now, but there will also be a reference implementation so that wallet developers can actually code them correctly, as you've stated.\n\n- Ali\n\nOn Fri, Aug 5, 2022 at 9:51 AM, Luke Dashjr <luke at dashjr.org> wrote:\n\n> On Friday 05 August 2022 04:05:56 Ali Sherief wrote:\n>> Yeah, I have a specific reason to advance this first (emphasis on the word\n>> first).\n>>\n>> I briefly mentioned in the BIP that BIP322 has superior message\n>> verification capabilities. This is true, but it suffers from the drawback\n>> that wallets are not using it.\n>\n> Likely because it is a draft and incomplete.\n>\n>> Message signatures are highly relied upon in some places (just to name a\n>> few, at many mining pools e.g. Slushpool, and the Bitcointalk forum),\n>\n> I'm not aware of any using the current message signatures _correctly_.\n> Note they are not useful for proving that you sent a transaction, nor have the\n> ability to send a transaction or access to bitcoins.\n>\n>> This BIP is kind of like a \"bumper car\", in that it forces compliance with\n>> previous BIPs that extend the message signing format, in particular BIP137.\n>\n> BIPs can't force anything, they're just documentation.\n>\n> IMO, there is no benefit to an additional message signing standard, especially\n> one that doesn't address the problems with the current standard or (at\n> present) BIP322.\n>\n> Luke\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220805/bc680629/attachment.html>"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2022-08-05T09:12:20",
                "message_text_only": "Hi Ali!\n\nNice work. Since it seems this is a strict superset of BIP137, why not just\nfocus on things that you are adding (Taproot) while saying your BIP is an\nexpansion of BIP137?\n\nYour approach make it unnecessarily hard to figure out whether you are\nchanging anything in handling of ECDSA signature types or not. If it was\nclearly stated you are just expanding BIP137 and removes everything that\u2019s\nalready described in BIP137, it would be much more obvious to everyone.\n\n\nOn Thu 4. 8. 2022 at 17:49, Ali Sherief via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi,\n>\n> I have created a new BIP, called notatether-signedmessage. It can be\n> viewed at\n> https://github.com/ZenulAbidin/bips/blob/master/bip-notatether-signedmessage.mediawiki\n> .\n>\n> For those who want a quick summary, it defines a step-by-step process for\n> signing and verifying messages from legacy, native/nested segwit, and\n> taproot addresses. It does not define a new signature format itself, except\n> in the case of Taproot. For those addresses, I have defined a signature\n> format that has 1 byte header/recID, 64 bytes signature, and 32 bytes x\n> coordinate of a public key. This is required to run the BIP340 Schnorr\n> verify algorithm using only the signature - and the header byte is added\n> for backwards compatibility. Otherwise, it completely integrates BIP137\n> signatures.\n>\n> I am planning to move that format to its own BIP as soon as possible, in\n> lieu that it is unacceptable to define formats in an Informational BIP.\n>\n> Please leave your comments in this mailing list. CC'ing BIP editors.\n>\n> - Ali\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-- \nBest Regards / S pozdravom,\n\nPavol \"stick\" Rusnak\nCo-Founder, SatoshiLabs\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220805/a38c1a1d/attachment-0001.html>"
            },
            {
                "author": "Ali Sherief",
                "date": "2022-08-05T10:52:41",
                "message_text_only": "That's actually a good idea. Perhaps I can move the algorithms (of BIP137) and stuff to Bitcoin Wiki, and then convert the BIP to strictly a \"Taproot message signing BIP\".\n\nEven though I already know the chances of such a BIP being numbered is low, at least the most important part will be accomplished already (get everybody to use BIP137, and later once BIP322 is finished make people use that).\n\nI ultimately prefer that everyone should use BIP322 eventually, though it should have some kind of RFC2440-like format for maximum user-friendliness. Perhaps bit by bit, the message sanitization can be introduced as well.\n\n- Ali\n\nOn Fri, Aug 5, 2022 at 12:12 PM, Pavol Rusnak <stick at satoshilabs.com> wrote:\n\n> Hi Ali!\n>\n> Nice work. Since it seems this is a strict superset of BIP137, why not just focus on things that you are adding (Taproot) while saying your BIP is an expansion of BIP137?\n>\n> Your approach make it unnecessarily hard to figure out whether you are changing anything in handling of ECDSA signature types or not. If it was clearly stated you are just expanding BIP137 and removes everything that\u2019s already described in BIP137, it would be much more obvious to everyone.\n>\n> On Thu 4. 8. 2022 at 17:49, Ali Sherief via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi,\n>>\n>> I have created a new BIP, called notatether-signedmessage. It can be viewed at https://github.com/ZenulAbidin/bips/blob/master/bip-notatether-signedmessage.mediawiki.\n>>\n>> For those who want a quick summary, it defines a step-by-step process for signing and verifying messages from legacy, native/nested segwit, and taproot addresses. It does not define a new signature format itself, except in the case of Taproot. For those addresses, I have defined a signature format that has 1 byte header/recID, 64 bytes signature, and 32 bytes x coordinate of a public key. This is required to run the BIP340 Schnorr verify algorithm using only the signature - and the header byte is added for backwards compatibility. Otherwise, it completely integrates BIP137 signatures.\n>>\n>> I am planning to move that format to its own BIP as soon as possible, in lieu that it is unacceptable to define formats in an Informational BIP.\n>>\n>> Please leave your comments in this mailing list. CC'ing BIP editors.\n>>\n>> - Ali\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> --\n>\n> Best Regards / S pozdravom,\n>\n> Pavol \"stick\" Rusnak\n> Co-Founder, SatoshiLabs\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220805/328ff3cb/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP-notatether-signedmessage",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Ali Sherief",
                "Pavol Rusnak",
                "Luke Dashjr",
                "Peter (Coinkite Inc)"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 15913
        }
    },
    {
        "title": "[bitcoin-dev] RBF rules, setting policy defaults in Bitcoin Core and the role of BIPs",
        "thread_messages": [
            {
                "author": "Michael Folkson",
                "date": "2022-08-04T14:54:54",
                "message_text_only": "A short history of RBF and BIP125\n\nThe history of BIP125 is as far as I\u2019m aware this. RBF rules were merged into Bitcoin Core in November 2015 [0]. Following that merge David Harding and Peter Todd drafted a BIP (BIP125 [1]) outlining the RBF rules that had been implemented in Bitcoin Core. The rationales for the rules in the BIP was a bit lacking (in my opinion) but recall this is 2015 (7 years ago!) when L2 protocols were in their infancy. Certainly the research on the security of L2 protocols has come a long way since and we have a much better idea of some of the possible attacks on L2 protocols that to some extent are impacted by policy rules.\n\nIn addition it was discovered [2] in May 2021 that the Bitcoin Core implementation of the RBF rules had never matched the RBF rules outlined in BIP125. Clearly this isn\u2019t ideal but mistakes happen and will continue to happen. I certainly do not intend any criticism whatsoever to any of the individuals involved. Thankfully this discrepancy doesn\u2019t seem to have resulted in any loss of funds or disruption. However, cross checking a specification with an implementation presumably led to the discovery and allowed for a post mortem on why the implementation didn\u2019t match the specification.\n\nThere seems to be two views on what to do next given that the RBF rules need to be updated. One is to ditch the idea of a specification for RBF rules and just document them in the Core repo instead. The other is to have a new specification for the RBF rules in Core and attempt to correct the mistakes made with BIP125 by having a BIP that does correctly outline the RBF rules implemented in Core and includes detailed rationales for why those RBF rules have been implemented.\n\nShould anyone care about where things are documented?\n\nPerhaps not but I think if you are a stakeholder in L2 protocol security you should. Suppose in the long term future an attacker exploits a L2 vulnerability that is based on the default policy set by the dominant implementation on the network (Bitcoin Core). Which would you prefer the norm to be? A detailed static, well reviewed BIP standard that lays out the updated RBF rules and the rationales for those new rules that is reviewed outside the Core repo and hence not just by Core reviewers? Or cross checking Bitcoin Core code with non-standardized Core documentation typically reviewed only by Core reviewers?\n\nFor the same reason the norm for consensus changes is a specification (BIP) and a reference implementation (Bitcoin Core) I think the norm for material step change policy changes should be a specification (BIP) and a reference implementation (Bitcoin Core). Policy is of course less risky than consensus for various reasons including there being no chain split risk if the user changes the default policy of their node. Alternative implementations are free to set entirely different policy rules too. But with L2 protocol security to some extent relying on policy whether we like it or not I think we should aspire to similar standards where possible for policy too.\n\nSpecifications and implementations\n\nThe Bitcoin Core review process generally requires Concept ACKs, Approach ACKs and then code review, testing ACKs in that order. The reason for this is even if the code is perfect if it is implementing a concept or an approach that informed reviewers oppose then it doesn\u2019t matter that the code is perfect. Documentation is generally done post merge if at all. For most PRs e.g. refactors this makes sense. There is no point documenting something in advance if it is still under review or may not get merged. For consensus PRs this clearly doesn\u2019t make sense. Many of us have and continue to cross check the Taproot BIPs with the Taproot reference implementation in Bitcoin Core. Having two points of reference released simultaneously is treating consensus changes with the highest possible standards we can. I think we should strive towards the highest possible standards for step change default policy changes in Core too given L2 protocol security is (unfortunately, ideally this wouldn\u2019t be the case) relying on them.\n\nWhat are the new RBF rules replacing the BIP125 rules?\n\nThe new RBF rules as implemented in Core today are documented here [3] in the Core repo (thanks for the link glozow). To the extent that these are a work in progress or close to final (i.e. intended to be static) I don\u2019t know. The devs who work on policy will have a much better idea on these questions than me. Will the new RBF rules continue to be iterated upon as new research on L2 security comes to light? Will this iteration make it impossible to maintain a static set of rules that the broader ecosystem can get comfortable with? Or is a new static set of RBF rules close to being finalized and there is just an aversion to using BIPs and a specification?\n\nGenerally, as time passes, the ecosystem grows, layers on top of the base layer get built out I get uncomfortable with what I perceive (correctly or incorrectly) as a slip in standards. If anything it should be going in the opposite direction. Standards should be improving and we should be striving to do better and be more rigorous than whatever the standard was in 2015. But I don\u2019t work on policy in Core full time and it is very possible that there are subtleties that I\u2019m entirely missing here. I think this is the right forum to ask about those subtleties though. Thanks to those who work on this important area.\n\n[0]: https://github.com/bitcoin/bitcoin/pull/6871\n\n[1]: https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki\n\n[2]: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-May/018893.html\n\n[3]: https://github.com/bitcoin/bitcoin/blob/master/doc/policy/mempool-replacements.md\n\n--\nMichael Folkson\nEmail: michaelfolkson at [protonmail.com](http://protonmail.com/)\nKeybase: michaelfolkson\nPGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220804/0036ee9e/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-08-04T18:06:34",
                "message_text_only": "On Thu, Aug 04, 2022 at 02:54:54PM +0000, Michael Folkson via bitcoin-dev wrote:\n> A short history of RBF and BIP125\n> \n> The history of BIP125 is as far as I\u2019m aware this. RBF rules were merged into Bitcoin Core in November 2015 [0]. Following that merge David Harding and Peter Todd drafted a BIP (BIP125 [1]) outlining the RBF rules that had been implemented in Bitcoin Core. The rationales for the rules in the BIP was a bit lacking (in my opinion) but recall this is 2015 (7 years ago!) when L2 protocols were in their infancy. Certainly the research on the security of L2 protocols has come a long way since and we have a much better idea of some of the possible attacks on L2 protocols that to some extent are impacted by policy rules.\n> \n> In addition it was discovered [2] in May 2021 that the Bitcoin Core implementation of the RBF rules had never matched the RBF rules outlined in BIP125. Clearly this isn\u2019t ideal but mistakes happen and will continue to happen. I certainly do not intend any criticism whatsoever to any of the individuals involved. Thankfully this discrepancy doesn\u2019t seem to have resulted in any loss of funds or disruption. However, cross checking a specification with an implementation presumably led to the discovery and allowed for a post mortem on why the implementation didn\u2019t match the specification.\n> \n> There seems to be two views on what to do next given that the RBF rules need to be updated. One is to ditch the idea of a specification for RBF rules and just document them in the Core repo instead. The other is to have a new specification for the RBF rules in Core and attempt to correct the mistakes made with BIP125 by having a BIP that does correctly outline the RBF rules implemented in Core and includes detailed rationales for why those RBF rules have been implemented.\n> \n> Should anyone care about where things are documented?\n\nThey really shouldn't.\n\nThe nature of L2 punishment protocols is that transaction relay schemes are\nadditive security: every different way that a punishment tx could get broadcast\nand mined is a different way that the punishment scheme could succeed. We\nshould be thinking about how to add diversity and robustness to this in the\nform of different schemes, rather than trying to specify exactly how we expect\nthese txs to be broadcast. In particular, you have to accept that different\nschemes will exist, and an adversary could use those schems.\n\nFor the near-term, an important part of this is to get package relay and\npackage replacements implemented, to avoid edge-cases in multiple-tx schemes.\nIt'd also be good to specify something entirely different, like a hashcase\nbased broadcast scheme.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220804/20f1b1fa/attachment.sig>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2022-08-04T19:35:13",
                "message_text_only": "Policy is a subjective per-node, not systemic, not enforcable or expectable, \nand generally not eligible for standardization.\n\nThe reason BIP125 is an exception, is because it is more than just policy.\nIt is a way for wallets and nodes to communicate. The wallet is saying \"this \nis the policy I would like you to apply to potential replacements of these \ntransactions\". Whether the nodes abide this request or not, the purpose and \njustification of the BIP is to standardize the communication of it.\n\nSince BIP125 is widely implemented, it should not be changed except for \ncorrections to things which are errors deviating from the original intent.\nIf there is merely a new policy intended to be conveyed, a new BIP should be \nwritten that is distinguishable from BIP125 (perhaps drop the sequence number \nby 1 more). However, unless nodes are going to honour both the BIP125-request \npolicy *and* a new policy, it might be simpler for them to just not honour \nthe requested BIP125 policy exactly.\n\nAlso note that security should NEVER depend on assumptions of node policies. \nDoing so would be a serious security vulnerability, regardless of what actual \nnetwork policies are. It's fine to blame nodes/miners if they single out your \ntransactions, but if it's just a matter of a general policy your transactions \nare failing to meet, that's on the sender/L2 to adapt.\n\nLuke\n\n\nOn Thursday 04 August 2022 14:54:54 Michael Folkson via bitcoin-dev wrote:\n> A short history of RBF and BIP125\n>\n> The history of BIP125 is as far as I\u2019m aware this. RBF rules were merged\n> into Bitcoin Core in November 2015 [0]. Following that merge David Harding\n> and Peter Todd drafted a BIP (BIP125 [1]) outlining the RBF rules that had\n> been implemented in Bitcoin Core. The rationales for the rules in the BIP\n> was a bit lacking (in my opinion) but recall this is 2015 (7 years ago!)\n> when L2 protocols were in their infancy. Certainly the research on the\n> security of L2 protocols has come a long way since and we have a much\n> better idea of some of the possible attacks on L2 protocols that to some\n> extent are impacted by policy rules.\n>\n> In addition it was discovered [2] in May 2021 that the Bitcoin Core\n> implementation of the RBF rules had never matched the RBF rules outlined in\n> BIP125. Clearly this isn\u2019t ideal but mistakes happen and will continue to\n> happen. I certainly do not intend any criticism whatsoever to any of the\n> individuals involved. Thankfully this discrepancy doesn\u2019t seem to have\n> resulted in any loss of funds or disruption. However, cross checking a\n> specification with an implementation presumably led to the discovery and\n> allowed for a post mortem on why the implementation didn\u2019t match the\n> specification.\n>\n> There seems to be two views on what to do next given that the RBF rules\n> need to be updated. One is to ditch the idea of a specification for RBF\n> rules and just document them in the Core repo instead. The other is to have\n> a new specification for the RBF rules in Core and attempt to correct the\n> mistakes made with BIP125 by having a BIP that does correctly outline the\n> RBF rules implemented in Core and includes detailed rationales for why\n> those RBF rules have been implemented.\n>\n> Should anyone care about where things are documented?\n>\n> Perhaps not but I think if you are a stakeholder in L2 protocol security\n> you should. Suppose in the long term future an attacker exploits a L2\n> vulnerability that is based on the default policy set by the dominant\n> implementation on the network (Bitcoin Core). Which would you prefer the\n> norm to be? A detailed static, well reviewed BIP standard that lays out the\n> updated RBF rules and the rationales for those new rules that is reviewed\n> outside the Core repo and hence not just by Core reviewers? Or cross\n> checking Bitcoin Core code with non-standardized Core documentation\n> typically reviewed only by Core reviewers?\n>\n> For the same reason the norm for consensus changes is a specification (BIP)\n> and a reference implementation (Bitcoin Core) I think the norm for material\n> step change policy changes should be a specification (BIP) and a reference\n> implementation (Bitcoin Core). Policy is of course less risky than\n> consensus for various reasons including there being no chain split risk if\n> the user changes the default policy of their node. Alternative\n> implementations are free to set entirely different policy rules too. But\n> with L2 protocol security to some extent relying on policy whether we like\n> it or not I think we should aspire to similar standards where possible for\n> policy too.\n>\n> Specifications and implementations\n>\n> The Bitcoin Core review process generally requires Concept ACKs, Approach\n> ACKs and then code review, testing ACKs in that order. The reason for this\n> is even if the code is perfect if it is implementing a concept or an\n> approach that informed reviewers oppose then it doesn\u2019t matter that the\n> code is perfect. Documentation is generally done post merge if at all. For\n> most PRs e.g. refactors this makes sense. There is no point documenting\n> something in advance if it is still under review or may not get merged. For\n> consensus PRs this clearly doesn\u2019t make sense. Many of us have and continue\n> to cross check the Taproot BIPs with the Taproot reference implementation\n> in Bitcoin Core. Having two points of reference released simultaneously is\n> treating consensus changes with the highest possible standards we can. I\n> think we should strive towards the highest possible standards for step\n> change default policy changes in Core too given L2 protocol security is\n> (unfortunately, ideally this wouldn\u2019t be the case) relying on them.\n>\n> What are the new RBF rules replacing the BIP125 rules?\n>\n> The new RBF rules as implemented in Core today are documented here [3] in\n> the Core repo (thanks for the link glozow). To the extent that these are a\n> work in progress or close to final (i.e. intended to be static) I don\u2019t\n> know. The devs who work on policy will have a much better idea on these\n> questions than me. Will the new RBF rules continue to be iterated upon as\n> new research on L2 security comes to light? Will this iteration make it\n> impossible to maintain a static set of rules that the broader ecosystem can\n> get comfortable with? Or is a new static set of RBF rules close to being\n> finalized and there is just an aversion to using BIPs and a specification?\n>\n> Generally, as time passes, the ecosystem grows, layers on top of the base\n> layer get built out I get uncomfortable with what I perceive (correctly or\n> incorrectly) as a slip in standards. If anything it should be going in the\n> opposite direction. Standards should be improving and we should be striving\n> to do better and be more rigorous than whatever the standard was in 2015.\n> But I don\u2019t work on policy in Core full time and it is very possible that\n> there are subtleties that I\u2019m entirely missing here. I think this is the\n> right forum to ask about those subtleties though. Thanks to those who work\n> on this important area.\n>\n> [0]: https://github.com/bitcoin/bitcoin/pull/6871\n>\n> [1]: https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki\n>\n> [2]:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-May/018893.htm\n>l\n>\n> [3]:\n> https://github.com/bitcoin/bitcoin/blob/master/doc/policy/mempool-replaceme\n>nts.md\n>\n> --\n> Michael Folkson\n> Email: michaelfolkson at [protonmail.com](http://protonmail.com/)\n> Keybase: michaelfolkson\n> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3"
            },
            {
                "author": "Michael Folkson",
                "date": "2022-08-04T21:47:08",
                "message_text_only": "Thanks for this Luke.\n\n> Since BIP125 is widely implemented, it should not be changed except for corrections to things which are errors deviating from the original intent.\n\nIn this example the BIP125/RBF rules implemented in Core are (and always have been) different to the rules as described in BIP125. As far as I know other implementations have also followed how it is implemented in Core rather than as described in BIP125. So we have the BIP125 rules, BIP125/RBF as implemented in Core and future intended changes to how RBF rules are implemented in Core which may or may not also be in a state of flux. I take the view that once those new RBF rules are \"finalized\" there should be a new BIP but others disagree.\n\n> Also note that security should NEVER depend on assumptions of node policies. Doing so would be a serious security vulnerability, regardless of what actual network policies are.\n\nYou regularly state this and of course you're right. I tried to allude that it is far from ideal that L2 security is impacted by default policy rules to any extent in my post. But if it is a matter of fact that default policy rules impact the viability of some L2 protocol attacks today what should one do when setting default policy rules in the dominant implementation on the network? I think you lean towards not factoring that in whatsoever to decisions on default policy rules whereas (perhaps mistakenly) I lean towards factoring that in to default policy rule decisions especially when there don't seem to be many other factors to consider. In the case of Lightning Network I think we both want it to succeed and hopefully in the long term default policy rules will have no impact on its security whatsoever. But today that seems to not be the case.\n\n--\nMichael Folkson\nEmail: michaelfolkson at protonmail.com\nKeybase: michaelfolkson\nPGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3\n\n\n------- Original Message -------\nOn Thursday, August 4th, 2022 at 20:35, Luke Dashjr <luke at dashjr.org> wrote:\n\n\n> Policy is a subjective per-node, not systemic, not enforcable or expectable,\n> and generally not eligible for standardization.\n>\n> The reason BIP125 is an exception, is because it is more than just policy.\n> It is a way for wallets and nodes to communicate. The wallet is saying \"this\n> is the policy I would like you to apply to potential replacements of these\n> transactions\". Whether the nodes abide this request or not, the purpose and\n> justification of the BIP is to standardize the communication of it.\n>\n> Since BIP125 is widely implemented, it should not be changed except for\n> corrections to things which are errors deviating from the original intent.\n> If there is merely a new policy intended to be conveyed, a new BIP should be\n> written that is distinguishable from BIP125 (perhaps drop the sequence number\n> by 1 more). However, unless nodes are going to honour both the BIP125-request\n> policy and a new policy, it might be simpler for them to just not honour\n> the requested BIP125 policy exactly.\n>\n> Also note that security should NEVER depend on assumptions of node policies.\n> Doing so would be a serious security vulnerability, regardless of what actual\n> network policies are. It's fine to blame nodes/miners if they single out your\n> transactions, but if it's just a matter of a general policy your transactions\n> are failing to meet, that's on the sender/L2 to adapt.\n>\n> Luke\n>\n>\n> On Thursday 04 August 2022 14:54:54 Michael Folkson via bitcoin-dev wrote:\n>\n> > A short history of RBF and BIP125\n> >\n> > The history of BIP125 is as far as I\u2019m aware this. RBF rules were merged\n> > into Bitcoin Core in November 2015 0. Following that merge David Harding\n> > and Peter Todd drafted a BIP (BIP125 1) outlining the RBF rules that had\n> > been implemented in Bitcoin Core. The rationales for the rules in the BIP\n> > was a bit lacking (in my opinion) but recall this is 2015 (7 years ago!)\n> > when L2 protocols were in their infancy. Certainly the research on the\n> > security of L2 protocols has come a long way since and we have a much\n> > better idea of some of the possible attacks on L2 protocols that to some\n> > extent are impacted by policy rules.\n> >\n> > In addition it was discovered 2 in May 2021 that the Bitcoin Core\n> > implementation of the RBF rules had never matched the RBF rules outlined in\n> > BIP125. Clearly this isn\u2019t ideal but mistakes happen and will continue to\n> > happen. I certainly do not intend any criticism whatsoever to any of the\n> > individuals involved. Thankfully this discrepancy doesn\u2019t seem to have\n> > resulted in any loss of funds or disruption. However, cross checking a\n> > specification with an implementation presumably led to the discovery and\n> > allowed for a post mortem on why the implementation didn\u2019t match the\n> > specification.\n> >\n> > There seems to be two views on what to do next given that the RBF rules\n> > need to be updated. One is to ditch the idea of a specification for RBF\n> > rules and just document them in the Core repo instead. The other is to have\n> > a new specification for the RBF rules in Core and attempt to correct the\n> > mistakes made with BIP125 by having a BIP that does correctly outline the\n> > RBF rules implemented in Core and includes detailed rationales for why\n> > those RBF rules have been implemented.\n> >\n> > Should anyone care about where things are documented?\n> >\n> > Perhaps not but I think if you are a stakeholder in L2 protocol security\n> > you should. Suppose in the long term future an attacker exploits a L2\n> > vulnerability that is based on the default policy set by the dominant\n> > implementation on the network (Bitcoin Core). Which would you prefer the\n> > norm to be? A detailed static, well reviewed BIP standard that lays out the\n> > updated RBF rules and the rationales for those new rules that is reviewed\n> > outside the Core repo and hence not just by Core reviewers? Or cross\n> > checking Bitcoin Core code with non-standardized Core documentation\n> > typically reviewed only by Core reviewers?\n> >\n> > For the same reason the norm for consensus changes is a specification (BIP)\n> > and a reference implementation (Bitcoin Core) I think the norm for material\n> > step change policy changes should be a specification (BIP) and a reference\n> > implementation (Bitcoin Core). Policy is of course less risky than\n> > consensus for various reasons including there being no chain split risk if\n> > the user changes the default policy of their node. Alternative\n> > implementations are free to set entirely different policy rules too. But\n> > with L2 protocol security to some extent relying on policy whether we like\n> > it or not I think we should aspire to similar standards where possible for\n> > policy too.\n> >\n> > Specifications and implementations\n> >\n> > The Bitcoin Core review process generally requires Concept ACKs, Approach\n> > ACKs and then code review, testing ACKs in that order. The reason for this\n> > is even if the code is perfect if it is implementing a concept or an\n> > approach that informed reviewers oppose then it doesn\u2019t matter that the\n> > code is perfect. Documentation is generally done post merge if at all. For\n> > most PRs e.g. refactors this makes sense. There is no point documenting\n> > something in advance if it is still under review or may not get merged. For\n> > consensus PRs this clearly doesn\u2019t make sense. Many of us have and continue\n> > to cross check the Taproot BIPs with the Taproot reference implementation\n> > in Bitcoin Core. Having two points of reference released simultaneously is\n> > treating consensus changes with the highest possible standards we can. I\n> > think we should strive towards the highest possible standards for step\n> > change default policy changes in Core too given L2 protocol security is\n> > (unfortunately, ideally this wouldn\u2019t be the case) relying on them.\n> >\n> > What are the new RBF rules replacing the BIP125 rules?\n> >\n> > The new RBF rules as implemented in Core today are documented here 3 in\n> > the Core repo (thanks for the link glozow). To the extent that these are a\n> > work in progress or close to final (i.e. intended to be static) I don\u2019t\n> > know. The devs who work on policy will have a much better idea on these\n> > questions than me. Will the new RBF rules continue to be iterated upon as\n> > new research on L2 security comes to light? Will this iteration make it\n> > impossible to maintain a static set of rules that the broader ecosystem can\n> > get comfortable with? Or is a new static set of RBF rules close to being\n> > finalized and there is just an aversion to using BIPs and a specification?\n> >\n> > Generally, as time passes, the ecosystem grows, layers on top of the base\n> > layer get built out I get uncomfortable with what I perceive (correctly or\n> > incorrectly) as a slip in standards. If anything it should be going in the\n> > opposite direction. Standards should be improving and we should be striving\n> > to do better and be more rigorous than whatever the standard was in 2015.\n> > But I don\u2019t work on policy in Core full time and it is very possible that\n> > there are subtleties that I\u2019m entirely missing here. I think this is the\n> > right forum to ask about those subtleties though. Thanks to those who work\n> > on this important area.\n> >\n> > l\n> >\n> > nts.md\n> >\n> > --\n> > Michael Folkson\n> > Email: michaelfolkson at protonmail.com\n> > Keybase: michaelfolkson\n> > PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3"
            }
        ],
        "thread_summary": {
            "title": "RBF rules, setting policy defaults in Bitcoin Core and the role of BIPs",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Luke Dashjr",
                "Michael Folkson",
                "Peter Todd"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 26177
        }
    },
    {
        "title": "[bitcoin-dev] BIP-notatether-signedmessage (appendix)",
        "thread_messages": [
            {
                "author": "Ali Sherief",
                "date": "2022-08-05T07:50:17",
                "message_text_only": "Also, I forgot to write in the previous message, that this BIP is not a standard - that's the reason I raised the N+1 problem in the first place. As mentioned previously, it's strictly limited to a reference manual - which could've been hosted anywhere else (such as my own website), but these instructions ought to be made official.\n\n- Ali\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220805/e37472b7/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP-notatether-signedmessage (appendix)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Ali Sherief"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 523
        }
    },
    {
        "title": "[bitcoin-dev] P2P trading replacement transactions",
        "thread_messages": [
            {
                "author": "alicexbt",
                "date": "2022-08-05T14:44:52",
                "message_text_only": "Hi Bitcoin Developers,\n\nDoes it make sense to trade replacement transactions for privacy? I have shared basic details to implement this and would love to read opinions about it or ways to improve it:\n\n=============================\nalice\n=============================\n\ntx1: input a (0.01) -> output b1 (0.008)\n-> change c1 (0.001)\n\ntx2: input a (0.01) -> output e2 (0.007)\n-> output f2 (0.001)\n\n=============================\n\nbob\n=============================\n\ntx1: input d (0.011) -> output e1 (0.007)\n-> change f1 (0.003)\n\ntx2: input d (0.011) -> output b2 (0.008)\n-> output c2 (0.001)\n\n=============================\n\ncarol\n=============================\n\n- creates an API to manage trades that will use 2 of 3 multisig\n- alice and bob create orders for replacement\n- either they could be matched automatically using some algorithm or bob manually accepts the offer\n- 2 of 3 multisig is created with Alice, Bob and Carol keys\n- bob locks 0.01 BTC in it and shares outputs e2,f2 with alice\n- alice signs tx2 and shares tx with bob\n- alice locks 0.011 BTC in it and shares outputs b2,c2 with bob\n- bob signs tx2 and shares with alice\n- both replacement txs can be broadcasted\n- funds are released from 2 of 3 multisig with a tx having 3 outputs (one to pay fee which goes to carol)\n\npositives:\n\n- privacy\n\nnegatives:\n\n- extra fees\n- will take some time although everything will be managed by wallet with API provided by carol\n- need to lock bitcoin with same amount as used in tx1\n- amounts could still be used to link txs in some cases- carol and other peer knows the details\n\n/dev/fd0\n\nSent with [Proton Mail](https://proton.me/) secure email.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220805/f3f782bd/attachment.html>"
            },
            {
                "author": "Michael Folkson",
                "date": "2022-08-06T12:55:49",
                "message_text_only": "Hi alicexbt\n\nWhat do you mean by \"replacement transaction\"? Replacing or swapping outputs with a counterparty's?\n\nI guess I'm struggling to understand exactly what you are attempting to achieve here with regards to privacy and if this additional protocol complexity is worth it. Recall a 2 (or n) party coinjoin would get you an output where it isn't clear to blockchain observers which output you control and a coinswap [0] would have you taking the coin history of your counterparty. What does this scheme offer with regards to privacy that those don't? This seems to have more complexity too though I maybe misunderstanding something.\n\nThanks\nMichael\n\n[0]: https://bitcoinops.org/en/topics/coinswap/\n\n--\nMichael Folkson\nEmail: michaelfolkson at [protonmail.com](http://protonmail.com/)\nKeybase: michaelfolkson\nPGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3\n\n------- Original Message -------\nOn Friday, August 5th, 2022 at 15:44, alicexbt via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi Bitcoin Developers,\n>\n> Does it make sense to trade replacement transactions for privacy? I have shared basic details to implement this and would love to read opinions about it or ways to improve it:\n>\n> =============================\n> alice\n> =============================\n>\n> tx1: input a (0.01) -> output b1 (0.008)\n> -> change c1 (0.001)\n>\n> tx2: input a (0.01) -> output e2 (0.007)\n> -> output f2 (0.001)\n>\n> =============================\n>\n> bob\n> =============================\n>\n> tx1: input d (0.011) -> output e1 (0.007)\n> -> change f1 (0.003)\n>\n> tx2: input d (0.011) -> output b2 (0.008)\n> -> output c2 (0.001)\n>\n> =============================\n>\n> carol\n> =============================\n>\n> - creates an API to manage trades that will use 2 of 3 multisig\n> - alice and bob create orders for replacement\n> - either they could be matched automatically using some algorithm or bob manually accepts the offer\n> - 2 of 3 multisig is created with Alice, Bob and Carol keys\n> - bob locks 0.01 BTC in it and shares outputs e2,f2 with alice\n> - alice signs tx2 and shares tx with bob\n> - alice locks 0.011 BTC in it and shares outputs b2,c2 with bob\n> - bob signs tx2 and shares with alice\n> - both replacement txs can be broadcasted\n> - funds are released from 2 of 3 multisig with a tx having 3 outputs (one to pay fee which goes to carol)\n>\n> positives:\n>\n> - privacy\n>\n> negatives:\n>\n> - extra fees\n> - will take some time although everything will be managed by wallet with API provided by carol\n> - need to lock bitcoin with same amount as used in tx1\n> - amounts could still be used to link txs in some cases- carol and other peer knows the details\n>\n> /dev/fd0\n>\n> Sent with [Proton Mail](https://proton.me/) secure email.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220806/efb828d3/attachment.html>"
            },
            {
                "author": "alicexbt",
                "date": "2022-08-06T14:11:34",
                "message_text_only": "Hi Michael,\n\n\n> What do you mean by \"replacement transaction\"? Replacing or swapping outputs with a counterparty's?\n\nUser broadcasts tx1 which is in mempool, wants to replace transaction with higher fee rate however changes outputs and they are replaced with counterparty's outputs in tx2.\n\n\n> I guess I'm struggling to understand exactly what you are attempting to achieve here with regards to privacy and if this additional protocol complexity is worth it. Recall a 2 (or n) party coinjoin would get you an output where it isn't clear to blockchain observers which output you control and a coinswap [0] would have you taking the coin history of your counterparty. What does this scheme offer with regards to privacy that those don't? This seems to have more complexity too though I maybe misunderstanding something.\n\nCoinjoin and Coinswap offer different levels of privacy. This method just aims to break the assumption that tx2 (replacement transaction) is done to use a higher fee rate with same sender and recipient. It looks complex in the way I wrote in the last email or maybe because of implementation details although UX will be simple and something like this:\n\n- user sends bitcoin in tx1 which is unconfirmed\n- tries to bump fee\n- wallet offer an extra privacy option\n- if user selects it, everything happens in the background and user just needs to approve in between\n- user broadcasts tx2 to replace tx1 which has outputs shared by counterparty\n- counterparty does the same for this user\n\nIf this method makes sense or we have a similar market to trade replacements in future, it could be helpful in creating a process in which a chain of replacements happen before bitcoin reaches the destination similar to tor circuit.\n\nExample:\n\n- tx1 enters a pool\n- gets replaced by tx2 (different outputs)\n- tx3 replaces tx2 (different outputs)\n\nWe could look at the logs and see tx3 originated at tx1 but no clue if original recipient received it in the end. There would be normal replacements done by other users so it would make analysis difficult.\n\n\n/dev/fd0\n\nSent with Proton Mail secure email.\n\n------- Original Message -------\nOn Saturday, August 6th, 2022 at 6:25 PM, Michael Folkson <michaelfolkson at protonmail.com> wrote:\n\n\n> Hi alicexbt\n>\n> What do you mean by \"replacement transaction\"? Replacing or swapping outputs with a counterparty's?\n>\n> I guess I'm struggling to understand exactly what you are attempting to achieve here with regards to privacy and if this additional protocol complexity is worth it. Recall a 2 (or n) party coinjoin would get you an output where it isn't clear to blockchain observers which output you control and a coinswap [0] would have you taking the coin history of your counterparty. What does this scheme offer with regards to privacy that those don't? This seems to have more complexity too though I maybe misunderstanding something.\n>\n> Thanks\n> Michael\n>\n> [0]:\u00a0https://bitcoinops.org/en/topics/coinswap/\n>\n> --\n> Michael Folkson\n> Email: michaelfolkson at protonmail.com\n> Keybase: michaelfolkson\n> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3\n>\n>\n> ------- Original Message -------\n> On Friday, August 5th, 2022 at 15:44, alicexbt via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>\n> > Hi Bitcoin Developers,\n> >\n> >\n> > Does it make sense to trade replacement transactions for privacy? I have shared basic details to implement this and would love to read opinions about it or ways to improve it:\n> >\n> >\n> > =============================\n> > alice=============================\n> >\n> > tx1: input a (0.01) -> output b1 (0.008)\n> > \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0-> change c1 (0.001)\n> >\n> > tx2: input a (0.01) -> output e2 (0.007)\n> > \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0-> output f2 (0.001)\n> >\n> >\n> > =============================\n> >\n> > bob\n> > =============================\n> >\n> >\n> > tx1: input d (0.011) -> output e1 (0.007)\n> > \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 -> change f1 (0.003)\n> >\n> > tx2: input d (0.011) -> output b2 (0.008)\n> > \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0-> output c2 (0.001)\n> >\n> >\n> > =============================\n> >\n> > carol\n> > =============================\n> >\n> >\n> > - creates an API to manage trades that will use 2 of 3 multisig\n> > - alice and bob create orders for replacement\n> > - either they could be matched automatically using some algorithm or bob manually accepts the offer\n> > - 2 of 3 multisig is created with Alice, Bob and Carol keys\n> > - bob locks 0.01 BTC in it and shares outputs e2,f2 with alice\n> > - alice signs tx2 and shares tx with bob\n> > - alice locks 0.011 BTC in it and shares outputs b2,c2 with bob\n> > - bob signs tx2 and shares with alice\n> > - both replacement txs can be broadcasted\n> > - funds are released from 2 of 3 multisig with a tx having 3 outputs (one to pay fee which goes to carol)\n> >\n> >\n> >\n> > positives:\n> >\n> > - privacy\n> >\n> > negatives:\n> >\n> > - extra fees\n> > - will take some time although everything will be managed by wallet with API provided by carol\n> > - need to lock bitcoin with same amount as used in tx1\n> > - amounts could still be used to link txs in some cases\n> > - carol and other peer knows the details\n> >\n> >\n> >\n> >\n> > /dev/fd0\n> >\n> >\n> >\n> >\n> > Sent with Proton Mail secure email."
            },
            {
                "author": "Ali Sherief",
                "date": "2022-08-06T14:16:08",
                "message_text_only": "It would probably only work out if each output got their own private keys, since otherwise Alice can't share any outputs with Bob and vice versa.\n\nThe whole thing sounds like an HTLC with an additional trading of private keys for the actual trades instead of in the HLTC. How are they going to share their private keys securely, with PGP?\n\nPerhaps Taproot with its selective revealing of certain script branches can help here, but I'm not sure about details.\n\n- Ali\n\n> Hi Bitcoin Developers,\n>\n> Does it make sense to trade replacement transactions for privacy? I have shared basic details to implement this and would love to read opinions about it or ways to improve it:\n>\n> =============================\n> alice\n> =============================\n>\n> tx1: input a (0.01) -> output b1 (0.008)\n> -> change c1 (0.001)\n>\n> tx2: input a (0.01) -> output e2 (0.007)\n> -> output f2 (0.001)\n>\n> =============================\n>\n> bob\n> =============================\n>\n> tx1: input d (0.011) -> output e1 (0.007)\n> -> change f1 (0.003)\n>\n> tx2: input d (0.011) -> output b2 (0.008)\n> -> output c2 (0.001)\n>\n> =============================\n>\n> carol\n> =============================\n>\n> - creates an API to manage trades that will use 2 of 3 multisig\n> - alice and bob create orders for replacement\n> - either they could be matched automatically using some algorithm or bob manually accepts the offer\n> - 2 of 3 multisig is created with Alice, Bob and Carol keys\n> - bob locks 0.01 BTC in it and shares outputs e2,f2 with alice\n> - alice signs tx2 and shares tx with bob\n> - alice locks 0.011 BTC in it and shares outputs b2,c2 with bob\n> - bob signs tx2 and shares with alice\n> - both replacement txs can be broadcasted\n> - funds are released from 2 of 3 multisig with a tx having 3 outputs (one to pay fee which goes to carol)\n>\n> positives:\n>\n> - privacy\n>\n> negatives:\n>\n> - extra fees\n> - will take some time although everything will be managed by wallet with API provided by carol\n> - need to lock bitcoin with same amount as used in tx1\n> - amounts could still be used to link txs in some cases- carol and other peer knows the details\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220806/40970fa9/attachment.html>"
            },
            {
                "author": "alicexbt",
                "date": "2022-08-08T13:12:44",
                "message_text_only": "Hi Ali,\n\n> It would probably only work out if each output got their own private keys, since otherwise Alice can't share any outputs with Bob and vice versa.\n> The whole thing sounds like an HTLC with an additional trading of private keys for the actual trades instead of in the HLTC. How are they going to share their private keys securely, with PGP?\n\nAlice and Bob can share outputs and these are swapped in the replacement transactions. A 2of3 multisig and Carol is required so that nobody cheats. Trading of private keys is not required. I have explained things in a different way in my [last email][1] sent to Michael Folkson.\n\n[1]: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-August/020841.html\n\n/dev/fd0\n\nSent with Proton Mail secure email.\n\n------- Original Message -------\nOn Saturday, August 6th, 2022 at 7:46 PM, Ali Sherief <ali at notatether.com> wrote:\n\n\n> It would probably only work out if each output got their own private keys, since otherwise Alice can't share any outputs with Bob and vice versa.\n>\n> The whole thing sounds like an HTLC with an additional trading of private keys for the actual trades instead of in the HLTC. How are they going to share their private keys securely, with PGP?\n> Perhaps Taproot with its selective revealing of certain script branches can help here, but I'm not sure about details.\n> - Ali\n>\n>\n> > Hi Bitcoin Developers,\n> >\n> > Does it make sense to trade replacement transactions for privacy? I have shared basic details to implement this and would love to read opinions about it or ways to improve it:\n> >\n> > =============================\n> > alice\n> > =============================\n> >\n> > tx1: input a (0.01) -> output b1 (0.008)\n> > -> change c1 (0.001)\n> >\n> > tx2: input a (0.01) -> output e2 (0.007)\n> > -> output f2 (0.001)\n> >\n> > =============================\n> >\n> > bob\n> > =============================\n> >\n> > tx1: input d (0.011) -> output e1 (0.007)\n> > -> change f1 (0.003)\n> >\n> > tx2: input d (0.011) -> output b2 (0.008)\n> > -> output c2 (0.001)\n> >\n> > =============================\n> >\n> > carol\n> > =============================\n> >\n> > - creates an API to manage trades that will use 2 of 3 multisig\n> > - alice and bob create orders for replacement\n> > - either they could be matched automatically using some algorithm or bob manually accepts the offer\n> > - 2 of 3 multisig is created with Alice, Bob and Carol keys\n> > - bob locks 0.01 BTC in it and shares outputs e2,f2 with alice\n> > - alice signs tx2 and shares tx with bob\n> > - alice locks 0.011 BTC in it and shares outputs b2,c2 with bob\n> > - bob signs tx2 and shares with alice\n> > - both replacement txs can be broadcasted\n> > - funds are released from 2 of 3 multisig with a tx having 3 outputs (one to pay fee which goes to carol)\n> >\n> > positives:\n> >\n> > - privacy\n> >\n> > negatives:\n> >\n> > - extra fees\n> > - will take some time although everything will be managed by wallet with API provided by carol\n> > - need to lock bitcoin with same amount as used in tx1\n> > - amounts could still be used to link txs in some cases- carol and other peer knows the details\n>\n>\n>"
            }
        ],
        "thread_summary": {
            "title": "P2P trading replacement transactions",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Ali Sherief",
                "alicexbt",
                "Michael Folkson"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 15469
        }
    },
    {
        "title": "[bitcoin-dev] Regarding BIP322 edge cases",
        "thread_messages": [
            {
                "author": "Ali Sherief",
                "date": "2022-08-09T13:09:13",
                "message_text_only": "Although there is a Github issue/PR at https://github.com/bitcoin/bips/pull/1347 for addressing all the TODO items of BIP322, I decided to throw it in the mailing list again to see if anyone else has suggestions for dealing with them.\n\nSo in an older copy of the draft at https://github.com/bitcoin/bips/blob/b6b0126e2d04793ba52a40f05d24538fa3f2c9ad/bip-0322.mediawiki , I found the some TODO items, and I will copy-paste the ones in the Specification section (for full proofs) here:\n\n> TODO: How does this interact with as-of-yet-unspecified \"Silent Transactions\"?\n> TODO: Some invalid opcode to allow only in various proof types?\n> TODO: A way for the initial signer to delegate to another scriptPubKey; needed for better privacy and CoinJoin/Lightning compatibility\n\nSo to start with, I believe it will be very helpful to limit what opcodes scriptPubKeys to be elligible to sign from them. The specification already does so to a point, but in order for these to be recognizable, it's my opinion that one of the NOPs should be placed at the beginning of the script to activate proof parsing mode.\n\nOf course, an opcode is not necessary at all, if the program is able to infer from context where the proof is coming from. After all, since they cannot be broadcasted, they can't be mined in blocks, so will never be encountered in a full node's usual verifier. I'm not sure what is to be gained from adding an opcode - the only source for real transactions is from P2P-obtained blocks, so when a human inputs a signature to be verified, it can check that a real transaction is not being inserted by looking for the invalid input.\n\nFor Silent Transactions, I have already given my suggestion in the PR, that some subsection can be made saying that it can operate with them by using its scriptPubKey (and other stuff that may be necessary - I am not excatly sure what goes inside the Witness stack of message_signature).\n\nIn the case of the last TODO, related to delegation to another scriptPubKey, I am not quite sure at the moment what to do about it - perhaps you guys can place a MAST (two Merkle branches, to be specific) - the first branch has the original signer's scriptPubKey, the second branch contains the delegated signer's scriptPubKey.\n\n- Ali"
            },
            {
                "author": "vjudeu at gazeta.pl",
                "date": "2022-08-10T02:59:46",
                "message_text_only": "> I'm not sure what is to be gained from adding an opcode\n\nBackward compatibility. If we don't have OP_CHECKDATASIG, then it has to be somehow introduced to make it compatible with \"Bitcoin Message\". And we have opcodes like OP_RESERVED, that can be wrapped in OP_IF, then it is \"conditionally valid transaction\". It is also possible to assign some unused opcode, but then it will be more complex, because in Script, those opcodes make transaction invalid, but inside TapScript, those opcodes are defined as OP_SUCCESS, and make things automatically valid.\n\n\nOn 2022-08-09 22:53:34 user Ali Sherief via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Although there is a Github issue/PR at https://github.com/bitcoin/bips/pull/1347 for addressing all the TODO items of BIP322, I decided to throw it in the mailing list again to see if anyone else has suggestions for dealing with them.\n\nSo in an older copy of the draft at https://github.com/bitcoin/bips/blob/b6b0126e2d04793ba52a40f05d24538fa3f2c9ad/bip-0322.mediawiki , I found the some TODO items, and I will copy-paste the ones in the Specification section (for full proofs) here:\n\n> TODO: How does this interact with as-of-yet-unspecified \"Silent Transactions\"?\n> TODO: Some invalid opcode to allow only in various proof types?\n> TODO: A way for the initial signer to delegate to another scriptPubKey; needed for better privacy and CoinJoin/Lightning compatibility\n\nSo to start with, I believe it will be very helpful to limit what opcodes scriptPubKeys to be elligible to sign from them. The specification already does so to a point, but in order for these to be recognizable, it's my opinion that one of the NOPs should be placed at the beginning of the script to activate proof parsing mode.\n\nOf course, an opcode is not necessary at all, if the program is able to infer from context where the proof is coming from. After all, since they cannot be broadcasted, they can't be mined in blocks, so will never be encountered in a full node's usual verifier. I'm not sure what is to be gained from adding an opcode - the only source for real transactions is from P2P-obtained blocks, so when a human inputs a signature to be verified, it can check that a real transaction is not being inserted by looking for the invalid input.\n\nFor Silent Transactions, I have already given my suggestion in the PR, that some subsection can be made saying that it can operate with them by using its scriptPubKey (and other stuff that may be necessary - I am not excatly sure what goes inside the Witness stack of message_signature).\n\nIn the case of the last TODO, related to delegation to another scriptPubKey, I am not quite sure at the moment what to do about it - perhaps you guys can place a MAST (two Merkle branches, to be specific) - the first branch has the original signer's scriptPubKey, the second branch contains the delegated signer's scriptPubKey.\n\n- Ali\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Ali Sherief",
                "date": "2022-08-10T13:53:19",
                "message_text_only": "> Backward compatibility. If we don't have OP_CHECKDATASIG, then it has to be somehow introduced to make it compatible with \"Bitcoin Message\".\n\nI suppose in the case of legacy P2PKH signing, a hypothetical OP_CHECKDATASIG can take <signature> <pubkeyhash> off the stack and perform an ECDSA public key recovery, followed by SHA256/RIPEMD160, kind of like a hybrid between OP_DUP/OP_HASH160/OP_EQUALVERIFY and OP_CHECKSIG.\n\nBut the implementations would have to decode the Base58 address into \"0x00\" plus the address hash. As the only supported invoice type for the Legacy signing methods, this should be straight forward to do.\n\n> And we have opcodes like OP_RESERVED, that can be wrapped in OP_IF, then it is \"conditionally valid transaction\".\n\nI'm not sure how an OP_RESERVED in an unexcuted OP_IF is going to help implement an ECDSA pubkey recovery + DUP/HASH160/EQUALVERIFY hybrid instruction.\n\n- Ali\n\nOn Wed, 10 Aug 2022 04:59:46 +0200, vjudeu at gazeta.pl wrote:\n> > I'm not sure what is to be gained from adding an opcode\n>\n> Backward compatibility. If we don't have OP_CHECKDATASIG, then it has to be somehow introduced to make it compatible with \"Bitcoin Message\". And we have opcodes like OP_RESERVED, that can be wrapped in OP_IF, then it is \"conditionally valid transaction\". It is also possible to assign some unused opcode, but then it will be more complex, because in Script, those opcodes make transaction invalid, but inside TapScript, those opcodes are defined as OP_SUCCESS, and make things automatically valid.\n>\n>\n> On 2022-08-09 22:53:34 user Ali Sherief via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > Although there is a Github issue/PR at https://github.com/bitcoin/bips/pull/1347 for addressing all the TODO items of BIP322, I decided to throw it in the mailing list again to see if anyone else has suggestions for dealing with them.\n>\n> So in an older copy of the draft at https://github.com/bitcoin/bips/blob/b6b0126e2d04793ba52a40f05d24538fa3f2c9ad/bip-0322.mediawiki , I found the some TODO items, and I will copy-paste the ones in the Specification section (for full proofs) here:\n>\n> > TODO: How does this interact with as-of-yet-unspecified \"Silent Transactions\"?\n> > TODO: Some invalid opcode to allow only in various proof types?\n> > TODO: A way for the initial signer to delegate to another scriptPubKey; needed for better privacy and CoinJoin/Lightning compatibility\n>\n> So to start with, I believe it will be very helpful to limit what opcodes scriptPubKeys to be elligible to sign from them. The specification already does so to a point, but in order for these to be recognizable, it's my opinion that one of the NOPs should be placed at the beginning of the script to activate proof parsing mode.\n>\n> Of course, an opcode is not necessary at all, if the program is able to infer from context where the proof is coming from. After all, since they cannot be broadcasted, they can't be mined in blocks, so will never be encountered in a full node's usual verifier. I'm not sure what is to be gained from adding an opcode - the only source for real transactions is from P2P-obtained blocks, so when a human inputs a signature to be verified, it can check that a real transaction is not being inserted by looking for the invalid input.\n>\n> For Silent Transactions, I have already given my suggestion in the PR, that some subsection can be made saying that it can operate with them by using its scriptPubKey (and other stuff that may be necessary - I am not excatly sure what goes inside the Witness stack of message_signature).\n>\n> In the case of the last TODO, related to delegation to another scriptPubKey, I am not quite sure at the moment what to do about it - perhaps you guys can place a MAST (two Merkle branches, to be specific) - the first branch has the original signer's scriptPubKey, the second branch contains the delegated signer's scriptPubKey.\n>\n> - Ali"
            },
            {
                "author": "vjudeu at gazeta.pl",
                "date": "2022-08-10T15:05:59",
                "message_text_only": "> I suppose in the case of legacy P2PKH signing, a hypothetical OP_CHECKDATASIG can take <signature> <pubkeyhash> off the stack and perform an ECDSA public key recovery\n\nYou can always perform key recovery for legacy ECDSA: \"<signature> OP_SWAP OP_CHECKSIG\" is always spendable, for any valid <r,s> DER-encoded pair. Here, if \"<signature> <messageHash> <pubkey> OP_CHECKDATASIG\" works for signature verification BIP, then you only need to provide \"<signature>\" as an input, the rest could be placed in some output, and your program could easily compute that. Or you can use \"OP_DUP OP_HASH160 <address> OP_EQUALVERIFY <messageHash> OP_SWAP OP_CHECKDATASIG\" as your output script, then the signer has to provide a valid signature, and a valid public key explicitly, but if you only have some signature, then you can always recover that key by yourself.\n\nBecause if OP_CHECKDATASIG is not handled, then still, signing by scripts can handle that, but the Script would be unnecessarily complex. And because there is no need to introduce OP_CHECKDATASIG on-chain, it can be safely done inside this BIP.\n\n> I'm not sure how an OP_RESERVED in an unexcuted OP_IF is going to help implement an ECDSA pubkey recovery + DUP/HASH160/EQUALVERIFY hybrid instruction.\n\nBecause if you want to support any script, and you want to add a new opcode, you have to make it somehow compatible with existing schemes. You have to assign some byte for OP_CHECKDATASIG or for any new opcodes you want to add. And you don't want to assign just the next free opcode, because you will get OP_CHECKSIGADD or other opcodes from TapScript, so your script decoder will no longer handle two script versions at once. Unless you want to make it also compatible with altcoins like BCH, but I guess it is not needed.\n\n\nOn 2022-08-10 15:53:31 user Ali Sherief <ali at notatether.com> wrote:\n> > Backward compatibility. If we don't have OP_CHECKDATASIG, then it has to be somehow introduced to make it compatible with \"Bitcoin Message\".\n\nI suppose in the case of legacy P2PKH signing, a hypothetical OP_CHECKDATASIG can take <signature> <pubkeyhash> off the stack and perform an ECDSA public key recovery, followed by SHA256/RIPEMD160, kind of like a hybrid between OP_DUP/OP_HASH160/OP_EQUALVERIFY and OP_CHECKSIG.\n\nBut the implementations would have to decode the Base58 address into \"0x00\" plus the address hash. As the only supported invoice type for the Legacy signing methods, this should be straight forward to do.\n\n> And we have opcodes like OP_RESERVED, that can be wrapped in OP_IF, then it is \"conditionally valid transaction\".\n\nI'm not sure how an OP_RESERVED in an unexcuted OP_IF is going to help implement an ECDSA pubkey recovery + DUP/HASH160/EQUALVERIFY hybrid instruction.\n\n- Ali\n\nOn Wed, 10 Aug 2022 04:59:46 +0200, vjudeu at gazeta.pl wrote:\n> > I'm not sure what is to be gained from adding an opcode\n>\n> Backward compatibility. If we don't have OP_CHECKDATASIG, then it has to be somehow introduced to make it compatible with \"Bitcoin Message\". And we have opcodes like OP_RESERVED, that can be wrapped in OP_IF, then it is \"conditionally valid transaction\". It is also possible to assign some unused opcode, but then it will be more complex, because in Script, those opcodes make transaction invalid, but inside TapScript, those opcodes are defined as OP_SUCCESS, and make things automatically valid.\n>\n>\n> On 2022-08-09 22:53:34 user Ali Sherief via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > Although there is a Github issue/PR at https://github.com/bitcoin/bips/pull/1347 for addressing all the TODO items of BIP322, I decided to throw it in the mailing list again to see if anyone else has suggestions for dealing with them.\n>\n> So in an older copy of the draft at https://github.com/bitcoin/bips/blob/b6b0126e2d04793ba52a40f05d24538fa3f2c9ad/bip-0322.mediawiki , I found the some TODO items, and I will copy-paste the ones in the Specification section (for full proofs) here:\n>\n> > TODO: How does this interact with as-of-yet-unspecified \"Silent Transactions\"?\n> > TODO: Some invalid opcode to allow only in various proof types?\n> > TODO: A way for the initial signer to delegate to another scriptPubKey; needed for better privacy and CoinJoin/Lightning compatibility\n>\n> So to start with, I believe it will be very helpful to limit what opcodes scriptPubKeys to be elligible to sign from them. The specification already does so to a point, but in order for these to be recognizable, it's my opinion that one of the NOPs should be placed at the beginning of the script to activate proof parsing mode.\n>\n> Of course, an opcode is not necessary at all, if the program is able to infer from context where the proof is coming from. After all, since they cannot be broadcasted, they can't be mined in blocks, so will never be encountered in a full node's usual verifier. I'm not sure what is to be gained from adding an opcode - the only source for real transactions is from P2P-obtained blocks, so when a human inputs a signature to be verified, it can check that a real transaction is not being inserted by looking for the invalid input.\n>\n> For Silent Transactions, I have already given my suggestion in the PR, that some subsection can be made saying that it can operate with them by using its scriptPubKey (and other stuff that may be necessary - I am not excatly sure what goes inside the Witness stack of message_signature).\n>\n> In the case of the last TODO, related to delegation to another scriptPubKey, I am not quite sure at the moment what to do about it - perhaps you guys can place a MAST (two Merkle branches, to be specific) - the first branch has the original signer's scriptPubKey, the second branch contains the delegated signer's scriptPubKey.\n>\n> - Ali"
            },
            {
                "author": "Ali Sherief",
                "date": "2022-08-10T16:42:10",
                "message_text_only": "Wait a minute. I did some lookup on OP_CHECKDATASIG to see if it's in some btc BIP draft somewhere, and it is actually an opcode in Bitcoin Cash since some years ago - https://mengerian.medium.com/the-story-of-op-checkdatasig-c2b1b38e801a\n\nI think we can safely assume that Kalle and the other major BIP322 proponents do not have BCH script compatibility on a high prioirty, perhaps not even medium prioity, so we should be able to make an opcode called OP_CHECKDATASIG for this BIP's internal purposes.\n\nHowever, a new opcode cannot be created without a lengthy soft-fork (which requires miner signalling - but for what use here, this BIP does not directly impact miners?) with an activation height. If we want to redefine an existing opcode, we must also make a similar soft-fork. Because consensus rules are being modified here.\n\nAt the same time, a message signing/verifying algorithm using Script must implement some way to verify a *single* ECDSA or Schnorr signature that is on the stack. The existing opcodes such as OP_CHECKSIG verify all of the inputs and outputs, and this won't work here since there's a deliberate invalid iput in \"to_spend\".\n\nI tried to research if there is any known use of OP_RESERVED in a script, even if it's only of academic origin, but I unfortunately could not find any references except for https://bitcoin.stackexchange.com/questions/105778/why-were-op-reserved-op-reserved1-and-op-reserved2-originally-reserved .\n\nSo this is now an open problem: How should Script verify a single signature that is on the stack without touching any of the inputs or outputs?\n\n- Ali\n\nOn Wed, Aug 10, 2022 at 05:05:59PM +0200, vjudeu at gazeta.pl wrote:\n> > I suppose in the case of legacy P2PKH signing, a hypothetical OP_CHECKDATASIG can take <signature> <pubkeyhash> off the stack and perform an ECDSA public key recovery\n>\n> You can always perform key recovery for legacy ECDSA: \"<signature> OP_SWAP OP_CHECKSIG\" is always spendable, for any valid <r,s> DER-encoded pair. Here, if \"<signature> <messageHash> <pubkey> OP_CHECKDATASIG\" works for signature verification BIP, then you only need to provide \"<signature>\" as an input, the rest could be placed in some output, and your program could easily compute that. Or you can use \"OP_DUP OP_HASH160 <address> OP_EQUALVERIFY <messageHash> OP_SWAP OP_CHECKDATASIG\" as your output script, then the signer has to provide a valid signature, and a valid public key explicitly, but if you only have some signature, then you can always recover that key by yourself.\n>\n> Because if OP_CHECKDATASIG is not handled, then still, signing by scripts can handle that, but the Script would be unnecessarily complex. And because there is no need to introduce OP_CHECKDATASIG on-chain, it can be safely done inside this BIP.\n>\n> > I'm not sure how an OP_RESERVED in an unexcuted OP_IF is going to help implement an ECDSA pubkey recovery + DUP/HASH160/EQUALVERIFY hybrid instruction.\n>\n> Because if you want to support any script, and you want to add a new opcode, you have to make it somehow compatible with existing schemes. You have to assign some byte for OP_CHECKDATASIG or for any new opcodes you want to add. And you don't want to assign just the next free opcode, because you will get OP_CHECKSIGADD or other opcodes from TapScript, so your script decoder will no longer handle two script versions at once. Unless you want to make it also compatible with altcoins like BCH, but I guess it is not needed.\n>\n>\n> On 2022-08-10 15:53:31 user Ali Sherief <ali at notatether.com> wrote:\n> > > Backward compatibility. If we don't have OP_CHECKDATASIG, then it has to be somehow introduced to make it compatible with \"Bitcoin Message\".\n>\n> I suppose in the case of legacy P2PKH signing, a hypothetical OP_CHECKDATASIG can take <signature> <pubkeyhash> off the stack and perform an ECDSA public key recovery, followed by SHA256/RIPEMD160, kind of like a hybrid between OP_DUP/OP_HASH160/OP_EQUALVERIFY and OP_CHECKSIG.\n>\n> But the implementations would have to decode the Base58 address into \"0x00\" plus the address hash. As the only supported invoice type for the Legacy signing methods, this should be straight forward to do.\n>\n> > And we have opcodes like OP_RESERVED, that can be wrapped in OP_IF, then it is \"conditionally valid transaction\".\n>\n> I'm not sure how an OP_RESERVED in an unexcuted OP_IF is going to help implement an ECDSA pubkey recovery + DUP/HASH160/EQUALVERIFY hybrid instruction.\n>\n> - Ali\n>\n> On Wed, 10 Aug 2022 04:59:46 +0200, vjudeu at gazeta.pl wrote:\n> > > I'm not sure what is to be gained from adding an opcode\n> >\n> > Backward compatibility. If we don't have OP_CHECKDATASIG, then it has to be somehow introduced to make it compatible with \"Bitcoin Message\". And we have opcodes like OP_RESERVED, that can be wrapped in OP_IF, then it is \"conditionally valid transaction\". It is also possible to assign some unused opcode, but then it will be more complex, because in Script, those opcodes make transaction invalid, but inside TapScript, those opcodes are defined as OP_SUCCESS, and make things automatically valid.\n> >\n> >"
            },
            {
                "author": "Ryan Grant",
                "date": "2022-08-10T23:11:10",
                "message_text_only": ">> TODO: A way for the initial signer to delegate to another\n>> scriptPubKey; needed for better privacy and CoinJoin/Lightning\n>> compatibility\n\nI need more documentation to understand this motivation.\n\nOn Tue, Aug 9, 2022 at 8:46 PM Ali Sherief via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> In the case of the last TODO, related to delegation to another\n> scriptPubKey, I am not quite sure at the moment what to do about\n> it - perhaps you guys can place a MAST (two Merkle branches, to be\n> specific) - the first branch has the original signer's scriptPubKey,\n> the second branch contains the delegated signer's scriptPubKey.\n\nI don't understand this requirement, but it seems that whatever\nparties are involved can make signatures on the delegating and\ndelegated keys."
            },
            {
                "author": "Ali Sherief",
                "date": "2022-08-11T16:56:29",
                "message_text_only": "Earlier last year on March, there was a post here by Jeremy Rubin that explains how a person could delegate its UTXO to some script, by (AFAICT) creating a new transaction using that UTXO, with whatever script you want it to have.\n\nIt was written in terms of normal transactions, but can be extended to message signing transactions too.\n\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-March/018615.html\n\nOnly the beginning of the post is relevant here.\n\n- Ali\n\nOn Wed, Aug 10, 2022 at 11:11:10PM +0000, Ryan Grant wrote:\n> >> TODO: A way for the initial signer to delegate to another\n> >> scriptPubKey; needed for better privacy and CoinJoin/Lightning\n> >> compatibility\n>\n> I need more documentation to understand this motivation.\n>\n> On Tue, Aug 9, 2022 at 8:46 PM Ali Sherief via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > In the case of the last TODO, related to delegation to another\n> > scriptPubKey, I am not quite sure at the moment what to do about\n> > it - perhaps you guys can place a MAST (two Merkle branches, to be\n> > specific) - the first branch has the original signer's scriptPubKey,\n> > the second branch contains the delegated signer's scriptPubKey.\n>\n> I don't understand this requirement, but it seems that whatever\n> parties are involved can make signatures on the delegating and\n> delegated keys."
            }
        ],
        "thread_summary": {
            "title": "Regarding BIP322 edge cases",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Ryan Grant",
                "Ali Sherief",
                "vjudeu at gazeta.pl"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 22320
        }
    },
    {
        "title": "[bitcoin-dev] RIDDLE: Lightweight anti-Sybil with anonymity in Bitcoin",
        "thread_messages": [
            {
                "author": "AdamISZ",
                "date": "2022-08-11T15:31:48",
                "message_text_only": "A quick summary on a lot of study I've done recently on this topic.\nMy last blog [1] was showing that you could concretely make logarithmic sized ring sigs on taproot keys (and built on the explanation and code of Groth/Kohlweiss [2] in the previous blog [5]).\nI left as an outstanding question, how to get one/N time usage of these ring signatures, with key images.\n\nSo this can definitely be addressed using something like Noether & Goodall's Triptych [3].\n\nThe right context for Triptych:\nThe GK paper [2] just referenced is the core idea: bit decomposition of index. Then, Bootle et al. in \"Short Accountable Ring Signatures Based on DDH\" in 2015 [4] found a significant further efficiency/compaction by generalising the concept a bit: using an n-ary decomposition and delta-functions as a way to identify the index with the correct digits in n-ary. They used this to form a new \"accountable\" ring sig based on El Gamal ciphertexts.\nThen in 2020 we have Triptych: it takes the n-ary decomposition as above, and adds one more element: a key image, as in the basic cryptonote , LWW, LSAG design.\nOf note is that Bootle et al. claim their construction is \"2.8 times smaller\" than the GK [2] design (which is ~ 7log_2 N + 1 size, so in practice maybe 2.5kB for 2000 keys for example). I mention this because although I *believe* the same key image appending idea would work with GK [2] design, there's no point trying to do that, because Bootle et al. is just more compact and already achieves the same thing.\n\nAdding in the key image needs more space in the proof of course, but only by less than a factor of 2 (just some commitment and response duplication in the sigma protocol).\n\nSo the endpoint of the research, for now, is that Triptych [3] seems to give both things we need: first, a key image, which is absolutely needed for something like RIDDLE, along with a very compact size for high anon sets.\n\nI'll probably add some code for this at some point to go along with the GK [2] toy code at [6]\n\nRegards,\nAdamISZ/waxwing\n\n[1] https://reyify.com/blog/bragging-with-brevity\n[2] https://eprint.iacr.org/2014/764.pdf\n[3] https://eprint.iacr.org/2020/018\n[4] https://eprint.iacr.org/2015/643.pdf\n[5] https://reyify.com/blog/leaking-secrets-logarithmically\n[6] https://gist.github.com/AdamISZ/77651979025d16b778494047c86c3a7c\n\nSent with Proton Mail secure email.\n\n------- Original Message -------\nOn Thursday, June 30th, 2022 at 22:50, AdamISZ via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n\n> Just a small update to those interested:\n> I migrated the gist due to failures of github's new equation formatting feature (which unfortunately started just when I published this gist!), to [1](but comments still on the gist please, or here).\n>\n> Secondly, I did some research (including toy code) into sublinear ring signatures and Groth/Kohlweiss 2014 can give logarithmic scaled ring signatures, whose security is reducible to that of the Pedersen commitments (essentially ECDLP). I made a note on what this looks like concretely here [2], TLDR 1 o 2 KB for 256-1024 keys. Open question how much the computational load matters. (Ring sig + key image I think is effected via ring sig + \"spend a coin\" part of \"how to leak a secret and spend a coin\", in the language of the paper).\n>\n> The above paragraph is mentioned of course to address the question of how practical it might be to get genuinely big anonymity sets. In short, it might be practical. Again to mention: though bilinear pairings crypto could give substantially more efficient constructions, that would not work on 'bare' secp256k1, though there might be a sensible way of 'transferring' over to other curves (I'll leave that to others to figure out!).\n>\n> [1] https://reyify.com/blog/riddle\n> [2] https://gist.github.com/AdamISZ/51349418be08be22aa2b4b469e3be92f?permalink_comment_id=4210892#gistcomment-4210892\n>\n> Cheers,\n> AdamISZ/waxwing\n>\n>\n>\n>\n> Sent with Proton Mail secure email.\n>\n>\n> ------- Original Message -------\n> On Sunday, June 12th, 2022 at 18:04, AdamISZ via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:\n>\n>\n>\n> > List denizens,\n> >\n> > As per the title, a suggested protocol for doing anti-Sybil that isn't too demanding for the users, but actually keeps a decent level of privacy.\n> >\n> > Notice how it's mostly focused on a user/customer of a service/product/website, but it could conceivably useful in e.g. anti-Sybil in things like Lightning.\n> >\n> > Sorry that as usual I write rather long but there are several conveniently arranged sections you can click on :)\n> >\n> > https://gist.github.com/AdamISZ/51349418be08be22aa2b4b469e3be92f\n> >\n> > (with apologies for my backronym-ing sins)\n> >\n> > Cheers,\n> > waxwing/AdamISZ\n> >\n> > Sent with Proton Mail secure email.\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "RIDDLE: Lightweight anti-Sybil with anonymity in Bitcoin",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "AdamISZ"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5172
        }
    },
    {
        "title": "[bitcoin-dev] A method for BIP322 signing delegation",
        "thread_messages": [
            {
                "author": "Ali Sherief",
                "date": "2022-08-14T04:25:33",
                "message_text_only": "[A similar message was posted in the Bitcointalk BIP322 thread.]\n\nOK, I just figured out how to solve the delegation problem. It builds on Jeremy Rubin's transaction delegation post which I linked to a few days ago.\n\nIn BIP322, there is a [planned] provision for some person to delegate signing to another person. That means the second person can do all the signing stuff that the first person could do, and the signature is as if the first person signed it.\n\nWhat this could be useful for?\n\n- L2/Lightning Network, a channel is just 2-of-2 multisig, so a prospective channel co-creator \"delegate\" signing to the channel itself, by signing a UTXO inside the multisig - signing along with the other party, creating a dummy output (see below), which can be signed to prove liquidity on behalf of the channel, while keeping the channel itself anonymous.\n- CoinJoin, To prove that some CoinJoin coordinator is liquid without violating its anonymity by revealing public keys, the person managing the CoinJoins delegates signing from all UTXOs to be used in the CJ, at once, delegating signing to another dummy output.\n- By the same token, Mixers can prove their liquidity without revealing their UTXO set.\n- Silent Payments, where the public key is not even known in the first place, the address of a silent payment can delegate signing to another dummy output which only the sender and receiver know about.\n\nSo how does this delegation work? It's very simple:\n\n1. All UTXOs that want to delegate signing to a different party must sign a preliminary transaction of this format:\n- All input/output amounts are zero.\n- input 1 is an invalid input of the kind in BIP322\n- the rest of the inputs are the UTXOs wanting to delegate signing to a different party, with valid signatures/witness stacks.\n- there is only one output, and it is a P2WSH output with the following script:\nOP_PUSH <hash-of-address-hash> OP_SWAP OP_HASH160 OP_EQUALVERIFY\n- And the witness stack that will \"spend\" the transaction in the \"to_spend\" tx is simply:\n<address-hash>\n- Likewise, the \"to_spend\" tx has only one input, refering to the txid of the delegating transaction with output point 0 i.e. the UTXO <delegation-txid>:0. Outputs of \"to_spend\" remain the same.\n-- Contrary to the use of Hash160, we are NOT hashing a public key or script. We are hashing an address hash, implying that we are using addresses.\n\nDo you know why I said \"delegating to a different party\"? Because it could be a functionally different entity, just like how CEO is diffferent from LLC company even if it has only 1 employee. The \"address\" here represents a kind of company <but is not a smart contract> - it can represent a channel, it can represent a coinjoin, it can represent a silent payment. The channel/CJ/etc. only has to hash the decoded RIPEMD160 of an address, with another SHA256-RIPEMD160, to make an \"address\" that can be used to sign messages from.\n\nThis \"address\" aka. LLC company can even be encoded with Bech32 to make it look like a real address - obviously don't send any funds directly to that address because they will be lost - and in fact, it *should* be Bech32-encoded when transmitting the Signed Message.\n\nA signed message has these three parts:\n\nMessage\nAddress\nSignature\n\nBIP322 specifies the signature is just the raw transaction format of \"to_sign\". Normally, the address would simply be the address you are signing from, but in the case of delegation, it is desireable for the original addresses to remain anonymous. So since an address must be filled in somewhere, the Bech32 \"hash-of-address-hash\" created above can be used as a P2WSH address.\n\nAdvantages of this scheme:\n\n- The real addresses/UTXOs signing the transaction are only known to each other and whoever is managing the \"to_delegate\" transaction.\n- Only the real signers and the person who is in charge of the P2WSH output can sign the \"to_delegate\" output and thus sign a message from it (note that they could be the same person).\n- There can be an arbitrary number of delegations before the transaction is actually signed (the new person who is in charge of signing, i.e. has the P2WSH output of the \"to_delegate\" transaction can simply generate another address hash, and delegate to that \"address\" in another transaction, giving some other person that \"address\" if they want to)\n- Delegated signatures can wrap Full and Full with UTXOs signing formats, so Light clients do not have to directly support those two formats, either for complexity reasons, or because they have no UTXO set.\n- And crucially: **There is no on-chain transaction, so the delegation is private and cannot be traced back by the public**.\n\nAnd there are virtually no disadvantages to this.\n\nI should emphasize that you don't delegate signing to another person, you delegate signing to another party that may just be comprised by one person. I say this because the delegation does not make any new on-chain UTXOs that someone could posess, but it simply creates a hash160 of some address hash that was generated by the delegators, and the hash-of-address-hash does not necessarily have to represent a person, it can also represent a service.\n\nFAQ:\n\nQ: Does this utilize the Full format?\nA: Yes.\n\nQ: How to represent the delegation in a signed transaction?\nA: Just encode the hash-of-address-hash in Bech32 version 0 and put it in the Address field.\n\nQ: If the delegation is private, then how can the address-hash be known and the transaction signed?\nA: The UTXO signers take a random address associated with them <could be one of their own address, could be the address of a multisig that is being used elsewhere etc.> and then make the hash160 of that address. Whoever they give this to, can sign a BIP322 transaction.\n\nQ: How can the public verify a delegated BIP322 transaction if the address-hash is private?\nA: The hash-of-address-hash is revealed in the Address, not in the Signature. BIP322 states that the signature only contains the \"to_sign\" transaction, which does not contain the witness stack of \"to_spend\" that has the hash-of-address-hash (because THAT was already spent in \"to_spend\") therefore the address hash is Bech32 (version 0) encoded and can be decoded to re-construct \"to_spend\" transaction and from there \"to_sign\".\n\nQ: How to differentiate between non-delegated and delegated signatures?\nA: You can't. But then again, BIP322 doesn't differentiate between \"message signatures from an address\" and a signature from a set of UTXOs so it wouldn't be able to identify a delegated transaction anyway.\nRather, a full-blown verification software should present a list-box or a set of radio buttons, that toggles between \"Legacy\", \"Simple\", \"Full\", \"Full with UTXOs\" and \"Full with Delegation\" - Each of these controls the content in the Address field - this would already be required to support validating Legacy signatures anyway, which are otherwise incompatible with the transaction-based signing (and this is the workaround BIP322 specifies to support that).\n\nQ: What if the verifier does not have a UTXO set (light clients)?\nA: Then present three toggles or radio buttons: \"Legacy\", \"Simple\", and \"Delegated\" - each of these options only require a single encoded address to be specified in the field, and Full, and Full With UTXOs signatures can be wrapped with a delegation to support a single address. Consequentially, these control how the signed transaction is [re]constructed for sign/verify.\n\nCC'ing Kalle as he might be interested in this.\n\n- Ali"
            },
            {
                "author": "Ali Sherief",
                "date": "2022-08-16T04:38:47",
                "message_text_only": "(Note: I'm going to stick with this thread for all proposals for BIP322 polishing, not just delegation - unless the subject matter changes radically as other people discuss it.)\n\nInstead of the admittingly complicated scheme using transactions, I've created one that utilizes multisig to make the possible delegatees known at signing time. I had a discussion with vjudeu, garlonicon, and aliashraf about this over the past week or so, and while we did not reach a consensus about the solution to use, I feel that this scheme requires the least amount of modifications to BIP322 draft.\n\nThe problem being solved is how to delegate signatures to other scriptPubKeys* [sic] for privacy purposes.\n\n*Here, I use P2WPKH addresses, under the assumption that the delegatees are people. If the delegatees are just some automated scripts or processes [as was mentioned in the BIP], then this scheme is equally valid with P2WSH multisignatures with appropriately constructed scriptPubKeys.\n\nWhat's about to follow was copied almost word-for-word from my forum post with extraneous paragraphs removed:\n\n---\n\nIt is extremely simple and doesn't require any additional transactions:\n\n- Replace the message challenge of \"to_spend\" with a 1-of-N standard P2WPKH multisig. N is the number of people you want to be able to create the signature, and their respective pubkeys are included in the script.\n-- In this way the possible delegatees are fixed at signature creation time and cannot be extended by creating more transactions.\n- Replace the challenge solution in \"to_sign\" (it's the input that spends the output we made in \"to_spend\") with a witness stack containing: n <pub1> <pub2> ... <pubn> 1 <a-signature> 0\n-- The signature is generated as if it were for a real P2WPKH-multisig transaction. [the zero at the end is due to a bug in OP_CHECKMULTISIG that pops an extra element].\n\nappendix - don't mix up this delegation and Full with UTXOs together - it increases the numebr of permutations that implementations have to verify.\n\nPros:\n\n- No recursive transactions.\n- If Alice and Bob are the two delegates of a signature (and one of them sign it), Carol does not know any of the private keys or challenge solutions and thus cannot claim the script was signed by her [besides the public keys of Alice and Bob are already in the signature]. Required, to avoid signature fraud.\n- The Address field is not used when delegating, so the engine can actually print which (compressed) public key it is signed against - i.e. the address verification is provable, as opposed to reactive Legacy signatures.\n-- Additionally, they will all be Segwit Bech32 addresses so it can just derive and print the corresponding bc1 address instead.\n- There is no opcode or new algorithm introduced, so no soft-fork is required.\n\nCons:\n\n- Everyone knows the public keys of the delegators, so there is no privacy [then again, in light of the signature fraud problem, this is possibly a non-issue].\n\n---\n\nI'd like to hear everyone's opinions about this.\n\nI don't know who suggested the idea of delegation in the first place, but CCing luke-jr because he participated in that Github discussion, so his opinion about this scheme will clarify a lot of things about this problem.\n\n- Ali"
            },
            {
                "author": "Ali Sherief",
                "date": "2022-08-19T06:23:38",
                "message_text_only": "Since I mailed the original scheme, some people have suggested to me that this delegation scheme can be written in TapScript, to avoid revealing the unspent public keys. I think that is a good idea.\n\nHere is a very helpful slideshow about implementing Multisig scripts in Taproot by Jimmy Song[1] - specifically, I have looked into \"Single leaf k-of-n multisig\" and \"Multi-leaf k-of-k multisig\". I have not considered the approach with MuSig, considering there is not even a BIP for that.\n\nTo my understanding, Single leaf k-of-n multisig is functionally identical to \"Using a single OP_CHECKSIGADD-based script\" described in BIP 0342, footnote 5, which itself has nearly all of the properties of the original CHECKMULTISIG opcode[2]. In other words, it won't hide the non-signing public keys (the TapScript is literally \"<PubKey 1> OP_CHECKSIG ... <PubKey N> OP_CHECKSIGADD OP_<N> OP_NUMEQUAL\", so it doesn't solve the privacy problem.\n\nThat leaves Multi-leaf k-of-k multisig. Now to my understanding, in every TapLeaf/Branch, there is going to be a K-of-K TapScript similar to the one constructed above. In each leaf there will be a combination of K public keys, so the number of leaves is going to be equal to nCr(n,k).\n\nNo wonder why BIP 342 says that it's only cost-effective for small values of k, because the number of leaves and thus the transaction size swells as k increases.\n\nFortuantely, for the purposes of delegation, K will always be 1, because we only utilize 1-n multisig signatures as per my previous message. Thus the fee rate will be economical for all values of N i.e. number of delegatees. This enables this scheme to have a wider use case than just BIP322 (even here though, decreasing the raw transaction size of 'to_sign' is a net positive for space reasons).\n\nIn other words, every TapScript is just <PubKey> OP_CHECKSIG OP_1 OP_NUMEQUAL, which can be simplified to just <PubKey> OP_CHECKSIG since OP_CHECKSIG failure in a TapScript returns the empty vector (false) on failure, and 1 (true) on success. I wrote the longer script merely because it's consistent with the script format in [2], but since it's by no means a standardness requirement, we can save 2*N bytes in the entire transaction.\n\nSo, for small numbers of delegates, these savings are not very eye-watering, but if fees become larger then every byte will matter. After all, I envision uses for delegation beyond BIP 322 anyway.\n\nAt this point, the witness stack of 'to_sign' will have one of these TapScripts, and an appropriately constructed BIP 341 control block. Obviously 'to_spend''s output scriptPubKey will push the SHA256 hash of the witness program.\n\nUse cases:\n- BIP 322 (obviously)\n- Any L2 protocol where participants' funds must be delegated to a comittee e.g. LN channels - which, in fact, are still using OP_CHECKMULTISIG.\n-- Where such a protocol requires the joint consensus of all participants, such as an LN channel closing gracefully, K can be modified appropriately, but this is beyond the scope of this scheme. Make a BOLT or the appropriate standard proposal if this affects your L2 network.\n\nAdvantages where they are relevant for BIP 322 :\n\n- Signature fraud is still impossible to carry out (the entire to_sign transaction still has to be verified, but now Address can be empty since the public key is in the control block which is in the 'to_sign' witness, and the spent TapScript is also in the 'to_sign' witness).\n- Delegated signers still use standard address type (Bech32m Taproot addresses).\n- No new opcodes are introduced, and no existing ones are redefined so no soft-forks are necessary.\n\nAdvantages for all applications of this BIP :\n\n- Only the delegatee who actually signs the message has a revealed public key, the others' are hidden - a major privacy advantage.\n- Signers must be determined beforehand. Jimmy Song actually lists this as a disadvantage, but I disagree. For L2 delegation, it is necessary to know the other parties to avoid a MITM attack where one of the signers is replaced by a rogue signer - through non-cryptographic methods of course (e.g. a computer hack).\n\nDisadvantages :\n\n- Taproot is not widely deployed in applications yet?\n- I can't think of any others, unless you consider the signer's public key being revealed a disadvantage [I wouldn't, because if it were hidden, it would defeat the whole purpose of signing by making it vulnerable to the aforementioned \"signature fraud\"].\n\nMy grasp on Taproot constructs is not 100%. So feel free to point out any errors in my reasoning for this scheme if you spot any.\n\n- Ali\n\n[1] - https://jimmysong.github.io/taproot-multisig\n[2] - https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#cite_ref-5-0\n\nOn Tue Aug 16 04:38:47 UTC 2022, ali at notatether.com wrote:\n>(Note: I'm going to stick with this thread for all proposals for BIP322 polishing, not just delegation - unless the subject matter changes radically as other people discuss it.)\n>\n>Instead of the admittingly complicated scheme using transactions, I've created one that utilizes multisig to make the possible delegatees known at signing time. I had a discussion with vjudeu, garlonicon, and aliashraf about this over the past week or so, and while we did not reach a consensus about the solution to use, I feel that this scheme requires the least amount of modifications to BIP322 draft.\n>\n>The problem being solved is how to delegate signatures to other scriptPubKeys* [sic] for privacy purposes.\n>\n>*Here, I use P2WPKH addresses, under the assumption that the delegatees are people. If the delegatees are just some automated scripts or processes [as was mentioned in the BIP], then this scheme is equally valid with P2WSH multisignatures with appropriately constructed scriptPubKeys.\n>\n>What's about to follow was copied almost word-for-word from my forum post with extraneous paragraphs removed:\n>\n>---\n>\n>It is extremely simple and doesn't require any additional transactions:\n>\n>- Replace the message challenge of \"to_spend\" with a 1-of-N standard P2WPKH multisig. N is the number of people you want to be able to create the signature, and their respective pubkeys are included in the script.\n>-- In this way the possible delegatees are fixed at signature creation time and cannot be extended by creating more transactions.\n>- Replace the challenge solution in \"to_sign\" (it's the input that spends the output we made in \"to_spend\") with a witness stack containing: n <pub1> <pub2> ... <pubn> 1 <a-signature> 0\n>-- The signature is generated as if it were for a real P2WPKH-multisig transaction. [the zero at the end is due to a bug in OP_CHECKMULTISIG that pops an extra element].\n>\n>appendix - don't mix up this delegation and Full with UTXOs together - it increases the numebr of permutations that implementations have to verify.\n>\n>Pros:\n>\n>- No recursive transactions.\n>- If Alice and Bob are the two delegates of a signature (and one of them sign it), Carol does not know any of the private keys or challenge solutions and thus cannot claim the script was signed by her [besides the public keys of Alice and Bob are already in the signature]. Required, to avoid signature fraud.\n>- The Address field is not used when delegating, so the engine can actually print which (compressed) public key it is signed against - i.e. the address verification is provable, as opposed to reactive Legacy signatures.\n>-- Additionally, they will all be Segwit Bech32 addresses so it can just derive and print the corresponding bc1 address instead.\n>- There is no opcode or new algorithm introduced, so no soft-fork is required.\n>\n>Cons:\n>\n>- Everyone knows the public keys of the delegators, so there is no privacy [then again, in light of the signature fraud problem, this is possibly a non-issue].\n>\n>---\n>\n>I'd like to hear everyone's opinions about this.\n>\n>I don't know who suggested the idea of delegation in the first place, but CCing luke-jr because he participated in that Github discussion, so his opinion about this scheme will clarify a lot of things about this problem.\n>\n>- Ali"
            },
            {
                "author": "Ali Sherief",
                "date": "2022-08-22T07:56:12",
                "message_text_only": "This message relates to an edge case which BIP322 only partially solves, and that is Proof of Payment.\n\nWhen you make a transaction to any business, it keeps the transaction in its records and generates an invoice so anyone can verify the transaction took place.\n\nWhen you do a P2P transaction, whether on the blockchain or with paper money, there is always the risk that the other party will be dishonest, act in their own interest to convince people that they did not receive the transaction. Nobody has been able to completely get rid of this.\n\nBut in cryptocurrencies, this type of dispute is rampant, because it's also a scam attempt, to extract more money from the buyer. Legacy signed message isn't even enough to prove the transction took place - they can just claim (falsely) the address in the transaction is not theirs.\n\nIt usually happens like this:\n\n1. Alice wants to buy something from Bob and sends bitcoins.\n2. Bob denies receiving payment.\n3. Alice publishes the txid of the transaction.\n4. Bob denies that the address in the transaction belongs to him.\n\nBIP322 signed messages only go half-way there: They can prove that the UTXO(s) belong to the buyer, and any good block explorer will show you the UTXOs that are being spent. So it can be independently established that Alice sent money, but not *who* it was sent to. That is where BIP322 falls short - there is no mechanism that forces Bob to sign a BIP322 message from the UTXO(s) he has just received, before the transaction is complete.\n\n---\n\nWhat should be done about this situation?\n\nI propose using P2WSH 2-of-2 multisig to solve this problem. The script challenge will consist of something like OP_SHA256 <sha256 hash> OP_EQUAL[1][2]\n\n[1]I don't even know if there is a standalone SHA256 opcode.\n[2]OP_CHECKMULTISIG and OP_CHECKSIG both take public keys from the stack in addition to signatures, but we have arbitrary byte arrays and their SHA256 hashes, not public keys and signatures. How can we make this work?\n\nNow on the witness stack, is pushed the BIP322 signature. Both of the signatures are then published on the blockchain. The catch is that both of the signatures are requires to be supplied\n\nWe don't want the signatures to be hidden using Taproot script paths or anything because whole point of this scheme is to make it verifiable to the public.\n\nBut I think that this idea can seriously work out in practice:\n\n- Alice starts a P2P payment with Bob (let's just call this whole scheme \"P2P payments\")\n- Alice sends bitcoin to the 2-of-2 multisig address generated by the P2P payment.\n- Alice signs a BIP322 message from a UTXO (or address, but preferably a UTXO) and provides one of the signatures.\n- Bob is forced to sign another BIP322 message from his address if he wants his money, and provides another signature.\n- One of them broadcasts the multisig transaction, and Bob gets his money.\n\nAdvantages:\n- The signatures in the Multisig transaction are two BIP322 signatures, which prove who has control of which inputs.\n-- Consequentially, it can be proven who paid who. It is like an invoice, but it cannot be doctored like company invoices and databases.\n\nDisadvantages:\n- If Bob chickens out at this point, the money in the P2P payment is lost forever.\n-- So, it is in the buyer's best interest to cooperate, and also in the seller's interest, but not particularly the best one - Until Bob provides a service, he doesn't lose anything except for time.\n\nWhat do you guys think about this scheme?\n\n- Ali"
            }
        ],
        "thread_summary": {
            "title": "A method for BIP322 signing delegation",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Ali Sherief"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 22294
        }
    },
    {
        "title": "[bitcoin-dev] Surprisingly, Tail Emission Is Not Inflationary",
        "thread_messages": [
            {
                "author": "jk_14 at op.pl",
                "date": "2022-08-15T21:46:52",
                "message_text_only": "> New blog post:\n> https://petertodd.org/2022/surprisingly-tail-emission-is-not-inflationary\n\n\nTail emission is inevitable, Milton Friedman says...\n\n\nThe key thing here in my opinion is to properly understand the seriousness of the situation.\n\"There is no such thing as a free lunch\" - is definitely helpful quote here.\n\nThere are two edge cases.\n\n1. while starting given cryptocurrency\n- the annual inflation is huge, nobody (in developed/mature monetary system) would like to keep such kind of money with e.g. 100% annual inflation rate, but from the other side there is no problem for transaction fee to be free of charge here\n\n2. while given cryptocurrency is switching off the block reward, in supposed \"mature phase\":\n- the annual inflation is zero, everyone want to hoard such money, transaction fees must carry the whole security of the system\n\n\nIn the first edge case: active users have got \"free lunches\" and passive users (i.e. holders) are paying for it (by \"inflation tax\")\nIn the second edge case: passive users have got \"free lunches\" and active users should pay for it (by \"transactional tax\")\n\nSo far I only highlighted some maybe not very well recognized, but pure facts (it's not comfortable to contradict the facts...)\n\n\nThe reason people do pay in the first phase - is a hope/promise of system growth (future coin price appreciation = profit)\nThe problem in the second phase is that there is no real incentive for people to pay for other's free lunches.\n\n\nAny wishful thinking that most (or even: any significant part) of holders will resign from a free lunch and will buy and run ASIC mining equipment at loss - is just a delusional perspective. It's well proven by game theory and what says us the Prisoner's Dilemma about it. For better understanding - here is my modified version of Prisoner's Dilemma short description:\n\n\"The Prisoner's Dilemma is a standard example of a game analyzed in game theory that shows why completely rational large holders might not cooperate, even if it appears that it is in their best interests to do so.\"\n\nI'm pretty sure we will have a textbook case of Prisoner's Dilemma here.\n\nAs a useful example - let's assume that fees don't compensate low block reward. Btw, right now a single transaction fee need to be $60 to compensate that (and it will only get worse in time). System is not inclusive with $60 per transaction fee. Only rich people will use it. Another possible scenario is a x100 drop of network hashrate to catch a previous fee levels. The network is x100 less secure, then. It really doesn't matter if this process is spread over the long run...\n\nSo, for example - let every 10 BTC holding needs to be secured by one Antminer S19 running.\n\nIn an ideal world every large bitcoin holder will run proper amount of ASICs and run it at loss.\nThe holders of less than 10 BTC - will organize \"group pays\", this time for sharing loss (electricity costs)\nExactly the same way like people made \"group buys\" of ASIC hardware in 2013.\n\nI hope it's clear that in the real world it WILL NOT work. People will simply think, that there is only a tiny punishment for betrayal.\nNoone will waste his renewable energy on unprofitable Antminer while he/she can sell this energy for the market price. Even Bitcoin can't beat the human nature.\n\n\nThanks to Milton Friedman - we can easily say that situation with \"free lunches\" (at least for some part of users) - is an unhealthy state of financial system.\nAnd may last only exceptionally for short period of time, and definitely not as a default state. System must be sustainable and time to accept that there is a real problem here (or: an elephant in the room - but maybe not such invisible like was before).\n\nThe good news is a natural solution exists. Bitcoin can solve this issue natural way.\n\nWhile decreasing block reward and moving from the first edge case to the second one - the system naturally cross the Area of Balance.\nAnd healthy system should stay somewhere in such area. And that's exactly what Monero did. But they did it arbitrally, at 0.9% level.\nBitcoin is able to do it much better - because empirically.\n\nThere is a simple trigger if the system is leaving an Area of Balance and cross the line of Phase 2 with \"free lunches\". The network difficulty / global network hashrate chart.\nFour years after some particular halving (in 2028, 2032 or later - no matter when in fact) - we will (definitely) see difficulty is not recovered during four long years.\nThis is a big red light. It means that halvings starts to be destructive to the network security. \n\nSomething what became destructive to the network - must be removed. Halving must be removed in such moment. Moment determined empirically - what is good thing. Satoshi Nakamoto wasn't able to properly predict when this moment may appear, but we are in better situation.\n\n\"Bitcoin to the moon\" (and any other pro-21M hardcap shortsighted slogans) - must have a lower priority than network security/health.\nI'm sure Satoshi would agree with it. Of course, someone may set up such environment, where holders (i.e. passive users) have got a free lunches\nand security of network is based on active users' shoulders only. Someone could even insist that it is quite fair...\nBut please don't expect a lack of impact for the network security where not all, but only a part of users - participate in supporting network health.\nMany people don't realise a simple fact: keeping destructive halvings in such situation above, just for maximising appreciation of already hoarded coins\n- is counterproductive. Because the network security is decreasing.\n\n\nWe have a lot of time yet to educate people about it - for reaching common consensus for halvings removal with \"ease\".\nWe should probably use Milton Friedman's quote and highlight that balanced system with 0.45% / 0.225% / 0.1125% (?) annual inflation rate (and slowly decreasing)\n- is still enormously better than any surrounding fiat system. But system still balanced and stable - and not in spiral of death...\n\n\n\u201cBitcoin should have had a 0.1% or 1% monetary inflation tax to pay for security,\u201d Peter said long time ago, further arguing bitcoin will die if it doesn\u2019t change the limit.\n\nI fully agree with Peter. The halvings should be removed in case it starts to be destructive to the network security (lack of hashrate recovery during long 4 years after given halving). Because that means bitcoin system has reached equilibrium / saturation on a globe scale level. The evolutionary path is the best path.\nThe worst path is: overcomplicated constructs, completely unclear for Average Joe. Additional merge-mining coins, whatever etc. - just to achieve the same final goal.\nKISS = Keep It Simple. Halving removal is the most honest, simplest and most understandable way to make every bitcoin pasive user to participate in keeping Bitcoin network secure. It just force the rule, that someone pay proportionally to amount of bitcoins he/she hold, and all participants are sure that everybody participate (no Prisoner's Dilemma, what is crucial matter)\n\n\nYes, that means: hard fork. But as written above - Bitcoin will die without the solution.\n\nBitcoin may be also out of sudden in a deadly risk from quantum computers. In such circumstances everyone (or: almost, i.e. everyone who cares) - would immediately download a quantum resistant, freshly released bitcoin wallet, no doubt. And these two dangers are similar at least in one aspect: both will cause the spiral of death.\nWidespread consensus would be the best scenario, but from the other side: a fork always shows retrospectively, who was right (BCH turmoil in 2017)\n\n\nRegards\nJaroslaw\n\n\nP.S  some other resources yet:\n\n\"Friedman originally proposed a fixed monetary rule, called Friedman's k-percent rule, where the money supply would be automatically increased by a fixed percentage per year. Under this rule, there would be no leeway for the central reserve bank, as money supply increases could be determined \"by a computer\", and business could anticipate all money supply changes. With other monetarists he believed that the active manipulation of the money supply or its growth rate is more likely to destabilise than stabilise the economy.\n\nMost monetarists oppose the gold standard. Friedman, for example, viewed a pure gold standard as impractical.[9] For example, whereas one of the benefits of the gold standard is that the intrinsic limitations to the growth of the money supply by the use of gold would prevent inflation, if the growth of population or increase in trade outpaces the money supply, there would be no way to counteract deflation and reduced liquidity (and any attendant recession) except for the mining of more gold\"\n\nno block reward  => reduced liquidity (reduced number of transactions) => network security in spiral of death\n\nhttps://en.wikipedia.org/wiki/Monetarism\nhttps://en.wikipedia.org/wiki/Friedman%27s_k-percent_rule\nhttps://twitter.com/hasufl/status/1511470668457652224\n\n\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Peter",
                "date": "2022-08-16T16:05:32",
                "message_text_only": "Hi Jaroslaw,\n\nIn the Prisoner's Dilemma the prisoners cannot communicate. In Bitcoin large holders are able to communicate with each other. Also, prisoners need not make an all or nothing decision in Bitcoin. Miners can join and leave the network freely over time. You can change your decision based on the decision of others.\n\nThe Bitcoin design is such that security is volatile but the issuance of blocks is timely and evened out to a 10 minutes average even after the reward is exhausted.\n\nThe existing incentive that miners earn money for including transactions is enough to motivate human nature. Transaction initiators have an incentive to mine and run full nodes for personal interest.\n\n>Noone will waste his renewable energy on unprofitable Antminer while he/she can sell this energy for the market price.\n\nThe law in most jurisdictions prevents the resale of spare electricity unless an expensive license is obtained (and in most cases no license is available as the government maintains a monopoly). Mining with waste electricity is reducing losses. Another incentive to motivate human nature.\n\nBitcoin holders can be enfranchised into any new system. So, no need for bike shedding the original design which is a Schelling Point.\n\nRegards\n\nPeter Kroll\n\npointbiz/ BTCCuracao\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220816/7446c044/attachment.html>"
            },
            {
                "author": "aliashraf.btc At protonmail",
                "date": "2022-08-19T17:21:03",
                "message_text_only": "Hi Peter, everyone\nThis issue has been discussed thoroughly in bitcointalk, general discussions are more suited to forums, I believe, still ....\n\nFirst and foremost, it is more than obvious that bitcoin block subsidy algorithm is a total disaster, not just for the zero subsidy security consequences, but also for the overly rewarding scheme that favors (few) first-runners against (masses of) people who join later, a policy that looks to be a cheap marketing trick rather than a decent strategic monetary, system design, no matter how natural it is presumed nowadays, after being implemented by Bitcoin.\n\nFor now, the brilliance of the idea behind Bitcoin and the enthusiasm have compensated for its bizzar, upside-down inflation policy, in practice as newcomers have been paying the price to lucky first-runners and adopting anyway.\nIs it happening for low block subsidy? Is it going to be solved somehow? I don't think so.\n\nWith subsidy still being the major (like 90%) portion of the block reward, there is an equalizer factor pushing equilibrium by paying security costs on behalf of current coin owners.Note that every single new bitcoin paid as subsidy is actually paid by the rest of the wallets proportional to their balance.\nOther than its direct contribution to security, once understood as a ballance-based taxing scheme, it is a crucial mechanism for re-distribution of wealth because to compensate for their costs, unlike speculators (who are among the worst adopters of Bitcoin, and unfortunately the most influencers), miners are used to dumping their coins, providing more fair opportunities for people to join.\nSo, halving and the hard cap, put both adoption and security as risk, It is why, unlike \"believers\", I'm deeply concerned about a future with low block subsidy because it puts both security and adoption in an awkward situation.\n\nAdditionally, It is not considered an engineering practice by any measure to speculate about the security of a system that we abundantly recommend to friends, family for joining.\nWe need proofs, security proof, ease of adaptation proof, etc.,\nFantasies are not proofs, having faith in a magical incentive mechanism that fixes everything is not an argument, let alone being a proof.\nIncentives are irrelevant, rules, schemes, projects, and so fort, matter. There are always incentives in games, but rules are in charge of determining the fate.\nWithout rules, there is no game, flawed schemes and rules move the game behind its equilibrium to fail eventually.\n\nI've not to mention the unfeasibility of tempering Bitcoin's basic consensus rules, Bitcoin rules are not subject to change specially when it comes to something that is widely considered a basic characteristic, a Schelling point, and so forth.\n\nSo, it is the paradoxical situation: we are exposed to, on one hand, it is a deficiency and on the other hand it is inevitable because is critically hard-code to Bitcoin, advertised more than any feature as its identity.\nBut it is our job, isn't it? Dealing with the impossible and taking care of it, but I think before reaching to that point we have to settle the basics.:\n\n- There is a problem with long term security and adoption consequences.\n- It is built deeply to bitcoin consensus rules, and considered a critical\n- It is not going to disappear magically, neither it will be addressed by whales, etc.\n- The 21M cap, halving, and generally, Bitcoin consensus, is not subject to change.\n\nDon't panic, it is not exactly a catch-22 situation. Tip:\nIt is always possible to help a system without aggressive intervention, either by smart tweaks or by supporting it using other system(s).\n\nCheers, Ali Ashraf\n\n------- Original Message -------\nOn Tuesday, August 16th, 2022 at 8:35 PM, Peter via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi Jaroslaw,\n\n> In the Prisoner's Dilemma the prisoners cannot communicate. In Bitcoin large holders are able to communicate with each other. Also, prisoners need not make an all or nothing decision in Bitcoin. Miners can join and leave the network freely over time. You can change your decision based on the decision of others.\n>\n> The Bitcoin design is such that security is volatile but the issuance of blocks is timely and evened out to a 10 minutes average even after the reward is exhausted.\n>\n> The existing incentive that miners earn money for including transactions is enough to motivate human nature. Transaction initiators have an incentive to mine and run full nodes for personal interest.\n>\n>>Noone will waste his renewable energy on unprofitable Antminer while he/she can sell this energy for the market price.\n>\n> The law in most jurisdictions prevents the resale of spare electricity unless an expensive license is obtained (and in most cases no license is available as the government maintains a monopoly). Mining with waste electricity is reducing losses. Another incentive to motivate human nature.\n>\n> Bitcoin holders can be enfranchised into any new system. So, no need for bike shedding the original design which is a Schelling Point.\n>\n> Regards\n>\n> Peter Kroll\n>\n> pointbiz/ BTCCuracao\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220819/5d3300ef/attachment.html>"
            },
            {
                "author": "Billy Tetrud",
                "date": "2022-08-20T15:30:26",
                "message_text_only": "@vjudeu\n> Miners can game this system by moving their own coins in 100% fees\ntransactions, just to produce more coins. You have one million BTC? No\nproblem, just move them as fees, and you just created 100k BTC out of thin\nair, just because you are a wealthy miner.\n\nHmm, I believe you're right about that. If a miner can make 1 BTC of fees\nby honestly mining + 0.1 BTC of inflation, they could instead make 2 BTC by\nmining their own transactions with 20 BTC of fees. That does sound very\ngameable. I rescind my suggestion.\n\nOne could imagine modifications to that suggestion that attempts to make it\nmore difficult to game directly. For example, if an average sum of\nfees/block was calculated over a window (eg 2 weeks, 2 months, etc) and 10%\nof that was released in coinbase rewards, you would eliminate the\npossibility for individual miners to game the system. However, you would\nthen have to consider the group of miners as a whole - since they all have\nan interest in increasing their revenues, it certainly seems like a\ndangerous incentive that could lead to runaway inflation. So perhaps even\nextensions of my suggestion are too gameable to be safe.\n\nBut my point still stands that tail emission is not a permanent solution.\nOne permanent solution would be some constant inflation *rate *(eg\n0.1%/year). Given that the necessary security is a function of the total\nvalue of the currency, perhaps that would be a reasonable natural way to\nscale security as needed.\n\nAgain tho, I haven't seen any convincing evidence that any solution like\nthis will likely be necessary at all. Total collected fees will also scale\nup as bitcoin grows, probably quadratically (since the value of the network\ngrows quadratically). I'm rather more inclined to think collected fees will\nget far *too* high - ie substantially higher than needed to pay for\nsufficient blockchain security.\n\n\n\n\nOn Fri, Aug 19, 2022 at 1:48 PM aliashraf.btc At protonmail via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi Peter, everyone\n> This issue has been discussed thoroughly in bitcointalk, general\n> discussions are more suited to forums, I believe, still ....\n>\n> First and foremost, it is more than obvious that bitcoin block subsidy\n> algorithm is a total disaster, not just for the zero subsidy security\n> consequences, but also for the overly rewarding scheme that favors (few)\n> first-runners against (masses of) people who join later, a policy that\n> looks to be a cheap marketing trick rather than a decent strategic\n> monetary, system design, no matter how natural it is presumed nowadays,\n> after being implemented by Bitcoin.\n>\n> For now, the brilliance of the idea behind Bitcoin and the enthusiasm have\n> compensated for its bizzar, upside-down inflation policy, in practice as\n> newcomers have been paying the price to lucky first-runners and adopting\n> anyway.\n> Is it happening for low block subsidy? Is it going to be solved somehow? I\n> don't think so.\n>\n> With subsidy still being the major (like 90%) portion of the block reward,\n> there is an equalizer factor pushing equilibrium by paying security costs\n> on behalf of current coin owners.Note that every single new bitcoin paid as\n> subsidy is actually paid by the rest of the wallets proportional to their\n> balance.\n> Other than its direct contribution to security, once understood as a\n> ballance-based taxing scheme, it is a crucial mechanism for re-distribution\n> of wealth because to compensate for their costs, unlike speculators (who\n> are among the worst adopters of Bitcoin, and unfortunately the most\n> influencers), miners are used to dumping their coins, providing more fair\n> opportunities for people to join.\n> So, halving and the hard cap, put both adoption and security as risk, It\n> is why, unlike  \"believers\", I'm deeply concerned about a future with low\n> block subsidy because it puts both security and adoption in an awkward\n> situation.\n>\n> Additionally, It is not considered an engineering practice by any measure\n> to speculate about the security of a system that we abundantly recommend to\n> friends, family for joining.\n> We need proofs, security proof, ease of adaptation proof, etc.,\n> Fantasies are not proofs, having faith in a magical incentive mechanism\n> that fixes everything is not an argument, let alone being a proof.\n> Incentives are irrelevant, rules, schemes, projects, and so fort, matter.\n> There are always incentives in games, but rules are in charge of\n> determining the fate.\n> Without rules, there is no game, flawed schemes and rules move the game\n> behind its equilibrium to fail eventually.\n>\n> I've not to mention the unfeasibility of tempering Bitcoin's basic\n> consensus rules, Bitcoin rules are not subject to change specially when it\n> comes to something that is widely considered a basic characteristic, a\n> Schelling point, and so forth.\n>\n> So, it is the paradoxical situation: we are exposed to, on one hand, it is\n> a deficiency and on the other hand it is inevitable because is critically\n> hard-code to Bitcoin, advertised more than any feature as its identity.\n> But it is our job, isn't it? Dealing with the impossible and taking care\n> of it, but I think before reaching to that point we have to settle the\n> basics.:\n>\n>\n>    1. There is a problem with long term security and adoption\n>    consequences.\n>    2. It is built deeply to bitcoin consensus rules, and considered a\n>    critical\n>    3. It is not going to disappear magically, neither it will be\n>    addressed by whales, etc.\n>    4. The 21M cap, halving, and generally, Bitcoin consensus, is not\n>    subject to change.\n>\n>\n> Don't panic, it is not exactly a catch-22 situation. Tip:\n> It is always possible to help a system without aggressive intervention,\n> either by smart tweaks or by supporting it using other system(s).\n>\n> Cheers, Ali Ashraf\n>\n>\n>\n> ------- Original Message -------\n> On Tuesday, August 16th, 2022 at 8:35 PM, Peter via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Hi Jaroslaw,\n>\n>\n>\n> In the Prisoner's Dilemma the prisoners cannot communicate. In Bitcoin\n> large holders are able to communicate with each other. Also, prisoners need\n> not make an all or nothing decision in Bitcoin. Miners can join and leave\n> the network freely over time. You can change your decision based on the\n> decision of others.\n>\n>\n> The Bitcoin design is such that security is volatile but the issuance of\n> blocks is timely and evened out to a 10 minutes average even after the\n> reward is exhausted.\n>\n>\n> The existing incentive that miners earn money for including transactions\n> is enough to motivate human nature. Transaction initiators have an\n> incentive to mine and run full nodes for personal interest.\n>\n>\n> >Noone will waste his renewable energy on unprofitable Antminer while\n> he/she can sell this energy for the market price.\n>\n>\n> The law in most jurisdictions prevents the resale of spare electricity\n> unless an expensive license is obtained (and in most cases no license is\n> available as the government maintains a monopoly). Mining with waste\n> electricity is reducing losses. Another incentive to motivate human nature.\n>\n>\n> Bitcoin holders can be enfranchised into any new system. So, no need for\n> bike shedding the original design which is a Schelling Point.\n>\n>\n> Regards\n>\n> Peter Kroll\n>\n> pointbiz/ BTCCuracao\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220820/84699ddb/attachment-0001.html>"
            },
            {
                "author": "jk_14 at op.pl",
                "date": "2022-08-17T08:54:11",
                "message_text_only": "Hi, Peter\n\nThanks to human nature, still:\n\n1. Bitcoin large holders are able to communicate with each other...\n- and as a large bitcoin holder someone will very well understand that he should run his Antminers at loss for goodness of Bitcoin network security.\nBut he won't communicate that - due to his greed - he just betrayed it. Maybe someone will communicate that he is running Anminers... But it doesn't change a lot.\nWe can assume this additional possibility of communication (especially taking into account big number of large holders and their anonimity) - doesn't change this Prisoner's Dilemma into a \"not textbook case enough\".\n\n2. The existing incentive that miners earn money for including transactions is enough to motivate human nature...\n- but paying $50 usd per such transaction (the amount necessary to compensate lack of block reward right now) - is \"no way\" to motivate a human nature, just due to: personal interest (as you correctly highlighted). It really doesn't matter that the process of disappearance of block reward is spreaded over the long run.\n(the same, but more terse: https://twitter.com/hasufl/status/1511470668457652224 )\n\n3. In many jurisdictions you can take back from grid for free - the amount you have produced and uploaded earlier (I'm in one of such). So I won't invest and oversize my solar panels by additional ~24kW of power for additional Antminer runing 24h/day - if I know it will be running at loss. (side note: it's not a good idea to be dependant with future health of bitcoin -  on what type of jurisdiction is the most popular one in given moment)\n\n\nThere are two statements to repeat then, but more precisely:\n\nA. Bitcoiners (me too) are proud the bitcoin system is designed so clever, that from the beginning till now - is able to run without the trust to anyone. And utilise even people's greed - for system goodness/expansion. But when I wrote the FIRST edge case is behind us, but the SECOND one - with no doubt with pathological Friedman's \"free lunches\" for part of participants - is only some years ahead (like in a Titanic scene) - then most of them suddenly say:\n\n\"Ok, then... Bitcoin idea is so brilliant that maybe the game theory won't apply anymore. Let's TRUST the large holders they will run Antminers at loss.\"\n\nIt's not The Satoshi's Vision anymore.\n\n\nB. Bitcoiners (me too) want to remove or neutralise all destructive things to Bitcoin, like for example: unfriendly government regulations, etc. But when I wrote there will be in the future (and the only question is: when) an alarm siren that halvings start to be destructive to the Bitcoin network, while start to cause consecutive network security/hashrate regressions - then most of them suddenly say:\n\n\"Ok, then... I'm to greed to resign from it.\"\n\n\n\nIt's not The Satoshi's Vision anymore.\n\nRegards\nJaroslaw\n\n\n\n\nW dniu 2022-08-16 23:21:30 u\u017cytkownik Peter via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> napisa\u0142:\nHi Jaroslaw,\n\nIn the Prisoner's Dilemma the prisoners cannot communicate. In Bitcoin large holders are able to communicate with each other. Also, prisoners need not make an all or nothing decision in Bitcoin. Miners can join and leave the network freely over time. You can change your decision based on the decision of others.\n\nThe Bitcoin design is such that security is volatile but the issuance of blocks is timely and evened out to a 10 minutes average even after the reward is exhausted.\n\nThe existing incentive that miners earn money for including transactions is enough to motivate human nature. Transaction initiators have an incentive to mine and run full nodes for personal interest.\n\n>Noone will waste his renewable energy on unprofitable Antminer while he/she can sell this energy for the market price.\n\nThe law in most jurisdictions prevents the resale of spare electricity unless an expensive license is obtained (and in most cases no license is available as the government maintains a monopoly). Mining with waste electricity is reducing losses. Another incentive to motivate human nature.\n\nBitcoin holders can be enfranchised into any new system. So, no need for bike shedding the original design which is a Schelling Point.\n\nRegards\n\nPeter Kroll\n\npointbiz/ BTCCuracao"
            },
            {
                "author": "Erik Aronesty",
                "date": "2022-08-17T11:10:24",
                "message_text_only": "you can stop talking about  the \"security of the system\" as meaningful\n\nthis has been discussed enough\n\nif fees are not sufficient, clearance times increase and large stakeholders\nare incentivised to mine\n\nin the best case, fees are sufficient\n\nin the worst case, it degrades to proof of stake\n\ni'm sure you can see how that's fine either way\n\n\nOn Mon, Aug 15, 2022 at 9:59 PM Jaroslaw via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> > New blog post:\n> >\n> https://petertodd.org/2022/surprisingly-tail-emission-is-not-inflationary\n>\n>\n> Tail emission is inevitable, Milton Friedman says...\n>\n>\n> The key thing here in my opinion is to properly understand the seriousness\n> of the situation.\n> \"There is no such thing as a free lunch\" - is definitely helpful quote\n> here.\n>\n> There are two edge cases.\n>\n> 1. while starting given cryptocurrency\n> - the annual inflation is huge, nobody (in developed/mature monetary\n> system) would like to keep such kind of money with e.g. 100% annual\n> inflation rate, but from the other side there is no problem for transaction\n> fee to be free of charge here\n>\n> 2. while given cryptocurrency is switching off the block reward, in\n> supposed \"mature phase\":\n> - the annual inflation is zero, everyone want to hoard such money,\n> transaction fees must carry the whole security of the system\n>\n>\n> In the first edge case: active users have got \"free lunches\" and passive\n> users (i.e. holders) are paying for it (by \"inflation tax\")\n> In the second edge case: passive users have got \"free lunches\" and active\n> users should pay for it (by \"transactional tax\")\n>\n> So far I only highlighted some maybe not very well recognized, but pure\n> facts (it's not comfortable to contradict the facts...)\n>\n>\n> The reason people do pay in the first phase - is a hope/promise of system\n> growth (future coin price appreciation = profit)\n> The problem in the second phase is that there is no real incentive for\n> people to pay for other's free lunches.\n>\n>\n> Any wishful thinking that most (or even: any significant part) of holders\n> will resign from a free lunch and will buy and run ASIC mining equipment at\n> loss - is just a delusional perspective. It's well proven by game theory\n> and what says us the Prisoner's Dilemma about it. For better understanding\n> - here is my modified version of Prisoner's Dilemma short description:\n>\n> \"The Prisoner's Dilemma is a standard example of a game analyzed in game\n> theory that shows why completely rational large holders might not\n> cooperate, even if it appears that it is in their best interests to do so.\"\n>\n> I'm pretty sure we will have a textbook case of Prisoner's Dilemma here.\n>\n> As a useful example - let's assume that fees don't compensate low block\n> reward. Btw, right now a single transaction fee need to be $60 to\n> compensate that (and it will only get worse in time). System is not\n> inclusive with $60 per transaction fee. Only rich people will use it.\n> Another possible scenario is a x100 drop of network hashrate to catch a\n> previous fee levels. The network is x100 less secure, then. It really\n> doesn't matter if this process is spread over the long run...\n>\n> So, for example - let every 10 BTC holding needs to be secured by one\n> Antminer S19 running.\n>\n> In an ideal world every large bitcoin holder will run proper amount of\n> ASICs and run it at loss.\n> The holders of less than 10 BTC - will organize \"group pays\", this time\n> for sharing loss (electricity costs)\n> Exactly the same way like people made \"group buys\" of ASIC hardware in\n> 2013.\n>\n> I hope it's clear that in the real world it WILL NOT work. People will\n> simply think, that there is only a tiny punishment for betrayal.\n> Noone will waste his renewable energy on unprofitable Antminer while\n> he/she can sell this energy for the market price. Even Bitcoin can't beat\n> the human nature.\n>\n>\n> Thanks to Milton Friedman - we can easily say that situation with \"free\n> lunches\" (at least for some part of users) - is an unhealthy state of\n> financial system.\n> And may last only exceptionally for short period of time, and definitely\n> not as a default state. System must be sustainable and time to accept that\n> there is a real problem here (or: an elephant in the room - but maybe not\n> such invisible like was before).\n>\n> The good news is a natural solution exists. Bitcoin can solve this issue\n> natural way.\n>\n> While decreasing block reward and moving from the first edge case to the\n> second one - the system naturally cross the Area of Balance.\n> And healthy system should stay somewhere in such area. And that's exactly\n> what Monero did. But they did it arbitrally, at 0.9% level.\n> Bitcoin is able to do it much better - because empirically.\n>\n> There is a simple trigger if the system is leaving an Area of Balance and\n> cross the line of Phase 2 with \"free lunches\". The network difficulty /\n> global network hashrate chart.\n> Four years after some particular halving (in 2028, 2032 or later - no\n> matter when in fact) - we will (definitely) see difficulty is not recovered\n> during four long years.\n> This is a big red light. It means that halvings starts to be destructive\n> to the network security.\n>\n> Something what became destructive to the network - must be removed.\n> Halving must be removed in such moment. Moment determined empirically -\n> what is good thing. Satoshi Nakamoto wasn't able to properly predict when\n> this moment may appear, but we are in better situation.\n>\n> \"Bitcoin to the moon\" (and any other pro-21M hardcap shortsighted slogans)\n> - must have a lower priority than network security/health.\n> I'm sure Satoshi would agree with it. Of course, someone may set up such\n> environment, where holders (i.e. passive users) have got a free lunches\n> and security of network is based on active users' shoulders only. Someone\n> could even insist that it is quite fair...\n> But please don't expect a lack of impact for the network security where\n> not all, but only a part of users - participate in supporting network\n> health.\n> Many people don't realise a simple fact: keeping destructive halvings in\n> such situation above, just for maximising appreciation of already hoarded\n> coins\n> - is counterproductive. Because the network security is decreasing.\n>\n>\n> We have a lot of time yet to educate people about it - for reaching common\n> consensus for halvings removal with \"ease\".\n> We should probably use Milton Friedman's quote and highlight that balanced\n> system with 0.45% / 0.225% / 0.1125% (?) annual inflation rate (and slowly\n> decreasing)\n> - is still enormously better than any surrounding fiat system. But system\n> still balanced and stable - and not in spiral of death...\n>\n>\n> \u201cBitcoin should have had a 0.1% or 1% monetary inflation tax to pay for\n> security,\u201d Peter said long time ago, further arguing bitcoin will die if it\n> doesn\u2019t change the limit.\n>\n> I fully agree with Peter. The halvings should be removed in case it starts\n> to be destructive to the network security (lack of hashrate recovery during\n> long 4 years after given halving). Because that means bitcoin system has\n> reached equilibrium / saturation on a globe scale level. The evolutionary\n> path is the best path.\n> The worst path is: overcomplicated constructs, completely unclear for\n> Average Joe. Additional merge-mining coins, whatever etc. - just to achieve\n> the same final goal.\n> KISS = Keep It Simple. Halving removal is the most honest, simplest and\n> most understandable way to make every bitcoin pasive user to participate in\n> keeping Bitcoin network secure. It just force the rule, that someone pay\n> proportionally to amount of bitcoins he/she hold, and all participants are\n> sure that everybody participate (no Prisoner's Dilemma, what is crucial\n> matter)\n>\n>\n> Yes, that means: hard fork. But as written above - Bitcoin will die\n> without the solution.\n>\n> Bitcoin may be also out of sudden in a deadly risk from quantum computers.\n> In such circumstances everyone (or: almost, i.e. everyone who cares) -\n> would immediately download a quantum resistant, freshly released bitcoin\n> wallet, no doubt. And these two dangers are similar at least in one aspect:\n> both will cause the spiral of death.\n> Widespread consensus would be the best scenario, but from the other side:\n> a fork always shows retrospectively, who was right (BCH turmoil in 2017)\n>\n>\n> Regards\n> Jaroslaw\n>\n>\n> P.S  some other resources yet:\n>\n> \"Friedman originally proposed a fixed monetary rule, called Friedman's\n> k-percent rule, where the money supply would be automatically increased by\n> a fixed percentage per year. Under this rule, there would be no leeway for\n> the central reserve bank, as money supply increases could be determined \"by\n> a computer\", and business could anticipate all money supply changes. With\n> other monetarists he believed that the active manipulation of the money\n> supply or its growth rate is more likely to destabilise than stabilise the\n> economy.\n>\n> Most monetarists oppose the gold standard. Friedman, for example, viewed a\n> pure gold standard as impractical.[9] For example, whereas one of the\n> benefits of the gold standard is that the intrinsic limitations to the\n> growth of the money supply by the use of gold would prevent inflation, if\n> the growth of population or increase in trade outpaces the money supply,\n> there would be no way to counteract deflation and reduced liquidity (and\n> any attendant recession) except for the mining of more gold\"\n>\n> no block reward  => reduced liquidity (reduced number of transactions) =>\n> network security in spiral of death\n>\n> https://en.wikipedia.org/wiki/Monetarism\n> https://en.wikipedia.org/wiki/Friedman%27s_k-percent_rule\n> https://twitter.com/hasufl/status/1511470668457652224\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220817/5fef26c6/attachment-0001.html>"
            },
            {
                "author": "jk_14 at op.pl",
                "date": "2022-08-17T13:43:16",
                "message_text_only": "On one scale you puts the Trust to the large stakeholders (why we avoid plenty of small stakeholders, btw),\nand on the other side I put game theory and well defined Prisoner's Dilemma.\n\nAgain: large stakeholders WILL NOT incentivised to mine, they will have the hundreds excuses why not to switch-on Antminers back.\nThat's how it simply works.  Bitcoin would fail miserably if Satoshi was based his concept mainly on existence of idealists.\n\nIf we will observe lack of hashrate recovery four years after some halving and still unprepared like today\n- means the trust in large stakeholders was a very costly mistake.\n\n\nSuperiority of Proof of Work against Proof of Stake has been discussed enough either\nThe overall conclusion with what I fully agree  is: swapping PoW to PoS - would be a degradation.\nYou can stop talking about degradation to proof of stake, but just: degradation.\n\nDegradation of Bitcoin, due to human greed.\n\nNow you mine and you have an INSTANT gratification.\nThen you will mine and it will cost you real money, but simple switch - and you have a DELAYED, maybe some day in the future, maybe only a tiny - punishment.\nAnd The Punishment Won't Be Tiny.\n\n\n\"If the pain after hitting the hand with a hammer would appear after a month - people would notoriously walk with swollen fingers\"\n100% (^2)\n\nRegards\nJaroslaw\n\n\n\nW dniu 2022-08-17 13:10:38 u\u017cytkownik Erik Aronesty <erik at q32.com> napisa\u0142:\n\n> you can stop talking about\u00a0 the \"security of the system\" as meaningful\n> this has been discussed enough\n> if fees are not sufficient, clearance times increase and large stakeholders are incentivised to mine\u00a0\n> in the best case, fees are sufficient\n> in the worst case, it degrades to proof of stake\n> i'm sure you can see how that's fine either\u00a0way\n\n\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Breno Brito",
                "date": "2022-08-18T15:29:01",
                "message_text_only": "Since we are talking about inflation and Milton Friedman, this Friedman's\ninterview seems relevant.\n[image: image.png]\nSource:\nhttps://www.econlib.org/library/Columns/y2006/Friedmantranscript.html\n\nRegards,\nBreno Brito\n\n\nOn Wed, Aug 17, 2022 at 11:31 AM Jaroslaw via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> On one scale you puts the Trust to the large stakeholders (why we avoid\n> plenty of small stakeholders, btw),\n> and on the other side I put game theory and well defined Prisoner's\n> Dilemma.\n>\n> Again: large stakeholders WILL NOT incentivised to mine, they will have\n> the hundreds excuses why not to switch-on Antminers back.\n> That's how it simply works.  Bitcoin would fail miserably if Satoshi was\n> based his concept mainly on existence of idealists.\n>\n> If we will observe lack of hashrate recovery four years after some halving\n> and still unprepared like today\n> - means the trust in large stakeholders was a very costly mistake.\n>\n>\n> Superiority of Proof of Work against Proof of Stake has been discussed\n> enough either\n> The overall conclusion with what I fully agree  is: swapping PoW to PoS -\n> would be a degradation.\n> You can stop talking about degradation to proof of stake, but just:\n> degradation.\n>\n> Degradation of Bitcoin, due to human greed.\n>\n> Now you mine and you have an INSTANT gratification.\n> Then you will mine and it will cost you real money, but simple switch -\n> and you have a DELAYED, maybe some day in the future, maybe only a tiny -\n> punishment.\n> And The Punishment Won't Be Tiny.\n>\n>\n> \"If the pain after hitting the hand with a hammer would appear after a\n> month - people would notoriously walk with swollen fingers\"\n> 100% (^2)\n>\n> Regards\n> Jaroslaw\n>\n>\n>\n> W dniu 2022-08-17 13:10:38 u\u017cytkownik Erik Aronesty <erik at q32.com>\n> napisa\u0142:\n>\n> > you can stop talking about  the \"security of the system\" as meaningful\n> > this has been discussed enough\n> > if fees are not sufficient, clearance times increase and large\n> stakeholders are incentivised to mine\n> > in the best case, fees are sufficient\n> > in the worst case, it degrades to proof of stake\n> > i'm sure you can see how that's fine either way\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220818/02c2e796/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: image.png\nType: image/png\nSize: 121588 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220818/02c2e796/attachment-0001.png>"
            },
            {
                "author": "Billy Tetrud",
                "date": "2022-08-18T15:44:11",
                "message_text_only": "While constant tail emission does in fact converge to 0 inflation over time\n(which bitcoin's halvings do as well mind you), tail emission does *not*\nsolve the potential problem of mining rewards, it only delays it. A tail\nemission of 200,000 btc/year (~1% of the current supply) would be\nequivalent to halvings every ~50 years rather than every 4 years. Were we\nto implement this kind of thing right after the last non-\" destructive\"\nhalving, it would buy us 46 years of extra time. Nothing more, nothing less.\n\nWhile its mildly interesting to know that tail emission converges to a\nstable point, while no inflation implies monetary deflation at the rate of\nloss, this feels very likely to be an insignificant problem. I think 1%\nloss rate per year is an absurdly high estimate these days, and the loss\nrate is likely to decrease as methods of storing bitcoin mature. Imagine\nbitcoin was worth $1 trillion (not so hard, since it was not too long ago),\nthen try imagining people losing $10 billion of bitcoin every year. Highly\nunlikely IMO. A rate of loss of 0.01%/year might be more realistic for a\nnear-future mature bitcoin. That's not going to be enough to make a\nsignificant difference even over 100s of years.\n\nIf we actually wanted to solve the potential problem of not-enough-fees to\nupkeep mining security, there are less temporary ways to solve that. For\nexample, if fees end up not being able to support sufficient mining, we\ncould add emission based on a constant fraction of fees in the block. For\nexample, every block could emit new bitcoin amounting to 10% of the fees\ncollected in that block. This would tie coinbase rewards to the real world\n(since the fee market is tied to the real economy) and ensure higher block\nrevenue indefinitely - ie not just for another 50 years.\n\nBut its also worth saying that blockchain security (which mining revenue\ncorrelates with) does *not* need to increase indefinitely. There is some\namount of security (and therefore some amount of mining revenue) that is\nsufficient, beyond which additional security is simply unnecessary,\nunwarranted, and wasteful (you wouldn't buy a $1000 safe to store $1000 of\nvaluables). Do we, as the bitcoin community, have some good idea how much\nsecurity we need? Do we have some idea how costly a 51% attack must be\nwhere we can be comfortable it will never happen? I'm curious to hear what\npeople think about that. Because without having some kind of estimates of\nwhat \"enough security\" is, there's absolutely no way of evaluating whether\nor not its likely that bitcoin fees alone will be able to sustain enough\nsecurity.\n\n\n\nOn Wed, Aug 17, 2022 at 9:31 AM Jaroslaw via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> On one scale you puts the Trust to the large stakeholders (why we avoid\n> plenty of small stakeholders, btw),\n> and on the other side I put game theory and well defined Prisoner's\n> Dilemma.\n>\n> Again: large stakeholders WILL NOT incentivised to mine, they will have\n> the hundreds excuses why not to switch-on Antminers back.\n> That's how it simply works.  Bitcoin would fail miserably if Satoshi was\n> based his concept mainly on existence of idealists.\n>\n> If we will observe lack of hashrate recovery four years after some halving\n> and still unprepared like today\n> - means the trust in large stakeholders was a very costly mistake.\n>\n>\n> Superiority of Proof of Work against Proof of Stake has been discussed\n> enough either\n> The overall conclusion with what I fully agree  is: swapping PoW to PoS -\n> would be a degradation.\n> You can stop talking about degradation to proof of stake, but just:\n> degradation.\n>\n> Degradation of Bitcoin, due to human greed.\n>\n> Now you mine and you have an INSTANT gratification.\n> Then you will mine and it will cost you real money, but simple switch -\n> and you have a DELAYED, maybe some day in the future, maybe only a tiny -\n> punishment.\n> And The Punishment Won't Be Tiny.\n>\n>\n> \"If the pain after hitting the hand with a hammer would appear after a\n> month - people would notoriously walk with swollen fingers\"\n> 100% (^2)\n>\n> Regards\n> Jaroslaw\n>\n>\n>\n> W dniu 2022-08-17 13:10:38 u\u017cytkownik Erik Aronesty <erik at q32.com>\n> napisa\u0142:\n>\n> > you can stop talking about  the \"security of the system\" as meaningful\n> > this has been discussed enough\n> > if fees are not sufficient, clearance times increase and large\n> stakeholders are incentivised to mine\n> > in the best case, fees are sufficient\n> > in the worst case, it degrades to proof of stake\n> > i'm sure you can see how that's fine either way\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220818/bc7a359b/attachment.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2022-08-18T20:49:55",
                "message_text_only": "1...\n>  Degradation\n\nRemember, if hash rate declines (no sign that it will so far), the\nnet-effect is longer clearance times for large transactions.\n\nIt's not \"failure\" or \"breaking\"\n\n2...\nCertainly, if demand for blockspace isn't high enough to support clearance\nthen the *first *thing to do would be to improve the utility of the chain\nso that demand for blockspace is high.\n\nThis is one of the strong reasons to support research like covenants and\nrgb and taro.   If those tools become popular, we will see rising fees.\n Indeed, large miners should be *paying* researchers to advance these\ntools.   It's in their own best interests.\n\n3...\n> and on the other side I put game theory and well defined Prisoner's\nDilemma.\n\nThe prisoner's dilemma does not state that zero stakeholders will\nmine, just far fewer.   Real world experiments with actual prisoners and\nstudents show cooperation rates of 33%.  Plus there are incentives.\nStakeholders who want to move large amounts in a reasonable amount of time\nare incentivised to mine.\n\n4...\nChanging issuance is a non-starter, forte very game-theoretic reasons you\nrefer to\n\nit would destroy the value proposition of the chain, fork the coin and i\nhave every confidence that the surviving fork would be the one without the\nnew issuance\n\n\nOn Wed, Aug 17, 2022 at 9:43 AM <jk_14 at op.pl> wrote:\n\n>\n> On one scale you puts the Trust to the large stakeholders (why we avoid\n> plenty of small stakeholders, btw),\n> and on the other side I put game theory and well defined Prisoner's\n> Dilemma.\n>\n> Again: large stakeholders WILL NOT incentivised to mine, they will have\n> the hundreds excuses why not to switch-on Antminers back.\n> That's how it simply works.  Bitcoin would fail miserably if Satoshi was\n> based his concept mainly on existence of idealists.\n>\n> If we will observe lack of hashrate recovery four years after some halving\n> and still unprepared like today\n> - means the trust in large stakeholders was a very costly mistake.\n>\n>\n> Superiority of Proof of Work against Proof of Stake has been discussed\n> enough either\n> The overall conclusion with what I fully agree  is: swapping PoW to PoS -\n> would be a degradation.\n> You can stop talking about degradation to proof of stake, but just:\n> degradation.\n>\n> Degradation of Bitcoin, due to human greed.\n>\n> Now you mine and you have an INSTANT gratification.\n> Then you will mine and it will cost you real money, but simple switch -\n> and you have a DELAYED, maybe some day in the future, maybe only a tiny -\n> punishment.\n> And The Punishment Won't Be Tiny.\n>\n>\n> \"If the pain after hitting the hand with a hammer would appear after a\n> month - people would notoriously walk with swollen fingers\"\n> 100% (^2)\n>\n> Regards\n> Jaroslaw\n>\n>\n>\n> W dniu 2022-08-17 13:10:38 u\u017cytkownik Erik Aronesty <erik at q32.com>\n> napisa\u0142:\n>\n> > you can stop talking about  the \"security of the system\" as meaningful\n> > this has been discussed enough\n> > if fees are not sufficient, clearance times increase and large\n> stakeholders are incentivised to mine\n> > in the best case, fees are sufficient\n> > in the worst case, it degrades to proof of stake\n> > i'm sure you can see how that's fine either way\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220818/8f313bd8/attachment-0001.html>"
            },
            {
                "author": "jk_14 at op.pl",
                "date": "2022-08-18T20:22:30",
                "message_text_only": "Fortunately halving in 2020 will be non destructive because it looks like we will have higher difficulty in 2024 than in 2020.\n\nLet's assume the worst case scenario: after halving in 2024, we have regression of difficulty in 2028. Annual inflation rate in 2028 is 0.81%. Removal of halvings in this year means that in year 2100 (72 years later) we will have 0.51% annual inflation rate, still. And that is Monero concept in fact: constant annual supply, thus very slowly decreasing of inflation.\n\nYes, you are right. Better that that - would be to wait for bitcoin ecosystem to show us what is the equilibrium/saturation level at globe scale - I hope it will be several years later and \"the annual inflation to keep\" - will be 0.40% in 2032 or even 0.20% only in 2036.\n\nAnd then instead of halving every 210k blocks - just to adjust the block reward (i.e. slightly increase). To keep the annual inflation rate constant. Constant forever. On most proper level - because determined empirically. I didn't propose it, because of certain, immediate backlash :)\n\nAnd for the same reason, as an answer how much security we need. Empirically reached security level is - the most accurate one. In military terminology: the protection of already conquered land. Regression is sign of weakness and we probably don't want to see it in Bitcoin.\n\nAnyway, keeping Bitcoin in the middle of ultra-obvious Edge Case, with pathological Friedman's \"free lunches\" for stakeholders, due to this overtaxing (punish) people which are simply want to use Bitcoin, additionally with pure form of Prisoner's Dilemma here, and with Trust to \"large\" stakeholders, while almost every of them will convince himself he is not really a large one and \"let Microstrategy run Antminers\" (and burn money)\n\n- and all above only because we are too greed to pay miners as low as only few tenths of a percent per year for their real service as keeping network secure, pay in most honest way, because with no exceptions and proportionally to holdings - and instead of it we rather prefer to take the high risk of spiral of death - is madness.\n\n\nPure madness. This is what almost 50y old cynic may assure you.\n\nRegards\nJaroslaw\n\n\n\n\nW dniu 2022-08-18 17:44:29 u\u017cytkownik Billy Tetrud <billy.tetrud at gmail.com> napisa\u0142:\nWhile constant tail emission does in fact converge to 0 inflation over time (which bitcoin's halvings do as well mind you), tail emission does *not* solve the potential problem of mining rewards, it only delays it. A tail emission of 200,000 btc/year (~1% of the\u00a0current supply) would be equivalent to halvings every ~50 years rather than every 4 years. Were we to implement this kind of thing right after the last non-\" destructive\" halving, it would buy us 46 years of extra time. Nothing more, nothing less.\n\nWhile its mildly interesting to know that tail emission converges to a stable point, while no inflation implies monetary deflation at the rate of loss, this feels very likely to be an insignificant problem. I think 1% loss rate per year is an absurdly high estimate these days, and the loss rate is likely to decrease as methods of storing bitcoin mature. Imagine bitcoin was worth $1 trillion (not so hard, since it was not too long ago), then try imagining people losing $10 billion of bitcoin every year. Highly unlikely IMO. A rate of loss of 0.01%/year might be more realistic for a near-future mature bitcoin. That's not going to be enough to make a significant difference\u00a0even over 100s of years.\u00a0\n\nIf we actually wanted to solve the potential problem of not-enough-fees to upkeep mining security, there are less temporary ways to solve that. For example, if fees end up not being able to support sufficient mining, we could add emission based on a constant fraction of fees in the block. For example, every block could emit new bitcoin amounting to 10% of the fees collected in that block. This would tie coinbase rewards to the real world (since the fee market is tied to the real economy) and ensure higher block revenue indefinitely - ie not just for another\u00a050 years.\u00a0\n\nBut its also worth saying that blockchain security (which mining revenue correlates with) does *not* need to increase indefinitely. There is some amount of security (and therefore some amount of mining revenue) that is sufficient, beyond which additional security is simply unnecessary, unwarranted, and wasteful (you wouldn't buy a $1000 safe to store $1000 of valuables). Do we, as the bitcoin community, have some good idea how much security we need? Do we have some idea how costly a 51% attack must be where we can be comfortable it will never happen? I'm curious to hear what people think about that. Because without having some kind of estimates of what \"enough security\" is, there's absolutely no way of evaluating whether or not its likely that bitcoin fees alone will be able to sustain enough security.\u00a0\n\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "vjudeu at gazeta.pl",
                "date": "2022-08-19T05:34:25",
                "message_text_only": "> If we actually wanted to solve the potential problem of not-enough-fees to upkeep mining security, there are less temporary ways to solve that. For example, if fees end up not being able to support sufficient mining, we could add emission based on a constant fraction of fees in the block. For example, every block could emit new bitcoin amounting to 10% of the fees collected in that block. This would tie coinbase rewards to the real world (since the fee market is tied to the real economy) and ensure higher block revenue indefinitely - ie not just for another 50 years.\n\nMiners can game this system by moving their own coins in 100% fees transactions, just to produce more coins. You have one million BTC? No problem, just move them as fees, and you just created 100k BTC out of thin air, just because you are a wealthy miner. And even if that amount will be stolen, when some other miner will reorg your block, then still, miners will keep creating coins by moving them as fees, and the strongest miner will get the whole pot. And guess what: 100 blocks later you can reuse newly created 100k BTC to make another 10k BTC, so it will exponentially explode as (amountOfCoins*(1+0.1))^n function. And guess what: (1.1)^8 is 2.14358881. That means, after eight moves, you can double your coins, if you are a wealthy miner. And you can start with smaller amounts, to play it safe, but eventually, this system will degrade into \"coin doubler after 800 blocks\" or something similar.\n\n\nOn 2022-08-18 18:45:43 user Billy Tetrud via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\nWhile constant tail emission does in fact converge to 0 inflation over time (which bitcoin's halvings do as well mind you), tail emission does *not* solve the potential problem of mining rewards, it only delays it. A tail emission of 200,000 btc/year (~1% of the\u00a0current supply) would be equivalent to halvings every ~50 years rather than every 4 years. Were we to implement this kind of thing right after the last non-\" destructive\" halving, it would buy us 46 years of extra time. Nothing more, nothing less.\n\n\nWhile its mildly interesting to know that tail emission converges to a stable point, while no inflation implies monetary deflation at the rate of loss, this feels very likely to be an insignificant problem. I think 1% loss rate per year is an absurdly high estimate these days, and the loss rate is likely to decrease as methods of storing bitcoin mature. Imagine bitcoin was worth $1 trillion (not so hard, since it was not too long ago), then try imagining people losing $10 billion of bitcoin every year. Highly unlikely IMO. A rate of loss of 0.01%/year might be more realistic for a near-future mature bitcoin. That's not going to be enough to make a significant difference\u00a0even over 100s of years.\u00a0\n\n\nIf we actually wanted to solve the potential problem of not-enough-fees to upkeep mining security, there are less temporary ways to solve that. For example, if fees end up not being able to support sufficient mining, we could add emission based on a constant fraction of fees in the block. For example, every block could emit new bitcoin amounting to 10% of the fees collected in that block. This would tie coinbase rewards to the real world (since the fee market is tied to the real economy) and ensure higher block revenue indefinitely - ie not just for another\u00a050 years.\u00a0\n\n\nBut its also worth saying that blockchain security (which mining revenue correlates with) does *not* need to increase indefinitely. There is some amount of security (and therefore some amount of mining revenue) that is sufficient, beyond which additional security is simply unnecessary, unwarranted, and wasteful (you wouldn't buy a $1000 safe to store $1000 of valuables). Do we, as the bitcoin community, have some good idea how much security we need? Do we have some idea how costly a 51% attack must be where we can be comfortable it will never happen? I'm curious to hear what people think about that. Because without having some kind of estimates of what \"enough security\" is, there's absolutely no way of evaluating whether or not its likely that bitcoin fees alone will be able to sustain enough security.\u00a0\n\n\n\n\n\n\nOn Wed, Aug 17, 2022 at 9:31 AM Jaroslaw via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\nOn one scale you puts the Trust to the large stakeholders (why we avoid plenty of small stakeholders, btw),\nand on the other side I put game theory and well defined Prisoner's Dilemma.\n\nAgain: large stakeholders WILL NOT incentivised to mine, they will have the hundreds excuses why not to switch-on Antminers back.\nThat's how it simply works.\u00a0 Bitcoin would fail miserably if Satoshi was based his concept mainly on existence of idealists.\n\nIf we will observe lack of hashrate recovery four years after some halving and still unprepared like today\n- means the trust in large stakeholders was a very costly mistake.\n\n\nSuperiority of Proof of Work against Proof of Stake has been discussed enough either\nThe overall conclusion with what I fully agree\u00a0 is: swapping PoW to PoS - would be a degradation.\nYou can stop talking about degradation to proof of stake, but just: degradation.\n\nDegradation of Bitcoin, due to human greed.\n\nNow you mine and you have an INSTANT gratification.\nThen you will mine and it will cost you real money, but simple switch - and you have a DELAYED, maybe some day in the future, maybe only a tiny - punishment.\nAnd The Punishment Won't Be Tiny.\n\n\n\"If the pain after hitting the hand with a hammer would appear after a month - people would notoriously walk with swollen fingers\"\n100% (^2)\n\nRegards\nJaroslaw\n\n\n\nW dniu 2022-08-17 13:10:38 u\u017cytkownik Erik Aronesty <erik at q32.com> napisa\u0142:\n\n> you can stop talking about\u00a0 the \"security of the system\" as meaningful\n> this has been discussed enough\n> if fees are not sufficient, clearance times increase and large stakeholders are incentivised to mine\u00a0\n> in the best case, fees are sufficient\n> in the worst case, it degrades to proof of stake\n> i'm sure you can see how that's fine either\u00a0way\n\n\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "Surprisingly, Tail Emission Is Not Inflationary",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "jk_14 at op.pl",
                "Peter",
                "vjudeu at gazeta.pl",
                "Erik Aronesty",
                "aliashraf.btc At protonmail",
                "Breno Brito",
                "Billy Tetrud"
            ],
            "messages_count": 12,
            "total_messages_chars_count": 64379
        }
    },
    {
        "title": "[bitcoin-dev] New Silent Payment version",
        "thread_messages": [
            {
                "author": "woltx",
                "date": "2022-08-17T00:08:11",
                "message_text_only": "PR #24897 (https://github.com/bitcoin/bitcoin/pull/24897) has been updated with a new silent payment version, which eliminates some manual steps from the previous version (such as the need to set the `keypool` to avoid costly multi-key scan).\n\nThis is achieved by using a new descriptor type (\"sp()\") that has no range and contains exactly one key.\n\nExample: \"sp(cQq73sG9....JD51uaRD)#9llg6xjm\"\n\nThis descriptor introduces a new type of output: \"silent-payment\". This output type returns a standard Taproot script (Segwit V1), but with HRP changed from \"bc\" to \"sp\" on the mainnet (or \"tsp\" on testnet and signet).\nThis output type will always generate the same address (unless another \"sp\" descriptor is enabled on the same wallet).\n\n$ ./src/bitcoin-cli -signet getnewaddress '' 'silent-payment'\ntsp1pfmjyl7ecpmx8yf8cu6g3ez36jy7s9mzuh5pdnal3k0n588uzgmfs4s4fws\n\nTo create a silent transaction, simply use the silent payment address as one of the outputs.\nThe \"send\" RPC will automatically identify and tweak it.\n\nThe transaction can contain multiple outputs, combining silent and standard addresses.\n\nI have written a step by step signet tutorial so reviewers can test this new version easily.\n\nhttps://gist.github.com/w0xlt/a7b498ac1ff14b8c292a22be789bd93f\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220817/97c45a02/attachment.html>"
            },
            {
                "author": "woltx",
                "date": "2022-08-21T22:01:34",
                "message_text_only": "The current Silent Payment implementation uses the standard Taproot script (Segwit V1).\n\nThis does not in any way affect the consensus or auditability rules.\n\n\n\n\nSent with Proton Mail secure email.\n\n------- Original Message -------\nOn Wednesday, August 17th, 2022 at 11:21 PM, <damian at willtech.com.au> wrote:\n\n\n> Let's be clear, if Bitcoin allows secret payments that cannot be\n> publicly audited then they have exceeded the original consensus that\n> gave Bitcoin fungibility and I will be publicly disavowing Bitcoin and\n> advocating for a full sell down. Why don't you resurrect Monero. -DA.\n> \n> On 2022-08-17 10:08, woltx via bitcoin-dev wrote:\n> \n> > PR #24897 (https://github.com/bitcoin/bitcoin/pull/24897) has been\n> > updated with a new silent payment version, which eliminates some\n> > manual steps from the previous version (such as the need to set the\n> > `keypool` to avoid costly multi-key scan).\n> > \n> > This is achieved by using a new descriptor type (\"sp()\") that has no\n> > range and contains exactly one key.\n> > \n> > Example: \"sp(cQq73sG9....JD51uaRD)#9llg6xjm\"\n> > \n> > This descriptor introduces a new type of output: \"silent-payment\".\n> > This output type returns a standard Taproot script (Segwit V1), but\n> > with HRP changed from \"bc\" to \"sp\" on the mainnet (or \"tsp\" on\n> > testnet and signet).\n> > \n> > This output type will always generate the same address (unless another\n> > \"sp\" descriptor is enabled on the same wallet).\n> > \n> > $ ./src/bitcoin-cli -signet getnewaddress '' 'silent-payment'\n> > tsp1pfmjyl7ecpmx8yf8cu6g3ez36jy7s9mzuh5pdnal3k0n588uzgmfs4s4fws\n> > \n> > To create a silent transaction, simply use the silent payment address\n> > as one of the outputs.\n> > \n> > The \"send\" RPC will automatically identify and tweak it.\n> > \n> > The transaction can contain multiple outputs, combining silent and\n> > standard addresses.\n> > \n> > I have written a step by step signet tutorial so reviewers can test\n> > this new version easily.\n> > \n> > https://gist.github.com/w0xlt/a7b498ac1ff14b8c292a22be789bd93f\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Ali Sherief",
                "date": "2022-08-22T12:55:58",
                "message_text_only": "Besides, all silent payments are mined at the end of the day, so they are still transactions that are included in publicly auditable blocks.\n\nThe only thing that changes from the user's point of view is that these addresses cannot be heirarchically derived with BIP44 (or any other path for that matter). Nobody else can find out the HD paths of an address anyway.\n\n- Ali\n\nOn Sun, 21 Aug 2022 22:01:34 +0000, woltx at protonmail.com wrote:\n> The current Silent Payment implementation uses the standard Taproot script (Segwit V1).\n>\n> This does not in any way affect the consensus or auditability rules.\n>\n>\n>\n>\n> Sent with Proton Mail secure email.\n>\n> ------- Original Message -------\n> On Wednesday, August 17th, 2022 at 11:21 PM, <damian at willtech.com.au> wrote:\n>\n>\n> > Let's be clear, if Bitcoin allows secret payments that cannot be\n> > publicly audited then they have exceeded the original consensus that\n> > gave Bitcoin fungibility and I will be publicly disavowing Bitcoin and\n> > advocating for a full sell down. Why don't you resurrect Monero. -DA.\n> >\n> > On 2022-08-17 10:08, woltx via bitcoin-dev wrote:\n> >\n> > > PR #24897 (https://github.com/bitcoin/bitcoin/pull/24897) has been\n> > > updated with a new silent payment version, which eliminates some\n> > > manual steps from the previous version (such as the need to set the\n> > > `keypool` to avoid costly multi-key scan).\n> > >\n> > > This is achieved by using a new descriptor type (\"sp()\") that has no\n> > > range and contains exactly one key.\n> > >\n> > > Example: \"sp(cQq73sG9....JD51uaRD)#9llg6xjm\"\n> > >\n> > > This descriptor introduces a new type of output: \"silent-payment\".\n> > > This output type returns a standard Taproot script (Segwit V1), but\n> > > with HRP changed from \"bc\" to \"sp\" on the mainnet (or \"tsp\" on\n> > > testnet and signet).\n> > >\n> > > This output type will always generate the same address (unless another\n> > > \"sp\" descriptor is enabled on the same wallet).\n> > >\n> > > $ ./src/bitcoin-cli -signet getnewaddress '' 'silent-payment'\n> > > tsp1pfmjyl7ecpmx8yf8cu6g3ez36jy7s9mzuh5pdnal3k0n588uzgmfs4s4fws\n> > >\n> > > To create a silent transaction, simply use the silent payment address\n> > > as one of the outputs.\n> > >\n> > > The \"send\" RPC will automatically identify and tweak it.\n> > >\n> > > The transaction can contain multiple outputs, combining silent and\n> > > standard addresses.\n> > >\n> > > I have written a step by step signet tutorial so reviewers can test\n> > > this new version easily.\n> > >\n> > > https://gist.github.com/w0xlt/a7b498ac1ff14b8c292a22be789bd93f"
            }
        ],
        "thread_summary": {
            "title": "New Silent Payment version",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "woltx",
                "Ali Sherief"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 6251
        }
    },
    {
        "title": "[bitcoin-dev] New User experience with the Bitcoin-Cli",
        "thread_messages": [
            {
                "author": "Zaidan",
                "date": "2022-08-17T21:02:33",
                "message_text_only": "I recently started running a node and learning how to be effective with it from The Blockchain Commons project here.\n\nhttps://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line\n\nGranted, I am new at this, I may have tied my shoe laces together and wanted to get feedback on what I experienced and perhaps suggest some fixes.\n\nWith chain=<chain> set in the bitcoin.conf and then mistakenly combined with a network argument such as -testnet it provides the error message \"\n\nEXCEPTION: St13runtime_error\nInvalid combination of -regtest, -signet, -testnet and -chain. Can use at most one.\"\n\nAs a novice, I didn't quite understand where this collision was coming from or why as I copied the conf file from an old setup. I got some help from the bitcoin-dev irc and worked it out. I was told there is currently no way of notifying where the arguments are coming from a config file or client arguments. Would an new argument options category being applied to arguments being set when the .conf file is being ingested by ArgsManager.ReadConfigFiles help? I see an enum class called Source which is used with MergeSettings. Perhaps that could be of help for generating a more descriptive warning in ArgsManager::GetChainName?\n\nMy second novice mistake was the mix naming of test and testnet. The command 'bitcoin-cli -chain=testnet' was failing me. having 'bitcoin-cli -testnet' be the equivalent of 'bitcoin-cli -chain=test' caused confusion leading to my opinion that it would be beneficial for the names to match CBaseChainParams network names.\n\nargsman.AddArg(\"-chain=<chain>\", \"Use the chain <chain> (default: main). Allowed values: main, test, signet, regtest\", ArgsManager::ALLOW_ANY, OptionsCategory::CHAINPARAMS);\nargsman.AddArg(\"-testnet\", \"Use the test chain. Equivalent to -chain=test.\", ArgsManager::ALLOW_ANY, OptionsCategory::CHAINPARAMS);\n\nWould SetupChainParamsBaseOptions benefit from changing the added argument -testnet to -test to match the CBaseChainParams or add the argument of -test to maintain backwards capability.\n\nLast, this is the first time I'm dipping my toe into contributing to this software. I've read a fair amount of guides before I got started online and through Chaincode's educational endeavors. I hope this doesn't seem like bike-shedding, but a novices attempt to contribute in good faith.\n\nAny feedback of how this issue is presented will be warmly welcomed. I am looking forward to improving my effectiveness at engaging with this community.\n\nThank you for your time,\nZaidan\n\nSent with [Proton Mail](https://proton.me/) secure email. \u200b\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220817/7a6ebd47/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "New User experience with the Bitcoin-Cli",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Zaidan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2770
        }
    },
    {
        "title": "[bitcoin-dev] Mock introducing vulnerability in important Bitcoin projects",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2022-08-19T03:09:46",
                "message_text_only": "On Thu, Nov 18, 2021 at 09:29:24PM +0100, Prayank via bitcoin-dev wrote:\n> After reading all the emails, personally experiencing review process especially on important issues like privacy and security, re-evaluating everything and considering the time I can spend on this, I have decided to do this exercise for 3 projects with just 1 account. I have created a salted hash for the username as you had mentioned in the first email:\n> f40bcb13dbcbf7b6245becb757777586c22798ed7360cd9853572152ddf07a39\n> 3 Bitcoin projects are Bitcoin Core (full node implementation), LND (LN implementation) and Bisq (DEX).\n> Pull requests will be created in next 6 months. If vulnerability gets caught during review, will publicly announce here that the project caught the PR and reveal the de-commitment publicly. If not caught during review, will privately reveal both the inserted vulnerability and the review failure via the normal private vulnerability-reporting channels. A summary with all the details will be shared later.\n\nIt's now been nine months since this email, but I don't believe\nthere's been any public report on this exercise. Does this mean that a\nvulnerability has been introduced in one or all of the named projects?\n\nCheers,\naj"
            }
        ],
        "thread_summary": {
            "title": "Mock introducing vulnerability in important Bitcoin projects",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Anthony Towns"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1230
        }
    },
    {
        "title": "[bitcoin-dev] More uses for CTV",
        "thread_messages": [
            {
                "author": "James O'Beirne",
                "date": "2022-08-19T16:33:37",
                "message_text_only": "Over the past few months there have been a few potential uses of\nOP_CHECKTEMPLATEVERIFY (BIP-119)\n(https://github.com/bitcoin/bitcoin/pull/21702) that I've found\ninteresting.\n\n# Congestion control redux\n\nWhen I first heard of CTV, a presentation Jeremy did at Chaincode back\nin 2018 or '19, he cited congestion control as one of its main use\ncases.\n\nThe pitch went something like\n\n> When there is a high demand for blockspace it becomes very expensive\n> to make transactions. By using OP_CHECKTEMPLATEVERIFY, a large volume\n> payment processor may aggregate all their payments into a single O(1)\n> transaction for purposes of confirmation. Then, some time later, the\n> payments can be expanded out of that UTXO when the demand for\n> blockspace is decreased.\n\n(from https://utxos.org/uses/scaling/)\n\nAt the time that didn't particularly grab me; the idea of smoothing fee\nrates seemed nice but marginal.\n\nBut recently, two particular cases have made me reassess the value of\ncongestion control.\n\nThe first stems from the necessity of L2 protocols (payment channels,\nvaults, etc.) to, under certain circumstances, settle to the chain in a\ntimely way in order to prevent abuse of the protocol. If some\nunexpected condition (a protocol exploit, large network disconnect, en\nmasse vault breach, etc.) creates a situation where a large number of\ncontracts need to settle to the chain in short order, mempools could\nfill up and protocol failures could happen for want of mempool/block\nspace\n(\nhttps://github.com/jamesob/mempool.work#failure-one-mempool-to-rule-them-all\n).\n\nIn such a case, CTV could be used effectively to \"compress\" settlement\ncommitments, get them on-chain, and then facilitate later unpacking of\nthe CTV ouputs into the contract's true end state.\n\nThis amounts to `n` contract-control outputs (e.g. a lightning funding\ntransaction outputs) being spent into a single CTV output, which\ncommits to the final settlement state. Multiple parties could\ntrustlessly collaborate to settle into a single CTV output using\nSIGHASH_ALL | ANYONECANPAY. This requires a level of interaction\nsimilar to coinjoins.\n\nPut simply, CTV allows deferring the chainspace required for the final\nsettlement outputs, but still immediately requires space for the\ninputs. This might sound like a temporary reprieve from half-ish of the\nspace required to settle, but in many (most?) cases the outputs require\nsubstantially more space than the inputs, given that often we're\nsettling a single UTXO into multiple payouts per party. A 2, 3, or\n4-fold increase (depending on the contracting pattern) in capacity\nisn't a silver bullet, but it could ameliorate the damage of unexpected\nsettlement \"tidal waves.\"\n\nConceptually, CTV is the most parsimonious way to do such a scheme,\nsince you can't really get smaller than a SHA256 commitment, and that's\nessentially all CTV is.\n\nThe second congestion control case is related to a recent post Bram\nmade about stability under a no-block-subsidy regime. He posted\n\n> If transaction fees came in at an even rate over time all at the\n> exact same level then they work fine for security, acting similarly\n> to fixed block rewards. Unfortunately that isn't how it works in the\n> real world. There's a very well established day/night cycle with fees\n> going to zero overnight and even longer gaps on weekends and\n> holidays. If in the future Bitcoin is entirely dependent on fees for\n> security (scheduled very strongly) and this pattern keeps up\n> (overwhelmingly likely) then this is going to become a serious\n> problem.\n\n(from\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-July/020702.html\n)\n\nRyan Grant points out that CTV's congestion control use could help to\nsmooth fees, creating a less spiky incentive to mine\n(\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-July/020702.html\n).\n\nAdmittedly the original concern is speculative and a ways off from now,\nas others in the thread pointed out. But having CTV-based fee smoothing\nas an option certainly doesn't seem like a bad thing.\n\n\n# Atomic mining pool payouts\n\nLaurentia is a mining pool design that pays participants out directly\nfrom the coinbase of found blocks.\n\n> Block solve reward is distributed directly from the block to each\n> user, meaning each user gets a 'mined' transaction directly into\n> their wallet as soon as the block is solved so there is no wait to\n> get paid and no pool wallet storing user's rewards.\n\n(from\nhttps://laurentiapool.org/wp-content/uploads/2020/05/laurentiapool_whitepaper.pdf\n)\n\nI'm not a mining expert and so I can't speak to the efficacy of the\npaper as a whole, but direct-from-coinbase payouts seem like a\ndesirable feature which avoids some trust in pools. One limitation is\nthe size of the coinbase outputs owed to constituent miners; this\nlimits the number of participants in the pool.\n\nIf the payout was instead a single OP_CTV output, an arbitrary number\nof pool participants could be paid out \"atomically\" within a single\ncoinbase.\n\n---\n\nCTV both in concept and implementation is very simple, and I think it\nis likely to continue to yield potential applications.\n\"Settlement compression\" seems like a useful thing, especially in light\nof a possible increase in L2 usage, and CTV seems like the simplest\nmeans to enable it.\n\nInterestingly, an analogue for this pattern going the other direction\nis possible, e.g. non-interactive channel openings\n(https://utxos.org/uses/non-interactive-channels/), which would allow\ne.g. opening a lightning channel with a merchant who doesn't want to\nhave their spending keys constantly accessible from a point-of-sale,\nbut can still parse/verify CTV commitments.\n\nRegards,\nJames\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220819/9af239a2/attachment.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-08-19T17:20:41",
                "message_text_only": "Hi James,\n\nCould you elaborate on a L2 contract where speedy\nsettlement of the \"first part\" can be done, while having the rest\ntake their time? I'm more thinking about time-out based protocols.\n\nNaturally my mind drifts to LN, where getting the proper commitment\ntransaction confirmed in a timely fashion is required to get the proper\nbalances back. The one hitch is that for HTLCs you still need speedy\nresolution otherwise theft can occur. And given today's \"layered\ncommitment\" style transaction where HTLCs are decoupled from\nthe balance output timeouts, I'm not sure this can save much.\n\nI don't know enough about vault designs to judge.\n\nCTV style commitments have popped up in a couple places in my\nwork on eltoo(emulated via APO sig-in-script), but mostly in the\ncontext of reducing interactivity in protocols, not in byte savings per se.\n\nThanks!\n\nGreg\n\nOn Fri, Aug 19, 2022 at 12:34 PM James O'Beirne via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Over the past few months there have been a few potential uses of\n> OP_CHECKTEMPLATEVERIFY (BIP-119)\n> (https://github.com/bitcoin/bitcoin/pull/21702) that I've found\n> interesting.\n>\n> # Congestion control redux\n>\n> When I first heard of CTV, a presentation Jeremy did at Chaincode back\n> in 2018 or '19, he cited congestion control as one of its main use\n> cases.\n>\n> The pitch went something like\n>\n> > When there is a high demand for blockspace it becomes very expensive\n> > to make transactions. By using OP_CHECKTEMPLATEVERIFY, a large volume\n> > payment processor may aggregate all their payments into a single O(1)\n> > transaction for purposes of confirmation. Then, some time later, the\n> > payments can be expanded out of that UTXO when the demand for\n> > blockspace is decreased.\n>\n> (from https://utxos.org/uses/scaling/)\n>\n> At the time that didn't particularly grab me; the idea of smoothing fee\n> rates seemed nice but marginal.\n>\n> But recently, two particular cases have made me reassess the value of\n> congestion control.\n>\n> The first stems from the necessity of L2 protocols (payment channels,\n> vaults, etc.) to, under certain circumstances, settle to the chain in a\n> timely way in order to prevent abuse of the protocol. If some\n> unexpected condition (a protocol exploit, large network disconnect, en\n> masse vault breach, etc.) creates a situation where a large number of\n> contracts need to settle to the chain in short order, mempools could\n> fill up and protocol failures could happen for want of mempool/block\n> space\n> (\n> https://github.com/jamesob/mempool.work#failure-one-mempool-to-rule-them-all\n> ).\n>\n> In such a case, CTV could be used effectively to \"compress\" settlement\n> commitments, get them on-chain, and then facilitate later unpacking of\n> the CTV ouputs into the contract's true end state.\n>\n> This amounts to `n` contract-control outputs (e.g. a lightning funding\n> transaction outputs) being spent into a single CTV output, which\n> commits to the final settlement state. Multiple parties could\n> trustlessly collaborate to settle into a single CTV output using\n> SIGHASH_ALL | ANYONECANPAY. This requires a level of interaction\n> similar to coinjoins.\n>\n> Put simply, CTV allows deferring the chainspace required for the final\n> settlement outputs, but still immediately requires space for the\n> inputs. This might sound like a temporary reprieve from half-ish of the\n> space required to settle, but in many (most?) cases the outputs require\n> substantially more space than the inputs, given that often we're\n> settling a single UTXO into multiple payouts per party. A 2, 3, or\n> 4-fold increase (depending on the contracting pattern) in capacity\n> isn't a silver bullet, but it could ameliorate the damage of unexpected\n> settlement \"tidal waves.\"\n>\n> Conceptually, CTV is the most parsimonious way to do such a scheme,\n> since you can't really get smaller than a SHA256 commitment, and that's\n> essentially all CTV is.\n>\n> The second congestion control case is related to a recent post Bram\n> made about stability under a no-block-subsidy regime. He posted\n>\n> > If transaction fees came in at an even rate over time all at the\n> > exact same level then they work fine for security, acting similarly\n> > to fixed block rewards. Unfortunately that isn't how it works in the\n> > real world. There's a very well established day/night cycle with fees\n> > going to zero overnight and even longer gaps on weekends and\n> > holidays. If in the future Bitcoin is entirely dependent on fees for\n> > security (scheduled very strongly) and this pattern keeps up\n> > (overwhelmingly likely) then this is going to become a serious\n> > problem.\n>\n> (from\n>\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-July/020702.html\n> )\n>\n> Ryan Grant points out that CTV's congestion control use could help to\n> smooth fees, creating a less spiky incentive to mine\n> (\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-July/020702.html\n> ).\n>\n> Admittedly the original concern is speculative and a ways off from now,\n> as others in the thread pointed out. But having CTV-based fee smoothing\n> as an option certainly doesn't seem like a bad thing.\n>\n>\n> # Atomic mining pool payouts\n>\n> Laurentia is a mining pool design that pays participants out directly\n> from the coinbase of found blocks.\n>\n> > Block solve reward is distributed directly from the block to each\n> > user, meaning each user gets a 'mined' transaction directly into\n> > their wallet as soon as the block is solved so there is no wait to\n> > get paid and no pool wallet storing user's rewards.\n>\n> (from\n>\n> https://laurentiapool.org/wp-content/uploads/2020/05/laurentiapool_whitepaper.pdf\n> )\n>\n> I'm not a mining expert and so I can't speak to the efficacy of the\n> paper as a whole, but direct-from-coinbase payouts seem like a\n> desirable feature which avoids some trust in pools. One limitation is\n> the size of the coinbase outputs owed to constituent miners; this\n> limits the number of participants in the pool.\n>\n> If the payout was instead a single OP_CTV output, an arbitrary number\n> of pool participants could be paid out \"atomically\" within a single\n> coinbase.\n>\n> ---\n>\n> CTV both in concept and implementation is very simple, and I think it\n> is likely to continue to yield potential applications.\n> \"Settlement compression\" seems like a useful thing, especially in light\n> of a possible increase in L2 usage, and CTV seems like the simplest\n> means to enable it.\n>\n> Interestingly, an analogue for this pattern going the other direction\n> is possible, e.g. non-interactive channel openings\n> (https://utxos.org/uses/non-interactive-channels/), which would allow\n> e.g. opening a lightning channel with a merchant who doesn't want to\n> have their spending keys constantly accessible from a point-of-sale,\n> but can still parse/verify CTV commitments.\n>\n> Regards,\n> James\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220819/5b1465f3/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2022-08-20T03:03:52",
                "message_text_only": "Good morning Greg,\n\n\n> Hi James,\n> Could you elaborate on a L2 contract where speedy\n> settlement of the \"first part\" can be done, while having the rest\n> take their time? I'm more thinking about time-out based protocols.\n> \n> Naturally my mind drifts to LN, where getting the proper commitment\n> transaction confirmed in a timely fashion is required to get the proper\n> balances back. The one hitch is that for HTLCs you still need speedy\n> resolution otherwise theft can occur. And given today's \"layered\n> commitment\" style transaction where HTLCs are decoupled from\n> the balance output timeouts, I'm not sure this can save much.\n\nAs I understand it, layered commitments can be modified to use `OP_CTV`, which would be slightly smaller (need only to reveal a 32-byte `OP_CTV` hash on the witness instead of a 64-byte Taproot signature, or 73-byte classical pre-Taproot ECDSA signature), and is in fact precisely an example of the speedy settlement style.\n\n> CTV style commitments have popped up in a couple places in my\n> work on eltoo(emulated via APO sig-in-script), but mostly in the\n> context of reducing interactivity in protocols, not in byte savings per se.\n\nIn many offchain cases, all channel participants would agree to some pre-determined set of UTXOs, which would be implemented as a transaction spending some single UTXO and outputting the pre-determined set of UTXOs.\n\nThe single UTXO can be an n-of-n of all participants, so that all agree by contributing their signatures:\n\n* Assuming Taproot, the output address itself is 33 bytes (x4 weight).\n* The n-of-n multisignature is 64 witness bytes (x1 weight). \n\nAlternatly the single UTXO can be a P2WSH that reveals an `OP_CTV`:\n\n* The P2WSH is 33 bytes (x4 weight) --- no savings here.\n* The revelation of the `<hash> OP_CTV` is 33 witness bytes (x1 weight).\n\nThus, as I understand it, `OP_CTV` can (almost?) always translate to a small weight reduction for such \"everyone agrees to this set of UTXOs\" for all offchain protocols that would require it.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "David A. Harding",
                "date": "2022-08-19T18:53:39",
                "message_text_only": "On 2022-08-19 06:33, James O'Beirne via bitcoin-dev wrote:\n> Multiple parties could\n> trustlessly collaborate to settle into a single CTV output using\n> SIGHASH_ALL | ANYONECANPAY. This requires a level of interaction\n> similar to coinjoins.\n\nJust to make sure I understand, is the reason for SH_ALL|SH_ACP so that \nany of the parties can subsequently RBF fee bump the transaction?\n\n> Conceptually, CTV is the most parsimonious way to do such a scheme,\n> since you can't really get smaller than a SHA256 commitment\n\nWhat's the advantage of CTV here compared to presigned transactions?  If \nmultiple parties need to interact to cooperatively sign a transaction, \nno significant overhead is added by having them simultaneously sign a \nsecond transaction that spends from the output of the first transaction. \n  Presigned transactions actually have two small benefits I can think of:\n\n1. The payment from the first transaction (containing the spends from \nthe channel setup transactions) can be sent to a P2WPKH output, which is \nactually smaller than a SHA256 commitment.  Though this probably does \nrequire an extra round of communication for commit-and-reveal to prevent \na collision attack on the P2WPKH address.[1]\n\n2. Having the first transaction pay a either a P2WPKH or bech32m output \nand the second transaction spend from that UTXO may blend in better with \nother transactions, enhancing privacy.  This advantage probably isn't \ncompatible with SH_ALL|SH_ACP, though, and it would require other \nprivacy upgrades to LN.\n\n> direct-from-coinbase payouts seem like a\n> desirable feature which avoids some trust in pools.\n> [...]\n> If the payout was instead a single OP_CTV output, an arbitrary number\n> of pool participants could be paid out \"atomically\" within a single\n> coinbase.  One limitation is\n> the size of the coinbase outputs owed to constituent miners; this\n> limits the number of participants in the pool.\n\nI'm confused by this.  What is the size limitation on coinbase outputs, \nhow does it limit the number of participants in a pool, and how does CTV \nfix that?\n\nThanks,\n\n-Dave\n\n[1] \nhttps://bitcoinops.org/en/newsletters/2020/06/24/#reminder-about-collision-attack-risks-on-two-party-ecdsa"
            },
            {
                "author": "Jeremy Rubin",
                "date": "2022-08-19T21:01:25",
                "message_text_only": "Presigned transactions have to use a N-of-N (2-2 for ln, more for pools)\nmultisignature which is computed over the network whereas in-script\ncommitments can be done 1 key that is a non-secret point (e.g., just the\ngenerator I think works).\n\nFor large protocol trees (e.g., of size N) the savings can be substantial!\nIt also reduces the amount of state that needs to be stored since the\nin-script sigs can be deterministic.\n\nRene has some nice work demonstrating that latency in generating state\ntransitions has a very substantial cost to the efficiency of routing, maybe\nhe can chime in further.\n\n\nYou can also do a \"back-filling\" where you get the best of both, by (after\nyou commit to the quick to generate in-script version) lazily backfilling\nwith an equivalent p2wpkh version. If you have a channel, when you are in\n\"burst mode\", you can cancel the longer to generate p2wpkh version when\nnewer states come in. (data hazard/ bypass).\n\n\nWith respect to mining pools and size constraints,\nhttps://rubin.io/bitcoin/2021/12/12/advent-15/ shows how paying into\nbatches of channels can be used to trustlessly compress payouts without\ncustodial relationship.\n\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n\nOn Fri, Aug 19, 2022 at 11:53 AM David A. Harding via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On 2022-08-19 06:33, James O'Beirne via bitcoin-dev wrote:\n> > Multiple parties could\n> > trustlessly collaborate to settle into a single CTV output using\n> > SIGHASH_ALL | ANYONECANPAY. This requires a level of interaction\n> > similar to coinjoins.\n>\n> Just to make sure I understand, is the reason for SH_ALL|SH_ACP so that\n> any of the parties can subsequently RBF fee bump the transaction?\n>\n> > Conceptually, CTV is the most parsimonious way to do such a scheme,\n> > since you can't really get smaller than a SHA256 commitment\n>\n> What's the advantage of CTV here compared to presigned transactions?  If\n> multiple parties need to interact to cooperatively sign a transaction,\n> no significant overhead is added by having them simultaneously sign a\n> second transaction that spends from the output of the first transaction.\n>   Presigned transactions actually have two small benefits I can think of:\n>\n> 1. The payment from the first transaction (containing the spends from\n> the channel setup transactions) can be sent to a P2WPKH output, which is\n> actually smaller than a SHA256 commitment.  Though this probably does\n> require an extra round of communication for commit-and-reveal to prevent\n> a collision attack on the P2WPKH address.[1]\n>\n> 2. Having the first transaction pay a either a P2WPKH or bech32m output\n> and the second transaction spend from that UTXO may blend in better with\n> other transactions, enhancing privacy.  This advantage probably isn't\n> compatible with SH_ALL|SH_ACP, though, and it would require other\n> privacy upgrades to LN.\n>\n> > direct-from-coinbase payouts seem like a\n> > desirable feature which avoids some trust in pools.\n> > [...]\n> > If the payout was instead a single OP_CTV output, an arbitrary number\n> > of pool participants could be paid out \"atomically\" within a single\n> > coinbase.  One limitation is\n> > the size of the coinbase outputs owed to constituent miners; this\n> > limits the number of participants in the pool.\n>\n> I'm confused by this.  What is the size limitation on coinbase outputs,\n> how does it limit the number of participants in a pool, and how does CTV\n> fix that?\n>\n> Thanks,\n>\n> -Dave\n>\n> [1]\n>\n> https://bitcoinops.org/en/newsletters/2020/06/24/#reminder-about-collision-attack-risks-on-two-party-ecdsa\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220819/3a8aa2ca/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "More uses for CTV",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "David A. Harding",
                "ZmnSCPxj",
                "Jeremy Rubin",
                "James O'Beirne",
                "Greg Sanders"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 21344
        }
    },
    {
        "title": "[bitcoin-dev] joinstr: coinjoin implementation using nostr",
        "thread_messages": [
            {
                "author": "alicexbt",
                "date": "2022-08-20T08:20:00",
                "message_text_only": "Hi Bitcoin Developers,\n\nI have written a python script as proof of concept for the [coinjoin implementation][1] using [nostr][2]. I used a lot of Python scripts created by others in school, so it feels nice to offer something that could be useful to others.\n\nThe implementation uses Bitcoin Core wallet and RPCs: `listunspent`, `getnewaddress`, `scantxoutset`, `createpsbt`, `combinepsbt`, `finalizepsbt` and `sendrawtransaction`. It requires python-nostr library because nostr is used for coordination between peers. Nostr is a decentralized network based on cryptographic keypairs. It is not peer-to-peer however simple and scalable.\n\nEvery step is published as an event using a nostr relay and 5 peers coordinate to create, sign and broadcast a coinjoin transaction.  I need to write a NIP that would be an alternative to blind signatures. Relay will share a random secret with clients for one round which should be present in output registration request although never gets published. If someone tries to register an output without registering any inputs, request would not have the number initially shared with inputs so request would get rejected or published as unverified. Relay would not be able to link inputs and outputs as the number is same for all inputs in a round and they get registered at different times with new keys and IP address. Clients can use multiple relays at the same time to avoid trusting one relay. This would result in different shared secret number but same process. If a relay tries to cheat, users will not sign the transaction and avoid using it in future.\n\nUsage:\n\n 1)Run `python coinjoin.py` and enter descriptor for one of the inputs.\n 2)Script will check inputs for this round in every 30 seconds and register a new adddress for output once 5 inputs are registered.\n 3)Similar check happens every 30 seconds for outputs. Last peer should create a PSBT.\n 4)Unsigned PSBT will be printed and signed by wallet with `walletprocesspsbt` RPC.\n 5)Script will check signed PSBTs and last peer to sign should finalize coinjoin transaction once 5 signed PSBTs are received.\n 6)Coinjoin transaction will be broadcasted and txid will printed.\n\nExample:\n\n```\nList of utxos in wallet:\n\nwpkh([53830dca/84'/1'/0'/0/0]02449be5fb74725255eeeb50eba930fa87705f21e99d13cd710cf2c1f21153c808)#x2hyyeg5\n\nEnter descriptor for the input registration: wpkh([53830dca/84'/1'/0'/0/0]02449be5fb74725255eeeb50eba930fa87705f21e99d13cd710cf2c1f21153c808)#x2hyyeg5\n\nevent id:  bcbbe62d75d99fed73f1e50ac58a38d1840b658951893e63c0322b378d7d56f0\n\n```\n```\ntb1qhxrp4zl54ul0twtyz0gury5399q7z0kvqqrl6m registered for output\n\nevent id: 9449c9065bef356d21507a98f88b028b17fc1c49eb195c8d4420604fcaaef041\n```\n```\nUnsigned PSBT: cHNidP8BAP1yAQIAAAAFtMaoJYcXvOG5L3Yaz3YyS7gIt4h5/zzOrRRS3hrVvwoAAAAAAP////+o83geaSm4L76KToIUl5MiZqLAUbIDJLq6DWrjP/3b8AEAAAAA/////zEF3CXIvVHpIa7No1s1yg+KtyOfXTRSyWnOdXMfzcDwAQAAAAD/////wMa4XAgnU+39Ien+KG9rYtv8bLMNYakmZyY/QFfwLRcAAAAAAP/////5M42ID6uLmQTb2tnFHnN7UMpnDD25uN8ZX7A+GNSM3QEAAAAA/////wV4xwEAAAAAABYAFLmGGov0rz71uWQT0cGSkSlB4T7MeMcBAAAAAAAWABSc0/FM6Hdbdxh10IJkYOklVFWqjnjHAQAAAAAAFgAUPSZKe/w6PT6qIF+WhL4wHaFymjd4xwEAAAAAABYAFMx0rxYlpPWB3NFry4Ctk2eVi/UNeMcBAAAAAAAWABSzc4xK0VTfvjK0MHXrAUFLYgYnOgAAAAAAAAAAAAAAAAAAAA==\n\nevent id: 976744b38fa9343fb79e1b5215512ead6ee08e5890d79a201fc5b872f6de4eba\n```\n```\nSigned PSBT: cHNidP8BAP1yAQIAAAAFtMaoJYcXvOG5L3Yaz3YyS7gIt4h5/zzOrRRS3hrVvwoAAAAAAP////+o83geaSm4L76KToIUl5MiZqLAUbIDJLq6DWrjP/3b8AEAAAAA/////zEF3CXIvVHpIa7No1s1yg+KtyOfXTRSyWnOdXMfzcDwAQAAAAD/////wMa4XAgnU+39Ien+KG9rYtv8bLMNYakmZyY/QFfwLRcAAAAAAP/////5M42ID6uLmQTb2tnFHnN7UMpnDD25uN8ZX7A+GNSM3QEAAAAA/////wV4xwEAAAAAABYAFLmGGov0rz71uWQT0cGSkSlB4T7MeMcBAAAAAAAWABSc0/FM6Hdbdxh10IJkYOklVFWqjnjHAQAAAAAAFgAUPSZKe/w6PT6qIF+WhL4wHaFymjd4xwEAAAAAABYAFMx0rxYlpPWB3NFry4Ctk2eVi/UNeMcBAAAAAAAWABSzc4xK0VTfvjK0MHXrAUFLYgYnOgAAAAAAAQBxAgAAAAG+qpMXZCy6tBuUlgo8JD0GVXKp60FkhwDeg2sF1fkFkwMAAAAA/f///wLo9wEAAAAAABYAFFfLA5xarC/w/SxeMDQ5tuXrYJLUWwMAAAAAAAAWABRfPf//hwMjHB4OKj87cU19XOSh7yOWAQABAR/o9wEAAAAAABYAFFfLA5xarC/w/SxeMDQ5tuXrYJLUAQhrAkcwRAIgOIhLoC5348U8YkEr4GU1K4yWskIOEXgW4Wsk/W2cR7ICIEJXqtOuDJ5CkwrSuwJLWtzab4dslbN3KuL/pyooMnOCASECRJvl+3RyUlXu61DrqTD6h3BfIemdE81xDPLB8hFTyAgAAAAAACICA77Cnd6o3kr0yc+91eabpOn5igs/MUMbudNYSS6oyMWMGFODDcpUAACAAQAAgAAAAIAAAAAAFAAAAAAAAAAA\n\nevent id: 5846b6e6902f3c5a43496d7d9785ed62444aa74963f03c33d637d8b09ee7a139\n```\n```\nCoinjoin tx: 75e490b10b15a6a0422f25ff66ad98ef70390c8fecaac02712705dce8cc3564b\n\nevent id: 9b5d4bf279b59e2b6e539e683fba83da72dce2b640360aa95db1b1400be93190\n```\n\nThere are lot of things that could be improved and a few suggestions are in the gist that described the [idea][3]. I would love read to any opinions about this experiment and will start working on creating an Android app for joinstr next week.\n\nCredits:\n\n- fiatjaf (Nostr)\n- Andrew Chow (PSBT)\n- Jeff Thibault (python-nostr)\n- Existing coinjoin implmentations\n\n[1]: https://github.com/1440000bytes/joinstr\n[2]: https://github.com/nostr-protocol/nostr\n[3]: https://gist.github.com/1440000bytes/1c305097b070c8374cc3b91f50314a45\n\n/dev/fd0\n\nSent with Proton Mail secure email."
            },
            {
                "author": "Max Hillebrand",
                "date": "2022-08-20T10:04:11",
                "message_text_only": "Great to see an implementation of the idea.\n\nMaybe I misunderstand, but isn't there a vulnerability of denial of service here?\n\nA user who registers one input will receive the round secret identifier, and this is all the information required for output registration. However, that malicious user can now register multiple outputs, providing the same secret, and nobody can link the malicious outputs to any specific input. Therefor there cannot be a blame round where the malicious input is removed, and thus there can be a ongoing free denial of service attack without attribution or defense.\n\nSkol\nMax\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220820/ed6040a1/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: sender_key.asc\nType: application/pgp-keys\nSize: 3910 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220820/ed6040a1/attachment.bin>"
            },
            {
                "author": "alicexbt",
                "date": "2022-08-20T16:52:56",
                "message_text_only": "Hi Max,\n\nThere a few DoS vectors that need to be fixed. Its just a proof of concept that I wanted to share with everyone to get feedback which could be improved over time. There is also a warning at the bottom of README to not use this on mainnet as it might have bugs.\n\nI will continue the development with coinjoin transactions on signet for a few weeks until there is a stable release with no bugs. \n\nI have a few ideas in mind for various relay types that might be used concurrently to prevent numerous problems. Custom relays are supported by Nostr. Examples include paying a fee to register for a round, subscribing with a time limit, or using invite-only relays. I will run a free and open nostr relay for this project and try to fix the Dos issues before a mainnet version is released for python script(for nerds) and android app (for all users).\n\nRelated links: \n\nhttps://github.com/fiatjaf/relayer\nhttps://github.com/fiatjaf/expensive-relay\nhttps://github.com/fiatjaf/relayer/tree/master/whitelisted\n\n/dev/fd0\n\n\nSent with Proton Mail secure email.\n\n------- Original Message -------\nOn Saturday, August 20th, 2022 at 10:04 AM, Max Hillebrand <max at towardsliberty.com> wrote:\n\n\n> Great to see an implementation of the idea.\n> \n> Maybe I misunderstand, but isn't there a vulnerability of denial of service here?\n> \n> A user who registers one input will receive the round secret identifier, and this is all the information required for output registration. However, that malicious user can now register multiple outputs, providing the same secret, and nobody can link the malicious outputs to any specific input. Therefor there cannot be a blame round where the malicious input is removed, and thus there can be a ongoing free denial of service attack without attribution or defense.\n> \n> Skol\n> Max\n> \n> \n> On August 20, 2022 10:20:00 AM GMT+02:00, alicexbt via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> > Hi Bitcoin Developers,\n> > \n> > I have written a python script as proof of concept for the [coinjoin implementation][1] using [nostr][2]. I used a lot of Python scripts created by others in school, so it feels nice to offer something that could be useful to others.\n> > \n> > The implementation uses Bitcoin Core wallet and RPCs: `listunspent`, `getnewaddress`, `scantxoutset`, `createpsbt`, `combinepsbt`, `finalizepsbt` and `sendrawtransaction`. It requires python-nostr library because nostr is used for coordination between peers. Nostr is a decentralized network based on cryptographic keypairs. It is not peer-to-peer however simple and scalable.\n> > \n> > Every step is published as an event using a nostr relay and 5 peers coordinate to create, sign and broadcast a coinjoin transaction.  I need to write a NIP that would be an alternative to blind signatures. Relay will share a random secret with clients for one round which should be present in output registration request although never gets published. If someone tries to register an output without registering any inputs, request would not have the number initially shared with inputs so request would get rejected or published as unverified. Relay would not be able to link inputs and outputs as the number is same for all inputs in a round and they get registered at different times with new keys and IP address. Clients can use multiple relays at the same time to avoid trusting one relay. This would result in different shared secret number but same process. If a relay tries to cheat, users will not sign the transaction and avoid using it in future.\n> > \n> > Usage:\n> > \n> >  1)Run `python coinjoin.py` and enter descriptor for one of the inputs.\n> >  2)Script will check inputs for this round in every 30 seconds and register a new adddress for output once 5 inputs are registered.\n> >  3)Similar check happens every 30 seconds for outputs. Last peer should create a PSBT.\n> >  4)Unsigned PSBT will be printed and signed by wallet with `walletprocesspsbt` RPC.\n> >  5)Script will check signed PSBTs and last peer to sign should finalize coinjoin transaction once 5 signed PSBTs are received.\n> >  6)Coinjoin transaction will be broadcasted and txid will printed.\n> > \n> > Example:\n> > \n> > ```\n> > List of utxos in wallet:\n> > \n> > wpkh([53830dca/84'/1'/0'/0/0]02449be5fb74725255eeeb50eba930fa87705f21e99d13cd710cf2c1f21153c808)#x2hyyeg5\n> > \n> > Enter descriptor for the input registration: wpkh([53830dca/84'/1'/0'/0/0]02449be5fb74725255eeeb50eba930fa87705f21e99d13cd710cf2c1f21153c808)#x2hyyeg5\n> > \n> > event id:  bcbbe62d75d99fed73f1e50ac58a38d1840b658951893e63c0322b378d7d56f0\n> > \n> > ```\n> > ```\n> > tb1qhxrp4zl54ul0twtyz0gury5399q7z0kvqqrl6m registered for output\n> > \n> > event id: 9449c9065bef356d21507a98f88b028b17fc1c49eb195c8d4420604fcaaef041\n> > ```\n> > ```\n> > Unsigned PSBT: cHNidP8BAP1yAQIAAAAFtMaoJYcXvOG5L3Yaz3YyS7gIt4h5/zzOrRRS3hrVvwoAAAAAAP////+o83geaSm4L76KToIUl5MiZqLAUbIDJLq6DWrjP/3b8AEAAAAA/////zEF3CXIvVHpIa7No1s1yg+KtyOfXTRSyWnOdXMfzcDwAQAAAAD/////wMa4XAgnU+39Ien+KG9rYtv8bLMNYakmZyY/QFfwLRcAAAAAAP/////5M42ID6uLmQTb2tnFHnN7UMpnDD25uN8ZX7A+GNSM3QEAAAAA/////wV4xwEAAAAAABYAFLmGGov0rz71uWQT0cGSkSlB4T7MeMcBAAAAAAAWABSc0/FM6Hdbdxh10IJkYOklVFWqjnjHAQAAAAAAFgAUPSZKe/w6PT6qIF+WhL4wHaFymjd4xwEAAAAAABYAFMx0rxYlpPWB3NFry4Ctk2eVi/UNeMcBAAAAAAAWABSzc4xK0VTfvjK0MHXrAUFLYgYnOgAAAAAAAAAAAAAAAAAAAA==\n> > \n> > event id: 976744b38fa9343fb79e1b5215512ead6ee08e5890d79a201fc5b872f6de4eba\n> > ```\n> > ```\n> > Signed PSBT: cHNidP8BAP1yAQIAAAAFtMaoJYcXvOG5L3Yaz3YyS7gIt4h5/zzOrRRS3hrVvwoAAAAAAP////+o83geaSm4L76KToIUl5MiZqLAUbIDJLq6DWrjP/3b8AEAAAAA/////zEF3CXIvVHpIa7No1s1yg+KtyOfXTRSyWnOdXMfzcDwAQAAAAD/////wMa4XAgnU+39Ien+KG9rYtv8bLMNYakmZyY/QFfwLRcAAAAAAP/////5M42ID6uLmQTb2tnFHnN7UMpnDD25uN8ZX7A+GNSM3QEAAAAA/////wV4xwEAAAAAABYAFLmGGov0rz71uWQT0cGSkSlB4T7MeMcBAAAAAAAWABSc0/FM6Hdbdxh10IJkYOklVFWqjnjHAQAAAAAAFgAUPSZKe/w6PT6qIF+WhL4wHaFymjd4xwEAAAAAABYAFMx0rxYlpPWB3NFry4Ctk2eVi/UNeMcBAAAAAAAWABSzc4xK0VTfvjK0MHXrAUFLYgYnOgAAAAAAAQBxAgAAAAG+qpMXZCy6tBuUlgo8JD0GVXKp60FkhwDeg2sF1fkFkwMAAAAA/f///wLo9wEAAAAAABYAFFfLA5xarC/w/SxeMDQ5tuXrYJLUWwMAAAAAAAAWABRfPf//hwMjHB4OKj87cU19XOSh7yOWAQABAR/o9wEAAAAAABYAFFfLA5xarC/w/SxeMDQ5tuXrYJLUAQhrAkcwRAIgOIhLoC5348U8YkEr4GU1K4yWskIOEXgW4Wsk/W2cR7ICIEJXqtOuDJ5CkwrSuwJLWtzab4dslbN3KuL/pyooMnOCASECRJvl+3RyUlXu61DrqTD6h3BfIemdE81xDPLB8hFTyAgAAAAAACICA77Cnd6o3kr0yc+91eabpOn5igs/MUMbudNYSS6oyMWMGFODDcpUAACAAQAAgAAAAIAAAAAAFAAAAAAAAAAA\n> > \n> > event id: 5846b6e6902f3c5a43496d7d9785ed62444aa74963f03c33d637d8b09ee7a139\n> > ```\n> > ```\n> > Coinjoin tx: 75e490b10b15a6a0422f25ff66ad98ef70390c8fecaac02712705dce8cc3564b\n> > \n> > event id: 9b5d4bf279b59e2b6e539e683fba83da72dce2b640360aa95db1b1400be93190\n> > ```\n> > \n> > There are lot of things that could be improved and a few suggestions are in the gist that described the [idea][3]. I would love read to any opinions about this experiment and will start working on creating an Android app for joinstr next week.\n> > \n> > Credits:\n> > \n> > - fiatjaf (Nostr)\n> > - Andrew Chow (PSBT)\n> > - Jeff Thibault (python-nostr)\n> > - Existing coinjoin implmentations\n> > \n> > [1]: https://github.com/1440000bytes/joinstr\n> > [2]: https://github.com/nostr-protocol/nostr\n> > [3]: https://gist.github.com/1440000bytes/1c305097b070c8374cc3b91f50314a45\n> > \n> > /dev/fd0\n> > \n> > Sent with Proton Mail secure email.\n> > \n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "joinstr: coinjoin implementation using nostr",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "alicexbt",
                "Max Hillebrand"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 13616
        }
    },
    {
        "title": "[bitcoin-dev] [BIP] Implementing Multisig Using Taproot",
        "thread_messages": [
            {
                "author": "Ali Sherief",
                "date": "2022-08-20T13:49:05",
                "message_text_only": "Greetings list.\n\nFollowing the discussions I made about BIP322 delegation on this mailing list and in other places, I have decided that that delegation depends on a very similar problem that arises when writing contracts and commitments. That problem is how to implement private Multisig.\n\nOf course, this can already be done using Taproot. But I doubt that many people know how to do it using script paths. BIP342 briefly touches on the subject but leaves it open. So I wrote a BIP to plug this hole, that precisely follows the guidelines hinted by BIPs 341 and 342, for creating and spending Multisig outputs.\n\nI also managed to figure out the formula that BIP342 vaguely hinted at for figuring out \"cost-effective multisignatures\" (hint: it's not quadratic).\n\nAs far as I can tell, such a BIP hasn't been advanced before, so there should be no problem of \"try working on the other BIP\".\n\nUse cases:\n\n- Layer 2 protocols that use multisig (e.g. LN, Discrete Log Contracts)\n- BIP322 message signatures, if it is decided that UTXO delegation is desireable.\n\nI'm pasting the draft of the BIP below, with the metadata shaved off, but references are left intact. I haven't uploaded it to Github yet.\n\n--------\n\n== Summary ==\n\nThis document defines the proper way to construct Multisig outputs and spends that utilize the privacy provided by Taproot script paths.\n\n== Copyright ==\n\nThis document is licensed under the 2-clause BSD license.\n\n== Abstract ==\n\nA Multisignature (also called Multisig) unspent transaction output (UTXO) attached to an address allows two or more parties to restrict the spending of the UTXO inside the address until a specified number of parties sign the output spending it. Multisig UTXOs are extremely useful for creating contracts, and is therefore used in many applications where delegation of funds to a committee is required, such as in Lightning Network channels, in DLCs (Discrete Log Contracts), and in other kinds of contracts.\n\n== Motivation ==\n\nOP_CHECKMULTISIG has the disadvantage of revealing all co-signer public keys involved in a transaction. This compromises the privacy of those signers. Additionally, this construct is not compatible with Taproot because OP_CHECKMULTISIG is disabled in TapScript, thus those applications are unable to make use of Pay-to-Taproot (P2TR) addresses.\n\nConstructing a Multisig output on Taproot is technically possible, but its implementation has not been specified by any existing BIP, to the author's knowledge. Additionally, most developers of Bitcoin applications do not know how to construct Multisig Taproot outputs.\n\n== Design ==\n\nTaproot gives us three different options for implementing Multisig, each with their own advantages and disadvantages<ref>'''Multisig implementation options reference''' The options were originally enumerated in [https://jimmysong.github.io/taproot-multisig Jimmy Song's slideshow] in a more detailed manner.</ref>:\n# Single-leaf with a TapScript implementing K-of-N Multisig. This is functionally equivalent to legacy OP_CHECKMULTISIG, and shares all its advantages and disadvantages. In particular, all public keys of signers are revealed in the TapScript embedded in the first element of the witness program, so the privacy advantages of Taproot are compromised.\n# Multiple leaves, each with a TapScript implementing K-of-K Multisig.\n# Multiple leaves, each with a TapScript implementing MuSig of K keys (i.e. aggregate of K public keys).\n\nThis document uses the second option for implementing Multisig, because it only reveals the public keys of those who sign the transaction.<ref>'''Why wasn't MuSig considered?''' Although MuSig provides even more privacy by not revealing any original public keys all together, it is a cumbersome process to create since K parties must be online not only at one point to create the aggregated keys, but also at another point to create a signature. There is the problem of who will be the trustee of the MuSigs themselves, as opposed to just the delegated UTXOs. Also, There is no BIP that implements MuSig, to the author's knowledge.</ref>\n\n== Specification ==\n\nNotations used here are specified in [[bip-0340.mediawiki#design|BIP340]].\n\n''taproot_output_script'' and ''taproot_sign_script'' refers to the Python functions of [[bip-0341.mediawiki|BIP341]] with the same name.\n\n=== Constructing K-of-N Multisig outputs ===\n\nAll of the participating TapScripts must be collected together at construction-time. This implies that all signers must know each other beforehand<ref>'''Why should all signers know each other beforehand?''' Knowing all possible signers of a multisignature is required for many instances of delegation, so that an unknown party cannot insert a rogue signature at spending-time.</ref>.\n\nThe algorithm takes as inputs:\n* An integer value  ''m'', greater than 0\n* An array ''scripts'' of ''m'' TapScripts as byte-arrays.\n** The scripts must be written in the following format: \"[PubKey p<sub>1</sub>] OP_CHECKSIG [PubKey p<sub>2</sub>] OP_CHECKSIGADD ... [PubKey p<sub>K</sub>] OP_CHECKSIGADD OP_[K] OP_NUMEQUAL\"<ref>'''1-of-N Multisig TapScripts''', it is possible to save two bytes in each script by dropping \"OP_[K] OP_NUMEQUAL\" from the end of each script. Since OP_CHECKSIG will return 1 on success and the empty array on failure, and the script interpreter considers a final stack of truthy values such as 1 as the script succeeding, and likewise for falsy values such as the empty array, the additional OP_NUMEQUAL comparison and associated number push is redundant.</ref>\nWhere the list p<sub>1</sub> ... p<sub>K</sub> represents a unique combination of K public keys from the total set of N public keys. In this way, each TapScript is a K-of-K multisig, requiring the signatures of all parties participating in the TapLeaf.\n\nAnd returns as the outputs:\n* The scriptPubKey, including the hash of the generated withness program and the push bytes.\n\nAlgorithm steps:\n# Generate a random private key ''p'', in the range ''[0, n-1]''.\n# Set the internal key ''internal_pubkey'' to ''lift_x(0x0250929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0) + p*G''<ref>'''Why is an arbitrary public key used for signing and spending?''' All possible combinations of multisignature spends are already enumerated in the script path, so the internal public key is not only redundant, but a security hazard since it must be specified. Values that will make Taproot validation fail cannot be used. BIP341 advises that in such cases, an internal public key with unknown discrete logarithm should be used.</ref>, where ''G'' is the secp256k1 generator point.\n# Set ''script_tree'' to the empty list.\n# For each script (''i'' in the range ''[0,m-1]'', convert it into a tuple with first element a byte 0xc0 and second element the script itself, and append it to ''script_tree''.\n# Return the result of ''taproot_output_script(internal_pubkey, script_tree)''.\n\n\n=== Spending K-of-N Multisig outputs ===\n\nOnly one of the multisignature TapScripts will be spent in a K-of-N Taproot Multisig.\n\nThe algorithm takes as inputs:\n* An integer value  ''m'', greater than 0\n* An array ''scripts'' of ''m'' TapScripts as byte-arrays, in the format taken by the Multisig Construction algorithm\n* An integer value ''j'', greater than 0 and less than ''m'', that indicates which multisignature TapScript will be used to spend the output.\n* The witness stack ''inputs'' of the script ''scripts[i]'', as an array of byte-arrays.\n** The witness stack must be written in the following format: \"[Signature s<sub>K</sub>] [Signature s<sub>K-1</sub>] ... [Signature s<sub>0</sub>]\"\nWhere the list s<sub>1</sub> ... s<sub>K</sub> are the Schnorr signatures corresponding to the public keys p<sub>1</sub> ... p<sub>K</sub>. Note that the list of signatures is coded in the reverse order, because the script interpreter will pop the left-most byte-array as the first stack element, the second-left-most byte array as the second stack element, and so on.\n\nAnd returns as the outputs:\n* The witness, that can spend the scriptPubKey returned by the Multisig Construction algorithm.\n\nAlgorithm steps:\n# Generate a random private key ''p'', in the range ''[0, n-1]''.\n# Set the internal key ''internal_pubkey'' to ''lift_x(0x0250929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0) + p*G''<ref>'''Why is an arbitrary public key used for signing and spending?''' All possible combinations of multisignature spends are already enumerated in the TapLeaves, so the internal public key is not only redundant, but a security hazard since it must be specified. Values that will make Taproot validation fail cannot be used. BIP341 advises that in such cases, an internal public key with unknown discrete logarithm should be used.</ref>.\n# Set the internal key ''internal_pubkey'' to ''lift_x(0x0250929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0) + p*G'', where ''G'' is the secp256k1 generator point.\n# Set ''script_tree'' to the empty list.\n# For each script (''i'' in the range ''[0,m-1]'', convert it into a tuple with first element a byte 0xc0 and second element the script itself, and append it to ''script_tree''.\n# Return the result of ''taproot_sign_script(internal_pubkey, script_tree, j, inputs)''.\n\n== Notes ==\n\n[[bip342.mediawiki|BIP342]] mentions that a complete TapBranch of ''k-of-k'' multisignature leaves are \"only more cost effective for small values of ''k'' (1-of-''n'' for any ''n'', 2-of-''n'' for ''n \u2265 6'', 3-of-''n'' for ''n \u2265 9'', ...)\". Since the scripts are all of fixed size, and the number of TapLeaves can similarly be calculated, it is possible to derive a formula for the relative size in (v)bytes of a spent Multisig Taproot output.\n* The size of each script is ''33*K + 2''.\n* The size of the control block is ''33 + 32 * ceil(log2(nCr(N,K)))'', where ''nCr'' computes the binomial coefficient of ''N'' and ''K''.\n* Therefore, the size of the witness inside the output is ''32*ceil(log2(nCr(N,K))) + 33*K + 35''. A table of output sizes is provided for the first few values of N and K.\n\nN,K,Size (vbytes)\n1,1,68\n2,1,100\n2,2,101\n3,1,132\n3,2,165\n3,3,134\n4,1,132\n4,2,197\n4,3,198\n4,4,167\n5,1,164\n5,2,229\n5,3,262\n5,4,263\n5,5,200\n6,1,164\n6,2,229\n6,3,294\n6,4,295\n6,5,296\n6,6,233\n\nThe data shows that 1-of-N Multisig TapScripts have the smallest witness output, and K-of-N Multisig Tapscripts with ''K > 1'' and progressively increasing to ''N-1'' have increasingly larger sizes. Where the K-of-N combination has a smaller size than the equivalent N-of-N combination, it is deemed to be cost-efficient. Hence, since 2 cosigners out of a maximum of 6 makes a transaction size smaller than 6-of-6, 2-of-6 multisig is the largest cost-effective combination for ''N = 6''. If the data is extended, it can similary be proven that 3-of-9 multisig is the largest cost-effective combination for ''N = 9''.<ref>'''Cost-effective delegations''' Several delegation schemes such as Lightning Network channels use only a combination of 1-of-N and N-of-N multisig transactions, with small N > 1.</ref>\n\nThe following Python 3.8 code an be used to calculate transaction sizes for ''K > 0'', ''N > 0'', and ''N \u2265 K'':\n\n<source lang=\"python\">\n>>> import math\n>>> txsize = lambda n,k : 32*math.ceil(math.log2(math.comb(n, k))) + 33*k + 35\n>>> txsize(1,1)\n68\n# ...\n</source>\n\n\n== Rationale ==\n\n<references />\n\n== Acknowledgements ==\n\nThanks to garlonicon, vjudeu, and Ali Ashraf for providing feedback about multisignatures while this document was being written.\n\n--------\n\nI appreciate any comments about this, especially from the BIP editors.\n\n- Ali"
            }
        ],
        "thread_summary": {
            "title": "Implementing Multisig Using Taproot",
            "categories": [
                "bitcoin-dev",
                "BIP"
            ],
            "authors": [
                "Ali Sherief"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 11618
        }
    },
    {
        "title": "[bitcoin-dev] Huge wallets make Bitcoin Core unusable (Daemon+CLI & Qt)",
        "thread_messages": [
            {
                "author": "micaroni at gmail.com",
                "date": "2022-08-20T14:16:53",
                "message_text_only": "Hi dear devs,\n\n\n1. THE ISSUE - DAEMON+CLI\n========================\nI had a wallet in a server production since 2017 (5 years old) and when it\nreached about 273 MB, 2.079.337 transactions and 446.503 generated\naddresses, the performance started to degrade exponentially.\n\nMost of the commands, e.g. \"getbalance\", \"walletpassphrase\" and\n\"getreceivedbyaddress\" started to timeout (more than 15 minutes delay -\ndefault timeout). The CPU was 100% used (all 32 cores - with 150 load avg)\nand the machine became almost unusable breaking everything else, with the\ndefault config of 16 RPC threads and 15 min timeout and some attempt calls\nper mi\n\nIncreasing the timeout and/or the RPC threads in the config file turns\nthings even worse.\n\nPutting the wallet.dat in a very fast SSD disk and increasing the size of\nthe cache (I tried with 8GB) have improved but I'm not sure if it is enough.\n\n\n2. TEST ON BITCOIN QT\n====================\nIf you try to load the wallet in the \"bitcoin-qt\" everything gets stuck,\neven the system (OS/UI) doesn't respond anymore. You click on a button and\nreceive the message \"window doesn't respond, wait or terminate?\" - if you\nwait it releases after a while but it is slow and hard to use the wallet\nanyway.\n\n\n3. WHY IS THIS SO BAD?\n=====================\nThis is bad because the standard client becomes almost useless for the\nwallet feature:\n\n3.1) the wallet Qt already is not so popular among end users. It doesn't\nlook modern, slow to first sync and hard to use. That's why people prefer\nto use Electrum or Wasabi - I personally don't care but it's the sad truth;\n\n3.2) it becomes useless now also for servers in production, forcing them to\nuse third party solutions for huge wallets. Even if you split in 10 wallets\nit will just delay 10 times more each to degrade, postponing the problem\nbut not eliminating it. Not to mention the slow and daily degradation.\n\n\n4. SHOULD WE GIVE UP THE WALLET FEATURE?\n========================================\nThen, Bitcoin Core becomes just a reference implementation and blocks\nrelayers, but as an application wallet itself turns into a really bad\nchoice. --- It leads me to the following question: if we won't invest time\non improving this, shouldn't we remove the wallet feature at all? Why keep\na wallet feature that is not useful for the end user nor the production\nserver? Is it useful for what then?\n\n\n5. THE CURRENT \"SOLUTION\" IS BAD\n===============================\nCurrently, the only \"solution\" for huge wallets is shameful: create a new\none and send the funds there from time to time. But when is the right time\nexactly? The performance degrades suddenly or gets worse slowly for each\nnew address and/or tx?. And besides not being an elegant solution and \"not\nin the handbook\", it also can break a lot of things like monitoring old\naddresses and also can lead to privacy concerns unifying lots of inputs in\na big and expensive tx.\n\n\n6. OTHER USER CASES?\n====================\nI think this could also become an issue if we have LN nodes that use the\nBitcoin Core wallet infrastructure behind to open / close many channels for\na long time.\n\n\n7. FINAL THOUGHTS\n=================\nIf moving the wallet from a HDD to a SSD improved a lot, maybe just caching\nthe entire wallet in memory could improve even more, but I'm afraid some\ncode optimization is also necessary.\n\n\n8. SOME QUESTIONS\n==================\n8.1) Can we \"optimize\" a huge wallet without moving the funds to a new one?\nLike a \"fsck\" or eqv?\n\n8.2) Can we improve the cache usage somehow? Putting the entire wallet in\nmemory, for example?\n\n8.3) Is it possible to reduce the wallet size (273 MB is too much for a HD\nwallet)?\n\n8.4) Can we tell the CLI to ignore old addresses? What if I need to watch\nonly the last 30 days?\n\n8.5) How to improve the I/O treatment and/or CPU usage in the main thread\non Bitcoin-Qt to avoid window freezing on big and huge wallets?\n\n8.6) In the last case (if it was not possible to optimize the wallet or the\nCLI & Qt), can the CLI just warn the user like: \"the wallet is becoming too\nbig and slow, execute the command 'archive'\". And then, the command\n\"archive\" could rename the current wallet to something like\n\"wallet.dat.archive_until_20220818\", create a new \"wallet.dat\" and move the\nfunds automatically? Also, would it be nice to have an\n\"autoarchivehugewallets=1\" in the file config?\n\n\n9. POSSIBLE RELATED AND TESTS\n=============================\n\n[1] https://github.com/bitcoin/bitcoin/issues/15015\n[2] https://github.com/bitcoin/bitcoin/issues/15148\n[3] https://github.com/bitcoin/bitcoin/issues/16874\n[4] https://github.com/bitcoin/bitcoin/pull/17135\n[5] https://github.com/bitcoin/bitcoin/pull/18160\n[6] https://github.com/bitpay/bitcore-node/issues/463\n[7] https://github.com/RavenProject/Ravencoin/issues/499\n[8] https://github.com/sugarchain-project/sugarchain/issues/106\n[9]\nhttps://bitcoin.stackexchange.com/questions/111844/loadwallet-takes-too-much-and-times-out\n[10] https://bitcoin.stackexchange.com/a/45713/1761\n\n\nANOTHER POSSIBLE BUG\n======================\n\nEven if my node is 100% sync:\n2022-08-20T13:11:43Z UpdateTip: new\nbest=00000000000000000005bba0593c2be0f1d322223501591d2b31b544e3af3d0b\nheight=750300 version=0x2fffe000 log2_work=93.687081 tx=758181489\ndate='2022-08-20T13:11:16Z' progress=1.000000 cache=4.6MiB(34964txo)\n\nAfter a \"loadwallet\" command I am getting an old / wrong balance. The\nwallet is already empty because I had moved the funds to a new one 3 or 4\ndays ago but it is still showing the old  balance. I didn't receive any\nwarning message saying the need for a rescan or something like that.\n\nI am trying the \"rescanblockchain\" command but it is running and it taking\na looooooooooooooong time.\n\n\n\n\nBest regards,\n\nFelipe.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220820/07f9887b/attachment.html>"
            },
            {
                "author": "rhavar at protonmail.com",
                "date": "2022-08-20T15:06:27",
                "message_text_only": "Of all wallets I've tried, by a huge margin, bitcoin core performs the best with large wallets. I know several massive casinos like bustabit (which has a lot more transactions than your wallet) have been using bitcoin core for large wallets, so it can work.\n\nThe reason I don't recommend normal people use core, is because of the initial-block-download and not defaulting to a pruned mode.\n\nThe thing that makes your wallet slow is the large amount of wallet transactions. So the secret to running a large bitcoin core wallet is to just call `RemovePrunedFunds` on old transactions. Its actually a little tricky though, because you need to make sure the transaction is \"safe to remove\". The first, most obvious, reason a transaction would not be safe to remove is if it has a wallet utxo that you have not spent or have recently spent. The second, less obvious reason is if transaction B spends from transaction A, and you remove transaction B your wallet will think transaction A is unspent (but it's not!). So you have to prune \"Depth first\".\n\n-Ryan\n\n------- Original Message -------\nOn Saturday, August 20th, 2022 at 7:16 AM, Felipe Micaroni Lalli via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi dear devs,\n>\n> 1. THE ISSUE - DAEMON+CLI\n> ========================\n> I had a wallet in a server production since 2017 (5 years old) and when it reached about 273 MB, 2.079.337 transactions and 446.503 generated addresses, the performance started to degrade exponentially.\n>\n> Most of the commands, e.g. \"getbalance\", \"walletpassphrase\" and \"getreceivedbyaddress\" started to timeout (more than 15 minutes delay - default timeout). The CPU was 100% used (all 32 cores - with 150 load avg) and the machine became almost unusable breaking everything else, with the default config of 16 RPC threads and 15 min timeout and some attempt calls per mi\n>\n> Increasing the timeout and/or the RPC threads in the config file turns things even worse.\n>\n> Putting the wallet.dat in a very fast SSD disk and increasing the size of the cache (I tried with 8GB) have improved but I'm not sure if it is enough.\n>\n> 2. TEST ON BITCOIN QT\n> ====================\n> If you try to load the wallet in the \"bitcoin-qt\" everything gets stuck, even the system (OS/UI) doesn't respond anymore. You click on a button and receive the message \"window doesn't respond, wait or terminate?\" - if you wait it releases after a while but it is slow and hard to use the wallet anyway.\n>\n> 3. WHY IS THIS SO BAD?\n> =====================\n> This is bad because the standard client becomes almost useless for the wallet feature:\n>\n> 3.1) the wallet Qt already is not so popular among end users. It doesn't look modern, slow to first sync and hard to use. That's why people prefer to use Electrum or Wasabi - I personally don't care but it's the sad truth;\n>\n> 3.2) it becomes useless now also for servers in production, forcing them to use third party solutions for huge wallets. Even if you split in 10 wallets it will just delay 10 times more each to degrade, postponing the problem but not eliminating it. Not to mention the slow and daily degradation.\n>\n> 4. SHOULD WE GIVE UP THE WALLET FEATURE?\n> ========================================\n> Then, Bitcoin Core becomes just a reference implementation and blocks relayers, but as an application wallet itself turns into a really bad choice. --- It leads me to the following question: if we won't invest time on improving this, shouldn't we remove the wallet feature at all? Why keep a wallet feature that is not useful for the end user nor the production server? Is it useful for what then?\n>\n> 5. THE CURRENT \"SOLUTION\" IS BAD\n> ===============================\n> Currently, the only \"solution\" for huge wallets is shameful: create a new one and send the funds there from time to time. But when is the right time exactly? The performance degrades suddenly or gets worse slowly for each new address and/or tx?. And besides not being an elegant solution and \"not in the handbook\", it also can break a lot of things like monitoring old addresses and also can lead to privacy concerns unifying lots of inputs in a big and expensive tx.\n>\n> 6. OTHER USER CASES?\n> ====================\n> I think this could also become an issue if we have LN nodes that use the Bitcoin Core wallet infrastructure behind to open / close many channels for a long time.\n>\n> 7. FINAL THOUGHTS\n> =================\n> If moving the wallet from a HDD to a SSD improved a lot, maybe just caching the entire wallet in memory could improve even more, but I'm afraid some code optimization is also necessary.\n>\n> 8. SOME QUESTIONS\n> ==================\n> 8.1) Can we \"optimize\" a huge wallet without moving the funds to a new one? Like a \"fsck\" or eqv?\n>\n> 8.2) Can we improve the cache usage somehow? Putting the entire wallet in memory, for example?\n>\n> 8.3) Is it possible to reduce the wallet size (273 MB is too much for a HD wallet)?\n>\n> 8.4) Can we tell the CLI to ignore old addresses? What if I need to watch only the last 30 days?\n>\n> 8.5) How to improve the I/O treatment and/or CPU usage in the main thread on Bitcoin-Qt to avoid window freezing on big and huge wallets?\n>\n> 8.6) In the last case (if it was not possible to optimize the wallet or the CLI & Qt), can the CLI just warn the user like: \"the wallet is becoming too big and slow, execute the command 'archive'\". And then, the command \"archive\" could rename the current wallet to something like \"wallet.dat.archive_until_20220818\", create a new \"wallet.dat\" and move the funds automatically? Also, would it be nice to have an \"autoarchivehugewallets=1\" in the file config?\n>\n> 9. POSSIBLE RELATED AND TESTS\n> =============================\n>\n> [1] https://github.com/bitcoin/bitcoin/issues/15015\n> [2] https://github.com/bitcoin/bitcoin/issues/15148\n> [3] https://github.com/bitcoin/bitcoin/issues/16874\n> [4] https://github.com/bitcoin/bitcoin/pull/17135\n> [5] https://github.com/bitcoin/bitcoin/pull/18160\n> [6] https://github.com/bitpay/bitcore-node/issues/463\n> [7] https://github.com/RavenProject/Ravencoin/issues/499\n> [8] https://github.com/sugarchain-project/sugarchain/issues/106\n> [9] https://bitcoin.stackexchange.com/questions/111844/loadwallet-takes-too-much-and-times-out\n> [10] https://bitcoin.stackexchange.com/a/45713/1761\n>\n> ANOTHER POSSIBLE BUG\n> ======================\n>\n> Even if my node is 100% sync:\n> 2022-08-20T13:11:43Z UpdateTip: new best=00000000000000000005bba0593c2be0f1d322223501591d2b31b544e3af3d0b height=750300 version=0x2fffe000 log2_work=93.687081 tx=758181489 date='2022-08-20T13:11:16Z' progress=1.000000 cache=4.6MiB(34964txo)\n>\n> After a \"loadwallet\" command I am getting an old / wrong balance. The wallet is already empty because I had moved the funds to a new one 3 or 4 days ago but it is still showing the old balance. I didn't receive any warning message saying the need for a rescan or something like that.\n>\n> I am trying the \"rescanblockchain\" command but it is running and it taking a looooooooooooooong time.\n>\n> Best regards,\n>\n> Felipe.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220820/e45141bc/attachment-0001.html>"
            },
            {
                "author": "Andrew Chow",
                "date": "2022-08-20T15:10:57",
                "message_text_only": "This is a known issue that I've been working on. The wallet is a large module in Bitcoin Core and changing it takes quite a bit of time.\n\nOn 08/20/2022 10:16 AM, Felipe Micaroni Lalli via bitcoin-dev wrote:\n\n> 8.1) Can we \"optimize\" a huge wallet without moving the funds to a new one? Like a \"fsck\" or eqv?\n\nYou can remove old transactions using the removeprunedfunds RPC. That should greatly speed up balance calculations and transaction creation.\n\n> 8.2) Can we improve the cache usage somehow? Putting the entire wallet in memory, for example?\n\nIt's already entirely in memory.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220820/3b217e52/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Huge wallets make Bitcoin Core unusable (Daemon+CLI & Qt)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Andrew Chow",
                "rhavar at protonmail.com",
                "micaroni at gmail.com"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 13913
        }
    },
    {
        "title": "[bitcoin-dev] Playing with full-rbf peers for fun and L2s security",
        "thread_messages": [
            {
                "author": "Antoine Riard",
                "date": "2022-08-24T01:56:14",
                "message_text_only": "> I'd suggest doing that right now, without waiting for the patch to get\nmerged,\n> as it improves the politics of getting the patch merged. Miners tend to\nrun\n> customized bitcoind's anyway.\n\nPhilosophically, I think we're better off arguing code patches free from a\npolitical framework and rather reasoning from scientific or engineering\nprinciples. If a change is adopted it should be in the name of making the\nwhole system better, making the new situation a win-win game.\n\nThat said, and more pragmatically, now that the full-rbf patch is merged in\nCore there is the pedagogical work of explaining the fee upsides of turning\non full-rbf setting to enough miners. AFAIK, we don't have public,\nbroadcast-all communication channels between developers and mining\noperators to exchange on software upgrades (e.g Stratum V2). I think I'm\nleft with the process of reaching out to miner one by one.\n\nLe jeu. 23 juin 2022 \u00e0 20:13, Peter Todd <pete at petertodd.org> a \u00e9crit :\n\n> On Tue, Jun 21, 2022 at 07:45:48PM -0400, Antoine Riard wrote:\n> > > BTW I changed one of my OTS calendars to issue fee-bumping txs without\n> the\n> > > opt-in RBF flag set as an experiment. I also made sure txs would\n> > propagate to\n> > > the above node. As of right now, it's up to 32 replacements (once per\n> > block),\n> > > without any of them mined; the calendars use the strategy of starting\n> at\n> > the\n> > > minimum possible fee, and bumping the fee up every time a new block\n> > arrives\n> > > without the tx getting mined. So that's evidence we don't have much\n> > full-rbf\n> > > hash power at this moment.\n> > >\n> > > You can see the current status at:\n> > https://alice.btc.calendar.opentimestamps.org/\n> >\n> > That's interesting. I'm not sure if we can conclude of the absence of\n> > full-rbf hash power at this moment, as it could also be a lack of\n> full-rbf\n> > propagation path towards such potential hash power. I think the day we\n> see\n> > an opt-out replacement transaction mined, it would constitute a good hint\n> > of full-rbf hash power (assuming the tx-relay topology stays relatively\n> > stable across the transaction issuance...)\n>\n> Fees are relatively low right now, so there could be 1% or so of full-rbf\n> hash\n> power and I wouldn't notice with this particular technique as the initial\n> tx\n> gets mined within 10-20 blocks; a few years back similar experiments were\n> finding a few percentage points of hashing power running full-rbf.\n>\n> > Anyway, if/when the `fullrbf` patch lands in Bitcoin Core, including\n> > automatic outbound connections to few `NODE_REPLACE_BY_FEE` peers, I'm\n> > thinking of reaching out to a few mining node operators to advocate them\n> > with the new policy setting.\n>\n> I'd suggest doing that right now, without waiting for the patch to get\n> merged,\n> as it improves the politics of getting the patch merged. Miners tend to run\n> customized bitcoind's anyway.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220824/f3ca52eb/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Playing with full-rbf peers for fun and L2s security",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Antoine Riard"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3137
        }
    },
    {
        "title": "[bitcoin-dev] BIP Proposal: Wallet Labels Export Format",
        "thread_messages": [
            {
                "author": "Craig Raw",
                "date": "2022-08-24T09:18:43",
                "message_text_only": "Hi all,\n\nI would like to propose a BIP that specifies a format for the export and\nimport of labels from a wallet. While transferring access to funds across\nwallet applications has been made simple through standards such as BIP39,\nwallet labels remain siloed and difficult to extract despite their value,\nparticularly in a privacy context.\n\nThe proposed format is a simple two column CSV file, with the reference to\na transaction, address, input or output in the first column, and the label\nin the second column. CSV was chosen for its wide accessibility, especially\nto users without specific technical expertise. Similarly, the CSV file may\nbe compressed using the ZIP format, and optionally encrypted using AES.\n\nThe full text of the BIP can be found at\nhttps://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki\nand also copied below.\n\nFeedback is appreciated.\n\nThanks,\nCraig Raw\n\n---\n\n<pre>\n  BIP: wallet-labels\n  Layer: Applications\n  Title: Wallet Labels Export Format\n  Author: Craig Raw <craig at sparrowwallet.com>\n  Comments-Summary: No comments yet.\n  Comments-URI:\nhttps://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels\n  Status: Draft\n  Type: Informational\n  Created: 2022-08-23\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nThis document specifies a format for the export of labels that may be\nattached to the transactions, addresses, input and outputs in a wallet.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Motivation==\n\nThe export and import of funds across different Bitcoin wallet applications\nis well defined through standards such as BIP39, BIP32, BIP44 etc.\nThese standards are well supported and allow users to move easily between\ndifferent wallets.\nThere is, however, no defined standard to transfer any labels the user may\nhave applied to the transactions, addresses, inputs or outputs in their\nwallet.\nThe UTXO model that Bitcoin uses makes these labels particularly valuable\nas they may indicate the source of funds, whether received externally or as\na result of change from a prior transaction.\nIn both cases, care must be taken when spending to avoid undesirable leaks\nof private information.\nLabels provide valuable guidance in this regard, and have even become\nmandatory when spending in several Bitcoin wallets.\nAllowing users to export their labels in a standardized way ensures that\nthey do not experience lock-in to a particular wallet application.\nIn addition, by using common formats, this BIP seeks to make manual or bulk\nmanagement of labels accessible to users without specific technical\nexpertise.\n\n==Specification==\n\nIn order to make the import and export of labels as widely accessible as\npossible, this BIP uses the comma separated values (CSV) format, which is\nwidely supported by consumer, business, and scientific applications.\nAlthough the technical specification of CSV in RFC4180 is not always\nfollowed, the application of the format in this BIP is simple enough that\ncompatibility should not present a problem.\nMoreover, the simplicity and forgiving nature of CSV (over for example\nJSON) lends itself well to bulk label editing using spreadsheet and text\nediting tools.\n\nA CSV export of labels from a wallet must be a UTF-8 encoded text file,\ncontaining one record per line, with records containing two fields\ndelimited by a comma.\nThe fields may be quoted, but this is unnecessary, as the first comma in\nthe line will always be the delimiter.\nThe first line in the file is a header, and should be ignored on import.\nThereafter, each line represents a record that refers to a label applied in\nthe wallet.\nThe order in which these records appear is not defined.\n\nThe first field in the record contains a reference to the transaction,\naddress, input or output in the wallet.\nThis is specified as one of the following:\n* Transaction ID (<tt>txid</tt>)\n* Address\n* Input (rendered as <tt>txid<index</tt>)\n* Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)\n\nThe second field contains the label applied to the reference.\nExporting applications may omit records with no labels or labels of zero\nlength.\nFiles exported should use the <tt>.csv</tt> file extension.\n\nIn order to reduce file size while retaining wide accessibility, the CSV\nfile may be compressed using the ZIP file format, using the <tt>.zip</tt>\nfile extension.\nThis <tt>.zip</tt> file may optionally be encrypted using either AES-128 or\nAES-256 encryption, which is supported by numerous applications including\nWinzip and 7-zip.\nIn order to ensure that weak encryption does not proliferate, importers\nfollowing this standard must refuse to import <tt>.zip</tt> files encrypted\nwith the weaker Zip 2.0 standard.\nThe textual representation of the wallet's extended public key (as defined\nby BIP32, with an <tt>xpub</tt> header) should be used as the password.\n\n==Importing==\n\nWhen importing, a naive algorithm may simply match against any reference,\nbut it is possible to disambiguate between transactions, addresses, inputs\nand outputs.\nFor example in the following pseudocode:\n<pre>\n  if reference length < 64\n    Set address label\n  else if reference length == 64\n    Set transaction label\n  else if reference contains '<'\n    Set input label\n  else\n    Set output label\n</pre>\n\nImporting applications may truncate labels if necessary.\n\n==Test Vectors==\n\nThe following fragment represents a wallet label export:\n<pre>\nReference,Label\nc3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e,Transaction\n1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address\nc3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e<0,Input\nc3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e>0,Output\nc3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e:0,Output\n(alternative)\n</pre>\n\n==Reference Implementation==\n\nTBD\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220824/025a538b/attachment.html>"
            },
            {
                "author": "Clark Moody",
                "date": "2022-08-24T13:53:27",
                "message_text_only": "Craig,\n\nThanks for the proposal.\n\nHow does this proposal compare with SLIP-0015, which provides encryption by default? Would it be worth exploring a merge of the two approaches?\n\nhttps://github.com/satoshilabs/slips/blob/master/slip-0015.md\n\nClark\n\n------- Original Message -------\nOn Wednesday, August 24th, 2022 at 4:18 AM, Craig Raw via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi all,\n>\n> I would like to propose a BIP that specifies a format for the export and import of labels from a wallet. While transferring access to funds across wallet applications has been made simple through standards such as BIP39, wallet labels remain siloed and difficult to extract despite their value, particularly in a privacy context.\n>\n> The proposed format is a simple two column CSV file, with the reference to a transaction, address, input or output in the first column, and the label in the second column. CSV was chosen for its wide accessibility, especially to users without specific technical expertise. Similarly, the CSV file may be compressed using the ZIP format, and optionally encrypted using AES.\n>\n> The full text of the BIP can be found at https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki and also copied below.\n>\n> Feedback is appreciated.\n>\n> Thanks,\n> Craig Raw\n>\n> ---\n>\n> <pre>\n> BIP: wallet-labels\n> Layer: Applications\n> Title: Wallet Labels Export Format\n> Author: Craig Raw <craig at sparrowwallet.com>\n> Comments-Summary: No comments yet.\n> Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels\n> Status: Draft\n> Type: Informational\n> Created: 2022-08-23\n> License: BSD-2-Clause\n> </pre>\n>\n> ==Abstract==\n>\n> This document specifies a format for the export of labels that may be attached to the transactions, addresses, input and outputs in a wallet.\n>\n> ==Copyright==\n>\n> This BIP is licensed under the BSD 2-clause license.\n>\n> ==Motivation==\n>\n> The export and import of funds across different Bitcoin wallet applications is well defined through standards such as BIP39, BIP32, BIP44 etc.\n> These standards are well supported and allow users to move easily between different wallets.\n> There is, however, no defined standard to transfer any labels the user may have applied to the transactions, addresses, inputs or outputs in their wallet.\n> The UTXO model that Bitcoin uses makes these labels particularly valuable as they may indicate the source of funds, whether received externally or as a result of change from a prior transaction.\n> In both cases, care must be taken when spending to avoid undesirable leaks of private information.\n> Labels provide valuable guidance in this regard, and have even become mandatory when spending in several Bitcoin wallets.\n> Allowing users to export their labels in a standardized way ensures that they do not experience lock-in to a particular wallet application.\n> In addition, by using common formats, this BIP seeks to make manual or bulk management of labels accessible to users without specific technical expertise.\n>\n> ==Specification==\n>\n> In order to make the import and export of labels as widely accessible as possible, this BIP uses the comma separated values (CSV) format, which is widely supported by consumer, business, and scientific applications.\n> Although the technical specification of CSV in RFC4180 is not always followed, the application of the format in this BIP is simple enough that compatibility should not present a problem.\n> Moreover, the simplicity and forgiving nature of CSV (over for example JSON) lends itself well to bulk label editing using spreadsheet and text editing tools.\n>\n> A CSV export of labels from a wallet must be a UTF-8 encoded text file, containing one record per line, with records containing two fields delimited by a comma.\n> The fields may be quoted, but this is unnecessary, as the first comma in the line will always be the delimiter.\n> The first line in the file is a header, and should be ignored on import.\n> Thereafter, each line represents a record that refers to a label applied in the wallet.\n> The order in which these records appear is not defined.\n>\n> The first field in the record contains a reference to the transaction, address, input or output in the wallet.\n> This is specified as one of the following:\n> * Transaction ID (<tt>txid</tt>)\n> * Address\n> * Input (rendered as <tt>txid<index</tt>)\n> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)\n>\n> The second field contains the label applied to the reference.\n> Exporting applications may omit records with no labels or labels of zero length.\n> Files exported should use the <tt>.csv</tt> file extension.\n>\n> In order to reduce file size while retaining wide accessibility, the CSV file may be compressed using the ZIP file format, using the <tt>.zip</tt> file extension.\n> This <tt>.zip</tt> file may optionally be encrypted using either AES-128 or AES-256 encryption, which is supported by numerous applications including Winzip and 7-zip.\n> In order to ensure that weak encryption does not proliferate, importers following this standard must refuse to import <tt>.zip</tt> files encrypted with the weaker Zip 2.0 standard.\n> The textual representation of the wallet's extended public key (as defined by BIP32, with an <tt>xpub</tt> header) should be used as the password.\n>\n> ==Importing==\n>\n> When importing, a naive algorithm may simply match against any reference, but it is possible to disambiguate between transactions, addresses, inputs and outputs.\n> For example in the following pseudocode:\n> <pre>\n> if reference length < 64\n> Set address label\n> else if reference length == 64\n> Set transaction label\n> else if reference contains '<'\n> Set input label\n> else\n> Set output label\n> </pre>\n>\n> Importing applications may truncate labels if necessary.\n>\n> ==Test Vectors==\n>\n> The following fragment represents a wallet label export:\n> <pre>\n> Reference,Label\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e,Transaction\n> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e<0,Input\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e>0,Output\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e:0,Output (alternative)\n> </pre>\n>\n> ==Reference Implementation==\n>\n> TBD\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220824/2c3e56ea/attachment.html>"
            },
            {
                "author": "Craig Raw",
                "date": "2022-08-25T08:59:08",
                "message_text_only": "Thanks Clark - despite having worked in the Bitcoin wallet space for a\nnumber of years I have not come across SLIP-0015. I did try to find prior\nwork on this - this one escaped me.\n\nThat said, having reviewed SLIP-0015, I think it has different design\ngoals. For example, it requires private key derivation from seed, which\nmeans wallets functioning as coordinators cannot use the format without\naccess to the devices storing the private keys. It seems to me that wallet\nlabels are more privacy rather than security sensitive, and coordinators\nshould be able to import and export a wallet label format independently.\n\nSecondly, it uses JSON as a data format, which I wanted to avoid for\nreasons I'll describe in a separate reply in this thread. Finally (and this\nis minor as it could easily be extended) SLIP-0015 does not currently\nsupport transaction labels.\n\nCraig\n\nOn Wed, Aug 24, 2022 at 3:53 PM Clark Moody <clark at clarkmoody.com> wrote:\n\n> Craig,\n>\n> Thanks for the proposal.\n>\n> How does this proposal compare with SLIP-0015, which provides encryption\n> by default? Would it be worth exploring a merge of the two approaches?\n>\n> https://github.com/satoshilabs/slips/blob/master/slip-0015.md\n>\n> Clark\n>\n> ------- Original Message -------\n> On Wednesday, August 24th, 2022 at 4:18 AM, Craig Raw via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Hi all,\n>\n> I would like to propose a BIP that specifies a format for the export and\n> import of labels from a wallet. While transferring access to funds across\n> wallet applications has been made simple through standards such as BIP39,\n> wallet labels remain siloed and difficult to extract despite their value,\n> particularly in a privacy context.\n>\n> The proposed format is a simple two column CSV file, with the reference to\n> a transaction, address, input or output in the first column, and the label\n> in the second column. CSV was chosen for its wide accessibility, especially\n> to users without specific technical expertise. Similarly, the CSV file may\n> be compressed using the ZIP format, and optionally encrypted using AES.\n>\n> The full text of the BIP can be found at\n> https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki\n> and also copied below.\n>\n> Feedback is appreciated.\n>\n> Thanks,\n> Craig Raw\n>\n> ---\n>\n> <pre>\n> BIP: wallet-labels\n> Layer: Applications\n> Title: Wallet Labels Export Format\n> Author: Craig Raw <craig at sparrowwallet.com>\n> Comments-Summary: No comments yet.\n> Comments-URI:\n> https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels\n> Status: Draft\n> Type: Informational\n> Created: 2022-08-23\n> License: BSD-2-Clause\n> </pre>\n>\n> ==Abstract==\n>\n> This document specifies a format for the export of labels that may be\n> attached to the transactions, addresses, input and outputs in a wallet.\n>\n> ==Copyright==\n>\n> This BIP is licensed under the BSD 2-clause license.\n>\n> ==Motivation==\n>\n> The export and import of funds across different Bitcoin wallet\n> applications is well defined through standards such as BIP39, BIP32, BIP44\n> etc.\n> These standards are well supported and allow users to move easily between\n> different wallets.\n> There is, however, no defined standard to transfer any labels the user may\n> have applied to the transactions, addresses, inputs or outputs in their\n> wallet.\n> The UTXO model that Bitcoin uses makes these labels particularly valuable\n> as they may indicate the source of funds, whether received externally or as\n> a result of change from a prior transaction.\n> In both cases, care must be taken when spending to avoid undesirable leaks\n> of private information.\n> Labels provide valuable guidance in this regard, and have even become\n> mandatory when spending in several Bitcoin wallets.\n> Allowing users to export their labels in a standardized way ensures that\n> they do not experience lock-in to a particular wallet application.\n> In addition, by using common formats, this BIP seeks to make manual or\n> bulk management of labels accessible to users without specific technical\n> expertise.\n>\n> ==Specification==\n>\n> In order to make the import and export of labels as widely accessible as\n> possible, this BIP uses the comma separated values (CSV) format, which is\n> widely supported by consumer, business, and scientific applications.\n> Although the technical specification of CSV in RFC4180 is not always\n> followed, the application of the format in this BIP is simple enough that\n> compatibility should not present a problem.\n> Moreover, the simplicity and forgiving nature of CSV (over for example\n> JSON) lends itself well to bulk label editing using spreadsheet and text\n> editing tools.\n>\n> A CSV export of labels from a wallet must be a UTF-8 encoded text file,\n> containing one record per line, with records containing two fields\n> delimited by a comma.\n> The fields may be quoted, but this is unnecessary, as the first comma in\n> the line will always be the delimiter.\n> The first line in the file is a header, and should be ignored on import.\n> Thereafter, each line represents a record that refers to a label applied\n> in the wallet.\n> The order in which these records appear is not defined.\n>\n> The first field in the record contains a reference to the transaction,\n> address, input or output in the wallet.\n> This is specified as one of the following:\n> * Transaction ID (<tt>txid</tt>)\n> * Address\n> * Input (rendered as <tt>txid<index</tt>)\n> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)\n>\n> The second field contains the label applied to the reference.\n> Exporting applications may omit records with no labels or labels of zero\n> length.\n> Files exported should use the <tt>.csv</tt> file extension.\n>\n> In order to reduce file size while retaining wide accessibility, the CSV\n> file may be compressed using the ZIP file format, using the <tt>.zip</tt>\n> file extension.\n> This <tt>.zip</tt> file may optionally be encrypted using either AES-128\n> or AES-256 encryption, which is supported by numerous applications\n> including Winzip and 7-zip.\n> In order to ensure that weak encryption does not proliferate, importers\n> following this standard must refuse to import <tt>.zip</tt> files encrypted\n> with the weaker Zip 2.0 standard.\n> The textual representation of the wallet's extended public key (as defined\n> by BIP32, with an <tt>xpub</tt> header) should be used as the password.\n>\n> ==Importing==\n>\n> When importing, a naive algorithm may simply match against any reference,\n> but it is possible to disambiguate between transactions, addresses, inputs\n> and outputs.\n> For example in the following pseudocode:\n> <pre>\n> if reference length < 64\n> Set address label\n> else if reference length == 64\n> Set transaction label\n> else if reference contains '<'\n> Set input label\n> else\n> Set output label\n> </pre>\n>\n> Importing applications may truncate labels if necessary.\n>\n> ==Test Vectors==\n>\n> The following fragment represents a wallet label export:\n> <pre>\n> Reference,Label\n>\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e,Transaction\n> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e<0,Input\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e>0,Output\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e:0,Output\n> (alternative)\n> </pre>\n>\n> ==Reference Implementation==\n>\n> TBD\n>\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220825/acdd8972/attachment-0001.html>"
            },
            {
                "author": "Brandon Black",
                "date": "2022-08-24T15:57:41",
                "message_text_only": "On 2022-08-24 (Wed) at 11:18:43 +0200, Craig Raw via bitcoin-dev wrote:\n> I would like to propose a BIP that specifies a format for the export and\n> import of labels from a wallet. While transferring access to funds across\n> wallet applications has been made simple through standards such as BIP39,\n> wallet labels remain siloed and difficult to extract despite their value,\n> particularly in a privacy context.\n\nI like the idea of standardizing the transfer of this valuable\ninformation.\n\n> The proposed format is a simple two column CSV file, with the reference to\n> a transaction, address, input or output in the first column, and the label\n> in the second column. CSV was chosen for its wide accessibility, especially\n> to users without specific technical expertise. Similarly, the CSV file may\n> be compressed using the ZIP format, and optionally encrypted using AES.\n\nIt seems like the format would be more useful if it also included\ndescriptors so that a single file could be used to transfer a wallet. I\nthink such an addition would improve usability for advanced users who\nmight have many such CSVs to manage, and would then be able to more\neasily select between them. Descriptor,Label pairs could also be useful\nin the format for the transfer of a wallet with several sub accounts.\n\nThanks,\n\n--Brandon"
            },
            {
                "author": "rhavar at protonmail.com",
                "date": "2022-08-24T19:01:17",
                "message_text_only": "I'd strongly suggest not using CSV. Especially for a standard. I've worked with it as an interchange format many a times, and it's always been a clusterfuck.\n\nRight off the bat, you have stuff like \"The fields may be quoted, but this is unnecessary as the first comma in the line will always be the delimiter\" which invariably leads to some implementations doing it, some implementations not doing it, and others that are intolerant of the other way.\n\nAnd you have also made the classic mistake of not strictly defining escape rules. So everyone will pick their own (e.g. some will \\, escape commas, others will not cause it's quoted and escape quotes, and others will assume no escaping is required since its the last column in a csv).\n\nOver time it morphs into its own mini-monster that introduces so much pain.\n\nOn a similar note, allowing alternatives (like: txid>index vs txid:index) provides no benefit, but creates additional work for implementations (who quite likely only test formats they produce) and future incompatibilities.\n\nI know everyone loves to hate on it, but really (line-separated?) json is the way to go.\n\n{ \"tx\": \"c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e\", \"label\": \"wow, such label\" }\n{ \"tx: \"c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\", \"txout\": 4, \"label\": \"omg this is so easy to parse\" }\n{ \"tx: \"c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\", \"txin\": 0, \"label\": \"wow this is going to be extensible as well\" }\n\n-Ryan\n\n------- Original Message -------\nOn Wednesday, August 24th, 2022 at 2:18 AM, Craig Raw via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi all,\n>\n> I would like to propose a BIP that specifies a format for the export and import of labels from a wallet. While transferring access to funds across wallet applications has been made simple through standards such as BIP39, wallet labels remain siloed and difficult to extract despite their value, particularly in a privacy context.\n>\n> The proposed format is a simple two column CSV file, with the reference to a transaction, address, input or output in the first column, and the label in the second column. CSV was chosen for its wide accessibility, especially to users without specific technical expertise. Similarly, the CSV file may be compressed using the ZIP format, and optionally encrypted using AES.\n>\n> The full text of the BIP can be found at https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki and also copied below.\n>\n> Feedback is appreciated.\n>\n> Thanks,\n> Craig Raw\n>\n> ---\n>\n> <pre>\n> BIP: wallet-labels\n> Layer: Applications\n> Title: Wallet Labels Export Format\n> Author: Craig Raw <craig at sparrowwallet.com>\n> Comments-Summary: No comments yet.\n> Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels\n> Status: Draft\n> Type: Informational\n> Created: 2022-08-23\n> License: BSD-2-Clause\n> </pre>\n>\n> ==Abstract==\n>\n> This document specifies a format for the export of labels that may be attached to the transactions, addresses, input and outputs in a wallet.\n>\n> ==Copyright==\n>\n> This BIP is licensed under the BSD 2-clause license.\n>\n> ==Motivation==\n>\n> The export and import of funds across different Bitcoin wallet applications is well defined through standards such as BIP39, BIP32, BIP44 etc.\n> These standards are well supported and allow users to move easily between different wallets.\n> There is, however, no defined standard to transfer any labels the user may have applied to the transactions, addresses, inputs or outputs in their wallet.\n> The UTXO model that Bitcoin uses makes these labels particularly valuable as they may indicate the source of funds, whether received externally or as a result of change from a prior transaction.\n> In both cases, care must be taken when spending to avoid undesirable leaks of private information.\n> Labels provide valuable guidance in this regard, and have even become mandatory when spending in several Bitcoin wallets.\n> Allowing users to export their labels in a standardized way ensures that they do not experience lock-in to a particular wallet application.\n> In addition, by using common formats, this BIP seeks to make manual or bulk management of labels accessible to users without specific technical expertise.\n>\n> ==Specification==\n>\n> In order to make the import and export of labels as widely accessible as possible, this BIP uses the comma separated values (CSV) format, which is widely supported by consumer, business, and scientific applications.\n> Although the technical specification of CSV in RFC4180 is not always followed, the application of the format in this BIP is simple enough that compatibility should not present a problem.\n> Moreover, the simplicity and forgiving nature of CSV (over for example JSON) lends itself well to bulk label editing using spreadsheet and text editing tools.\n>\n> A CSV export of labels from a wallet must be a UTF-8 encoded text file, containing one record per line, with records containing two fields delimited by a comma.\n> The fields may be quoted, but this is unnecessary, as the first comma in the line will always be the delimiter.\n> The first line in the file is a header, and should be ignored on import.\n> Thereafter, each line represents a record that refers to a label applied in the wallet.\n> The order in which these records appear is not defined.\n>\n> The first field in the record contains a reference to the transaction, address, input or output in the wallet.\n> This is specified as one of the following:\n> * Transaction ID (<tt>txid</tt>)\n> * Address\n> * Input (rendered as <tt>txid<index</tt>)\n> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)\n>\n> The second field contains the label applied to the reference.\n> Exporting applications may omit records with no labels or labels of zero length.\n> Files exported should use the <tt>.csv</tt> file extension.\n>\n> In order to reduce file size while retaining wide accessibility, the CSV file may be compressed using the ZIP file format, using the <tt>.zip</tt> file extension.\n> This <tt>.zip</tt> file may optionally be encrypted using either AES-128 or AES-256 encryption, which is supported by numerous applications including Winzip and 7-zip.\n> In order to ensure that weak encryption does not proliferate, importers following this standard must refuse to import <tt>.zip</tt> files encrypted with the weaker Zip 2.0 standard.\n> The textual representation of the wallet's extended public key (as defined by BIP32, with an <tt>xpub</tt> header) should be used as the password.\n>\n> ==Importing==\n>\n> When importing, a naive algorithm may simply match against any reference, but it is possible to disambiguate between transactions, addresses, inputs and outputs.\n> For example in the following pseudocode:\n> <pre>\n> if reference length < 64\n> Set address label\n> else if reference length == 64\n> Set transaction label\n> else if reference contains '<'\n> Set input label\n> else\n> Set output label\n> </pre>\n>\n> Importing applications may truncate labels if necessary.\n>\n> ==Test Vectors==\n>\n> The following fragment represents a wallet label export:\n> <pre>\n> Reference,Label\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e,Transaction\n> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e<0,Input\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e>0,Output\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e:0,Output (alternative)\n> </pre>\n>\n> ==Reference Implementation==\n>\n> TBD\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220824/f1fcaed1/attachment-0001.html>"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2022-08-24T20:18:27",
                "message_text_only": "There is already a JSON standard that has been already used in the wild for\nthe last 7 years described in SLIP-0015 (mentioned by Clark in this\nthread). No need to reinventing the wheel again.\n\nOn Wed 24. 8. 2022 at 21:44, Ryan Havar via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I'd strongly suggest not using CSV. Especially for a standard. I've worked\n> with it as an interchange format many a times, and it's always been a\n> clusterfuck.\n>\n> Right off the bat, you have stuff like \"The fields may be quoted, but this\n> is unnecessary as the first comma in the line will always be the delimiter\"\n> which invariably leads to some implementations doing it, some\n> implementations not doing it, and others that are intolerant of the other\n> way.\n>\n> And you have also made the classic mistake of not strictly defining escape\n> rules. So everyone will pick their own (e.g. some will \\, escape commas,\n> others will not cause it's quoted and escape quotes, and others will assume\n> no escaping is required since its the last column in a csv).\n>\n> Over time it morphs into its own mini-monster that introduces so much pain.\n>\n> On a similar note, allowing alternatives (like: txid>index vs txid:index)\n> provides no benefit, but creates additional work for implementations (who\n> quite likely only test formats they produce) and future incompatibilities.\n>\n> I know everyone loves to hate on it, but really (line-separated?) json is\n> the way to go.\n>\n> { \"tx\": \"c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e\",\n> \"label\": \"wow, such label\" }\n> { \"tx: \"c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\",\n> \"txout\": 4, \"label\": \"omg this is so easy to parse\" }\n> { \"tx: \"c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\",\n> \"txin\": 0, \"label\": \"wow this is going to be extensible as well\" }\n>\n>\n>\n>\n> -Ryan\n>\n> ------- Original Message -------\n>\n> On Wednesday, August 24th, 2022 at 2:18 AM, Craig Raw via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Hi all,\n>\n> I would like to propose a BIP that specifies a format for the export and\n> import of labels from a wallet. While transferring access to funds across\n> wallet applications has been made simple through standards such as BIP39,\n> wallet labels remain siloed and difficult to extract despite their value,\n> particularly in a privacy context.\n>\n> The proposed format is a simple two column CSV file, with the reference to\n> a transaction, address, input or output in the first column, and the label\n> in the second column. CSV was chosen for its wide accessibility, especially\n> to users without specific technical expertise. Similarly, the CSV file may\n> be compressed using the ZIP format, and optionally encrypted using AES.\n>\n> The full text of the BIP can be found at\n> https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki\n> and also copied below.\n>\n> Feedback is appreciated.\n>\n> Thanks,\n> Craig Raw\n>\n> ---\n>\n> <pre>\n> BIP: wallet-labels\n> Layer: Applications\n> Title: Wallet Labels Export Format\n> Author: Craig Raw <craig at sparrowwallet.com>\n> Comments-Summary: No comments yet.\n> Comments-URI:\n> https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels\n> Status: Draft\n> Type: Informational\n> Created: 2022-08-23\n> License: BSD-2-Clause\n> </pre>\n>\n> ==Abstract==\n>\n> This document specifies a format for the export of labels that may be\n> attached to the transactions, addresses, input and outputs in a wallet.\n>\n> ==Copyright==\n>\n> This BIP is licensed under the BSD 2-clause license.\n>\n> ==Motivation==\n>\n> The export and import of funds across different Bitcoin wallet\n> applications is well defined through standards such as BIP39, BIP32, BIP44\n> etc.\n> These standards are well supported and allow users to move easily between\n> different wallets.\n> There is, however, no defined standard to transfer any labels the user may\n> have applied to the transactions, addresses, inputs or outputs in their\n> wallet.\n> The UTXO model that Bitcoin uses makes these labels particularly valuable\n> as they may indicate the source of funds, whether received externally or as\n> a result of change from a prior transaction.\n> In both cases, care must be taken when spending to avoid undesirable leaks\n> of private information.\n> Labels provide valuable guidance in this regard, and have even become\n> mandatory when spending in several Bitcoin wallets.\n> Allowing users to export their labels in a standardized way ensures that\n> they do not experience lock-in to a particular wallet application.\n> In addition, by using common formats, this BIP seeks to make manual or\n> bulk management of labels accessible to users without specific technical\n> expertise.\n>\n> ==Specification==\n>\n> In order to make the import and export of labels as widely accessible as\n> possible, this BIP uses the comma separated values (CSV) format, which is\n> widely supported by consumer, business, and scientific applications.\n> Although the technical specification of CSV in RFC4180 is not always\n> followed, the application of the format in this BIP is simple enough that\n> compatibility should not present a problem.\n> Moreover, the simplicity and forgiving nature of CSV (over for example\n> JSON) lends itself well to bulk label editing using spreadsheet and text\n> editing tools.\n>\n> A CSV export of labels from a wallet must be a UTF-8 encoded text file,\n> containing one record per line, with records containing two fields\n> delimited by a comma.\n> The fields may be quoted, but this is unnecessary, as the first comma in\n> the line will always be the delimiter.\n> The first line in the file is a header, and should be ignored on import.\n> Thereafter, each line represents a record that refers to a label applied\n> in the wallet.\n> The order in which these records appear is not defined.\n>\n> The first field in the record contains a reference to the transaction,\n> address, input or output in the wallet.\n> This is specified as one of the following:\n> * Transaction ID (<tt>txid</tt>)\n> * Address\n> * Input (rendered as <tt>txid<index</tt>)\n> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)\n>\n> The second field contains the label applied to the reference.\n> Exporting applications may omit records with no labels or labels of zero\n> length.\n> Files exported should use the <tt>.csv</tt> file extension.\n>\n> In order to reduce file size while retaining wide accessibility, the CSV\n> file may be compressed using the ZIP file format, using the <tt>.zip</tt>\n> file extension.\n> This <tt>.zip</tt> file may optionally be encrypted using either AES-128\n> or AES-256 encryption, which is supported by numerous applications\n> including Winzip and 7-zip.\n> In order to ensure that weak encryption does not proliferate, importers\n> following this standard must refuse to import <tt>.zip</tt> files encrypted\n> with the weaker Zip 2.0 standard.\n> The textual representation of the wallet's extended public key (as defined\n> by BIP32, with an <tt>xpub</tt> header) should be used as the password.\n>\n> ==Importing==\n>\n> When importing, a naive algorithm may simply match against any reference,\n> but it is possible to disambiguate between transactions, addresses, inputs\n> and outputs.\n> For example in the following pseudocode:\n> <pre>\n> if reference length < 64\n> Set address label\n> else if reference length == 64\n> Set transaction label\n> else if reference contains '<'\n> Set input label\n> else\n> Set output label\n> </pre>\n>\n> Importing applications may truncate labels if necessary.\n>\n> ==Test Vectors==\n>\n> The following fragment represents a wallet label export:\n> <pre>\n> Reference,Label\n>\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e,Transaction\n> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e<0,Input\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e>0,Output\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e:0,Output\n> (alternative)\n> </pre>\n>\n> ==Reference Implementation==\n>\n> TBD\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-- \nBest Regards / S pozdravom,\n\nPavol \"stick\" Rusnak\nCo-Founder, SatoshiLabs\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220824/36ce85ba/attachment-0001.html>"
            },
            {
                "author": "Craig Raw",
                "date": "2022-08-25T08:59:13",
                "message_text_only": "Thanks for your thoughts Ryan.\n\nWithout reference to the quality feedback on this proposal, I was aware\nwhen submitting it for review that it provides an excellent opportunity for\nbike shedding. As developers, we have all experienced frustration with data\nformats. One thing that I did not perhaps make clear enough is that this\nformat is not solely intended for developers, but general users who are\nprobably not well represented on this list.\n\nWhile doing research for this proposal I spoke to several professional\nusers of Sparrow Wallet (who are not developers). They all expressed a\ndesire for the format to integrate with their business processes, which are\ndriven by business tools such as Excel. Labelling provides an important\nfunction in UTXO and address management in these scenarios, and needs to be\naccessible and manageable outside of wallet software.\n\nIf this is to be achieved, it immediately rules out JSON as a data format.\nNot only is JSON limited to editing only through specific software or text\neditors, but (in the latter case) it is fragile enough that a single\nmissing character can cause an entire file to fail parsing. CSV is more\nforgiving in this regard. With respect to your comments on escaping, my\nexpectation would be that developers will be using a mature CSV library\nrather than handling character escaping themselves. I would rather propose\na format that is generally usable, even if occasionally a label is escaped\nincorrectly.\n\nFinally, I'll note that CSV files are already common and uncontroversial in\nBitcoin wallet software. Bitcoin Core, Electrum, Sparrow (and no doubt many\nothers) already export addresses and/or transactions with their labels as\nCSV files. This proposal simply attempts to create a standard for importing\nand exporting all the labels in a wallet.\n\nCraig\n\nOn Wed, Aug 24, 2022 at 9:01 PM <rhavar at protonmail.com> wrote:\n\n> I'd strongly suggest not using CSV. Especially for a standard. I've worked\n> with it as an interchange format many a times, and it's always been a\n> clusterfuck.\n>\n> Right off the bat, you have stuff like \"The fields may be quoted, but this\n> is unnecessary as the first comma in the line will always be the delimiter\"\n> which invariably leads to some implementations doing it, some\n> implementations not doing it, and others that are intolerant of the other\n> way.\n>\n> And you have also made the classic mistake of not strictly defining escape\n> rules. So everyone will pick their own (e.g. some will \\, escape commas,\n> others will not cause it's quoted and escape quotes, and others will assume\n> no escaping is required since its the last column in a csv).\n>\n> Over time it morphs into its own mini-monster that introduces so much pain.\n>\n> On a similar note, allowing alternatives (like: txid>index vs txid:index)\n> provides no benefit, but creates additional work for implementations (who\n> quite likely only test formats they produce) and future incompatibilities.\n>\n> I know everyone loves to hate on it, but really (line-separated?) json is\n> the way to go.\n>\n> { \"tx\": \"c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e\",\n> \"label\": \"wow, such label\" }\n> { \"tx: \"c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\",\n> \"txout\": 4, \"label\": \"omg this is so easy to parse\" }\n> { \"tx: \"c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\",\n> \"txin\": 0, \"label\": \"wow this is going to be extensible as well\" }\n>\n>\n>\n>\n> -Ryan\n>\n> ------- Original Message -------\n> On Wednesday, August 24th, 2022 at 2:18 AM, Craig Raw via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Hi all,\n>\n> I would like to propose a BIP that specifies a format for the export and\n> import of labels from a wallet. While transferring access to funds across\n> wallet applications has been made simple through standards such as BIP39,\n> wallet labels remain siloed and difficult to extract despite their value,\n> particularly in a privacy context.\n>\n> The proposed format is a simple two column CSV file, with the reference to\n> a transaction, address, input or output in the first column, and the label\n> in the second column. CSV was chosen for its wide accessibility, especially\n> to users without specific technical expertise. Similarly, the CSV file may\n> be compressed using the ZIP format, and optionally encrypted using AES.\n>\n> The full text of the BIP can be found at\n> https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki\n> and also copied below.\n>\n> Feedback is appreciated.\n>\n> Thanks,\n> Craig Raw\n>\n> ---\n>\n> <pre>\n> BIP: wallet-labels\n> Layer: Applications\n> Title: Wallet Labels Export Format\n> Author: Craig Raw <craig at sparrowwallet.com>\n> Comments-Summary: No comments yet.\n> Comments-URI:\n> https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels\n> Status: Draft\n> Type: Informational\n> Created: 2022-08-23\n> License: BSD-2-Clause\n> </pre>\n>\n> ==Abstract==\n>\n> This document specifies a format for the export of labels that may be\n> attached to the transactions, addresses, input and outputs in a wallet.\n>\n> ==Copyright==\n>\n> This BIP is licensed under the BSD 2-clause license.\n>\n> ==Motivation==\n>\n> The export and import of funds across different Bitcoin wallet\n> applications is well defined through standards such as BIP39, BIP32, BIP44\n> etc.\n> These standards are well supported and allow users to move easily between\n> different wallets.\n> There is, however, no defined standard to transfer any labels the user may\n> have applied to the transactions, addresses, inputs or outputs in their\n> wallet.\n> The UTXO model that Bitcoin uses makes these labels particularly valuable\n> as they may indicate the source of funds, whether received externally or as\n> a result of change from a prior transaction.\n> In both cases, care must be taken when spending to avoid undesirable leaks\n> of private information.\n> Labels provide valuable guidance in this regard, and have even become\n> mandatory when spending in several Bitcoin wallets.\n> Allowing users to export their labels in a standardized way ensures that\n> they do not experience lock-in to a particular wallet application.\n> In addition, by using common formats, this BIP seeks to make manual or\n> bulk management of labels accessible to users without specific technical\n> expertise.\n>\n> ==Specification==\n>\n> In order to make the import and export of labels as widely accessible as\n> possible, this BIP uses the comma separated values (CSV) format, which is\n> widely supported by consumer, business, and scientific applications.\n> Although the technical specification of CSV in RFC4180 is not always\n> followed, the application of the format in this BIP is simple enough that\n> compatibility should not present a problem.\n> Moreover, the simplicity and forgiving nature of CSV (over for example\n> JSON) lends itself well to bulk label editing using spreadsheet and text\n> editing tools.\n>\n> A CSV export of labels from a wallet must be a UTF-8 encoded text file,\n> containing one record per line, with records containing two fields\n> delimited by a comma.\n> The fields may be quoted, but this is unnecessary, as the first comma in\n> the line will always be the delimiter.\n> The first line in the file is a header, and should be ignored on import.\n> Thereafter, each line represents a record that refers to a label applied\n> in the wallet.\n> The order in which these records appear is not defined.\n>\n> The first field in the record contains a reference to the transaction,\n> address, input or output in the wallet.\n> This is specified as one of the following:\n> * Transaction ID (<tt>txid</tt>)\n> * Address\n> * Input (rendered as <tt>txid<index</tt>)\n> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)\n>\n> The second field contains the label applied to the reference.\n> Exporting applications may omit records with no labels or labels of zero\n> length.\n> Files exported should use the <tt>.csv</tt> file extension.\n>\n> In order to reduce file size while retaining wide accessibility, the CSV\n> file may be compressed using the ZIP file format, using the <tt>.zip</tt>\n> file extension.\n> This <tt>.zip</tt> file may optionally be encrypted using either AES-128\n> or AES-256 encryption, which is supported by numerous applications\n> including Winzip and 7-zip.\n> In order to ensure that weak encryption does not proliferate, importers\n> following this standard must refuse to import <tt>.zip</tt> files encrypted\n> with the weaker Zip 2.0 standard.\n> The textual representation of the wallet's extended public key (as defined\n> by BIP32, with an <tt>xpub</tt> header) should be used as the password.\n>\n> ==Importing==\n>\n> When importing, a naive algorithm may simply match against any reference,\n> but it is possible to disambiguate between transactions, addresses, inputs\n> and outputs.\n> For example in the following pseudocode:\n> <pre>\n> if reference length < 64\n> Set address label\n> else if reference length == 64\n> Set transaction label\n> else if reference contains '<'\n> Set input label\n> else\n> Set output label\n> </pre>\n>\n> Importing applications may truncate labels if necessary.\n>\n> ==Test Vectors==\n>\n> The following fragment represents a wallet label export:\n> <pre>\n> Reference,Label\n>\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e,Transaction\n> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e<0,Input\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e>0,Output\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e:0,Output\n> (alternative)\n> </pre>\n>\n> ==Reference Implementation==\n>\n> TBD\n>\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220825/0b1b7bed/attachment-0001.html>"
            },
            {
                "author": "rhavar at protonmail.com",
                "date": "2022-08-25T13:48:36",
                "message_text_only": "> Not only is JSON limited to editing only through specific software or text editors, but (in the latter case) it is fragile enough that a single missing character can cause an entire file to fail parsing. CSV is more forgiving in this regard.\n\nI think quite simply: A forgiving format is not appropriate for a standard.\n\nIt'd be hard to understate how much extra and pointless effort it creates for everyone, and every implementation ends up creating its own defacto standard for what it produces and accepts. Even doing something as simple as adding an extra column will not be possible in the future because it'll break comparability with previous parsers.\n\nI've literally worked on projects where the csv parser has evolved into scan-ahead to use heuristics to understand \"rules\" of a csv file, and then do line-by-line heuristics to override those rules in pathological cases. Makes a bit of sense when you're trying to achieve 30 years of backwards compatibility. Doesn't make sense for much else..\n\nIf your application users really like csv, then introduce an application-specific import-from-csv and export-to-csv with your own rules.\n-Ryan\n\n------- Original Message -------\nOn Thursday, August 25th, 2022 at 1:59 AM, Craig Raw <craigraw at gmail.com> wrote:\n\n> Thanks for your thoughts Ryan.\n>\n> Without reference to the quality feedback on this proposal, I was aware when submitting it for review that it provides an excellent opportunity for bike shedding. As developers, we have all experienced frustration with data formats. One thing that I did not perhaps make clear enough is that this format is not solely intended for developers, but general users who are probably not well represented on this list.\n>\n> While doing research for this proposal I spoke to several professional users of Sparrow Wallet (who are not developers). They all expressed a desire for the format to integrate with their business processes, which are driven by business tools such as Excel. Labelling provides an important function in UTXO and address management in these scenarios, and needs to be accessible and manageable outside of wallet software.\n>\n> If this is to be achieved, it immediately rules out JSON as a data format. Not only is JSON limited to editing only through specific software or text editors, but (in the latter case) it is fragile enough that a single missing character can cause an entire file to fail parsing. CSV is more forgiving in this regard. With respect to your comments on escaping, my expectation would be that developers will be using a mature CSV library rather than handling character escaping themselves. I would rather propose a format that is generally usable, even if occasionally a label is escaped incorrectly.\n>\n> Finally, I'll note that CSV files are already common and uncontroversial in Bitcoin wallet software. Bitcoin Core, Electrum, Sparrow (and no doubt many others) already export addresses and/or transactions with their labels as CSV files. This proposal simply attempts to create a standard for importing and exporting all the labels in a wallet.\n>\n> Craig\n>\n> On Wed, Aug 24, 2022 at 9:01 PM <rhavar at protonmail.com> wrote:\n>\n>> I'd strongly suggest not using CSV. Especially for a standard. I've worked with it as an interchange format many a times, and it's always been a clusterfuck.\n>>\n>> Right off the bat, you have stuff like \"The fields may be quoted, but this is unnecessary as the first comma in the line will always be the delimiter\" which invariably leads to some implementations doing it, some implementations not doing it, and others that are intolerant of the other way.\n>>\n>> And you have also made the classic mistake of not strictly defining escape rules. So everyone will pick their own (e.g. some will \\, escape commas, others will not cause it's quoted and escape quotes, and others will assume no escaping is required since its the last column in a csv).\n>>\n>> Over time it morphs into its own mini-monster that introduces so much pain.\n>>\n>> On a similar note, allowing alternatives (like: txid>index vs txid:index) provides no benefit, but creates additional work for implementations (who quite likely only test formats they produce) and future incompatibilities.\n>>\n>> I know everyone loves to hate on it, but really (line-separated?) json is the way to go.\n>>\n>> { \"tx\": \"c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e\", \"label\": \"wow, such label\" }\n>> { \"tx: \"c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\", \"txout\": 4, \"label\": \"omg this is so easy to parse\" }\n>> { \"tx: \"c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\", \"txin\": 0, \"label\": \"wow this is going to be extensible as well\" }\n>>\n>> -Ryan\n>>\n>> ------- Original Message -------\n>> On Wednesday, August 24th, 2022 at 2:18 AM, Craig Raw via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Hi all,\n>>>\n>>> I would like to propose a BIP that specifies a format for the export and import of labels from a wallet. While transferring access to funds across wallet applications has been made simple through standards such as BIP39, wallet labels remain siloed and difficult to extract despite their value, particularly in a privacy context.\n>>>\n>>> The proposed format is a simple two column CSV file, with the reference to a transaction, address, input or output in the first column, and the label in the second column. CSV was chosen for its wide accessibility, especially to users without specific technical expertise. Similarly, the CSV file may be compressed using the ZIP format, and optionally encrypted using AES.\n>>>\n>>> The full text of the BIP can be found at https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki and also copied below.\n>>>\n>>> Feedback is appreciated.\n>>>\n>>> Thanks,\n>>> Craig Raw\n>>>\n>>> ---\n>>>\n>>> <pre>\n>>> BIP: wallet-labels\n>>> Layer: Applications\n>>> Title: Wallet Labels Export Format\n>>> Author: Craig Raw <craig at sparrowwallet.com>\n>>> Comments-Summary: No comments yet.\n>>> Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels\n>>> Status: Draft\n>>> Type: Informational\n>>> Created: 2022-08-23\n>>> License: BSD-2-Clause\n>>> </pre>\n>>>\n>>> ==Abstract==\n>>>\n>>> This document specifies a format for the export of labels that may be attached to the transactions, addresses, input and outputs in a wallet.\n>>>\n>>> ==Copyright==\n>>>\n>>> This BIP is licensed under the BSD 2-clause license.\n>>>\n>>> ==Motivation==\n>>>\n>>> The export and import of funds across different Bitcoin wallet applications is well defined through standards such as BIP39, BIP32, BIP44 etc.\n>>> These standards are well supported and allow users to move easily between different wallets.\n>>> There is, however, no defined standard to transfer any labels the user may have applied to the transactions, addresses, inputs or outputs in their wallet.\n>>> The UTXO model that Bitcoin uses makes these labels particularly valuable as they may indicate the source of funds, whether received externally or as a result of change from a prior transaction.\n>>> In both cases, care must be taken when spending to avoid undesirable leaks of private information.\n>>> Labels provide valuable guidance in this regard, and have even become mandatory when spending in several Bitcoin wallets.\n>>> Allowing users to export their labels in a standardized way ensures that they do not experience lock-in to a particular wallet application.\n>>> In addition, by using common formats, this BIP seeks to make manual or bulk management of labels accessible to users without specific technical expertise.\n>>>\n>>> ==Specification==\n>>>\n>>> In order to make the import and export of labels as widely accessible as possible, this BIP uses the comma separated values (CSV) format, which is widely supported by consumer, business, and scientific applications.\n>>> Although the technical specification of CSV in RFC4180 is not always followed, the application of the format in this BIP is simple enough that compatibility should not present a problem.\n>>> Moreover, the simplicity and forgiving nature of CSV (over for example JSON) lends itself well to bulk label editing using spreadsheet and text editing tools.\n>>>\n>>> A CSV export of labels from a wallet must be a UTF-8 encoded text file, containing one record per line, with records containing two fields delimited by a comma.\n>>> The fields may be quoted, but this is unnecessary, as the first comma in the line will always be the delimiter.\n>>> The first line in the file is a header, and should be ignored on import.\n>>> Thereafter, each line represents a record that refers to a label applied in the wallet.\n>>> The order in which these records appear is not defined.\n>>>\n>>> The first field in the record contains a reference to the transaction, address, input or output in the wallet.\n>>> This is specified as one of the following:\n>>> * Transaction ID (<tt>txid</tt>)\n>>> * Address\n>>> * Input (rendered as <tt>txid<index</tt>)\n>>> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)\n>>>\n>>> The second field contains the label applied to the reference.\n>>> Exporting applications may omit records with no labels or labels of zero length.\n>>> Files exported should use the <tt>.csv</tt> file extension.\n>>>\n>>> In order to reduce file size while retaining wide accessibility, the CSV file may be compressed using the ZIP file format, using the <tt>.zip</tt> file extension.\n>>> This <tt>.zip</tt> file may optionally be encrypted using either AES-128 or AES-256 encryption, which is supported by numerous applications including Winzip and 7-zip.\n>>> In order to ensure that weak encryption does not proliferate, importers following this standard must refuse to import <tt>.zip</tt> files encrypted with the weaker Zip 2.0 standard.\n>>> The textual representation of the wallet's extended public key (as defined by BIP32, with an <tt>xpub</tt> header) should be used as the password.\n>>>\n>>> ==Importing==\n>>>\n>>> When importing, a naive algorithm may simply match against any reference, but it is possible to disambiguate between transactions, addresses, inputs and outputs.\n>>> For example in the following pseudocode:\n>>> <pre>\n>>> if reference length < 64\n>>> Set address label\n>>> else if reference length == 64\n>>> Set transaction label\n>>> else if reference contains '<'\n>>> Set input label\n>>> else\n>>> Set output label\n>>> </pre>\n>>>\n>>> Importing applications may truncate labels if necessary.\n>>>\n>>> ==Test Vectors==\n>>>\n>>> The following fragment represents a wallet label export:\n>>> <pre>\n>>> Reference,Label\n>>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e,Transaction\n>>> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address\n>>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e<0,Input\n>>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e>0,Output\n>>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e:0,Output (alternative)\n>>> </pre>\n>>>\n>>> ==Reference Implementation==\n>>>\n>>> TBD\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220825/b57b0503/attachment-0001.html>"
            },
            {
                "author": "Clark Moody",
                "date": "2022-08-25T22:54:14",
                "message_text_only": "Having previously developed an export format[1] for general cryptocurrency transaction information, I can attest to the value of the human-readable CSV. I was careful to mention the RFC 4180 spec so that implementations could avoid the pitfalls of incorrect CSV encoding.\n\n[1]: https://github.com/harmony-csv/harmony\n\nClark\n\n------- Original Message -------\nOn Thursday, August 25th, 2022 at 3:59 AM, Craig Raw via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Thanks for your thoughts Ryan.\n>\n> Without reference to the quality feedback on this proposal, I was aware when submitting it for review that it provides an excellent opportunity for bike shedding. As developers, we have all experienced frustration with data formats. One thing that I did not perhaps make clear enough is that this format is not solely intended for developers, but general users who are probably not well represented on this list.\n>\n> While doing research for this proposal I spoke to several professional users of Sparrow Wallet (who are not developers). They all expressed a desire for the format to integrate with their business processes, which are driven by business tools such as Excel. Labelling provides an important function in UTXO and address management in these scenarios, and needs to be accessible and manageable outside of wallet software.\n>\n> If this is to be achieved, it immediately rules out JSON as a data format. Not only is JSON limited to editing only through specific software or text editors, but (in the latter case) it is fragile enough that a single missing character can cause an entire file to fail parsing. CSV is more forgiving in this regard. With respect to your comments on escaping, my expectation would be that developers will be using a mature CSV library rather than handling character escaping themselves. I would rather propose a format that is generally usable, even if occasionally a label is escaped incorrectly.\n>\n> Finally, I'll note that CSV files are already common and uncontroversial in Bitcoin wallet software. Bitcoin Core, Electrum, Sparrow (and no doubt many others) already export addresses and/or transactions with their labels as CSV files. This proposal simply attempts to create a standard for importing and exporting all the labels in a wallet.\n>\n> Craig\n>\n> On Wed, Aug 24, 2022 at 9:01 PM <rhavar at protonmail.com> wrote:\n>\n>> I'd strongly suggest not using CSV. Especially for a standard. I've worked with it as an interchange format many a times, and it's always been a clusterfuck.\n>>\n>> Right off the bat, you have stuff like \"The fields may be quoted, but this is unnecessary as the first comma in the line will always be the delimiter\" which invariably leads to some implementations doing it, some implementations not doing it, and others that are intolerant of the other way.\n>>\n>> And you have also made the classic mistake of not strictly defining escape rules. So everyone will pick their own (e.g. some will \\, escape commas, others will not cause it's quoted and escape quotes, and others will assume no escaping is required since its the last column in a csv).\n>>\n>> Over time it morphs into its own mini-monster that introduces so much pain.\n>>\n>> On a similar note, allowing alternatives (like: txid>index vs txid:index) provides no benefit, but creates additional work for implementations (who quite likely only test formats they produce) and future incompatibilities.\n>>\n>> I know everyone loves to hate on it, but really (line-separated?) json is the way to go.\n>>\n>> { \"tx\": \"c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e\", \"label\": \"wow, such label\" }\n>> { \"tx: \"c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\", \"txout\": 4, \"label\": \"omg this is so easy to parse\" }\n>> { \"tx: \"c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\", \"txin\": 0, \"label\": \"wow this is going to be extensible as well\" }\n>>\n>> -Ryan\n>>\n>> ------- Original Message -------\n>> On Wednesday, August 24th, 2022 at 2:18 AM, Craig Raw via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Hi all,\n>>>\n>>> I would like to propose a BIP that specifies a format for the export and import of labels from a wallet. While transferring access to funds across wallet applications has been made simple through standards such as BIP39, wallet labels remain siloed and difficult to extract despite their value, particularly in a privacy context.\n>>>\n>>> The proposed format is a simple two column CSV file, with the reference to a transaction, address, input or output in the first column, and the label in the second column. CSV was chosen for its wide accessibility, especially to users without specific technical expertise. Similarly, the CSV file may be compressed using the ZIP format, and optionally encrypted using AES.\n>>>\n>>> The full text of the BIP can be found at https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki and also copied below.\n>>>\n>>> Feedback is appreciated.\n>>>\n>>> Thanks,\n>>> Craig Raw\n>>>\n>>> ---\n>>>\n>>> <pre>\n>>> BIP: wallet-labels\n>>> Layer: Applications\n>>> Title: Wallet Labels Export Format\n>>> Author: Craig Raw <craig at sparrowwallet.com>\n>>> Comments-Summary: No comments yet.\n>>> Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels\n>>> Status: Draft\n>>> Type: Informational\n>>> Created: 2022-08-23\n>>> License: BSD-2-Clause\n>>> </pre>\n>>>\n>>> ==Abstract==\n>>>\n>>> This document specifies a format for the export of labels that may be attached to the transactions, addresses, input and outputs in a wallet.\n>>>\n>>> ==Copyright==\n>>>\n>>> This BIP is licensed under the BSD 2-clause license.\n>>>\n>>> ==Motivation==\n>>>\n>>> The export and import of funds across different Bitcoin wallet applications is well defined through standards such as BIP39, BIP32, BIP44 etc.\n>>> These standards are well supported and allow users to move easily between different wallets.\n>>> There is, however, no defined standard to transfer any labels the user may have applied to the transactions, addresses, inputs or outputs in their wallet.\n>>> The UTXO model that Bitcoin uses makes these labels particularly valuable as they may indicate the source of funds, whether received externally or as a result of change from a prior transaction.\n>>> In both cases, care must be taken when spending to avoid undesirable leaks of private information.\n>>> Labels provide valuable guidance in this regard, and have even become mandatory when spending in several Bitcoin wallets.\n>>> Allowing users to export their labels in a standardized way ensures that they do not experience lock-in to a particular wallet application.\n>>> In addition, by using common formats, this BIP seeks to make manual or bulk management of labels accessible to users without specific technical expertise.\n>>>\n>>> ==Specification==\n>>>\n>>> In order to make the import and export of labels as widely accessible as possible, this BIP uses the comma separated values (CSV) format, which is widely supported by consumer, business, and scientific applications.\n>>> Although the technical specification of CSV in RFC4180 is not always followed, the application of the format in this BIP is simple enough that compatibility should not present a problem.\n>>> Moreover, the simplicity and forgiving nature of CSV (over for example JSON) lends itself well to bulk label editing using spreadsheet and text editing tools.\n>>>\n>>> A CSV export of labels from a wallet must be a UTF-8 encoded text file, containing one record per line, with records containing two fields delimited by a comma.\n>>> The fields may be quoted, but this is unnecessary, as the first comma in the line will always be the delimiter.\n>>> The first line in the file is a header, and should be ignored on import.\n>>> Thereafter, each line represents a record that refers to a label applied in the wallet.\n>>> The order in which these records appear is not defined.\n>>>\n>>> The first field in the record contains a reference to the transaction, address, input or output in the wallet.\n>>> This is specified as one of the following:\n>>> * Transaction ID (<tt>txid</tt>)\n>>> * Address\n>>> * Input (rendered as <tt>txid<index</tt>)\n>>> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)\n>>>\n>>> The second field contains the label applied to the reference.\n>>> Exporting applications may omit records with no labels or labels of zero length.\n>>> Files exported should use the <tt>.csv</tt> file extension.\n>>>\n>>> In order to reduce file size while retaining wide accessibility, the CSV file may be compressed using the ZIP file format, using the <tt>.zip</tt> file extension.\n>>> This <tt>.zip</tt> file may optionally be encrypted using either AES-128 or AES-256 encryption, which is supported by numerous applications including Winzip and 7-zip.\n>>> In order to ensure that weak encryption does not proliferate, importers following this standard must refuse to import <tt>.zip</tt> files encrypted with the weaker Zip 2.0 standard.\n>>> The textual representation of the wallet's extended public key (as defined by BIP32, with an <tt>xpub</tt> header) should be used as the password.\n>>>\n>>> ==Importing==\n>>>\n>>> When importing, a naive algorithm may simply match against any reference, but it is possible to disambiguate between transactions, addresses, inputs and outputs.\n>>> For example in the following pseudocode:\n>>> <pre>\n>>> if reference length < 64\n>>> Set address label\n>>> else if reference length == 64\n>>> Set transaction label\n>>> else if reference contains '<'\n>>> Set input label\n>>> else\n>>> Set output label\n>>> </pre>\n>>>\n>>> Importing applications may truncate labels if necessary.\n>>>\n>>> ==Test Vectors==\n>>>\n>>> The following fragment represents a wallet label export:\n>>> <pre>\n>>> Reference,Label\n>>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e,Transaction\n>>> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address\n>>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e<0,Input\n>>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e>0,Output\n>>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e:0,Output (alternative)\n>>> </pre>\n>>>\n>>> ==Reference Implementation==\n>>>\n>>> TBD\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220825/20dfb197/attachment-0001.html>"
            },
            {
                "author": "Billy Tetrud",
                "date": "2022-08-27T22:20:31",
                "message_text_only": "I think it might be a good idea to record something that can directly\nconnect the list of labels with the correct wallet. Imagine someone backs\nup a bunch of label files and then forgets which wallet they apply to. Sure\nyou could probably look through the list of transactions, addresses, etc\nand compare against those contained in the actual wallet, but this would be\nsort of messy and potentially inefficient. It might be useful to include a\nhash of the wallet descriptor (hash for privacy) that can be compared\nagainst potential matching wallet descriptors.\n\nOn Fri, Aug 26, 2022 at 2:46 AM Clark Moody via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Having previously developed an export format[1] for general cryptocurrency\n> transaction information, I can attest to the value of the human-readable\n> CSV. I was careful to mention the RFC 4180 spec so that implementations\n> could avoid the pitfalls of incorrect CSV encoding.\n>\n> [1]: https://github.com/harmony-csv/harmony\n>\n> Clark\n>\n> ------- Original Message -------\n> On Thursday, August 25th, 2022 at 3:59 AM, Craig Raw via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Thanks for your thoughts Ryan.\n>\n> Without reference to the quality feedback on this proposal, I was aware\n> when submitting it for review that it provides an excellent opportunity for\n> bike shedding. As developers, we have all experienced frustration with data\n> formats. One thing that I did not perhaps make clear enough is that this\n> format is not solely intended for developers, but general users who are\n> probably not well represented on this list.\n>\n> While doing research for this proposal I spoke to several professional\n> users of Sparrow Wallet (who are not developers). They all expressed a\n> desire for the format to integrate with their business processes, which are\n> driven by business tools such as Excel. Labelling provides an important\n> function in UTXO and address management in these scenarios, and needs to be\n> accessible and manageable outside of wallet software.\n>\n> If this is to be achieved, it immediately rules out JSON as a data format.\n> Not only is JSON limited to editing only through specific software or text\n> editors, but (in the latter case) it is fragile enough that a single\n> missing character can cause an entire file to fail parsing. CSV is more\n> forgiving in this regard. With respect to your comments on escaping, my\n> expectation would be that developers will be using a mature CSV library\n> rather than handling character escaping themselves. I would rather propose\n> a format that is generally usable, even if occasionally a label is escaped\n> incorrectly.\n>\n> Finally, I'll note that CSV files are already common and uncontroversial\n> in Bitcoin wallet software. Bitcoin Core, Electrum, Sparrow (and no doubt\n> many others) already export addresses and/or transactions with their labels\n> as CSV files. This proposal simply attempts to create a standard for\n> importing and exporting all the labels in a wallet.\n>\n> Craig\n>\n> On Wed, Aug 24, 2022 at 9:01 PM <rhavar at protonmail.com> wrote:\n>\n>> I'd strongly suggest not using CSV. Especially for a standard. I've\n>> worked with it as an interchange format many a times, and it's always been\n>> a clusterfuck.\n>>\n>> Right off the bat, you have stuff like \"The fields may be quoted, but\n>> this is unnecessary as the first comma in the line will always be the\n>> delimiter\" which invariably leads to some implementations doing it, some\n>> implementations not doing it, and others that are intolerant of the other\n>> way.\n>>\n>> And you have also made the classic mistake of not strictly defining\n>> escape rules. So everyone will pick their own (e.g. some will \\, escape\n>> commas, others will not cause it's quoted and escape quotes, and others\n>> will assume no escaping is required since its the last column in a csv).\n>>\n>> Over time it morphs into its own mini-monster that introduces so much\n>> pain.\n>>\n>> On a similar note, allowing alternatives (like: txid>index vs\n>> txid:index) provides no benefit, but creates additional work for\n>> implementations (who quite likely only test formats they produce) and\n>> future incompatibilities.\n>>\n>> I know everyone loves to hate on it, but really (line-separated?) json is\n>> the way to go.\n>>\n>> { \"tx\": \"c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e\",\n>> \"label\": \"wow, such label\" }\n>> { \"tx: \"c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\",\n>> \"txout\": 4, \"label\": \"omg this is so easy to parse\" }\n>> { \"tx: \"c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\",\n>> \"txin\": 0, \"label\": \"wow this is going to be extensible as well\" }\n>>\n>>\n>>\n>>\n>> -Ryan\n>>\n>> ------- Original Message -------\n>> On Wednesday, August 24th, 2022 at 2:18 AM, Craig Raw via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> Hi all,\n>>\n>> I would like to propose a BIP that specifies a format for the export and\n>> import of labels from a wallet. While transferring access to funds across\n>> wallet applications has been made simple through standards such as BIP39,\n>> wallet labels remain siloed and difficult to extract despite their value,\n>> particularly in a privacy context.\n>>\n>> The proposed format is a simple two column CSV file, with the reference\n>> to a transaction, address, input or output in the first column, and the\n>> label in the second column. CSV was chosen for its wide accessibility,\n>> especially to users without specific technical expertise. Similarly, the\n>> CSV file may be compressed using the ZIP format, and optionally encrypted\n>> using AES.\n>>\n>> The full text of the BIP can be found at\n>> https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki\n>> and also copied below.\n>>\n>> Feedback is appreciated.\n>>\n>> Thanks,\n>> Craig Raw\n>>\n>> ---\n>>\n>> <pre>\n>> BIP: wallet-labels\n>> Layer: Applications\n>> Title: Wallet Labels Export Format\n>> Author: Craig Raw <craig at sparrowwallet.com>\n>> Comments-Summary: No comments yet.\n>> Comments-URI:\n>> https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels\n>> Status: Draft\n>> Type: Informational\n>> Created: 2022-08-23\n>> License: BSD-2-Clause\n>> </pre>\n>>\n>> ==Abstract==\n>>\n>> This document specifies a format for the export of labels that may be\n>> attached to the transactions, addresses, input and outputs in a wallet.\n>>\n>> ==Copyright==\n>>\n>> This BIP is licensed under the BSD 2-clause license.\n>>\n>> ==Motivation==\n>>\n>> The export and import of funds across different Bitcoin wallet\n>> applications is well defined through standards such as BIP39, BIP32, BIP44\n>> etc.\n>> These standards are well supported and allow users to move easily between\n>> different wallets.\n>> There is, however, no defined standard to transfer any labels the user\n>> may have applied to the transactions, addresses, inputs or outputs in their\n>> wallet.\n>> The UTXO model that Bitcoin uses makes these labels particularly valuable\n>> as they may indicate the source of funds, whether received externally or as\n>> a result of change from a prior transaction.\n>> In both cases, care must be taken when spending to avoid undesirable\n>> leaks of private information.\n>> Labels provide valuable guidance in this regard, and have even become\n>> mandatory when spending in several Bitcoin wallets.\n>> Allowing users to export their labels in a standardized way ensures that\n>> they do not experience lock-in to a particular wallet application.\n>> In addition, by using common formats, this BIP seeks to make manual or\n>> bulk management of labels accessible to users without specific technical\n>> expertise.\n>>\n>> ==Specification==\n>>\n>> In order to make the import and export of labels as widely accessible as\n>> possible, this BIP uses the comma separated values (CSV) format, which is\n>> widely supported by consumer, business, and scientific applications.\n>> Although the technical specification of CSV in RFC4180 is not always\n>> followed, the application of the format in this BIP is simple enough that\n>> compatibility should not present a problem.\n>> Moreover, the simplicity and forgiving nature of CSV (over for example\n>> JSON) lends itself well to bulk label editing using spreadsheet and text\n>> editing tools.\n>>\n>> A CSV export of labels from a wallet must be a UTF-8 encoded text file,\n>> containing one record per line, with records containing two fields\n>> delimited by a comma.\n>> The fields may be quoted, but this is unnecessary, as the first comma in\n>> the line will always be the delimiter.\n>> The first line in the file is a header, and should be ignored on import.\n>> Thereafter, each line represents a record that refers to a label applied\n>> in the wallet.\n>> The order in which these records appear is not defined.\n>>\n>> The first field in the record contains a reference to the transaction,\n>> address, input or output in the wallet.\n>> This is specified as one of the following:\n>> * Transaction ID (<tt>txid</tt>)\n>> * Address\n>> * Input (rendered as <tt>txid<index</tt>)\n>> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)\n>>\n>> The second field contains the label applied to the reference.\n>> Exporting applications may omit records with no labels or labels of zero\n>> length.\n>> Files exported should use the <tt>.csv</tt> file extension.\n>>\n>> In order to reduce file size while retaining wide accessibility, the CSV\n>> file may be compressed using the ZIP file format, using the <tt>.zip</tt>\n>> file extension.\n>> This <tt>.zip</tt> file may optionally be encrypted using either AES-128\n>> or AES-256 encryption, which is supported by numerous applications\n>> including Winzip and 7-zip.\n>> In order to ensure that weak encryption does not proliferate, importers\n>> following this standard must refuse to import <tt>.zip</tt> files encrypted\n>> with the weaker Zip 2.0 standard.\n>> The textual representation of the wallet's extended public key (as\n>> defined by BIP32, with an <tt>xpub</tt> header) should be used as the\n>> password.\n>>\n>> ==Importing==\n>>\n>> When importing, a naive algorithm may simply match against any reference,\n>> but it is possible to disambiguate between transactions, addresses, inputs\n>> and outputs.\n>> For example in the following pseudocode:\n>> <pre>\n>> if reference length < 64\n>> Set address label\n>> else if reference length == 64\n>> Set transaction label\n>> else if reference contains '<'\n>> Set input label\n>> else\n>> Set output label\n>> </pre>\n>>\n>> Importing applications may truncate labels if necessary.\n>>\n>> ==Test Vectors==\n>>\n>> The following fragment represents a wallet label export:\n>> <pre>\n>> Reference,Label\n>>\n>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e,Transaction\n>> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address\n>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e<0,Input\n>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e>0,Output\n>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e:0,Output\n>> (alternative)\n>> </pre>\n>>\n>> ==Reference Implementation==\n>>\n>> TBD\n>>\n>>\n>>\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220827/d9a86c1b/attachment-0001.html>"
            },
            {
                "author": "Ali Sherief",
                "date": "2022-08-24T19:10:04",
                "message_text_only": "Hi Craig,\n\nThis a really good proposal. I studied your BIP and I have some feedback on some parts of it.\n\n> The first line in the file is a header, and should be ignored on import.\n\n>From past experience and lessons, most notably BIP39, it is important that a version byte is defined somewhere in case someone wants to extend it in the future, currently there is no version byte which someone can increment if somebody wants to extend it. In the unique case of CSV files, you should make the header line mandatory (I see you have already implied this, but you should make it explicit in the BIP), but instead of a line with columns in it, I suggest instead of Reference,Label, you make the format like this:\n\nBIP-wallet-labels,<version>\n\nSince there are two columns per record, this works out nicely. The first column can be the name of the BIP - BIPxxxx where the x's are numbers, and the second column can be an unsigned 32-bit integer (most significant 8 bits reserved for version, the remaining for flags, or perhaps the entirety for version - but I recommend leaving at least some bits for flags, even if they all end up being just \"reserved\").\n\nYou should make importing fail if the header line is not exactly as specified - or appropriate, should you decide a different format for the header.\n\n> Files exported should use the <tt>.csv</tt> file extension.\nDon't mandate the file extension (read below for why):\n\n> In order to reduce file size while retaining wide accessibility, the CSV\n> file may be compressed using the ZIP file format, using the <tt>.zip</tt>\n> file extension.\nI see three problems with this. The first is more important than the later two because it makes them moot points, but I'll mention them anyway so you get a background of the situation:\n- The BIP is trying to specify in what file format the export format can be written in onto the filesystem. There is no way to enforce this on a BIP level (besides, Unix operating systems don't even consider the file extension, they use its mimetype). Also specifying this in the BIP will prevent modular \"Layer 2\" protocols and schemes from encoding the Export labels into another format - for example Base64 or with their own compression algorithm.\n\nNow for the two \"moot problems\":\n- ZIP does not have good performance or compression ratio, there are better algorithms out there like gzip (which also happens to be more ubiquitous; nearly all websites are serving HTML compressed with gzip compression).\n- ZIP is an archiving format, that happens to have its own compression format. Archiving format parsers can have serious vulnerabilities in their implementation that can allow malware to swipe private keys and passwords, since the primary target for this BIP is wallets. For example, there was Zip Slip[1] in 2018, which allows for remote code execution. So the malware can even hide in memory until private keys or passwords are written to memory, then send them accros the network. Assuming it's targeting a specific wallet software it's not hard to carry out at all.\n\nThere's two solutions for all this:\n1. The duck-tape solution: Use some compression algorithm like gzip instead of ZIP archive format.\n2. The \"throw it out and buy a new one\" solution: Get rid of the optional compression specs altogether, because users are responsible for supplying the export labels in the first place, so all the compression stuff is redundant and should be left up to the user use if they desire to.\n\nI prefer the second solution because it hits the nail at the problem directly instead of putting duck tape on it like the first one.\n\n> This <tt>.zip</tt> file may optionally be encrypted using either AES-128 or\n> AES-256 encryption, which is supported by numerous applications including\n> Winzip and 7-zip.\n> The textual representation of the wallet's extended public key (as defined\n> by BIP32, with an <tt>xpub</tt> header) should be used as the password.\nNot specific to AES, but I don't see the benefit of encrypting addresses and labels together. Can you please elaborate why this would be desireable?\n\nLike I said though, it's better to leave it up to users to decide how to store their exports, since BIPs can't enforce that anyway (additionally, the password you propose is insecure - anybody with access to the wallet can unlock it, which is not desireable to some users who want their own security).\n\n> * Transaction ID (<tt>txid</tt>)\n> * Address\n> * Input (rendered as <tt>txid<index</tt>)\n> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)\nWhy the need for input and output formats? There is no difference between them on the wallet level, because they are always identified with a txid and output index. To distinguish between them and hence write them with the correct format would require a UTXO set and thus access to a full node, otherwise the CSV cannot be verified to be completely well-formed.\n\nAnother important point is that practically nobody labels inputs or outputs because most people do not know that those things even exist, and the rest don't bother to label them.\n\nBut the biggest downside to including them is related to the problem of information leaking which you make reference to here:\n> In both cases, care must be taken when spending to avoid undesirable leaks\n> of private information.\nA CSV dump that has inputs/outputs and addresses mixed together can infer the owner of all those items. In fact, A CVS label dump is basically a personal information store so everything in it can be correlated as coming from the same wallet, so it's important that unnecessary types are kept out of the format. People are known to leave files lying around on their computer that they don't need anymore, so these files can find their way via telemetry to surveillence entities. While we can't specify what users can do with their exports, we can control the information leak by preventing certain types of items that we know most users will never use from being exported in the first place.\n\n> The order in which these records appear is not defined.\nAgain, since the primary use case for this BIP is wallets, which likely use heirarchical derivation schemes like BIP44, there is a net benefit for the addresses to be exported in ascending order of their `address_type`. It means that wallets can import them in O(n) time as opposed to O(n^2) time spent serially checking in which index the address appears at. Of course, this implies that all addresses up to a certain index have to be exported into the CSV as well, but most wallets I know of like Core, Electrum already store addresses like that.\n\nAlso if you do this, you will need to group all the transaction records before the address records or vice versa - you can use lexigraphical sorting if you want (ie. Addresses before Transactions). The benefit of this separation of parts is that wallets can split the imported address records from the transaction records internally, and feed them to separate functions which set these labels internally.\n\nIf you decide on doing it this way, then you need a 3rd column to identify the item type, and also you should quote the label (see below). I strongly recommend using numbers for identification as opposed to character strings, so you don't have to worry about localization or character case issues. There is always one unique number, but there could be multiple strings that reference the same type. This will complicate importing functions.\n\nIf you insist on include Input and Output types then they can both be specified as <txid>:<index> if you do this change. They won't be used to determine the type anyway.\n\n> The fields may be quoted, but this is unnecessary, as the first comma in\n> the line will always be the delimiter.\nDon't implement it like that, because that will break CSV parsers which expect a fixed amount of rows in each record (2 in the header, and some rows have >2 rows). It's better to mandate that they should always be double-quoted, since only wallets will generate label exports anyway. If you plan to use headers then the 3rd column can be blank for it (or you can split the version and flags from each other).\n\n> ==Importing==\n>\n> When importing, a naive algorithm may simply match against any reference,\n> but it is possible to disambiguate between transactions, addresses, inputs\n> and outputs.\n> For example in the following pseudocode:\n> <pre>\n>   if reference length < 64\n>     Set address label\n>   else if reference length == 64\n>     Set transaction label\n>   else if reference contains '<'\n>     Set input label\n>   else\n>     Set output label\n> </pre>\nThe importing code is too naive and in its current form will prevent the BIP from getting a number. It is perhaps the single most important part of a BIP. When implementing an importer, it should utilize a dedicate item type field that unambiguously identifies the item. So the naive importer is not good, you need use a 3rd column for that like I explained above, so that the importer becomes robust.\n\nIn summary (exclamation marks indicate severity - one means low, two means medium, and three means high):\n\n1. Convert the header into a version line with optional flags, otherwise nobody can extend this format without compatibility issues (!)\n2. Get rid of the specs related to file compression (!!!)\n3. Add a 3rd column for item type (address, transaction etc.) preferably as numeric constants and grouping items of one type after items of another type, or if you insist on strings, then only recognize their Titlecase ASCII versions <spreadsheet software like Excel always tries to titlecase the words> (!!)\n4. Require double quotes around the label (or single quotes if you prefer, as long as spreadsheet software doesn't choke on them) (!!)\n5. Require sorting the records according to the order they are stored in the wallet implementation. (!)\n6. Consider getting rid of Input and Output item types. (!)\n7. And last and most importantly, please write a more robust importer algorithm in the example given by the BIP, because code in BIPs are frequently used as references for software. (!!!)\n\nI hope you will consider these points in future revisions of your BIP.\n\n- Ali\n\n[1] https://github.com/snyk/zip-slip-vulnerability\n\nOn Wed, 24 Aug 2022 11:18:43 +0200, craigraw at gmail.com wrote:\n> Hi all,\n>\n> I would like to propose a BIP that specifies a format for the export and\n> import of labels from a wallet. While transferring access to funds across\n> wallet applications has been made simple through standards such as BIP39,\n> wallet labels remain siloed and difficult to extract despite their value,\n> particularly in a privacy context.\n>\n> The proposed format is a simple two column CSV file, with the reference to\n> a transaction, address, input or output in the first column, and the label\n> in the second column. CSV was chosen for its wide accessibility, especially\n> to users without specific technical expertise. Similarly, the CSV file may\n> be compressed using the ZIP format, and optionally encrypted using AES.\n>\n> The full text of the BIP can be found at\n> https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki\n> and also copied below.\n>\n> Feedback is appreciated.\n>\n> Thanks,\n> Craig Raw\n>\n> ---\n>\n> <pre>\n>   BIP: wallet-labels\n>   Layer: Applications\n>   Title: Wallet Labels Export Format\n>   Author: Craig Raw <craig at sparrowwallet.com>\n>   Comments-Summary: No comments yet.\n>   Comments-URI:\n> https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels\n>   Status: Draft\n>   Type: Informational\n>   Created: 2022-08-23\n>   License: BSD-2-Clause\n> </pre>\n>\n> ==Abstract==\n>\n> This document specifies a format for the export of labels that may be\n> attached to the transactions, addresses, input and outputs in a wallet.\n>\n> ==Copyright==\n>\n> This BIP is licensed under the BSD 2-clause license.\n>\n> ==Motivation==\n>\n> The export and import of funds across different Bitcoin wallet applications\n> is well defined through standards such as BIP39, BIP32, BIP44 etc.\n> These standards are well supported and allow users to move easily between\n> different wallets.\n> There is, however, no defined standard to transfer any labels the user may\n> have applied to the transactions, addresses, inputs or outputs in their\n> wallet.\n> The UTXO model that Bitcoin uses makes these labels particularly valuable\n> as they may indicate the source of funds, whether received externally or as\n> a result of change from a prior transaction.\n> In both cases, care must be taken when spending to avoid undesirable leaks\n> of private information.\n> Labels provide valuable guidance in this regard, and have even become\n> mandatory when spending in several Bitcoin wallets.\n> Allowing users to export their labels in a standardized way ensures that\n> they do not experience lock-in to a particular wallet application.\n> In addition, by using common formats, this BIP seeks to make manual or bulk\n> management of labels accessible to users without specific technical\n> expertise.\n>\n> ==Specification==\n>\n> In order to make the import and export of labels as widely accessible as\n> possible, this BIP uses the comma separated values (CSV) format, which is\n> widely supported by consumer, business, and scientific applications.\n> Although the technical specification of CSV in RFC4180 is not always\n> followed, the application of the format in this BIP is simple enough that\n> compatibility should not present a problem.\n> Moreover, the simplicity and forgiving nature of CSV (over for example\n> JSON) lends itself well to bulk label editing using spreadsheet and text\n> editing tools.\n>\n> A CSV export of labels from a wallet must be a UTF-8 encoded text file,\n> containing one record per line, with records containing two fields\n> delimited by a comma.\n> The fields may be quoted, but this is unnecessary, as the first comma in\n> the line will always be the delimiter.\n> The first line in the file is a header, and should be ignored on import.\n> Thereafter, each line represents a record that refers to a label applied in\n> the wallet.\n> The order in which these records appear is not defined.\n>\n> The first field in the record contains a reference to the transaction,\n> address, input or output in the wallet.\n> This is specified as one of the following:\n> * Transaction ID (<tt>txid</tt>)\n> * Address\n> * Input (rendered as <tt>txid<index</tt>)\n> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)\n>\n> The second field contains the label applied to the reference.\n> Exporting applications may omit records with no labels or labels of zero\n> length.\n> Files exported should use the <tt>.csv</tt> file extension.\n>\n> In order to reduce file size while retaining wide accessibility, the CSV\n> file may be compressed using the ZIP file format, using the <tt>.zip</tt>\n> file extension.\n> This <tt>.zip</tt> file may optionally be encrypted using either AES-128 or\n> AES-256 encryption, which is supported by numerous applications including\n> Winzip and 7-zip.\n> In order to ensure that weak encryption does not proliferate, importers\n> following this standard must refuse to import <tt>.zip</tt> files encrypted\n> with the weaker Zip 2.0 standard.\n> The textual representation of the wallet's extended public key (as defined\n> by BIP32, with an <tt>xpub</tt> header) should be used as the password.\n>\n> ==Importing==\n>\n> When importing, a naive algorithm may simply match against any reference,\n> but it is possible to disambiguate between transactions, addresses, inputs\n> and outputs.\n> For example in the following pseudocode:\n> <pre>\n>   if reference length < 64\n>     Set address label\n>   else if reference length == 64\n>     Set transaction label\n>   else if reference contains '<'\n>     Set input label\n>   else\n>     Set output label\n> </pre>\n>\n> Importing applications may truncate labels if necessary.\n>\n> ==Test Vectors==\n>\n> The following fragment represents a wallet label export:\n> <pre>\n> Reference,Label\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction\n> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output\n> (alternative)\n> </pre>\n>\n> ==Reference Implementation==\n>\n> TBD"
            },
            {
                "author": "Billy Tetrud",
                "date": "2022-08-27T21:03:01",
                "message_text_only": "@Ali Thats some good well thought through and well articulated feedback. I\nhave one point of contention\n\n> it's important that unnecessary types are kept out of the format. People\nare known to leave files lying around on their computer that they don't\nneed anymore, so these files can find their way via telemetry to\nsurveillence entities. While we can't specify what users can do with their\nexports, we can control the information leak by preventing certain types of\nitems that we know most users will never use from being exported in the\nfirst place.\n\nThis seems to run contrary with your point about letting users be in\ncontrol of how they store this. Given that you can always connect together\nan output and its address or find the outputs at any address, it doesn't\nseem like it would actually leak any more information than just including\naddresses. Am I missing something?\n\nOn Wed, Aug 24, 2022, 14:44 Ali Sherief via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi Craig,\n>\n> This a really good proposal. I studied your BIP and I have some feedback\n> on some parts of it.\n>\n> > The first line in the file is a header, and should be ignored on import.\n>\n> From past experience and lessons, most notably BIP39, it is important that\n> a version byte is defined somewhere in case someone wants to extend it in\n> the future, currently there is no version byte which someone can increment\n> if somebody wants to extend it. In the unique case of CSV files, you should\n> make the header line mandatory (I see you have already implied this, but\n> you should make it explicit in the BIP), but instead of a line with columns\n> in it, I suggest instead of Reference,Label, you make the format like this:\n>\n> BIP-wallet-labels,<version>\n>\n> Since there are two columns per record, this works out nicely. The first\n> column can be the name of the BIP - BIPxxxx where the x's are numbers, and\n> the second column can be an unsigned 32-bit integer (most significant 8\n> bits reserved for version, the remaining for flags, or perhaps the entirety\n> for version - but I recommend leaving at least some bits for flags, even if\n> they all end up being just \"reserved\").\n>\n> You should make importing fail if the header line is not exactly as\n> specified - or appropriate, should you decide a different format for the\n> header.\n>\n> > Files exported should use the <tt>.csv</tt> file extension.\n> Don't mandate the file extension (read below for why):\n>\n> > In order to reduce file size while retaining wide accessibility, the CSV\n> > file may be compressed using the ZIP file format, using the <tt>.zip</tt>\n> > file extension.\n> I see three problems with this. The first is more important than the later\n> two because it makes them moot points, but I'll mention them anyway so you\n> get a background of the situation:\n> - The BIP is trying to specify in what file format the export format can\n> be written in onto the filesystem. There is no way to enforce this on a BIP\n> level (besides, Unix operating systems don't even consider the file\n> extension, they use its mimetype). Also specifying this in the BIP will\n> prevent modular \"Layer 2\" protocols and schemes from encoding the Export\n> labels into another format - for example Base64 or with their own\n> compression algorithm.\n>\n> Now for the two \"moot problems\":\n> - ZIP does not have good performance or compression ratio, there are\n> better algorithms out there like gzip (which also happens to be more\n> ubiquitous; nearly all websites are serving HTML compressed with gzip\n> compression).\n> - ZIP is an archiving format, that happens to have its own compression\n> format. Archiving format parsers can have serious vulnerabilities in their\n> implementation that can allow malware to swipe private keys and passwords,\n> since the primary target for this BIP is wallets. For example, there was\n> Zip Slip[1] in 2018, which allows for remote code execution. So the malware\n> can even hide in memory until private keys or passwords are written to\n> memory, then send them accros the network. Assuming it's targeting a\n> specific wallet software it's not hard to carry out at all.\n>\n> There's two solutions for all this:\n> 1. The duck-tape solution: Use some compression algorithm like gzip\n> instead of ZIP archive format.\n> 2. The \"throw it out and buy a new one\" solution: Get rid of the optional\n> compression specs altogether, because users are responsible for supplying\n> the export labels in the first place, so all the compression stuff is\n> redundant and should be left up to the user use if they desire to.\n>\n> I prefer the second solution because it hits the nail at the problem\n> directly instead of putting duck tape on it like the first one.\n>\n> > This <tt>.zip</tt> file may optionally be encrypted using either AES-128\n> or\n> > AES-256 encryption, which is supported by numerous applications including\n> > Winzip and 7-zip.\n> > The textual representation of the wallet's extended public key (as\n> defined\n> > by BIP32, with an <tt>xpub</tt> header) should be used as the password.\n> Not specific to AES, but I don't see the benefit of encrypting addresses\n> and labels together. Can you please elaborate why this would be desireable?\n>\n> Like I said though, it's better to leave it up to users to decide how to\n> store their exports, since BIPs can't enforce that anyway (additionally,\n> the password you propose is insecure - anybody with access to the wallet\n> can unlock it, which is not desireable to some users who want their own\n> security).\n>\n> > * Transaction ID (<tt>txid</tt>)\n> > * Address\n> > * Input (rendered as <tt>txid<index</tt>)\n> > * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)\n> Why the need for input and output formats? There is no difference between\n> them on the wallet level, because they are always identified with a txid\n> and output index. To distinguish between them and hence write them with the\n> correct format would require a UTXO set and thus access to a full node,\n> otherwise the CSV cannot be verified to be completely well-formed.\n>\n> Another important point is that practically nobody labels inputs or\n> outputs because most people do not know that those things even exist, and\n> the rest don't bother to label them.\n>\n> But the biggest downside to including them is related to the problem of\n> information leaking which you make reference to here:\n> > In both cases, care must be taken when spending to avoid undesirable\n> leaks\n> > of private information.\n> A CSV dump that has inputs/outputs and addresses mixed together can infer\n> the owner of all those items. In fact, A CVS label dump is basically a\n> personal information store so everything in it can be correlated as coming\n> from the same wallet, so it's important that unnecessary types are kept out\n> of the format. People are known to leave files lying around on their\n> computer that they don't need anymore, so these files can find their way\n> via telemetry to surveillence entities. While we can't specify what users\n> can do with their exports, we can control the information leak by\n> preventing certain types of items that we know most users will never use\n> from being exported in the first place.\n>\n> > The order in which these records appear is not defined.\n> Again, since the primary use case for this BIP is wallets, which likely\n> use heirarchical derivation schemes like BIP44, there is a net benefit for\n> the addresses to be exported in ascending order of their `address_type`. It\n> means that wallets can import them in O(n) time as opposed to O(n^2) time\n> spent serially checking in which index the address appears at. Of course,\n> this implies that all addresses up to a certain index have to be exported\n> into the CSV as well, but most wallets I know of like Core, Electrum\n> already store addresses like that.\n>\n> Also if you do this, you will need to group all the transaction records\n> before the address records or vice versa - you can use lexigraphical\n> sorting if you want (ie. Addresses before Transactions). The benefit of\n> this separation of parts is that wallets can split the imported address\n> records from the transaction records internally, and feed them to separate\n> functions which set these labels internally.\n>\n> If you decide on doing it this way, then you need a 3rd column to identify\n> the item type, and also you should quote the label (see below). I strongly\n> recommend using numbers for identification as opposed to character strings,\n> so you don't have to worry about localization or character case issues.\n> There is always one unique number, but there could be multiple strings that\n> reference the same type. This will complicate importing functions.\n>\n> If you insist on include Input and Output types then they can both be\n> specified as <txid>:<index> if you do this change. They won't be used to\n> determine the type anyway.\n>\n> > The fields may be quoted, but this is unnecessary, as the first comma in\n> > the line will always be the delimiter.\n> Don't implement it like that, because that will break CSV parsers which\n> expect a fixed amount of rows in each record (2 in the header, and some\n> rows have >2 rows). It's better to mandate that they should always be\n> double-quoted, since only wallets will generate label exports anyway. If\n> you plan to use headers then the 3rd column can be blank for it (or you can\n> split the version and flags from each other).\n>\n> > ==Importing==\n> >\n> > When importing, a naive algorithm may simply match against any reference,\n> > but it is possible to disambiguate between transactions, addresses,\n> inputs\n> > and outputs.\n> > For example in the following pseudocode:\n> > <pre>\n> >   if reference length < 64\n> >     Set address label\n> >   else if reference length == 64\n> >     Set transaction label\n> >   else if reference contains '<'\n> >     Set input label\n> >   else\n> >     Set output label\n> > </pre>\n> The importing code is too naive and in its current form will prevent the\n> BIP from getting a number. It is perhaps the single most important part of\n> a BIP. When implementing an importer, it should utilize a dedicate item\n> type field that unambiguously identifies the item. So the naive importer is\n> not good, you need use a 3rd column for that like I explained above, so\n> that the importer becomes robust.\n>\n> In summary (exclamation marks indicate severity - one means low, two means\n> medium, and three means high):\n>\n> 1. Convert the header into a version line with optional flags, otherwise\n> nobody can extend this format without compatibility issues (!)\n> 2. Get rid of the specs related to file compression (!!!)\n> 3. Add a 3rd column for item type (address, transaction etc.) preferably\n> as numeric constants and grouping items of one type after items of another\n> type, or if you insist on strings, then only recognize their Titlecase\n> ASCII versions <spreadsheet software like Excel always tries to titlecase\n> the words> (!!)\n> 4. Require double quotes around the label (or single quotes if you prefer,\n> as long as spreadsheet software doesn't choke on them) (!!)\n> 5. Require sorting the records according to the order they are stored in\n> the wallet implementation. (!)\n> 6. Consider getting rid of Input and Output item types. (!)\n> 7. And last and most importantly, please write a more robust importer\n> algorithm in the example given by the BIP, because code in BIPs are\n> frequently used as references for software. (!!!)\n>\n> I hope you will consider these points in future revisions of your BIP.\n>\n> - Ali\n>\n> [1] https://github.com/snyk/zip-slip-vulnerability\n>\n> On Wed, 24 Aug 2022 11:18:43 +0200, craigraw at gmail.com wrote:\n> > Hi all,\n> >\n> > I would like to propose a BIP that specifies a format for the export and\n> > import of labels from a wallet. While transferring access to funds across\n> > wallet applications has been made simple through standards such as BIP39,\n> > wallet labels remain siloed and difficult to extract despite their value,\n> > particularly in a privacy context.\n> >\n> > The proposed format is a simple two column CSV file, with the reference\n> to\n> > a transaction, address, input or output in the first column, and the\n> label\n> > in the second column. CSV was chosen for its wide accessibility,\n> especially\n> > to users without specific technical expertise. Similarly, the CSV file\n> may\n> > be compressed using the ZIP format, and optionally encrypted using AES.\n> >\n> > The full text of the BIP can be found at\n> > https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki\n> > and also copied below.\n> >\n> > Feedback is appreciated.\n> >\n> > Thanks,\n> > Craig Raw\n> >\n> > ---\n> >\n> > <pre>\n> >   BIP: wallet-labels\n> >   Layer: Applications\n> >   Title: Wallet Labels Export Format\n> >   Author: Craig Raw <craig at sparrowwallet.com>\n> >   Comments-Summary: No comments yet.\n> >   Comments-URI:\n> > https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels\n> >   Status: Draft\n> >   Type: Informational\n> >   Created: 2022-08-23\n> >   License: BSD-2-Clause\n> > </pre>\n> >\n> > ==Abstract==\n> >\n> > This document specifies a format for the export of labels that may be\n> > attached to the transactions, addresses, input and outputs in a wallet.\n> >\n> > ==Copyright==\n> >\n> > This BIP is licensed under the BSD 2-clause license.\n> >\n> > ==Motivation==\n> >\n> > The export and import of funds across different Bitcoin wallet\n> applications\n> > is well defined through standards such as BIP39, BIP32, BIP44 etc.\n> > These standards are well supported and allow users to move easily between\n> > different wallets.\n> > There is, however, no defined standard to transfer any labels the user\n> may\n> > have applied to the transactions, addresses, inputs or outputs in their\n> > wallet.\n> > The UTXO model that Bitcoin uses makes these labels particularly valuable\n> > as they may indicate the source of funds, whether received externally or\n> as\n> > a result of change from a prior transaction.\n> > In both cases, care must be taken when spending to avoid undesirable\n> leaks\n> > of private information.\n> > Labels provide valuable guidance in this regard, and have even become\n> > mandatory when spending in several Bitcoin wallets.\n> > Allowing users to export their labels in a standardized way ensures that\n> > they do not experience lock-in to a particular wallet application.\n> > In addition, by using common formats, this BIP seeks to make manual or\n> bulk\n> > management of labels accessible to users without specific technical\n> > expertise.\n> >\n> > ==Specification==\n> >\n> > In order to make the import and export of labels as widely accessible as\n> > possible, this BIP uses the comma separated values (CSV) format, which is\n> > widely supported by consumer, business, and scientific applications.\n> > Although the technical specification of CSV in RFC4180 is not always\n> > followed, the application of the format in this BIP is simple enough that\n> > compatibility should not present a problem.\n> > Moreover, the simplicity and forgiving nature of CSV (over for example\n> > JSON) lends itself well to bulk label editing using spreadsheet and text\n> > editing tools.\n> >\n> > A CSV export of labels from a wallet must be a UTF-8 encoded text file,\n> > containing one record per line, with records containing two fields\n> > delimited by a comma.\n> > The fields may be quoted, but this is unnecessary, as the first comma in\n> > the line will always be the delimiter.\n> > The first line in the file is a header, and should be ignored on import.\n> > Thereafter, each line represents a record that refers to a label applied\n> in\n> > the wallet.\n> > The order in which these records appear is not defined.\n> >\n> > The first field in the record contains a reference to the transaction,\n> > address, input or output in the wallet.\n> > This is specified as one of the following:\n> > * Transaction ID (<tt>txid</tt>)\n> > * Address\n> > * Input (rendered as <tt>txid<index</tt>)\n> > * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)\n> >\n> > The second field contains the label applied to the reference.\n> > Exporting applications may omit records with no labels or labels of zero\n> > length.\n> > Files exported should use the <tt>.csv</tt> file extension.\n> >\n> > In order to reduce file size while retaining wide accessibility, the CSV\n> > file may be compressed using the ZIP file format, using the <tt>.zip</tt>\n> > file extension.\n> > This <tt>.zip</tt> file may optionally be encrypted using either AES-128\n> or\n> > AES-256 encryption, which is supported by numerous applications including\n> > Winzip and 7-zip.\n> > In order to ensure that weak encryption does not proliferate, importers\n> > following this standard must refuse to import <tt>.zip</tt> files\n> encrypted\n> > with the weaker Zip 2.0 standard.\n> > The textual representation of the wallet's extended public key (as\n> defined\n> > by BIP32, with an <tt>xpub</tt> header) should be used as the password.\n> >\n> > ==Importing==\n> >\n> > When importing, a naive algorithm may simply match against any reference,\n> > but it is possible to disambiguate between transactions, addresses,\n> inputs\n> > and outputs.\n> > For example in the following pseudocode:\n> > <pre>\n> >   if reference length < 64\n> >     Set address label\n> >   else if reference length == 64\n> >     Set transaction label\n> >   else if reference contains '<'\n> >     Set input label\n> >   else\n> >     Set output label\n> > </pre>\n> >\n> > Importing applications may truncate labels if necessary.\n> >\n> > ==Test Vectors==\n> >\n> > The following fragment represents a wallet label export:\n> > <pre>\n> > Reference,Label\n> >\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction\n> > 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address\n> > c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input\n> >\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output\n> >\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output\n> > (alternative)\n> > </pre>\n> >\n> > ==Reference Implementation==\n> >\n> > TBD\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220827/656c893a/attachment-0001.html>"
            },
            {
                "author": "Craig Raw",
                "date": "2022-08-29T11:25:13",
                "message_text_only": "Thanks for your feedback @Ali.\n\nI am attempting to achieve two goals with this proposal, primarily for the\nbenefit of wallet users:\n\nGoal #1. Transfer labels between different wallet implementations\nGoal #2. Manage labels in applications outside of Bitcoin wallets (such as\nExcel)\n\nMuch of the feedback so far has indicated the tension between these two\ngoals - it may be that it is too difficult to achieve both, in which case\nGoal #1 is the most important. That said, I think further exploration is\nstill necessary before abandoning Goal #2, because removing it would\nsignificantly reduce the value of this proposal and mean users need to rely\non application-specific workarounds.\n\n> it is important that a version byte is defined\nIf Goal #2 is to be achieved it's difficult to mandate this, particularly\nif one requires bit flags to be set. Should an importing wallet fail to\nimport if the version byte is not present, even if all the data is\notherwise correct? Although it is difficult to know in advance how a format\nmay be extended, it is certainly possible to extend this format with\nadditional types where the nature of hashes serve as unique identifiers\n(more on this below).\n\n > Don't mandate the file extension... There is no way to enforce this on a\nBIP level.\nI'm not quite sure what you mean here - for example BIP174, which is widely\nused, states \"Binary PSBT files should use the .psbt file extension.\" Also,\nthis contradicts Goal #2 - Excel and Numbers register as handlers for .csv,\nand so make it clear that the file is editable outside of a wallet.\n\n> ZIP does not have good performance or compression ratio\nIndeed, but it is very widely available. That said, gzip is supported\nwidely too these days. Unfortunately, gzip does not offer encryption (see\nnext answer).\n\n> ZIP is an archiving format, that happens to have its own compression\nformat.\nI agree this is not ideal. My main reason for choosing ZIP was that it\nsupports encryption. It seems to me that without considering encryption, an\napplication must create label export files that allow privacy-sensitive\nwallet information to be readable in plain text. Being able to transfer\nlabels without risking privacy is IMO valuable. I considered other\nencryption formats such as PGP, but they are much more niche and so again\ncontradict Goal #2.\n\n> I don't see the benefit of encrypting addresses and labels together...\nadditionally, the password you propose is insecure - anybody with access to\nthe wallet can unlock it\nI'm not sure I understand your question, but both wallet addresses and\nwallet labels contain privacy-sensitive information that should be\nprotected. Wrt to the password, there is actually a more fundamental\nproblem with using the wallet xpub - there is no equivalent for multisig\nwallets. For this reason I'll remove that requirement in future iterations.\n\n> Why the need for input and output formats? There is no difference between\nthem on the wallet level, because they are always identified with a txid\nand output index.\nThe input refers to the txid and the input index (in the set of vin), so\nthe difference is the context in which they are displayed. A wallet will\nnot necessarily store the spent outputs for a funding transaction\ncontaining a UTXO coming into the wallet, but it will contain references to\nthe inputs as part of that transaction.\n\n> Another important point is that practically nobody labels inputs or\noutputs\nTo the contrary, UTXOs are very frequently labelled, as they link and\nreveal information when spent. Inputs are much less frequently labelled,\nbut there is no particular reason to exclude them.\n\n> there is a net benefit for the addresses to be exported in ascending order\nIndeed, but it makes achieving Goal #2 much more difficult for marginal\nbenefit.\n\n> It's better to mandate that they should always be double-quoted, since\nonly wallets will generate label exports anyway.\nRather I think it's better to mandate RFC4180 is followed, as per\nrecommendations in other feedback.\n\n> The importing code is too naive... it should utilize a dedicate item type\nfield that unambiguously identifies the item\nIt's unclear to me what you mean here. As I've indicated it is currently\npossible to disambiguate between addresses/transactions/etc without the\nneed for a 3rd column, but in any case the hash functions used ensure that\nlabels will not be associated incorrectly. Even in the unlikely event of\nsome future address type being indistinguishable from a txid, it will\nsimply not match any txids in the wallet.\n\nCraig\n\n\n\nOn Wed, Aug 24, 2022 at 9:10 PM Ali Sherief <ali at notatether.com> wrote:\n\n> Hi Craig,\n>\n> This a really good proposal. I studied your BIP and I have some feedback\n> on some parts of it.\n>\n> > The first line in the file is a header, and should be ignored on import.\n>\n> From past experience and lessons, most notably BIP39, it is important that\n> a version byte is defined somewhere in case someone wants to extend it in\n> the future, currently there is no version byte which someone can increment\n> if somebody wants to extend it. In the unique case of CSV files, you should\n> make the header line mandatory (I see you have already implied this, but\n> you should make it explicit in the BIP), but instead of a line with columns\n> in it, I suggest instead of Reference,Label, you make the format like this:\n>\n> BIP-wallet-labels,<version>\n>\n> Since there are two columns per record, this works out nicely. The first\n> column can be the name of the BIP - BIPxxxx where the x's are numbers, and\n> the second column can be an unsigned 32-bit integer (most significant 8\n> bits reserved for version, the remaining for flags, or perhaps the entirety\n> for version - but I recommend leaving at least some bits for flags, even if\n> they all end up being just \"reserved\").\n>\n> You should make importing fail if the header line is not exactly as\n> specified - or appropriate, should you decide a different format for the\n> header.\n>\n> > Files exported should use the <tt>.csv</tt> file extension.\n> Don't mandate the file extension (read below for why):\n>\n> > In order to reduce file size while retaining wide accessibility, the CSV\n> > file may be compressed using the ZIP file format, using the <tt>.zip</tt>\n> > file extension.\n> I see three problems with this. The first is more important than the later\n> two because it makes them moot points, but I'll mention them anyway so you\n> get a background of the situation:\n> - The BIP is trying to specify in what file format the export format can\n> be written in onto the filesystem. There is no way to enforce this on a BIP\n> level (besides, Unix operating systems don't even consider the file\n> extension, they use its mimetype). Also specifying this in the BIP will\n> prevent modular \"Layer 2\" protocols and schemes from encoding the Export\n> labels into another format - for example Base64 or with their own\n> compression algorithm.\n>\n> Now for the two \"moot problems\":\n> - ZIP does not have good performance or compression ratio, there are\n> better algorithms out there like gzip (which also happens to be more\n> ubiquitous; nearly all websites are serving HTML compressed with gzip\n> compression).\n> - ZIP is an archiving format, that happens to have its own compression\n> format. Archiving format parsers can have serious vulnerabilities in their\n> implementation that can allow malware to swipe private keys and passwords,\n> since the primary target for this BIP is wallets. For example, there was\n> Zip Slip[1] in 2018, which allows for remote code execution. So the malware\n> can even hide in memory until private keys or passwords are written to\n> memory, then send them accros the network. Assuming it's targeting a\n> specific wallet software it's not hard to carry out at all.\n>\n> There's two solutions for all this:\n> 1. The duck-tape solution: Use some compression algorithm like gzip\n> instead of ZIP archive format.\n> 2. The \"throw it out and buy a new one\" solution: Get rid of the optional\n> compression specs altogether, because users are responsible for supplying\n> the export labels in the first place, so all the compression stuff is\n> redundant and should be left up to the user use if they desire to.\n>\n> I prefer the second solution because it hits the nail at the problem\n> directly instead of putting duck tape on it like the first one.\n>\n> > This <tt>.zip</tt> file may optionally be encrypted using either AES-128\n> or\n> > AES-256 encryption, which is supported by numerous applications including\n> > Winzip and 7-zip.\n> > The textual representation of the wallet's extended public key (as\n> defined\n> > by BIP32, with an <tt>xpub</tt> header) should be used as the password.\n> Not specific to AES, but I don't see the benefit of encrypting addresses\n> and labels together. Can you please elaborate why this would be desireable?\n>\n> Like I said though, it's better to leave it up to users to decide how to\n> store their exports, since BIPs can't enforce that anyway (additionally,\n> the password you propose is insecure - anybody with access to the wallet\n> can unlock it, which is not desireable to some users who want their own\n> security).\n>\n> > * Transaction ID (<tt>txid</tt>)\n> > * Address\n> > * Input (rendered as <tt>txid<index</tt>)\n> > * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)\n> Why the need for input and output formats? There is no difference between\n> them on the wallet level, because they are always identified with a txid\n> and output index. To distinguish between them and hence write them with the\n> correct format would require a UTXO set and thus access to a full node,\n> otherwise the CSV cannot be verified to be completely well-formed.\n>\n> Another important point is that practically nobody labels inputs or\n> outputs because most people do not know that those things even exist, and\n> the rest don't bother to label them.\n>\n> But the biggest downside to including them is related to the problem of\n> information leaking which you make reference to here:\n> > In both cases, care must be taken when spending to avoid undesirable\n> leaks\n> > of private information.\n> A CSV dump that has inputs/outputs and addresses mixed together can infer\n> the owner of all those items. In fact, A CVS label dump is basically a\n> personal information store so everything in it can be correlated as coming\n> from the same wallet, so it's important that unnecessary types are kept out\n> of the format. People are known to leave files lying around on their\n> computer that they don't need anymore, so these files can find their way\n> via telemetry to surveillence entities. While we can't specify what users\n> can do with their exports, we can control the information leak by\n> preventing certain types of items that we know most users will never use\n> from being exported in the first place.\n>\n> > The order in which these records appear is not defined.\n> Again, since the primary use case for this BIP is wallets, which likely\n> use heirarchical derivation schemes like BIP44, there is a net benefit for\n> the addresses to be exported in ascending order of their `address_type`. It\n> means that wallets can import them in O(n) time as opposed to O(n^2) time\n> spent serially checking in which index the address appears at. Of course,\n> this implies that all addresses up to a certain index have to be exported\n> into the CSV as well, but most wallets I know of like Core, Electrum\n> already store addresses like that.\n>\n> Also if you do this, you will need to group all the transaction records\n> before the address records or vice versa - you can use lexigraphical\n> sorting if you want (ie. Addresses before Transactions). The benefit of\n> this separation of parts is that wallets can split the imported address\n> records from the transaction records internally, and feed them to separate\n> functions which set these labels internally.\n>\n> If you decide on doing it this way, then you need a 3rd column to identify\n> the item type, and also you should quote the label (see below). I strongly\n> recommend using numbers for identification as opposed to character strings,\n> so you don't have to worry about localization or character case issues.\n> There is always one unique number, but there could be multiple strings that\n> reference the same type. This will complicate importing functions.\n>\n> If you insist on include Input and Output types then they can both be\n> specified as <txid>:<index> if you do this change. They won't be used to\n> determine the type anyway.\n>\n> > The fields may be quoted, but this is unnecessary, as the first comma in\n> > the line will always be the delimiter.\n> Don't implement it like that, because that will break CSV parsers which\n> expect a fixed amount of rows in each record (2 in the header, and some\n> rows have >2 rows). It's better to mandate that they should always be\n> double-quoted, since only wallets will generate label exports anyway. If\n> you plan to use headers then the 3rd column can be blank for it (or you can\n> split the version and flags from each other).\n>\n> > ==Importing==\n> >\n> > When importing, a naive algorithm may simply match against any reference,\n> > but it is possible to disambiguate between transactions, addresses,\n> inputs\n> > and outputs.\n> > For example in the following pseudocode:\n> > <pre>\n> >   if reference length < 64\n> >     Set address label\n> >   else if reference length == 64\n> >     Set transaction label\n> >   else if reference contains '<'\n> >     Set input label\n> >   else\n> >     Set output label\n> > </pre>\n> The importing code is too naive and in its current form will prevent the\n> BIP from getting a number. It is perhaps the single most important part of\n> a BIP. When implementing an importer, it should utilize a dedicate item\n> type field that unambiguously identifies the item. So the naive importer is\n> not good, you need use a 3rd column for that like I explained above, so\n> that the importer becomes robust.\n>\n> In summary (exclamation marks indicate severity - one means low, two means\n> medium, and three means high):\n>\n> 1. Convert the header into a version line with optional flags, otherwise\n> nobody can extend this format without compatibility issues (!)\n> 2. Get rid of the specs related to file compression (!!!)\n> 3. Add a 3rd column for item type (address, transaction etc.) preferably\n> as numeric constants and grouping items of one type after items of another\n> type, or if you insist on strings, then only recognize their Titlecase\n> ASCII versions <spreadsheet software like Excel always tries to titlecase\n> the words> (!!)\n> 4. Require double quotes around the label (or single quotes if you prefer,\n> as long as spreadsheet software doesn't choke on them) (!!)\n> 5. Require sorting the records according to the order they are stored in\n> the wallet implementation. (!)\n> 6. Consider getting rid of Input and Output item types. (!)\n> 7. And last and most importantly, please write a more robust importer\n> algorithm in the example given by the BIP, because code in BIPs are\n> frequently used as references for software. (!!!)\n>\n> I hope you will consider these points in future revisions of your BIP.\n>\n> - Ali\n>\n> [1] https://github.com/snyk/zip-slip-vulnerability\n>\n> On Wed, 24 Aug 2022 11:18:43 +0200, craigraw at gmail.com wrote:\n> > Hi all,\n> >\n> > I would like to propose a BIP that specifies a format for the export and\n> > import of labels from a wallet. While transferring access to funds across\n> > wallet applications has been made simple through standards such as BIP39,\n> > wallet labels remain siloed and difficult to extract despite their value,\n> > particularly in a privacy context.\n> >\n> > The proposed format is a simple two column CSV file, with the reference\n> to\n> > a transaction, address, input or output in the first column, and the\n> label\n> > in the second column. CSV was chosen for its wide accessibility,\n> especially\n> > to users without specific technical expertise. Similarly, the CSV file\n> may\n> > be compressed using the ZIP format, and optionally encrypted using AES.\n> >\n> > The full text of the BIP can be found at\n> > https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki\n> > and also copied below.\n> >\n> > Feedback is appreciated.\n> >\n> > Thanks,\n> > Craig Raw\n> >\n> > ---\n> >\n> > <pre>\n> >   BIP: wallet-labels\n> >   Layer: Applications\n> >   Title: Wallet Labels Export Format\n> >   Author: Craig Raw <craig at sparrowwallet.com>\n> >   Comments-Summary: No comments yet.\n> >   Comments-URI:\n> > https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels\n> >   Status: Draft\n> >   Type: Informational\n> >   Created: 2022-08-23\n> >   License: BSD-2-Clause\n> > </pre>\n> >\n> > ==Abstract==\n> >\n> > This document specifies a format for the export of labels that may be\n> > attached to the transactions, addresses, input and outputs in a wallet.\n> >\n> > ==Copyright==\n> >\n> > This BIP is licensed under the BSD 2-clause license.\n> >\n> > ==Motivation==\n> >\n> > The export and import of funds across different Bitcoin wallet\n> applications\n> > is well defined through standards such as BIP39, BIP32, BIP44 etc.\n> > These standards are well supported and allow users to move easily between\n> > different wallets.\n> > There is, however, no defined standard to transfer any labels the user\n> may\n> > have applied to the transactions, addresses, inputs or outputs in their\n> > wallet.\n> > The UTXO model that Bitcoin uses makes these labels particularly valuable\n> > as they may indicate the source of funds, whether received externally or\n> as\n> > a result of change from a prior transaction.\n> > In both cases, care must be taken when spending to avoid undesirable\n> leaks\n> > of private information.\n> > Labels provide valuable guidance in this regard, and have even become\n> > mandatory when spending in several Bitcoin wallets.\n> > Allowing users to export their labels in a standardized way ensures that\n> > they do not experience lock-in to a particular wallet application.\n> > In addition, by using common formats, this BIP seeks to make manual or\n> bulk\n> > management of labels accessible to users without specific technical\n> > expertise.\n> >\n> > ==Specification==\n> >\n> > In order to make the import and export of labels as widely accessible as\n> > possible, this BIP uses the comma separated values (CSV) format, which is\n> > widely supported by consumer, business, and scientific applications.\n> > Although the technical specification of CSV in RFC4180 is not always\n> > followed, the application of the format in this BIP is simple enough that\n> > compatibility should not present a problem.\n> > Moreover, the simplicity and forgiving nature of CSV (over for example\n> > JSON) lends itself well to bulk label editing using spreadsheet and text\n> > editing tools.\n> >\n> > A CSV export of labels from a wallet must be a UTF-8 encoded text file,\n> > containing one record per line, with records containing two fields\n> > delimited by a comma.\n> > The fields may be quoted, but this is unnecessary, as the first comma in\n> > the line will always be the delimiter.\n> > The first line in the file is a header, and should be ignored on import.\n> > Thereafter, each line represents a record that refers to a label applied\n> in\n> > the wallet.\n> > The order in which these records appear is not defined.\n> >\n> > The first field in the record contains a reference to the transaction,\n> > address, input or output in the wallet.\n> > This is specified as one of the following:\n> > * Transaction ID (<tt>txid</tt>)\n> > * Address\n> > * Input (rendered as <tt>txid<index</tt>)\n> > * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)\n> >\n> > The second field contains the label applied to the reference.\n> > Exporting applications may omit records with no labels or labels of zero\n> > length.\n> > Files exported should use the <tt>.csv</tt> file extension.\n> >\n> > In order to reduce file size while retaining wide accessibility, the CSV\n> > file may be compressed using the ZIP file format, using the <tt>.zip</tt>\n> > file extension.\n> > This <tt>.zip</tt> file may optionally be encrypted using either AES-128\n> or\n> > AES-256 encryption, which is supported by numerous applications including\n> > Winzip and 7-zip.\n> > In order to ensure that weak encryption does not proliferate, importers\n> > following this standard must refuse to import <tt>.zip</tt> files\n> encrypted\n> > with the weaker Zip 2.0 standard.\n> > The textual representation of the wallet's extended public key (as\n> defined\n> > by BIP32, with an <tt>xpub</tt> header) should be used as the password.\n> >\n> > ==Importing==\n> >\n> > When importing, a naive algorithm may simply match against any reference,\n> > but it is possible to disambiguate between transactions, addresses,\n> inputs\n> > and outputs.\n> > For example in the following pseudocode:\n> > <pre>\n> >   if reference length < 64\n> >     Set address label\n> >   else if reference length == 64\n> >     Set transaction label\n> >   else if reference contains '<'\n> >     Set input label\n> >   else\n> >     Set output label\n> > </pre>\n> >\n> > Importing applications may truncate labels if necessary.\n> >\n> > ==Test Vectors==\n> >\n> > The following fragment represents a wallet label export:\n> > <pre>\n> > Reference,Label\n> >\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction\n> > 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address\n> > c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input\n> >\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output\n> >\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output\n> > (alternative)\n> > </pre>\n> >\n> > ==Reference Implementation==\n> >\n> > TBD\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220829/cefd5c3b/attachment-0001.html>"
            },
            {
                "author": "Ali Sherief",
                "date": "2022-08-26T06:06:30",
                "message_text_only": "I think these problems can be mitigated if the CSV format is strictly defined, such as how I specified it in my previous message.\n\nIn particular, the parser has to recognize only one specific header line that has a version number somewhere, or abort - and I still insist on quoting the labels with double-quote and introducing a 3rd column with specific string or numeric types and then replacing all the special characters in the input/output with \":\".\n\nStrictly defining CSV version and consequentially, the fields, and then specifying on what kind of data the import is supposed to fail at will limit the complexity of importers to N different switch cases - where N is the number of circulating versions of the format (for now 1).\n\n- Ali\n\nOn Thu, Thu, 25 Aug 2022 13:48:36 +0000, rhavar at protonmail.com wrote:\n> > Not only is JSON limited to editing only through specific software or text editors, but (in the latter case) it is fragile enough that a single missing character can cause an entire file to fail parsing. CSV is more forgiving in this regard.\n>\n> I think quite simply: A forgiving format is not appropriate for a standard.\n>\n> It'd be hard to understate how much extra and pointless effort it creates for everyone, and every implementation ends up creating its own defacto standard for what it produces and accepts. Even doing something as simple as adding an extra column will not be possible in the future because it'll break comparability with previous parsers.\n>\n> I've literally worked on projects where the csv parser has evolved into scan-ahead to use heuristics to understand \"rules\" of a csv file, and then do line-by-line heuristics to override those rules in pathological cases. Makes a bit of sense when you're trying to achieve 30 years of backwards compatibility. Doesn't make sense for much else..\n>\n> If your application users really like csv, then introduce an application-specific import-from-csv and export-to-csv with your own rules.\n> -Ryan\n>\n> ------- Original Message -------\n> On Thursday, August 25th, 2022 at 1:59 AM, Craig Raw <craigraw at gmail.com> wrote:\n>\n> > Thanks for your thoughts Ryan.\n> >\n> > Without reference to the quality feedback on this proposal, I was aware when submitting it for review that it provides an excellent opportunity for bike shedding. As developers, we have all experienced frustration with data formats. One thing that I did not perhaps make clear enough is that this format is not solely intended for developers, but general users who are probably not well represented on this list.\n> >\n> > While doing research for this proposal I spoke to several professional users of Sparrow Wallet (who are not developers). They all expressed a desire for the format to integrate with their business processes, which are driven by business tools such as Excel. Labelling provides an important function in UTXO and address management in these scenarios, and needs to be accessible and manageable outside of wallet software.\n> >\n> > If this is to be achieved, it immediately rules out JSON as a data format. Not only is JSON limited to editing only through specific software or text editors, but (in the latter case) it is fragile enough that a single missing character can cause an entire file to fail parsing. CSV is more forgiving in this regard. With respect to your comments on escaping, my expectation would be that developers will be using a mature CSV library rather than handling character escaping themselves. I would rather propose a format that is generally usable, even if occasionally a label is escaped incorrectly.\n> >\n> > Finally, I'll note that CSV files are already common and uncontroversial in Bitcoin wallet software. Bitcoin Core, Electrum, Sparrow (and no doubt many others) already export addresses and/or transactions with their labels as CSV files. This proposal simply attempts to create a standard for importing and exporting all the labels in a wallet.\n> >\n> > Craig\n> >\n> > On Wed, Aug 24, 2022 at 9:01 PM <rhavar at protonmail.com> wrote:\n> >\n> >> I'd strongly suggest not using CSV. Especially for a standard. I've worked with it as an interchange format many a times, and it's always been a clusterfuck.\n> >>\n> >> Right off the bat, you have stuff like \"The fields may be quoted, but this is unnecessary as the first comma in the line will always be the delimiter\" which invariably leads to some implementations doing it, some implementations not doing it, and others that are intolerant of the other way.\n> >>\n> >> And you have also made the classic mistake of not strictly defining escape rules. So everyone will pick their own (e.g. some will \\, escape commas, others will not cause it's quoted and escape quotes, and others will assume no escaping is required since its the last column in a csv).\n> >>\n> >> Over time it morphs into its own mini-monster that introduces so much pain.\n> >>\n> >> On a similar note, allowing alternatives (like: txid>index vs txid:index) provides no benefit, but creates additional work for implementations (who quite likely only test formats they produce) and future incompatibilities.\n> >>\n> >> I know everyone loves to hate on it, but really (line-separated?) json is the way to go.\n> >>\n> >> { \"tx\": \"c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?\", \"label\": \"wow, such label\" }\n> >> { \"tx: \"c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\", \"txout\": 4, \"label\": \"omg this is so easy to parse\" }\n> >> { \"tx: \"c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\", \"txin\": 0, \"label\": \"wow this is going to be extensible as well\" }\n> >>\n> >> -Ryan\n> >>\n> >> ------- Original Message -------\n> >> On Wednesday, August 24th, 2022 at 2:18 AM, Craig Raw via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >>\n> >>> Hi all,\n> >>>\n> >>> I would like to propose a BIP that specifies a format for the export and import of labels from a wallet. While transferring access to funds across wallet applications has been made simple through standards such as BIP39, wallet labels remain siloed and difficult to extract despite their value, particularly in a privacy context.\n> >>>\n> >>> The proposed format is a simple two column CSV file, with the reference to a transaction, address, input or output in the first column, and the label in the second column. CSV was chosen for its wide accessibility, especially to users without specific technical expertise. Similarly, the CSV file may be compressed using the ZIP format, and optionally encrypted using AES.\n> >>>\n> >>> The full text of the BIP can be found at https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki and also copied below.\n> >>>\n> >>> Feedback is appreciated.\n> >>>\n> >>> Thanks,\n> >>> Craig Raw\n> >>>\n> >>> ---\n> >>>\n> >>> <pre>\n> >>> BIP: wallet-labels\n> >>> Layer: Applications\n> >>> Title: Wallet Labels Export Format\n> >>> Author: Craig Raw <craig at sparrowwallet.com>\n> >>> Comments-Summary: No comments yet.\n> >>> Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels\n> >>> Status: Draft\n> >>> Type: Informational\n> >>> Created: 2022-08-23\n> >>> License: BSD-2-Clause\n> >>> </pre>\n> >>>\n> >>> ==Abstract==\n> >>>\n> >>> This document specifies a format for the export of labels that may be attached to the transactions, addresses, input and outputs in a wallet.\n> >>>\n> >>> ==Copyright==\n> >>>\n> >>> This BIP is licensed under the BSD 2-clause license.\n> >>>\n> >>> ==Motivation==\n> >>>\n> >>> The export and import of funds across different Bitcoin wallet applications is well defined through standards such as BIP39, BIP32, BIP44 etc.\n> >>> These standards are well supported and allow users to move easily between different wallets.\n> >>> There is, however, no defined standard to transfer any labels the user may have applied to the transactions, addresses, inputs or outputs in their wallet.\n> >>> The UTXO model that Bitcoin uses makes these labels particularly valuable as they may indicate the source of funds, whether received externally or as a result of change from a prior transaction.\n> >>> In both cases, care must be taken when spending to avoid undesirable leaks of private information.\n> >>> Labels provide valuable guidance in this regard, and have even become mandatory when spending in several Bitcoin wallets.\n> >>> Allowing users to export their labels in a standardized way ensures that they do not experience lock-in to a particular wallet application.\n> >>> In addition, by using common formats, this BIP seeks to make manual or bulk management of labels accessible to users without specific technical expertise.\n> >>>\n> >>> ==Specification==\n> >>>\n> >>> In order to make the import and export of labels as widely accessible as possible, this BIP uses the comma separated values (CSV) format, which is widely supported by consumer, business, and scientific applications.\n> >>> Although the technical specification of CSV in RFC4180 is not always followed, the application of the format in this BIP is simple enough that compatibility should not present a problem.\n> >>> Moreover, the simplicity and forgiving nature of CSV (over for example JSON) lends itself well to bulk label editing using spreadsheet and text editing tools.\n> >>>\n> >>> A CSV export of labels from a wallet must be a UTF-8 encoded text file, containing one record per line, with records containing two fields delimited by a comma.\n> >>> The fields may be quoted, but this is unnecessary, as the first comma in the line will always be the delimiter.\n> >>> The first line in the file is a header, and should be ignored on import.\n> >>> Thereafter, each line represents a record that refers to a label applied in the wallet.\n> >>> The order in which these records appear is not defined.\n> >>>\n> >>> The first field in the record contains a reference to the transaction, address, input or output in the wallet.\n> >>> This is specified as one of the following:\n> >>> * Transaction ID (<tt>txid</tt>)\n> >>> * Address\n> >>> * Input (rendered as <tt>txid<index</tt>)\n> >>> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)\n> >>>\n> >>> The second field contains the label applied to the reference.\n> >>> Exporting applications may omit records with no labels or labels of zero length.\n> >>> Files exported should use the <tt>.csv</tt> file extension.\n> >>>\n> >>> In order to reduce file size while retaining wide accessibility, the CSV file may be compressed using the ZIP file format, using the <tt>.zip</tt> file extension.\n> >>> This <tt>.zip</tt> file may optionally be encrypted using either AES-128 or AES-256 encryption, which is supported by numerous applications including Winzip and 7-zip.\n> >>> In order to ensure that weak encryption does not proliferate, importers following this standard must refuse to import <tt>.zip</tt> files encrypted with the weaker Zip 2.0 standard.\n> >>> The textual representation of the wallet's extended public key (as defined by BIP32, with an <tt>xpub</tt> header) should be used as the password.\n> >>>\n> >>> ==Importing==\n> >>>\n> >>> When importing, a naive algorithm may simply match against any reference, but it is possible to disambiguate between transactions, addresses, inputs and outputs.\n> >>> For example in the following pseudocode:\n> >>> <pre>\n> >>> if reference length < 64\n> >>> Set address label\n> >>> else if reference length == 64\n> >>> Set transaction label\n> >>> else if reference contains '<'\n> >>> Set input label\n> >>> else\n> >>> Set output label\n> >>> </pre>\n> >>>\n> >>> Importing applications may truncate labels if necessary.\n> >>>\n> >>> ==Test Vectors==\n> >>>\n> >>> The following fragment represents a wallet label export:\n> >>> <pre>\n> >>> Reference,Label\n> >>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction\n> >>> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address\n> >>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input\n> >>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output\n> >>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output (alternative)\n> >>> </pre>\n> >>>\n> >>> ==Reference Implementation==\n> >>>\n> >>> TBD"
            },
            {
                "author": "Ali Sherief",
                "date": "2022-08-27T21:26:58",
                "message_text_only": "> This seems to run contrary with your point about letting users be in\n> control of how they store this. Given that you can always connect together\n> an output and its address or find the outputs at any address, it doesn't\n> seem like it would actually leak any more information than just including\n> addresses. Am I missing something?\n\nThat's actually true, and coming back to it now it feels more like a security-through-obscurity suggestion. It's still valid that the export files will be valuable telemetry, but now I'm starting to feel more concerned about how inputs and outputs would be represented in the first place.\n\nSome folks have suggested writing them as descriptors for that purpose[1]. But I see problems with that approach; there are only descriptors for things like addresses, outputs, derivation paths and so on. I know of no descriptors for transaction IDs or inputs.\n\nI am actually starting to contemplate whether it's wise to merge Inputs and Outputs to one classification conveniently called just \"Outputs\", because it's impossible to distinguish between them by looking at them (any input is also an output, but not vice versa). Wise, because I do not know of any wallet software that labels outputs.\n\n- Ali\n\n[1]: https://bitcointalk.org/index.php?topic=5411159.0\n\nOn Sat, Sat, 27 Aug 2022 16:03:01 -0500, billy.tetrud at gmail.com wrote:\n> @Ali Thats some good well thought through and well articulated feedback. I\n> have one point of contention\n>\n> > it's important that unnecessary types are kept out of the format. People\n> are known to leave files lying around on their computer that they don't\n> need anymore, so these files can find their way via telemetry to\n> surveillence entities. While we can't specify what users can do with their\n> exports, we can control the information leak by preventing certain types of\n> items that we know most users will never use from being exported in the\n> first place.\n>\n> This seems to run contrary with your point about letting users be in\n> control of how they store this. Given that you can always connect together\n> an output and its address or find the outputs at any address, it doesn't\n> seem like it would actually leak any more information than just including\n> addresses. Am I missing something?\n>\n> On Wed, Aug 24, 2022, 14:44 Ali Sherief via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > Hi Craig,\n> >\n> > This a really good proposal. I studied your BIP and I have some feedback\n> > on some parts of it.\n> >\n> > > The first line in the file is a header, and should be ignored on import.\n> >\n> > From past experience and lessons, most notably BIP39, it is important that\n> > a version byte is defined somewhere in case someone wants to extend it in\n> > the future, currently there is no version byte which someone can increment\n> > if somebody wants to extend it. In the unique case of CSV files, you should\n> > make the header line mandatory (I see you have already implied this, but\n> > you should make it explicit in the BIP), but instead of a line with columns\n> > in it, I suggest instead of Reference,Label, you make the format like this:\n> >\n> > BIP-wallet-labels,<version>\n> >\n> > Since there are two columns per record, this works out nicely. The first\n> > column can be the name of the BIP - BIPxxxx where the x's are numbers, and\n> > the second column can be an unsigned 32-bit integer (most significant 8\n> > bits reserved for version, the remaining for flags, or perhaps the entirety\n> > for version - but I recommend leaving at least some bits for flags, even if\n> > they all end up being just \"reserved\").\n> >\n> > You should make importing fail if the header line is not exactly as\n> > specified - or appropriate, should you decide a different format for the\n> > header.\n> >\n> > > Files exported should use the <tt>.csv</tt> file extension.\n> > Don't mandate the file extension (read below for why):\n> >\n> > > In order to reduce file size while retaining wide accessibility, the CSV\n> > > file may be compressed using the ZIP file format, using the <tt>.zip</tt>\n> > > file extension.\n> > I see three problems with this. The first is more important than the later\n> > two because it makes them moot points, but I'll mention them anyway so you\n> > get a background of the situation:\n> > - The BIP is trying to specify in what file format the export format can\n> > be written in onto the filesystem. There is no way to enforce this on a BIP\n> > level (besides, Unix operating systems don't even consider the file\n> > extension, they use its mimetype). Also specifying this in the BIP will\n> > prevent modular \"Layer 2\" protocols and schemes from encoding the Export\n> > labels into another format - for example Base64 or with their own\n> > compression algorithm.\n> >\n> > Now for the two \"moot problems\":\n> > - ZIP does not have good performance or compression ratio, there are\n> > better algorithms out there like gzip (which also happens to be more\n> > ubiquitous; nearly all websites are serving HTML compressed with gzip\n> > compression).\n> > - ZIP is an archiving format, that happens to have its own compression\n> > format. Archiving format parsers can have serious vulnerabilities in their\n> > implementation that can allow malware to swipe private keys and passwords,\n> > since the primary target for this BIP is wallets. For example, there was\n> > Zip Slip[1] in 2018, which allows for remote code execution. So the malware\n> > can even hide in memory until private keys or passwords are written to\n> > memory, then send them accros the network. Assuming it's targeting a\n> > specific wallet software it's not hard to carry out at all.\n> >\n> > There's two solutions for all this:\n> > 1. The duck-tape solution: Use some compression algorithm like gzip\n> > instead of ZIP archive format.\n> > 2. The \"throw it out and buy a new one\" solution: Get rid of the optional\n> > compression specs altogether, because users are responsible for supplying\n> > the export labels in the first place, so all the compression stuff is\n> > redundant and should be left up to the user use if they desire to.\n> >\n> > I prefer the second solution because it hits the nail at the problem\n> > directly instead of putting duck tape on it like the first one.\n> >\n> > > This <tt>.zip</tt> file may optionally be encrypted using either AES-128\n> > or\n> > > AES-256 encryption, which is supported by numerous applications including\n> > > Winzip and 7-zip.\n> > > The textual representation of the wallet's extended public key (as\n> > defined\n> > > by BIP32, with an <tt>xpub</tt> header) should be used as the password.\n> > Not specific to AES, but I don't see the benefit of encrypting addresses\n> > and labels together. Can you please elaborate why this would be desireable?\n> >\n> > Like I said though, it's better to leave it up to users to decide how to\n> > store their exports, since BIPs can't enforce that anyway (additionally,\n> > the password you propose is insecure - anybody with access to the wallet\n> > can unlock it, which is not desireable to some users who want their own\n> > security).\n> >\n> > > * Transaction ID (<tt>txid</tt>)\n> > > * Address\n> > > * Input (rendered as <tt>txid<index</tt>)\n> > > * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)\n> > Why the need for input and output formats? There is no difference between\n> > them on the wallet level, because they are always identified with a txid\n> > and output index. To distinguish between them and hence write them with the\n> > correct format would require a UTXO set and thus access to a full node,\n> > otherwise the CSV cannot be verified to be completely well-formed.\n> >\n> > Another important point is that practically nobody labels inputs or\n> > outputs because most people do not know that those things even exist, and\n> > the rest don't bother to label them.\n> >\n> > But the biggest downside to including them is related to the problem of\n> > information leaking which you make reference to here:\n> > > In both cases, care must be taken when spending to avoid undesirable\n> > leaks\n> > > of private information.\n> > A CSV dump that has inputs/outputs and addresses mixed together can infer\n> > the owner of all those items. In fact, A CVS label dump is basically a\n> > personal information store so everything in it can be correlated as coming\n> > from the same wallet, so it's important that unnecessary types are kept out\n> > of the format. People are known to leave files lying around on their\n> > computer that they don't need anymore, so these files can find their way\n> > via telemetry to surveillence entities. While we can't specify what users\n> > can do with their exports, we can control the information leak by\n> > preventing certain types of items that we know most users will never use\n> > from being exported in the first place.\n> >\n> > > The order in which these records appear is not defined.\n> > Again, since the primary use case for this BIP is wallets, which likely\n> > use heirarchical derivation schemes like BIP44, there is a net benefit for\n> > the addresses to be exported in ascending order of their `address_type`. It\n> > means that wallets can import them in O(n) time as opposed to O(n^2) time\n> > spent serially checking in which index the address appears at. Of course,\n> > this implies that all addresses up to a certain index have to be exported\n> > into the CSV as well, but most wallets I know of like Core, Electrum\n> > already store addresses like that.\n> >\n> > Also if you do this, you will need to group all the transaction records\n> > before the address records or vice versa - you can use lexigraphical\n> > sorting if you want (ie. Addresses before Transactions). The benefit of\n> > this separation of parts is that wallets can split the imported address\n> > records from the transaction records internally, and feed them to separate\n> > functions which set these labels internally.\n> >\n> > If you decide on doing it this way, then you need a 3rd column to identify\n> > the item type, and also you should quote the label (see below). I strongly\n> > recommend using numbers for identification as opposed to character strings,\n> > so you don't have to worry about localization or character case issues.\n> > There is always one unique number, but there could be multiple strings that\n> > reference the same type. This will complicate importing functions.\n> >\n> > If you insist on include Input and Output types then they can both be\n> > specified as <txid>:<index> if you do this change. They won't be used to\n> > determine the type anyway.\n> >\n> > > The fields may be quoted, but this is unnecessary, as the first comma in\n> > > the line will always be the delimiter.\n> > Don't implement it like that, because that will break CSV parsers which\n> > expect a fixed amount of rows in each record (2 in the header, and some\n> > rows have >2 rows). It's better to mandate that they should always be\n> > double-quoted, since only wallets will generate label exports anyway. If\n> > you plan to use headers then the 3rd column can be blank for it (or you can\n> > split the version and flags from each other).\n> >\n> > > ==Importing==\n> > >\n> > > When importing, a naive algorithm may simply match against any reference,\n> > > but it is possible to disambiguate between transactions, addresses,\n> > inputs\n> > > and outputs.\n> > > For example in the following pseudocode:\n> > > <pre>\n> > >   if reference length < 64\n> > >     Set address label\n> > >   else if reference length == 64\n> > >     Set transaction label\n> > >   else if reference contains '<'\n> > >     Set input label\n> > >   else\n> > >     Set output label\n> > > </pre>\n> > The importing code is too naive and in its current form will prevent the\n> > BIP from getting a number. It is perhaps the single most important part of\n> > a BIP. When implementing an importer, it should utilize a dedicate item\n> > type field that unambiguously identifies the item. So the naive importer is\n> > not good, you need use a 3rd column for that like I explained above, so\n> > that the importer becomes robust.\n> >\n> > In summary (exclamation marks indicate severity - one means low, two means\n> > medium, and three means high):\n> >\n> > 1. Convert the header into a version line with optional flags, otherwise\n> > nobody can extend this format without compatibility issues (!)\n> > 2. Get rid of the specs related to file compression (!!!)\n> > 3. Add a 3rd column for item type (address, transaction etc.) preferably\n> > as numeric constants and grouping items of one type after items of another\n> > type, or if you insist on strings, then only recognize their Titlecase\n> > ASCII versions <spreadsheet software like Excel always tries to titlecase\n> > the words> (!!)\n> > 4. Require double quotes around the label (or single quotes if you prefer,\n> > as long as spreadsheet software doesn't choke on them) (!!)\n> > 5. Require sorting the records according to the order they are stored in\n> > the wallet implementation. (!)\n> > 6. Consider getting rid of Input and Output item types. (!)\n> > 7. And last and most importantly, please write a more robust importer\n> > algorithm in the example given by the BIP, because code in BIPs are\n> > frequently used as references for software. (!!!)\n> >\n> > I hope you will consider these points in future revisions of your BIP.\n> >\n> > - Ali\n> >\n> > [1] https://github.com/snyk/zip-slip-vulnerability\n> >\n> > On Wed, 24 Aug 2022 11:18:43 +0200, craigraw at gmail.com wrote:\n> > > Hi all,\n> > >\n> > > I would like to propose a BIP that specifies a format for the export and\n> > > import of labels from a wallet. While transferring access to funds across\n> > > wallet applications has been made simple through standards such as BIP39,\n> > > wallet labels remain siloed and difficult to extract despite their value,\n> > > particularly in a privacy context.\n> > >\n> > > The proposed format is a simple two column CSV file, with the reference\n> > to\n> > > a transaction, address, input or output in the first column, and the\n> > label\n> > > in the second column. CSV was chosen for its wide accessibility,\n> > especially\n> > > to users without specific technical expertise. Similarly, the CSV file\n> > may\n> > > be compressed using the ZIP format, and optionally encrypted using AES.\n> > >\n> > > The full text of the BIP can be found at\n> > > https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki\n> > > and also copied below.\n> > >\n> > > Feedback is appreciated.\n> > >\n> > > Thanks,\n> > > Craig Raw\n> > >\n> > > ---\n> > >\n> > > <pre>\n> > >   BIP: wallet-labels\n> > >   Layer: Applications\n> > >   Title: Wallet Labels Export Format\n> > >   Author: Craig Raw <craig at sparrowwallet.com>\n> > >   Comments-Summary: No comments yet.\n> > >   Comments-URI:\n> > > https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels\n> > >   Status: Draft\n> > >   Type: Informational\n> > >   Created: 2022-08-23\n> > >   License: BSD-2-Clause\n> > > </pre>\n> > >\n> > > ==Abstract==\n> > >\n> > > This document specifies a format for the export of labels that may be\n> > > attached to the transactions, addresses, input and outputs in a wallet.\n> > >\n> > > ==Copyright==\n> > >\n> > > This BIP is licensed under the BSD 2-clause license.\n> > >\n> > > ==Motivation==\n> > >\n> > > The export and import of funds across different Bitcoin wallet\n> > applications\n> > > is well defined through standards such as BIP39, BIP32, BIP44 etc.\n> > > These standards are well supported and allow users to move easily between\n> > > different wallets.\n> > > There is, however, no defined standard to transfer any labels the user\n> > may\n> > > have applied to the transactions, addresses, inputs or outputs in their\n> > > wallet.\n> > > The UTXO model that Bitcoin uses makes these labels particularly valuable\n> > > as they may indicate the source of funds, whether received externally or\n> > as\n> > > a result of change from a prior transaction.\n> > > In both cases, care must be taken when spending to avoid undesirable\n> > leaks\n> > > of private information.\n> > > Labels provide valuable guidance in this regard, and have even become\n> > > mandatory when spending in several Bitcoin wallets.\n> > > Allowing users to export their labels in a standardized way ensures that\n> > > they do not experience lock-in to a particular wallet application.\n> > > In addition, by using common formats, this BIP seeks to make manual or\n> > bulk\n> > > management of labels accessible to users without specific technical\n> > > expertise.\n> > >\n> > > ==Specification==\n> > >\n> > > In order to make the import and export of labels as widely accessible as\n> > > possible, this BIP uses the comma separated values (CSV) format, which is\n> > > widely supported by consumer, business, and scientific applications.\n> > > Although the technical specification of CSV in RFC4180 is not always\n> > > followed, the application of the format in this BIP is simple enough that\n> > > compatibility should not present a problem.\n> > > Moreover, the simplicity and forgiving nature of CSV (over for example\n> > > JSON) lends itself well to bulk label editing using spreadsheet and text\n> > > editing tools.\n> > >\n> > > A CSV export of labels from a wallet must be a UTF-8 encoded text file,\n> > > containing one record per line, with records containing two fields\n> > > delimited by a comma.\n> > > The fields may be quoted, but this is unnecessary, as the first comma in\n> > > the line will always be the delimiter.\n> > > The first line in the file is a header, and should be ignored on import.\n> > > Thereafter, each line represents a record that refers to a label applied\n> > in\n> > > the wallet.\n> > > The order in which these records appear is not defined.\n> > >\n> > > The first field in the record contains a reference to the transaction,\n> > > address, input or output in the wallet.\n> > > This is specified as one of the following:\n> > > * Transaction ID (<tt>txid</tt>)\n> > > * Address\n> > > * Input (rendered as <tt>txid<index</tt>)\n> > > * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)\n> > >\n> > > The second field contains the label applied to the reference.\n> > > Exporting applications may omit records with no labels or labels of zero\n> > > length.\n> > > Files exported should use the <tt>.csv</tt> file extension.\n> > >\n> > > In order to reduce file size while retaining wide accessibility, the CSV\n> > > file may be compressed using the ZIP file format, using the <tt>.zip</tt>\n> > > file extension.\n> > > This <tt>.zip</tt> file may optionally be encrypted using either AES-128\n> > or\n> > > AES-256 encryption, which is supported by numerous applications including\n> > > Winzip and 7-zip.\n> > > In order to ensure that weak encryption does not proliferate, importers\n> > > following this standard must refuse to import <tt>.zip</tt> files\n> > encrypted\n> > > with the weaker Zip 2.0 standard.\n> > > The textual representation of the wallet's extended public key (as\n> > defined\n> > > by BIP32, with an <tt>xpub</tt> header) should be used as the password.\n> > >\n> > > ==Importing==\n> > >\n> > > When importing, a naive algorithm may simply match against any reference,\n> > > but it is possible to disambiguate between transactions, addresses,\n> > inputs\n> > > and outputs.\n> > > For example in the following pseudocode:\n> > > <pre>\n> > >   if reference length < 64\n> > >     Set address label\n> > >   else if reference length == 64\n> > >     Set transaction label\n> > >   else if reference contains '<'\n> > >     Set input label\n> > >   else\n> > >     Set output label\n> > > </pre>\n> > >\n> > > Importing applications may truncate labels if necessary.\n> > >\n> > > ==Test Vectors==\n> > >\n> > > The following fragment represents a wallet label export:\n> > > <pre>\n> > > Reference,Label\n> > >\n> > c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction\n> > > 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address\n> > > c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input\n> > >\n> > c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output\n> > >\n> > c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output\n> > > (alternative)\n> > > </pre>\n> > >\n> > > ==Reference Implementation==\n> > >\n> > > TBD"
            },
            {
                "author": "Ali Sherief",
                "date": "2022-08-29T15:46:09",
                "message_text_only": "> I am attempting to achieve two goals with this proposal, primarily for the\n> benefit of wallet users:\n>\n> Goal #1. Transfer labels between different wallet implementations\n> Goal #2. Manage labels in applications outside of Bitcoin wallets (such as\n> Excel)\n>\n> Much of the feedback so far has indicated the tension between these two\n> goals - it may be that it is too difficult to achieve both, in which case\n> Goal #1 is the most important. That said, I think further exploration is\n> still necessary before abandoning Goal #2, because removing it would\n> significantly reduce the value of this proposal and mean users need to rely\n> on application-specific workarounds.\nIn my opinion, it would be best if these two goals were split into two separate BIPs where the BIP for Goal 2 requires Goal 1's BIP, gut Goal 1's BIP is independent. This is because wallet software and business spreadsheet processes have different and in some cases divergent needs.\n\nA BIP shouldn't try to address too many things at once, that's why technologies like Segwit and Taproot were split into four or five BIPs each.\n\n>  > Don't mandate the file extension... There is no way to enforce this on a\n> BIP level.\n> I'm not quite sure what you mean here - for example BIP174, which is widely\n> used, states \"Binary PSBT files should use the .psbt file extension.\" Also,\n> this contradicts Goal #2 - Excel and Numbers register as handlers for .csv,\n> and so make it clear that the file is editable outside of a wallet.\nBIP174's assignment is a specification but not a hard requirement, becase if you have a file whose extension implies one type, but its MIME type (obtained from inspecting the file contents) indicates another type, then the extension should be disregarded by the parser.\n\nI am aware that business processes are mostly CSV file oriented so you can make a statement akin to BIP174 in the Goal 2 BIP, that expects the medium of exchange to be in files ending in .csv. I wouldn't mind if you require .csv file extension in a BIP for Goal 2. But such a statement is not appropriate in the Goal 1 BIP which is only concerned with the wallet label format itself.\n\n> > ZIP does not have good performance or compression ratio\n> Indeed, but it is very widely available. That said, gzip is supported\n> widely too these days. Unfortunately, gzip does not offer encryption (see\n> next answer).\n>\n> > ZIP is an archiving format, that happens to have its own compression\n> format.\n> I agree this is not ideal. My main reason for choosing ZIP was that it\n> supports encryption. It seems to me that without considering encryption, an\n> application must create label export files that allow privacy-sensitive\n> wallet information to be readable in plain text. Being able to transfer\n> labels without risking privacy is IMO valuable. I considered other\n> encryption formats such as PGP, but they are much more niche and so again\n> contradict Goal #2.\nBoth of these look like parts of the spec that should be in the Goal 2 BIP. Because Goal 1, which is only concerned with wallet label importing, does not need to interact with compression or encryption.\n\nI don't mind if you make Goal 2 BIP utilize ZIP compression with optional encryption, it's just that specifying this in the same place in the Goal 1 BIP stuff forces wallets to check for that stuff too to be compliant. It's important to make compliance as easy as possible.\n\nRegardless, I still believe that making the xpub the ZIP password is a bad design, because some wallets that are made from a random list of private keys do not have xpubs at all. If the purpose of a password is to make label sharing between two parties secure, then why not simply let them agree on a password for their own use?\n\n> > I don't see the benefit of encrypting addresses and labels together...\n> additionally, the password you propose is insecure - anybody with access to\n> the wallet can unlock it\n> I'm not sure I understand your question, but both wallet addresses and\n> wallet labels contain privacy-sensitive information that should be\n> protected. Wrt to the password, there is actually a more fundamental\n> problem with using the wallet xpub - there is no equivalent for multisig\n> wallets. For this reason I'll remove that requirement in future iterations.\nLet me explain.\n\nBefore you partitioned the BIP into two goals, I was under the impression that wallets would have to read an encrypted export file, which seemed very overkill to me (for one, all wallets would now need to bundle a ZIP or AES dependency module with their program).\n\nBut now I see why a password and encryption would be desireable for Goal 2 BIP applications. Like I said though, Goal 1 BIP applications (i.e. wallets) do not need any of that.\n\n> > Why the need for input and output formats? There is no difference between\n> them on the wallet level, because they are always identified with a txid\n> and output index.\n> The input refers to the txid and the input index (in the set of vin), so\n> the difference is the context in which they are displayed. A wallet will\n> not necessarily store the spent outputs for a funding transaction\n> containing a UTXO coming into the wallet, but it will contain references to\n> the inputs as part of that transaction.\n>\n> > Another important point is that practically nobody labels inputs or\n> outputs\n> To the contrary, UTXOs are very frequently labelled, as they link and\n> reveal information when spent. Inputs are much less frequently labelled,\n> but there is no particular reason to exclude them.\n>\n> > there is a net benefit for the addresses to be exported in ascending order\n> Indeed, but it makes achieving Goal #2 much more difficult for marginal\n> benefit.\nFair enough.\n\n> > It's better to mandate that they should always be double-quoted, since\n> only wallets will generate label exports anyway.\n> Rather I think it's better to mandate RFC4180 is followed, as per\n> recommendations in other feedback.\nI agree with this.\n\n> > The importing code is too naive... it should utilize a dedicate item type\n> field that unambiguously identifies the item\n> It's unclear to me what you mean here. As I've indicated it is currently\n> possible to disambiguate between addresses/transactions/etc without the\n> need for a 3rd column, but in any case the hash functions used ensure that\n> labels will not be associated incorrectly. Even in the unlikely event of\n> some future address type being indistinguishable from a txid, it will\n> simply not match any txids in the wallet.\nYou already have a custom format proposed here, but this importer relies on heuristics of the data like how long it is, what characters it has, and so on. It is better for the importer to have the same kind of conditions.\n\nYou can make parsing vastly simpler by prefixing the items with some text. Similar to how we have \"bitcoin:\" for indicating a bitcoin address, you can have \"address:\", \"transaction:\", \"input:\", and \"output:\" at the beginning of each entity.\n\nThis has a major advantage: You can add new formats in a backward-compatible way without breaking parsers, since the parsers never depended on the text heuristics in the first place, therefore you don't have to clutter the BIP(s) with even more test vectors for these cases. You won't even need a version byte, since the only revision that will ever be made (that doesn't modify any existing format to preserve backward-compatibility) are adding new formats.\n\nTake a look at your sample:\n\n> > >   if reference length < 64\n> > >     Set address label\n> > >   else if reference length == 64\n> > >     Set transaction label\n> > >   else if reference contains '<'\n> > >     Set input label\n> > >   else\n> > >     Set output label\n\nversus how mine would look:\n\n> if reference.startsWith(\"address:\")\n>   Set address label\n> else if reference.startsWith(\"transaction:\")\n>   Set transaction label\n> else if reference.startsWith(\"input:\")\n>   Set input label\n> else if reference.startsWith(\"output:\")\n>   Set output label\n> # No else case: allows for future extensions\n\nSee how simpler it is to understand?\n\nThe truth is, a format has to be defined that developers find it easy to implement. If the implementation is such that a developer could misunderstand at a first glance, they will implement it wrongly, creating bugs.\n\nLooking at your sample, a developer would think as such: \"anything less than 64 chars is an address, anything 64 chars long is a transaction, anything that contains a '<' is an input (and is also greater than 64 chars), and everything else is an output (>64 chars and has no  '<').\"\n\nIn light of all this, is it not much easier to simply introduce a prefix at the beginning of each entity? It has a negligible space cost. The \"else\" case can be ommitted hypothetically (although that's not strictly necessary), so developers can just add more \"else if\"'s when a BIP revision is made.\n\nA good way to see if a reference implementation has a good design is by asking yourself the following question: Imagine you are committing your reference into Bitcoin Core. Based on the code quality, would a pull request for that be merged, or not?\n\n\nSo to summarize, I strongly suggest you do the following:\n- Split the BIP into two, one defines the CSV format for label import/export between wallets, and the other defines workflows for distributing and sharing label CSVs in a universal and safe way.\n- Add prefixes before each entity, so in other words: \"adddress:bc1q23456...\", \"transaction:432abd874d...\", \"input:432abd874d...<DELIMITER>1\", \"output:432abd874d...<DELIMITER>1\". Replace <DELIMITER> with any delimiter you want, it doesn't have to be consistent. This will make it much simpler to implement an importer, without applications doing any of the hacks that RHavar wrote about (IMO this is what people mean when they say that implementing a CSV importer will be complex work).\n\n- Ali\n\nOn Mon, Aug 29, 2022 at 11:26:32AM +0000, craigraw at gmail.com wrote:\n> Thanks for your feedback @Ali.\n>\n>\n> > it is important that a version byte is defined\n> If Goal #2 is to be achieved it's difficult to mandate this, particularly\n> if one requires bit flags to be set. Should an importing wallet fail to\n> import if the version byte is not present, even if all the data is\n> otherwise correct? Although it is difficult to know in advance how a format\n> may be extended, it is certainly possible to extend this format with\n> additional types where the nature of hashes serve as unique identifiers\n> (more on this below).\n>\n>  > Don't mandate the file extension... There is no way to enforce this on a\n> BIP level.\n> I'm not quite sure what you mean here - for example BIP174, which is widely\n> used, states \"Binary PSBT files should use the .psbt file extension.\" Also,\n> this contradicts Goal #2 - Excel and Numbers register as handlers for .csv,\n> and so make it clear that the file is editable outside of a wallet.\n>\n> > ZIP does not have good performance or compression ratio\n> Indeed, but it is very widely available. That said, gzip is supported\n> widely too these days. Unfortunately, gzip does not offer encryption (see\n> next answer).\n>\n> > ZIP is an archiving format, that happens to have its own compression\n> format.\n> I agree this is not ideal. My main reason for choosing ZIP was that it\n> supports encryption. It seems to me that without considering encryption, an\n> application must create label export files that allow privacy-sensitive\n> wallet information to be readable in plain text. Being able to transfer\n> labels without risking privacy is IMO valuable. I considered other\n> encryption formats such as PGP, but they are much more niche and so again\n> contradict Goal #2.\n>\n> > I don't see the benefit of encrypting addresses and labels together...\n> additionally, the password you propose is insecure - anybody with access to\n> the wallet can unlock it\n> I'm not sure I understand your question, but both wallet addresses and\n> wallet labels contain privacy-sensitive information that should be\n> protected. Wrt to the password, there is actually a more fundamental\n> problem with using the wallet xpub - there is no equivalent for multisig\n> wallets. For this reason I'll remove that requirement in future iterations.\n>\n> > Why the need for input and output formats? There is no difference between\n> them on the wallet level, because they are always identified with a txid\n> and output index.\n> The input refers to the txid and the input index (in the set of vin), so\n> the difference is the context in which they are displayed. A wallet will\n> not necessarily store the spent outputs for a funding transaction\n> containing a UTXO coming into the wallet, but it will contain references to\n> the inputs as part of that transaction.\n>\n> > Another important point is that practically nobody labels inputs or\n> outputs\n> To the contrary, UTXOs are very frequently labelled, as they link and\n> reveal information when spent. Inputs are much less frequently labelled,\n> but there is no particular reason to exclude them.\n>\n> > there is a net benefit for the addresses to be exported in ascending order\n> Indeed, but it makes achieving Goal #2 much more difficult for marginal\n> benefit.\n>\n> > It's better to mandate that they should always be double-quoted, since\n> only wallets will generate label exports anyway.\n> Rather I think it's better to mandate RFC4180 is followed, as per\n> recommendations in other feedback.\n>\n> > The importing code is too naive... it should utilize a dedicate item type\n> field that unambiguously identifies the item\n> It's unclear to me what you mean here. As I've indicated it is currently\n> possible to disambiguate between addresses/transactions/etc without the\n> need for a 3rd column, but in any case the hash functions used ensure that\n> labels will not be associated incorrectly. Even in the unlikely event of\n> some future address type being indistinguishable from a txid, it will\n> simply not match any txids in the wallet.\n>\n> Craig\n>\n>\n>\n> On Wed, Aug 24, 2022 at 9:10 PM Ali Sherief <ali at notatether.com> wrote:\n>\n> > Hi Craig,\n> >\n> > This a really good proposal. I studied your BIP and I have some feedback\n> > on some parts of it.\n> >\n> > > The first line in the file is a header, and should be ignored on import.\n> >\n> > From past experience and lessons, most notably BIP39, it is important that\n> > a version byte is defined somewhere in case someone wants to extend it in\n> > the future, currently there is no version byte which someone can increment\n> > if somebody wants to extend it. In the unique case of CSV files, you should\n> > make the header line mandatory (I see you have already implied this, but\n> > you should make it explicit in the BIP), but instead of a line with columns\n> > in it, I suggest instead of Reference,Label, you make the format like this:\n> >\n> > BIP-wallet-labels,<version>\n> >\n> > Since there are two columns per record, this works out nicely. The first\n> > column can be the name of the BIP - BIPxxxx where the x's are numbers, and\n> > the second column can be an unsigned 32-bit integer (most significant 8\n> > bits reserved for version, the remaining for flags, or perhaps the entirety\n> > for version - but I recommend leaving at least some bits for flags, even if\n> > they all end up being just \"reserved\").\n> >\n> > You should make importing fail if the header line is not exactly as\n> > specified - or appropriate, should you decide a different format for the\n> > header.\n> >\n> > > Files exported should use the <tt>.csv</tt> file extension.\n> > Don't mandate the file extension (read below for why):\n> >\n> > > In order to reduce file size while retaining wide accessibility, the CSV\n> > > file may be compressed using the ZIP file format, using the <tt>.zip</tt>\n> > > file extension.\n> > I see three problems with this. The first is more important than the later\n> > two because it makes them moot points, but I'll mention them anyway so you\n> > get a background of the situation:\n> > - The BIP is trying to specify in what file format the export format can\n> > be written in onto the filesystem. There is no way to enforce this on a BIP\n> > level (besides, Unix operating systems don't even consider the file\n> > extension, they use its mimetype). Also specifying this in the BIP will\n> > prevent modular \"Layer 2\" protocols and schemes from encoding the Export\n> > labels into another format - for example Base64 or with their own\n> > compression algorithm.\n> >\n> > Now for the two \"moot problems\":\n> > - ZIP does not have good performance or compression ratio, there are\n> > better algorithms out there like gzip (which also happens to be more\n> > ubiquitous; nearly all websites are serving HTML compressed with gzip\n> > compression).\n> > - ZIP is an archiving format, that happens to have its own compression\n> > format. Archiving format parsers can have serious vulnerabilities in their\n> > implementation that can allow malware to swipe private keys and passwords,\n> > since the primary target for this BIP is wallets. For example, there was\n> > Zip Slip[1] in 2018, which allows for remote code execution. So the malware\n> > can even hide in memory until private keys or passwords are written to\n> > memory, then send them accros the network. Assuming it's targeting a\n> > specific wallet software it's not hard to carry out at all.\n> >\n> > There's two solutions for all this:\n> > 1. The duck-tape solution: Use some compression algorithm like gzip\n> > instead of ZIP archive format.\n> > 2. The \"throw it out and buy a new one\" solution: Get rid of the optional\n> > compression specs altogether, because users are responsible for supplying\n> > the export labels in the first place, so all the compression stuff is\n> > redundant and should be left up to the user use if they desire to.\n> >\n> > I prefer the second solution because it hits the nail at the problem\n> > directly instead of putting duck tape on it like the first one.\n> >\n> > > This <tt>.zip</tt> file may optionally be encrypted using either AES-128\n> > or\n> > > AES-256 encryption, which is supported by numerous applications including\n> > > Winzip and 7-zip.\n> > > The textual representation of the wallet's extended public key (as\n> > defined\n> > > by BIP32, with an <tt>xpub</tt> header) should be used as the password.\n> > Not specific to AES, but I don't see the benefit of encrypting addresses\n> > and labels together. Can you please elaborate why this would be desireable?\n> >\n> > Like I said though, it's better to leave it up to users to decide how to\n> > store their exports, since BIPs can't enforce that anyway (additionally,\n> > the password you propose is insecure - anybody with access to the wallet\n> > can unlock it, which is not desireable to some users who want their own\n> > security).\n> >\n> > > * Transaction ID (<tt>txid</tt>)\n> > > * Address\n> > > * Input (rendered as <tt>txid<index</tt>)\n> > > * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)\n> > Why the need for input and output formats? There is no difference between\n> > them on the wallet level, because they are always identified with a txid\n> > and output index. To distinguish between them and hence write them with the\n> > correct format would require a UTXO set and thus access to a full node,\n> > otherwise the CSV cannot be verified to be completely well-formed.\n> >\n> > Another important point is that practically nobody labels inputs or\n> > outputs because most people do not know that those things even exist, and\n> > the rest don't bother to label them.\n> >\n> > But the biggest downside to including them is related to the problem of\n> > information leaking which you make reference to here:\n> > > In both cases, care must be taken when spending to avoid undesirable\n> > leaks\n> > > of private information.\n> > A CSV dump that has inputs/outputs and addresses mixed together can infer\n> > the owner of all those items. In fact, A CVS label dump is basically a\n> > personal information store so everything in it can be correlated as coming\n> > from the same wallet, so it's important that unnecessary types are kept out\n> > of the format. People are known to leave files lying around on their\n> > computer that they don't need anymore, so these files can find their way\n> > via telemetry to surveillence entities. While we can't specify what users\n> > can do with their exports, we can control the information leak by\n> > preventing certain types of items that we know most users will never use\n> > from being exported in the first place.\n> >\n> > > The order in which these records appear is not defined.\n> > Again, since the primary use case for this BIP is wallets, which likely\n> > use heirarchical derivation schemes like BIP44, there is a net benefit for\n> > the addresses to be exported in ascending order of their `address_type`. It\n> > means that wallets can import them in O(n) time as opposed to O(n^2) time\n> > spent serially checking in which index the address appears at. Of course,\n> > this implies that all addresses up to a certain index have to be exported\n> > into the CSV as well, but most wallets I know of like Core, Electrum\n> > already store addresses like that.\n> >\n> > Also if you do this, you will need to group all the transaction records\n> > before the address records or vice versa - you can use lexigraphical\n> > sorting if you want (ie. Addresses before Transactions). The benefit of\n> > this separation of parts is that wallets can split the imported address\n> > records from the transaction records internally, and feed them to separate\n> > functions which set these labels internally.\n> >\n> > If you decide on doing it this way, then you need a 3rd column to identify\n> > the item type, and also you should quote the label (see below). I strongly\n> > recommend using numbers for identification as opposed to character strings,\n> > so you don't have to worry about localization or character case issues.\n> > There is always one unique number, but there could be multiple strings that\n> > reference the same type. This will complicate importing functions.\n> >\n> > If you insist on include Input and Output types then they can both be\n> > specified as <txid>:<index> if you do this change. They won't be used to\n> > determine the type anyway.\n> >\n> > > The fields may be quoted, but this is unnecessary, as the first comma in\n> > > the line will always be the delimiter.\n> > Don't implement it like that, because that will break CSV parsers which\n> > expect a fixed amount of rows in each record (2 in the header, and some\n> > rows have >2 rows). It's better to mandate that they should always be\n> > double-quoted, since only wallets will generate label exports anyway. If\n> > you plan to use headers then the 3rd column can be blank for it (or you can\n> > split the version and flags from each other).\n> >\n> > > ==Importing==\n> > >\n> > > When importing, a naive algorithm may simply match against any reference,\n> > > but it is possible to disambiguate between transactions, addresses,\n> > inputs\n> > > and outputs.\n> > > For example in the following pseudocode:\n> > > <pre>\n> > >   if reference length < 64\n> > >     Set address label\n> > >   else if reference length == 64\n> > >     Set transaction label\n> > >   else if reference contains '<'\n> > >     Set input label\n> > >   else\n> > >     Set output label\n> > > </pre>\n> > The importing code is too naive and in its current form will prevent the\n> > BIP from getting a number. It is perhaps the single most important part of\n> > a BIP. When implementing an importer, it should utilize a dedicate item\n> > type field that unambiguously identifies the item. So the naive importer is\n> > not good, you need use a 3rd column for that like I explained above, so\n> > that the importer becomes robust.\n> >\n> > In summary (exclamation marks indicate severity - one means low, two means\n> > medium, and three means high):\n> >\n> > 1. Convert the header into a version line with optional flags, otherwise\n> > nobody can extend this format without compatibility issues (!)\n> > 2. Get rid of the specs related to file compression (!!!)\n> > 3. Add a 3rd column for item type (address, transaction etc.) preferably\n> > as numeric constants and grouping items of one type after items of another\n> > type, or if you insist on strings, then only recognize their Titlecase\n> > ASCII versions <spreadsheet software like Excel always tries to titlecase\n> > the words> (!!)\n> > 4. Require double quotes around the label (or single quotes if you prefer,\n> > as long as spreadsheet software doesn't choke on them) (!!)\n> > 5. Require sorting the records according to the order they are stored in\n> > the wallet implementation. (!)\n> > 6. Consider getting rid of Input and Output item types. (!)\n> > 7. And last and most importantly, please write a more robust importer\n> > algorithm in the example given by the BIP, because code in BIPs are\n> > frequently used as references for software. (!!!)\n> >\n> > I hope you will consider these points in future revisions of your BIP.\n> >\n> > - Ali\n> >\n> > [1] https://github.com/snyk/zip-slip-vulnerability\n> >\n> > On Wed, 24 Aug 2022 11:18:43 +0200, craigraw at gmail.com wrote:\n> > > Hi all,\n> > >\n> > > I would like to propose a BIP that specifies a format for the export and\n> > > import of labels from a wallet. While transferring access to funds across\n> > > wallet applications has been made simple through standards such as BIP39,\n> > > wallet labels remain siloed and difficult to extract despite their value,\n> > > particularly in a privacy context.\n> > >\n> > > The proposed format is a simple two column CSV file, with the reference\n> > to\n> > > a transaction, address, input or output in the first column, and the\n> > label\n> > > in the second column. CSV was chosen for its wide accessibility,\n> > especially\n> > > to users without specific technical expertise. Similarly, the CSV file\n> > may\n> > > be compressed using the ZIP format, and optionally encrypted using AES.\n> > >\n> > > The full text of the BIP can be found at\n> > > https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki\n> > > and also copied below.\n> > >\n> > > Feedback is appreciated.\n> > >\n> > > Thanks,\n> > > Craig Raw\n> > >\n> > > ---\n> > >\n> > > <pre>\n> > >   BIP: wallet-labels\n> > >   Layer: Applications\n> > >   Title: Wallet Labels Export Format\n> > >   Author: Craig Raw <craig at sparrowwallet.com>\n> > >   Comments-Summary: No comments yet.\n> > >   Comments-URI:\n> > > https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels\n> > >   Status: Draft\n> > >   Type: Informational\n> > >   Created: 2022-08-23\n> > >   License: BSD-2-Clause\n> > > </pre>\n> > >\n> > > ==Abstract==\n> > >\n> > > This document specifies a format for the export of labels that may be\n> > > attached to the transactions, addresses, input and outputs in a wallet.\n> > >\n> > > ==Copyright==\n> > >\n> > > This BIP is licensed under the BSD 2-clause license.\n> > >\n> > > ==Motivation==\n> > >\n> > > The export and import of funds across different Bitcoin wallet\n> > applications\n> > > is well defined through standards such as BIP39, BIP32, BIP44 etc.\n> > > These standards are well supported and allow users to move easily between\n> > > different wallets.\n> > > There is, however, no defined standard to transfer any labels the user\n> > may\n> > > have applied to the transactions, addresses, inputs or outputs in their\n> > > wallet.\n> > > The UTXO model that Bitcoin uses makes these labels particularly valuable\n> > > as they may indicate the source of funds, whether received externally or\n> > as\n> > > a result of change from a prior transaction.\n> > > In both cases, care must be taken when spending to avoid undesirable\n> > leaks\n> > > of private information.\n> > > Labels provide valuable guidance in this regard, and have even become\n> > > mandatory when spending in several Bitcoin wallets.\n> > > Allowing users to export their labels in a standardized way ensures that\n> > > they do not experience lock-in to a particular wallet application.\n> > > In addition, by using common formats, this BIP seeks to make manual or\n> > bulk\n> > > management of labels accessible to users without specific technical\n> > > expertise.\n> > >\n> > > ==Specification==\n> > >\n> > > In order to make the import and export of labels as widely accessible as\n> > > possible, this BIP uses the comma separated values (CSV) format, which is\n> > > widely supported by consumer, business, and scientific applications.\n> > > Although the technical specification of CSV in RFC4180 is not always\n> > > followed, the application of the format in this BIP is simple enough that\n> > > compatibility should not present a problem.\n> > > Moreover, the simplicity and forgiving nature of CSV (over for example\n> > > JSON) lends itself well to bulk label editing using spreadsheet and text\n> > > editing tools.\n> > >\n> > > A CSV export of labels from a wallet must be a UTF-8 encoded text file,\n> > > containing one record per line, with records containing two fields\n> > > delimited by a comma.\n> > > The fields may be quoted, but this is unnecessary, as the first comma in\n> > > the line will always be the delimiter.\n> > > The first line in the file is a header, and should be ignored on import.\n> > > Thereafter, each line represents a record that refers to a label applied\n> > in\n> > > the wallet.\n> > > The order in which these records appear is not defined.\n> > >\n> > > The first field in the record contains a reference to the transaction,\n> > > address, input or output in the wallet.\n> > > This is specified as one of the following:\n> > > * Transaction ID (<tt>txid</tt>)\n> > > * Address\n> > > * Input (rendered as <tt>txid<index</tt>)\n> > > * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)\n> > >\n> > > The second field contains the label applied to the reference.\n> > > Exporting applications may omit records with no labels or labels of zero\n> > > length.\n> > > Files exported should use the <tt>.csv</tt> file extension.\n> > >\n> > > In order to reduce file size while retaining wide accessibility, the CSV\n> > > file may be compressed using the ZIP file format, using the <tt>.zip</tt>\n> > > file extension.\n> > > This <tt>.zip</tt> file may optionally be encrypted using either AES-128\n> > or\n> > > AES-256 encryption, which is supported by numerous applications including\n> > > Winzip and 7-zip.\n> > > In order to ensure that weak encryption does not proliferate, importers\n> > > following this standard must refuse to import <tt>.zip</tt> files\n> > encrypted\n> > > with the weaker Zip 2.0 standard.\n> > > The textual representation of the wallet's extended public key (as\n> > defined\n> > > by BIP32, with an <tt>xpub</tt> header) should be used as the password.\n> > >\n> > > ==Importing==\n> > >\n> > > When importing, a naive algorithm may simply match against any reference,\n> > > but it is possible to disambiguate between transactions, addresses,\n> > inputs\n> > > and outputs.\n> > > For example in the following pseudocode:\n> > > <pre>\n> > >   if reference length < 64\n> > >     Set address label\n> > >   else if reference length == 64\n> > >     Set transaction label\n> > >   else if reference contains '<'\n> > >     Set input label\n> > >   else\n> > >     Set output label\n> > > </pre>\n> > >\n> > > Importing applications may truncate labels if necessary.\n> > >\n> > > ==Test Vectors==\n> > >\n> > > The following fragment represents a wallet label export:\n> > > <pre>\n> > > Reference,Label\n> > >\n> > c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction\n> > > 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address\n> > > c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input\n> > >\n> > c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output\n> > >\n> > c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output\n> > > (alternative)\n> > > </pre>\n> > >\n> > > ==Reference Implementation==\n> > >\n> > > TBD"
            },
            {
                "author": "Christopher Allen",
                "date": "2022-08-29T18:19:07",
                "message_text_only": "On Mon, Aug 29, 2022 at 9:12 AM Ali Sherief via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I am aware that business processes are mostly CSV file oriented\n\n\nI disagree that business processes are mostly CSV.  Amateur processes\nmaybe, but professional accounting, no. Trying to do my business accounting\nwith CSV files from various exchanges is PITA.\n\n\n> so you can make a statement akin to BIP174 in the Goal 2 BIP, that expects\n> the medium of exchange to be in files ending in .csv. I wouldn't mind if\n> you require .csv file extension in a BIP for Goal 2. But such a statement\n> is not appropriate in the Goal 1 BIP which is only concerned with the\n> wallet label format itself.\n\n\nI too would like to see some separation of layers here, as there are other\npossible output formats. Maybe expanding on another use case for this data\nwould help.\n\nI've been working with @nochiel <https://github.com/nochiel> on export\nto a Plain-Text\nAccounting <https://plaintextaccounting.org> friendly format,\ninitially the beancount\npython app <https://github.com/beancount/beancount/>: (our prototype is\ncurrent at /beancounter.py but it is being refactored into new repo).\n\nBasically what the final tool will do is: given a descriptor, get any\ntransactions for that descriptor from a random explora via Tor (initially\nours and Blockstream's), and then get price information from a random\nSpotbit price server via Tor (initially just ours, but seeking more hosts),\nand export a beancount compatible file.\n\n```\n\npython app.py beancount\n\"wpkh(tpubD9hudZxy8Uj3453QrsEbr8KiyXTYC5ExHjJ5sNDVW7yKJ8wc7acKQcpdbvZX6dFerHK6MfVvs78VvGfotjN28yC4ij6nr4uSVhX2qorUV8V/0/*)\"\nOutputs: spotbit.beancount\n\n2008-10-31 commodity BTC\n  name: \"Bitcoin\"\n  asset-class: \"cryptocurrency\"\n\n2018-04-02 open Assets:BTC BTC\n2018-04-02 open Liabilities:Cash:USDT USDT\n\n2018-04-02 * \"tb1qcrekknrspx28t9vl53ltsag5gqgqdj066ydf75\" \"Transaction\nhash: 2a2f7f24761fa54cb6e559efea5678415d9cbbabc42e6a4e2ce463ee3c446230\"\nAssets:BTC 1.00000000 BTC { 6935.16 USDT }\nLiabilities:Cash:USDT - 6935.16 USDT\n\n2018-04-02 * \"tb1q45whzx3emntntnpzjdx3gzj6z5cgxakkg7s3sa\" \"Transaction\nhash: 387123efcaa707759a4af8159cb1309fae86b793d26b5fd8bba42637852dde89\"\nAssets:BTC - 0.36300616 BTC @  6935.16 USDT\nLiabilities:Cash:USDT 2517.51 USDT\n\n2018-04-02 * \"tb1qgv5484m83e2mzz3n8tf4snvnwj5qgqgampnhvv\" \"Transaction\nhash: 387123efcaa707759a4af8159cb1309fae86b793d26b5fd8bba42637852dde89\"\nAssets:BTC - 0.63699243 BTC @  6935.16 USDT\nLiabilities:Cash:USDT 4417.64 USDT\n\n2018-04-02 * \"tb1q45whzx3emntntnpzjdx3gzj6z5cgxakkg7s3sa\" \"Transaction\nhash: 387123efcaa707759a4af8159cb1309fae86b793d26b5fd8bba42637852dde89\"\nAssets:BTC 0.36300616 BTC { 6935.16 USDT }\nLiabilities:Cash:USDT - 2517.51 USDT\n```\n\nI can then use the beancount cli app (or it's fava webapp) to easily add\nother details to this file to do my bitcoin accounting (and any other\naccounting I need). In particular, as beancount support lots, it solves a\nproblem for me with US taxes which is unrealized capital gain (I get 1 BTC\nfrom donor at $20K, the price goes up to $30K and I pay it to an engineer,\nmy BTC balance is 0 but my unrealized capital gain for US tax purposes  is\n$10K).\n\nMore ideally, if there were additional details that I could merge in from\nmy wallet export, such as payer and payee, notes, etc. it would make my\naccounting much easier.\n\nThus I'd like to see an easier and interoperable way to merge these details\n(my account details from an Esplora and price details from Spotbit), with\nwhat my different wallets may (or may not) have available.\n\nI hope that this might inspire some ideas from the people working on this\nwallet export format.\n\n-- Christopher Allen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220829/21fd9830/attachment.html>"
            },
            {
                "author": "NVK",
                "date": "2022-08-29T19:52:17",
                "message_text_only": "Hello,\n\nThanks for this proposal.\n\nI was trying to avoid adding more opinions / bike-shdding to the discussion and didn\u2019t want to particularly pick at any of the threads.\n\nBut, I think I\u2019d like to at least voice at how important having a human readable format for this is. CSV is indeed a format with many shortcomings, but so are most cross applications open formats that are human readable. I go through this every month for business and personal.\n\nIf contention is too high for CSV as cross application for import/export then maybe the route of two file formats maybe awkward but necessary. JSON maybe used as the choice for bitcoin clients for label syncing and CSV as the export for other purposes. I believe CSV is importable by most accounting software, old and new. JSON is not.\n\nIn regards to encryption, AES on 7z is a great, wide os native support.\n\nBest,\n\nNVK\n\n> On Aug 24, 2022, at 05:46, Craig Raw via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \ufeff\n> Hi all,\n> \n> I would like to propose a BIP that specifies a format for the export and import of labels from a wallet. While transferring access to funds across wallet applications has been made simple through standards such as BIP39, wallet labels remain siloed and difficult to extract despite their value, particularly in a privacy context.\n> \n> The proposed format is a simple two column CSV file, with the reference to a transaction, address, input or output in the first column, and the label in the second column. CSV was chosen for its wide accessibility, especially to users without specific technical expertise. Similarly, the CSV file may be compressed using the ZIP format, and optionally encrypted using AES.\n> \n> The full text of the BIP can be found at https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki and also copied below.\n> \n> Feedback is appreciated.\n> \n> Thanks,\n> Craig Raw\n> \n> ---\n> \n> <pre>\n>   BIP: wallet-labels\n>   Layer: Applications\n>   Title: Wallet Labels Export Format\n>   Author: Craig Raw <craig at sparrowwallet.com>\n>   Comments-Summary: No comments yet.\n>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels\n>   Status: Draft\n>   Type: Informational\n>   Created: 2022-08-23\n>   License: BSD-2-Clause\n> </pre>\n> \n> ==Abstract==\n> \n> This document specifies a format for the export of labels that may be attached to the transactions, addresses, input and outputs in a wallet.\n> \n> ==Copyright==\n> \n> This BIP is licensed under the BSD 2-clause license.\n> \n> ==Motivation==\n> \n> The export and import of funds across different Bitcoin wallet applications is well defined through standards such as BIP39, BIP32, BIP44 etc.\n> These standards are well supported and allow users to move easily between different wallets.\n> There is, however, no defined standard to transfer any labels the user may have applied to the transactions, addresses, inputs or outputs in their wallet.\n> The UTXO model that Bitcoin uses makes these labels particularly valuable as they may indicate the source of funds, whether received externally or as a result of change from a prior transaction.\n> In both cases, care must be taken when spending to avoid undesirable leaks of private information.\n> Labels provide valuable guidance in this regard, and have even become mandatory when spending in several Bitcoin wallets.\n> Allowing users to export their labels in a standardized way ensures that they do not experience lock-in to a particular wallet application.\n> In addition, by using common formats, this BIP seeks to make manual or bulk management of labels accessible to users without specific technical expertise.\n> \n> ==Specification==\n> \n> In order to make the import and export of labels as widely accessible as possible, this BIP uses the comma separated values (CSV) format, which is widely supported by consumer, business, and scientific applications.\n> Although the technical specification of CSV in RFC4180 is not always followed, the application of the format in this BIP is simple enough that compatibility should not present a problem.\n> Moreover, the simplicity and forgiving nature of CSV (over for example JSON) lends itself well to bulk label editing using spreadsheet and text editing tools. \n> \n> A CSV export of labels from a wallet must be a UTF-8 encoded text file, containing one record per line, with records containing two fields delimited by a comma.\n> The fields may be quoted, but this is unnecessary, as the first comma in the line will always be the delimiter.\n> The first line in the file is a header, and should be ignored on import.\n> Thereafter, each line represents a record that refers to a label applied in the wallet.\n> The order in which these records appear is not defined.\n> \n> The first field in the record contains a reference to the transaction, address, input or output in the wallet.\n> This is specified as one of the following:\n> * Transaction ID (<tt>txid</tt>)\n> * Address\n> * Input (rendered as <tt>txid<index</tt>)\n> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)\n> \n> The second field contains the label applied to the reference. \n> Exporting applications may omit records with no labels or labels of zero length.\n> Files exported should use the <tt>.csv</tt> file extension.\n> \n> In order to reduce file size while retaining wide accessibility, the CSV file may be compressed using the ZIP file format, using the <tt>.zip</tt> file extension.\n> This <tt>.zip</tt> file may optionally be encrypted using either AES-128 or AES-256 encryption, which is supported by numerous applications including Winzip and 7-zip. \n> In order to ensure that weak encryption does not proliferate, importers following this standard must refuse to import <tt>.zip</tt> files encrypted with the weaker Zip 2.0 standard.\n> The textual representation of the wallet's extended public key (as defined by BIP32, with an <tt>xpub</tt> header) should be used as the password.\n> \n> ==Importing==\n> \n> When importing, a naive algorithm may simply match against any reference, but it is possible to disambiguate between transactions, addresses, inputs and outputs. \n> For example in the following pseudocode:\n> <pre>\n>   if reference length < 64\n>     Set address label\n>   else if reference length == 64\n>     Set transaction label\n>   else if reference contains '<'\n>     Set input label\n>   else\n>     Set output label\n> </pre>\n> \n> Importing applications may truncate labels if necessary.\n> \n> ==Test Vectors==\n> \n> The following fragment represents a wallet label export:\n> <pre>\n> Reference,Label\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e,Transaction\n> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e<0,Input\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e>0,Output\n> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b\u200e:0,Output (alternative)\n> </pre>\n> \n> ==Reference Implementation==\n> \n> TBD\n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220829/58fd4d21/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP Proposal: Wallet Labels Export Format",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Christopher Allen",
                "Brandon Black",
                "Ali Sherief",
                "Pavol Rusnak",
                "rhavar at protonmail.com",
                "Craig Raw",
                "Clark Moody",
                "Billy Tetrud",
                "NVK"
            ],
            "messages_count": 18,
            "total_messages_chars_count": 213343
        }
    },
    {
        "title": "[bitcoin-dev] BIP Draft: Revocable Proof-of-Burn Transaction Template",
        "thread_messages": [
            {
                "author": "\u0412\u0435\u043b\u0435\u0441\u043b\u0430\u0432",
                "date": "2022-08-25T19:24:16",
                "message_text_only": "Dear Bitcoin Development Mailing List,\n\nI would like to present for initial comment a new draft BIP that we have been working on.\n\nThis BIP provides a new standard template for creating revocable proof-of-burn transactions that can be easily and cheaply verified by nodes running under SPV assumptions.\n\nWe would very much appreciate further peer-feedback and critical comment so that this proposal may be improved as it continues through the formal standardisation process.\n\nPlease find the full draft-proposal appended, you may also use the link provided to view the online rendered copy.\n\nYours sincerely,\nVeleslav\n\n\nPS. Upon being assigned a BIP-Number, I will write to the list with the updated URL.\n\nhttps://github.com/veleslavs/bips/blob/bip-rpob-tx-template/bip-rpob-tx-template.mediawiki\n\n\n<pre>\n  BIP: bip-rpob-tx-template\n  Layer: Applications\n  Title: Revocable Proof-of-Burn Transaction Template\n  Author: Veleslav <veleslav.bips at protonmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-bip-rpob-tx-template\n  Status: Draft\n  Type: Standards Track\n  Created: 2022-08-18\n  License: BSD-3-Clause\n           CC0-1.0\n</pre>\n\n==Introduction==\n\n===Abstract===\nThis BIP proposes an application-layer template for revocable proof-of-burn, or ''\"RPoB\"'', transactions.\n\n* This proposal uses a new transaction version number to allow for future extensions.\n* This proposal recommends that implementations who mine and relay transaction to update their standard transaction templates as defined by this document.\n\nThis proposal aims to support decentralised systems, allowing the use ''RPoB'' assertions in a consistent, efficient, reliable, and interoperable way.\n\n''The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.''\n\n===Copyright===\nThis document is dual licensed as BSD 3-clause and Creative Commons CC0 1.0 Universal.\n\n===Motivation===\nIn signalling theory<ref group=\"Note\">Evolutionary biology theory of communication, or ''\"signalling theory\"'', where creatures make honest signals that are hard to cheat, for mutual evolutionary advantage.</ref>, proof of burn<ref group=\"Note\">In Bitcoin, ''proof of burn'' places bitcoin value into outputs that provably unspendable. This dose not reduce the wealthy of the network, but instead reduces the velocity of these coins to zero. Transferring the network wealth onto the remaining coins that have a non-zero velocity.</ref> is a costly signal,<ref group=\"Note\">A ''\"costly signal\"'' indicates dedication, an observer expects that such a signal is not made flippantly because the high cost.</ref> allowing the network to assign a default trust.<ref group=\"Note\">An entity is assigned a ''\"default trust\"'' value when they are not connected to the trust graph. Without a default source trust, growing a decentralised web-of-trust network is impossible. New users face a catch-22 problem: they are disconnected from the trust graph and don't have a possibility to prove themselves.</ref> Bitcoin naturally provides an implementation of proof of burn without feedback loops,<ref group=\"Note\">A ''\"feedback loop\"'' is when a trust signal can be amplified by a privileged subset of the network by feeding the creation-cost of this signal back into the process of making the signal.</ref> allowing for default trust to be assigned fairly in decentralised networks.<ref group=\"Note\">New users are able to use a proof-of-burn to bootstrap themselves into new trust networks. 'New-user-with-burn-proofs' can be welcomed-in with basic services and focused attention, as the network knows that it was costly to generate the burn-proof.</ref>\n\nThe ability to revoke<ref group=\"Note\">To ''\"revoke\", is'' publicly asserting that a previous statement should not be valued as originally intended.</ref> past assertions is important for many applications,<ref group=\"Note\">Unexpected things happen, for example, the loss or compromise of private keys.</ref> therefore proposal couples bitcoin proof-of-burn with a revocation mechanic.\n\nIn choosing to standardise via the BIP peer-reviewed process, we hope to give the community greater confidence in making use of bitcoin-based revocable proof of burn technology.\n\n====Notes:====\n<references group=\"Note\" />\n\n==Design==\n\n===Conceptual===\n''\"Proof-of-Burn\"'' transactions have long exited in Bitcoin, ''\"OP_RETURN\"'' transactions, (named after the op-code ''\"return\"'', that causes the public key script to return in failure, hence making the output unspendable and \"burning\" any value allocated to that output), these transactions have been actively mined since the release of Bitcoin-Core 0.9.\n\nSince OP_RETURN doesn't allow the public key script to be spent (as is it's design), there hasn't been any built-in solution addressing the requirements a application-useable proof-of-burn transaction, in particular:\n\n*A standard association with a public key in for transaction.\n*A standard protocol to publicly revoke a proof-of-burn transaction.\n\nIn this proposal we satisfy these requirements by specifying a taproot public key in the op_return payload and an another output for revocation.\n\n===Other Requirements===\nOperation under <abbr title=\"Simple Payment Verification\">SPV</abbr> assumptions:\n*Transactions are small: ''RPoB transactions (non-witness-part) are fixed to two possible sizes, depending if there is a change output, or not.''\n*Revocations are quickly and cheaply indexed: ''RPoB revocations only require obtaining the preimage to a double-sha256 hash. This is easily indexed and propagated in a gossip network.''\n\nEase of implementation:\n*Use of only Taproot and Schnorr: ''To reduce the scope of the transaction, we use only Taproot for inputs and Outputs, and Schnorr for the signature that covers the funding outpoint.''\n\nTransaction funded by 3rd party:\n* It should be secure for an untrusted 3rd party fund the proof-of-burn transaction. ''Allowing for services to fund these transactions and be compensated with some sort of off-chain payment.''\n\nFuture extendability:\n*Making use of the transaction version feature of bitcoin. ''This allows for easier indexing strategies in the future, (with a simple consensus change: to include in the coinbase the number of the transactions in the block by their transaction version).''\n* Including a byte for 8 version flag bits. ''This allows for a reliable way to upgrade in the future in a forward-comparable way.''\n\n===Transaction Design Overview:===\n[[File:bip-rpob-tx-template/rpob-template-summary-table.svg]]\n\n==Specification==\nThis section specifies our RPoB transaction template.\n\n===Transaction===\nGeneral form:\n<pre>\nversion:      0x3\nmarker:       0x0\nflag:         0x1\ntxin_count:   0x1\ntxout_count:  0x2 (without change) or 0x3 (with change)\nlock_time:    (any)\n</pre>\n\n*RPoB transactions MUST use the transaction version (nVersion) 0x03.\n\n*RPoB transactions MUST have only one input and either two or three outputs.\n\n===Input 1: Funding===\nGeneral form:\n<pre>\nsignature_script:  (empty)\nwitness_script:    <taproot_witness>\n</pre>\n\n*The RPoB transaction input MUST be P2TR (Pay to Tap Root).\n\n===Output 1: Burn and Data===\nGeneral form:\n\n<pre>\nvalue:              (any)\npublic_key_script:  RETURN < 1-byte-rpob_version_flag>\n                           <32-byte-rpob_secp256k1_public_key>\n                           <64-byte-rpob_schnorr_signature>\n</pre>\n\nThe public key script fields are:\n\n<pre>\nrpob_version_flag:           1-byte , 0x00 (initial version).\nrpob_secp256k1_public_key:  32-bytes, SECP256K1 compact public key.\nrpob_schnorr_signature:     64-bytes, bip-340 Schnorr Signature.\n</pre>\n\n*The first RPoB transaction contains the burn value, that is made unspendable by the 'OP_RETURN' in the public key script.\n\n===Output 2: Revocation Puzzle===\nGeneral form:\n\n<pre>\nvalue:              0\npublic_key_script:  SIZE 32 EQUALVERIFY HASH256\n                    <32-byte-rpob_revocation_puzzle>\n                    EQUAL\n</pre>\n\n*The Value of the Revocation Puzzle Output MUST be zero.\n\n<code>HASH256</code> is defined by ''double sha256'':\n\n<pre>\nrpob_revocation_puzzle:    32-bytes, public, SHA256(SHA256(\n                                     <32-byte-rpob_revocation_solution>\n                                     ))\n\nrpob_revocation_solution:  32-bytes, secret, publicly reveal this value to revoke the proof-of-burn.\n</pre>\n\n*It is RECOMMENDED that implementations use a value for the <code>rpob_revocation_solution</code> that is derived from the secret key used to generate the  <code>rpob_secp256k1_public_key</code> .\n\n===Output 3, Optional: Change===\n<pre>\nvalue:              (any)\npublic_key_script:  1 <32-byte-taproot_witness_program>\n</pre>\n\n*This output MAY have any value.\n*The public key MUST be a standard P2TW output.\n\n===Signature: Included in Output 1===\n<pre>\nrpob_schnorr_signature:       64-bytes, bip-340, signature (\n                                        <32-byte-rpob_signature_message_hash>,\n                                        <32-byte-secp256k1_private_key>\n                                        )\n\nrpob_signature_message_hash:  32-bytes, bip-340, sha256_taged_hash (\n                                        <77-byte-rpob_signature_message>,\n                                        <16-byte-rpob_hash_tag>\n                                        )\n\nrpob_hash_tag:                16-bytes, utf-8-hash_tag (\"rpob/BTC/MAINNET\")\n                                    or, utf-8-hash_tag (\"rpob/BTC/TESTNET\")\n\nrpob_signature_message:       77-bytes, < 1-byte-version_flags>\n                                        <32-byte-input_txid_hash>\n                                        < 4-byte-input_index>\n                                        < 8-byte-burn_output_value>\n                                        <32-byte-rpob_revocation_puzzle>\n</pre>\n\n*The <code>rpob_schnorr_signature</code> uses the [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP-340] algorithm.\n\n==Deployment==\n\nWhile the ''IsStandard'' rules are quite restricting, it is quite possible to submit transactions directly to miners, or co-operate with miners who would enjoy to have some addition fee-revenue. So the initial process of testing on the main-network should be possible.\n\nIf this standard gains significant attention, we are happy to write a supplementary BIP to define a new service bit to allow nodes to signal that this new type of standard transaction is accepted.\n\n==Rationale==\n===Why require RPoB transactions to use a new transaction version?===\n\nThis allows for future indexing and enforcement strategies at the consensus layer.\n\n===Why use a hash puzzle for the revocation?===\n\nThe hash-puzzle allows for easy indexing of the revocation, in the format:\n\n<code><32-byte-revocation-puzzle> (if revoked: <32-byte-revocation-puzzle-preimage>)</code>\n\n*Since the digest algorithm is double sha256, even for a very large number of revocation, this index would be very cheap to verify.\n\n*We envision nodes keeping track of all the revocation-puzzles listed in the blockchain, as 32-byte each, a million RPoB is only 32mb. This can be further optimised.\n\nAdditionally, we do not want to confuse a public key, (that can sign), and a revocation-puzzle (that may only revoke).\n\n===Why must the revocation output be of zero value?===\n\nRevocation can be spent by anyone once the revocation pre-image has been published.\n\n===Why does a RPoB need a signature at all?===\n\nThe primary purpose of the signature is to stop replay-attacks. (Somebody takes your public-key and makes transaction where you don't control the revocation).\n\nThe secondary purpose is to allow for untrusted parties to create transactions on your behalf. i.e. a 'RPoB' transaction creation service.\n===Why waste precious block space?===\n\nConsuming block-space is a of secondary proof-of-burn that this proposal takes advantage of, as itself is limited and contested for (blocks are almost full on average). There is an opportunity cost of the next best transaction when a miner chooses to include a RPoB transaction their block.\n\nAdditionally, transaction fees are important for the long-term health of the bitcoin-network, this proposal increases the demand for the blockchain.\n\n===What do you want to make these RPoB transactions if there is insufficient block-space?===\n\nThis isn't our problem. Those who have the economic purpose and resources to make RPoB transactions will outcompete those who do not.\n\n==Backwards Compatibility==\n\nAs this is an application layer structure without any preexisting deployment, we foresee no compatibility issues.\n\n==Reference Implementation==\n\nTo be made.\n\n==Acknowledgements==\n\nWhile we have somewhat independently come up with the concept of RPoB, the idea of having a public record of public key enrolments has been around for a long time. None of the ideas in this BIP are new.\n\nWe would like to thank Jonas Schnelli, 'M', and 'P', for their past contributions.\n\n==Appendixes==\n\n===Appendix 1: Some alternatives to blockchain-based proof-of-burn:===\nBlockchains provide the our first opportunity to have deterministic and decentralised trust networks. Before blockchains we had proof-of-work and proof-of-payments as the two main gate-keepers for boot-scraping new members into a exclusive group:\n\n==== Proof-of-Work: ====\nFor example,\n\n* In games it could be to grind your character up to a certain level.\n* Or it could be to make and present hand-drawn artworks.\n* Or it could be to solve a CAPTCHA.\n\nWith proof-of-work blockchains provides a way to quantises an abstract an amount of work into a value. Providing a solution \"how much dose this work cost?\" problem: your work can be traded for bitcoin, and the bitcoin value is set efficiently in the market.\n\n==== Proof-of-Payment: ====\nFor example,\n\n* Buying an expensive uniform item required for the clan.\n* Paying membership dues.\n* Proving a donation to a charity.\n\nWith proof-of-payment the problem is the feedback loops, who gets the payment is placed into a privileged position of responsibly. The blockchain solves this with proof-of-burn outputs, the 'payment' goes back to the network, distributed indirectly and proportionally the holders of bitcoin.\n\n==== None: ====\nFor example,\n\n* Pretty-Good-Privacy (PGP).\n\nPGP provided the basic cryptographic infrastructure for secure communication, including a basic web-of-trust where users can cross-sign each others keys, to make man-in-the-middle attacks harder to carry out. The primary problem with PGP is that any infrastructure that uses it is open to denial-of-service attack, as making new pgp-key identities is extremely cheap.\n\nThe trust network also is open to sybil attack, as huge numbers of keys can all cross-trust each other making it appear that they belong to a large-genuine trust network.\n\n==== Other: ====\n\n* Blockchain Timestamping, i.e. Open-Timestamps.\n\nOne of the most simple ways of assiging value to something is to prove that it is old. Timestamping with a blockchain allows users to assert that they didn't just create this account just now. -  However the problem is that timestamps are cheap to make, and if the need for timestamps is predictable, then adversaries can pre-generate many to misuse and attack a network at a later date.\n\n* Blockchain space Use.\n\nSimply putting a statement into a blockchain itself, if there is any free-pressure is indirect form of burn by via the miner.  By out-competing the next-best-transaction set, this has burnt the value in the difference between the fees of the two set.\n\nThus, it can be shown that if the blocks are full, a RPoB transaction with zero-burn-amount is still a proof-of-bun transaction!\n\n=== Appendix 2: Some notes on blockchain-based proof-of-burn and decentralised networks: ===\nUsing a blockchain the relative value of a proof-of-burn is deterministically calculable:\n\n* Trust calculations transferring a proof-of-burn into a \"default trust\" value are possible. Leading to the creation of trust graphs that can operate reliably without human intervention.\n* Networks using such default trust calculations become inherently resistant to distributed denial of service attacks.\n\nAll this cannot easily be achieved without leveraging the functionally of a blockchain such as Bitcoin.\n\n==Footnotes==\n\n<references />"
            }
        ],
        "thread_summary": {
            "title": "BIP Draft: Revocable Proof-of-Burn Transaction Template",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "\u0412\u0435\u043b\u0435\u0441\u043b\u0430\u0432"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 16431
        }
    }
]