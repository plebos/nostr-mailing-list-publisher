[
    {
        "title": "[bitcoin-dev] Introducing Flexible Transactions.",
        "thread_messages": [
            {
                "author": "Tom",
                "date": "2016-08-01T09:30:22",
                "message_text_only": "I've been asked one question quite regularly and recently with more force.\nThe question is about Segregated Witness and specifically what a hard\nfork based version would look like.\n\n\nThis is available online at my blog;\n  http://zander.github.io/posts/Flexible_Transactions/\n\nBut I'll publish the actual text here as well, hoping to hear from others in \nthe Bitcoin industry what they think about this approach.\n\n\n\n\nSegregated Witness (or SegWit for short) is complex. It tries to solve\nquite a lot of completely different and not related issues and it tries to\ndo this in a backwards compatible manner. Not a small feat!\n\nSo, what exactly does SegWit try to solve? We can find info of that in the\n[benefits](https://bitcoincore.org/en/2016/01/26/segwit-benefits/) document.\n\n* Malleability Fixes\n* Linear scaling of sighash operations\n* Signing of input values\n* Increased security for multisig via pay-to-script-hash (P2SH)\n* Script versioning\n* Reducing UTXO growth\n* Compact fraud proofs\n\nAs mentioned above, SegWit tries to solve these problems in a backwards\ncompatible way. This requirement is there only because the authors of\nSegWit set themselves this requirement. They set this because they wished\nto use a softfork to roll out this protocol upgrade.\n**This post is going to attempt to answer the question if that is indeed\nthe best way of solving these problems.**\n\n\nStarting with Malleability, the problem is that a transaction between being\ncreated by the owner of the funds and being mined in a block is possible to\nchange in such a way that it still is valid, but the transaction identifier\n(TX-id) has been changed. But before we dive into the deep, lets have some\ngeneral look at the transaction data first.\n\nIf we look at a\n[Transaction](http://bitcoinfactswiki.github.io/Transaction) as it is\ntoday, we notice some issues.\n\n<table>\n<tr><td colspan=2>Version</td><td>4 bytes</td></tr>\n<tr><td colspan=2>Number of inputs</td><td>VarInt (between 1 and 9 \nbytes)</td></tr>\n<tr><td rowspan=5 class=vertical>inputs</td><td>Prev transaction \nhash</td><td>32 bytes.\n            <font color=\"red\">Stored in reverse</font></td></tr>\n<tr><td>Prev transaction index</td><td>4 bytes</td></tr>\n<tr><td>TX-in script length</td><td><font color=red>Compact-\nint</font></td></tr>\n<tr><td>TX-in script</td><td>This is the witness data</td></tr>\n<tr><td>Sequence-no/<a \nhref=\"https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki\">CSV</a>\n  </td><td>4 bytes</td></tr>\n<tr><td colspan=2>Number of outputs</td><td>VarInt (between 1 and 9 \nbyte)</td></tr>\n<tr><td rowspan=3 class=vertical>outputs</td><td>Value</td><td>Var \nint</td></tr>\n<tr><td>TX-out script length</td><td><font color=red>Compact-\nint</font></td></tr>\n<tr><td>TX-out script</td><td>bytearray</td></tr>\n<tr><td colspan=2>NLockTime</td><td>4 bytes</td></tr>\n</table>\n</table>\n\nThe original transaction format as designed by\n[Satoshi Nakamoto](http://bitcoinfactswiki.github.io/Satoshi_Nakamoto/)\nhad a 4 byte version. This design approach is common in the industry and\nthe way that this is used is that a new version is defined whenever any\nfield in the data structure needs changing.  In Bitcoin we have not done\nthis and we are still at version 1.\n\nWhat Bitcoin has done instead is make small, semi backwards-compatible, \nchanges.\nFor instance the [CHECKSEQUENCEVERIFY]\n(http://bitcoinfactswiki.github.io/Script/#Locktime)\nfeature repurposes the sequence field as a way to add data\nthat would not break old clients.  Incidentally, this specific change\n(described in BIP68)\nis not backwards compatible in the main clients as it depends on a\ntransaction version number being greater than 1, they all check for\nStandard transactions and say that only version 1 is standard.\n\nThe design of having a version number implies that the designer wanted to\nuse hard forks for changes. A new client is required to know how to parse a\nnewly designed data structure, this should be obvious. So the idea is to\nchange the version number and so older clients would know they can't parse\nthis new transaction version. To keep operating, everyone would have to\nupgrade to a client that supports this new transaction version.\n\nLets look at why we would want to change the version; I marked some items in\nred that are confusing. Most specifically is that numbers are stored in 3\ndifferent, incompatible formats in transactions. Not really great and\ncertainly a source of bugs.\n\nTransactions are cryptographically signed by the owner of the coin so\nothers can validate that he is actually allowed to move the coins.\nThe signature is stored in the `TX-in-script`.  \nCrypto-geeks may have noticed something weird that goes against any\ntextbooks knowledge.  What this is is that a digital\nsignature has to be placed outside of the thing it signs. This is because\na digital signature protects against changes. But a signature itself would\ncause this change. So you have to store the signature outside the thing you\nsign.\n\nBitcoin's creator did something smart with how transactions are actually\nsigned so the signature actually doesn't have to be outside the\ntransaction. It works. Mostly. But we want it to work flawlessly\nbecause currently this being too smart causes the dreaded malleability\nissues where people have been known to lose money.\n\n\n## What about SegWit?\n\nSegWit actually solves only one of these items. It moves the signature out\nof the transaction. SegWit doesn't fix any of the other problems in Bitcoin\ntransactions, it also doesn't change the version after making the\ntransaction's-meaning essentially unable to be understood by old clients.\n\nOld clients will stop being able to check the SegWit type of transaction,\nbecause the authors of SegWit made it so that SegWit transactions just have\na sticker of \"All-Ok\" on the car while moving the real data to the trailer,\nknowing that the old clients will ignore the trailer.\n\nSegWit wants to keep the data-structure of the transaction unchanged and it\ntries to fix the data structure of the transaction.  This causes friction\nas you can't do both at the same time, so there will be a non-ideal\nsituation and hacks are to be expected.\n\nThe problem, then, is that SegWit introduces more technical debt, a term\nsoftware developers use to say the system-design isn't done and needs\nsignificant more work.  And the term 'debt' is accurate as over time\neveryone that uses transactions will have to understand the defects to work\nwith this properly. Which is quite similar to paying interest.\n\nUsing a Soft fork means old clients will stop being able to validate\ntransactions, or even parses them fully. But these old clients are\nthemselves convinced they are doing full validation.\n\n## Can we improve on that?\n\nI want to suggest a way to **one-time** change the data-structure of the\ntransaction so it becomes much more future-proof and fix the issues it\ngained over time as well. Including the malleability issue. It turns out\nthat this new data-structure makes all the other issues that SegWit fixes\nquite trivial to fix.\n\nI'm going to propose an upgrade I called;\n\n> **Flexible Transactions**\n\nLast weekend I wrote a little app (sources [here]\n(http://zander.github.io/scaling/transactions))\nthat reads a transaction and then writes it out in a new format I've\ndesigned for Bitcoin. Its based on ideas I've used for some time in other\nprojects as well, but this is the first open source version.\n\nThe basic idea is to change the transaction to be much more like modern\nsystems like JSON, HTML and XML. Its a 'tag' based format and has various\nadvantages over the closed binary-blob format.  \nFor instance if you add a new field, much like tags in HTML, your old\nbrowser will just ignore that field making it backwards compatible and\nfriendly to future upgrades.\n\nFurther advantages;\n\n* Solving the malleability problem becomes trivial.\n* tag based systems allow you to skip writing of unused or default values.\n* Since we are changing things anyway, we can default to use only var-int\n  encoded data instead of having 3 different types in transactions.\n* Adding a new tag later, (for instance ScriptVersion) is easy and doesn't\n  require further changes to the transaction data structure. All old clients\n  can still make sense of all the known data.\n* The actual transaction turns out to be about 3% shorter average (calculated\n  over 200K transactions)\n* Where SegWit adds a huge amount of technical debt, my Flexible\n  Transactions proposal instead amortizes a good chunk of technical debt.\n\nAn average **Flexible Transaction** will look like this;\n\n<table>\n<tr><td colspan=2>TxStart (Version)</td><td>0x04</td>\n<td rowspan=5 class=\"vertical\">TX-ID data</td></tr>\n<tr><td rowspan=2 class=vertical>inputs</td><td>TX-ID I try to spent</td><td>1 \n+ 32 bytes</td></tr>\n<tr><td>Index in prev TX-ID</td><td>varint</td></tr>\n<tr><td rowspan=2 class=vertical>outputs</td><td>TX-out Value (in \nSatoshis)</td><td>VarInt</td></tr>\n<tr><td>TX-out script</td><td>bytearray</td></tr>\n<tr><td>inputs</td><td>TX-in-script (Witness data)<td>bytearray</td>\n    <td rowspan=2 class=vertical>WID-data</td></tr>\n<tr><td colspan=2>TxEnd</td><td>0x2C</td></tr>\n</table>\n\nNotice how the not used tags are skipped. The `NLockTime` and the\n`Sequence` were not used, so they are skipped in the transaction.\n\nThe Flexible Transaction proposal uses a list of tags. Like JSON; `\"Name:\"\n\"Value\"`. Which makes the content very flexible and extensible. Just\ninstead of using text, Flexible Transactions use a binary format.\n\nThe biggest change here is that the `TX-in-script` (aka the witness data) is\nmoved to be at the end of the transaction. When a wallet generates this new\ntype of transaction they will append the witness data at the end but the\ntransaction ID is calculated by hashing the data that ends before the\nwitness data.\n\nThe witness data typically contains a public key as well as a signature.\nIn the Flexible Transactions proposal the signature is made by signing exactly\nthe same set of data as is being hashed to generate the TX-input. Thereby\nsolving the malleability issue. If someone would change the transaction, it\nwould invalidate the signature.\n\nI took 187000 recent transactions and checked what this change would do to\nthe size of a transaction with my test app I linked to above.\n\n* Transactions went from a average size of 1712 bytes to 1660 bytes and a\n  median size of 333 to 318 bytes.\n* Transactions can be pruned (removing of signatures) after they have been\n  confirmed. Then the size goes down to an average of 450 bytes or a median\n  of 101 bytes\n* In contrary to SegWit new transactions get smaller for all clients with this\n  upgrade.\n* Transactions, and blocks, where signatures are removed can expect up to\n  75% reduction in size.\n\n## Broken OP_CHECKSIG scripting instruction\n\nTo actually fix the malleability issues at its source we need to fix this\ninstruction. But we can't change the original until we decide to make a\nversion 2 of the Script language.  \nThis change is not really a good trigger to do a version two, and it\nwould be madness to do that at the same time as we roll out a new format of\nthe transaction itself. (too many changes at the same time is bound to\ncause issues)\n\nThis means that in order to make the Flexible Transaction proposal actually\nwork we need to use one of the NOP codes unused in Script right now and\nmake it do essentially the same as OP_CHECKSIG, but instead of using the\noverly complicated manner of deciding what it will sign, we just define it\nto sign exactly the same area of the transaction that we also use to create\nthe TX-ID. (see right most column in the above table)\n\nThis new opcode should be relatively easy to code and it becomes really\neasy to clean up the scripting issues we introduce in a future version of\nscript.\n\n## So, how does this compare to SegWit.\n\nFirst of all, introducing a new version of a transaction doesn't mean we\nstop supporting the current version. So all this is perfectly backwards\ncompatible because clients can just continue making old style transactions.\nNaturally, with the problems that had, but nobody will end up stuck.\n\nUsing a tagged format for a transaction is a one time hard fork to upgrade\nthe protocol and allow many more changes to be made with much lower impact\non the system in the future.  There are parallels to SegWit, it strives for\nthe same goals, after-all. But where SegWit tries to adjust a static\nmemory-format by re-purposing existing fields, Flexible transactions presents\na coherent simple design that removes lots of conflicting concepts.\n\nMost importantly, years after Flexible transactions has been introduced we\ncan continue to benefit from the tagged system to extend and fix issues we\nfind then we haven't thought of today. In the same, consistent, concepts.\n\nWe can fit more transactions in the same (block) space similarly to SegWit, \nthe\nsignatures (witness part) can be pruned by full nodes without causing any\nsecurity implications in both solutions.  What SegWit doesn't do is\nallowing unused features to not use space. So if a transaction doesn't use\nNLockTime (which is near 100% of them) they will take space in SegWit but\nnot in this proposal. Expect your transactions to be smaller and thus lower\nfee!\n\nOn size, SegWit proposes to gain 60% space. Which is by removing the\nsignatures minus the overhead introduced.  In my tests Flexible\ntransactions showed 75% gain.\n\nSegWit also describes changes how data is stored in the block. It creates\nan extra 'branch' in the merkle tree.  The Flexible Transactions proposal\nis in essence solving the same problem as SegWit and the same solution for\nblocks can be applied.  Which means we can have that merkle tree solution\nas well. No change.\n\n\nAt the start of the blog I mentioned a list of advantages that the authors\nof SegWit included.  It turns out that those advantages themselves are\ncompletely not related to each other and they each have a very separate\nsolution to their individual problems. The tricky part is that due to the\nrequirement of old clients staying forwards-compatible they are forced to\npush them all into the one 'fix'.\n\nLets go over them individually;\n\n\n### Malleability Fixes\n\nUsing this new version of a transaction data-structure solves all forms of\nknown malleability.\n\n### Linear scaling of sighash operations\n\nThis has been fixed in the BIP109 2MB hardfork quite some months ago.\n\n### Signing of input values\n\nThis is included in this proposal.\n\n### Increased security for multisig via pay-to-script-hash (P2SH)\n\nThe *Flexible transactions* proposal outlined in this document makes many\nof the additional changes in SegWit really easy to add at a later time.\nThis change is one of them.\n\nBottom line, changing the security with a bigger hash in SegWit is only\nincluded in SegWit because SegWit didn't solve the transaction versioning\nproblem making it trivial to do separately.  \nWith flexible transactions this change can now be done at any time in the\nfuture with minimal impact.\n\n### Script versioning\n\nNotice that this *only* introduces the versioning byte. It doesn't actually\nintroduce a new version of script.  \nThis is an excellent example where tagged formats shine brighter than a\nstatic memory format that SegWit uses because adding such a versioning tag\nis much cleaner and much easier and less intrusive to do with\nflexible transactions. Just add a new tag that defaults to version 1 so the\nold transactions not having the tag stay consistent.\n\nImagine having to include \"body background=white\" in each and every html\npage because it was not allowed to leave it out. Thats what SegWit does\nright now. Even though it doesn't actually support changing it yet.\n\n### Reducing UTXO growth\n\nI suggest you read this \n[point](https://bitcoincore.org/en/2016/01/26/segwit-benefits/#reducing-utxo-growth)\nfor yourself, its rather interestingly technical and I'm sure many will not\nfully grasp the idea.  The bottom line of that they are claiming the\nUTXO database will avoid growing because SegWit doesn't allow more\ncustomers to be served.\n\nI don't even know how to respond to such a solution. Its throwing out the\nbaby with the bath water.\n\nDatabase technology has matured immensely over the last 20 years, the\ndatabase is tiny in comparison to what free and open source databases can\ndo today. Granted, the UTXO database is slightly unfit for a normal SQL\ndatabase, but telling customers to go elsewhere has never worked out for\nproducts in the long term.\n\n### Compact fraud proofs\n\nAgain, not really included in SegWit, just started as a basis. The exact\nsame basis is suggested for flexible transactions, and as such this is\nidentical.\n\n### What do we offer that SegWit doesn't offer?\n\n* A transaction becomes extensible. Future modifications are cheap.\n* A transaction gets smaller. Using less features also takes less space.\n* We only use one instead of 3 types of encodings for integers.\n* We remove technical debt and simplify implementations. SegWit does the\n  opposite.\n\n## Conclusions\n\nSegWit has some good ideas and some needed fixes. Stealing all the good\nideas and improving on them can be done, but require a hard fork. This post\nshows that the advantages are quite significant and certainly worth it.\n\nWe introduced a tagged data structure. Conceptually like JSON and XML in\nthat it is flexible, but the proposal is a compact and fast binary format.\nUsing the Flexible Transaction data format allows many future\ninnovations to be done cleanly in a consistent and, at a later stage, a\nmore backwards compatible manner than SegWit is able to do, even if given\nmuch more time. We realize that separating the fundamental issues that\nSegWit tries to fix all in one go, is possible and each becomes much lower\nrisk to Bitcoin as a system.\n\nAfter SegWit has been in the design stage for a year and still we find\nshow-stopping issues, delaying the release, I would argue that dropping\nthe requirement of staying backwards compatible should be on the table.\n\nThe introduction of the *Flexible Transaction* upgrade has big benefits\nbecause the transaction design becomes extensible.\nA hardfork is done once to allow us to do soft upgrades in the future.\n\nThe Flexible transaction solution lowers the amount of changes required in\nthe entire ecosystem. Not just for full nodes. Especially considering that\nmany tools and wallets use shared libraries between them to actually create\nand parse transactions.\n\nThe Flexible Transaction upgrade proposal should be considered by anyone\nthat cares about the protocol stability because its risk of failures\nduring or after upgrading is several magnitudes lower than SegWit is and\nit removes technical debt that will allow us to innovate better into the\nfuture.\n\nFlexible transactions are smaller, giving significant savings after pruning\nover SegWit.\n\n\nThanks"
            }
        ],
        "thread_summary": {
            "title": "Introducing Flexible Transactions.",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tom"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 18831
        }
    },
    {
        "title": "[bitcoin-dev] ScalingBitcoin 2015: Retarget - Call For Proposals Now Open",
        "thread_messages": [
            {
                "author": "Pindar Wong",
                "date": "2016-08-02T01:49:56",
                "message_text_only": "Dear All,\n\nThe Call for Proposals (CFP) for 'Scaling Bitcoin 2016: Retarget' is now\nopen.\n\nPlease see https://scalingbitcoin.org for details.\n\n*Important Dates*\n\nSept 2nd - Deadline for submissions to the CFP\nSept 23rd - Deadline for applicant acceptance notification\n\nSee you in Milan! (October 8th and 9th)\n\nCiao! :)\n\np.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160802/d876b20f/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "ScalingBitcoin 2015: Retarget - Call For Proposals Now Open",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Pindar Wong"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 505
        }
    },
    {
        "title": "[bitcoin-dev] BIP Number Request: Open Asset",
        "thread_messages": [
            {
                "author": "Nicolas Dorier",
                "date": "2016-08-02T05:21:49",
                "message_text_only": "Sorry, I completely forgot about having submitted the BIP as I was busy at\nthis time.\nThanks for the review.\n\nOpen Asset is actually not an abandoned project and is a protocol already\nused in production with multiple implementation.\nWallet: https://www.coinprism.com/\nImplementation C#: https://github.com/NicolasDorier/NBitcoin with heavy\ndocumentation (\nhttps://programmingblockchain.gitbooks.io/programmingblockchain/content/other_types_of_asset/colored_coins.html\n)\nImplementation Ruby: https://github.com/haw-itn/openassets-ruby/\nUsage stats: http://opreturn.org/\n\nConcerning whether or not we can put my name in the BIP, I'll ask the\noriginal author that I know personally.\n\n> Quite a bit ugly, giving a meaning to an input's pubkey script like that.\n> But more problematically: how can this work with other pubkey scripts?\n> Particularly relevant now that this old script format is being deprecated.\n> Another possible problem is that I don't see a way to provably guarantee\nan\n> asset issuance is final.\n\nYes, with open asset it is not possible to do provably limited issuance.\nThe scriptPubKey can be anything, not necessarily P2PK.\nIf you can spend the scriptPubkey, then you are the issuer.\n\n> And the assets attached to its inputs are destroyed? Or?\n\nCorrect, if you spend a colored output incorrectly, it is effectively\ndestroyed.\n\n> Is it intentional that the first case is \"parsable\", and the second\n\"valid\"?\n> I think these need to be better specified; for example, it is not so\nclear how\n> to reach if the OAP version number is something other than 1: is that\n> parsable? valid?\n\nThe terminology is correct we are parsing PUSHDATA, if there is a parsable\npushdata, the output is considered valid.\nIf there is multiple valid output, then we take the first one.\n\n> What determines the asset id? How would one issue and/or transfer multiple\n> asset ids in the same transaction?\n\nYou can't issue more than one asset type in a transaction. (as the asset\nissued is defined by the scriptPubKey of the first input)\nFor multiple transfer it is possible, imagine a transaction with the\nfollowing 3 inputs and 6 outputs:\n\nInputs: {0, 10a, 20b}\nOutputs: {5, OP_RETURN; 7; 3; 11; 9)\n\nInputs1: 0\nInputs2: Enqueue 10a in the queue ( {10a} )\nInput3: Enqueue 20b in the queue ( { 20b, 10a} )\n\nOutput1: Before OP_RETURN, so is issuance whose color is defined by the\nscriptPubKey of Input1. (say c)\nOutput2: No color (marker)\nOutput3: Dequeue 7a ( {20b, 3a} ), color output with a.\nOutput4: Dequeue 3a ( {20b} ), color output with a\nOutput5: Dequeue 11b ( {9b} ), color output with b\nOutput5: Dequeue 9b ( {0} ), color output with b\n\nFinally, outputs color are\nOutputs: {5c, OP_RETURN; 7a; 3a; 11b; 9b)\n\n> What if I have a transaction with 5 outputs, the marker output at\nposition 3,\n> and all 4 other outputs are to receive assets? Does the marker output get\n> skipped in the list (ie, the list is 4 elements long) or must it be set to\n> zero quantity (ie, the list is 5 elements long)?\n\nMarker output is skipped (explained in the example)\n\n> Addresses are not used for spending bitcoins, only for receiving them.\nThe way\n> this BIP uses inputs' pubkey script is extremely unusual and probably a\nbad\n> idea.\n\nActually there is no \"issuance address\", just the AssetId is defined by the\nscriptPubKey of the issuer.\n\n> As I understand it, this would require address reuse to setup, which is\nnot\n> supported behaviour and insecure.\n\nYes, it requires address reuse for issuing.\n\n> Won't an older client then accidentally destroy assets?\n\nCorrect. Actually we prevent users sending asset to wallet which does not\nsupport OA via another address scheme described in another document (\nhttps://github.com/OpenAssets/open-assets-protocol/blob/master/address-format.mediawiki\n)\n\nAs said, Open Asset is not a draft proposal and is already used in the wild\nsince 2014. We can't easily modify the protocol by now for improving it.\n\nPS:\nhttps://github.com/OpenAssets/open-assets-protocol/blob/master/specification.mediawiki\nis\nmore readable than a mail.\n\nNicolas,\n\nOn Tue, Jul 5, 2016 at 7:14 PM, James MacWhyte <macwhyte at gmail.com> wrote:\n\n> I'm curious to hear the answers to the questions Luke asked earlier. I\n> also read through the documentation and wasn't convinced it was thought out\n> well enough to actually build something on top of, but there's no reason it\n> can't get a number as a work-in-progress.\n>\n> I hope it does continue to get worked on, though. The lack of response or\n> discussion worries me that it might become an abandoned project.\n>\n> On Tue, Jul 5, 2016, 18:32 Luke Dashjr via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> On Tuesday, July 05, 2016 5:46:36 PM Peter Todd wrote:\n>> > On Thu, May 26, 2016 at 03:53:04AM +0000, Luke Dashjr via bitcoin-dev\n>> wrote:\n>> > > On Thursday, May 26, 2016 2:50:26 AM Nicolas Dorier via bitcoin-dev\n>> wrote:\n>> > > >   Author: Flavien Charlon <flavien at charlon.net>\n>> >\n>> > What's the status of this BIP? Will it be assigned?\n>>\n>> I was waiting for clarification on the Author thing, but Nicholas hasn't\n>> responded yet. I am unaware of any reason NOT to assign it, and there\n>> appear\n>> to be no objections, so let's call it BIP 160.\n>>\n>> Luke\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160801/7028265d/attachment.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2016-08-02T14:53:59",
                "message_text_only": "> As said, Open Asset is not a draft proposal and is already used in the\nwild since 2014. We can't easily modify the protocol by now for improving\nit.\n\nYou can, however, provide a new OA2.0 protocol that improves upon these\nissues, and assure that upgraded wallets maintain support for both\nversions.\n\nIt seems like OA's stance has *always *been to focus on integration, rather\nthan fixing the core protocol and then, by virtue of having the largest\nintegration, saying things like \"it's too late to turn back now\".    Colu\nand Chromaway/EPOBC also have stuff \"in the wild\".\n\nI would love to see an RFC-style standard \"multiple-colored-coin-protocol\"\nwritten by reps from all of the major protocols and that meta-merges the\nfeatures of these implementations - in collaboration with feedback from\ncore developers that understand the direction the protocol will be taking\nand the issues to avoid.   HTTP/TCP/IP MCCP/BTC\n\nAs it stands, investors have to install multiple wallets to deal with these\nvarying implementations.   Merging them into one \"meta-specification\"\nfairly soon might be in the best interests of the community and of future\nshareholders.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160802/f8abe85e/attachment.html>"
            },
            {
                "author": "Alex Mizrahi",
                "date": "2016-08-02T17:25:50",
                "message_text_only": ">\n> I would love to see an RFC-style standard \"multiple-colored-coin-protocol\"\n> written by reps from all of the major protocols and that meta-merges the\n> features of these implementations\n>\n\nWe actually tried to do that in 2014-2015, but that effort have failed...\nNobody was really interested in collaboration, each company only cared\nabout it's own product.\nEspecially Colu, they asked everyone for requirements, and then developed a\nnew protocol completely on their own without taking anyone's input.\n\nI'm not sure that merging the protocols makes sense, as some protocols\nvalue simplicity, and a combined protocol cannot have this feature.\n\nI don't think there is much interest in a merged colored coin protocol now.\nColu is moving away from colored coins, as far as I can tell.\nCoinSpark is now doing MultiChain closed-source private blockchain.\nCoinPrism also seems to be largely disinterested in colored coins.\n\nWe (ChromaWay) won't mind replacing EPOBC with something better, our\nsoftware could always support multiple different kernels so adding a new\nprotocol isn't a big deal for us.\n\nSo if somebody is interested in a new protocol please ping me.\n\nOne of ideas I have is to decouple input-output mapping/multiplexing from\ncoloring.\nSo one layer will describe a mapping, e.g. \"Inputs 0 and 1 should go into\noutputs 0, 1 and 2\".\nIn this case it will be possible to create more advanced protocols (e.g.\nwith support for 'smart contracts' and whatnot) while also keeping them\ncompatible with old ones to some extent, e.g. a wallet can safely engage in\np2ptrade or CoinJoin transactions without understanding all protocols used\nin a transaction.\n\n\n> - in collaboration with feedback from core developers that understand the\n> direction the protocol will be taking and the issues to avoid.\n>\n\nCore developers generally dislike things like colored coins, so I doubt\nthey are going to help.\n\nBlockstream is developing a sidechain with user-defined assets, so I guess\nthey see it as the preferred way of doing things:\nhttps://elementsproject.org/elements/asset-issuance/\n\n\n> As it stands, investors have to install multiple wallets to deal with\n> these varying implementations.\n>\n\nActually this can be solved without making a new \"merged protocol\": one can\njust implement a wallet which supports multiple protocols.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160802/2da95a58/attachment.html>"
            },
            {
                "author": "Nicolas Dorier",
                "date": "2016-08-13T02:25:04",
                "message_text_only": "I think that regardless of merits protocol or limitations of protocols,\nonce they become used and stable they merit their place as a BIP.\nI'd like to submit OA as is on flavien's repository, and update or reword\nthings once it is there. (so he can ACK easily and we can keep track of\nchanges instead of using mails back and forth)\nIt would be useful to have other colored coin protocols as well. (EPOBC and\nColu)\n\nOn Thu, Aug 4, 2016 at 9:37 PM, Flavien Charlon <\nflavien.charlon at coinprism.com> wrote:\n\n> Hi,\n>\n> > I would love to see an RFC-style standard \"multiple-colored-coin-protocol\"\n> written by reps from all of the major protocols and that meta-merges the\n> features of these implementations\n>\n> Alex summarizes the situation well. Efforts to come up with a\n> \"multiple-colored-coin-protocol\" have failed since the different\n> protocols take different assumptions and different tradeoffs and are built\n> for different use cases. In the end, we ended up exactly in the same\n> situation as the well known XKCD comic strip about standards (\n> https://xkcd.com/927/).\n>\n> > You can, however, provide a new OA2.0 protocol that improves upon these\n> issues, and assure that upgraded wallets maintain support for both versions.\n>\n> I don't think there is a point in doing that. This would just result in\n> having yet another \"standard\", which nobody uses. Open Assets 1.0 took 3\n> years to get where it is today, and is used by many companies across the\n> industry. It has well over 20 different implementations, some open source,\n> some proprietary.\n>\n> The goal of this process is to have OA 1.0 becoming the BIP since this is\n> the one people are using.\n>\n> > I was waiting for clarification on the Author thing, but Nicholas hasn't\n> responded yet. I am unaware of any reason NOT to assign it, and there\n> appear to be no objections, so let's call it BIP 160.\n>\n> Nicolas is proposing the BIP on my behalf. I'll ACK as needed but he can\n> drive the discussions.\n>\n> Best,\n> Flavien\n>\n> On Tue, Aug 2, 2016 at 6:25 PM, Alex Mizrahi via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> I would love to see an RFC-style standard \"multiple-colored-coin-protocol\"\n>>> written by reps from all of the major protocols and that meta-merges the\n>>> features of these implementations\n>>>\n>>\n>> We actually tried to do that in 2014-2015, but that effort have failed...\n>> Nobody was really interested in collaboration, each company only cared\n>> about it's own product.\n>> Especially Colu, they asked everyone for requirements, and then developed\n>> a new protocol completely on their own without taking anyone's input.\n>>\n>> I'm not sure that merging the protocols makes sense, as some protocols\n>> value simplicity, and a combined protocol cannot have this feature.\n>>\n>> I don't think there is much interest in a merged colored coin protocol\n>> now.\n>> Colu is moving away from colored coins, as far as I can tell.\n>> CoinSpark is now doing MultiChain closed-source private blockchain.\n>> CoinPrism also seems to be largely disinterested in colored coins.\n>>\n>> We (ChromaWay) won't mind replacing EPOBC with something better, our\n>> software could always support multiple different kernels so adding a new\n>> protocol isn't a big deal for us.\n>>\n>> So if somebody is interested in a new protocol please ping me.\n>>\n>> One of ideas I have is to decouple input-output mapping/multiplexing from\n>> coloring.\n>> So one layer will describe a mapping, e.g. \"Inputs 0 and 1 should go into\n>> outputs 0, 1 and 2\".\n>> In this case it will be possible to create more advanced protocols (e.g.\n>> with support for 'smart contracts' and whatnot) while also keeping them\n>> compatible with old ones to some extent, e.g. a wallet can safely engage in\n>> p2ptrade or CoinJoin transactions without understanding all protocols used\n>> in a transaction.\n>>\n>>\n>>> - in collaboration with feedback from core developers that understand\n>>> the direction the protocol will be taking and the issues to avoid.\n>>>\n>>\n>> Core developers generally dislike things like colored coins, so I doubt\n>> they are going to help.\n>>\n>> Blockstream is developing a sidechain with user-defined assets, so I\n>> guess they see it as the preferred way of doing things:\n>> https://elementsproject.org/elements/asset-issuance/\n>>\n>>\n>>> As it stands, investors have to install multiple wallets to deal with\n>>> these varying implementations.\n>>>\n>>\n>> Actually this can be solved without making a new \"merged protocol\": one\n>> can just implement a wallet which supports multiple protocols.\n>>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160813/41706ad9/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP Number Request: Open Asset",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Alex Mizrahi",
                "Erik Aronesty",
                "Nicolas Dorier"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 14406
        }
    },
    {
        "title": "[bitcoin-dev] A conversation with Dan Boneh (2016-08-01)",
        "thread_messages": [
            {
                "author": "Bryan Bishop",
                "date": "2016-08-02T07:20:08",
                "message_text_only": "Some Bitcoin developers and miners went to visit with Dan Boneh at Stanford\nearlier today, and I thought I would share what we talked about.\n\nTranscript:\nhttp://diyhpl.us/wiki/transcripts/2016-july-bitcoin-developers-miners-meeting/dan-boneh/\n\nTopics discussed include elliptic curve crypto, ECDSA, Schnorr signatures,\nsignature aggregation, BLS signature schemes, pairing crypto, group\nsignatures, block-level signature aggregation, transaction-level signature\naggregation, post-quantum crypto, quantum mining ASICs, provable solvency\nschemes, scrypt password hashing, and balloon hashing.\n\n(I would include the text directly but it's nearly 60 kilobytes in size and\npast the point where I am presently comfortable with gunking up other\nmailboxes.)\n\n- Bryan\nhttp://heybryan.org/\n1 512 203 0507\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160802/31e6d043/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "A conversation with Dan Boneh (2016-08-01)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Bryan Bishop"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 982
        }
    },
    {
        "title": "[bitcoin-dev] Fees and Accounts",
        "thread_messages": [
            {
                "author": "Marc Larue",
                "date": "2016-08-03T09:53:51",
                "message_text_only": "Hi,\n\nI have 2 problems with bitcoind that separately are not a problem but\ntogether they make the platform unusable for many projects.\n\nIf I have accounts I need to make sure the account holders do not \novercharge their account. To do this I can now use \"createrawtransaction() \n+ fundrawtransaction() + signrawtransaction()\" and then make sure the\ntransaction can be paid by an account.\n\nBut since you deprecated the accounts and there is no\nsendrawtransactionfrom() method; I either have to build my own account\nsystem (this is no picknick btw, since you need to track all incoming \nfunds to all addresses and having an integrated account system in bitcoind \nis 100% necessary to do this effectively).\n\nOr I might be able to go ahead and speculate that you will not be able to\nuntangle the account code and hack my bitcoind to have a sendfrom with a\nfixed fee parameter that overrides the size multiplication and I just do\nthe math before I send hoping that the transactions go through (this is \nbad but better than having accounts overcharge because they send dust that \ninduce high fees).\n\nI understand the privacy problems with using accounts for off-chain\nmicrostransactions but currently it's the best workable option.\n\nI hope you understand that I'm not trolling here, I have been mining since\n2011 on FPGAs and built bitcoinbankbook.com 2 years ago. When I descovered\nthat once transactions will require fees (back then they didn't) and that\nyour system is not able to handle fees with accounts, I stopped developing\neverything related to bitcoin.\n\nThere are probably 100s if not 1000s of developers in the same situation.\n\nYou can't just deprecate accounts like that because nobody likes the code.\nWithout accounts bitcoind is only a person-to-person manual client.\n\nTo build many-to-many automatic \"organisations\" on top of bitcoind you \nneed accounts and you need fees that are predictable.\n\nKind Regards,\n\n/marc"
            },
            {
                "author": "James MacWhyte",
                "date": "2016-08-03T18:33:41",
                "message_text_only": ">From what I've seen, most people build their own account system separately\n(including fee management) and just use bitcoind to send, receive, and\nverify transactions. It's not meant to be a drop-in solution for running an\nentire bitcoin deposit and withdrawal system, it just provides the bare\ntools required to build your own. If you need a pre-built solution, there\nare companies that provide those types of services as a platform (BitGo,\nfor example).\n\nOn Wed, Aug 3, 2016, 11:25 Marc Larue via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi,\n>\n> I have 2 problems with bitcoind that separately are not a problem but\n> together they make the platform unusable for many projects.\n>\n> If I have accounts I need to make sure the account holders do not\n> overcharge their account. To do this I can now use \"createrawtransaction()\n> + fundrawtransaction() + signrawtransaction()\" and then make sure the\n> transaction can be paid by an account.\n>\n> But since you deprecated the accounts and there is no\n> sendrawtransactionfrom() method; I either have to build my own account\n> system (this is no picknick btw, since you need to track all incoming\n> funds to all addresses and having an integrated account system in bitcoind\n> is 100% necessary to do this effectively).\n>\n> Or I might be able to go ahead and speculate that you will not be able to\n> untangle the account code and hack my bitcoind to have a sendfrom with a\n> fixed fee parameter that overrides the size multiplication and I just do\n> the math before I send hoping that the transactions go through (this is\n> bad but better than having accounts overcharge because they send dust that\n> induce high fees).\n>\n> I understand the privacy problems with using accounts for off-chain\n> microstransactions but currently it's the best workable option.\n>\n> I hope you understand that I'm not trolling here, I have been mining since\n> 2011 on FPGAs and built bitcoinbankbook.com 2 years ago. When I descovered\n> that once transactions will require fees (back then they didn't) and that\n> your system is not able to handle fees with accounts, I stopped developing\n> everything related to bitcoin.\n>\n> There are probably 100s if not 1000s of developers in the same situation.\n>\n> You can't just deprecate accounts like that because nobody likes the code.\n> Without accounts bitcoind is only a person-to-person manual client.\n>\n> To build many-to-many automatic \"organisations\" on top of bitcoind you\n> need accounts and you need fees that are predictable.\n>\n> Kind Regards,\n>\n> /marc\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160803/dce3245a/attachment.html>"
            },
            {
                "author": "James MacWhyte",
                "date": "2016-08-04T00:59:11",
                "message_text_only": "> Most people?\n\nI'm talking about services that are built to handle multiple accounts, like\nexchanges and payment processors.\n\n\n> You realize that you need to set up bitcoind to make an\n> external request on every reception of funds on any address in the whole\n> system.\n>\nNo, you don't. You can write a script that repeatedly asks bitcoind for the\nblock height, and when it increments you know a new block has been\nconfirmed. So then you request the transaction list from the latest block,\nand check each confirmed transaction against your database of receive/watch\naddresses. If there is a match, you record the transaction info in your\ndatabase so you can use it as an input later to create a spend transaction.\n\nYou could also use something like Bitpay's Insight to make interfacing with\nbitcoind easier.\n\n\n> It can't possibly scale, also we don't have the time to build an account\n> system for every bitcoind service. Imagine the loss of time, it's huge and\n> grows exponentially with adoption, or rather there is no adoption!\n>\nWhat are you trying to build?\n\n\n> Also external systems are not be trusted, specially not bitgo, did you\n> read any news in the last 24 hours?\n>\nI prefer to wait until all facts are in before I pass judgement. I think\nBitGo is an excellent company with a great track record. If used properly,\nthey are extremely secure. If you are worried about storing funds there\nlong time, don't--just use them to detect incoming payments and move your\nfunds elsewhere for long term storage.\n\n\n> /m\n>\n> On Wed, 3 Aug 2016, James MacWhyte wrote:\n>\n> >\n> > From what I've seen, most people build their own account system\n> separately\n> > (including fee management) and just use bitcoind to send, receive, and\n> > verify transactions. It's not meant to be a drop-in solution for running\n> an\n> > entire bitcoin deposit and withdrawal system, it just provides the bare\n> > tools required to build your own. If you need a pre-built solution, there\n> > are companies that provide those types of services as a platform (BitGo,\n> for\n> > example).\n> >\n> >\n> > On Wed, Aug 3, 2016, 11:25 Marc Larue via bitcoin-dev\n> > <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >       Hi,\n> >\n> >       I have 2 problems with bitcoind that separately are not a\n> >       problem but\n> >       together they make the platform unusable for many projects.\n> >\n> >       If I have accounts I need to make sure the account holders do\n> >       not\n> >       overcharge their account. To do this I can now use\n> >       \"createrawtransaction()\n> >       + fundrawtransaction() + signrawtransaction()\" and then make\n> >       sure the\n> >       transaction can be paid by an account.\n> >\n> >       But since you deprecated the accounts and there is no\n> >       sendrawtransactionfrom() method; I either have to build my own\n> >       account\n> >       system (this is no picknick btw, since you need to track all\n> >       incoming\n> >       funds to all addresses and having an integrated account system\n> >       in bitcoind\n> >       is 100% necessary to do this effectively).\n> >\n> >       Or I might be able to go ahead and speculate that you will not\n> >       be able to\n> >       untangle the account code and hack my bitcoind to have a\n> >       sendfrom with a\n> >       fixed fee parameter that overrides the size multiplication and I\n> >       just do\n> >       the math before I send hoping that the transactions go through\n> >       (this is\n> >       bad but better than having accounts overcharge because they send\n> >       dust that\n> >       induce high fees).\n> >\n> >       I understand the privacy problems with using accounts for\n> >       off-chain\n> >       microstransactions but currently it's the best workable option.\n> >\n> >       I hope you understand that I'm not trolling here, I have been\n> >       mining since\n> >       2011 on FPGAs and built bitcoinbankbook.com 2 years ago. When I\n> >       descovered\n> >       that once transactions will require fees (back then they didn't)\n> >       and that\n> >       your system is not able to handle fees with accounts, I stopped\n> >       developing\n> >       everything related to bitcoin.\n> >\n> >       There are probably 100s if not 1000s of developers in the same\n> >       situation.\n> >\n> >       You can't just deprecate accounts like that because nobody likes\n> >       the code.\n> >       Without accounts bitcoind is only a person-to-person manual\n> >       client.\n> >\n> >       To build many-to-many automatic \"organisations\" on top of\n> >       bitcoind you\n> >       need accounts and you need fees that are predictable.\n> >\n> >       Kind Regards,\n> >\n> >       /marc\n> >       _______________________________________________\n> >       bitcoin-dev mailing list\n> >       bitcoin-dev at lists.linuxfoundation.org\n> >       https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n> >\n> >\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160804/f3ae45ea/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Fees and Accounts",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Marc Larue",
                "James MacWhyte"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 9923
        }
    },
    {
        "title": "[bitcoin-dev] BIP clearing house addresses",
        "thread_messages": [
            {
                "author": "Matthew Roberts",
                "date": "2016-08-03T18:16:20",
                "message_text_only": "In light of the recent hack: what does everyone think of the idea of\ncreating a new address type that has a reversal key and settlement layer\nthat can be used to revoke transactions?\n\nYou could specify so that transactions \"sent\" from these addresses must\nreceive N confirmations before they can't be revoked, after which the\ntransaction is \"settled\" and the coins become redeemable from their\ndestination output. A settlement phase would also mean that a transaction's\nprogress was publicly visible so transparent fraud prevention and auditing\nwould become possible by anyone.\n\nThe reason why I bring this up is existing OP codes and TX types don't seem\nsuitable for a secure clearing mechanism; Nlocktimed TXs won't work for\nthis since you can't know ahead of time when and where a withdrawal needs\nto be made, plus there's still the potential for key mismanagement; Similar\nproblems with OP_CHECKLOCKTIMEVERIFY apply too \u2013 unless you keep a private\nkey around on the server which would defeat the purpose. The main use case\nhere, would be specifically to improve centralized exchange security by\nmaking it impossible for a hot wallet to be raided all at once.\n\nThoughts?\n\nSome existing background:\n\nhttp://hackingdistributed.com/2016/08/03/how-bitfinex-heist-could-have-been-avoided/\n-- Proposed the basic idea for a time-based clearing house but using\nblockchains directly, this is a much better idea than my own.\n\nroberts.pm/timechain -- My original paper written in 2015 which proposed a\nsimilar idea for secure wallet design but implemented using time-locked\nECDSA keys. Obviously a blockchain would work better for this.\n\nOther -- if the idea has already been brought up by other people, I\napologize.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160804/fe4335fb/attachment.html>"
            },
            {
                "author": "Troy Benjegerdes",
                "date": "2016-08-03T21:13:20",
                "message_text_only": "On Thu, Aug 04, 2016 at 04:16:20AM +1000, Matthew Roberts via bitcoin-dev wrote:\n> In light of the recent hack: what does everyone think of the idea of\n> creating a new address type that has a reversal key and settlement layer\n> that can be used to revoke transactions?\n\nI think many of us who think about human - computer interactions see the\nneed for a well defined process to roll back unexpected behavior in a computer\nsystem. My 2014 era proposal is https://bitbucket.org/tmagik/catoshi/issues/24\n\nThe fundamental assumption around cryptocoins is you have a secret (private\nkey) known only by you. Currently in bitcoin if that assumption changes, the\nresponse is blame the user. 'Incompetence, etc, etc'\n\nThis is bad business. For any cryptocurrency to really get mass market, we\nneed to provide our users with key revocation, to be used when the assumption\nabout being the only holder of a secret is broken.\n\nI think there's a hardfork-worthy choice here:\n\n1) implement reversal/revocation as an add-on feature\n2) implement reversal/revocation as a fundamental that every address gets.\n\nEthereum made a quick hardfork choice to reverse a *single* instance of\nunexpected behavior, and looks a lot like a bank bailout. We have the chance\nto learn from this mistake, and, apparently, make a lot of money trading\non both sides of the hardfork.\n\n> You could specify so that transactions \"sent\" from these addresses must\n> receive N confirmations before they can't be revoked, after which the\n> transaction is \"settled\" and the coins become redeemable from their\n> destination output. A settlement phase would also mean that a transaction's\n> progress was publicly visible so transparent fraud prevention and auditing\n> would become possible by anyone.\n> \n> The reason why I bring this up is existing OP codes and TX types don't seem\n> suitable for a secure clearing mechanism; Nlocktimed TXs won't work for\n> this since you can't know ahead of time when and where a withdrawal needs\n> to be made, plus there's still the potential for key mismanagement; Similar\n> problems with OP_CHECKLOCKTIMEVERIFY apply too ??? unless you keep a private\n> key around on the server which would defeat the purpose. The main use case\n> here, would be specifically to improve centralized exchange security by\n> making it impossible for a hot wallet to be raided all at once.\n> \n> Thoughts?\n> \n> Some existing background:\n> \n> http://hackingdistributed.com/2016/08/03/how-bitfinex-heist-could-have-been-avoided/\n> -- Proposed the basic idea for a time-based clearing house but using\n> blockchains directly, this is a much better idea than my own.\n> \n> roberts.pm/timechain -- My original paper written in 2015 which proposed a\n> similar idea for secure wallet design but implemented using time-locked\n> ECDSA keys. Obviously a blockchain would work better for this.\n> \n> Other -- if the idea has already been brought up by other people, I\n> apologize.\n\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Tier Nolan",
                "date": "2016-08-03T23:55:00",
                "message_text_only": "On Wed, Aug 3, 2016 at 7:16 PM, Matthew Roberts via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> The reason why I bring this up is existing OP codes and TX types don't\n> seem suitable for a secure clearing mechanism;\n>\n\nI think reversing transactions is not likely to be acceptable.  You could\nadd an opcode that requires that an output be set to something.\n\n[target script] SPENDTO\n\nThis would require that [target script] is the script for the corresponding\noutput.  This is a purely local check.\n\nFor example, if SPENDTO executes as part of the script for input 3, then it\nchecks that output 3 uses the given script as its scriptPubKey.  The value\nof input 3 and output 3 would have to be the same too.\n\nThis allows check sequence verify to be used to lock the spending script\nfor a while.  This doesn't allow reversal, but would give a 24 hour window\nwhere the spenders can reverse the transaction.\n\n[IF <1 day> CSV DROP <live public key> CHECKSIG ELSE <offline protected\nkey> CHECKSIG] SPENDTO <live public key2> CHECKSIG\n\nSomeone with the live public key can create a transaction that spends the\nfunds to the script in the square brackets.\n\nOnce that transaction hits the blockchain, then someone with the <offline\nprotected key> has 24 hours to spend the output before the person with the\nlive keys can send the funds onward.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160804/3e551535/attachment-0001.html>"
            },
            {
                "author": "Matthew Roberts",
                "date": "2016-08-04T02:07:06",
                "message_text_only": "This would honestly work. It forces the attacker to go through with the\nclearing phase which simultaneously makes it possible to \"cancel\" the TX\nthrough another logic branch before the timeout occurs. I'd say that would\nmeet the needs of a clearing mechanism / fraud prevention system for an\nexchange perfectly while requiring minimal changes to the software.\n\nVery, very smart idea. A++, would read again.\n\nOn Thu, Aug 4, 2016 at 9:55 AM, Tier Nolan via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Wed, Aug 3, 2016 at 7:16 PM, Matthew Roberts via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> The reason why I bring this up is existing OP codes and TX types don't\n>> seem suitable for a secure clearing mechanism;\n>>\n>\n> I think reversing transactions is not likely to be acceptable.  You could\n> add an opcode that requires that an output be set to something.\n>\n> [target script] SPENDTO\n>\n> This would require that [target script] is the script for the\n> corresponding output.  This is a purely local check.\n>\n> For example, if SPENDTO executes as part of the script for input 3, then\n> it checks that output 3 uses the given script as its scriptPubKey.  The\n> value of input 3 and output 3 would have to be the same too.\n>\n> This allows check sequence verify to be used to lock the spending script\n> for a while.  This doesn't allow reversal, but would give a 24 hour window\n> where the spenders can reverse the transaction.\n>\n> [IF <1 day> CSV DROP <live public key> CHECKSIG ELSE <offline protected\n> key> CHECKSIG] SPENDTO <live public key2> CHECKSIG\n>\n> Someone with the live public key can create a transaction that spends the\n> funds to the script in the square brackets.\n>\n> Once that transaction hits the blockchain, then someone with the <offline\n> protected key> has 24 hours to spend the output before the person with the\n> live keys can send the funds onward.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160804/4eda2f65/attachment.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2016-08-04T03:27:34",
                "message_text_only": "On Wednesday, August 03, 2016 6:16:20 PM Matthew Roberts via bitcoin-dev \nwrote:\n> In light of the recent hack: what does everyone think of the idea of\n> creating a new address type that has a reversal key and settlement layer\n> that can be used to revoke transactions?\n\nThis isn't something that makes sense at the address, since it represents the \nrecipient and not the sender. Transactions are not sent from addresses ever.\n\n> You could specify so that transactions \"sent\" from these addresses must\n> receive N confirmations before they can't be revoked, after which the\n> transaction is \"settled\" and the coins become redeemable from their\n> destination output. A settlement phase would also mean that a transaction's\n> progress was publicly visible so transparent fraud prevention and auditing\n> would become possible by anyone.\n\nThis is already possible. Just nLockTime your withdrawls for some future \nblock. Don't sign any transaction that isn't nLockTime'd at least N blocks \nbeyond the present tip.\n\nLuke"
            },
            {
                "author": "Andrew Johnson",
                "date": "2016-08-04T03:49:26",
                "message_text_only": "\"This is already possible. Just nLockTime your withdrawls for some future\nblock. Don't sign any transaction that isn't nLockTime'd at least N blocks\nbeyond the present tip.\"\n\nThis would have prevented the Bitfinex hack if BitGo did this, but it\nwouldn't have helped if the Bitfinex offline key had been compromised\ninstead of BitGo doing the 2nd sig.  In the BFX hack the TXNs were signed\nby Bitfinex's hot key and BitGo's key, they required 2 of 2.\n\nIf I'm understanding correctly, what Matthew is proposing is a new type of\nUTXO that is only valid to be spent as an nLockTime transaction and can be\nreversed by some sort of RBF-type transaction within that time period, I\nbelieve.\n\nBut I don't think this will work. What do you do if the keys are\ncompromised?  What's to stop the attacker from locking the coins up\nindefinitely by repeatedly broadcasting a refund transaction each time you\ntry to spend to an uncompromised address?\n\nYou'd need a third distinct key required for the refund TXN that's separate\nfrom the keys used to sign the initial nLockTime TXN.  And the refund TXN\nwould need to be able to go to a new address entirely.\n\nOn Aug 3, 2016 11:28 PM, \"Luke Dashjr via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Wednesday, August 03, 2016 6:16:20 PM Matthew Roberts via bitcoin-dev\n> wrote:\n> > In light of the recent hack: what does everyone think of the idea of\n> > creating a new address type that has a reversal key and settlement layer\n> > that can be used to revoke transactions?\n>\n> This isn't something that makes sense at the address, since it represents\n> the\n> recipient and not the sender. Transactions are not sent from addresses\n> ever.\n>\n> > You could specify so that transactions \"sent\" from these addresses must\n> > receive N confirmations before they can't be revoked, after which the\n> > transaction is \"settled\" and the coins become redeemable from their\n> > destination output. A settlement phase would also mean that a\n> transaction's\n> > progress was publicly visible so transparent fraud prevention and\n> auditing\n> > would become possible by anyone.\n>\n> This is already possible. Just nLockTime your withdrawls for some future\n> block. Don't sign any transaction that isn't nLockTime'd at least N blocks\n> beyond the present tip.\n>\n> Luke\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160803/c004566c/attachment.html>"
            },
            {
                "author": "s7r",
                "date": "2016-08-06T10:39:33",
                "message_text_only": "Hi,\n\nI can clearly see some advantages for such a feature, but it's kind of\nin conflict with Bitcoin's fundamental design. This design might be\nproblematic when it comes to hacks/thefts, but it's what gives Bitcoin\nstrength and make it differentiate from other currencies:\n\n* reversal of transactions is impossible\n* keep private keys private and safe. Lose them, it's like losing cash,\nyou can just forget about it.\n* while we try hard to make 0-conf as safe as possible (if there's no\nRBF flag on the transaction), we make it almost impossible or very very\nexpensive to reverse a confirmed transaction.\n\nAlso, we don't have a clear way to properly decide a good settlement\nperiod length. It doesn't fix the problem any more than nLockTime fixes\nit -- you can't know ahead of time when a withdraw needs to be made.\nFair enough, but even if the withdraw is made with a settlement layer,\nwill the user be able to spend it further immediately? Who will accept\nsuch an input and treat it as a payment if it can be reversed during the\nsettlement layer? So, if you can't know ahead of time when a withdraw\nneeds to be made (nLockTime) how can you know ahead of time+settlement\nperiod when a transaction needs to be declared irrevocable?\n\nThe linked page describes that merchants will never accept payments from\n'vaults', and it will take 24 hours for coins to be irreversible moved\noutside the 'vault'. This covers the part \"is the user able to spend a\ntransaction with settlement layer\" but it has security properties equal\nto nLockTime = 24 hours - you can't benefit and use the coins\nimmediately and in 24 hours price might go up or down in an undesirable\nway for a certain user. It however raises a lot of other questions: what\nif the attacker manages to steal both the private key and vault key (we\nhave strong reasons to assume this can happen: if you can't keep a\nprivate key safe, why would you be able to keep the vault key any\nsafer?) and starts a race with the actual user to unlock and lock back\nthe vault?\n\nI think this is a wrong approach. hacks and big losses are sad, but all\nthe time users / exchanges are to blame for wrong implementations or\nterrible security practices.\n\nThanks!\n\nOn 8/3/2016 9:16 PM, Matthew Roberts via bitcoin-dev wrote:\n> In light of the recent hack: what does everyone think of the idea of\n> creating a new address type that has a reversal key and settlement layer\n> that can be used to revoke transactions?\n> \n> You could specify so that transactions \"sent\" from these addresses must\n> receive N confirmations before they can't be revoked, after which the\n> transaction is \"settled\" and the coins become redeemable from their\n> destination output. A settlement phase would also mean that a\n> transaction's progress was publicly visible so transparent fraud\n> prevention and auditing would become possible by anyone.\n> \n> The reason why I bring this up is existing OP codes and TX types don't\n> seem suitable for a secure clearing mechanism; Nlocktimed TXs won't work\n> for this since you can't know ahead of time when and where a withdrawal\n> needs to be made, plus there's still the potential for key\n> mismanagement; Similar problems with OP_CHECKLOCKTIMEVERIFY apply too \u2013\n> unless you keep a private key around on the server which would defeat\n> the purpose. The main use case here, would be specifically to improve\n> centralized exchange security by making it impossible for a hot wallet\n> to be raided all at once.\n> \n> Thoughts?\n> \n> Some existing background:\n> \n> http://hackingdistributed.com/2016/08/03/how-bitfinex-heist-could-have-been-avoided/\n> -- Proposed the basic idea for a time-based clearing house but using\n> blockchains directly, this is a much better idea than my own.\n> \n> roberts.pm/timechain <http://roberts.pm/timechain> -- My original paper\n> written in 2015 which proposed a similar idea for secure wallet design\n> but implemented using time-locked ECDSA keys. Obviously a blockchain\n> would work better for this.\n> \n> Other -- if the idea has already been brought up by other people, I\n> apologize.\n> \n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160806/e7d9caab/attachment.sig>"
            },
            {
                "author": "Tier Nolan",
                "date": "2016-08-06T11:13:52",
                "message_text_only": "On Sat, Aug 6, 2016 at 11:39 AM, s7r via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> * reversal of transactions is impossible\n>\n\nI think it would be more accurate to say that the requirement is that\nreversal doesn't happen unexpectedly.\n\nIf it is clear in the script that reversal is possible, then obviously the\nrecipient can take that into consideration.\n\n\n> * keep private keys private and safe. Lose them, it's like losing cash,\n> you can just forget about it.\n>\n\nKey management is a thing.  Managing risk by keeping some keys offline is\nan important part of that.\n\n\n> * while we try hard to make 0-conf as safe as possible (if there's no\n> RBF flag on the transaction), we make it almost impossible or very very\n> expensive to reverse a confirmed transaction.\n>\n\nBitGo has an \"instant\" system where they promise to only sign one\ntransaction for a given output.  If you trust BitGo, then this is safe from\ndouble spending, since a double spender can't sign two transactions.\n\nIf BitGo had actually implemented a daily withdrawal limit, then their\nsystem ends up similar to cold storage.  Only 10% of the funds at Bitfinex\ncould have been withdrawn before manual intervention was required (with\noffline keys).\n\nWho will accept\n> such an input and treat it as a payment if it can be reversed during the\n> settlement layer?\n\n\nObviously, if a payment is reversible, then you treat it as a reversible\npayment.  The protection here relates to moving coins from the equivalent\nof cold storage to hot storage.\n\nIt is OK if it takes longer, since security is more important than\nconvenience for coins in cold storage.\n\n\n> The linked page describes that merchants will never accept payments from\n> 'vaults', and it will take 24 hours for coins to be irreversible moved\n> outside the 'vault'.\n\n\nThis relates to the reserves held by the exchange.  A portion of the funds\nare in hot storage with live keys.  These funds can be stolen by anyone who\ngets access to the servers.  The remaining funds are held in cold storage\nand they cannot be accessed unless you have the offline keys.  These funds\nare supposed to be hard to reach and require manual intervention.\n\nI think this is a wrong approach. hacks and big losses are sad, but all\n> the time users / exchanges are to blame for wrong implementations or\n> terrible security practices.\n>\n\nSetting up offline keys to act as firebreaks is part of good security\npractices.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160806/7bcdc140/attachment-0001.html>"
            },
            {
                "author": "Matthew Roberts",
                "date": "2016-08-07T05:35:49",
                "message_text_only": "I'm wondering if we're fully on the same page here. What I was thinking was\nthat this protection mechanism would be applied to the coins in the hot\nwallet (I wasn't talking about moving coins from the cold wallet to the hot\nwallet -- though such a mechanism is also needed.)\n\nWith the hot wallet you would have an output script that only allowed coins\nto be sent to a new transaction whose output script was then only\nredeemable after N confirmations (the output is relative time-locked) but\nwhich can also be recovered to a fixed fail-safe address before the\ntime-lock is reached (exactly like TierNolan already listed only the\ntime-locked destination shouldn't be completely fixed.) So the private key\nfor this hot wallet can still sign valid transactions to withdraw coins to\nany known destination and these transactions still reach the blockchain.\n\nThe key difference from a regular transaction is that the destination only\nhas access to the coins -after- the relative time-lock is reached (N blocks\nafter first confirm) so everyone knows where withdrawals are suppose to be\ngoing and how many coins are being withdrawn at any given time. Deposits to\nthe hot wallet would therefore need to be encumbered by the same protection\nso that from then on this time-lock to redeem coins can be applied to every\nnew transaction trying to move coins (withdrawn by a user of the exchange\nor sent to the cold wallet.)\n\nNotice we don't care about the destination in the TX script for the hot\nwallet because to process user's withdrawals we can't know ahead of time\nwhere they need to be sent (so it isn't possible to use a fixed address\nhere \u2013 though you might want to remove the clearing phase and set a fixed\naddress for coins sent from the hot wallet to the cold wallet.) The benefit\nhere comes from being able to see what withdrawals are being cleared,\nmatching those up to our expectations, and being able to \"cancel\"\nwithdrawals if they look suspicious, and you get the benefits for transfers\nmade from the hot wallet to the cold wallet and visa-versa.\n\n\nThis approach is good for a number of crucial services:\n\n1. Wallets could be built that grouped coins into different \"accounts\" with\ndifferent time-frames required for clearing / unlocking coins. Your savings\nor investment account would say -- take up to a week to clear -- whereas\nyour everyday account used for smaller purchases (with less money) would\nonly take a few hours. This could all be linked up to services that\nnotified you of your money being moved + made any phone calls needed to\nverify any larger transfers.\n\nThe service could also be entrusted with the \u201ccancellation\u201d key which can\nonly be used to move money to your offline fail-safe address. This would be\nquite an interesting way to mitigate fraud without the user having to be\ntrusted to do anything (except I suppose \u2013 not storing their recovery keys\nonline \u2026 but this could be partially solved with BIP 32-style \u201cmaster\u201d\npublic keys + hardware wallets + multi-sig, N factor auth, etc ...)\n\n2. Gambling websites that process a lot of Bitcoins also have a hot wallet\nwhich could be better protected by this.\n\n3. Various other e-commerce websites also accept Bitcoins directly. (Deep\nweb markets come to mind -- hey, people breaking the law need good security\ntoo.)\n\n4. Provable dead man's switches on the protocol level is another idea -- no\nneed to keep special time-locked transactions around and rely on them to be\nbroadcast = more reliable escrow services.\n\n5. And obviously exchange hot (and cold) wallets - enemy number 1.\n\nI hope that makes sense. I think I initially managed to confuse a lot of\npeople by talking about revoking transactions / \u201csettlement layers\u201d, etc.\nBut IMO: all of this needs to take place on the blockchain with a new set\nof OP_CODES and other than the fixed address issue with OP_SPENDTO, I think\nthe general idea would still work.\n\n\ntl; dr, A pseudo-reversal mechanism for transactions would mean that stolen\nprivate keys were no longer such an issue. This is desperately needed for\nexchanges, wallets, and other services that are forced to manage private\nkeys, and whose users (I argue) already expect for this to be possible (or\nat least will when they're hacked.)\n\n\n\n\nOn Sat, Aug 6, 2016 at 9:13 PM, Tier Nolan via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Sat, Aug 6, 2016 at 11:39 AM, s7r via bitcoin-dev <bitcoin-dev at lists.\n> linuxfoundation.org> wrote:\n>\n>> * reversal of transactions is impossible\n>>\n>\n> I think it would be more accurate to say that the requirement is that\n> reversal doesn't happen unexpectedly.\n>\n> If it is clear in the script that reversal is possible, then obviously the\n> recipient can take that into consideration.\n>\n>\n>> * keep private keys private and safe. Lose them, it's like losing cash,\n>> you can just forget about it.\n>>\n>\n> Key management is a thing.  Managing risk by keeping some keys offline is\n> an important part of that.\n>\n>\n>> * while we try hard to make 0-conf as safe as possible (if there's no\n>> RBF flag on the transaction), we make it almost impossible or very very\n>> expensive to reverse a confirmed transaction.\n>>\n>\n> BitGo has an \"instant\" system where they promise to only sign one\n> transaction for a given output.  If you trust BitGo, then this is safe from\n> double spending, since a double spender can't sign two transactions.\n>\n> If BitGo had actually implemented a daily withdrawal limit, then their\n> system ends up similar to cold storage.  Only 10% of the funds at Bitfinex\n> could have been withdrawn before manual intervention was required (with\n> offline keys).\n>\n> Who will accept\n>> such an input and treat it as a payment if it can be reversed during the\n>> settlement layer?\n>\n>\n> Obviously, if a payment is reversible, then you treat it as a reversible\n> payment.  The protection here relates to moving coins from the equivalent\n> of cold storage to hot storage.\n>\n> It is OK if it takes longer, since security is more important than\n> convenience for coins in cold storage.\n>\n>\n>> The linked page describes that merchants will never accept payments from\n>> 'vaults', and it will take 24 hours for coins to be irreversible moved\n>> outside the 'vault'.\n>\n>\n> This relates to the reserves held by the exchange.  A portion of the funds\n> are in hot storage with live keys.  These funds can be stolen by anyone who\n> gets access to the servers.  The remaining funds are held in cold storage\n> and they cannot be accessed unless you have the offline keys.  These funds\n> are supposed to be hard to reach and require manual intervention.\n>\n> I think this is a wrong approach. hacks and big losses are sad, but all\n>> the time users / exchanges are to blame for wrong implementations or\n>> terrible security practices.\n>>\n>\n> Setting up offline keys to act as firebreaks is part of good security\n> practices.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160807/c4d377f1/attachment-0001.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2016-08-07T22:59:34",
                "message_text_only": "I still feel like you're better off getting rid of \"hot wallets\" and use\nlightning-esqe networks to route orders.  I don't think either speed or\nflexibility is an issue there.\n\nIMO, the point of Bitcoin is to avoid the centralization that seems to be\nhappening on the network now.   By making \"hot wallets\" more \"secure\", we\nencourage things to keep heading downhill with massive centralized\ncrappy-security exchanges.\n\nBecause, ultimately, there's no security that will prevent an inside job.\nAnd all of these thefts have, in my opinion, been at least partly inside\njobs.\n\nAnd centralization is the actually demon that needs slaying here.\n\nA client-side library with P2P order routing, tether.to + bitcoin ....  and\nyou've got a decentralized exchange... with orders matched to users\ndirectly, and channel-trades executed instantly.   And \"market makers\"\nrunning nodes to facilitate routing, etc.\n\nNo center... nothing to shut down or sue... and no one holds your funds.\nThat's a real Bitcoin exchange.\n\n\n\nOn Sun, Aug 7, 2016 at 1:35 AM, Matthew Roberts via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I'm wondering if we're fully on the same page here. What I was thinking\n> was that this protection mechanism would be applied to the coins in the hot\n> wallet (I wasn't talking about moving coins from the cold wallet to the hot\n> wallet -- though such a mechanism is also needed.)\n>\n> With the hot wallet you would have an output script that only allowed\n> coins to be sent to a new transaction whose output script was then only\n> redeemable after N confirmations (the output is relative time-locked) but\n> which can also be recovered to a fixed fail-safe address before the\n> time-lock is reached (exactly like TierNolan already listed only the\n> time-locked destination shouldn't be completely fixed.) So the private key\n> for this hot wallet can still sign valid transactions to withdraw coins to\n> any known destination and these transactions still reach the blockchain.\n>\n> The key difference from a regular transaction is that the destination only\n> has access to the coins -after- the relative time-lock is reached (N blocks\n> after first confirm) so everyone knows where withdrawals are suppose to be\n> going and how many coins are being withdrawn at any given time. Deposits to\n> the hot wallet would therefore need to be encumbered by the same protection\n> so that from then on this time-lock to redeem coins can be applied to every\n> new transaction trying to move coins (withdrawn by a user of the exchange\n> or sent to the cold wallet.)\n>\n> Notice we don't care about the destination in the TX script for the hot\n> wallet because to process user's withdrawals we can't know ahead of time\n> where they need to be sent (so it isn't possible to use a fixed address\n> here \u2013 though you might want to remove the clearing phase and set a fixed\n> address for coins sent from the hot wallet to the cold wallet.) The benefit\n> here comes from being able to see what withdrawals are being cleared,\n> matching those up to our expectations, and being able to \"cancel\"\n> withdrawals if they look suspicious, and you get the benefits for transfers\n> made from the hot wallet to the cold wallet and visa-versa.\n>\n>\n> This approach is good for a number of crucial services:\n>\n> 1. Wallets could be built that grouped coins into different \"accounts\"\n> with different time-frames required for clearing / unlocking coins. Your\n> savings or investment account would say -- take up to a week to clear --\n> whereas your everyday account used for smaller purchases (with less money)\n> would only take a few hours. This could all be linked up to services that\n> notified you of your money being moved + made any phone calls needed to\n> verify any larger transfers.\n>\n> The service could also be entrusted with the \u201ccancellation\u201d key which can\n> only be used to move money to your offline fail-safe address. This would be\n> quite an interesting way to mitigate fraud without the user having to be\n> trusted to do anything (except I suppose \u2013 not storing their recovery keys\n> online \u2026 but this could be partially solved with BIP 32-style \u201cmaster\u201d\n> public keys + hardware wallets + multi-sig, N factor auth, etc ...)\n>\n> 2. Gambling websites that process a lot of Bitcoins also have a hot wallet\n> which could be better protected by this.\n>\n> 3. Various other e-commerce websites also accept Bitcoins directly. (Deep\n> web markets come to mind -- hey, people breaking the law need good security\n> too.)\n>\n> 4. Provable dead man's switches on the protocol level is another idea --\n> no need to keep special time-locked transactions around and rely on them to\n> be broadcast = more reliable escrow services.\n>\n> 5. And obviously exchange hot (and cold) wallets - enemy number 1.\n>\n> I hope that makes sense. I think I initially managed to confuse a lot of\n> people by talking about revoking transactions / \u201csettlement layers\u201d, etc.\n> But IMO: all of this needs to take place on the blockchain with a new set\n> of OP_CODES and other than the fixed address issue with OP_SPENDTO, I think\n> the general idea would still work.\n>\n>\n> tl; dr, A pseudo-reversal mechanism for transactions would mean that\n> stolen private keys were no longer such an issue. This is desperately\n> needed for exchanges, wallets, and other services that are forced to manage\n> private keys, and whose users (I argue) already expect for this to be\n> possible (or at least will when they're hacked.)\n>\n>\n>\n>\n> On Sat, Aug 6, 2016 at 9:13 PM, Tier Nolan via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> On Sat, Aug 6, 2016 at 11:39 AM, s7r via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> * reversal of transactions is impossible\n>>>\n>>\n>> I think it would be more accurate to say that the requirement is that\n>> reversal doesn't happen unexpectedly.\n>>\n>> If it is clear in the script that reversal is possible, then obviously\n>> the recipient can take that into consideration.\n>>\n>>\n>>> * keep private keys private and safe. Lose them, it's like losing cash,\n>>> you can just forget about it.\n>>>\n>>\n>> Key management is a thing.  Managing risk by keeping some keys offline is\n>> an important part of that.\n>>\n>>\n>>> * while we try hard to make 0-conf as safe as possible (if there's no\n>>> RBF flag on the transaction), we make it almost impossible or very very\n>>> expensive to reverse a confirmed transaction.\n>>>\n>>\n>> BitGo has an \"instant\" system where they promise to only sign one\n>> transaction for a given output.  If you trust BitGo, then this is safe from\n>> double spending, since a double spender can't sign two transactions.\n>>\n>> If BitGo had actually implemented a daily withdrawal limit, then their\n>> system ends up similar to cold storage.  Only 10% of the funds at Bitfinex\n>> could have been withdrawn before manual intervention was required (with\n>> offline keys).\n>>\n>> Who will accept\n>>> such an input and treat it as a payment if it can be reversed during the\n>>> settlement layer?\n>>\n>>\n>> Obviously, if a payment is reversible, then you treat it as a reversible\n>> payment.  The protection here relates to moving coins from the equivalent\n>> of cold storage to hot storage.\n>>\n>> It is OK if it takes longer, since security is more important than\n>> convenience for coins in cold storage.\n>>\n>>\n>>> The linked page describes that merchants will never accept payments from\n>>> 'vaults', and it will take 24 hours for coins to be irreversible moved\n>>> outside the 'vault'.\n>>\n>>\n>> This relates to the reserves held by the exchange.  A portion of the\n>> funds are in hot storage with live keys.  These funds can be stolen by\n>> anyone who gets access to the servers.  The remaining funds are held in\n>> cold storage and they cannot be accessed unless you have the offline keys.\n>> These funds are supposed to be hard to reach and require manual\n>> intervention.\n>>\n>> I think this is a wrong approach. hacks and big losses are sad, but all\n>>> the time users / exchanges are to blame for wrong implementations or\n>>> terrible security practices.\n>>>\n>>\n>> Setting up offline keys to act as firebreaks is part of good security\n>> practices.\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160807/528041a5/attachment.html>"
            },
            {
                "author": "Matthew Roberts",
                "date": "2016-08-08T00:48:52",
                "message_text_only": "Not everyone who uses centralized exchanges are there to obtain the\ncurrency though. A large portion are speculators who need to be able to\nenter and exit complex positions in milliseconds and don't care about\ndecentralization, security, and often even the asset that they're buying.\n\nTry telling everyone who currently uses Btc-e to go do their margin trading\nover lightning channels, for example. They're not going to want to do that\nbecause these exchanges are already meeting their needs perfectly well, and\nlike I argued before -- it would be very hard to do that as efficiently\nwith any other design (there are major drawbacks for traders with a\ndecentralized exchange.)\n\nLike it or not, these exchanges play an integral role in the current\nBitcoin eco-system since they allow us to most efficiently discover price\nand help improve liquidity. A decentralized exchange isn't going to stop\nany more centralized exchanges from being hacked even if they are more\nsecure simply because traders don't want to use them.\n\n(Sorry for the duplicate message Erik, I haven't used many mailing lists\nbefore. I think I have the hang of it now though :) )\n\nOn Mon, Aug 8, 2016 at 8:59 AM, Erik Aronesty <erik at q32.com> wrote:\n\n> I still feel like you're better off getting rid of \"hot wallets\" and use\n> lightning-esqe networks to route orders.  I don't think either speed or\n> flexibility is an issue there.\n>\n> IMO, the point of Bitcoin is to avoid the centralization that seems to be\n> happening on the network now.   By making \"hot wallets\" more \"secure\", we\n> encourage things to keep heading downhill with massive centralized\n> crappy-security exchanges.\n>\n> Because, ultimately, there's no security that will prevent an inside\n> job.   And all of these thefts have, in my opinion, been at least partly\n> inside jobs.\n>\n> And centralization is the actually demon that needs slaying here.\n>\n> A client-side library with P2P order routing, tether.to + bitcoin ....\n> and you've got a decentralized exchange... with orders matched to users\n> directly, and channel-trades executed instantly.   And \"market makers\"\n> running nodes to facilitate routing, etc.\n>\n> No center... nothing to shut down or sue... and no one holds your funds.\n> That's a real Bitcoin exchange.\n>\n>\n>\n> On Sun, Aug 7, 2016 at 1:35 AM, Matthew Roberts via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> I'm wondering if we're fully on the same page here. What I was thinking\n>> was that this protection mechanism would be applied to the coins in the hot\n>> wallet (I wasn't talking about moving coins from the cold wallet to the hot\n>> wallet -- though such a mechanism is also needed.)\n>>\n>> With the hot wallet you would have an output script that only allowed\n>> coins to be sent to a new transaction whose output script was then only\n>> redeemable after N confirmations (the output is relative time-locked) but\n>> which can also be recovered to a fixed fail-safe address before the\n>> time-lock is reached (exactly like TierNolan already listed only the\n>> time-locked destination shouldn't be completely fixed.) So the private key\n>> for this hot wallet can still sign valid transactions to withdraw coins to\n>> any known destination and these transactions still reach the blockchain.\n>>\n>> The key difference from a regular transaction is that the destination\n>> only has access to the coins -after- the relative time-lock is reached (N\n>> blocks after first confirm) so everyone knows where withdrawals are suppose\n>> to be going and how many coins are being withdrawn at any given time.\n>> Deposits to the hot wallet would therefore need to be encumbered by the\n>> same protection so that from then on this time-lock to redeem coins can be\n>> applied to every new transaction trying to move coins (withdrawn by a user\n>> of the exchange or sent to the cold wallet.)\n>>\n>> Notice we don't care about the destination in the TX script for the hot\n>> wallet because to process user's withdrawals we can't know ahead of time\n>> where they need to be sent (so it isn't possible to use a fixed address\n>> here \u2013 though you might want to remove the clearing phase and set a fixed\n>> address for coins sent from the hot wallet to the cold wallet.) The benefit\n>> here comes from being able to see what withdrawals are being cleared,\n>> matching those up to our expectations, and being able to \"cancel\"\n>> withdrawals if they look suspicious, and you get the benefits for transfers\n>> made from the hot wallet to the cold wallet and visa-versa.\n>>\n>>\n>> This approach is good for a number of crucial services:\n>>\n>> 1. Wallets could be built that grouped coins into different \"accounts\"\n>> with different time-frames required for clearing / unlocking coins. Your\n>> savings or investment account would say -- take up to a week to clear --\n>> whereas your everyday account used for smaller purchases (with less money)\n>> would only take a few hours. This could all be linked up to services that\n>> notified you of your money being moved + made any phone calls needed to\n>> verify any larger transfers.\n>>\n>> The service could also be entrusted with the \u201ccancellation\u201d key which can\n>> only be used to move money to your offline fail-safe address. This would be\n>> quite an interesting way to mitigate fraud without the user having to be\n>> trusted to do anything (except I suppose \u2013 not storing their recovery keys\n>> online \u2026 but this could be partially solved with BIP 32-style \u201cmaster\u201d\n>> public keys + hardware wallets + multi-sig, N factor auth, etc ...)\n>>\n>> 2. Gambling websites that process a lot of Bitcoins also have a hot\n>> wallet which could be better protected by this.\n>>\n>> 3. Various other e-commerce websites also accept Bitcoins directly. (Deep\n>> web markets come to mind -- hey, people breaking the law need good security\n>> too.)\n>>\n>> 4. Provable dead man's switches on the protocol level is another idea --\n>> no need to keep special time-locked transactions around and rely on them to\n>> be broadcast = more reliable escrow services.\n>>\n>> 5. And obviously exchange hot (and cold) wallets - enemy number 1.\n>>\n>> I hope that makes sense. I think I initially managed to confuse a lot of\n>> people by talking about revoking transactions / \u201csettlement layers\u201d, etc.\n>> But IMO: all of this needs to take place on the blockchain with a new set\n>> of OP_CODES and other than the fixed address issue with OP_SPENDTO, I think\n>> the general idea would still work.\n>>\n>>\n>> tl; dr, A pseudo-reversal mechanism for transactions would mean that\n>> stolen private keys were no longer such an issue. This is desperately\n>> needed for exchanges, wallets, and other services that are forced to manage\n>> private keys, and whose users (I argue) already expect for this to be\n>> possible (or at least will when they're hacked.)\n>>\n>>\n>>\n>>\n>> On Sat, Aug 6, 2016 at 9:13 PM, Tier Nolan via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> On Sat, Aug 6, 2016 at 11:39 AM, s7r via bitcoin-dev <\n>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>>> * reversal of transactions is impossible\n>>>>\n>>>\n>>> I think it would be more accurate to say that the requirement is that\n>>> reversal doesn't happen unexpectedly.\n>>>\n>>> If it is clear in the script that reversal is possible, then obviously\n>>> the recipient can take that into consideration.\n>>>\n>>>\n>>>> * keep private keys private and safe. Lose them, it's like losing cash,\n>>>> you can just forget about it.\n>>>>\n>>>\n>>> Key management is a thing.  Managing risk by keeping some keys offline\n>>> is an important part of that.\n>>>\n>>>\n>>>> * while we try hard to make 0-conf as safe as possible (if there's no\n>>>> RBF flag on the transaction), we make it almost impossible or very very\n>>>> expensive to reverse a confirmed transaction.\n>>>>\n>>>\n>>> BitGo has an \"instant\" system where they promise to only sign one\n>>> transaction for a given output.  If you trust BitGo, then this is safe from\n>>> double spending, since a double spender can't sign two transactions.\n>>>\n>>> If BitGo had actually implemented a daily withdrawal limit, then their\n>>> system ends up similar to cold storage.  Only 10% of the funds at Bitfinex\n>>> could have been withdrawn before manual intervention was required (with\n>>> offline keys).\n>>>\n>>> Who will accept\n>>>> such an input and treat it as a payment if it can be reversed during the\n>>>> settlement layer?\n>>>\n>>>\n>>> Obviously, if a payment is reversible, then you treat it as a reversible\n>>> payment.  The protection here relates to moving coins from the equivalent\n>>> of cold storage to hot storage.\n>>>\n>>> It is OK if it takes longer, since security is more important than\n>>> convenience for coins in cold storage.\n>>>\n>>>\n>>>> The linked page describes that merchants will never accept payments from\n>>>> 'vaults', and it will take 24 hours for coins to be irreversible moved\n>>>> outside the 'vault'.\n>>>\n>>>\n>>> This relates to the reserves held by the exchange.  A portion of the\n>>> funds are in hot storage with live keys.  These funds can be stolen by\n>>> anyone who gets access to the servers.  The remaining funds are held in\n>>> cold storage and they cannot be accessed unless you have the offline keys.\n>>> These funds are supposed to be hard to reach and require manual\n>>> intervention.\n>>>\n>>> I think this is a wrong approach. hacks and big losses are sad, but all\n>>>> the time users / exchanges are to blame for wrong implementations or\n>>>> terrible security practices.\n>>>>\n>>>\n>>> Setting up offline keys to act as firebreaks is part of good security\n>>> practices.\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/39344b7f/attachment.html>"
            },
            {
                "author": "Matthew Roberts",
                "date": "2016-08-04T04:53:18",
                "message_text_only": ">This is already possible. Just nLockTime your withdrawls for some future\nblock. Don't sign any transaction that isn't nLockTime'd at least N blocks\nbeyond the present tip.\n\nThe problem with nLockTimed transactions is a centralized exchange isn't\ngoing to know ahead of time where those locked transactions need to go or\nthe amount that needs to be signed so you will end up having to keep the\nprivate key around. If there was a way to create these transactions offline\nwith special SIG_HASH flags (and I don't think there is) there's nothing\nabout nLockTime that forces that the transactions be broadcast straight\naway and plus: since the TXs aren't confirmed until the lock-time expires\nthey can be overwritten anyway.\n\nI think given the requirements that a centralized exchange has: TierNolan's\nidea is the best so far. Essentially, you have a new type of output script\nthat forces the redeemer to use a designated output script template in the\nredeeming transaction, meaning that you can actually force people to send\ncoins into another transaction with \"relative lock-timed\" outputs. The new\ntransaction can then only be redeemed at the destination after the relative\nlock-time expires OR it can be moved before-hand to a designated off-line\nrecovery address. This is much better than creating a new transaction\nsystem, IMO.\n\n>And the refund TXN would need to be able to go to a new address entirely.\n\nAgreed.\n\nOn Thu, Aug 4, 2016 at 1:49 PM, Andrew Johnson <andrew.johnson83 at gmail.com>\nwrote:\n\n> \"This is already possible. Just nLockTime your withdrawls for some future\n> block. Don't sign any transaction that isn't nLockTime'd at least N blocks\n> beyond the present tip.\"\n>\n> This would have prevented the Bitfinex hack if BitGo did this, but it\n> wouldn't have helped if the Bitfinex offline key had been compromised\n> instead of BitGo doing the 2nd sig.  In the BFX hack the TXNs were signed\n> by Bitfinex's hot key and BitGo's key, they required 2 of 2.\n>\n> If I'm understanding correctly, what Matthew is proposing is a new type of\n> UTXO that is only valid to be spent as an nLockTime transaction and can be\n> reversed by some sort of RBF-type transaction within that time period, I\n> believe.\n>\n> But I don't think this will work. What do you do if the keys are\n> compromised?  What's to stop the attacker from locking the coins up\n> indefinitely by repeatedly broadcasting a refund transaction each time you\n> try to spend to an uncompromised address?\n>\n> You'd need a third distinct key required for the refund TXN that's\n> separate from the keys used to sign the initial nLockTime TXN.  And the\n> refund TXN would need to be able to go to a new address entirely.\n>\n> On Aug 3, 2016 11:28 PM, \"Luke Dashjr via bitcoin-dev\" <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> On Wednesday, August 03, 2016 6:16:20 PM Matthew Roberts via bitcoin-dev\n>> wrote:\n>> > In light of the recent hack: what does everyone think of the idea of\n>> > creating a new address type that has a reversal key and settlement layer\n>> > that can be used to revoke transactions?\n>>\n>> This isn't something that makes sense at the address, since it represents\n>> the\n>> recipient and not the sender. Transactions are not sent from addresses\n>> ever.\n>>\n>> > You could specify so that transactions \"sent\" from these addresses must\n>> > receive N confirmations before they can't be revoked, after which the\n>> > transaction is \"settled\" and the coins become redeemable from their\n>> > destination output. A settlement phase would also mean that a\n>> transaction's\n>> > progress was publicly visible so transparent fraud prevention and\n>> auditing\n>> > would become possible by anyone.\n>>\n>> This is already possible. Just nLockTime your withdrawls for some future\n>> block. Don't sign any transaction that isn't nLockTime'd at least N blocks\n>> beyond the present tip.\n>>\n>> Luke\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160804/9a441ba6/attachment-0001.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2016-08-04T12:43:34",
                "message_text_only": "https://www.reddit.com/r/Bitcoin/comments/4w016b/use_of_payment_channels_to_mitigate_exchange_risk/\n\nOn Thu, Aug 4, 2016 at 12:53 AM, Matthew Roberts via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> >This is already possible. Just nLockTime your withdrawls for some future\n> block. Don't sign any transaction that isn't nLockTime'd at least N blocks\n> beyond the present tip.\n>\n> The problem with nLockTimed transactions is a centralized exchange isn't\n> going to know ahead of time where those locked transactions need to go or\n> the amount that needs to be signed so you will end up having to keep the\n> private key around. If there was a way to create these transactions offline\n> with special SIG_HASH flags (and I don't think there is) there's nothing\n> about nLockTime that forces that the transactions be broadcast straight\n> away and plus: since the TXs aren't confirmed until the lock-time expires\n> they can be overwritten anyway.\n>\n> I think given the requirements that a centralized exchange has:\n> TierNolan's idea is the best so far. Essentially, you have a new type of\n> output script that forces the redeemer to use a designated output script\n> template in the redeeming transaction, meaning that you can actually force\n> people to send coins into another transaction with \"relative lock-timed\"\n> outputs. The new transaction can then only be redeemed at the destination\n> after the relative lock-time expires OR it can be moved before-hand to a\n> designated off-line recovery address. This is much better than creating a\n> new transaction system, IMO.\n>\n> >And the refund TXN would need to be able to go to a new address entirely.\n>\n> Agreed.\n>\n> On Thu, Aug 4, 2016 at 1:49 PM, Andrew Johnson <andrew.johnson83 at gmail.com\n> > wrote:\n>\n>> \"This is already possible. Just nLockTime your withdrawls for some future\n>> block. Don't sign any transaction that isn't nLockTime'd at least N blocks\n>> beyond the present tip.\"\n>>\n>> This would have prevented the Bitfinex hack if BitGo did this, but it\n>> wouldn't have helped if the Bitfinex offline key had been compromised\n>> instead of BitGo doing the 2nd sig.  In the BFX hack the TXNs were signed\n>> by Bitfinex's hot key and BitGo's key, they required 2 of 2.\n>>\n>> If I'm understanding correctly, what Matthew is proposing is a new type\n>> of UTXO that is only valid to be spent as an nLockTime transaction and can\n>> be reversed by some sort of RBF-type transaction within that time period, I\n>> believe.\n>>\n>> But I don't think this will work. What do you do if the keys are\n>> compromised?  What's to stop the attacker from locking the coins up\n>> indefinitely by repeatedly broadcasting a refund transaction each time you\n>> try to spend to an uncompromised address?\n>>\n>> You'd need a third distinct key required for the refund TXN that's\n>> separate from the keys used to sign the initial nLockTime TXN.  And the\n>> refund TXN would need to be able to go to a new address entirely.\n>>\n>> On Aug 3, 2016 11:28 PM, \"Luke Dashjr via bitcoin-dev\" <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> On Wednesday, August 03, 2016 6:16:20 PM Matthew Roberts via bitcoin-dev\n>>> wrote:\n>>> > In light of the recent hack: what does everyone think of the idea of\n>>> > creating a new address type that has a reversal key and settlement\n>>> layer\n>>> > that can be used to revoke transactions?\n>>>\n>>> This isn't something that makes sense at the address, since it\n>>> represents the\n>>> recipient and not the sender. Transactions are not sent from addresses\n>>> ever.\n>>>\n>>> > You could specify so that transactions \"sent\" from these addresses must\n>>> > receive N confirmations before they can't be revoked, after which the\n>>> > transaction is \"settled\" and the coins become redeemable from their\n>>> > destination output. A settlement phase would also mean that a\n>>> transaction's\n>>> > progress was publicly visible so transparent fraud prevention and\n>>> auditing\n>>> > would become possible by anyone.\n>>>\n>>> This is already possible. Just nLockTime your withdrawls for some future\n>>> block. Don't sign any transaction that isn't nLockTime'd at least N\n>>> blocks\n>>> beyond the present tip.\n>>>\n>>> Luke\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160804/dffea869/attachment.html>"
            },
            {
                "author": "Tier Nolan",
                "date": "2016-08-08T09:56:24",
                "message_text_only": "On Mon, Aug 8, 2016 at 1:48 AM, Matthew Roberts <matthew at roberts.pm> wrote:\n\n> Not everyone who uses centralized exchanges are there to obtain the\n> currency though. A large portion are speculators who need to be able to\n> enter and exit complex positions in milliseconds and don't care about\n> decentralization, security, and often even the asset that they're buying.\n>\n\nCentralized exchanges also allow for things like limit orders.  You don't\neven have to be logged in and they can execute trades.  This couldn't be\ndone with channels.\n\n> Try telling everyone who currently uses Btc-e to go do their margin\n> trading over lightning channels, for example.\n>\n\nUsing channels and a centralized exchange gets many of the benefits of a\ndistributed exchange.\n\nThe channel allows instant funding while allowing the customer to have full\ncontrol over the funds.  The customer could fund the channel and then move\nmoney to the exchange when needed.\n\nEven margin account holders might like the fact that it is clear which\nfunds are under their direct control and which funds are held by the\nexchange.\n\nIf they are using bitcoin funds as collateral for a margin trade, then\ninherently the exchange has to have control over those funds.  A 2 of 3\nsystem where the customer, exchange and a 3rd party arbitration agency\nholds keys might be acceptable to the exchange.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/7634409e/attachment-0001.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2016-08-08T10:09:24",
                "message_text_only": "I'm not convinced you need to hold people's funds to provide those\nfeatures. Maybe the millisecond thing.   But 99 out of 100 traders would\naccept a 100 millisecond latency in exchange for 0 counterparty risk.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/436cdea4/attachment.html>"
            },
            {
                "author": "Tier Nolan",
                "date": "2016-08-08T11:01:57",
                "message_text_only": "With channels and the exchange acting as hub, you can do instant trades\nbetween altcoins.\n\nThis doesn't work with fiat accounts.  A \"100% reserve\" company could issue\nfiat tokens.  The exchange could then trade those tokens.\n\nThis eliminates the counter-party risk for the exchange.  If the exchange\ndies, you still have your (alt)coins and also fiat tokens.\n\nThere is still risk that the token company could go bankrupt though.  This\ncould be mitigated by that company requiring only \"cashing out\" tokens to\naccounts which have been verified.\n\nThe company could set up a blockchain where it signed the blocks rather\nthan mining and could get money from transaction fees and also minting fees\n(say it charges 1% for minting new tokens)\n\nI wonder what how the law would work for that.  It isn't actually doing\ntrading, it is just issuing tokens and redeeming them.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/bba6a71c/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP clearing house addresses",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Troy Benjegerdes",
                "Andrew Johnson",
                "s7r",
                "Tier Nolan",
                "Luke Dashjr",
                "Erik Aronesty",
                "Matthew Roberts"
            ],
            "messages_count": 16,
            "total_messages_chars_count": 57770
        }
    },
    {
        "title": "[bitcoin-dev] Mimblewimble: non-interactive coinjoin, signature aggregation and confidential transactions",
        "thread_messages": [
            {
                "author": "Bryan Bishop",
                "date": "2016-08-03T18:41:27",
                "message_text_only": "Someone dropped this document in -wizards the other day:\nhttp://5pdcbgndmprm4wud.onion/mimblewimble.txt\nhttp://diyhpl.us/~bryan/papers2/bitcoin/mimblewimble.txt\n\nSome commentary:\nhttp://gnusha.org/bitcoin-wizards/2016-08-02.log\nhttp://gnusha.org/bitcoin-wizards/2016-08-03.log\nhttps://www.reddit.com/r/Bitcoin/comments/4vub3y/mimblewimble_noninteractive_coinjoin_and_better/\n\n- Bryan\nhttp://heybryan.org/\n1 512 203 0507\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160803/136b7b2b/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Mimblewimble: non-interactive coinjoin, signature aggregation and confidential transactions",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Bryan Bishop"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 602
        }
    },
    {
        "title": "[bitcoin-dev] Progress On Hardfork Proposals Following The Segwit Blocksize Increase",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2016-08-05T19:54:16",
                "message_text_only": "Repost by request from my blog, apologies for the somewhat screwy formatting!\n\n\n---\nlayout: post\ntitle:  \"Progress On Hardfork Proposals Following The Segwit Blocksize Increase\"\ndate:   2016-08-05\ntags:\n- bitcoin\n- hardfork\n- segwit\n---\n\nWith segwit getting close to its initial testnet release in Bitcoin Core\nv0.13.0 - expected to be followed soon by a mainnet release in Bitcoin Core\nv0.13.1 - I thought it'd be a good idea to go over work being done on a\npotential hard-fork to follow it, should the Bitcoin community decide to accept\nthe segwit proposal.\n\nFirst of all, to recap, in addition to many other improvements such as fixing\ntransaction malleability, fixing the large transaction signature verification\nDoS attack, providing a better way to upgrade the scripting system in the\nfuture, etc. segwit increases the maximum blocksize to 4MB. However, because\nit's a soft-fork - a backwards compatible change to the protocol - only witness\n(signature) data can take advantage of this blocksize increase; non-witness\ndata is still limited to 1MB total per block. With current transaction patterns\nit's expected that blocks post-segwit won't use all 4MB of serialized data\nallowed by the post-segwit maximum blocksize limit.\n\nSecondly, there's two potential upgrades to the Bitcoin protocol that will\nfurther reduce the amount of witness data most transactions need: [Schnorr\nsignatures](https://bitcoinmagazine.com/articles/the-power-of-schnorr-the-signature-algorithm-to-increase-bitcoin-s-scale-and-privacy-1460642496) and [BLS aggregate signatures](http://diyhpl.us/wiki/transcripts/2016-july-bitcoin-developers-miners-meeting/dan-boneh/).\nBasically, both these improvements allow multiple signatures to be combined,\nthe former on a per-transaction level, and the latter on a per-block level.\n\n[Last February](https://medium.com/@bitcoinroundtable/bitcoin-roundtable-consensus-266d475a61ff)\nsome of the mining community and some of the developer community got together to discuss potential\nhard-forks, with the aim of coming up with a reasonable proposal to take to the\nwider community for further discussion and consensus building. Let's look at\nwhere that effort has lead.\n\n## Ethereum: Lessons to be learned\n\nBut first, Ethereum. Or as some have quipped, the Etherea:\n\n<blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\">The Battle for Etherea. <a href=\"https://t.co/2ATQRQRXnH\">https://t.co/2ATQRQRXnH</a></p>&mdash; Samson Mow (@Excellion) <a href=\"https://twitter.com/Excellion/status/759677608753627136\">July 31, 2016</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nIf you've been following the crypto-currency space at all recently, you\nprobably know that the Ethereum community has split in two following a very\ncontroversial hard-fork to the Ethereum protocol, To make a long story short, a\nunintended feature in a smart-contract called \"The DAO\" was exploited by a\nas-yet-unknown individual to drain around $50 million worth of the Ethereum\ncurrency from the contract. While \"white-hat attackers\" did manage to recover a\nmajority of the funds in the DAO, a hard-fork was proposed to rewrite the\nEthereum ledger to recover all funds - an action that many, [including myself](/2016/ethereum-dao-bailout-vote),\nhave described as a bailout.\n\nThe result has been a big mess. This isn't the place to talk about all the\ndrama that's followed in depth, but I think it's fair to say that the Ethereum\ncommunity found out the hard way that just because you give a new protocol the\nsame name as an existing protocol, that doesn't force everyone to use it. As of\nwriting, what a month ago was called \"Ethereum\" - Ethereum Classic - has 20% of\nthe hashing power as the bailout chain, and peaked only two or three days ago\nat around 30%. As for market cap, while the combined total for the two chains\nis similar to the one chain pre-fork, this is likely misleading: there's\nprobably a lot of coins on both chains that aren't actually accessible and\ndon't represent liquid assets on the market. Instead, there's a good chance a\nsignificant amount of value has been lost.\n\nIn particular, both chains have suffered significantly from transaction replay\nissues. Basically, due to the way the Ethereum protocol is designed - in\nparticular the fact that Ethereum isn't based on a UTXO model - when the\nEthereum chain split transactions on one chain were very often valid on another\nchain. Both attacks and accidents can lead to transactions from one chain\nending up broadcast to others, leading to unintentional spends. This wasn't an\nunexpected problem:\n\n<blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\">.<a href=\"https://twitter.com/petertoddbtc\">@petertoddbtc</a> we knew it would happen weeks before launch, we didn&#39;t want to implement replay-protection b.c. of implementation complexity</p>&mdash; Vlad Zamfir (@VladZamfir) <a href=\"https://twitter.com/VladZamfir/status/759552287157133313\">July 31, 2016</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n...and it's lead to costly losses. Among others Coinbase has lost [an unknown amount of\nfunds](https://twitter.com/eiaine/status/758560296017416194) that they may [have to buy back](https://twitter.com/brian_armstrong/status/760991445352386560). Even worse, BTC-e [lost pretty much their entire balance](https://www.reddit.com/r/EthereumClassic/comments/4v2d6j/btce_dear_clients_btces_official_standpoint_on/d5v2f3t)\nof original Ethereum coins - apparently becoming insolvent - and instead of\nreturning customer funds, they decided to [declare the original Ethereum chain a scam](https://btc-e.com/news/230) instead.\n\nA particularly scary thing about this kind of problem is that it can lead to\nartificial demand for a chain that would otherwise die: for all we know\nCoinbase has been scrambling behind the scenes to buy replacement ether to make\nup for the ether that it lost due to replay issues.\n\nMore generally, the fact that the community split shows the difficulty - and\nunpredictability - of achieving consensus, maintaining consensus, and\nmeasuring consensus. For instance, while the Ethereum community did do a coin\nvote [as I suggested](/2016/ethereum-dao-bailout-vote), turnout was extremely\nlow - around 5% - with a significant minority in opposition (and note that\nexchanges' coins were blacklisted from the vote due to technical reasons).\nAdditionally, the miner vote also had low turnout, and again, significant\nminority opposition.\n\nWith regard to [drama](https://twitter.com/petertoddbtc/status/761506592827125760) resulting\nfrom a coin split, something I think not many in the technical community had\nconsidered, is that exchanges can have perverse incentives to encourage it. The\nsplit resulted in significant trading volume on the pre-fork, status quo,\nEthereum chain, which of course is very profitable for exchanges. The second\nexchange to list the status-quo chain was Poloniex, who have over 100\nBitcoin-denominated markets for a very wide variety of niche currencies - their\nbusiness is normally niche currencies that don't necessarily have wide appeal.\n\nFinally, keep in mind that while this has been bad for Ethereum, it'd be even\nworse for Bitcoin: unlike Ethereum, Bitcoin actually has non-trivial usage in\ncommerce, by users who aren't necessarily keeping up to date with the latest\ndrama^H^H^H^H^H news. We need to proceed carefully with any\nnon-backwards-compatible changes if we're to keep those users informed, and\nprotect them from sending and receiving coins on chains that they didn't mean\ntoo.\n\n\n## Splitting Safely\n\nSo how can we split safely? Luke Dashjr has written both a\n[BIP](https://github.com/luke-jr/bips/blob/bip-mmhf/bip-mmhf.mediawiki), and\n[preliminary code](https://github.com/luke-jr/bitcoin/compare/bc94b87\u2026luke-jr:hardfork2016)\nto do a combination of a hard-fork, and a soft-fork.\n\nThis isn't a new idea, in fact Luke [posted it](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-February/012377.html)\nto the bitcoin-dev mailing list last February, and it's been known as an option\nfor years prior; I personally mentioned it [on this blog](/2016/forced-soft-forks) last January.\n\nThe idea is basically that we do a hard-fork - an incompatible rule change - by\n\"wrapping\" it in a soft-fork so that all nodes are forced to choose one chain\nor the other. The new soft-forked rule-set is simple: no transactions are\nallowed at all. Assuming that a majority of hashing power chooses to adopt the\nfork, nodes that haven't made a decision are essentially 51% attacked and will\nfollow an empty chain, unable to make any transactions at all.\n\nFor those who choose not to adopt the hard-fork, they need to themselves do a\nhard-fork to continue transacting. This can be as simple as blacklisting the\nblock where the two sides diverged, or something more complex like a\nproof-of-work change.\n\nOn the plus side, Luke's proposal maximizes safety in many respects: so long as\na majority of hashing power adopts the fork no-one will accidentally accept\nfunds from a chain that they didn't intend too.\n\n\n### Giving Everyone A Voice\n\nIt's notable that what Luke calls a \"soft-hardfork\" has also been called a\n\"forced soft-fork\" by myself, as well as an \"evil fork\" by many others - what\nname you give it is a matter of perspective. From a technical point of view,\nthe idea is a 51% attack against those who choose not to support the new\nprotocol; it's notable that when I pointed this out to some miners they were\nvery concerned about the precedent this could set if done badly.\n\nInterestingly, due to implementation details Ethereum hard-fork was similar to\nLuke's suggestion: pre-fork Ethereum clients would generally fail to start due\nto an implementation flaw - in most cases - so everyone was forced to get new\nsoftware. Yet, Ethereum still split into two economically distinct coins.\n\nThis shows that attempting to kill an unwanted side of a split chain via 51%\nattack isn't a panacea: people can and will choose to use the chain they want\nto if there's controversy. So we'd be wise to try to achieve broad community\nconsensus first.\n\nInterestingly, Tom Harding's [Hard fork opt-out bits](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-July/012917.html)\nproposal can also be used to measure consent. Basically, as an anti-replay\nmechanism, wallets could begin (un)setting a nSequence bit in transaction\ninputs that a hard-fork would make _invalid_, while simultaneously a soft-fork\nwould make (un)setting a different bit invalid already; the hard-fork would\nmake that second bit _valid_ (users of nLockTime would (un)set neither bit,\nmaking their transactions valid on both chains). This allows us to easily\nmeasure readiness for a fork by looking at what percentage of transactions are\nsetting the anti-replay bit correctly - a sign that their running software that\nis ready for a future hard-fork.\n\nSecondly, I've been working on coming up with more concrete mechanisms based on\nsignaling/voting proportional to coins held, in particular, out-of-band\nmechanisms based on signed messages and probabilistic sampling that could\npotentially offer better privacy and censorship resistance, and give \"hodlers\"\nwho aren't necessarily doing frequent transactions a voice as well. My recent\nwork on [making TXO commitments more practical](/2016/delayed-txo-commitments)\nis part of that effort.\n\n\n### UTXO Size\n\nSegwit's witness-data-discount has the important effect of discouraging the\ncreation of new UTXOs, in favor of spending existing ones, hopefully resulting\nin [reduced UTXO set growth](https://bitcoincore.org/en/2016/01/26/segwit-benefits/#reducing-utxo-growth).\nAs a full copy of the UTXO set is (currently) a mandatory requirement for\nrunning a full node, even with pruning, it's important that we keep UTXO growth\nrates sustainable.\n\nMatt Corallo has been doing work on finding better ways to properly account for\nthe cost to the network as a whole of UTXO creation, and he has told me he'll\nbe publishing that work soon. In addition, I've been working on a longer-term\nsolution in the form of [TXO commitments](/2016/delayed-txo-commitments), which\nhopefully can eliminate the problem entirely, by allowing UTXO's to be\narchived, shifting the burden of storing them to wallets rather than all\nBitcoin nodes. Additionally, Bram Cohen has been [working on](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-June/012758.html)\nmaking the necessary data structures for TXO commitments faster in of\nthemselves by optimizing cache access patterns.\n\n\n### Block Propagation Latency\n\nA significant concern with any blocksize increase - including segwit - is that\nthe higher bandwidth requirements will encourage centralization of hashing\npower due to the disproportionate effect higher latency has on stale rates\nbetween large and small miners. Matt Corallo has done a significant amount of\nwork recently on mitigating this effect with his [compact blocks](https://bitcoincore.org/en/2016/06/07/compact-blocks-faq/) - to be\nreleased in v0.13.0 - and his next-gen block relay network\n[FIBRE](http://bluematt.bitcoin.ninja/2016/07/07/relay-networks/).\n\nAdditionally, I've been [doing research](http://bluematt.bitcoin.ninja/2016/07/07/relay-networks/) to better\nunderstanding the limitations of these approaches in adversarial,\nsemi-adversarial, and \"uncaring\" scenarios.\n\n\n### Anti-Replay\n\nI mentioned Tom Harding's work, above; I'll also mention that Gregory Maxwell\nproposed a generic - and very robust - solution to anti-replay: have\ntransactions commit to a recent but not too recent (older than ~100 blocks or so) block hash.\nWhile this has some potential downsides in a large reorg - transactions may\nbecome permanently invalid due to differing block hashes - so long as the block\nhashes committed too aren't too recently the idea does very robustly fix replay\nattacks across chains, in a way that's completely generic no matter how many\nforks happen. For example, a reasonable way to deploy would be to have wallet's\nrefuse to make transactions for the first day or two after a hard-fork, and\nthen use a post-fork blockhash in all transactions to ensure they can't be\nreplayed on an unwanted chain.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160805/6460c660/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Progress On Hardfork Proposals Following The Segwit Blocksize Increase",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Peter Todd"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 14617
        }
    },
    {
        "title": "[bitcoin-dev] *Changing* the blocksize limit",
        "thread_messages": [
            {
                "author": "Chris Priest",
                "date": "2016-08-06T14:15:22",
                "message_text_only": "Because the blocksize limit is denominated in bytes, miners choose\ntransactions to add to a block based on fee/byte ratio. This mean that\nif you make a transaction with a lot of inputs, your transaction will\nbe very big, an you'll have a to pay a lot in fees to get that\ntransaction included in a block.\n\nFor a long time I have been of the belief that it is a flaw in bitcoin\nthat you have to pay more to move coins that are sent to you via small\nvalue UTXOs, compared to coins sent to you through a single high\nvalues UTXO. There are many legitimate uses of bitcoin where you get\nthe money is very small increments (such as microtransactions). This\nis the basis for my \"Wildcard inputs\" proposal now known as BIP131.\nThis BIP was rejected because it requires a database index, which\npeople thought would make bitcoin not scale, which I think is complete\nmalarkey, but it is what it is. It has recently occurred to me a way\nto achieve the same effect without needing the database index.\n\nIf the blocksize limit was denominated in outputs, miners would choose\ntransactions based on maximum fee per output. This would essentially\nmake it free to include an input to a transaction.\n\nIf the blocksize limit were removed and replaced with a \"block output\nlimit\", it would have multiple positive effects. First off, like I\nsaid earlier, it would incentivize microtransactions. Secondly it\nwould serve to decrease the UTXO set. As I described in the text of\nBIP131, as blocks fill up and fees rise, there is a \"minimum\nprofitability to include an input to a transaction\" which increases.\nAt the time I wrote BIP131, it was something like 2 cents: Any UTXO\nworth less than 2 cents was not economical to add to a transaction,\nand therefore likely to never be spent (unless blocks get bigger and\nfee's drop). This contributes to the \"UTXO bloat problem\" which a lot\nof people talk about being a big problem.\n\nIf the blocksize limit is to be changed to a block output limit, the\nnumber the limit is set to should be roughly the amount of outputs\nthat are found in 1MB blocks today. This way, the change should be\nconsidered non-controversial. I think its silly that some people think\nits a good thing to keep usage restricted, but again, it is what it\nis.\n\nBlocks can be bigger than 1MB, but the extra data in the block will\nnot result in more people using bitcoin, but rather existing users\nspending inputs to decrease the UTXO set.\n\nIt would also bring about data that can be used to determine how to\nscale bitcoin in the future. For instance, we have *no idea* how the\nnetwork will handle blocks bigger than 1MB, simply because the network\nhas never seen blocks bigger than 1MB. People have set up private\nnetworks for testing bigger blocks, but thats not quite the same as\n1MB+ blocks on the actual live network. This change will allow us to\nsee what actually happens when bigger blocks gets published.\n\nWhy is this change a bad idea?"
            },
            {
                "author": "Luke Dashjr",
                "date": "2016-08-06T18:52:55",
                "message_text_only": "This is exactly what segwit does...\n\nOn Saturday, August 06, 2016 2:15:22 PM Chris Priest via bitcoin-dev wrote:\n> Because the blocksize limit is denominated in bytes, miners choose\n> transactions to add to a block based on fee/byte ratio. This mean that\n> if you make a transaction with a lot of inputs, your transaction will\n> be very big, an you'll have a to pay a lot in fees to get that\n> transaction included in a block.\n> \n> For a long time I have been of the belief that it is a flaw in bitcoin\n> that you have to pay more to move coins that are sent to you via small\n> value UTXOs, compared to coins sent to you through a single high\n> values UTXO. There are many legitimate uses of bitcoin where you get\n> the money is very small increments (such as microtransactions). This\n> is the basis for my \"Wildcard inputs\" proposal now known as BIP131.\n> This BIP was rejected because it requires a database index, which\n> people thought would make bitcoin not scale, which I think is complete\n> malarkey, but it is what it is. It has recently occurred to me a way\n> to achieve the same effect without needing the database index.\n> \n> If the blocksize limit was denominated in outputs, miners would choose\n> transactions based on maximum fee per output. This would essentially\n> make it free to include an input to a transaction.\n> \n> If the blocksize limit were removed and replaced with a \"block output\n> limit\", it would have multiple positive effects. First off, like I\n> said earlier, it would incentivize microtransactions. Secondly it\n> would serve to decrease the UTXO set. As I described in the text of\n> BIP131, as blocks fill up and fees rise, there is a \"minimum\n> profitability to include an input to a transaction\" which increases.\n> At the time I wrote BIP131, it was something like 2 cents: Any UTXO\n> worth less than 2 cents was not economical to add to a transaction,\n> and therefore likely to never be spent (unless blocks get bigger and\n> fee's drop). This contributes to the \"UTXO bloat problem\" which a lot\n> of people talk about being a big problem.\n> \n> If the blocksize limit is to be changed to a block output limit, the\n> number the limit is set to should be roughly the amount of outputs\n> that are found in 1MB blocks today. This way, the change should be\n> considered non-controversial. I think its silly that some people think\n> its a good thing to keep usage restricted, but again, it is what it\n> is.\n> \n> Blocks can be bigger than 1MB, but the extra data in the block will\n> not result in more people using bitcoin, but rather existing users\n> spending inputs to decrease the UTXO set.\n> \n> It would also bring about data that can be used to determine how to\n> scale bitcoin in the future. For instance, we have *no idea* how the\n> network will handle blocks bigger than 1MB, simply because the network\n> has never seen blocks bigger than 1MB. People have set up private\n> networks for testing bigger blocks, but thats not quite the same as\n> 1MB+ blocks on the actual live network. This change will allow us to\n> see what actually happens when bigger blocks gets published.\n> \n> Why is this change a bad idea?\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Peter Todd",
                "date": "2016-08-09T02:21:29",
                "message_text_only": "On Sat, Aug 06, 2016 at 07:15:22AM -0700, Chris Priest via bitcoin-dev wrote:\n> If the blocksize limit is to be changed to a block output limit, the\n> number the limit is set to should be roughly the amount of outputs\n> that are found in 1MB blocks today. This way, the change should be\n\nThe largest output on testnet is a bit under 1MB, and encodes a certain\nwell-known love song...\n\nIn many circumstances(1) miners have an incentive to create larger blocks that\ntake their competitors longer to receive and validate, so protocol-level block\nlimits need to take all these potential DoS vectors into account; serialized\nsize is one of the most fundemental things that needs to be limited.\n\n> considered non-controversial. I think its silly that some people think\n> its a good thing to keep usage restricted, but again, it is what it\n> is.\n\nAs mentioned above, and explained in detail in my recent blog post(1),\nrestrictions are needed to keep a level playing field between all miners.\n\n1) https://petertodd.org/2016/block-publication-incentives-for-miners\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/d79e1812/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "*Changing* the blocksize limit",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Chris Priest",
                "Luke Dashjr",
                "Peter Todd"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 7644
        }
    },
    {
        "title": "[bitcoin-dev] Authentication BIP",
        "thread_messages": [
            {
                "author": "Jonas Schnelli",
                "date": "2016-08-08T15:00:51",
                "message_text_only": "Hi\n\nAs already mentioned in the recent BIP151 thread\n(https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-June/012826.html),\nI propose the following authentication scheme to basically allow MITM\ndetection and rejection in conjunction with BIP151.\n\nThe proposed authentication BIP does require BIP151.\n\nThe propose BIP does assume, node operators want to build trusted\nconnections for various reasons.\n\nBIPs mediawiki github page available here:\nhttps://github.com/bitcoin/bips/compare/master...jonasschnelli:2016/07/auth_bip?expand=1\n\n===================================================\n\n  BIP: ???\n  Title: Peer Authentication\n  Author: Jonas Schnelli <dev at jonasschnelli.ch>\n  Status: Draft\n  Type: Standards Track\n  Created: 2016-03-23\n\n== Abstract ==\n\nThis BIP describes a way how peers can authenticate \u2013 without opening\nfingerprinting possibilities \u2013 to other peers to guarantee ownership\nand/or allowing to access additional or limited services.\n\n== Motivation ==\n\nWe assume peer operators want to limit the access of different services\nor increase datastream priorities to a selective subset of peers. Also\nwe assume peers want to connect to specific peers to broadcast or filter\ntransactions (or similar action that reveals sensitive informations) and\ntherefore they want to authenticate the remote peer and make sure that\nthey have not connected to a MITM.\n\nBenefits with peer authentication:\n* Peers could detect MITM attacks when connecting to known peers\n* Peers could allow resource hungry transaction filtering only to\nspecific peers\n* Peers could allow access to sensitive information that can lead to\nnode fingerprinting (fee estimation)\n* Peers could allow custom message types (private extensions) to\nauthenticated peers\n\nA simple authentication scheme based on elliptic cryptography will allow\npeers to identify each other and selective allow access to restricted\nservices or reject the connection if the identity could not be verified.\n\n== Specification ==\n\nThe authentication scheme proposed in this BIP uses ECDSA, ___secrets\nwill never be transmitted___.\n\n___Authentication initialization must only happen if encrypted channels\nhave been established (according to BIP-151 [1]).___\n\nThe ___encryption-session-ID___ is available once channels are encrypted\n(according to BIP-151 [1]).\n\nThe identity-public-keys used for the authentication must be pre-shared\nover a different channel (Mail/PGP, physical paper exchange, etc.). This\nBIP does not cover a \"trust on first use\" (TOFU) concept.\n\nThe authentication state must be kept until the encryption/connection\nterminates.\n\nOnly one authentication process is allowed per connection.\nRe-authenticate require re-establishing the connection.\n\n=== Known-peers and authorized-peers database ===\nEach peer that supports p2p authentication must provide two users\neditable \"databases\"\n\n# ___known-peers___ contains known identity-public-keys together with a\nnetwork identifier (IP & port), similar to the \"known-host\" file\nsupported by openssh.\n# ___authorized-peers___ contains authorized identity-public-keys\n\n=== Local identity key management ===\nEach peer can configure one identity-key (ECC, 32 bytes) per listening\nnetwork interface (IPv4, IPv6, tor).\nThe according identity-public-key can be shared over a different channel\nwith other node-operators (or non-validating clients) to grant\nauthorized access.\n\n=== Authentication procedure ===\nAuthentication after this BIP will require both sides to authenticate.\nSignatures/public-keys will only be revealed if the remote peer could\nprove that they already know the remote identity-public-key.\n\n# -> Requesting peer sends `AUTHCHALLENGE` (hash)\n# <- Responding peer sends `AUTHREPLY` (signature)\n# -> Requesting peer sends `AUTHPROPOSE` (hash)\n# <- Responding peer sends `AUTHCHALLENGE` (hash)\n# -> Requesting peer sends `AUTHREPLY` (signature)\n\nFor privacy reasons, dropping the connection or aborting during the\nauthentication process must not be possible.\n\n=== `AUTHCHALLENGE` message ===\nA peer can send an authentication challenge to see if the responding\npeer can produce a valid signature with the expected responding peers\nidentity-public-key by sending an `AUTHCHALLENGE`-message to the remote\npeer.\n\nThe responding peer needs to check if the hash matches the hash\ncalculated with his own local identity-public-key. Fingerprinting the\nrequesting peer is not possible.\n\n32bytes challenge-hash `hash(encryption-session-ID || challenge_type ||\nremote-peers-expected-identity-public-key)`\n\n`challenge_type` is a single character. `i` if the\n`AUTHCHALLENGE`-message is the first, requesting challenge or `r` if\nit's the second, remote peers challenge message.\n\n=== `AUTHREPLY` message ===\nA peer must reply an `AUTHCHALLENGE`-message with an `AUTHREPLY`-message.\n\n\n| 64bytes || signature || normalized comp.-signature || A signature of\nthe encryption-session-ID done with the identity-key\n\n\nIf the challenge-hash from the `AUTHCHALLENGE`-message did not match the\nlocal authentication public-key, the signature must contain 64bytes of\nzeros.\n\nThe requesting peer can check the responding peers identity by checking\nthe validity of the sent signature against with the pre-shared remote\npeers identity-public-key.\n\nIf the signature was invalid, the requesting peer must still proceed\nwith the authentication by sending an `AUTHPROPOSE`-message with 32\nrandom bytes.\n\n=== `AUTHPROPOSE` message ===\nA peer can propose authentication of the channel by sending an\n`AUTHPROPOSE`-message to the remote peer.\n\nIf the signature sent in `AUTHREPLY` was invalid, the peer must still\nsend an `AUTHPROPOSE`-message containing 32 random bytes.\n\nThe `AUTHPROPOSE` message must be answered with an\n`AUTHCHALLENGE`-message \u2013 even if the proposed requesting-peers\nidentity-public-key has not been found in the authorized_peers database.\nIn case of no match, the responding `AUTHCHALLENGE`-message must\ncontains 32 bytes of zeros.\n\n\n| 32bytes || auth-propose-hash || hash || `hash(encryption-session-ID\n\n\n== Post-Authentication Re-Keying ==\n\nAfter the second `AUTHREPLY` message (requesting peers signature ->\nresponding peer), both clients must re-key the symmetric encryption\naccording to BIP151 while using ___a slightly  different re-key key\nderivation hash___.\n\nThey both re-key with `hash(encryption-session-ID ||\nold_symmetric_cipher_key || requesting-peer-identity-public-key ||\nresponding-peer-identity-public-key)`\n\n== Identity-Addresses ==\nThe peers should display/log the identity-public-key as an\nidentity-address to the users, which is a base58-check encoded\nripemd160(sha256) hash. The purpose of this is for better visual\ncomparison (logs, accept-dialogs).\nThe base58check identity byte is `0x0F` followed by an identity-address\nversion number (=`0xFF01`).\n\nAn identity address would look like\n`TfG4ScDgysrSpodWD4Re5UtXmcLbY5CiUHA` and can be interpreted as a remote\npeers fingerprint.\n\n== Compatibility ==\n\nThis proposal is backward compatible. Non-supporting peers will ignore\nthe new `AUTH*` messages.\n\n== Example of an auth interaction ==\n\nBefore authentication (once during peer setup or upgrade)\n# Requesting peer and responding peer create each an identity-keypair\n(standard ECC priv/pubkey)\n# Requesting and responding peer share the identity-public-key over a\ndifferent channel (PGP mail, physical exchange, etc.)\n# Responding peer stores requesting peers identity-public-key in its\nauthorized-peers database (A)\n# Requesting peer stores responding peers identity-public-key in its\nknown-peers database together with its IP and port (B)\n\nEncryption\n# Encrypted channels must be established (according to BIP-151 [1])\n\nAuthentication\n# Requesting peer sends an `AUTHCHALLENGE` message\n  AUTHCHALLENGE:\n    [32 bytes, hash(encryption-session-ID || \"i\" ||\n<remote-peers-expected-identity-public-key>)]\n\n# Responding peer does create the same hash `(encryption-session-ID ||\n\"i\" || <remote-peers-expected-identity-public-key>)` with its local\nidentity-public-key\n# If the hash does not match, response with an `AUTHREPLY` message\ncontaining 64bytes of zeros.\n# In case of a match, response with an `AUTHREPLY` message\n  AUTHREPLY:\n    [64 bytes normalized compact ECDSA signature (H)] (sig of the\nencryption-session-ID done with the identity-key)\n\n# Requesting peer does verify the signature with the\n`remote-peers-identity-public-key`\n# If the signature is invalid, requesting peer answers with an\n`AUTHREPLY` message containing 32 random bytes\n# In case of a valid signature, requesting peer sends an `AUTHPROPOSE`\nmessage\n  AUTHPROPOSE:\n    [32 bytes, hash(encryption-session-ID || \"p\" ||\n<client-identity-public-key>)]\n\n# Responding peer iterates over authorized-peers database (A), hashes\nthe identical data and looks for a match.\n# If the hash does not match, responding peer answer with an\n`AUTHCHALLENGE` message containing 32 bytes of zeros.\n# In case of a match, responding peer sends an `AUTHCHALLENGE` message\nwith the hashed client public-key\n  AUTHCHALLENGE:\n    [32 bytes, hash(encryption-session-ID || \"r\" ||\n<client-identity-public-key>)]\n# Requesting peer sends an `AUTHREPLY` message containing 64 bytes of\nzeros if server failed to authenticate\n# Otherwise, response with signature in the `AUTHREPLY` message\n  AUTHREPLY:\n    [64 bytes normalized compact ECDSA signature (H)] (sig of the\nencryption-session-ID done with the identity-key)\n# Responding peer must verify the signature and can grant access to\nrestricted services.\n# Both peers re-key the encryption after BIP151 including the\nrequesting-peer-identity-public-key and responding-peer-identity-public-key\n\n== Disadvantages ==\n\nThe protocol may be slow if a peer has a large authorized-peers database\ndue to the requirement of iterating and hashing over all available\nauthorized peers identity-public-keys.\n\n== Reference implementation ==\n\n== References ==\n\n* [1] [[bip-0151.mediawiki|BIP 151: Peer-to-Peer Communication Encryption]]\n\n== Acknowledgements ==\n* Gregory Maxwell and Pieter Wuille for most of the ideas in this BIP.\n\n== Copyright ==\nThis work is placed in the public domain.\n\n\n\n\n\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/e83bc378/attachment-0001.sig>"
            },
            {
                "author": "Andy Schroder",
                "date": "2016-08-08T17:09:45",
                "message_text_only": "On 08/08/2016 11:00 AM, Jonas Schnelli via bitcoin-dev wrote:\n> # ___known-peers___ contains known identity-public-keys together with a\n> network identifier (IP & port), similar to the \"known-host\" file\n> supported by openssh.\n\n\nI have mixed feelings about strictly tying the identity-public-keys with \na network identifier. I think the purpose of this is to detect if \nsomeone has physically stolen and compromised my bitcoin node and placed \nit on another network under control of an attacker. This seems to be a \nbit of a benefit, however, an attacker could always spoof the original \nnetwork identifier anyway.\n\nI run my bitcoin node on an internet connection that does not guarantee \na static IP address (although it usually stays the same for several \nweeks or months at a time). I'd like to be able to make secure \nconnections back to my own node, even if I know the IP address may \nchange from time to time. There are several reasons for wanting to this \nwith a changing IP. The first is because the bandwidth on my internet \nconnection with a guaranteed static IP address is considerably more \nexpensive than my internet connection without a guaranteed static IP \naddress. The second reason is because the DNS PTR record for my static \nIP address is personally identifiable based on other reasons/services. \nThe internet connection that my bitcoin node is using without a \nguaranteed static IP address just has a PTR record that basically \nincludes my IP address and ISP name. This isn't much use to the general \npublic (although my ISP obviously knows who I am). The third reason is \nthat I consider it a good thing from a privacy perspective if my IP \naddress changes every once and a while.\n\nMaybe a strict check option where the identity-public-keys must \noptionally match a specific network identifier would be a compromise? \nMaybe this is up to the client implementation to decide, so it should \njust be suggested in the BIP rather than required?\n\n\n\n\n> # ___authorized-peers___ contains authorized identity-public-keys\n\nIs there an option for a wildcard here? Couldn't there be a case where \nthe client wants to authenticate, but the bitcoin node does not care who \nit's clients are? This would be similar to many of the http based \nbitcoin block explorer API services that are out there. The API \noperators have built up some reputation, so people use them, but they \ndon't necessarily care about who their users are.\n\n\n\n\n\n\n\n> === Local identity key management ===\n> Each peer can configure one identity-key (ECC, 32 bytes) per listening\n> network interface (IPv4, IPv6, tor).\n\nWhat if I have bitcoind listening on multiple IPv4 interfaces? Can I \nhave a different identity-key for each IPv4 interface?\n\nAlso, would it be possible to only allow this authentication on specific \ninterfaces? In my example above where I have two internet connections, \nif you don't agree to loosening the tie between the network identifier \nand the identity-public-keys, maybe I would just connect my bitcoin node \nto both internet connections, but only allow a few authorized-peers on \nthe static IP (which would be low bandwidth), and then not authenticate \non the internet connection with the changing IP at all\n\nIf you don't want to increase complexity by adding these options, one \ncould always accomplish the same thing by runing two instances of \nbitcoind and pairing the two over a local network, it would just be a \nwaste of resources.\n\n\n\n\n> == Disadvantages ==\n>\n> The protocol may be slow if a peer has a large authorized-peers database\n> due to the requirement of iterating and hashing over all available\n> authorized peers identity-public-keys.\n\n\nDoes openssh have this same problem?\n\nI'm assuming this could be parallelized very easily, so it is not a huge \nproblem?\n\n\n\n\n\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/819a2eb5/attachment-0001.sig>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2016-08-08T17:42:45",
                "message_text_only": "On Mon, Aug 8, 2016 at 5:09 PM, Andy Schroder via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> I have mixed feelings about strictly tying the identity-public-keys with a\n[...]\n> guaranteed static IP address. The second reason is because the DNS PTR\n\nI don't see any reason that it couldn't also accept a DNS name there.\n\nThe purpose of that table is so the client knows which server ID to expect.\n\n> I consider it a good thing from a privacy perspective if my IP address\n> changes every once and a while.\n\nAnd the design seeks to preserve that privacy.\n\n> Maybe a strict check option where the identity-public-keys must optionally\n> match a specific network identifier would be a compromise? Maybe this is up\n\nThe client must know the identity of the server it is expecting. The\nserver does not announce itself. If it did then your changing of IPs\nwould provide you with no privacy at all.\n\nIf the design is to provide any protection against MITM you need to\nknow who you expected to connect to in any case.\n\n> I think the purpose of this is to detect if someone has physically stolen and compromised my bitcoin node and placed it on another network under control of an attacker.\n\nHuh. No. Almost the opposite. The system is designed to inhibit\nfingerprinting. You can't tell what identity key(s) a node has unless\nyou already know them. This means that if you don't publish your node\npubkey, no one can use it to track your node around the network.\n\n> Is there an option for a wildcard here? Couldn't there be a case where the\n> client wants to authenticate, but the bitcoin node does not care who it's\n> clients are? This would be similar to many of the http based bitcoin block\n> explorer API services that are out there. The API operators have built up\n> some reputation, so people use them, but they don't necessarily care about\n> who their users are.\n\nThen they're just not listed in the file. The client can ask the server to\nauthenticate without authenticating itself.\n\n> Does openssh have this same problem?\n\nNo. OpenSSH doesn't make an effort to protect the privacy of its users.\n\n> I'm assuming this could be parallelized very easily, so it is not a huge\n> problem?\n\nIt's not a issue because we're not aware of any usecase where a node\nwould have a large list of authenticated peers.\n\n> Each peer can configure one identity-key (ECC, 32 bytes) per listening\nnetwork interface (IPv4, IPv6, tor).\n\nI'm not aware of any reason for this limitation to exist. A node\nshould be able to have as many listening identities as it wants, with\na similar cost to having a large authorized keys list."
            },
            {
                "author": "Andy Schroder",
                "date": "2016-08-08T17:54:53",
                "message_text_only": "On 08/08/2016 01:42 PM, Gregory Maxwell wrote:\n> On Mon, Aug 8, 2016 at 5:09 PM, Andy Schroder via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> I have mixed feelings about strictly tying the identity-public-keys with a\n> [...]\n>> guaranteed static IP address. The second reason is because the DNS PTR\n> I don't see any reason that it couldn't also accept a DNS name there.\n>\n> The purpose of that table is so the client knows which server ID to expect.\n\nOkay, that may be fine. You are saying otherwise you'd have to do a \ntrial and error and this tying to a network identifier just speeds \nthings up? If the DNS is spoofed, it's no big deal because the \nauthentication will fail anyway?\n\n\n\n>\n>> I consider it a good thing from a privacy perspective if my IP address\n>> changes every once and a while.\n> And the design seeks to preserve that privacy.\n>\n>> Maybe a strict check option where the identity-public-keys must optionally\n>> match a specific network identifier would be a compromise? Maybe this is up\n> The client must know the identity of the server it is expecting. The\n> server does not announce itself. If it did then your changing of IPs\n> would provide you with no privacy at all.\n\nGood point.\n\n>\n> If the design is to provide any protection against MITM you need to\n> know who you expected to connect to in any case.\n>\n>> I think the purpose of this is to detect if someone has physically stolen and compromised my bitcoin node and placed it on another network under control of an attacker.\n> Huh. No. Almost the opposite. The system is designed to inhibit\n> fingerprinting. You can't tell what identity key(s) a node has unless\n> you already know them. This means that if you don't publish your node\n> pubkey, no one can use it to track your node around the network.\n\nCool.\n\n>\n>> Is there an option for a wildcard here? Couldn't there be a case where the\n>> client wants to authenticate, but the bitcoin node does not care who it's\n>> clients are? This would be similar to many of the http based bitcoin block\n>> explorer API services that are out there. The API operators have built up\n>> some reputation, so people use them, but they don't necessarily care about\n>> who their users are.\n> Then they're just not listed in the file. The client can ask the server to\n> authenticate without authenticating itself.\n\nSimple enough.\n\n>\n>> Does openssh have this same problem?\n> No. OpenSSH doesn't make an effort to protect the privacy of its users.\n>\n>> I'm assuming this could be parallelized very easily, so it is not a huge\n>> problem?\n> It's not a issue because we're not aware of any usecase where a node\n> would have a large list of authenticated peers.\n>\n>> Each peer can configure one identity-key (ECC, 32 bytes) per listening\n> network interface (IPv4, IPv6, tor).\n>\n> I'm not aware of any reason for this limitation to exist. A node\n> should be able to have as many listening identities as it wants, with\n> a similar cost to having a large authorized keys list.\n>\n\nSo you are saying that you agree with me that the original text needs to \nbe revised slightly or I am just misinterpreting the original text?\n\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/35f0fa9d/attachment.sig>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2016-08-09T10:02:06",
                "message_text_only": "Hi Andy\n\n>>\n>>> Does openssh have this same problem?\n>> No. OpenSSH doesn't make an effort to protect the privacy of its users.\n>>\n>>> I'm assuming this could be parallelized very easily, so it is not a huge\n>>> problem?\n>> It's not a issue because we're not aware of any usecase where a node\n>> would have a large list of authenticated peers.\n>>\n>>> Each peer can configure one identity-key (ECC, 32 bytes) per listening\n>> network interface (IPv4, IPv6, tor).\n>>\n>> I'm not aware of any reason for this limitation to exist. A node\n>> should be able to have as many listening identities as it wants, with\n>> a similar cost to having a large authorized keys list.\n>>\n> \n> So you are saying that you agree with me that the original text needs to\n> be revised slightly or I am just misinterpreting the original text?\n\nYes. I think this limitation could be removed.\nA responding node can have \u2013 in theory \u2013 multiple identity-keys per\nnetwork interface (network interfaces is also confusing, because you\ncould run multiple bitcoind instances on the same interface with\ndifferent ports).\n\nThe BIP should just make clear, that it is probably wise, to use\ndifferent identity-keys for each network interface (ipv4, v6, tor).\n\nI'll try to overhaul that part.\n\n</jonas>\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160809/2de7eeaa/attachment.sig>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2016-08-12T12:47:31",
                "message_text_only": "> Yes. I think this limitation could be removed.\n> A responding node can have \u2013 in theory \u2013 multiple identity-keys per\n> network interface (network interfaces is also confusing, because you\n> could run multiple bitcoind instances on the same interface with\n> different ports).\n> \n> The BIP should just make clear, that it is probably wise, to use\n> different identity-keys for each network interface (ipv4, v6, tor).\n> \n\nI have updated that part of the BIP\n\n-----------\nEach peer can configure multiple identity-keys (ECC, 32 bytes). Peers\nshould make sure, each network interface (IPv4, IPv6, tor) has its own\nidentity-key (otherwise it would be possible to link a tor address to a\nIPvX address).\nThe identity-public-key(s) can be shared over a different channel with\nother node-operators (or non-validating clients) to grant authorized access.\n-----------\n\nhttps://github.com/bitcoin/bips/compare/master...jonasschnelli:2016/07/auth_bip?expand=1\n\n</jonas>\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160812/c8a0c3c3/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Authentication BIP",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Gregory Maxwell",
                "Andy Schroder",
                "Jonas Schnelli"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 23311
        }
    },
    {
        "title": "[bitcoin-dev] Hiding entire content of on-chain transactions",
        "thread_messages": [
            {
                "author": "Tony Churyumoff",
                "date": "2016-08-08T15:30:21",
                "message_text_only": "This is a proposal about hiding the entire content of bitcoin\ntransactions.  It goes farther than CoinJoin and ring signatures, which\nonly obfuscate the transaction graph, and Confidential Transactions, which\nonly hide the amounts.\n\nThe central idea of the proposed design is to hide the entire inputs and\noutputs, and publish only the hash of inputs and outputs in the\nblockchain.  The hash can be published as OP_RETURN.  The plaintext of\ninputs and outputs is sent directly to the payee via a private message, and\nnever goes into the blockchain.  The payee then calculates the hash and\nlooks it up in the blockchain to verify that the hash was indeed published\nby the payer.\n\nSince the plaintext of the transaction is not published to the public\nblockchain, all validation work has to be done only by the user who\nreceives the payment.\n\nTo protect against double-spends, the payer also has to publish another\nhash, which is the hash of the output being spent.  We\u2019ll call this hash *spend\nproof*.  Since the spend proof depends solely on the output being spent,\nany attempt to spend the same output again will produce exactly the same\nspend proof, and the payee will be able to see that, and will reject the\npayment.  If there are several outputs consumed by the same transaction,\nthe payer has to publish several spend proofs.\n\nTo prove that the outputs being spent are valid, the payer also has to send\nthe plaintexts of the earlier transaction(s) that produced them, then the\nplaintexts of even earlier transactions that produced the outputs spent in\nthose transactions, and so on, up until the issue (similar to coinbase)\ntransactions that created the initial private coins.  Each new owner of the\ncoin will have to store its entire history, and when he spends the coin, he\nforwards the entire history to the next owner and extends it with his own\ntransaction.\n\nIf we apply the existing bitcoin design that allows multiple inputs and\nmultiple outputs per transaction, the history of ownership transfers would\ngrow exponentially.  Indeed, if we take any regular bitcoin output and try\nto track its history back to coinbase, our history will branch every time\nwe see a transaction that has more than one input (which is not uncommon).\nAfter such a transaction (remember, we are traveling back in time), we\u2019ll\nhave to track two or more histories, for each respective input.  Those\nhistories will branch again, and the total number of history entries grows\nexponentially.  For example, if every transaction had exactly two inputs,\nthe size of history would grow as 2^N where N is the number of steps back\nin history.\n\nTo avoid such rapid growth of ownership history (which is not only\ninconvenient to move, but also exposes too much private information about\nprevious owners of all the contributing coins), we will require each\nprivate transaction to have exactly one input (i.e. to consume exactly one\nprevious output).  This means that when we track a coin\u2019s history back in\ntime, it will no longer branch.  It will grow linearly with the number of\ntransfers of ownership.  If a user wants to combine several inputs, he will\nhave to send them as separate private transactions (technically, several\nOP_RETURNs, which can be included in a single regular bitcoin transaction).\n\nThus, we are now forbidding any coin merges but still allowing coin\nsplits.  To avoid ultimate splitting into the dust, we will also require\nthat all private coins be issued in one of a small number of\ndenominations.  Only integer number of \u201cbanknotes\u201d can be transferred, the\ninput and output amounts must therefore be divisible by the denomination.\nFor example, an input of amount 700, denomination 100, can be split into\noutputs 400 and 300, but not into 450 and 250.  To send a payment, the\npayer has to pick the unspent outputs of the highest denomination first,\nthen the second highest, and so on, like we already do when we pay in cash.\n\nWith fixed denominations and one input per transaction, coin histories\nstill grow, but only linearly, which should not be a concern in regard to\nscalability given that all relevant computing resources still grow\nexponentially.  The histories need to be stored only by the current owner\nof the coin, not every bitcoin node.  This is a fairer allocation of\ncosts.  Regarding privacy, coin histories do expose private transactions\n(or rather parts thereof, since a typical payment will likely consist of\nseveral transactions due to one-input-per-transaction rule) of past coin\nowners to the future ones, and that exposure grows linearly with time, but\nit is still much much better than having every transaction immediately on\nthe public blockchain.  Also, the value of this information for potential\nadversaries arguably decreases with time.\n\nThere is one technical nuance that I omitted above to avoid distraction.\n Unlike regular bitcoin transactions, every output in a private payment\nmust also include a blinding factor, which is just a random string.  When\nthe output is spent, the corresponding spend proof will therefore depend on\nthis blinding factor (remember that spend proof is just a hash of the\noutput).  Without a blinding factor, it would be feasible to pre-image the\nspend proof and reveal the output being spent as the search space of all\npossible outputs is rather small.\n\nTo issue the new private coin, one can burn regular BTC by sending it to\none of several unspendable bitcoin addresses, one address per denomination.\n Burning BTC would entitle one to an equal amount of the new private coin,\nlet\u2019s call it *black bitcoin*, or *BBC*.\n\nThen BBC would be transferred from user to user by:\n1. creating a private transaction, which consists of one input and several\noutputs;\n2. storing the hash of the transaction and the spend proof of the consumed\noutput into the blockchain in an OP_RETURN (the sender pays the\ncorresponding fees in regular BTC)\n3. sending the transaction, together with the history leading to its input,\ndirectly to the payee over a private communication channel.  The first\nentry of the history must be a bitcoin transaction that burned BTC to issue\nan equal amount of BCC.\n\nTo verify the payment, the payee:\n1. makes sure that the amount of the input matches the sum of outputs, and\nall are divisible by the denomination\n2. calculates the hash of the private transaction\n3. looks up an OP_RETURN that includes this hash and is signed by the\npayee.  If there is more than one, the one that comes in the earlier block\nprevails.\n4. calculates the spend proof and makes sure that it is included in the\nsame OP_RETURN\n5. makes sure the same spend proof is not included anywhere in the same or\nearlier blocks (that is, the coin was not spent before).  Only transactions\nby the same author are searched.\n6. repeats the same steps for every entry in the history, except the first\nentry, which should be a valid burning transaction.\n\nTo facilitate exchange of private transaction data, the bitcoin network\nprotocol can be extended with a new message type.  Unfortunately, it lacks\nencryption, hence private payments are really private only when bitcoin is\nused over tor.\n\nThere are a few limitations that ought to be mentioned:\n1. After user A sends a private payment to user B, user A will know what\nthe spend proof is going to be when B decides to spend the coin.\n Therefore, A will know when the coin was spent by B, but nothing more.\n Neither the new owner of the coin, nor its future movements will be known\nto A.\n2. Over time, larger outputs will likely be split into many smaller\noutputs, whose amounts are not much greater than their denominations.\nYou\u2019ll have to combine more inputs to send the same amount.  When you want\nto send a very large amount that is much greater than the highest available\ndenomination, you\u2019ll have to send a lot of private transactions, your\nbitcoin transaction with so many OP_RETURNs will stand out, and their\nnumber will roughly indicate the total amount.  This kind of privacy\nleakage, however it applies to a small number of users, is easy to avoid by\nusing multiple addresses and storing a relatively small amount on each\naddress.\n3. Exchanges and large merchants will likely accumulate large coin\nhistories.  Although fragmented, far from complete, and likely outdated, it\nis still something to bear in mind.\n\nNo hard or soft fork is required, BBC is just a separate privacy preserving\ncurrency on top of bitcoin blockchain, and the same private keys and\naddresses are used for both BBC and the base currency BTC.  Every BCC\ntransaction must be enclosed into by a small BTC transaction that stores\nthe OP_RETURNs and pays for the fees.\n\nAre there any flaws in this design?\n\nOriginally posted to BCT https://bitcointalk.org/index.php?topic=1574508.0,\nbut got no feedback so far, apparently everybody was consumed with bitfinex\ndrama and now mimblewimble.\n\nTony\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/e3c67d56/attachment.html>"
            },
            {
                "author": "Henning Kopp",
                "date": "2016-08-08T15:47:07",
                "message_text_only": "Hi Tony,\n\nI see some issues in your protocol.\n\n1. How are mining fees handled?\n\n2. Assume Alice sends Bob some Coins together with their history and\nBob checks that the history is correct. How does the hash of the txout\nfind its way into the blockchain?\n\nRegarding the blinding factor, I think you could just use HMAC.\n\nAll the best\nHenning\n\n\nOn Mon, Aug 08, 2016 at 06:30:21PM +0300, Tony Churyumoff via bitcoin-dev wrote:\n> This is a proposal about hiding the entire content of bitcoin\n> transactions.  It goes farther than CoinJoin and ring signatures, which\n> only obfuscate the transaction graph, and Confidential Transactions, which\n> only hide the amounts.\n> \n> The central idea of the proposed design is to hide the entire inputs and\n> outputs, and publish only the hash of inputs and outputs in the\n> blockchain.  The hash can be published as OP_RETURN.  The plaintext of\n> inputs and outputs is sent directly to the payee via a private message, and\n> never goes into the blockchain.  The payee then calculates the hash and\n> looks it up in the blockchain to verify that the hash was indeed published\n> by the payer.\n> \n> Since the plaintext of the transaction is not published to the public\n> blockchain, all validation work has to be done only by the user who\n> receives the payment.\n> \n> To protect against double-spends, the payer also has to publish another\n> hash, which is the hash of the output being spent.  We\u2019ll call this hash *spend\n> proof*.  Since the spend proof depends solely on the output being spent,\n> any attempt to spend the same output again will produce exactly the same\n> spend proof, and the payee will be able to see that, and will reject the\n> payment.  If there are several outputs consumed by the same transaction,\n> the payer has to publish several spend proofs.\n> \n> To prove that the outputs being spent are valid, the payer also has to send\n> the plaintexts of the earlier transaction(s) that produced them, then the\n> plaintexts of even earlier transactions that produced the outputs spent in\n> those transactions, and so on, up until the issue (similar to coinbase)\n> transactions that created the initial private coins.  Each new owner of the\n> coin will have to store its entire history, and when he spends the coin, he\n> forwards the entire history to the next owner and extends it with his own\n> transaction.\n> \n> If we apply the existing bitcoin design that allows multiple inputs and\n> multiple outputs per transaction, the history of ownership transfers would\n> grow exponentially.  Indeed, if we take any regular bitcoin output and try\n> to track its history back to coinbase, our history will branch every time\n> we see a transaction that has more than one input (which is not uncommon).\n> After such a transaction (remember, we are traveling back in time), we\u2019ll\n> have to track two or more histories, for each respective input.  Those\n> histories will branch again, and the total number of history entries grows\n> exponentially.  For example, if every transaction had exactly two inputs,\n> the size of history would grow as 2^N where N is the number of steps back\n> in history.\n> \n> To avoid such rapid growth of ownership history (which is not only\n> inconvenient to move, but also exposes too much private information about\n> previous owners of all the contributing coins), we will require each\n> private transaction to have exactly one input (i.e. to consume exactly one\n> previous output).  This means that when we track a coin\u2019s history back in\n> time, it will no longer branch.  It will grow linearly with the number of\n> transfers of ownership.  If a user wants to combine several inputs, he will\n> have to send them as separate private transactions (technically, several\n> OP_RETURNs, which can be included in a single regular bitcoin transaction).\n> \n> Thus, we are now forbidding any coin merges but still allowing coin\n> splits.  To avoid ultimate splitting into the dust, we will also require\n> that all private coins be issued in one of a small number of\n> denominations.  Only integer number of \u201cbanknotes\u201d can be transferred, the\n> input and output amounts must therefore be divisible by the denomination.\n> For example, an input of amount 700, denomination 100, can be split into\n> outputs 400 and 300, but not into 450 and 250.  To send a payment, the\n> payer has to pick the unspent outputs of the highest denomination first,\n> then the second highest, and so on, like we already do when we pay in cash.\n> \n> With fixed denominations and one input per transaction, coin histories\n> still grow, but only linearly, which should not be a concern in regard to\n> scalability given that all relevant computing resources still grow\n> exponentially.  The histories need to be stored only by the current owner\n> of the coin, not every bitcoin node.  This is a fairer allocation of\n> costs.  Regarding privacy, coin histories do expose private transactions\n> (or rather parts thereof, since a typical payment will likely consist of\n> several transactions due to one-input-per-transaction rule) of past coin\n> owners to the future ones, and that exposure grows linearly with time, but\n> it is still much much better than having every transaction immediately on\n> the public blockchain.  Also, the value of this information for potential\n> adversaries arguably decreases with time.\n> \n> There is one technical nuance that I omitted above to avoid distraction.\n>  Unlike regular bitcoin transactions, every output in a private payment\n> must also include a blinding factor, which is just a random string.  When\n> the output is spent, the corresponding spend proof will therefore depend on\n> this blinding factor (remember that spend proof is just a hash of the\n> output).  Without a blinding factor, it would be feasible to pre-image the\n> spend proof and reveal the output being spent as the search space of all\n> possible outputs is rather small.\n> \n> To issue the new private coin, one can burn regular BTC by sending it to\n> one of several unspendable bitcoin addresses, one address per denomination.\n>  Burning BTC would entitle one to an equal amount of the new private coin,\n> let\u2019s call it *black bitcoin*, or *BBC*.\n> \n> Then BBC would be transferred from user to user by:\n> 1. creating a private transaction, which consists of one input and several\n> outputs;\n> 2. storing the hash of the transaction and the spend proof of the consumed\n> output into the blockchain in an OP_RETURN (the sender pays the\n> corresponding fees in regular BTC)\n> 3. sending the transaction, together with the history leading to its input,\n> directly to the payee over a private communication channel.  The first\n> entry of the history must be a bitcoin transaction that burned BTC to issue\n> an equal amount of BCC.\n> \n> To verify the payment, the payee:\n> 1. makes sure that the amount of the input matches the sum of outputs, and\n> all are divisible by the denomination\n> 2. calculates the hash of the private transaction\n> 3. looks up an OP_RETURN that includes this hash and is signed by the\n> payee.  If there is more than one, the one that comes in the earlier block\n> prevails.\n> 4. calculates the spend proof and makes sure that it is included in the\n> same OP_RETURN\n> 5. makes sure the same spend proof is not included anywhere in the same or\n> earlier blocks (that is, the coin was not spent before).  Only transactions\n> by the same author are searched.\n> 6. repeats the same steps for every entry in the history, except the first\n> entry, which should be a valid burning transaction.\n> \n> To facilitate exchange of private transaction data, the bitcoin network\n> protocol can be extended with a new message type.  Unfortunately, it lacks\n> encryption, hence private payments are really private only when bitcoin is\n> used over tor.\n> \n> There are a few limitations that ought to be mentioned:\n> 1. After user A sends a private payment to user B, user A will know what\n> the spend proof is going to be when B decides to spend the coin.\n>  Therefore, A will know when the coin was spent by B, but nothing more.\n>  Neither the new owner of the coin, nor its future movements will be known\n> to A.\n> 2. Over time, larger outputs will likely be split into many smaller\n> outputs, whose amounts are not much greater than their denominations.\n> You\u2019ll have to combine more inputs to send the same amount.  When you want\n> to send a very large amount that is much greater than the highest available\n> denomination, you\u2019ll have to send a lot of private transactions, your\n> bitcoin transaction with so many OP_RETURNs will stand out, and their\n> number will roughly indicate the total amount.  This kind of privacy\n> leakage, however it applies to a small number of users, is easy to avoid by\n> using multiple addresses and storing a relatively small amount on each\n> address.\n> 3. Exchanges and large merchants will likely accumulate large coin\n> histories.  Although fragmented, far from complete, and likely outdated, it\n> is still something to bear in mind.\n> \n> No hard or soft fork is required, BBC is just a separate privacy preserving\n> currency on top of bitcoin blockchain, and the same private keys and\n> addresses are used for both BBC and the base currency BTC.  Every BCC\n> transaction must be enclosed into by a small BTC transaction that stores\n> the OP_RETURNs and pays for the fees.\n> \n> Are there any flaws in this design?\n> \n> Originally posted to BCT https://bitcointalk.org/index.php?topic=1574508.0,\n> but got no feedback so far, apparently everybody was consumed with bitfinex\n> drama and now mimblewimble.\n> \n> Tony\n\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n\n-- \nHenning Kopp\nInstitute of Distributed Systems\nUlm University, Germany\n\nOffice: O27 - 3402\nPhone: +49 731 50-24138\nWeb: http://www.uni-ulm.de/in/vs/~kopp"
            },
            {
                "author": "Tony Churyumoff",
                "date": "2016-08-08T16:03:28",
                "message_text_only": "Hi Henning,\n\n1. The fees are paid by the enclosing BTC transaction.\n2. The hash is encoded into an OP_RETURN.\n\n> Regarding the blinding factor, I think you could just use HMAC.\nHow exactly?\n\nTony\n\n\n2016-08-08 18:47 GMT+03:00 Henning Kopp <henning.kopp at uni-ulm.de>:\n\n> Hi Tony,\n>\n> I see some issues in your protocol.\n>\n> 1. How are mining fees handled?\n>\n> 2. Assume Alice sends Bob some Coins together with their history and\n> Bob checks that the history is correct. How does the hash of the txout\n> find its way into the blockchain?\n>\n> Regarding the blinding factor, I think you could just use HMAC.\n>\n> All the best\n> Henning\n>\n>\n> On Mon, Aug 08, 2016 at 06:30:21PM +0300, Tony Churyumoff via bitcoin-dev\n> wrote:\n> > This is a proposal about hiding the entire content of bitcoin\n> > transactions.  It goes farther than CoinJoin and ring signatures, which\n> > only obfuscate the transaction graph, and Confidential Transactions,\n> which\n> > only hide the amounts.\n> >\n> > The central idea of the proposed design is to hide the entire inputs and\n> > outputs, and publish only the hash of inputs and outputs in the\n> > blockchain.  The hash can be published as OP_RETURN.  The plaintext of\n> > inputs and outputs is sent directly to the payee via a private message,\n> and\n> > never goes into the blockchain.  The payee then calculates the hash and\n> > looks it up in the blockchain to verify that the hash was indeed\n> published\n> > by the payer.\n> >\n> > Since the plaintext of the transaction is not published to the public\n> > blockchain, all validation work has to be done only by the user who\n> > receives the payment.\n> >\n> > To protect against double-spends, the payer also has to publish another\n> > hash, which is the hash of the output being spent.  We\u2019ll call this hash\n> *spend\n> > proof*.  Since the spend proof depends solely on the output being spent,\n> > any attempt to spend the same output again will produce exactly the same\n> > spend proof, and the payee will be able to see that, and will reject the\n> > payment.  If there are several outputs consumed by the same transaction,\n> > the payer has to publish several spend proofs.\n> >\n> > To prove that the outputs being spent are valid, the payer also has to\n> send\n> > the plaintexts of the earlier transaction(s) that produced them, then the\n> > plaintexts of even earlier transactions that produced the outputs spent\n> in\n> > those transactions, and so on, up until the issue (similar to coinbase)\n> > transactions that created the initial private coins.  Each new owner of\n> the\n> > coin will have to store its entire history, and when he spends the coin,\n> he\n> > forwards the entire history to the next owner and extends it with his own\n> > transaction.\n> >\n> > If we apply the existing bitcoin design that allows multiple inputs and\n> > multiple outputs per transaction, the history of ownership transfers\n> would\n> > grow exponentially.  Indeed, if we take any regular bitcoin output and\n> try\n> > to track its history back to coinbase, our history will branch every time\n> > we see a transaction that has more than one input (which is not\n> uncommon).\n> > After such a transaction (remember, we are traveling back in time), we\u2019ll\n> > have to track two or more histories, for each respective input.  Those\n> > histories will branch again, and the total number of history entries\n> grows\n> > exponentially.  For example, if every transaction had exactly two inputs,\n> > the size of history would grow as 2^N where N is the number of steps back\n> > in history.\n> >\n> > To avoid such rapid growth of ownership history (which is not only\n> > inconvenient to move, but also exposes too much private information about\n> > previous owners of all the contributing coins), we will require each\n> > private transaction to have exactly one input (i.e. to consume exactly\n> one\n> > previous output).  This means that when we track a coin\u2019s history back in\n> > time, it will no longer branch.  It will grow linearly with the number of\n> > transfers of ownership.  If a user wants to combine several inputs, he\n> will\n> > have to send them as separate private transactions (technically, several\n> > OP_RETURNs, which can be included in a single regular bitcoin\n> transaction).\n> >\n> > Thus, we are now forbidding any coin merges but still allowing coin\n> > splits.  To avoid ultimate splitting into the dust, we will also require\n> > that all private coins be issued in one of a small number of\n> > denominations.  Only integer number of \u201cbanknotes\u201d can be transferred,\n> the\n> > input and output amounts must therefore be divisible by the denomination.\n> > For example, an input of amount 700, denomination 100, can be split into\n> > outputs 400 and 300, but not into 450 and 250.  To send a payment, the\n> > payer has to pick the unspent outputs of the highest denomination first,\n> > then the second highest, and so on, like we already do when we pay in\n> cash.\n> >\n> > With fixed denominations and one input per transaction, coin histories\n> > still grow, but only linearly, which should not be a concern in regard to\n> > scalability given that all relevant computing resources still grow\n> > exponentially.  The histories need to be stored only by the current owner\n> > of the coin, not every bitcoin node.  This is a fairer allocation of\n> > costs.  Regarding privacy, coin histories do expose private transactions\n> > (or rather parts thereof, since a typical payment will likely consist of\n> > several transactions due to one-input-per-transaction rule) of past coin\n> > owners to the future ones, and that exposure grows linearly with time,\n> but\n> > it is still much much better than having every transaction immediately on\n> > the public blockchain.  Also, the value of this information for potential\n> > adversaries arguably decreases with time.\n> >\n> > There is one technical nuance that I omitted above to avoid distraction.\n> >  Unlike regular bitcoin transactions, every output in a private payment\n> > must also include a blinding factor, which is just a random string.  When\n> > the output is spent, the corresponding spend proof will therefore depend\n> on\n> > this blinding factor (remember that spend proof is just a hash of the\n> > output).  Without a blinding factor, it would be feasible to pre-image\n> the\n> > spend proof and reveal the output being spent as the search space of all\n> > possible outputs is rather small.\n> >\n> > To issue the new private coin, one can burn regular BTC by sending it to\n> > one of several unspendable bitcoin addresses, one address per\n> denomination.\n> >  Burning BTC would entitle one to an equal amount of the new private\n> coin,\n> > let\u2019s call it *black bitcoin*, or *BBC*.\n> >\n> > Then BBC would be transferred from user to user by:\n> > 1. creating a private transaction, which consists of one input and\n> several\n> > outputs;\n> > 2. storing the hash of the transaction and the spend proof of the\n> consumed\n> > output into the blockchain in an OP_RETURN (the sender pays the\n> > corresponding fees in regular BTC)\n> > 3. sending the transaction, together with the history leading to its\n> input,\n> > directly to the payee over a private communication channel.  The first\n> > entry of the history must be a bitcoin transaction that burned BTC to\n> issue\n> > an equal amount of BCC.\n> >\n> > To verify the payment, the payee:\n> > 1. makes sure that the amount of the input matches the sum of outputs,\n> and\n> > all are divisible by the denomination\n> > 2. calculates the hash of the private transaction\n> > 3. looks up an OP_RETURN that includes this hash and is signed by the\n> > payee.  If there is more than one, the one that comes in the earlier\n> block\n> > prevails.\n> > 4. calculates the spend proof and makes sure that it is included in the\n> > same OP_RETURN\n> > 5. makes sure the same spend proof is not included anywhere in the same\n> or\n> > earlier blocks (that is, the coin was not spent before).  Only\n> transactions\n> > by the same author are searched.\n> > 6. repeats the same steps for every entry in the history, except the\n> first\n> > entry, which should be a valid burning transaction.\n> >\n> > To facilitate exchange of private transaction data, the bitcoin network\n> > protocol can be extended with a new message type.  Unfortunately, it\n> lacks\n> > encryption, hence private payments are really private only when bitcoin\n> is\n> > used over tor.\n> >\n> > There are a few limitations that ought to be mentioned:\n> > 1. After user A sends a private payment to user B, user A will know what\n> > the spend proof is going to be when B decides to spend the coin.\n> >  Therefore, A will know when the coin was spent by B, but nothing more.\n> >  Neither the new owner of the coin, nor its future movements will be\n> known\n> > to A.\n> > 2. Over time, larger outputs will likely be split into many smaller\n> > outputs, whose amounts are not much greater than their denominations.\n> > You\u2019ll have to combine more inputs to send the same amount.  When you\n> want\n> > to send a very large amount that is much greater than the highest\n> available\n> > denomination, you\u2019ll have to send a lot of private transactions, your\n> > bitcoin transaction with so many OP_RETURNs will stand out, and their\n> > number will roughly indicate the total amount.  This kind of privacy\n> > leakage, however it applies to a small number of users, is easy to avoid\n> by\n> > using multiple addresses and storing a relatively small amount on each\n> > address.\n> > 3. Exchanges and large merchants will likely accumulate large coin\n> > histories.  Although fragmented, far from complete, and likely outdated,\n> it\n> > is still something to bear in mind.\n> >\n> > No hard or soft fork is required, BBC is just a separate privacy\n> preserving\n> > currency on top of bitcoin blockchain, and the same private keys and\n> > addresses are used for both BBC and the base currency BTC.  Every BCC\n> > transaction must be enclosed into by a small BTC transaction that stores\n> > the OP_RETURNs and pays for the fees.\n> >\n> > Are there any flaws in this design?\n> >\n> > Originally posted to BCT https://bitcointalk.org/index.\n> php?topic=1574508.0,\n> > but got no feedback so far, apparently everybody was consumed with\n> bitfinex\n> > drama and now mimblewimble.\n> >\n> > Tony\n>\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> --\n> Henning Kopp\n> Institute of Distributed Systems\n> Ulm University, Germany\n>\n> Office: O27 - 3402\n> Phone: +49 731 50-24138\n> Web: http://www.uni-ulm.de/in/vs/~kopp\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/1ce6b828/attachment.html>"
            },
            {
                "author": "James MacWhyte",
                "date": "2016-08-08T21:41:27",
                "message_text_only": "Wouldn't you lose the ability to assume transactions in the blockchain are\nverified as valid, since miners can't see the details of what is being\nspent and how? I feel like this ability is bitcoin's greatest asset, and by\nremoving it you're creating an altcoin different enough to not be connected\nto/supported by the main bitcoin project.\n\nOn Mon, Aug 8, 2016, 09:13 Tony Churyumoff via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi Henning,\n>\n> 1. The fees are paid by the enclosing BTC transaction.\n> 2. The hash is encoded into an OP_RETURN.\n>\n> > Regarding the blinding factor, I think you could just use HMAC.\n> How exactly?\n>\n> Tony\n>\n>\n> 2016-08-08 18:47 GMT+03:00 Henning Kopp <henning.kopp at uni-ulm.de>:\n>\n>> Hi Tony,\n>>\n>> I see some issues in your protocol.\n>>\n>> 1. How are mining fees handled?\n>>\n>> 2. Assume Alice sends Bob some Coins together with their history and\n>> Bob checks that the history is correct. How does the hash of the txout\n>> find its way into the blockchain?\n>>\n>> Regarding the blinding factor, I think you could just use HMAC.\n>>\n>> All the best\n>> Henning\n>>\n>>\n>> On Mon, Aug 08, 2016 at 06:30:21PM +0300, Tony Churyumoff via bitcoin-dev\n>> wrote:\n>> > This is a proposal about hiding the entire content of bitcoin\n>> > transactions.  It goes farther than CoinJoin and ring signatures, which\n>> > only obfuscate the transaction graph, and Confidential Transactions,\n>> which\n>> > only hide the amounts.\n>> >\n>> > The central idea of the proposed design is to hide the entire inputs and\n>> > outputs, and publish only the hash of inputs and outputs in the\n>> > blockchain.  The hash can be published as OP_RETURN.  The plaintext of\n>> > inputs and outputs is sent directly to the payee via a private message,\n>> and\n>> > never goes into the blockchain.  The payee then calculates the hash and\n>> > looks it up in the blockchain to verify that the hash was indeed\n>> published\n>> > by the payer.\n>> >\n>> > Since the plaintext of the transaction is not published to the public\n>> > blockchain, all validation work has to be done only by the user who\n>> > receives the payment.\n>> >\n>> > To protect against double-spends, the payer also has to publish another\n>> > hash, which is the hash of the output being spent.  We\u2019ll call this\n>> hash *spend\n>> > proof*.  Since the spend proof depends solely on the output being spent,\n>> > any attempt to spend the same output again will produce exactly the same\n>> > spend proof, and the payee will be able to see that, and will reject the\n>> > payment.  If there are several outputs consumed by the same transaction,\n>> > the payer has to publish several spend proofs.\n>> >\n>> > To prove that the outputs being spent are valid, the payer also has to\n>> send\n>> > the plaintexts of the earlier transaction(s) that produced them, then\n>> the\n>> > plaintexts of even earlier transactions that produced the outputs spent\n>> in\n>> > those transactions, and so on, up until the issue (similar to coinbase)\n>> > transactions that created the initial private coins.  Each new owner of\n>> the\n>> > coin will have to store its entire history, and when he spends the\n>> coin, he\n>> > forwards the entire history to the next owner and extends it with his\n>> own\n>> > transaction.\n>> >\n>> > If we apply the existing bitcoin design that allows multiple inputs and\n>> > multiple outputs per transaction, the history of ownership transfers\n>> would\n>> > grow exponentially.  Indeed, if we take any regular bitcoin output and\n>> try\n>> > to track its history back to coinbase, our history will branch every\n>> time\n>> > we see a transaction that has more than one input (which is not\n>> uncommon).\n>> > After such a transaction (remember, we are traveling back in time),\n>> we\u2019ll\n>> > have to track two or more histories, for each respective input.  Those\n>> > histories will branch again, and the total number of history entries\n>> grows\n>> > exponentially.  For example, if every transaction had exactly two\n>> inputs,\n>> > the size of history would grow as 2^N where N is the number of steps\n>> back\n>> > in history.\n>> >\n>> > To avoid such rapid growth of ownership history (which is not only\n>> > inconvenient to move, but also exposes too much private information\n>> about\n>> > previous owners of all the contributing coins), we will require each\n>> > private transaction to have exactly one input (i.e. to consume exactly\n>> one\n>> > previous output).  This means that when we track a coin\u2019s history back\n>> in\n>> > time, it will no longer branch.  It will grow linearly with the number\n>> of\n>> > transfers of ownership.  If a user wants to combine several inputs, he\n>> will\n>> > have to send them as separate private transactions (technically, several\n>> > OP_RETURNs, which can be included in a single regular bitcoin\n>> transaction).\n>> >\n>> > Thus, we are now forbidding any coin merges but still allowing coin\n>> > splits.  To avoid ultimate splitting into the dust, we will also require\n>> > that all private coins be issued in one of a small number of\n>> > denominations.  Only integer number of \u201cbanknotes\u201d can be transferred,\n>> the\n>> > input and output amounts must therefore be divisible by the\n>> denomination.\n>> > For example, an input of amount 700, denomination 100, can be split into\n>> > outputs 400 and 300, but not into 450 and 250.  To send a payment, the\n>> > payer has to pick the unspent outputs of the highest denomination first,\n>> > then the second highest, and so on, like we already do when we pay in\n>> cash.\n>> >\n>> > With fixed denominations and one input per transaction, coin histories\n>> > still grow, but only linearly, which should not be a concern in regard\n>> to\n>> > scalability given that all relevant computing resources still grow\n>> > exponentially.  The histories need to be stored only by the current\n>> owner\n>> > of the coin, not every bitcoin node.  This is a fairer allocation of\n>> > costs.  Regarding privacy, coin histories do expose private transactions\n>> > (or rather parts thereof, since a typical payment will likely consist of\n>> > several transactions due to one-input-per-transaction rule) of past coin\n>> > owners to the future ones, and that exposure grows linearly with time,\n>> but\n>> > it is still much much better than having every transaction immediately\n>> on\n>> > the public blockchain.  Also, the value of this information for\n>> potential\n>> > adversaries arguably decreases with time.\n>> >\n>> > There is one technical nuance that I omitted above to avoid distraction.\n>> >  Unlike regular bitcoin transactions, every output in a private payment\n>> > must also include a blinding factor, which is just a random string.\n>> When\n>> > the output is spent, the corresponding spend proof will therefore\n>> depend on\n>> > this blinding factor (remember that spend proof is just a hash of the\n>> > output).  Without a blinding factor, it would be feasible to pre-image\n>> the\n>> > spend proof and reveal the output being spent as the search space of all\n>> > possible outputs is rather small.\n>> >\n>> > To issue the new private coin, one can burn regular BTC by sending it to\n>> > one of several unspendable bitcoin addresses, one address per\n>> denomination.\n>> >  Burning BTC would entitle one to an equal amount of the new private\n>> coin,\n>> > let\u2019s call it *black bitcoin*, or *BBC*.\n>> >\n>> > Then BBC would be transferred from user to user by:\n>> > 1. creating a private transaction, which consists of one input and\n>> several\n>> > outputs;\n>> > 2. storing the hash of the transaction and the spend proof of the\n>> consumed\n>> > output into the blockchain in an OP_RETURN (the sender pays the\n>> > corresponding fees in regular BTC)\n>> > 3. sending the transaction, together with the history leading to its\n>> input,\n>> > directly to the payee over a private communication channel.  The first\n>> > entry of the history must be a bitcoin transaction that burned BTC to\n>> issue\n>> > an equal amount of BCC.\n>> >\n>> > To verify the payment, the payee:\n>> > 1. makes sure that the amount of the input matches the sum of outputs,\n>> and\n>> > all are divisible by the denomination\n>> > 2. calculates the hash of the private transaction\n>> > 3. looks up an OP_RETURN that includes this hash and is signed by the\n>> > payee.  If there is more than one, the one that comes in the earlier\n>> block\n>> > prevails.\n>> > 4. calculates the spend proof and makes sure that it is included in the\n>> > same OP_RETURN\n>> > 5. makes sure the same spend proof is not included anywhere in the same\n>> or\n>> > earlier blocks (that is, the coin was not spent before).  Only\n>> transactions\n>> > by the same author are searched.\n>> > 6. repeats the same steps for every entry in the history, except the\n>> first\n>> > entry, which should be a valid burning transaction.\n>> >\n>> > To facilitate exchange of private transaction data, the bitcoin network\n>> > protocol can be extended with a new message type.  Unfortunately, it\n>> lacks\n>> > encryption, hence private payments are really private only when bitcoin\n>> is\n>> > used over tor.\n>> >\n>> > There are a few limitations that ought to be mentioned:\n>> > 1. After user A sends a private payment to user B, user A will know what\n>> > the spend proof is going to be when B decides to spend the coin.\n>> >  Therefore, A will know when the coin was spent by B, but nothing more.\n>> >  Neither the new owner of the coin, nor its future movements will be\n>> known\n>> > to A.\n>> > 2. Over time, larger outputs will likely be split into many smaller\n>> > outputs, whose amounts are not much greater than their denominations.\n>> > You\u2019ll have to combine more inputs to send the same amount.  When you\n>> want\n>> > to send a very large amount that is much greater than the highest\n>> available\n>> > denomination, you\u2019ll have to send a lot of private transactions, your\n>> > bitcoin transaction with so many OP_RETURNs will stand out, and their\n>> > number will roughly indicate the total amount.  This kind of privacy\n>> > leakage, however it applies to a small number of users, is easy to\n>> avoid by\n>> > using multiple addresses and storing a relatively small amount on each\n>> > address.\n>> > 3. Exchanges and large merchants will likely accumulate large coin\n>> > histories.  Although fragmented, far from complete, and likely\n>> outdated, it\n>> > is still something to bear in mind.\n>> >\n>> > No hard or soft fork is required, BBC is just a separate privacy\n>> preserving\n>> > currency on top of bitcoin blockchain, and the same private keys and\n>> > addresses are used for both BBC and the base currency BTC.  Every BCC\n>> > transaction must be enclosed into by a small BTC transaction that stores\n>> > the OP_RETURNs and pays for the fees.\n>> >\n>> > Are there any flaws in this design?\n>> >\n>> > Originally posted to BCT\n>> https://bitcointalk.org/index.php?topic=1574508.0,\n>> > but got no feedback so far, apparently everybody was consumed with\n>> bitfinex\n>> > drama and now mimblewimble.\n>> >\n>> > Tony\n>>\n>> > _______________________________________________\n>> > bitcoin-dev mailing list\n>> > bitcoin-dev at lists.linuxfoundation.org\n>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>> --\n>> Henning Kopp\n>> Institute of Distributed Systems\n>> Ulm University, Germany\n>>\n>> Office: O27 - 3402\n>> Phone: +49 731 50-24138\n>> Web: http://www.uni-ulm.de/in/vs/~kopp\n>>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/0bfeb179/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2016-08-08T21:53:54",
                "message_text_only": "On Mon, Aug 08, 2016 at 09:41:27PM +0000, James MacWhyte via bitcoin-dev wrote:\n> Wouldn't you lose the ability to assume transactions in the blockchain are\n> verified as valid, since miners can't see the details of what is being\n> spent and how? I feel like this ability is bitcoin's greatest asset, and by\n> removing it you're creating an altcoin different enough to not be connected\n> to/supported by the main bitcoin project.\n\nThe fact that miners verify transactions is just an optimisation:\n\n    https://petertodd.org/2013/disentangling-crypto-coin-mining\n\nPreventing double-spending however is a fundemental requirement of Bitcoin, and\nthis proposal does prevent double-spending perfectly well (although there may\nbe better ways to do it).\n\nThe OP's proposal sounds quite similar to my earlier one along similar lines:\n\n    https://petertodd.org/2016/closed-seal-sets-and-truth-lists-for-privacy\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/21a67947/attachment.sig>"
            },
            {
                "author": "Tony Churyumoff",
                "date": "2016-08-08T23:42:03",
                "message_text_only": "The whole point is in preventing every third party, including miners, from\nseeing the details of what is being spent and how.  The burden of\nverification is shifted to the owners of the coin (which is fair).\n\nIn fact we could have miners recognize spend proofs and check that the same\nspend proof is not entered into the blockchain more than once (which would\nbe a sign of double spend), but it is not required.  The coin owners can\nalready do that themselves.\n\n2016-08-09 0:41 GMT+03:00 James MacWhyte <macwhyte at gmail.com>:\n\n> Wouldn't you lose the ability to assume transactions in the blockchain are\n> verified as valid, since miners can't see the details of what is being\n> spent and how? I feel like this ability is bitcoin's greatest asset, and by\n> removing it you're creating an altcoin different enough to not be connected\n> to/supported by the main bitcoin project.\n>\n> On Mon, Aug 8, 2016, 09:13 Tony Churyumoff via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi Henning,\n>>\n>> 1. The fees are paid by the enclosing BTC transaction.\n>> 2. The hash is encoded into an OP_RETURN.\n>>\n>> > Regarding the blinding factor, I think you could just use HMAC.\n>> How exactly?\n>>\n>> Tony\n>>\n>>\n>> 2016-08-08 18:47 GMT+03:00 Henning Kopp <henning.kopp at uni-ulm.de>:\n>>\n>>> Hi Tony,\n>>>\n>>> I see some issues in your protocol.\n>>>\n>>> 1. How are mining fees handled?\n>>>\n>>> 2. Assume Alice sends Bob some Coins together with their history and\n>>> Bob checks that the history is correct. How does the hash of the txout\n>>> find its way into the blockchain?\n>>>\n>>> Regarding the blinding factor, I think you could just use HMAC.\n>>>\n>>> All the best\n>>> Henning\n>>>\n>>>\n>>> On Mon, Aug 08, 2016 at 06:30:21PM +0300, Tony Churyumoff via\n>>> bitcoin-dev wrote:\n>>> > This is a proposal about hiding the entire content of bitcoin\n>>> > transactions.  It goes farther than CoinJoin and ring signatures, which\n>>> > only obfuscate the transaction graph, and Confidential Transactions,\n>>> which\n>>> > only hide the amounts.\n>>> >\n>>> > The central idea of the proposed design is to hide the entire inputs\n>>> and\n>>> > outputs, and publish only the hash of inputs and outputs in the\n>>> > blockchain.  The hash can be published as OP_RETURN.  The plaintext of\n>>> > inputs and outputs is sent directly to the payee via a private\n>>> message, and\n>>> > never goes into the blockchain.  The payee then calculates the hash and\n>>> > looks it up in the blockchain to verify that the hash was indeed\n>>> published\n>>> > by the payer.\n>>> >\n>>> > Since the plaintext of the transaction is not published to the public\n>>> > blockchain, all validation work has to be done only by the user who\n>>> > receives the payment.\n>>> >\n>>> > To protect against double-spends, the payer also has to publish another\n>>> > hash, which is the hash of the output being spent.  We\u2019ll call this\n>>> hash *spend\n>>> > proof*.  Since the spend proof depends solely on the output being\n>>> spent,\n>>> > any attempt to spend the same output again will produce exactly the\n>>> same\n>>> > spend proof, and the payee will be able to see that, and will reject\n>>> the\n>>> > payment.  If there are several outputs consumed by the same\n>>> transaction,\n>>> > the payer has to publish several spend proofs.\n>>> >\n>>> > To prove that the outputs being spent are valid, the payer also has to\n>>> send\n>>> > the plaintexts of the earlier transaction(s) that produced them, then\n>>> the\n>>> > plaintexts of even earlier transactions that produced the outputs\n>>> spent in\n>>> > those transactions, and so on, up until the issue (similar to coinbase)\n>>> > transactions that created the initial private coins.  Each new owner\n>>> of the\n>>> > coin will have to store its entire history, and when he spends the\n>>> coin, he\n>>> > forwards the entire history to the next owner and extends it with his\n>>> own\n>>> > transaction.\n>>> >\n>>> > If we apply the existing bitcoin design that allows multiple inputs and\n>>> > multiple outputs per transaction, the history of ownership transfers\n>>> would\n>>> > grow exponentially.  Indeed, if we take any regular bitcoin output and\n>>> try\n>>> > to track its history back to coinbase, our history will branch every\n>>> time\n>>> > we see a transaction that has more than one input (which is not\n>>> uncommon).\n>>> > After such a transaction (remember, we are traveling back in time),\n>>> we\u2019ll\n>>> > have to track two or more histories, for each respective input.  Those\n>>> > histories will branch again, and the total number of history entries\n>>> grows\n>>> > exponentially.  For example, if every transaction had exactly two\n>>> inputs,\n>>> > the size of history would grow as 2^N where N is the number of steps\n>>> back\n>>> > in history.\n>>> >\n>>> > To avoid such rapid growth of ownership history (which is not only\n>>> > inconvenient to move, but also exposes too much private information\n>>> about\n>>> > previous owners of all the contributing coins), we will require each\n>>> > private transaction to have exactly one input (i.e. to consume exactly\n>>> one\n>>> > previous output).  This means that when we track a coin\u2019s history back\n>>> in\n>>> > time, it will no longer branch.  It will grow linearly with the number\n>>> of\n>>> > transfers of ownership.  If a user wants to combine several inputs, he\n>>> will\n>>> > have to send them as separate private transactions (technically,\n>>> several\n>>> > OP_RETURNs, which can be included in a single regular bitcoin\n>>> transaction).\n>>> >\n>>> > Thus, we are now forbidding any coin merges but still allowing coin\n>>> > splits.  To avoid ultimate splitting into the dust, we will also\n>>> require\n>>> > that all private coins be issued in one of a small number of\n>>> > denominations.  Only integer number of \u201cbanknotes\u201d can be transferred,\n>>> the\n>>> > input and output amounts must therefore be divisible by the\n>>> denomination.\n>>> > For example, an input of amount 700, denomination 100, can be split\n>>> into\n>>> > outputs 400 and 300, but not into 450 and 250.  To send a payment, the\n>>> > payer has to pick the unspent outputs of the highest denomination\n>>> first,\n>>> > then the second highest, and so on, like we already do when we pay in\n>>> cash.\n>>> >\n>>> > With fixed denominations and one input per transaction, coin histories\n>>> > still grow, but only linearly, which should not be a concern in regard\n>>> to\n>>> > scalability given that all relevant computing resources still grow\n>>> > exponentially.  The histories need to be stored only by the current\n>>> owner\n>>> > of the coin, not every bitcoin node.  This is a fairer allocation of\n>>> > costs.  Regarding privacy, coin histories do expose private\n>>> transactions\n>>> > (or rather parts thereof, since a typical payment will likely consist\n>>> of\n>>> > several transactions due to one-input-per-transaction rule) of past\n>>> coin\n>>> > owners to the future ones, and that exposure grows linearly with time,\n>>> but\n>>> > it is still much much better than having every transaction immediately\n>>> on\n>>> > the public blockchain.  Also, the value of this information for\n>>> potential\n>>> > adversaries arguably decreases with time.\n>>> >\n>>> > There is one technical nuance that I omitted above to avoid\n>>> distraction.\n>>> >  Unlike regular bitcoin transactions, every output in a private payment\n>>> > must also include a blinding factor, which is just a random string.\n>>> When\n>>> > the output is spent, the corresponding spend proof will therefore\n>>> depend on\n>>> > this blinding factor (remember that spend proof is just a hash of the\n>>> > output).  Without a blinding factor, it would be feasible to pre-image\n>>> the\n>>> > spend proof and reveal the output being spent as the search space of\n>>> all\n>>> > possible outputs is rather small.\n>>> >\n>>> > To issue the new private coin, one can burn regular BTC by sending it\n>>> to\n>>> > one of several unspendable bitcoin addresses, one address per\n>>> denomination.\n>>> >  Burning BTC would entitle one to an equal amount of the new private\n>>> coin,\n>>> > let\u2019s call it *black bitcoin*, or *BBC*.\n>>> >\n>>> > Then BBC would be transferred from user to user by:\n>>> > 1. creating a private transaction, which consists of one input and\n>>> several\n>>> > outputs;\n>>> > 2. storing the hash of the transaction and the spend proof of the\n>>> consumed\n>>> > output into the blockchain in an OP_RETURN (the sender pays the\n>>> > corresponding fees in regular BTC)\n>>> > 3. sending the transaction, together with the history leading to its\n>>> input,\n>>> > directly to the payee over a private communication channel.  The first\n>>> > entry of the history must be a bitcoin transaction that burned BTC to\n>>> issue\n>>> > an equal amount of BCC.\n>>> >\n>>> > To verify the payment, the payee:\n>>> > 1. makes sure that the amount of the input matches the sum of outputs,\n>>> and\n>>> > all are divisible by the denomination\n>>> > 2. calculates the hash of the private transaction\n>>> > 3. looks up an OP_RETURN that includes this hash and is signed by the\n>>> > payee.  If there is more than one, the one that comes in the earlier\n>>> block\n>>> > prevails.\n>>> > 4. calculates the spend proof and makes sure that it is included in the\n>>> > same OP_RETURN\n>>> > 5. makes sure the same spend proof is not included anywhere in the\n>>> same or\n>>> > earlier blocks (that is, the coin was not spent before).  Only\n>>> transactions\n>>> > by the same author are searched.\n>>> > 6. repeats the same steps for every entry in the history, except the\n>>> first\n>>> > entry, which should be a valid burning transaction.\n>>> >\n>>> > To facilitate exchange of private transaction data, the bitcoin network\n>>> > protocol can be extended with a new message type.  Unfortunately, it\n>>> lacks\n>>> > encryption, hence private payments are really private only when\n>>> bitcoin is\n>>> > used over tor.\n>>> >\n>>> > There are a few limitations that ought to be mentioned:\n>>> > 1. After user A sends a private payment to user B, user A will know\n>>> what\n>>> > the spend proof is going to be when B decides to spend the coin.\n>>> >  Therefore, A will know when the coin was spent by B, but nothing more.\n>>> >  Neither the new owner of the coin, nor its future movements will be\n>>> known\n>>> > to A.\n>>> > 2. Over time, larger outputs will likely be split into many smaller\n>>> > outputs, whose amounts are not much greater than their denominations.\n>>> > You\u2019ll have to combine more inputs to send the same amount.  When you\n>>> want\n>>> > to send a very large amount that is much greater than the highest\n>>> available\n>>> > denomination, you\u2019ll have to send a lot of private transactions, your\n>>> > bitcoin transaction with so many OP_RETURNs will stand out, and their\n>>> > number will roughly indicate the total amount.  This kind of privacy\n>>> > leakage, however it applies to a small number of users, is easy to\n>>> avoid by\n>>> > using multiple addresses and storing a relatively small amount on each\n>>> > address.\n>>> > 3. Exchanges and large merchants will likely accumulate large coin\n>>> > histories.  Although fragmented, far from complete, and likely\n>>> outdated, it\n>>> > is still something to bear in mind.\n>>> >\n>>> > No hard or soft fork is required, BBC is just a separate privacy\n>>> preserving\n>>> > currency on top of bitcoin blockchain, and the same private keys and\n>>> > addresses are used for both BBC and the base currency BTC.  Every BCC\n>>> > transaction must be enclosed into by a small BTC transaction that\n>>> stores\n>>> > the OP_RETURNs and pays for the fees.\n>>> >\n>>> > Are there any flaws in this design?\n>>> >\n>>> > Originally posted to BCT https://bitcointalk.org/index.\n>>> php?topic=1574508.0,\n>>> > but got no feedback so far, apparently everybody was consumed with\n>>> bitfinex\n>>> > drama and now mimblewimble.\n>>> >\n>>> > Tony\n>>>\n>>> > _______________________________________________\n>>> > bitcoin-dev mailing list\n>>> > bitcoin-dev at lists.linuxfoundation.org\n>>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>>\n>>> --\n>>> Henning Kopp\n>>> Institute of Distributed Systems\n>>> Ulm University, Germany\n>>>\n>>> Office: O27 - 3402\n>>> Phone: +49 731 50-24138\n>>> Web: http://www.uni-ulm.de/in/vs/~kopp\n>>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160809/9191ca6a/attachment-0001.html>"
            },
            {
                "author": "Henning Kopp",
                "date": "2016-08-09T07:26:35",
                "message_text_only": "Hi Tony,\n\n> > Regarding the blinding factor, I think you could just use HMAC.\n> How exactly?\n\nI am not entirely sure if this works. You wrote:\n\n> There is one technical nuance that I omitted above to avoid distraction.\n>  Unlike regular bitcoin transactions, every output in a private payment\n> must also include a blinding factor, which is just a random string.  When\n> the output is spent, the corresponding spend proof will therefore depend on\n> this blinding factor (remember that spend proof is just a hash of the\n> output).  Without a blinding factor, it would be feasible to pre-image the\n> spend proof and reveal the output being spent as the search space of all\n> possible outputs is rather small.\n\nInstead of a hash function you may use a keyed hash function (HMAC) where\nthe key is just the random string. They key needs to be stored in the\nhistory of the coin to allow for verification.\n\nBest\nHenning\n\nOn Mon, Aug 08, 2016 at 07:03:28PM +0300, Tony Churyumoff wrote:\n> Hi Henning,\n> \n> 1. The fees are paid by the enclosing BTC transaction.\n> 2. The hash is encoded into an OP_RETURN.\n> \n> > Regarding the blinding factor, I think you could just use HMAC.\n> How exactly?\n> \n> Tony\n> \n> \n> 2016-08-08 18:47 GMT+03:00 Henning Kopp <henning.kopp at uni-ulm.de>:\n> \n> > Hi Tony,\n> >\n> > I see some issues in your protocol.\n> >\n> > 1. How are mining fees handled?\n> >\n> > 2. Assume Alice sends Bob some Coins together with their history and\n> > Bob checks that the history is correct. How does the hash of the txout\n> > find its way into the blockchain?\n> >\n> > Regarding the blinding factor, I think you could just use HMAC.\n> >\n> > All the best\n> > Henning\n> >\n> >\n> > On Mon, Aug 08, 2016 at 06:30:21PM +0300, Tony Churyumoff via bitcoin-dev\n> > wrote:\n> > > This is a proposal about hiding the entire content of bitcoin\n> > > transactions.  It goes farther than CoinJoin and ring signatures, which\n> > > only obfuscate the transaction graph, and Confidential Transactions,\n> > which\n> > > only hide the amounts.\n> > >\n> > > The central idea of the proposed design is to hide the entire inputs and\n> > > outputs, and publish only the hash of inputs and outputs in the\n> > > blockchain.  The hash can be published as OP_RETURN.  The plaintext of\n> > > inputs and outputs is sent directly to the payee via a private message,\n> > and\n> > > never goes into the blockchain.  The payee then calculates the hash and\n> > > looks it up in the blockchain to verify that the hash was indeed\n> > published\n> > > by the payer.\n> > >\n> > > Since the plaintext of the transaction is not published to the public\n> > > blockchain, all validation work has to be done only by the user who\n> > > receives the payment.\n> > >\n> > > To protect against double-spends, the payer also has to publish another\n> > > hash, which is the hash of the output being spent.  We\u2019ll call this hash\n> > *spend\n> > > proof*.  Since the spend proof depends solely on the output being spent,\n> > > any attempt to spend the same output again will produce exactly the same\n> > > spend proof, and the payee will be able to see that, and will reject the\n> > > payment.  If there are several outputs consumed by the same transaction,\n> > > the payer has to publish several spend proofs.\n> > >\n> > > To prove that the outputs being spent are valid, the payer also has to\n> > send\n> > > the plaintexts of the earlier transaction(s) that produced them, then the\n> > > plaintexts of even earlier transactions that produced the outputs spent\n> > in\n> > > those transactions, and so on, up until the issue (similar to coinbase)\n> > > transactions that created the initial private coins.  Each new owner of\n> > the\n> > > coin will have to store its entire history, and when he spends the coin,\n> > he\n> > > forwards the entire history to the next owner and extends it with his own\n> > > transaction.\n> > >\n> > > If we apply the existing bitcoin design that allows multiple inputs and\n> > > multiple outputs per transaction, the history of ownership transfers\n> > would\n> > > grow exponentially.  Indeed, if we take any regular bitcoin output and\n> > try\n> > > to track its history back to coinbase, our history will branch every time\n> > > we see a transaction that has more than one input (which is not\n> > uncommon).\n> > > After such a transaction (remember, we are traveling back in time), we\u2019ll\n> > > have to track two or more histories, for each respective input.  Those\n> > > histories will branch again, and the total number of history entries\n> > grows\n> > > exponentially.  For example, if every transaction had exactly two inputs,\n> > > the size of history would grow as 2^N where N is the number of steps back\n> > > in history.\n> > >\n> > > To avoid such rapid growth of ownership history (which is not only\n> > > inconvenient to move, but also exposes too much private information about\n> > > previous owners of all the contributing coins), we will require each\n> > > private transaction to have exactly one input (i.e. to consume exactly\n> > one\n> > > previous output).  This means that when we track a coin\u2019s history back in\n> > > time, it will no longer branch.  It will grow linearly with the number of\n> > > transfers of ownership.  If a user wants to combine several inputs, he\n> > will\n> > > have to send them as separate private transactions (technically, several\n> > > OP_RETURNs, which can be included in a single regular bitcoin\n> > transaction).\n> > >\n> > > Thus, we are now forbidding any coin merges but still allowing coin\n> > > splits.  To avoid ultimate splitting into the dust, we will also require\n> > > that all private coins be issued in one of a small number of\n> > > denominations.  Only integer number of \u201cbanknotes\u201d can be transferred,\n> > the\n> > > input and output amounts must therefore be divisible by the denomination.\n> > > For example, an input of amount 700, denomination 100, can be split into\n> > > outputs 400 and 300, but not into 450 and 250.  To send a payment, the\n> > > payer has to pick the unspent outputs of the highest denomination first,\n> > > then the second highest, and so on, like we already do when we pay in\n> > cash.\n> > >\n> > > With fixed denominations and one input per transaction, coin histories\n> > > still grow, but only linearly, which should not be a concern in regard to\n> > > scalability given that all relevant computing resources still grow\n> > > exponentially.  The histories need to be stored only by the current owner\n> > > of the coin, not every bitcoin node.  This is a fairer allocation of\n> > > costs.  Regarding privacy, coin histories do expose private transactions\n> > > (or rather parts thereof, since a typical payment will likely consist of\n> > > several transactions due to one-input-per-transaction rule) of past coin\n> > > owners to the future ones, and that exposure grows linearly with time,\n> > but\n> > > it is still much much better than having every transaction immediately on\n> > > the public blockchain.  Also, the value of this information for potential\n> > > adversaries arguably decreases with time.\n> > >\n> > > There is one technical nuance that I omitted above to avoid distraction.\n> > >  Unlike regular bitcoin transactions, every output in a private payment\n> > > must also include a blinding factor, which is just a random string.  When\n> > > the output is spent, the corresponding spend proof will therefore depend\n> > on\n> > > this blinding factor (remember that spend proof is just a hash of the\n> > > output).  Without a blinding factor, it would be feasible to pre-image\n> > the\n> > > spend proof and reveal the output being spent as the search space of all\n> > > possible outputs is rather small.\n> > >\n> > > To issue the new private coin, one can burn regular BTC by sending it to\n> > > one of several unspendable bitcoin addresses, one address per\n> > denomination.\n> > >  Burning BTC would entitle one to an equal amount of the new private\n> > coin,\n> > > let\u2019s call it *black bitcoin*, or *BBC*.\n> > >\n> > > Then BBC would be transferred from user to user by:\n> > > 1. creating a private transaction, which consists of one input and\n> > several\n> > > outputs;\n> > > 2. storing the hash of the transaction and the spend proof of the\n> > consumed\n> > > output into the blockchain in an OP_RETURN (the sender pays the\n> > > corresponding fees in regular BTC)\n> > > 3. sending the transaction, together with the history leading to its\n> > input,\n> > > directly to the payee over a private communication channel.  The first\n> > > entry of the history must be a bitcoin transaction that burned BTC to\n> > issue\n> > > an equal amount of BCC.\n> > >\n> > > To verify the payment, the payee:\n> > > 1. makes sure that the amount of the input matches the sum of outputs,\n> > and\n> > > all are divisible by the denomination\n> > > 2. calculates the hash of the private transaction\n> > > 3. looks up an OP_RETURN that includes this hash and is signed by the\n> > > payee.  If there is more than one, the one that comes in the earlier\n> > block\n> > > prevails.\n> > > 4. calculates the spend proof and makes sure that it is included in the\n> > > same OP_RETURN\n> > > 5. makes sure the same spend proof is not included anywhere in the same\n> > or\n> > > earlier blocks (that is, the coin was not spent before).  Only\n> > transactions\n> > > by the same author are searched.\n> > > 6. repeats the same steps for every entry in the history, except the\n> > first\n> > > entry, which should be a valid burning transaction.\n> > >\n> > > To facilitate exchange of private transaction data, the bitcoin network\n> > > protocol can be extended with a new message type.  Unfortunately, it\n> > lacks\n> > > encryption, hence private payments are really private only when bitcoin\n> > is\n> > > used over tor.\n> > >\n> > > There are a few limitations that ought to be mentioned:\n> > > 1. After user A sends a private payment to user B, user A will know what\n> > > the spend proof is going to be when B decides to spend the coin.\n> > >  Therefore, A will know when the coin was spent by B, but nothing more.\n> > >  Neither the new owner of the coin, nor its future movements will be\n> > known\n> > > to A.\n> > > 2. Over time, larger outputs will likely be split into many smaller\n> > > outputs, whose amounts are not much greater than their denominations.\n> > > You\u2019ll have to combine more inputs to send the same amount.  When you\n> > want\n> > > to send a very large amount that is much greater than the highest\n> > available\n> > > denomination, you\u2019ll have to send a lot of private transactions, your\n> > > bitcoin transaction with so many OP_RETURNs will stand out, and their\n> > > number will roughly indicate the total amount.  This kind of privacy\n> > > leakage, however it applies to a small number of users, is easy to avoid\n> > by\n> > > using multiple addresses and storing a relatively small amount on each\n> > > address.\n> > > 3. Exchanges and large merchants will likely accumulate large coin\n> > > histories.  Although fragmented, far from complete, and likely outdated,\n> > it\n> > > is still something to bear in mind.\n> > >\n> > > No hard or soft fork is required, BBC is just a separate privacy\n> > preserving\n> > > currency on top of bitcoin blockchain, and the same private keys and\n> > > addresses are used for both BBC and the base currency BTC.  Every BCC\n> > > transaction must be enclosed into by a small BTC transaction that stores\n> > > the OP_RETURNs and pays for the fees.\n> > >\n> > > Are there any flaws in this design?\n> > >\n> > > Originally posted to BCT https://bitcointalk.org/index.\n> > php?topic=1574508.0,\n> > > but got no feedback so far, apparently everybody was consumed with\n> > bitfinex\n> > > drama and now mimblewimble.\n> > >\n> > > Tony\n> >\n> > > _______________________________________________\n> > > bitcoin-dev mailing list\n> > > bitcoin-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n> >\n> > --\n> > Henning Kopp\n> > Institute of Distributed Systems\n> > Ulm University, Germany\n> >\n> > Office: O27 - 3402\n> > Phone: +49 731 50-24138\n> > Web: http://www.uni-ulm.de/in/vs/~kopp\n> >\n\n-- \nHenning Kopp\nInstitute of Distributed Systems\nUlm University, Germany\n\nOffice: O27 - 3402\nPhone: +49 731 50-24138\nWeb: http://www.uni-ulm.de/in/vs/~kopp"
            },
            {
                "author": "James MacWhyte",
                "date": "2016-08-09T00:03:17",
                "message_text_only": "That is a good point. As you said, it puts a lot more burden on the coin\nholders. One big downside would be data management. Instead of simply\nbacking up a single HD private key, the user would have to back up entire\nhistories of every output that has been sent to them if they want to secure\ntheir funds.\n\nIt also requires them to be online to receive payments, and I think finding\na method of sending the private message containing the coin's history is\ngoing to be a bit of a challenge. If you connect directly to the recipient\nto convey the information through traditional channels, anonymity is lost.\nSending messages through the bitcoin network is one option to protect\nanonymity, but without active pathfinding there's no guarantee the payee\nwill even get the message. I'm assuming you'd have to essentially replace\ntx messages with encrypted BBC histories, and mempools are quite full as it\nis.\n\nTony, do you have any more thoughts on exactly how users would convey the\nprivate messages to payees?\n\nOn Mon, Aug 8, 2016 at 4:42 PM Tony Churyumoff <tony991 at gmail.com> wrote:\n\n> The whole point is in preventing every third party, including miners, from\n> seeing the details of what is being spent and how.  The burden of\n> verification is shifted to the owners of the coin (which is fair).\n>\n> In fact we could have miners recognize spend proofs and check that the\n> same spend proof is not entered into the blockchain more than once (which\n> would be a sign of double spend), but it is not required.  The coin owners\n> can already do that themselves.\n>\n> 2016-08-09 0:41 GMT+03:00 James MacWhyte <macwhyte at gmail.com>:\n>\n>> Wouldn't you lose the ability to assume transactions in the blockchain\n>> are verified as valid, since miners can't see the details of what is being\n>> spent and how? I feel like this ability is bitcoin's greatest asset, and by\n>> removing it you're creating an altcoin different enough to not be connected\n>> to/supported by the main bitcoin project.\n>>\n>> On Mon, Aug 8, 2016, 09:13 Tony Churyumoff via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Hi Henning,\n>>>\n>>> 1. The fees are paid by the enclosing BTC transaction.\n>>> 2. The hash is encoded into an OP_RETURN.\n>>>\n>>> > Regarding the blinding factor, I think you could just use HMAC.\n>>> How exactly?\n>>>\n>>> Tony\n>>>\n>>>\n>>> 2016-08-08 18:47 GMT+03:00 Henning Kopp <henning.kopp at uni-ulm.de>:\n>>>\n>>>> Hi Tony,\n>>>>\n>>>> I see some issues in your protocol.\n>>>>\n>>>> 1. How are mining fees handled?\n>>>>\n>>>> 2. Assume Alice sends Bob some Coins together with their history and\n>>>> Bob checks that the history is correct. How does the hash of the txout\n>>>> find its way into the blockchain?\n>>>>\n>>>> Regarding the blinding factor, I think you could just use HMAC.\n>>>>\n>>>> All the best\n>>>> Henning\n>>>>\n>>>>\n>>>> On Mon, Aug 08, 2016 at 06:30:21PM +0300, Tony Churyumoff via\n>>>> bitcoin-dev wrote:\n>>>> > This is a proposal about hiding the entire content of bitcoin\n>>>> > transactions.  It goes farther than CoinJoin and ring signatures,\n>>>> which\n>>>> > only obfuscate the transaction graph, and Confidential Transactions,\n>>>> which\n>>>> > only hide the amounts.\n>>>> >\n>>>> > The central idea of the proposed design is to hide the entire inputs\n>>>> and\n>>>> > outputs, and publish only the hash of inputs and outputs in the\n>>>> > blockchain.  The hash can be published as OP_RETURN.  The plaintext of\n>>>> > inputs and outputs is sent directly to the payee via a private\n>>>> message, and\n>>>> > never goes into the blockchain.  The payee then calculates the hash\n>>>> and\n>>>> > looks it up in the blockchain to verify that the hash was indeed\n>>>> published\n>>>> > by the payer.\n>>>> >\n>>>> > Since the plaintext of the transaction is not published to the public\n>>>> > blockchain, all validation work has to be done only by the user who\n>>>> > receives the payment.\n>>>> >\n>>>> > To protect against double-spends, the payer also has to publish\n>>>> another\n>>>> > hash, which is the hash of the output being spent.  We\u2019ll call this\n>>>> hash *spend\n>>>> > proof*.  Since the spend proof depends solely on the output being\n>>>> spent,\n>>>> > any attempt to spend the same output again will produce exactly the\n>>>> same\n>>>> > spend proof, and the payee will be able to see that, and will reject\n>>>> the\n>>>> > payment.  If there are several outputs consumed by the same\n>>>> transaction,\n>>>> > the payer has to publish several spend proofs.\n>>>> >\n>>>> > To prove that the outputs being spent are valid, the payer also has\n>>>> to send\n>>>> > the plaintexts of the earlier transaction(s) that produced them, then\n>>>> the\n>>>> > plaintexts of even earlier transactions that produced the outputs\n>>>> spent in\n>>>> > those transactions, and so on, up until the issue (similar to\n>>>> coinbase)\n>>>> > transactions that created the initial private coins.  Each new owner\n>>>> of the\n>>>> > coin will have to store its entire history, and when he spends the\n>>>> coin, he\n>>>> > forwards the entire history to the next owner and extends it with his\n>>>> own\n>>>> > transaction.\n>>>> >\n>>>> > If we apply the existing bitcoin design that allows multiple inputs\n>>>> and\n>>>> > multiple outputs per transaction, the history of ownership transfers\n>>>> would\n>>>> > grow exponentially.  Indeed, if we take any regular bitcoin output\n>>>> and try\n>>>> > to track its history back to coinbase, our history will branch every\n>>>> time\n>>>> > we see a transaction that has more than one input (which is not\n>>>> uncommon).\n>>>> > After such a transaction (remember, we are traveling back in time),\n>>>> we\u2019ll\n>>>> > have to track two or more histories, for each respective input.  Those\n>>>> > histories will branch again, and the total number of history entries\n>>>> grows\n>>>> > exponentially.  For example, if every transaction had exactly two\n>>>> inputs,\n>>>> > the size of history would grow as 2^N where N is the number of steps\n>>>> back\n>>>> > in history.\n>>>> >\n>>>> > To avoid such rapid growth of ownership history (which is not only\n>>>> > inconvenient to move, but also exposes too much private information\n>>>> about\n>>>> > previous owners of all the contributing coins), we will require each\n>>>> > private transaction to have exactly one input (i.e. to consume\n>>>> exactly one\n>>>> > previous output).  This means that when we track a coin\u2019s history\n>>>> back in\n>>>> > time, it will no longer branch.  It will grow linearly with the\n>>>> number of\n>>>> > transfers of ownership.  If a user wants to combine several inputs,\n>>>> he will\n>>>> > have to send them as separate private transactions (technically,\n>>>> several\n>>>> > OP_RETURNs, which can be included in a single regular bitcoin\n>>>> transaction).\n>>>> >\n>>>> > Thus, we are now forbidding any coin merges but still allowing coin\n>>>> > splits.  To avoid ultimate splitting into the dust, we will also\n>>>> require\n>>>> > that all private coins be issued in one of a small number of\n>>>> > denominations.  Only integer number of \u201cbanknotes\u201d can be\n>>>> transferred, the\n>>>> > input and output amounts must therefore be divisible by the\n>>>> denomination.\n>>>> > For example, an input of amount 700, denomination 100, can be split\n>>>> into\n>>>> > outputs 400 and 300, but not into 450 and 250.  To send a payment, the\n>>>> > payer has to pick the unspent outputs of the highest denomination\n>>>> first,\n>>>> > then the second highest, and so on, like we already do when we pay in\n>>>> cash.\n>>>> >\n>>>> > With fixed denominations and one input per transaction, coin histories\n>>>> > still grow, but only linearly, which should not be a concern in\n>>>> regard to\n>>>> > scalability given that all relevant computing resources still grow\n>>>> > exponentially.  The histories need to be stored only by the current\n>>>> owner\n>>>> > of the coin, not every bitcoin node.  This is a fairer allocation of\n>>>> > costs.  Regarding privacy, coin histories do expose private\n>>>> transactions\n>>>> > (or rather parts thereof, since a typical payment will likely consist\n>>>> of\n>>>> > several transactions due to one-input-per-transaction rule) of past\n>>>> coin\n>>>> > owners to the future ones, and that exposure grows linearly with\n>>>> time, but\n>>>> > it is still much much better than having every transaction\n>>>> immediately on\n>>>> > the public blockchain.  Also, the value of this information for\n>>>> potential\n>>>> > adversaries arguably decreases with time.\n>>>> >\n>>>> > There is one technical nuance that I omitted above to avoid\n>>>> distraction.\n>>>> >  Unlike regular bitcoin transactions, every output in a private\n>>>> payment\n>>>> > must also include a blinding factor, which is just a random string.\n>>>> When\n>>>> > the output is spent, the corresponding spend proof will therefore\n>>>> depend on\n>>>> > this blinding factor (remember that spend proof is just a hash of the\n>>>> > output).  Without a blinding factor, it would be feasible to\n>>>> pre-image the\n>>>> > spend proof and reveal the output being spent as the search space of\n>>>> all\n>>>> > possible outputs is rather small.\n>>>> >\n>>>> > To issue the new private coin, one can burn regular BTC by sending it\n>>>> to\n>>>> > one of several unspendable bitcoin addresses, one address per\n>>>> denomination.\n>>>> >  Burning BTC would entitle one to an equal amount of the new private\n>>>> coin,\n>>>> > let\u2019s call it *black bitcoin*, or *BBC*.\n>>>> >\n>>>> > Then BBC would be transferred from user to user by:\n>>>> > 1. creating a private transaction, which consists of one input and\n>>>> several\n>>>> > outputs;\n>>>> > 2. storing the hash of the transaction and the spend proof of the\n>>>> consumed\n>>>> > output into the blockchain in an OP_RETURN (the sender pays the\n>>>> > corresponding fees in regular BTC)\n>>>> > 3. sending the transaction, together with the history leading to its\n>>>> input,\n>>>> > directly to the payee over a private communication channel.  The first\n>>>> > entry of the history must be a bitcoin transaction that burned BTC to\n>>>> issue\n>>>> > an equal amount of BCC.\n>>>> >\n>>>> > To verify the payment, the payee:\n>>>> > 1. makes sure that the amount of the input matches the sum of\n>>>> outputs, and\n>>>> > all are divisible by the denomination\n>>>> > 2. calculates the hash of the private transaction\n>>>> > 3. looks up an OP_RETURN that includes this hash and is signed by the\n>>>> > payee.  If there is more than one, the one that comes in the earlier\n>>>> block\n>>>> > prevails.\n>>>> > 4. calculates the spend proof and makes sure that it is included in\n>>>> the\n>>>> > same OP_RETURN\n>>>> > 5. makes sure the same spend proof is not included anywhere in the\n>>>> same or\n>>>> > earlier blocks (that is, the coin was not spent before).  Only\n>>>> transactions\n>>>> > by the same author are searched.\n>>>> > 6. repeats the same steps for every entry in the history, except the\n>>>> first\n>>>> > entry, which should be a valid burning transaction.\n>>>> >\n>>>> > To facilitate exchange of private transaction data, the bitcoin\n>>>> network\n>>>> > protocol can be extended with a new message type.  Unfortunately, it\n>>>> lacks\n>>>> > encryption, hence private payments are really private only when\n>>>> bitcoin is\n>>>> > used over tor.\n>>>> >\n>>>> > There are a few limitations that ought to be mentioned:\n>>>> > 1. After user A sends a private payment to user B, user A will know\n>>>> what\n>>>> > the spend proof is going to be when B decides to spend the coin.\n>>>> >  Therefore, A will know when the coin was spent by B, but nothing\n>>>> more.\n>>>> >  Neither the new owner of the coin, nor its future movements will be\n>>>> known\n>>>> > to A.\n>>>> > 2. Over time, larger outputs will likely be split into many smaller\n>>>> > outputs, whose amounts are not much greater than their denominations.\n>>>> > You\u2019ll have to combine more inputs to send the same amount.  When you\n>>>> want\n>>>> > to send a very large amount that is much greater than the highest\n>>>> available\n>>>> > denomination, you\u2019ll have to send a lot of private transactions, your\n>>>> > bitcoin transaction with so many OP_RETURNs will stand out, and their\n>>>> > number will roughly indicate the total amount.  This kind of privacy\n>>>> > leakage, however it applies to a small number of users, is easy to\n>>>> avoid by\n>>>> > using multiple addresses and storing a relatively small amount on each\n>>>> > address.\n>>>> > 3. Exchanges and large merchants will likely accumulate large coin\n>>>> > histories.  Although fragmented, far from complete, and likely\n>>>> outdated, it\n>>>> > is still something to bear in mind.\n>>>> >\n>>>> > No hard or soft fork is required, BBC is just a separate privacy\n>>>> preserving\n>>>> > currency on top of bitcoin blockchain, and the same private keys and\n>>>> > addresses are used for both BBC and the base currency BTC.  Every BCC\n>>>> > transaction must be enclosed into by a small BTC transaction that\n>>>> stores\n>>>> > the OP_RETURNs and pays for the fees.\n>>>> >\n>>>> > Are there any flaws in this design?\n>>>> >\n>>>> > Originally posted to BCT\n>>>> https://bitcointalk.org/index.php?topic=1574508.0,\n>>>> > but got no feedback so far, apparently everybody was consumed with\n>>>> bitfinex\n>>>> > drama and now mimblewimble.\n>>>> >\n>>>> > Tony\n>>>>\n>>>> > _______________________________________________\n>>>> > bitcoin-dev mailing list\n>>>> > bitcoin-dev at lists.linuxfoundation.org\n>>>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>\n>>>>\n>>>> --\n>>>> Henning Kopp\n>>>> Institute of Distributed Systems\n>>>> Ulm University, Germany\n>>>>\n>>>> Office: O27 - 3402\n>>>> Phone: +49 731 50-24138\n>>>> Web: http://www.uni-ulm.de/in/vs/~kopp\n>>>>\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160809/00d83f50/attachment-0001.html>"
            },
            {
                "author": "James MacWhyte",
                "date": "2016-08-09T00:18:21",
                "message_text_only": "One more thought about why verification by miners may be needed.\n\nLet's say Alice sends Bob a transaction, generating output C.\n\nA troll, named Timothy, broadcasts a transaction with a random hash,\nreferencing C's output as its spend proof. The miners can't tell if it's\nvalid or not, and so they include the transaction in a block. Now Bob's\nmoney is useless, because everyone can see the spend proof referenced and\nthinks it has already been spent, even though the transaction that claims\nit isn't valid.\n\nDid I miss something that protects against this?\n\nOn Mon, Aug 8, 2016 at 4:42 PM Tony Churyumoff <tony991 at gmail.com> wrote:\n\n> The whole point is in preventing every third party, including miners, from\n> seeing the details of what is being spent and how.  The burden of\n> verification is shifted to the owners of the coin (which is fair).\n>\n> In fact we could have miners recognize spend proofs and check that the\n> same spend proof is not entered into the blockchain more than once (which\n> would be a sign of double spend), but it is not required.  The coin owners\n> can already do that themselves.\n>\n> 2016-08-09 0:41 GMT+03:00 James MacWhyte <macwhyte at gmail.com>:\n>\n>> Wouldn't you lose the ability to assume transactions in the blockchain\n>> are verified as valid, since miners can't see the details of what is being\n>> spent and how? I feel like this ability is bitcoin's greatest asset, and by\n>> removing it you're creating an altcoin different enough to not be connected\n>> to/supported by the main bitcoin project.\n>>\n>> On Mon, Aug 8, 2016, 09:13 Tony Churyumoff via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Hi Henning,\n>>>\n>>> 1. The fees are paid by the enclosing BTC transaction.\n>>> 2. The hash is encoded into an OP_RETURN.\n>>>\n>>> > Regarding the blinding factor, I think you could just use HMAC.\n>>> How exactly?\n>>>\n>>> Tony\n>>>\n>>>\n>>> 2016-08-08 18:47 GMT+03:00 Henning Kopp <henning.kopp at uni-ulm.de>:\n>>>\n>>>> Hi Tony,\n>>>>\n>>>> I see some issues in your protocol.\n>>>>\n>>>> 1. How are mining fees handled?\n>>>>\n>>>> 2. Assume Alice sends Bob some Coins together with their history and\n>>>> Bob checks that the history is correct. How does the hash of the txout\n>>>> find its way into the blockchain?\n>>>>\n>>>> Regarding the blinding factor, I think you could just use HMAC.\n>>>>\n>>>> All the best\n>>>> Henning\n>>>>\n>>>>\n>>>> On Mon, Aug 08, 2016 at 06:30:21PM +0300, Tony Churyumoff via\n>>>> bitcoin-dev wrote:\n>>>> > This is a proposal about hiding the entire content of bitcoin\n>>>> > transactions.  It goes farther than CoinJoin and ring signatures,\n>>>> which\n>>>> > only obfuscate the transaction graph, and Confidential Transactions,\n>>>> which\n>>>> > only hide the amounts.\n>>>> >\n>>>> > The central idea of the proposed design is to hide the entire inputs\n>>>> and\n>>>> > outputs, and publish only the hash of inputs and outputs in the\n>>>> > blockchain.  The hash can be published as OP_RETURN.  The plaintext of\n>>>> > inputs and outputs is sent directly to the payee via a private\n>>>> message, and\n>>>> > never goes into the blockchain.  The payee then calculates the hash\n>>>> and\n>>>> > looks it up in the blockchain to verify that the hash was indeed\n>>>> published\n>>>> > by the payer.\n>>>> >\n>>>> > Since the plaintext of the transaction is not published to the public\n>>>> > blockchain, all validation work has to be done only by the user who\n>>>> > receives the payment.\n>>>> >\n>>>> > To protect against double-spends, the payer also has to publish\n>>>> another\n>>>> > hash, which is the hash of the output being spent.  We\u2019ll call this\n>>>> hash *spend\n>>>> > proof*.  Since the spend proof depends solely on the output being\n>>>> spent,\n>>>> > any attempt to spend the same output again will produce exactly the\n>>>> same\n>>>> > spend proof, and the payee will be able to see that, and will reject\n>>>> the\n>>>> > payment.  If there are several outputs consumed by the same\n>>>> transaction,\n>>>> > the payer has to publish several spend proofs.\n>>>> >\n>>>> > To prove that the outputs being spent are valid, the payer also has\n>>>> to send\n>>>> > the plaintexts of the earlier transaction(s) that produced them, then\n>>>> the\n>>>> > plaintexts of even earlier transactions that produced the outputs\n>>>> spent in\n>>>> > those transactions, and so on, up until the issue (similar to\n>>>> coinbase)\n>>>> > transactions that created the initial private coins.  Each new owner\n>>>> of the\n>>>> > coin will have to store its entire history, and when he spends the\n>>>> coin, he\n>>>> > forwards the entire history to the next owner and extends it with his\n>>>> own\n>>>> > transaction.\n>>>> >\n>>>> > If we apply the existing bitcoin design that allows multiple inputs\n>>>> and\n>>>> > multiple outputs per transaction, the history of ownership transfers\n>>>> would\n>>>> > grow exponentially.  Indeed, if we take any regular bitcoin output\n>>>> and try\n>>>> > to track its history back to coinbase, our history will branch every\n>>>> time\n>>>> > we see a transaction that has more than one input (which is not\n>>>> uncommon).\n>>>> > After such a transaction (remember, we are traveling back in time),\n>>>> we\u2019ll\n>>>> > have to track two or more histories, for each respective input.  Those\n>>>> > histories will branch again, and the total number of history entries\n>>>> grows\n>>>> > exponentially.  For example, if every transaction had exactly two\n>>>> inputs,\n>>>> > the size of history would grow as 2^N where N is the number of steps\n>>>> back\n>>>> > in history.\n>>>> >\n>>>> > To avoid such rapid growth of ownership history (which is not only\n>>>> > inconvenient to move, but also exposes too much private information\n>>>> about\n>>>> > previous owners of all the contributing coins), we will require each\n>>>> > private transaction to have exactly one input (i.e. to consume\n>>>> exactly one\n>>>> > previous output).  This means that when we track a coin\u2019s history\n>>>> back in\n>>>> > time, it will no longer branch.  It will grow linearly with the\n>>>> number of\n>>>> > transfers of ownership.  If a user wants to combine several inputs,\n>>>> he will\n>>>> > have to send them as separate private transactions (technically,\n>>>> several\n>>>> > OP_RETURNs, which can be included in a single regular bitcoin\n>>>> transaction).\n>>>> >\n>>>> > Thus, we are now forbidding any coin merges but still allowing coin\n>>>> > splits.  To avoid ultimate splitting into the dust, we will also\n>>>> require\n>>>> > that all private coins be issued in one of a small number of\n>>>> > denominations.  Only integer number of \u201cbanknotes\u201d can be\n>>>> transferred, the\n>>>> > input and output amounts must therefore be divisible by the\n>>>> denomination.\n>>>> > For example, an input of amount 700, denomination 100, can be split\n>>>> into\n>>>> > outputs 400 and 300, but not into 450 and 250.  To send a payment, the\n>>>> > payer has to pick the unspent outputs of the highest denomination\n>>>> first,\n>>>> > then the second highest, and so on, like we already do when we pay in\n>>>> cash.\n>>>> >\n>>>> > With fixed denominations and one input per transaction, coin histories\n>>>> > still grow, but only linearly, which should not be a concern in\n>>>> regard to\n>>>> > scalability given that all relevant computing resources still grow\n>>>> > exponentially.  The histories need to be stored only by the current\n>>>> owner\n>>>> > of the coin, not every bitcoin node.  This is a fairer allocation of\n>>>> > costs.  Regarding privacy, coin histories do expose private\n>>>> transactions\n>>>> > (or rather parts thereof, since a typical payment will likely consist\n>>>> of\n>>>> > several transactions due to one-input-per-transaction rule) of past\n>>>> coin\n>>>> > owners to the future ones, and that exposure grows linearly with\n>>>> time, but\n>>>> > it is still much much better than having every transaction\n>>>> immediately on\n>>>> > the public blockchain.  Also, the value of this information for\n>>>> potential\n>>>> > adversaries arguably decreases with time.\n>>>> >\n>>>> > There is one technical nuance that I omitted above to avoid\n>>>> distraction.\n>>>> >  Unlike regular bitcoin transactions, every output in a private\n>>>> payment\n>>>> > must also include a blinding factor, which is just a random string.\n>>>> When\n>>>> > the output is spent, the corresponding spend proof will therefore\n>>>> depend on\n>>>> > this blinding factor (remember that spend proof is just a hash of the\n>>>> > output).  Without a blinding factor, it would be feasible to\n>>>> pre-image the\n>>>> > spend proof and reveal the output being spent as the search space of\n>>>> all\n>>>> > possible outputs is rather small.\n>>>> >\n>>>> > To issue the new private coin, one can burn regular BTC by sending it\n>>>> to\n>>>> > one of several unspendable bitcoin addresses, one address per\n>>>> denomination.\n>>>> >  Burning BTC would entitle one to an equal amount of the new private\n>>>> coin,\n>>>> > let\u2019s call it *black bitcoin*, or *BBC*.\n>>>> >\n>>>> > Then BBC would be transferred from user to user by:\n>>>> > 1. creating a private transaction, which consists of one input and\n>>>> several\n>>>> > outputs;\n>>>> > 2. storing the hash of the transaction and the spend proof of the\n>>>> consumed\n>>>> > output into the blockchain in an OP_RETURN (the sender pays the\n>>>> > corresponding fees in regular BTC)\n>>>> > 3. sending the transaction, together with the history leading to its\n>>>> input,\n>>>> > directly to the payee over a private communication channel.  The first\n>>>> > entry of the history must be a bitcoin transaction that burned BTC to\n>>>> issue\n>>>> > an equal amount of BCC.\n>>>> >\n>>>> > To verify the payment, the payee:\n>>>> > 1. makes sure that the amount of the input matches the sum of\n>>>> outputs, and\n>>>> > all are divisible by the denomination\n>>>> > 2. calculates the hash of the private transaction\n>>>> > 3. looks up an OP_RETURN that includes this hash and is signed by the\n>>>> > payee.  If there is more than one, the one that comes in the earlier\n>>>> block\n>>>> > prevails.\n>>>> > 4. calculates the spend proof and makes sure that it is included in\n>>>> the\n>>>> > same OP_RETURN\n>>>> > 5. makes sure the same spend proof is not included anywhere in the\n>>>> same or\n>>>> > earlier blocks (that is, the coin was not spent before).  Only\n>>>> transactions\n>>>> > by the same author are searched.\n>>>> > 6. repeats the same steps for every entry in the history, except the\n>>>> first\n>>>> > entry, which should be a valid burning transaction.\n>>>> >\n>>>> > To facilitate exchange of private transaction data, the bitcoin\n>>>> network\n>>>> > protocol can be extended with a new message type.  Unfortunately, it\n>>>> lacks\n>>>> > encryption, hence private payments are really private only when\n>>>> bitcoin is\n>>>> > used over tor.\n>>>> >\n>>>> > There are a few limitations that ought to be mentioned:\n>>>> > 1. After user A sends a private payment to user B, user A will know\n>>>> what\n>>>> > the spend proof is going to be when B decides to spend the coin.\n>>>> >  Therefore, A will know when the coin was spent by B, but nothing\n>>>> more.\n>>>> >  Neither the new owner of the coin, nor its future movements will be\n>>>> known\n>>>> > to A.\n>>>> > 2. Over time, larger outputs will likely be split into many smaller\n>>>> > outputs, whose amounts are not much greater than their denominations.\n>>>> > You\u2019ll have to combine more inputs to send the same amount.  When you\n>>>> want\n>>>> > to send a very large amount that is much greater than the highest\n>>>> available\n>>>> > denomination, you\u2019ll have to send a lot of private transactions, your\n>>>> > bitcoin transaction with so many OP_RETURNs will stand out, and their\n>>>> > number will roughly indicate the total amount.  This kind of privacy\n>>>> > leakage, however it applies to a small number of users, is easy to\n>>>> avoid by\n>>>> > using multiple addresses and storing a relatively small amount on each\n>>>> > address.\n>>>> > 3. Exchanges and large merchants will likely accumulate large coin\n>>>> > histories.  Although fragmented, far from complete, and likely\n>>>> outdated, it\n>>>> > is still something to bear in mind.\n>>>> >\n>>>> > No hard or soft fork is required, BBC is just a separate privacy\n>>>> preserving\n>>>> > currency on top of bitcoin blockchain, and the same private keys and\n>>>> > addresses are used for both BBC and the base currency BTC.  Every BCC\n>>>> > transaction must be enclosed into by a small BTC transaction that\n>>>> stores\n>>>> > the OP_RETURNs and pays for the fees.\n>>>> >\n>>>> > Are there any flaws in this design?\n>>>> >\n>>>> > Originally posted to BCT\n>>>> https://bitcointalk.org/index.php?topic=1574508.0,\n>>>> > but got no feedback so far, apparently everybody was consumed with\n>>>> bitfinex\n>>>> > drama and now mimblewimble.\n>>>> >\n>>>> > Tony\n>>>>\n>>>> > _______________________________________________\n>>>> > bitcoin-dev mailing list\n>>>> > bitcoin-dev at lists.linuxfoundation.org\n>>>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>\n>>>>\n>>>> --\n>>>> Henning Kopp\n>>>> Institute of Distributed Systems\n>>>> Ulm University, Germany\n>>>>\n>>>> Office: O27 - 3402\n>>>> Phone: +49 731 50-24138\n>>>> Web: http://www.uni-ulm.de/in/vs/~kopp\n>>>>\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160809/09443165/attachment-0001.html>"
            },
            {
                "author": "James MacWhyte",
                "date": "2016-08-10T04:31:11",
                "message_text_only": "Signed by the key pair that was referenced in the output of the on-chain\ntransaction? (Bob in my example, actually) Doesn't that mean it's easy to\nfollow who is paying whom, you just can't see how much is going to reach\nrecipient?\n\nOn Tue, Aug 9, 2016, 04:40 Tony Churyumoff <tony991 at gmail.com> wrote:\n\n> This troll is harmless.  A duplicate spend proof should also be signed\n> by the same user (Alice, in your example) to be considered a double\n> spend.\n>\n> 2016-08-09 3:18 GMT+03:00 James MacWhyte <macwhyte at gmail.com>:\n> > One more thought about why verification by miners may be needed.\n> >\n> > Let's say Alice sends Bob a transaction, generating output C.\n> >\n> > A troll, named Timothy, broadcasts a transaction with a random hash,\n> > referencing C's output as its spend proof. The miners can't tell if it's\n> > valid or not, and so they include the transaction in a block. Now Bob's\n> > money is useless, because everyone can see the spend proof referenced and\n> > thinks it has already been spent, even though the transaction that\n> claims it\n> > isn't valid.\n> >\n> > Did I miss something that protects against this?\n> >\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160810/718af0de/attachment.html>"
            },
            {
                "author": "Tony Churyumoff",
                "date": "2016-08-10T08:37:37",
                "message_text_only": "> Signed by the key pair that was referenced in the output of the on-chain\n> transaction?\n\nSigned by the key pair referenced in the private output.\n\n>  (Bob in my example, actually)\n\nI misread your example.  If it was Bob, then the troll couldn't\ngenerate the correct spend proof because he didn't see the private\noutput C.  The troll could try to replay the spend proof in the\nAlice's transaction as soon as he sees it in the mempool, but then the\nspend proof would be signed by the wrong user.\n\n> Doesn't that mean it's easy to\n> follow who is paying whom, you just can't see how much is going to reach\n> recipient?\n\nOnly the recipients of the private outputs can see the previous owners\nof the coins they receive (including amounts).  What everybody else\nsees, is just meaningless hashes that hide both the recipient of the\ncoin and the amount.\n\n\n2016-08-10 7:31 GMT+03:00 James MacWhyte <macwhyte at gmail.com>:\n> Signed by the key pair that was referenced in the output of the on-chain\n> transaction? (Bob in my example, actually) Doesn't that mean it's easy to\n> follow who is paying whom, you just can't see how much is going to reach\n> recipient?\n>\n> On Tue, Aug 9, 2016, 04:40 Tony Churyumoff <tony991 at gmail.com> wrote:\n>>\n>> This troll is harmless.  A duplicate spend proof should also be signed\n>> by the same user (Alice, in your example) to be considered a double\n>> spend.\n>>\n>> 2016-08-09 3:18 GMT+03:00 James MacWhyte <macwhyte at gmail.com>:\n>> > One more thought about why verification by miners may be needed.\n>> >\n>> > Let's say Alice sends Bob a transaction, generating output C.\n>> >\n>> > A troll, named Timothy, broadcasts a transaction with a random hash,\n>> > referencing C's output as its spend proof. The miners can't tell if it's\n>> > valid or not, and so they include the transaction in a block. Now Bob's\n>> > money is useless, because everyone can see the spend proof referenced\n>> > and\n>> > thinks it has already been spent, even though the transaction that\n>> > claims it\n>> > isn't valid.\n>> >\n>> > Did I miss something that protects against this?\n>> >"
            }
        ],
        "thread_summary": {
            "title": "Hiding entire content of on-chain transactions",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Henning Kopp",
                "Tony Churyumoff",
                "James MacWhyte",
                "Peter Todd"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 98868
        }
    },
    {
        "title": "[bitcoin-dev] BIP Number Request: Addresses over Audio",
        "thread_messages": [
            {
                "author": "Daniel Hoffman",
                "date": "2016-08-08T21:22:44",
                "message_text_only": "This is my BIP idea: a fast, robust, and standardized for representing\nBitcoin addresses over audio. It takes the binary representation of the\nBitcoin address (little endian), chops that up into 4 or 2 bit chunks\n(depending on type, 2 bit only for low quality audio like american\ntelephone lines), and generates a tone based upon that value. This started\nbecause I wanted an easy way to donate to podcasts that I listen to, and\nhaving a Shazam-esque app (or a media player with this capability) that\ngives me an address automatically would be wonderful for both the consumer\nand producer. Comes with error correction built into the protocol\n\nYou can see the full specification of the BIP on my GitHub page (\nhttps://github.com/Dako300/BIP-0153).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/6d625f95/attachment.html>"
            },
            {
                "author": "Justin Newton",
                "date": "2016-08-08T22:06:05",
                "message_text_only": "Daniel,\n   Thanks for proposing this.  I think this could have some useful use\ncases as you state.  I was wondering what you would think to adding some\nadditional tones to optionally denote an amount (in satoshis?).\n\n(FYI, actual link is here:  https://github.com/Dako300/BIP )\n\nJustin\n\nOn Mon, Aug 8, 2016 at 2:22 PM, Daniel Hoffman via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> This is my BIP idea: a fast, robust, and standardized for representing\n> Bitcoin addresses over audio. It takes the binary representation of the\n> Bitcoin address (little endian), chops that up into 4 or 2 bit chunks\n> (depending on type, 2 bit only for low quality audio like american\n> telephone lines), and generates a tone based upon that value. This started\n> because I wanted an easy way to donate to podcasts that I listen to, and\n> having a Shazam-esque app (or a media player with this capability) that\n> gives me an address automatically would be wonderful for both the consumer\n> and producer. Comes with error correction built into the protocol\n>\n> You can see the full specification of the BIP on my GitHub page (\n> https://github.com/Dako300/BIP-0153).\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n\n\n-- \n\nJustin W. Newton\nFounder/CEO\nNetki, Inc.\n\njustin at netki.com\n+1.818.261.4248\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/4ea7b965/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: PastedGraphic-1.tiff\nType: image/tiff\nSize: 10972 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/4ea7b965/attachment.tiff>"
            },
            {
                "author": "Daniel Hoffman",
                "date": "2016-08-08T22:35:32",
                "message_text_only": "I wouldn't worry about payment requests until I built a decoder and made\nthe transmission a lot faster (probably adding tones and making it 5 bits\nwide), which shouldn't be hard\n\nOn Mon, Aug 8, 2016 at 5:06 PM, Justin Newton via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Daniel,\n>    Thanks for proposing this.  I think this could have some useful use\n> cases as you state.  I was wondering what you would think to adding some\n> additional tones to optionally denote an amount (in satoshis?).\n>\n> (FYI, actual link is here:  https://github.com/Dako300/BIP )\n>\n> Justin\n>\n> On Mon, Aug 8, 2016 at 2:22 PM, Daniel Hoffman via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> This is my BIP idea: a fast, robust, and standardized for representing\n>> Bitcoin addresses over audio. It takes the binary representation of the\n>> Bitcoin address (little endian), chops that up into 4 or 2 bit chunks\n>> (depending on type, 2 bit only for low quality audio like american\n>> telephone lines), and generates a tone based upon that value. This started\n>> because I wanted an easy way to donate to podcasts that I listen to, and\n>> having a Shazam-esque app (or a media player with this capability) that\n>> gives me an address automatically would be wonderful for both the consumer\n>> and producer. Comes with error correction built into the protocol\n>>\n>> You can see the full specification of the BIP on my GitHub page (\n>> https://github.com/Dako300/BIP-0153).\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>\n>\n> --\n>\n> Justin W. Newton\n> Founder/CEO\n> Netki, Inc.\n>\n> justin at netki.com\n> +1.818.261.4248\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/f5f3271e/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: PastedGraphic-1.tiff\nType: image/tiff\nSize: 10972 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/f5f3271e/attachment.tiff>"
            },
            {
                "author": "Trevin Hofmann",
                "date": "2016-08-08T22:59:25",
                "message_text_only": "Would it be feasible to transmit an entire BIP21 URI as audio? If you were\nto encode any extra information (such as amount), it would be useful to\ninclude a checksum for the entire message. This checksum could possibly be\nused instead of the checksum in the address.\n\nTrevin\n\nOn Aug 8, 2016 3:06 PM, \"Justin Newton via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Daniel,\n>    Thanks for proposing this.  I think this could have some useful use\n> cases as you state.  I was wondering what you would think to adding some\n> additional tones to optionally denote an amount (in satoshis?).\n>\n> (FYI, actual link is here:  https://github.com/Dako300/BIP )\n>\n> Justin\n>\n> On Mon, Aug 8, 2016 at 2:22 PM, Daniel Hoffman via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> This is my BIP idea: a fast, robust, and standardized for representing\n>> Bitcoin addresses over audio. It takes the binary representation of the\n>> Bitcoin address (little endian), chops that up into 4 or 2 bit chunks\n>> (depending on type, 2 bit only for low quality audio like american\n>> telephone lines), and generates a tone based upon that value. This started\n>> because I wanted an easy way to donate to podcasts that I listen to, and\n>> having a Shazam-esque app (or a media player with this capability) that\n>> gives me an address automatically would be wonderful for both the consumer\n>> and producer. Comes with error correction built into the protocol\n>>\n>> You can see the full specification of the BIP on my GitHub page (\n>> https://github.com/Dako300/BIP-0153).\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>\n>\n> --\n>\n> Justin W. Newton\n> Founder/CEO\n> Netki, Inc.\n>\n> justin at netki.com\n> +1.818.261.4248\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/8f8844cf/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: PastedGraphic-1.tiff\nType: image/tiff\nSize: 10972 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/8f8844cf/attachment-0001.tiff>"
            },
            {
                "author": "Daniel Hoffman",
                "date": "2016-08-09T01:50:00",
                "message_text_only": "It wouldn't be feasible in the vast majority of cases, but I can't think of\na reason why it can't be built into the standard.\n\nOn Mon, Aug 8, 2016 at 5:59 PM, Trevin Hofmann via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Would it be feasible to transmit an entire BIP21 URI as audio? If you were\n> to encode any extra information (such as amount), it would be useful to\n> include a checksum for the entire message. This checksum could possibly be\n> used instead of the checksum in the address.\n>\n> Trevin\n>\n> On Aug 8, 2016 3:06 PM, \"Justin Newton via bitcoin-dev\" <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Daniel,\n>>    Thanks for proposing this.  I think this could have some useful use\n>> cases as you state.  I was wondering what you would think to adding some\n>> additional tones to optionally denote an amount (in satoshis?).\n>>\n>> (FYI, actual link is here:  https://github.com/Dako300/BIP )\n>>\n>> Justin\n>>\n>> On Mon, Aug 8, 2016 at 2:22 PM, Daniel Hoffman via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> This is my BIP idea: a fast, robust, and standardized for representing\n>>> Bitcoin addresses over audio. It takes the binary representation of the\n>>> Bitcoin address (little endian), chops that up into 4 or 2 bit chunks\n>>> (depending on type, 2 bit only for low quality audio like american\n>>> telephone lines), and generates a tone based upon that value. This started\n>>> because I wanted an easy way to donate to podcasts that I listen to, and\n>>> having a Shazam-esque app (or a media player with this capability) that\n>>> gives me an address automatically would be wonderful for both the consumer\n>>> and producer. Comes with error correction built into the protocol\n>>>\n>>> You can see the full specification of the BIP on my GitHub page (\n>>> https://github.com/Dako300/BIP-0153).\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>>\n>>\n>>\n>> --\n>>\n>> Justin W. Newton\n>> Founder/CEO\n>> Netki, Inc.\n>>\n>> justin at netki.com\n>> +1.818.261.4248\n>>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/6b858c35/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: PastedGraphic-1.tiff\nType: image/tiff\nSize: 10972 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/6b858c35/attachment-0001.tiff>"
            },
            {
                "author": "Daniel Hoffman",
                "date": "2016-08-09T23:06:20",
                "message_text_only": "I have updated the GitHub a lot (changed tones to be less chirpy, fixed\nsome smalls) and made a couple of samples (see attachment for MP3 and FLAC\nof both tone tables, first 16 then 4). Is this good enough to warrant an\nofficial BIP number? I haven't built a decoder yet, but it seems like the\nencoder is working properly (looked at Audacity, seems like it is working),\nand some people on reddit want to \"allow for decoding experiments\"\n<https://www.reddit.com/r/btc/comments/4wsn7v/bip_proposal_addresses_over_audio_thoughts/d69m3st>\n\nWhat suggestions do you all have for it?\n\nOn Mon, Aug 8, 2016 at 8:50 PM, Daniel Hoffman <danielhoffman699 at gmail.com>\nwrote:\n\n> It wouldn't be feasible in the vast majority of cases, but I can't think\n> of a reason why it can't be built into the standard.\n>\n> On Mon, Aug 8, 2016 at 5:59 PM, Trevin Hofmann via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Would it be feasible to transmit an entire BIP21 URI as audio? If you\n>> were to encode any extra information (such as amount), it would be useful\n>> to include a checksum for the entire message. This checksum could possibly\n>> be used instead of the checksum in the address.\n>>\n>> Trevin\n>>\n>> On Aug 8, 2016 3:06 PM, \"Justin Newton via bitcoin-dev\" <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Daniel,\n>>>    Thanks for proposing this.  I think this could have some useful use\n>>> cases as you state.  I was wondering what you would think to adding some\n>>> additional tones to optionally denote an amount (in satoshis?).\n>>>\n>>> (FYI, actual link is here:  https://github.com/Dako300/BIP )\n>>>\n>>> Justin\n>>>\n>>> On Mon, Aug 8, 2016 at 2:22 PM, Daniel Hoffman via bitcoin-dev <\n>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>>> This is my BIP idea: a fast, robust, and standardized for representing\n>>>> Bitcoin addresses over audio. It takes the binary representation of the\n>>>> Bitcoin address (little endian), chops that up into 4 or 2 bit chunks\n>>>> (depending on type, 2 bit only for low quality audio like american\n>>>> telephone lines), and generates a tone based upon that value. This started\n>>>> because I wanted an easy way to donate to podcasts that I listen to, and\n>>>> having a Shazam-esque app (or a media player with this capability) that\n>>>> gives me an address automatically would be wonderful for both the consumer\n>>>> and producer. Comes with error correction built into the protocol\n>>>>\n>>>> You can see the full specification of the BIP on my GitHub page (\n>>>> https://github.com/Dako300/BIP-0153).\n>>>>\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>\n>>>>\n>>>\n>>>\n>>> --\n>>>\n>>> Justin W. Newton\n>>> Founder/CEO\n>>> Netki, Inc.\n>>>\n>>> justin at netki.com\n>>> +1.818.261.4248\n>>>\n>>>\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160809/e580ef48/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: PastedGraphic-1.tiff\nType: image/tiff\nSize: 10972 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160809/e580ef48/attachment-0001.tiff>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: BIP_latest_custom_address.flac\nType: audio/flac\nSize: 2484566 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160809/e580ef48/attachment-0001.bin>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: BIP_latest_custom_address.mp3\nType: audio/mpeg\nSize: 585142 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160809/e580ef48/attachment-0001.mp3>"
            },
            {
                "author": "Jannes Faber",
                "date": "2016-08-10T00:17:35",
                "message_text_only": "Wow. No value judgement, but 1980 called, they want their radio broadcast\nfor analogue modems back. Both very cool and very cringe worthy.\n\nIt sounds quite horrible tbh. Imagine this being as pervasive as bar and qr\ncodes. And it's as meaningful and unpleasant to the human ear as a qr code\nis to the eye.\n\nPlease think of something like using a Mozart symphony as the carrier wave\nonto which you modulate your signal. Let the notes last a little longer to\nrepresent a 1 bit. Or change the tempo. Or add an echo. Make it so the\nlistener can interpret it as a generic not too annoying tune and not even\nrealise it's different every time without being an audiophile.\n\nMaybe have a 100 different base tunes from mozart to hiphop so the user can\npick one suitable to their audience and context. Maybe have some that don't\ninterfere with human speech frequencies so narrator can keep talking right\nover it.\n\nI guess it may be tricky because you want your signal to survive\nre-encoding as increased playback speeds.\n\nAnother consideration: you want a preamble that is very easy to detect, so\nit doesn't cost a lot of CPU (battery) to have your podcast player\ncontinuously scanning for these things.\n\nNot sure all these wishes are possible at the same time, but surely there's\nresearch around on some?.\n\nOn 10 Aug 2016 1:28 a.m., \"Daniel Hoffman via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I have updated the GitHub a lot (changed tones to be less chirpy, fixed\n> some smalls) and made a couple of samples (see attachment for MP3 and FLAC\n> of both tone tables, first 16 then 4). Is this good enough to warrant an\n> official BIP number? I haven't built a decoder yet, but it seems like the\n> encoder is working properly (looked at Audacity, seems like it is working),\n> and some people on reddit want to \"allow for decoding experiments\"\n> <https://www.reddit.com/r/btc/comments/4wsn7v/bip_proposal_addresses_over_audio_thoughts/d69m3st>\n>\n> What suggestions do you all have for it?\n>\n> On Mon, Aug 8, 2016 at 8:50 PM, Daniel Hoffman <danielhoffman699 at gmail.com\n> > wrote:\n>\n>> It wouldn't be feasible in the vast majority of cases, but I can't think\n>> of a reason why it can't be built into the standard.\n>>\n>> On Mon, Aug 8, 2016 at 5:59 PM, Trevin Hofmann via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Would it be feasible to transmit an entire BIP21 URI as audio? If you\n>>> were to encode any extra information (such as amount), it would be useful\n>>> to include a checksum for the entire message. This checksum could possibly\n>>> be used instead of the checksum in the address.\n>>>\n>>> Trevin\n>>>\n>>> On Aug 8, 2016 3:06 PM, \"Justin Newton via bitcoin-dev\" <\n>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>>> Daniel,\n>>>>    Thanks for proposing this.  I think this could have some useful use\n>>>> cases as you state.  I was wondering what you would think to adding some\n>>>> additional tones to optionally denote an amount (in satoshis?).\n>>>>\n>>>> (FYI, actual link is here:  https://github.com/Dako300/BIP )\n>>>>\n>>>> Justin\n>>>>\n>>>> On Mon, Aug 8, 2016 at 2:22 PM, Daniel Hoffman via bitcoin-dev <\n>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>>\n>>>>> This is my BIP idea: a fast, robust, and standardized for representing\n>>>>> Bitcoin addresses over audio. It takes the binary representation of the\n>>>>> Bitcoin address (little endian), chops that up into 4 or 2 bit chunks\n>>>>> (depending on type, 2 bit only for low quality audio like american\n>>>>> telephone lines), and generates a tone based upon that value. This started\n>>>>> because I wanted an easy way to donate to podcasts that I listen to, and\n>>>>> having a Shazam-esque app (or a media player with this capability) that\n>>>>> gives me an address automatically would be wonderful for both the consumer\n>>>>> and producer. Comes with error correction built into the protocol\n>>>>>\n>>>>> You can see the full specification of the BIP on my GitHub page (\n>>>>> https://github.com/Dako300/BIP-0153).\n>>>>>\n>>>>> _______________________________________________\n>>>>> bitcoin-dev mailing list\n>>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>>\n>>>>>\n>>>>\n>>>>\n>>>> --\n>>>>\n>>>> Justin W. Newton\n>>>> Founder/CEO\n>>>> Netki, Inc.\n>>>>\n>>>> justin at netki.com\n>>>> +1.818.261.4248\n>>>>\n>>>>\n>>>>\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>\n>>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>>\n>>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160810/a08aa8b1/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: PastedGraphic-1.tiff\nType: image/tiff\nSize: 10972 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160810/a08aa8b1/attachment-0001.tiff>"
            },
            {
                "author": "Chris Riley",
                "date": "2016-08-10T00:27:57",
                "message_text_only": "Have you checked AudioModem out:\nhttps://github.com/applidium/AudioModem\n\nOr Chirp:\nhttp://www.chirp.io/faq/\n\nOr this Network World article (particularly the last portion on bitcoin):\nhttp://www.networkworld.com/article/2956450/smartphones/sending-data-over-sound-revisited.html\nand\nhttp://www.networkworld.com/article/2689597/opensource-subnet/how-a-tv-network-is-being-used-to-move-financial-transactions.html\n\nInstead of re-inventing the wheel, perhaps take a look at them.  Or at\nleast to see their design choices and rationale.\n\nCheers!\n\n\nOn Tue, Aug 9, 2016 at 7:06 PM, Daniel Hoffman via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I have updated the GitHub a lot (changed tones to be less chirpy, fixed\n> some smalls) and made a couple of samples (see attachment for MP3 and FLAC\n> of both tone tables, first 16 then 4). Is this good enough to warrant an\n> official BIP number? I haven't built a decoder yet, but it seems like the\n> encoder is working properly (looked at Audacity, seems like it is working),\n> and some people on reddit want to \"allow for decoding experiments\"\n> <https://www.reddit.com/r/btc/comments/4wsn7v/bip_proposal_addresses_over_audio_thoughts/d69m3st>\n>\n> What suggestions do you all have for it?\n>\n> On Mon, Aug 8, 2016 at 8:50 PM, Daniel Hoffman <danielhoffman699 at gmail.com\n> > wrote:\n>\n>> It wouldn't be feasible in the vast majority of cases, but I can't think\n>> of a reason why it can't be built into the standard.\n>>\n>> On Mon, Aug 8, 2016 at 5:59 PM, Trevin Hofmann via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Would it be feasible to transmit an entire BIP21 URI as audio? If you\n>>> were to encode any extra information (such as amount), it would be useful\n>>> to include a checksum for the entire message. This checksum could possibly\n>>> be used instead of the checksum in the address.\n>>>\n>>> Trevin\n>>>\n>>> On Aug 8, 2016 3:06 PM, \"Justin Newton via bitcoin-dev\" <\n>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>>> Daniel,\n>>>>    Thanks for proposing this.  I think this could have some useful use\n>>>> cases as you state.  I was wondering what you would think to adding some\n>>>> additional tones to optionally denote an amount (in satoshis?).\n>>>>\n>>>> (FYI, actual link is here:  https://github.com/Dako300/BIP )\n>>>>\n>>>> Justin\n>>>>\n>>>> On Mon, Aug 8, 2016 at 2:22 PM, Daniel Hoffman via bitcoin-dev <\n>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>>\n>>>>> This is my BIP idea: a fast, robust, and standardized for representing\n>>>>> Bitcoin addresses over audio. It takes the binary representation of the\n>>>>> Bitcoin address (little endian), chops that up into 4 or 2 bit chunks\n>>>>> (depending on type, 2 bit only for low quality audio like american\n>>>>> telephone lines), and generates a tone based upon that value. This started\n>>>>> because I wanted an easy way to donate to podcasts that I listen to, and\n>>>>> having a Shazam-esque app (or a media player with this capability) that\n>>>>> gives me an address automatically would be wonderful for both the consumer\n>>>>> and producer. Comes with error correction built into the protocol\n>>>>>\n>>>>> You can see the full specification of the BIP on my GitHub page (\n>>>>> https://github.com/Dako300/BIP-0153).\n>>>>>\n>>>>> _______________________________________________\n>>>>> bitcoin-dev mailing list\n>>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>>\n>>>>>\n>>>>\n>>>>\n>>>> --\n>>>>\n>>>> Justin W. Newton\n>>>> Founder/CEO\n>>>> Netki, Inc.\n>>>>\n>>>> justin at netki.com\n>>>> +1.818.261.4248\n>>>>\n>>>>\n>>>>\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>\n>>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>>\n>>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160809/231ed5cb/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: PastedGraphic-1.tiff\nType: image/tiff\nSize: 10972 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160809/231ed5cb/attachment-0001.tiff>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2016-08-10T00:36:04",
                "message_text_only": "On Tuesday, August 09, 2016 11:06:20 PM Daniel Hoffman via bitcoin-dev wrote:\n> Is this good enough to warrant an official BIP number?\n\nYeah, let's call it BIP 170.\n\nNext step is to:\n- Fix the BIP number in the file\n- Format it in the usual BIP mediawiki format instead of markdown\n- Add it to a fork of the bitcoin/bips git repository\n- Open a pull request against bitcoin/bips\n\nP.S. Why are telephones considered 4-tone? DTMF is 16-tone IIRC?"
            },
            {
                "author": "Thomas Daede",
                "date": "2016-08-10T01:09:50",
                "message_text_only": "If this is just encoding BIP-21 addresses, it is basically an \"audio QR\ncode\". In this case, does publishing it as a BIP still make sense? (Not\nto imply that it doesn't, but it's something you should consider.)\n\nPlease look at existing implementations of audio modems when creating\nyour design. A lot of this work has been done many times before, so\nthere is a lot to learn from.\n\nYour selected frequencies are harmonics of each other, meaning nonlinear\ndistortion will make detection more difficult. The Bell 202 and similar\nmodem standards chose AFSK frequencies to minimize interference.\n\nRepeating a message multiple times is a very inefficient method of error\nrecovery. It works, but there may be better techniques, such as trellis\nmodulation or other convolutional codes.\n\nDefining channel models to simulate your various use cases will help a\nlot to determine if you have met your requirements.\n\n- Thomas\n\nP.S. I also briefly considered audio to exchange transactions with a\nhardware wallet. Using GNU Radio made the implementation much easier.\n\nOn 08/09/2016 04:06 PM, Daniel Hoffman via bitcoin-dev wrote:\n> I have updated the GitHub a lot (changed tones to be less chirpy, fixed\n> some smalls) and made a couple of samples (see attachment for MP3 and\n> FLAC of both tone tables, first 16 then 4). Is this good enough to\n> warrant an official BIP number? I haven't built a decoder yet, but it\n> seems like the encoder is working properly (looked at Audacity, seems\n> like it is working), and some people on reddit want to \"allow for\n> decoding experiments\"\n> <https://www.reddit.com/r/btc/comments/4wsn7v/bip_proposal_addresses_over_audio_thoughts/d69m3st>\n> \n> What suggestions do you all have for it?\n> \n> On Mon, Aug 8, 2016 at 8:50 PM, Daniel Hoffman\n> <danielhoffman699 at gmail.com <mailto:danielhoffman699 at gmail.com>> wrote:\n> \n>     It wouldn't be feasible in the vast majority of cases, but I can't\n>     think of a reason why it can't be built into the standard.\n> \n>     On Mon, Aug 8, 2016 at 5:59 PM, Trevin Hofmann via bitcoin-dev\n>     <bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> \n>         Would it be feasible to transmit an entire BIP21 URI as audio?\n>         If you were to encode any extra information (such as amount), it\n>         would be useful to include a checksum for the entire message.\n>         This checksum could possibly be used instead of the checksum in\n>         the address.\n> \n>         Trevin\n> \n> \n>         On Aug 8, 2016 3:06 PM, \"Justin Newton via bitcoin-dev\"\n>         <bitcoin-dev at lists.linuxfoundation.org\n>         <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> \n>             Daniel,\n>                Thanks for proposing this.  I think this could have some\n>             useful use cases as you state.  I was wondering what you\n>             would think to adding some additional tones to optionally\n>             denote an amount (in satoshis?).\n> \n>             (FYI, actual link is here:  https://github.com/Dako300/BIP\n>             <https://github.com/Dako300/BIP> )\n> \n>             Justin\n> \n>             On Mon, Aug 8, 2016 at 2:22 PM, Daniel Hoffman via\n>             bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org\n>             <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> \n>                 This is my BIP idea: a fast, robust, and standardized\n>                 for representing Bitcoin addresses over audio. It takes\n>                 the binary representation of the Bitcoin address (little\n>                 endian), chops that up into 4 or 2 bit chunks (depending\n>                 on type, 2 bit only for low quality audio like american\n>                 telephone lines), and generates a tone based upon that\n>                 value. This started because I wanted an easy way to\n>                 donate to podcasts that I listen to, and having a\n>                 Shazam-esque app (or a media player with this\n>                 capability) that gives me an address automatically would\n>                 be wonderful for both the consumer and producer. Comes\n>                 with error correction built into the protocol\n> \n>                 You can see the full specification of the BIP on my\n>                 GitHub page (https://github.com/Dako300/BIP-0153\n>                 <https://github.com/Dako300/BIP-0153>).\n> \n>                 _______________________________________________\n>                 bitcoin-dev mailing list\n>                 bitcoin-dev at lists.linuxfoundation.org\n>                 <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>                 https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>                 <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>\n> \n> \n> \n> \n>             -- \n> \n>             Justin W. Newton\n>             Founder/CEO\n>             Netki, Inc.\n> \n>             justin at netki.com <mailto:justin at netki.com>\n>             +1.818.261.4248 <tel:+1.818.261.4248>\n> \n> \n> \n>             _______________________________________________\n>             bitcoin-dev mailing list\n>             bitcoin-dev at lists.linuxfoundation.org\n>             <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>             https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>             <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>\n> \n> \n>         _______________________________________________\n>         bitcoin-dev mailing list\n>         bitcoin-dev at lists.linuxfoundation.org\n>         <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>         <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>\n> \n> \n> \n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Daniel Hoffman",
                "date": "2016-08-10T01:53:06",
                "message_text_only": "Thomas\nIn all honesty, I shouldn't have added the multiple feature. It should\nalways stay to one and have the Bitcoin address's built in checksum do all\nof the heavy lifting (or implement another checksum into the protocol).\nHaving said that, it would make the most sense to not include BIP21\nrequests. The frequencies that are going to be used are prone to being\nchanged (probably moving them into the ultrasound range, at least for the\n16 tones)\n\nLuke Dashjr\nI thought it was only 12, will change it accordingly.\n\nChris\nI looked at Audio Modem and will probably look at the others soon as well.\n\nThe general idea of this BIP is to see if you all even approve of the idea\nof sending Bitcoin addresses over sound waves. I will push it into the\nultrasound, and I might implement phase modulation.\n\nOn Tue, Aug 9, 2016 at 8:09 PM, Thomas Daede via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> If this is just encoding BIP-21 addresses, it is basically an \"audio QR\n> code\". In this case, does publishing it as a BIP still make sense? (Not\n> to imply that it doesn't, but it's something you should consider.)\n>\n> Please look at existing implementations of audio modems when creating\n> your design. A lot of this work has been done many times before, so\n> there is a lot to learn from.\n>\n> Your selected frequencies are harmonics of each other, meaning nonlinear\n> distortion will make detection more difficult. The Bell 202 and similar\n> modem standards chose AFSK frequencies to minimize interference.\n>\n> Repeating a message multiple times is a very inefficient method of error\n> recovery. It works, but there may be better techniques, such as trellis\n> modulation or other convolutional codes.\n>\n> Defining channel models to simulate your various use cases will help a\n> lot to determine if you have met your requirements.\n>\n> - Thomas\n>\n> P.S. I also briefly considered audio to exchange transactions with a\n> hardware wallet. Using GNU Radio made the implementation much easier.\n>\n> On 08/09/2016 04:06 PM, Daniel Hoffman via bitcoin-dev wrote:\n> > I have updated the GitHub a lot (changed tones to be less chirpy, fixed\n> > some smalls) and made a couple of samples (see attachment for MP3 and\n> > FLAC of both tone tables, first 16 then 4). Is this good enough to\n> > warrant an official BIP number? I haven't built a decoder yet, but it\n> > seems like the encoder is working properly (looked at Audacity, seems\n> > like it is working), and some people on reddit want to \"allow for\n> > decoding experiments\"\n> > <https://www.reddit.com/r/btc/comments/4wsn7v/bip_proposal_\n> addresses_over_audio_thoughts/d69m3st>\n> >\n> > What suggestions do you all have for it?\n> >\n> > On Mon, Aug 8, 2016 at 8:50 PM, Daniel Hoffman\n> > <danielhoffman699 at gmail.com <mailto:danielhoffman699 at gmail.com>> wrote:\n> >\n> >     It wouldn't be feasible in the vast majority of cases, but I can't\n> >     think of a reason why it can't be built into the standard.\n> >\n> >     On Mon, Aug 8, 2016 at 5:59 PM, Trevin Hofmann via bitcoin-dev\n> >     <bitcoin-dev at lists.linuxfoundation.org\n> >     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> >\n> >         Would it be feasible to transmit an entire BIP21 URI as audio?\n> >         If you were to encode any extra information (such as amount), it\n> >         would be useful to include a checksum for the entire message.\n> >         This checksum could possibly be used instead of the checksum in\n> >         the address.\n> >\n> >         Trevin\n> >\n> >\n> >         On Aug 8, 2016 3:06 PM, \"Justin Newton via bitcoin-dev\"\n> >         <bitcoin-dev at lists.linuxfoundation.org\n> >         <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> >\n> >             Daniel,\n> >                Thanks for proposing this.  I think this could have some\n> >             useful use cases as you state.  I was wondering what you\n> >             would think to adding some additional tones to optionally\n> >             denote an amount (in satoshis?).\n> >\n> >             (FYI, actual link is here:  https://github.com/Dako300/BIP\n> >             <https://github.com/Dako300/BIP> )\n> >\n> >             Justin\n> >\n> >             On Mon, Aug 8, 2016 at 2:22 PM, Daniel Hoffman via\n> >             bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org\n> >             <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> >\n> >                 This is my BIP idea: a fast, robust, and standardized\n> >                 for representing Bitcoin addresses over audio. It takes\n> >                 the binary representation of the Bitcoin address (little\n> >                 endian), chops that up into 4 or 2 bit chunks (depending\n> >                 on type, 2 bit only for low quality audio like american\n> >                 telephone lines), and generates a tone based upon that\n> >                 value. This started because I wanted an easy way to\n> >                 donate to podcasts that I listen to, and having a\n> >                 Shazam-esque app (or a media player with this\n> >                 capability) that gives me an address automatically would\n> >                 be wonderful for both the consumer and producer. Comes\n> >                 with error correction built into the protocol\n> >\n> >                 You can see the full specification of the BIP on my\n> >                 GitHub page (https://github.com/Dako300/BIP-0153\n> >                 <https://github.com/Dako300/BIP-0153>).\n> >\n> >                 _______________________________________________\n> >                 bitcoin-dev mailing list\n> >                 bitcoin-dev at lists.linuxfoundation.org\n> >                 <mailto:bitcoin-dev at lists.linuxfoundation.org>\n> >                 https://lists.linuxfoundation.\n> org/mailman/listinfo/bitcoin-dev\n> >                 <https://lists.linuxfoundation.org/mailman/\n> listinfo/bitcoin-dev>\n> >\n> >\n> >\n> >\n> >             --\n> >\n> >             Justin W. Newton\n> >             Founder/CEO\n> >             Netki, Inc.\n> >\n> >             justin at netki.com <mailto:justin at netki.com>\n> >             +1.818.261.4248 <tel:+1.818.261.4248>\n> >\n> >\n> >\n> >             _______________________________________________\n> >             bitcoin-dev mailing list\n> >             bitcoin-dev at lists.linuxfoundation.org\n> >             <mailto:bitcoin-dev at lists.linuxfoundation.org>\n> >             https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-\n> dev\n> >             <https://lists.linuxfoundation.org/mailman/\n> listinfo/bitcoin-dev>\n> >\n> >\n> >         _______________________________________________\n> >         bitcoin-dev mailing list\n> >         bitcoin-dev at lists.linuxfoundation.org\n> >         <mailto:bitcoin-dev at lists.linuxfoundation.org>\n> >         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >         <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>\n> >\n> >\n> >\n> >\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160809/5b88055b/attachment-0001.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2016-08-10T02:14:42",
                "message_text_only": "On Tue, Aug 9, 2016 at 11:06 PM, Daniel Hoffman via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I have updated the GitHub a lot (changed tones to be less chirpy, fixed\n> some smalls) and made a couple of samples (see attachment for MP3 and FLAC\n> of both tone tables, first 16 then 4). Is this good enough to warrant an\n> official BIP number? I haven't built a decoder yet, but it seems like the\n> encoder is working properly (looked at Audacity, seems like it is working),\n> and some people on reddit want to \"allow for decoding experiments\"\n> <https://www.reddit.com/r/btc/comments/4wsn7v/bip_proposal_addresses_over_audio_thoughts/d69m3st>\n>\n> What suggestions do you all have for it?\n>\n\n\nWith DSP hat on, your decoder for noisy/distorted channels will be 99.9% of\nthe complexity and will completely control the design of the encoder.\n\nIt's not a proposal yet without a decoder, it's just an idea.  FSK modems\nmicrophone-channel (terrible multipath) is quite challenging and several\nother parties have tried to do bitcoin info over audio in the past without\nsuccess.\n\nIt's very interesting, but I think you do need to go through and get the\nwhole thing working to really gauge viability.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160810/af156283/attachment.html>"
            },
            {
                "author": "Tier Nolan",
                "date": "2016-08-10T10:41:35",
                "message_text_only": "Have you considered CDMA?  This has the nice property that it just sounds\nlike noise.  The codes would take longer to send, but you could send\nmultiple bits at once and have the codes orthogonal.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160810/717d8ede/attachment.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2016-08-10T11:42:57",
                "message_text_only": "NOTE:\n\nAddresses aren't really meant to be broadcast - you should probably be\nencoding BIP32 public seeds, not addresses.\n\nOR simply:\n\n- Send btc to rick at q32.com\n- TXT record _btc.rick.q32.com is queried (_<coin-code>.<name>.<domain>)\n- DNS-SEC validation is *required*\n- TXT record contains addr:[<bip32-pub-seed>]\n\nThen you can just say, in the podcast, \"Send your bitcoin donations to\nrick at q32.com\".   And you can link it to your email address, if your\nprovider lets you set up a TXT record.   (By structuring the TXT record\nthat way, many existing email providers will support the standard without\nhaving to change anything.)\n\nThis works with audio, video, web and other publishing formats... and very\nlittle infrastructure change is needed.\n\n\nOn Wed, Aug 10, 2016 at 6:41 AM, Tier Nolan via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Have you considered CDMA?  This has the nice property that it just sounds\n> like noise.  The codes would take longer to send, but you could send\n> multiple bits at once and have the codes orthogonal.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160810/4af8834e/attachment.html>"
            },
            {
                "author": "Theo Chino",
                "date": "2016-08-10T11:49:16",
                "message_text_only": "Another use for the audio would be for watches that can listen but can't\nuse a camera (ie: Samsung S2), so sound would be great.\n\nOn Wed, Aug 10, 2016 at 7:42 AM, Erik Aronesty via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> NOTE:\n>\n> Addresses aren't really meant to be broadcast - you should probably be\n> encoding BIP32 public seeds, not addresses.\n>\n> OR simply:\n>\n> - Send btc to rick at q32.com\n> - TXT record _btc.rick.q32.com is queried (_<coin-code>.<name>.<domain>)\n> - DNS-SEC validation is *required*\n> - TXT record contains addr:[<bip32-pub-seed>]\n>\n> Then you can just say, in the podcast, \"Send your bitcoin donations to\n> rick at q32.com\".   And you can link it to your email address, if your\n> provider lets you set up a TXT record.   (By structuring the TXT record\n> that way, many existing email providers will support the standard without\n> having to change anything.)\n>\n> This works with audio, video, web and other publishing formats... and very\n> little infrastructure change is needed.\n>\n>\n> On Wed, Aug 10, 2016 at 6:41 AM, Tier Nolan via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Have you considered CDMA?  This has the nice property that it just sounds\n>> like noise.  The codes would take longer to send, but you could send\n>> multiple bits at once and have the codes orthogonal.\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160810/ac810b1a/attachment.html>"
            },
            {
                "author": "Daniel Hoffman",
                "date": "2016-08-10T16:01:15",
                "message_text_only": "Erik\nWhat would be the advantages of transmitting a BIP32 public seed, instead\nof a plain address?\n\nTheo\nI didn't really think of that, but that's genius.\n\nOn Wed, Aug 10, 2016 at 6:49 AM, Theo Chino via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Another use for the audio would be for watches that can listen but can't\n> use a camera (ie: Samsung S2), so sound would be great.\n>\n> On Wed, Aug 10, 2016 at 7:42 AM, Erik Aronesty via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> NOTE:\n>>\n>> Addresses aren't really meant to be broadcast - you should probably be\n>> encoding BIP32 public seeds, not addresses.\n>>\n>> OR simply:\n>>\n>> - Send btc to rick at q32.com\n>> - TXT record _btc.rick.q32.com is queried (_<coin-code>.<name>.<domain>)\n>> - DNS-SEC validation is *required*\n>> - TXT record contains addr:[<bip32-pub-seed>]\n>>\n>> Then you can just say, in the podcast, \"Send your bitcoin donations to\n>> rick at q32.com\".   And you can link it to your email address, if your\n>> provider lets you set up a TXT record.   (By structuring the TXT record\n>> that way, many existing email providers will support the standard without\n>> having to change anything.)\n>>\n>> This works with audio, video, web and other publishing formats... and\n>> very little infrastructure change is needed.\n>>\n>>\n>> On Wed, Aug 10, 2016 at 6:41 AM, Tier Nolan via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Have you considered CDMA?  This has the nice property that it just\n>>> sounds like noise.  The codes would take longer to send, but you could send\n>>> multiple bits at once and have the codes orthogonal.\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160810/8f1d1434/attachment-0001.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2016-08-10T17:28:16",
                "message_text_only": "By sending a public seed,  there's no way for someone to use the\ntransmitted address and trace the total amount of payments to it.\n\nOn Aug 10, 2016 12:02 PM, \"Daniel Hoffman via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Erik\n> What would be the advantages of transmitting a BIP32 public seed, instead\n> of a plain address?\n>\n> Theo\n> I didn't really think of that, but that's genius.\n>\n> On Wed, Aug 10, 2016 at 6:49 AM, Theo Chino via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Another use for the audio would be for watches that can listen but can't\n>> use a camera (ie: Samsung S2), so sound would be great.\n>>\n>> On Wed, Aug 10, 2016 at 7:42 AM, Erik Aronesty via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> NOTE:\n>>>\n>>> Addresses aren't really meant to be broadcast - you should probably be\n>>> encoding BIP32 public seeds, not addresses.\n>>>\n>>> OR simply:\n>>>\n>>> - Send btc to rick at q32.com\n>>> - TXT record _btc.rick.q32.com is queried (_<coin-code>.<name>.<domain>)\n>>> - DNS-SEC validation is *required*\n>>> - TXT record contains addr:[<bip32-pub-seed>]\n>>>\n>>> Then you can just say, in the podcast, \"Send your bitcoin donations to\n>>> rick at q32.com\".   And you can link it to your email address, if your\n>>> provider lets you set up a TXT record.   (By structuring the TXT record\n>>> that way, many existing email providers will support the standard without\n>>> having to change anything.)\n>>>\n>>> This works with audio, video, web and other publishing formats... and\n>>> very little infrastructure change is needed.\n>>>\n>>>\n>>> On Wed, Aug 10, 2016 at 6:41 AM, Tier Nolan via bitcoin-dev <\n>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>>> Have you considered CDMA?  This has the nice property that it just\n>>>> sounds like noise.  The codes would take longer to send, but you could send\n>>>> multiple bits at once and have the codes orthogonal.\n>>>>\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>\n>>>>\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160810/4f50a2ea/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2016-08-10T17:38:26",
                "message_text_only": "On Wed, Aug 10, 2016 at 7:28 PM, Erik Aronesty via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> By sending a public seed,  there's no way for someone to use the transmitted\n> address and trace the total amount of payments to it.\n\nWorse. By revealing a public seed, anyone who has seen it (= anyone\nwho ever pays you through it) can identity all payments to _any_\naddress derived from that seed.\n\n-- \nPieter"
            },
            {
                "author": "Daniel Hoffman",
                "date": "2016-08-10T17:55:04",
                "message_text_only": "thats how i thought it worked originally, but im not well versed on that,\nso i took his word for it\n\nOn Aug 10, 2016 12:38 PM, \"Pieter Wuille via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Wed, Aug 10, 2016 at 7:28 PM, Erik Aronesty via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > By sending a public seed,  there's no way for someone to use the\n> transmitted\n> > address and trace the total amount of payments to it.\n>\n> Worse. By revealing a public seed, anyone who has seen it (= anyone\n> who ever pays you through it) can identity all payments to _any_\n> address derived from that seed.\n>\n> --\n> Pieter\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160810/9722b54a/attachment.html>"
            },
            {
                "author": "James MacWhyte",
                "date": "2016-08-10T22:31:16",
                "message_text_only": "I agree, audio-based transference isn't really great for a podcast or radio\nad. It could be used to transmit payment details between phones that don't\nhave cameras, though. I think it would be better to define a standard for\ntransmitting information over audio, but not define what information is to\nbe conveyed so people could use the method for sending pub keys, payment\nprotocol requests, or anything else developers might want to make use of.\n\nI'm guessing some sort of data-over-audio standard already exists? In which\ncase the bip could just say \"we use [standard] to convey any\nbitcoin-related data\".\n\nOn Wed, Aug 10, 2016, 10:55 Daniel Hoffman via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> thats how i thought it worked originally, but im not well versed on that,\n> so i took his word for it\n>\n> On Aug 10, 2016 12:38 PM, \"Pieter Wuille via bitcoin-dev\" <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> On Wed, Aug 10, 2016 at 7:28 PM, Erik Aronesty via bitcoin-dev\n>> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> > By sending a public seed,  there's no way for someone to use the\n>> transmitted\n>> > address and trace the total amount of payments to it.\n>>\n>> Worse. By revealing a public seed, anyone who has seen it (= anyone\n>> who ever pays you through it) can identity all payments to _any_\n>> address derived from that seed.\n>>\n>> --\n>> Pieter\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160810/115775e9/attachment-0001.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2016-08-11T13:55:51",
                "message_text_only": "Sorr, I thought there was some BIP for a public seed such that someone can\ngenerate new random addresses, but cannot trivially verify whether an\naddress was derived from the seed.\n\nOn Wed, Aug 10, 2016 at 1:38 PM, Pieter Wuille <pieter.wuille at gmail.com>\nwrote:\n\n> On Wed, Aug 10, 2016 at 7:28 PM, Erik Aronesty via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > By sending a public seed,  there's no way for someone to use the\n> transmitted\n> > address and trace the total amount of payments to it.\n>\n> Worse. By revealing a public seed, anyone who has seen it (= anyone\n> who ever pays you through it) can identity all payments to _any_\n> address derived from that seed.\n>\n> --\n> Pieter\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160811/b2cd5a11/attachment.html>"
            },
            {
                "author": "Tier Nolan",
                "date": "2016-08-11T15:13:19",
                "message_text_only": "On Thu, Aug 11, 2016 at 2:55 PM, Erik Aronesty via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Sorr, I thought there was some BIP for a public seed such that someone can\n> generate new random addresses, but cannot trivially verify whether an\n> address was derived from the seed.\n>\n\nIf you take a public key and multiply it by k, then the recipient can work\nout the private key by multiplying their master private key by k.\n\nIf k is random, then the recipient wouldn't be able to work it out, but if\nit is non-random, then everyone else can work it out.  You need some way to\nget k to the recipient without others figuring it out.\n\nThis means either the system is interactive or you use a shared secret.\n\nThe info about the shared secret is included in the scriptPubKey (or the\nmore socially conscientious option, an OP_RETURN).\n\nThe address would indicate the master public key.\n\nmaster_public = master_private * G\n\nThe transaction contains k*G.\n\nBoth sides can compute the shared secret.\n\nsecret = k*master_private*G = master_private*k*G\n\n<encode(k*G)> DROP DUP HASH160 <hash160(encode(secret + pub key))>\nEQUALVERIFY CHECKSIG\n\nThis adds 34 bytes to the scriptPubKey.\n\nThis is pretty heavy for scanning for transactions sent to you.  You have\nto check every transaction output to see if it is the given template.  Then\nyou have to do an ECC multiply to compute the shared secret.  Once you have\nthe shared secret, you need to do an ECC addition and a hash to figure out\nif it matches the public key hash in the output.\n\nThis is approx one ECC multiply per output and is similar CPU load to what\nyou would need to do to actually verify a block.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160811/7ac1043e/attachment.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2016-08-11T20:37:04",
                "message_text_only": "Can't have shared secrets or interactivity for a public address to have the\nlove it needs.\n\nStill not sure how you can take a BIP32 public seed and figure out if an\naddress was derived from it though.   I mean, wouldn't I have to compute\nall 2^31 possible public child addresses?\n\n\n\n\n\nOn Thu, Aug 11, 2016 at 11:13 AM, Tier Nolan via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Thu, Aug 11, 2016 at 2:55 PM, Erik Aronesty via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Sorr, I thought there was some BIP for a public seed such that someone\n>> can generate new random addresses, but cannot trivially verify whether an\n>> address was derived from the seed.\n>>\n>\n> If you take a public key and multiply it by k, then the recipient can work\n> out the private key by multiplying their master private key by k.\n>\n> If k is random, then the recipient wouldn't be able to work it out, but if\n> it is non-random, then everyone else can work it out.  You need some way to\n> get k to the recipient without others figuring it out.\n>\n> This means either the system is interactive or you use a shared secret.\n>\n> The info about the shared secret is included in the scriptPubKey (or the\n> more socially conscientious option, an OP_RETURN).\n>\n> The address would indicate the master public key.\n>\n> master_public = master_private * G\n>\n> The transaction contains k*G.\n>\n> Both sides can compute the shared secret.\n>\n> secret = k*master_private*G = master_private*k*G\n>\n> <encode(k*G)> DROP DUP HASH160 <hash160(encode(secret + pub key))>\n> EQUALVERIFY CHECKSIG\n>\n> This adds 34 bytes to the scriptPubKey.\n>\n> This is pretty heavy for scanning for transactions sent to you.  You have\n> to check every transaction output to see if it is the given template.  Then\n> you have to do an ECC multiply to compute the shared secret.  Once you have\n> the shared secret, you need to do an ECC addition and a hash to figure out\n> if it matches the public key hash in the output.\n>\n> This is approx one ECC multiply per output and is similar CPU load to what\n> you would need to do to actually verify a block.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160811/70953954/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2016-08-12T00:36:07",
                "message_text_only": "On Thu, Aug 11, 2016 at 8:37 PM, Erik Aronesty via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Still not sure how you can take a BIP32 public seed and figure out if an\n> address was derived from it though.   I mean, wouldn't I have to compute all\n> 2^31 possible public child addresses?\n\nWhich would take a quad core laptop about 8 hours with competent software\n\nAnd presumably you're not using the whole 2^31 space else the receiver\nalso has to do that computation..."
            },
            {
                "author": "Erik Aronesty",
                "date": "2016-08-12T12:36:31",
                "message_text_only": "I'm imagining a \"publishable seed\" such that:\n\n - someone can derive a random bitcoin address from it -  and send funds to\nit.\n - the possible derived address space is large enough that generating all\npossible addresses would be a barrier\n - the receiver, however, knowing the private key, can easily scan the\nblockchain fairly efficiently and determine which addresses he has the keys\nto\n - another interested party cannot easily do so\n\nPerhaps homomorphic encryption may need to be involved?\n\n\nOn Thu, Aug 11, 2016 at 8:36 PM, Gregory Maxwell <greg at xiph.org> wrote:\n\n> On Thu, Aug 11, 2016 at 8:37 PM, Erik Aronesty via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > Still not sure how you can take a BIP32 public seed and figure out if an\n> > address was derived from it though.   I mean, wouldn't I have to compute\n> all\n> > 2^31 possible public child addresses?\n>\n> Which would take a quad core laptop about 8 hours with competent software\n>\n> And presumably you're not using the whole 2^31 space else the receiver\n> also has to do that computation...\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160812/eadb6765/attachment.html>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2016-08-12T15:49:23",
                "message_text_only": "No, anyone with the bip32 public seed can do the same as the receiver as\n\"watch only\". The only difference is rhat the receiver can actually spend\nthe coins. As gmaxwell explained, if it's expensive for everyone, it will\nbe also expensive for the receiver (assuming no interaction after the bip32\npublic seed is transfered).\n\nSomething different would be to give a different bip32 public seed to each\npayer.  That way they can simply start with zero an increment with each new\npayment. With those assumptions, the receiver could start listening to new\naddresses only after they receive something in the previous address.\n\nProbably not useful for this case, just thinking out loud about using bip32\npublic seeds instead of one use addresses when there's going to be several\npayments from the same payer to the payee.\n\nOn Aug 12, 2016 2:37 PM, \"Erik Aronesty via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> I'm imagining a \"publishable seed\" such that:\n>\n>  - someone can derive a random bitcoin address from it -  and send funds\nto it.\n>  - the possible derived address space is large enough that generating all\npossible addresses would be a barrier\n>  - the receiver, however, knowing the private key, can easily scan the\nblockchain fairly efficiently and determine which addresses he has the keys\nto\n>  - another interested party cannot easily do so\n>\n> Perhaps homomorphic encryption may need to be involved?\n>\n>\n> On Thu, Aug 11, 2016 at 8:36 PM, Gregory Maxwell <greg at xiph.org> wrote:\n>>\n>> On Thu, Aug 11, 2016 at 8:37 PM, Erik Aronesty via bitcoin-dev\n>> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> > Still not sure how you can take a BIP32 public seed and figure out if\nan\n>> > address was derived from it though.   I mean, wouldn't I have to\ncompute all\n>> > 2^31 possible public child addresses?\n>>\n>> Which would take a quad core laptop about 8 hours with competent software\n>>\n>> And presumably you're not using the whole 2^31 space else the receiver\n>> also has to do that computation...\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160812/c7c37c71/attachment.html>"
            },
            {
                "author": "James MacWhyte",
                "date": "2016-08-12T18:39:07",
                "message_text_only": "For reasons others have pointed out, it's not really plausible.\n\nEither way, this has nothing to do with transmitting data over audio.\nPlease start a new thread if you want to discuss your idea instead of\nhijacking this one. Thanks ;)\n\nOn Fri, Aug 12, 2016, 05:36 Erik Aronesty via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I'm imagining a \"publishable seed\" such that:\n>\n>  - someone can derive a random bitcoin address from it -  and send funds\n> to it.\n>  - the possible derived address space is large enough that generating all\n> possible addresses would be a barrier\n>  - the receiver, however, knowing the private key, can easily scan the\n> blockchain fairly efficiently and determine which addresses he has the keys\n> to\n>  - another interested party cannot easily do so\n>\n> Perhaps homomorphic encryption may need to be involved?\n>\n>\n> On Thu, Aug 11, 2016 at 8:36 PM, Gregory Maxwell <greg at xiph.org> wrote:\n>\n>> On Thu, Aug 11, 2016 at 8:37 PM, Erik Aronesty via bitcoin-dev\n>> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> > Still not sure how you can take a BIP32 public seed and figure out if an\n>> > address was derived from it though.   I mean, wouldn't I have to\n>> compute all\n>> > 2^31 possible public child addresses?\n>>\n>> Which would take a quad core laptop about 8 hours with competent software\n>>\n>> And presumably you're not using the whole 2^31 space else the receiver\n>> also has to do that computation...\n>>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160812/e916cf2b/attachment-0001.html>"
            },
            {
                "author": "Daniel Hoffman",
                "date": "2016-08-13T04:41:32",
                "message_text_only": "I started work on the decoder. It works by comparing each cycle of the sine\nwave recorded with a certain frequency (freq_t). The function that does\nthis currently returns the last sample that falls in that range over all\nsamples. The longest chain to match up with a certain frequency the best is\ninterpreted as that frequency (assuming it passes an entrance floor to\nseparate it from static).  I will probably extrapolate the sine wave to\nmore samples (320 kbps+), but this works OK just for testing. I am also\nprepping the docs per the official BIP spec.\n\nGitHub is https://github.com/Dako300/BIP-0170\n\nIs it okay to host the BIP on my own GitHub, or do I need to host it on a\nmore official repository?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160812/68e9539c/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP Number Request: Addresses over Audio",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Thomas Daede",
                "Theo Chino",
                "Trevin Hofmann",
                "Justin Newton",
                "Tier Nolan",
                "Jorge Tim\u00f3n",
                "Daniel Hoffman",
                "Jannes Faber",
                "Luke Dashjr",
                "Gregory Maxwell",
                "Erik Aronesty",
                "James MacWhyte",
                "Pieter Wuille",
                "Chris Riley"
            ],
            "messages_count": 28,
            "total_messages_chars_count": 65441
        }
    },
    {
        "title": "[bitcoin-dev] BIP Number Request: Addresses over Audio (fixed link)",
        "thread_messages": [
            {
                "author": "Daniel Hoffman",
                "date": "2016-08-08T21:33:06",
                "message_text_only": "Sorry about the last email, I deleted the repository to get rid of the BIP\nnumber to prevent confusion. The correct address is\nhttps://github.com/Dako300/BIP\n\nThis is my BIP idea: a fast, robust, and standardized way for representing\nBitcoin addresses over audio. It takes the binary representation of the\nBitcoin address (little endian), chops that up into 4 or 2 bit chunks\n(depending on type, 2 bit only for low quality audio like american\ntelephone lines), and generates a tone based upon that value. This started\nbecause I wanted an easy way to donate to podcasts that I listen to, and\nhaving a Shazam-esque app (or a media player with this capability) that\ngives me an address automatically would be wonderful for both the consumer\nand producer. Comes with error correction built into the protocol\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/0fedf9a6/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP Number Request: Addresses over Audio (fixed link)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Daniel Hoffman"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 991
        }
    },
    {
        "title": "[bitcoin-dev] BIP draft: HTLC transactions",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2016-08-09T00:46:33",
                "message_text_only": "On Wed, Jul 20, 2016 at 06:17:39AM +0000, Luke Dashjr wrote:\n> On Wednesday, July 20, 2016 5:46:54 AM Peter Todd via bitcoin-dev wrote:\n> > On Tue, Jul 19, 2016 at 10:35:39PM -0600, Sean Bowe via bitcoin-dev wrote:\n> > > I'm requesting feedback for Hash Time-Locked Contract (HTLC) transactions\n> > > in Bitcoin.\n> > > \n> > > HTLC transactions allow you to pay for the preimage of a hash. CSV/CLTV\n> > > can be used to recover your funds if the other party is not cooperative.\n> > > These\n> > > \n> > > scripts take the following general form:\n> > >     [HASHOP] <digest> OP_EQUAL\n> > >     OP_IF\n> > >     \n> > >         <seller pubkey>\n> > >     \n> > >     OP_ELSE\n> > >     \n> > >         <num> [TIMEOUTOP] OP_DROP <buyer pubkey>\n> > >     \n> > >     OP_ENDIF\n> > >     OP_CHECKSIG\n> > \n> > Note that because you're hashing the top item on the stack regardless\n> > scriptSig's that satisfy HTLC's are malleable: that top stack item can be\n> > changed anything in the digest-not-provided case and the script still\n> > passes.\n> \n> OP_SIZE\n> OP_IF\n>   [HASHOP] <digest> OP_EQUALVERIFY\n>   <seller pubkey>\n> OP_ELSE\n>   <num> [TIMEOUTOP]\n>   <buyer pubkey>\n> OP_ENDIF\n> OP_CHECKSIG\n\nHa! That's brilliant; good job.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160808/2402c688/attachment.sig>"
            },
            {
                "author": "Johnson Lau",
                "date": "2016-08-17T10:00:37",
                "message_text_only": "> On July 20, 2016 at 2:17 AM Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> On Wednesday, July 20, 2016 5:46:54 AM Peter Todd via bitcoin-dev wrote:\n> \n> > On Tue, Jul 19, 2016 at 10:35:39PM -0600, Sean Bowe via bitcoin-dev wrote:\n> > \n> > > I'm requesting feedback for Hash Time-Locked Contract (HTLC) transactions\n> > > in Bitcoin.\n> > > \n> > > HTLC transactions allow you to pay for the preimage of a hash. CSV/CLTV\n> > > can be used to recover your funds if the other party is not cooperative.\n> > > These\n> > > \n> > > scripts take the following general form:\n> > >  [HASHOP]  OP_EQUAL\n> > >  OP_IF\n> > > \n> > > \n> > > \n> > > OP_ELSE\n> > > \n> > >  [TIMEOUTOP] OP_DROP \n> > > \n> > > OP_ENDIF\n> > >  OP_CHECKSIG\n> > \n> > Note that because you're hashing the top item on the stack regardless\n> > scriptSig's that satisfy HTLC's are malleable: that top stack item can be\n> > changed anything in the digest-not-provided case and the script still\n> > passes.\n> \n> OP_SIZE\n> OP_IF\n>  [HASHOP] <digest> OP_EQUALVERIFY\n>  <seller pubkey>\n> OP_ELSE\n>  <num> [TIMEOUTOP]\n>  <buyer pubkey>\n> OP_ENDIF\n> OP_CHECKSIG\n> \n\nThis is incompatible with my proposal for fixing the OP_IF/NOTIF malleability in segwit (\"MINIMALIF\"). In this case only the timeout branch may be executed.\n\nTo make it compatible, you may use one of the following 2 scripts:\n\nOP_SIZE OP_0NOTEQUAL\nOP_IF\n [HASHOP] <digest> OP_EQUALVERIFY\n <seller pubkey>\nOP_ELSE\n <num> [TIMEOUTOP] OP_DROP\n <buyer pubkey>\nOP_ENDIF\nOP_CHECKSIG\n\nor\n\nOP_IF\n [HASHOP] <digest> OP_EQUALVERIFY\n <seller pubkey>\nOP_ELSE\n <num> [TIMEOUTOP] OP_DROP\n <buyer pubkey>\nOP_ENDIF\nOP_CHECKSIG\n\nThe overall witness size are the same for these scripts. They are 1 byte larger than Luke's script, in case MINIMALIF is not enforced.\n\n(btw, the OP_DROP after TIMEOUTOP is missing in Luke's script)"
            }
        ],
        "thread_summary": {
            "title": "BIP draft: HTLC transactions",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Johnson Lau",
                "Peter Todd"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3401
        }
    },
    {
        "title": "[bitcoin-dev] Fwd: Hiding entire content of on-chain transactions",
        "thread_messages": [
            {
                "author": "Tony Churyumoff",
                "date": "2016-08-10T07:50:25",
                "message_text_only": "> The OP's proposal sounds quite similar to my earlier one along similar lines:\n>\n>    https://petertodd.org/2016/closed-seal-sets-and-truth-lists-for-privacy\n\nSimilar indeed, thank you for the link.\n\n\n2016-08-09 0:53 GMT+03:00 Peter Todd <pete at petertodd.org>:\n>\n> On Mon, Aug 08, 2016 at 09:41:27PM +0000, James MacWhyte via bitcoin-dev wrote:\n> > Wouldn't you lose the ability to assume transactions in the blockchain are\n> > verified as valid, since miners can't see the details of what is being\n> > spent and how? I feel like this ability is bitcoin's greatest asset, and by\n> > removing it you're creating an altcoin different enough to not be connected\n> > to/supported by the main bitcoin project.\n>\n> The fact that miners verify transactions is just an optimisation:\n>\n>     https://petertodd.org/2013/disentangling-crypto-coin-mining\n>\n> Preventing double-spending however is a fundemental requirement of Bitcoin, and\n> this proposal does prevent double-spending perfectly well (although there may\n> be better ways to do it).\n>\n> The OP's proposal sounds quite similar to my earlier one along similar lines:\n>\n>     https://petertodd.org/2016/closed-seal-sets-and-truth-lists-for-privacy\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org"
            },
            {
                "author": "Tony Churyumoff",
                "date": "2016-08-10T07:51:34",
                "message_text_only": "> That is a good point. As you said, it puts a lot more burden on the coin\n> holders. One big downside would be data management. Instead of simply\n> backing up a single HD private key, the user would have to back up entire\n> histories of every output that has been sent to them if they want to secure\n> their funds.\n\nYou are correct.  It is somewhat similar to bearer assets: if you lose\nthe histories, you lose money.\n\n> It also requires them to be online to receive payments, and I think finding\n> a method of sending the private message containing the coin's history is\n> going to be a bit of a challenge. If you connect directly to the recipient\n> to convey the information through traditional channels, anonymity is lost.\n> Sending messages through the bitcoin network is one option to protect\n> anonymity, but without active pathfinding there's no guarantee the payee\n> will even get the message. I'm assuming you'd have to essentially replace tx\n> messages with encrypted BBC histories, and mempools are quite full as it is.\n>\n> Tony, do you have any more thoughts on exactly how users would convey the\n> private messages to payees?\n\nYou are right conveying the private messages is not trivial.  While we\ncan adapt the existing bitcoin network protocol for a limited set of\nuse cases, such as both parties being online at the same time and\nconnected directly, BBC would work best if we design a whole new\ncommunication layer specifically for conveying private messages.  We\ncould route the end-to-end encrypted messages through hubs who are\nconstantly online and would store and forward the messages, thus the\npeers don't have to be online at the same time and don't have to\nconnect directly.  The hubs could simultaneously serve as lightening\nnetwork hubs.\n\n\n2016-08-09 3:03 GMT+03:00 James MacWhyte <macwhyte at gmail.com>:\n> That is a good point. As you said, it puts a lot more burden on the coin\n> holders. One big downside would be data management. Instead of simply\n> backing up a single HD private key, the user would have to back up entire\n> histories of every output that has been sent to them if they want to secure\n> their funds.\n>\n> It also requires them to be online to receive payments, and I think finding\n> a method of sending the private message containing the coin's history is\n> going to be a bit of a challenge. If you connect directly to the recipient\n> to convey the information through traditional channels, anonymity is lost.\n> Sending messages through the bitcoin network is one option to protect\n> anonymity, but without active pathfinding there's no guarantee the payee\n> will even get the message. I'm assuming you'd have to essentially replace tx\n> messages with encrypted BBC histories, and mempools are quite full as it is.\n>\n> Tony, do you have any more thoughts on exactly how users would convey the\n> private messages to payees?\n>\n> On Mon, Aug 8, 2016 at 4:42 PM Tony Churyumoff <tony991 at gmail.com> wrote:\n>>\n>> The whole point is in preventing every third party, including miners, from\n>> seeing the details of what is being spent and how.  The burden of\n>> verification is shifted to the owners of the coin (which is fair).\n>>\n>> In fact we could have miners recognize spend proofs and check that the\n>> same spend proof is not entered into the blockchain more than once (which\n>> would be a sign of double spend), but it is not required.  The coin owners\n>> can already do that themselves.\n>>\n>> 2016-08-09 0:41 GMT+03:00 James MacWhyte <macwhyte at gmail.com>:\n>>>\n>>> Wouldn't you lose the ability to assume transactions in the blockchain\n>>> are verified as valid, since miners can't see the details of what is being\n>>> spent and how? I feel like this ability is bitcoin's greatest asset, and by\n>>> removing it you're creating an altcoin different enough to not be connected\n>>> to/supported by the main bitcoin project.\n>>>\n>>>\n>>> On Mon, Aug 8, 2016, 09:13 Tony Churyumoff via bitcoin-dev\n>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>>\n>>>> Hi Henning,\n>>>>\n>>>> 1. The fees are paid by the enclosing BTC transaction.\n>>>> 2. The hash is encoded into an OP_RETURN.\n>>>>\n>>>> > Regarding the blinding factor, I think you could just use HMAC.\n>>>> How exactly?\n>>>>\n>>>> Tony\n>>>>\n>>>>\n>>>> 2016-08-08 18:47 GMT+03:00 Henning Kopp <henning.kopp at uni-ulm.de>:\n>>>>>\n>>>>> Hi Tony,\n>>>>>\n>>>>> I see some issues in your protocol.\n>>>>>\n>>>>> 1. How are mining fees handled?\n>>>>>\n>>>>> 2. Assume Alice sends Bob some Coins together with their history and\n>>>>> Bob checks that the history is correct. How does the hash of the txout\n>>>>> find its way into the blockchain?\n>>>>>\n>>>>> Regarding the blinding factor, I think you could just use HMAC.\n>>>>>\n>>>>> All the best\n>>>>> Henning\n>>>>>\n>>>>>\n>>>>> On Mon, Aug 08, 2016 at 06:30:21PM +0300, Tony Churyumoff via\n>>>>> bitcoin-dev wrote:\n>>>>> > This is a proposal about hiding the entire content of bitcoin\n>>>>> > transactions.  It goes farther than CoinJoin and ring signatures,\n>>>>> > which\n>>>>> > only obfuscate the transaction graph, and Confidential Transactions,\n>>>>> > which\n>>>>> > only hide the amounts.\n>>>>> >\n>>>>> > The central idea of the proposed design is to hide the entire inputs\n>>>>> > and\n>>>>> > outputs, and publish only the hash of inputs and outputs in the\n>>>>> > blockchain.  The hash can be published as OP_RETURN.  The plaintext\n>>>>> > of\n>>>>> > inputs and outputs is sent directly to the payee via a private\n>>>>> > message, and\n>>>>> > never goes into the blockchain.  The payee then calculates the hash\n>>>>> > and\n>>>>> > looks it up in the blockchain to verify that the hash was indeed\n>>>>> > published\n>>>>> > by the payer.\n>>>>> >\n>>>>> > Since the plaintext of the transaction is not published to the public\n>>>>> > blockchain, all validation work has to be done only by the user who\n>>>>> > receives the payment.\n>>>>> >\n>>>>> > To protect against double-spends, the payer also has to publish\n>>>>> > another\n>>>>> > hash, which is the hash of the output being spent.  We\u2019ll call this\n>>>>> > hash *spend\n>>>>> > proof*.  Since the spend proof depends solely on the output being\n>>>>> > spent,\n>>>>> > any attempt to spend the same output again will produce exactly the\n>>>>> > same\n>>>>> > spend proof, and the payee will be able to see that, and will reject\n>>>>> > the\n>>>>> > payment.  If there are several outputs consumed by the same\n>>>>> > transaction,\n>>>>> > the payer has to publish several spend proofs.\n>>>>> >\n>>>>> > To prove that the outputs being spent are valid, the payer also has\n>>>>> > to send\n>>>>> > the plaintexts of the earlier transaction(s) that produced them, then\n>>>>> > the\n>>>>> > plaintexts of even earlier transactions that produced the outputs\n>>>>> > spent in\n>>>>> > those transactions, and so on, up until the issue (similar to\n>>>>> > coinbase)\n>>>>> > transactions that created the initial private coins.  Each new owner\n>>>>> > of the\n>>>>> > coin will have to store its entire history, and when he spends the\n>>>>> > coin, he\n>>>>> > forwards the entire history to the next owner and extends it with his\n>>>>> > own\n>>>>> > transaction.\n>>>>> >\n>>>>> > If we apply the existing bitcoin design that allows multiple inputs\n>>>>> > and\n>>>>> > multiple outputs per transaction, the history of ownership transfers\n>>>>> > would\n>>>>> > grow exponentially.  Indeed, if we take any regular bitcoin output\n>>>>> > and try\n>>>>> > to track its history back to coinbase, our history will branch every\n>>>>> > time\n>>>>> > we see a transaction that has more than one input (which is not\n>>>>> > uncommon).\n>>>>> > After such a transaction (remember, we are traveling back in time),\n>>>>> > we\u2019ll\n>>>>> > have to track two or more histories, for each respective input.\n>>>>> > Those\n>>>>> > histories will branch again, and the total number of history entries\n>>>>> > grows\n>>>>> > exponentially.  For example, if every transaction had exactly two\n>>>>> > inputs,\n>>>>> > the size of history would grow as 2^N where N is the number of steps\n>>>>> > back\n>>>>> > in history.\n>>>>> >\n>>>>> > To avoid such rapid growth of ownership history (which is not only\n>>>>> > inconvenient to move, but also exposes too much private information\n>>>>> > about\n>>>>> > previous owners of all the contributing coins), we will require each\n>>>>> > private transaction to have exactly one input (i.e. to consume\n>>>>> > exactly one\n>>>>> > previous output).  This means that when we track a coin\u2019s history\n>>>>> > back in\n>>>>> > time, it will no longer branch.  It will grow linearly with the\n>>>>> > number of\n>>>>> > transfers of ownership.  If a user wants to combine several inputs,\n>>>>> > he will\n>>>>> > have to send them as separate private transactions (technically,\n>>>>> > several\n>>>>> > OP_RETURNs, which can be included in a single regular bitcoin\n>>>>> > transaction).\n>>>>> >\n>>>>> > Thus, we are now forbidding any coin merges but still allowing coin\n>>>>> > splits.  To avoid ultimate splitting into the dust, we will also\n>>>>> > require\n>>>>> > that all private coins be issued in one of a small number of\n>>>>> > denominations.  Only integer number of \u201cbanknotes\u201d can be\n>>>>> > transferred, the\n>>>>> > input and output amounts must therefore be divisible by the\n>>>>> > denomination.\n>>>>> > For example, an input of amount 700, denomination 100, can be split\n>>>>> > into\n>>>>> > outputs 400 and 300, but not into 450 and 250.  To send a payment,\n>>>>> > the\n>>>>> > payer has to pick the unspent outputs of the highest denomination\n>>>>> > first,\n>>>>> > then the second highest, and so on, like we already do when we pay in\n>>>>> > cash.\n>>>>> >\n>>>>> > With fixed denominations and one input per transaction, coin\n>>>>> > histories\n>>>>> > still grow, but only linearly, which should not be a concern in\n>>>>> > regard to\n>>>>> > scalability given that all relevant computing resources still grow\n>>>>> > exponentially.  The histories need to be stored only by the current\n>>>>> > owner\n>>>>> > of the coin, not every bitcoin node.  This is a fairer allocation of\n>>>>> > costs.  Regarding privacy, coin histories do expose private\n>>>>> > transactions\n>>>>> > (or rather parts thereof, since a typical payment will likely consist\n>>>>> > of\n>>>>> > several transactions due to one-input-per-transaction rule) of past\n>>>>> > coin\n>>>>> > owners to the future ones, and that exposure grows linearly with\n>>>>> > time, but\n>>>>> > it is still much much better than having every transaction\n>>>>> > immediately on\n>>>>> > the public blockchain.  Also, the value of this information for\n>>>>> > potential\n>>>>> > adversaries arguably decreases with time.\n>>>>> >\n>>>>> > There is one technical nuance that I omitted above to avoid\n>>>>> > distraction.\n>>>>> >  Unlike regular bitcoin transactions, every output in a private\n>>>>> > payment\n>>>>> > must also include a blinding factor, which is just a random string.\n>>>>> > When\n>>>>> > the output is spent, the corresponding spend proof will therefore\n>>>>> > depend on\n>>>>> > this blinding factor (remember that spend proof is just a hash of the\n>>>>> > output).  Without a blinding factor, it would be feasible to\n>>>>> > pre-image the\n>>>>> > spend proof and reveal the output being spent as the search space of\n>>>>> > all\n>>>>> > possible outputs is rather small.\n>>>>> >\n>>>>> > To issue the new private coin, one can burn regular BTC by sending it\n>>>>> > to\n>>>>> > one of several unspendable bitcoin addresses, one address per\n>>>>> > denomination.\n>>>>> >  Burning BTC would entitle one to an equal amount of the new private\n>>>>> > coin,\n>>>>> > let\u2019s call it *black bitcoin*, or *BBC*.\n>>>>> >\n>>>>> > Then BBC would be transferred from user to user by:\n>>>>> > 1. creating a private transaction, which consists of one input and\n>>>>> > several\n>>>>> > outputs;\n>>>>> > 2. storing the hash of the transaction and the spend proof of the\n>>>>> > consumed\n>>>>> > output into the blockchain in an OP_RETURN (the sender pays the\n>>>>> > corresponding fees in regular BTC)\n>>>>> > 3. sending the transaction, together with the history leading to its\n>>>>> > input,\n>>>>> > directly to the payee over a private communication channel.  The\n>>>>> > first\n>>>>> > entry of the history must be a bitcoin transaction that burned BTC to\n>>>>> > issue\n>>>>> > an equal amount of BCC.\n>>>>> >\n>>>>> > To verify the payment, the payee:\n>>>>> > 1. makes sure that the amount of the input matches the sum of\n>>>>> > outputs, and\n>>>>> > all are divisible by the denomination\n>>>>> > 2. calculates the hash of the private transaction\n>>>>> > 3. looks up an OP_RETURN that includes this hash and is signed by the\n>>>>> > payee.  If there is more than one, the one that comes in the earlier\n>>>>> > block\n>>>>> > prevails.\n>>>>> > 4. calculates the spend proof and makes sure that it is included in\n>>>>> > the\n>>>>> > same OP_RETURN\n>>>>> > 5. makes sure the same spend proof is not included anywhere in the\n>>>>> > same or\n>>>>> > earlier blocks (that is, the coin was not spent before).  Only\n>>>>> > transactions\n>>>>> > by the same author are searched.\n>>>>> > 6. repeats the same steps for every entry in the history, except the\n>>>>> > first\n>>>>> > entry, which should be a valid burning transaction.\n>>>>> >\n>>>>> > To facilitate exchange of private transaction data, the bitcoin\n>>>>> > network\n>>>>> > protocol can be extended with a new message type.  Unfortunately, it\n>>>>> > lacks\n>>>>> > encryption, hence private payments are really private only when\n>>>>> > bitcoin is\n>>>>> > used over tor.\n>>>>> >\n>>>>> > There are a few limitations that ought to be mentioned:\n>>>>> > 1. After user A sends a private payment to user B, user A will know\n>>>>> > what\n>>>>> > the spend proof is going to be when B decides to spend the coin.\n>>>>> >  Therefore, A will know when the coin was spent by B, but nothing\n>>>>> > more.\n>>>>> >  Neither the new owner of the coin, nor its future movements will be\n>>>>> > known\n>>>>> > to A.\n>>>>> > 2. Over time, larger outputs will likely be split into many smaller\n>>>>> > outputs, whose amounts are not much greater than their denominations.\n>>>>> > You\u2019ll have to combine more inputs to send the same amount.  When you\n>>>>> > want\n>>>>> > to send a very large amount that is much greater than the highest\n>>>>> > available\n>>>>> > denomination, you\u2019ll have to send a lot of private transactions, your\n>>>>> > bitcoin transaction with so many OP_RETURNs will stand out, and their\n>>>>> > number will roughly indicate the total amount.  This kind of privacy\n>>>>> > leakage, however it applies to a small number of users, is easy to\n>>>>> > avoid by\n>>>>> > using multiple addresses and storing a relatively small amount on\n>>>>> > each\n>>>>> > address.\n>>>>> > 3. Exchanges and large merchants will likely accumulate large coin\n>>>>> > histories.  Although fragmented, far from complete, and likely\n>>>>> > outdated, it\n>>>>> > is still something to bear in mind.\n>>>>> >\n>>>>> > No hard or soft fork is required, BBC is just a separate privacy\n>>>>> > preserving\n>>>>> > currency on top of bitcoin blockchain, and the same private keys and\n>>>>> > addresses are used for both BBC and the base currency BTC.  Every BCC\n>>>>> > transaction must be enclosed into by a small BTC transaction that\n>>>>> > stores\n>>>>> > the OP_RETURNs and pays for the fees.\n>>>>> >\n>>>>> > Are there any flaws in this design?\n>>>>> >\n>>>>> > Originally posted to BCT\n>>>>> > https://bitcointalk.org/index.php?topic=1574508.0,\n>>>>> > but got no feedback so far, apparently everybody was consumed with\n>>>>> > bitfinex\n>>>>> > drama and now mimblewimble.\n>>>>> >\n>>>>> > Tony\n>>>>>\n>>>>> > _______________________________________________\n>>>>> > bitcoin-dev mailing list\n>>>>> > bitcoin-dev at lists.linuxfoundation.org\n>>>>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>>\n>>>>>\n>>>>> --\n>>>>> Henning Kopp\n>>>>> Institute of Distributed Systems\n>>>>> Ulm University, Germany\n>>>>>\n>>>>> Office: O27 - 3402\n>>>>> Phone: +49 731 50-24138\n>>>>> Web: http://www.uni-ulm.de/in/vs/~kopp\n>>>>\n>>>>\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>"
            },
            {
                "author": "Tony Churyumoff",
                "date": "2016-08-10T07:52:11",
                "message_text_only": "> Instead of a hash function you may use a keyed hash function (HMAC) where\n> the key is just the random string. They key needs to be stored in the\n> history of the coin to allow for verification.\n\nThis is nearly equivalent.  The sole purpose of the blinding factor is\nto increase the search space and make preimaging of the output\nimpossible.  While in many applications HMAC is superior to plain hash\nof a concatenation of the input data and the key (key = blinding\nfactor in our case), its preimage resistance is the same as that of\nthe hash.\n\n\n2016-08-09 10:26 GMT+03:00 Henning Kopp <henning.kopp at uni-ulm.de>:\n>\n> Hi Tony,\n>\n> > > Regarding the blinding factor, I think you could just use HMAC.\n> > How exactly?\n>\n> I am not entirely sure if this works. You wrote:\n>\n> > There is one technical nuance that I omitted above to avoid distraction.\n> >  Unlike regular bitcoin transactions, every output in a private payment\n> > must also include a blinding factor, which is just a random string.  When\n> > the output is spent, the corresponding spend proof will therefore depend on\n> > this blinding factor (remember that spend proof is just a hash of the\n> > output).  Without a blinding factor, it would be feasible to pre-image the\n> > spend proof and reveal the output being spent as the search space of all\n> > possible outputs is rather small.\n>\n> Instead of a hash function you may use a keyed hash function (HMAC) where\n> the key is just the random string. They key needs to be stored in the\n> history of the coin to allow for verification.\n>\n> Best\n> Henning\n>\n> On Mon, Aug 08, 2016 at 07:03:28PM +0300, Tony Churyumoff wrote:\n> > Hi Henning,\n> >\n> > 1. The fees are paid by the enclosing BTC transaction.\n> > 2. The hash is encoded into an OP_RETURN.\n> >\n> > > Regarding the blinding factor, I think you could just use HMAC.\n> > How exactly?\n> >\n> > Tony\n> >\n> >\n> > 2016-08-08 18:47 GMT+03:00 Henning Kopp <henning.kopp at uni-ulm.de>:\n> >\n> > > Hi Tony,\n> > >\n> > > I see some issues in your protocol.\n> > >\n> > > 1. How are mining fees handled?\n> > >\n> > > 2. Assume Alice sends Bob some Coins together with their history and\n> > > Bob checks that the history is correct. How does the hash of the txout\n> > > find its way into the blockchain?\n> > >\n> > > Regarding the blinding factor, I think you could just use HMAC.\n> > >\n> > > All the best\n> > > Henning\n> > >\n> > >\n> > > On Mon, Aug 08, 2016 at 06:30:21PM +0300, Tony Churyumoff via bitcoin-dev\n> > > wrote:\n> > > > This is a proposal about hiding the entire content of bitcoin\n> > > > transactions.  It goes farther than CoinJoin and ring signatures, which\n> > > > only obfuscate the transaction graph, and Confidential Transactions,\n> > > which\n> > > > only hide the amounts.\n> > > >\n> > > > The central idea of the proposed design is to hide the entire inputs and\n> > > > outputs, and publish only the hash of inputs and outputs in the\n> > > > blockchain.  The hash can be published as OP_RETURN.  The plaintext of\n> > > > inputs and outputs is sent directly to the payee via a private message,\n> > > and\n> > > > never goes into the blockchain.  The payee then calculates the hash and\n> > > > looks it up in the blockchain to verify that the hash was indeed\n> > > published\n> > > > by the payer.\n> > > >\n> > > > Since the plaintext of the transaction is not published to the public\n> > > > blockchain, all validation work has to be done only by the user who\n> > > > receives the payment.\n> > > >\n> > > > To protect against double-spends, the payer also has to publish another\n> > > > hash, which is the hash of the output being spent.  We\u2019ll call this hash\n> > > *spend\n> > > > proof*.  Since the spend proof depends solely on the output being spent,\n> > > > any attempt to spend the same output again will produce exactly the same\n> > > > spend proof, and the payee will be able to see that, and will reject the\n> > > > payment.  If there are several outputs consumed by the same transaction,\n> > > > the payer has to publish several spend proofs.\n> > > >\n> > > > To prove that the outputs being spent are valid, the payer also has to\n> > > send\n> > > > the plaintexts of the earlier transaction(s) that produced them, then the\n> > > > plaintexts of even earlier transactions that produced the outputs spent\n> > > in\n> > > > those transactions, and so on, up until the issue (similar to coinbase)\n> > > > transactions that created the initial private coins.  Each new owner of\n> > > the\n> > > > coin will have to store its entire history, and when he spends the coin,\n> > > he\n> > > > forwards the entire history to the next owner and extends it with his own\n> > > > transaction.\n> > > >\n> > > > If we apply the existing bitcoin design that allows multiple inputs and\n> > > > multiple outputs per transaction, the history of ownership transfers\n> > > would\n> > > > grow exponentially.  Indeed, if we take any regular bitcoin output and\n> > > try\n> > > > to track its history back to coinbase, our history will branch every time\n> > > > we see a transaction that has more than one input (which is not\n> > > uncommon).\n> > > > After such a transaction (remember, we are traveling back in time), we\u2019ll\n> > > > have to track two or more histories, for each respective input.  Those\n> > > > histories will branch again, and the total number of history entries\n> > > grows\n> > > > exponentially.  For example, if every transaction had exactly two inputs,\n> > > > the size of history would grow as 2^N where N is the number of steps back\n> > > > in history.\n> > > >\n> > > > To avoid such rapid growth of ownership history (which is not only\n> > > > inconvenient to move, but also exposes too much private information about\n> > > > previous owners of all the contributing coins), we will require each\n> > > > private transaction to have exactly one input (i.e. to consume exactly\n> > > one\n> > > > previous output).  This means that when we track a coin\u2019s history back in\n> > > > time, it will no longer branch.  It will grow linearly with the number of\n> > > > transfers of ownership.  If a user wants to combine several inputs, he\n> > > will\n> > > > have to send them as separate private transactions (technically, several\n> > > > OP_RETURNs, which can be included in a single regular bitcoin\n> > > transaction).\n> > > >\n> > > > Thus, we are now forbidding any coin merges but still allowing coin\n> > > > splits.  To avoid ultimate splitting into the dust, we will also require\n> > > > that all private coins be issued in one of a small number of\n> > > > denominations.  Only integer number of \u201cbanknotes\u201d can be transferred,\n> > > the\n> > > > input and output amounts must therefore be divisible by the denomination.\n> > > > For example, an input of amount 700, denomination 100, can be split into\n> > > > outputs 400 and 300, but not into 450 and 250.  To send a payment, the\n> > > > payer has to pick the unspent outputs of the highest denomination first,\n> > > > then the second highest, and so on, like we already do when we pay in\n> > > cash.\n> > > >\n> > > > With fixed denominations and one input per transaction, coin histories\n> > > > still grow, but only linearly, which should not be a concern in regard to\n> > > > scalability given that all relevant computing resources still grow\n> > > > exponentially.  The histories need to be stored only by the current owner\n> > > > of the coin, not every bitcoin node.  This is a fairer allocation of\n> > > > costs.  Regarding privacy, coin histories do expose private transactions\n> > > > (or rather parts thereof, since a typical payment will likely consist of\n> > > > several transactions due to one-input-per-transaction rule) of past coin\n> > > > owners to the future ones, and that exposure grows linearly with time,\n> > > but\n> > > > it is still much much better than having every transaction immediately on\n> > > > the public blockchain.  Also, the value of this information for potential\n> > > > adversaries arguably decreases with time.\n> > > >\n> > > > There is one technical nuance that I omitted above to avoid distraction.\n> > > >  Unlike regular bitcoin transactions, every output in a private payment\n> > > > must also include a blinding factor, which is just a random string.  When\n> > > > the output is spent, the corresponding spend proof will therefore depend\n> > > on\n> > > > this blinding factor (remember that spend proof is just a hash of the\n> > > > output).  Without a blinding factor, it would be feasible to pre-image\n> > > the\n> > > > spend proof and reveal the output being spent as the search space of all\n> > > > possible outputs is rather small.\n> > > >\n> > > > To issue the new private coin, one can burn regular BTC by sending it to\n> > > > one of several unspendable bitcoin addresses, one address per\n> > > denomination.\n> > > >  Burning BTC would entitle one to an equal amount of the new private\n> > > coin,\n> > > > let\u2019s call it *black bitcoin*, or *BBC*.\n> > > >\n> > > > Then BBC would be transferred from user to user by:\n> > > > 1. creating a private transaction, which consists of one input and\n> > > several\n> > > > outputs;\n> > > > 2. storing the hash of the transaction and the spend proof of the\n> > > consumed\n> > > > output into the blockchain in an OP_RETURN (the sender pays the\n> > > > corresponding fees in regular BTC)\n> > > > 3. sending the transaction, together with the history leading to its\n> > > input,\n> > > > directly to the payee over a private communication channel.  The first\n> > > > entry of the history must be a bitcoin transaction that burned BTC to\n> > > issue\n> > > > an equal amount of BCC.\n> > > >\n> > > > To verify the payment, the payee:\n> > > > 1. makes sure that the amount of the input matches the sum of outputs,\n> > > and\n> > > > all are divisible by the denomination\n> > > > 2. calculates the hash of the private transaction\n> > > > 3. looks up an OP_RETURN that includes this hash and is signed by the\n> > > > payee.  If there is more than one, the one that comes in the earlier\n> > > block\n> > > > prevails.\n> > > > 4. calculates the spend proof and makes sure that it is included in the\n> > > > same OP_RETURN\n> > > > 5. makes sure the same spend proof is not included anywhere in the same\n> > > or\n> > > > earlier blocks (that is, the coin was not spent before).  Only\n> > > transactions\n> > > > by the same author are searched.\n> > > > 6. repeats the same steps for every entry in the history, except the\n> > > first\n> > > > entry, which should be a valid burning transaction.\n> > > >\n> > > > To facilitate exchange of private transaction data, the bitcoin network\n> > > > protocol can be extended with a new message type.  Unfortunately, it\n> > > lacks\n> > > > encryption, hence private payments are really private only when bitcoin\n> > > is\n> > > > used over tor.\n> > > >\n> > > > There are a few limitations that ought to be mentioned:\n> > > > 1. After user A sends a private payment to user B, user A will know what\n> > > > the spend proof is going to be when B decides to spend the coin.\n> > > >  Therefore, A will know when the coin was spent by B, but nothing more.\n> > > >  Neither the new owner of the coin, nor its future movements will be\n> > > known\n> > > > to A.\n> > > > 2. Over time, larger outputs will likely be split into many smaller\n> > > > outputs, whose amounts are not much greater than their denominations.\n> > > > You\u2019ll have to combine more inputs to send the same amount.  When you\n> > > want\n> > > > to send a very large amount that is much greater than the highest\n> > > available\n> > > > denomination, you\u2019ll have to send a lot of private transactions, your\n> > > > bitcoin transaction with so many OP_RETURNs will stand out, and their\n> > > > number will roughly indicate the total amount.  This kind of privacy\n> > > > leakage, however it applies to a small number of users, is easy to avoid\n> > > by\n> > > > using multiple addresses and storing a relatively small amount on each\n> > > > address.\n> > > > 3. Exchanges and large merchants will likely accumulate large coin\n> > > > histories.  Although fragmented, far from complete, and likely outdated,\n> > > it\n> > > > is still something to bear in mind.\n> > > >\n> > > > No hard or soft fork is required, BBC is just a separate privacy\n> > > preserving\n> > > > currency on top of bitcoin blockchain, and the same private keys and\n> > > > addresses are used for both BBC and the base currency BTC.  Every BCC\n> > > > transaction must be enclosed into by a small BTC transaction that stores\n> > > > the OP_RETURNs and pays for the fees.\n> > > >\n> > > > Are there any flaws in this design?\n> > > >\n> > > > Originally posted to BCT https://bitcointalk.org/index.\n> > > php?topic=1574508.0,\n> > > > but got no feedback so far, apparently everybody was consumed with\n> > > bitfinex\n> > > > drama and now mimblewimble.\n> > > >\n> > > > Tony\n> > >\n> > > > _______________________________________________\n> > > > bitcoin-dev mailing list\n> > > > bitcoin-dev at lists.linuxfoundation.org\n> > > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> > >\n> > >\n> > > --\n> > > Henning Kopp\n> > > Institute of Distributed Systems\n> > > Ulm University, Germany\n> > >\n> > > Office: O27 - 3402\n> > > Phone: +49 731 50-24138\n> > > Web: http://www.uni-ulm.de/in/vs/~kopp\n> > >\n>\n> --\n> Henning Kopp\n> Institute of Distributed Systems\n> Ulm University, Germany\n>\n> Office: O27 - 3402\n> Phone: +49 731 50-24138\n> Web: http://www.uni-ulm.de/in/vs/~kopp"
            },
            {
                "author": "Tony Churyumoff",
                "date": "2016-08-10T07:53:01",
                "message_text_only": "This troll is harmless.  A duplicate spend proof should also be signed\nby the same user (Alice, in your example) to be considered a double\nspend.\n\n2016-08-09 3:18 GMT+03:00 James MacWhyte <macwhyte at gmail.com>:\n> One more thought about why verification by miners may be needed.\n>\n> Let's say Alice sends Bob a transaction, generating output C.\n>\n> A troll, named Timothy, broadcasts a transaction with a random hash,\n> referencing C's output as its spend proof. The miners can't tell if it's\n> valid or not, and so they include the transaction in a block. Now Bob's\n> money is useless, because everyone can see the spend proof referenced and\n> thinks it has already been spent, even though the transaction that claims it\n> isn't valid.\n>\n> Did I miss something that protects against this?\n>"
            }
        ],
        "thread_summary": {
            "title": "Fwd: Hiding entire content of on-chain transactions",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tony Churyumoff"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 31780
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Core 0.13.0 release candidate 3 available",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2016-08-13T06:58:40",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nBinaries for bitcoin Core version 0.13.0rc3 are available from:\n\n    https://bitcoin.org/bin/bitcoin-core-0.13.0/test.rc3/\n\nSource code can be found on github under the signed tag\n\n    https://github.com/bitcoin/bitcoin/tree/v0.13.0rc3\n\nThis is a release candidate for a new major version release, bringing new\nfeatures, bug fixes, as well as other improvements.\n\nPreliminary release notes for the release can be found at\n\n    https://github.com/bitcoin/bitcoin/blob/0.13/doc/release-notes.md\n\nRelease candidates are test versions for releases. When no critical problems\nare found, this release candidate will be tagged as 0.13.0.\n\nPlease report bugs using the issue tracker at github:\n\n    https://github.com/bitcoin/bitcoin/issues\n\nNotable changes since rc2:\n\n### Block and transaction handling\n\n- - #8364 `3f65ba2` Treat high-sigop transactions as larger rather than rejecting them (sipa)\n\n### Tests and QA\n\n- - #8444 `cd0910b` Fix p2p-feefilter.py for changed tx relay behavior (sdaftuar)\n\n### Mining\n\n- - #8489 `8b0eee6` Bugfix: Use pre-BIP141 sigops until segwit activates (GBT) (luke-jr)\n\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQEcBAEBCgAGBQJXrsS5AAoJEHSBCwEjRsmmH1oH/3PKk2rJIgMhsf4a8fuGJD7H\n+j+ugsdRpjRGK8XKgnCisLQ8UJc2Z7dRbRYfdUb1ibkkCccMQJdmS6JAahWTe+Hb\nN8GbODwZ5m4LrP2PA1gqNE/pwix/pqBY4GfR+TxXEbegNUNYDkvUzeUidcYGMAZd\nLEAFrVnvsTAOQiwK3/pwa+sdWVNc0Jx/hHSZhouUtFmaqjXdg5M8ShmnRjyhVovI\nGeuJ2s/3+uMtIX0g+kIOv16e0qYHJtIJMexMV5x4x1oWpXMYi2YeVDFSAkcKxA/z\n5JOqlhDBK2lVMOKw8kYcNXKpvhXg9UBKImJDS0S4Bye8nMLQC6VEnkscOd7bupU=\n=ae21\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.13.0 release candidate 3 available",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Wladimir J. van der Laan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1617
        }
    },
    {
        "title": "[bitcoin-dev] General bitcoin users mailing list?",
        "thread_messages": [
            {
                "author": "Cannon",
                "date": "2016-08-14T03:41:25",
                "message_text_only": "I understand this mailing list is for topics relating to development. Is\nthere a general users mailing list for bitcoin related things such as\nquestions that are not necessarily related to dev?\n\n-- \n\nCannon\nPGP Fingerprint: 2BB5 15CD 66E7 4E28 45DC 6494 A5A2 2879 3F06 E832\nEmail: cannon at cannon-ciota.info\nBitmessage Address: BM-2cVaTbC8fJ5UDDaBBs4jPQoFNp1PfNhxqU\nRicochet-IM: ricochet:hfddt2csxnsb2mdq"
            },
            {
                "author": "Daniel Hoffman",
                "date": "2016-08-14T04:14:34",
                "message_text_only": "Have you tried out reddit's /r/btc and /r/Bitcoin?\n\nOn Sat, Aug 13, 2016 at 10:41 PM, Cannon via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I understand this mailing list is for topics relating to development. Is\n> there a general users mailing list for bitcoin related things such as\n> questions that are not necessarily related to dev?\n>\n> --\n>\n> Cannon\n> PGP Fingerprint: 2BB5 15CD 66E7 4E28 45DC 6494 A5A2 2879 3F06 E832\n> Email: cannon at cannon-ciota.info\n> Bitmessage Address: BM-2cVaTbC8fJ5UDDaBBs4jPQoFNp1PfNhxqU\n> Ricochet-IM: ricochet:hfddt2csxnsb2mdq\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160813/bff1a497/attachment.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2016-08-14T04:22:40",
                "message_text_only": "On Sunday, August 14, 2016 3:41:25 AM Cannon via bitcoin-dev wrote:\n> I understand this mailing list is for topics relating to development. Is\n> there a general users mailing list for bitcoin related things such as\n> questions that are not necessarily related to dev?\n\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-discuss"
            }
        ],
        "thread_summary": {
            "title": "General bitcoin users mailing list?",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Cannon",
                "Luke Dashjr",
                "Daniel Hoffman"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 1695
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Knots 0.13.0.knots20160814 released",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2016-08-15T04:13:01",
                "message_text_only": "Bitcoin Knots version 0.13.0.knots20160814 is now available from:\n\n  <https://bitcoinknots.org/files/0.13.x/0.13.0.knots20160814/>\n\nThis is a new major version release, including new features, various bugfixes\nand performance improvements, as well as updated translations.\n\nPlease report bugs using the issue tracker at github:\n\n  <https://github.com/bitcoinknots/bitcoin/issues>\n\nCompatibility\n==============\n\nMicrosoft ended support for Windows XP on [April 8th, 2014]\n(https://www.microsoft.com/en-us/WindowsForBusiness/end-of-xp-support),\nan OS initially released in 2001. This means that not even critical security\nupdates will be released anymore. Without security updates, using a bitcoin\nwallet on a XP machine is irresponsible at least.\n\nIn addition to that, with 0.12.x there have been varied reports of Bitcoin\nCore randomly crashing on Windows XP. It is [not clear]\n(https://github.com/bitcoin/bitcoin/issues/7681#issuecomment-217439891)\nwhat the source of these crashes is, but it is likely that upstream libraries\nsuch as Qt are no longer being tested on XP.\n\nWe do not have time nor resources to provide support for an OS that is\nend-of-life. From 0.13.0 on, Windows XP is no longer supported. Users are\nsuggested to upgrade to a newer verion of Windows, or install an alternative \nOS that is supported.\n\nNo attempt is made to prevent installing or running the software on Windows \nXP, you can still do so at your own risk, but do not expect it to work: do not\nreport issues about Windows XP to the issue tracker.\n\nNotable changes\n===============\n\nNon-mining nodes may influence miner policy\n-------------------------------------------\n\nAs a side-effect of Compact Blocks support (see below), ordinary non-mining\nnodes will download and upload blocks faster if those blocks were produced by\nminers using similar transaction filtering policies. This means that a miner\nwho produces a block with many transactions discouraged by your node will be\nrelayed slower than one with only transactions already in your memory pool.\n\nThe overall effect of such relay differences on the network may result in\nblocks which include widely-discouraged transactions losing a stale block\nrace, and therefore miners may wish to configure their node to take common\nrelay policies into consideration.\n\nBecause of this influence, ordinary nodes should review their mempool policy\nconfiguration, and explicitly make informed decisions about what they wish\ntheir policy to be. Miners should think about whether their current policy is\nwidely accepted by the community, and consider possibly making adjustments.\n\nMany policy options are available in the GUI settings. For reference, the\nequivalent bitcoin.conf settings are: `permitbaremultisig`, `acceptnonstdtxn`,\n`bytespersigop`, `bytespersigopstrict`, `datacarrier`, `datacarriersize`,\n`mempoolreplacement`, `spamfilter`, `maxorphantx`, `maxmempool`,\n`mempoolexpiry`, `limitancestorcount`, `limitancestorsize`,\n`limitdescendantcount`, and `limitdescendantsize`. Further details on the\nconfig file options can be seen with the `-help` command line option.\n\n(Note that nodes still respect a strict first-seen order for competing tip\nblocks, and this change only affects relay speed to peer nodes.)\n\nDatabase cache memory increased\n--------------------------------\n\nAs a result of growth of the UTXO set, performance with the prior default\ndatabase cache of 100 MiB has suffered.\nFor this reason the default was changed to 300 MiB in this release.\n\nFor nodes on low-memory systems, the database cache can be changed back to\n100 MiB (or to another value) by either:\n\n- Adding `dbcache=100` in bitcoin.conf\n- Changing it in the GUI under `Options \u2192 Size of database cache`\n\nNote that the database cache setting has the most performance impact\nduring initial sync of a node, and when catching up after downtime.\n\nbitcoin-cli: arguments privacy\n------------------------------\n\nThe RPC command line client gained a new argument, `-stdin`\nto read extra arguments from standard input, one per line until EOF/Ctrl-D.\nFor example:\n\n    $ src/bitcoin-cli -stdin walletpassphrase\n    mysecretcode\n    120\n    ..... press Ctrl-D here to end input\n    $\n\nIt is recommended to use this for sensitive information such as wallet\npassphrases, as command-line arguments can usually be read from the process\ntable by any user on the system.\n\nC++11 and Python 3\n------------------\n\nVarious code modernizations have been done. The Bitcoin Knots code base has\nstarted using C++11. This means that a C++11-capable compiler is now needed \nfor building. Effectively this means GCC 4.7 or higher, or Clang 3.3 or \nhigher.\n\nFor running the functional tests in `qa/rpc-tests`, Python3.4 or higher is now\nrequired.\n\nLinux ARM builds\n----------------\n\nDue to popular request, Linux ARM builds have been added to the uploaded\nexecutables.\n\nThe following extra files can be found in the download directory or torrent:\n\n- `bitcoin-${VERSION}-arm-linux-gnueabihf.tar.gz`: Linux binaries for the most\n  common 32-bit ARM architecture.\n- `bitcoin-${VERSION}-aarch64-linux-gnu.tar.gz`: Linux binaries for the most\n  common 64-bit ARM architecture.\n\nARM builds are still experimental. If you have problems on a certain device or\nLinux distribution combination please report them on the bug tracker, it may \nbe possible to resolve them.\n\nNote that Android is not considered ARM Linux in this context. The executables\nare not expected to work out of the box on Android.\n\nFee filtering of invs (BIP 133)\n-------------------------------\n\nThe optional new p2p message \"feefilter\" is implemented and the protocol\nversion is bumped to 70013. Upon receiving a feefilter message from a peer,\na node will not send invs for any transactions which do not meet the filter\nfeerate. [BIP 133]\n(https://github.com/bitcoin/bips/blob/master/bip-0133.mediawiki)\n\nCompact Block support (BIP 152)\n-------------------------------\n\nSupport for block relay using the Compact Blocks protocol has been implemented\nin PR 8068.\n\nThe primary goal is reducing the bandwidth spikes at relay time, though in \nmany cases it also reduces propagation delay. It is automatically enabled \nbetween compatible peers.\n[BIP 152](https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki)\n\nHierarchical Deterministic Key Generation\n-----------------------------------------\nNewly created wallets will use hierarchical deterministic key generation\naccording to BIP32 (keypath m/0'/0'/k').\nExisting wallets will still use traditional key generation.\n\nBackups of HD wallets, regardless of when they have been created, can\ntherefore be used to re-generate all possible private keys, even the\nones which haven't already been generated during the time of the backup.\n**Attention:** Encrypting the wallet will create a new seed which requires\na new backup!\n\nHD key generation for new wallets can be disabled by `-usehd=0`. Keep in\nmind that this flag only has affect on newly created wallets.\nYou can't disable HD key generation once you have created a HD wallet.\n\nThere is no distinction between internal (change) and external keys.\n\nHD wallets are incompatible with older versions of Bitcoin Knots.\n\n[Pull request](https://github.com/bitcoin/bitcoin/pull/8035/files), [BIP 32]\n(https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)\n\nSegregated Witness\n------------------\n\nThe code preparations for Segregated Witness (\"segwit\"), as described in [BIP\n141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki), [BIP\n143](https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki), [BIP\n144](https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki), and [BIP\n145](https://github.com/bitcoin/bips/blob/master/bip-0145.mediawiki) are\nfinished and included in this release.  However, BIP 141 does not yet specify\nactivation parameters on mainnet, and so this release does not support segwit\nuse on mainnet.  Testnet use is supported, and after BIP 141 is updated with\nproposed parameters, a future release of Bitcoin Knots is expected that\nimplements those parameters for mainnet.\n\nFurthermore, because segwit activation is not yet specified for mainnet,\nversion 0.13.0 will behave similarly as other pre-segwit releases even after a\nfuture activation of BIP 141 on the network.  Upgrading from 0.13.0 will be\nrequired in order to utilize segwit-related features on mainnet (such as \nsignal BIP 141 activation, mine segwit blocks, fully validate segwit blocks, \nrelay segwit blocks to other segwit nodes, and use segwit transactions in the\nwallet, etc).\n\nMining transaction selection (\"Child Pays For Parent\")\n------------------------------------------------------\n\nThe mining transaction selection algorithm has been replaced with an algorithm\nthat selects transactions based on their feerate inclusive of unconfirmed\nancestor transactions.  This means that a low-fee transaction can become more\nlikely to be selected if a high-fee transaction that spends its outputs is\nrelayed.\n\nWith this change, the `-blockminsize` command line option has been removed.\n\nThe command line option `-blockmaxsize` remains an option to specify the\nmaximum number of serialized bytes in a generated block.  In addition, the new\ncommand line option `-blockmaxweight` has been added, which specifies the\nmaximum \"block weight\" of a generated block, as defined by [BIP 141 \n(Segregated Witness)] \n(https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki).\n\nIn preparation for Segregated Witness, the mining algorithm has been modified\nto choose transactions to mine based on their block weight, rather than number\nof serialized bytes.  In this release, transaction selection is unaffected by\nthis distinction (as BIP 141 activation is not supported on mainnet in this\nrelease, see above), but in future releases and after BIP 141 activation,\nthese calculations would be expected to differ.\n\nReindexing changes\n------------------\n\nIn earlier versions, reindexing did validation while reading through the block\nfiles on disk. These two have now been split up, so that all blocks are known\nbefore validation starts. This was necessary to make certain optimizations \nthat are available during normal synchronizations also available during \nreindexing.\n\nThe two phases are distinct in the Bitcoin-Qt GUI. During the first one,\n\"Reindexing blocks on disk\" is shown. During the second (slower) one,\n\"Processing blocks on disk\" is shown.\n\nIt is possible to only redo validation now, without rebuilding the block \nindex, using the command line option `-reindex-chainstate` (in addition to\n`-reindex` which does both). This new option is useful when the blocks on disk\nare assumed to be fine, but the chainstate is still corrupted. It is also\nuseful for benchmarks.\n\nRemoval of internal miner\n--------------------------\n\nAs CPU mining has been useless for a long time, the internal miner has been\nremoved in this release, and replaced with a simpler implementation for the\ntest framework.\n\nThe overall result of this is that `setgenerate` RPC call has been removed, as\nwell as the `-gen` and `-genproclimit` command-line options.\n\nFor testing, the `generate` call can still be used to mine a block, and a new\nRPC call `generatetoaddress` has been added to mine to a specific address. \nThis works with wallet disabled.\n\nNew bytespersigop implementation\n--------------------------------\n\nThe former implementation of the bytespersigop filter accidentally broke bare\nmultisig (which is meant to be controlled by the `permitbaremultisig` option),\nsince the consensus protocol always counts these older transaction forms as 20\nsigops for backwards compatibility. Simply fixing this bug by counting more\naccurately would have reintroduced a vulnerability. It has therefore been\nreplaced with a new implementation that rather than filter such transactions,\ninstead treats them (for fee purposes only) as if they were in fact the size\nof a transaction actually using all 20 sigops.\n\nThe original filtering behaviour is also available under the new\n`bytespersigopstrict` option, but with fixed/accurate sigop counting.\n\nLow-level P2P changes\n----------------------\n\n- The P2P alert system has been removed in PR #7692 and the `alert` P2P\n  message is no longer supported.\n\n- The transaction relay mechanism used to relay one quarter of all\n  transactions instantly, while queueing up the rest and sending them out in\n  batch. As this resulted in chains of dependent transactions being reordered,\n  it systematically hurt transaction relay. The relay code was redesigned in\n  PRs #7840 and #8082, and now always batches transactions announcements while\n  also sorting them according to dependency order. This significantly reduces\n  orphan transactions. To compensate for the removal of instant relay, the\n  frequency of batch sending was doubled for outgoing peers.\n\n- Since PR #7840 the BIP35 `mempool` command is also subject to batch\n  processing. Also the `mempool` message is no longer handled for\n  non-whitelisted peers when `NODE_BLOOM` is disabled through\n  `-peerbloomfilters=0`.\n\n- The maximum size of orphan transactions that are kept in memory until their\n  ancestors arrive has been raised in PR #8179 from 5000 to 99999 bytes. They\n  are now also removed from memory when they are included in a block, conflict\n  with a block, and time out after 20 minutes.\n\n- We respond at most once to a getaddr request during the lifetime of a\n  connection since PR #7856.\n\n- Connections to peers who have recently been the first one to give us a valid\n  new block or transaction are protected from disconnections since PR #8084.\n\nLow-level RPC changes\n----------------------\n\n- `gettxoutsetinfo` UTXO hash (`hash_serialized`) has changed. There was a\n  divergence between 32-bit and 64-bit platforms, and the txids were missing\n  in the hashed data. This has been fixed, but this means that the output will\n  be different than from previous versions.\n\n- Full UTF-8 support in the RPC API. Non-ASCII characters in, for example,\n  wallet labels have always been malformed because they weren't taken into\n  account properly in JSON RPC processing. This is no longer the case. This\n  also affects the GUI debug console. (This may require upgrading system\n  UniValue library.)\n\n- Asm script outputs replacements for OP_NOP2 and OP_NOP3\n\n  - OP_NOP2 has been renamed to OP_CHECKLOCKTIMEVERIFY by [BIP \n65](https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki)\n\n  - OP_NOP3 has been renamed to OP_CHECKSEQUENCEVERIFY by [BIP \n112](https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki)\n\n  - The following outputs are affected by this change:\n\n    - RPC `getrawtransaction` (in verbose mode)\n    - RPC `decoderawtransaction`\n    - RPC `decodescript`\n    - REST `/rest/tx/` (JSON format)\n    - REST `/rest/block/` (JSON format when including extended tx details)\n    - `bitcoin-tx -json`\n\n- The sorting of the output of the `getrawmempool` output has changed.\n\n- New RPC commands: `generatetoaddress`, `importprunedfunds`, \n`removeprunedfunds`, `signmessagewithprivkey`,\n  `createwitnessaddress`, `addwitnessaddress`.\n\n- Removed RPC commands: `setgenerate`, `getgenerate`.\n\n- New `feeRate` option was added to `fundrawtransaction`\n\nLow-level ZMQ changes\n----------------------\n\n- Each ZMQ notification now contains an up-counting sequence number that\n  allows listeners to detect lost notifications.\n  The sequence number is always the last element in a multi-part ZMQ\n  notification and therefore backward compatible. Each message type has its\n  own counter. PR [#7762](https://github.com/bitcoin/bitcoin/pull/7762).\n\n0.13.0.knots20160814 Change log\n===============================\n\nDetailed release notes follow. This overview includes changes that affect\nbehavior, not code moves, refactors and string updates. For convenience in \nlocating the code changes and accompanying discussion, both the pull request\nand git merge commit are mentioned. Changes specific to Bitcoin Knots (beyond\nCore) are flagged with an asterisk ('*') before the description.\n\n### RPC and other APIs\n\n- #7156 `9ee02cf` Remove cs_main lock from `createrawtransaction` (laanwj)\n- #7326 `2cd004b` Fix typo, wrong information in gettxout help text \n(paveljanik)\n- #7222 `82429d0` Indicate which transactions are signaling opt-in RBF \n(sdaftuar)\n- #7480 `b49a623` Changed getnetworkhps value to double to avoid overflow \n(instagibbs)\n- #7550 `8b958ab` Input-from-stdin mode for bitcoin-cli (laanwj)\n- #7670 `c9a1265` Use cached block hash in blockToJSON() (rat4)\n- #7726 `9af69fa` Correct importaddress help reference to importpubkey \n(CypherGrue)\n- #7766 `16555b6` Register calls where they are defined (laanwj)\n- #7797 `e662a76` Fix generatetoaddress failing to parse address (mruddy)\n- #7774 `916b15a` Add versionHex in getblock and getblockheader JSON results \n(mruddy)\n- #7863 `72c54e3` Getblockchaininfo: make bip9_softforks an object, not an \narray (rustyrussell)\n- #7842 `d97101e` Do not print minping time in getpeerinfo when no ping \nreceived yet (paveljanik)\n- #7518 `be14ca5` Add multiple options to fundrawtransaction (promag)\n- #7756 `9e47fce` Add cursor to iterate over utxo set, use this in \n`gettxoutsetinfo` (laanwj)\n- #7848 `88616d2` Divergence between 32- and 64-bit when hashing >4GB affects \n`gettxoutsetinfo` (laanwj)\n- #7827 `4205ad7` Speed up `getchaintips` (mrbandrews)\n- #7762 `a1eb344` Append a message sequence number to every ZMQ notification \n(jonasschnelli)\n- #7688 `46880ed` List solvability in listunspent output and improve help \n(sipa)\n- #7926 `5725807` Push back `getaddednodeinfo` dead value (instagibbs)\n- #7953 `0630353` Create `signmessagewithprivkey` rpc (achow101)\n- #8049 `c028c7b` Expose information on whether transaction relay is enabled \nin `getnetworkinfo` (laanwj)\n- #7967 `8c1e49b` Add feerate option to `fundrawtransaction` (jonasschnelli)\n- #8118 `9b6a48c` Reduce unnecessary hashing in `signrawtransaction` \n(jonasnick)\n- #7957 `79004d4` Add support for transaction sequence number (jonasschnelli)\n- #8153 `75ec320` `fundrawtransaction` feeRate: Use BTC/kB (MarcoFalke)\n- #7292 `7ce9ac5` Expose ancestor/descendant information over RPC (sdaftuar)\n- #8171 `62fcf27` Fix createrawtx sequence number unsigned int parsing \n(jonasschnelli)\n- #7892 `9c3d0fa` Add full UTF-8 support to RPC (laanwj)\n- #8317 `304eff3` Don't use floating point in rpcwallet (MarcoFalke)\n- #8258 `5a06ebb` Hide softfork in `getblockchaininfo` if timeout is 0 \n(jl2012)\n- #8244 `1922e5a` Remove unnecessary LOCK(cs_main) in getrawmempool (dcousens)\n\n### Block and transaction handling\n\n- #7056 `6a07208` Save last db read (morcos)\n- #6842 `0192806` Limitfreerelay edge case bugfix (ptschip)\n- #7084 `11d74f6` Replace maxFeeRate of 10000*minRelayTxFee with maxTxFee in \nmempool (MarcoFalke)\n- #7539 `9f33dba` Add tags to mempool's mapTx indices (sdaftuar)\n- #7592 `26a2a72` Re-remove ERROR logging for mempool rejects (laanwj)\n- #7187 `14d6324` Keep reorgs fast for SequenceLocks checks (morcos)\n- #7594 `01f4267` Mempool: Add tracking of ancestor packages (sdaftuar)\n- #7904 `fc9e334` Txdb: Fix assert crash in new UTXO set cursor (laanwj)\n- #7927 `f9c2ac7` Minor changes to dbwrapper to simplify support for other \ndatabases (laanwj)\n- #7933 `e26b620` Fix OOM when deserializing UTXO entries with invalid length \n(sipa)\n- #8020 `5e374f7` Use SipHash-2-4 for various non-cryptographic hashes (sipa)\n- #8076 `d720980` VerifyDB: don't check blocks that have been pruned \n(sdaftuar)\n- #8080 `862fd24` Do not use mempool for GETDATA for tx accepted after the \nlast mempool req (gmaxwell)\n- #7997 `a82f033` Replace mapNextTx with slimmer setSpends (kazcw)\n- #8220 `1f86d64` Stop trimming when mapTx is empty (sipa)\n- #8273 `396f9d6` Bump `-dbcache` default to 300MiB (laanwj)\n- #7225 `eb33179` Eliminate unnecessary call to CheckBlock (sdaftuar)\n- #7907 `006cdf6` Optimize and Cleanup CScript::FindAndDelete (pstratem)\n- #7917 `239d419` Optimize reindex (sipa)\n- #7763 `3081fb9` Put hex-encoded version in UpdateTip (sipa)\n- #8149 `d612837` Testnet-only segregated witness (sipa)\n- #8305 `3730393` Improve handling of unconnecting headers (sdaftuar)\n- #8363 `fca1a41` Rename \"block cost\" to \"block weight\" (sdaftuar)\n- #8381 `f84ee3d` Make witness v0 outputs non-standard (jl2012)\n- #8364 `3f65ba2` Treat high-sigop transactions as larger rather than \nrejecting them (sipa)\n- n/a   `15edeeb` *Add a new checkpoint at block 421,888 (luke-jr)\n- n/a   `6ae2e2d` *Restore original bytespersigop as bytespersigopstrict \n(luke-jr)\n\n### P2P protocol and network code\n\n- #6589 `dc0305d` Log bytes recv/sent per command (jonasschnelli)\n- #7164 `3b43cad` Do not download transactions during initial blockchain sync \n(ptschip)\n- #7458 `898fedf` peers.dat, banlist.dat recreated when missing (kirkalx)\n- #7637 `3da5d1b` Fix memleak in TorController (laanwj, jonasschnelli)\n- #7553 `9f14e5a` Remove vfReachable and modify IsReachable to only use \nvfLimited (pstratem)\n- #7708 `9426632` De-neuter NODE_BLOOM (pstratem)\n- #7692 `29b2be6` Remove P2P alert system (btcdrak)\n- #7542 `c946a15` Implement \"feefilter\" P2P message (morcos)\n- #7573 `352fd57` Add `-maxtimeadjustment` command line option (mruddy)\n- #7570 `232592a` Add IPv6 Link-Local Address Support (mruddy)\n- #7874 `e6a4d48` Improve AlreadyHave (morcos)\n- #7856 `64e71b3` Only send one GetAddr response per connection (gmaxwell)\n- #7868 `7daa3ad` Split DNS resolving functionality out of net structures \n(theuni)\n- #7919 `7617682` Fix headers announcements edge case (sdaftuar)\n- #7514 `d9594bf` Fix IsInitialBlockDownload for testnet (jmacwhyte)\n- #7959 `03cf6e8` fix race that could fail to persist a ban (kazcw)\n- #7840 `3b9a0bf` Several performance and privacy improvements to inv/mempool \nhandling (sipa)\n- #8011 `65aecda` Don't run ThreadMessageHandler at lowered priority (kazcw)\n- #7696 `5c3f8dd` Fix de-serialization bug where AddrMan is left corrupted \n(EthanHeilman)\n- #7932 `ed749bd` CAddrMan::Deserialize handle corrupt serializations better \n(pstratem)\n- #7906 `83121cc` Prerequisites for p2p encapsulation changes (theuni)\n- #8033 `18436d8` Fix Socks5() connect failures to be less noisy and less \nunnecessarily scary (wtogami)\n- #8082 `01d8359` Defer inserting into maprelay until just before relaying \n(gmaxwell)\n- #7960 `6a22373` Only use AddInventoryKnown for transactions (sdaftuar)\n- #8078 `2156fa2` Disable the mempool P2P command when bloom filters disabled \n(petertodd)\n- #8065 `67c91f8` Addrman offline attempts (gmaxwell)\n- #7703 `761cddb` Tor: Change auth order to only use password auth if -\ntorpassword (laanwj)\n- #8083 `cd0c513` Add support for dnsseeds with option to filter by \nservicebits (jonasschnelli)\n- #8173 `4286f43` Use SipHash for node eviction (sipa)\n- #8154 `1445835` Drop vAddrToSend after sending big addr message (kazcw)\n- #7749 `be9711e` Enforce expected outbound services (sipa)\n- #8208 `0a64777` Do not set extra flags for unfiltered DNS seed results \n(sipa)\n- #8084 `e4bb4a8` Add recently accepted blocks and txn to \nAttemptToEvictConnection (gmaxwell)\n- #8113 `3f89a53` Rework addnode behaviour (sipa)\n- #8179 `94ab58b` Evict orphans which are included or precluded by accepted \nblocks (gmaxwell)\n- #8068 `e9d76a1` Compact Blocks (TheBlueMatt)\n- #8204 `0833894` Update petertodd's testnet seed (petertodd)\n- #8247 `5cd35d3` Mark my dnsseed as supporting filtering (sipa)\n- #8275 `042c323` Remove bad chain alert partition check (btcdrak)\n- #8271 `1bc9c80` Do not send witnesses in cmpctblock (sipa)\n- #8312 `ca40ef6` Fix mempool DoS vulnerability from malleated transactions \n(sdaftuar)\n- #7180 `16ccb74` Account for `sendheaders` `verack` messages (laanwj)\n- #8102 `425278d` Bugfix: use global ::fRelayTxes instead of CNode in version \nsend (sipa)\n- #8408 `b7e2011` Prevent fingerprinting, disk-DoS with compact blocks \n(sdaftuar)\n\n### Build system\n\n- #7302 `41f1a3e` C++11 build/runtime fixes (theuni)\n- #7322 `fd9356b` c++11: add scoped enum fallbacks to CPPFLAGS rather than \ndefining them locally (theuni)\n- #7441 `a6771fc` Use Debian 8.3 in gitian build guide (fanquake)\n- #7349 `152a821` Build against system UniValue when available (luke-jr)\n- #7520 `621940e` LibreSSL doesn't define OPENSSL_VERSION, use \nLIBRESSL_VERSION_TEXT instead (paveljanik)\n- #7528 `9b9bfce` autogen.sh: warn about needing autoconf if autoreconf is not \nfound (knocte)\n- #7504 `19324cf` Crystal clean make clean (paveljanik)\n- #7619 `18b3f1b` Add missing sudo entry in gitian VM setup (btcdrak)\n- #7616 `639ec58`  [depends] Delete unused patches  (MarcoFalke)\n- #7658 `c15eb28` Add curl to Gitian setup instructions (btcdrak)\n- #7710 `909b72b` [Depends] Bump miniupnpc and config.guess+sub (fanquake)\n- #7723 `5131005` build: python 3 compatibility (laanwj)\n- #7477 `28ad4d9` Fix quoting of copyright holders in configure.ac (domob1812)\n- #7711 `a67bc5e` [build-aux] Update Boost & check macros to latest serials \n(fanquake)\n- #7788 `4dc1b3a` Use relative paths instead of absolute paths in protoc calls \n(paveljanik)\n- #7809 `bbd210d` depends: some base fixes/changes (theuni)\n- #7603 `73fc922` Build System: Use PACKAGE_TARNAME in NSIS script \n(JeremyRand)\n- #7905 `187186b` test: move accounting_tests and rpc_wallet_tests to \nwallet/test (laanwj)\n- #7911 `351abf9` leveldb: integrate leveldb into our buildsystem (theuni)\n- #7944 `a407807` Re-instate TARGET_OS=linux in configure.ac. Removed by \n351abf9e035 (randy-waterhouse)\n- #7920 `c3e3cfb` Switch Travis to Trusty (theuni)\n- #7954 `08b37c5` build: quiet annoying warnings without adding new ones \n(theuni)\n- #7165 `06162f1` build: Enable C++11 in build, require C++11 compiler \n(laanwj)\n- #7982 `559fbae` build: No need to check for leveldb atomics (theuni)\n- #8002 `f9b4582` [depends] Add -stdlib=libc++ to darwin CXX flags (fanquake)\n- #7993 `6a034ed` [depends] Bump Freetype, ccache, ZeroMQ, miniupnpc, expat \n(fanquake)\n- #8167 `19ea173` Ship debug tarballs/zips with debug symbols (theuni)\n- #8175 `f0299d8` Add --disable-bench to config flags for windows (laanwj)\n- #7283 `fd9881a` [gitian] Default reference_datetime to commit author date \n(MarcoFalke)\n- #8181 `9201ce8` Get rid of `CLIENT_DATE` (laanwj)\n- #8133 `fde0ac4` Finish up out-of-tree changes (theuni)\n- #8188 `65a9d7d` Add armhf/aarch64 gitian builds (theuni)\n- #8194 `cca1c8c` [gitian] set correct PATH for wrappers (MarcoFalke)\n- #8198 `5201614` Sync ax_pthread with upstream draft4 (fanquake)\n- #8210 `12a541e` [Qt] Bump to Qt5.6.1 (jonasschnelli)\n- #8285 `da50997` windows: Add testnet link to installer (laanwj)\n- #8304 `0cca2fe` [travis] Update SDK_URL (MarcoFalke)\n- #8310 `6ae20df` Require boost for bench (theuni)\n- #8315 `2e51590` Don't require sudo for Linux (theuni)\n- #8314 `67caef6` Fix pkg-config issues for 0.13 (theuni)\n- #8373 `1fe7f40` Fix OSX non-deterministic dmg (theuni)\n- #8358 `cfd1280` Gbuild: Set memory explicitly (default is too low) \n(MarcoFalke)\n- #8492 `216d796` *configure: Allow building bench_bitcoin by itself (luke-jr)\n- n/a   `2271350` *Qt/Options: Fix warning about comparing signed/unsigned \n(luke-jr)\n\n### GUI\n\n- #7154 `00b4b8d` Add InMempool() info to transaction details (jonasschnelli)\n- #7068 `5f3c670` [RPC-Tests] add simple way to run rpc test over QT clients \n(jonasschnelli)\n- #7218 `a1c185b` Fix misleading translation (MarcoFalke)\n- #7214 `be9a9a3` qt5: Use the fixed font the system recommends (MarcoFalke)\n- #7256 `08ab906` Add note to coin control dialog QT5 workaround (fanquake)\n- #7255 `e289807` Replace some instances of formatWithUnit with \nformatHtmlWithUnit (fanquake)\n- #7317 `3b57e9c` Fix RPCTimerInterface ordering issue (jonasschnelli)\n- #7327 `c079d79` Transaction View: LastMonth calculation fixed (crowning-)\n- #7334 `e1060c5` coincontrol workaround is still needed in qt5.4 (fixed in \nqt5.5) (MarcoFalke)\n- #7383 `ae2db67` Rename \"amount\" to \"requested amount\" in receive coins table \n(jonasschnelli)\n- #7396 `cdcbc59` Add option to increase/decrease font size in the console \nwindow (jonasschnelli)\n- #7437 `9645218` Disable tab navigation for peers tables (Kefkius)\n- #7604 `354b03d` build: Remove spurious dollar sign. Fixes #7189 (dooglus)\n- #7605 `7f001bd` Remove openssl info from init/log and from Qt debug window \n(jonasschnelli)\n- #7628 `87d6562` Add 'copy full transaction details' option (ericshawlinux)\n- #7613 `3798e5d` Add autocomplete to bitcoin-qt's console window (GamerSg)\n- #7668 `b24266c` Fix history deletion bug after font size change (achow101)\n- #7680 `41d2dfa` Remove reflection from `about` icon (laanwj)\n- #7686 `f034bce` Remove 0-fee from send dialog (MarcoFalke)\n- #7506 `b88e0b0` Use CCoinControl selection in CWallet::FundTransaction \n(promag)\n- #7732 `0b98dd7` Debug window: replace \"Build date\" with \"Datadir\" \n(jonasschnelli)\n- #7761 `60db51d` remove trailing output-index from transaction-id \n(jonasschnelli)\n- #7772 `6383268` Clear the input line after activating autocomplete \n(paveljanik)\n- #7925 `f604bf6` Fix out-of-tree GUI builds (laanwj)\n- #7939 `574ddc6` Make it possible to show details for multiple transactions \n(laanwj)\n- #8012 `b33824b` Delay user confirmation of send (Tyler-Hardin)\n- #8006 `7c8558d` Add option to disable the system tray icon (Tyler-Hardin)\n- #8046 `169d379` Fix Cmd-Q / Menu Quit shutdown on OSX (jonasschnelli)\n- #8042 `6929711` Don't allow to open the debug window during splashscreen & \nverification state (jonasschnelli)\n- #8014 `77b49ac` Sort transactions by date (Tyler-Hardin)\n- #8073 `eb2f6f7` askpassphrasedialog: Clear pass fields on accept (rat4)\n- #8129 `ee1533e` Fix RPC console auto completer (UdjinM6)\n- #7636 `fb0ac48` Add bitcoin address label to request payment QR code \n(makevoid)\n- #8231 `760a6c7` Fix a bug where the SplashScreen will not be hidden during \nstartup (jonasschnelli)\n- #8256 `af2421c` BUG: bitcoin-qt crash (fsb4000)\n- #8257 `ff03c50` Do not ask a UI question from bitcoind (sipa)\n- #8288 `91abb77` Network-specific example address (laanwj)\n- #7707 `a914968` UI support for abandoned transactions (jonasschnelli)\n- #8207 `f7a403b` Add a link to the Bitcoin-Core repository and website to the \nAbout Dialog (MarcoFalke)\n- #8281 `6a87eb0` Remove client name from debug window (laanwj)\n- #8407 `45eba4b` Add dbcache migration path (jonasschnelli)\n- n/a   `1e345d2` *Qt/Options: Replace blockminsize with blockmaxweight (luke-\njr)\n- n/a   `2185e93` *Qt/Options: Update for bytespersigopstrict (luke-jr)\n- n/a   `2da1d28` *Recognise NODE_XTHIN service bit (luke-jr)\n\n### Wallet\n\n- #7262 `fc08994` Reduce inefficiency of GetAccountAddress() (dooglus)\n- #7537 `78e81b0` Warn on unexpected EOF while salvaging wallet (laanwj)\n- #7521 `3368895` Don't resend wallet txs that aren't in our own mempool \n(morcos)\n- #7576 `86a1ec5` Move wallet help string creation to CWallet (jonasschnelli)\n- #7577 `5b3b5a7` Move \"load wallet phase\" to CWallet (jonasschnelli)\n- #7608 `0735c0c` Move hardcoded file name out of log messages (MarcoFalke)\n- #7649 `4900641` Prevent multiple calls to CWallet::AvailableCoins (promag)\n- #7646 `e5c3511` Fix lockunspent help message (promag)\n- #7558 `b35a591` Add import/removeprunedfunds rpc call (instagibbs)\n- #7691 `30c2dd8` Refactor wallet/init interaction (jonasschnelli)\n- #6215 `48c5adf` add bip32 pub key serialization (jonasschnelli)\n- #7913 `bafd075` Fix for incorrect locking in GetPubKey() (keystore.cpp) \n(yurizhykin)\n- #7816 `0c95ebc` Slighly refactor GetOldestKeyPoolTime() (jonasschnelli)\n- #8036 `41138f9` init: Move berkeleydb version reporting to wallet (laanwj)\n- #8028 `373b50d` Fix insanity of CWalletDB::WriteTx and \nCWalletTx::WriteToDisk (pstratem)\n- #8061 `f6b7df3` Improve Wallet encapsulation (pstratem)\n- #7891 `950be19` Always require OS randomness when generating secret keys \n(sipa)\n- #7689 `b89ef13` Replace OpenSSL AES with ctaes-based version (sipa)\n- #7825 `f972b04` Prevent multiple calls to ExtractDestination (pedrobranco)\n- #8137 `243ac0c` Improve CWallet API with new AccountMove function (pstratem)\n- #8142 `52c3f34` Improve CWallet API  with new GetAccountPubkey function \n(pstratem)\n- #8035 `b67a472` Add simplest BIP32/deterministic key generation \nimplementation (jonasschnelli)\n- #7687 `a6ddb19` Stop treating importaddress'ed scripts as change (sipa)\n- #8298 `aef3811` wallet: Revert input selection post-pruning (laanwj)\n- #8324 `bc94b87` Keep HD seed during salvagewallet (jonasschnelli)\n- #8323 `238300b` Add HD keypath to CKeyMetadata, report metadata in \nvalidateaddress (jonasschnelli)\n- #8367 `3b38a6a` Ensure <0.13 clients can't open HD wallets (jonasschnelli)\n- #8378 `ebea651` Move SetMinVersion for FEATURE_HD to SetHDMasterKey \n(pstratem)\n- #8390 `73adfe3` Correct hdmasterkeyid/masterkeyid name confusion \n(jonasschnelli)\n- #8206 `18b8ee1` Add HD xpriv to dumpwallet (jonasschnelli)\n- #8389 `c3c82c4` Create a new HD seed after encrypting the wallet \n(jonasschnelli)\n- n/a   `9480ef4` *wallet: Prevent key origin support for HD wallets, since \nthey are incompatible (luke-jr)\n\n### Tests and QA\n\n- #7320 `d3dfc6d` Test walletpassphrase timeout (MarcoFalke)\n- #7208 `47c5ed1` Make max tip age an option instead of chainparam (laanwj)\n- #7372 `21376af` Trivial: [qa] wallet: Print maintenance (MarcoFalke)\n- #7280 `668906f` [travis] Fail when documentation is outdated (MarcoFalke)\n- #7177 `93b0576` [qa] Change default block priority size to 0 (MarcoFalke)\n- #7236 `02676c5` Use createrawtx locktime parm in txn_clone (dgenr8)\n- #7212 `326ffed` Adds unittests for CAddrMan and CAddrinfo, removes source of \nnon-determinism (EthanHeilman)\n- #7490 `d007511` tests: Remove May15 test (laanwj)\n- #7531 `18cb2d5` Add bip68-sequence.py to extended rpc tests (btcdrak)\n- #7536 `ce5fc02` test: test leading spaces for ParseHex (laanwj)\n- #7620 `1b68de3` [travis] Only run check-doc.py once (MarcoFalke)\n- #7455 `7f96671` [travis] Exit early when check-doc.py fails (MarcoFalke)\n- #7667 `56d2c4e` Move GetTempPath() to testutil (musalbas)\n- #7517 `f1ca891` test: script_error checking in script_invalid tests (laanwj)\n- #7684 `3d0dfdb` Extend tests (MarcoFalke)\n- #7697 `622fe6c` Tests: make prioritise_transaction.py more robust (sdaftuar)\n- #7709 `efde86b` Tests: fix missing import in mempool_packages (sdaftuar)\n- #7702 `29e1131` Add tests verifychain, lockunspent, getbalance, \nlistsinceblock (MarcoFalke)\n- #7720 `3b4324b` rpc-test: Normalize assert() (MarcoFalke)\n- #7757 `26794d4` wallet: Wait for reindex to catch up (MarcoFalke)\n- #7764 `a65b36c` Don't run pruning.py twice (MarcoFalke)\n- #7773 `7c80e72` Fix comments in tests (btcdrak)\n- #7489 `e9723cb` tests: Make proxy_test work on travis servers without IPv6 \n(laanwj)\n- #7778 `ff5874b` Bug fixes and refactor (MarcoFalke)\n- #7801 `70ac71b` Remove misleading \"errorString syntax\" (MarcoFalke)\n- #7803 `401c65c` maxblocksinflight: Actually enable test (MarcoFalke)\n- #7802 `3bc71e1` httpbasics: Actually test second connection (MarcoFalke)\n- #7818 `3911a0a` Refactor script tests (sipa)\n- #7849 `ab8586e` tests: add varints_bitpatterns test (laanwj)\n- #7846 `491171f` Clean up lockorder data of destroyed mutexes (sipa)\n- #7853 `6ef5e00` py2: Unfiddle strings into bytes explicitly (MarcoFalke)\n- #7878 `53adc83` [test] bctest.py: Revert faa41ee (MarcoFalke)\n- #7798 `cabba24` [travis] Print the commit which was evaluated (MarcoFalke)\n- #7833 `b1bf511` tests: Check Content-Type header returned from RPC server \n(laanwj)\n- #7851 `fa9d86f` pull-tester: Don't mute zmq ImportError (MarcoFalke)\n- #7822 `0e6fd5e` Add listunspent() test for spendable/unspendable UTXO \n(jpdffonseca)\n- #7912 `59ad568` Tests: Fix deserialization of reject messages (sdaftuar)\n- #7941 `0ea3941` Fixing comment in script_test.json test case (Christewart)\n- #7807 `0ad1041` Fixed miner test values, gave constants for less error-prone \nvalues (instagibbs)\n- #7980 `88b77c7` Smartfees: Properly use ordered dict (MarcoFalke)\n- #7814 `77b637f` Switch to py3 (MarcoFalke)\n- #8030 `409a8a1` Revert fatal-ness of missing python-zmq (laanwj)\n- #8018 `3e90fe6` Autofind rpc tests --srcdir (jonasschnelli)\n- #7971 `4e14afe` Refactor test_framework and pull tester (MarcoFalke)\n- #8016 `5767e80` Fix multithread CScheduler and reenable test (paveljanik)\n- #7972 `423ca30` pull-tester: Run rpc test in parallel  (MarcoFalke)\n- #8039 `69b3a6d` Bench: Add crypto hash benchmarks (laanwj)\n- #8041 `5b736dd` Fix bip9-softforks blockstore issue (MarcoFalke)\n- #7994 `1f01443` Add op csv tests to script_tests.json (Christewart)\n- #8038 `e2bf830` Various minor fixes (MarcoFalke)\n- #8072 `1b87e5b` Travis: 'make check' in parallel and verbose (MarcoFalke)\n- #8056 `8844ef1` Remove hardcoded \"4 nodes\" from test_framework (MarcoFalke)\n- #8047 `37f9a1f` Test_framework: Set wait-timeout for bitcoind procs \n(MarcoFalke)\n- #8095 `6700cc9` Test framework: only cleanup on successful test runs \n(sdaftuar)\n- #8098 `06bd4f6` Test_framework: Append portseed to tmpdir (MarcoFalke)\n- #8104 `6ff2c8d` Add timeout to sync_blocks() and sync_mempools() (sdaftuar)\n- #8111 `61b8684` Benchmark SipHash (sipa)\n- #8107 `52b803e` Bench: Added base58 encoding/decoding benchmarks \n(yurizhykin)\n- #8115 `0026e0e` Avoid integer division in the benchmark inner-most loop \n(gmaxwell)\n- #8090 `a2df115` Adding P2SH(p2pkh) script test case (Christewart)\n- #7992 `ec45cc5` Extend #7956 with one more test (TheBlueMatt)\n- #8139 `ae5575b` Fix interrupted HTTP RPC connection workaround for Python \n3.5+ (sipa)\n- #8164 `0f24eaf` [Bitcoin-Tx] fix missing test fixtures, fix 32bit atoi issue \n(jonasschnelli)\n- #8166 `0b5279f` Src/test: Do not shadow local variables (paveljanik)\n- #8141 `44c1b1c` Continuing port of java comparison tool (mrbandrews)\n- #8201 `36b7400` fundrawtransaction: Fix race, assert amounts (MarcoFalke)\n- #8214 `ed2cd59` Mininode: fail on send_message instead of silent return \n(MarcoFalke)\n- #8215 `a072d1a` Don't use floating point in wallet tests (MarcoFalke)\n- #8066 `65c2058` Test_framework: Use different rpc_auth_pair for each node \n(MarcoFalke)\n- #8216 `0d41d70` Assert 'changePosition out of bounds'  (MarcoFalke)\n- #8222 `961893f` Enable mempool consistency checks in unit tests (sipa)\n- #7751 `84370d5` test_framework: python3.4 authproxy compat (laanwj)\n- #7744 `d8e862a` test_framework: detect failure of bitcoind startup (laanwj)\n- #8280 `115735d` Increase sync_blocks() timeouts in pruning.py (MarcoFalke)\n- #8340 `af9b7a9` Solve trivial merge conflict in p2p-segwit.py (MarcoFalke)\n- #8067 `3e4cf8f` Travis: use slim generic image, and some fixups (theuni)\n- #7951 `5c7df70` Test_framework: Properly print exception (MarcoFalke)\n- #8070 `7771aa5` Remove non-determinism which is breaking net_tests #8069 \n(EthanHeilman)\n- #8309 `bb2646a` Add wallet-hd test (MarcoFalke)\n- #8444 `cd0910b` Fix p2p-feefilter.py for changed tx relay behavior \n(sdaftuar)\n- #6996 `5e6af82` *qa: Adapt preciousblock test to current test framework (and \nPy3) (luke-jr)\n\n### Mining\n\n- #7507 `11c7699` Remove internal miner (Leviathn)\n- #7663 `c87f51e` Make the generate RPC call function for non-regtest (sipa)\n- #7671 `e2ebd25` Add generatetoaddress RPC to mine to an address (achow101)\n- #7935 `66ed450` Versionbits: GBT support (luke-jr)\n- #7598 `e1486eb` Refactor CreateNewBlock to be a method of the BlockAssembler \nclass (morcos)\n- #7600 `66db2d6` Select transactions using feerate-with-ancestors (sdaftuar)\n- #8295 `f5660d3` Mining-related fixups for 0.13.0 (sdaftuar)\n- #7796 `536b75e` Add support for negative fee rates, fixes \n`prioritizetransaction` (MarcoFalke)\n- #8362 `86edc20` Scale legacy sigop count in CreateNewBlock (sdaftuar)\n- #8489 `8b0eee6` Bugfix: Use pre-BIP141 sigops until segwit activates (GBT) \n(luke-jr)\n- n/a   `5a716a3` *Trivially map blockmaxsize to blockmaxweight while segwit \nis unactivated (luke-jr)\n\n### Documentation and miscellaneous\n\n- #7423 `69e2a40` Add example for building with constrained resources (jarret)\n- #8254 `c2c69ed` Add OSX ZMQ requirement to QA readme (fanquake)\n- #8203 `377d131` Clarify documentation for running a tor node (nathaniel-\nmahieu)\n- #7428 `4b12266` Add example for listing ./configure flags (nathaniel-mahieu)\n- #7847 `3eae681` Add arch linux build example (mruddy)\n- #7968 `ff69aaf` Fedora build requirements (wtogami)\n- #8013 `fbedc09` Fedora build requirements, add gcc-c++ and fix typo \n(wtogami)\n- #8009 `fbd8478` Fixed invalid example paths in gitian-building.md \n(JeremyRand)\n- #8240 `63fbdbc` Mention Windows XP end of support in release notes (laanwj)\n- #8303 `5077d2c` Update bips.md for CSV softfork (fanquake)\n- #7789 `e0b3e19` Add note about using the Qt official binary installer \n(paveljanik)\n- #7791 `e30a5b0` Change Precise to Trusty in gitian-building.md (JeremyRand)\n- #7838 `8bb5d3d` Update gitian build guide to debian 8.4.0 (fanquake)\n- #7855 `b778e59` Replace precise with trusty (MarcoFalke)\n- #7975 `fc23fee` Update bitcoin-core GitHub links (MarcoFalke)\n- #8034 `e3a8207` Add basic git squash workflow (fanquake)\n- #7813 `214ec0b` Update port in tor.md (MarcoFalke)\n- #8193 `37c9830` Use Debian 8.5 in the gitian-build guide (fanquake)\n- #8261 `3685e0c` Clarify help for `getblockchaininfo` (paveljanik)\n- #7185 `ea0f5a2` Note that reviewers should mention the id of the commits \nthey reviewed (pstratem)\n- #7290 `c851d8d` [init] Add missing help for args (MarcoFalke)\n- #7281 `f9fd4c2` Improve CheckInputs() comment about sig verification \n(petertodd)\n- #7417 `1e06bab` Minor improvements to the release process (PRabahy)\n- #7444 `4cdbd42` Improve block validity/ConnectBlock() comments (petertodd)\n- #7527 `db2e1c0` Fix and cleanup listreceivedbyX documentation (instagibbs)\n- #7541 `b6e00af` Clarify description of blockindex (pinheadmz)\n- #7590 `f06af57` Improving wording related to Boost library requirements \n[updated] (jonathancross)\n- #7635 `0fa88ef` Add dependency info to test docs (elliotolds)\n- #7609 `3ba07bd` RPM spec file project (AliceWonderMiscreations)\n- #7850 `229a17c` Removed call to `TryCreateDirectory` from \n`GetDefaultDataDir` in `src/util.cpp` (alexreg)\n- #7888 `ec870e1` Prevector: fix 2 bugs in currently unreached code paths \n(kazcw)\n- #7922 `90653bc` CBase58Data::SetString: cleanse the full vector (kazcw)\n- #7881 `c4e8390` Update release process (laanwj)\n- #7952 `a9c8b74` Log invalid block hash to make debugging easier (paveljanik)\n- #7974 `8206835` More comments on the design of AttemptToEvictConnection \n(gmaxwell)\n- #7795 `47a7cfb` UpdateTip: log only one line at most per block (laanwj)\n- #8110 `e7e25ea` Add benchmarking notes (fanquake)\n- #8121 `58f0c92` Update implemented BIPs list (fanquake)\n- #8029 `58725ba` Simplify OS X build notes (fanquake)\n- #8143 `d46b8b5` comment nit: miners don't vote (instagibbs)\n- #8136 `22e0b35` Log/report in 10% steps during VerifyDB (jonasschnelli)\n- #8168 `d366185` util: Add ParseUInt32 and ParseUInt64 (laanwj)\n- #8178 `f7b1bfc` Add git and github tips and tricks to developer notes (sipa)\n- #8177 `67db011` developer notes: updates for C++11 (kazcw)\n- #8229 `8ccdac1` [Doc] Update OS X build notes for 10.11 SDK (fanquake)\n- #8233 `9f1807a` Mention Linux ARM executables in release process and notes \n(laanwj)\n- #7540 `ff46dd4` Rename OP_NOP3 to OP_CHECKSEQUENCEVERIFY (btcdrak)\n- #8289 `26316ff` bash-completion: Adapt for 0.12 and 0.13 (roques)\n- #7453 `3dc3149` Missing patches from 0.12 (MarcoFalke)\n- #7113 `54a550b` Switch to a more efficient rolling Bloom filter (sipa)\n- #7257 `de9e5ea` Combine common error strings for different options so \ntranslations can be shared and reused (luke-jr)\n- #7304 `b8f485c` [contrib] Add clang-format-diff.py (MarcoFalke)\n- #7378 `e6f97ef` devtools: replace github-merge with python version (laanwj)\n- #7395 `0893705` devtools: show pull and commit information in github-merge \n(laanwj)\n- #7402 `6a5932b` devtools: github-merge get toplevel dir without extra \nwhitespace (achow101)\n- #7425 `20a408c` devtools: Fix utf-8 support in messages for github-merge \n(laanwj)\n- #7632 `409f843` Delete outdated test-patches reference (Lewuathe)\n- #7662 `386f438` remove unused NOBLKS_VERSION_{START,END} constants (rat4)\n- #7737 `aa0d2b2` devtools: make github-merge.py use py3 (laanwj)\n- #7781 `55db5f0` devtools: Auto-set branch to merge to in github-merge \n(laanwj)\n- #7934 `f17032f` Improve rolling bloom filter performance and benchmark \n(sipa)\n- #8004 `2efe38b` signal handling: fReopenDebugLog and fRequestShutdown should \nbe type sig_atomic_t (catilac)\n- #7713 `f6598df` Fixes for verify-commits script (petertodd)\n- #8412 `8360d5b` libconsensus: Expose a flag for BIP112 (jtimon)\n- n/a   `d5d0ce6` *corepolicy: Add bytespersigopstrict=0 (luke-jr)\n- #7483 `f8bf558` *Update SVG icon rendering for 0.13 (bitcoin_test.ico, RPM \nspec, VPATH builds) (luke-jr)\n\nCredits\n=======\n\nThanks to everyone who directly contributed to this release:\n\n- 21E14\n- accraze\n- Adam Brown\n- Alexander Regueiro\n- Alex Morcos\n- Alfie John\n- Alice Wonder\n- AlSzacrel\n- Andrew Chow\n- Andr\u00e9s G. Aragoneses\n- Bob McElrath\n- BtcDrak\n- calebogden\n- C\u00e9dric F\u00e9lizard\n- Chirag Dav\u00e9\n- Chris Moore\n- Chris Stewart\n- Christian von Roques\n- Chris Wheeler\n- Cory Fields\n- crowning-\n- Daniel Cousens\n- Daniel Kraft\n- Denis Lukianov\n- Elias Rohrer\n- Elliot Olds\n- Eric Shaw\n- error10\n- Ethan Heilman\n- face\n- fanquake\n- Francesco 'makevoid' Canessa\n- fsb4000\n- Gavin Andresen\n- gladoscc\n- Gregory Maxwell\n- Gregory Sanders\n- instagibbs\n- James O'Beirne\n- Jannes Faber\n- Jarret Dyrbye\n- Jeremy Rand\n- jloughry\n- jmacwhyte\n- Joao Fonseca\n- Johnson Lau\n- Jonas Nick\n- Jonas Schnelli\n- Jonathan Cross\n- Jo\u00e3o Barbosa\n- Jorge Tim\u00f3n\n- Kaz Wesley\n- Kefkius\n- kirkalx\n- Krzysztof Jurewicz\n- Leviathn\n- lewuathe\n- Luke Dashjr\n- Luv Khemani\n- Marcel Kr\u00fcger\n- Marco Falke\n- Mark Friedenbach\n- Matt\n- Matt Bogosian\n- Matt Corallo\n- Matthew English\n- Matthew Zipkin\n- mb300sd\n- Mitchell Cash\n- mrbandrews\n- mruddy\n- Murch\n- Mustafa\n- Nathaniel Mahieu\n- Nicolas Dorier\n- Patrick Strateman\n- Paul Rabahy\n- paveljanik\n- Pavel Jan\u00edk\n- Pavel Vasin\n- Pedro Branco\n- Peter Todd\n- Philip Kaufmann\n- Pieter Wuille\n- Prayag Verma\n- ptschip\n- Puru\n- randy-waterhouse\n- R E Broadley\n- Rusty Russell\n- Suhas Daftuar\n- Suriyaa Kudo\n- TheLazieR Yip\n- Thomas Kerin\n- Tom Harding\n- Tyler Hardin\n- UdjinM6\n- Warren Togami\n- Will Binns\n- Wladimir J. van der Laan\n- Yuri Zhykin\n\nAs well as everyone that helped translating on [Transifex]\n(https://www.transifex.com/projects/p/bitcoin/).\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 1513 bytes\nDesc: This is a digitally signed message part.\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160815/98ccc262/attachment-0001.sig>"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Knots 0.13.0.knots20160814 released",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Luke Dashjr"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 46559
        }
    },
    {
        "title": "[bitcoin-dev] New BIP: Low S values signatures",
        "thread_messages": [
            {
                "author": "Johnson Lau",
                "date": "2016-08-16T10:10:01",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nAs discussed in the 11 Aug 2016 IRC meeting (https://bitcoincore.org/en/meetings/2016/08/11/#softfork-to-make-low-s-required), a new BIP with implementation is prepared to make low S value signature as a consensus rule:\n\nhttps://github.com/jl2012/bips/blob/biplows/bip-lows.mediawiki\n\nhttps://github.com/bitcoin/bitcoin/pull/8514\n\nThe softfork is proposed to be deployed with segwit (BIP141), likely in v0.13.1\n\nThe text is copied below\n\n  BIP: ?\n  Title: Low S values signatures\n  Author: Pieter Wuille <pieter.wuille at gmail.com>\n          Johnson Lau <jl2012 at xbt.hk>\n  Status: Draft\n  Type: Standards Track\n  Created: 2016-08-16\n\nAbstract\n\nThis document specifies proposed changes to the Bitcoin transaction validity rules to restrict signatures to using low S values.\n\nMotivation\n\nECDSA signatures are inherently malleable as taking the negative of the number S inside (modulo the curve order) does not invalidate it. This is a nuisance malleability vector as any relay node on the network may transform the signature, with no access to the relevant private keys required. For non-segregated witness transactions, this malleability will change the txid and invalidate any unconfirmed child transactions. Although the txid of segregated witness (BIP141) transactions is not third party malleable, this malleability vector will change the wtxid and may reduce the efficiency of compact block relay (BIP152).\n\nTo fix this malleability, we require that the S value inside ECDSA signatures is at most the curve order divided by 2 (essentially restricting this value to its lower half range). The value S in signatures must be between 0x1 and 0x7FFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 5D576E73 57A4501D DFE92F46 681B20A0 (inclusive). If S is too high, simply replace it by S' = 0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141 - S.\n\nSpecification\n\nEvery signature passed to OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKMULTISIG, or OP_CHECKMULTISIGVERIFY, to which ECDSA verification is applied, MUST use a S value between 0x1 and 0x7FFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 5D576E73 57A4501D DFE92F46 681B20A0 (inclusive) with strict DER encoding (see BIP66).\n\nThese operators all perform ECDSA verifications on pubkey/signature pairs, iterating from the top of the stack backwards. For each such verification, if the signature does not pass the IsLowDERSignature check, the entire script evaluates to false immediately. If the signature is valid DER with low S value, but does not pass ECDSA verification, opcode execution continues as it used to, causing opcode execution to stop and push false on the stack (but not immediately fail the script) in some cases, which potentially skips further signatures (and thus does not subject them to IsLowDERSignature).\n\nDeployment\n\nThis BIP will be deployed by \"version bits\" BIP9 using the same parameters for BIP141 and BIP143, with the name \"segwit\" and using bit 1.\n\nFor Bitcoin mainnet, the BIP9 starttime will be midnight TBD UTC (Epoch timestamp TBD) and BIP9 timeout will be midnight TBD UTC (Epoch timestamp TBD).\n\nFor Bitcoin testnet, the BIP9 starttime will be midnight 1 May 2016 UTC (Epoch timestamp 1462060800) and BIP9 timeout will be midnight 1 May 2017 UTC (Epoch timestamp 1493596800).\n\nCompatibility\n\nThe reference client has produced compatible signatures since v0.9.0, and the requirement to have low S value signatures has been enforced as a relay policy by the reference client since v0.11.1. As of August 2016, very few transactions violating the requirement are being added to the chain. In addition, every non-compliant signature can trivially be converted into a compliant one, so there is no loss of functionality by this requirement. This proposal has the added benefit of reducing transaction malleability.\n\nImplementation\n\nAn implementation for the reference client is available at https://github.com/bitcoin/bitcoin/pull/8514\n\nAcknowledgements\n\nThis document is extracted from the previous BIP62 proposal which had input from various people.\n\nCopyright\n\nThis document is placed in the public domain.\n\n-----BEGIN PGP SIGNATURE-----\nComment: GPGTools - https://gpgtools.org\n\niQGcBAEBCgAGBQJXsuZLAAoJEO6eVSA0viTSBkIL/RxdKYhfQUcXhWf3wPzJ2rSo\nbhxoGOoswf5Npx1ybKvvTRf51IirgO9JkEl8hYfzLr9KSbfTxCKlr2Z/S+snFGDi\nQ0bvVPcg8uoK1iBMrFmIqCi/0pW3/lnnpgqt+O5Jup+DfK4S1QbSVNff8uP7ZK9x\nNcgXekAbad57JfZ7gki9aERRj4THliTFBlaKkWo4CP+AwCgtKP6BwWvJxnfGpCc5\nEsb/7aFvB0OwTWC7bPdS/XSCChxEdK9n5U3LaUH5o1oMQQhaGVHqeR76Wuf2oDvY\nYsXX0b1gttpSJhz00ifOhMf7PhFzQuNyI6gM6ee7kMXwHMlrmyvROQh009cUzKeZ\n5m7QKiondMsCoyz0zYXncF/MlwoyI7y1M5pQEqF/CHI5yZGu2K3EeDQebEHDzIrd\nRyI6j5BbjLQ4w+geswaxzRSJfkoaKTHdh8g49HL7Q7FUj551jExKA8ZM50SbfeRi\nT4fAN8BTXWVpfHkeDYdM2fesaqmFuN9wg18/xwTWJA==\n=GgxI\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Luke Dashjr",
                "date": "2016-08-16T10:20:27",
                "message_text_only": "On Tuesday, August 16, 2016 10:10:01 AM Johnson Lau via bitcoin-dev wrote:\n> Specification\n> \n> Every signature passed to OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKMULTISIG,\n> or OP_CHECKMULTISIGVERIFY, to which ECDSA verification is applied,\n\nNot 20-byte witness v0 programs?\n\n> These operators all perform ECDSA verifications on pubkey/signature pairs,\n> iterating from the top of the stack backwards. For each such verification,\n> if the signature does not pass the IsLowDERSignature check,\n\n\"the IsLowDERSignature check\" is not well-defined. Probably intend to \nreference the previous paragraph?\n\nLuke"
            },
            {
                "author": "Johnson Lau",
                "date": "2016-08-16T17:46:11",
                "message_text_only": "> On August 16, 2016 at 6:20 AM Luke Dashjr <luke at dashjr.org> wrote:\n>\n>\n> On Tuesday, August 16, 2016 10:10:01 AM Johnson Lau via bitcoin-dev wrote:\n> > Specification\n> >\n> > Every signature passed to OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKMULTISIG,\n> > or OP_CHECKMULTISIGVERIFY, to which ECDSA verification is applied,\n>\n> Not 20-byte witness v0 programs?\n\nThat's an implicit CHECKSIG. Will clarify.\n\n>\n> > These operators all perform ECDSA verifications on pubkey/signature pairs,\n> > iterating from the top of the stack backwards. For each such verification,\n> > if the signature does not pass the IsLowDERSignature check,\n>\n> \"the IsLowDERSignature check\" is not well-defined. Probably intend to\n> reference the previous paragraph?\n\nIsLowDERSignature is the function in Bitcoin Core. That's a bit complicated as the real checking function is not directly called. I'll clarify.\n\n\n>\n> Luke\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160816/b039cd88/attachment-0001.html>"
            },
            {
                "author": "Johnson Lau",
                "date": "2016-08-17T12:43:47",
                "message_text_only": "The BIP146 has been updated to include NULLDUMMY* as part of the softfork:\n\nhttps://github.com/bitcoin/bips/pull/435\n\nNULLDUMMY is a trivial softfork to fix malleability related to the extra stack element consumed by CHECKMULTISIG(VERIFY). It is probably more important than LOW_S since without that an attacker may replace the stack element with any value.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160817/9188d171/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "New BIP: Low S values signatures",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Luke Dashjr",
                "Johnson Lau"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 7035
        }
    },
    {
        "title": "[bitcoin-dev] Hardware Wallet Standard",
        "thread_messages": [
            {
                "author": "Jonas Schnelli",
                "date": "2016-08-16T14:10:04",
                "message_text_only": "Hi\n\nUnfortunately, there is no standard in how desktop- or mobile-wallets\ncan interact with a hardware device resulting in wallet vendors adding\nplugins with proprietary code for non-standardized interfaces.\n\nI started a BIP (extreme draft, feel free to improve language, grammar\nand content) to address this missing part of the ecosystem.\n\nI think it would be extremely helpful if @ledger, @trezor,\n@voisin/@breadwallet, @electrum, @bitpay (and more?!) would help working\non a such standard.\n\nThe BIP describes two approaches how to communicate (pipe and\nURI-scheme) with the signing-devices app, although, in my opinion, all\nmajor platform do support the URI approach (maybe we could drop the pipe\napproach then).\nThe URI approach means that there is no need to configure the\napplication location in order to start a inter-process(-app) communication.\n\nMediawiki:\nhttps://github.com/jonasschnelli/bips/blob/8abb51f0b21b6664388f6e88f6fd642c90d25dca/bip-undef-0.mediawiki\n\n</jonas>\n\n\n---- BIP (rough early stage draft)\n\n<pre>\n  BIP: ???\n  Title: Detached Signing\n  Author: Jonas Schnelli <dev at jonasschnelli.ch>\n  Status: Draft (early stage!)\n  Type: Standards Track\n  Created: 2016-08-02\n</pre>\n\n== Abstract ==\n\nThis BIP describes a way how wallet applications can decouple sensitive\nprivatekeys from the internal keychain and interact with a\nsigning-devices (hardware wallet, \"cold\" storage) over a generic\ninterface in order to get signatures.\n\n== Motivation ==\n\nIt seems like that the current approach for allowing signing-devices to\ninteract with third party wallets is to build a plugin [1][2][3]. Adding\nplugins for each hardware wallet type will increase possible security\nissues and result in multiple proprietary-third-party code within the\nwallet application with very similar structures.\n\nA generic interface how wallets can interact with signing-devices would\nresult in better user experience, less critical code and simpler\nadaption for various signing-devices.\n\n== Specification ==\n\nIn order to support desktop- and smartphone-wallet-applications, this\nBIP describes two slightly different approaches (process pipe and URI\ncall) in how to interact with the signing-devices. If possible, the\nmodern URI approach should be chosen.\n\n=== Signing-Device-Controller-Application ===\n\nTo allow a generic interface while still allowing different ways how to\ninternally communicate with the signing device itself (USB, TCP/IP,\nair-gapped Qr-Code scanning, etc.) a controller-application is required.\n\n=== General signing process ===\n\nThe wallets signing process must be according the following principal:\n* Wallet prepares signing-request-object including bitcoin-transaction\nor message together with metadata (scriptPubKey, hd-keypath of the inputs)\n* Wallet passes signing-request-object to the\nsigning-device-controller-application\n* Signing-device-controller-application processes\nsigning-request-object, eventually shows UI, user can sign or cancel\n* Signing-device-controller-application sends back\nsigning-response-object with signatures or an error\n* Wallet processes signing-response-object and completes data-object\ncreating process (example: add signatures to transaction and broadcast)\n\n=== Desktop Process Intercommunication ===\n\nDesktop wallets can interact with a signing device over process\nintercommunication (pipe) together with a\nsigning-device-controller-application.\nAs specified below, the signing-request-object is a URI string passed\nthrough the pipe. The desktop wallet needs to wait (with a recommended\ntimeout between 1 and 5 minutes) until the signing-response-object will\nbe sent back by the signing-device-controller-application.\n\n=== Smartphone/URI App Intercommunication ===\n\nSmartphones and modern operating systems are trying to sandbox\napplications and interprocess communication (on pipe level) is mostly\ndisallowed.\nOn smartphones, we must use URI-schemes.\nThe wallet can pass information to the\nsigning-device-controller-application by using a predefined URI scheme.\n\n<code>detatchedsigning://<command>?<querystring>&returnurischeme=<returnurischeme://></code>\n\nThe <code>querystring</code> must be URI encoded.\nRFC 2616 does not specify a maximum length of URIs (get request). Most\nmodern smartphone operating system allow URIs up to serval megabytes.\nSigning complex data-structure is therefore possible.\n\nThe <code>returnurischeme</code> must contain a URI schema where the\nresult of the signing process should be returned to.\nThe returnurischeme must be populated and \"opened\" once the signing\nprocess has been completed (or cancled).\n\n=== Signing Request ===\n\nThe signing request is a flexible URI-Query-String that will be used by\nthe Signing-device-controller-application for user confirmation as well\nas for creating the signature.\n\nThe URI-query-string must conform to the following format:\n\n<code>detatchedsigning://sign?type=<bitcoin-p2pkh|bitcoin-p2sh|bitcoin-msg>&data=<raw-transaction|message>&inputscripts=<scriptPubKey-input0>,<scriptPubKey-input1>,...&inputhdkeypath=<hdkeypath0>,<hdkeypath1>,...&returnscheme=<returnurischeme></code>\n\ntype = type of the data to sign\ndata = raw unsigned bitcoin transaction or text-message\n(optional)inputscripts = scriptPubKey(s) of the inputs in exact order\n(optional)inputhdkeypath = hd-keypath of the inputs in exact order\n(optional)returnscheme = a URI scheme where the response must be sent to\n(smartphone approach)\n\n* inputhdkeypath or inputscripts must be provided.\n\n=== Signing Response ===\n\nThe signing response is a flexible URI-Query-String that will be sent\nback to the wallet application and must contain the signatures or an\nerror code.\nThe URI-query-string can be opened (smartphone approach) or will be sent\nback though the interprocess pipe.\n\n<code><returnurischeme>://signresponse?errorcode=<errorcode>&signatures=<signature-input0>,<signature-input0>,...</code>\n\nIn case of ECDSA, the returned signatures must be normalized compact\nsignatures with the size of 64bytes (128 hex chars).\n\n==== Possible error code ====\n\n0 = no error\n1 = user canceled\n2 = timeout\n10 = missing key identifier (missing HD keypath or input scriptpubkey)\n11 = unsupported signing type\n12 = could not resolve script\n50 = unknown internal error\n\n\n==== Examples ====\n\n===== Simple p2pkh transaction =====\nUnsigned raw transaction:\n<code>0100000001fd3cd19d0fb7dbb5bff148e6d3e18bc42cc49a76ed2bfd7d760ad1d7907fd9ce0100000000ffffffff0100e1f505000000001976a9149062e542a78d4fe00dcf7cca89c24a8013c381a388ac00000000</code>\n(input ced97f90d7d10a767dfd2bed769ac42cc48be1d3e648f1bfb5dbb70f9dd13cfd\nvout:1, output: P2PKH mtgQ54Uf3iRTc9kq18rw9SJznngvF5ryZn 1 BTC)\n\nsigning-request URI must be:\n<code>detatchedsigning://sign?type=bitcoin-p2pkh&data=0100000001fd3cd19d0fb7dbb5bff148e6d3e18bc42cc49a76ed2bfd7d760ad1d7907fd9ce0100000000ffffffff0100e1f505000000001976a9149062e542a78d4fe00dcf7cca89c24a8013c381a388ac00000000&inputscripts=76a914531148ad17fdbffd4bac72d43deea6c7cf0387d088ac&inputhdkeypath=m/0'/0'/1&returnscheme=myapp</code>\nThe <code>inputhdkeypath</code> is optional in this case\n\nsigning-response URI must be:\n<code>detatchedsigning://signresponse?error=0&signatures=<128hex-chars></code>\n\n===== Simple a bitcoin message =====\nMessage: <code>Lorem ipsum dolor sit amet</code>\n\nsigning-request URI must be:\n<code>detatchedsigning://sign?type=bitcoinmsg&data=Lorem+ipsum+dolor+sit+amet&inputhdkeypath=m/0'/0'/2</code>\n\nsigning-response URI must be:\n<code>detatchedsigning://signresponse?error=0&signatures=<128hex-chars></code>\n\n=== Support for multiple signing-devices ===\nMust operating systems allow only one registered application per\nURI-scheme. To support multiple signing-devices, wallets and\nsigning-devices can optional add support for brand based URI-schemes.\n\nIn addition to the standard URI scheme,\nsigning-devices-controller-applications can register an additional URI\nscheme (with the identical request/response syntax and logic) including\na brand-identifier.\n\nRegistering a brand-identifier based URI scheme without registering the\ndefault URI scheme is not allowed.\n\nWallets can detect if a certain brand based URI scheme is supported and\ntherefore gives user a selection if multiple signing-devices where\ndetected [4][5].\n\n<code>detatchedsigning<brandid>://</code>\n\nSupported brand-identifiers are:\n* trezor\n* ledger\n* keepkey\n* digitalbitbix\n\n== References ==\n[1] https://github.com/spesmilo/electrum/pull/1662\n[2] https://github.com/spesmilo/electrum/pull/1391\n[3] https://github.com/bitpay/copay/pull/3143\n[4]\nhttps://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplication_Class/\n[5]\nhttps://developer.android.com/reference/android/content/pm/PackageManager.html\n== Acknowledgements ==\n\n== Copyright ==\nThis work is placed in the public domain.\n\n\n\n\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160816/fe4471a9/attachment.sig>"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2016-08-16T14:48:53",
                "message_text_only": "I think it does not make sense to try to get this standardized for\ncurrent Bitcoin transactions. They are just too complex.\n\nWhat might be interesting is to have something similar for Segwit and\nLightning transactions.\n\n* TREZOR performs extended validation of the inputs, when all of\nprev-txs are streamed into the device and validated. Your standard does\nnot tackle this at all and I don't think it's worthy to make this\nstandard unnecessarily complicated.\n\n-- \nBest Regards / S pozdravom,\n\nPavol \"stick\" Rusnak\nSatoshiLabs.com\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160816/802e48ca/attachment.sig>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2016-08-16T15:13:33",
                "message_text_only": "> I think it does not make sense to try to get this standardized for\n> current Bitcoin transactions. They are just too complex.\n> \n> What might be interesting is to have something similar for Segwit and\n> Lightning transactions.\n> \n> * TREZOR performs extended validation of the inputs, when all of\n> prev-txs are streamed into the device and validated. Your standard does\n> not tackle this at all and I don't think it's worthy to make this\n> standard unnecessarily complicated.\n\nI'm aware of this approach but I don't think this makes sense long term.\nWe need a better way on the protocol level to validate inputs amounts\n(where segwit is a first step towards this).\n\nIMO, not having a standard for hardware wallet interfaces/communication\nwill long term result in reducing the end user experience.\n\nI think we should collaborate together and work out a standard.\n\nMy goal is to add hardware wallet support in Bitcoin-Core where adding\nproprietary code (plugin-ish) is something we don't want to do for the\nsake of security and compatibility.\n\nAs said, the \"BIP\" is very draft and I'm happy to include the input\nstreaming as part of it (or you could add it if you want because you\nhave more experience with it).\n\n</jonas>\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160816/75ee098a/attachment.sig>"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2016-08-16T15:21:57",
                "message_text_only": "On 16/08/16 17:13, Jonas Schnelli wrote:\n> I'm aware of this approach but I don't think this makes sense long term.\n> We need a better way on the protocol level to validate inputs amounts\n> (where segwit is a first step towards this).\n\nSo you basically rephrased what I am saying but in another words.\n\n> I think we should collaborate together and work out a standard.\n\nI am for it. I am just saying we should create a standard for new forms\nof transactions (Segwit and maybe Lightning), not the current \"ugly\" ones.\n\n-- \nBest Regards / S pozdravom,\n\nPavol \"stick\" Rusnak\nSatoshiLabs.com\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160816/07dddfef/attachment.sig>"
            },
            {
                "author": "Jochen Hoenicke",
                "date": "2016-08-16T17:48:27",
                "message_text_only": "Hello Jonas,\n\nthanks for your efforts of writing the draft for the standard.\n\nFirst, this only describes detached signing.  A wallet also needs to\nconnect with a hardware wallet at some time to learn the xpubs\ncontrolled by the hardware.  Do you plan to have this in a separate\nstandard or should this also be included here?  Basically one needs one\noperation: get xpub for an HD path.\n\nFrom a first read over the specification I found the following points\nmissing, that a fully checking hardware wallet needs to know:\n\n- the amount spent by each input (necessary for segwit).\n- the full serialized input transactions (without witness informations)\nto prove that the amount really matches (this is not necessary for segwit)\n- the position of the change output and its HD Path (to verify that it\nreally is a change output).\n- For multisig change addresses, there are more extensive checks\nnecessary:  All inputs must be multisig addresses signed with public\nkeys derived from the same set of xpubs as the change address and use\nthe same \"m of n\" scheme.  So for multisig inputs and multisig change\naddress the standard should allow to give the parent xpubs of the other\npublic keys and their derivation paths.\n\nIt is also a bit ambiguous what the \"inputscript\" is especially for p2sh\ntransactions.  Is this always the scriptPubKey of the transaction output\nthat is spent by this input? For p2wsh nested in BIP16 p2sh transactions\nthere are three scripts\n\n    witness:      0 <signature1> <1 <pubkey1> <pubkey2> 2 CHECKMULTISIG>\n    scriptSig:    <0 <32-byte-hash>>\n                  (0x220020{32-byte-hash})\n    scriptPubKey: HASH160 <20-byte-hash> EQUAL\n                  (0xA914{20-byte-hash}87)\n (quoted from BIP-141).\n\nIn principle one could put witness and scriptSig (with \"OP_FALSE\" in\nplaces of the signatures) in the raw transaction and make inputscript\nalways the scriptPubKey of the corresponding output.  Then one also\ndoesn't need to distinguish between p2pkh or p2sh or p2wpkh or \"p2wpkh\nnested in bip16 p2sh\" transactions.\n\nRegards,\n  Jochen\n\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 213 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160816/37adb191/attachment.sig>"
            },
            {
                "author": "Thomas Kerin",
                "date": "2016-08-17T00:25:29",
                "message_text_only": "Hi all,\n\nThanks again Jonas for starting this!\n\nI worked on a similar proposal a while back (never posted), approaching\nthe same problem as if a merchant's website accepted xpubs/public keys,\ncreated multi-signature addresses, and wanted the user to easily sign\noffline instead of using some javascript code / using Core's debug\nconsole / coinb.in\n\nHappily the procedure is largely the same, though I would echo Jochen's\npoint that there needs to be a way to request an xpub/public key.\n\nThe redeemScript and witnessScript are also required fields for full\nvalidation & signing a transaction input if it's P2SH, or just the\nwitnessScript if it's bare V0_P2WSH\n\nSince the output amounts are required, so maybe instead provide\nserialized TxOut's? or Utxo's i.e: [txid, vout, amount, scriptPubKey].\n\nThe protocol ought to be as stateless as possible - it can't be assumed\nwhether the redeemScript and other details will ever be saved on the\ndevice - so perhaps provide the redeemScript + witnessScript as the\nfinal fields on the Utxo structure above.\n\nI do think it enables two important choices for bitcoin users:\n\n* it might be preferable to provide your own xpub vs generating a brand\nnew HD key to potentially lose.\n\n* you could leverage the services provided by [random example]\nGreenAddress without necessarily having to rely on signing code provided\nby them, and so end up only having to trust only one ECDSA\nimplementation when interacting with a wide number of services\n\nAll the best\n\nThomas\n\nOn 08/16/2016 06:48 PM, Jochen Hoenicke via bitcoin-dev wrote:\n> Hello Jonas,\n>\n> thanks for your efforts of writing the draft for the standard.\n>\n> First, this only describes detached signing.  A wallet also needs to\n> connect with a hardware wallet at some time to learn the xpubs\n> controlled by the hardware.  Do you plan to have this in a separate\n> standard or should this also be included here?  Basically one needs one\n> operation: get xpub for an HD path.\n>\n> From a first read over the specification I found the following points\n> missing, that a fully checking hardware wallet needs to know:\n>\n> - the amount spent by each input (necessary for segwit).\n> - the full serialized input transactions (without witness informations)\n> to prove that the amount really matches (this is not necessary for segwit)\n> - the position of the change output and its HD Path (to verify that it\n> really is a change output).\n> - For multisig change addresses, there are more extensive checks\n> necessary:  All inputs must be multisig addresses signed with public\n> keys derived from the same set of xpubs as the change address and use\n> the same \"m of n\" scheme.  So for multisig inputs and multisig change\n> address the standard should allow to give the parent xpubs of the other\n> public keys and their derivation paths.\n>\n> It is also a bit ambiguous what the \"inputscript\" is especially for p2sh\n> transactions.  Is this always the scriptPubKey of the transaction output\n> that is spent by this input? For p2wsh nested in BIP16 p2sh transactions\n> there are three scripts\n>\n>     witness:      0 <signature1> <1 <pubkey1> <pubkey2> 2 CHECKMULTISIG>\n>     scriptSig:    <0 <32-byte-hash>>\n>                   (0x220020{32-byte-hash})\n>     scriptPubKey: HASH160 <20-byte-hash> EQUAL\n>                   (0xA914{20-byte-hash}87)\n>  (quoted from BIP-141).\n>\n> In principle one could put witness and scriptSig (with \"OP_FALSE\" in\n> places of the signatures) in the raw transaction and make inputscript\n> always the scriptPubKey of the corresponding output.  Then one also\n> doesn't need to distinguish between p2pkh or p2sh or p2wpkh or \"p2wpkh\n> nested in bip16 p2sh\" transactions.\n>\n> Regards,\n>   Jochen\n>\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n\nOn 08/16/2016 06:48 PM, Jochen Hoenicke via bitcoin-dev wrote:\n> Hello Jonas,\n>\n> thanks for your efforts of writing the draft for the standard.\n>\n> First, this only describes detached signing.  A wallet also needs to\n> connect with a hardware wallet at some time to learn the xpubs\n> controlled by the hardware.  Do you plan to have this in a separate\n> standard or should this also be included here?  Basically one needs one\n> operation: get xpub for an HD path.\n>\n> From a first read over the specification I found the following points\n> missing, that a fully checking hardware wallet needs to know:\n>\n> - the amount spent by each input (necessary for segwit).\n> - the full serialized input transactions (without witness informations)\n> to prove that the amount really matches (this is not necessary for segwit)\n> - the position of the change output and its HD Path (to verify that it\n> really is a change output).\n> - For multisig change addresses, there are more extensive checks\n> necessary:  All inputs must be multisig addresses signed with public\n> keys derived from the same set of xpubs as the change address and use\n> the same \"m of n\" scheme.  So for multisig inputs and multisig change\n> address the standard should allow to give the parent xpubs of the other\n> public keys and their derivation paths.\n>\n> It is also a bit ambiguous what the \"inputscript\" is especially for p2sh\n> transactions.  Is this always the scriptPubKey of the transaction output\n> that is spent by this input? For p2wsh nested in BIP16 p2sh transactions\n> there are three scripts\n>\n>     witness:      0 <signature1> <1 <pubkey1> <pubkey2> 2 CHECKMULTISIG>\n>     scriptSig:    <0 <32-byte-hash>>\n>                   (0x220020{32-byte-hash})\n>     scriptPubKey: HASH160 <20-byte-hash> EQUAL\n>                   (0xA914{20-byte-hash}87)\n>  (quoted from BIP-141).\n>\n> In principle one could put witness and scriptSig (with \"OP_FALSE\" in\n> places of the signatures) in the raw transaction and make inputscript\n> always the scriptPubKey of the corresponding output.  Then one also\n> doesn't need to distinguish between p2pkh or p2sh or p2wpkh or \"p2wpkh\n> nested in bip16 p2sh\" transactions.\n>\n> Regards,\n>   Jochen\n>\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160817/69978782/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160817/69978782/attachment-0001.sig>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2016-08-17T07:24:46",
                "message_text_only": "Hi all\n\nThanks for the response.\n\n\nJochen's points:\n===============\nIndeed. There are some missing points and I'd like to work this into the\nBIP. Thanks for bringing this up.\n\nAlong with a support for wallet-creation with a xpub from the signing\ndevice, we might also want to support loading multiple pubkeys into a\nkeypool from the device (in case someone likes to use hardened\nderivation at all levels). I guess this would not be over-complex to\nachieve.\n\nLuke's points:\n=============\n\nUSB / Plugin/Driver problematic\n-------------------------------\nI don't think it would be wise to set Trezors USB communication\n(hardware interface) as \"the standard\". A) A USB stack/interaction in\nwallets should be avoided IMO. B) This approach won't work for some\nplatforms (like iOS) due to technical and legal restrictions.\n\nIn my opinion, each hardware wallet has to provide custom software in\nany case. We don't want to standardize how a hardware wallet has to do\nbackups, recovers, firmware upgrade, etc. and if we agree on that, then\nhardware wallets must provide an application (mostly Chrome extensions\ntoday) to implement theses processes.\n\nAlso diversity at the hardware interface will reduce centralized risks\nfor weak security/vulnerabilities.\n\nThe proposed URI scheme approach does not require any sorts of\nlibraries/dependencies. USB HID can be a problem for cross platform\ndesktop wallets as well as it won't work of one of the major mobile\nplatform (iOS). USB HID interaction can be restricted or disabled in non\nsuperuser setups where I'm not aware of any restriction on URI-Scheme level.\n\nURI scheme instead of stdio/pipe\n--------------------------------\nThe URI scheme is not ugly. Its a modern way \u2013 implemented in almost all\nplatforms \u2013 how applications can interact with each other while not\ndirectly knowing each other. Registering a URI scheme like \"bitcoin://\"\nhas some concrete advantages over just piping through stdio.\n\nAlso, the stdio/piping approach does not work for mobile platforms\n(where the URI scheme works).\n\nThe URI scheme does not require any sorts of wallet app level\nconfiguration (where the stdio/pipe approach would require to configure\nsome details about the used hardware wallet).\n\n\nThomase D.'s points:\n===================\nStandardizing to many layers of the interaction stack (including the\nhardware interaction) will very likely result in vendors not sticking to\nthe standard.\n\nI agree, the URI scheme has some fragility, but at a level where we can\nhandle it and with the advantage of abstracting the used brand/device\nfor privacy and security reasons.\n\n> The existing URI scheme, while allowing disambiguate by manufacturer,\nprovides no way to to enumerate available manufacturers or enabled\nwallets.\n\nMost operating systems allow to check if a certain URL-Scheme is\nsupported (registered), this would allow at least to check for known\nmajor vendors (like trezor, etc.) which should solve most\nmulti-hardware-wallet use-cases.\n\nThe URI return scheme does work fine and with the correct set timeouts\nit should result in a neat user experience.\nIt's the proposed way of application intercommunication in Apple iOS [1]\nand Google Android [2].\n\nConclusion:\n===========\n* Non of the points convinced me that there is a better alternative to\nthe proposed URI scheme interaction (please tell me if I'm stubborn).\n* Also, we should move the end users UX in the center of the\nproblems-to-solve (and not overweight the ideal\ncode-/API-/hardware-interaction-design while ignoring the end user\nexperience).\n* We should try to not over-standardize the interaction with the device\nitself to allow flexibility on the hardware wallet vendor side.\n\n[1]\nhttps://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html\n[2] https://developer.android.com/training/basics/intents/sending.html\n\n</jonas>\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160817/63e4d8a4/attachment-0001.sig>"
            },
            {
                "author": "Nicolas Bacca",
                "date": "2016-08-17T07:40:58",
                "message_text_only": "On Wed, Aug 17, 2016 at 9:24 AM, Jonas Schnelli via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> Conclusion:\n> ===========\n> * Non of the points convinced me that there is a better alternative to\n> the proposed URI scheme interaction (please tell me if I'm stubborn).\n>\n\nI'd also agree with this - and it's convenient to test against simulators /\nmocks.\n\n-- \nNicolas Bacca | CTO, Ledger\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160817/62fc71e9/attachment.html>"
            },
            {
                "author": "Dana L. Coe",
                "date": "2016-08-17T10:13:29",
                "message_text_only": "> On Aug 17, 2016, at 15:24, Jonas Schnelli via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> URI scheme instead of stdio/pipe\n> --------------------------------\n> The URI scheme is not ugly. Its a modern way \u2013 implemented in almost all\n> platforms \u2013 how applications can interact with each other while not\n> directly knowing each other. Registering a URI scheme like \"bitcoin://\"\n> has some concrete advantages over just piping through stdio.\n> \n> Also, the stdio/piping approach does not work for mobile platforms\n> (where the URI scheme works).\n> \n> The URI scheme does not require any sorts of wallet app level\n> configuration (where the stdio/pipe approach would require to configure\n> some details about the used hardware wallet).\n\nHi everybody, just thought I\u2019d throw my opinion in here.\n\nThe URI scheme is a nice idea, but this ignores the fact that hardware wallet vendors do most of the work on talking between the computer/mobile and the wallet on a lower level of communication. In the case of BitLox, the base protocol is Google\u2019s ProtoBuf. The commands and transaction data is in a \u201cschema\u201d which is then encoded in different methods accessible via ProtoBuf (depending on the data being sent). The advantages of this protocol is that it can be implemented on a wide variety of platforms. (but that\u2019s a whole 'nother discussion)\n\nThe URI would be handled waaaaay up in the specific application (such as the mytrezor wallet software or the various standalone wallets) - nowhere near the actual hardware communications layer.\n\nBest regards,\nDana\nBitLox\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 841 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160817/bddd5d9e/attachment.sig>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2016-08-17T11:34:35",
                "message_text_only": "Hi Dana\n\n>> The URI scheme does not require any sorts of wallet app level\n>> configuration (where the stdio/pipe approach would require to configure\n>> some details about the used hardware wallet).\n> \n> Hi everybody, just thought I\u2019d throw my opinion in here.\n> \n> The URI scheme is a nice idea, but this ignores the fact that hardware wallet vendors do most of the work on talking between the computer/mobile and the wallet on a lower level of communication. In the case of BitLox, the base protocol is Google\u2019s ProtoBuf. The commands and transaction data is in a \u201cschema\u201d which is then encoded in different methods accessible via ProtoBuf (depending on the data being sent). The advantages of this protocol is that it can be implemented on a wide variety of platforms. (but that\u2019s a whole 'nother discussion)\n> \n> The URI would be handled waaaaay up in the specific application (such as the mytrezor wallet software or the various standalone wallets) - nowhere near the actual hardware communications layer.\n\nThis is maybe a question of the scope.\nThe BIP I'm proposing would make a clear interface cut between\nwallet-with-unsigned-transaction and a signing-device (and maybe between\nwallet-requires-pubkey, signing-device generate some pubkeys [or\nnon-hardened xpub]).\n\nThe detached-signing proposal does not duplicate work. It just moves the\ncurrent plugin design into a separate application. Plugins in security\nand privacy critical wallet software is something that should probably\nbe avoided.\n\nIt's intentional at a high level to allow maximum flexibility at the\nhardware interaction layer.\n\nYour protobuf example is a good use-case. You could implement your\ncustom processes behind the URI scheme (which is probably way more\nefficient then writing a couple of wallet plugins where you \u2013 at the end\n\u2013 mostly don't control the deployment and the source-code).\n\nDefining a standard on the hardware interaction layer is possible, but a\nfairly different approach.\n\n</jonas>\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160817/3eea9613/attachment-0001.sig>"
            },
            {
                "author": "Marek Palatinus",
                "date": "2016-08-17T17:06:08",
                "message_text_only": "Hi,\n\nI fundamentally disagree with the concept of driving signing workflow by\nthe wallet software. Wallet software does not know in advance all data\nnecessary for the signer to do the job. As Jochen mentioned above, Segwit\nvs Non-segwit use cases are a good example, but there may be many.\n\nCurrently the TREZOR protocol works like device is a server and wallet is a\nclient calling methods on it. It's like: \"Sign this for me, please\", \"Ok,\ngive me this information\", \"Here it is\", \"Now I need this another\npiece\".... \"There is the signature\". Wallet does not know in advance what\nwill go next, and it is for sake of simplicity. I'm quite happy with the\nprotocol so far.\n\nConsidering the difference in between current hardware, I really don't\nthink it is possible to find any minimal URI-based API good enough for\ncommunicating with all vendors. What I see more likely is some 3rd party\nlibraries (JS, C++, Python, ...) defining high-level API and implementing\nhardware-specific protocols and transports as plugins. That way vendors are\nnot limited by strict standard and application developers and services can\nintegrate wide range of hardware wallets easily. However, this can be done\nalready and we do not need any standardization process (yet).\n\nslush\n\nOn Wed, Aug 17, 2016 at 1:34 PM, Jonas Schnelli via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi Dana\n>\n> >> The URI scheme does not require any sorts of wallet app level\n> >> configuration (where the stdio/pipe approach would require to configure\n> >> some details about the used hardware wallet).\n> >\n> > Hi everybody, just thought I\u2019d throw my opinion in here.\n> >\n> > The URI scheme is a nice idea, but this ignores the fact that hardware\n> wallet vendors do most of the work on talking between the computer/mobile\n> and the wallet on a lower level of communication. In the case of BitLox,\n> the base protocol is Google\u2019s ProtoBuf. The commands and transaction data\n> is in a \u201cschema\u201d which is then encoded in different methods accessible via\n> ProtoBuf (depending on the data being sent). The advantages of this\n> protocol is that it can be implemented on a wide variety of platforms. (but\n> that\u2019s a whole 'nother discussion)\n> >\n> > The URI would be handled waaaaay up in the specific application (such as\n> the mytrezor wallet software or the various standalone wallets) - nowhere\n> near the actual hardware communications layer.\n>\n> This is maybe a question of the scope.\n> The BIP I'm proposing would make a clear interface cut between\n> wallet-with-unsigned-transaction and a signing-device (and maybe between\n> wallet-requires-pubkey, signing-device generate some pubkeys [or\n> non-hardened xpub]).\n>\n> The detached-signing proposal does not duplicate work. It just moves the\n> current plugin design into a separate application. Plugins in security\n> and privacy critical wallet software is something that should probably\n> be avoided.\n>\n> It's intentional at a high level to allow maximum flexibility at the\n> hardware interaction layer.\n>\n> Your protobuf example is a good use-case. You could implement your\n> custom processes behind the URI scheme (which is probably way more\n> efficient then writing a couple of wallet plugins where you \u2013 at the end\n> \u2013 mostly don't control the deployment and the source-code).\n>\n> Defining a standard on the hardware interaction layer is possible, but a\n> fairly different approach.\n>\n> </jonas>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160817/136eadac/attachment.html>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2016-08-18T06:54:04",
                "message_text_only": "Hi\n\n> I fundamentally disagree with the concept of driving signing workflow by\n> the wallet software. Wallet software does not know in advance all data\n> necessary for the signer to do the job. As Jochen mentioned above,\n> Segwit vs Non-segwit use cases are a good example, but there may be many.\n\nI think this is easily solvable. The required data to verify and sign a\n(standard) bitcoin transaction (including P2WSH multi-sig) is manageable.\n\nIMO what a signing devices requires in order to sign a (standard)\ntransaction:\n-> serialized tx\n-> serialized tx of the inputs\n-> scriptPubKey of the inputs\n-> inputs redeem-Scripts\n-> input amounts\n-> position of the change output any maybe its keypath\n-> cosigners pubkeys for inputs and changeaddress\n\nThis seems to be manageable for a 1 round communication?\nOr do I miss something?\n\n\n> Currently the TREZOR protocol works like device is a server and wallet\n> is a client calling methods on it. It's like: \"Sign this for me,\n> please\", \"Ok, give me this information\", \"Here it is\", \"Now I need this\n> another piece\".... \"There is the signature\". Wallet does not know in\n> advance what will go next, and it is for sake of simplicity. I'm quite\n> happy with the protocol so far.\n\nI think multiple rounds would still be possible with a clever design.\nAlthough I could imaging that >95% of the users transaction would\nrequire only a single \"shot\".\n\nWhats the benefits of the multiple rounds communication? Would a single\nround result in to many data transported?\n\nPassing a 300kb chunk (assuming a large transaction) over a URI scheme\nrequires a couple of milliseconds on standard Smartphones or PCs.\n\n> Considering the difference in between current hardware, I really don't\n> think it is possible to find any minimal URI-based API good enough for\n> communicating with all vendors. What I see more likely is some 3rd party\n> libraries (JS, C++, Python, ...) defining high-level API and\n> implementing hardware-specific protocols and transports as plugins. That\n> way vendors are not limited by strict standard and application\n> developers and services can integrate wide range of hardware wallets\n> easily. However, this can be done already and we do not need any\n> standardization process (yet).\n\nThe URI-based API allows transmitting data of multiple megabytes while\nthere is no need for...\n* dependencies of any form (library, etc.)\n* library support for a particular language\n* platform that supports the dependencies of the library (like USBHID,\nnot supported by iOS)\n\nCan you elaborate what benefits you would get from the library approach\nand how the library API would be different form the proposed URI-scheme?\n\nHow would the library approach work on mobile platforms? Would USB be\nthe only supported hardware communication layer?\n\nThanks\n--\n</jonas>\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160818/5ae29972/attachment.sig>"
            },
            {
                "author": "Marek Palatinus",
                "date": "2016-08-18T09:15:23",
                "message_text_only": "> Can you elaborate what benefits you would get from the library approach\nand how the library API would be different form the proposed URI-scheme?\n\nThe main benefit is that you don't need \"standard\" to solve problem, but\nuse natural tools in given environment and programming stack. Build a\n\"standard\" on top of URI protocol is a huge limitation, which does not give\nany advantage.\n\nWe already see issues with dead simple \"bitcoin uri\" standard, it barely\nworks in most of bitcoin apps. Think of vague definitions of parameters or\nability to send payment requests over it. HW API would be complicated by an\norder of magnitude and I have serious concerns that it will be helpful for\nanything. So why complicate things.\n\n> How would the library approach work on mobile platforms? Would USB be\nthe only supported hardware communication layer?\n\nInterprocess communication/libraries/dependencies on Android are not bound\nto specific transport anyhow. Such library could be used by any android\napp, and the library would implement proper transports for various\nsupported vendors. USB for Trezor, NFC for something different etc. If the\npoint is \"make life of app developers easier\", let's do this and do not\ndefine artifical \"standards\".\n\nslush\n\n\nOn Thu, Aug 18, 2016 at 8:54 AM, Jonas Schnelli <dev at jonasschnelli.ch>\nwrote:\n\n> Hi\n>\n> > I fundamentally disagree with the concept of driving signing workflow by\n> > the wallet software. Wallet software does not know in advance all data\n> > necessary for the signer to do the job. As Jochen mentioned above,\n> > Segwit vs Non-segwit use cases are a good example, but there may be many.\n>\n> I think this is easily solvable. The required data to verify and sign a\n> (standard) bitcoin transaction (including P2WSH multi-sig) is manageable.\n>\n> IMO what a signing devices requires in order to sign a (standard)\n> transaction:\n> -> serialized tx\n> -> serialized tx of the inputs\n> -> scriptPubKey of the inputs\n> -> inputs redeem-Scripts\n> -> input amounts\n> -> position of the change output any maybe its keypath\n> -> cosigners pubkeys for inputs and changeaddress\n>\n> This seems to be manageable for a 1 round communication?\n> Or do I miss something?\n>\n>\n> > Currently the TREZOR protocol works like device is a server and wallet\n> > is a client calling methods on it. It's like: \"Sign this for me,\n> > please\", \"Ok, give me this information\", \"Here it is\", \"Now I need this\n> > another piece\".... \"There is the signature\". Wallet does not know in\n> > advance what will go next, and it is for sake of simplicity. I'm quite\n> > happy with the protocol so far.\n>\n> I think multiple rounds would still be possible with a clever design.\n> Although I could imaging that >95% of the users transaction would\n> require only a single \"shot\".\n>\n> Whats the benefits of the multiple rounds communication? Would a single\n> round result in to many data transported?\n>\n> Passing a 300kb chunk (assuming a large transaction) over a URI scheme\n> requires a couple of milliseconds on standard Smartphones or PCs.\n>\n> > Considering the difference in between current hardware, I really don't\n> > think it is possible to find any minimal URI-based API good enough for\n> > communicating with all vendors. What I see more likely is some 3rd party\n> > libraries (JS, C++, Python, ...) defining high-level API and\n> > implementing hardware-specific protocols and transports as plugins. That\n> > way vendors are not limited by strict standard and application\n> > developers and services can integrate wide range of hardware wallets\n> > easily. However, this can be done already and we do not need any\n> > standardization process (yet).\n>\n> The URI-based API allows transmitting data of multiple megabytes while\n> there is no need for...\n> * dependencies of any form (library, etc.)\n> * library support for a particular language\n> * platform that supports the dependencies of the library (like USBHID,\n> not supported by iOS)\n>\n> Can you elaborate what benefits you would get from the library approach\n> and how the library API would be different form the proposed URI-scheme?\n>\n> How would the library approach work on mobile platforms? Would USB be\n> the only supported hardware communication layer?\n>\n> Thanks\n> --\n> </jonas>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160818/59c71c94/attachment-0001.html>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2016-08-18T09:35:05",
                "message_text_only": "Hi\n\n> The main benefit is that you don't need \"standard\" to solve problem, but\n> use natural tools in given environment and programming stack. Build a\n> \"standard\" on top of URI protocol is a huge limitation, which does not\n> give any advantage.\n\nStandards can help an ecosystem to grow, can help to sustain a good user\nexperience.\n\nThe hardware wallet vendors have used \"natural tools\" and look where we\nare. We have *native* plugins in Electrum, Copay, etc. for different\nhardware wallets. Mostly the plugins are in the code base of the wallet,\nwhich makes it \u2013 in theory \u2013 impossible to change from the perspective\nof the hardware wallet vendor (there is no control of the deployment if\nthere are bugs in the plugins code).\nThe plugins functions overlap significant.\n\nI think this is a bad design for security critical applications.\n\nWhat I want as hardware wallet user:\n* I'd like to have a trusted application (layer) where I'm sure I'm\nusing software provided through my hardware wallet vendor.\n\nWhat I want as hardware wallet vendor:\n* I'd like to be able to provide and update a software layer (app) to my\ncustomer with the ability to provide code signatures and security\nupdates anytime. I do want to control the user experience.\n\n\n> We already see issues with dead simple \"bitcoin uri\" standard, it barely\n> works in most of bitcoin apps. Think of vague definitions of parameters\n> or ability to send payment requests over it. HW API would be complicated\n> by an order of magnitude and I have serious concerns that it will be\n> helpful for anything. So why complicate things.\n\nAs far as I know most bitcoin wallets do support the bitcoin:// URI\nscheme quite well.\nI agree that BIP70 is a mess (including the bitcoin:// additions).\n\nThe proposed URI scheme would be completely different. The only\nsimilarity is using the URI scheme as transport layer (which is the\nproposed long term inter-app communication layer by Apple and Google).\n\n>> How would the library approach work on mobile platforms? Would USB be\n> the only supported hardware communication layer?\n> \n> Interprocess communication/libraries/dependencies on Android are not\n> bound to specific transport anyhow. Such library could be used by any\n> android app, and the library would implement proper transports for\n> various supported vendors. USB for Trezor, NFC for something different\n> etc. If the point is \"make life of app developers easier\", let's do this\n> and do not define artifical \"standards\".\n\nSo you propose having one library that would support multiple vendors?\nWhat if new vendors add a new transport layer (lets assume NFC or\nBluetooth), wouldn't that result in every possible consumer of that\nlibrary (all wallets) need to update before the new vendors transport\nlayer could be used, resulting in a huge deployment process probably\nrequire many month until it can be used?\n\nWhat if there is a critical security issue in the library? How would the\ndeployment plan looks like?\n\nI really think we should remove the \"hardware communication layer\" from\nwallets and move it towards the hardware vendor app.\n\nWhat about iOS? Should we just leave that platform unsupported with\nhardware wallets?\n\n</jonas>\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160818/ca1a24d9/attachment.sig>"
            },
            {
                "author": "Marek Palatinus",
                "date": "2016-08-18T09:43:33",
                "message_text_only": "On Thu, Aug 18, 2016 at 11:35 AM, Jonas Schnelli <dev at jonasschnelli.ch>\nwrote:\n\n> I agree that BIP70 is a mess (including the bitcoin:// additions). The\n> proposed URI scheme would be completely different.\n\n\nThis reminds me https://xkcd.com/927/\n\nI have some experience with hardware wallet development and its integration\nand I know it's a mess. But it is too early to define such rigid standards\nyet. Also, TREZOR concept (device as a server and the primary source of\nworkflow management) goes directly against your proposal of wallet software\nas an workflow manager. So it is clear NACK for me.\n\nslush\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160818/2fd8ecbe/attachment.html>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2016-08-18T09:49:51",
                "message_text_only": "Hi\n\n> I have some experience with hardware wallet development and its\n> integration and I know it's a mess. But it is too early to define such\n> rigid standards yet. Also, TREZOR concept (device as a server and the\n> primary source of workflow management) goes directly against your\n> proposal of wallet software as an workflow manager. So it is clear NACK\n> for me.\n\nThe current question \u2013 as already mentioned \u2013 is we ACK to work together\non a signing protocol or if we NACK this before we even have started.\n\nI'm not saying that the draft proposal I made is the way to go, I'm\nhappy to NACK it myself in favor of a better proposal.\n\nI strongly recommend to work together on a standard that will have one\ncentral winner: the end user.\n\n</jonas>\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160818/343d9d28/attachment.sig>"
            },
            {
                "author": "Nicolas Bacca",
                "date": "2016-08-18T10:23:21",
                "message_text_only": "On Thu, Aug 18, 2016 at 11:49 AM, Jonas Schnelli via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi\n>\n> > I have some experience with hardware wallet development and its\n> > integration and I know it's a mess. But it is too early to define such\n> > rigid standards yet. Also, TREZOR concept (device as a server and the\n> > primary source of workflow management) goes directly against your\n> > proposal of wallet software as an workflow manager. So it is clear NACK\n> > for me.\n>\n> The current question \u2013 as already mentioned \u2013 is we ACK to work together\n> on a signing protocol or if we NACK this before we even have started.\n>\n\nACK for Ledger. What's necessary to sign a transaction is well known, I\ndon't see how driving any hardware wallet from the wallet itself or from a\nthird party daemon implementing that URL scheme would make any difference,\nother than providing better devices interoperability, as well as easier\nmaintenance and update paths for the wallets.\n\n-- \nNicolas Bacca | CTO, Ledger\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160818/cac3d457/attachment.html>"
            },
            {
                "author": "Thomas Kerin",
                "date": "2016-08-24T10:31:20",
                "message_text_only": "I want to pitch a use-case that might have been ignored in this discussion:\n\nI don't think this protocol is only useful for hardware wallets.\nTechnically any website that wants to request public keys/signatures and\noffload the responsibility for managing keys and signing to the user\nwould also find this valuable.\n\nI hope we can move forward with a protocol that suits both the hardware\npeople, and the people who find signing transactions in browsers\nunsettling.\n\nMaybe we the focus should move away from only servicing hardware, and\nasking if the motivation is better captured by \"allow users pick their\nown ECDSA implementation, hardware or software\", then working out what\nwe need to get us there.\n\n\nOn 08/18/2016 12:23 PM, Nicolas Bacca via bitcoin-dev wrote:\n> On Thu, Aug 18, 2016 at 11:49 AM, Jonas Schnelli via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>\n>     Hi\n>\n>     > I have some experience with hardware wallet development and its\n>     > integration and I know it's a mess. But it is too early to\n>     define such\n>     > rigid standards yet. Also, TREZOR concept (device as a server\n>     and the\n>     > primary source of workflow management) goes directly against your\n>     > proposal of wallet software as an workflow manager. So it is\n>     clear NACK\n>     > for me.\n>\n>     The current question \u2013 as already mentioned \u2013 is we ACK to work\n>     together\n>     on a signing protocol or if we NACK this before we even have started.\n>\n>\n> ACK for Ledger. What's necessary to sign a transaction is well known,\n> I don't see how driving any hardware wallet from the wallet itself or\n> from a third party daemon implementing that URL scheme would make any\n> difference, other than providing better devices interoperability, as\n> well as easier maintenance and update paths for the wallets.\n>\n> -- \n> Nicolas Bacca | CTO, Ledger\n>\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160824/ce0a856d/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160824/ce0a856d/attachment-0001.sig>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2016-08-16T19:22:29",
                "message_text_only": "On Tuesday, August 16, 2016 2:10:04 PM Jonas Schnelli via bitcoin-dev wrote:\n> The BIP describes two approaches how to communicate (pipe and\n> URI-scheme) with the signing-devices app, although, in my opinion, all\n> major platform do support the URI approach (maybe we could drop the pipe\n> approach then).\n\nIMO it's kindof ugly to abuse URIs for communication. Stdio pipes are pretty \nuniversally supported, why not just use those?\n\nOn the other hand, no matter how the plugin is implemented, it's still a \nsecurity risk, and requires installation (which the user might not have access \nfor). It would be best if the hardware protocol were standardised, so the user \ndoesn't need a plugin of *any* sort... I notice some hardware wallets have \nbegun to implement (or reuse) Trezor's interface, so that would seem a good \nplace to start?\n\nLuke"
            },
            {
                "author": "Thomas Daede",
                "date": "2016-08-17T00:03:00",
                "message_text_only": "On 08/16/2016 12:22 PM, Luke Dashjr via bitcoin-dev wrote:\n> It would be best if the hardware protocol were standardised, so the user \n> doesn't need a plugin of *any* sort... I notice some hardware wallets have \n> begun to implement (or reuse) Trezor's interface, so that would seem a good \n> place to start?\n\nI also agree with this - the user experience would be a lot better\nwithout the need to install custom adapter software, especially for the\ndesktop case.\n\nThere could be two layers to the specification - the raw messages that\nneed to be passed, and the transport mechanism to pass them (USB HID, QR\ncode, audio...). For the most common case (USB), both layers could be\ndefined, and other transports could be added later. This split already\nexists in the draft specification, though it's not very clear (URIs\ninclude return URIs that don't make sense for a pipe, for example).\n\nThe existing URI scheme, while allowing disambiguate by manufacturer,\nprovides no way to to enumerate available manufacturers or enabled\nwallets. This means that the \"driver\" would have to include a GUI to\nselect this. Also, passing return URIs seems rather fragile - are there\nany other examples of protocols that use URIs for bidirectional IPC?\n\nThomas"
            },
            {
                "author": "Aiqin Li",
                "date": "2016-08-16T23:36:02",
                "message_text_only": "Out of curiosity, what is the technical reason a normal ECC-enabled \nsmart-card cannot be used for the hardware signing component of a wallet \napp? (Since if it can, its standardization must have been discussed.)\n\nDebian wiki gives a list of such cards with related opensource software \nto access them.\n\nRegards"
            },
            {
                "author": "Peter Todd",
                "date": "2016-08-17T00:14:07",
                "message_text_only": "On Wed, Aug 17, 2016 at 09:36:02AM +1000, Aiqin Li via bitcoin-dev wrote:\n> Out of curiosity, what is the technical reason a normal ECC-enabled\n> smart-card cannot be used for the hardware signing component of a wallet\n> app? (Since if it can, its standardization must have been discussed.)\n> \n> Debian wiki gives a list of such cards with related opensource software to\n> access them.\n\nI'm not aware of any ECC-enabled smart-cards that can sign the specific curve\nthat Bitcoin uses, not to mention the fact that those smartcards generally only\nspeak higher level protocols than raw signature generation, precluding the\nsigning of bitcoin transactions.\n\nThe other serious problem - and this is a problem with smartcards in general\nanyway - is that without Bitcoin-specific logic you're just signing blindly; we\nrecently saw the problems with that with the Bitfinex/BitGo hack. And even\nthen, without a screen most of the hardware wallets in are still just signing\nblindly, with at best hard-to-use limits on maximum funds moved\nper-transaction. Also note how even hardware wallets with a screen, like\nTrezor, aren't yet able to authenticate who you are paying.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160816/29699c7e/attachment.sig>"
            },
            {
                "author": "Nicolas Bacca",
                "date": "2016-08-17T07:27:03",
                "message_text_only": "On Wed, Aug 17, 2016 at 2:14 AM, Peter Todd via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> I'm not aware of any ECC-enabled smart-cards that can sign the specific\n> curve\n> that Bitcoin uses, not to mention the fact that those smartcards generally\n> only\n> speak higher level protocols than raw signature generation, precluding the\n> signing of bitcoin transactions.\n>\n\nany Java Card supporting ECC can sign on user supplied Weierstrass curve\nparameters - you can find a good shopping list at\nhttp://www.fi.muni.cz/~xsvenda/jcsupport.html (look for ALG_ECDSA_SHA256 on\njavacard.crypto.signature). The NXP JCOP platform (found in Yubico Neo) is\na popular choice, and then you can add your own custom logic for validation.\n\n-- \nNicolas Bacca | CTO, Ledger\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160817/2502add3/attachment.html>"
            },
            {
                "author": "Bryan Bishop",
                "date": "2016-08-17T18:36:38",
                "message_text_only": "On Tue, Aug 16, 2016 at 7:14 PM, Peter Todd via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> The other serious problem - and this is a problem with smartcards in\n> general\n> anyway - is that without Bitcoin-specific logic you're just signing\n> blindly; we\n> recently saw the problems with that with the Bitfinex/BitGo hack. And even\n> then, without a screen most of the hardware wallets in are still just\n> signing\n> blindly, with at best hard-to-use limits on maximum funds moved\n> per-transaction. Also note how even hardware wallets with a screen, like\n> Trezor, aren't yet able to authenticate who you are paying.\n>\n\n\"Welcome to my threat model.\"\n\nIn multisig scenarios, there must be a different \"trust root\" for each key.\nFor example, storing two private keys next to each other on the same web\nserver is broken because if one key is compromised it is infinitely trivial\nto compromise the second key. Using multiple web servers is also broken if\nthe two servers are controlled by the same AWS keys or same \"help me get my\nservers back\" support email request to whatever single sign-on service is\nused. In some cases, it can be better to write software such that\ntransaction data is served at a particular location, and another\nsecurity-critical step is responsible for downloading that data from the\nfirst machine, rather than the first computer directly pushing (with\nauthentication credentials in place for the attacker to compromise) the\ndata to the second computer.\n\nI recommend using hardware security modules (HSMs). It's important to have\na public, reviewed bitcoin standard for hardware wallets, especially HSMs.\nI expect this is something that the entire industry has a tremendous\ninterest in following and contributing to, which could even lead to\nadditional resources contributed (or at the very least, more detailed\nrequirements) towards libconsensus work.\n\nInstead of signing any bitcoin transaction that the hardware wallet is\ngiven, the hardware should be responsible for running bitcoin validation\nrules and business logic, which I recommend for everyone, not only\nbusinesses. Without running business logic and bitcoin validation rules,\nthe actual bitcoin history on the blockchain could be a very different\nreality from what the hardware thinks is happening. Using a different\nout-of-band communication channel, the hardware could query for information\nfrom another database in another trust root, which would be useful for\nbusiness logic to validate against.\n\nAs for a screen, I consider that somewhat limited because you only get text\noutput (and I don't know if I can reasonably suggest QR codes here). With a\nscreen, you are limited to text output, which can compromise privacy of the\ndevice's operations and info about the wallet owner. An alternative would\nbe to have a dedicated port that is responsibly only for sending out data\nencrypted to the key of the wallet owner, to report information such as\nwhatever the hardware's transaction planner has decided, or to report about\nthe state of the device, state of the bitcoin validation rules, or any\naccounting details, etc. Additionally, even a signed transaction should be\nencrypted to the key of the device owner because a signed transaction can\nbe harmless as long as the owner still has the ability to control whether\nthe signed transaction is broadcasted to the network. It's \"separation of\nconcerns\" for transaction signing and decrypting a signed transaction\nshould be unrelated and uncoupled.\n\nAlso I am eager to see what the community proposes regarding signed and\nauthenticated payment requests.\n\n((insert here general promotional statement regarding the value of reusable\nchecklists used during every signing ritual ceremony))\n\n- Bryan\nhttp://heybryan.org/\n1 512 203 0507\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160817/5492f37f/attachment.html>"
            },
            {
                "author": "Moral Agent",
                "date": "2016-08-22T16:50:13",
                "message_text_only": "It would be nice if the detached signer and the normal wallet could both\nverify the correctness of generated addresses before you cause coins to be\nsent there.\n\ne.g. the hardware wallet could give its master public key to Bitcoin Core\nand you can thereafter generate your receiving addresses on Core, with the\noption to have the HW wallet validate them.\n\nOne of my biggest fears about using any wallet is the \"whoops, cosmic ray\nflipped a bit while producing receiving address; SFYL!\" possibility. For\nhigh value cold storage, I always generate my addresses on two independent\nmachines using two different pieces of software. Am I nuts for doing that?\n\nWith the above scheme, you are pretty well protected from losing money if\nyour HW wallet is defective. You could still lose it if the HW wallet was\nevil of course, but that strikes me as much more likely to be discovered\nquickly.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160822/2f6378e9/attachment.html>"
            },
            {
                "author": "Corey Haddad",
                "date": "2016-08-28T23:14:03",
                "message_text_only": "*One of my biggest fears about using any wallet is the \"whoops, cosmic ray\nflipped a bit while producing receiving address; SFYL!\" possibility. For\nhigh value cold storage, I always generate my addresses on two independent\nmachines using two different pieces of software. Am I nuts for doing that?*\nA randomly flipped bit would be extremely unlikely to yield a valid\naddress, however, I still think it you are wise to use independent routes\nto confirm that your addresses match the keys.  I do the same when I\ngenerating my cold storage key pairs.  I think malicious address\nsubstitution is an under appreciated attack vector.\n\nRegarding this thread in general, would it make sense for this proposal to\ninclude standards for multi-sig wallet interoperability?  A whole spectrum\nof attacks would be made less likely - and easy for typical users to guard\nagainst - by using wallets on separate devices AND where the wallet\nsoftware was written and provided by different parties.\n\nOn Mon, Aug 22, 2016 at 9:50 AM, Moral Agent via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> It would be nice if the detached signer and the normal wallet could both\n> verify the correctness of generated addresses before you cause coins to be\n> sent there.\n>\n> e.g. the hardware wallet could give its master public key to Bitcoin Core\n> and you can thereafter generate your receiving addresses on Core, with the\n> option to have the HW wallet validate them.\n>\n> One of my biggest fears about using any wallet is the \"whoops, cosmic ray\n> flipped a bit while producing receiving address; SFYL!\" possibility. For\n> high value cold storage, I always generate my addresses on two independent\n> machines using two different pieces of software. Am I nuts for doing that?\n>\n> With the above scheme, you are pretty well protected from losing money if\n> your HW wallet is defective. You could still lose it if the HW wallet was\n> evil of course, but that strikes me as much more likely to be discovered\n> quickly.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160828/65c0f30a/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Hardware Wallet Standard",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Aiqin Li",
                "Bryan Bishop",
                "Moral Agent",
                "Thomas Daede",
                "Corey Haddad",
                "Thomas Kerin",
                "Pavol Rusnak",
                "Peter Todd",
                "Dana L. Coe",
                "Nicolas Bacca",
                "Marek Palatinus",
                "Jochen Hoenicke",
                "Luke Dashjr",
                "Jonas Schnelli"
            ],
            "messages_count": 26,
            "total_messages_chars_count": 62979
        }
    },
    {
        "title": "[bitcoin-dev] New BIP: Dealing with OP_IF and OP_NOTIF malleability in P2WSH",
        "thread_messages": [
            {
                "author": "Johnson Lau",
                "date": "2016-08-16T17:53:08",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nA new BIP is prepared to deal with OP_IF and OP_NOTIF malleability in P2WSH:\nhttps://github.com/jl2012/bips/blob/minimalif/bip-minimalif.mediawiki\nhttps://github.com/bitcoin/bitcoin/pull/8526\n\n   BIP: x\n   Title: Dealing with OP_IF and OP_NOTIF malleability in P2WSH\n   Author: Johnson Lau <jl2012 at xbt.hk>\n   Status: Draft\n   Type: Standards Track\n   Created: 2016-08-17\n\nAbstract\n\nThis document specifies proposed changes to the Bitcoin script validity rules in order to make transaction malleability related to OP_IF and OP_NOTIF impossible in pay-to-witness-script-hash (P2WSH) scripts.\n\nMotivation\n\nOP_IF and OP_NOTIF are flow control codes in the Bitcoin script system. The programme flow is decided by whether the top stake value is True or False. However, this behaviour opens a source of malleability as a third party may replace a True (False) stack item with any other True (False) value without invalidating the transaction.\n\nThe proposed rules apply only to pay-to-witness-script-hash (P2WSH) scripts described in BIP141, which has not been activated on the Bitcoin mainnet as of writing. To ensure OP_IF and OP_NOTIF transactions created before the introduction of this BIP will still be accepted by the network, the new rules are not applied to non-segregated witness scripts.\n\nSpecification\n\nIn P2WSH, the argument for OP_IF and OP_NOTIF MUST be exactly an empty vector or 0x01, or the script evaluation fails immediately.\n\nThis is deployed using BIP9 after segregated witness (BIP141) is activated. Details TBD.\n\nCompatibility\n\nThis is a softfork on top of BIP141. The rules are enforced as a relay policy by the reference client since the first release of BIP141 (v0.13.1). To avoid risks of fund loss, users MUST NOT create P2WSH scripts that are incompatible with this BIP. An OP_0NOTEQUAL may be used before OP_IF or OP_NOTIF to imitate the original behaviour (which may also re-enable the malleability vector depending on the exact script).\n\nImplementation\n\nhttps://github.com/bitcoin/bitcoin/pull/8526\n\nCopyright\n\nThis work is placed in the public domain.\n-----BEGIN PGP SIGNATURE-----\nComment: GPGTools - https://gpgtools.org\n\niQGcBAEBCgAGBQJXs1LgAAoJEO6eVSA0viTSrJQL/A/womJKgi4FuyBTL9oykCss\naBMNN9+SLtmuH7SBgEUGZ8TFxa2st+6RP6Imu+Vvn4O5sXQl3DIXV+X38X93sUYk\nwrjdpvdpqFFYJezPDESz6pR/6bZ1ES0aO2QqX578/8sqr8GO6L388s66vJeIGj4n\n0LWW8sdEypMuV3HUG/9FFdUNHgiVX1U0sS1rT3P4aN30JYtb7PQpd7r8KTMta7Rt\nL1VOZB+W3m2m2YZ9gB7IRmMfzzNm2QXRTPIZXt2x3mYDBuMkp+zEd5+ogA4sBpgP\nwp2+l/aos686v0w8QYiNUX2+9Qpe7+238qUpw75d2XJYmLzdotWFvmp4g1hP+awX\nHEfwe4BUM+El17LjrHkNeMWNJXMlhTtXb2i0XMj8tU5lZVHep4WpQ+LEahrNlsUl\nFdFsi3q8HeWh8JsGaNCL41Bgbg/rKb5hUXyF6hTRHa//E6llOrpXRnsloKgBLv8c\nQezgKTAPwwgdjcS6Ek0AqgLp7bCFRijCduYH9i9uaQ==\n=lLIZ\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Luke Dashjr",
                "date": "2016-08-16T19:37:19",
                "message_text_only": "On Tuesday, August 16, 2016 5:53:08 PM Johnson Lau via bitcoin-dev wrote:\n> A new BIP is prepared to deal with OP_IF and OP_NOTIF malleability in\n> P2WSH:\n> https://github.com/jl2012/bips/blob/minimalif/bip-minimalif.mediawiki\n> https://github.com/bitcoin/bitcoin/pull/8526\n\nI am not sure this makes sense. SegWit transactions are already non-malleable \ndue to skipping the witness data in calculating the transaction id. What is \nthe benefit to this?\n\nLuke"
            },
            {
                "author": "Peter Todd",
                "date": "2016-08-16T19:43:32",
                "message_text_only": "On Tue, Aug 16, 2016 at 07:37:19PM +0000, Luke Dashjr via bitcoin-dev wrote:\n> On Tuesday, August 16, 2016 5:53:08 PM Johnson Lau via bitcoin-dev wrote:\n> > A new BIP is prepared to deal with OP_IF and OP_NOTIF malleability in\n> > P2WSH:\n> > https://github.com/jl2012/bips/blob/minimalif/bip-minimalif.mediawiki\n> > https://github.com/bitcoin/bitcoin/pull/8526\n> \n> I am not sure this makes sense. SegWit transactions are already non-malleable \n> due to skipping the witness data in calculating the transaction id. What is \n> the benefit to this?\n\nSegWit txids aren't malleable, but segwit transactions as a whole still are.\nFor instance, I could mess with a segwit transaction by replacing part of the\nwitness that is used as an argument to an OP_IF with a much larger push,\npotentially making the transaction larger, thus making it not get mined due to\nthe higher fee. There are also potential legal issues if someone replaces a\npush with data where posession in your jurisdiction is illegal.\n\nHaving said that, a better approach may be a separate CHECKBOOLVERIFY opcode\nthat fails unless the top item on the stack is a minimally encoded true or\nfalse value, to allow script writers to opt into this behavior; it's not always\nideal.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160816/98322ba5/attachment.sig>"
            },
            {
                "author": "Joseph Poon",
                "date": "2016-08-16T21:58:58",
                "message_text_only": "I agree this is an interesting area of transaction malleability to still\nconsider in the future, and minimization of these areas of malleability\nwith regards to its impact on the p2p network should be easy to resolve\nand (hopefully) well-understood by script writers in the future.\n\nOn Tue, Aug 16, 2016 at 12:43:32PM -0700, Peter Todd via bitcoin-dev wrote:\n> Having said that, a better approach may be a separate CHECKBOOLVERIFY opcode\n> that fails unless the top item on the stack is a minimally encoded true or\n> false value, to allow script writers to opt into this behavior; it's not always\n> ideal.\n\nI think the biggest value of the proposed BIP behavior is that the cost\nis lower for \"doing it right\" to create script enforcement of OP_TRUE or\nOP_FALSE. It is already possible to enforce with 2 bytes pushing OP_TRUE\nand then OP_EQUAL. Creating an \"OP_CHECKBOOLVERIFY\" definitely achieves\nthe same result, but at a 1-byte (insetad of 2-byte) cost to \"do it\nright\", so there is the same incentive to save on the byte and push\npotential DoS costs onto the network -- whereas enforcing OP_TRUE byte\nin OP_IF would create costs for those who want to evaluate pushdata, so\nthat has to be explicitly opt-in from an optimization/convenience\nstandpoint.\n\n-- \nJoseph Poon"
            },
            {
                "author": "Russell O'Connor",
                "date": "2016-08-16T22:23:00",
                "message_text_only": "On Tue, Aug 16, 2016 at 3:43 PM, Peter Todd via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Tue, Aug 16, 2016 at 07:37:19PM +0000, Luke Dashjr via bitcoin-dev\n> wrote:\n> > On Tuesday, August 16, 2016 5:53:08 PM Johnson Lau via bitcoin-dev wrote:\n> > > A new BIP is prepared to deal with OP_IF and OP_NOTIF malleability in\n> > > P2WSH:\n> > > https://github.com/jl2012/bips/blob/minimalif/bip-minimalif.mediawiki\n> > > https://github.com/bitcoin/bitcoin/pull/8526\n> >\n> > I am not sure this makes sense. SegWit transactions are already\n> non-malleable\n> > due to skipping the witness data in calculating the transaction id. What\n> is\n> > the benefit to this?\n>\n> SegWit txids aren't malleable, but segwit transactions as a whole still\n> are.\n> For instance, I could mess with a segwit transaction by replacing part of\n> the\n> witness that is used as an argument to an OP_IF with a much larger push,\n> potentially making the transaction larger, thus making it not get mined\n> due to\n> the higher fee. There are also potential legal issues if someone replaces a\n> push with data where posession in your jurisdiction is illegal.\n>\n\nIf one's goal is to mess with an transaction to prevent it from being\nmined, it is more effective to just not relay the transaction rather than\nto mess with the witness.  Given two transactions with the same txid and\ndifferent witness data, miners and good nodes ought to mine/relay the\nversion with the lower cost (smaller?) witness data.\n\nWorries about \"illegal data\" appearing in the blockchain is not an issue\nworth writing a soft-fork over.\n\nThere may be good reasons for this BIP, but I don't think the reasons give\nabove are good.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160816/06d324f7/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2016-08-16T22:30:52",
                "message_text_only": "On Aug 17, 2016 00:23, \"Russell O'Connor via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> If one's goal is to mess with an transaction to prevent it from being\nmined, it is more effective to just not relay the transaction rather than\nto mess with the witness.  Given two transactions with the same txid and\ndifferent witness data, miners and good nodes ought to mine/relay the\nversion with the lower cost (smaller?) witness data.\n\nThat implies that everyone will see both versions and be able to make that\nchoice. Unfortunately, those two versions will be definition be in conflict\nwith each other, and thus only one will end up paying a fee. We're can't\nrelay two transactions for the price of one, or we'd expose the p2p network\nto a very cheap DDoS attack: just send increasingly small versions of the\nsame transaction.\n\nSegwit's third party mallebility protection makes it not an issue for\ndependent contracts if transactions are mauled (=apparently the verb\nrelated to malleability), but there are still good reasons for senders not\nto gratuitously make their transactions extensible in size or other\nresources.\n\n--\nPieter\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160817/2c5284a7/attachment.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2016-08-16T22:36:24",
                "message_text_only": "On Tue, Aug 16, 2016 at 6:30 PM, Pieter Wuille <pieter.wuille at gmail.com>\nwrote:\n\n> On Aug 17, 2016 00:23, \"Russell O'Connor via bitcoin-dev\" <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > If one's goal is to mess with an transaction to prevent it from being\n> mined, it is more effective to just not relay the transaction rather than\n> to mess with the witness.  Given two transactions with the same txid and\n> different witness data, miners and good nodes ought to mine/relay the\n> version with the lower cost (smaller?) witness data.\n>\n> That implies that everyone will see both versions and be able to make that\n> choice. Unfortunately, those two versions will be definition be in conflict\n> with each other, and thus only one will end up paying a fee. We're can't\n> relay two transactions for the price of one, or we'd expose the p2p network\n> to a very cheap DDoS attack: just send increasingly small versions of the\n> same transaction.\n>\nCan I already do something similar with replace by fee, or are there limits\non that?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160816/a0057d43/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2016-08-16T22:39:08",
                "message_text_only": "On Aug 17, 2016 00:36, \"Russell O'Connor\" <roconnor at blockstream.io> wrote:\n\n> Can I already do something similar with replace by fee, or are there\nlimits on that?\n\nBIP125 and mempool eviction both require the replacing transaction to have\nhigher fee, to compensate for the cost of relaying the replaced\ntransaction(s).\n\n-- \nPieter\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160817/3710f5b7/attachment.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2016-08-16T22:52:38",
                "message_text_only": "I see.\n\nBut is it really necessary to soft fork over this issue?  Why not just make\nit a relay rule?  Miners are already incentivized to modify transactions to\ndrop excess witness data and/or prioritize (versions of) transactions based\non their cost.  If a miner wants to mine a block with excess witness data,\nit is mostly their own loss.\n\nOn Tue, Aug 16, 2016 at 6:39 PM, Pieter Wuille <pieter.wuille at gmail.com>\nwrote:\n\n> On Aug 17, 2016 00:36, \"Russell O'Connor\" <roconnor at blockstream.io> wrote:\n>\n> > Can I already do something similar with replace by fee, or are there\n> limits on that?\n>\n> BIP125 and mempool eviction both require the replacing transaction to have\n> higher fee, to compensate for the cost of relaying the replaced\n> transaction(s).\n>\n> --\n> Pieter\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160816/e72fef81/attachment-0001.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2016-08-17T00:18:09",
                "message_text_only": "On Tue, Aug 16, 2016 at 10:52 PM, Russell O'Connor via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> I see.\n>\n> But is it really necessary to soft fork over this issue?  Why not just make\n> it a relay rule?  Miners are already incentivized to modify transactions to\n> drop excess witness data and/or prioritize (versions of) transactions based\n> on their cost.  If a miner wants to mine a block with excess witness data,\n> it is mostly their own loss.\n\nRelay rules are quite fragile-- people build programs or protocols not\nexpecting them to be violated, without proper error handling in those\ncases... and then eventually some miner rips them out because they\nsimply don't care about them: not enforcing them won't make their\nblocks invalid.\n\nIt's my general view that we should avoid blocking things with relay\nrules unless we think that someday they could be made invalid... not\nnecessarily that they will, but that it's plausible. Then the\nelimination at the relay level is just the first exploratory step in\nthat direction.\n\nOne should also consider adversarial behavior by miners.  For example,\nI can mine blocks with mutated witnesses with a keyed mac that chooses\nthe mutation. The key is shared by conspirators or customers, and now\ncollectively we have a propagation advantage (since we know the\nmutated version before it shows up).  Not the _biggest_ concern, since\nparties doing this could just create their own new transactions to\nselectively propagate; but doing that would require leaving behind fee\npaying public transactions, while using malleability wouldn't."
            },
            {
                "author": "Russell O'Connor",
                "date": "2016-08-17T00:27:54",
                "message_text_only": "Okay.\n\nI'm not really opposed to this BIP, but I am worried that fighting script\nmalleability is a battle that can never be won; even leaving one avenue of\nmalleability open is probably just as bad as having many avenues of\nmalleability, so it just doesn't seem worthwhile to me.\n\nOn Tue, Aug 16, 2016 at 8:18 PM, Gregory Maxwell <greg at xiph.org> wrote:\n\n> On Tue, Aug 16, 2016 at 10:52 PM, Russell O'Connor via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > I see.\n> >\n> > But is it really necessary to soft fork over this issue?  Why not just\n> make\n> > it a relay rule?  Miners are already incentivized to modify transactions\n> to\n> > drop excess witness data and/or prioritize (versions of) transactions\n> based\n> > on their cost.  If a miner wants to mine a block with excess witness\n> data,\n> > it is mostly their own loss.\n>\n> Relay rules are quite fragile-- people build programs or protocols not\n> expecting them to be violated, without proper error handling in those\n> cases... and then eventually some miner rips them out because they\n> simply don't care about them: not enforcing them won't make their\n> blocks invalid.\n>\n> It's my general view that we should avoid blocking things with relay\n> rules unless we think that someday they could be made invalid... not\n> necessarily that they will, but that it's plausible. Then the\n> elimination at the relay level is just the first exploratory step in\n> that direction.\n>\n> One should also consider adversarial behavior by miners.  For example,\n> I can mine blocks with mutated witnesses with a keyed mac that chooses\n> the mutation. The key is shared by conspirators or customers, and now\n> collectively we have a propagation advantage (since we know the\n> mutated version before it shows up).  Not the _biggest_ concern, since\n> parties doing this could just create their own new transactions to\n> selectively propagate; but doing that would require leaving behind fee\n> paying public transactions, while using malleability wouldn't.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160816/891f91a7/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2016-08-17T02:30:07",
                "message_text_only": "On Tue, Aug 16, 2016 at 08:27:54PM -0400, Russell O'Connor via bitcoin-dev wrote:\n> Okay.\n> \n> I'm not really opposed to this BIP, but I am worried that fighting script\n> malleability is a battle that can never be won; even leaving one avenue of\n> malleability open is probably just as bad as having many avenues of\n> malleability, so it just doesn't seem worthwhile to me.\n\nAt least some types of malleability are less harmful than others: changing a\nfew bits with some weird ECC transformation isn't as likely to cause problems\nas being able to append arbitrary data to a transaction's input script. And of\ncourse, we do prevent the latter with the cleanstack rule - consensus enforced\nin segwit.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160816/3a991698/attachment.sig>"
            },
            {
                "author": "Johnson Lau",
                "date": "2016-08-17T03:02:53",
                "message_text_only": "> On August 16, 2016 at 8:27 PM Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Okay.\n> \n> I'm not really opposed to this BIP, but I am worried that fighting script malleability is a battle that can never be won; even leaving one avenue of malleability open is probably just as bad as having many avenues of malleability, so it just doesn't seem worthwhile to me.\n\nNot really. I think the goal is to protect as many common scripts as possible.\n\nFor example:\n1) BIP146 (Low S values signatures) will eliminate all malleability for P2WPKH\n2) BIP146 + null dummy value for CHECKMULTISIG (\"NULLDUMMY\") will eliminate all malleability for simple multi-sig in P2WSH. This is particularly interesting since without NULLDUMMY, attackers are able to replace the dummy value with anything.\n3) BIP146 + NULLDUMMY + minimal IF argument (\"MINIMALIF\") will eliminate malleability for any Lightening Network scripts that I'm aware of.\n\nWith 3), 99.99% of segwit transactions in foreseeable future should be fully protected.\n\nThe plan is to implement MINIMALIF as a relay policy first, and enforce the softfork after further risks assessment. This BIP serves as a warning to users for not using incompatible script.\n\nPeter Todd:\n> Having said that, a better approach may be a separate CHECKBOOLVERIFY opcode that fails unless the top item on the stack is a minimally encoded true or false value, to allow script writers to opt into this behavior; it's not always ideal.\n\nI believe all Lightening Network scripts (the only real users of IF/NOTIF in foreseeable future) are already compatible with MINIMALIF. It may not be a good idea for them to spend 1 more byte to get protected.\n\nIf people want to have the original OP_IF behaviour, a simple way would be using \"0NOTEQUAL IF\". However, this works only if the argument is a valid number (also beware of MINIMALDATA rule in BIP62).\n\nTo completely replicate the original behaviour, one may use:\n\"DEPTH TOALTSTACK IFDUP DEPTH FROMALTSTACK NUMNOTEQUAL IF 2DROP {if script} ELSE DROP {else script} ENDIF\"\n\nThis is because we don't have a simple OP_CASTTOBOOL, and IFDUP is 1 of the 4 codes that perform CastToBool on top stack item (the others are VERIFY, IF, and NOTIF; and VERIFY can't be used here since it terminates the script with a False)."
            },
            {
                "author": "Luke Dashjr",
                "date": "2016-08-17T04:40:34",
                "message_text_only": "On Wednesday, August 17, 2016 3:02:53 AM Johnson Lau via bitcoin-dev wrote:\n> To completely replicate the original behaviour, one may use:\n> \"DEPTH TOALTSTACK IFDUP DEPTH FROMALTSTACK NUMNOTEQUAL IF 2DROP {if script}\n> ELSE DROP {else script} ENDIF\"\n\nThis is much uglier than expected. IMO if that's the best workaround for the \ncurrent behaviour, people should just use \"OP_1 OP_EQUAL OP_IF\" when/if they \nneed to avoid malleability issues.\n\nI suspect most cases OP_IF would be used, you really want to accept any non-\nzero value. For example, the HTLC script I posted on the list about not long \nago (OP_IF operates on the result from OP_SIZE). Counter-examples would be BIP \n124, the examples in BIP 65 and BIP 112, but I note all of these could be just \nas easily done without the explicit boolean being fed to the OP_IF (you'd need \nan OP_DUP to keep the value, so it wouldn't reduce the byte-size).\n\nOf course, as long as we're talking about a softfork activating together with \nsegwit, and only having effect in segwit scripts... there's no reason we can't \nadd whatever opcodes we need so long as it gets done before 0.13.1. I suggest \nOP_CASTTOBOOL and OP_DUPASBOOL would be two good candidates if we make OP_IF \nstricter. There's also the possibility of adding an OP_RETAINIF which behaves \nas the current OP_IF, except not popping the conditional value off the stack. \nBut perhaps this is getting too complicated for testing in time for segwit...\n\nLuke"
            },
            {
                "author": "Johnson Lau",
                "date": "2016-08-17T10:15:48",
                "message_text_only": "> On August 17, 2016 at 12:40 AM Luke Dashjr <luke at dashjr.org> wrote:\n>\n>\n> On Wednesday, August 17, 2016 3:02:53 AM Johnson Lau via bitcoin-dev wrote:\n> > To completely replicate the original behaviour, one may use:\n> > \"DEPTH TOALTSTACK IFDUP DEPTH FROMALTSTACK NUMNOTEQUAL IF 2DROP {if script}\n> > ELSE DROP {else script} ENDIF\"\n>\n> This is much uglier than expected. IMO if that's the best workaround for the\n> current behaviour, people should just use \"OP_1 OP_EQUAL OP_IF\" when/if they\n> need to avoid malleability issues.\n\nIt is ugly only if you want to faithfully replicate the behaviour. I'd argue that in no real use case you need to do this. For example, \"OP_SIZE OP_IF\" could just become \"OP_SIZE OP_0NOTEQUAL OP_IF\", since OP_SIZE must return a valid MINIMALDATA number.\n\nAnd your workaround does not fix malleability, since any non-0x01 values are valid FALSE\n\nHowever, in some case, enforcing MINIMALIF does require 1 more witness byte: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-August/013036.html\n\nI think the best strategy is to make it a relay policy first, and decide whether we want a softfork later.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160817/c3a1cef3/attachment.html>"
            },
            {
                "author": "Sergio Demian Lerner",
                "date": "2016-08-18T00:11:16",
                "message_text_only": "I think that we're not attacking the real source of the problem: that the\nwitness data size is not signed. It may be the case that a new source of\nmalleability is detected in witness programs later, or related to new\nopcodes we'll soft-fork in the future.\n\nThe problem is real, as some systems (such as hardware wallets or other\nlow-memory IoT embedded systems) may have hard limits in the size of the\nwitness program they can accept. So we need a solution for all current and\nfuture segwit extension problems.\n\nWe could soft-fork to add an opcode OP_PROGSIZE using segwit script\nversioning that pushes in the stack the size of the segwit program being\nevaluated, and then the script can take any action it wishes based on that.\n\nExample:\n<0x50> OP_PROGSIZE OP_GREATERTHAN OP_VERIFY ..... OP_CHECKSIG\n\nThen an attacker cannot create a clone of the transaction having a witness\nECDSA signature longer than 0x50 bytes. (many details omitted in this\nexample)\n\n\n\nOn Wed, Aug 17, 2016 at 7:15 AM, Johnson Lau via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> > On August 17, 2016 at 12:40 AM Luke Dashjr <luke at dashjr.org> wrote:\n> >\n> >\n> > On Wednesday, August 17, 2016 3:02:53 AM Johnson Lau via bitcoin-dev\n> wrote:\n> > > To completely replicate the original behaviour, one may use:\n> > > \"DEPTH TOALTSTACK IFDUP DEPTH FROMALTSTACK NUMNOTEQUAL IF 2DROP {if\n> script}\n> > > ELSE DROP {else script} ENDIF\"\n> >\n> > This is much uglier than expected. IMO if that's the best workaround for\n> the\n> > current behaviour, people should just use \"OP_1 OP_EQUAL OP_IF\" when/if\n> they\n> > need to avoid malleability issues.\n>\n> It is ugly only if you want to faithfully replicate the behaviour. I'd\n> argue that in no real use case you need to do this. For example, \"OP_SIZE\n> OP_IF\" could just become \"OP_SIZE OP_0NOTEQUAL OP_IF\", since OP_SIZE must\n> return a valid MINIMALDATA number.\n>\n> And your workaround does not fix malleability, since any non-0x01 values\n> are valid FALSE\n>\n> However, in some case, enforcing MINIMALIF does require 1 more witness\n> byte: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-August/\n> 013036.html\n>\n> I think the best strategy is to make it a relay policy first, and decide\n> whether we want a softfork later.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160817/7e9c664e/attachment-0001.html>"
            },
            {
                "author": "Sergio Demian Lerner",
                "date": "2016-08-18T00:33:24",
                "message_text_only": "On Wed, Aug 17, 2016 at 9:19 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n\n> On Thu, Aug 18, 2016 at 12:11 AM, Sergio Demian Lerner via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > I think that we're not attacking the real source of the problem: that the\n> > witness data size is not signed.\n>\n> It's not possible to do that for the general case, since you may not\n> even know the witness size in advance (even for checksig's ECDSA, the\n> encoding is variable sized).\n>\n> That's why scripts can check a maximum witness size, and not necessarily\nan exact value.\n\n\nI think that is overly focusing on \"someone might change the feerate\",\n> yes that is an example of an undesirable witness tampering, but it's\n> not the only one.\n>\n> I don't think fees are the problem. There is another problem. Let me\nre-explain.\nIf I send a transaction to an IoT device (say to an OpenDime or to the old\nFirmcoin), and the OpenDime must verify that the transaction has been mined\n(SPV verification), then it may expect the witness program to be of certain\nmaximum size (an implementation-imposed  limit). If a Miner modifies the\nwitness size and makes it too large, then the device may not be able to\naccept the transaction and the bitcoins may be lost. Lost because the\nprivate key is in the device, and because the device cannot accept that\ncloned transaction, never ever.\n\nThe same is true (although less strict) for side-chains and drive-chains:\nthey may have certain restrictions on the size of transactions they accept\nto lock bitcoins.\n\nThat's why I'm proposing that a transaction becomes INVALID if the witness\nsize is higher than the expected size (by the sender).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160817/8a7bc92b/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2016-08-18T03:00:38",
                "message_text_only": "On Wed, Aug 17, 2016 at 09:33:24PM -0300, Sergio Demian Lerner via bitcoin-dev wrote:\n> If I send a transaction to an IoT device (say to an OpenDime or to the old\n> Firmcoin), and the OpenDime must verify that the transaction has been mined\n> (SPV verification), then it may expect the witness program to be of certain\n> maximum size (an implementation-imposed  limit). If a Miner modifies the\n> witness size and makes it too large, then the device may not be able to\n> accept the transaction and the bitcoins may be lost. Lost because the\n> private key is in the device, and because the device cannot accept that\n> cloned transaction, never ever.\n> \n> The same is true (although less strict) for side-chains and drive-chains:\n> they may have certain restrictions on the size of transactions they accept\n> to lock bitcoins.\n> \n> That's why I'm proposing that a transaction becomes INVALID if the witness\n> size is higher than the expected size (by the sender).\n\nAn important part of the design of segwit is that resource constained devices\ndoing lite-client verification don't need to get witness data at all to verify\nlite-client merkle-path proofs.\n\nRemember that lite-clients can't verify anything useful in witnesses anyway, so\nfor them to have witness data is useless (unless they're doing some kind of\nembedded consensus protocol with data published in witnesses, but few people\nhere care about that use-case).\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160817/77ec1d9f/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "New BIP: Dealing with OP_IF and OP_NOTIF malleability in P2WSH",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Peter Todd",
                "Johnson Lau",
                "Russell O'Connor",
                "Sergio Demian Lerner",
                "Luke Dashjr",
                "Gregory Maxwell",
                "Pieter Wuille",
                "Joseph Poon"
            ],
            "messages_count": 18,
            "total_messages_chars_count": 28199
        }
    },
    {
        "title": "[bitcoin-dev] Status updates for BIP 9, 68, 112, and 113",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2016-08-18T21:09:00",
                "message_text_only": "On Friday, July 15, 2016 4:46:57 PM Wladimir J. van der Laan wrote:\n> On Fri, Jul 15, 2016 at 03:52:37PM +0000, Luke Dashjr wrote:\n> > On Friday, July 15, 2016 3:46:28 PM Wladimir J. van der Laan wrote:\n> > > I'm not sure why it is labeled as only \"Informational\" in the first\n> > > place, as BIP9 is part of the consensus logic.\n> > \n> > Only by proxy/inclusion from another BIP, such as 68, 112, and 113. In\n> > other words, BIP 9 is informational in that it advises how other BIPs\n> > might deploy themselves.\n> \n> It's a bit of grey area, as indeed, only the BIPs that are actual softforks\n> are consensus changes - which employ this mechanism for deployment. But I\n> think such an important deployment mechanism, which is supposed to be used\n> by all softforks from now onwards, shouldn't just be an informational BIP.\n\nAs things stand right now, none of the Authors have commented on changing the \ntype. It has been a month, and I am prepared to change the status to Final or \nActive; but I am unclear if your comments were an objection to changing the \nstatus or not.\n\nLast call: Does anyone mind if I update BIP 9 to Final status?\n\nLuke"
            },
            {
                "author": "Btc Drak",
                "date": "2016-08-18T23:05:59",
                "message_text_only": "Fine by me to update BIP68 and BIP112 to Final status. The forks have\nactivated.\n\nOn Fri, Jul 15, 2016 at 4:30 PM, Luke Dashjr <luke at dashjr.org> wrote:\n\n> Daniel Cousens opened the issue a few weeks ago, that BIP 9 should\n> progress to\n> Accepted stage. However, as an informational BIP, it is not entirely clear\n> on\n> whether it falls in the Draft/Accepted/Final classification of proposals\n> requiring implementation, or the Draft/Active classification like process\n> BIPs. Background of this discussion is at:\n>     https://github.com/bitcoin/bips/pull/413\n> (Discussion on the GitHub BIPs repo is *NOT* recommended, hence bringing\n> this\n> topic to the mailing list)\n>\n> Reviewing the criteria for status changes, my opinion is that:\n> - BIPs 68, 112, 113, and 141 are themselves implementations of BIP 9\n> -- therefore, BIP 9 falls under the Draft/Accepted/Final class\n> - BIPs 68, 112, and 113 have been deployed to the network successfully\n> -- therefore, BIP 9 has satisfied the conditions of not only Accepted\n> status,\n>    but also Final status\n> -- therefore, BIPs 68, 112, and 113 also ought to be Final status\n>\n> If there are no objections, I plan to update the status to Final for BIPs\n> 9,\n> 68, 112, and 113 in one month. Since all four BIPs are currently Draft, I\n> also\n> need at least one author from each BIP to sign-off on promoting them to\n> (and\n> beyond) Accepted.\n>\n> BIP   9: Pieter Wuille <pieter.wuille at gmail.com>\n>          Peter Todd <pete at petertodd.org>\n>          Greg Maxwell <greg at xiph.org>\n>          Rusty Russell <rusty at rustcorp.com.au>\n>\n> BIP  68: Mark Friedenbach <mark at friedenbach.org>\n>          BtcDrak <btcdrak at gmail.com>\n>          Nicolas Dorier <nicolas.dorier at gmail.com>\n>          kinoshitajona <kinoshitajona at gmail.com>\n>\n> BIP 112: BtcDrak <btcdrak at gmail.com>\n>          Mark Friedenbach <mark at friedenbach.org>\n>          Eric Lombrozo <elombrozo at gmail.com>\n>\n> BIP 113: Thomas Kerin <me at thomaskerin.io>\n>          Mark Friedenbach <mark at friedenbach.org>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160819/70d02f16/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Status updates for BIP 9, 68, 112, and 113",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Luke Dashjr",
                "Btc Drak"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3379
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Core 0.13.0 released",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2016-08-23T15:23:38",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nBitcoin Core version 0.13.0 is now available from:\n\n  <https://bitcoin.org/bin/bitcoin-core-0.13.0/>\n\nOr through bittorrent:\n\n  magnet:?xt=urn:btih:35367ed2db6c41f7af9c1ed2dd54ae29d99bc632&dn=bitcoin-core-0.13.0&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.publicbt.com%3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.ccc.de%3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969&ws=https%3A%2F%2Fbitcoin.org%2Fbin%2F\n\nThis is a new major version release, including new features, various bugfixes\nand performance improvements, as well as updated translations.\n\nPlease report bugs using the issue tracker at github:\n\n  <https://github.com/bitcoin/bitcoin/issues>\n\nTo receive security and update notifications, please subscribe to:\n\n  <https://bitcoincore.org/en/list/announcements/join/>\n\nCompatibility\n==============\n\nMicrosoft ended support for Windows XP on [April 8th, 2014](https://www.microsoft.com/en-us/WindowsForBusiness/end-of-xp-support),\nan OS initially released in 2001. This means that not even critical security\nupdates will be released anymore. Without security updates, using a bitcoin\nwallet on a XP machine is irresponsible at least.\n\nIn addition to that, with 0.12.x there have been varied reports of Bitcoin Core\nrandomly crashing on Windows XP. It is [not clear](https://github.com/bitcoin/bitcoin/issues/7681#issuecomment-217439891)\nwhat the source of these crashes is, but it is likely that upstream\nlibraries such as Qt are no longer being tested on XP.\n\nWe do not have time nor resources to provide support for an OS that is\nend-of-life. From 0.13.0 on, Windows XP is no longer supported. Users are\nsuggested to upgrade to a newer verion of Windows, or install an alternative OS\nthat is supported.\n\nNo attempt is made to prevent installing or running the software on Windows XP,\nyou can still do so at your own risk, but do not expect it to work: do not\nreport issues about Windows XP to the issue tracker.\n\nNotable changes\n===============\n\nDatabase cache memory increased\n- --------------------------------\n\nAs a result of growth of the UTXO set, performance with the prior default\ndatabase cache of 100 MiB has suffered.\nFor this reason the default was changed to 300 MiB in this release.\n\nFor nodes on low-memory systems, the database cache can be changed back to\n100 MiB (or to another value) by either:\n\n- - Adding `dbcache=100` in bitcoin.conf\n- - Changing it in the GUI under `Options \u2192 Size of database cache`\n\nNote that the database cache setting has the most performance impact\nduring initial sync of a node, and when catching up after downtime.\n\n\nbitcoin-cli: arguments privacy\n- ------------------------------\n\nThe RPC command line client gained a new argument, `-stdin`\nto read extra arguments from standard input, one per line until EOF/Ctrl-D.\nFor example:\n\n    $ src/bitcoin-cli -stdin walletpassphrase\n    mysecretcode\n    120\n    ..... press Ctrl-D here to end input\n    $\n\nIt is recommended to use this for sensitive information such as wallet\npassphrases, as command-line arguments can usually be read from the process\ntable by any user on the system.\n\n\nC++11 and Python 3\n- ------------------\n\nVarious code modernizations have been done. The Bitcoin Core code base has\nstarted using C++11. This means that a C++11-capable compiler is now needed for\nbuilding. Effectively this means GCC 4.7 or higher, or Clang 3.3 or higher.\n\nWhen cross-compiling for a target that doesn't have C++11 libraries, configure with\n`./configure --enable-glibc-back-compat ... LDFLAGS=-static-libstdc++`.\n\nFor running the functional tests in `qa/rpc-tests`, Python3.4 or higher is now\nrequired.\n\n\nLinux ARM builds\n- ----------------\n\nDue to popular request, Linux ARM builds have been added to the uploaded\nexecutables.\n\nThe following extra files can be found in the download directory or torrent:\n\n- - `bitcoin-${VERSION}-arm-linux-gnueabihf.tar.gz`: Linux binaries for the most\n  common 32-bit ARM architecture.\n- - `bitcoin-${VERSION}-aarch64-linux-gnu.tar.gz`: Linux binaries for the most\n  common 64-bit ARM architecture.\n\nARM builds are still experimental. If you have problems on a certain device or\nLinux distribution combination please report them on the bug tracker, it may be\npossible to resolve them.\n\nNote that Android is not considered ARM Linux in this context. The executables\nare not expected to work out of the box on Android.\n\n\nCompact Block support (BIP 152)\n- -------------------------------\n\nSupport for block relay using the Compact Blocks protocol has been implemented\nin PR 8068.\n\nThe primary goal is reducing the bandwidth spikes at relay time, though in many\ncases it also reduces propagation delay. It is automatically enabled between\ncompatible peers.\n[BIP 152](https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki)\n\nAs a side-effect, ordinary non-mining nodes will download and upload blocks\nfaster if those blocks were produced by miners using similar transaction\nfiltering policies. This means that a miner who produces a block with many\ntransactions discouraged by your node will be relayed slower than one with\nonly transactions already in your memory pool. The overall effect of such\nrelay differences on the network may result in blocks which include widely-\ndiscouraged transactions losing a stale block race, and therefore miners may\nwish to configure their node to take common relay policies into consideration.\n\n\nHierarchical Deterministic Key Generation\n- -----------------------------------------\nNewly created wallets will use hierarchical deterministic key generation\naccording to BIP32 (keypath m/0'/0'/k').\nExisting wallets will still use traditional key generation.\n\nBackups of HD wallets, regardless of when they have been created, can\ntherefore be used to re-generate all possible private keys, even the\nones which haven't already been generated during the time of the backup.\n**Attention:** Encrypting the wallet will create a new seed which requires\na new backup!\n\nWallet dumps (created using the `dumpwallet` RPC) will contain the deterministic\nseed. This is expected to allow future versions to import the seed and all\nassociated funds, but this is not yet implemented.\n\nHD key generation for new wallets can be disabled by `-usehd=0`. Keep in\nmind that this flag only has affect on newly created wallets.\nYou can't disable HD key generation once you have created a HD wallet.\n\nThere is no distinction between internal (change) and external keys.\n\nHD wallets are incompatible with older versions of Bitcoin Core.\n\n[Pull request](https://github.com/bitcoin/bitcoin/pull/8035/files), [BIP 32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)\n\n\nSegregated Witness\n- ------------------\n\nThe code preparations for Segregated Witness (\"segwit\"), as described in [BIP\n141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki), [BIP\n143](https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki), [BIP\n144](https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki), and [BIP\n145](https://github.com/bitcoin/bips/blob/master/bip-0145.mediawiki) are\nfinished and included in this release.  However, BIP 141 does not yet specify\nactivation parameters on mainnet, and so this release does not support segwit\nuse on mainnet.  Testnet use is supported, and after BIP 141 is updated with\nproposed parameters, a future release of Bitcoin Core is expected that\nimplements those parameters for mainnet.\n\nFurthermore, because segwit activation is not yet specified for mainnet,\nversion 0.13.0 will behave similarly as other pre-segwit releases even after a\nfuture activation of BIP 141 on the network.  Upgrading from 0.13.0 will be\nrequired in order to utilize segwit-related features on mainnet (such as signal\nBIP 141 activation, mine segwit blocks, fully validate segwit blocks, relay\nsegwit blocks to other segwit nodes, and use segwit transactions in the\nwallet, etc).\n\n\nMining transaction selection (\"Child Pays For Parent\")\n- ------------------------------------------------------\n\nThe mining transaction selection algorithm has been replaced with an algorithm\nthat selects transactions based on their feerate inclusive of unconfirmed\nancestor transactions.  This means that a low-fee transaction can become more\nlikely to be selected if a high-fee transaction that spends its outputs is\nrelayed.\n\nWith this change, the `-blockminsize` command line option has been removed.\n\nThe command line option `-blockmaxsize` remains an option to specify the\nmaximum number of serialized bytes in a generated block.  In addition, the new\ncommand line option `-blockmaxweight` has been added, which specifies the\nmaximum \"block weight\" of a generated block, as defined by [BIP 141 (Segregated\nWitness)] (https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki).\n\nIn preparation for Segregated Witness, the mining algorithm has been modified\nto optimize transaction selection for a given block weight, rather than a given\nnumber of serialized bytes in a block.  In this release, transaction selection\nis unaffected by this distinction (as BIP 141 activation is not supported on\nmainnet in this release, see above), but in future releases and after BIP 141\nactivation, these calculations would be expected to differ.\n\nFor optimal runtime performance, miners using this release should specify\n`-blockmaxweight` on the command line, and not specify `-blockmaxsize`.\nAdditionally (or only) specifying `-blockmaxsize`, or relying on default\nsettings for both, may result in performance degradation, as the logic to\nsupport `-blockmaxsize` performs additional computation to ensure that\nconstraint is met.  (Note that for mainnet, in this release, the equivalent\nparameter for `-blockmaxweight` would be four times the desired\n`-blockmaxsize`.  See [BIP 141]\n(https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki) for additional\ndetails.)\n\nIn the future, the `-blockmaxsize` option may be removed, as block creation is\nno longer optimized for this metric.  Feedback is requested on whether to\ndeprecate or keep this command line option in future releases.\n\n\nReindexing changes\n- ------------------\n\nIn earlier versions, reindexing did validation while reading through the block\nfiles on disk. These two have now been split up, so that all blocks are known\nbefore validation starts. This was necessary to make certain optimizations that\nare available during normal synchronizations also available during reindexing.\n\nThe two phases are distinct in the Bitcoin-Qt GUI. During the first one,\n\"Reindexing blocks on disk\" is shown. During the second (slower) one,\n\"Processing blocks on disk\" is shown.\n\nIt is possible to only redo validation now, without rebuilding the block index,\nusing the command line option `-reindex-chainstate` (in addition to\n`-reindex` which does both). This new option is useful when the blocks on disk\nare assumed to be fine, but the chainstate is still corrupted. It is also\nuseful for benchmarks.\n\n\nRemoval of internal miner\n- --------------------------\n\nAs CPU mining has been useless for a long time, the internal miner has been\nremoved in this release, and replaced with a simpler implementation for the\ntest framework.\n\nThe overall result of this is that `setgenerate` RPC call has been removed, as\nwell as the `-gen` and `-genproclimit` command-line options.\n\nFor testing, the `generate` call can still be used to mine a block, and a new\nRPC call `generatetoaddress` has been added to mine to a specific address. This\nworks with wallet disabled.\n\n\nNew bytespersigop implementation\n- --------------------------------\n\nThe former implementation of the bytespersigop filter accidentally broke bare\nmultisig (which is meant to be controlled by the `permitbaremultisig` option),\nsince the consensus protocol always counts these older transaction forms as 20\nsigops for backwards compatibility. Simply fixing this bug by counting more\naccurately would have reintroduced a vulnerability. It has therefore been\nreplaced with a new implementation that rather than filter such transactions,\ninstead treats them (for fee purposes only) as if they were in fact the size\nof a transaction actually using all 20 sigops.\n\n\nLow-level P2P changes\n- ----------------------\n\n- - The optional new p2p message \"feefilter\" is implemented and the protocol\n  version is bumped to 70013. Upon receiving a feefilter message from a peer,\n  a node will not send invs for any transactions which do not meet the filter\n  feerate. [BIP 133](https://github.com/bitcoin/bips/blob/master/bip-0133.mediawiki)\n\n- - The P2P alert system has been removed in PR #7692 and the `alert` P2P message\n  is no longer supported.\n\n- - The transaction relay mechanism used to relay one quarter of all transactions\n  instantly, while queueing up the rest and sending them out in batch. As\n  this resulted in chains of dependent transactions being reordered, it\n  systematically hurt transaction relay. The relay code was redesigned in PRs\n  \\#7840 and #8082, and now always batches transactions announcements while also\n  sorting them according to dependency order. This significantly reduces orphan\n  transactions. To compensate for the removal of instant relay, the frequency of\n  batch sending was doubled for outgoing peers.\n\n- - Since PR #7840 the BIP35 `mempool` command is also subject to batch processing.\n  Also the `mempool` message is no longer handled for non-whitelisted peers when\n  `NODE_BLOOM` is disabled through `-peerbloomfilters=0`.\n\n- - The maximum size of orphan transactions that are kept in memory until their\n  ancestors arrive has been raised in PR #8179 from 5000 to 99999 bytes. They\n  are now also removed from memory when they are included in a block, conflict\n  with a block, and time out after 20 minutes.\n\n- - We respond at most once to a getaddr request during the lifetime of a\n  connection since PR #7856.\n\n- - Connections to peers who have recently been the first one to give us a valid\n  new block or transaction are protected from disconnections since PR #8084.\n\n\nLow-level RPC changes\n- ----------------------\n\n- - RPC calls have been added to output detailed statistics for individual mempool\n  entries, as well as to calculate the in-mempool ancestors or descendants of a\n  transaction: see `getmempoolentry`, `getmempoolancestors`, `getmempooldescendants`.\n\n- - `gettxoutsetinfo` UTXO hash (`hash_serialized`) has changed. There was a divergence between\n  32-bit and 64-bit platforms, and the txids were missing in the hashed data. This has been\n  fixed, but this means that the output will be different than from previous versions.\n\n- - Full UTF-8 support in the RPC API. Non-ASCII characters in, for example,\n  wallet labels have always been malformed because they weren't taken into account\n  properly in JSON RPC processing. This is no longer the case. This also affects\n  the GUI debug console.\n\n- - Asm script outputs replacements for OP_NOP2 and OP_NOP3\n\n  - OP_NOP2 has been renamed to OP_CHECKLOCKTIMEVERIFY by [BIP \n65](https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki)\n\n  - OP_NOP3 has been renamed to OP_CHECKSEQUENCEVERIFY by [BIP \n112](https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki)\n\n  - The following outputs are affected by this change:\n\n    - RPC `getrawtransaction` (in verbose mode)\n    - RPC `decoderawtransaction`\n    - RPC `decodescript`\n    - REST `/rest/tx/` (JSON format)\n    - REST `/rest/block/` (JSON format when including extended tx details)\n    - `bitcoin-tx -json`\n\n- - The sorting of the output of the `getrawmempool` output has changed.\n\n- - New RPC commands: `generatetoaddress`, `importprunedfunds`, `removeprunedfunds`, `signmessagewithprivkey`,\n  `getmempoolancestors`, `getmempooldescendants`, `getmempoolentry`,\n  `createwitnessaddress`, `addwitnessaddress`.\n\n- - Removed RPC commands: `setgenerate`, `getgenerate`.\n\n- - New options were added to `fundrawtransaction`: `includeWatching`, `changeAddress`, `changePosition` and `feeRate`.\n\n\nLow-level ZMQ changes\n- ----------------------\n\n- - Each ZMQ notification now contains an up-counting sequence number that allows\n  listeners to detect lost notifications.\n  The sequence number is always the last element in a multi-part ZMQ notification and\n  therefore backward compatible. Each message type has its own counter.\n  PR [#7762](https://github.com/bitcoin/bitcoin/pull/7762).\n\n\n0.13.0 Change log\n=================\n\nDetailed release notes follow. This overview includes changes that affect\nbehavior, not code moves, refactors and string updates. For convenience in locating\nthe code changes and accompanying discussion, both the pull request and\ngit merge commit are mentioned.\n\n### RPC and other APIs\n\n- - #7156 `9ee02cf` Remove cs_main lock from `createrawtransaction` (laanwj)\n- - #7326 `2cd004b` Fix typo, wrong information in gettxout help text (paveljanik)\n- - #7222 `82429d0` Indicate which transactions are signaling opt-in RBF (sdaftuar)\n- - #7480 `b49a623` Changed getnetworkhps value to double to avoid overflow (instagibbs)\n- - #7550 `8b958ab` Input-from-stdin mode for bitcoin-cli (laanwj)\n- - #7670 `c9a1265` Use cached block hash in blockToJSON() (rat4)\n- - #7726 `9af69fa` Correct importaddress help reference to importpubkey (CypherGrue)\n- - #7766 `16555b6` Register calls where they are defined (laanwj)\n- - #7797 `e662a76` Fix generatetoaddress failing to parse address (mruddy)\n- - #7774 `916b15a` Add versionHex in getblock and getblockheader JSON results (mruddy)\n- - #7863 `72c54e3` Getblockchaininfo: make bip9_softforks an object, not an array (rustyrussell)\n- - #7842 `d97101e` Do not print minping time in getpeerinfo when no ping received yet (paveljanik)\n- - #7518 `be14ca5` Add multiple options to fundrawtransaction (promag)\n- - #7756 `9e47fce` Add cursor to iterate over utxo set, use this in `gettxoutsetinfo` (laanwj)\n- - #7848 `88616d2` Divergence between 32- and 64-bit when hashing >4GB affects `gettxoutsetinfo` (laanwj)\n- - #7827 `4205ad7` Speed up `getchaintips` (mrbandrews)\n- - #7762 `a1eb344` Append a message sequence number to every ZMQ notification (jonasschnelli)\n- - #7688 `46880ed` List solvability in listunspent output and improve help (sipa)\n- - #7926 `5725807` Push back `getaddednodeinfo` dead value (instagibbs)\n- - #7953 `0630353` Create `signmessagewithprivkey` rpc (achow101)\n- - #8049 `c028c7b` Expose information on whether transaction relay is enabled in `getnetworkinfo` (laanwj)\n- - #7967 `8c1e49b` Add feerate option to `fundrawtransaction` (jonasschnelli)\n- - #8118 `9b6a48c` Reduce unnecessary hashing in `signrawtransaction` (jonasnick)\n- - #7957 `79004d4` Add support for transaction sequence number (jonasschnelli)\n- - #8153 `75ec320` `fundrawtransaction` feeRate: Use BTC/kB (MarcoFalke)\n- - #7292 `7ce9ac5` Expose ancestor/descendant information over RPC (sdaftuar)\n- - #8171 `62fcf27` Fix createrawtx sequence number unsigned int parsing (jonasschnelli)\n- - #7892 `9c3d0fa` Add full UTF-8 support to RPC (laanwj)\n- - #8317 `304eff3` Don't use floating point in rpcwallet (MarcoFalke)\n- - #8258 `5a06ebb` Hide softfork in `getblockchaininfo` if timeout is 0 (jl2012)\n- - #8244 `1922e5a` Remove unnecessary LOCK(cs_main) in getrawmempool (dcousens)\n\n### Block and transaction handling\n\n- - #7056 `6a07208` Save last db read (morcos)\n- - #6842 `0192806` Limitfreerelay edge case bugfix (ptschip)\n- - #7084 `11d74f6` Replace maxFeeRate of 10000*minRelayTxFee with maxTxFee in mempool (MarcoFalke)\n- - #7539 `9f33dba` Add tags to mempool's mapTx indices (sdaftuar)\n- - #7592 `26a2a72` Re-remove ERROR logging for mempool rejects (laanwj)\n- - #7187 `14d6324` Keep reorgs fast for SequenceLocks checks (morcos)\n- - #7594 `01f4267` Mempool: Add tracking of ancestor packages (sdaftuar)\n- - #7904 `fc9e334` Txdb: Fix assert crash in new UTXO set cursor (laanwj)\n- - #7927 `f9c2ac7` Minor changes to dbwrapper to simplify support for other databases (laanwj)\n- - #7933 `e26b620` Fix OOM when deserializing UTXO entries with invalid length (sipa)\n- - #8020 `5e374f7` Use SipHash-2-4 for various non-cryptographic hashes (sipa)\n- - #8076 `d720980` VerifyDB: don't check blocks that have been pruned (sdaftuar)\n- - #8080 `862fd24` Do not use mempool for GETDATA for tx accepted after the last mempool req (gmaxwell)\n- - #7997 `a82f033` Replace mapNextTx with slimmer setSpends (kazcw)\n- - #8220 `1f86d64` Stop trimming when mapTx is empty (sipa)\n- - #8273 `396f9d6` Bump `-dbcache` default to 300MiB (laanwj)\n- - #7225 `eb33179` Eliminate unnecessary call to CheckBlock (sdaftuar)\n- - #7907 `006cdf6` Optimize and Cleanup CScript::FindAndDelete (pstratem)\n- - #7917 `239d419` Optimize reindex (sipa)\n- - #7763 `3081fb9` Put hex-encoded version in UpdateTip (sipa)\n- - #8149 `d612837` Testnet-only segregated witness (sipa)\n- - #8305 `3730393` Improve handling of unconnecting headers (sdaftuar)\n- - #8363 `fca1a41` Rename \"block cost\" to \"block weight\" (sdaftuar)\n- - #8381 `f84ee3d` Make witness v0 outputs non-standard (jl2012)\n- - #8364 `3f65ba2` Treat high-sigop transactions as larger rather than rejecting them (sipa)\n\n### P2P protocol and network code\n\n- - #6589 `dc0305d` Log bytes recv/sent per command (jonasschnelli)\n- - #7164 `3b43cad` Do not download transactions during initial blockchain sync (ptschip)\n- - #7458 `898fedf` peers.dat, banlist.dat recreated when missing (kirkalx)\n- - #7637 `3da5d1b` Fix memleak in TorController (laanwj, jonasschnelli)\n- - #7553 `9f14e5a` Remove vfReachable and modify IsReachable to only use vfLimited (pstratem)\n- - #7708 `9426632` De-neuter NODE_BLOOM (pstratem)\n- - #7692 `29b2be6` Remove P2P alert system (btcdrak)\n- - #7542 `c946a15` Implement \"feefilter\" P2P message (morcos)\n- - #7573 `352fd57` Add `-maxtimeadjustment` command line option (mruddy)\n- - #7570 `232592a` Add IPv6 Link-Local Address Support (mruddy)\n- - #7874 `e6a4d48` Improve AlreadyHave (morcos)\n- - #7856 `64e71b3` Only send one GetAddr response per connection (gmaxwell)\n- - #7868 `7daa3ad` Split DNS resolving functionality out of net structures (theuni)\n- - #7919 `7617682` Fix headers announcements edge case (sdaftuar)\n- - #7514 `d9594bf` Fix IsInitialBlockDownload for testnet (jmacwhyte)\n- - #7959 `03cf6e8` fix race that could fail to persist a ban (kazcw)\n- - #7840 `3b9a0bf` Several performance and privacy improvements to inv/mempool handling (sipa)\n- - #8011 `65aecda` Don't run ThreadMessageHandler at lowered priority (kazcw)\n- - #7696 `5c3f8dd` Fix de-serialization bug where AddrMan is left corrupted (EthanHeilman)\n- - #7932 `ed749bd` CAddrMan::Deserialize handle corrupt serializations better (pstratem)\n- - #7906 `83121cc` Prerequisites for p2p encapsulation changes (theuni)\n- - #8033 `18436d8` Fix Socks5() connect failures to be less noisy and less unnecessarily scary (wtogami)\n- - #8082 `01d8359` Defer inserting into maprelay until just before relaying (gmaxwell)\n- - #7960 `6a22373` Only use AddInventoryKnown for transactions (sdaftuar)\n- - #8078 `2156fa2` Disable the mempool P2P command when bloom filters disabled (petertodd)\n- - #8065 `67c91f8` Addrman offline attempts (gmaxwell)\n- - #7703 `761cddb` Tor: Change auth order to only use password auth if -torpassword (laanwj)\n- - #8083 `cd0c513` Add support for dnsseeds with option to filter by servicebits (jonasschnelli)\n- - #8173 `4286f43` Use SipHash for node eviction (sipa)\n- - #8154 `1445835` Drop vAddrToSend after sending big addr message (kazcw)\n- - #7749 `be9711e` Enforce expected outbound services (sipa)\n- - #8208 `0a64777` Do not set extra flags for unfiltered DNS seed results (sipa)\n- - #8084 `e4bb4a8` Add recently accepted blocks and txn to AttemptToEvictConnection (gmaxwell)\n- - #8113 `3f89a53` Rework addnode behaviour (sipa)\n- - #8179 `94ab58b` Evict orphans which are included or precluded by accepted blocks (gmaxwell)\n- - #8068 `e9d76a1` Compact Blocks (TheBlueMatt)\n- - #8204 `0833894` Update petertodd's testnet seed (petertodd)\n- - #8247 `5cd35d3` Mark my dnsseed as supporting filtering (sipa)\n- - #8275 `042c323` Remove bad chain alert partition check (btcdrak)\n- - #8271 `1bc9c80` Do not send witnesses in cmpctblock (sipa)\n- - #8312 `ca40ef6` Fix mempool DoS vulnerability from malleated transactions (sdaftuar)\n- - #7180 `16ccb74` Account for `sendheaders` `verack` messages (laanwj)\n- - #8102 `425278d` Bugfix: use global ::fRelayTxes instead of CNode in version send (sipa)\n- - #8408 `b7e2011` Prevent fingerprinting, disk-DoS with compact blocks (sdaftuar)\n\n### Build system\n\n- - #7302 `41f1a3e` C++11 build/runtime fixes (theuni)\n- - #7322 `fd9356b` c++11: add scoped enum fallbacks to CPPFLAGS rather than defining them locally (theuni)\n- - #7441 `a6771fc` Use Debian 8.3 in gitian build guide (fanquake)\n- - #7349 `152a821` Build against system UniValue when available (luke-jr)\n- - #7520 `621940e` LibreSSL doesn't define OPENSSL_VERSION, use LIBRESSL_VERSION_TEXT instead (paveljanik)\n- - #7528 `9b9bfce` autogen.sh: warn about needing autoconf if autoreconf is not found (knocte)\n- - #7504 `19324cf` Crystal clean make clean (paveljanik)\n- - #7619 `18b3f1b` Add missing sudo entry in gitian VM setup (btcdrak)\n- - #7616 `639ec58`  [depends] Delete unused patches  (MarcoFalke)\n- - #7658 `c15eb28` Add curl to Gitian setup instructions (btcdrak)\n- - #7710 `909b72b` [Depends] Bump miniupnpc and config.guess+sub (fanquake)\n- - #7723 `5131005` build: python 3 compatibility (laanwj)\n- - #7477 `28ad4d9` Fix quoting of copyright holders in configure.ac (domob1812)\n- - #7711 `a67bc5e` [build-aux] Update Boost & check macros to latest serials (fanquake)\n- - #7788 `4dc1b3a` Use relative paths instead of absolute paths in protoc calls (paveljanik)\n- - #7809 `bbd210d` depends: some base fixes/changes (theuni)\n- - #7603 `73fc922` Build System: Use PACKAGE_TARNAME in NSIS script (JeremyRand)\n- - #7905 `187186b` test: move accounting_tests and rpc_wallet_tests to wallet/test (laanwj)\n- - #7911 `351abf9` leveldb: integrate leveldb into our buildsystem (theuni)\n- - #7944 `a407807` Re-instate TARGET_OS=linux in configure.ac. Removed by 351abf9e035 (randy-waterhouse)\n- - #7920 `c3e3cfb` Switch Travis to Trusty (theuni)\n- - #7954 `08b37c5` build: quiet annoying warnings without adding new ones (theuni)\n- - #7165 `06162f1` build: Enable C++11 in build, require C++11 compiler (laanwj)\n- - #7982 `559fbae` build: No need to check for leveldb atomics (theuni)\n- - #8002 `f9b4582` [depends] Add -stdlib=libc++ to darwin CXX flags (fanquake)\n- - #7993 `6a034ed` [depends] Bump Freetype, ccache, ZeroMQ, miniupnpc, expat (fanquake)\n- - #8167 `19ea173` Ship debug tarballs/zips with debug symbols (theuni)\n- - #8175 `f0299d8` Add --disable-bench to config flags for windows (laanwj)\n- - #7283 `fd9881a` [gitian] Default reference_datetime to commit author date (MarcoFalke)\n- - #8181 `9201ce8` Get rid of `CLIENT_DATE` (laanwj)\n- - #8133 `fde0ac4` Finish up out-of-tree changes (theuni)\n- - #8188 `65a9d7d` Add armhf/aarch64 gitian builds (theuni)\n- - #8194 `cca1c8c` [gitian] set correct PATH for wrappers (MarcoFalke)\n- - #8198 `5201614` Sync ax_pthread with upstream draft4 (fanquake)\n- - #8210 `12a541e` [Qt] Bump to Qt5.6.1 (jonasschnelli)\n- - #8285 `da50997` windows: Add testnet link to installer (laanwj)\n- - #8304 `0cca2fe` [travis] Update SDK_URL (MarcoFalke)\n- - #8310 `6ae20df` Require boost for bench (theuni)\n- - #8315 `2e51590` Don't require sudo for Linux (theuni)\n- - #8314 `67caef6` Fix pkg-config issues for 0.13 (theuni)\n- - #8373 `1fe7f40` Fix OSX non-deterministic dmg (theuni)\n- - #8358 `cfd1280` Gbuild: Set memory explicitly (default is too low) (MarcoFalke)\n\n### GUI\n\n- - #7154 `00b4b8d` Add InMempool() info to transaction details (jonasschnelli)\n- - #7068 `5f3c670` [RPC-Tests] add simple way to run rpc test over QT clients (jonasschnelli)\n- - #7218 `a1c185b` Fix misleading translation (MarcoFalke)\n- - #7214 `be9a9a3` qt5: Use the fixed font the system recommends (MarcoFalke)\n- - #7256 `08ab906` Add note to coin control dialog QT5 workaround (fanquake)\n- - #7255 `e289807` Replace some instances of formatWithUnit with formatHtmlWithUnit (fanquake)\n- - #7317 `3b57e9c` Fix RPCTimerInterface ordering issue (jonasschnelli)\n- - #7327 `c079d79` Transaction View: LastMonth calculation fixed (crowning-)\n- - #7334 `e1060c5` coincontrol workaround is still needed in qt5.4 (fixed in qt5.5) (MarcoFalke)\n- - #7383 `ae2db67` Rename \"amount\" to \"requested amount\" in receive coins table (jonasschnelli)\n- - #7396 `cdcbc59` Add option to increase/decrease font size in the console window (jonasschnelli)\n- - #7437 `9645218` Disable tab navigation for peers tables (Kefkius)\n- - #7604 `354b03d` build: Remove spurious dollar sign. Fixes #7189 (dooglus)\n- - #7605 `7f001bd` Remove openssl info from init/log and from Qt debug window (jonasschnelli)\n- - #7628 `87d6562` Add 'copy full transaction details' option (ericshawlinux)\n- - #7613 `3798e5d` Add autocomplete to bitcoin-qt's console window (GamerSg)\n- - #7668 `b24266c` Fix history deletion bug after font size change (achow101)\n- - #7680 `41d2dfa` Remove reflection from `about` icon (laanwj)\n- - #7686 `f034bce` Remove 0-fee from send dialog (MarcoFalke)\n- - #7506 `b88e0b0` Use CCoinControl selection in CWallet::FundTransaction (promag)\n- - #7732 `0b98dd7` Debug window: replace \"Build date\" with \"Datadir\" (jonasschnelli)\n- - #7761 `60db51d` remove trailing output-index from transaction-id (jonasschnelli)\n- - #7772 `6383268` Clear the input line after activating autocomplete (paveljanik)\n- - #7925 `f604bf6` Fix out-of-tree GUI builds (laanwj)\n- - #7939 `574ddc6` Make it possible to show details for multiple transactions (laanwj)\n- - #8012 `b33824b` Delay user confirmation of send (Tyler-Hardin)\n- - #8006 `7c8558d` Add option to disable the system tray icon (Tyler-Hardin)\n- - #8046 `169d379` Fix Cmd-Q / Menu Quit shutdown on OSX (jonasschnelli)\n- - #8042 `6929711` Don't allow to open the debug window during splashscreen & verification state (jonasschnelli)\n- - #8014 `77b49ac` Sort transactions by date (Tyler-Hardin)\n- - #8073 `eb2f6f7` askpassphrasedialog: Clear pass fields on accept (rat4)\n- - #8129 `ee1533e` Fix RPC console auto completer (UdjinM6)\n- - #7636 `fb0ac48` Add bitcoin address label to request payment QR code (makevoid)\n- - #8231 `760a6c7` Fix a bug where the SplashScreen will not be hidden during startup (jonasschnelli)\n- - #8256 `af2421c` BUG: bitcoin-qt crash (fsb4000)\n- - #8257 `ff03c50` Do not ask a UI question from bitcoind (sipa)\n- - #8288 `91abb77` Network-specific example address (laanwj)\n- - #7707 `a914968` UI support for abandoned transactions (jonasschnelli)\n- - #8207 `f7a403b` Add a link to the Bitcoin-Core repository and website to the About Dialog (MarcoFalke)\n- - #8281 `6a87eb0` Remove client name from debug window (laanwj)\n- - #8407 `45eba4b` Add dbcache migration path (jonasschnelli)\n\n### Wallet\n\n- - #7262 `fc08994` Reduce inefficiency of GetAccountAddress() (dooglus)\n- - #7537 `78e81b0` Warn on unexpected EOF while salvaging wallet (laanwj)\n- - #7521 `3368895` Don't resend wallet txs that aren't in our own mempool (morcos)\n- - #7576 `86a1ec5` Move wallet help string creation to CWallet (jonasschnelli)\n- - #7577 `5b3b5a7` Move \"load wallet phase\" to CWallet (jonasschnelli)\n- - #7608 `0735c0c` Move hardcoded file name out of log messages (MarcoFalke)\n- - #7649 `4900641` Prevent multiple calls to CWallet::AvailableCoins (promag)\n- - #7646 `e5c3511` Fix lockunspent help message (promag)\n- - #7558 `b35a591` Add import/removeprunedfunds rpc call (instagibbs)\n- - #6215 `48c5adf` add bip32 pub key serialization (jonasschnelli)\n- - #7913 `bafd075` Fix for incorrect locking in GetPubKey() (keystore.cpp) (yurizhykin)\n- - #8036 `41138f9` init: Move berkeleydb version reporting to wallet (laanwj)\n- - #8028 `373b50d` Fix insanity of CWalletDB::WriteTx and CWalletTx::WriteToDisk (pstratem)\n- - #8061 `f6b7df3` Improve Wallet encapsulation (pstratem)\n- - #7891 `950be19` Always require OS randomness when generating secret keys (sipa)\n- - #7689 `b89ef13` Replace OpenSSL AES with ctaes-based version (sipa)\n- - #7825 `f972b04` Prevent multiple calls to ExtractDestination (pedrobranco)\n- - #8137 `243ac0c` Improve CWallet API with new AccountMove function (pstratem)\n- - #8142 `52c3f34` Improve CWallet API  with new GetAccountPubkey function (pstratem)\n- - #8035 `b67a472` Add simplest BIP32/deterministic key generation implementation (jonasschnelli)\n- - #7687 `a6ddb19` Stop treating importaddress'ed scripts as change (sipa)\n- - #8298 `aef3811` wallet: Revert input selection post-pruning (laanwj)\n- - #8324 `bc94b87` Keep HD seed during salvagewallet (jonasschnelli)\n- - #8323 `238300b` Add HD keypath to CKeyMetadata, report metadata in validateaddress (jonasschnelli)\n- - #8367 `3b38a6a` Ensure <0.13 clients can't open HD wallets (jonasschnelli)\n- - #8378 `ebea651` Move SetMinVersion for FEATURE_HD to SetHDMasterKey (pstratem)\n- - #8390 `73adfe3` Correct hdmasterkeyid/masterkeyid name confusion (jonasschnelli)\n- - #8206 `18b8ee1` Add HD xpriv to dumpwallet (jonasschnelli)\n- - #8389 `c3c82c4` Create a new HD seed after encrypting the wallet (jonasschnelli)\n\n### Tests and QA\n\n- - #7320 `d3dfc6d` Test walletpassphrase timeout (MarcoFalke)\n- - #7208 `47c5ed1` Make max tip age an option instead of chainparam (laanwj)\n- - #7372 `21376af` Trivial: [qa] wallet: Print maintenance (MarcoFalke)\n- - #7280 `668906f` [travis] Fail when documentation is outdated (MarcoFalke)\n- - #7177 `93b0576` [qa] Change default block priority size to 0 (MarcoFalke)\n- - #7236 `02676c5` Use createrawtx locktime parm in txn_clone (dgenr8)\n- - #7212 `326ffed` Adds unittests for CAddrMan and CAddrinfo, removes source of non-determinism (EthanHeilman)\n- - #7490 `d007511` tests: Remove May15 test (laanwj)\n- - #7531 `18cb2d5` Add bip68-sequence.py to extended rpc tests (btcdrak)\n- - #7536 `ce5fc02` test: test leading spaces for ParseHex (laanwj)\n- - #7620 `1b68de3` [travis] Only run check-doc.py once (MarcoFalke)\n- - #7455 `7f96671` [travis] Exit early when check-doc.py fails (MarcoFalke)\n- - #7667 `56d2c4e` Move GetTempPath() to testutil (musalbas)\n- - #7517 `f1ca891` test: script_error checking in script_invalid tests (laanwj)\n- - #7684 `3d0dfdb` Extend tests (MarcoFalke)\n- - #7697 `622fe6c` Tests: make prioritise_transaction.py more robust (sdaftuar)\n- - #7709 `efde86b` Tests: fix missing import in mempool_packages (sdaftuar)\n- - #7702 `29e1131` Add tests verifychain, lockunspent, getbalance, listsinceblock (MarcoFalke)\n- - #7720 `3b4324b` rpc-test: Normalize assert() (MarcoFalke)\n- - #7757 `26794d4` wallet: Wait for reindex to catch up (MarcoFalke)\n- - #7764 `a65b36c` Don't run pruning.py twice (MarcoFalke)\n- - #7773 `7c80e72` Fix comments in tests (btcdrak)\n- - #7489 `e9723cb` tests: Make proxy_test work on travis servers without IPv6 (laanwj)\n- - #7801 `70ac71b` Remove misleading \"errorString syntax\" (MarcoFalke)\n- - #7803 `401c65c` maxblocksinflight: Actually enable test (MarcoFalke)\n- - #7802 `3bc71e1` httpbasics: Actually test second connection (MarcoFalke)\n- - #7849 `ab8586e` tests: add varints_bitpatterns test (laanwj)\n- - #7846 `491171f` Clean up lockorder data of destroyed mutexes (sipa)\n- - #7853 `6ef5e00` py2: Unfiddle strings into bytes explicitly (MarcoFalke)\n- - #7878 `53adc83` [test] bctest.py: Revert faa41ee (MarcoFalke)\n- - #7798 `cabba24` [travis] Print the commit which was evaluated (MarcoFalke)\n- - #7833 `b1bf511` tests: Check Content-Type header returned from RPC server (laanwj)\n- - #7851 `fa9d86f` pull-tester: Don't mute zmq ImportError (MarcoFalke)\n- - #7822 `0e6fd5e` Add listunspent() test for spendable/unspendable UTXO (jpdffonseca)\n- - #7912 `59ad568` Tests: Fix deserialization of reject messages (sdaftuar)\n- - #7941 `0ea3941` Fixing comment in script_test.json test case (Christewart)\n- - #7807 `0ad1041` Fixed miner test values, gave constants for less error-prone values (instagibbs)\n- - #7980 `88b77c7` Smartfees: Properly use ordered dict (MarcoFalke)\n- - #7814 `77b637f` Switch to py3 (MarcoFalke)\n- - #8030 `409a8a1` Revert fatal-ness of missing python-zmq (laanwj)\n- - #8018 `3e90fe6` Autofind rpc tests --srcdir (jonasschnelli)\n- - #8016 `5767e80` Fix multithread CScheduler and reenable test (paveljanik)\n- - #7972 `423ca30` pull-tester: Run rpc test in parallel  (MarcoFalke)\n- - #8039 `69b3a6d` Bench: Add crypto hash benchmarks (laanwj)\n- - #8041 `5b736dd` Fix bip9-softforks blockstore issue (MarcoFalke)\n- - #7994 `1f01443` Add op csv tests to script_tests.json (Christewart)\n- - #8038 `e2bf830` Various minor fixes (MarcoFalke)\n- - #8072 `1b87e5b` Travis: 'make check' in parallel and verbose (MarcoFalke)\n- - #8056 `8844ef1` Remove hardcoded \"4 nodes\" from test_framework (MarcoFalke)\n- - #8047 `37f9a1f` Test_framework: Set wait-timeout for bitcoind procs (MarcoFalke)\n- - #8095 `6700cc9` Test framework: only cleanup on successful test runs (sdaftuar)\n- - #8098 `06bd4f6` Test_framework: Append portseed to tmpdir (MarcoFalke)\n- - #8104 `6ff2c8d` Add timeout to sync_blocks() and sync_mempools() (sdaftuar)\n- - #8111 `61b8684` Benchmark SipHash (sipa)\n- - #8107 `52b803e` Bench: Added base58 encoding/decoding benchmarks (yurizhykin)\n- - #8115 `0026e0e` Avoid integer division in the benchmark inner-most loop (gmaxwell)\n- - #8090 `a2df115` Adding P2SH(p2pkh) script test case (Christewart)\n- - #7992 `ec45cc5` Extend #7956 with one more test (TheBlueMatt)\n- - #8139 `ae5575b` Fix interrupted HTTP RPC connection workaround for Python 3.5+ (sipa)\n- - #8164 `0f24eaf` [Bitcoin-Tx] fix missing test fixtures, fix 32bit atoi issue (jonasschnelli)\n- - #8166 `0b5279f` Src/test: Do not shadow local variables (paveljanik)\n- - #8141 `44c1b1c` Continuing port of java comparison tool (mrbandrews)\n- - #8201 `36b7400` fundrawtransaction: Fix race, assert amounts (MarcoFalke)\n- - #8214 `ed2cd59` Mininode: fail on send_message instead of silent return (MarcoFalke)\n- - #8215 `a072d1a` Don't use floating point in wallet tests (MarcoFalke)\n- - #8066 `65c2058` Test_framework: Use different rpc_auth_pair for each node (MarcoFalke)\n- - #8216 `0d41d70` Assert 'changePosition out of bounds'  (MarcoFalke)\n- - #8222 `961893f` Enable mempool consistency checks in unit tests (sipa)\n- - #7751 `84370d5` test_framework: python3.4 authproxy compat (laanwj)\n- - #7744 `d8e862a` test_framework: detect failure of bitcoind startup (laanwj)\n- - #8280 `115735d` Increase sync_blocks() timeouts in pruning.py (MarcoFalke)\n- - #8340 `af9b7a9` Solve trivial merge conflict in p2p-segwit.py (MarcoFalke)\n- - #8067 `3e4cf8f` Travis: use slim generic image, and some fixups (theuni)\n- - #7951 `5c7df70` Test_framework: Properly print exception (MarcoFalke)\n- - #8070 `7771aa5` Remove non-determinism which is breaking net_tests #8069 (EthanHeilman)\n- - #8309 `bb2646a` Add wallet-hd test (MarcoFalke)\n- - #8444 `cd0910b` Fix p2p-feefilter.py for changed tx relay behavior (sdaftuar)\n\n### Mining\n\n- - #7507 `11c7699` Remove internal miner (Leviathn)\n- - #7663 `c87f51e` Make the generate RPC call function for non-regtest (sipa)\n- - #7671 `e2ebd25` Add generatetoaddress RPC to mine to an address (achow101)\n- - #7935 `66ed450` Versionbits: GBT support (luke-jr)\n- - #7600 `66db2d6` Select transactions using feerate-with-ancestors (sdaftuar)\n- - #8295 `f5660d3` Mining-related fixups for 0.13.0 (sdaftuar)\n- - #7796 `536b75e` Add support for negative fee rates, fixes `prioritizetransaction` (MarcoFalke)\n- - #8362 `86edc20` Scale legacy sigop count in CreateNewBlock (sdaftuar)\n- - #8489 `8b0eee6` Bugfix: Use pre-BIP141 sigops until segwit activates (GBT) (luke-jr)\n\n### Documentation and miscellaneous\n\n- - #7423 `69e2a40` Add example for building with constrained resources (jarret)\n- - #8254 `c2c69ed` Add OSX ZMQ requirement to QA readme (fanquake)\n- - #8203 `377d131` Clarify documentation for running a tor node (nathaniel-mahieu)\n- - #7428 `4b12266` Add example for listing ./configure flags (nathaniel-mahieu)\n- - #7847 `3eae681` Add arch linux build example (mruddy)\n- - #7968 `ff69aaf` Fedora build requirements (wtogami)\n- - #8013 `fbedc09` Fedora build requirements, add gcc-c++ and fix typo (wtogami)\n- - #8009 `fbd8478` Fixed invalid example paths in gitian-building.md (JeremyRand)\n- - #8240 `63fbdbc` Mention Windows XP end of support in release notes (laanwj)\n- - #8303 `5077d2c` Update bips.md for CSV softfork (fanquake)\n- - #7789 `e0b3e19` Add note about using the Qt official binary installer (paveljanik)\n- - #7791 `e30a5b0` Change Precise to Trusty in gitian-building.md (JeremyRand)\n- - #7838 `8bb5d3d` Update gitian build guide to debian 8.4.0 (fanquake)\n- - #7855 `b778e59` Replace precise with trusty (MarcoFalke)\n- - #7975 `fc23fee` Update bitcoin-core GitHub links (MarcoFalke)\n- - #8034 `e3a8207` Add basic git squash workflow (fanquake)\n- - #7813 `214ec0b` Update port in tor.md (MarcoFalke)\n- - #8193 `37c9830` Use Debian 8.5 in the gitian-build guide (fanquake)\n- - #8261 `3685e0c` Clarify help for `getblockchaininfo` (paveljanik)\n- - #7185 `ea0f5a2` Note that reviewers should mention the id of the commits they reviewed (pstratem)\n- - #7290 `c851d8d` [init] Add missing help for args (MarcoFalke)\n- - #7281 `f9fd4c2` Improve CheckInputs() comment about sig verification (petertodd)\n- - #7417 `1e06bab` Minor improvements to the release process (PRabahy)\n- - #7444 `4cdbd42` Improve block validity/ConnectBlock() comments (petertodd)\n- - #7527 `db2e1c0` Fix and cleanup listreceivedbyX documentation (instagibbs)\n- - #7541 `b6e00af` Clarify description of blockindex (pinheadmz)\n- - #7590 `f06af57` Improving wording related to Boost library requirements [updated] (jonathancross)\n- - #7635 `0fa88ef` Add dependency info to test docs (elliotolds)\n- - #7609 `3ba07bd` RPM spec file project (AliceWonderMiscreations)\n- - #7850 `229a17c` Removed call to `TryCreateDirectory` from `GetDefaultDataDir` in `src/util.cpp` (alexreg)\n- - #7888 `ec870e1` Prevector: fix 2 bugs in currently unreached code paths (kazcw)\n- - #7922 `90653bc` CBase58Data::SetString: cleanse the full vector (kazcw)\n- - #7881 `c4e8390` Update release process (laanwj)\n- - #7952 `a9c8b74` Log invalid block hash to make debugging easier (paveljanik)\n- - #7974 `8206835` More comments on the design of AttemptToEvictConnection (gmaxwell)\n- - #7795 `47a7cfb` UpdateTip: log only one line at most per block (laanwj)\n- - #8110 `e7e25ea` Add benchmarking notes (fanquake)\n- - #8121 `58f0c92` Update implemented BIPs list (fanquake)\n- - #8029 `58725ba` Simplify OS X build notes (fanquake)\n- - #8143 `d46b8b5` comment nit: miners don't vote (instagibbs)\n- - #8136 `22e0b35` Log/report in 10% steps during VerifyDB (jonasschnelli)\n- - #8168 `d366185` util: Add ParseUInt32 and ParseUInt64 (laanwj)\n- - #8178 `f7b1bfc` Add git and github tips and tricks to developer notes (sipa)\n- - #8177 `67db011` developer notes: updates for C++11 (kazcw)\n- - #8229 `8ccdac1` [Doc] Update OS X build notes for 10.11 SDK (fanquake)\n- - #8233 `9f1807a` Mention Linux ARM executables in release process and notes (laanwj)\n- - #7540 `ff46dd4` Rename OP_NOP3 to OP_CHECKSEQUENCEVERIFY (btcdrak)\n- - #8289 `26316ff` bash-completion: Adapt for 0.12 and 0.13 (roques)\n- - #7453 `3dc3149` Missing patches from 0.12 (MarcoFalke)\n- - #7113 `54a550b` Switch to a more efficient rolling Bloom filter (sipa)\n- - #7257 `de9e5ea` Combine common error strings for different options so translations can be shared and reused (luke-jr)\n- - #7304 `b8f485c` [contrib] Add clang-format-diff.py (MarcoFalke)\n- - #7378 `e6f97ef` devtools: replace github-merge with python version (laanwj)\n- - #7395 `0893705` devtools: show pull and commit information in github-merge (laanwj)\n- - #7402 `6a5932b` devtools: github-merge get toplevel dir without extra whitespace (achow101)\n- - #7425 `20a408c` devtools: Fix utf-8 support in messages for github-merge (laanwj)\n- - #7632 `409f843` Delete outdated test-patches reference (Lewuathe)\n- - #7662 `386f438` remove unused NOBLKS_VERSION_{START,END} constants (rat4)\n- - #7737 `aa0d2b2` devtools: make github-merge.py use py3 (laanwj)\n- - #7781 `55db5f0` devtools: Auto-set branch to merge to in github-merge (laanwj)\n- - #7934 `f17032f` Improve rolling bloom filter performance and benchmark (sipa)\n- - #8004 `2efe38b` signal handling: fReopenDebugLog and fRequestShutdown should be type sig_atomic_t (catilac)\n- - #7713 `f6598df` Fixes for verify-commits script (petertodd)\n- - #8412 `8360d5b` libconsensus: Expose a flag for BIP112 (jtimon)\n\nCredits\n=======\n\nThanks to everyone who directly contributed to this release:\n\n- - 21E14\n- - accraze\n- - Adam Brown\n- - Alexander Regueiro\n- - Alex Morcos\n- - Alfie John\n- - Alice Wonder\n- - AlSzacrel\n- - Andrew Chow\n- - Andr\u00e9s G. Aragoneses\n- - Bob McElrath\n- - BtcDrak\n- - calebogden\n- - C\u00e9dric F\u00e9lizard\n- - Chirag Dav\u00e9\n- - Chris Moore\n- - Chris Stewart\n- - Christian von Roques\n- - Chris Wheeler\n- - Cory Fields\n- - crowning-\n- - Daniel Cousens\n- - Daniel Kraft\n- - Denis Lukianov\n- - Elias Rohrer\n- - Elliot Olds\n- - Eric Shaw\n- - error10\n- - Ethan Heilman\n- - face\n- - fanquake\n- - Francesco 'makevoid' Canessa\n- - fsb4000\n- - Gavin Andresen\n- - gladoscc\n- - Gregory Maxwell\n- - Gregory Sanders\n- - instagibbs\n- - James O'Beirne\n- - Jannes Faber\n- - Jarret Dyrbye\n- - Jeremy Rand\n- - jloughry\n- - jmacwhyte\n- - Joao Fonseca\n- - Johnson Lau\n- - Jonas Nick\n- - Jonas Schnelli\n- - Jonathan Cross\n- - Jo\u00e3o Barbosa\n- - Jorge Tim\u00f3n\n- - Kaz Wesley\n- - Kefkius\n- - kirkalx\n- - Krzysztof Jurewicz\n- - Leviathn\n- - lewuathe\n- - Luke Dashjr\n- - Luv Khemani\n- - Marcel Kr\u00fcger\n- - Marco Falke\n- - Mark Friedenbach\n- - Matt\n- - Matt Bogosian\n- - Matt Corallo\n- - Matthew English\n- - Matthew Zipkin\n- - mb300sd\n- - Mitchell Cash\n- - mrbandrews\n- - mruddy\n- - Murch\n- - Mustafa\n- - Nathaniel Mahieu\n- - Nicolas Dorier\n- - Patrick Strateman\n- - Paul Rabahy\n- - paveljanik\n- - Pavel Jan\u00edk\n- - Pavel Vasin\n- - Pedro Branco\n- - Peter Todd\n- - Philip Kaufmann\n- - Pieter Wuille\n- - Prayag Verma\n- - ptschip\n- - Puru\n- - randy-waterhouse\n- - R E Broadley\n- - Rusty Russell\n- - Suhas Daftuar\n- - Suriyaa Kudo\n- - TheLazieR Yip\n- - Thomas Kerin\n- - Tom Harding\n- - Tyler Hardin\n- - UdjinM6\n- - Warren Togami\n- - Will Binns\n- - Wladimir J. van der Laan\n- - Yuri Zhykin\n\nAs well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).\n\nHashes for verification\n========================\n\nThese are the SHA-256 hashes of the released files:\n\n    f94123e37530f9de25988ff93e5568a93aa5146f689e63fb0ec1f962cf0bbfcd  bitcoin-0.13.0-aarch64-linux-gnu.tar.gz\n    7c657ec6f6a5dbb93b9394da510d5dff8dd461df8b80a9410f994bc53c876303  bitcoin-0.13.0-arm-linux-gnueabihf.tar.gz\n    d6da2801dd9d92183beea16d0f57edcea85fc749cdc2abec543096c8635ad244  bitcoin-0.13.0-i686-pc-linux-gnu.tar.gz\n    2f67ac67b935368e06f2f3b83f0173be641eef799e45d0a267efc0b9802ca8d2  bitcoin-0.13.0-osx64.tar.gz\n    e7fed095f1fb833d167697c19527d735e43ab2688564887b80b76c3c349f85b0  bitcoin-0.13.0-osx.dmg\n    0c7d7049689bb17f4256f1e5ec20777f42acef61814d434b38e6c17091161cda  bitcoin-0.13.0.tar.gz\n    213e6626ad1f7a0c7a0ae2216edd9c8f7b9617c84287c17c15290feca0b8f13b  bitcoin-0.13.0-win32-setup.exe\n    5c5bd6d31e4f764e33f2f3034e97e34789c3066a62319ae8d6a6011251187f7c  bitcoin-0.13.0-win32.zip\n    c94f351fd5266e07d2132d45dd831d87d0e7fdb673d5a0ba48638e2f9f8339fc  bitcoin-0.13.0-win64-setup.exe\n    54606c9a4fd32b826ceab4da9335d7a34a380859fa9495bf35a9e9c0dd9b6298  bitcoin-0.13.0-win64.zip\n    bcc1e42d61f88621301bbb00512376287f9df4568255f8b98bc10547dced96c8  bitcoin-0.13.0-x86_64-linux-gnu.tar.gz\n\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQEcBAEBCgAGBQJXvGoPAAoJEHSBCwEjRsmm8a4H/j06PHEWZ/NDL+38d//aHLIn\n7QTE3ih2aSPsEVtwSnC8cFQVyTAG6ZyJ0T4DvXZ7wizzCqTjtDzDs03GQCBaAHH6\nQzqGgdezffFFxYG2/aTcEhf0bW44FMqc9t5ypgn61o1cbrgP9/1edWz4FSj6BGoX\nkx4D9pPudST3J1mYEdC77foi7uFCLU2J6m2N02qwCqr/uXxao+2dR+l3nfpeJA8N\n1D+D1MdAq55/UEwxankVFeoLdMHSb5AXZZQyvkeimfwxnEDX1k1maoyYyYFx9MJK\nMevaNTpRwiAhNtY3m9ucI/LrLETKC3vRvonxoSHBHioz9rZwvBEwNkP0+M/9zGQ=\n=wCgV\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.13.0 released",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Wladimir J. van der Laan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 48084
        }
    },
    {
        "title": "[bitcoin-dev] BIP Status updates (including to Active/Final Status) - BIP 39, BIP 43, BIP 44, BIP 67, BIP 111, BIP 125, BIP 130",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2016-08-23T20:12:11",
                "message_text_only": "A number of BIPs seem ready for updating to Final Status. If there are no \nobjections, I will update these in 2 weeks:\n\nBIP 39: Mnemonic code for generating deterministic keys\n- Used by many wallets and hundreds of thousands of users.\n\nBIP 44: Multi-Account Hierarchy for Deterministic Wallets\n- Appears to be implemented by multiple wallets.\n\nBIP 67: Deterministic Pay-to-script-hash multi-signature addresses through\n        public key sorting\n- Implementations in multiple wallet software exist.\n\nBIP 125: Opt-in Full Replace-by-Fee Signaling\n- Implemented in Bitcoin Core and derivatives; appears to be in regular use on \nthe network.\n\nBIP 130: sendheaders message\n- Implemented in Bitcoin Core and derivatives.\n\nAlso, BIP 43 (Purpose Field for Deterministic Wallets) is an informational BIP \nwhich appears to be guiding to some extent the creation of new BIPs; therefore \nI propose its Status be upgraded to Active. I will make this update in 2 weeks \nalso, if no objections.\n\nAdditionally, BIP 111 (NODE_BLOOM service bit) has been implemented in Bitcoin \nCore and derivatives; it is unclear if used by clients yet. Can developers of \nsuch clients please comment and let me know: 1) if their software supports \nthis BIP already; 2) if not, do they intend to support it in the future?\nIf and only if there are any clients using this service bit already, I will \nupdate BIP 111 to Final Status in 2 weeks also.\n\nThanks,\n\nLuke"
            },
            {
                "author": "Kenneth Heutmaker",
                "date": "2016-08-23T20:54:50",
                "message_text_only": "> Additionally, BIP 111 (NODE_BLOOM service bit) has been implemented in Bitcoin\n> Core and derivatives; it is unclear if used by clients yet. Can developers of\n> such clients please comment and let me know: 1) if their software supports\n> this BIP already; 2) if not, do they intend to support it in the future?\n> If and only if there are any clients using this service bit already, I will\n> update BIP 111 to Final Status in 2 weeks also.\n\nMultibit is adding detection of the NODE_BLOOM bit in the next 2-3 weeks.\n\nSPV is kinda broken if the wallet doesn\u2019t do this detection. If your wallet connects only to nodes that don\u2019t support bloom filtering, the wallet never gets updates. We have had a spike in users reporting that their wallet isn't getting updated. To compound the problem, they rescan the blockchain and lose all of their transaction history. It has caused much panic among less technical users.\n\nWe believe that failing to detect the NODE_BLOOM bit is the culprit, although it is non-deterministic, so we aren't certain.\n\nI imagine that other SPV wallets are having similar issues. BIP 111 really isn\u2019t optional at this point, so it should be marked final.\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 801 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160823/2e38b60b/attachment.sig>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2016-08-24T06:59:56",
                "message_text_only": ">> Additionally, BIP 111 (NODE_BLOOM service bit) has been implemented in Bitcoin\n>> Core and derivatives; it is unclear if used by clients yet. Can developers of\n>> such clients please comment and let me know: 1) if their software supports\n>> this BIP already; 2) if not, do they intend to support it in the future?\n>> If and only if there are any clients using this service bit already, I will\n>> update BIP 111 to Final Status in 2 weeks also.\n> \n> Multibit is adding detection of the NODE_BLOOM bit in the next 2-3 weeks.\n> \n> SPV is kinda broken if the wallet doesn\u2019t do this detection. If your wallet connects only to nodes that don\u2019t support bloom filtering, the wallet never gets updates. We have had a spike in users reporting that their wallet isn't getting updated. To compound the problem, they rescan the blockchain and lose all of their transaction history. It has caused much panic among less technical users.\n> \n> We believe that failing to detect the NODE_BLOOM bit is the culprit, although it is non-deterministic, so we aren't certain.\n> \n> I imagine that other SPV wallets are having similar issues. BIP 111 really isn\u2019t optional at this point, so it should be marked final.\n\nSPV Wallets should definitively update to respect NODE_BLOOM. Bloom\nfiltering is CPU and disk intense and some node operators have disabled\nit (or will disabled it) because there is no direct p2p network-health\nbenefit.\n\nSPV wallets should probably also make use of the new DNS seeder filter\noption.\nIt is running at least on seed.bitcoin.sipa.be and\nseed.bitcoin.jonasschnelli.ch.\n\nThe filter option allows SPV Wallets to only get nodes that signal\nsupport for NODE_BLOOM.\n\nThe syntax is\n\n   x<networkservice_flags_filter_as_int>.seed.bitcoin....\n\nExample for NODE_NETWORK together with NODE_BLOOM\ndig x5.seed.bitcoin.jonasschnelli.ch\n(NETWORK = (1 << 0), NODE_BLOOM = (1 << 2)) = (bin00000101 = (int)5)\n\n\n</jonas>\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160824/c7311f2b/attachment.sig>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2016-08-24T08:34:20",
                "message_text_only": "On Tue, Aug 23, 2016 at 8:54 PM, Kenneth Heutmaker via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> SPV is kinda broken if the wallet doesn\u2019t do this detection. If your wallet connects only to nodes that don\u2019t support bloom filtering, the wallet never gets updates. We have had a spike in users reporting that their wallet isn't getting updated. To compound the problem, they rescan the blockchain and lose all of their transaction history. It has caused much panic among less technical users.\n>\n> We believe that failing to detect the NODE_BLOOM bit is the culprit, although it is non-deterministic, so we aren't certain.\n\nThere are almost no NODE_BLOOM supporting bloom-off nodes on the\nnetwork currently. So, while supporting this is important, I am\ndoubtful that its the current problem you've suffered.\n\nThere are a great many fake nodes which appear to exist purely to\nmonitor transactions. Many do not implement enough of the protocol to\nsupport scanning or transaction relay. (and, in fact, relaying\ntransactions would make monitoring less effective).\n\nYou can't count on peers on a peer to peer network to be honest and\ncooperative. Implementations need to work hard to be robust to abusive\npeers. Unfortunately, the design of the bloom filtering is such that\nit isn't always easy (or even possible) to be robust."
            },
            {
                "author": "Thomas Voegtlin",
                "date": "2016-08-24T12:51:32",
                "message_text_only": "Le 23/08/2016 \u00e0 22:12, Luke Dashjr via bitcoin-dev a \u00e9crit :\n> BIP 39: Mnemonic code for generating deterministic keys\n> - Used by many wallets and hundreds of thousands of users.\n> \n> BIP 44: Multi-Account Hierarchy for Deterministic Wallets\n> - Appears to be implemented by multiple wallets.\n> \n\nI personally believe that BIP39/BIP44 is a bad design. There is limited\nsupport for these BIPs in Electrum, in order to provide compatibility\nwith hardware wallets. However, I do not plan to use BIP39/BIP44 for\ndefault Electrum wallets, for the following reasons.\n\n(Note that it does not make sense to consider BIP39 and BIP44\nindependently. Any wallet that decides to implement one without the\nother would be considered as broken.)\n\nHere is why I rejected this design:\n\n1 - BIP44 uses multiple accounts. This means that in order to be\ncompatible with the standard, a wallet *must* implement multiple\naccounts. A wallet that decides to keep things simple and use only one\naccount, will not allow users to recover all their funds when they\nrestore from a BIP39 seed, and will be considered as broken.\n\n2 - An appealing feature of deterministic wallets is that you can use\nthe same instance of your wallet on different devices. Two instances of\nyour wallet can automatically synchronize their Bitcoin addresses, and\ndisplay the same balance. The problem is that hardened derivations break\nthis property. Indeed, with hardened derivations, software wallets need\nto ask the user's password in order to derive new accounts. Therefore,\nin order to implement automated detection of newly created accounts, a\nBIP44-compatible software wallets would need to ask the user's password\nwhenever a new account is detected. This means that the wallet would ask\nthe password without the user initiating any action. This seems to be an\navenue for malware.\n\nOf course, hardware wallets do not have that issue, because they can\nderive new accounts without requesting a password from the user. BIP44\nis a standard that has been designed for hardware wallets, but that\nmakes things really difficult for software wallets.\n\n3 - Unneeded complexity. From an end user perspective, the multiple\naccounts in BIP44 achieve the same result as using different derivation\npassphrases with the same BIP39 seed phrase. The only real difference is\nthat BIP44 accounts can be enumerated deterministically, while\npassphrases in general cannot. However, this property is of limited\ninterest, because automatic synchronization of multiple accounts cannot\nbe guaranteed for bip44 software wallets, as explained in 2.\n\n4 - BIP39 is inconsistent. It uses a hash of the utf8 encoded 'seed\nphrase' in order to derive the BIP32 seed. This hash-based derivation\nwas added on my suggestion, in order to make the BIP independent from\nthe particular wordlist used to generate the seed phrases. However,\nBIP39 also requires the implementation of a checksum, in order to verify\nthat a seed phrase is valid. Suprisingly, the specification of the\nchecksum involves wordlist indices. This means the checksum (and thus\nthe BIP) requires a fixed wordlist. This defeats the purpose of using a\nhash for the derivation of the seed.\n\nThe authors of the BIP should either have used hash functions for both\nthe seed AND the checksum (that is what Electrum does), or for none of\nthem (in that case case, you can have a bidirectional function between\nseed phrases and entropy, which is nice if you want to perform Shamir\nsecret sharing of seed phrases, at the expenses of a fixed wordlist). In\nits current state, BIP39 takes the worst of both worlds.\n\n5 - The fact that the wordlist must be part of BIP39, and cannot be\nchanged in the future, seems a terrible idea to me. I believe that a\nspecification should always try to be minimal. In that case, the\nspecification includes a 2000+ words dictionary, when it could have\navoided that.\n\nEven if you decide that BIP39 is final, there will always be users\nrequiring the addition of wordlists for new languages. So, in practice,\nthis BIP will never be final.\n\n6 - Finally, and most importantly, BIP39 seed phrases do not have a\nversion number. Without a version number, how are you going to derive\naddresses from a BIP39 seed phrase, when wallets start to use to new\nderivation methods (such as SegWit, or Schnorr signatures)? Does it mean\nthat a BIP39 compatible wallet will have to check addresses from all the\nderivation methods that ever existed in the past, in order to ensure\nthat all coins are correctly retrieved? Or will there be users that\ncannot access their coins because their BIP39 seed phrase is too old for\nnewer software?\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 836 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160824/926591b8/attachment.sig>"
            },
            {
                "author": "Andreas Schildbach",
                "date": "2016-08-24T13:47:08",
                "message_text_only": "FWIW, BIP44 also doesn't encode a seed birthday. This needed so that SPV\nwallets do not need to scan from the beginning of the blockchain.\n\nThat doesn't mean BIP44 could not be final. There are some wallets that\ninteroperate on that standard and that's fine. The whole reason I\ninsisted on separating BIP43 from BIP44 is that someone else can come up\nwith a better \"BIP44+\" standard and not get into the way of existing\nstandards. I think BIP43 should be made final as well, if it isn't already.\n\n\nOn 08/24/2016 02:51 PM, Thomas Voegtlin via bitcoin-dev wrote:\n> Le 23/08/2016 \u00e0 22:12, Luke Dashjr via bitcoin-dev a \u00e9crit :\n>> BIP 39: Mnemonic code for generating deterministic keys\n>> - Used by many wallets and hundreds of thousands of users.\n>>\n>> BIP 44: Multi-Account Hierarchy for Deterministic Wallets\n>> - Appears to be implemented by multiple wallets.\n>>\n> \n> I personally believe that BIP39/BIP44 is a bad design. There is limited\n> support for these BIPs in Electrum, in order to provide compatibility\n> with hardware wallets. However, I do not plan to use BIP39/BIP44 for\n> default Electrum wallets, for the following reasons.\n> \n> (Note that it does not make sense to consider BIP39 and BIP44\n> independently. Any wallet that decides to implement one without the\n> other would be considered as broken.)\n> \n> Here is why I rejected this design:\n> \n> 1 - BIP44 uses multiple accounts. This means that in order to be\n> compatible with the standard, a wallet *must* implement multiple\n> accounts. A wallet that decides to keep things simple and use only one\n> account, will not allow users to recover all their funds when they\n> restore from a BIP39 seed, and will be considered as broken.\n> \n> 2 - An appealing feature of deterministic wallets is that you can use\n> the same instance of your wallet on different devices. Two instances of\n> your wallet can automatically synchronize their Bitcoin addresses, and\n> display the same balance. The problem is that hardened derivations break\n> this property. Indeed, with hardened derivations, software wallets need\n> to ask the user's password in order to derive new accounts. Therefore,\n> in order to implement automated detection of newly created accounts, a\n> BIP44-compatible software wallets would need to ask the user's password\n> whenever a new account is detected. This means that the wallet would ask\n> the password without the user initiating any action. This seems to be an\n> avenue for malware.\n> \n> Of course, hardware wallets do not have that issue, because they can\n> derive new accounts without requesting a password from the user. BIP44\n> is a standard that has been designed for hardware wallets, but that\n> makes things really difficult for software wallets.\n> \n> 3 - Unneeded complexity. From an end user perspective, the multiple\n> accounts in BIP44 achieve the same result as using different derivation\n> passphrases with the same BIP39 seed phrase. The only real difference is\n> that BIP44 accounts can be enumerated deterministically, while\n> passphrases in general cannot. However, this property is of limited\n> interest, because automatic synchronization of multiple accounts cannot\n> be guaranteed for bip44 software wallets, as explained in 2.\n> \n> 4 - BIP39 is inconsistent. It uses a hash of the utf8 encoded 'seed\n> phrase' in order to derive the BIP32 seed. This hash-based derivation\n> was added on my suggestion, in order to make the BIP independent from\n> the particular wordlist used to generate the seed phrases. However,\n> BIP39 also requires the implementation of a checksum, in order to verify\n> that a seed phrase is valid. Suprisingly, the specification of the\n> checksum involves wordlist indices. This means the checksum (and thus\n> the BIP) requires a fixed wordlist. This defeats the purpose of using a\n> hash for the derivation of the seed.\n> \n> The authors of the BIP should either have used hash functions for both\n> the seed AND the checksum (that is what Electrum does), or for none of\n> them (in that case case, you can have a bidirectional function between\n> seed phrases and entropy, which is nice if you want to perform Shamir\n> secret sharing of seed phrases, at the expenses of a fixed wordlist). In\n> its current state, BIP39 takes the worst of both worlds.\n> \n> 5 - The fact that the wordlist must be part of BIP39, and cannot be\n> changed in the future, seems a terrible idea to me. I believe that a\n> specification should always try to be minimal. In that case, the\n> specification includes a 2000+ words dictionary, when it could have\n> avoided that.\n> \n> Even if you decide that BIP39 is final, there will always be users\n> requiring the addition of wordlists for new languages. So, in practice,\n> this BIP will never be final.\n> \n> 6 - Finally, and most importantly, BIP39 seed phrases do not have a\n> version number. Without a version number, how are you going to derive\n> addresses from a BIP39 seed phrase, when wallets start to use to new\n> derivation methods (such as SegWit, or Schnorr signatures)? Does it mean\n> that a BIP39 compatible wallet will have to check addresses from all the\n> derivation methods that ever existed in the past, in order to ensure\n> that all coins are correctly retrieved? Or will there be users that\n> cannot access their coins because their BIP39 seed phrase is too old for\n> newer software?\n> \n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2016-08-24T18:22:39",
                "message_text_only": "On Wednesday, August 24, 2016 1:47:08 PM Andreas Schildbach via bitcoin-dev \nwrote:\n> FWIW, BIP44 also doesn't encode a seed birthday. This needed so that SPV\n> wallets do not need to scan from the beginning of the blockchain.\n> \n> That doesn't mean BIP44 could not be final. There are some wallets that\n> interoperate on that standard and that's fine.\n\nRight. The Status doesn't depend on whether it is a good idea or not, only \nwhether or not people are de facto using it.\n\nBIP 2's BIP Comments would have provided a place for Thomas and yourself to \ncriticise the BIP, but unfortunately this was too controversial.\n\n> I think BIP43 should be made final as well, if it isn't already.\n\nBIP 43 merely advises other BIPs how they might do things, so it goes into the \nDraft->Active Status flow rather than Draft->Accepted->Final.\n\nLuke"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2016-08-24T14:18:26",
                "message_text_only": "Hi\n\n> 6 - Finally, and most importantly, BIP39 seed phrases do not have a\n> version number. Without a version number, how are you going to derive\n> addresses from a BIP39 seed phrase, when wallets start to use to new\n> derivation methods (such as SegWit, or Schnorr signatures)? Does it mean\n> that a BIP39 compatible wallet will have to check addresses from all the\n> derivation methods that ever existed in the past, in order to ensure\n> that all coins are correctly retrieved? Or will there be users that\n> cannot access their coins because their BIP39 seed phrase is too old for\n> newer software?\n\nI totally agree with Thomas.\n\nAnother thing that I think could be a BIP misdesign:\n\nBIP44 Gap Limits\nFrom the BIP:\n\n----------\n  \"Address gap limit is currently set to 20. If the software hits 20\nunused addresses in a row, it expects there are no used addresses beyond\nthis point and stops searching the address chain.\"\n----------\n\n* Does that mean, we do a transaction rescan back to the genesis block\nfor every 20 addresses?\n* Or is it a prerequirement to do a wallet recovery after BIP44's to\nhave access to a full address-indexed blockchain?\n\nOr maybe I'm missing something.\n\n</jonas>\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160824/c679a7ea/attachment.sig>"
            },
            {
                "author": "Jochen Hoenicke",
                "date": "2016-08-24T14:42:25",
                "message_text_only": "On 24.08.2016 16:18, Jonas Schnelli via bitcoin-dev wrote:\n> \n> Another thing that I think could be a BIP misdesign:\n> \n> BIP44 Gap Limits\n> From the BIP:\n> \n> ----------\n>   \"Address gap limit is currently set to 20. If the software hits 20\n> unused addresses in a row, it expects there are no used addresses beyond\n> this point and stops searching the address chain.\"\n> ----------\n> \n> * Does that mean, we do a transaction rescan back to the genesis block\n> for every 20 addresses?\n\nAs I understand it, you can scan sequentially starting with the genesis\nblock (or with a block at around the time when BIP44 was written).  Then\nif you find a new transaction, which requires to generate new addresses,\nyou generate them and scan further from that point on.  This way you can\nscan in a single pass if the scanning process calls you back when it\nfinds a transaction and allows you to change the set of addresses on the\nfly.\n\n  Jochen"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2016-08-25T07:39:28",
                "message_text_only": "Sorry for hijacking the thread again\n\n> As I understand it, you can scan sequentially starting with the genesis\n> block (or with a block at around the time when BIP44 was written).  Then\n> if you find a new transaction, which requires to generate new addresses,\n> you generate them and scan further from that point on.  This way you can\n> scan in a single pass if the scanning process calls you back when it\n> finds a transaction and allows you to change the set of addresses on the\n> fly.\n\n(I think this case if not completely unrealistic):\n\nWhat would happen, if a user gave out 21 addresses, then address0 had\nreceive funds in +180 days after generation where address21 had receive\nfunds immediately (all other addresses never received a tx).\n\nIn a scan, address0 would be detected at <address-birthday>+180 days\nwhich would trigger the resize+20 of the address-lookup-window, but, we\nwould require to go back 180day in order to detect received transaction\nof address21 (new lookup-window) in that case.\n\nOr do I misunderstand something?\n\n\n</jonas>\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160825/b7df9cb6/attachment.sig>"
            },
            {
                "author": "Thomas Voegtlin",
                "date": "2016-08-25T07:56:17",
                "message_text_only": "Le 25/08/2016 \u00e0 09:39, Jonas Schnelli via bitcoin-dev a \u00e9crit :\n> (I think this case if not completely unrealistic):\n> \n> What would happen, if a user gave out 21 addresses, then address0 had\n> receive funds in +180 days after generation where address21 had receive\n> funds immediately (all other addresses never received a tx).\n> \n> In a scan, address0 would be detected at <address-birthday>+180 days\n> which would trigger the resize+20 of the address-lookup-window, but, we\n> would require to go back 180day in order to detect received transaction\n> of address21 (new lookup-window) in that case.\n> \n> Or do I misunderstand something?\n> \n> \n\nThat case is not unrealistic; a merchant might generate addresses that\nare beyond their gap limit, and orders get filled at a later date.\n\nIn that case you will not get the same result when restoring your wallet\nin a block-scanning wallet and in Electrum.\n\nThe lack of consideration for these cases is another issue with BIP44.\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 836 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160825/5fed1fda/attachment-0001.sig>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2016-08-25T08:08:21",
                "message_text_only": "> Le 25/08/2016 \u00e0 09:39, Jonas Schnelli via bitcoin-dev a \u00e9crit :\n>> (I think this case if not completely unrealistic):\n>>\n>> What would happen, if a user gave out 21 addresses, then address0 had\n>> receive funds in +180 days after generation where address21 had receive\n>> funds immediately (all other addresses never received a tx).\n>>\n>> In a scan, address0 would be detected at <address-birthday>+180 days\n>> which would trigger the resize+20 of the address-lookup-window, but, we\n>> would require to go back 180day in order to detect received transaction\n>> of address21 (new lookup-window) in that case.\n>>\n>> Or do I misunderstand something?\n>>\n>>\n> \n> That case is not unrealistic; a merchant might generate addresses that\n> are beyond their gap limit, and orders get filled at a later date.\n> \n> In that case you will not get the same result when restoring your wallet\n> in a block-scanning wallet and in Electrum.\n> \n> The lack of consideration for these cases is another issue with BIP44.\n\nThe development paradigm of \"maybe detect funds\" is not something we\nshould *not* encourage for Bitcoin IMO.\n\nUsers might sweep their existing bip32/bip44 seed (which could miss\nfunds according to the problem above) to a new wallet and discard the\nprevious seed.\n\nBut I agree with Luke-Jr.\nThis Thread is not about specification, it's about what's used and what\nshould be marked as standard.\n\nNew BIPs could cover \"overhauled\" proposals for BIP39 and BIP44.\nOtherwise \u2013 very likely \u2013 nothing will happen.\n\n</jonas>\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160825/500f4db6/attachment.sig>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2016-08-25T08:12:22",
                "message_text_only": "> The development paradigm of \"maybe detect funds\" is not something we\n> should *not* encourage for Bitcoin IMO.\n\nSorry. That was one \"not\" to many.\n\n</jonas>\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160825/3a663553/attachment.sig>"
            },
            {
                "author": "Marek Palatinus",
                "date": "2016-08-25T08:50:43",
                "message_text_only": "As Luke pointed, BIP44 is already used by many wallets and to my knowledge\npeople don't have any real world issues with that, including loading funds\nin another BIP44 wallet. I'm not saying that BIP44 is perfect from all\npoints of view, but IMO it just works for most use cases. Let's set it as\nfinal, and propose competing standards which cover all your concerns.\n\nslush\n\nOn Thu, Aug 25, 2016 at 10:12 AM, Jonas Schnelli via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> > The development paradigm of \"maybe detect funds\" is not something we\n> > should *not* encourage for Bitcoin IMO.\n>\n> Sorry. That was one \"not\" to many.\n>\n> </jonas>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160825/ffbc4f83/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2016-08-25T09:02:27",
                "message_text_only": "This is not the place to discuss the merits and/or issues of these BIPs,\nonly whether they should be treated as final.\n\nOn Aug 25, 2016 10:51, \"Marek Palatinus via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> As Luke pointed, BIP44 is already used by many wallets and to my knowledge\n> people don't have any real world issues with that, including loading funds\n> in another BIP44 wallet. I'm not saying that BIP44 is perfect from all\n> points of view, but IMO it just works for most use cases. Let's set it as\n> final, and propose competing standards which cover all your concerns.\n>\n> slush\n>\n> On Thu, Aug 25, 2016 at 10:12 AM, Jonas Schnelli via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>>\n>> > The development paradigm of \"maybe detect funds\" is not something we\n>> > should *not* encourage for Bitcoin IMO.\n>>\n>> Sorry. That was one \"not\" to many.\n>>\n>> </jonas>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160825/f6711fae/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP Status updates (including to Active/Final Status) - BIP 39, BIP 43, BIP 44, BIP 67, BIP 111, BIP 125, BIP 130",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Thomas Voegtlin",
                "Andreas Schildbach",
                "Kenneth Heutmaker",
                "Luke Dashjr",
                "Gregory Maxwell",
                "Jochen Hoenicke",
                "Marek Palatinus",
                "Pieter Wuille",
                "Jonas Schnelli"
            ],
            "messages_count": 15,
            "total_messages_chars_count": 27502
        }
    },
    {
        "title": "[bitcoin-dev] Capital Efficient Honeypots w/ \"Scorched Earth\" Doublespending Protection",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2016-08-24T01:46:34",
                "message_text_only": "Bitcoin-based honeypots incentivise intruders into revealing the fact they have\nbroken into a server by allowing them to claim a reward based on secret\ninformation obtained during the intrusion. Spending a bitcoin can only be done\nby publishing data to a public place - the Bitcoin blockchain - allowing\ndetection of the intrusion.\n\nThe simplest way to achieve this is with one private key per server, with each\nserver associated with one transaction output spendable by that key. However\nthis isn't capital efficient if you have multiple servers to protect: if we\nhave N servers and P bitcoins that we can afford to lose in the compromise, one\nkey per server gives the intruder only N/P incentive.\n\nPreviously Piete Wuille proposed(1) tree signatures for honeypots, with a\nsingle txout protected by a 1-N tree of keys, with each server assigned a\nspecific key. Unfortunately though, tree signatures aren't yet implemented in\nthe Bitcoin protocol.\n\nHowever with a 2-of-2 multisig and the SIGHASH_SINGLE feature we can implement\nthis functionality with the existing Bitcoin protocol using the following\nscript:\n\n    2 <honeypot-pubkey> <distriminator-pubkey> 2 CHECKMULTISIG\n\nThe honeypot secret key is shared among all N servers, and left on them. The\ndistriminator secret key meanwhile is kept secret, however for each server a\nunique signature is created with SIGHASH_SINGLE, paying a token amount to a\nnotification address. For each individual server a pre-signed signature created\nwith the distriminator secret key is then left on the associated server along\nwith the honeypot secret key.\n\nRecall the SIGHASH_SINGLE flag means that the signature only signs a single\ntransaction input and transaction output; the transaction is allowed to have\nadditional inputs and outputs added. This allows the thief to use the honeypot\nkey to construct a claim transaction with an additional output added that pays\nan address that they own with the rest of the funds.\n\nEqually, we could also use SIGHASH_NONE, with the per-server discriminator\nbeing the K value used in the pre-signed transaction.\n\nNote that Jeff Coleman deserves credit as co-inventor of all the above.\n\n\nCensorship Resistance\n=====================\n\nA potential disadvantage of using non-standard SIGHASH flags is that the\ntransactions involved are somewhat unusual, and may be flagged by\nrisk analysis at exchanges and the like, a threat to the fungibility of the\nreward.\n\nWe can improve on the above concept from Todd/Coleman by using a pre-signed\nstandard transaction instead. The pre-signed transaction spends the honeypot\ntxout to two addresses, a per-server canary address, and a change address. The\nprivate key associated with the change addres is also left on the server, and\nthe intruder can then spend that change output to finally collect their reward.\n\nTo any external observer the result looks like two normal transactions created\nin the process of someone with a standard wallet sending a small amount of\nfunds to an address, followed by sending a larger amount.\n\n\nDoublespending\n==============\n\nA subtlety in the the two transactions concept is that the intruder doesn't\nhave the necessary private keys to modify the first transaction, which means\nthat the honeypot owner can respond to the compromise by doublespending that\ntransaction, potentially recovering the honeypot while still learning about the\ncompromise. While this is possible with all honeypots, if the first transaction\nis signed with the opt-in RBF flags, and CPFP-aware transaction replacement is\nnot implemented by miners, the mechanics are particularly disadvantageous to\nthe intruder, as the honeypot owner only needs to increase the first\ntransaction's fee slightly to have a high chance of recovering their funds.\nWith CPFP-aware transaction replacement the intruder could in-turn respond with\na high-fee CPFP second transaction, but currently no such implementation is\nknown.\n\n\nScorched Earth\n==============\n\nWe can use the \"scorched earth\" concept to improve the credibility of the\nhoneypot reward by making it costly for the honeypot owner to doublespend. Here\na second version of the honeypot pre-signed transaction would also be provided\nwhich sepnds the entirety of the honeypot output to fees, and additionally\nspends a second output to fees. An economically rational intruder will publish\nthe first version, which maximizes the funds they get out of the honeypot. If\nthe owner tries to dishonestly doublespend, they can respond by publishing the\n\"scorched earth\" transaction, encouraging the honeypot owner's honesty and\nmaking CPFP-aware transaction replacement irrelevant.\n\nOf course, miner centralization adds complexity to the above: in many instances\nhoneypot owners and/or intruders will be able to recover funds from altruistic\nminers. Equally, the additional complexity may discourage intruders from making\nuse of the honeypot entirely.\n\nNote that as an implementation consideration CHECKSEQUENCEVERIFY can be used to\nensure the honeypot output can only be spent with transaction replacement\nenabled, as CSV requires nSequence to be set in specific ways in any transation\nspending the output.\n\n\nReferences\n==========\n\n1) https://blockstream.com/2015/08/24/treesignatures/\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160824/b348f953/attachment.sig>"
            },
            {
                "author": "Matthew Roberts",
                "date": "2016-08-24T15:37:34",
                "message_text_only": "Really nice idea. So its like a smart contract that incentivizes\npublication that a server has been hacked? I also really like how the\nfunding has been handled -- with all the coins stored in the same address\nand then each server associated with a unique signature. That way, you\ndon't have to split up all the coins among every server and reduce the\nincentive for an attacker yet you can still identify which server was\nhacked.\n\nIt would be nice if after the attacker broke into the server that they were\nalso incentivized to act on the information as soon as possible (revealing\nearly on when the server was compromised.) I suppose you could split up the\ncoins into different outputs that could optimally be redeemed by the owner\nat different points in the future -- so they're incentivzed to act lest\ntheir reward decays even more (this is of course, assuming that the\nmonetary reward for this is greater than any possible legal consequences\nfor the attacker -- it might not be. Thinking about this some more: it\nwould also be somewhat hard to deny that this -wasn't- a honeypot with such\na complex and unique scheme required for transactions, and I for one\nwouldn't like to reveal that I'd hacked a server if I knew it was all a\ncalculated ploy. Don't honeypots rely on subtly?)\n\nWhat about also proving to an attacker that by breaking into a server they\nwould be guaranteed a reward? I know that the use-case for this is proof of\ncompromise so incentivizing a security audit would kind of fall more into\nan active invitation to audit but couldn't you also make a cryptocurrency\nthat allowed coins to be moved based on a service banner existing at a\ngiven IP address? Attackers could then break into the server, setup a\nservice that broadcasts their public key hash, and then spend coins locked\nat this special contract address to that pub key hash which miners would\ncheck on redemption (putting aside malicious use-cases for now.)\n\n\nOn Wed, Aug 24, 2016 at 11:46 AM, Peter Todd via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Bitcoin-based honeypots incentivise intruders into revealing the fact they\n> have\n> broken into a server by allowing them to claim a reward based on secret\n> information obtained during the intrusion. Spending a bitcoin can only be\n> done\n> by publishing data to a public place - the Bitcoin blockchain - allowing\n> detection of the intrusion.\n>\n> The simplest way to achieve this is with one private key per server, with\n> each\n> server associated with one transaction output spendable by that key.\n> However\n> this isn't capital efficient if you have multiple servers to protect: if we\n> have N servers and P bitcoins that we can afford to lose in the\n> compromise, one\n> key per server gives the intruder only N/P incentive.\n>\n> Previously Piete Wuille proposed(1) tree signatures for honeypots, with a\n> single txout protected by a 1-N tree of keys, with each server assigned a\n> specific key. Unfortunately though, tree signatures aren't yet implemented\n> in\n> the Bitcoin protocol.\n>\n> However with a 2-of-2 multisig and the SIGHASH_SINGLE feature we can\n> implement\n> this functionality with the existing Bitcoin protocol using the following\n> script:\n>\n>     2 <honeypot-pubkey> <distriminator-pubkey> 2 CHECKMULTISIG\n>\n> The honeypot secret key is shared among all N servers, and left on them.\n> The\n> distriminator secret key meanwhile is kept secret, however for each server\n> a\n> unique signature is created with SIGHASH_SINGLE, paying a token amount to a\n> notification address. For each individual server a pre-signed signature\n> created\n> with the distriminator secret key is then left on the associated server\n> along\n> with the honeypot secret key.\n>\n> Recall the SIGHASH_SINGLE flag means that the signature only signs a single\n> transaction input and transaction output; the transaction is allowed to\n> have\n> additional inputs and outputs added. This allows the thief to use the\n> honeypot\n> key to construct a claim transaction with an additional output added that\n> pays\n> an address that they own with the rest of the funds.\n>\n> Equally, we could also use SIGHASH_NONE, with the per-server discriminator\n> being the K value used in the pre-signed transaction.\n>\n> Note that Jeff Coleman deserves credit as co-inventor of all the above.\n>\n>\n> Censorship Resistance\n> =====================\n>\n> A potential disadvantage of using non-standard SIGHASH flags is that the\n> transactions involved are somewhat unusual, and may be flagged by\n> risk analysis at exchanges and the like, a threat to the fungibility of the\n> reward.\n>\n> We can improve on the above concept from Todd/Coleman by using a pre-signed\n> standard transaction instead. The pre-signed transaction spends the\n> honeypot\n> txout to two addresses, a per-server canary address, and a change address.\n> The\n> private key associated with the change addres is also left on the server,\n> and\n> the intruder can then spend that change output to finally collect their\n> reward.\n>\n> To any external observer the result looks like two normal transactions\n> created\n> in the process of someone with a standard wallet sending a small amount of\n> funds to an address, followed by sending a larger amount.\n>\n>\n> Doublespending\n> ==============\n>\n> A subtlety in the the two transactions concept is that the intruder doesn't\n> have the necessary private keys to modify the first transaction, which\n> means\n> that the honeypot owner can respond to the compromise by doublespending\n> that\n> transaction, potentially recovering the honeypot while still learning\n> about the\n> compromise. While this is possible with all honeypots, if the first\n> transaction\n> is signed with the opt-in RBF flags, and CPFP-aware transaction\n> replacement is\n> not implemented by miners, the mechanics are particularly disadvantageous\n> to\n> the intruder, as the honeypot owner only needs to increase the first\n> transaction's fee slightly to have a high chance of recovering their funds.\n> With CPFP-aware transaction replacement the intruder could in-turn respond\n> with\n> a high-fee CPFP second transaction, but currently no such implementation is\n> known.\n>\n>\n> Scorched Earth\n> ==============\n>\n> We can use the \"scorched earth\" concept to improve the credibility of the\n> honeypot reward by making it costly for the honeypot owner to doublespend.\n> Here\n> a second version of the honeypot pre-signed transaction would also be\n> provided\n> which sepnds the entirety of the honeypot output to fees, and additionally\n> spends a second output to fees. An economically rational intruder will\n> publish\n> the first version, which maximizes the funds they get out of the honeypot.\n> If\n> the owner tries to dishonestly doublespend, they can respond by publishing\n> the\n> \"scorched earth\" transaction, encouraging the honeypot owner's honesty and\n> making CPFP-aware transaction replacement irrelevant.\n>\n> Of course, miner centralization adds complexity to the above: in many\n> instances\n> honeypot owners and/or intruders will be able to recover funds from\n> altruistic\n> miners. Equally, the additional complexity may discourage intruders from\n> making\n> use of the honeypot entirely.\n>\n> Note that as an implementation consideration CHECKSEQUENCEVERIFY can be\n> used to\n> ensure the honeypot output can only be spent with transaction replacement\n> enabled, as CSV requires nSequence to be set in specific ways in any\n> transation\n> spending the output.\n>\n>\n> References\n> ==========\n>\n> 1) https://blockstream.com/2015/08/24/treesignatures/\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160825/9d41f9d8/attachment.html>"
            },
            {
                "author": "Jimmy",
                "date": "2016-08-24T16:29:19",
                "message_text_only": "Is this unrelated to Bitcoin Vigil idea published in 2014?\n\nhttp://www.coindesk.com/bitcoin-vigil-program-guards-against-intrusion-coin-theft/\n\n\n\n\n\nOn Wed, Aug 24, 2016 at 8:42 AM Matthew Roberts via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Really nice idea. So its like a smart contract that incentivizes\n> publication that a server has been hacked? I also really like how the\n> funding has been handled -- with all the coins stored in the same address\n> and then each server associated with a unique signature. That way, you\n> don't have to split up all the coins among every server and reduce the\n> incentive for an attacker yet you can still identify which server was\n> hacked.\n>\n> It would be nice if after the attacker broke into the server that they\n> were also incentivized to act on the information as soon as possible\n> (revealing early on when the server was compromised.) I suppose you could\n> split up the coins into different outputs that could optimally be redeemed\n> by the owner at different points in the future -- so they're incentivzed to\n> act lest their reward decays even more (this is of course, assuming that\n> the monetary reward for this is greater than any possible legal\n> consequences for the attacker -- it might not be. Thinking about this some\n> more: it would also be somewhat hard to deny that this -wasn't- a honeypot\n> with such a complex and unique scheme required for transactions, and I for\n> one wouldn't like to reveal that I'd hacked a server if I knew it was all a\n> calculated ploy. Don't honeypots rely on subtly?)\n>\n> What about also proving to an attacker that by breaking into a server they\n> would be guaranteed a reward? I know that the use-case for this is proof of\n> compromise so incentivizing a security audit would kind of fall more into\n> an active invitation to audit but couldn't you also make a cryptocurrency\n> that allowed coins to be moved based on a service banner existing at a\n> given IP address? Attackers could then break into the server, setup a\n> service that broadcasts their public key hash, and then spend coins locked\n> at this special contract address to that pub key hash which miners would\n> check on redemption (putting aside malicious use-cases for now.)\n>\n>\n> On Wed, Aug 24, 2016 at 11:46 AM, Peter Todd via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Bitcoin-based honeypots incentivise intruders into revealing the fact\n>> they have\n>> broken into a server by allowing them to claim a reward based on secret\n>> information obtained during the intrusion. Spending a bitcoin can only be\n>> done\n>> by publishing data to a public place - the Bitcoin blockchain - allowing\n>> detection of the intrusion.\n>>\n>> The simplest way to achieve this is with one private key per server, with\n>> each\n>> server associated with one transaction output spendable by that key.\n>> However\n>> this isn't capital efficient if you have multiple servers to protect: if\n>> we\n>> have N servers and P bitcoins that we can afford to lose in the\n>> compromise, one\n>> key per server gives the intruder only N/P incentive.\n>>\n>> Previously Piete Wuille proposed(1) tree signatures for honeypots, with a\n>> single txout protected by a 1-N tree of keys, with each server assigned a\n>> specific key. Unfortunately though, tree signatures aren't yet\n>> implemented in\n>> the Bitcoin protocol.\n>>\n>> However with a 2-of-2 multisig and the SIGHASH_SINGLE feature we can\n>> implement\n>> this functionality with the existing Bitcoin protocol using the following\n>> script:\n>>\n>>     2 <honeypot-pubkey> <distriminator-pubkey> 2 CHECKMULTISIG\n>>\n>> The honeypot secret key is shared among all N servers, and left on them.\n>> The\n>> distriminator secret key meanwhile is kept secret, however for each\n>> server a\n>> unique signature is created with SIGHASH_SINGLE, paying a token amount to\n>> a\n>> notification address. For each individual server a pre-signed signature\n>> created\n>> with the distriminator secret key is then left on the associated server\n>> along\n>> with the honeypot secret key.\n>>\n>> Recall the SIGHASH_SINGLE flag means that the signature only signs a\n>> single\n>> transaction input and transaction output; the transaction is allowed to\n>> have\n>> additional inputs and outputs added. This allows the thief to use the\n>> honeypot\n>> key to construct a claim transaction with an additional output added that\n>> pays\n>> an address that they own with the rest of the funds.\n>>\n>> Equally, we could also use SIGHASH_NONE, with the per-server discriminator\n>> being the K value used in the pre-signed transaction.\n>>\n>> Note that Jeff Coleman deserves credit as co-inventor of all the above.\n>>\n>>\n>> Censorship Resistance\n>> =====================\n>>\n>> A potential disadvantage of using non-standard SIGHASH flags is that the\n>> transactions involved are somewhat unusual, and may be flagged by\n>> risk analysis at exchanges and the like, a threat to the fungibility of\n>> the\n>> reward.\n>>\n>> We can improve on the above concept from Todd/Coleman by using a\n>> pre-signed\n>> standard transaction instead. The pre-signed transaction spends the\n>> honeypot\n>> txout to two addresses, a per-server canary address, and a change\n>> address. The\n>> private key associated with the change addres is also left on the server,\n>> and\n>> the intruder can then spend that change output to finally collect their\n>> reward.\n>>\n>> To any external observer the result looks like two normal transactions\n>> created\n>> in the process of someone with a standard wallet sending a small amount of\n>> funds to an address, followed by sending a larger amount.\n>>\n>>\n>> Doublespending\n>> ==============\n>>\n>> A subtlety in the the two transactions concept is that the intruder\n>> doesn't\n>> have the necessary private keys to modify the first transaction, which\n>> means\n>> that the honeypot owner can respond to the compromise by doublespending\n>> that\n>> transaction, potentially recovering the honeypot while still learning\n>> about the\n>> compromise. While this is possible with all honeypots, if the first\n>> transaction\n>> is signed with the opt-in RBF flags, and CPFP-aware transaction\n>> replacement is\n>> not implemented by miners, the mechanics are particularly disadvantageous\n>> to\n>> the intruder, as the honeypot owner only needs to increase the first\n>> transaction's fee slightly to have a high chance of recovering their\n>> funds.\n>> With CPFP-aware transaction replacement the intruder could in-turn\n>> respond with\n>> a high-fee CPFP second transaction, but currently no such implementation\n>> is\n>> known.\n>>\n>>\n>> Scorched Earth\n>> ==============\n>>\n>> We can use the \"scorched earth\" concept to improve the credibility of the\n>> honeypot reward by making it costly for the honeypot owner to\n>> doublespend. Here\n>> a second version of the honeypot pre-signed transaction would also be\n>> provided\n>> which sepnds the entirety of the honeypot output to fees, and additionally\n>> spends a second output to fees. An economically rational intruder will\n>> publish\n>> the first version, which maximizes the funds they get out of the\n>> honeypot. If\n>> the owner tries to dishonestly doublespend, they can respond by\n>> publishing the\n>> \"scorched earth\" transaction, encouraging the honeypot owner's honesty and\n>> making CPFP-aware transaction replacement irrelevant.\n>>\n>> Of course, miner centralization adds complexity to the above: in many\n>> instances\n>> honeypot owners and/or intruders will be able to recover funds from\n>> altruistic\n>> miners. Equally, the additional complexity may discourage intruders from\n>> making\n>> use of the honeypot entirely.\n>>\n>> Note that as an implementation consideration CHECKSEQUENCEVERIFY can be\n>> used to\n>> ensure the honeypot output can only be spent with transaction replacement\n>> enabled, as CSV requires nSequence to be set in specific ways in any\n>> transation\n>> spending the output.\n>>\n>>\n>> References\n>> ==========\n>>\n>> 1) https://blockstream.com/2015/08/24/treesignatures/\n>>\n>> --\n>> https://petertodd.org 'peter'[:-1]@petertodd.org\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160824/03bc35b5/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2016-08-24T19:18:48",
                "message_text_only": "On Wed, Aug 24, 2016 at 04:29:19PM +0000, Jimmy wrote:\n> Is this unrelated to Bitcoin Vigil idea published in 2014?\n> \n> http://www.coindesk.com/bitcoin-vigil-program-guards-against-intrusion-coin-theft/\n\nI think it's very related; to be absolutely clear the idea of a Bitcoin\nhoneypot is 100% not my idea! Also, if anyone else had previously invented the\ntechniques I (and Jeff Coleman) invented, I'd love to hear about it so I can\ngive appropriate credit.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160824/8a9f76f9/attachment.sig>"
            },
            {
                "author": "Peter Todd",
                "date": "2016-08-24T19:22:11",
                "message_text_only": "On Thu, Aug 25, 2016 at 01:37:34AM +1000, Matthew Roberts wrote:\n> Really nice idea. So its like a smart contract that incentivizes\n> publication that a server has been hacked? I also really like how the\n> funding has been handled -- with all the coins stored in the same address\n> and then each server associated with a unique signature. That way, you\n> don't have to split up all the coins among every server and reduce the\n> incentive for an attacker yet you can still identify which server was\n> hacked.\n> \n> It would be nice if after the attacker broke into the server that they were\n> also incentivized to act on the information as soon as possible (revealing\n> early on when the server was compromised.) I suppose you could split up the\n> coins into different outputs that could optimally be redeemed by the owner\n> at different points in the future -- so they're incentivzed to act lest\n\nRemember that it's _always_ possible for the owner to redeem the coins at any\ntime, and there's no way to prevent that.\n\nThe incentive for the intruder to collect the honeypot in a timely manner is\nsimple: once they've broken in, the moment the honeypot owner learns about the\ncompromise they have every reason to attempt to recover the funds, so the\nintruder needs to act as fast as possible to maximize their chances of being\nrewarded.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160824/860da896/attachment.sig>"
            },
            {
                "author": "Chris Priest",
                "date": "2016-08-24T23:03:16",
                "message_text_only": "How does your system prevent against insider attacks? How do you know\nthe money is stolen by someone who compromised server #4, and not\nstolen by the person who set up server #4? It is my understanding\nthese days most attacks are inside jobs.\n\nOn 8/24/16, Peter Todd via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> On Thu, Aug 25, 2016 at 01:37:34AM +1000, Matthew Roberts wrote:\n>> Really nice idea. So its like a smart contract that incentivizes\n>> publication that a server has been hacked? I also really like how the\n>> funding has been handled -- with all the coins stored in the same address\n>> and then each server associated with a unique signature. That way, you\n>> don't have to split up all the coins among every server and reduce the\n>> incentive for an attacker yet you can still identify which server was\n>> hacked.\n>>\n>> It would be nice if after the attacker broke into the server that they\n>> were\n>> also incentivized to act on the information as soon as possible\n>> (revealing\n>> early on when the server was compromised.) I suppose you could split up\n>> the\n>> coins into different outputs that could optimally be redeemed by the\n>> owner\n>> at different points in the future -- so they're incentivzed to act lest\n>\n> Remember that it's _always_ possible for the owner to redeem the coins at\n> any\n> time, and there's no way to prevent that.\n>\n> The incentive for the intruder to collect the honeypot in a timely manner\n> is\n> simple: once they've broken in, the moment the honeypot owner learns about\n> the\n> compromise they have every reason to attempt to recover the funds, so the\n> intruder needs to act as fast as possible to maximize their chances of\n> being\n> rewarded.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2016-08-24T23:38:30",
                "message_text_only": "On Wed, Aug 24, 2016 at 11:03 PM, Chris Priest via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> How does your system prevent against insider attacks? How do you know\n> the money is stolen by someone who compromised server #4, and not\n> stolen by the person who set up server #4? It is my understanding\n> these days most attacks are inside jobs.\n\nWorking as designed in that case:  You know #4 is compromised, it\ndoesn't tell you if it was an insider or an outsider, but in both\ncases someone unauthorized or without integrity got access to the\nkey(s)."
            },
            {
                "author": "James MacWhyte",
                "date": "2016-08-25T02:54:47",
                "message_text_only": "I've always assumed honeypots were meant to look like regular, yet\npoorly-secured, assets. If the intruder could identify this as a honeypot\nby the strange setup (presigned, non-standard transactions lying around)\nand was aware that the creator intended to doublespend as soon as the\ntransaction was discovered, wouldn't they instead prefer to not touch\nanything and wait for a non-bait target to appear? Is the assumption here\nthat the intruder wouldn't know this is a honeypot, or that they would know\nand it's just assumed that they would rather take their chances on this\ninstead of causing some other trouble?\n\nOn Tue, Aug 23, 2016 at 6:47 PM Peter Todd via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Bitcoin-based honeypots incentivise intruders into revealing the fact they\n> have\n> broken into a server by allowing them to claim a reward based on secret\n> information obtained during the intrusion. Spending a bitcoin can only be\n> done\n> by publishing data to a public place - the Bitcoin blockchain - allowing\n> detection of the intrusion.\n>\n> The simplest way to achieve this is with one private key per server, with\n> each\n> server associated with one transaction output spendable by that key.\n> However\n> this isn't capital efficient if you have multiple servers to protect: if we\n> have N servers and P bitcoins that we can afford to lose in the\n> compromise, one\n> key per server gives the intruder only N/P incentive.\n>\n> Previously Piete Wuille proposed(1) tree signatures for honeypots, with a\n> single txout protected by a 1-N tree of keys, with each server assigned a\n> specific key. Unfortunately though, tree signatures aren't yet implemented\n> in\n> the Bitcoin protocol.\n>\n> However with a 2-of-2 multisig and the SIGHASH_SINGLE feature we can\n> implement\n> this functionality with the existing Bitcoin protocol using the following\n> script:\n>\n>     2 <honeypot-pubkey> <distriminator-pubkey> 2 CHECKMULTISIG\n>\n> The honeypot secret key is shared among all N servers, and left on them.\n> The\n> distriminator secret key meanwhile is kept secret, however for each server\n> a\n> unique signature is created with SIGHASH_SINGLE, paying a token amount to a\n> notification address. For each individual server a pre-signed signature\n> created\n> with the distriminator secret key is then left on the associated server\n> along\n> with the honeypot secret key.\n>\n> Recall the SIGHASH_SINGLE flag means that the signature only signs a single\n> transaction input and transaction output; the transaction is allowed to\n> have\n> additional inputs and outputs added. This allows the thief to use the\n> honeypot\n> key to construct a claim transaction with an additional output added that\n> pays\n> an address that they own with the rest of the funds.\n>\n> Equally, we could also use SIGHASH_NONE, with the per-server discriminator\n> being the K value used in the pre-signed transaction.\n>\n> Note that Jeff Coleman deserves credit as co-inventor of all the above.\n>\n>\n> Censorship Resistance\n> =====================\n>\n> A potential disadvantage of using non-standard SIGHASH flags is that the\n> transactions involved are somewhat unusual, and may be flagged by\n> risk analysis at exchanges and the like, a threat to the fungibility of the\n> reward.\n>\n> We can improve on the above concept from Todd/Coleman by using a pre-signed\n> standard transaction instead. The pre-signed transaction spends the\n> honeypot\n> txout to two addresses, a per-server canary address, and a change address.\n> The\n> private key associated with the change addres is also left on the server,\n> and\n> the intruder can then spend that change output to finally collect their\n> reward.\n>\n> To any external observer the result looks like two normal transactions\n> created\n> in the process of someone with a standard wallet sending a small amount of\n> funds to an address, followed by sending a larger amount.\n>\n>\n> Doublespending\n> ==============\n>\n> A subtlety in the the two transactions concept is that the intruder doesn't\n> have the necessary private keys to modify the first transaction, which\n> means\n> that the honeypot owner can respond to the compromise by doublespending\n> that\n> transaction, potentially recovering the honeypot while still learning\n> about the\n> compromise. While this is possible with all honeypots, if the first\n> transaction\n> is signed with the opt-in RBF flags, and CPFP-aware transaction\n> replacement is\n> not implemented by miners, the mechanics are particularly disadvantageous\n> to\n> the intruder, as the honeypot owner only needs to increase the first\n> transaction's fee slightly to have a high chance of recovering their funds.\n> With CPFP-aware transaction replacement the intruder could in-turn respond\n> with\n> a high-fee CPFP second transaction, but currently no such implementation is\n> known.\n>\n>\n> Scorched Earth\n> ==============\n>\n> We can use the \"scorched earth\" concept to improve the credibility of the\n> honeypot reward by making it costly for the honeypot owner to doublespend.\n> Here\n> a second version of the honeypot pre-signed transaction would also be\n> provided\n> which sepnds the entirety of the honeypot output to fees, and additionally\n> spends a second output to fees. An economically rational intruder will\n> publish\n> the first version, which maximizes the funds they get out of the honeypot.\n> If\n> the owner tries to dishonestly doublespend, they can respond by publishing\n> the\n> \"scorched earth\" transaction, encouraging the honeypot owner's honesty and\n> making CPFP-aware transaction replacement irrelevant.\n>\n> Of course, miner centralization adds complexity to the above: in many\n> instances\n> honeypot owners and/or intruders will be able to recover funds from\n> altruistic\n> miners. Equally, the additional complexity may discourage intruders from\n> making\n> use of the honeypot entirely.\n>\n> Note that as an implementation consideration CHECKSEQUENCEVERIFY can be\n> used to\n> ensure the honeypot output can only be spent with transaction replacement\n> enabled, as CSV requires nSequence to be set in specific ways in any\n> transation\n> spending the output.\n>\n>\n> References\n> ==========\n>\n> 1) https://blockstream.com/2015/08/24/treesignatures/\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160825/52443c18/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2016-08-25T14:27:32",
                "message_text_only": "On Thu, Aug 25, 2016 at 02:54:47AM +0000, James MacWhyte via bitcoin-dev wrote:\n> I've always assumed honeypots were meant to look like regular, yet\n> poorly-secured, assets. If the intruder could identify this as a honeypot\n> by the strange setup (presigned, non-standard transactions lying around)\n> and was aware that the creator intended to doublespend as soon as the\n> transaction was discovered, wouldn't they instead prefer to not touch\n> anything and wait for a non-bait target to appear? Is the assumption here\n> that the intruder wouldn't know this is a honeypot, or that they would know\n> and it's just assumed that they would rather take their chances on this\n> instead of causing some other trouble?\n\nThat strongly depends on the value of the compromised machine to the\nattacker. If he has syphoned all the data from it and has no further\nuse for it then the he will probably trip the tripwire to get the\ncoins even though this will make the compromise apparent. If however\nhe is planning to use it as a foothold to further compromise your\ncompany, send spam or similar, he will likely try to avoid these\ntripwires. In which case a classic honeypot, that attempts to look\nlike a regular system is what you're looking for."
            },
            {
                "author": "Gregory Maxwell",
                "date": "2016-08-25T18:26:21",
                "message_text_only": "On Thu, Aug 25, 2016 at 2:27 PM, Christian Decker via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> If however\n> he is planning to use it as a foothold to further compromise your\n> company, send spam or similar, he will likely try to avoid these\n> tripwires. [...]\n\nDepends on the value of their activity compared to the value of the coins.\nSpamming doesn't pay much.\n\nCovert tripwires would obviously be better, but if shared tripwires\nallow you to have 100x the funds available it could be a good\ntrade-off."
            },
            {
                "author": "James MacWhyte",
                "date": "2016-08-28T02:50:12",
                "message_text_only": "Why not just have a single 1-of-m multisig transaction, with one key on\neach server? Based on which key is used you would know which server is\ncompromised, and (in my opinion) it wouldn't look nearly as suspicious.\n\nOn Thu, Aug 25, 2016 at 11:26 AM Gregory Maxwell via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Thu, Aug 25, 2016 at 2:27 PM, Christian Decker via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > If however\n> > he is planning to use it as a foothold to further compromise your\n> > company, send spam or similar, he will likely try to avoid these\n> > tripwires. [...]\n>\n> Depends on the value of their activity compared to the value of the coins.\n> Spamming doesn't pay much.\n>\n> Covert tripwires would obviously be better, but if shared tripwires\n> allow you to have 100x the funds available it could be a good\n> trade-off.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160828/5d9952ea/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2016-08-28T04:42:01",
                "message_text_only": "On 25 August 2016 14:26:21 GMT-04:00, Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>On Thu, Aug 25, 2016 at 2:27 PM, Christian Decker via bitcoin-dev\n><bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> If however\n>> he is planning to use it as a foothold to further compromise your\n>> company, send spam or similar, he will likely try to avoid these\n>> tripwires. [...]\n>\n>Depends on the value of their activity compared to the value of the\n>coins.\n>Spamming doesn't pay much.\n>\n>Covert tripwires would obviously be better, but if shared tripwires\n>allow you to have 100x the funds available it could be a good\n>trade-off.\n\nAlso, having a overt tripwire doesn't preclude having covert tripwires as well.\n\n\nIn any case, this all deserves a Standard\u2122 to make sure intruders know where to look to find the funds. Maybe /var/honeypot..."
            },
            {
                "author": "Peter Todd",
                "date": "2016-08-28T04:37:29",
                "message_text_only": "On 24 August 2016 22:54:47 GMT-04:00, James MacWhyte <macwhyte at gmail.com> wrote:\n>I've always assumed honeypots were meant to look like regular, yet\n>poorly-secured, assets.\n\nNot at all. Most servers have zero reason to have any Bitcoin's accessible via them, so the presence of BTC privkeys is a gigantic red flag that they are part of a honeypot.\n\n> If the intruder could identify this as a\n>honeypot\n>by the strange setup (presigned, non-standard transactions lying\n>around)\n>and was aware that the creator intended to doublespend as soon as the\n>transaction was discovered, wouldn't they instead prefer to not touch\n>anything and wait for a non-bait target to appear?\n\nRe-read my last section on the \"scorched earth\" disincentive to doublespend the intruder."
            },
            {
                "author": "James MacWhyte",
                "date": "2016-08-31T19:48:50",
                "message_text_only": ">\n> >I've always assumed honeypots were meant to look like regular, yet\n> >poorly-secured, assets.\n>\n> Not at all. Most servers have zero reason to have any Bitcoin's accessible\n> via them, so the presence of BTC privkeys is a gigantic red flag that they\n> are part of a honeypot.\n>\n\nI was talking about the traditional concept. From Wikipedia: \"Generally, a\nhoneypot consists of data (for example, in a network site) that appears to\nbe a legitimate part of the site but is actually isolated and monitored,\nand that seems to contain information or a resource of value to attackers,\nwhich are then blocked.\"\n\nI would argue there are ways to make it look like it is not a honeypot\n(plenty of bitcoin services have had their hot wallets hacked before, and\nif the intruder only gains access to one server they wouldn't know that all\nthe servers have the same honeypot on them). But I was just confirming that\nthe proposal is for an obvious honeypot.\n\n\n> Re-read my last section on the \"scorched earth\" disincentive to\n> doublespend the intruder.\n>\n> The first time I read it I didn't realize that the second transaction the\nintruder has is designed to waste the honeypot AND additional funds\nbelonging to the honeypot creator. That's pretty good, from a game theory\nperspective.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160831/fe3096c6/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2016-08-31T20:01:14",
                "message_text_only": "On Wed, Aug 31, 2016 at 07:48:50PM +0000, James MacWhyte wrote:\n> >\n> > >I've always assumed honeypots were meant to look like regular, yet\n> > >poorly-secured, assets.\n> >\n> > Not at all. Most servers have zero reason to have any Bitcoin's accessible\n> > via them, so the presence of BTC privkeys is a gigantic red flag that they\n> > are part of a honeypot.\n> >\n> \n> I was talking about the traditional concept. From Wikipedia: \"Generally, a\n> honeypot consists of data (for example, in a network site) that appears to\n> be a legitimate part of the site but is actually isolated and monitored,\n> and that seems to contain information or a resource of value to attackers,\n> which are then blocked.\"\n> \n> I would argue there are ways to make it look like it is not a honeypot\n> (plenty of bitcoin services have had their hot wallets hacked before, and\n> if the intruder only gains access to one server they wouldn't know that all\n> the servers have the same honeypot on them). But I was just confirming that\n> the proposal is for an obvious honeypot.\n\nAh, yeah, I think you have a point re: naming - this isn't quite the\ntraditional honeypot, as we uniquely have the ability to give the attackers a\nreward in a way where it's ok for the intruder to know that they've been\ndetected; with traditional non-monetary honeypots it's quite difficult to come\nup with a scenario where it's ok for an intruder to gain something from the\nintrusion, so you're forced to use deception instead.\n\nPerhaps a better term for this technique would be a \"compromise canary\"? Or\n\"intruder bait\"? After all, in wildlife animal research it's common to use bait\nas a way of attracting targets to discover that they exist (e.g. w/ wildlife\ncameras), even when you have no intention of doing any harm to the animal.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160831/1f5db108/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Capital Efficient Honeypots w/ \"Scorched Earth\" Doublespending Protection",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Chris Priest",
                "Peter Todd",
                "Gregory Maxwell",
                "James MacWhyte",
                "Matthew Roberts",
                "Jimmy",
                "Christian Decker"
            ],
            "messages_count": 15,
            "total_messages_chars_count": 41884
        }
    },
    {
        "title": "[bitcoin-dev] Attack by modifying non-segwit transactions after segwit is accepted ?",
        "thread_messages": [
            {
                "author": "Sergio Demian Lerner",
                "date": "2016-08-24T20:51:47",
                "message_text_only": "In a previous thread (\"New BIP: Dealing with OP_IF and OP_NOTIF\nmalleability in P2WSH\") it was briefly discussed what happens if someone\nmodifies segwit data during transmission. I think the discussion should\ncontinue.\n\nWhat worries me is what happens with non-segwit transactions after segwit\nis activated. I've followed the code from transaction arrival to\ntransaction relay and it seems that a malicious node could receive a\nnon-segwit tx, and re-format it into a segwit tx having as high as 400\nKbytes of segwit witness program data, and then relay it. Both transaction\nwould have the same hash.\n\nThe MAX_SCRIPT_ELEMENT_SIZE limit is only enforced on segwit execution, not\nin old non-segwit execution, so witness program stack elements could be as\nlarge as 400 Kbytes (MAX_STANDARD_TX_WEIGHT prevents increasing more).\nSuch large modified transaction will probably not be properly relayed by\nthe network due too low fee/byte, so the honest miner will probably win and\nforward the original transaction through the network.\nBut if the attacker has better connectivity with the network and he\nmodifies the original transaction adding segwit witness program data only\nup to the point where the transaction is relayed but miners are discouraged\nto include it in blocks due to low fees/byte, then the attacker has\nsuccessfully prevented a transaction from being mined (or at least it will\ntake much more).\n\nAlso an attacker can encode arbitrary data (such as virus signatures or\nillegal content) into passing non-segwit transactions.\n\nOne solution would be to increase the transaction version to 3 for segwit\ntransactions, so a non-segwit transaction cannot be converted into a segwit\ntransaction without changing the transaction hash. But this seems not to be\na good solution, because it does not solve all the problems. Transactions\nhaving a mixture of segwit and non-segwit inputs could suffer the same\nattack (even if they are version 3).\n\nI proposed that a rule is added to IsStandardTX() that prevents witness\nprograms of having a stack elements of length greater than\nMAX_SCRIPT_ELEMENT_SIZE. (currently this is not a rule)\n\nThat's a simple check that prevents most of the problems.\n\nA long term solution would be to add the maximum size of the witness stack\nin bytes (maxWitnessSize) as a field for each input, or as a field of the\nwhole transaction.\n\nRegards\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160824/1158ef31/attachment.html>"
            },
            {
                "author": "Johnson Lau",
                "date": "2016-08-25T01:49:34",
                "message_text_only": "Adding witness data to a non-segwit script is invalid by consensus:\n\nhttps://github.com/bitcoin/bitcoin/blob/d612837814020ae832499d18e6ee5eb919a87907/src/script/interpreter.cpp#L1467\n\n\nThis PR will detect such violation early and ban the peer:\n\nhttps://github.com/bitcoin/bitcoin/pull/8499\n\n\nAnother approach is to run the scripts of all incoming transactions. That's not too bad as you have already fetched the utxos which is a major part of validation.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160824/957edeac/attachment.html>"
            },
            {
                "author": "Sergio Demian Lerner",
                "date": "2016-08-26T13:16:36",
                "message_text_only": "Because there was a discussion on reddit about this topic, I want to\nclarify that Johnson Lau explained how a check in the code prevents this\nattack.\nSo there is no real attack.\n\nAlso note that the subject of this thread has a question mark, which means\nthat I'm asking the community for clarification, not asserting the\nexistence of a vulnerability.\n\nThe segwit code is complex, and some key parts of the consensus code are\nspread over the source files (such as state.CorruptionPossible() relation\nto DoS banning, IsNull() check in witness program serialization, etc.).\n\nThanks again Johnson for your clarifications.\n\n\nOn Wed, Aug 24, 2016 at 10:49 PM, Johnson Lau <jl2012 at xbt.hk> wrote:\n\n> Adding witness data to a non-segwit script is invalid by consensus:\n>\n> https://github.com/bitcoin/bitcoin/blob/d612837814020ae832499d18e6ee5e\n> b919a87907/src/script/interpreter.cpp#L1467\n>\n>\n> This PR will detect such violation early and ban the peer:\n>\n> https://github.com/bitcoin/bitcoin/pull/8499\n>\n>\n> Another approach is to run the scripts of all incoming transactions.\n> That's not too bad as you have already fetched the utxos which is a major\n> part of validation.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160826/aa2ad6dd/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Attack by modifying non-segwit transactions after segwit is accepted ?",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Sergio Demian Lerner",
                "Johnson Lau"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 4540
        }
    },
    {
        "title": "[bitcoin-dev] BIP 151",
        "thread_messages": [
            {
                "author": "Pieter Wuille",
                "date": "2016-08-31T14:29:53",
                "message_text_only": "Hello Eric,\n\nI felt like I still owed you a response to the points below.\n\nOn Thu, Jun 30, 2016 at 5:10 PM, Eric Voskuil <eric at voskuil.org> wrote:\n> Pieter, these are in my opinion very reasonable positions. I've made some observations inline.\n>\n>> On Jun 30, 2016, at 3:03 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n>>\n>> On Thu, Jun 30, 2016 at 11:57 AM, Eric Voskuil via bitcoin-dev\n>> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>> The proliferation of node identity is my primary concern - this relates to privacy and the security of the network.\n>>\n>> I think this is a reasonable concern.\n>>\n>> However, node identity is already being used widely, and in a very\n>> inadvisable way:\n>> * Since forever there have been lists of 'good nodes' to pass in\n>> addnode= configuration options.\n>> * Various people run multiple nodes in different geographic locations,\n>> peering with each other.\n>> * Various pieces of infrastructure exist that relies on connecting to\n>> well-behaving nodes (miner relay networks, large players peering\n>> directly with each other, ...)\n>\n> Yes, libbitcoin also provides these options on an IP basis.\n>\n>> * Several lightweight clients support configuring a trusted host to connect to.\n>\n> I explicitly exclude client-server behavior as I believe the proper resolution is to isolate clients from the P2P protocol. Libbitcoin does this already.\n\nI think that's a false dichotomy. There is no reason why the P2P\nnetwork consists of purely servers (full nodes) and clients\n(lightweight nodes). Where does a client fit that is SPV at startup,\nbut upgrades in the background to a full node? It seems strange that\nsuch a client would use a 'client protocol' for initial connections,\nbut the P2P protocol for syncing with history, when both come from the\nsame peers, and transmit the same kind of information.\n\nWhat would make sense IMHO is a protocol split between the different\nkinds of transmission:\n1) Historical block download\n2) Block synchronization at the tip\n3) Transaction relay\n...\n\n(1) prefers high bandwidth, has no connectivity concerns, and does not\ncare about latency and has no privacy concerns. (2) needs\npartition-resistance, low latency and has also no privacy concerns.\n(3) needs moderate latency, reliability of propagation and privacy.\n\nIf there were to be separate protocols for these, I would argue that\n(3) should use opportunistic encryption always to increase transaction\nsource privacy, and (2) and (3) need authentication when one of the\npeers is not fully validating.\n\nBIP 150/151 give the tools to construct these.\n\n>> Perhaps you deplore that fact, but I believe it is inevitable that different pieces of the network will make different choices here. You can't prevent people from create connections along preexisting trust lines. That does not mean that the network as a whole relies on first establishing trust everywhere.\n>\n> Of course, the network operates just fine without universal trust. My concern is not that it is required, but that it may grow significantly and will have a tendency to gravitate towards more effective registration mechanisms for what is a \"good\" peer. Even an informal but pervasive web of trust may make it difficult for untrusted parties to connect.\n\nMaybe, but I'm very unconvinced that that will happen more than how\ntoday IP and DNS-based \"authentication\" is used already (in very\ninadvisable ways).\n\n>> And I do think there are advantages.\n>>\n>> BIP 151 on its own gives you opportunistic encryption. You're very right to point out that this does not give you protection from active attackers, and that active attacking is relatively easy through sybil attacks. I still prefer my attacker to actually do that over just listening in on my connection.\n\n> I agree, and I doubt this proposal will have much impact on an advanced persistent threat, or even lesser threats. People should understand that there is both a risk and a limited benefit to this proposal.\n\nI believe the risk is only in misunderstanding what it is good for,\nand there significant benefits to a network that encrypts connections\nby default, as it excludes purely passive attackers.\n\n> I believe you have misinterpreted my comments on distributed anonymous credentials (and the like) as commentary on the construction of BIP151 (and a subsequent auth proposal). As such your observation that it is exaggerated would make sense, but it is not what I intended. Encryption and auth are straightforward. Preventing bad nodes from participating in an anonymous distributed system is not.\n\nPreventing bad nodes from participating is a very hard problem, if not\nimpossible. That doesn't mean we can't improve the current situation:\npeople are relying on node identity already, and doing so in ways that\nhave unclear attack vectors (IP spoofing, DNS poisoning, BGP routing\nattacks). Adding optional and non-discoverable cryptographic\nidentities can improve this.\n\n-- \nPieter"
            }
        ],
        "thread_summary": {
            "title": "BIP 151",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Pieter Wuille"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 4949
        }
    },
    {
        "title": "[bitcoin-dev] BIP75 Update - August 31, 2016",
        "thread_messages": [
            {
                "author": "James MacWhyte",
                "date": "2016-08-31T17:02:39",
                "message_text_only": "Hello all,\n\nToday we are submitting some updates to BIP75:\n\n-- Example use cases have been reworded to more accurately describe the\ngoal of this BIP and how the technology works.\n-- ECDSA and PGP have been added to the supported public key infrastructure\n(PKI) types to increase flexibility and use cases.\n-- Versioning has been added to make future changes and backwards\ncompatibility easy to manage.\n-- Other minor, technical details have been added or changed to improve\nperformance and reduce ambiguity during implementation.\n\nYou can see the PR here: https://github.com/bitcoin/bips/pull/439\n\nThank you,\nJames\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160831/87e4cd0e/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP75 Update - August 31, 2016",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "James MacWhyte"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 797
        }
    }
]