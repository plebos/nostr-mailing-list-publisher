[
    {
        "title": "[bitcoin-dev] OP_CTV Workshop & CFP February 1st, 2020",
        "thread_messages": [
            {
                "author": "Jeremy",
                "date": "2020-01-05T01:58:00",
                "message_text_only": "Dear Bitcoin Developers,\n\nOn February 1st, 2020 in San Francisco (location to be shared with\nattendees only) I will be hosting a workshop to aid in reviewing and\nadvancing OP_CHECKTEMPLATEVERIFY.\n\nThe workshop will be from 10am-5pm. The basic schedule of events (subject\nto change) is in the footer of this email.\n\nIf you would like to attend, please fill out the form\nhttps://forms.gle/ex2WLYS319HFdpJYA . We should have capacity for everyone\nwho wants to come, but I'll need to know by January 15th if you plan to\nattend. The primary audience for the event is Bitcoin developers, ecosystem\nengineers (i.e., mining pools, wallets, exchanges, etc), and researchers.\n\nIf you have research or projects related to OP_CTV you would be interested\nin presenting, please indicate in the application form with a brief summary\nof your topic.\n\nI may be able to sponsor travel for a few developers who would otherwise be\nunable to attend. Please indicate on the form if you require such support.\n\nIf you're able to sponsor the event (for lunch/dinner, or for travel\nsubsidies), please reach out or indicate on the form.\n\nIf you cannot attend, I'll make a best effort to make all materials from\nthe event available online. The channel ##ctv-bip-review is also available\nfor general discussion about OP_CTV.\n\nHappy New Year!\n\nJeremy\n\n10:00 AM - 10:30 AM: coffee & registration\n\nBIP SESSION\n10:30 AM - 11:00 AM: CTV BIP Design Walkthrough & Basic Motivation\n11:00 AM - 11:30 AM: Small Group Discussion & BIP Reading\n11:30 AM - 12:00 PM: BIP Q&A\n\n12pm: Lunch\n\nIMPLEMENTATION SESSION\n1:00 PM - 1:30 PM: BIP Implementation Walkthrough\n1:30 PM - 2:00 PM: Q&A + silent review implementation review time\n\nDEPLOYMENT SESSION\n2:00 PM - 2:15 PM: Deployment Plan Proposal\n2:15 PM - 2:45 PM: Deployment Plan Discussion\n\n2:45-3pm: BREAK\n\nECOSYSTEM SUPPORT SESSION\n3:00 PM - 3:30 PM: Mempool Updates Presentation & Discussion\n3:30 PM - 4:00 PM: Package Relay Informational Updates\n\nDEMO SESSION & APPLICATION TALKS\n4:00 PM - 4:10 PM: SENDMANYCOMPACTED Demo\n4:10 PM - 4:20 PM: Vault Wallet Demo\n4:20 PM: - 4:30 PM: TBA\n4:30 PM - 4:40PM: TBA\n4:40 PM - 4:50 PM: TBA\n\nWRAP UP\n4:50 PM - 5:00 PM\n\nDINNER:\n5:00 PM - 7:00 PM Dinner & Drinks\n\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200104/c57899f1/attachment.html>"
            },
            {
                "author": "Jeremy",
                "date": "2020-01-18T03:58:27",
                "message_text_only": "It's not too late to sign up  to attend the workshop; but we are\napproaching capacity!\n\nPlease fill out the form if you'd like to participate as soon as possible\nso that we can plan accordingly.\n\nFeel free to forward this posting to people who don't follow this list but\nyou think should attend.\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\n\nOn Sat, Jan 4, 2020 at 5:58 PM Jeremy <jlrubin at mit.edu> wrote:\n\n> Dear Bitcoin Developers,\n>\n> On February 1st, 2020 in San Francisco (location to be shared with\n> attendees only) I will be hosting a workshop to aid in reviewing and\n> advancing OP_CHECKTEMPLATEVERIFY.\n>\n> The workshop will be from 10am-5pm. The basic schedule of events (subject\n> to change) is in the footer of this email.\n>\n> If you would like to attend, please fill out the form\n> https://forms.gle/ex2WLYS319HFdpJYA . We should have capacity for\n> everyone who wants to come, but I'll need to know by January 15th if you\n> plan to attend. The primary audience for the event is Bitcoin developers,\n> ecosystem engineers (i.e., mining pools, wallets, exchanges, etc), and\n> researchers.\n>\n> If you have research or projects related to OP_CTV you would be interested\n> in presenting, please indicate in the application form with a brief\n> summary of your topic.\n>\n> I may be able to sponsor travel for a few developers who would otherwise\n> be unable to attend. Please indicate on the form if you require such\n> support.\n>\n> If you're able to sponsor the event (for lunch/dinner, or for travel\n> subsidies), please reach out or indicate on the form.\n>\n> If you cannot attend, I'll make a best effort to make all materials from\n> the event available online. The channel ##ctv-bip-review is also available\n> for general discussion about OP_CTV.\n>\n> Happy New Year!\n>\n> Jeremy\n>\n> 10:00 AM - 10:30 AM: coffee & registration\n>\n> BIP SESSION\n> 10:30 AM - 11:00 AM: CTV BIP Design Walkthrough & Basic Motivation\n> 11:00 AM - 11:30 AM: Small Group Discussion & BIP Reading\n> 11:30 AM - 12:00 PM: BIP Q&A\n>\n> 12pm: Lunch\n>\n> IMPLEMENTATION SESSION\n> 1:00 PM - 1:30 PM: BIP Implementation Walkthrough\n> 1:30 PM - 2:00 PM: Q&A + silent review implementation review time\n>\n> DEPLOYMENT SESSION\n> 2:00 PM - 2:15 PM: Deployment Plan Proposal\n> 2:15 PM - 2:45 PM: Deployment Plan Discussion\n>\n> 2:45-3pm: BREAK\n>\n> ECOSYSTEM SUPPORT SESSION\n> 3:00 PM - 3:30 PM: Mempool Updates Presentation & Discussion\n> 3:30 PM - 4:00 PM: Package Relay Informational Updates\n>\n> DEMO SESSION & APPLICATION TALKS\n> 4:00 PM - 4:10 PM: SENDMANYCOMPACTED Demo\n> 4:10 PM - 4:20 PM: Vault Wallet Demo\n> 4:20 PM: - 4:30 PM: TBA\n> 4:30 PM - 4:40PM: TBA\n> 4:40 PM - 4:50 PM: TBA\n>\n> WRAP UP\n> 4:50 PM - 5:00 PM\n>\n> DINNER:\n> 5:00 PM - 7:00 PM Dinner & Drinks\n>\n>\n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin>\n> <https://twitter.com/JeremyRubin>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200117/ca2da814/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "OP_CTV Workshop & CFP February 1st, 2020",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Jeremy"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 5528
        }
    },
    {
        "title": "[bitcoin-dev] Modern Soft Fork Activation",
        "thread_messages": [
            {
                "author": "Matt Corallo",
                "date": "2020-01-10T21:30:09",
                "message_text_only": "There are a series of soft-fork designs which have recently been making\ngood progress towards implementation and future adoption. However, for\nvarious reasons, activation methods therefor have gotten limited\ndiscussion. I'd like to reopen that discussion here.\n\nIt is likely worth revisiting the goals both for soft forks and their\nactivation methods to start. I'm probably missing some, but some basic\nrequirements:\n\n1) Avoid activating in the face of significant, reasonable, and directed\nobjection. Period. If someone has a well-accepted, reasonable use of\nBitcoin that is working today, have no reason to believe wouldn't work\nlong into the future without a change, and which would be made\nimpossible or significantly more difficult by a change, that change must\nnot happen. I certainly hope there is no objection on this point (see\nthe last point for an important caveat that I'm sure everyone will jump\nto point out).\n\n2) Avoid activating within a timeframe which does not make high\nnode-level-adoption likely. As with all \"node\" arguments, I'll note that\nI mean \"economically-used\" nodes, not the thousand or so spy nodes on\nGoogle Cloud and AWS. Rule changes don't make sense without nodes\nenforcing them, whether they happen to be a soft fork, hard fork, or a\nblue fork, so activating in a reduced timeframe that doesn't allow for\nlarge-scale node adoption doesn't have any value, and may cause other\nunintended side effects.\n\n3) Don't (needlessly) lose hashpower to un-upgraded miners. As a part of\nBitcoin's security comes from miners, reducing the hashpower of the\nnetwork as a side effect of a rule change is a needless reduction in a\nkey security parameter of the network. This is why, in recent history,\nsoft forks required 95% of hashpower to indicate that they have upgraded\nand are capable of enforcing the new rules. Further, this is why recent\nsoft forks have not included changes which would result in a standard\nBitcoin Core instance mining invalid-by-new-rules changes (by relying on\nthe standardness behavior of Bitcoin Core).\n\n4) Use hashpower enforcement to de-risk the upgrade process, wherever\npossible. As a corollary of the above, one of the primary reasons we use\nsoft forks is that hashpower-based enforcement of rules is an elegant\nway to prevent network splits during the node upgrade process. While it\ndoes not make sense to invest material value in systems protected by new\nrules until a significant majority of \"economic nodes\" is enforcing said\nrules, hashpower lets us neatly bridge the gap in time between\nactivation and then. By having a supermajority of miners enforce the new\nrules, attempts at violating the new rules does not result in a\nsignificant network split, disrupting existing users of the system. If\nwe aren't going to take advantage of this, we should do a hard fork\ninstead, with the necessarily slow timescale that entails.\n\n5) Follow the will of the community, irrespective of individuals or\nunreasoned objection, but without ever overruling any reasonable\nobjection. Recent history also includes \"objection\" to soft forks in the\nform of \"this is bad because it doesn't fix a different problem I want\nfixed ASAP\". I don't think anyone would argue this qualifies as a\nreasonable objection to a change, and we should be in a place, as a\ncommunity (never as developers or purely one group), to ignore such\nobjections and make forward progress in spite of them. We don't make\ngood engineering decisions by \"bundling\" unrelated features together to\nenable political football and compromise.\n\nI think BIP 9 (plus a well-crafted softfork) pretty effectively checks\nthe boxes for #2-4 here, and when done carefully with lots of community\nengagement and measurement, can effectively fulfill #1 as well. #5 is,\nas I'm sure everyone is aware, where it starts to fall down pretty hard.\n\nBIP 8 has been proposed as an alternative, largely in response to issues\nwith #5. However, a naive deployment of it, rather obviously, completely\nfails #1, #3, and #4, and, in my view, fails #5 as well by both giving\nan impression of, setting a precedent of, and possibly even in practice\nincreasing the ability of developers to decide the consensus rules of\nthe system. A BIP 8 deployment that more accurately measures community\nsupport as a prerequisite could arguably fulfill #1 and #5, though I'm\nunaware of any concrete proposals on how to accomplish that. Arguably, a\nsignificantly longer activation window could also allow BIP 8 to fulfill\n#3 and #4, but only by exploiting the \"needlessly\" and \"wherever\npossible\" loopholes.\n\nYou may note that, from the point of view of achieving the critical\ngoals here, BIP 8 is only different from a flag-day activation in that,\nif it takes the \"happy-path\" of activating before the flag day, it looks\nlike BIP 9, but isn't guaranteed to. It additionally has the\n\"nice-to-have\" property that activation can occur before the flag-day in\nthe case of faster miner adoption, though there is a limit of how fast\nis useful due to node adoption.\n\nThus, to strike a balance between the drawbacks of BIP 8 and BIP 9, the\nGreat Consensus Cleanup softfork proposal included this text in the\ndiscussion section (with the spec describing a BIP 9 deployment):\n\n> In spite of some suggestion that other activation methods be used, BIP\n> 9 is proposed as ensuring miners have upgraded to enforce new rules is\n> an important part of minimizing disruption. While previous BIP 9 soft-\n> forks have resulted in political contention, this comparatively-\n> unimportant soft-fork provides a good opportunity to attempt to return\n> to utilizing BIP 9 to ensure miner upgrade prior to activation, which\n> the authors believe is a critical goal. However, if there is broad\n> agreement to activate these rules when the BIP 9 expiry time is\n> reached, and miners have not yet signaled sufficient level of\n> readiness, a later flag-day activation may be merited. For this\n> reason, implementations may wish to provide a compatibility option\n> which allows flag-day enforcement of these rules without an update.\n\nUltimately, through admittedly rather limited discussion, I still like\nthis model (though I cannot claim it as my own, the original proposal\ncame from Greg Maxwell). BIP 9 only falls apart in case of unreasonable\nobjection, which, naturally, should carry a high bar to ignore, given we\nhave to have some level of agreement that it is, in fact, unreasonable\n(or untargeted). While I admit this is a possibility, I both find it\nless likely than in previous soft-forks, and even if it is the case, it\nonly slows down the process, it doesn't necessarily stop it. In the case\nthat it does fail, BIP 9 process, in fact, provides a good learning\nopportunity as to the level of community readiness and desire for a\ngiven change. While we can (and should, and are) learning a lot about\ncommunity readiness for, and acceptability of a change through outreach\nand discussion, there is something about a change with a timeframe that\nforces people to more carefully consider it.\n\nThus, as something a bit more concrete, I think an activation method\nwhich sets the right precedent and appropriately considers the above\ngoals, would be:\n\n1) a standard BIP 9 deployment with a one-year time horizon for\nactivation with 95% miner readiness,\n2) in the case that no activation occurs within a year, a six month\nquieting period during which the community can analyze and discussion\nthe reasons for no activation and,\n3) in the case that it makes sense, a simple command-line/bitcoin.conf\nparameter which was supported since the original deployment release\nwould enable users to opt into a BIP 8 deployment with a 24-month\ntime-horizon for flag-day activation (as well as a new Bitcoin Core\nrelease enabling the flag universally).\n\nThis provides a very long time horizon for more standard activation,\nwhile still ensuring the goals in #5 are met, even if, in those cases,\nthe time horizon needs to be significantly extended to meet the goals of\n#3. Developing Bitcoin is not a race. If we have to, waiting 42 months\nensures we're not setting a negative precedent that we'll come to regret\nas Bitcoin continues to grow.\n\nMatt\n\nThanks also to AJ for feedback on an earlier version of this rant."
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2020-01-10T22:21:51",
                "message_text_only": "Well, bip9 doesn't only fall apart in case of unreasonable objection,\nit also fails simply with miners' apathy.\nAnyway, your proposed plan should take care of that case too, I think.\nOverall sounds good to me.\n\nRegarding bip8-like activation, luke-jr suggested that instead of\nsimply activating on date x if failed to do so by miners' signaling, a\nconsensus rule could require the blocks to signal for activation in\nthe last activation window.\nI see 2 main advantages for this:\n\n1) Outdated nodes can implement warnings (like in bip9) and they can\nsee those warnings even if it's activated in the last activation\nwindow. Of course this can become counterproductive if miners' squat\nsignaling bits for asicboost again.\n\n2) It is easier for users to actively resist a given change they\noppose. Instead of requiring signaling, their nodes can be set to\nignore chains that activate it. This will result in a fork, but if\ndifferent groups of users want different things, this is arguably the\nbest behaviour: a \"clean\" split.\n\nI assume many people won't like this, but I really think we should\nconsider how users should ideally resist an unwanted change, even if\nthe proponents had the best intentions in mind, there may be\nlegitimate reasons to resist it that they may not have considered.\n\nOn Fri, Jan 10, 2020 at 10:30 PM Matt Corallo via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> There are a series of soft-fork designs which have recently been making\n> good progress towards implementation and future adoption. However, for\n> various reasons, activation methods therefor have gotten limited\n> discussion. I'd like to reopen that discussion here.\n>\n> It is likely worth revisiting the goals both for soft forks and their\n> activation methods to start. I'm probably missing some, but some basic\n> requirements:\n>\n> 1) Avoid activating in the face of significant, reasonable, and directed\n> objection. Period. If someone has a well-accepted, reasonable use of\n> Bitcoin that is working today, have no reason to believe wouldn't work\n> long into the future without a change, and which would be made\n> impossible or significantly more difficult by a change, that change must\n> not happen. I certainly hope there is no objection on this point (see\n> the last point for an important caveat that I'm sure everyone will jump\n> to point out).\n>\n> 2) Avoid activating within a timeframe which does not make high\n> node-level-adoption likely. As with all \"node\" arguments, I'll note that\n> I mean \"economically-used\" nodes, not the thousand or so spy nodes on\n> Google Cloud and AWS. Rule changes don't make sense without nodes\n> enforcing them, whether they happen to be a soft fork, hard fork, or a\n> blue fork, so activating in a reduced timeframe that doesn't allow for\n> large-scale node adoption doesn't have any value, and may cause other\n> unintended side effects.\n>\n> 3) Don't (needlessly) lose hashpower to un-upgraded miners. As a part of\n> Bitcoin's security comes from miners, reducing the hashpower of the\n> network as a side effect of a rule change is a needless reduction in a\n> key security parameter of the network. This is why, in recent history,\n> soft forks required 95% of hashpower to indicate that they have upgraded\n> and are capable of enforcing the new rules. Further, this is why recent\n> soft forks have not included changes which would result in a standard\n> Bitcoin Core instance mining invalid-by-new-rules changes (by relying on\n> the standardness behavior of Bitcoin Core).\n>\n> 4) Use hashpower enforcement to de-risk the upgrade process, wherever\n> possible. As a corollary of the above, one of the primary reasons we use\n> soft forks is that hashpower-based enforcement of rules is an elegant\n> way to prevent network splits during the node upgrade process. While it\n> does not make sense to invest material value in systems protected by new\n> rules until a significant majority of \"economic nodes\" is enforcing said\n> rules, hashpower lets us neatly bridge the gap in time between\n> activation and then. By having a supermajority of miners enforce the new\n> rules, attempts at violating the new rules does not result in a\n> significant network split, disrupting existing users of the system. If\n> we aren't going to take advantage of this, we should do a hard fork\n> instead, with the necessarily slow timescale that entails.\n>\n> 5) Follow the will of the community, irrespective of individuals or\n> unreasoned objection, but without ever overruling any reasonable\n> objection. Recent history also includes \"objection\" to soft forks in the\n> form of \"this is bad because it doesn't fix a different problem I want\n> fixed ASAP\". I don't think anyone would argue this qualifies as a\n> reasonable objection to a change, and we should be in a place, as a\n> community (never as developers or purely one group), to ignore such\n> objections and make forward progress in spite of them. We don't make\n> good engineering decisions by \"bundling\" unrelated features together to\n> enable political football and compromise.\n>\n> I think BIP 9 (plus a well-crafted softfork) pretty effectively checks\n> the boxes for #2-4 here, and when done carefully with lots of community\n> engagement and measurement, can effectively fulfill #1 as well. #5 is,\n> as I'm sure everyone is aware, where it starts to fall down pretty hard.\n>\n> BIP 8 has been proposed as an alternative, largely in response to issues\n> with #5. However, a naive deployment of it, rather obviously, completely\n> fails #1, #3, and #4, and, in my view, fails #5 as well by both giving\n> an impression of, setting a precedent of, and possibly even in practice\n> increasing the ability of developers to decide the consensus rules of\n> the system. A BIP 8 deployment that more accurately measures community\n> support as a prerequisite could arguably fulfill #1 and #5, though I'm\n> unaware of any concrete proposals on how to accomplish that. Arguably, a\n> significantly longer activation window could also allow BIP 8 to fulfill\n> #3 and #4, but only by exploiting the \"needlessly\" and \"wherever\n> possible\" loopholes.\n>\n> You may note that, from the point of view of achieving the critical\n> goals here, BIP 8 is only different from a flag-day activation in that,\n> if it takes the \"happy-path\" of activating before the flag day, it looks\n> like BIP 9, but isn't guaranteed to. It additionally has the\n> \"nice-to-have\" property that activation can occur before the flag-day in\n> the case of faster miner adoption, though there is a limit of how fast\n> is useful due to node adoption.\n>\n> Thus, to strike a balance between the drawbacks of BIP 8 and BIP 9, the\n> Great Consensus Cleanup softfork proposal included this text in the\n> discussion section (with the spec describing a BIP 9 deployment):\n>\n> > In spite of some suggestion that other activation methods be used, BIP\n> > 9 is proposed as ensuring miners have upgraded to enforce new rules is\n> > an important part of minimizing disruption. While previous BIP 9 soft-\n> > forks have resulted in political contention, this comparatively-\n> > unimportant soft-fork provides a good opportunity to attempt to return\n> > to utilizing BIP 9 to ensure miner upgrade prior to activation, which\n> > the authors believe is a critical goal. However, if there is broad\n> > agreement to activate these rules when the BIP 9 expiry time is\n> > reached, and miners have not yet signaled sufficient level of\n> > readiness, a later flag-day activation may be merited. For this\n> > reason, implementations may wish to provide a compatibility option\n> > which allows flag-day enforcement of these rules without an update.\n>\n> Ultimately, through admittedly rather limited discussion, I still like\n> this model (though I cannot claim it as my own, the original proposal\n> came from Greg Maxwell). BIP 9 only falls apart in case of unreasonable\n> objection, which, naturally, should carry a high bar to ignore, given we\n> have to have some level of agreement that it is, in fact, unreasonable\n> (or untargeted). While I admit this is a possibility, I both find it\n> less likely than in previous soft-forks, and even if it is the case, it\n> only slows down the process, it doesn't necessarily stop it. In the case\n> that it does fail, BIP 9 process, in fact, provides a good learning\n> opportunity as to the level of community readiness and desire for a\n> given change. While we can (and should, and are) learning a lot about\n> community readiness for, and acceptability of a change through outreach\n> and discussion, there is something about a change with a timeframe that\n> forces people to more carefully consider it.\n>\n> Thus, as something a bit more concrete, I think an activation method\n> which sets the right precedent and appropriately considers the above\n> goals, would be:\n>\n> 1) a standard BIP 9 deployment with a one-year time horizon for\n> activation with 95% miner readiness,\n> 2) in the case that no activation occurs within a year, a six month\n> quieting period during which the community can analyze and discussion\n> the reasons for no activation and,\n> 3) in the case that it makes sense, a simple command-line/bitcoin.conf\n> parameter which was supported since the original deployment release\n> would enable users to opt into a BIP 8 deployment with a 24-month\n> time-horizon for flag-day activation (as well as a new Bitcoin Core\n> release enabling the flag universally).\n>\n> This provides a very long time horizon for more standard activation,\n> while still ensuring the goals in #5 are met, even if, in those cases,\n> the time horizon needs to be significantly extended to meet the goals of\n> #3. Developing Bitcoin is not a race. If we have to, waiting 42 months\n> ensures we're not setting a negative precedent that we'll come to regret\n> as Bitcoin continues to grow.\n>\n> Matt\n>\n> Thanks also to AJ for feedback on an earlier version of this rant.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-01-10T22:43:35",
                "message_text_only": "I went back and forth with a few folks on this one. I think the fact that we lose goals 3/4 very explicitly in order to nudge miners seems like a poor trade off. I\u2019ll note that your point 2 here seems a bit disconnected to me. If you want to fork yourself off the network, you can do it in easier ways, and if miners want to maliciously censors transactions to the detriment of users, rejecting a version bit doesn\u2019t really help avoid that.\n\nYour point about upgrade warnings is well-made, but I\u2019m dubious of it\u2019s value over the network chaos many large forks might otherwise cause.\n\nMatt\n\n> On Jan 10, 2020, at 17:22, Jorge Tim\u00f3n <jtimon at jtimon.cc> wrote:\n> \n> \ufeffWell, bip9 doesn't only fall apart in case of unreasonable objection,\n> it also fails simply with miners' apathy.\n> Anyway, your proposed plan should take care of that case too, I think.\n> Overall sounds good to me.\n> \n> Regarding bip8-like activation, luke-jr suggested that instead of\n> simply activating on date x if failed to do so by miners' signaling, a\n> consensus rule could require the blocks to signal for activation in\n> the last activation window.\n> I see 2 main advantages for this:\n> \n> 1) Outdated nodes can implement warnings (like in bip9) and they can\n> see those warnings even if it's activated in the last activation\n> window. Of course this can become counterproductive if miners' squat\n> signaling bits for asicboost again.\n> \n> 2) It is easier for users to actively resist a given change they\n> oppose. Instead of requiring signaling, their nodes can be set to\n> ignore chains that activate it. This will result in a fork, but if\n> different groups of users want different things, this is arguably the\n> best behaviour: a \"clean\" split.\n> \n> I assume many people won't like this, but I really think we should\n> consider how users should ideally resist an unwanted change, even if\n> the proponents had the best intentions in mind, there may be\n> legitimate reasons to resist it that they may not have considered.\n> \n>> On Fri, Jan 10, 2020 at 10:30 PM Matt Corallo via bitcoin-dev\n>> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> \n>> There are a series of soft-fork designs which have recently been making\n>> good progress towards implementation and future adoption. However, for\n>> various reasons, activation methods therefor have gotten limited\n>> discussion. I'd like to reopen that discussion here.\n>> \n>> It is likely worth revisiting the goals both for soft forks and their\n>> activation methods to start. I'm probably missing some, but some basic\n>> requirements:\n>> \n>> 1) Avoid activating in the face of significant, reasonable, and directed\n>> objection. Period. If someone has a well-accepted, reasonable use of\n>> Bitcoin that is working today, have no reason to believe wouldn't work\n>> long into the future without a change, and which would be made\n>> impossible or significantly more difficult by a change, that change must\n>> not happen. I certainly hope there is no objection on this point (see\n>> the last point for an important caveat that I'm sure everyone will jump\n>> to point out).\n>> \n>> 2) Avoid activating within a timeframe which does not make high\n>> node-level-adoption likely. As with all \"node\" arguments, I'll note that\n>> I mean \"economically-used\" nodes, not the thousand or so spy nodes on\n>> Google Cloud and AWS. Rule changes don't make sense without nodes\n>> enforcing them, whether they happen to be a soft fork, hard fork, or a\n>> blue fork, so activating in a reduced timeframe that doesn't allow for\n>> large-scale node adoption doesn't have any value, and may cause other\n>> unintended side effects.\n>> \n>> 3) Don't (needlessly) lose hashpower to un-upgraded miners. As a part of\n>> Bitcoin's security comes from miners, reducing the hashpower of the\n>> network as a side effect of a rule change is a needless reduction in a\n>> key security parameter of the network. This is why, in recent history,\n>> soft forks required 95% of hashpower to indicate that they have upgraded\n>> and are capable of enforcing the new rules. Further, this is why recent\n>> soft forks have not included changes which would result in a standard\n>> Bitcoin Core instance mining invalid-by-new-rules changes (by relying on\n>> the standardness behavior of Bitcoin Core).\n>> \n>> 4) Use hashpower enforcement to de-risk the upgrade process, wherever\n>> possible. As a corollary of the above, one of the primary reasons we use\n>> soft forks is that hashpower-based enforcement of rules is an elegant\n>> way to prevent network splits during the node upgrade process. While it\n>> does not make sense to invest material value in systems protected by new\n>> rules until a significant majority of \"economic nodes\" is enforcing said\n>> rules, hashpower lets us neatly bridge the gap in time between\n>> activation and then. By having a supermajority of miners enforce the new\n>> rules, attempts at violating the new rules does not result in a\n>> significant network split, disrupting existing users of the system. If\n>> we aren't going to take advantage of this, we should do a hard fork\n>> instead, with the necessarily slow timescale that entails.\n>> \n>> 5) Follow the will of the community, irrespective of individuals or\n>> unreasoned objection, but without ever overruling any reasonable\n>> objection. Recent history also includes \"objection\" to soft forks in the\n>> form of \"this is bad because it doesn't fix a different problem I want\n>> fixed ASAP\". I don't think anyone would argue this qualifies as a\n>> reasonable objection to a change, and we should be in a place, as a\n>> community (never as developers or purely one group), to ignore such\n>> objections and make forward progress in spite of them. We don't make\n>> good engineering decisions by \"bundling\" unrelated features together to\n>> enable political football and compromise.\n>> \n>> I think BIP 9 (plus a well-crafted softfork) pretty effectively checks\n>> the boxes for #2-4 here, and when done carefully with lots of community\n>> engagement and measurement, can effectively fulfill #1 as well. #5 is,\n>> as I'm sure everyone is aware, where it starts to fall down pretty hard.\n>> \n>> BIP 8 has been proposed as an alternative, largely in response to issues\n>> with #5. However, a naive deployment of it, rather obviously, completely\n>> fails #1, #3, and #4, and, in my view, fails #5 as well by both giving\n>> an impression of, setting a precedent of, and possibly even in practice\n>> increasing the ability of developers to decide the consensus rules of\n>> the system. A BIP 8 deployment that more accurately measures community\n>> support as a prerequisite could arguably fulfill #1 and #5, though I'm\n>> unaware of any concrete proposals on how to accomplish that. Arguably, a\n>> significantly longer activation window could also allow BIP 8 to fulfill\n>> #3 and #4, but only by exploiting the \"needlessly\" and \"wherever\n>> possible\" loopholes.\n>> \n>> You may note that, from the point of view of achieving the critical\n>> goals here, BIP 8 is only different from a flag-day activation in that,\n>> if it takes the \"happy-path\" of activating before the flag day, it looks\n>> like BIP 9, but isn't guaranteed to. It additionally has the\n>> \"nice-to-have\" property that activation can occur before the flag-day in\n>> the case of faster miner adoption, though there is a limit of how fast\n>> is useful due to node adoption.\n>> \n>> Thus, to strike a balance between the drawbacks of BIP 8 and BIP 9, the\n>> Great Consensus Cleanup softfork proposal included this text in the\n>> discussion section (with the spec describing a BIP 9 deployment):\n>> \n>>> In spite of some suggestion that other activation methods be used, BIP\n>>> 9 is proposed as ensuring miners have upgraded to enforce new rules is\n>>> an important part of minimizing disruption. While previous BIP 9 soft-\n>>> forks have resulted in political contention, this comparatively-\n>>> unimportant soft-fork provides a good opportunity to attempt to return\n>>> to utilizing BIP 9 to ensure miner upgrade prior to activation, which\n>>> the authors believe is a critical goal. However, if there is broad\n>>> agreement to activate these rules when the BIP 9 expiry time is\n>>> reached, and miners have not yet signaled sufficient level of\n>>> readiness, a later flag-day activation may be merited. For this\n>>> reason, implementations may wish to provide a compatibility option\n>>> which allows flag-day enforcement of these rules without an update.\n>> \n>> Ultimately, through admittedly rather limited discussion, I still like\n>> this model (though I cannot claim it as my own, the original proposal\n>> came from Greg Maxwell). BIP 9 only falls apart in case of unreasonable\n>> objection, which, naturally, should carry a high bar to ignore, given we\n>> have to have some level of agreement that it is, in fact, unreasonable\n>> (or untargeted). While I admit this is a possibility, I both find it\n>> less likely than in previous soft-forks, and even if it is the case, it\n>> only slows down the process, it doesn't necessarily stop it. In the case\n>> that it does fail, BIP 9 process, in fact, provides a good learning\n>> opportunity as to the level of community readiness and desire for a\n>> given change. While we can (and should, and are) learning a lot about\n>> community readiness for, and acceptability of a change through outreach\n>> and discussion, there is something about a change with a timeframe that\n>> forces people to more carefully consider it.\n>> \n>> Thus, as something a bit more concrete, I think an activation method\n>> which sets the right precedent and appropriately considers the above\n>> goals, would be:\n>> \n>> 1) a standard BIP 9 deployment with a one-year time horizon for\n>> activation with 95% miner readiness,\n>> 2) in the case that no activation occurs within a year, a six month\n>> quieting period during which the community can analyze and discussion\n>> the reasons for no activation and,\n>> 3) in the case that it makes sense, a simple command-line/bitcoin.conf\n>> parameter which was supported since the original deployment release\n>> would enable users to opt into a BIP 8 deployment with a 24-month\n>> time-horizon for flag-day activation (as well as a new Bitcoin Core\n>> release enabling the flag universally).\n>> \n>> This provides a very long time horizon for more standard activation,\n>> while still ensuring the goals in #5 are met, even if, in those cases,\n>> the time horizon needs to be significantly extended to meet the goals of\n>> #3. Developing Bitcoin is not a race. If we have to, waiting 42 months\n>> ensures we're not setting a negative precedent that we'll come to regret\n>> as Bitcoin continues to grow.\n>> \n>> Matt\n>> \n>> Thanks also to AJ for feedback on an earlier version of this rant.\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2020-01-10T23:07:00",
                "message_text_only": "I see how your approach doesn't lose goal 3 while \"mine\" does.\nRegarding goal 4, I don't think any of the approaches loses it. \"Use\nhashpower enforcement to de-risk the upgrade process, wherever\npossible\".\nWell, in the case of activation while there's \"many\" non upgrade\nminers, they simply can't help to reduce upgrade risks unless they\nupgrade. It doesn't matter if the activation is silent or with\nmandatory signaling. Am I missing something?\n\n>  in order to nudge miners\n\nThat's not the goal at all. All my arguments have been focused on\nusers, not miners.\n\n> If you want to fork yourself off the network, you can do it in easier ways,\n\nWell, it's not that you want to fork yourself off the network, is that\nyou don't want change X. Ideally change X wouldn't be activated, but\nif it is, you prefer to be in a chain without change X.\nLet's say we're using your system to deploy change X you oppose for\nlegitimate reasons.\nWhat easier thing would you do as a user to resist change X with all\nother users who also oppose it?\n\nIf there are simpler and better ways to do this, great. It's just\nsomething to think about.\n\n\n\n\n\nOn Fri, Jan 10, 2020 at 11:43 PM Matt Corallo <lf-lists at mattcorallo.com> wrote:\n>\n> I went back and forth with a few folks on this one. I think the fact that we lose goals 3/4 very explicitly in order to nudge miners seems like a poor trade off. I\u2019ll note that your point 2 here seems a bit disconnected to me. If you want to fork yourself off the network, you can do it in easier ways, and if miners want to maliciously censors transactions to the detriment of users, rejecting a version bit doesn\u2019t really help avoid that.\n>\n> Your point about upgrade warnings is well-made, but I\u2019m dubious of it\u2019s value over the network chaos many large forks might otherwise cause.\n>\n> Matt\n>\n> > On Jan 10, 2020, at 17:22, Jorge Tim\u00f3n <jtimon at jtimon.cc> wrote:\n> >\n> > \ufeffWell, bip9 doesn't only fall apart in case of unreasonable objection,\n> > it also fails simply with miners' apathy.\n> > Anyway, your proposed plan should take care of that case too, I think.\n> > Overall sounds good to me.\n> >\n> > Regarding bip8-like activation, luke-jr suggested that instead of\n> > simply activating on date x if failed to do so by miners' signaling, a\n> > consensus rule could require the blocks to signal for activation in\n> > the last activation window.\n> > I see 2 main advantages for this:\n> >\n> > 1) Outdated nodes can implement warnings (like in bip9) and they can\n> > see those warnings even if it's activated in the last activation\n> > window. Of course this can become counterproductive if miners' squat\n> > signaling bits for asicboost again.\n> >\n> > 2) It is easier for users to actively resist a given change they\n> > oppose. Instead of requiring signaling, their nodes can be set to\n> > ignore chains that activate it. This will result in a fork, but if\n> > different groups of users want different things, this is arguably the\n> > best behaviour: a \"clean\" split.\n> >\n> > I assume many people won't like this, but I really think we should\n> > consider how users should ideally resist an unwanted change, even if\n> > the proponents had the best intentions in mind, there may be\n> > legitimate reasons to resist it that they may not have considered.\n> >\n> >> On Fri, Jan 10, 2020 at 10:30 PM Matt Corallo via bitcoin-dev\n> >> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >>\n> >> There are a series of soft-fork designs which have recently been making\n> >> good progress towards implementation and future adoption. However, for\n> >> various reasons, activation methods therefor have gotten limited\n> >> discussion. I'd like to reopen that discussion here.\n> >>\n> >> It is likely worth revisiting the goals both for soft forks and their\n> >> activation methods to start. I'm probably missing some, but some basic\n> >> requirements:\n> >>\n> >> 1) Avoid activating in the face of significant, reasonable, and directed\n> >> objection. Period. If someone has a well-accepted, reasonable use of\n> >> Bitcoin that is working today, have no reason to believe wouldn't work\n> >> long into the future without a change, and which would be made\n> >> impossible or significantly more difficult by a change, that change must\n> >> not happen. I certainly hope there is no objection on this point (see\n> >> the last point for an important caveat that I'm sure everyone will jump\n> >> to point out).\n> >>\n> >> 2) Avoid activating within a timeframe which does not make high\n> >> node-level-adoption likely. As with all \"node\" arguments, I'll note that\n> >> I mean \"economically-used\" nodes, not the thousand or so spy nodes on\n> >> Google Cloud and AWS. Rule changes don't make sense without nodes\n> >> enforcing them, whether they happen to be a soft fork, hard fork, or a\n> >> blue fork, so activating in a reduced timeframe that doesn't allow for\n> >> large-scale node adoption doesn't have any value, and may cause other\n> >> unintended side effects.\n> >>\n> >> 3) Don't (needlessly) lose hashpower to un-upgraded miners. As a part of\n> >> Bitcoin's security comes from miners, reducing the hashpower of the\n> >> network as a side effect of a rule change is a needless reduction in a\n> >> key security parameter of the network. This is why, in recent history,\n> >> soft forks required 95% of hashpower to indicate that they have upgraded\n> >> and are capable of enforcing the new rules. Further, this is why recent\n> >> soft forks have not included changes which would result in a standard\n> >> Bitcoin Core instance mining invalid-by-new-rules changes (by relying on\n> >> the standardness behavior of Bitcoin Core).\n> >>\n> >> 4) Use hashpower enforcement to de-risk the upgrade process, wherever\n> >> possible. As a corollary of the above, one of the primary reasons we use\n> >> soft forks is that hashpower-based enforcement of rules is an elegant\n> >> way to prevent network splits during the node upgrade process. While it\n> >> does not make sense to invest material value in systems protected by new\n> >> rules until a significant majority of \"economic nodes\" is enforcing said\n> >> rules, hashpower lets us neatly bridge the gap in time between\n> >> activation and then. By having a supermajority of miners enforce the new\n> >> rules, attempts at violating the new rules does not result in a\n> >> significant network split, disrupting existing users of the system. If\n> >> we aren't going to take advantage of this, we should do a hard fork\n> >> instead, with the necessarily slow timescale that entails.\n> >>\n> >> 5) Follow the will of the community, irrespective of individuals or\n> >> unreasoned objection, but without ever overruling any reasonable\n> >> objection. Recent history also includes \"objection\" to soft forks in the\n> >> form of \"this is bad because it doesn't fix a different problem I want\n> >> fixed ASAP\". I don't think anyone would argue this qualifies as a\n> >> reasonable objection to a change, and we should be in a place, as a\n> >> community (never as developers or purely one group), to ignore such\n> >> objections and make forward progress in spite of them. We don't make\n> >> good engineering decisions by \"bundling\" unrelated features together to\n> >> enable political football and compromise.\n> >>\n> >> I think BIP 9 (plus a well-crafted softfork) pretty effectively checks\n> >> the boxes for #2-4 here, and when done carefully with lots of community\n> >> engagement and measurement, can effectively fulfill #1 as well. #5 is,\n> >> as I'm sure everyone is aware, where it starts to fall down pretty hard.\n> >>\n> >> BIP 8 has been proposed as an alternative, largely in response to issues\n> >> with #5. However, a naive deployment of it, rather obviously, completely\n> >> fails #1, #3, and #4, and, in my view, fails #5 as well by both giving\n> >> an impression of, setting a precedent of, and possibly even in practice\n> >> increasing the ability of developers to decide the consensus rules of\n> >> the system. A BIP 8 deployment that more accurately measures community\n> >> support as a prerequisite could arguably fulfill #1 and #5, though I'm\n> >> unaware of any concrete proposals on how to accomplish that. Arguably, a\n> >> significantly longer activation window could also allow BIP 8 to fulfill\n> >> #3 and #4, but only by exploiting the \"needlessly\" and \"wherever\n> >> possible\" loopholes.\n> >>\n> >> You may note that, from the point of view of achieving the critical\n> >> goals here, BIP 8 is only different from a flag-day activation in that,\n> >> if it takes the \"happy-path\" of activating before the flag day, it looks\n> >> like BIP 9, but isn't guaranteed to. It additionally has the\n> >> \"nice-to-have\" property that activation can occur before the flag-day in\n> >> the case of faster miner adoption, though there is a limit of how fast\n> >> is useful due to node adoption.\n> >>\n> >> Thus, to strike a balance between the drawbacks of BIP 8 and BIP 9, the\n> >> Great Consensus Cleanup softfork proposal included this text in the\n> >> discussion section (with the spec describing a BIP 9 deployment):\n> >>\n> >>> In spite of some suggestion that other activation methods be used, BIP\n> >>> 9 is proposed as ensuring miners have upgraded to enforce new rules is\n> >>> an important part of minimizing disruption. While previous BIP 9 soft-\n> >>> forks have resulted in political contention, this comparatively-\n> >>> unimportant soft-fork provides a good opportunity to attempt to return\n> >>> to utilizing BIP 9 to ensure miner upgrade prior to activation, which\n> >>> the authors believe is a critical goal. However, if there is broad\n> >>> agreement to activate these rules when the BIP 9 expiry time is\n> >>> reached, and miners have not yet signaled sufficient level of\n> >>> readiness, a later flag-day activation may be merited. For this\n> >>> reason, implementations may wish to provide a compatibility option\n> >>> which allows flag-day enforcement of these rules without an update.\n> >>\n> >> Ultimately, through admittedly rather limited discussion, I still like\n> >> this model (though I cannot claim it as my own, the original proposal\n> >> came from Greg Maxwell). BIP 9 only falls apart in case of unreasonable\n> >> objection, which, naturally, should carry a high bar to ignore, given we\n> >> have to have some level of agreement that it is, in fact, unreasonable\n> >> (or untargeted). While I admit this is a possibility, I both find it\n> >> less likely than in previous soft-forks, and even if it is the case, it\n> >> only slows down the process, it doesn't necessarily stop it. In the case\n> >> that it does fail, BIP 9 process, in fact, provides a good learning\n> >> opportunity as to the level of community readiness and desire for a\n> >> given change. While we can (and should, and are) learning a lot about\n> >> community readiness for, and acceptability of a change through outreach\n> >> and discussion, there is something about a change with a timeframe that\n> >> forces people to more carefully consider it.\n> >>\n> >> Thus, as something a bit more concrete, I think an activation method\n> >> which sets the right precedent and appropriately considers the above\n> >> goals, would be:\n> >>\n> >> 1) a standard BIP 9 deployment with a one-year time horizon for\n> >> activation with 95% miner readiness,\n> >> 2) in the case that no activation occurs within a year, a six month\n> >> quieting period during which the community can analyze and discussion\n> >> the reasons for no activation and,\n> >> 3) in the case that it makes sense, a simple command-line/bitcoin.conf\n> >> parameter which was supported since the original deployment release\n> >> would enable users to opt into a BIP 8 deployment with a 24-month\n> >> time-horizon for flag-day activation (as well as a new Bitcoin Core\n> >> release enabling the flag universally).\n> >>\n> >> This provides a very long time horizon for more standard activation,\n> >> while still ensuring the goals in #5 are met, even if, in those cases,\n> >> the time horizon needs to be significantly extended to meet the goals of\n> >> #3. Developing Bitcoin is not a race. If we have to, waiting 42 months\n> >> ensures we're not setting a negative precedent that we'll come to regret\n> >> as Bitcoin continues to grow.\n> >>\n> >> Matt\n> >>\n> >> Thanks also to AJ for feedback on an earlier version of this rant.\n> >> _______________________________________________\n> >> bitcoin-dev mailing list\n> >> bitcoin-dev at lists.linuxfoundation.org\n> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Anthony Towns",
                "date": "2020-01-11T14:42:07",
                "message_text_only": "On Fri, Jan 10, 2020 at 09:30:09PM +0000, Matt Corallo via bitcoin-dev wrote:\n> 1) a standard BIP 9 deployment with a one-year time horizon for\n> activation with 95% miner readiness,\n> 2) in the case that no activation occurs within a year, a six month\n> quieting period during which the community can analyze and discussion\n> the reasons for no activation and,\n> 3) in the case that it makes sense, a simple command-line/bitcoin.conf\n> parameter which was supported since the original deployment release\n> would enable users to opt into a BIP 8 deployment with a 24-month\n> time-horizon for flag-day activation (as well as a new Bitcoin Core\n> release enabling the flag universally).\n\nFWIW etc, but my perspective on this is that the way we want consensus\nchanges in Bitcoin to work is:\n\n - decentralised: we want everyone to be able to participate, in\n   designing/promoting/reviewing changes, without decision making\n   power getting centralised amongst one group or another\n\n - technical: we want changes to be judged on their objective technical\n   merits; politics and animal spirits and the like are fine, especially\n   for working out what to prioritise, but they shouldn't be part of the\n   final yes/no decision on consensus changes\n\n - improvements: changes might not make everyone better off, but we\n   don't want changes to screw anyone over either -- pareto\n   improvements in economics, \"first, do no harm\", etc. (if we get this\n   right, there's no need to make compromises and bundle multiple\n   flawed proposals so that everyone's an equal mix of happy and\n   miserable)\n\nIn particular, we don't want to misalign skills and responsibilities: it's\nfine for developers to judge if a proposal has bugs or technical problems,\nbut we don't want want developers to have to decide if a proposal is\n\"sufficiently popular\" or \"economically sound\" and the like, for instance.\nLikewise we don't want to have miners or pool operators have to take\nresponsibility for managing the whole economy, rather than just keeping\ntheir systems running.\n\nSo the way I hope this will work out is:\n\n - investors, industry, people in general work out priorities for what's\n   valuable to work on; this is an economic/policy/subjective question,\n   that everyone can participate in, and everyone can act on --\n   either directly if they're developers who can work on proposals and\n   implementations directly, or indirectly by persuading or paying other\n   people to work on whatever's important\n\n - developers work on proposals, designing and implementing them to make\n   (some subset of) bitcoin users better off, and to not make anyone worse\n   off.\n\n - if someone discovers a good technical reason why a proposal does make\n   people worse off, we don't try to keep pushing the proposal over the\n   top of objections, but go back to the drawing board and try to fix\n   the problems\n\n - once we've done as much development as we can, including setting up\n   experimental testnet/signet style deployments for testing, we setup a\n   deployment. the idea at this point is to make sure the live network\n   upgrade works, and to retain the ability to abort if last minute\n   problems come up. no doubt some review and testing will be left until\n   the last minute and only done here, but *ideally* the focus should be\n   on catching errors *well before* this point.\n\n - as a result, the activation strategy mostly needs to be about ensuring\n   that the Bitcoin network stays in consensus, rather than checking\n   popularity or voting -- the yes/no decisions should have mostly been\n   made earlier already. so we have two strategies for locking in the\n   upgrade: either 95%+ of hashpower signals that they've upgraded to\n   software that will enforce the changes forever more, _or_ after a\n   year of trying to deploy, we fail to find any technical problems,\n   and then allow an additional 2.5 years to ensure all node software is\n   upgraded to enforce the new rules before locking them in.\n\nThe strategy behind the last point is that we need to establish that\nthere's consensus amongst all of Bitcoin before we commit to a flag day,\nand if we've found some method to establish consensus on that, then we're\ndone -- we've already got consensus, we don't need to put a blockchain\nprotocol on top of that and signal that we've got consensus. (Activating\nvia hashpower still needs signalling, because we need to coordinate on\n*when* sufficient hashpower has upgraded)\n\nThis approach is obviously compatible with BIP-148 or BIP-91 style\nforced-signalling UASFs if some upgrade does need to be done urgently\ndespite miner opposition; the forced signalling just needs to occur during\nthe BIP-9 or BIP-8 phases, and no during the \"quiet period\". Probably the\nfirst period of BIP-8 after the quiet period would make the most sense.\n\nBut without that, this approach seems very friendly for miners: even\nif they don't upgrade, they won't mine invalid blocks (unless the rules\nactivate and someone else deliberately mines an invalid block and they\nbuild on top of it), and if a change is incompatible with, say 10%\nof hashpower, it won't be forced on them for 3.5 years, by which point\nit's probably a good bet that everyone's upgrading to a new generation\nof mining hardware anyway. But even that's a backstop, because if a\nchange *is* incompatible with existing mining hardware, that's an easily\ndescribable technical problem that should mean we go back to the drawing\nboard and fix it, not deploy the change despite the problems. [0]\n\nOn Fri, Jan 10, 2020 at 11:21:51PM +0100, Jorge Tim\u00f3n via bitcoin-dev wrote:\n> Regarding bip8-like activation, luke-jr suggested that [..] a\n> consensus rule could require the blocks to signal for activation in\n> the last activation window.\n\nFWIW, that had been my (strong) preference too, but I think I'm now\nconvinced it's not needed/useful.\n\n> I see 2 main advantages for this:\n> 1) Outdated nodes can implement warnings (like in bip9) and they can\n> see those warnings even if it's activated in the last activation\n> window.\n\nThe 3.5 year window from BIP-9-starttime to BIP-8-flagday means you'd\nhave to be using *very* out of date software to need to autodetect\nunknown upgrades. If an upgrade starts on 2021-01-01 say, it'd be\nsupported by 0.21.x, 0.22.0, and 0.23.0 (with bip8 as an opt-in) and\n0.24.0, 0.25.0, 0.26.0, 0.27.0, and 0.28.0 (with bip8 as always on)\nbefore flag day activation on 2024-06-01.\n\n0.21.x to 0.23.x could warn if they see potential early BIP-8 activation\nvia versionbits, and also warn if the flag day date is seen saying \"flag\nday activation may have happened, please check external sources and\nconsider upgrading your node software\".\n\nSo you'd need to be running 0.20.x, released 4 years prior to the\nactivation to be outdated enough to not get warnings, I think.\n\n> 2) It is easier for users to actively resist a given change they\n> oppose. Instead of requiring signaling, their nodes can be set to\n> ignore chains that activate it. This will result in a fork, but if\n> different groups of users want different things, this is arguably the\n> best behaviour: a \"clean\" split.\n\nIf you're knowingly doing a deliberate minority chain split, you'll\nalmost certainly change the PoW function, and trivially get a clean\nsplit as a result of doing that.\n\nBut I think what we want is to move away from consensus decisions being a\n\"who has the most money/power/hashpower/nodes/reddit-accounts\" contest\nto being a question of \"have we dealt with every reasonable technical\nobjection?\" -- I think that's better for decentralisation in that anyone\ncan stop a bad proposal without having to be rich/powerful/persuasive,\nand better for encouraging constructive contributions. \n\nThe other side to this is that if it's just a matter of resolving\ntechnical problems, then it's also straightforward for a small but skilled\ngroup to get a consensus change through even if the vast majority doesn't\nthink it's a priority -- they just need to make a good proposal, make\nsure it doesn't make people worse off, work through all the objections\npeople find, and be willing to wait for it to go through reviews and\nupgrade steps which may take extra time if other people don't think it's\na high priority. But those are all just technical challenges, that can\nbe resolved with skill and patience, whoever you might be. So to me,\nthat's a win for decentralisation as well.\n\n> I assume many people won't like this, but I really think we should\n> consider how users should ideally resist an unwanted change, even if\n> the proponents had the best intentions in mind, there may be\n> legitimate reasons to resist it that they may not have considered.\n\nFor me, the focus there is on Matt's first point: \"avoid activating\n[or merging, or even proposing] in the face of significant, reasonable,\nand directed objection\". If you want to stop a change you should have to\ndo nothing more than describe the problems with it; and if there aren't\nproblems with it, you shouldn't be trying to stop the change.\n\n(A benefit to having the BIP-8 settings defined simultaneously with\nthe initial activation attempt is that it means that if the core\ndevs/maintainers go crazy with power and try to force/prevent the BIP-8\nactivation despite clear community consensus going the other way, then\nit will be easy to for the client, and set the parameter correctly --\nliterally just a matter of changing a value in chainparams.cpp, unlike the\ndifficulties of changing the blocksize from 1MB to 2MB. Other variations\nof this overall approach have the same benefit)\n\nCheers,\naj (very grateful to Greg and Matt for explaining a lot of thing\n    about this approach and helping resolve my concerns with it)\n\n[0] Trigger warning, PTSD over the 2015-2017 blocksize wars...\n\n    The segwit timeline was something like this:\n\n     2015-05 - blocksize debate begins on bitcoin-dev\n     2015-08 - bitcoin xt with bip101 hardfork released\n     2015-09 - scaling bitcoin phase 1\n     2015-12 - segwit proposal at scaling bitcoin phase 2\n     2016-01 - segwit testnet launched\n     2016-02 - bitcoin classic with bip109 hardfork released\n     2016-04 - first release (0.12.1) with a bip9 deployment (csv)\n     2016-06 - segwit merged\n     2016-07 - csv activated\n     2016-10 - first release (0.13.1) with segwit activation params\n     2016-11 - segwit activation starttime\n     2017-02 - UASF first proposed\n     2017-03 - antpool to swith to bitcoin unlimited\n     2017-04 - covert ASICBoost vs segwit conflict described\n     2017-05 - NY segwit2x agreement, btc1 with bip102 hardfork started\n     2017-05 - BIP-91 proposed\n     2017-06 - UAHF proposal from bitmain that became BCH\n     2017-07 - BIP-91 lockin\n     2017-08 - BIP-148 activation\n     2017-08 - BCH chainsplit\n     2017-08 - segwit lockin and activation\n     2017-11 - 2x fork called off; btc1 nodes stall; 2x chain stillborn\n     2018-02 - first release (0.16.0) with segwit wallet support\n\n    (That's about 33 months in total, compared to the 24 months we've\n    already spent since taproot was first described in Jan 2018, or the\n    42 months before flag-day activation in Matt's proposal)\n\n    I don't think that timeline is a good example of how things should\n    work, and would call out a few mistakes in particular:\n\n     * too much urgency to increase the blocksize resulting in rushed\n       decision making, especially for the hardfork implementations, but\n       also for segwit\n\n     * alternative clients attempted to activate forks without\n       resolving technical problems (eventually resulting in the btc1\n       client stalling prior to the expected hard fork block, eg)\n\n     * a lot of emphasis was on numbers (market share, hashpower, etc)\n       rather than technical merits, resulting in a lot of false\n       signalling an political meaneuvering\n\n     * the incompatibility between ASICBoost and segwit wasn't noticed\n       prior to activation, and wasn't fixed when it was noticed\n       (certainly you can justify this as a tit-for-tat response to the\n       other errors having been made in bad faith, or as not being a real\n       problem because everyone claimed that they weren't doing covert\n       ASICBoost, but considered on its own I think the incompatibility\n       should have been resolved)\n\n     * the UASF approach had significant potential technical problems\n       (potential for long reorgs, p2p network splits) that weren't\n       resolved by the time it became active. happily, this was mitigated\n       by hashpower enforcement of BIP-148 rules via BIP-91. neither\n       BIP-148 or BIP-91 gained enough consensus to be supported in\n       bitcoin core though\n\n    I don't personally think we need to fix every problem we had with\n    segwit's process -- it eventually mostly worked out okay, after all --\n    but I think Matt's approach has a good chance of fixing a lot of\n    them, while still leaving us flexibility to deal with whatever new\n    problems we come up with in their place."
            },
            {
                "author": "Luke Dashjr",
                "date": "2020-01-12T05:58:33",
                "message_text_only": "On Saturday 11 January 2020 14:42:07 Anthony Towns wrote:\n>  the UASF approach had significant potential technical problems\n> \u00a0 \u00a0 \u00a0 \u00a0(potential for long reorgs, p2p network splits) that weren't\n> \u00a0 \u00a0 \u00a0 \u00a0resolved by the time it became active.\n\nLong reorgs, only for old nodes, were a possibility, but not a problem.\n\nThe p2p network split issues WERE resolved well before activation.\n(In fact, Bitcoin Knots still ships with the general p2p fixes.)\n\n> \u00a0 \u00a0 \u00a0 \u00a0neither \n> \u00a0 \u00a0 \u00a0 \u00a0BIP-148 or BIP-91 gained enough consensus to be supported in\n> \u00a0 \u00a0 \u00a0 \u00a0bitcoin core though\n\nThere was no measurable difference in community support between BIP148 and \nSegwit itself, months before BIP148's activation. (There was about 20% that \nindicated they would support BIP148 \"only if Bitcoin Core releases it\", which \nIMO \"counts\" in this context.)\n\nThe only difference was in the opinions of developers. Basing the decision to \nexclude BIP148 as even an *option* on this basis was IMO improper and \nshouldn't be repeated. The community's readiness to switch to another \nfork/build for UASFs is also valuable, but shouldn't be necessary.\n\nLuke"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-01-14T19:42:07",
                "message_text_only": "In general, your thoughts on the theory of how consensus changes should\nwork I strongly agree with. However, my one significant disagreement is\nhow practical it is for things to *actually* work that way. While I wish\necosystem players (both businesses and users) spent their time\ninteracting with the Bitcoin development community enough that they had\na deep understanding of upcoming protocol change designs, it just isn't\nrealistic to expect that. Thus, having an \"out\" to avoid activation\nafter a release has been cut with fork activation logic is quite a\ncompelling requirement.\n\nThus, part of the goal here is that we ensure we have that \"out\", and\ncan observe the response of the ecosystem once the change is \"staring\nthem in the face\", as it were. A BIP 9 process is here not only to offer\na compelling activation path, but *also* to allow for observation and\ndiscussion time for any lingering minor objections prior to a BIP 8/flag\nday activation.\n\nAs for a \"mandatory signaling period\" as a part of BIP 8, I find this\nidea strange both in that it flies in the face of all recent soft fork\ndesign work, and because it doesn't actually accomplish its stated goal.\n\nRecent soft-fork design has all been about how to design something with\nminimal ecosystem impact. Certainly in the 95% activation case I can't\nsay I feel strongly, but if you actually *hit* the BIP 8 flag day,\ndeliberately causing significant network forks for old clients has the\npotential to cause real ecosystem risk. While part of the reason for a\n24-month time horizon between BIP 8 decision and flag-day activation\nendeavors to de-risk the chance that major players are running on\nun-upgraded nodes, you cannot ignore the reality of them, both full-,\nand SPV-clients.\n\nOn the other hand, in practice, we've seen that version bits are set on\nthe pool side, and not on the node side, meaning the goal of ensuring\nminers have upgraded isn't really accomplished in practice, you just end\nup forking the chain for no gain.\n\nMatt\n\nOn 1/11/20 2:42 PM, Anthony Towns wrote:\n> On Fri, Jan 10, 2020 at 09:30:09PM +0000, Matt Corallo via bitcoin-dev wrote:\n>> 1) a standard BIP 9 deployment with a one-year time horizon for\n>> activation with 95% miner readiness,\n>> 2) in the case that no activation occurs within a year, a six month\n>> quieting period during which the community can analyze and discussion\n>> the reasons for no activation and,\n>> 3) in the case that it makes sense, a simple command-line/bitcoin.conf\n>> parameter which was supported since the original deployment release\n>> would enable users to opt into a BIP 8 deployment with a 24-month\n>> time-horizon for flag-day activation (as well as a new Bitcoin Core\n>> release enabling the flag universally).\n> \n> FWIW etc, but my perspective on this is that the way we want consensus\n> changes in Bitcoin to work is:\n> \n>  - decentralised: we want everyone to be able to participate, in\n>    designing/promoting/reviewing changes, without decision making\n>    power getting centralised amongst one group or another\n> \n>  - technical: we want changes to be judged on their objective technical\n>    merits; politics and animal spirits and the like are fine, especially\n>    for working out what to prioritise, but they shouldn't be part of the\n>    final yes/no decision on consensus changes\n> \n>  - improvements: changes might not make everyone better off, but we\n>    don't want changes to screw anyone over either -- pareto\n>    improvements in economics, \"first, do no harm\", etc. (if we get this\n>    right, there's no need to make compromises and bundle multiple\n>    flawed proposals so that everyone's an equal mix of happy and\n>    miserable)\n> \n> In particular, we don't want to misalign skills and responsibilities: it's\n> fine for developers to judge if a proposal has bugs or technical problems,\n> but we don't want want developers to have to decide if a proposal is\n> \"sufficiently popular\" or \"economically sound\" and the like, for instance.\n> Likewise we don't want to have miners or pool operators have to take\n> responsibility for managing the whole economy, rather than just keeping\n> their systems running.\n> \n> So the way I hope this will work out is:\n> \n>  - investors, industry, people in general work out priorities for what's\n>    valuable to work on; this is an economic/policy/subjective question,\n>    that everyone can participate in, and everyone can act on --\n>    either directly if they're developers who can work on proposals and\n>    implementations directly, or indirectly by persuading or paying other\n>    people to work on whatever's important\n> \n>  - developers work on proposals, designing and implementing them to make\n>    (some subset of) bitcoin users better off, and to not make anyone worse\n>    off.\n> \n>  - if someone discovers a good technical reason why a proposal does make\n>    people worse off, we don't try to keep pushing the proposal over the\n>    top of objections, but go back to the drawing board and try to fix\n>    the problems\n> \n>  - once we've done as much development as we can, including setting up\n>    experimental testnet/signet style deployments for testing, we setup a\n>    deployment. the idea at this point is to make sure the live network\n>    upgrade works, and to retain the ability to abort if last minute\n>    problems come up. no doubt some review and testing will be left until\n>    the last minute and only done here, but *ideally* the focus should be\n>    on catching errors *well before* this point.\n> \n>  - as a result, the activation strategy mostly needs to be about ensuring\n>    that the Bitcoin network stays in consensus, rather than checking\n>    popularity or voting -- the yes/no decisions should have mostly been\n>    made earlier already. so we have two strategies for locking in the\n>    upgrade: either 95%+ of hashpower signals that they've upgraded to\n>    software that will enforce the changes forever more, _or_ after a\n>    year of trying to deploy, we fail to find any technical problems,\n>    and then allow an additional 2.5 years to ensure all node software is\n>    upgraded to enforce the new rules before locking them in.\n> \n> The strategy behind the last point is that we need to establish that\n> there's consensus amongst all of Bitcoin before we commit to a flag day,\n> and if we've found some method to establish consensus on that, then we're\n> done -- we've already got consensus, we don't need to put a blockchain\n> protocol on top of that and signal that we've got consensus. (Activating\n> via hashpower still needs signalling, because we need to coordinate on\n> *when* sufficient hashpower has upgraded)\n> \n> This approach is obviously compatible with BIP-148 or BIP-91 style\n> forced-signalling UASFs if some upgrade does need to be done urgently\n> despite miner opposition; the forced signalling just needs to occur during\n> the BIP-9 or BIP-8 phases, and no during the \"quiet period\". Probably the\n> first period of BIP-8 after the quiet period would make the most sense.\n> \n> But without that, this approach seems very friendly for miners: even\n> if they don't upgrade, they won't mine invalid blocks (unless the rules\n> activate and someone else deliberately mines an invalid block and they\n> build on top of it), and if a change is incompatible with, say 10%\n> of hashpower, it won't be forced on them for 3.5 years, by which point\n> it's probably a good bet that everyone's upgrading to a new generation\n> of mining hardware anyway. But even that's a backstop, because if a\n> change *is* incompatible with existing mining hardware, that's an easily\n> describable technical problem that should mean we go back to the drawing\n> board and fix it, not deploy the change despite the problems. [0]\n> \n> On Fri, Jan 10, 2020 at 11:21:51PM +0100, Jorge Tim\u00f3n via bitcoin-dev wrote:\n>> Regarding bip8-like activation, luke-jr suggested that [..] a\n>> consensus rule could require the blocks to signal for activation in\n>> the last activation window.\n> \n> FWIW, that had been my (strong) preference too, but I think I'm now\n> convinced it's not needed/useful.\n> \n>> I see 2 main advantages for this:\n>> 1) Outdated nodes can implement warnings (like in bip9) and they can\n>> see those warnings even if it's activated in the last activation\n>> window.\n> \n> The 3.5 year window from BIP-9-starttime to BIP-8-flagday means you'd\n> have to be using *very* out of date software to need to autodetect\n> unknown upgrades. If an upgrade starts on 2021-01-01 say, it'd be\n> supported by 0.21.x, 0.22.0, and 0.23.0 (with bip8 as an opt-in) and\n> 0.24.0, 0.25.0, 0.26.0, 0.27.0, and 0.28.0 (with bip8 as always on)\n> before flag day activation on 2024-06-01.\n> \n> 0.21.x to 0.23.x could warn if they see potential early BIP-8 activation\n> via versionbits, and also warn if the flag day date is seen saying \"flag\n> day activation may have happened, please check external sources and\n> consider upgrading your node software\".\n> \n> So you'd need to be running 0.20.x, released 4 years prior to the\n> activation to be outdated enough to not get warnings, I think.\n> \n>> 2) It is easier for users to actively resist a given change they\n>> oppose. Instead of requiring signaling, their nodes can be set to\n>> ignore chains that activate it. This will result in a fork, but if\n>> different groups of users want different things, this is arguably the\n>> best behaviour: a \"clean\" split.\n> \n> If you're knowingly doing a deliberate minority chain split, you'll\n> almost certainly change the PoW function, and trivially get a clean\n> split as a result of doing that.\n> \n> But I think what we want is to move away from consensus decisions being a\n> \"who has the most money/power/hashpower/nodes/reddit-accounts\" contest\n> to being a question of \"have we dealt with every reasonable technical\n> objection?\" -- I think that's better for decentralisation in that anyone\n> can stop a bad proposal without having to be rich/powerful/persuasive,\n> and better for encouraging constructive contributions. \n> \n> The other side to this is that if it's just a matter of resolving\n> technical problems, then it's also straightforward for a small but skilled\n> group to get a consensus change through even if the vast majority doesn't\n> think it's a priority -- they just need to make a good proposal, make\n> sure it doesn't make people worse off, work through all the objections\n> people find, and be willing to wait for it to go through reviews and\n> upgrade steps which may take extra time if other people don't think it's\n> a high priority. But those are all just technical challenges, that can\n> be resolved with skill and patience, whoever you might be. So to me,\n> that's a win for decentralisation as well.\n> \n>> I assume many people won't like this, but I really think we should\n>> consider how users should ideally resist an unwanted change, even if\n>> the proponents had the best intentions in mind, there may be\n>> legitimate reasons to resist it that they may not have considered.\n> \n> For me, the focus there is on Matt's first point: \"avoid activating\n> [or merging, or even proposing] in the face of significant, reasonable,\n> and directed objection\". If you want to stop a change you should have to\n> do nothing more than describe the problems with it; and if there aren't\n> problems with it, you shouldn't be trying to stop the change.\n> \n> (A benefit to having the BIP-8 settings defined simultaneously with\n> the initial activation attempt is that it means that if the core\n> devs/maintainers go crazy with power and try to force/prevent the BIP-8\n> activation despite clear community consensus going the other way, then\n> it will be easy to for the client, and set the parameter correctly --\n> literally just a matter of changing a value in chainparams.cpp, unlike the\n> difficulties of changing the blocksize from 1MB to 2MB. Other variations\n> of this overall approach have the same benefit)\n> \n> Cheers,\n> aj (very grateful to Greg and Matt for explaining a lot of thing\n>     about this approach and helping resolve my concerns with it)\n> \n> [0] Trigger warning, PTSD over the 2015-2017 blocksize wars...\n> \n>     The segwit timeline was something like this:\n> \n>      2015-05 - blocksize debate begins on bitcoin-dev\n>      2015-08 - bitcoin xt with bip101 hardfork released\n>      2015-09 - scaling bitcoin phase 1\n>      2015-12 - segwit proposal at scaling bitcoin phase 2\n>      2016-01 - segwit testnet launched\n>      2016-02 - bitcoin classic with bip109 hardfork released\n>      2016-04 - first release (0.12.1) with a bip9 deployment (csv)\n>      2016-06 - segwit merged\n>      2016-07 - csv activated\n>      2016-10 - first release (0.13.1) with segwit activation params\n>      2016-11 - segwit activation starttime\n>      2017-02 - UASF first proposed\n>      2017-03 - antpool to swith to bitcoin unlimited\n>      2017-04 - covert ASICBoost vs segwit conflict described\n>      2017-05 - NY segwit2x agreement, btc1 with bip102 hardfork started\n>      2017-05 - BIP-91 proposed\n>      2017-06 - UAHF proposal from bitmain that became BCH\n>      2017-07 - BIP-91 lockin\n>      2017-08 - BIP-148 activation\n>      2017-08 - BCH chainsplit\n>      2017-08 - segwit lockin and activation\n>      2017-11 - 2x fork called off; btc1 nodes stall; 2x chain stillborn\n>      2018-02 - first release (0.16.0) with segwit wallet support\n> \n>     (That's about 33 months in total, compared to the 24 months we've\n>     already spent since taproot was first described in Jan 2018, or the\n>     42 months before flag-day activation in Matt's proposal)\n> \n>     I don't think that timeline is a good example of how things should\n>     work, and would call out a few mistakes in particular:\n> \n>      * too much urgency to increase the blocksize resulting in rushed\n>        decision making, especially for the hardfork implementations, but\n>        also for segwit\n> \n>      * alternative clients attempted to activate forks without\n>        resolving technical problems (eventually resulting in the btc1\n>        client stalling prior to the expected hard fork block, eg)\n> \n>      * a lot of emphasis was on numbers (market share, hashpower, etc)\n>        rather than technical merits, resulting in a lot of false\n>        signalling an political meaneuvering\n> \n>      * the incompatibility between ASICBoost and segwit wasn't noticed\n>        prior to activation, and wasn't fixed when it was noticed\n>        (certainly you can justify this as a tit-for-tat response to the\n>        other errors having been made in bad faith, or as not being a real\n>        problem because everyone claimed that they weren't doing covert\n>        ASICBoost, but considered on its own I think the incompatibility\n>        should have been resolved)\n> \n>      * the UASF approach had significant potential technical problems\n>        (potential for long reorgs, p2p network splits) that weren't\n>        resolved by the time it became active. happily, this was mitigated\n>        by hashpower enforcement of BIP-148 rules via BIP-91. neither\n>        BIP-148 or BIP-91 gained enough consensus to be supported in\n>        bitcoin core though\n> \n>     I don't personally think we need to fix every problem we had with\n>     segwit's process -- it eventually mostly worked out okay, after all --\n>     but I think Matt's approach has a good chance of fixing a lot of\n>     them, while still leaving us flexibility to deal with whatever new\n>     problems we come up with in their place.\n>"
            },
            {
                "author": "Anthony Towns",
                "date": "2020-01-16T03:46:17",
                "message_text_only": "On Tue, Jan 14, 2020 at 07:42:07PM +0000, Matt Corallo wrote:\n> Thus, part of the goal here is that we ensure we have that \"out\", and\n> can observe the response of the ecosystem once the change is \"staring\n> them in the face\", as it were.\n\n> A BIP 9 process is here not only to offer\n> a compelling activation path, but *also* to allow for observation and\n> discussion time for any lingering minor objections prior to a BIP 8/flag\n> day activation.\n\nOne thing that I wonder is if your proposal (and BIP9) has enough of\ntime for this sort of observation?\n\nIf something looks good to devs and miners, but still has some\nunderlying problem, it seems like it would be pretty easy to for it\nto activate quickly just because miners happen to upgrade quickly and\ndon't see a need to tweak the default signalling parameters. I think\nthe BIP 68/112/113 bundle starttime was met at block 409643 (May 1,\n2016), so it entered STARTED at 411264 (May 11), was LOCKED_IN at 417312\n(June 21), and active at 481824 (July 5). If we're worried people will\nonly seriously look at things once activation is possible, having just\na month or two to find new problems isn't very long.\n\nOne approach to improve that might be to have the first point release that\nincludes the soft-fork activation parameters _not_ update getblocktemplate\nto signal the version bit by default, but only do that in a second point\nrelease later. That way miners could manually enable signalling if there's\nsome reason to rush things (which still means there's pressure to actually\nlook at the changes), but by default there's a bit of extra time.\n\n(This might just be a reason why people should look at proposals before\nthey're ready to activate, though; or why users of bitcoin should also\nbe miners)\n\n> On the other hand, in practice, we've seen that version bits are set on\n> the pool side, and not on the node side, meaning the goal of ensuring\n> miners have upgraded isn't really accomplished in practice, you just end\n> up forking the chain for no gain.\n\nITYM version bits are set via mining software rather than the node\nsoftware the constructs blocks (when validation happens), so that\nthere's no strong link between signalling and having actually updated\nyour software to properly enforce the new rules? I think people have\nsuggested in the past moving signalling into the coinbase or similar\nrather than the version field of the header to make that link a bit\ntighter. Maybe this is worth doing at the same time? (For pools that\nwant to let their users choose whether to signal or not, that'd mean\noffering two different templates for them to mine, I guess) That would\nmean miners using the version field as extra nonce space wouldn't be\nconfused with upgrade signalling at least...\n\n(I don't have an opinion on whether either of these is worth worrying\nabout)\n\nCheers,\naj"
            },
            {
                "author": "Luke Dashjr",
                "date": "2020-01-10T23:37:49",
                "message_text_only": "I think BIP 9 is a proven failure, and flag day softforks have their own \nproblems:\n\nA) There is no way to unambiguously say \"the rules for this chain are \n<x,y,z>\". It leaves the chain in a kind of \"quantum state\" where the rules \ncould be one thing, or could be another. Until the new rules are violated, we \ndo not know if the softfork was a success or not. Because of this, people \nwill rightly shy away from relying on the new rules. This problem is made \nworse by the fact that common node policies might not produce blocks which \nviolate the rules. If we had gone with BIP149 for Segwit, it is IMO probable \nwe would still not have a clear answer today to \"Is Segwit active or not?\"\n\nB) Because of (A), there is also no clear way to intentionally reject the \nsoftfork. Those who do not consent to it are effectively compelled to accept \nit anyway. While it is usually possible to craft an opposing softfork, this \nshould IMO be well-defined and simple to do (including a plan to do so in any \nBIP9-alike spec).\n\nFor these reasons, in 2017, I proposed revising BIP 8 with a mandatory signal, \nsimilar to how BIP148 worked: https://github.com/bitcoin/bips/pull/550\nHowever, the author of BIP 8 has since vanished, and because we had no \nimmediate softfork plans, efforts to move this forward were abandoned \ntemporarily. It seems like a good time to resume this work.\n\nIn regard to your goal #3, I would like to note that after the mandatory \nsignal period, old miners could resume mining unchanged. This means there is \na temporary loss of hashrate to the network, but I think it is overall better \nthan the alternatives. The temporary loss of income from invalid blocks will \nalso give affected miners a last push to upgrade, hopefully improving the \nlong run security of the network hashrate.\n\nLuke\n\n(P.S. As for your #1, I do think it is oversimplified in some cases, but we \nshould leave that for later discussion when it actually becomes relevant.)\n\n\n\nOn Friday 10 January 2020 21:30:09 Matt Corallo via bitcoin-dev wrote:\n> There are a series of soft-fork designs which have recently been making\n> good progress towards implementation and future adoption. However, for\n> various reasons, activation methods therefor have gotten limited\n> discussion. I'd like to reopen that discussion here.\n>\n> It is likely worth revisiting the goals both for soft forks and their\n> activation methods to start. I'm probably missing some, but some basic\n> requirements:\n>\n> 1) Avoid activating in the face of significant, reasonable, and directed\n> objection. Period. If someone has a well-accepted, reasonable use of\n> Bitcoin that is working today, have no reason to believe wouldn't work\n> long into the future without a change, and which would be made\n> impossible or significantly more difficult by a change, that change must\n> not happen. I certainly hope there is no objection on this point (see\n> the last point for an important caveat that I'm sure everyone will jump\n> to point out).\n>\n> 2) Avoid activating within a timeframe which does not make high\n> node-level-adoption likely. As with all \"node\" arguments, I'll note that\n> I mean \"economically-used\" nodes, not the thousand or so spy nodes on\n> Google Cloud and AWS. Rule changes don't make sense without nodes\n> enforcing them, whether they happen to be a soft fork, hard fork, or a\n> blue fork, so activating in a reduced timeframe that doesn't allow for\n> large-scale node adoption doesn't have any value, and may cause other\n> unintended side effects.\n>\n> 3) Don't (needlessly) lose hashpower to un-upgraded miners. As a part of\n> Bitcoin's security comes from miners, reducing the hashpower of the\n> network as a side effect of a rule change is a needless reduction in a\n> key security parameter of the network. This is why, in recent history,\n> soft forks required 95% of hashpower to indicate that they have upgraded\n> and are capable of enforcing the new rules. Further, this is why recent\n> soft forks have not included changes which would result in a standard\n> Bitcoin Core instance mining invalid-by-new-rules changes (by relying on\n> the standardness behavior of Bitcoin Core).\n>\n> 4) Use hashpower enforcement to de-risk the upgrade process, wherever\n> possible. As a corollary of the above, one of the primary reasons we use\n> soft forks is that hashpower-based enforcement of rules is an elegant\n> way to prevent network splits during the node upgrade process. While it\n> does not make sense to invest material value in systems protected by new\n> rules until a significant majority of \"economic nodes\" is enforcing said\n> rules, hashpower lets us neatly bridge the gap in time between\n> activation and then. By having a supermajority of miners enforce the new\n> rules, attempts at violating the new rules does not result in a\n> significant network split, disrupting existing users of the system. If\n> we aren't going to take advantage of this, we should do a hard fork\n> instead, with the necessarily slow timescale that entails.\n>\n> 5) Follow the will of the community, irrespective of individuals or\n> unreasoned objection, but without ever overruling any reasonable\n> objection. Recent history also includes \"objection\" to soft forks in the\n> form of \"this is bad because it doesn't fix a different problem I want\n> fixed ASAP\". I don't think anyone would argue this qualifies as a\n> reasonable objection to a change, and we should be in a place, as a\n> community (never as developers or purely one group), to ignore such\n> objections and make forward progress in spite of them. We don't make\n> good engineering decisions by \"bundling\" unrelated features together to\n> enable political football and compromise.\n>\n> I think BIP 9 (plus a well-crafted softfork) pretty effectively checks\n> the boxes for #2-4 here, and when done carefully with lots of community\n> engagement and measurement, can effectively fulfill #1 as well. #5 is,\n> as I'm sure everyone is aware, where it starts to fall down pretty hard.\n>\n> BIP 8 has been proposed as an alternative, largely in response to issues\n> with #5. However, a naive deployment of it, rather obviously, completely\n> fails #1, #3, and #4, and, in my view, fails #5 as well by both giving\n> an impression of, setting a precedent of, and possibly even in practice\n> increasing the ability of developers to decide the consensus rules of\n> the system. A BIP 8 deployment that more accurately measures community\n> support as a prerequisite could arguably fulfill #1 and #5, though I'm\n> unaware of any concrete proposals on how to accomplish that. Arguably, a\n> significantly longer activation window could also allow BIP 8 to fulfill\n> #3 and #4, but only by exploiting the \"needlessly\" and \"wherever\n> possible\" loopholes.\n>\n> You may note that, from the point of view of achieving the critical\n> goals here, BIP 8 is only different from a flag-day activation in that,\n> if it takes the \"happy-path\" of activating before the flag day, it looks\n> like BIP 9, but isn't guaranteed to. It additionally has the\n> \"nice-to-have\" property that activation can occur before the flag-day in\n> the case of faster miner adoption, though there is a limit of how fast\n> is useful due to node adoption.\n>\n> Thus, to strike a balance between the drawbacks of BIP 8 and BIP 9, the\n> Great Consensus Cleanup softfork proposal included this text in the\n>\n> discussion section (with the spec describing a BIP 9 deployment):\n> > In spite of some suggestion that other activation methods be used, BIP\n> > 9 is proposed as ensuring miners have upgraded to enforce new rules is\n> > an important part of minimizing disruption. While previous BIP 9 soft-\n> > forks have resulted in political contention, this comparatively-\n> > unimportant soft-fork provides a good opportunity to attempt to return\n> > to utilizing BIP 9 to ensure miner upgrade prior to activation, which\n> > the authors believe is a critical goal. However, if there is broad\n> > agreement to activate these rules when the BIP 9 expiry time is\n> > reached, and miners have not yet signaled sufficient level of\n> > readiness, a later flag-day activation may be merited. For this\n> > reason, implementations may wish to provide a compatibility option\n> > which allows flag-day enforcement of these rules without an update.\n>\n> Ultimately, through admittedly rather limited discussion, I still like\n> this model (though I cannot claim it as my own, the original proposal\n> came from Greg Maxwell). BIP 9 only falls apart in case of unreasonable\n> objection, which, naturally, should carry a high bar to ignore, given we\n> have to have some level of agreement that it is, in fact, unreasonable\n> (or untargeted). While I admit this is a possibility, I both find it\n> less likely than in previous soft-forks, and even if it is the case, it\n> only slows down the process, it doesn't necessarily stop it. In the case\n> that it does fail, BIP 9 process, in fact, provides a good learning\n> opportunity as to the level of community readiness and desire for a\n> given change. While we can (and should, and are) learning a lot about\n> community readiness for, and acceptability of a change through outreach\n> and discussion, there is something about a change with a timeframe that\n> forces people to more carefully consider it.\n>\n> Thus, as something a bit more concrete, I think an activation method\n> which sets the right precedent and appropriately considers the above\n> goals, would be:\n>\n> 1) a standard BIP 9 deployment with a one-year time horizon for\n> activation with 95% miner readiness,\n> 2) in the case that no activation occurs within a year, a six month\n> quieting period during which the community can analyze and discussion\n> the reasons for no activation and,\n> 3) in the case that it makes sense, a simple command-line/bitcoin.conf\n> parameter which was supported since the original deployment release\n> would enable users to opt into a BIP 8 deployment with a 24-month\n> time-horizon for flag-day activation (as well as a new Bitcoin Core\n> release enabling the flag universally).\n>\n> This provides a very long time horizon for more standard activation,\n> while still ensuring the goals in #5 are met, even if, in those cases,\n> the time horizon needs to be significantly extended to meet the goals of\n> #3. Developing Bitcoin is not a race. If we have to, waiting 42 months\n> ensures we're not setting a negative precedent that we'll come to regret\n> as Bitcoin continues to grow.\n>\n> Matt\n>\n> Thanks also to AJ for feedback on an earlier version of this rant.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Jeremy",
                "date": "2020-01-11T00:54:06",
                "message_text_only": "It's not at a \"directly implementable policy state\", but I think you might\nbe interested in checking out the spork protocol upgrade model I proposed a\nwhile back. https://www.youtube.com/watch?v=J1CP7qbnpqA&feature=youtu.be\n\nIt has some interesting properties around the 5 properties you've mentioned.\n\n1) Avoid activating in the face of significant, reasonable, and directed\nobjection. Period.\n\nUp to miners to orphan spork-activating blocks.\n\n2) Avoid activating within a timeframe which does not make high\nnode-level-adoption likely.\n\nMandatory minimum flag day for Spork initiation, statistically\nimprobable/impossible for even earlier adoption.\n\n3) Don't (needlessly) lose hashpower to un-upgraded miners.\n\nDifficulty adjustments make the missing spork'd block \"go away\" over time,\nthe additional difficulty of *not activating* a rejected spork fills in as\nan additional PoW.\n\n\n4) Use hashpower enforcement to de-risk the upgrade process, wherever\npossible.\n\nMiners choose to activate or build on activating blocks.\n\n5) Follow the will of the community, irrespective of individuals or\nunreasoned objection, but without ever overruling any reasonable\nobjection.\n\nHonest signalling makes people be forced to \"put their money where there\nmouth is\" on what the community wants.\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200110/fd51faa2/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-01-14T19:22:47",
                "message_text_only": "Good thing no one is proposing a naive BIP 9 approach :). I'll note that\nBIP 9 has been fairly robust (spy-mining issues notwithstanding, which\nwe believe are at least largely solved in the wild) in terms of safety,\nthough I noted extensively in the first mail that it failed in terms of\nmisunderstanding the activation parameters. I think the above proposal\nlargely solves that, and I don't see much in the way of arguing that\npoint from you, here.\n\nAs an aside, BIP 9 is also the Devil We Know, which carries a lot of\nvalue, since we've found (and addressed) direct issues with it, whereas\nall other activation methods we have ~0 experience with in the modern\nBitcoin network.\n\nOn 1/10/20 11:37 PM, Luke Dashjr wrote:\n> I think BIP 9 is a proven failure, and flag day softforks have their own \n> problems:\n> \n> A) There is no way to unambiguously say \"the rules for this chain are \n> <x,y,z>\". It leaves the chain in a kind of \"quantum state\" where the rules \n> could be one thing, or could be another. Until the new rules are violated, we \n> do not know if the softfork was a success or not. Because of this, people \n> will rightly shy away from relying on the new rules. This problem is made \n> worse by the fact that common node policies might not produce blocks which \n> violate the rules. If we had gone with BIP149 for Segwit, it is IMO probable \n> we would still not have a clear answer today to \"Is Segwit active or not?\"\n> \n> B) Because of (A), there is also no clear way to intentionally reject the \n> softfork. Those who do not consent to it are effectively compelled to accept \n> it anyway. While it is usually possible to craft an opposing softfork, this \n> should IMO be well-defined and simple to do (including a plan to do so in any \n> BIP9-alike spec).\n> \n> For these reasons, in 2017, I proposed revising BIP 8 with a mandatory signal, \n> similar to how BIP148 worked: https://github.com/bitcoin/bips/pull/550\n> However, the author of BIP 8 has since vanished, and because we had no \n> immediate softfork plans, efforts to move this forward were abandoned \n> temporarily. It seems like a good time to resume this work.\n> \n> In regard to your goal #3, I would like to note that after the mandatory \n> signal period, old miners could resume mining unchanged. This means there is \n> a temporary loss of hashrate to the network, but I think it is overall better \n> than the alternatives. The temporary loss of income from invalid blocks will \n> also give affected miners a last push to upgrade, hopefully improving the \n> long run security of the network hashrate.\n> \n> Luke\n> \n> (P.S. As for your #1, I do think it is oversimplified in some cases, but we \n> should leave that for later discussion when it actually becomes relevant.)"
            },
            {
                "author": "Anthony Towns",
                "date": "2020-01-14T03:20:26",
                "message_text_only": "On Mon, Jan 13, 2020 at 08:34:24AM +0000, Yosef via bitcoin-dev wrote:\n> tl;dr How about 80% ?\n\nThe point of having hashpower upgraded is that it means that there's low\nliklihood of long chains of blocks that are invalid per the new rules, so\nthat if you haven't upgraded your node but wait for a few confirmations,\nyou'll still (with very high liklihood) only see blocks valid per the\nnew rules.\n\nIf you have 80% of miners enforcing the rules, then if someone produces\na block that violates the new rules (but is valid for the old ones),\nthen you've got a 20% chance of one of the non-enforcing miners getting\nthe next block, and a 4% chance of non-enforcing miners getting both\nthe next blocks, giving 3 confirmations to invalid transactions. That\nseems a bit high.\n\n3 confirmations isn't unrealistic, eg Coinbase apparently recently\ndropped its requirement to that apparently:\n\nhttps://blog.coinbase.com/announcing-new-confirmation-requirements-4a5504ba8d81\n\nI could maybe see a 90% threshold though?\n\n> 95% can prove difficult to achieve. Some % of negligent miners that forget to upgrade is expected.\n\nIs it? We went from 59% to 54% to 28% to 0% (!!) of blocks not signalling\nfor segwit during consecutive two-week blocks in the BIP-91/148\nperiod; and from 100% of blocks not signalling for BIP-91 to 99.4%,\n48%, 15%, and 11% during consecutive 2.3 day periods targeting an 80%\nthreshold. Certainly that was a particularly high-stakes period, but\nthey were both pretty short. For comparison, for CSV, we went from 100%\nnot signalling to 61%, to 54% to 3.4% in consecutive two-week periods.\n\n> Completing that to 5% is not too difficult for a small malicious minority trying to delay the activation. This is the issue Matt's goal #5 aims to prevent, and while the fallback to BIP-8 helps, BIP-9\u2019s 95% requirement makes it worse by allowing quite a neglected minority to force a dramatic delay. Also note how in such case it would have been better to skip BIP-9 altogether and maybe save 1.5 years.\n\nI don't think you can really skip steps if you need a flag day:\n\n - the first 12 months is for *really seriously* making sure there's no\n   problems with the proposed upgrade; you can't that because people\n   might not look for problems until the code's out there and ready for\n   actual use\n\n - the next 6 months is for updating the software to lock in the flag\n   day; you can't skip that because it takes time to get new releases out\n\n - the next 24 months is to ensure everyone's upgraded their nodes so\n   that they won't be at risk of thinking they've received bitcoins when\n   those coins aren't in compliance with the new rules; and you can't\n   skip that because if we don't have hashpower reliably enforcing the\n   rules, *everybody* needs to upgrade, which can take a lot of time.\n\nTimes could be tweaked, but the \"everyone has to upgrade their node\nsoftware\" is almost the same constraint that hard forks have, so I think\nyou want to end up with a long overall lead time any which way. For\ncomparison, 0.12.1 came out about 45 months ago and 0.13.2 came out\nabout 36 months ago -- about 0.5% of nodes are running 0.12 or earler,\nand about 4.9% of nodes are running 0.13 or earlier, at least per [0],\nso the overall timeline of 42 months seems plausible to me...\n\n[0] https://luke.dashjr.org/programs/bitcoin/files/charts/software.html\n\nI think (especially if we attempt BIP-91/BIP-148-style compulsory\nsignalling again) it's worth also considering the failure case if miners\nfalse-signal: that is they signal support of the new soft-fork rules,\nbut then don't actually enforce them. If you end up with, say, 15% of\nhashpower not upgraded or signalling, 25% of hashpower not upgraded but\nsignalling so their blocks don't get orphaned, and only 65% of hashpower\nupgraded, you have a 1% chance of 5 blocks built on top of a block\nthat's invalid according to the new rules, giving those transactions 6\nconfirmations as far as non-upgraded nodes are concerned.\n\nCheers,\naj"
            }
        ],
        "thread_summary": {
            "title": "Modern Soft Fork Activation",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Jeremy",
                "Anthony Towns",
                "Jorge Tim\u00f3n",
                "Luke Dashjr",
                "Matt Corallo"
            ],
            "messages_count": 12,
            "total_messages_chars_count": 93248
        }
    },
    {
        "title": "[bitcoin-dev]  Modern Soft Fork Activation",
        "thread_messages": [
            {
                "author": "Yosef",
                "date": "2020-01-13T08:34:24",
                "message_text_only": "tl;dr How about 80% ?\n\nThe fallback to BIP-8 makes sense, but it's not a graceful one and we absolutely prefer BIP-9 to succeed. A failure to reach 95% readiness signalling means 2.5 years delay, 3.5 years in total, not yet counting.\n\n95% can prove difficult to achieve. Some % of negligent miners that forget to upgrade is expected. Completing that to 5% is not too difficult for a small malicious minority trying to delay the activation. This is the issue Matt's goal #5 aims to prevent, and while the fallback to BIP-8 helps, BIP-9\u2019s 95% requirement makes it worse by allowing quite a neglected minority to force a dramatic delay. Also note how in such case it would have been better to skip BIP-9 altogether and maybe save 1.5 years.\n\nMatt mentions the 95% requirement under goal #3 \"Don't (needlessly) lose hashpower to un-upgraded miners\". If that is the trade-off, I'd say 2.5 years delay is worse than a momentary loss of hashrate. The protocol is quiet resilient to hashrate fluctuations and, as others mentioned, at that point miners don\u2019t just signal, but lose coins if they don't upgrade, so the hashpower loss is expected to shortly correct. This also means goal #4 is not really effected.\n\nOn Sat Jan 11 14:42:07 UTC 2020, Anthony Towns wrote:\n\n> For me, the focus there is on Matt's first point: \"avoid activating [or merging, or even proposing] in the face of significant, reasonable, and directed objection\"\n\nI agree, and believe the outreach and review process around taproot are maybe the best we had so far. Notably goal #1 should be mostly satisfied already at merge time, so risking 3.5 years delay after that, seems excessive.\n\nBIP-91 \u201cReduced threshold Segwit MASF\u201d was deployed by miners specifically to reduce the 95% requirement down to 80% during the segwit drama. While hopefully taproot won\u2019t produce any such excitements, the events around segwit activation and the weird \u201chash wars\u201d meme that later followed \u2013 might encourage some to try similar games again.\n\nThe difference between `5% minus apathetic-miners` and `20% minus apathetic-miners` is dramatic and can make such attempts an order of magnitude more difficult.\n\nThe taproot process is looking great so far, I feel it will be a mistake to put it on a route that can easily extend to so many years. I suggest keeping Matt\u2019s proposal as is but decrease BIP-9\u2019s 95% threshold down to around 80%.\n\nYosef"
            }
        ],
        "thread_summary": {
            "title": "Modern Soft Fork Activation",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Yosef"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2390
        }
    },
    {
        "title": "[bitcoin-dev] PSBT Addition (BIP 174) for authenticating source/output PSBT files",
        "thread_messages": [
            {
                "author": "Peter D. Gray",
                "date": "2020-01-11T17:29:06",
                "message_text_only": "## Background\n\nPSBT files in transit are at risk of MiTM changes. This isn't\nsupposed to matter, but as another layer of defence, I would like\nto add two signatures to PSBT files when they are processed by the\nPSBT Signer. These additional fields would be optional, and should\npass through existing PSBT processors transparently, assuming they\npass unknown key/values as BIP-174 specifies.\n\n## Additional Key/Values\n\n1) In the PSBT globals section, a signature over the \"source\" PSBT\nfile. It would cover all the bytes of the original PSBT file, as\nit was received by the Signer. The key used for the signature may\nbe any one the keys that the Signer applied during its transaction\nsigning process. (This is flexible so that the Signer can make the\nsignature at any point in the signing process. On the Coldcard, we\nwould probably use the first key that we used for signing, so the\nfirst key involved in the first input.)\n\nThe \"key\" of the global value will be pubkey value of the key which\nwas selected by the Signer.  If its BIP32 derivation is needed for\nsome reason, that is documented in the input section already.\n\nThe \"value\" will be 65(?) bytes of a standard Bitcoin signature.\nThe digest (hash) of the source PSBT is not provided, so any tool\nthat wants to verify this signature will need to have a copy of the\noriginal PSBT. (I see that as a critical feature, not a limitation).\n\n2) In the output section, specifically, the last key/value pair of\nthe last output of the transaction, I want to add a similar signature,\nagain signed by one of the keys used in the signing process. This\nsignature will cover all the bytes of the resulting (signed) PSBT\nup to that point. Because it is the last output of the output\nsection, that signature will be the last few bytes of the PSBT file.\nBy \"appending\" the signature in this way, it's easier to validate\nand create the signature, without blanking the signature area during\ndigest step.\n\n## Role-Based View\n\nThe above additions can only be made by a PSBT processor in the Signer\nrole. No-one else has the keys needed. As for the other PSBT roles:\n\n- Any tool that reads in a PSBT and finds a signature in the final output\n  section can and should verify it:\n    - check signature over a digest of the PSBT file up to the last X bytes\n    - file must end at that point, with only the signature following it\n    - also check the key used for signature is one of the input's keys\n\n- PSBT processors in the \"combining\" role, should preserve the\nsignatures in the global section, accumulating them into the next\nPSBT. (Of course they should validate them, if they have the original\nPSBT on hand as well, but that's optional and could be done later\nin the flow.) The Combiner should always check a signed PSBT was\nnot modified in transit via the signature in the final output\nsection, and then strip it out of the combined PSBT.\n\n- At the end of the signing process, the Finalizer should check all\nthe Signers have worked from the same PSBT file (assuming that's\nthe flow expected), or the appropriate PSBT if it's a more complex\ncase. If the Finalizer is working on a file directly from a Signer,\nthen it can verify the signature in the output section as well.\n\n## Open Questions\n\nFor the message digest, I propose simple SHA256(SHA256(bytes of PSBT)).\nI'm not sure of the best way to serialize the signature, but to be\nconsistent with the rest of the file, it should probably be DER-encoded\nand variable length.\n\n## Next Steps\n\nI'd like to get two officially-assigned BIP-174 key numbers assigned\nfor these two signatures, and then I will see that it gets added\ninto Coldcard's firmware immediately. In time, other tools are\nwelcome to take advantage of these checks. I will also write a BIP\nfor this, and/or make an addition to BIP-174.\n\nI think with these changes, and assuming all the tools are verifying\nproperly, we can shutdown undetectable MiTM changes to PSBT contents.\n\n---\nPeter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 529 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200111/51fab912/attachment.sig>"
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2020-01-11T20:17:05",
                "message_text_only": "I am not sure that this particular task should be done with data\nembedded in PSBT itself, and not with some sort of container that\nincludes PSBT and the authentication information.\n\nThe benefit seems to be in reusing PSBT structure for compatibilty, and\nthis might be a valid way, although I do not agree with some of your\npoints. I elaborate below:\n\n> 1) In the PSBT globals section, a signature over the \"source\" PSBT\n> file. It would cover all the bytes of the original PSBT file, as\n> it was received by the Signer.\n\nThe problem of authenticating the contents of PSBT is independent of\nthe signing action. PSBT might be altered on the path from Creator to\nSigner. Therefore you cannot always say that Signer will be an\nauthority over 'correctness' of PSBT.\n\n> - At the end of the signing process, the Finalizer should check all\n> the Signers have worked from the same PSBT file (assuming that's\n> the flow expected)\n\nIf there is MitM, checking something at Finalizer is likely too\nlate - the party that can intercept PSBTs can finalize before the\nlegitimate Finalizer and broadcast the transaction.\n\nParticipants can work from the same PSBT file if they all receive the\nsame PSBT, and not working in chain where next particpant receives\nupdated PSBT from the previous participant. Otherwise they will need to\neither pass two files (original and updated), or work out which fields\n(key-value blobs) to remove to get the 'source' PSBT (which might not be\ntrivial with presense of proprietary and unknown fields). Even if you\nknow which key-value pairs to remove, there is no requirement for\nordering of the fields, and some signer can serialize them in different\norder after dserialize/sign/add-signatures/re-serialize operation.\n\nIntroducing additional ordering or other structure requirements over\nsimple key-value structure will add complexity to PSBT processing, and\nadding complexity on such a basic level should have really serious\nreasons, because that increases effort required for even basic\nimplementations and increases chance of bugs.\n\nIf there is some authority on the 'correctness' of 'original' PSBT\n(all particpants receive same PSBT at the start), particpants should\ncheck the signature by that authority. That authority might use\nthe key used only for authentication, and not in the tx signing.\n\nIf particpants send PSBT in chain after adding their signatures, then\neach participant can add their signature to say 'the contents\nof PSBT after my updates should match this hash'.\n\nThe signatures of previous participants in the chain most likely do not\nmatter because of difficulty of restoring the contents of PSBT as it\nwas before the previous particpant, if you do not pass _all_ the PSBTs\n(which is excessive). \n \n> 2) In the output section, specifically, the last key/value pair of\n> the last output of the transaction, I want to add a similar signature,\n> again signed by one of the keys used in the signing process. This\n> signature will cover all the bytes of the resulting (signed) PSBT\n> up to that point. Because it is the last output of the output\n> section, that signature will be the last few bytes of the PSBT file.\n> By \"appending\" the signature in this way, it's easier to validate\n> and create the signature, without blanking the signature area during\n> digest step.\n\nThis will introduce unnecessary higher-level structure to PSBT for the\nreasons that I do not find strong enough for the amount of complexity\nadded.\n\nAlso, as I said above, you likely do not need more than one\nsignature - if this is 'fan-out' scheme, then participants need do\ncheck the sig of authority that created PSBT; if this is piggy-back\nchain, then only previous particpant's signature is easily verifiable.\n\n> ## Next Steps\n> \n> I'd like to get two officially-assigned BIP-174 key numbers assigned\n> for these two signatures, and then I will see that it gets added\n> into Coldcard's firmware immediately. In time, other tools are\n> welcome to take advantage of these checks. I will also write a BIP\n> for this, and/or make an addition to BIP-174.\n\nI think you do not need to wait for officially-assigned key numbers,\nand can just implement the scheme you envision with proprietary keys,\ndocument and promote it. Then if it shows its usefulness, it will\neither become de-facto standard with your proprietary keys (and\neveryone will want to support 'Coldard PSBT auth' or whatever the name),\nor the scheme will have serious grounds to be converted to standard and\nhave non-proprietary keys assigned.\n\n// Dmitry.\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: not available\nType: application/pgp-signature\nSize: 833 bytes\nDesc: \u00d0\u00a6\u00d0\u00b8\u00d1\u201e\u00d1\u20ac\u00d0\u00be\u00d0\u00b2\u00d0\u00b0\u00d1\u008f \u00d0\u00bf\u00d0\u00be\u00d0\u00b4\u00d0\u00bf\u00d0\u00b8\u00d1\u0081\u00d1\u0152 OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200112/1e8c2cc8/attachment-0001.sig>"
            },
            {
                "author": "Andrew Chow",
                "date": "2020-01-13T06:39:28",
                "message_text_only": "I agree with Dimitry. I don't see the point of having the MiTM\nprotection within the PSBT structure itself, in addition to the fact\nthat adding new fields is largely unnecessary. In fact, I'm not quite\nsure what kind of attack you are trying to defend against with this\nproposal.\n\nIf there is a MiTM who can modify your PSBT, then they can just modify\nthe result the signed PSBT to drop the auth signatures. Furthermore, any\nmodifications to scripts or UTXOs would just result in an invalid\nsignature, so only time is wasted. But you'll just waste time anyways\nwhen you see a failed auth sig.\n\nAdditionally, when a signer processes a PSBT, it will either accept the\nPSBT and add a signature for its inputs, or reject it and do nothing.\nGiven this behavior (and I assume you aren't going to add auth sigs for\nrejected PSBTs because that doesn't make any sense), then you already\nhave a signature there that covers everything your auth signature would\ncover. So just verify those signatures instead; for any inputs with\nsignatures, everything you need to verify them are already there.\n\nLastly, IMO, if you want MiTM protection, then you should do your\nprotection with out of band communication. Just PGP sign the PSBT (or\nsomething similar) and send the signature along separately.\n\nAndrew\n\nOn 1/11/20 3:17 PM, Dmitry Petukhov via bitcoin-dev wrote:\n> \n> I am not sure that this particular task should be done with data\n> embedded in PSBT itself, and not with some sort of container that\n> includes PSBT and the authentication information.\n> \n> The benefit seems to be in reusing PSBT structure for compatibilty, and\n> this might be a valid way, although I do not agree with some of your\n> points. I elaborate below:\n> \n>> 1) In the PSBT globals section, a signature over the \"source\" PSBT\n>> file. It would cover all the bytes of the original PSBT file, as\n>> it was received by the Signer.\n> \n> The problem of authenticating the contents of PSBT is independent of\n> the signing action. PSBT might be altered on the path from Creator to\n> Signer. Therefore you cannot always say that Signer will be an\n> authority over 'correctness' of PSBT.\n> \n>> - At the end of the signing process, the Finalizer should check all\n>> the Signers have worked from the same PSBT file (assuming that's\n>> the flow expected)\n> \n> If there is MitM, checking something at Finalizer is likely too\n> late - the party that can intercept PSBTs can finalize before the\n> legitimate Finalizer and broadcast the transaction.\n> \n> Participants can work from the same PSBT file if they all receive the\n> same PSBT, and not working in chain where next particpant receives\n> updated PSBT from the previous participant. Otherwise they will need to\n> either pass two files (original and updated), or work out which fields\n> (key-value blobs) to remove to get the 'source' PSBT (which might not be\n> trivial with presense of proprietary and unknown fields). Even if you\n> know which key-value pairs to remove, there is no requirement for\n> ordering of the fields, and some signer can serialize them in different\n> order after dserialize/sign/add-signatures/re-serialize operation.\n> \n> Introducing additional ordering or other structure requirements over\n> simple key-value structure will add complexity to PSBT processing, and\n> adding complexity on such a basic level should have really serious\n> reasons, because that increases effort required for even basic\n> implementations and increases chance of bugs.\n> \n> If there is some authority on the 'correctness' of 'original' PSBT\n> (all particpants receive same PSBT at the start), particpants should\n> check the signature by that authority. That authority might use\n> the key used only for authentication, and not in the tx signing.\n> \n> If particpants send PSBT in chain after adding their signatures, then\n> each participant can add their signature to say 'the contents\n> of PSBT after my updates should match this hash'.\n> \n> The signatures of previous participants in the chain most likely do not\n> matter because of difficulty of restoring the contents of PSBT as it\n> was before the previous particpant, if you do not pass _all_ the PSBTs\n> (which is excessive).\n> \n>> 2) In the output section, specifically, the last key/value pair of\n>> the last output of the transaction, I want to add a similar signature,\n>> again signed by one of the keys used in the signing process. This\n>> signature will cover all the bytes of the resulting (signed) PSBT\n>> up to that point. Because it is the last output of the output\n>> section, that signature will be the last few bytes of the PSBT file.\n>> By \"appending\" the signature in this way, it's easier to validate\n>> and create the signature, without blanking the signature area during\n>> digest step.\n> \n> This will introduce unnecessary higher-level structure to PSBT for the\n> reasons that I do not find strong enough for the amount of complexity\n> added.\n> \n> Also, as I said above, you likely do not need more than one\n> signature - if this is 'fan-out' scheme, then participants need do\n> check the sig of authority that created PSBT; if this is piggy-back\n> chain, then only previous particpant's signature is easily verifiable.\n> \n>> ## Next Steps\n>>\n>> I'd like to get two officially-assigned BIP-174 key numbers assigned\n>> for these two signatures, and then I will see that it gets added\n>> into Coldcard's firmware immediately. In time, other tools are\n>> welcome to take advantage of these checks. I will also write a BIP\n>> for this, and/or make an addition to BIP-174.\n> \n> I think you do not need to wait for officially-assigned key numbers,\n> and can just implement the scheme you envision with proprietary keys,\n> document and promote it. Then if it shows its usefulness, it will\n> either become de-facto standard with your proprietary keys (and\n> everyone will want to support 'Coldard PSBT auth' or whatever the name),\n> or the scheme will have serious grounds to be converted to standard and\n> have non-proprietary keys assigned.\n> \n> // Dmitry.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Peter D. Gray",
                "date": "2020-01-13T14:28:17",
                "message_text_only": "Thanks for the useful comments guys. I understand where you are\ncoming from, but my PoV is from the deep embedded side.\n\nOn Mon, Jan 13, 2020 at 06:39:28AM +0000, Andrew Chow wrote:\n> ... In fact, I'm not quite\n> sure what kind of attack you are trying to defend against with this\n> proposal.\n\nI don't have a specific attack in mind, but these signatures, if\nadopted by the community at large, will allow detection of-, and\ncould mitigate damage from-, some broad \"bug-classes\".\n\nConsider if the PSBT Signer (hardware wallet) has bugs. Perhaps if\nyou tweak the PSBT in some unnatural way it produces output that\nreveals the private key (duplicate k-value perhaps), or corrupts\nthe display of the transaction in helpful (to the attacker) ways\n(typically case: output hidden as change).\n\nSeeing a corrupted file signature would alert you of the attempt\nto do this. So maybe you don't transmit the transaction, maybe you\nwarn the user and so on. What happens next is up to you, but at\nleast we know something is happening.\n\nThere could also be bugs in the Combiner/Finalizer which the MiTM\nwants to trigger. Legimate files, signed by the PSBT Signer, will not\ncontain those attacks, so are \"safer\" to process, even if your\nCombiner's PSBT parser has bugs or is tragically dumb.\n\nIt's just another layer of security and confidence, on top of the\nexisting system-level security (which is already excellent).\n\n> If there is a MiTM who can modify your PSBT, then they can just modify\n> the result the signed PSBT to drop the auth signatures.\n\nYes, the MiTM can remove the signatures. However, if your tools expect\nand require the signatures in place, then the feature is working\nas intended, because the user will be alerted to the funny-business.\n\nMore importantly: nothing has been lost by implementing the feature,\nand Coldcard (and other PSBT Signers) have to be first to implement it.\n\n> ... then you already\n> have a signature there that covers everything your auth signature would\n> cover. So just verify those signatures instead; for any inputs with\n\nThat's just it, when we receive a signed PSBT, at present we don't\nknow *what* was signed without a complete understanding of the\ntransaction, the input UTXO (at least syntactially), and PSBT file\ncontents.  If there are bugs in that understanding (ie. checks we\nall know are needed, but no-one actually implemented) then we might\ntransmit an harmful transaction, or continue to process a file\nthat has been corrupted-with-intent by a MiTM.\n\n> Lastly, IMO, if you want MiTM protection, then you should do your\n> protection with out of band communication. Just PGP sign the PSBT (or\n> something similar) and send the signature along separately.\n\nIt's fine to say that, but in an embedded environment, with very\nlimited memory like the Coldcard, PGP isn't an option (signing vs.\nsignature verification). I want to leverage the existing crypto and\nPKI that we already have in play.\n\n> On 1/11/20 3:17 PM, Dmitry Petukhov via bitcoin-dev wrote:\n... [many valid points, repeated by Andrew] ...\n> > If there is MitM, checking something at Finalizer is likely too\n> > late - the party that can intercept PSBTs can finalize before the\n> > legitimate Finalizer and broadcast the transaction.\n\nYes, that is a problem which is proposal does not address. If the\nMitM has control over both directions, in and out, then whatever\nhe or she was trying to do will still happen. Personally, I'm okay\nwith that as a limition, but using the same signatures features,\nand a pre-shared public key between the PSBT Creator and the Signer,\nwe could block the Signer from looking at MitM'ed files. (The Signer\nwould require and verify incoming unsigned PSBT to contain the\nlast-output-section-signature thing.) I'm not planning on supporting\nthat on the Coldcard (at least not yet), but with the proposed\nadditions, it is possible to do without further changes to the PSBT\nspec.\n\n> > Participants can work from the same PSBT ...\n> > either pass two files (original and updated), or work out which fields\n> > (key-value blobs) to remove to get the 'source' PSBT (which might not be\n> > trivial with presense of proprietary and unknown fields). Even if you\n> > know which key-value pairs to remove, there is no requirement for\n> > ordering of the fields, and some signer can serialize them in different\n> > order after dserialize/sign/add-signatures/re-serialize operation.\n...\n> > Introducing additional ordering or other structure requirements over\n> > simple key-value structure will add complexity to PSBT processing, and\n> > adding complexity on such a basic level should have really serious\n> > reasons, because that increases effort required for even basic\n> > implementations and increases chance of bugs.\n\nI want these signatures to protect against PSBT parsing bugs. That's\nwhy they are byte-level on the whole file contents, and not based\non sub-sections of the file or various fields inside the file. Yes,\nthere are non-linear PSBT paths that will be difficult or impossible\nto support with this approach. I would not expect implementations to\ndo anything fancy to reconstruct PSBT contents, I think they would\njust track the complete file. In most setups today the Creator,\nCombiner and Finalizer are the same device, and they are desktop\nsystems with gigs of memory.\n\n> > If there is some authority on the 'correctness' of 'original' PSBT\n> > (all particpants receive same PSBT at the start), particpants should\n> > check the signature by that authority. That authority might use\n> > the key used only for authentication, and not in the tx signing.\n\nYes, this can be acheived by pre-sharing a public key with the\nSigner (described above). Only signed incoming PSBT's would be\naccepted. That key doesn't have anything to do with the blockchain\nor value transfer.\n\n> > I think you do not need to wait for officially-assigned key numbers,\n> > and can just implement the scheme you envision with proprietary keys,\n> > document and promote it. Then if it shows its usefulness, it will\n> > either become de-facto standard with your proprietary keys...\n\nYes, 100% ... but I value the list's feedback, and I would prefer to\nstart with a legitimate key number which I don't need to change later. It's\na non-breaking change and I wouldn't propose it otherwise.\n\n---\nPeter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10\n\nOn Mon, Jan 13, 2020 at 06:39:28AM +0000, Andrew Chow wrote:\n> I agree with Dimitry. I don't see the point of having the MiTM\n> protection within the PSBT structure itself, in addition to the fact\n> that adding new fields is largely unnecessary. In fact, I'm not quite\n> sure what kind of attack you are trying to defend against with this\n> proposal.\n> \n> If there is a MiTM who can modify your PSBT, then they can just modify\n> the result the signed PSBT to drop the auth signatures. Furthermore, any\n> modifications to scripts or UTXOs would just result in an invalid\n> signature, so only time is wasted. But you'll just waste time anyways\n> when you see a failed auth sig.\n> \n> Additionally, when a signer processes a PSBT, it will either accept the\n> PSBT and add a signature for its inputs, or reject it and do nothing.\n> Given this behavior (and I assume you aren't going to add auth sigs for\n> rejected PSBTs because that doesn't make any sense), then you already\n> have a signature there that covers everything your auth signature would\n> cover. So just verify those signatures instead; for any inputs with\n> signatures, everything you need to verify them are already there.\n> \n> Lastly, IMO, if you want MiTM protection, then you should do your\n> protection with out of band communication. Just PGP sign the PSBT (or\n> something similar) and send the signature along separately.\n> \n> Andrew\n> \n> On 1/11/20 3:17 PM, Dmitry Petukhov via bitcoin-dev wrote:\n> > \n> > I am not sure that this particular task should be done with data\n> > embedded in PSBT itself, and not with some sort of container that\n> > includes PSBT and the authentication information.\n> > \n> > The benefit seems to be in reusing PSBT structure for compatibilty, and\n> > this might be a valid way, although I do not agree with some of your\n> > points. I elaborate below:\n> > \n> >> 1) In the PSBT globals section, a signature over the \"source\" PSBT\n> >> file. It would cover all the bytes of the original PSBT file, as\n> >> it was received by the Signer.\n> > \n> > The problem of authenticating the contents of PSBT is independent of\n> > the signing action. PSBT might be altered on the path from Creator to\n> > Signer. Therefore you cannot always say that Signer will be an\n> > authority over 'correctness' of PSBT.\n> > \n> >> - At the end of the signing process, the Finalizer should check all\n> >> the Signers have worked from the same PSBT file (assuming that's\n> >> the flow expected)\n> > \n> > If there is MitM, checking something at Finalizer is likely too\n> > late - the party that can intercept PSBTs can finalize before the\n> > legitimate Finalizer and broadcast the transaction.\n> > \n> > Participants can work from the same PSBT file if they all receive the\n> > same PSBT, and not working in chain where next particpant receives\n> > updated PSBT from the previous participant. Otherwise they will need to\n> > either pass two files (original and updated), or work out which fields\n> > (key-value blobs) to remove to get the 'source' PSBT (which might not be\n> > trivial with presense of proprietary and unknown fields). Even if you\n> > know which key-value pairs to remove, there is no requirement for\n> > ordering of the fields, and some signer can serialize them in different\n> > order after dserialize/sign/add-signatures/re-serialize operation.\n> > \n> > Introducing additional ordering or other structure requirements over\n> > simple key-value structure will add complexity to PSBT processing, and\n> > adding complexity on such a basic level should have really serious\n> > reasons, because that increases effort required for even basic\n> > implementations and increases chance of bugs.\n> > \n> > If there is some authority on the 'correctness' of 'original' PSBT\n> > (all particpants receive same PSBT at the start), particpants should\n> > check the signature by that authority. That authority might use\n> > the key used only for authentication, and not in the tx signing.\n> > \n> > If particpants send PSBT in chain after adding their signatures, then\n> > each participant can add their signature to say 'the contents\n> > of PSBT after my updates should match this hash'.\n> > \n> > The signatures of previous participants in the chain most likely do not\n> > matter because of difficulty of restoring the contents of PSBT as it\n> > was before the previous particpant, if you do not pass _all_ the PSBTs\n> > (which is excessive).\n> > \n> >> 2) In the output section, specifically, the last key/value pair of\n> >> the last output of the transaction, I want to add a similar signature,\n> >> again signed by one of the keys used in the signing process. This\n> >> signature will cover all the bytes of the resulting (signed) PSBT\n> >> up to that point. Because it is the last output of the output\n> >> section, that signature will be the last few bytes of the PSBT file.\n> >> By \"appending\" the signature in this way, it's easier to validate\n> >> and create the signature, without blanking the signature area during\n> >> digest step.\n> > \n> > This will introduce unnecessary higher-level structure to PSBT for the\n> > reasons that I do not find strong enough for the amount of complexity\n> > added.\n> > \n> > Also, as I said above, you likely do not need more than one\n> > signature - if this is 'fan-out' scheme, then participants need do\n> > check the sig of authority that created PSBT; if this is piggy-back\n> > chain, then only previous particpant's signature is easily verifiable.\n> > \n> >> ## Next Steps\n> >>\n> >> I'd like to get two officially-assigned BIP-174 key numbers assigned\n> >> for these two signatures, and then I will see that it gets added\n> >> into Coldcard's firmware immediately. In time, other tools are\n> >> welcome to take advantage of these checks. I will also write a BIP\n> >> for this, and/or make an addition to BIP-174.\n> > \n> > I think you do not need to wait for officially-assigned key numbers,\n> > and can just implement the scheme you envision with proprietary keys,\n> > document and promote it. Then if it shows its usefulness, it will\n> > either become de-facto standard with your proprietary keys (and\n> > everyone will want to support 'Coldard PSBT auth' or whatever the name),\n> > or the scheme will have serious grounds to be converted to standard and\n> > have non-proprietary keys assigned.\n> > \n> > // Dmitry.\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> > \n> \n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 529 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200113/2ad4e27c/attachment-0001.sig>"
            },
            {
                "author": "Andrew Chow",
                "date": "2020-01-13T17:05:10",
                "message_text_only": "On 1/13/20 9:28 AM, Peter D. Gray wrote:\n> I don't have a specific attack in mind, but these signatures, if\n> adopted by the community at large, will allow detection of-, and\n> could mitigate damage from-, some broad \"bug-classes\".\n> \n> Consider if the PSBT Signer (hardware wallet) has bugs. Perhaps if\n> you tweak the PSBT in some unnatural way it produces output that\n> reveals the private key (duplicate k-value perhaps), or corrupts\n> the display of the transaction in helpful (to the attacker) ways\n> (typically case: output hidden as change).\n\nSince the PSBT is to be signed by one of the Signers for the PSBT, I\ndon't see how this is useful. If it is mutated and the signer has bugs,\nespecially parsing bugs, the Signer also adding its signature won't\nhelp. In your proposal, it is the Signer who adds the signature, so it\nwill receive a PSBT without auth sigs and thus that could be mutated to\ntrigger those bugs anyways.\n\n> There could also be bugs in the Combiner/Finalizer which the MiTM\n> wants to trigger. Legimate files, signed by the PSBT Signer, will not\n> contain those attacks, so are \"safer\" to process, even if your\n> Combiner's PSBT parser has bugs or is tragically dumb.\n\nThe job of Combiners is fairly limited and is really just related to\nparsing the PSBT into some internal object then shuffling those fields\naround. In that case, any bugs an attacker would want to exploit have to\nbe deserialization bugs, in which case, your auth sigs don't help. The\nCombiner still has to deserialize the PSBT to get the signature, then it\nneeds to re-serialize the PSBT to check that signature. An attacker\ncould insert bad bytes into the PSBT which causes problems during\ndeserialization, before the Combiner is able to check the signature.\n\nFor Finalizers, since its job is to construct the final\nscriptSig/scriptWitness, at worst, all it can do is produce an invalid\ntransaction. Finalizers don't have access to the private keys so there's\nno bug possible that can result in a Finalizer producing a transaction\nthat reveals the private key.\n\n> \n> That's just it, when we receive a signed PSBT, at present we don't\n> know *what* was signed without a complete understanding of the\n> transaction, the input UTXO (at least syntactially), and PSBT file\n> contents.  If there are bugs in that understanding (ie. checks we\n> all know are needed, but no-one actually implemented) then we might\n> transmit an harmful transaction, or continue to process a file\n> that has been corrupted-with-intent by a MiTM.\n\nISTM the same is true of your proposal. You need to deserialize the PSBT\nand then figure out which fields were \"original\" and in what order. If\nthere is a bug in your deserialization, an attacker can still exploit\nthat. And if there is a bug in your reconstruction of \"original\", you'll\nhave false positives.\n\n> It's fine to say that, but in an embedded environment, with very\n> limited memory like the Coldcard, PGP isn't an option (signing vs.\n> signature verification). I want to leverage the existing crypto and\n> PKI that we already have in play.\n\nMy point was that you can achieve your MiTM protection by having the\nsignature separate from the PSBT. You can still make your ECDSA\nsignature and send it along with the PSBT, and you can do it with fixed\nor exchanged keys, no need for parsing the PSBT itself. It can be part\nof the transport protocol, not part of the data that is being transferred.\n\nAndrew\n\n> \n>> On 1/11/20 3:17 PM, Dmitry Petukhov via bitcoin-dev wrote:\n> ... [many valid points, repeated by Andrew] ...\n>>> If there is MitM, checking something at Finalizer is likely too\n>>> late - the party that can intercept PSBTs can finalize before the\n>>> legitimate Finalizer and broadcast the transaction.\n> \n> Yes, that is a problem which is proposal does not address. If the\n> MitM has control over both directions, in and out, then whatever\n> he or she was trying to do will still happen. Personally, I'm okay\n> with that as a limition, but using the same signatures features,\n> and a pre-shared public key between the PSBT Creator and the Signer,\n> we could block the Signer from looking at MitM'ed files. (The Signer\n> would require and verify incoming unsigned PSBT to contain the\n> last-output-section-signature thing.) I'm not planning on supporting\n> that on the Coldcard (at least not yet), but with the proposed\n> additions, it is possible to do without further changes to the PSBT\n> spec.\n> \n>>> Participants can work from the same PSBT ...\n>>> either pass two files (original and updated), or work out which fields\n>>> (key-value blobs) to remove to get the 'source' PSBT (which might not be\n>>> trivial with presense of proprietary and unknown fields). Even if you\n>>> know which key-value pairs to remove, there is no requirement for\n>>> ordering of the fields, and some signer can serialize them in different\n>>> order after dserialize/sign/add-signatures/re-serialize operation.\n> ...\n>>> Introducing additional ordering or other structure requirements over\n>>> simple key-value structure will add complexity to PSBT processing, and\n>>> adding complexity on such a basic level should have really serious\n>>> reasons, because that increases effort required for even basic\n>>> implementations and increases chance of bugs.\n> \n> I want these signatures to protect against PSBT parsing bugs. That's\n> why they are byte-level on the whole file contents, and not based\n> on sub-sections of the file or various fields inside the file. Yes,\n> there are non-linear PSBT paths that will be difficult or impossible\n> to support with this approach. I would not expect implementations to\n> do anything fancy to reconstruct PSBT contents, I think they would\n> just track the complete file. In most setups today the Creator,\n> Combiner and Finalizer are the same device, and they are desktop\n> systems with gigs of memory.\n> \n>>> If there is some authority on the 'correctness' of 'original' PSBT\n>>> (all particpants receive same PSBT at the start), particpants should\n>>> check the signature by that authority. That authority might use\n>>> the key used only for authentication, and not in the tx signing.\n> \n> Yes, this can be acheived by pre-sharing a public key with the\n> Signer (described above). Only signed incoming PSBT's would be\n> accepted. That key doesn't have anything to do with the blockchain\n> or value transfer.\n> \n>>> I think you do not need to wait for officially-assigned key numbers,\n>>> and can just implement the scheme you envision with proprietary keys,\n>>> document and promote it. Then if it shows its usefulness, it will\n>>> either become de-facto standard with your proprietary keys...\n> \n> Yes, 100% ... but I value the list's feedback, and I would prefer to\n> start with a legitimate key number which I don't need to change later. It's\n> a non-breaking change and I wouldn't propose it otherwise.\n> \n> ---\n> Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10\n> \n> On Mon, Jan 13, 2020 at 06:39:28AM +0000, Andrew Chow wrote:\n>> I agree with Dimitry. I don't see the point of having the MiTM\n>> protection within the PSBT structure itself, in addition to the fact\n>> that adding new fields is largely unnecessary. In fact, I'm not quite\n>> sure what kind of attack you are trying to defend against with this\n>> proposal.\n>>\n>> If there is a MiTM who can modify your PSBT, then they can just modify\n>> the result the signed PSBT to drop the auth signatures. Furthermore, any\n>> modifications to scripts or UTXOs would just result in an invalid\n>> signature, so only time is wasted. But you'll just waste time anyways\n>> when you see a failed auth sig.\n>>\n>> Additionally, when a signer processes a PSBT, it will either accept the\n>> PSBT and add a signature for its inputs, or reject it and do nothing.\n>> Given this behavior (and I assume you aren't going to add auth sigs for\n>> rejected PSBTs because that doesn't make any sense), then you already\n>> have a signature there that covers everything your auth signature would\n>> cover. So just verify those signatures instead; for any inputs with\n>> signatures, everything you need to verify them are already there.\n>>\n>> Lastly, IMO, if you want MiTM protection, then you should do your\n>> protection with out of band communication. Just PGP sign the PSBT (or\n>> something similar) and send the signature along separately.\n>>\n>> Andrew\n>>\n>> On 1/11/20 3:17 PM, Dmitry Petukhov via bitcoin-dev wrote:\n>>>\n>>> I am not sure that this particular task should be done with data\n>>> embedded in PSBT itself, and not with some sort of container that\n>>> includes PSBT and the authentication information.\n>>>\n>>> The benefit seems to be in reusing PSBT structure for compatibilty, and\n>>> this might be a valid way, although I do not agree with some of your\n>>> points. I elaborate below:\n>>>\n>>>> 1) In the PSBT globals section, a signature over the \"source\" PSBT\n>>>> file. It would cover all the bytes of the original PSBT file, as\n>>>> it was received by the Signer.\n>>>\n>>> The problem of authenticating the contents of PSBT is independent of\n>>> the signing action. PSBT might be altered on the path from Creator to\n>>> Signer. Therefore you cannot always say that Signer will be an\n>>> authority over 'correctness' of PSBT.\n>>>\n>>>> - At the end of the signing process, the Finalizer should check all\n>>>> the Signers have worked from the same PSBT file (assuming that's\n>>>> the flow expected)\n>>>\n>>> If there is MitM, checking something at Finalizer is likely too\n>>> late - the party that can intercept PSBTs can finalize before the\n>>> legitimate Finalizer and broadcast the transaction.\n>>>\n>>> Participants can work from the same PSBT file if they all receive the\n>>> same PSBT, and not working in chain where next particpant receives\n>>> updated PSBT from the previous participant. Otherwise they will need to\n>>> either pass two files (original and updated), or work out which fields\n>>> (key-value blobs) to remove to get the 'source' PSBT (which might not be\n>>> trivial with presense of proprietary and unknown fields). Even if you\n>>> know which key-value pairs to remove, there is no requirement for\n>>> ordering of the fields, and some signer can serialize them in different\n>>> order after dserialize/sign/add-signatures/re-serialize operation.\n>>>\n>>> Introducing additional ordering or other structure requirements over\n>>> simple key-value structure will add complexity to PSBT processing, and\n>>> adding complexity on such a basic level should have really serious\n>>> reasons, because that increases effort required for even basic\n>>> implementations and increases chance of bugs.\n>>>\n>>> If there is some authority on the 'correctness' of 'original' PSBT\n>>> (all particpants receive same PSBT at the start), particpants should\n>>> check the signature by that authority. That authority might use\n>>> the key used only for authentication, and not in the tx signing.\n>>>\n>>> If particpants send PSBT in chain after adding their signatures, then\n>>> each participant can add their signature to say 'the contents\n>>> of PSBT after my updates should match this hash'.\n>>>\n>>> The signatures of previous participants in the chain most likely do not\n>>> matter because of difficulty of restoring the contents of PSBT as it\n>>> was before the previous particpant, if you do not pass _all_ the PSBTs\n>>> (which is excessive).\n>>>\n>>>> 2) In the output section, specifically, the last key/value pair of\n>>>> the last output of the transaction, I want to add a similar signature,\n>>>> again signed by one of the keys used in the signing process. This\n>>>> signature will cover all the bytes of the resulting (signed) PSBT\n>>>> up to that point. Because it is the last output of the output\n>>>> section, that signature will be the last few bytes of the PSBT file.\n>>>> By \"appending\" the signature in this way, it's easier to validate\n>>>> and create the signature, without blanking the signature area during\n>>>> digest step.\n>>>\n>>> This will introduce unnecessary higher-level structure to PSBT for the\n>>> reasons that I do not find strong enough for the amount of complexity\n>>> added.\n>>>\n>>> Also, as I said above, you likely do not need more than one\n>>> signature - if this is 'fan-out' scheme, then participants need do\n>>> check the sig of authority that created PSBT; if this is piggy-back\n>>> chain, then only previous particpant's signature is easily verifiable.\n>>>\n>>>> ## Next Steps\n>>>>\n>>>> I'd like to get two officially-assigned BIP-174 key numbers assigned\n>>>> for these two signatures, and then I will see that it gets added\n>>>> into Coldcard's firmware immediately. In time, other tools are\n>>>> welcome to take advantage of these checks. I will also write a BIP\n>>>> for this, and/or make an addition to BIP-174.\n>>>\n>>> I think you do not need to wait for officially-assigned key numbers,\n>>> and can just implement the scheme you envision with proprietary keys,\n>>> document and promote it. Then if it shows its usefulness, it will\n>>> either become de-facto standard with your proprietary keys (and\n>>> everyone will want to support 'Coldard PSBT auth' or whatever the name),\n>>> or the scheme will have serious grounds to be converted to standard and\n>>> have non-proprietary keys assigned.\n>>>\n>>> // Dmitry.\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>"
            },
            {
                "author": "Peter D. Gray",
                "date": "2020-01-13T20:29:11",
                "message_text_only": "> In your proposal, it is the Signer who adds the signature, so it\n> will receive a PSBT without auth sigs and thus that could be mutated to\n> trigger those bugs anyways.\n\nThe Signer may be signing a PSBT that was corrupted by the MitM,\nbut at least later users of the signed PSBT can detect that occured.\nAt present, they do not know what the input PSBT content was when\nit got to the Signer.\n\n> ... The Combiner still has to deserialize the PSBT to get the signature, then it\n> needs to re-serialize the PSBT to check that signature. \n\nIf we use a fixed-width signature, such as just R+S bytes (64 bytes),\nand not DER-encoding, then the signature is a fixed distance from\nthe last byte of the file. A conservative PSBT parser could start\nby verifying the signature exists and is valid, before parsing the\nrest of the file. (It would need to use the pubkeys from the original\nPSBT, which it would ideally have on-hand already to verify the source\nPSBT to the Coldcard.)\n\n> For Finalizers, since its job is to construct the final\n> scriptSig/scriptWitness, at worst, all it can do is produce an invalid\n> transaction. Finalizers don't have access to the private keys so there's\n> no bug possible that can result in a Finalizer producing a transaction\n> that reveals the private key.\n\nI agree that Finalizers cannot access the Bitcoin private keys, but\nthey still have stacks that can overflow, buffers that can be overrun\nand so on. Perhaps if sighash is not SIGHASH_ALL, there are dangerous\nthings they can be tricked into... I don't know, but at least we\nshould make it possible to detect these cases. My goal is detection.\n\n> ISTM the same is true of your proposal. You need to deserialize the PSBT\n> and then figure out which fields were \"original\" and in what order. If\n> there is a bug in your deserialization, an attacker can still exploit\n> that. And if there is a bug in your reconstruction of \"original\", you'll\n> have false positives.\n\nNo, I am not proposing anyone re-construct PSBT's... My proposal\nis really only helpful if you have the full original PSBT on hand\n(or its digest). For ultimate safety I would recommend checking the\nincoming PSBT's signature is valid before parsing it.(If the\nsignature is fixed-length, see above.)\n\n> My point was that you can achieve your MiTM protection by having the\n> signature separate from the PSBT. You can still make your ECDSA\n> signature and send it along with the PSBT, and you can do it with fixed\n> or exchanged keys, no need for parsing the PSBT itself. It can be part\n> of the transport protocol, not part of the data that is being transferred.\n\nIn the USB protocol between Coldcard and desktop, we do end-to-end\nencryption with a session key picked via diff-hel so we're doing\nour best there against MitM. However, our customers love the air-gap\nfeature which involves lots of sneakernet handling of MicroSD cards.\nI don't want to force them into handling paired files, like detacted\nsignatures, and I was hoping this would be a good way to move the\nsignatures inside the PSBT files already being moved about.\n\n---\nPeter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10\n\nOn Mon, Jan 13, 2020 at 05:05:10PM +0000, Andrew Chow wrote:\n> \n> On 1/13/20 9:28 AM, Peter D. Gray wrote:\n> > I don't have a specific attack in mind, but these signatures, if\n> > adopted by the community at large, will allow detection of-, and\n> > could mitigate damage from-, some broad \"bug-classes\".\n> > \n> > Consider if the PSBT Signer (hardware wallet) has bugs. Perhaps if\n> > you tweak the PSBT in some unnatural way it produces output that\n> > reveals the private key (duplicate k-value perhaps), or corrupts\n> > the display of the transaction in helpful (to the attacker) ways\n> > (typically case: output hidden as change).\n> \n> Since the PSBT is to be signed by one of the Signers for the PSBT, I\n> don't see how this is useful. If it is mutated and the signer has bugs,\n> especially parsing bugs, the Signer also adding its signature won't\n> help. In your proposal, it is the Signer who adds the signature, so it\n> will receive a PSBT without auth sigs and thus that could be mutated to\n> trigger those bugs anyways.\n> \n> > There could also be bugs in the Combiner/Finalizer which the MiTM\n> > wants to trigger. Legimate files, signed by the PSBT Signer, will not\n> > contain those attacks, so are \"safer\" to process, even if your\n> > Combiner's PSBT parser has bugs or is tragically dumb.\n> \n> The job of Combiners is fairly limited and is really just related to\n> parsing the PSBT into some internal object then shuffling those fields\n> around. In that case, any bugs an attacker would want to exploit have to\n> be deserialization bugs, in which case, your auth sigs don't help. The\n> Combiner still has to deserialize the PSBT to get the signature, then it\n> needs to re-serialize the PSBT to check that signature. An attacker\n> could insert bad bytes into the PSBT which causes problems during\n> deserialization, before the Combiner is able to check the signature.\n> \n> For Finalizers, since its job is to construct the final\n> scriptSig/scriptWitness, at worst, all it can do is produce an invalid\n> transaction. Finalizers don't have access to the private keys so there's\n> no bug possible that can result in a Finalizer producing a transaction\n> that reveals the private key.\n> \n> > \n> > That's just it, when we receive a signed PSBT, at present we don't\n> > know *what* was signed without a complete understanding of the\n> > transaction, the input UTXO (at least syntactially), and PSBT file\n> > contents.  If there are bugs in that understanding (ie. checks we\n> > all know are needed, but no-one actually implemented) then we might\n> > transmit an harmful transaction, or continue to process a file\n> > that has been corrupted-with-intent by a MiTM.\n> \n> ISTM the same is true of your proposal. You need to deserialize the PSBT\n> and then figure out which fields were \"original\" and in what order. If\n> there is a bug in your deserialization, an attacker can still exploit\n> that. And if there is a bug in your reconstruction of \"original\", you'll\n> have false positives.\n> \n> > It's fine to say that, but in an embedded environment, with very\n> > limited memory like the Coldcard, PGP isn't an option (signing vs.\n> > signature verification). I want to leverage the existing crypto and\n> > PKI that we already have in play.\n> \n> My point was that you can achieve your MiTM protection by having the\n> signature separate from the PSBT. You can still make your ECDSA\n> signature and send it along with the PSBT, and you can do it with fixed\n> or exchanged keys, no need for parsing the PSBT itself. It can be part\n> of the transport protocol, not part of the data that is being transferred.\n> \n> Andrew\n> \n> > \n> >> On 1/11/20 3:17 PM, Dmitry Petukhov via bitcoin-dev wrote:\n> > ... [many valid points, repeated by Andrew] ...\n> >>> If there is MitM, checking something at Finalizer is likely too\n> >>> late - the party that can intercept PSBTs can finalize before the\n> >>> legitimate Finalizer and broadcast the transaction.\n> > \n> > Yes, that is a problem which is proposal does not address. If the\n> > MitM has control over both directions, in and out, then whatever\n> > he or she was trying to do will still happen. Personally, I'm okay\n> > with that as a limition, but using the same signatures features,\n> > and a pre-shared public key between the PSBT Creator and the Signer,\n> > we could block the Signer from looking at MitM'ed files. (The Signer\n> > would require and verify incoming unsigned PSBT to contain the\n> > last-output-section-signature thing.) I'm not planning on supporting\n> > that on the Coldcard (at least not yet), but with the proposed\n> > additions, it is possible to do without further changes to the PSBT\n> > spec.\n> > \n> >>> Participants can work from the same PSBT ...\n> >>> either pass two files (original and updated), or work out which fields\n> >>> (key-value blobs) to remove to get the 'source' PSBT (which might not be\n> >>> trivial with presense of proprietary and unknown fields). Even if you\n> >>> know which key-value pairs to remove, there is no requirement for\n> >>> ordering of the fields, and some signer can serialize them in different\n> >>> order after dserialize/sign/add-signatures/re-serialize operation.\n> > ...\n> >>> Introducing additional ordering or other structure requirements over\n> >>> simple key-value structure will add complexity to PSBT processing, and\n> >>> adding complexity on such a basic level should have really serious\n> >>> reasons, because that increases effort required for even basic\n> >>> implementations and increases chance of bugs.\n> > \n> > I want these signatures to protect against PSBT parsing bugs. That's\n> > why they are byte-level on the whole file contents, and not based\n> > on sub-sections of the file or various fields inside the file. Yes,\n> > there are non-linear PSBT paths that will be difficult or impossible\n> > to support with this approach. I would not expect implementations to\n> > do anything fancy to reconstruct PSBT contents, I think they would\n> > just track the complete file. In most setups today the Creator,\n> > Combiner and Finalizer are the same device, and they are desktop\n> > systems with gigs of memory.\n> > \n> >>> If there is some authority on the 'correctness' of 'original' PSBT\n> >>> (all particpants receive same PSBT at the start), particpants should\n> >>> check the signature by that authority. That authority might use\n> >>> the key used only for authentication, and not in the tx signing.\n> > \n> > Yes, this can be acheived by pre-sharing a public key with the\n> > Signer (described above). Only signed incoming PSBT's would be\n> > accepted. That key doesn't have anything to do with the blockchain\n> > or value transfer.\n> > \n> >>> I think you do not need to wait for officially-assigned key numbers,\n> >>> and can just implement the scheme you envision with proprietary keys,\n> >>> document and promote it. Then if it shows its usefulness, it will\n> >>> either become de-facto standard with your proprietary keys...\n> > \n> > Yes, 100% ... but I value the list's feedback, and I would prefer to\n> > start with a legitimate key number which I don't need to change later. It's\n> > a non-breaking change and I wouldn't propose it otherwise.\n> > \n> > ---\n> > Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10\n> > \n> > On Mon, Jan 13, 2020 at 06:39:28AM +0000, Andrew Chow wrote:\n> >> I agree with Dimitry. I don't see the point of having the MiTM\n> >> protection within the PSBT structure itself, in addition to the fact\n> >> that adding new fields is largely unnecessary. In fact, I'm not quite\n> >> sure what kind of attack you are trying to defend against with this\n> >> proposal.\n> >>\n> >> If there is a MiTM who can modify your PSBT, then they can just modify\n> >> the result the signed PSBT to drop the auth signatures. Furthermore, any\n> >> modifications to scripts or UTXOs would just result in an invalid\n> >> signature, so only time is wasted. But you'll just waste time anyways\n> >> when you see a failed auth sig.\n> >>\n> >> Additionally, when a signer processes a PSBT, it will either accept the\n> >> PSBT and add a signature for its inputs, or reject it and do nothing.\n> >> Given this behavior (and I assume you aren't going to add auth sigs for\n> >> rejected PSBTs because that doesn't make any sense), then you already\n> >> have a signature there that covers everything your auth signature would\n> >> cover. So just verify those signatures instead; for any inputs with\n> >> signatures, everything you need to verify them are already there.\n> >>\n> >> Lastly, IMO, if you want MiTM protection, then you should do your\n> >> protection with out of band communication. Just PGP sign the PSBT (or\n> >> something similar) and send the signature along separately.\n> >>\n> >> Andrew\n> >>\n> >> On 1/11/20 3:17 PM, Dmitry Petukhov via bitcoin-dev wrote:\n> >>>\n> >>> I am not sure that this particular task should be done with data\n> >>> embedded in PSBT itself, and not with some sort of container that\n> >>> includes PSBT and the authentication information.\n> >>>\n> >>> The benefit seems to be in reusing PSBT structure for compatibilty, and\n> >>> this might be a valid way, although I do not agree with some of your\n> >>> points. I elaborate below:\n> >>>\n> >>>> 1) In the PSBT globals section, a signature over the \"source\" PSBT\n> >>>> file. It would cover all the bytes of the original PSBT file, as\n> >>>> it was received by the Signer.\n> >>>\n> >>> The problem of authenticating the contents of PSBT is independent of\n> >>> the signing action. PSBT might be altered on the path from Creator to\n> >>> Signer. Therefore you cannot always say that Signer will be an\n> >>> authority over 'correctness' of PSBT.\n> >>>\n> >>>> - At the end of the signing process, the Finalizer should check all\n> >>>> the Signers have worked from the same PSBT file (assuming that's\n> >>>> the flow expected)\n> >>>\n> >>> If there is MitM, checking something at Finalizer is likely too\n> >>> late - the party that can intercept PSBTs can finalize before the\n> >>> legitimate Finalizer and broadcast the transaction.\n> >>>\n> >>> Participants can work from the same PSBT file if they all receive the\n> >>> same PSBT, and not working in chain where next particpant receives\n> >>> updated PSBT from the previous participant. Otherwise they will need to\n> >>> either pass two files (original and updated), or work out which fields\n> >>> (key-value blobs) to remove to get the 'source' PSBT (which might not be\n> >>> trivial with presense of proprietary and unknown fields). Even if you\n> >>> know which key-value pairs to remove, there is no requirement for\n> >>> ordering of the fields, and some signer can serialize them in different\n> >>> order after dserialize/sign/add-signatures/re-serialize operation.\n> >>>\n> >>> Introducing additional ordering or other structure requirements over\n> >>> simple key-value structure will add complexity to PSBT processing, and\n> >>> adding complexity on such a basic level should have really serious\n> >>> reasons, because that increases effort required for even basic\n> >>> implementations and increases chance of bugs.\n> >>>\n> >>> If there is some authority on the 'correctness' of 'original' PSBT\n> >>> (all particpants receive same PSBT at the start), particpants should\n> >>> check the signature by that authority. That authority might use\n> >>> the key used only for authentication, and not in the tx signing.\n> >>>\n> >>> If particpants send PSBT in chain after adding their signatures, then\n> >>> each participant can add their signature to say 'the contents\n> >>> of PSBT after my updates should match this hash'.\n> >>>\n> >>> The signatures of previous participants in the chain most likely do not\n> >>> matter because of difficulty of restoring the contents of PSBT as it\n> >>> was before the previous particpant, if you do not pass _all_ the PSBTs\n> >>> (which is excessive).\n> >>>\n> >>>> 2) In the output section, specifically, the last key/value pair of\n> >>>> the last output of the transaction, I want to add a similar signature,\n> >>>> again signed by one of the keys used in the signing process. This\n> >>>> signature will cover all the bytes of the resulting (signed) PSBT\n> >>>> up to that point. Because it is the last output of the output\n> >>>> section, that signature will be the last few bytes of the PSBT file.\n> >>>> By \"appending\" the signature in this way, it's easier to validate\n> >>>> and create the signature, without blanking the signature area during\n> >>>> digest step.\n> >>>\n> >>> This will introduce unnecessary higher-level structure to PSBT for the\n> >>> reasons that I do not find strong enough for the amount of complexity\n> >>> added.\n> >>>\n> >>> Also, as I said above, you likely do not need more than one\n> >>> signature - if this is 'fan-out' scheme, then participants need do\n> >>> check the sig of authority that created PSBT; if this is piggy-back\n> >>> chain, then only previous particpant's signature is easily verifiable.\n> >>>\n> >>>> ## Next Steps\n> >>>>\n> >>>> I'd like to get two officially-assigned BIP-174 key numbers assigned\n> >>>> for these two signatures, and then I will see that it gets added\n> >>>> into Coldcard's firmware immediately. In time, other tools are\n> >>>> welcome to take advantage of these checks. I will also write a BIP\n> >>>> for this, and/or make an addition to BIP-174.\n> >>>\n> >>> I think you do not need to wait for officially-assigned key numbers,\n> >>> and can just implement the scheme you envision with proprietary keys,\n> >>> document and promote it. Then if it shows its usefulness, it will\n> >>> either become de-facto standard with your proprietary keys (and\n> >>> everyone will want to support 'Coldard PSBT auth' or whatever the name),\n> >>> or the scheme will have serious grounds to be converted to standard and\n> >>> have non-proprietary keys assigned.\n> >>>\n> >>> // Dmitry.\n> >>> _______________________________________________\n> >>> bitcoin-dev mailing list\n> >>> bitcoin-dev at lists.linuxfoundation.org\n> >>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >>>\n>"
            },
            {
                "author": "Andrew Chow",
                "date": "2020-01-13T23:18:34",
                "message_text_only": "On 1/13/20 3:29 PM, Peter D. Gray wrote:\n> The Signer may be signing a PSBT that was corrupted by the MitM,\n> but at least later users of the signed PSBT can detect that occured.\n> At present, they do not know what the input PSBT content was when\n> it got to the Signer.\n\nBut the MiTM on the way to the other roles will still see that signed\nPSBT, and if the Signer has produced a signature such that someone can\nget the private key, that MiTM will have the private key before the\ntransaction is broadcast. If this isn't part of your threat model, I\nthink it should be; I don't think it is reasonable to say that you are\nonly protecting against MiTM for one specific leg of the entire protocol.\n\n> If we use a fixed-width signature, such as just R+S bytes (64 bytes),\n> and not DER-encoding, then the signature is a fixed distance from\n> the last byte of the file. A conservative PSBT parser could start\n> by verifying the signature exists and is valid, before parsing the\n> rest of the file. (It would need to use the pubkeys from the original\n> PSBT, which it would ideally have on-hand already to verify the source\n> PSBT to the Coldcard.)\n\nWhy the end? This brings up a particular implementation detail I didn't\nwant to get into since I was opposing the idea conceptually, but I don't\nthink that 2 new types are necessary. We absolutely do not need nor\nshould we have any global data (and the auth sig is absolutely global\ndata) in input or output specific fields. The outputs really should be\nindependent of the other inputs and outputs. So having the last output\nhave the signature is a layer violation.\n\nWhy put it at the end? If you want a byte offset, just put the signature\nin the globals as the first kv pair.\n\n> I agree that Finalizers cannot access the Bitcoin private keys, but\n> they still have stacks that can overflow, buffers that can be overrun\n> and so on. Perhaps if sighash is not SIGHASH_ALL, there are dangerous\n> things they can be tricked into... I don't know, but at least we\n> should make it possible to detect these cases. My goal is detection.\n\nBut that shouldn't matter to the Finalizer. It isn't the Finalizer's job\nto enforce that the Signers followed a specific signing policy. If the\nSigner chose to sign with a \"dangerous policy\", that's up to the signer\nand the Finalizers shouldn't have anything to do with that.\n\n> No, I am not proposing anyone re-construct PSBT's... My proposal\n> is really only helpful if you have the full original PSBT on hand\n> (or its digest). For ultimate safety I would recommend checking the\n> incoming PSBT's signature is valid before parsing it.(If the\n> signature is fixed-length, see above.)\n\nThat's another thing I don't understand about your proposal. Your\nsignature covers the \"Original PSBT\" which is really nebulous and could\nanything. This doesn't make sense to me. Everyone has to somehow get the\nsame \"Original PSBT\" so you are assuming there's no MiTM in that initial\ndistribution (seems like an oversight in your threat model).\n\nBut then your \"Original PSBT\" can also be in a number of different\nstates, and your signature wouldn't cover some things. For example, the\n\"Original\" could have just some of the UTXOs and some of the scripts,\nnot everything. So in later steps of the process, the MiTM protection\ndoesn't cover those things, so an attacker could modify them with no\neffect on the signature.\n\n> In the USB protocol between Coldcard and desktop, we do end-to-end\n> encryption with a session key picked via diff-hel so we're doing\n> our best there against MitM. However, our customers love the air-gap\n> feature which involves lots of sneakernet handling of MicroSD cards.\n> I don't want to force them into handling paired files, like detacted\n> signatures, and I was hoping this would be a good way to move the\n> signatures inside the PSBT files already being moved about.\n\nYou could put them in an archive (tarfile) so it's still just one file\nbeing copied from the SD card. You already have archive creation on the\ncoldcard for backup creation anyways.\n\n***\n\nI guess what I don't get about this proposal is your threat model and\nwhat specifically you are protecting against. It seems like this is only\nprotecting against the specific leg from a specific combined\nUpdater/Finalizer to and from its respective Signer. But this is not\nalways the use case and this isn't very generic. Other places that there\ncould be MiTM aren't covered.\n\nI also don't get what a MiTM could even do. If your parser is vulnerable\nto the standard programming vulns (buffer overflows, stack overflows,\netc.), ISTM you will still run into those with just a normal PSBT. If\nyou don't, then a MiTM can't trigger one there. And likewise for\nsignature issues; if your signer might produce a private key leaking\nsignature, then it will probably do that with a non-MiTM'd PSBT, and if\nnot, MiTM isn't going to change that.\n\nAndrew\n\n> \n> ---\n> Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10\n> \n> On Mon, Jan 13, 2020 at 05:05:10PM +0000, Andrew Chow wrote:\n>>\n>> On 1/13/20 9:28 AM, Peter D. Gray wrote:\n>>> I don't have a specific attack in mind, but these signatures, if\n>>> adopted by the community at large, will allow detection of-, and\n>>> could mitigate damage from-, some broad \"bug-classes\".\n>>>\n>>> Consider if the PSBT Signer (hardware wallet) has bugs. Perhaps if\n>>> you tweak the PSBT in some unnatural way it produces output that\n>>> reveals the private key (duplicate k-value perhaps), or corrupts\n>>> the display of the transaction in helpful (to the attacker) ways\n>>> (typically case: output hidden as change).\n>>\n>> Since the PSBT is to be signed by one of the Signers for the PSBT, I\n>> don't see how this is useful. If it is mutated and the signer has bugs,\n>> especially parsing bugs, the Signer also adding its signature won't\n>> help. In your proposal, it is the Signer who adds the signature, so it\n>> will receive a PSBT without auth sigs and thus that could be mutated to\n>> trigger those bugs anyways.\n>>\n>>> There could also be bugs in the Combiner/Finalizer which the MiTM\n>>> wants to trigger. Legimate files, signed by the PSBT Signer, will not\n>>> contain those attacks, so are \"safer\" to process, even if your\n>>> Combiner's PSBT parser has bugs or is tragically dumb.\n>>\n>> The job of Combiners is fairly limited and is really just related to\n>> parsing the PSBT into some internal object then shuffling those fields\n>> around. In that case, any bugs an attacker would want to exploit have to\n>> be deserialization bugs, in which case, your auth sigs don't help. The\n>> Combiner still has to deserialize the PSBT to get the signature, then it\n>> needs to re-serialize the PSBT to check that signature. An attacker\n>> could insert bad bytes into the PSBT which causes problems during\n>> deserialization, before the Combiner is able to check the signature.\n>>\n>> For Finalizers, since its job is to construct the final\n>> scriptSig/scriptWitness, at worst, all it can do is produce an invalid\n>> transaction. Finalizers don't have access to the private keys so there's\n>> no bug possible that can result in a Finalizer producing a transaction\n>> that reveals the private key.\n>>\n>>>\n>>> That's just it, when we receive a signed PSBT, at present we don't\n>>> know *what* was signed without a complete understanding of the\n>>> transaction, the input UTXO (at least syntactially), and PSBT file\n>>> contents.  If there are bugs in that understanding (ie. checks we\n>>> all know are needed, but no-one actually implemented) then we might\n>>> transmit an harmful transaction, or continue to process a file\n>>> that has been corrupted-with-intent by a MiTM.\n>>\n>> ISTM the same is true of your proposal. You need to deserialize the PSBT\n>> and then figure out which fields were \"original\" and in what order. If\n>> there is a bug in your deserialization, an attacker can still exploit\n>> that. And if there is a bug in your reconstruction of \"original\", you'll\n>> have false positives.\n>>\n>>> It's fine to say that, but in an embedded environment, with very\n>>> limited memory like the Coldcard, PGP isn't an option (signing vs.\n>>> signature verification). I want to leverage the existing crypto and\n>>> PKI that we already have in play.\n>>\n>> My point was that you can achieve your MiTM protection by having the\n>> signature separate from the PSBT. You can still make your ECDSA\n>> signature and send it along with the PSBT, and you can do it with fixed\n>> or exchanged keys, no need for parsing the PSBT itself. It can be part\n>> of the transport protocol, not part of the data that is being transferred.\n>>\n>> Andrew\n>>\n>>>\n>>>> On 1/11/20 3:17 PM, Dmitry Petukhov via bitcoin-dev wrote:\n>>> ... [many valid points, repeated by Andrew] ...\n>>>>> If there is MitM, checking something at Finalizer is likely too\n>>>>> late - the party that can intercept PSBTs can finalize before the\n>>>>> legitimate Finalizer and broadcast the transaction.\n>>>\n>>> Yes, that is a problem which is proposal does not address. If the\n>>> MitM has control over both directions, in and out, then whatever\n>>> he or she was trying to do will still happen. Personally, I'm okay\n>>> with that as a limition, but using the same signatures features,\n>>> and a pre-shared public key between the PSBT Creator and the Signer,\n>>> we could block the Signer from looking at MitM'ed files. (The Signer\n>>> would require and verify incoming unsigned PSBT to contain the\n>>> last-output-section-signature thing.) I'm not planning on supporting\n>>> that on the Coldcard (at least not yet), but with the proposed\n>>> additions, it is possible to do without further changes to the PSBT\n>>> spec.\n>>>\n>>>>> Participants can work from the same PSBT ...\n>>>>> either pass two files (original and updated), or work out which fields\n>>>>> (key-value blobs) to remove to get the 'source' PSBT (which might not be\n>>>>> trivial with presense of proprietary and unknown fields). Even if you\n>>>>> know which key-value pairs to remove, there is no requirement for\n>>>>> ordering of the fields, and some signer can serialize them in different\n>>>>> order after dserialize/sign/add-signatures/re-serialize operation.\n>>> ...\n>>>>> Introducing additional ordering or other structure requirements over\n>>>>> simple key-value structure will add complexity to PSBT processing, and\n>>>>> adding complexity on such a basic level should have really serious\n>>>>> reasons, because that increases effort required for even basic\n>>>>> implementations and increases chance of bugs.\n>>>\n>>> I want these signatures to protect against PSBT parsing bugs. That's\n>>> why they are byte-level on the whole file contents, and not based\n>>> on sub-sections of the file or various fields inside the file. Yes,\n>>> there are non-linear PSBT paths that will be difficult or impossible\n>>> to support with this approach. I would not expect implementations to\n>>> do anything fancy to reconstruct PSBT contents, I think they would\n>>> just track the complete file. In most setups today the Creator,\n>>> Combiner and Finalizer are the same device, and they are desktop\n>>> systems with gigs of memory.\n>>>\n>>>>> If there is some authority on the 'correctness' of 'original' PSBT\n>>>>> (all particpants receive same PSBT at the start), particpants should\n>>>>> check the signature by that authority. That authority might use\n>>>>> the key used only for authentication, and not in the tx signing.\n>>>\n>>> Yes, this can be acheived by pre-sharing a public key with the\n>>> Signer (described above). Only signed incoming PSBT's would be\n>>> accepted. That key doesn't have anything to do with the blockchain\n>>> or value transfer.\n>>>\n>>>>> I think you do not need to wait for officially-assigned key numbers,\n>>>>> and can just implement the scheme you envision with proprietary keys,\n>>>>> document and promote it. Then if it shows its usefulness, it will\n>>>>> either become de-facto standard with your proprietary keys...\n>>>\n>>> Yes, 100% ... but I value the list's feedback, and I would prefer to\n>>> start with a legitimate key number which I don't need to change later. It's\n>>> a non-breaking change and I wouldn't propose it otherwise.\n>>>\n>>> ---\n>>> Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10\n>>>\n>>> On Mon, Jan 13, 2020 at 06:39:28AM +0000, Andrew Chow wrote:\n>>>> I agree with Dimitry. I don't see the point of having the MiTM\n>>>> protection within the PSBT structure itself, in addition to the fact\n>>>> that adding new fields is largely unnecessary. In fact, I'm not quite\n>>>> sure what kind of attack you are trying to defend against with this\n>>>> proposal.\n>>>>\n>>>> If there is a MiTM who can modify your PSBT, then they can just modify\n>>>> the result the signed PSBT to drop the auth signatures. Furthermore, any\n>>>> modifications to scripts or UTXOs would just result in an invalid\n>>>> signature, so only time is wasted. But you'll just waste time anyways\n>>>> when you see a failed auth sig.\n>>>>\n>>>> Additionally, when a signer processes a PSBT, it will either accept the\n>>>> PSBT and add a signature for its inputs, or reject it and do nothing.\n>>>> Given this behavior (and I assume you aren't going to add auth sigs for\n>>>> rejected PSBTs because that doesn't make any sense), then you already\n>>>> have a signature there that covers everything your auth signature would\n>>>> cover. So just verify those signatures instead; for any inputs with\n>>>> signatures, everything you need to verify them are already there.\n>>>>\n>>>> Lastly, IMO, if you want MiTM protection, then you should do your\n>>>> protection with out of band communication. Just PGP sign the PSBT (or\n>>>> something similar) and send the signature along separately.\n>>>>\n>>>> Andrew\n>>>>\n>>>> On 1/11/20 3:17 PM, Dmitry Petukhov via bitcoin-dev wrote:\n>>>>>\n>>>>> I am not sure that this particular task should be done with data\n>>>>> embedded in PSBT itself, and not with some sort of container that\n>>>>> includes PSBT and the authentication information.\n>>>>>\n>>>>> The benefit seems to be in reusing PSBT structure for compatibilty, and\n>>>>> this might be a valid way, although I do not agree with some of your\n>>>>> points. I elaborate below:\n>>>>>\n>>>>>> 1) In the PSBT globals section, a signature over the \"source\" PSBT\n>>>>>> file. It would cover all the bytes of the original PSBT file, as\n>>>>>> it was received by the Signer.\n>>>>>\n>>>>> The problem of authenticating the contents of PSBT is independent of\n>>>>> the signing action. PSBT might be altered on the path from Creator to\n>>>>> Signer. Therefore you cannot always say that Signer will be an\n>>>>> authority over 'correctness' of PSBT.\n>>>>>\n>>>>>> - At the end of the signing process, the Finalizer should check all\n>>>>>> the Signers have worked from the same PSBT file (assuming that's\n>>>>>> the flow expected)\n>>>>>\n>>>>> If there is MitM, checking something at Finalizer is likely too\n>>>>> late - the party that can intercept PSBTs can finalize before the\n>>>>> legitimate Finalizer and broadcast the transaction.\n>>>>>\n>>>>> Participants can work from the same PSBT file if they all receive the\n>>>>> same PSBT, and not working in chain where next particpant receives\n>>>>> updated PSBT from the previous participant. Otherwise they will need to\n>>>>> either pass two files (original and updated), or work out which fields\n>>>>> (key-value blobs) to remove to get the 'source' PSBT (which might not be\n>>>>> trivial with presense of proprietary and unknown fields). Even if you\n>>>>> know which key-value pairs to remove, there is no requirement for\n>>>>> ordering of the fields, and some signer can serialize them in different\n>>>>> order after dserialize/sign/add-signatures/re-serialize operation.\n>>>>>\n>>>>> Introducing additional ordering or other structure requirements over\n>>>>> simple key-value structure will add complexity to PSBT processing, and\n>>>>> adding complexity on such a basic level should have really serious\n>>>>> reasons, because that increases effort required for even basic\n>>>>> implementations and increases chance of bugs.\n>>>>>\n>>>>> If there is some authority on the 'correctness' of 'original' PSBT\n>>>>> (all particpants receive same PSBT at the start), particpants should\n>>>>> check the signature by that authority. That authority might use\n>>>>> the key used only for authentication, and not in the tx signing.\n>>>>>\n>>>>> If particpants send PSBT in chain after adding their signatures, then\n>>>>> each participant can add their signature to say 'the contents\n>>>>> of PSBT after my updates should match this hash'.\n>>>>>\n>>>>> The signatures of previous participants in the chain most likely do not\n>>>>> matter because of difficulty of restoring the contents of PSBT as it\n>>>>> was before the previous particpant, if you do not pass _all_ the PSBTs\n>>>>> (which is excessive).\n>>>>>\n>>>>>> 2) In the output section, specifically, the last key/value pair of\n>>>>>> the last output of the transaction, I want to add a similar signature,\n>>>>>> again signed by one of the keys used in the signing process. This\n>>>>>> signature will cover all the bytes of the resulting (signed) PSBT\n>>>>>> up to that point. Because it is the last output of the output\n>>>>>> section, that signature will be the last few bytes of the PSBT file.\n>>>>>> By \"appending\" the signature in this way, it's easier to validate\n>>>>>> and create the signature, without blanking the signature area during\n>>>>>> digest step.\n>>>>>\n>>>>> This will introduce unnecessary higher-level structure to PSBT for the\n>>>>> reasons that I do not find strong enough for the amount of complexity\n>>>>> added.\n>>>>>\n>>>>> Also, as I said above, you likely do not need more than one\n>>>>> signature - if this is 'fan-out' scheme, then participants need do\n>>>>> check the sig of authority that created PSBT; if this is piggy-back\n>>>>> chain, then only previous particpant's signature is easily verifiable.\n>>>>>\n>>>>>> ## Next Steps\n>>>>>>\n>>>>>> I'd like to get two officially-assigned BIP-174 key numbers assigned\n>>>>>> for these two signatures, and then I will see that it gets added\n>>>>>> into Coldcard's firmware immediately. In time, other tools are\n>>>>>> welcome to take advantage of these checks. I will also write a BIP\n>>>>>> for this, and/or make an addition to BIP-174.\n>>>>>\n>>>>> I think you do not need to wait for officially-assigned key numbers,\n>>>>> and can just implement the scheme you envision with proprietary keys,\n>>>>> document and promote it. Then if it shows its usefulness, it will\n>>>>> either become de-facto standard with your proprietary keys (and\n>>>>> everyone will want to support 'Coldard PSBT auth' or whatever the name),\n>>>>> or the scheme will have serious grounds to be converted to standard and\n>>>>> have non-proprietary keys assigned.\n>>>>>\n>>>>> // Dmitry.\n>>>>> _______________________________________________\n>>>>> bitcoin-dev mailing list\n>>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>>\n>>"
            }
        ],
        "thread_summary": {
            "title": "PSBT Addition (BIP 174) for authenticating source/output PSBT files",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Andrew Chow",
                "Peter D. Gray",
                "Dmitry Petukhov"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 78356
        }
    },
    {
        "title": "[bitcoin-dev] Coins: A trustless sidechain protocol",
        "thread_messages": [
            {
                "author": "Robin Linus",
                "date": "2020-01-12T18:54:57",
                "message_text_only": "Hi all,\n\nI've been working on a sidechain protocol with no trusted third party. You can find the [whitepaper here](http://coins.github.io/coins.pdf).\n\nAbstract. Coins is a Bitcoin extension designed for payments at scale. We propose an efficient solution to the double-spending problem using a bitcoin-backed proof-of-stake.  Validators vote on sidechain blocks with one-time signatures, forming a record that cannot be changed without destroying their collateral. Every user can become a validator by locking bitcoins. One-time signatures guarantee that validators loose their stake for publishing conflicting histories. Checkpoints can be additionally secured with a bitcoin-backed proof-of-burn. Assuming a rational majority of validators, the sidechain provides safety and liveness. The sidechain\u2019s footprint within bitcoin\u2019s blockchain is minimal. The protocol is a generic consensus mechanism allowing for arbitrary sidechain assets. Spawning multiple, independent instances scales horizontally.\n\nFeedback is highly appreciated!\n\nThank you\n\n- Robin\n\nPS: [Here on Github you can find further research on scalability and usability](https://github.com/coins/coins.github.io).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200112/10bc934c/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-01-13T00:21:42",
                "message_text_only": "Good morning Robin,\n\nThe reason why I stopped considering sidechains for scaling and have since moved to Lightning Network development was that, on reflection, I realized sidechains *still* do not scale, even with stakes anchored on the mainchain.\nThe issue is that sidechains, like any blockchain, still require that everyone interested in it to propagate all their transaction to everyone else interested in it.\nContrast this with Lightning Network, where you select only a tiny handful of nodes to inform about your payment, even if you have a gigantic Lightning Network.\n\nOr, more blithely: Let me get this straight, you already know blockchains cannot scale, so your scaling proposal involves making ***more*** blockchains?\n\nYou might point to the use of large numbers of sidechains with limited userbase, and the use of cross-chain atomic swaps to convert between sidecoins.\nI would then point out that Lightning Network channel are cryptocurrency systems with two users (with significantly better security than a 2-user sidechain would have), and that Lightning Network payment routing is just the use of cross-channel atomic swaps to convert between channelcoins.\nIndeed, with a multiparticipant offchain updateable cryptocurrency system mechanism, like Decker-Wattenhofer or Decker-Russell-Osuntokun (\"eltoo\"), you could entirely replace sidechains with a mechanism that does not give custody to your funds to anyone else, since you can always insist on using n-of-n signing with you included in the signer set to prevent state changes that do not have your approval.\n\n---\n\nYou could implement the collateral contract with a simple `<one year> OP_CHECKSEQUENCEVERIFY OP_DROP <A> OP_CHECKSIG`, with a single-sign signature used at the consensus layer for your sidechain.\n`OP_CHECKSEQUENCEVERIFY` ensures, as a side effect, that the spending transaction opts in to RBF.\nThus, if the pubkey `<A>` is used in a single-sign signature scheme (which reveals the privkey if double-signed), then at the end of the period, anyone who saw the double-signing can claim that fund and thus act as \"Bob\".\nIndeed, many \"Bob\"s will act and claim this fund, increasing the fee each time to try to get their version onchain.\nEventually, some \"Bob\" will just put the entire fund as fee and put a measly `OP_RETURN` as single output.\nThis \"burns\" the funds by donating it to miners.\n\n>From the point of view of Alice this is hardly distinguishable from losing the fund right now, since Alice will have a vanishingly low chance of spending it after the collateral period ends, and Alice still cannot touch the funds now anyway.\nAlice also cannot plausibly bribe a miner, since the miner could always get more funds by replacing the transaction internally with a spend-everything-on-fees `OP_RETURN` output transaction, and can only persuade the miner not to engage in this behavior by offering more than the collateral is worth (which is always worse than just losing the collateral).\n\nA `OP_CHECKTEMPLATEVERIFY` would work better for this use-case, but even without it you do not need a *single* *tr\\*sted* Bob to implement the collateral contract.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Robin Linus",
                "date": "2020-01-13T02:02:53",
                "message_text_only": "Good morning ZmnSCPxj,\n\nThank you for your detailed feedback! Two topics:\n\n\n\n## Lightning vs Sidechains\nWhy an either-or-solution, if we can connect sidechains via the LN to get the best of both worlds?\n\nThe LN works exceptionally great under the following conditions:\n- you're always online\n- you have BTC to manage your channels' inbound-capacity\n- you can afford BTC transactions\n\t- in your channel is much more than the minimum on-chain TX fees\n\nThe next Billion users do not fit that category. They are on unreliable cell phone connections and do not have any BTC yet.\nAnd the more popular Bitcoin becomes, the fewer people can afford LN channels. Even Eltoo requires your funds to be significantly higher than Bitcoin's TX fees, right?\n\nAlready today, more and more services like tippin.me, BlueWallet, etc, provide custodial solutions.\nFor small amounts, custody is an acceptable workaround. And I love their usability. Install it and immediately I can send you $0.01. Yet, scaling their approach globally does not lead to desirable outcomes, since we'd be back to trusting banks with their Excel sheets.\n\nSo let's make their internal ledgers public and trustless, via independent sidechains. Decentralized Blockchains do scale decently up to a couple Million UTXOs. So a couple thousand Sidechains is probably sufficient for a global medium of exchange. Cross-chain communication without requiring cross-chain validation is possible via atomic swaps and through Bitcoin's LN. That scales because it separates chain-validators from swap-validators.\nBitcoin's LN acts as the central settlement layer for efficient cross-chain transactions between all sidechains.\n\nSo Endusers \"living\" in sidechains instead of directly in the LN has many advantages:\n- no bitcoin blockspace required for on-boarding new users\n- no need to lock funds to provide inbound-capacity\n- no need to stay online or pay watch towers\n- no need to store channel histories\n- account balances can be much smaller than BTC TX fees\n\nThose are the exact same reasons why BlueWallet built their LndHub. But sidechains can be trustless. Also a generic protocol provides flexibility for sidechain innovations with arbitrary digital assets and consensus rules.\n\n\n\n\n## Collateral Contract\nThanks for mentioning that! I like the simplicity of your variant! It's better than my workarounds. I'll add it to the paper. However, in the long term, the cleanest solution is to destroy the funds. Giving it to miners assumes Alice does not control much Hash power, which is harder to reason about.\n\n\nRegards,\nrobin\n\n\n\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Monday, January 13, 2020 1:21 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Robin,\n>\n> The reason why I stopped considering sidechains for scaling and have since moved to Lightning Network development was that, on reflection, I realized sidechains still do not scale, even with stakes anchored on the mainchain.\n> The issue is that sidechains, like any blockchain, still require that everyone interested in it to propagate all their transaction to everyone else interested in it.\n> Contrast this with Lightning Network, where you select only a tiny handful of nodes to inform about your payment, even if you have a gigantic Lightning Network.\n>\n> Or, more blithely: Let me get this straight, you already know blockchains cannot scale, so your scaling proposal involves making more blockchains?\n>\n> You might point to the use of large numbers of sidechains with limited userbase, and the use of cross-chain atomic swaps to convert between sidecoins.\n> I would then point out that Lightning Network channel are cryptocurrency systems with two users (with significantly better security than a 2-user sidechain would have), and that Lightning Network payment routing is just the use of cross-channel atomic swaps to convert between channelcoins.\n> Indeed, with a multiparticipant offchain updateable cryptocurrency system mechanism, like Decker-Wattenhofer or Decker-Russell-Osuntokun (\"eltoo\"), you could entirely replace sidechains with a mechanism that does not give custody to your funds to anyone else, since you can always insist on using n-of-n signing with you included in the signer set to prevent state changes that do not have your approval.\n>\n>\n\n\n>\n> Regards,\n> ZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-01-13T02:33:21",
                "message_text_only": "Good morning Robin,\n\n\n> Good morning ZmnSCPxj,\n>\n> Thank you for your detailed feedback! Two topics:\n>\n> Lightning vs Sidechains\n>\n> ------------------------\n>\n> Why an either-or-solution, if we can connect sidechains via the LN to get the best of both worlds?\n>\n> The LN works exceptionally great under the following conditions:\n>\n> -   you're always online\n> -   you have BTC to manage your channels' inbound-capacity\n> -   you can afford BTC transactions\n>     -   in your channel is much more than the minimum on-chain TX fees\n>\n>         The next Billion users do not fit that category. They are on unreliable cell phone connections and do not have any BTC yet.\n>         And the more popular Bitcoin becomes, the fewer people can afford LN channels. Even Eltoo requires your funds to be significantly higher than Bitcoin's TX fees, right?\n>\n>         Already today, more and more services like tippin.me, BlueWallet, etc, provide custodial solutions.\n>         For small amounts, custody is an acceptable workaround. And I love their usability. Install it and immediately I can send you $0.01. Yet, scaling their approach globally does not lead to desirable outcomes, since we'd be back to trusting banks with their Excel sheets.\n>\n>         So let's make their internal ledgers public and trustless, via independent sidechains. Decentralized Blockchains do scale decently up to a couple Million UTXOs. So a couple thousand Sidechains is probably sufficient for a global medium of exchange. Cross-chain communication without requiring cross-chain validation is possible via atomic swaps and through Bitcoin's LN. That scales because it separates chain-validators from swap-validators.\n>         Bitcoin's LN acts as the central settlement layer for efficient cross-chain transactions between all sidechains.\n>\n>         So Endusers \"living\" in sidechains instead of directly in the LN has many advantages:\n>\n> -   no bitcoin blockspace required for on-boarding new users\n> -   no need to lock funds to provide inbound-capacity\n> -   no need to stay online or pay watch towers\n> -   no need to store channel histories\n> -   account balances can be much smaller than BTC TX fees\n>\n>     Those are the exact same reasons why BlueWallet built their LndHub. But sidechains can be trustless. Also a generic protocol provides flexibility for sidechain innovations with arbitrary digital assets and consensus rules.\n\n\nWhich is why I brought up multiparticipant offchain updateable cryptocurrency systems.\nThe \"channel factories\" concepts does what you are looking for, except with better trust-minimization than sidechains can achieve.\nJust replace \"sidechain\" with either Decker-Wattenhofer or Decker-Russell-Osuntokun constructions.\nYou can even use the Somsen \"statechain\" mechanism, which rides a Decker-Wattenhofer/Decker-Russell-Osuntokun construction, though its trust-minimization is only very very slightly better than federated sidechains.\n\nIt is helpful to remember that Poon-Dryja, Decker-Wattenhofer, Decker-Russell-Osuntokun, and all other future such constructions, can host any contract that its lower layer can support.\nSo if you ride a Poon-Dryja on top of the Bitcoin blockchain, you can host HTLCs inside the Poon-Dryja, since the Bitcoin blockchain can host HTLCs.\nSimilarly, if you ride a Decker-Wattenhofer on top of the Bitcoin blockchain, you can host a Poon-Dryja inside the Decker-Wattenhofer, since the Bitcoin blockchain can host Poon-Dryja channels.\nThis central insight leads one to conclude that anything you can put onchain, you an generally also put offchain, so why use a chain at all except as an ultimate anchor to reality?\nPoon-Dryja is strictly two-participant, while Decker-Wattenhofer limits the practical number of updates due to its use of decrementing relative timelocks: so you put the payment layer in a bunch of Poon-Dryja channels which support tons of updates each but only two participants per channel, and create a layer that supports changes to the channel topology (where changes to the channel connectivity are expected to be much rarer than payments) and is multiparticipant so you can *actually* scale.\n\nInstead of using sidechains, just use channel factories.\nYou do not need to broadcast the entire internal ledgers of those services, only their customers need to know those internal ledgers, and sign off on the updates of those ledgers.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Joachim Str\u00f6mbergson",
                "date": "2020-01-13T17:34:17",
                "message_text_only": "> Instead of using sidechains, just use channel factories.\n\nI am not familiar enough with the latest advancements in this field. Is it possible using LN/channel factories to achieve off-line-like participation user experience without previous registration with any kind of gateway provider? For example, can you go online, join the network [somehow instantly], generate address/invoice and then put it somewhere for others to later use it when you are off-line? Can you also participate while being off-line for very long periods of time without relying on third party providers to secure your channels? If not, is using sidechains really equally replaceable with LN/CF constructions?\n\n\n\n\n\n\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Monday, January 13, 2020 2:33 AM, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Robin,\n>\n> > Good morning ZmnSCPxj,\n> > Thank you for your detailed feedback! Two topics:\n> > Lightning vs Sidechains\n> >\n> > Why an either-or-solution, if we can connect sidechains via the LN to get the best of both worlds?\n> > The LN works exceptionally great under the following conditions:\n> >\n> > -   you're always online\n> >\n> > -   you have BTC to manage your channels' inbound-capacity\n> >\n> > -   you can afford BTC transactions\n> >     -   in your channel is much more than the minimum on-chain TX fees\n> >         The next Billion users do not fit that category. They are on unreliable cell phone connections and do not have any BTC yet.\n> >         And the more popular Bitcoin becomes, the fewer people can afford LN channels. Even Eltoo requires your funds to be significantly higher than Bitcoin's TX fees, right?\n> >         Already today, more and more services like tippin.me, BlueWallet, etc, provide custodial solutions.\n> >         For small amounts, custody is an acceptable workaround. And I love their usability. Install it and immediately I can send you $0.01. Yet, scaling their approach globally does not lead to desirable outcomes, since we'd be back to trusting banks with their Excel sheets.\n> >         So let's make their internal ledgers public and trustless, via independent sidechains. Decentralized Blockchains do scale decently up to a couple Million UTXOs. So a couple thousand Sidechains is probably sufficient for a global medium of exchange. Cross-chain communication without requiring cross-chain validation is possible via atomic swaps and through Bitcoin's LN. That scales because it separates chain-validators from swap-validators.\n> >         Bitcoin's LN acts as the central settlement layer for efficient cross-chain transactions between all sidechains.\n> >         So Endusers \"living\" in sidechains instead of directly in the LN has many advantages:\n> >\n> > -   no bitcoin blockspace required for on-boarding new users\n> >\n> > -   no need to lock funds to provide inbound-capacity\n> >\n> > -   no need to stay online or pay watch towers\n> >\n> > -   no need to store channel histories\n> >\n> > -   account balances can be much smaller than BTC TX fees\n> >     Those are the exact same reasons why BlueWallet built their LndHub. But sidechains can be trustless. Also a generic protocol provides flexibility for sidechain innovations with arbitrary digital assets and consensus rules.\n> >\n>\n> Which is why I brought up multiparticipant offchain updateable cryptocurrency systems.\n> The \"channel factories\" concepts does what you are looking for, except with better trust-minimization than sidechains can achieve.\n> Just replace \"sidechain\" with either Decker-Wattenhofer or Decker-Russell-Osuntokun constructions.\n> You can even use the Somsen \"statechain\" mechanism, which rides a Decker-Wattenhofer/Decker-Russell-Osuntokun construction, though its trust-minimization is only very very slightly better than federated sidechains.\n>\n> It is helpful to remember that Poon-Dryja, Decker-Wattenhofer, Decker-Russell-Osuntokun, and all other future such constructions, can host any contract that its lower layer can support.\n> So if you ride a Poon-Dryja on top of the Bitcoin blockchain, you can host HTLCs inside the Poon-Dryja, since the Bitcoin blockchain can host HTLCs.\n> Similarly, if you ride a Decker-Wattenhofer on top of the Bitcoin blockchain, you can host a Poon-Dryja inside the Decker-Wattenhofer, since the Bitcoin blockchain can host Poon-Dryja channels.\n> This central insight leads one to conclude that anything you can put onchain, you an generally also put offchain, so why use a chain at all except as an ultimate anchor to reality?\n> Poon-Dryja is strictly two-participant, while Decker-Wattenhofer limits the practical number of updates due to its use of decrementing relative timelocks: so you put the payment layer in a bunch of Poon-Dryja channels which support tons of updates each but only two participants per channel, and create a layer that supports changes to the channel topology (where changes to the channel connectivity are expected to be much rarer than payments) and is multiparticipant so you can actually scale.\n>\n> Instead of using sidechains, just use channel factories.\n> You do not need to broadcast the entire internal ledgers of those services, only their customers need to know those internal ledgers, and sign off on the updates of those ledgers.\n>\n> Regards,\n> ZmnSCPxj\n>\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Jeremy",
                "date": "2020-01-13T22:05:21",
                "message_text_only": "https://utxos.org/uses/\n\nYes, you should check out the material at the link above. Specifically non\ninteractive channels solve this problem of one sided opens, where the other\nparty is passive/offline.\n\n\nOn Mon, Jan 13, 2020, 12:42 PM Joachim Str\u00f6mbergson via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> > Instead of using sidechains, just use channel factories.\n>\n> I am not familiar enough with the latest advancements in this field. Is it\n> possible using LN/channel factories to achieve off-line-like participation\n> user experience without previous registration with any kind of gateway\n> provider? For example, can you go online, join the network [somehow\n> instantly], generate address/invoice and then put it somewhere for others\n> to later use it when you are off-line? Can you also participate while being\n> off-line for very long periods of time without relying on third party\n> providers to secure your channels? If not, is using sidechains really\n> equally replaceable with LN/CF constructions?\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200113/87716194/attachment.html>"
            },
            {
                "author": "Angel Leon",
                "date": "2020-01-16T01:21:52",
                "message_text_only": "> Instead of using sidechains, just use channel factories.\n> You do not need to broadcast the entire internal ledgers of those\nservices, only their customers need to know those internal ledgers, and\nsign off on the updates of those ledgers.\n\nThat's right, all you need to broadcast is a small proof, a non-interactive\nblockchain suffix proof\nhttps://eprint.iacr.org/2017/963.pdf\n\n\n\nOn Sun, Jan 12, 2020 at 7:33 PM ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Robin,\n>\n>\n> > Good morning ZmnSCPxj,\n> >\n> > Thank you for your detailed feedback! Two topics:\n> >\n> > Lightning vs Sidechains\n> >\n> > ------------------------\n> >\n> > Why an either-or-solution, if we can connect sidechains via the LN to\n> get the best of both worlds?\n> >\n> > The LN works exceptionally great under the following conditions:\n> >\n> > -   you're always online\n> > -   you have BTC to manage your channels' inbound-capacity\n> > -   you can afford BTC transactions\n> >     -   in your channel is much more than the minimum on-chain TX fees\n> >\n> >         The next Billion users do not fit that category. They are on\n> unreliable cell phone connections and do not have any BTC yet.\n> >         And the more popular Bitcoin becomes, the fewer people can\n> afford LN channels. Even Eltoo requires your funds to be significantly\n> higher than Bitcoin's TX fees, right?\n> >\n> >         Already today, more and more services like tippin.me,\n> BlueWallet, etc, provide custodial solutions.\n> >         For small amounts, custody is an acceptable workaround. And I\n> love their usability. Install it and immediately I can send you $0.01. Yet,\n> scaling their approach globally does not lead to desirable outcomes, since\n> we'd be back to trusting banks with their Excel sheets.\n> >\n> >         So let's make their internal ledgers public and trustless, via\n> independent sidechains. Decentralized Blockchains do scale decently up to a\n> couple Million UTXOs. So a couple thousand Sidechains is probably\n> sufficient for a global medium of exchange. Cross-chain communication\n> without requiring cross-chain validation is possible via atomic swaps and\n> through Bitcoin's LN. That scales because it separates chain-validators\n> from swap-validators.\n> >         Bitcoin's LN acts as the central settlement layer for efficient\n> cross-chain transactions between all sidechains.\n> >\n> >         So Endusers \"living\" in sidechains instead of directly in the LN\n> has many advantages:\n> >\n> > -   no bitcoin blockspace required for on-boarding new users\n> > -   no need to lock funds to provide inbound-capacity\n> > -   no need to stay online or pay watch towers\n> > -   no need to store channel histories\n> > -   account balances can be much smaller than BTC TX fees\n> >\n> >     Those are the exact same reasons why BlueWallet built their LndHub.\n> But sidechains can be trustless. Also a generic protocol provides\n> flexibility for sidechain innovations with arbitrary digital assets and\n> consensus rules.\n>\n>\n> Which is why I brought up multiparticipant offchain updateable\n> cryptocurrency systems.\n> The \"channel factories\" concepts does what you are looking for, except\n> with better trust-minimization than sidechains can achieve.\n> Just replace \"sidechain\" with either Decker-Wattenhofer or\n> Decker-Russell-Osuntokun constructions.\n> You can even use the Somsen \"statechain\" mechanism, which rides a\n> Decker-Wattenhofer/Decker-Russell-Osuntokun construction, though its\n> trust-minimization is only very very slightly better than federated\n> sidechains.\n>\n> It is helpful to remember that Poon-Dryja, Decker-Wattenhofer,\n> Decker-Russell-Osuntokun, and all other future such constructions, can host\n> any contract that its lower layer can support.\n> So if you ride a Poon-Dryja on top of the Bitcoin blockchain, you can host\n> HTLCs inside the Poon-Dryja, since the Bitcoin blockchain can host HTLCs.\n> Similarly, if you ride a Decker-Wattenhofer on top of the Bitcoin\n> blockchain, you can host a Poon-Dryja inside the Decker-Wattenhofer, since\n> the Bitcoin blockchain can host Poon-Dryja channels.\n> This central insight leads one to conclude that anything you can put\n> onchain, you an generally also put offchain, so why use a chain at all\n> except as an ultimate anchor to reality?\n> Poon-Dryja is strictly two-participant, while Decker-Wattenhofer limits\n> the practical number of updates due to its use of decrementing relative\n> timelocks: so you put the payment layer in a bunch of Poon-Dryja channels\n> which support tons of updates each but only two participants per channel,\n> and create a layer that supports changes to the channel topology (where\n> changes to the channel connectivity are expected to be much rarer than\n> payments) and is multiparticipant so you can *actually* scale.\n>\n> Instead of using sidechains, just use channel factories.\n> You do not need to broadcast the entire internal ledgers of those\n> services, only their customers need to know those internal ledgers, and\n> sign off on the updates of those ledgers.\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200115/48d7ea4b/attachment-0001.html>"
            },
            {
                "author": "Joachim Str\u00f6mbergson",
                "date": "2020-01-13T18:06:17",
                "message_text_only": "While I haven't rejected sidechains entirely yet, this particular proposal seems uninteresting, especially for two reasons.\n\nOne \u2013 it introduces a new token for each sidechain and suggests atomic swaps to be used for the exchange of the mainchain token with the sidechain token. Such a model seems nonsensical to me because there seems to be excessive number of blockchain projects that can be used similarly just as the sidechain in this proposal. Pick almost any altcoin out there and you can atomic swap it with Bitcoin. The fact that your sidechain is somehow mathematically bound to Bitcoin seems arbitrary because at the end you have a new token and a new issuance model. Therefore this is not extending Bitcoin economy, which is strictly limited by its convergence to zero inflation. This proposal is inflating the supply with a new token, which goes against what many people consider as a pillar of Bitcoin's value proposal. I think if you implement this proposal, you are going not to be considered as a Bitcoin sidechain, but you will be, from certain point of view, indistinguishable from any other altcoin. At the level of my current understanding, the only interesting sidechain model is the [theoretical] one with a two way peg with Bitcoin, preserving the issuance policy of Bitcoin.\n\nTwo \u2013 the security of the proposed system seems to be very fragile, unless I have missed something. When I think about sidechains, I expect that it should be possible to create a niche chain which is used by few participants while the security of the chain is somehow guaranteed from its bind to the mainchain. If this was not the case, such a niche sidechain could easily be attacked, even if just stalled/censored for a long period time, with just a small [absolute] investment from an attacker, although this investment might be large if taken relatively to the utility of this niche sidechain. So if we speak concretely about your proposal, you assume honest majority of validators. But in your system the validators come from locking of stake on Bitcoin chain by nodes that are interested in a particular sidechain. If you put this model on a niche chain where only few participants are interested in it, it's trivial for an attacker to be stronger [have more Bitcoin to lock] than all legitimate users together. You should only use honest majority assumption where the scope is global, where it is very hard and very expensive to obtain majority.\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Sunday, January 12, 2020 6:54 PM, Robin Linus via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi all,\n>\n> I've been working on a sidechain protocol with no trusted third party. You can find the [whitepaper here](http://coins.github.io/coins.pdf).\n>\n> Abstract. Coins is a Bitcoin extension designed for payments at scale. We propose an efficient solution to the double-spending problem using a bitcoin-backed proof-of-stake.  Validators vote on sidechain blocks with one-time signatures, forming a record that cannot be changed without destroying their collateral. Every user can become a validator by locking bitcoins. One-time signatures guarantee that validators loose their stake for publishing conflicting histories. Checkpoints can be additionally secured with a bitcoin-backed proof-of-burn. Assuming a rational majority of validators, the sidechain provides safety and liveness. The sidechain\u2019s footprint within bitcoin\u2019s blockchain is minimal. The protocol is a generic consensus mechanism allowing for arbitrary sidechain assets. Spawning multiple, independent instances scales horizontally.\n>\n> Feedback is highly appreciated!\n>\n> Thank you\n>\n> - Robin\n>\n> PS: [Here on Github you can find further research on scalability and usability](https://github.com/coins/coins.github.io).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200113/8ec899cc/attachment-0001.html>"
            },
            {
                "author": "Robin Linus",
                "date": "2020-01-13T19:47:23",
                "message_text_only": "Hi Joachim,\n\nThank you for your detailed feedback!\n\nRegarding Reason #1:\nThis proposal is less like Bitcoin vs. Altcoins and much more like Ethereum vs. ERC20 tokens, because the derivatives are not in competition with BTC, but depend on it heavily. You support Bitcoin's growth by supporting such a sidechain.\nAlso, they won't work as separate currencies. For endusers you can abstract away all underlying complexities such that they have to think only in BTC. Exchanges rates can be hidden in TX fees. The sidechain derivatives would be nothing but a means of transfer. The unit of account is still BTC.\n\nRegarding Reason #2:\nIn the \"Limitations\" section I discuss the cost of halting the chain:\n\nTime value of locked bitcoins might be too cheap to protect the chain. We can introduce an additional cost and let validators burn bitcoins for every on-chain vote. This is much more robust because there is an ongoing cost for halting the system. Proof-of-burn has recently been formally analysed [16]. The economic implications of burning significant amounts of Bitcoin are questionable. A level of security comparable to Bitcoin requires the system\u2019s BTC burn rate to be equal to Bitcoin\u2019s infaltion rate.\n\nAlso remember, time value of Bitcoins is indeed a value. Even without a proof of burn, I'd consider such sidechains much more secure than those custodial lightning wallets which become more and more popular to circumvent the usability hurdles of the LN.\n\nThanks again,\n- Robin\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Monday, January 13, 2020 7:06 PM, Joachim Str\u00f6mbergson <joachimstr at protonmail.com> wrote:\n\n> While I haven't rejected sidechains entirely yet, this particular proposal seems uninteresting, especially for two reasons.\n>\n> One \u2013 it introduces a new token for each sidechain and suggests atomic swaps to be used for the exchange of the mainchain token with the sidechain token. Such a model seems nonsensical to me because there seems to be excessive number of blockchain projects that can be used similarly just as the sidechain in this proposal. Pick almost any altcoin out there and you can atomic swap it with Bitcoin. The fact that your sidechain is somehow mathematically bound to Bitcoin seems arbitrary because at the end you have a new token and a new issuance model. Therefore this is not extending Bitcoin economy, which is strictly limited by its convergence to zero inflation. This proposal is inflating the supply with a new token, which goes against what many people consider as a pillar of Bitcoin's value proposal. I think if you implement this proposal, you are going not to be considered as a Bitcoin sidechain, but you will be, from certain point of view, indistinguishable from any other altcoin. At the level of my current understanding, the only interesting sidechain model is the [theoretical] one with a two way peg with Bitcoin, preserving the issuance policy of Bitcoin.\n>\n> Two \u2013 the security of the proposed system seems to be very fragile, unless I have missed something. When I think about sidechains, I expect that it should be possible to create a niche chain which is used by few participants while the security of the chain is somehow guaranteed from its bind to the mainchain. If this was not the case, such a niche sidechain could easily be attacked, even if just stalled/censored for a long period time, with just a small [absolute] investment from an attacker, although this investment might be large if taken relatively to the utility of this niche sidechain. So if we speak concretely about your proposal, you assume honest majority of validators. But in your system the validators come from locking of stake on Bitcoin chain by nodes that are interested in a particular sidechain. If you put this model on a niche chain where only few participants are interested in it, it's trivial for an attacker to be stronger [have more Bitcoin to lock] than all legitimate users together. You should only use honest majority assumption where the scope is global, where it is very hard and very expensive to obtain majority.\n>\n> Sent with [ProtonMail](https://protonmail.com) Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Sunday, January 12, 2020 6:54 PM, Robin Linus via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi all,\n>>\n>> I've been working on a sidechain protocol with no trusted third party. You can find the [whitepaper here](http://coins.github.io/coins.pdf).\n>>\n>> Abstract. Coins is a Bitcoin extension designed for payments at scale. We propose an efficient solution to the double-spending problem using a bitcoin-backed proof-of-stake.  Validators vote on sidechain blocks with one-time signatures, forming a record that cannot be changed without destroying their collateral. Every user can become a validator by locking bitcoins. One-time signatures guarantee that validators loose their stake for publishing conflicting histories. Checkpoints can be additionally secured with a bitcoin-backed proof-of-burn. Assuming a rational majority of validators, the sidechain provides safety and liveness. The sidechain\u2019s footprint within bitcoin\u2019s blockchain is minimal. The protocol is a generic consensus mechanism allowing for arbitrary sidechain assets. Spawning multiple, independent instances scales horizontally.\n>>\n>> Feedback is highly appreciated!\n>>\n>> Thank you\n>>\n>> - Robin\n>>\n>> PS: [Here on Github you can find further research on scalability and usability](https://github.com/coins/coins.github.io).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200113/b82d6658/attachment.html>"
            },
            {
                "author": "Joachim Str\u00f6mbergson",
                "date": "2020-01-13T20:49:51",
                "message_text_only": "Hi Robin,\n\ninline...\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Monday, January 13, 2020 7:47 PM, Robin Linus <robinlinus at protonmail.com> wrote:\n\n> Hi Joachim,\n>\n> Thank you for your detailed feedback!\n>\n> Regarding Reason #1:\n> This proposal is less like Bitcoin vs. Altcoins and much more like Ethereum vs. ERC20 tokens, because the derivatives are not in competition with BTC, but depend on it heavily. You support Bitcoin's growth by supporting such a sidechain.\n> Also, they won't work as separate currencies. For endusers you can abstract away all underlying complexities such that they have to think only in BTC. Exchanges rates can be hidden in TX fees. The sidechain derivatives would be nothing but a means of transfer. The unit of account is still BTC.\n\nI can't see any difference and advantage over doing the same with say Litecoin. All you need is to create a special wallet which offers atomic swaps LTC-BTC and its unit of account displayed to user is going to be BTC. All you say will work perfectly with this special LTC wallet. Therefore your idea is as good as any other altcoin. In your case, someone else should indeed be able to create such a wallet in which the unit of account will be the new token, thus emulating the current LTC wallets. So the only difference in Litecoin is that the special wallet with BTC as unit is going to be created after the native one, while in your case it is vice versa.\n\nI simply can't see why I'd call this construction of yours a Bitcoin sidechain and any other altcoin not. So I'd call both altcoins.\n\n> Regarding Reason #2:\n> In the \"Limitations\" section I discuss the cost of halting the chain:\n>\n> Time value of locked bitcoins might be too cheap to protect the chain. We can introduce an additional cost and let validators burn bitcoins for every on-chain vote. This is much more robust because there is an ongoing cost for halting the system. Proof-of-burn has recently been formally analysed [16]. The economic implications of burning significant amounts of Bitcoin are questionable. A level of security comparable to Bitcoin requires the system\u2019s BTC burn rate to be equal to Bitcoin\u2019s infaltion rate.\n>\n> Also remember, time value of Bitcoins is indeed a value. Even without a proof of burn, I'd consider such sidechains much more secure than those custodial lightning wallets which become more and more popular to circumvent the usability hurdles of the LN.\n\nComparison to other models is not relevant to my claim that such construction is insecure for small sidechains. And for big sidechains the reason #1 prefers any other altcoin. Even if you introduce proof of burn, the final attack cost is small for an attacker in absolute numbers, despite the fact that in the relative numbers the cost is huge.\n\n> Thanks again,\n> - Robin\n>\n> Sent with [ProtonMail](https://protonmail.com) Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Monday, January 13, 2020 7:06 PM, Joachim Str\u00f6mbergson <joachimstr at protonmail.com> wrote:\n>\n>> While I haven't rejected sidechains entirely yet, this particular proposal seems uninteresting, especially for two reasons.\n>>\n>> One \u2013 it introduces a new token for each sidechain and suggests atomic swaps to be used for the exchange of the mainchain token with the sidechain token. Such a model seems nonsensical to me because there seems to be excessive number of blockchain projects that can be used similarly just as the sidechain in this proposal. Pick almost any altcoin out there and you can atomic swap it with Bitcoin. The fact that your sidechain is somehow mathematically bound to Bitcoin seems arbitrary because at the end you have a new token and a new issuance model. Therefore this is not extending Bitcoin economy, which is strictly limited by its convergence to zero inflation. This proposal is inflating the supply with a new token, which goes against what many people consider as a pillar of Bitcoin's value proposal. I think if you implement this proposal, you are going not to be considered as a Bitcoin sidechain, but you will be, from certain point of view, indistinguishable from any other altcoin. At the level of my current understanding, the only interesting sidechain model is the [theoretical] one with a two way peg with Bitcoin, preserving the issuance policy of Bitcoin.\n>>\n>> Two \u2013 the security of the proposed system seems to be very fragile, unless I have missed something. When I think about sidechains, I expect that it should be possible to create a niche chain which is used by few participants while the security of the chain is somehow guaranteed from its bind to the mainchain. If this was not the case, such a niche sidechain could easily be attacked, even if just stalled/censored for a long period time, with just a small [absolute] investment from an attacker, although this investment might be large if taken relatively to the utility of this niche sidechain. So if we speak concretely about your proposal, you assume honest majority of validators. But in your system the validators come from locking of stake on Bitcoin chain by nodes that are interested in a particular sidechain. If you put this model on a niche chain where only few participants are interested in it, it's trivial for an attacker to be stronger [have more Bitcoin to lock] than all legitimate users together. You should only use honest majority assumption where the scope is global, where it is very hard and very expensive to obtain majority.\n>>\n>> Sent with [ProtonMail](https://protonmail.com) Secure Email.\n>>\n>> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>> On Sunday, January 12, 2020 6:54 PM, Robin Linus via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Hi all,\n>>>\n>>> I've been working on a sidechain protocol with no trusted third party. You can find the [whitepaper here](http://coins.github.io/coins.pdf).\n>>>\n>>> Abstract. Coins is a Bitcoin extension designed for payments at scale. We propose an efficient solution to the double-spending problem using a bitcoin-backed proof-of-stake.  Validators vote on sidechain blocks with one-time signatures, forming a record that cannot be changed without destroying their collateral. Every user can become a validator by locking bitcoins. One-time signatures guarantee that validators loose their stake for publishing conflicting histories. Checkpoints can be additionally secured with a bitcoin-backed proof-of-burn. Assuming a rational majority of validators, the sidechain provides safety and liveness. The sidechain\u2019s footprint within bitcoin\u2019s blockchain is minimal. The protocol is a generic consensus mechanism allowing for arbitrary sidechain assets. Spawning multiple, independent instances scales horizontally.\n>>>\n>>> Feedback is highly appreciated!\n>>>\n>>> Thank you\n>>>\n>>> - Robin\n>>>\n>>> PS: [Here on Github you can find further research on scalability and usability](https://github.com/coins/coins.github.io).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200113/88c8c246/attachment-0001.html>"
            },
            {
                "author": "Robin Linus",
                "date": "2020-01-13T22:22:43",
                "message_text_only": "Hi Joachim,\n\n>> Regarding Reason #1:\n>> This proposal is less like Bitcoin vs. Altcoins and much more like Ethereum vs. ERC20 tokens, because the derivatives are not in competition with BTC, but depend on it heavily. You support Bitcoin's growth by supporting such a sidechain.\n>> Also, they won't work as separate currencies. For endusers you can abstract away all underlying complexities such that they have to think only in BTC. Exchanges rates can be hidden in TX fees. The sidechain derivatives would be nothing but a means of transfer. The unit of account is still BTC.\n>\n> I can't see any difference and advantage over doing the same with say Litecoin. All you need is to create a special wallet which offers atomic swaps LTC-BTC and its unit of account displayed to user is going to be BTC. All you say will work perfectly with this special LTC wallet. Therefore your idea is as good as any other altcoin. In your case, someone else should indeed be able to create such a wallet in which the unit of account will be the new token, thus emulating the current LTC wallets. So the only difference in Litecoin is that the special wallet with BTC as unit is going to be created after the native one, while in your case it is vice versa.\n>\n> I simply can't see why I'd call this construction of yours a Bitcoin sidechain and any other altcoin not. So I'd call both altcoins.\n\nLet me try to explain where I am coming from: Whenever I want to onboard a not-so-techy friend to Bitcoin by sending him $5 worth of BTC, I don't have many good options. Usually we end up using BlueWallet. It works great. Though it only works so well because it is fully custodial. That is how they solve all the tough LN problems like inbound-capacity of new users, watchtowers and channel backends. Their service is just an Excel table connect to the LN. Unfortunately, that is the best UX we can currently offer to endusers. To me that's unsatisfying. Is that how we want to enter the emerging markets and on-board the next Billion users? I like that BlueWallet gives me the option to run my own LndHub for my friends. Still, does that scale globally? More importantly, do we want that?\n\nNow let's think about the altcoins argument. We want to serve a billion users. Blockchains do scale well to about a couple Million UTXOs, so we require a network of a couple thousand altcoins to serve our users.\nWe know how to build a nice LN for all of our altcoins with a star-shaped topology around Bitcoin as the central settlement layer. Atomic swaps FTW. We can abstract away their native currencies. We display to our users only BTC, hide the exchange rates in the TX fees and we're done. That is actually a scalability solution. So why don't we do that?\nThe problem here is, that In the long term, the market of PoW blockchains should be a winner-takes-all market, right? So all PoW chains but Bitcoin will eventually die because they're wasting lots of value on their energy. So actually we don't want a couple thousand altcoins wasting resources on pointlessly weak PoW chains. We want a single PoW chain which is as strong as possible.\n\nThat's why I'd argue it makes sense to consider a bitcoin-backed PoS and build a LN of thousands of nameless altcoins.\n\nRegarding sidechain security: Burning BTC is almost equivalent to burning energy. You might argue that people won't burn BTC, but it is hard to argue against the strong theoretical security properties of proof-of-burn.\n\nFurthermore, even without burning BTC, using only proof-of-stake I can guarantee doublespending is impossible. There is a very low incentive to risk your BTC's time value. You can only halt a sidechain. And you can halt the sidechain only for as long as you maintain the staking majority. Once you start an attack, you increase the incentive for others to increase their stake. Staking happens in bitcoin's blockchain, which you can't halt. Once the rational stakers regain 51% you've lost a year of time value of your BTC. Note that you can easily enforce stakers having to stake per chain. This guarantees attackers can use their BTC only to attack one chain per year.\nThus, the security of such a bitcoin-based PoS is stronger then one might suspect.\n\nThanks again,\n- Robin\n\n>> Regarding Reason #2:\n>> In the \"Limitations\" section I discuss the cost of halting the chain:\n>>\n>> Time value of locked bitcoins might be too cheap to protect the chain. We can introduce an additional cost and let validators burn bitcoins for every on-chain vote. This is much more robust because there is an ongoing cost for halting the system. Proof-of-burn has recently been formally analysed [16]. The economic implications of burning significant amounts of Bitcoin are questionable. A level of security comparable to Bitcoin requires the system\u2019s BTC burn rate to be equal to Bitcoin\u2019s infaltion rate.\n>>\n>> Also remember, time value of Bitcoins is indeed a value. Even without a proof of burn, I'd consider such sidechains much more secure than those custodial lightning wallets which become more and more popular to circumvent the usability hurdles of the LN.\n>\n> Comparison to other models is not relevant to my claim that such construction is insecure for small sidechains. And for big sidechains the reason #1 prefers any other altcoin. Even if you introduce proof of burn, the final attack cost is small for an attacker in absolute numbers, despite the fact that in the relative numbers the cost is huge.\n>\n>> Thanks again,\n>> - Robin\n>>\n>> Sent with [ProtonMail](https://protonmail.com) Secure Email.\n>>\n>> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>> On Monday, January 13, 2020 7:06 PM, Joachim Str\u00f6mbergson <joachimstr at protonmail.com> wrote:\n>>\n>>> While I haven't rejected sidechains entirely yet, this particular proposal seems uninteresting, especially for two reasons.\n>>>\n>>> One \u2013 it introduces a new token for each sidechain and suggests atomic swaps to be used for the exchange of the mainchain token with the sidechain token. Such a model seems nonsensical to me because there seems to be excessive number of blockchain projects that can be used similarly just as the sidechain in this proposal. Pick almost any altcoin out there and you can atomic swap it with Bitcoin. The fact that your sidechain is somehow mathematically bound to Bitcoin seems arbitrary because at the end you have a new token and a new issuance model. Therefore this is not extending Bitcoin economy, which is strictly limited by its convergence to zero inflation. This proposal is inflating the supply with a new token, which goes against what many people consider as a pillar of Bitcoin's value proposal. I think if you implement this proposal, you are going not to be considered as a Bitcoin sidechain, but you will be, from certain point of view, indistinguishable from any other altcoin. At the level of my current understanding, the only interesting sidechain model is the [theoretical] one with a two way peg with Bitcoin, preserving the issuance policy of Bitcoin.\n>>>\n>>> Two \u2013 the security of the proposed system seems to be very fragile, unless I have missed something. When I think about sidechains, I expect that it should be possible to create a niche chain which is used by few participants while the security of the chain is somehow guaranteed from its bind to the mainchain. If this was not the case, such a niche sidechain could easily be attacked, even if just stalled/censored for a long period time, with just a small [absolute] investment from an attacker, although this investment might be large if taken relatively to the utility of this niche sidechain. So if we speak concretely about your proposal, you assume honest majority of validators. But in your system the validators come from locking of stake on Bitcoin chain by nodes that are interested in a particular sidechain. If you put this model on a niche chain where only few participants are interested in it, it's trivial for an attacker to be stronger [have more Bitcoin to lock] than all legitimate users together. You should only use honest majority assumption where the scope is global, where it is very hard and very expensive to obtain majority.\n>>>\n>>> Sent with [ProtonMail](https://protonmail.com) Secure Email.\n>>>\n>>> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>>> On Sunday, January 12, 2020 6:54 PM, Robin Linus via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>>> Hi all,\n>>>>\n>>>> I've been working on a sidechain protocol with no trusted third party. You can find the [whitepaper here](http://coins.github.io/coins.pdf).\n>>>>\n>>>> Abstract. Coins is a Bitcoin extension designed for payments at scale. We propose an efficient solution to the double-spending problem using a bitcoin-backed proof-of-stake.  Validators vote on sidechain blocks with one-time signatures, forming a record that cannot be changed without destroying their collateral. Every user can become a validator by locking bitcoins. One-time signatures guarantee that validators loose their stake for publishing conflicting histories. Checkpoints can be additionally secured with a bitcoin-backed proof-of-burn. Assuming a rational majority of validators, the sidechain provides safety and liveness. The sidechain\u2019s footprint within bitcoin\u2019s blockchain is minimal. The protocol is a generic consensus mechanism allowing for arbitrary sidechain assets. Spawning multiple, independent instances scales horizontally.\n>>>>\n>>>> Feedback is highly appreciated!\n>>>>\n>>>> Thank you\n>>>>\n>>>> - Robin\n>>>>\n>>>> PS: [Here on Github you can find further research on scalability and usability](https://github.com/coins/coins.github.io).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200113/aeed17c9/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-01-14T00:53:24",
                "message_text_only": "Good morning Robin,\n\n> Hi Joachim,\n>\n> > > Regarding Reason #1:\n> > > This proposal is less like Bitcoin vs. Altcoins and much more like Ethereum vs. ERC20 tokens, because the derivatives are not in competition with BTC, but depend on it heavily. You support Bitcoin's growth by supporting such a sidechain.\u00a0\n> > > Also, they won't work as separate currencies. For endusers you can abstract away all underlying complexities such that they have to think only in BTC. Exchanges rates can be hidden in TX fees. The sidechain derivatives would be nothing but a means of transfer. The unit of account is still BTC.\u00a0\n> >\n> > I can't see any difference and advantage over doing the same with say Litecoin. All you need is to create a special wallet which offers atomic swaps LTC-BTC and its unit of account displayed to user is going to be BTC. All you say will work perfectly with this special LTC wallet. Therefore your idea is as good as any other altcoin. In your case, someone else should indeed be able to create such a wallet in which the unit of account will be the new token, thus emulating the current LTC wallets. So the only difference in Litecoin is that the special wallet with BTC as unit is going to be created after the native one, while in your case it is vice versa.\n> >\n> > I simply can't see why I'd call this construction of yours a Bitcoin sidechain and any other altcoin not. So I'd call both altcoins.\n>\n> Let me try to explain where I am coming from: Whenever I want to onboard a not-so-techy friend to Bitcoin by sending him $5 worth of BTC, I don't have many good options. Usually we end up using BlueWallet. It works great. Though it only works so well because it is fully custodial. That is how they solve all the tough LN problems like inbound-capacity of new users, watchtowers and channel backends. Their service is just an Excel table connect to the LN. Unfortunately, that is the best UX we can currently offer to endusers. To me that's unsatisfying. Is that how we want to enter the emerging markets and on-board the next Billion users? I like that BlueWallet gives me the option to run my own LndHub for my friends. Still, does that scale globally? More importantly, do we want that?\n>\n> Now let's think about the altcoins argument. We want to serve a billion users. Blockchains do scale well to about a couple Million UTXOs, so we require a network of a couple thousand altcoins to serve our users.\n> We know how to build a nice LN for all of our altcoins with a star-shaped topology around Bitcoin as the central settlement layer. Atomic swaps FTW. We can abstract away their native currencies. We display to our users only BTC, hide the exchange rates in the TX fees and we're done. That is actually a scalability solution. So why don't we do that?\n\nBecause Lightning remains a superior *scalability* solution to microchains.\n\n(The below is a Fermi estimate; it is intended to give an intuition on the rough orders of magnitude that we are discussing, not strict predictions of how the world works)\n\nLet us suppose that N users would produce N * t bytes of transactions.\n\nUnder Lightning, that data is sent to a tiny subset of the entire LN.\nAs Lightning limits routes to at most 20 hops, let us take the worst case and say that under Lightning, those users will force 20 * N * t bytes to be processed globally.\n\nIf all users were to use a *single* blockchain, because all users must process all transactions within the blockchain, that will mean everyone has to process N * N * t bytes.\n\nNow the microchain concept is that, we can split the N in half, so instead of a single N * N * t bytes being processed, we get two (N / 2) * (N / 2) * t, or more generally, if there are c chains: c * ((N / c) ^ 2) * t or N * N * t / c.\n\nSo for microchains to beat Lightning, you would have to make N * N * t / c < 20 * N * t, or equivalently N / c < 20, i.e. 20 users per sidechain.\n\nIf you have as low as 20 users per sidechain, you might as well just use channel factories to host Lightning channels, so channel factories + channels (i.e. Lightning Network) is probably better than having tiny sidechaisn with 20 users each.\n\nAgain the above is a very rough Fermi estimate, but it gives you a hint on the orders of magnitude you should consider, i.e. about a few dozen users per sidechain, and a few dozens users in a sidechain is probably not a lot to give security to that sidechain, whereas with Lightning channel factories you can drop onchain any time to upgrade your security to the full mining hashpower (and we hope that the threat of being able to do so is enough to discourage attempts at theft).\n\nWhat Lightning cannot do is add certain kinds of features other than scalability, for example Turing-complete disasters (RSK) or confidential assets (LBTC).\nSidechains are for features, not scale, so your proposed sidechain concept remains of interest at least as a possible way to anchor sidechains with new features.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Robin Linus",
                "date": "2020-01-14T02:19:55",
                "message_text_only": "> because all users must process all transactions within the blockchain\n\nReality shows, that's wrong. Bitcoin's security doesn't require verification to scale quadratically with users. Since the whitepaper, Satoshi was explicit about that phenomena. We can discuss nuances, yet it's overall plausible and empirically it's true: Only a tiny minority of users ever verifies the blockchain, still bitcoin works perfectly well. An honest economic majority is sufficient.\n\nYes, if you can, run your own node. Let's lower the barriers and let's help others to run their own nodes. Let's keep the blocks small and bitcoin's UTXOs set verifiable with consumer hardware. That's the core of decentralized security.\n\nBut let's face it: most people on this planet will never run a bitcoin full node. And it is not required.\n\nBitcoin-backed PoS-sidechains scale in terms of verification and storage just like any other blockchain. However, security is strictly better because double-spends are impossible.  A single honest validating user guarantees that attackers cannot do more harm than halting a sidechain. Thus, endusers won't have to validate all of each others' transactions at all.\n\nFor most endusers such sidechains' security is strictly superior to today's LN experience.\n\nLet's face it: The most popular LN apps are fully custodial.\nThey have to be custodial because there is no way to make LN usable for regular users on unreliable phones.\n\nAny payment channel which requires you to be always online excludes 99% of the world's population.\nAny payment channel which potentially requires you to be able to pay high on-chain fees excludes most people, too. And on-chain fees keep rising.\n\nThus, no matter what Channel Factory constructions we build, they will not match most people's requirements. We will keep falling back to custodial solutions.\nExcel tables connected to the LN. The LN is awesome as a settlement layer. In particular for anything like bitcoin banks that have been discussed since the beginning.\nBut why 1000 trusted Excel tables if we can have 1000 trustless sidechains?"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-01-14T02:59:25",
                "message_text_only": "Good morning Robin,\n\n\n> > because all users must process all transactions within the blockchain\n>\n> Reality shows, that's wrong. Bitcoin's security doesn't require verification to scale quadratically with users. Since the whitepaper, Satoshi was explicit about that phenomena. We can discuss nuances, yet it's overall plausible and empirically it's true: Only a tiny minority of users ever verifies the blockchain, still bitcoin works perfectly well. An honest economic majority is sufficient.\n>\n> Yes, if you can, run your own node. Let's lower the barriers and let's help others to run their own nodes. Let's keep the blocks small and bitcoin's UTXOs set verifiable with consumer hardware. That's the core of decentralized security.\n>\n> But let's face it: most people on this planet will never run a bitcoin full node. And it is not required.\n>\n> Bitcoin-backed PoS-sidechains scale in terms of verification and storage just like any other blockchain. However, security is strictly better because double-spends are impossible. A single honest validating user guarantees that attackers cannot do more harm than halting a sidechain. Thus, endusers won't have to validate all of each others' transactions at all.\n>\n> For most endusers such sidechains' security is strictly superior to today's LN experience.\n>\n> Let's face it: The most popular LN apps are fully custodial.\n> They have to be custodial because there is no way to make LN usable for regular users on unreliable phones.\n>\n> Any payment channel which requires you to be always online excludes 99% of the world's population.\n> Any payment channel which potentially requires you to be able to pay high on-chain fees excludes most people, too. And on-chain fees keep rising.\n>\n> Thus, no matter what Channel Factory constructions we build, they will not match most people's requirements. We will keep falling back to custodial solutions.\n> Excel tables connected to the LN. The LN is awesome as a settlement layer. In particular for anything like bitcoin banks that have been discussed since the beginning.\n> But why 1000 trusted Excel tables if we can have 1000 trustless sidechains?\n\nFirst:\n\n>  A single honest validating user guarantees that attackers cannot do more harm than halting a sidechain.\n\nIs not compatible with:\n\n> 1000 trustless sidechains\n\nYou are *tr\\*sting* that there exists at least ***one*** ***honest*** user per sidechain.\nThus it is not a trustless solution, but a tr\\*sted one.\nReplacing 1000 tr\\*sted Excel tables with 1000 tr\\*sted blockchains is the same class of error as replacing the banking system with centralized large-scale blockchains: you gain the drawbacks of blockchains without gaining its benefits.\n\nThe security, integrity, and censorship-resistance of Bitcoin is dependent on there existing some sophisticated actors (\"persons\") who are willing to take on the risk of running fullnodes and providing hashpower.\nThis is the Risk-Sharing principle, by which the risk of keeping Bitcoin running is spread out among many persons who are willing to keep Bitcoin alive.\nThe existence of such actors cannot be assured, but it seems to me that fragmenting the entire community of such limited number of actors would not give good risk-sharing within a sidechain.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Robin Linus",
                "date": "2020-01-14T04:12:56",
                "message_text_only": "Good morning ZmnSCPxj,\n\n> > > because all users must process all transactions within the blockchain\n> >\n> > Reality shows, that's wrong. Bitcoin's security doesn't require verification to scale quadratically with users. Since the whitepaper, Satoshi was explicit about that phenomena. We can discuss nuances, yet it's overall plausible and empirically it's true: Only a tiny minority of users ever verifies the blockchain, still bitcoin works perfectly well. An honest economic majority is sufficient.\n> > Yes, if you can, run your own node. Let's lower the barriers and let's help others to run their own nodes. Let's keep the blocks small and bitcoin's UTXOs set verifiable with consumer hardware. That's the core of decentralized security.\n> > But let's face it: most people on this planet will never run a bitcoin full node. And it is not required.\n> > Bitcoin-backed PoS-sidechains scale in terms of verification and storage just like any other blockchain. However, security is strictly better because double-spends are impossible. A single honest validating user guarantees that attackers cannot do more harm than halting a sidechain. Thus, endusers won't have to validate all of each others' transactions at all.\n> > For most endusers such sidechains' security is strictly superior to today's LN experience.\n> > Let's face it: The most popular LN apps are fully custodial.\n> > They have to be custodial because there is no way to make LN usable for regular users on unreliable phones.\n> > Any payment channel which requires you to be always online excludes 99% of the world's population.\n> > Any payment channel which potentially requires you to be able to pay high on-chain fees excludes most people, too. And on-chain fees keep rising.\n> > Thus, no matter what Channel Factory constructions we build, they will not match most people's requirements. We will keep falling back to custodial solutions.\n> > Excel tables connected to the LN. The LN is awesome as a settlement layer. In particular for anything like bitcoin banks that have been discussed since the beginning.\n> > But why 1000 trusted Excel tables if we can have 1000 trustless sidechains?\n>\n> First:\n>\n> > A single honest validating user guarantees that attackers cannot do more harm than halting a sidechain.\n>\n> Is not compatible with:\n>\n> > 1000 trustless sidechains\n>\n> You are *tr\\sting that there exists at least one honest user per sidechain.\n> Thus it is not a trustless solution, but a tr\\*sted one.\n> Replacing 1000 tr\\*sted Excel tables with 1000 tr\\*sted blockchains is the same class of error as replacing the banking system with centralized large-scale blockchains: you gain the drawbacks of blockchains without gaining its benefits.\n\nAgreed. Still, let's discuss a solution that meets the requirements of billions of average users with unreliable mobile devices.\n\nEndusers payment experience should be insanely simple.\n\nThe LN currently offers regular users mostly custodial services. Is there a foreseeable roadmap to meet endusers' simplicity requirements with non-custodial constructions?\n\nBitcoin-backed PoS sidechains are strictly superior to custodial hubs. They provide all hub features such as being able to pay merchants in BTC, plus many clear advantages such as better security including public auditability and decentralized data storage. And they do not require any consensus changes.\n\n\n> The security, integrity, and censorship-resistance of Bitcoin is dependent on there existing some sophisticated actors (\"persons\") who are willing to take on the risk of running fullnodes and providing hashpower.\n> This is the Risk-Sharing principle, by which the risk of keeping Bitcoin running is spread out among many persons who are willing to keep Bitcoin alive.\n> The existence of such actors cannot be assured, but it seems to me that fragmenting the entire community of such limited number of actors would not give good risk-sharing within a sidechain.\n\nIndeed, a highly fragmented market would be inefficient and insecure. However, I'd assume a free market of sidechains is intelligent enough to use its resources efficiently.\n\n\nThanks again for your detailed feedback,\n-Robin"
            },
            {
                "author": "Joachim Str\u00f6mbergson",
                "date": "2020-01-14T15:06:32",
                "message_text_only": "Hi Robin.\n\nWhile your motivation seems reasonable, your solution is not. It is not enough that a problem exists. Although the solution must be technically sound for the proposal to be interesting. So I agree it makes sense to consider Bitcoin sidechains, not sure if with PoS consensus or other, but no one yet proposed a viable solution, other than Federation based sidechains. Your proposal explored a single specific PoS sidechain, which to me does not sound interesting. Maybe you can improve it, maybe not.\n\nI also disagree that it is okay if anyone can halt operation of a sidechain with just tiny investment. For me that is critical security flaw of your proposal. By enforcing stakers having to stake per chain you have actually lowered the cost for the attacker to attack each specific chain.\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Monday, January 13, 2020 10:22 PM, Robin Linus <robinlinus at protonmail.com> wrote:\n\n> Hi Joachim,\n>\n>>> Regarding Reason #1:\n>>> This proposal is less like Bitcoin vs. Altcoins and much more like Ethereum vs. ERC20 tokens, because the derivatives are not in competition with BTC, but depend on it heavily. You support Bitcoin's growth by supporting such a sidechain.\n>>> Also, they won't work as separate currencies. For endusers you can abstract away all underlying complexities such that they have to think only in BTC. Exchanges rates can be hidden in TX fees. The sidechain derivatives would be nothing but a means of transfer. The unit of account is still BTC.\n>>\n>> I can't see any difference and advantage over doing the same with say Litecoin. All you need is to create a special wallet which offers atomic swaps LTC-BTC and its unit of account displayed to user is going to be BTC. All you say will work perfectly with this special LTC wallet. Therefore your idea is as good as any other altcoin. In your case, someone else should indeed be able to create such a wallet in which the unit of account will be the new token, thus emulating the current LTC wallets. So the only difference in Litecoin is that the special wallet with BTC as unit is going to be created after the native one, while in your case it is vice versa.\n>>\n>> I simply can't see why I'd call this construction of yours a Bitcoin sidechain and any other altcoin not. So I'd call both altcoins.\n>\n> Let me try to explain where I am coming from: Whenever I want to onboard a not-so-techy friend to Bitcoin by sending him $5 worth of BTC, I don't have many good options. Usually we end up using BlueWallet. It works great. Though it only works so well because it is fully custodial. That is how they solve all the tough LN problems like inbound-capacity of new users, watchtowers and channel backends. Their service is just an Excel table connect to the LN. Unfortunately, that is the best UX we can currently offer to endusers. To me that's unsatisfying. Is that how we want to enter the emerging markets and on-board the next Billion users? I like that BlueWallet gives me the option to run my own LndHub for my friends. Still, does that scale globally? More importantly, do we want that?\n>\n> Now let's think about the altcoins argument. We want to serve a billion users. Blockchains do scale well to about a couple Million UTXOs, so we require a network of a couple thousand altcoins to serve our users.\n> We know how to build a nice LN for all of our altcoins with a star-shaped topology around Bitcoin as the central settlement layer. Atomic swaps FTW. We can abstract away their native currencies. We display to our users only BTC, hide the exchange rates in the TX fees and we're done. That is actually a scalability solution. So why don't we do that?\n> The problem here is, that In the long term, the market of PoW blockchains should be a winner-takes-all market, right? So all PoW chains but Bitcoin will eventually die because they're wasting lots of value on their energy. So actually we don't want a couple thousand altcoins wasting resources on pointlessly weak PoW chains. We want a single PoW chain which is as strong as possible.\n>\n> That's why I'd argue it makes sense to consider a bitcoin-backed PoS and build a LN of thousands of nameless altcoins.\n>\n> Regarding sidechain security: Burning BTC is almost equivalent to burning energy. You might argue that people won't burn BTC, but it is hard to argue against the strong theoretical security properties of proof-of-burn.\n>\n> Furthermore, even without burning BTC, using only proof-of-stake I can guarantee doublespending is impossible. There is a very low incentive to risk your BTC's time value. You can only halt a sidechain. And you can halt the sidechain only for as long as you maintain the staking majority. Once you start an attack, you increase the incentive for others to increase their stake. Staking happens in bitcoin's blockchain, which you can't halt. Once the rational stakers regain 51% you've lost a year of time value of your BTC. Note that you can easily enforce stakers having to stake per chain. This guarantees attackers can use their BTC only to attack one chain per year.\n> Thus, the security of such a bitcoin-based PoS is stronger then one might suspect.\n>\n> Thanks again,\n> - Robin\n>\n>>> Regarding Reason #2:\n>>> In the \"Limitations\" section I discuss the cost of halting the chain:\n>>>\n>>> Time value of locked bitcoins might be too cheap to protect the chain. We can introduce an additional cost and let validators burn bitcoins for every on-chain vote. This is much more robust because there is an ongoing cost for halting the system. Proof-of-burn has recently been formally analysed [16]. The economic implications of burning significant amounts of Bitcoin are questionable. A level of security comparable to Bitcoin requires the system\u2019s BTC burn rate to be equal to Bitcoin\u2019s infaltion rate.\n>>>\n>>> Also remember, time value of Bitcoins is indeed a value. Even without a proof of burn, I'd consider such sidechains much more secure than those custodial lightning wallets which become more and more popular to circumvent the usability hurdles of the LN.\n>>\n>> Comparison to other models is not relevant to my claim that such construction is insecure for small sidechains. And for big sidechains the reason #1 prefers any other altcoin. Even if you introduce proof of burn, the final attack cost is small for an attacker in absolute numbers, despite the fact that in the relative numbers the cost is huge.\n>>\n>>> Thanks again,\n>>> - Robin\n>>>\n>>> Sent with [ProtonMail](https://protonmail.com) Secure Email.\n>>>\n>>> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>>> On Monday, January 13, 2020 7:06 PM, Joachim Str\u00f6mbergson <joachimstr at protonmail.com> wrote:\n>>>\n>>>> While I haven't rejected sidechains entirely yet, this particular proposal seems uninteresting, especially for two reasons.\n>>>>\n>>>> One \u2013 it introduces a new token for each sidechain and suggests atomic swaps to be used for the exchange of the mainchain token with the sidechain token. Such a model seems nonsensical to me because there seems to be excessive number of blockchain projects that can be used similarly just as the sidechain in this proposal. Pick almost any altcoin out there and you can atomic swap it with Bitcoin. The fact that your sidechain is somehow mathematically bound to Bitcoin seems arbitrary because at the end you have a new token and a new issuance model. Therefore this is not extending Bitcoin economy, which is strictly limited by its convergence to zero inflation. This proposal is inflating the supply with a new token, which goes against what many people consider as a pillar of Bitcoin's value proposal. I think if you implement this proposal, you are going not to be considered as a Bitcoin sidechain, but you will be, from certain point of view, indistinguishable from any other altcoin. At the level of my current understanding, the only interesting sidechain model is the [theoretical] one with a two way peg with Bitcoin, preserving the issuance policy of Bitcoin.\n>>>>\n>>>> Two \u2013 the security of the proposed system seems to be very fragile, unless I have missed something. When I think about sidechains, I expect that it should be possible to create a niche chain which is used by few participants while the security of the chain is somehow guaranteed from its bind to the mainchain. If this was not the case, such a niche sidechain could easily be attacked, even if just stalled/censored for a long period time, with just a small [absolute] investment from an attacker, although this investment might be large if taken relatively to the utility of this niche sidechain. So if we speak concretely about your proposal, you assume honest majority of validators. But in your system the validators come from locking of stake on Bitcoin chain by nodes that are interested in a particular sidechain. If you put this model on a niche chain where only few participants are interested in it, it's trivial for an attacker to be stronger [have more Bitcoin to lock] than all legitimate users together. You should only use honest majority assumption where the scope is global, where it is very hard and very expensive to obtain majority.\n>>>>\n>>>> Sent with [ProtonMail](https://protonmail.com) Secure Email.\n>>>>\n>>>> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>>>> On Sunday, January 12, 2020 6:54 PM, Robin Linus via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>>\n>>>>> Hi all,\n>>>>>\n>>>>> I've been working on a sidechain protocol with no trusted third party. You can find the [whitepaper here](http://coins.github.io/coins.pdf).\n>>>>>\n>>>>> Abstract. Coins is a Bitcoin extension designed for payments at scale. We propose an efficient solution to the double-spending problem using a bitcoin-backed proof-of-stake.  Validators vote on sidechain blocks with one-time signatures, forming a record that cannot be changed without destroying their collateral. Every user can become a validator by locking bitcoins. One-time signatures guarantee that validators loose their stake for publishing conflicting histories. Checkpoints can be additionally secured with a bitcoin-backed proof-of-burn. Assuming a rational majority of validators, the sidechain provides safety and liveness. The sidechain\u2019s footprint within bitcoin\u2019s blockchain is minimal. The protocol is a generic consensus mechanism allowing for arbitrary sidechain assets. Spawning multiple, independent instances scales horizontally.\n>>>>>\n>>>>> Feedback is highly appreciated!\n>>>>>\n>>>>> Thank you\n>>>>>\n>>>>> - Robin\n>>>>>\n>>>>> PS: [Here on Github you can find further research on scalability and usability](https://github.com/coins/coins.github.io).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200114/72b4fc9b/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-01-14T15:26:18",
                "message_text_only": "As well I would like to point out that in order to receive funds, *something* has to be online to get the message that receives the data.\nIn the blockchain layer this is diffused among all fullnodes.\n\nAt the Lightning layer, your direct peer could hold off on failing an incoming payment while you are offline.\nInstead, it could simply stall until the outgoing HTLC would reach its timelock anyway.\nThen you can come online and then the peer can send the HTLC to you and you can claim it.\nThis remains noncustodial as the direct peer cannot steal the funds from you.\nI believe there was some discussion regarding this on lightning-dev in the past few months.\nHowever, it does require that the peer know that *you* are the final recipient (if not, it would be unable to fail the HTLC as quickly as possible), thus a privacy leak.\n\nIn any case *some* node has to be online in order for anyone to receive funds, whether onchain or not: it is simply that a widespread blcokchain is very very likely to have some online node capable of storing the payment until you can come online to process it.\nWhat you propose splits up the fullnodes into many tiny sidechains, such that a sidechain may get stalled and you would be unable to receive a payment anyway while you are offline, because there are far fewer nodes per sidechain in order for such mass sidechains to start beating the raw scaling Lightning brings.\n\nRegards,\nZmnSCPxj\n\n> Hi Robin.\n>\n> While your motivation seems reasonable, your solution is not. It is not enough that a problem exists. Although the solution must be technically sound for the proposal to be interesting. So I agree it makes sense to consider Bitcoin sidechains, not sure if with PoS consensus or other, but no one yet proposed a viable solution, other than Federation based sidechains. Your proposal explored a single specific PoS sidechain, which to me does not sound interesting. Maybe you can improve it, maybe not.\n>\n> I also disagree that it is okay if anyone can halt operation of a sidechain with just tiny investment. For me that is critical security flaw of your proposal. By enforcing stakers having to stake per chain you have actually lowered the cost for the attacker to attack each specific chain.\n>\n> Sent with ProtonMail Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Monday, January 13, 2020 10:22 PM, Robin Linus <robinlinus at protonmail.com> wrote:\n>\n> > Hi Joachim,\n> >\n> > > > Regarding Reason #1:\n> > > > This proposal is less like Bitcoin vs. Altcoins and much more like Ethereum vs. ERC20 tokens, because the derivatives are not in competition with BTC, but depend on it heavily. You support Bitcoin's growth by supporting such a sidechain.\u00a0\n> > > > Also, they won't work as separate currencies. For endusers you can abstract away all underlying complexities such that they have to think only in BTC. Exchanges rates can be hidden in TX fees. The sidechain derivatives would be nothing but a means of transfer. The unit of account is still BTC.\u00a0\n> > >\n> > > I can't see any difference and advantage over doing the same with say Litecoin. All you need is to create a special wallet which offers atomic swaps LTC-BTC and its unit of account displayed to user is going to be BTC. All you say will work perfectly with this special LTC wallet. Therefore your idea is as good as any other altcoin. In your case, someone else should indeed be able to create such a wallet in which the unit of account will be the new token, thus emulating the current LTC wallets. So the only difference in Litecoin is that the special wallet with BTC as unit is going to be created after the native one, while in your case it is vice versa.\n> > >\n> > > I simply can't see why I'd call this construction of yours a Bitcoin sidechain and any other altcoin not. So I'd call both altcoins.\n> >\n> > Let me try to explain where I am coming from: Whenever I want to onboard a not-so-techy friend to Bitcoin by sending him $5 worth of BTC, I don't have many good options. Usually we end up using BlueWallet. It works great. Though it only works so well because it is fully custodial. That is how they solve all the tough LN problems like inbound-capacity of new users, watchtowers and channel backends. Their service is just an Excel table connect to the LN. Unfortunately, that is the best UX we can currently offer to endusers. To me that's unsatisfying. Is that how we want to enter the emerging markets and on-board the next Billion users? I like that BlueWallet gives me the option to run my own LndHub for my friends. Still, does that scale globally? More importantly, do we want that?\n> >\n> > Now let's think about the altcoins argument. We want to serve a billion users. Blockchains do scale well to about a couple Million UTXOs, so we require a network of a couple thousand altcoins to serve our users.\n> > We know how to build a nice LN for all of our altcoins with a star-shaped topology around Bitcoin as the central settlement layer. Atomic swaps FTW. We can abstract away their native currencies. We display to our users only BTC, hide the exchange rates in the TX fees and we're done. That is actually a scalability solution. So why don't we do that?\n> > The problem here is, that In the long term, the market of PoW blockchains should be a winner-takes-all market, right? So all PoW chains but Bitcoin will eventually die because they're wasting lots of value on their energy. So actually we don't want a couple thousand altcoins wasting resources on pointlessly weak PoW chains. We want a single PoW chain which is as strong as possible.\n> >\n> > That's why I'd argue it makes sense to consider a bitcoin-backed PoS and build a LN of thousands of nameless altcoins.\n> >\n> > Regarding sidechain security: Burning BTC is almost equivalent to burning energy. You might argue that people won't burn BTC, but it is hard to argue against the strong theoretical security properties of proof-of-burn.\n> >\n> > Furthermore, even without burning BTC, using only proof-of-stake I can guarantee doublespending is impossible. There is a very low incentive to risk your BTC's time value. You can only halt a sidechain. And you can halt the sidechain only for as long as you maintain the staking majority. Once you start an attack, you increase the incentive for others to increase their stake. Staking happens in bitcoin's blockchain, which you can't halt. Once the rational stakers regain 51% you've lost a year of time value of your BTC. Note that you can easily enforce stakers having to stake per chain. This guarantees attackers can use their BTC only to attack one chain per year.\u00a0\n> > Thus, the security of such a bitcoin-based PoS is stronger then one might suspect.\n> >\n> > Thanks again,\n> > - Robin\n> >\n> > > > Regarding Reason #2:\n> > > > In the \"Limitations\" section I discuss the cost of halting the chain:\n> > > >\n> > > > Time value of locked bitcoins might be too cheap to protect the chain. We can introduce an additional cost and let validators burn bitcoins for every on-chain vote. This is much more robust because there is an ongoing cost for halting the system. Proof-of-burn has recently been formally analysed [16]. The economic implications of burning significant amounts of Bitcoin are questionable. A level of security comparable to Bitcoin requires the system\u2019s BTC burn rate to be equal to Bitcoin\u2019s infaltion rate.\n> > > >\n> > > > Also remember, time value of Bitcoins is indeed a value. Even without a proof of burn, I'd consider such sidechains much more secure than those custodial lightning wallets which become more and more popular to circumvent the usability hurdles of the LN.\n> > >\n> > > Comparison to other models is not relevant to my claim that such construction is insecure for small sidechains. And for big sidechains the reason #1 prefers any other altcoin. Even if you introduce proof of burn, the final attack cost is small for an attacker in absolute numbers, despite the fact that in the relative numbers the cost is huge.\n> > >\n> > > > Thanks again,\u00a0\n> > > > - Robin\n> > > >\n> > > > Sent with ProtonMail Secure Email.\n> > > >\n> > > > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> > > > On Monday, January 13, 2020 7:06 PM, Joachim Str\u00f6mbergson <joachimstr at protonmail.com> wrote:\n> > > >\n> > > > > While I haven't rejected sidechains entirely yet, this particular proposal seems uninteresting, especially for two reasons.\n> > > > >\n> > > > > One \u2013 it introduces a new token for each sidechain and suggests atomic swaps to be used for the exchange of the mainchain token with the sidechain token. Such a model seems nonsensical to me because there seems to be excessive number of blockchain projects that can be used similarly just as the sidechain in this proposal. Pick almost any altcoin out there and you can atomic swap it with Bitcoin. The fact that your sidechain is somehow mathematically bound to Bitcoin seems arbitrary because at the end you have a new token and a new issuance model. Therefore this is not extending Bitcoin economy, which is strictly limited by its convergence to zero inflation. This proposal is inflating the supply with a new token, which goes against what many people consider as a pillar of Bitcoin's value proposal. I think if you implement this proposal, you are going not to be considered as a Bitcoin sidechain, but you will be, from certain point of view, indistinguishable from any other altcoin. At the level of my current understanding, the only interesting sidechain model is the [theoretical] one with a two way peg with Bitcoin, preserving the issuance policy of Bitcoin.\n> > > > >\n> > > > > Two \u2013 the security of the proposed system seems to be very fragile, unless I have missed something. When I think about sidechains, I expect that it should be possible to create a niche chain which is used by few participants while the security of the chain is somehow guaranteed from its bind to the mainchain. If this was not the case, such a niche sidechain could easily be attacked, even if just stalled/censored for a long period time, with just a small [absolute] investment from an attacker, although this investment might be large if taken relatively to the utility of this niche sidechain. So if we speak concretely about your proposal, you assume honest majority of validators. But in your system the validators come from locking of stake on Bitcoin chain by nodes that are interested in a particular sidechain. If you put this model on a niche chain where only few participants are interested in it, it's trivial for an attacker to be stronger [have more Bitcoin to lock] than all legitimate users together. You should only use honest majority assumption where the scope is global, where it is very hard and very expensive to obtain majority.\n> > > > >\n> > > > > Sent with ProtonMail Secure Email.\n> > > > >\n> > > > > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> > > > > On Sunday, January 12, 2020 6:54 PM, Robin Linus via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > > > >\n> > > > > > Hi all,\n> > > > > >\n> > > > > > I've been working on a sidechain protocol with no trusted third party. You can find thewhitepaper here.\n> > > > > >\n> > > > > > Abstract.Coins is a Bitcoin extension designed for payments at scale.\u00a0We propose an efficient solution to the double-spending problem using a bitcoin-backed proof-of-stake.\u00a0 Validators vote on sidechain blocks with one-time signatures, forming a record that cannot be changed without destroying their collateral. Every user can become a validator by locking bitcoins.\u00a0One-time signatures guarantee that validators loose their\u00a0stake\u00a0for\u00a0publishing\u00a0conflicting\u00a0histories. Checkpoints\u00a0can\u00a0be\u00a0additionally secured with a bitcoin-backed proof-of-burn.\u00a0Assuming a rational majority of validators, the sidechain provides safety and liveness. The sidechain\u2019s footprint within bitcoin\u2019s blockchain is minimal.\u00a0The protocol is a generic consensus mechanism allowing for arbitrary sidechain assets. Spawning multiple, independent instances scales horizontally.\n> > > > > >\n> > > > > > Feedback is highly appreciated!\n> > > > > >\n> > > > > > Thank you\n> > > > > >\n> > > > > > - Robin\n> > > > > >\n> > > > > > PS:Here on Github you can find further research on scalability and usability."
            },
            {
                "author": "Robin Linus",
                "date": "2020-01-15T01:43:06",
                "message_text_only": "Good morning everybody!\n\nThanks again for your detailed feedback.\n\nMaybe you're right and my solution is just crap :) So back to the drafting table!\n\nIt seems to be a good idea to separate problem definition and solution. Here I tried to nail down LN's usability issue:\nhttps://github.com/coins/coins.github.io/blob/master/notes/lightning-network.md\nWould be great to hear your thoughts on that. Do we generally agree that Bitcoin has to work well on mobiles? Where do your opinions differ?\n\nIf you are open to sidechains in general, we are discussing mostly consensus mechanisms.\nThe consensus mechanism of custodial LN services is some trusted server somewhere, with a single hot key and no public auditability.\nThat's state of the art LN experience on mobile. And it's worse than fiat banks.\n\nYes, Liquid's trusted federation is much better than such custodial services. Still, how does it scale globally? Lots of trusted federations?\nProbably, we all favor a more trust-minimized sidechain consensus mechanism.\n\nMost likely, it is impossible to produce decentralized consensus without consuming an external resource.\nFurthermore, decentralized consensus requires an honest majority. Thus, fragmenting the consumption of the available resources over multiple chains weakens every chain proportionally. Therefore, whatever consensus mechanism we choose, the number of sidechains should be as small as possible. By implication, sidechains have to be as large as possible.\n\nThe market simply has no capacity to secure thousands of chains, if they don't have millions of users each.\nConsensus resource consumption is a winner takes all market, until a sidechain becomes so full, that a further chain becomes profitable. Secure and profitable sidechains require strong network effects. Otherwise, there's a downwards spiral of no users which leads to no stakers and vice versa. Needless sidechains die off quickly.\n\n\nRegarding proof-of-burn: In theory, you could build a pure proof-of-burn sidechain which is literally as secure as Bitcoin's consensus. If you burn about 12.5 BTC for every sidechain block, then the sidechain is exactly as costly to produce as Bitcoins blockchain. So regardless of the practicality, the theoretical security argument of PoB is very sound, or am I missing something?\n\nIf it is, then can't we build some PoS / PoB construction to secure sidechains?\n\n\nRegarding 2-way peg and \"a new asset for every chain is bad\". Let's look at my real world bank account. There are no real dollars in it. No legal tender.\nIt's just my bank's derivative of the Dollar, representing their promise to give me my Dollars whenever I want.\nNote that my bank's altcoin is not pegged 1:1 to the legal tender issued by the central bank. In the background they're balancing their books.\nAll that is hidden from me as a customer. They know, I just want to facilitate payments in USD. As a customer I do not care about their underlying financial instruments. That's why I'd assume, that sidechain assets can be used as an instrument of BTC value transfer, without a 1:1-peg to BTC.\nThe only thing that really matters, is liquidity for atomic swaps to pay LN invoices denominated in BTC. That again, is a matter of network effects of a sidechain.\n\n\nThanks again,\n-Robin\n\n\n\n\n\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Tuesday, January 14, 2020 4:26 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> As well I would like to point out that in order to receive funds, something has to be online to get the message that receives the data.\n> In the blockchain layer this is diffused among all fullnodes.\n>\n> At the Lightning layer, your direct peer could hold off on failing an incoming payment while you are offline.\n> Instead, it could simply stall until the outgoing HTLC would reach its timelock anyway.\n> Then you can come online and then the peer can send the HTLC to you and you can claim it.\n> This remains noncustodial as the direct peer cannot steal the funds from you.\n> I believe there was some discussion regarding this on lightning-dev in the past few months.\n> However, it does require that the peer know that you are the final recipient (if not, it would be unable to fail the HTLC as quickly as possible), thus a privacy leak.\n>\n> In any case some node has to be online in order for anyone to receive funds, whether onchain or not: it is simply that a widespread blcokchain is very very likely to have some online node capable of storing the payment until you can come online to process it.\n> What you propose splits up the fullnodes into many tiny sidechains, such that a sidechain may get stalled and you would be unable to receive a payment anyway while you are offline, because there are far fewer nodes per sidechain in order for such mass sidechains to start beating the raw scaling Lightning brings.\n>\n> Regards,\n> ZmnSCPxj\n>\n> > Hi Robin.\n> > While your motivation seems reasonable, your solution is not. It is not enough that a problem exists. Although the solution must be technically sound for the proposal to be interesting. So I agree it makes sense to consider Bitcoin sidechains, not sure if with PoS consensus or other, but no one yet proposed a viable solution, other than Federation based sidechains. Your proposal explored a single specific PoS sidechain, which to me does not sound interesting. Maybe you can improve it, maybe not.\n> > I also disagree that it is okay if anyone can halt operation of a sidechain with just tiny investment. For me that is critical security flaw of your proposal. By enforcing stakers having to stake per chain you have actually lowered the cost for the attacker to attack each specific chain.\n> > Sent with ProtonMail Secure Email.\n> > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> > On Monday, January 13, 2020 10:22 PM, Robin Linus robinlinus at protonmail.com wrote:\n> >\n> > > Hi Joachim,\n> > >\n> > > > > Regarding Reason #1:\n> > > > > This proposal is less like Bitcoin vs. Altcoins and much more like Ethereum vs. ERC20 tokens, because the derivatives are not in competition with BTC, but depend on it heavily. You support Bitcoin's growth by supporting such a sidechain.\u00a0\n> > > > > Also, they won't work as separate currencies. For endusers you can abstract away all underlying complexities such that they have to think only in BTC. Exchanges rates can be hidden in TX fees. The sidechain derivatives would be nothing but a means of transfer. The unit of account is still BTC.\n> > > >\n> > > > I can't see any difference and advantage over doing the same with say Litecoin. All you need is to create a special wallet which offers atomic swaps LTC-BTC and its unit of account displayed to user is going to be BTC. All you say will work perfectly with this special LTC wallet. Therefore your idea is as good as any other altcoin. In your case, someone else should indeed be able to create such a wallet in which the unit of account will be the new token, thus emulating the current LTC wallets. So the only difference in Litecoin is that the special wallet with BTC as unit is going to be created after the native one, while in your case it is vice versa.\n> > > > I simply can't see why I'd call this construction of yours a Bitcoin sidechain and any other altcoin not. So I'd call both altcoins.\n> > >\n> > > Let me try to explain where I am coming from: Whenever I want to onboard a not-so-techy friend to Bitcoin by sending him $5 worth of BTC, I don't have many good options. Usually we end up using BlueWallet. It works great. Though it only works so well because it is fully custodial. That is how they solve all the tough LN problems like inbound-capacity of new users, watchtowers and channel backends. Their service is just an Excel table connect to the LN. Unfortunately, that is the best UX we can currently offer to endusers. To me that's unsatisfying. Is that how we want to enter the emerging markets and on-board the next Billion users? I like that BlueWallet gives me the option to run my own LndHub for my friends. Still, does that scale globally? More importantly, do we want that?\n> > > Now let's think about the altcoins argument. We want to serve a billion users. Blockchains do scale well to about a couple Million UTXOs, so we require a network of a couple thousand altcoins to serve our users.\n> > > We know how to build a nice LN for all of our altcoins with a star-shaped topology around Bitcoin as the central settlement layer. Atomic swaps FTW. We can abstract away their native currencies. We display to our users only BTC, hide the exchange rates in the TX fees and we're done. That is actually a scalability solution. So why don't we do that?\n> > > The problem here is, that In the long term, the market of PoW blockchains should be a winner-takes-all market, right? So all PoW chains but Bitcoin will eventually die because they're wasting lots of value on their energy. So actually we don't want a couple thousand altcoins wasting resources on pointlessly weak PoW chains. We want a single PoW chain which is as strong as possible.\n> > > That's why I'd argue it makes sense to consider a bitcoin-backed PoS and build a LN of thousands of nameless altcoins.\n> > > Regarding sidechain security: Burning BTC is almost equivalent to burning energy. You might argue that people won't burn BTC, but it is hard to argue against the strong theoretical security properties of proof-of-burn.\n> > > Furthermore, even without burning BTC, using only proof-of-stake I can guarantee doublespending is impossible. There is a very low incentive to risk your BTC's time value. You can only halt a sidechain. And you can halt the sidechain only for as long as you maintain the staking majority. Once you start an attack, you increase the incentive for others to increase their stake. Staking happens in bitcoin's blockchain, which you can't halt. Once the rational stakers regain 51% you've lost a year of time value of your BTC. Note that you can easily enforce stakers having to stake per chain. This guarantees attackers can use their BTC only to attack one chain per year.\u00a0\n> > > Thus, the security of such a bitcoin-based PoS is stronger then one might suspect.\n> > > Thanks again,\n> > >\n> > > -   Robin\n> > >\n> > > > > Regarding Reason #2:\n> > > > > In the \"Limitations\" section I discuss the cost of halting the chain:\n> > > > > Time value of locked bitcoins might be too cheap to protect the chain. We can introduce an additional cost and let validators burn bitcoins for every on-chain vote. This is much more robust because there is an ongoing cost for halting the system. Proof-of-burn has recently been formally analysed [16]. The economic implications of burning significant amounts of Bitcoin are questionable. A level of security comparable to Bitcoin requires the system\u2019s BTC burn rate to be equal to Bitcoin\u2019s infaltion rate.\n> > > > > Also remember, time value of Bitcoins is indeed a value. Even without a proof of burn, I'd consider such sidechains much more secure than those custodial lightning wallets which become more and more popular to circumvent the usability hurdles of the LN.\n> > > >\n> > > > Comparison to other models is not relevant to my claim that such construction is insecure for small sidechains. And for big sidechains the reason #1 prefers any other altcoin. Even if you introduce proof of burn, the final attack cost is small for an attacker in absolute numbers, despite the fact that in the relative numbers the cost is huge.\n> > > >\n> > > > > Thanks again,\n> > > > >\n> > > > > -   Robin\n> > > > >\n> > > > > Sent with ProtonMail Secure Email.\n> > > > > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> > > > > On Monday, January 13, 2020 7:06 PM, Joachim Str\u00f6mbergson joachimstr at protonmail.com wrote:\n> > > > >\n> > > > > > While I haven't rejected sidechains entirely yet, this particular proposal seems uninteresting, especially for two reasons.\n> > > > > > One \u2013 it introduces a new token for each sidechain and suggests atomic swaps to be used for the exchange of the mainchain token with the sidechain token. Such a model seems nonsensical to me because there seems to be excessive number of blockchain projects that can be used similarly just as the sidechain in this proposal. Pick almost any altcoin out there and you can atomic swap it with Bitcoin. The fact that your sidechain is somehow mathematically bound to Bitcoin seems arbitrary because at the end you have a new token and a new issuance model. Therefore this is not extending Bitcoin economy, which is strictly limited by its convergence to zero inflation. This proposal is inflating the supply with a new token, which goes against what many people consider as a pillar of Bitcoin's value proposal. I think if you implement this proposal, you are going not to be considered as a Bitcoin sidechain, but you will be, from certain point of view, indistinguishable from any other altcoin. At the level of my current understanding, the only interesting sidechain model is the [theoretical] one with a two way peg with Bitcoin, preserving the issuance policy of Bitcoin.\n> > > > > > Two \u2013 the security of the proposed system seems to be very fragile, unless I have missed something. When I think about sidechains, I expect that it should be possible to create a niche chain which is used by few participants while the security of the chain is somehow guaranteed from its bind to the mainchain. If this was not the case, such a niche sidechain could easily be attacked, even if just stalled/censored for a long period time, with just a small [absolute] investment from an attacker, although this investment might be large if taken relatively to the utility of this niche sidechain. So if we speak concretely about your proposal, you assume honest majority of validators. But in your system the validators come from locking of stake on Bitcoin chain by nodes that are interested in a particular sidechain. If you put this model on a niche chain where only few participants are interested in it, it's trivial for an attacker to be stronger [have more Bitcoin to lock] than all legitimate users together. You should only use honest majority assumption where the scope is global, where it is very hard and very expensive to obtain majority.\n> > > > > > Sent with ProtonMail Secure Email.\n> > > > > > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> > > > > > On Sunday, January 12, 2020 6:54 PM, Robin Linus via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:\n> > > > > >\n> > > > > > > Hi all,\n> > > > > > > I've been working on a sidechain protocol with no trusted third party. You can find thewhitepaper here.\n> > > > > > > Abstract.Coins is a Bitcoin extension designed for payments at scale.\u00a0We propose an efficient solution to the double-spending problem using a bitcoin-backed proof-of-stake.\u00a0 Validators vote on sidechain blocks with one-time signatures, forming a record that cannot be changed without destroying their collateral. Every user can become a validator by locking bitcoins.\u00a0One-time signatures guarantee that validators loose their\u00a0stake\u00a0for\u00a0publishing\u00a0conflicting\u00a0histories. Checkpoints\u00a0can\u00a0be\u00a0additionally secured with a bitcoin-backed proof-of-burn.\u00a0Assuming a rational majority of validators, the sidechain provides safety and liveness. The sidechain\u2019s footprint within bitcoin\u2019s blockchain is minimal.\u00a0The protocol is a generic consensus mechanism allowing for arbitrary sidechain assets. Spawning multiple, independent instances scales horizontally.\n> > > > > > > Feedback is highly appreciated!\n> > > > > > > Thank you\n> > > > > > >\n> > > > > > > -   Robin\n> > > > > > >\n> > > > > > > PS:Here on Github you can find further research on scalability and usability."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-01-15T05:46:04",
                "message_text_only": "Good morning Robin,\n\n\n> Good morning everybody!\n>\n> Thanks again for your detailed feedback.\n>\n> Maybe you're right and my solution is just crap :) So back to the drafting table!\n>\n> It seems to be a good idea to separate problem definition and solution. Here I tried to nail down LN's usability issue:\n> https://github.com/coins/coins.github.io/blob/master/notes/lightning-network.md\n> Would be great to hear your thoughts on that. Do we generally agree that Bitcoin has to work well on mobiles? Where do your opinions differ?\n>\n> If you are open to sidechains in general, we are discussing mostly consensus mechanisms.\n> The consensus mechanism of custodial LN services is some trusted server somewhere, with a single hot key and no public auditability.\n> That's state of the art LN experience on mobile. And it's worse than fiat banks.\n>\n> Yes, Liquid's trusted federation is much better than such custodial services. Still, how does it scale globally? Lots of trusted federations?\n> Probably, we all favor a more trust-minimized sidechain consensus mechanism.\n>\n> Most likely, it is impossible to produce decentralized consensus without consuming an external resource.\n> Furthermore, decentralized consensus requires an honest majority. Thus, fragmenting the consumption of the available resources over multiple chains weakens every chain proportionally. Therefore, whatever consensus mechanism we choose, the number of sidechains should be as small as possible. By implication, sidechains have to be as large as possible.\n>\n> The market simply has no capacity to secure thousands of chains, if they don't have millions of users each.\n> Consensus resource consumption is a winner takes all market, until a sidechain becomes so full, that a further chain becomes profitable. Secure and profitable sidechains require strong network effects. Otherwise, there's a downwards spiral of no users which leads to no stakers and vice versa. Needless sidechains die off quickly.\n\nAgain, please refer to the previous Fermi estimate: blockchains have bad scaling precisely because every fullnode must know every transaction.\nWith blockchains, anything that is not a fullnode is trusting something, and the issue of custodiality is always and has always been an issue of trust.\n\n>\n> Regarding proof-of-burn: In theory, you could build a pure proof-of-burn sidechain which is literally as secure as Bitcoin's consensus. If you burn about 12.5 BTC for every sidechain block, then the sidechain is exactly as costly to produce as Bitcoins blockchain. So regardless of the practicality, the theoretical security argument of PoB is very sound, or am I missing something?\n\nLocking coins is equivalent to burning them, as you are \"burning\" the opportunity to use those coins elsewhere, e.g. in a JoinMarket maker or Lightning forwarding node.\nProof of locked coins is therefore indistinguishable from proof-of-burn in this sense, and your original proposal is proof-of-locked-coins.\n\nBurning coins is effectively a donation to all HODLers, while locking coins is effectively a donation to all JoinMarket makers and Lightning forwarding nodes (i.e. HODLers too).\n\nSomething I have been playing with mentally would be a unidirectional peg in a sidechain.\nBurn funds in the mainchain and build a block with equivalent amount in the coinbase of a sidechain.\nBut I stopped working on sidechains due to the aforementioned lack of scaling they produce: sidechains are for features, and federated sidechains are fine for new features.\n\n>\n> If it is, then can't we build some PoS / PoB construction to secure sidechains?\n>\n> Regarding 2-way peg and \"a new asset for every chain is bad\". Let's look at my real world bank account. There are no real dollars in it. No legal tender.\n> It's just my bank's derivative of the Dollar, representing their promise to give me my Dollars whenever I want.\n> Note that my bank's altcoin is not pegged 1:1 to the legal tender issued by the central bank. In the background they're balancing their books.\n\n....\n\n\nThe \"balancing their books\" **is** the peg.\n\nConsider that for example that a sidechain may have 21 million bitcoins instantiated in it, but locked.\nIn order to unlock *part* of that supply, you have to provably lock funds in the mainchain.\nThis \"moves\" coins from mainchain to  sidechain, but in reality there are still 21 million maincoins and 21 million separate sidecoins.\nWhat matters is that there are only 21 million ***user-controllable*** coins in total, some in the mainchain and some in the sidechain.\nThat is enough for this to be a peg.\n\nThus, everything the bank does to \"balance their books\" is in fact a peg to the central-bank issued currency.\n\n> All that is hidden from me as a customer. They know, I just want to facilitate payments in USD. As a customer I do not care about their underlying financial instruments. That's why I'd assume, that sidechain assets can be used as an instrument of BTC value transfer, without a 1:1-peg to BTC.\n> The only thing that really matters, is liquidity for atomic swaps to pay LN invoices denominated in BTC. That again, is a matter of network effects of a sidechain.\n\nWhy would accept a sidecoin with degraded security and accepted by fewer people if it is not pegged to BTC?\n\nThat immediately kills any network effects you are targeting.\n\n--\n\nIn any case, a project I have been playing with (which I am not pursuing in seriousness and which I will not seriously support, because LN > sidechains) is to combine the mainchain-staking with https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-January/016611.html\n\nBasically, on the mainchain, the sidechain is represented by single UTXO that contains all the funds in the sidechain.\nThat UTXO would then have the same SCRIPT as described in the above linked post.\n\nMainchain coin owners that want to be included in the staker set can put their staked amount into a UTXO.\nThe sidechain stakers then confirm the addition of this staker to the staker set by spending the sidechain single UTXO and the entering staker, putting the funds into a new sidechain single UTXO that now includes the entering staker in the signing set.\nSidechain stakers can also redeem their stake back by requesting the staker set, so that the sidechain single UTXO is consumed and spent into a new sidechain single UTXO that removes the leaving staker in the signing set, plus a second UTXO containing the money that the leaving sidechain staker is reclaiming from stake.\n\nWithdraws and deposits into the sidechain use a similar mechanism, except the depositor does not get its pubkey added to the signer set, but its funds are instantiated into the sidechain (the stakers do not have their funds instantiated into the sidechain: the mainchain staked funds and the sidechain \"live\" funds are thus separated, even though on the mainchain they are combined within the sidechain single UTXO).\n\nLike all federated sidechains this assumes a federation can be formed that can be trusted to not just spend the entire sidechain single UTXO on other funds.\nIn particular, if the federation is taken over, it can deny the entry of new stakers that would want to evict them.\nThus the security is significantly lower.\n\n(proof-of-work allows existing miners to be evicted, at cost, by deploying more hashpower than the existing miners have: this is central to censorship-resistance on the main blockchain layer)\n\nThe stakers that sign on the sidechain single UTXO that appears on the mainchain need not be the same set that determines consensus on the sidechain.\nIn terms of the Liquid blockchain, the signers on the sidechain single UTXO are the watchmen (who ensure the peg is correct), and need not be the same set as the blocksigners (who advance the sidechain state by authorizing valid blocks).\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Robin Linus",
                "date": "2020-01-17T04:17:56",
                "message_text_only": "Hi Joachim,\n\n> if anyone can halt operation of a sidechain with just tiny investment.\n\nIt'll be impossible to halt a healthy chain with a tiny investment because halting a chain costs you at least as much as the side chain rewards. The \"invested time value per block\" of all honest stakers converges against the block reward. If imbalanced, someone will stake more bitcoin to get the cheap sidechain rewards. Exactly the same market mechanism secures PoW.\n\nFor a decentralized consensus via resource consumption it doesn't matter which limited resource you consume. The only relevant factor is that the value of the block reward is sufficient to motivate people to invest a lot of that resource. To motivate them to invest so much that an attacker cannot invest more. Independently of the resource, the amount of honestly invested resources converges against the value of the block reward.\n\nThus, I would even go further with my claim and argue that the security of bitcoin-backed PoS is exactly as strong as PoW because in both cases their security is proportionally to the dollar value of their block reward. PoS sidechain security depends only on a sufficient userbase and thus, block reward value.\n\nThanks again for your detailed feedback,\n-Robin\n\n> For me that is critical security flaw of your proposal. By enforcing stakers having to stake per chain you have actually lowered the cost for the attacker to attack each specific chain.\n>\n> Sent with [ProtonMail](https://protonmail.com) Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Monday, January 13, 2020 10:22 PM, Robin Linus <robinlinus at protonmail.com> wrote:\n>\n>> Hi Joachim,\n>>\n>>>> Regarding Reason #1:\n>>>> This proposal is less like Bitcoin vs. Altcoins and much more like Ethereum vs. ERC20 tokens, because the derivatives are not in competition with BTC, but depend on it heavily. You support Bitcoin's growth by supporting such a sidechain.\n>>>> Also, they won't work as separate currencies. For endusers you can abstract away all underlying complexities such that they have to think only in BTC. Exchanges rates can be hidden in TX fees. The sidechain derivatives would be nothing but a means of transfer. The unit of account is still BTC.\n>>>\n>>> I can't see any difference and advantage over doing the same with say Litecoin. All you need is to create a special wallet which offers atomic swaps LTC-BTC and its unit of account displayed to user is going to be BTC. All you say will work perfectly with this special LTC wallet. Therefore your idea is as good as any other altcoin. In your case, someone else should indeed be able to create such a wallet in which the unit of account will be the new token, thus emulating the current LTC wallets. So the only difference in Litecoin is that the special wallet with BTC as unit is going to be created after the native one, while in your case it is vice versa.\n>>>\n>>> I simply can't see why I'd call this construction of yours a Bitcoin sidechain and any other altcoin not. So I'd call both altcoins.\n>>\n>> Let me try to explain where I am coming from: Whenever I want to onboard a not-so-techy friend to Bitcoin by sending him $5 worth of BTC, I don't have many good options. Usually we end up using BlueWallet. It works great. Though it only works so well because it is fully custodial. That is how they solve all the tough LN problems like inbound-capacity of new users, watchtowers and channel backends. Their service is just an Excel table connect to the LN. Unfortunately, that is the best UX we can currently offer to endusers. To me that's unsatisfying. Is that how we want to enter the emerging markets and on-board the next Billion users? I like that BlueWallet gives me the option to run my own LndHub for my friends. Still, does that scale globally? More importantly, do we want that?\n>>\n>> Now let's think about the altcoins argument. We want to serve a billion users. Blockchains do scale well to about a couple Million UTXOs, so we require a network of a couple thousand altcoins to serve our users.\n>> We know how to build a nice LN for all of our altcoins with a star-shaped topology around Bitcoin as the central settlement layer. Atomic swaps FTW. We can abstract away their native currencies. We display to our users only BTC, hide the exchange rates in the TX fees and we're done. That is actually a scalability solution. So why don't we do that?\n>> The problem here is, that In the long term, the market of PoW blockchains should be a winner-takes-all market, right? So all PoW chains but Bitcoin will eventually die because they're wasting lots of value on their energy. So actually we don't want a couple thousand altcoins wasting resources on pointlessly weak PoW chains. We want a single PoW chain which is as strong as possible.\n>>\n>> That's why I'd argue it makes sense to consider a bitcoin-backed PoS and build a LN of thousands of nameless altcoins.\n>>\n>> Regarding sidechain security: Burning BTC is almost equivalent to burning energy. You might argue that people won't burn BTC, but it is hard to argue against the strong theoretical security properties of proof-of-burn.\n>>\n>> Furthermore, even without burning BTC, using only proof-of-stake I can guarantee doublespending is impossible. There is a very low incentive to risk your BTC's time value. You can only halt a sidechain. And you can halt the sidechain only for as long as you maintain the staking majority. Once you start an attack, you increase the incentive for others to increase their stake. Staking happens in bitcoin's blockchain, which you can't halt. Once the rational stakers regain 51% you've lost a year of time value of your BTC. Note that you can easily enforce stakers having to stake per chain. This guarantees attackers can use their BTC only to attack one chain per year.\n>> Thus, the security of such a bitcoin-based PoS is stronger then one might suspect.\n>>\n>> Thanks again,\n>> - Robin\n>>\n>>>> Regarding Reason #2:\n>>>> In the \"Limitations\" section I discuss the cost of halting the chain:\n>>>>\n>>>> Time value of locked bitcoins might be too cheap to protect the chain. We can introduce an additional cost and let validators burn bitcoins for every on-chain vote. This is much more robust because there is an ongoing cost for halting the system. Proof-of-burn has recently been formally analysed [16]. The economic implications of burning significant amounts of Bitcoin are questionable. A level of security comparable to Bitcoin requires the system\u2019s BTC burn rate to be equal to Bitcoin\u2019s infaltion rate.\n>>>>\n>>>> Also remember, time value of Bitcoins is indeed a value. Even without a proof of burn, I'd consider such sidechains much more secure than those custodial lightning wallets which become more and more popular to circumvent the usability hurdles of the LN.\n>>>\n>>> Comparison to other models is not relevant to my claim that such construction is insecure for small sidechains. And for big sidechains the reason #1 prefers any other altcoin. Even if you introduce proof of burn, the final attack cost is small for an attacker in absolute numbers, despite the fact that in the relative numbers the cost is huge.\n>>>\n>>>> Thanks again,\n>>>> - Robin\n>>>>\n>>>> Sent with [ProtonMail](https://protonmail.com) Secure Email.\n>>>>\n>>>> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>>>> On Monday, January 13, 2020 7:06 PM, Joachim Str\u00f6mbergson <joachimstr at protonmail.com> wrote:\n>>>>\n>>>>> While I haven't rejected sidechains entirely yet, this particular proposal seems uninteresting, especially for two reasons.\n>>>>>\n>>>>> One \u2013 it introduces a new token for each sidechain and suggests atomic swaps to be used for the exchange of the mainchain token with the sidechain token. Such a model seems nonsensical to me because there seems to be excessive number of blockchain projects that can be used similarly just as the sidechain in this proposal. Pick almost any altcoin out there and you can atomic swap it with Bitcoin. The fact that your sidechain is somehow mathematically bound to Bitcoin seems arbitrary because at the end you have a new token and a new issuance model. Therefore this is not extending Bitcoin economy, which is strictly limited by its convergence to zero inflation. This proposal is inflating the supply with a new token, which goes against what many people consider as a pillar of Bitcoin's value proposal. I think if you implement this proposal, you are going not to be considered as a Bitcoin sidechain, but you will be, from certain point of view, indistinguishable from any other altcoin. At the level of my current understanding, the only interesting sidechain model is the [theoretical] one with a two way peg with Bitcoin, preserving the issuance policy of Bitcoin.\n>>>>>\n>>>>> Two \u2013 the security of the proposed system seems to be very fragile, unless I have missed something. When I think about sidechains, I expect that it should be possible to create a niche chain which is used by few participants while the security of the chain is somehow guaranteed from its bind to the mainchain. If this was not the case, such a niche sidechain could easily be attacked, even if just stalled/censored for a long period time, with just a small [absolute] investment from an attacker, although this investment might be large if taken relatively to the utility of this niche sidechain. So if we speak concretely about your proposal, you assume honest majority of validators. But in your system the validators come from locking of stake on Bitcoin chain by nodes that are interested in a particular sidechain. If you put this model on a niche chain where only few participants are interested in it, it's trivial for an attacker to be stronger [have more Bitcoin to lock] than all legitimate users together. You should only use honest majority assumption where the scope is global, where it is very hard and very expensive to obtain majority.\n>>>>>\n>>>>> Sent with [ProtonMail](https://protonmail.com) Secure Email.\n>>>>>\n>>>>> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>>>>> On Sunday, January 12, 2020 6:54 PM, Robin Linus via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>>>\n>>>>>> Hi all,\n>>>>>>\n>>>>>> I've been working on a sidechain protocol with no trusted third party. You can find the [whitepaper here](http://coins.github.io/coins.pdf).\n>>>>>>\n>>>>>> Abstract. Coins is a Bitcoin extension designed for payments at scale. We propose an efficient solution to the double-spending problem using a bitcoin-backed proof-of-stake.  Validators vote on sidechain blocks with one-time signatures, forming a record that cannot be changed without destroying their collateral. Every user can become a validator by locking bitcoins. One-time signatures guarantee that validators loose their stake for publishing conflicting histories. Checkpoints can be additionally secured with a bitcoin-backed proof-of-burn. Assuming a rational majority of validators, the sidechain provides safety and liveness. The sidechain\u2019s footprint within bitcoin\u2019s blockchain is minimal. The protocol is a generic consensus mechanism allowing for arbitrary sidechain assets. Spawning multiple, independent instances scales horizontally.\n>>>>>>\n>>>>>> Feedback is highly appreciated!\n>>>>>>\n>>>>>> Thank you\n>>>>>>\n>>>>>> - Robin\n>>>>>>\n>>>>>> PS: [Here on Github you can find further research on scalability and usability](https://github.com/coins/coins.github.io).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200117/bcdd4c47/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-01-17T13:54:50",
                "message_text_only": "Good morning Robin,\n\n> Hi Joachim,\u00a0\n>\n> > if anyone can halt operation of a sidechain with just tiny investment.\n>\n> It'll be impossible to halt a healthy chain with a tiny investment because halting a chain costs you at least as much as the side chain rewards. The \"invested time value per block\" of all honest stakers converges against the block reward. If imbalanced, someone will stake more bitcoin to get the cheap sidechain rewards. Exactly the same market mechanism secures PoW.\n>\n> For a decentralized consensus via resource consumption it doesn't matter which limited resource you consume. The only relevant factor is that the value of the block reward is sufficient to motivate people to invest a lot of that resource. To motivate them to invest so much that an attacker cannot invest more. Independently of the resource, the amount of honestly invested resources converges against the value of the block reward.\n\nAlso known as MC = MR.\n\nThis is in fact the core of the argument *against* this kind of global microchain system: each individual chain will either:\n\n* Pay ridiculously high fees per transaction, because the microchain has a small number of transactions because that is the entire *point* of microchains.\n* Pay insufficient fees per block, making it easy to attack, meaning the security of the chain has to be centralized around a few actors anyway (e.g. checkpoints, like what every altcoin implements), which is not much better than the custodial case you are complaining against.\n\nIn order to have a sidechain that is as secure as Bitcoin today, you need:\n\n* Sidechain fees to cover both *current Bitcoin fees* plus *current Bitcoin block rewards*.\n\nConsequently, the sidechain has to have either *more* users than Bitcoin today, or *higher* fees than Bitcoin today.\n\nUnless of course you propose to have the sidechain issue its own coin, in which case it is not much more than an altcoin.\nStill, the real-world value of the total block rewards for that altcoin will have to match the real-world value of the total block rewards of Bitcoin in order to have security even approaching Bitcoin.\n\n>\n> Thus, I would even go further with my claim and argue that the security of bitcoin-backed PoS is exactly as strong as PoW because in both cases their security is proportionally to the dollar value of their block reward. PoS sidechain security depends only on a sufficient userbase and thus, block reward value.\n\nOnly if the consumed resource matches what is consumed under PoW.\nOtherwise it is not much better than a low-PoW altcoin, i.e. easily attackable unless it centralizes around the developers.\n\n\nI understand the desire to smoothen the experience of onboarding new users to Bitcoin.\nBut this path is not much better than the custodial solutions you are trying to avoid anyway.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Robin Linus",
                "date": "2020-01-18T08:21:36",
                "message_text_only": "Goog morning ZmnSCPxj,\n\n\n>     Unless of course you propose to have the sidechain issue its own coin, in which case it is not much more than an altcoin.\n\nOkay, call it an altcoin consensus mechanism. Because sidechains do have to issue their own coins.\n\nStill, I am not proposing independent altcoins. Bitcoin is the only unit of account. I am proposing bitcoin derivatives only as means of bitcoin transfer. Think of gold vs cash.\n\n>     Still, the real-world value of the total block rewards for that altcoin will have to match the real-world value of the total block rewards of Bitcoin in order to have security even approaching Bitcoin.\n\nMy point is that, assuming equal rewards, PoW and bitcoin-backed PoS do offer the same level of security.\n\nSo in theory, you are right. In practice, a sidechain does not need to be as secure as bitcoin. It requires only a sufficient user base.\n\n\n\nThanks again for your detailed answer,\n-Robin"
            }
        ],
        "thread_summary": {
            "title": "Coins: A trustless sidechain protocol",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Jeremy",
                "Robin Linus",
                "Angel Leon",
                "ZmnSCPxj",
                "Joachim Str\u00f6mbergson"
            ],
            "messages_count": 22,
            "total_messages_chars_count": 128621
        }
    },
    {
        "title": "[bitcoin-dev] [Annoucement] Discreet Log Contract Protocol Specification",
        "thread_messages": [
            {
                "author": "Chris Stewart",
                "date": "2020-01-13T12:27:34",
                "message_text_only": "Hi all,\n\nSuredbits and Crypto Garage have begun to work on a specification for\nusing discreet\nlog contracts <https://adiabat.github.io/dlc.pdf> in a safe, private and\ninteroperable way. We are writing to the mailing list to inform and solicit\nfeedback for the protocol specification so that we can -- as a community --\nagree on a common standard to use Bitcoin oracles.\n\nOur goal is to end up with a set of documents like the BIPs (Bitcoin\nImprovement Proposals) and BOLTs (Basis of Lightning Technology) so that\nothers that wish to use the technology can easily write software to\nintegrate into the protocol.\n\nA secondary goal of ours is to remain compatible with standards used by\nother bitcoin related protocols (like Lightning) so that every future\nbitcoin related protocol can reach for a \u201ctoolbox\u201d of agreed standards for\nthings like funding transactions and closing transactions. We want to avoid\nreinventing the wheel where possible and allow for library developers to\nre-use software to hook into many bitcoin related protocols.\n\nYou can find the specification repository here:\n\nhttps://github.com/discreetlogcontracts/dlcspecs/\n\nFor more information on DLCs:\n\n[1] - https://adiabat.github.io/dlc.pdf\n\n[2] - https://cryptogarage.co.jp/p2pd/\n\n[3] -\nhttps://suredbits.com/discreet-log-contracts-part-1-what-is-a-discreet-log-contract/\n\n[4] -\nhttps://blockstream.com/2019/04/19/en-transacting-bitcoin-based-p2p-derivatives/\n\n[5] - https://dci.mit.edu/smart-contracts\n\n-Chris\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200113/eca4ae73/attachment-0001.html>"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2020-01-28T09:28:27",
                "message_text_only": "Hi Chris,\n\nThis is a really exciting effort. I hope I will be able to contribute to\nit. I was wondering if you had seen the idea that DLCs can be done in only\ntwo transaction using Schnorr[1]. I also think this can be done in Bitcoin\nas it is today using ECDSA adaptor signatures [2]. In my mind, the adaptor\nsignature protocol is both easier to specify and implement on top of being\ncheaper and more private.\n\nLL\n\n[1] https://lists.launchpad.net/mimblewimble/msg00485.html\n[2]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-November/002316.html\n\nOn Tue, Jan 14, 2020 at 2:12 AM Chris Stewart via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi all,\n>\n> Suredbits and Crypto Garage have begun to work on a specification for\n> using discreet log contracts <https://adiabat.github.io/dlc.pdf> in a\n> safe, private and interoperable way. We are writing to the mailing list to\n> inform and solicit feedback for the protocol specification so that we can\n> -- as a community -- agree on a common standard to use Bitcoin oracles.\n>\n> Our goal is to end up with a set of documents like the BIPs (Bitcoin\n> Improvement Proposals) and BOLTs (Basis of Lightning Technology) so that\n> others that wish to use the technology can easily write software to\n> integrate into the protocol.\n>\n> A secondary goal of ours is to remain compatible with standards used by\n> other bitcoin related protocols (like Lightning) so that every future\n> bitcoin related protocol can reach for a \u201ctoolbox\u201d of agreed standards for\n> things like funding transactions and closing transactions. We want to avoid\n> reinventing the wheel where possible and allow for library developers to\n> re-use software to hook into many bitcoin related protocols.\n>\n> You can find the specification repository here:\n>\n> https://github.com/discreetlogcontracts/dlcspecs/\n>\n> For more information on DLCs:\n>\n> [1] - https://adiabat.github.io/dlc.pdf\n>\n> [2] - https://cryptogarage.co.jp/p2pd/\n>\n> [3] -\n> https://suredbits.com/discreet-log-contracts-part-1-what-is-a-discreet-log-contract/\n>\n> [4] -\n> https://blockstream.com/2019/04/19/en-transacting-bitcoin-based-p2p-derivatives/\n>\n> [5] - https://dci.mit.edu/smart-contracts\n>\n> -Chris\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200128/4b5183aa/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Discreet Log Contract Protocol Specification",
            "categories": [
                "bitcoin-dev",
                "Annoucement"
            ],
            "authors": [
                "Chris Stewart",
                "Lloyd Fournier"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 4261
        }
    },
    {
        "title": "[bitcoin-dev] ***UNCHECKED*** Wormhole: Sending and receiving bitcoin anonymously",
        "thread_messages": [
            {
                "author": "Max Hillebrand",
                "date": "2020-01-15T21:23:15",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\n\nHello all!\n\nMay I propose you this protocol which seemingly provides a great level\nof privacy for both the sender and receiver of bitcoin. This was\ninitially posted to the [Wasabi Wallet\nGitHub](https://github.com/zkSNACKs/Meta/issues/64), and after thorough\ncontemplation and minor tweaks, I would now like to request your\nfeedback on the conceptual design and possible implementation.\n\nCheers\nMax\n\n\n# Wormhole\n\n\n## Abstract\n\nA protocol to transfer bitcoin, without the receiver gaining knowledge\nof the input of the sender, and without the sender gaining knowledge of\nthe output of the receiver, while simultaneously generating equal value\nCoinJoin outputs with anonymity set.\n\n\n## Introduction\n\nThis is achieved by minor changes to the [Zero\nLink](https://github.com/nopara73/zerolink) CoinJoin protocol, utilizing\na centralized coordinator who cannot steal, and cannot spy. Schnorr\nblind signatures are used to obfuscate the link between inputs and equal\nvalue outputs throughout the ceremony. The coordinator does not gain\nknowledge that Wormhole is used.\n\n\n## Protocol\n\n- - Alice A [with tor identity A1 and A2] has a 5.5 bitcoin UTXO\n- - A sends 1 bitcoin to Bob B [with tor identity B1 and B2]\n- - Wasabi server W coordinates the zero link CoinJoin:\n\u00a0\u00a0\u00a0 -- Equal value denominations are 1, 2, 4, 8, 16, 32 bitcoin\n\u00a0\u00a0\u00a0 -- Anonymity set for each denomination is 100\n\u00a0\u00a0\u00a0 -- Wormhole protocol is opt-in for some unknown number of peers\n\n### Input Registration\n\n- - A generates an input proof of the 5.5 bitcoin UTXO\n- - A generates one `blindedOutput` with 4 bitcoin, and one\n`changeAddress` with 0.5 bitcoin\n- - B generates one `blindedOutput` with 1 bitcoin & he sends this\nto A\n- - A1 sends all of the above to W\n- - W verifies\n\u00a0\u00a0\u00a0 -- `maxInputsPerRegistraion` not reached\n\u00a0\u00a0\u00a0 -- `maxInputPerTx` not reached\n\u00a0\u00a0\u00a0 -- `blindedOutput` never registered\n\u00a0\u00a0\u00a0 -- each input\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 --- not already registered for this round\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 --- UTXO not banned\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 --- proof\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 --- unspent\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 --- if coinbase, confirmations > 100\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 --- must be SegWit v0 [maybe also v1] bech32\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 --- is from unconfirmed CoinJoin tx\n- - W generates `uniqueID`\n- - W signs all `blindedOutput`\n- - W sends `uniqueID` & `signedBlindedOutput` to A1\n\n### Connection Confirmation\n\n- - Starts when `timeSinceLastRound > maxWaitPeriod` OR\n`registeredInputs > requiredInputs`\n- - A abandons if confirmation is refused\n- - A1 sends `uniqueID` W\n- - W verifies `uniqueID`, and calculates `roundHash = hash of all\nregistered inputs`\n- - W sends `roundHash` to A1 and B1\n\n### Output Registration\n\n- - Starts when `confirmedUniquelds == registeredInputs` OR `timeout &&\nconfirmedUniquelds >= requiredInputs`\n- - A sends `signedBlindedOuput_B` to B\n- - Both A and B unblind the `signedBlindedOutput`\n- - Both A2 and B2 send `output` & `signature` & `roundHash`\n**DIRECTLY** to W - they do **NOT** send to each other\n- - W verifies `roundHash` & `signature` & `Output`\n\n### Signing\n\n- - Starts when `outputs == registeredInputs` OR `timeout` [go signing,\neven if there are missing outputs to identify them and ban them as they\nwon't sign]\n- - W builds CoinJoin transaction `CJTX` and sends to A1 and B1\nand all other peers\n- - A and B verify `roundHash` [by calculating hash of all `txInputs`]\n- - B verifies that his output is included & signs a commitment\nmessage m where he acknowledges that it is included & sends m to A\n- - A verifies that her input and her outputs are included & verifies\nB signature of m [assumption that Bob provides a correct address, as\nwith any transaction] & signs `CJTX`\n- - A1 sends `uniqueID` & `signature, inputIndex` to W - A does\n**NOT** send this to B\n- - W verifies `uniqueID` & each signature against\n`inputs[uniqueID][index]`\n\n### Broadcast TX\n\n- - Starts when `signatures == registeredInputs`\n- - W broadcasts signed transaction to the Bitcoin peer-to-peer network\n\n\n## Result\n\n- - A has one 4 bitcoin UTXO with 100 anonset & one 0.5 bitcoin\nUTXO with 1 anonset\n- - B has one 1 bitcoin UTXO with 100 anonset\n- - W knows the input and change of A & W does not know who\ncontrols which equal value output & W does not know that B has no inputs\n- - A does not know the output of B, there are 99 possible coins.\n- - B does not know the input and outputs of A, there are 100+\npossible coins.\n\n\n## Communication\n\nThis is an interactive protocol with several rounds of communication,\nthus all A & B & W need to be online. The communication between\nA and B can be done on any suitably private channel, including but\nnot limited to tor, QR codes, SD cards, or carrier pigeon. The\ncommunication between A / B & W will be the same as used for the\nregular zero link implementation, most likely tor.\n\n\n## Privacy\n\nThe equal value zero link outputs from A and B have the anonymity\nset of the total number of equal value zero link outputs in the same\ntransaction. Wormhole breaks the assumption that zero link is a\nconsolidation within the same wallet [`Input Alice = Output Alice +\nFee`], in a way that neither A nor B can spy on each other. W does\nnot know if any peer is using Wormhole, none or one or all peers\n**might** use it.\n\n\n## Questions\n\nI am not sure what information is broadcasted from W to all peers in\nthe round, and if Bob can get this information without revealing that he\nis the receiver of a Wormhole transaction [he has no input proof]. What\ninformation can be send from W to B directly will determine the\ntrust level of A passing honest messages.\n\nWormhole might be used in conjunction with [Pay to\nEndpoint](https://medium.com/@nopara73/pay-to-endpoint-56eb05d3cac6) or\n[Knapsack](https://www.comsys.rwth-aachen.de/fileadmin/papers/2017/2017-maurer-trustcom-coinjoin.pdf)\nso that A can send a specific amount to B, with part being the equal\nvalue zero link output, and part the P2EP change, or Knapsack\nsub-transaction.\n\n[Atomic coin\nswaps](https://github.com/ElementsProject/scriptless-scripts/blob/master/md/atomic-swap.md)\nwith Schnorr adaptor signatures might be integrated, so A input in\n`CJTX1` \"pays\" B output in `CJTX2`, but this might require B to know\nthe signature [and thus the input] of A.\n\n- -- \nThis email was signed with my PGP key [E900 5F66 A86B B816 BD7D 967E\nBEDC D95C 42AC\n3C57](https://towardsliberty.com/contact/PGP_MaxHillebrand.txt)\nPlease verify it on my [website](https://towardsliberty.com/contact),\n[github](https://github.com/maxhillebrand/contact) and on the bottom\nright corner of my [videos](https://towardsliberty.com/videos).\n-----BEGIN PGP SIGNATURE-----\n\niQIzBAEBCgAdFiEESKcexyWeb+u7zuh5+CjfVEmKd88FAl4fgr4ACgkQ+CjfVEmK\nd8/56xAAnRcr8CN945OGzHQOZE4aaSKDipPBIPhuRs4RNWSzlP+16gUuDOksR31b\nP8lXgleycr/SHipL2CwrBdl4FPNX82CKw9p5rO/PBkkZ4g3TNAyMJD6ec2S0oBRc\nhsASMPWJ7oXoRFf9yXKUnFyjMPg75U12pw3GmNOu9EM8FB50zjCO61BB2VRbFHTh\nVZ5KVWHclOMyWpQsz+/awi9kzpP2t0/dMV1vx6fq3DhlzXQOKEGXQ+yh4eZ+0L+Y\n9DwjBVH1q0QufQHwZynWv+TjSftdwJqdiCeKpO1UQo+IgaBE6CkHSlwOK/09mPHK\nhcSaSpa75KbNIdZUP+6bZG1aLT4AWMAdxbeR/Z4E50bqnHsvETcJeN+L6vopcLZN\n3Pyc7jWD82+jBqXrLez7IiIyHRxrqrcyrLYAJoNavvtyGKRnT/jodxsX0QDyhm/3\nPfHwADKrrnYtcnSL2rpSNNAEQF8SOXRPUm+Kr7rrwnfegiRjtIz1uD5lysPj++OJ\nO9yxQsnhNt6/lAkUTXnQPPIooqEXXazDb0hrJMguXfnPVRsKGpzajHg7e33d5OZx\nvLSpKZx9TGOPbsbC6vR+NXz6n0U3Kba26Qc4dSYUi3sdLokcTR0wvDxHxTouYswr\nKPOaqR11SZ3wsL9NTXbU91SyVQBvdZP95uvlpoN3n9kopzSO5eA=\n=HG53\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-01-16T02:11:44",
                "message_text_only": "Good morning Max,\n\nIt seems similar very closely to TumbleBit, at least in the overall protocol.\nA cursory read does not reveal any direct problems with it.\n\nRegards,\nZmnSCPxj\n\n> Hello all!\n>\n> May I propose you this protocol which seemingly provides a great level\n> of privacy for both the sender and receiver of bitcoin. This was\n> initially posted to the Wasabi WalletGitHub, and after thoroughcontemplation and minor tweaks, I would now like to request your\n> feedback on the conceptual design and possible implementation.\n>\n> Cheers\n> Max\n>\n> Wormhole\n>\n> =========\n>\n> Abstract\n>\n> ---------\n>\n> A protocol to transfer bitcoin, without the receiver gaining knowledge\n> of the input of the sender, and without the sender gaining knowledge of\n> the output of the receiver, while simultaneously generating equal value\n> CoinJoin outputs with anonymity set.\n>\n> Introduction\n>\n> -------------\n>\n> This is achieved by minor changes to theZeroLink CoinJoin protocol, utilizinga centralized coordinator who cannot steal, and cannot spy. Schnorr\n> blind signatures are used to obfuscate the link between inputs and equal\n> value outputs throughout the ceremony. The coordinator does not gain\n> knowledge that Wormhole is used.\n>\n> Protocol\n>\n> ---------\n>\n> -   Alice A [with tor identity A1 and A2] has a 5.5 bitcoin UTXO\n> -   A sends 1 bitcoin to Bob B [with tor identity B1 and B2]\n> -   Wasabi server W coordinates the zero link CoinJoin:\n>     \u00a0\u00a0\u00a0 -- Equal value denominations are 1, 2, 4, 8, 16, 32 bitcoin\n>     \u00a0\u00a0\u00a0 -- Anonymity set for each denomination is 100\n>     \u00a0\u00a0\u00a0 -- Wormhole protocol is opt-in for some unknown number of peers\n>\n>\n> ### Input Registration\n>\n> -   A generates an input proof of the 5.5 bitcoin UTXO\n> -   A generates one `blindedOutput` with 4 bitcoin, and one\n>     `changeAddress` with 0.5 bitcoin\n>\n> -   B generates one `blindedOutput` with 1 bitcoin & he sends this\n>     to A\n>\n> -   A1 sends all of the above to W\n> -   W verifies\n>     \u00a0\u00a0\u00a0 -- `maxInputsPerRegistraion` not reached\n>     \u00a0\u00a0\u00a0 -- `maxInputPerTx` not reached\n>     \u00a0\u00a0\u00a0 -- `blindedOutput` never registered\n>     \u00a0\u00a0\u00a0 -- each input\n>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 --- not already registered for this round\n>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 --- UTXO not banned\n>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 --- proof\n>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 --- unspent\n>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 --- if coinbase, confirmations > 100\n>\n>\n> --- must be SegWit v0 [maybe also v1] bech32\n> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 --- is from unconfirmed CoinJoin tx\n>\n> -   W generates `uniqueID`\n> -   W signs all `blindedOutput`\n> -   W sends `uniqueID` & `signedBlindedOutput` to A1\n>\n> ### Connection Confirmation\n>\n> -   Starts when `timeSinceLastRound > maxWaitPeriod` OR\n>\n> `registeredInputs > requiredInputs`\n>\n> -   A abandons if confirmation is refused\n> -   A1 sends `uniqueID` W\n> -   W verifies `uniqueID`, and calculates `roundHash = hash of all registered inputs`\n> -   W sends `roundHash` to A1 and B1\n>\n> ### Output Registration\n>\n> -   Starts when `confirmedUniquelds == registeredInputs` OR `timeout && confirmedUniquelds >= requiredInputs`\n>\n> -   A sends `signedBlindedOuput_B` to B\n>\n> -   Both A and B unblind the `signedBlindedOutput`\n>\n> -   Both A2 and B2 send `output` & `signature` & `roundHash`\n>     DIRECTLY to W - they do NOT send to each other\n>\n> -   W verifies `roundHash` & `signature` & `Output`\n>\n>\n> ### Signing\n>\n> -   Starts when `outputs == registeredInputs` OR `timeout` [go signing,\n>     even if there are missing outputs to identify them and ban them as they\n>     won't sign]\n>\n> -   W builds CoinJoin transaction `CJTX` and sends to A1 and B1\n>     and all other peers\n>\n> -   A and B verify `roundHash` [by calculating hash of all `txInputs`]\n> -   B verifies that his output is included & signs a commitment\n>     message m where he acknowledges that it is included & sends m to A\n>\n> -   A verifies that her input and her outputs are included & verifies\n>     B signature of m [assumption that Bob provides a correct address, as\n>     with any transaction] & signs `CJTX`\n>\n> -   A1 sends `uniqueID` & `signature, inputIndex` to W - A does\n>     NOT send this to B\n>\n> -   W verifies `uniqueID` & each signature against\n>     `inputs[uniqueID][index]`\n>\n>\n> ### Broadcast TX\n>\n> -   Starts when `signatures == registeredInputs`\n> -   W broadcasts signed transaction to the Bitcoin peer-to-peer network\n>\n>\n> Result\n>\n> -------\n>\n> -   A has one 4 bitcoin UTXO with 100 anonset & one 0.5 bitcoin\n>     UTXO with 1 anonset\n>\n> -   B has one 1 bitcoin UTXO with 100 anonset\n> -   W knows the input and change of A & W does not know who\n>     controls which equal value output & W does not know that B has no inputs\n>\n> -   A does not know the output of B, there are 99 possible coins.\n> -   B does not know the input and outputs of A, there are 100+\n>     possible coins.\n>\n>\n> Communication\n>\n> --------------\n>\n> This is an interactive protocol with several rounds of communication,\n> thus all A & B & W need to be online. The communication between\n> A and B can be done on any suitably private channel, including but\n> not limited to tor, QR codes, SD cards, or carrier pigeon. The\n> communication between A / B & W will be the same as used for the\n> regular zero link implementation, most likely tor.\n>\n> Privacy\n>\n> --------\n>\n> The equal value zero link outputs from A and B have the anonymity\n> set of the total number of equal value zero link outputs in the same\n> transaction. Wormhole breaks the assumption that zero link is a\n> consolidation within the same wallet [`Input Alice = Output Alice + Fee`], in a way that neither A nor B can spy on each other. W does\n> not know if any peer is using Wormhole, none or one or all peers\n> might use it.\n>\n> Questions\n>\n> ----------\n>\n> I am not sure what information is broadcasted from W to all peers in\n> the round, and if Bob can get this information without revealing that he\n> is the receiver of a Wormhole transaction [he has no input proof]. What\n> information can be send from W to B directly will determine the\n> trust level of A passing honest messages.\n>\n> Wormhole might be used in conjunction with Pay toEndpoint orKnapsack\n> so that A can send a specific amount to B, with part being the equal\n> value zero link output, and part the P2EP change, or Knapsack\n> sub-transaction.\n>\n> Atomic coinswapswith Schnorr adaptor signatures might be integrated, so A input in\n> `CJTX1` \"pays\" B output in `CJTX2`, but this might require B to know\n> the signature [and thus the input] of A.\n>\n> --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n>\n> This email was signed with my PGP key E900 5F66 A86B B816 BD7D 967EBEDC D95C 42AC3C57Please verify it on my website,\n> github and on the bottom\n> right corner of my videos."
            }
        ],
        "thread_summary": {
            "title": "***UNCHECKED*** Wormhole: Sending and receiving bitcoin anonymously",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Max Hillebrand"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 14735
        }
    },
    {
        "title": "[bitcoin-dev] I want to rebuild the GUI in JavaScript",
        "thread_messages": [
            {
                "author": "M.K. Safi",
                "date": "2020-01-16T18:30:24",
                "message_text_only": "Thank you for the feedback Jonas. It was helpful.\n\nI'll take this topic off list since this is probably not the right place\nfor it, but just for those who emailed me asking about how to follow the\nprogress, I've been working on a proof-of-concept over the last month and\npublished it here: https://github.com/orange-org/orange\n\nI would appreciate contributions toward growing this. Check out the bottom\nof the README for ways to get involved. Thanks!\n\nOn Sat, Nov 23, 2019 at 10:36 AM Jonas Schnelli via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi\n>\n> This is probably the wrong place to discuss that (OT).\n>\n> > I\u2019d like to try to rebuild Bitcoin Core GUI using the JavaScript\n> Electron framework. My goal is to get a real world understanding of the\n> pros and cons of moving from Qt to Electron.\n>\n> There is a relatively new Bitcoin Core Github issue that covers that topic\n> [1].\n> AFAIK many Bitcoin Core contributors (and users?) don\u2019t like the idea of\n> having a Browser and JavaScript to achieve a UI with relatively simple\n> user-stories.\n>\n> I think if you want to do this, try to work on a third party project and\n> let your Electron UI connect to Bitcoin Core over RPC.\n> To avoid pulling, eventually use ZMQ or help getting long polling into\n> Bitcoin Core [2].\n>\n> Adding a Electron/JavaScript UI to the Bitcoin Core repository is very\n> unlikely to happen.\n>\n> [1] https://github.com/bitcoin/bitcoin/issues/17395\n> [2] https://github.com/bitcoin/bitcoin/pull/7949\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200116/e1893bcc/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "I want to rebuild the GUI in JavaScript",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "M.K. Safi"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1874
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Knots 0.19.0.1.knots20200104 released",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2020-01-19T17:04:35",
                "message_text_only": "Bitcoin Knots version 0.19.0.1.knots20200104 is now available from:\n\n  https://bitcoinknots.org/files/0.19.x/0.19.0.1.knots20200104/\n\nThis release includes new features, various bug fixes and performance \nimprovements, as well as updated translations.\n\nPlease report bugs using the issue tracker at GitHub:\n\n  https://github.com/bitcoinknots/bitcoin/issues\n\nTo receive security and update notifications, please subscribe to:\n\n  https://bitcoinknots.org/list/announcements/join/\n\nFor the full release notes and change log, see:\n\nhttps://github.com/bitcoinknots/bitcoin/blob/v0.19.0.1.knots20200104/doc/release-notes.md\n\nNew features of particular interest\n===================================\n\n- BIP157 (Neutrino) can be enabled to serve compact block filters to peers.\n  This requires both the `-blockfilterindex` and `-peercfilters` options\n  enabled, and can also be turned on in the GUI settings under the Network\n  tab.\n\n- PSBT support has been experimentally expanded to include the new version and\n  proprietary fields, as well as easier usage from the GUI for watch-only\n  wallets.\n\n- The Overview tab now has the ability to hide private information. This is\n  still an experimental feature, and suggestions for how the new \"privacy\n  mode\" should look can be made on the related Core PR:\n    https://github.com/bitcoin/bitcoin/pull/16432\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 1524 bytes\nDesc: This is a digitally signed message part.\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200119/83ec0ecc/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Knots 0.19.0.1.knots20200104 released",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Luke Dashjr"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1645
        }
    },
    {
        "title": "[bitcoin-dev] Payswap",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2020-01-21T04:38:07",
                "message_text_only": "Good morning list,\n\n[On a recent post on lightning-dev](https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-January/002431.html), I brought up the possibility of using a circular self-payment to hide the actual direction of payment from third-party snooping nodes.\nBasically, instead of paying the amount to the destination, we can have an atomic mechanism by which the source pays a larger-than-amount payment to the destination and the destination returns the difference instead.\n\nAs the mechanisms on Lightning are also implementable directly on the blockchain, I observe as well that we can use a similar mechanism based on CoinSwap to mislead onchain analysis as well.\n\nThe normal payment flow for a Bitoin payer is typically:\n\n* Locate some of its owned UTXO(s) that total an amount equal or greater than the payment amount.\n* Create a single transaction that consumes those inputs and outputs the amount to the destination and any remainder to a new address we control.\n\nHowever, we can observe as well that transactions and transaction outputs can be considered nodes and edges of a transaction graph, respectively.\nWe can then consider the categorical dual of such a graph.\n\nLet me then present the Payswap payment flow:\n\n* Sender locates some of its owned UTXO(s) that total an amount equal or greater than the payment amount.\n  * Sender reveals the sum to destination.\n* Destination locates some of its owned UTXO(s) that total an amount equal or greater than the difference (change) of the sender total minus the payment amount.\n* Sender and destination set up an unequal CoinSwap:\n  * Destination receives all the Sender coins.\n  * Sender receives the difference between the Sender total and the payment amount (change).\n* Sender and destination execute the CoinSwap and complete the payment protocol.\n\nWhat appears onchain are:\n\n* A transaction with a single output.\n  * This is the CoinSwap funding transaction that was offered by the sender and claimed by the destination.\n  * As a single-output transaction, this looks to chain analysis to be a likely self-payment.\n* A transaction with two outputs.\n  * This is the CoinSwap funding transaction that was offered by the destination and claimed by the sender.\n  * The output that goes back to the destination looks like a change output according to chain analysis.\n  * The output that goes to the sender looks like a payment from the destination to the sender, reversing the apparent direction of payment and obscuring the amount paid.\n* Two more transaction that complete the protocol, each spending one of the above and moving the funds to unilateral control of the destination and sender respectively.\n\nThe above is an active misleading of chain analysis.\n\nThis is even possible today with 2p-ECDSA to make it use P2WPKH with Scriptless Script.\n\nAgainst the above flow I must caution:\n\n* This involves more transactions than Payjoin, thus more expensive in blockspace.\n* The protocol can be aborted by one participant, which will lead to spending onchain fees to back out of the protocol, unlike Payjoin which is atomic with paying onchain fees.\n* As I [point out elsewhere](https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002245.html), CoinSwap overhead approaches the overhead of setting up a temporary Lightning Network channel, thus it might actually be better to implement all CoinSwap protocols over Lightning instead.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-01-24T10:11:55",
                "message_text_only": "Good morning list,\n\nA few more things to consider:\n\nProbably the correct order for this would be for the payer to instantiate the Scriptless Script payment to the payee first, then the payee instantiating the change back to the payer.\n\nBy use of some kind of Scriptless Script, it is possible to as well implement a proof-of-payment system similar to Lightning, which might be useful to prove to an auditor that a payment has been made (without being forced to reveal this to anyone other than the auditor).\nBoth the payer and payee can generate a scalar.\nThe payee provides a signed invoice (can reuse the Lightning BOLT11 invoice format) attesting the payment point that needs to be paid, the payment point being the generator point times te payee scalar.\nThe payer then instantiates the Scriptless Script PTLC, requiring knowledge of the payee scalar + the payer scalar from the payee.\nThen the payee instantiates the change Scriptless Script PTLC, requiring knowledge of the payer scalar from the payer.\nThen the payee claims the change, which allows the payer to claim the full transfer while revealing the payee scalar as a proof-of-payment.\n\n\nRegards,\nZmnSCPxj\n\n> Good morning list,\n>\n> On a recent post on lightning-dev, I brought up the possibility of using a circular self-payment to hide the actual direction of payment from third-party snooping nodes.\n> Basically, instead of paying the amount to the destination, we can have an atomic mechanism by which the source pays a larger-than-amount payment to the destination and the destination returns the difference instead.\n>\n> As the mechanisms on Lightning are also implementable directly on the blockchain, I observe as well that we can use a similar mechanism based on CoinSwap to mislead onchain analysis as well.\n>\n> The normal payment flow for a Bitoin payer is typically:\n>\n> -   Locate some of its owned UTXO(s) that total an amount equal or greater than the payment amount.\n> -   Create a single transaction that consumes those inputs and outputs the amount to the destination and any remainder to a new address we control.\n>\n>     However, we can observe as well that transactions and transaction outputs can be considered nodes and edges of a transaction graph, respectively.\n>     We can then consider the categorical dual of such a graph.\n>\n>     Let me then present the Payswap payment flow:\n>\n> -   Sender locates some of its owned UTXO(s) that total an amount equal or greater than the payment amount.\n>     -   Sender reveals the sum to destination.\n> -   Destination locates some of its owned UTXO(s) that total an amount equal or greater than the difference (change) of the sender total minus the payment amount.\n> -   Sender and destination set up an unequal CoinSwap:\n>     -   Destination receives all the Sender coins.\n>     -   Sender receives the difference between the Sender total and the payment amount (change).\n> -   Sender and destination execute the CoinSwap and complete the payment protocol.\n>\n>     What appears onchain are:\n>\n> -   A transaction with a single output.\n>     -   This is the CoinSwap funding transaction that was offered by the sender and claimed by the destination.\n>     -   As a single-output transaction, this looks to chain analysis to be a likely self-payment.\n> -   A transaction with two outputs.\n>     -   This is the CoinSwap funding transaction that was offered by the destination and claimed by the sender.\n>     -   The output that goes back to the destination looks like a change output according to chain analysis.\n>     -   The output that goes to the sender looks like a payment from the destination to the sender, reversing the apparent direction of payment and obscuring the amount paid.\n> -   Two more transaction that complete the protocol, each spending one of the above and moving the funds to unilateral control of the destination and sender respectively.\n>\n>     The above is an active misleading of chain analysis.\n>\n>     This is even possible today with 2p-ECDSA to make it use P2WPKH with Scriptless Script.\n>\n>     Against the above flow I must caution:\n>\n> -   This involves more transactions than Payjoin, thus more expensive in blockspace.\n> -   The protocol can be aborted by one participant, which will lead to spending onchain fees to back out of the protocol, unlike Payjoin which is atomic with paying onchain fees.\n> -   As I point out elsewhere, CoinSwap overhead approaches the overhead of setting up a temporary Lightning Network channel, thus it might actually be better to implement all CoinSwap protocols over Lightning instead.\n>\n>     Regards,\n>     ZmnSCPxj\n>\n>\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "Payswap",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 8200
        }
    },
    {
        "title": "[bitcoin-dev] op_checktemplateverify and number of inputs",
        "thread_messages": [
            {
                "author": "Billy",
                "date": "2020-01-25T01:50:49",
                "message_text_only": "I have a question about op_ctv related to the requirement to specify the\nnumber of inputs. I don't quite see why its necessary, but most\nimportantly, I don't see why we want to *require* the user of the op to\nspecify the number of inputs, tho I see the reasoning why one would want to\nspecify it. If the op allowed both cases (specifying a number of inputs and\nallowing any number), it seems like the best of both worlds. I started a\ndiscussion on bitcointalk.org:\n\nhttps://bitcointalk.org/index.php?topic=5220520\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200124/5cd8c5b5/attachment.html>"
            },
            {
                "author": "Jeremy",
                "date": "2020-01-26T17:23:57",
                "message_text_only": "Hi Billy,\n\nRestricting the number of inputs is necessary to preclude TXID\nmalleability. Committing to all of the information required necessitates\nthat the number of inputs be committed.\n\nThis allows us to build non-interactive layer 2 protocols which depend on\nTXID non-malleability (most of them at writing).\n\nYou raise a good point that allowing *any number* of inputs is an\ninteresting case, which I had discussed offline with a few different\npeople. I think the conclusion was that that flexibility is better left\noutside of the OP directly.\n\nIf you want an any number of inputs template, and we enable something like\nOP_CAT (e.g., OP_CAT, OP_SHA256STREAM) then you can spend to something like:\n\n<hash data before # inputs> OP_SWAP OP_CAT OP_SWAP OP_CAT <data post #\ninputs> OP_CAT OP_SHA256 OP_CTV\n\nAnd then pass in the # of inputs and sequences hash as arguments to the\nfunction.\n\nI can respond separately to your bitcointalk post as you ask a different\nset of questions there.\n\nBest,\n\nJeremy\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\n\nOn Sun, Jan 26, 2020 at 8:59 AM Billy via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I have a question about op_ctv related to the requirement to specify the\n> number of inputs. I don't quite see why its necessary, but most\n> importantly, I don't see why we want to *require* the user of the op to\n> specify the number of inputs, tho I see the reasoning why one would want to\n> specify it. If the op allowed both cases (specifying a number of inputs and\n> allowing any number), it seems like the best of both worlds. I started a\n> discussion on bitcointalk.org:\n>\n> https://bitcointalk.org/index.php?topic=5220520\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200126/a0b42ad4/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "op_checktemplateverify and number of inputs",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Billy",
                "Jeremy"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2788
        }
    },
    {
        "title": "[bitcoin-dev] New tool to assist in BIP 340-342 review: tap",
        "thread_messages": [
            {
                "author": "Karl-Johan Alm",
                "date": "2020-01-30T11:55:13",
                "message_text_only": "Hello,\n\nOne of the tools I am maintaining called btcdeb (Bitcoin Script\nDebugger) has a new experimental branch \"taproot\", which builds on top\nof the WIP taproot pull request to Bitcoin Core, and contains a new\ncommand line tool called \"tap\".\n\nTap allows you to compose taproot and/or tapscript outputs, both for\nfunding and spending.\n\nThere is a detailed tutorial on how this works here:\nhttps://github.com/kallewoof/btcdeb/blob/taproot/doc/tapscript-example-with-tap.md\n\nFeedback welcome."
            }
        ],
        "thread_summary": {
            "title": "New tool to assist in BIP 340-342 review: tap",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Karl-Johan Alm"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 490
        }
    },
    {
        "title": "[bitcoin-dev] Onchain fee insurance mechanism",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2020-01-31T03:42:08",
                "message_text_only": "Good morning list,\n\nDuring LNConf 2019, Jack Mallers presented about hedging of onchain fees, which he argues is necessary in order to have a smooth experience interfacing between onchain and offchain (in particular, when closing and opening channels).\n\nThe exact mechanism proposed was to construct a futures market on onchain feerates, with miners taking short positions on fees (they are naturally long on fees) while users take long positions on fees (they are naturally short on fees).\n\nI observe that what the users effectively experience is similar to a constant feerate (indeed the positions the user takes up are arranged such that the user takes a constant feerate for a vast majority of the expected future outcomes).\nThis is effectively an insurance policy against increases in feerate.\n\nLet me then propose a specific mechanism for feerate insurance against onchain feerate spikes.\n\nLet us suppose that the user Alice, has 500000 satoshi, and has to pay Bob 400000 satoshi.\nFurther, Alice and Bob have a fee insurance provider Ingrid.\nIngrid assures Alice and Bob that 600 satoshi is sufficient to confirm the payment from Alice to Bob within 4 blocks.\nIngrid also happens to have a 800000 satoshi output lying around.\n\nAt current blockheight B, Alice and Ingrid then arrange a series of transactions:\n\n    nLockTime: B+1\n    nSequence: RBF enabled, no relative locktime.\n    inputs: Alice 5000000, Ingrid 800000\n    outputs:\n        Bob 400000\n        Alice 99400\n        Ingrid 800400\n    fee: 200\n\n    nLockTime: B+2\n    nSequence: RBF enabled, no relative locktime.\n    inputs: Alice 5000000, Ingrid 800000\n    outputs:\n        Bob 400000\n        Alice 99400\n        Ingrid 800200\n    fee: 400\n\n    nLockTime: B+3\n    nSequence: RBF enabled, no relative locktime.\n    inputs: Alice 5000000, Ingrid 800000\n    outputs:\n        Bob 400000\n        Alice 99400\n        Ingrid 800001\n    fee: 599\n\n    nLockTime: B+4\n    nSequence: RBF enabled, no relative locktime.\n    inputs: Alice 5000000, Ingrid 800000\n    outputs:\n        Bob 400000\n        Alice 99400\n        Ingrid 797000\n    fee: 3600\n\nBasically, if the first transaction is able to be included in the next block immediately, then Ingrid is able to earn the most of the fee paid by Alice.\nHowever, as more blocks pass without the transaction getting committed, the transaction in the mempool is replaced by transactions that bump up the fee, until the time limit is reached and Ingrid pays out significantly in order to ensure the payment pushes through.\n\nAs far as I can tell, this mechanism will also work for CPFP-style transactions.\n\nIn general, the insurance provider Ingrid will be a miner.\n\n--\n\nIn the original context, this is generally about fast confirmation of channel closes.\nAt the time that a commitment transaction is made, it is uncertain if the feerate for it would still remain valid for some future spike.\nThe safest is that, if the counterparty is offline, if the feerate spikes, we should drop the channel unilaterally onchain before it rises so high that the commitment transaction cannot be confirmed in a timely manner.\nHowever, if the feerate then settles lower afterwards, we have already broadcasted the channel closure will no longer be able to use the fund on Lightning.\n\nUnfortunately, the mechanism described above requires absolute locktimes, which would impose a maximum lifetime on channels, which we would like to avoid.\nThus, the mechanism cannot be used for Lightning closes.\n\nFor the Lightning case, what we want is something like:\n\n* Ingrid assures Alice and Bob that the close transaction can be confirmed at any time, for only N satoshi.\n\nThe previous mechanism described is nearer to:\n\n* Ingrid assures Alice that the transaction can be confirmed up to B blocks from now, for only N satoshi.\n\nThe issue is that relative locktimes require that a transaction be confirmed, and it is transaction itself that we want to assure.\nThus, we cannot use relative locktimes for any kind of fee-insurance mechanism.\nThus, we must somehow tie down the blockheight at which we start our countdown, and so we cannot use this for Lightning closes, since Lightning closes must be freely doable at any time.\n\nStill, the mechanism might be useful for onchain transactions to help reassure users (which is why I send this post to bitcoin-dev).\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "David A. Harding",
                "date": "2020-01-31T21:01:29",
                "message_text_only": "On Fri, Jan 31, 2020 at 03:42:08AM +0000, ZmnSCPxj via bitcoin-dev wrote:\n> Let me then propose a specific mechanism for feerate insurance against onchain feerate spikes.\n> \n> [...]\n> \n> At current blockheight B, Alice and Ingrid then arrange a series of transactions:\n> \n>     nLockTime: B+1\n>     nSequence: RBF enabled, no relative locktime.\n>     inputs: Alice 5000000, Ingrid 800000\n>     outputs:\n>         Bob 400000\n>         Alice 99400\n>         Ingrid 800400\n>     fee: 200\n>\n> [...]\n\nIngrid is able to rescind this series of pre-signed transactions at any\ntime before one of the transactions is confirmed by double spending her\nUTXO (e.g. via a RBF fee bump).  If Alice needs to trust Ingrid to honor\nthe contract anyway, they might as well not include Ingrid's input or\noutput in the transaction and instead use an external accounting and\npayment mechanism.  For example, Alice and Ingrid agree to a fee\nschedule:\n\n>     height: B+1\n>     fee: 200\n>\n>     height: B+2\n>     fee: 400\n>\n>     height: B+3\n>     fee: 599\n>\n>     height: B+4\n>     fee: 3600\n\nThen they wait for whichever version of the transaction to confirm and\none of them remits to the other the appropriate amount (either 400, 200,\nor 1 base unit to Ingrid, or 3,000 base units to Alice).  This\nremittance can be done by whatever mechanism they both support (e.g. an\nonchain transaction, an LN payment, or just credit on an exchange).\n\nSince it's possible to achieve equivilent security (or lack thereof)\nwithout the locktime mechanism, I don't think the locktime mechanism\nadds anything to the idea of hedging fees---and, as you note, it suffers\nfrom incompatibility with some cases where users would be especially\neager to obtain feerate insurance.\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200131/7493919a/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Onchain fee insurance mechanism",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "David A. Harding"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 6367
        }
    },
    {
        "title": "[bitcoin-dev] Purge attacks (spin on sabotage attacks)",
        "thread_messages": [
            {
                "author": "ha su",
                "date": "2020-01-31T13:38:22",
                "message_text_only": "Hi all,\n\nI think I discovered an interesting form of sabotage attack (possible for\nminers) that tries to create coordination disincentives among Bitcoin users\n- named after the dystopian movie The Purge, where all crime is legal for\none night every year.\n\nTLDR\n* An attacker replaces the most recent blocks full of transactions with\nempty blocks.\n* Previously confirmed txns return into the mempool, where anyone with a\nminimum of technical knowledge or access to public tools can\nopportunistically double-spend their txns back to themselves. (the process\nis the same as double-spending regular zero-conf txns)\n\nThe attack seems useful to undermine trust in Bitcoin's assurances, e.g.\nthe future finality of transactions. It differs from other forms of\nsabotage (e.g. DoS by mining only empty blocks) in that it specifically\ndisrupts the coordination process among users in response to the attack.\n\nBy giving some users a chance to benefit from the attack, the attacker\ngives them a vested interest in staying on the attack chain. If enough\nusers accept the invitation to double-spend, it might become harder to come\nto consensus on how to deal with the attack.\n\nPurge attacks probably don\u2019t constitute a bigger risk than other known\nforms of sabotage attacks, but seem like an interesting spin where the\nattacker specifically targets the pre-coordination of defenders.\n\nYou can find the full report, incl. some mitigations against sabotage\nattacks, at\nhttps://blog.deribit.com/insights/destabilizing-bitcoin-consensus-with-purge-attacks/\n\nYour feedback is highly appreciated.\n\nRegards,\nHasu\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200131/774692b8/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Purge attacks (spin on sabotage attacks)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ha su"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1774
        }
    },
    {
        "title": "[bitcoin-dev] Characterizing orphan transaction in the Bitcoin network",
        "thread_messages": [
            {
                "author": "Anas",
                "date": "2020-01-31T23:07:26",
                "message_text_only": "Hi all,\n\nThis paper - https://arxiv.org/pdf/1912.11541.pdf - characterizes orphan\ntransactions in the Bitcoin network and shows that increasing the size of\nthe orphan pool reduces network overhead with almost no additional\nperformance overhead. What are your thoughts?\n\nAbstract:\n\n> Orphan transactions are those whose parental income-sources are missing at\n> the time that they are processed. These transactions are not propagated to\n> other nodes until all of their missing parents are received, and they thus\n> end up languishing in a local buffer until evicted or their parents are\n> found. Although there has been little work in the literature on\n> characterizing the nature and impact of such orphans, it is intuitive that\n> they may affect throughput on the Bitcoin network. This work thus seeks to\n> methodically research such effects through a measurement campaign of orphan\n> transactions on live Bitcoin nodes. Our data show that, surprisingly,\n> orphan transactions tend to have fewer parents on average than non-orphan\n> transactions. Moreover, the salient features of their missing parents are a\n> lower fee and larger size than their non-orphan counterparts, resulting in\n> a lower transaction fee per byte. Finally, we note that the network\n> overhead incurred by these orphan transactions can be significant,\n> exceeding 17% when using the default orphan memory pool size (100\n> transactions). However, this overhead can be made negligible, without\n> significant computational or memory demands, if the pool size is merely\n> increased to 1000 transactions.\n\n\nRegards,\nAnas\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200131/374b5b05/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Characterizing orphan transaction in the Bitcoin network",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Anas"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1772
        }
    }
]