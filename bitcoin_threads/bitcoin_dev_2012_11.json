[
    {
        "title": "[Bitcoin-development] IRC meeting agenda, 18:00 UTC Thursday",
        "thread_messages": [
            {
                "author": "Gavin Andresen",
                "date": "2012-11-06T18:47:34",
                "message_text_only": "Thursdays at 18:00 UTC (6PM Europe/1PM east US/10AM west US) seem to\nbe a good time for the core dev team to meet on the #bitcoin-dev\nfreenode IRC channel to chat.\n\nI'd like to talk about:\n\no Can we put together a TODO list to get to a 0.8 release candidate ?\n\no Is it time to feature-freeze 0.8 and work on just testing the new\nfeatures and fixing existing bugs (the issues list keeps getting\nlonger and longer ... )?\n\no BIP process: are we happy with how it is working? What can we do to\nimprove it?\n\nWhat else should we talk about?\n\n-- \n--\nGavin Andresen"
            },
            {
                "author": "Luke-Jr",
                "date": "2012-11-06T19:13:33",
                "message_text_only": "On Tuesday, November 06, 2012 6:47:34 PM Gavin Andresen wrote:\n> Thursdays at 18:00 UTC (6PM Europe/1PM east US/10AM west US) seem to\n> be a good time for the core dev team to meet on the #bitcoin-dev\n> freenode IRC channel to chat.\n> \n> I'd like to talk about:\n> \n> o Can we put together a TODO list to get to a 0.8 release candidate ?\n> \n> o Is it time to feature-freeze 0.8 and work on just testing the new\n> features and fixing existing bugs (the issues list keeps getting\n> longer and longer ... )?\n\nNot much has changed besides internal workings, right?\nThough perhaps that's still significant enough for 0.8.\n\n> o BIP process: are we happy with how it is working? What can we do to\n> improve it?\n\nAmir seems to be more and more absent these days, so it might be nice to setup \na successor failsafe in the event that he cannot be reached. It would be a \nshame for the BIP process to fall apart merely because we can't get numbers \nassigned.\n\nBut more important to the success of BIP today, I think, is encouraging wider \ncommunity participation. The stratum mining mess seems to be a direct result \nof lack of participation in the GBT BIP process (resulting in it not being as \nideal as some pools desire) and lack of any peer review/contribution toward \nthe stratum protocol. What can we do to increase awareness of BIP and \nencourage more collaboration?\n\nLuke"
            },
            {
                "author": "slush",
                "date": "2012-11-06T19:56:23",
                "message_text_only": "On Tue, Nov 6, 2012 at 7:13 PM, Luke-Jr <luke at dashjr.org> wrote:\n\n> But more important to the success of BIP today, I think, is encouraging\n> wider\n> community participation.\n\n\nIt's not about BIP process, it's possibly about content of particular\nproposals.\n\n\n> The stratum mining mess seems to be a direct result\n\n\nThere's no mess with stratum mining, except in your head. There's no\nrequirement to have BIP for everything what people do. Stratum is NOT\nrelated to bitcoin protocol or bitcoin implementation, it is just custom,\npooled-mining extension and bitcoin network doesn't need to know about\nStratum existence at all.\n\n\n> and lack of any peer review/contribution toward the stratum protocol.\n\n\nThere have been peer review of the protocol. You wanted to say \"I was not\ninvited to do peer review\", right?\n\nPlease don't start it AGAIN and stop bashing Stratum in your posts, at\nleast in bitcoin-dev mailing list.\n\nI promised to write BIP draft for Stratum, I proposed and implemented\nget_transactions method to allow Stratum jobs inspection. What more do you\nwant, seriously? I'm soo tired by you, Luke.\n\nslush\n\nP.S. I'm sorry that other developers had to read such posts. I'll try to\nsit on my hands next time.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20121106/2d9a1a30/attachment.html>"
            },
            {
                "author": "Luke-Jr",
                "date": "2012-11-06T22:12:53",
                "message_text_only": "On Tuesday, November 06, 2012 7:56:23 PM slush wrote:\n> On Tue, Nov 6, 2012 at 7:13 PM, Luke-Jr <luke at dashjr.org> wrote:\n> > But more important to the success of BIP today, I think, is encouraging\n> > wider community participation.\n> \n> It's not about BIP process, it's possibly about content of particular\n> proposals.\n> ...\n> I promised to write BIP draft for Stratum, I proposed and implemented\n> get_transactions method to allow Stratum jobs inspection. What more do you\n> want, seriously? I'm soo tired by you, Luke.\n\nPerhaps the problem lies in misunderstanding of the BIP process, then, rather \nthan awareness of it. BIP isn't just \"write a document\"; that's just the first \nstep. The main thing is that it gets peer review, changed to meet the \ncommunity's needs, and when done should result in a common standard suitable \nto the needs of the whole community. Whatever the reason, there was a failure \nof key members of the community to participate in the GBT BIP process and \nensure it addressed their needs/wants; identifying and addressing that is \nsomething that would improve the BIP process.\n\nget_transactions is a step in the right direction, and I don't think anyone \nexpects Stratum to reach the same level as GBT overnight considering it took \nmonths for GBT (though I have no doubt now that the GBT discussions have taken \nplace, that some dedicated individual could probably combine the two if they \ndedicated a few days to it). My comments, however, were not intended to bash \nstratum or mere complain about the past (it can't be changed), but an attempt \nto learn from the past and figure out how we can improve things the next time \naround.\n\nLuke"
            },
            {
                "author": "Pieter Wuille",
                "date": "2012-11-07T19:37:26",
                "message_text_only": "On Tue, Nov 6, 2012 at 7:47 PM, Gavin Andresen <gavinandresen at gmail.com> wrote:\n> Thursdays at 18:00 UTC (6PM Europe/1PM east US/10AM west US) seem to\n> be a good time for the core dev team to meet on the #bitcoin-dev\n> freenode IRC channel to chat.\n\nOk, good.\n\n-- \nPieter"
            },
            {
                "author": "Mike Hearn",
                "date": "2012-11-08T09:19:05",
                "message_text_only": "I won't be able to make it this time.  My feeling is IRC is a good place to\nbounce ideas around when time and people happen to be available, but having\nmeetings there will inevitably lead to decision making that's better done\nin a slower manner via email.\n\nComments:\n\n   BIP process: are we happy with how it is working? What can we do to improve\nit?\n\nNeeding some kind of process to allocate a number is over the top. I\nskipped this for the bloom filtering BIP. We should take off the part of\nthe {{BIP}} template that says \"don't just pick a number and add a bip\" -\nthat's exactly what people should do. I'm not sure there's any need for an\nediting role either.\n\n    Is it time to feature-freeze 0.8\n\nI'd like more time to get the bloom filtering work in. It'll be easier to\npromote the 0.8 release if we can sell it as \"important\nscalability/performance improvement for the network, upgrade to help\nBitcoin keep growing\", as whilst there's no real auto update or organized\npeople who religiously update promotion is very important. I think\nultraprune + bloom filtering is the two major scalability improvements we\nhave right now.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20121108/af4d5de4/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2012-11-08T12:56:52",
                "message_text_only": "On Thu, Nov 08, 2012 at 10:19:05AM +0100, Mike Hearn wrote:\n> Comments:\n> \n>    BIP process: are we happy with how it is working? What can we do to improve\n> it?\n> \n> Needing some kind of process to allocate a number is over the top. I\n> skipped this for the bloom filtering BIP. We should take off the part of\n> the {{BIP}} template that says \"don't just pick a number and add a bip\" -\n> that's exactly what people should do. I'm not sure there's any need for an\n> editing role either.\n\nRight now, there seem to be little problems with allocation and viability of\nproposed BIPs, with hardly any reviewing/formal allocation being done in\npractice. In the past there have been collisions though, and there also have\nbeen nonsensical proposals. I'm in favor of some moderate form of process,\nbut if the process becomes a burden more than a help, there is clearly a\nproblem.\n\nIt seems there is also little attractiveness to writing BIPs. If many proposals\ndo not result in useful discussion, there is little incentive to write one\nexcept for those proposals that absolutely need to (p2p protocol, block\nvalidity rules, ...). That's a pity in my opinion - I'd like to see non-core\nproposals related to Bitcoin being discussed more often as well.\n\n> \n>     Is it time to feature-freeze 0.8\n> \n> I'd like more time to get the bloom filtering work in. It'll be easier to\n> promote the 0.8 release if we can sell it as \"important\n> scalability/performance improvement for the network, upgrade to help\n> Bitcoin keep growing\", as whilst there's no real auto update or organized\n> people who religiously update promotion is very important. I think\n> ultraprune + bloom filtering is the two major scalability improvements we\n> have right now.\n\nAgree, I think Bloom filtering should make it into 0.8 - it's a critical\nstep to make SPV clients more useful for end users.\n\nRegarding ultraprune, there are a few TODOs left:\n* Auto-migrate old data (depends on -reindex, for which there is a pullreq)\n* UTXO set consistency checks at startup (-checklevel)\n\n-- \nPieter"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2012-11-08T13:07:31",
                "message_text_only": "On Thu, Nov 8, 2012 at 4:19 AM, Mike Hearn <mike at plan99.net> wrote:\n>     Is it time to feature-freeze 0.8\n>\n> I'd like more time to get the bloom filtering work in. It'll be easier to\n> promote the 0.8 release if we can sell it as \"important\n> scalability/performance improvement for the network, upgrade to help Bitcoin\n\nI agree on getting the bloom filtering stuff in for 0.8, though I\ndon't think it'll need any marketing at all\u2014 ultraprune speaks for\nitself. :P\nI'm also concerned about overselling it for miners and merchants when\nthe ultraprune stuff is such a major change.\n\nSince the current changes will just need a lot of testing and soaking\ntime which is pretty much independent of RPC and GUI changes it might\nbe unfortunate to feature freeze those things and then have a long\ndelay just on QA for the other stuff.  I do think we need to talk\nabout what we think we need to o to get what we have now ready for\nrelease."
            }
        ],
        "thread_summary": {
            "title": "IRC meeting agenda, 18:00 UTC Thursday",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Luke-Jr",
                "slush",
                "Mike Hearn",
                "Gregory Maxwell",
                "Gavin Andresen",
                "Pieter Wuille"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 9573
        }
    },
    {
        "title": "[Bitcoin-development] Draft BIP for Bloom filtering",
        "thread_messages": [
            {
                "author": "Pieter Wuille",
                "date": "2012-11-06T19:14:58",
                "message_text_only": "On Fri, Oct 26, 2012 at 04:01:58PM +0200, Mike Hearn wrote:\n> I don't feel I understand the effort required to do some kind of\n> partial tree encoding. Having a kind of custom compression whereby\n> branches are represented as varint indexes into a dictionary, I can\n> feel how much work that involves and maybe I can make time over the\n> next few weeks to implement it. Has anyone got example code for\n> representing partial Merkle trees?\n\nI've implemented code for efficient representation of partial merkle\ntrees: see https://github.com/sipa/bitcoin/commits/partialmerkle\n\nThe encoding/decoding algorithm uses a depth-first traversal of the tree, at\neach node outputting whether anything relevant is beneath, and if not, storing\nits hash and not descending into the children.\n\nFurthermore, thanks to some properties of the tree, some hard upper bounds on\nthe size of the serialized structures are guaranteed. See the comments in the\ncode for details.\n\nUnit tests are included to verify that\n1) encoding and decoding a subset of transactions is an identity\n2) the calculated merkle root matches the merkle root calculated by the existing merkle algorithm in the source code\n3) the calculated merkle root actually depends on all hashes in the data structure.\n4) serialization/deserialization is an identity\n5) bounds on the size of the serialization are respected\n\nHope it is clear enough to port to other languages.\n\n-- \nPieter"
            },
            {
                "author": "Pieter Wuille",
                "date": "2012-11-21T15:15:35",
                "message_text_only": "On Wed, Oct 24, 2012 at 05:56:07PM +0200, Mike Hearn wrote:\n> I've written a draft BIP describing the bloom filtering protocol\n> extension developed by myself and Matt.\n> \n> https://en.bitcoin.it/wiki/BIP_0037\n\nTwo comments I made on the pullreq page, which are probably better discussed here:\n* The 0xFFFFFFFF/(n-1)*i seed value seems intended to result in large bit\n  differences between the different hash function's seeds. Together with the tweak,\n  however, the first and the last now get seeds tweak and tweak-1. I think\n  something simpler like k1*i+k2*n+tweak is better (with k1 and k2 arbitrary large\n  odd 32-bit integers).\n* I feel uneasy about the arbitrary filter parameters used for the implicitly\n  created filter when sending filteradd without filterload. The server cannot be\n  expected to make a reasonable guess how the client is going to use the filter,\n  and the client still has to track how large the server-side filter grows anyway.\n  I'd prefer to make this simply illegal (DoS 100): filteradd always requires an\n  active filter. Maybe the actual filter data in filterload can be made optional:\n  if it is omitted, it's assumed to be all zeroes (though that would mean the size\n  has to be specified).\n\n-- \nPieter"
            },
            {
                "author": "Matt Corallo",
                "date": "2012-11-21T18:38:37",
                "message_text_only": "On Wed, 2012-11-21 at 16:15 +0100, Pieter Wuille wrote:\n> On Wed, Oct 24, 2012 at 05:56:07PM +0200, Mike Hearn wrote:\n> > I've written a draft BIP describing the bloom filtering protocol\n> > extension developed by myself and Matt.\n> > \n> > https://en.bitcoin.it/wiki/BIP_0037\n> \n> Two comments I made on the pullreq page, which are probably better discussed here:\n> * The 0xFFFFFFFF/(n-1)*i seed value seems intended to result in large bit\n>   differences between the different hash function's seeds. Together with the tweak,\n>   however, the first and the last now get seeds tweak and tweak-1. I think\n>   something simpler like k1*i+k2*n+tweak is better (with k1 and k2 arbitrary large\n>   odd 32-bit integers).\nMeh, sure, whatever...I dont really think the seed values matter\nsignificantly (Murmur3 isnt that bad of a hash function...) (and the\noriginal algorithm wont result in a significant bit difference between\nthe seeds in many cases).\n> * I feel uneasy about the arbitrary filter parameters used for the implicitly\n>   created filter when sending filteradd without filterload. The server cannot be\n>   expected to make a reasonable guess how the client is going to use the filter,\n>   and the client still has to track how large the server-side filter grows anyway.\n>   I'd prefer to make this simply illegal (DoS 100): filteradd always requires an\n>   active filter.\nI think there is some consensus here, and I have no problem doing it\nthis way (in large part, filteradd should not be used at all).\n> Maybe the actual filter data in filterload can be made optional:\n>   if it is omitted, it's assumed to be all zeroes (though that would mean the size\n>   has to be specified).\n> \nI'm not sure here, if you are sending a filter just to use filteradd to\nadd things to it manually, you are doing something very, very, very\nwrong... Though we could certainly do some kind of compressed bloom\nfilter encoding to allow for small filter loads (loading the few things\nyou need to filteradd right away) where you anticipate adding\nsignificantly more filter elements down the road (can anyone even come\nup with a case where you anticipate doing this?), the filter is small\nenough (max 36kB) that I see little benefit for the large increase in\ncomplexity (or is this another repeat of the merkle branch discussion?)\n\nMatt"
            },
            {
                "author": "Pieter Wuille",
                "date": "2012-11-27T21:10:23",
                "message_text_only": "On Wed, Nov 21, 2012 at 01:38:37PM -0500, Matt Corallo wrote:\n> On Wed, 2012-11-21 at 16:15 +0100, Pieter Wuille wrote:\n> > On Wed, Oct 24, 2012 at 05:56:07PM +0200, Mike Hearn wrote:\n> > > I've written a draft BIP describing the bloom filtering protocol\n> > > extension developed by myself and Matt.\n> > > \n> > > https://en.bitcoin.it/wiki/BIP_0037\n> > \n> > Two comments I made on the pullreq page, which are probably better discussed here:\n> > * The 0xFFFFFFFF/(n-1)*i seed value seems intended to result in large bit\n> >   differences between the different hash function's seeds. Together with the tweak,\n> >   however, the first and the last now get seeds tweak and tweak-1. I think\n> >   something simpler like k1*i+k2*n+tweak is better (with k1 and k2 arbitrary large\n> >   odd 32-bit integers).\n> Meh, sure, whatever...I dont really think the seed values matter\n> significantly (Murmur3 isnt that bad of a hash function...) (and the\n> original algorithm wont result in a significant bit difference between\n> the seeds in many cases).\n\nSure, it's nothing important, but it seems like it fails to do what it was intended for.\n\nHow about just this: tweak + i*0xFBA4C795 (number optimized to give large seed\ndifferences for every tweak). If you want variation when changing the number of hash\nfunctions, just choose a different seed. \n\n> > Maybe the actual filter data in filterload can be made optional:\n> >   if it is omitted, it's assumed to be all zeroes (though that would mean the size\n> >   has to be specified).\n> > \n> I'm not sure here, if you are sending a filter just to use filteradd to\n> add things to it manually, you are doing something very, very, very\n> wrong... Though we could certainly do some kind of compressed bloom\n> filter encoding to allow for small filter loads (loading the few things\n> you need to filteradd right away) where you anticipate adding\n> significantly more filter elements down the road (can anyone even come\n> up with a case where you anticipate doing this?), the filter is small\n> enough (max 36kB) that I see little benefit for the large increase in\n> complexity (or is this another repeat of the merkle branch discussion?)\n\nIt's probably not worth it for something that is max 36 kilobytes. If ever\nnecessary, we can define a new message type that just lists a number of bits to\nbe set in the server-side filter.\n\nFor now, I agree that you should just send the filter as intended, and not expect to\ndo many filteradds (though you should take the implicitly-added txids into\naccounted when computing the filter size).\n\n-- \nPieter"
            }
        ],
        "thread_summary": {
            "title": "Draft BIP for Bloom filtering",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Pieter Wuille",
                "Matt Corallo"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 7563
        }
    },
    {
        "title": "[Bitcoin-development] Fwd:  IRC meeting agenda, 18:00 UTC Thursday",
        "thread_messages": [
            {
                "author": "Wladimir",
                "date": "2012-11-08T13:10:45",
                "message_text_only": "On Thu, Nov 8, 2012 at 10:19 AM, Mike Hearn <mike at plan99.net> wrote:\n\n> I won't be able to make it this time.  My feeling is IRC is a good place\n> to bounce ideas around when time and people happen to be available, but\n> having meetings there will inevitably lead to decision making that's better\n> done in a slower manner via email.\n\n\nWell I think regularly scheduled IRC meetings are a good idea, as for some\nsmaller decisions quick brainstorming tends to work better than long e-mail\nthreads.\n\nBut indeed big and important decisions should be posted on the mailing list\ntoo.\n\n\n> Comments:\n>\n>    BIP process: are we happy with how it is working? What can we do to improve\n> it?\n>\n> Needing some kind of process to allocate a number is over the top. I\n> skipped this for the bloom filtering BIP. We should take off the part of\n> the {{BIP}} template that says \"don't just pick a number and add a bip\" -\n> that's exactly what people should do. I'm not sure there's any need for an\n> editing role either.\n>\n\nAgreed in that we don't need a \"number allocation king\". But some rules for\nthe numbering can be good to keep sanity. What about very simply \"everyone\nthat wants to create a BIP picks the next available number and reserves\nthat page on the Wiki?\".\n\n\n>\n>     Is it time to feature-freeze 0.8\n>\n> I'd like more time to get the bloom filtering work in. It'll be easier to\n> promote the 0.8 release if we can sell it as \"important\n> scalability/performance improvement for the network, upgrade to help\n> Bitcoin keep growing\", as whilst there's no real auto update or organized\n> people who religiously update promotion is very important. I think\n> ultraprune + bloom filtering is the two major scalability improvements we\n> have right now.\n>\n\nI'm not sure about a full feature freeze. I agree it could be wise not do\nany more changes of the scale of ultraprune before 0.9, to give some\nstability to fix the kinks in the current version.\n\nWladimir\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20121108/2f36acb3/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Fwd:  IRC meeting agenda, 18:00 UTC Thursday",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Wladimir"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2137
        }
    },
    {
        "title": "[Bitcoin-development] Electrum security model concerns",
        "thread_messages": [
            {
                "author": "Gregory Maxwell",
                "date": "2012-11-15T23:45:09",
                "message_text_only": "On Sat, Oct 6, 2012 at 12:37 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n> I'm concerned about how the particular security model of electrum is\n> being described; or rather\u2014 not being described.\n\nJust to close the loop on this: I finally got in touch with Thomas on\nIRC and walked over the security issues I brought up here, plus a\nnumber of other ones.\n\nHe took the concerns seriously and rapidly redesigned big swaths of\nelectrum to eliminate the issues structurally.  Electrum no longer a\nclassical thin client it is now a slightly watered down\nsimplified-payment-validation node with generally the same security\nproperties as other SPV nodes. Its network behavior leaves it somewhat\nmore vulnerable to isolation and compromise by a high hash power\nattacker, because it does not (yet) make an effort to make sure it's\nreally on the longest chain. It is also more vulnerable to transaction\nhiding (a DOS attack) for similar reasons.  But this is still a\nmassive improvement.  The UI was also changed and the confirmation\nstatus of payments is no longer hidden.\n\nThere are still things to improve\u2014 both in the client and the security\ncommunication to users. But I wanted to leave a note that it's come a\nlong way and that I now feel confident that any remaining issues will\nbe resolved."
            },
            {
                "author": "Mike Hearn",
                "date": "2012-11-16T15:59:45",
                "message_text_only": "Great to hear that.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20121116/9b635a41/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2012-11-16T17:44:32",
                "message_text_only": "BTW have you checked the code? I took a quick look and didn't see things I\nwas expecting to see. In particular I couldn't find any code that manages\nwallet state in the presence of re-orgs. It appears to check that\ntransactions appeared in the block chain, but if there's a chain switch\nit's not clear to me the wallet will be in the right state.\n\nI saw a message from Thomas on his thread saying something like \"can't\nspend coins bug happens when there's a re-org and the server gives you the\nwrong histories, to fix it reset your wallet and switch to a new server\"\n.... which to me rather implies there's no re-org handling at all.\n\nIf Electrum does end up doing all SPV work correctly, how is it different\nto MultiBit? Just the deterministic wallet seeding?\n\n\nOn Fri, Nov 16, 2012 at 4:59 PM, Mike Hearn <mike at plan99.net> wrote:\n\n> Great to hear that.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20121116/ec070abb/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Electrum security model concerns",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Mike Hearn",
                "Gregory Maxwell"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 2536
        }
    },
    {
        "title": "[Bitcoin-development] TLS (SSL) for bitcoin.org and downloads",
        "thread_messages": [
            {
                "author": "Jay Weisskopf",
                "date": "2012-11-16T14:58:40",
                "message_text_only": "Are there any plans to eventually force TLS (SSL) for bitcoin.org and\nits downloads?\n\n- Jay"
            }
        ],
        "thread_summary": {
            "title": "TLS (SSL) for bitcoin.org and downloads",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jay Weisskopf"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 91
        }
    },
    {
        "title": "[Bitcoin-development] Bitcoin and ISO",
        "thread_messages": [
            {
                "author": "Jeff Garzik",
                "date": "2012-11-25T05:42:51",
                "message_text_only": "A forum post worth tracking: https://bitcointalk.org/index.php?topic=127604.0\n\nEvery little standardization helps.\n\n-- \nJeff Garzik\nexMULTI, Inc.\njgarzik at exmulti.com"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin and ISO",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 168
        }
    },
    {
        "title": "[Bitcoin-development] Has anyone compiled under MacOS 10.8?",
        "thread_messages": [
            {
                "author": "Mike Hearn",
                "date": "2012-11-26T15:05:54",
                "message_text_only": "It appears that something about Boost doesn't play nicely with the default\nbuild instructions (possibly the switch to clang++?).\n\nI will dig in eventually but for now, if anyone has a recipe that fixes\nthings, let me know.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20121126/199d3806/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2012-11-29T20:34:20",
                "message_text_only": "I found that the problem is the version of the Qt SDK I used didn't\nlike the new MacOS version. Re-installing Qt fixed it.\n\nOn Mon, Nov 26, 2012 at 4:05 PM, Mike Hearn <mike at plan99.net> wrote:\n> It appears that something about Boost doesn't play nicely with the default\n> build instructions (possibly the switch to clang++?).\n>\n> I will dig in eventually but for now, if anyone has a recipe that fixes\n> things, let me know."
            }
        ],
        "thread_summary": {
            "title": "Has anyone compiled under MacOS 10.8?",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Mike Hearn"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 832
        }
    },
    {
        "title": "[Bitcoin-development] Payment Protocol Proposal: Invoices/Payments/Receipts",
        "thread_messages": [
            {
                "author": "Gavin Andresen",
                "date": "2012-11-26T22:37:31",
                "message_text_only": "This is the next big \"lets all agree to do things the same way\" thing\nI think we should tackle. I'm particularly looking for feedback from\nother bitcoin client developers, even if it is just a quick \"looks\nreasonable, if everybody else is going to do it then I will\n(eventually) too...\"\n\nThanks to Pieter Wuille and Mike Hearn for lots of feedback and\nsuggestions and brainstorming.\n\nThis document is online at https://gist.github.com/4120476\n\nIf you respond to this message, please be considerate of people who\nsubscribe to the digest version of this mailing list and trim your\nresponse.\n\n\nInvoices, Payments and Receipts for Bitcoin Transactions\n========================================================\n\nThis document proposes protocol buffer-based formats for signed,\nauthenticated \"invoices\" and \"receipts\" -- requests for payment, and\nproof-of-payment.\n\nSeparate documents propose an extension to the Bitcoin URI syntax and\nnew MIME types to support them.\n\nMotivation\n==========\n\nThe idea of a \"payment protocol\" to improve on Bitcoin addresses has\nbeen around for over a year. Users have been asking for some features\nin this proposal (like the ability to provide a refund address so\noverpayments or refunds can be returned to customers without the need\nto ask them for their address) for two or three years, and have\nstarted to work around shortcomings in the Bitcoin payment process\nwith creative (but inefficient) uses of transactions.\n\nThe key features of this proposal are:\n\n+ Requests for payment (Invoices) are tied to authenticated identities\nusing the only widely-deployed identity authentication system we have\nright now (X.509 certificates signed by root certificate authorities)\n+ Invoices include a user-friendly description of what the payment is for\n+ Payments include where refunds should be sent\n+ At the end of the payment process, the customer holds a\ncryptographically signed Receipt that can be used as proof-of-payment\nif there is any dispute with the merchant.\n\n\nSpecification\n=============\n\nInvoice/SignedInvoice\n---------------------\n\nAn Invoice is a request for payment from a merchant to a customer:\n\n::\n\n    message Output {\n\toptional uint64 amount = 1;\n\trequired bytes script = 2;\n    }\n\namount: Number of satoshis (0.00000001 BTC) to be paid. If not given\nor zero, then the customer will be asked how much to pay.\n\nscript: a \"TxOut\" script to which the customer should direct payment.\nThis will normally be one of the standard Bitcoin transaction script\n(e.g. pubkey OP_CHECKSIG).\n\n::\n\n    message Invoice {\n        repeated bytes x509chain = 1;\n        repeated Output outputs = 2;\n        required uint64 time = 3;\n        optional uint64 expires = 4;\n        optional bool single_use = 5 [default = true];\n        optional string memo = 6;\n        optional string receiptURI = 7;\n        optional bytes merchant_data = 8;\n    }\n\noutputs: one or more outputs where Bitcoins are to be sent.\n\nx509chain: one or more DER-encoded X.509 certificates that identifies\nthe merchant. See the \"Certificates\" section below for details.\n\ntime: Unix timestamp (seconds since 1-Jan-1970) when the Invoice was created.\n\nexpires: Unix timestamp after which the Invoice should be considered\ninvalid. If not given, the Invoice may be re-used until the earliest\ncertificate expiration date in the X509chain.\n\nsingle_use: If true, this Invoice should be used for only one payment.\nIf false, it may be added to the user's address book and used\nrepeatedly until it expires (e.g. for donations or a recurring\npayment).\n\nmemo: UTF-8 encoded, plain-text (no formatting) note that should be\ndisplayed to the customer, explaining what this Invoice is for.\n\nreceiptURI: Secure (https) URI where a Payment message (see below) may\nbe sent to obtain a SignedReceipt as proof-of-payment.\n\nmerchant_data : Arbitrary data ignored by the client that may be used\nby the merchant to identify the Invoice.\n\n::\n\n    message SignedInvoice {\n        required Invoice invoice = 1;\n        required bytes signature = 2;\n    }\n\nA SignedInvoice is an Invoice signed using the private key\ncorresponding to the public key in the first certificate in the\nx509chain and the HMAC SHA-256 algorithm.\n\nWhen a Bitcoin client receives a SignedInvoice, it must authorize\npayment by doing the following:\n\n1. Validate the x509chain certificate chain up to it's list of root\ncertificate authorities\n2. Validate that the time on the customer's system is before Invoice.expires\n3. Display the \"Common Name\" (CN) string from the first x509chain\ncertificate and ask the customer if they would like to submit payment\n\nPayment\n-------\n\n::\n\n    message Payment {\n        required Invoice invoice = 1;\n        repeated bytes transactions = 2;\n        repeated Output refund_to = 3;\n        optional string memo = 4;\n    }\n\ninvoice : the invoice received from the merchant. A merchant must\nvalidate the Invoice and may reject the Payment if the Invoice was\naltered by the customer.\n\ntransactions : One or more valid, signed Bitcoin transactions that\nfully pay the Invoice\n\nrefund_to : One or more outputs where the merchant may return funds,\nif necessary.\n\nmemo : UTF-8 encoded, plain-text note from the customer to the merchant.\n\nIf the customer authorizes payment, then the Bitcoin client:\n\n1. Creates and signs a transaction with one output sending the Invoice.script\n2. If there is no Invoice.receiptURI, then the transaction is\nbroadcast on the Bitcoin p2p network.\n3. Else POST a Payment message to Invoice.receiptURI and expect a\nSignedReceipt in response.\n\nInvoice.receiptURI must be secure against man-in-the-middle attacks\nthat might alter Payment.refund_to.\n\n*Note: an alternative would be a SignedPayment message that ties the\nsignatures in Payment.transactions to a signature for the entire\nPayment message. Spending multisig inputs that may be controlled by\nmore than one person or spending arbitrary non-standard transactions\nmakes that non-trivial.*\n\nReceipt/SignedReceipt\n---------------------\n\n::\n\n    message Receipt {\n        required Payment payment = 1;\n        required bool accepted = 2;\n        optional string memo = 3;\n    }\n\naccepted : true if the Payment is accepted and will be broadcast on\nthe Bitcoin p2p network.\n\nmemo : UTF-8 encoded note that should be displayed to the customer\nindicating that the transaction is complete.\n\n::\n\n    message SignedReceipt {\n        required Receipt receipt = 1;\n        required bytes signature = 3;\n    }\n\nA SignedReceipt is a Receipt signed using the private key\ncorresponding to the public key in the first certificate in the\nReceipt->Payment->Invoice.x509chain and the HMAC SHA-256 algorithm.\n\nUpon receiving a SignedReceipt, a Bitcoin client should validate the\nsignature and, if valid, display the Receipt.memo and store the\nSignedReceipt as proof-of-payment.\n\nIf a SignedReceipt is not received for any reason (timeout, error) and\nPayment.transactions has not been broadcast by the merchant on the\nBitcoin p2p network, then the Bitcoin client should assume that the\npayment failed, inform the customer that the payment failed, and\nreturn coins involved in the transaction to the customer's wallet.\n\n\nCertificates\n============\n\nThe Invoice.x509chain (X.509 Certificate Chain) field contains the\nX.509 public key certificate or certificate chain [RFC5280]\ncorresponding to the key used to digitally sign the Invoice and\nReceipt. The certificate or certificate chain is represented as an\narray of DER [ITU.X690.1994] PKIX certificate value. The certificate\ncontaining the public key of the entity that digitally signed the\nInvoice MUST be the first certificate. This MAY be followed by\nadditional certificates, with each subsequent certificate being the\none used to certify the previous one. The recipient MUST verify the\ncertificate chain according to [RFC5280] and reject the payment\nrequest if any validation failure occurs.\n\n*What should we say about root certificates and certificate management\nin general? Any requirements, or leave it up to each Bitcoin client to\ndetermine which root CA's are trustworthy, as happens with web\nbrowsers? Gavin suggests trusting only (say) ten of the Extended\nValidation authorities:\nhttp://en.wikipedia.org/wiki/Extended_Validation_Certificate#Extended_Validation_certificate_identification\n*\n\n*X.509 is widely criticised for doing too much. However, it is the\nPublic Key Infrastructure (PKI) system we're stuck with. Do web\nbrowsers / certificate authorities support the full X.509 spec, or\nonly a subset? Should Bitcoin clients only support some well-defined\nsubset of X.509 ? More research needed here... *\n\nUse Cases\n=========\n\nMerchant Payment Service\n------------------------\n\nA merchant payment service (like Paysius or bit-pay.com) would use\nInvoices and Receipts as follows:\n\n1. Merchant pays for a certificate from a certificate authority, and\nthen gives the payment service the certificate and their private key.\nThis could be the same certificate and private key as is used for the\nmerchant's web site, but best security practice would be to purchase a\nseparate certificate for authenticating Invoices. Very successful\nmerchant payment services might act as intermediate certificate\nauthorities, issuing certificates for their merchants.\n2. Customer goes through the checkout process on either the merchant's\nor payment service's web site.\n3. At the end of the checkout process, a SignedInvoice is generated\nand sent to the customer's Bitcoin client.\n4. Customer's Bitcoin client displays the Invoice, showing that the\npayment is for the merchant.\n5. On customer approval, a Payment is sent to the payment service's\npaymentURI. The merchant is notified of the payment, and the customer\nreceives a SignedReceipt as proof-of-payment.\n\nSatoshiDice\n-----------\n\nSatoshiDice (www.satoshidice.com) is an extremely popular game that\nuses tiny transactions for some customer/service communications. In\nparticular, customers can add an extra output to their transactions to\nindicate where winnings should be sent. And SatoshiDice creates tiny\ntransactions to let their customers know that a bet was received, but\nlost.\n\nAssuming Bitcoin clients upgrade to support this proposal, a bet on\nSatoshiDice would proceed as follows:\n\n1. Customer clicks on a link on SatoshiDice.com and their Bitcoin\nclient receives a SignedInvoice.\n2. Customer authorizes payment, and their Bitcoin client creates a\nPayment message and submits it directly to\nhttps://satoshidice.com/something\n3. The SatoshiDice web server checks to make sure the transaction is\nvalid, broadcasts it, and determines whether the customer wins or\nloses. It returns a SignedReceipt with either a \"You win\" or \"You\nlost\" memo.\n4. If the customer won, it broadcasts a transaction to pay them using\nPayment.refund_to\n5. Customer's Bitcoin client displays the win/lose memo, and if they\nwon the winnings appear in their wallet when received over the p2p\nnetwork.\n\nMultiperson Wallet\n------------------\n\nThis use case starts with a multi-signature Bitcoin address or wallet,\nwith keys held by two different people (Alice and Bob). Payments from\nthat address/wallet must be authorized by both Alice and Bob, and both\nare running multi-signature-capable Bitcoin clients.\n\nAlice begins the payment process by getting a SignedInvoice from a\nmerchant that needs to be paid. She authorizes payment and her Bitcoin\nclient creates a Payment message with a partially-signed transaction,\nwhich is then sent to Bob any way that is convenient (email\nattachment, smoke signals...).\n\nBob's Bitcoin client validates the SignedInvoice and asks Bob to\nauthorize the transaction. He says OK, his Bitcoin client completes\nthe transaction by providing his signature, submits the payment to the\nmerchant, and then sends a message to Alice with the SignedReceipt he\nreceived from the merchant, completing the payment process.\n\n\nDesign Notes\n============\n\nWhy X.509 Certificates?\n-----------------------\n\nThis proposal uses X.509 certificates as the identity system for\nmerchants because most of them will have already purchased a\ncertificate to secure their website and will be familiar with the\nprocess of proving their identity to a certificate issuing authority.\n\nImplementing a better global PKI is outside the scope of this\nproposal. If a better PKI is adopted, the only change to this proposal\nwould be to replace the Invoice.x509chain with whatever that better\ninfrastructure uses to identify entities.\n\n\nWhy not JSON?\n-------------\n\nInvoice, Payment and Receipt messages could all be JSON-encoded. And\nthe Javascript Object Signing and Encryption (JOSE) working group at\nthe IETF has a draft specification for signing JSON data.\n\nBut the spec is non-trivial. Signing JSON data is troublesome because\nJSON can encode the same data in multiple ways (whitespace is\ninsignificant, characters in strings can be represented escaped or\nun-escaped, etc.), and the standards committee identified at least one\nsecurity-related issue that will require special JSON parsers for\nhandling JSON-Web-Signed (JWS) data (duplicate keys must be rejected\nby the parser, which is more strict than the JSON spec requires).\n\nA binary message format has none of those complicating issues. Which\nencoding format to pick is largely a matter of taste, but Protocol\nBuffers is a simple, robust, multi-programming-language,\nwell-documented, easy-to-work-with, extensible format.\n\nWhat about a merchant-pays-fee feature?\n---------------------------------------\n\nIt is desireable to allow a merchant to pay the cost of any Bitcoin\nnetwork transaction processing fees, so if a customer is paying for a\n1 BTC item they pay exactly 1 BTC.\n\nOne way of accomplishing that is to add a 'maxfee' field to the\nInvoice, and have the Bitcoin client construct a transaction that pays\nthe merchant (amount-maxfee).\n\nAnother way of accomplishing that is to change the transaction\nselection code used by Bitcoin miners, so that dependent transactions\nare considered as a group. Then a merchant with several unconfirmed\nzero-fee transaction from customers can create a pay-to-self\ntransaction with a large enough fee to pay for the set of transactions\nto be confirmed.\n\nA third way of accomplishing that is for the Bitcoin client to sign\nPayment.transactions[0] using the SIGHASH_ANYONECANPAY flag, and for\nthe merchant to add an additional, small-BTC-value input to the\ntransaction before broadcasting it. That additional input would go\ndirectly to miners as a fee. *Note: Gavin is not sure if he loves or\nhates this idea.*\n\nChecking for revoked certificates\n---------------------------------\n\nThe Online Certificate Checking Protocol (OCSP) is supposed to be a\nquick and easy way for applications to check for revoked certificates.\n\nIn practice, it doesn't work very well. Certificate Authorities have\nno financial incentive to support a robust infrastructure that can\nhandle millions of OCSP validation requests quickly.\n\nIdeally, Bitcoin clients would use OCSP to check certificate statuses\nevery time they received or re-used an Invoice. But if that results in\nlong pauses or lots of false-positive rejections (because an OCSP\nendpoint is offline or overwhelmed, perhaps) then merchants and\ncustomers might revert to just using \"never fails\" Bitcoin addresses.\n\n\n\nReferences\n==========\n\nPublic-Key Infrastructure (X.509) working group :\nhttp://datatracker.ietf.org/wg/pkix/charter/\n\nRFC 2560, X.509 Internet Public Key Infrastructure Online Certificate\nStatus Protocol - OCSP : http://tools.ietf.org/html/rfc2560\n\nProtocol Buffers : https://developers.google.com/protocol-buffers/\n\nSee Also\n========\n\nJavascript Object Signing and Encryption working group :\nhttp://datatracker.ietf.org/wg/jose/\n\nsipa's payment protocol proposal: https://gist.github.com/1237788\n\nThomasV's \"Signed Aliases\" proposal : http://ecdsa.org/bitcoin_URIs.html"
            },
            {
                "author": "Mike Hearn",
                "date": "2012-11-26T23:02:14",
                "message_text_only": "Obviously this LGTM :)\n\nMinor caveat, IMHO we should support all CAs used by the popular\nbrowsers. This ensures no merchant ever finds that their SSL cert they\nalready own is OK for the web but not for Bitcoin. I don't see a need\nto be stricter here, given all it achieves is signing some data in a\nway linked with a domain name.\n\nX.509 is pretty baroque indeed, for our use cases it'd not be hard to\ndo better. In particular, the inability to delegate properly rather\ndefeats the benefits of chained certificates. For the payment\nprocessor case what you really want to do is take your keys, then\nissue a new cert that is specific to signing Bitcoin transactions and\ngive that to the payment processor secure in the knowledge that they\ncannot MITM your secure connections. Unfortunately X.509 wasn't\ndesigned for the web and thus certificates you buy are marked such\nthat they are not allowed to sign for other certs (due to lack of real\nnamespace support).\n\nThis leads to the idea of redefining the cert chain part of the\nprotocol like this:\n\n  repeated bytes x509_chain = 1;\n\nbecomes\n\n  message Certificate {\n    enum Type {\n      X509 = 1;\n    }\n    required Type type = 1;\n    required bytes data = 2;\n  }\n\n  repeated Certificate cert_chain = 1;\n\nThen if later we want to introduce our own minimal certificate formats\nwhich include features we want, we can add new enum types to do so.\n\nNote that if an old client encounters an invoice with a cert type it\ndoesn't recognize, it will abort parsing of the message entirely. So\nthe request to download the invoice should probably include a protocol\nversion number of some kind so the server knows when it's safe to use\nnew invoice features."
            },
            {
                "author": "Luke-Jr",
                "date": "2012-11-26T23:13:42",
                "message_text_only": "On Monday, November 26, 2012 11:02:14 PM Mike Hearn wrote:\n> Minor caveat, IMHO we should support all CAs used by the popular\n> browsers.\n\nI would prefer using the user-accepted certs at the operating system level..."
            },
            {
                "author": "Mike Hearn",
                "date": "2012-11-26T23:16:03",
                "message_text_only": "They could be included as well of course, but from a seller\nperspective the most important thing is consistency. You have to be\nable to predict what CAs the user has, otherwise your invoice would\nappear in the UI as unverified and is subject to manipulation by\nviruses, etc.\n\nSo using the OS cert store would effectively restrict merchants to the\nintersection of what ships in all the operating systems their users\nuse, which could be unnecessarily restrictive. As far as I know, every\nbrowser has its own cert store for that reason."
            },
            {
                "author": "Luke-Jr",
                "date": "2012-11-26T23:19:34",
                "message_text_only": "On Monday, November 26, 2012 11:16:03 PM Mike Hearn wrote:\n> They could be included as well of course, but from a seller\n> perspective the most important thing is consistency. You have to be\n> able to predict what CAs the user has, otherwise your invoice would\n> appear in the UI as unverified and is subject to manipulation by\n> viruses, etc.\n\nThat's expected behaviour - except it's mainly be manipulated by *users*, not \nviruses (which can just as easily manipulate whatever custom cert store we \nuse). If I don't trust Joe's certs, I don't want Bitcoin overriding that no \nmatter who Joe is or what connections he has.\n\n> So using the OS cert store would effectively restrict merchants to the\n> intersection of what ships in all the operating systems their users\n> use, which could be unnecessarily restrictive. As far as I know, every\n> browser has its own cert store for that reason.\n\nBrowsers with this bug are not relevant IMO."
            },
            {
                "author": "Mike Hearn",
                "date": "2012-11-26T23:27:19",
                "message_text_only": "> That's expected behaviour - except it's mainly be manipulated by *users*, not\n> viruses (which can just as easily manipulate whatever custom cert store we\n> use).\n\nThe point of using signed invoices as virus protection isn't to change\nwhat the user sees on the infected host. The point is the invoice can\nbe relayed to a second device that isn't also compromised which then\nindependently renders a payment confirmation screen (like your mobile\nphone), and it has an identifier in it that's useful to people, like\nbitmit.net instead of an address.\n\nIf it was just showing you a Bitcoin address, that doesn't mean\nanything to you so a virus on your PC could wait until you want to\nmake a large payment somewhere and swap out the address in use. You'd\nnever know it was the wrong address and you'd happily confirm on your\nsecond device.\n\nFor this to work, the seller has to be able to predict what certs you\nhave in all your devices. If it's up to the OS vendors then it's hard\nto know and in practice all that'll happen is somebody will compile a\nlist of CAs that are \"known good\" (ie, present in all deployed mobile\nand desktop OS') and that'll be the minimal cert list. No different to\nif it was hard-coded in the spec.\n\n> If I don't trust Joe's certs, I don't want Bitcoin overriding that no\n> matter who Joe is or what connections he has.\n\nNothing says your wallet software can't provide cert management UI\nlike browsers do.\n\nIn practice I have a feeling that cert management UI is one of the\nleast used parts of a browser. I've used browsers for years and the\nonly time I've ever had to go into those screens was to manage\ninstallation/removal of self signed certs used by various\norganizations. I never manually revoked a root authority. When it was\nnecessary due to breaches (Comodo/DigiNotar) the browser makers\nrevoked them for me."
            },
            {
                "author": "Gregory Maxwell",
                "date": "2012-11-26T23:32:46",
                "message_text_only": "On Mon, Nov 26, 2012 at 6:19 PM, Luke-Jr <luke at dashjr.org> wrote:\n> On Monday, November 26, 2012 11:16:03 PM Mike Hearn wrote:\n>> They could be included as well of course, but from a seller\n>> perspective the most important thing is consistency. You have to be\n>> able to predict what CAs the user has, otherwise your invoice would\n>> appear in the UI as unverified and is subject to manipulation by\n>> viruses, etc.\n>\n> That's expected behaviour - except it's mainly be manipulated by *users*, not\n> viruses (which can just as easily manipulate whatever custom cert store we\n> use). If I don't trust Joe's certs, I don't want Bitcoin overriding that no\n> matter who Joe is or what connections he has.\n>\n>> So using the OS cert store would effectively restrict merchants to the\n>> intersection of what ships in all the operating systems their users\n>> use, which could be unnecessarily restrictive. As far as I know, every\n>> browser has its own cert store for that reason.\n>\n> Browsers with this bug are not relevant IMO.\n\n\nThis is messy.   It's important to people to know that their cert will\nbe accepted by ~everyone because non-acceptance looks like malice.  If\nthe cert system is actually to provide value then false positives need\nto be low enough that people can start calling in law enforcement,\ncomputer investigators, etc.. every time a cert failure happens.\nOtherwise there is little incentive for an attacker to not _try_.\n\nObviously the state of the world with browsers is not that good... but\nin our own UAs we can do better and get closer to that.\n\nWould you find it acceptable if something supported a static whitelist\nplus a OS provided list minus a user configured blacklist and the\nability for sophisticated users to disable the whitelist?\n\nThis way people could trust that if their cert is signed via one on\nthe whitelist they'll work for ALL normal users.. and the UI can have\nvery strong behavior that protects people (e.g. no 'click here to\ndisable all security because tldr' button)... but advanced users who\ncan deal with sorting out failure can still have complete control\nincluding OS based control."
            },
            {
                "author": "Luke-Jr",
                "date": "2012-11-26T23:44:00",
                "message_text_only": "On Monday, November 26, 2012 11:32:46 PM Gregory Maxwell wrote:\n> Obviously the state of the world with browsers is not that good... but\n> in our own UAs we can do better and get closer to that.\n\nThis effectively centralizes Bitcoin (at least in the eyes of many) and even \nif each competing client had their own list, you'd be back to the original \n\"problem\" of not being sure your CA is on all lists.\n\n> Would you find it acceptable if something supported a static whitelist\n> plus a OS provided list minus a user configured blacklist and the\n> ability for sophisticated users to disable the whitelist?\n\nHow is this whitelist any different from the list of CAs included by default \nwith every OS?"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2012-11-27T00:16:07",
                "message_text_only": "On Mon, Nov 26, 2012 at 6:44 PM, Luke-Jr <luke at dashjr.org> wrote:\n> On Monday, November 26, 2012 11:32:46 PM Gregory Maxwell wrote:\n>> Obviously the state of the world with browsers is not that good... but\n>> in our own UAs we can do better and get closer to that.\n>\n> This effectively centralizes Bitcoin (at least in the eyes of many) and even\n> if each competing client had their own list, you'd be back to the original\n> \"problem\" of not being sure your CA is on all lists.\n\nThats the CA model generally. It _is_ a distributed-centralized model\nin practice.\n\n>> Would you find it acceptable if something supported a static whitelist\n>> plus a OS provided list minus a user configured blacklist and the\n>> ability for sophisticated users to disable the whitelist?\n>\n> How is this whitelist any different from the list of CAs included by default\n> with every OS?\n\nBecause the list is not identical (and of course, couldn't be without\ncentralizing control of all OSes :P ) meaning that the software has to\nbe setup in a way where false-positive authentication failures are a\ncommon thing (terrible for user security) or merchants have to waste a\nbunch of time, probably unsuccessfully, figuring out what certs work\nsufficiently 'everwhere' and likely end up handing over extortion\nlevel fees to the most well established CAs that happen to be included\non the oldest and most obscure things.\n\nTaking\u2014 say\u2014 the intersection of Chrome, Webkit, and Firefox's CA list\nas of the first of the year every year and putting the result on a\nwhitelist would be a possible nothing-up-my-sleeve approach which is\nnot as limited as having some users subject to the WinXP cert list,\nwhich IIRC is very limited (but not in a way that improves security!).\n\nJeff wrote:\n> Self-signed certs are quite common, because it is easier, while being\n> more secure than http://\n\nUhh.  Really?   Well, I agree with you that they should be (I\nunsuccessfully lobbied browser vendors to make self-signed https on\nhttp URLs JustWork and simply hide all user visible evidence of\nsecurity), but the really nasty warnings on those sites undermines the\nsecurity of the sites _and_ of other HTTPS sites because it conditions\nusers to click ignore-ignore-ignore. I don't think they are all that\ncommon.\n\nOne thing which I think will be hard for us in this discussion is\nbeing sensitive to the (quite justified!) concerns that the current CA\nsystem is absolute rubbish, both terrible for security, usability, and\nan unreasonable barrier to entry relative to the provided security\u2014\nwithout allowing the discussion to be usurped by everyone's pet\nreplacement, which there are a great many of with varying feasibility\nand security.\n\nPerhaps we should agree to talk about everything _except_ that first?"
            },
            {
                "author": "Mike Hearn",
                "date": "2012-11-27T00:26:16",
                "message_text_only": "> Perhaps we should agree to talk about everything _except_ that first?\n\nYeah, alternatives to X.509 chains don't interest me right now except\nin the sense that they should be cleanly implementable with future\nextensions.\n\nSo if you care about DANE or DNSSEC or custom PKI infrastructures or\nwhatever, rather than proposing them as replacements here (DOA), just\nfigure out how you would extend the protocol in Gavins mail in a\nfuture extension. If you can't see a clean way to do it then let's\ndiscuss that. If you can think of a way to do it then let's table it.\nBetter replacements can come in later BIPs."
            },
            {
                "author": "Rick Wesson",
                "date": "2012-11-27T00:45:09",
                "message_text_only": "On Mon, Nov 26, 2012 at 4:26 PM, Mike Hearn <mike at plan99.net> wrote:\n>> Perhaps we should agree to talk about everything _except_ that first?\n>\n> Yeah, alternatives to X.509 chains don't interest me right now except\n> in the sense that they should be cleanly implementable with future\n> extensions.\n>\n> So if you care about DANE or DNSSEC or custom PKI infrastructures or\n> whatever, rather than proposing them as replacements here (DOA), just\n> figure out how you would extend the protocol in Gavins mail in a\n> future extension. If you can't see a clean way to do it then let's\n> discuss that. If you can think of a way to do it then let's table it.\n> Better replacements can come in later BIPs.\n\nThe only part that has an x509 cert associated is in the invoice message.\n\nmessage Invoice {\n//    repeated bytes x509chain = 1;\n    optional string domainName =1;\n    repeated Output outputs = 2;\n    required uint64 time = 3;\n    optional uint64 expires = 4;\n    optional bool single_use = 5 [default = true];\n    optional string memo = 6;\n    optional string receiptURI = 7;\n    optional bytes merchant_data = 8;\n}\n\nRemoving that and adding a opaque string called domain name, or\nidentityName would be sufficient to move the conversation forward\nwithout the x.509 baggage.\n\n-rick"
            },
            {
                "author": "Gavin",
                "date": "2012-11-27T01:09:25",
                "message_text_only": "Supporting DNSSEC/DANE in the future when they are widely deployed is a great idea.\n\nNote that the x509chain field is 'repeated', and any repeated field may have zero entries. So I would suggest supporting other PKI systems in the future by adding optional new fields (for maximum compatibility or security merchants might want to include both a x509chain AND \n\n--\nGavin Andresen"
            },
            {
                "author": "Mike Hearn",
                "date": "2012-11-27T08:44:41",
                "message_text_only": "Luke-Jr - common subset of what operating systems ship is fine for me\nas long as people do due diligence around mobile OS' here. It seems\neasier to me to just grab a list from a popular browser, on the\ngrounds that SSL is mostly used by them so nobody is going to buy an\nSSL cert rejected by IE/Firefox/Chrome/etc. But intersecting OS lists\nis effectively the same.\n\nFor my own clients I'd just ship my own copy of the canonical CA certs\nregardless, because integrating with each operating systems\nproprietary crypto APIs is a lot of work vs just loading a pem file\ninto OpenSSL. If there are a lot of people who want to use the OS cert\nmanagement UIs then I guess that can be a point wallet clients compete\non.\n\n> Removing that and adding a opaque string called domain name, or\n> identityName would be sufficient to move the conversation forward\n> without the x.509 baggage.\n\nBut it would result in implementations that do not meet the requirements.\n\nYes, X.509 has problems. It's in the proposal because we can get the\neffect we want (verifiable domain names in the UI) in about 50 lines\nof code, today, with the id-verified keys people actually have already\nbought.\n\nAs Gavin says, we can add optional fields later to extend the protocol\nin a backwards compatible way."
            },
            {
                "author": "Luke-Jr",
                "date": "2012-11-27T00:44:03",
                "message_text_only": "On Tuesday, November 27, 2012 12:16:07 AM Gregory Maxwell wrote:\n> On Mon, Nov 26, 2012 at 6:44 PM, Luke-Jr <luke at dashjr.org> wrote:\n> > On Monday, November 26, 2012 11:32:46 PM Gregory Maxwell wrote:\n> >> Would you find it acceptable if something supported a static whitelist\n> >> plus a OS provided list minus a user configured blacklist and the\n> >> ability for sophisticated users to disable the whitelist?\n> > \n> > How is this whitelist any different from the list of CAs included by\n> > default with every OS?\n> \n> Because the list is not identical (and of course, couldn't be without\n> centralizing control of all OSes :P ) meaning that the software has to\n> be setup in a way where false-positive authentication failures are a\n> common thing (terrible for user security) or merchants have to waste a\n> bunch of time, probably unsuccessfully, figuring out what certs work\n> sufficiently 'everwhere' and likely end up handing over extortion\n> level fees to the most well established CAs that happen to be included\n> on the oldest and most obscure things.\n\nThere is a common subset of CAs which are included in all OSs.\nThat's the \"whitelist equivalent\". We or someone else could even setup a list \nof these common CAs for merchants if that is needed.\n\nThe fees CAs charge for certs is a flaw in the CA model in general, I don't \nsee that it's important for us to solve it."
            },
            {
                "author": "Rick Wesson",
                "date": "2012-11-26T23:38:31",
                "message_text_only": "X.509 has some problems we have recent experience with. I'd prefer to\nleverage something like DANE which looks to help with assertions\naround certificates and creates an option around the CAs and x.509\nroots.\n\n-rick\n\n\nOn Mon, Nov 26, 2012 at 2:37 PM, Gavin Andresen <gavinandresen at gmail.com> wrote:\n> This is the next big \"lets all agree to do things the same way\" thing\n> I think we should tackle. I'm particularly looking for feedback from\n> other bitcoin client developers, even if it is just a quick \"looks\n> reasonable, if everybody else is going to do it then I will\n> (eventually) too...\"\n>\n> Thanks to Pieter Wuille and Mike Hearn for lots of feedback and\n> suggestions and brainstorming.\n>\n> This document is online at https://gist.github.com/4120476\n>\n> If you respond to this message, please be considerate of people who\n> subscribe to the digest version of this mailing list and trim your\n> response.\n>\n>\n> Invoices, Payments and Receipts for Bitcoin Transactions\n> ========================================================\n>\n> This document proposes protocol buffer-based formats for signed,\n> authenticated \"invoices\" and \"receipts\" -- requests for payment, and\n> proof-of-payment.\n>\n> Separate documents propose an extension to the Bitcoin URI syntax and\n> new MIME types to support them.\n>\n> Motivation\n> ==========\n>\n> The idea of a \"payment protocol\" to improve on Bitcoin addresses has\n> been around for over a year. Users have been asking for some features\n> in this proposal (like the ability to provide a refund address so\n> overpayments or refunds can be returned to customers without the need\n> to ask them for their address) for two or three years, and have\n> started to work around shortcomings in the Bitcoin payment process\n> with creative (but inefficient) uses of transactions.\n>\n> The key features of this proposal are:\n>\n> + Requests for payment (Invoices) are tied to authenticated identities\n> using the only widely-deployed identity authentication system we have\n> right now (X.509 certificates signed by root certificate authorities)\n> + Invoices include a user-friendly description of what the payment is for\n> + Payments include where refunds should be sent\n> + At the end of the payment process, the customer holds a\n> cryptographically signed Receipt that can be used as proof-of-payment\n> if there is any dispute with the merchant.\n>\n>\n> Specification\n> =============\n>\n> Invoice/SignedInvoice\n> ---------------------\n>\n> An Invoice is a request for payment from a merchant to a customer:\n>\n> ::\n>\n>     message Output {\n>         optional uint64 amount = 1;\n>         required bytes script = 2;\n>     }\n>\n> amount: Number of satoshis (0.00000001 BTC) to be paid. If not given\n> or zero, then the customer will be asked how much to pay.\n>\n> script: a \"TxOut\" script to which the customer should direct payment.\n> This will normally be one of the standard Bitcoin transaction script\n> (e.g. pubkey OP_CHECKSIG).\n>\n> ::\n>\n>     message Invoice {\n>         repeated bytes x509chain = 1;\n>         repeated Output outputs = 2;\n>         required uint64 time = 3;\n>         optional uint64 expires = 4;\n>         optional bool single_use = 5 [default = true];\n>         optional string memo = 6;\n>         optional string receiptURI = 7;\n>         optional bytes merchant_data = 8;\n>     }\n>\n> outputs: one or more outputs where Bitcoins are to be sent.\n>\n> x509chain: one or more DER-encoded X.509 certificates that identifies\n> the merchant. See the \"Certificates\" section below for details.\n>\n> time: Unix timestamp (seconds since 1-Jan-1970) when the Invoice was created.\n>\n> expires: Unix timestamp after which the Invoice should be considered\n> invalid. If not given, the Invoice may be re-used until the earliest\n> certificate expiration date in the X509chain.\n>\n> single_use: If true, this Invoice should be used for only one payment.\n> If false, it may be added to the user's address book and used\n> repeatedly until it expires (e.g. for donations or a recurring\n> payment).\n>\n> memo: UTF-8 encoded, plain-text (no formatting) note that should be\n> displayed to the customer, explaining what this Invoice is for.\n>\n> receiptURI: Secure (https) URI where a Payment message (see below) may\n> be sent to obtain a SignedReceipt as proof-of-payment.\n>\n> merchant_data : Arbitrary data ignored by the client that may be used\n> by the merchant to identify the Invoice.\n>\n> ::\n>\n>     message SignedInvoice {\n>         required Invoice invoice = 1;\n>         required bytes signature = 2;\n>     }\n>\n> A SignedInvoice is an Invoice signed using the private key\n> corresponding to the public key in the first certificate in the\n> x509chain and the HMAC SHA-256 algorithm.\n>\n> When a Bitcoin client receives a SignedInvoice, it must authorize\n> payment by doing the following:\n>\n> 1. Validate the x509chain certificate chain up to it's list of root\n> certificate authorities\n> 2. Validate that the time on the customer's system is before Invoice.expires\n> 3. Display the \"Common Name\" (CN) string from the first x509chain\n> certificate and ask the customer if they would like to submit payment\n>\n> Payment\n> -------\n>\n> ::\n>\n>     message Payment {\n>         required Invoice invoice = 1;\n>         repeated bytes transactions = 2;\n>         repeated Output refund_to = 3;\n>         optional string memo = 4;\n>     }\n>\n> invoice : the invoice received from the merchant. A merchant must\n> validate the Invoice and may reject the Payment if the Invoice was\n> altered by the customer.\n>\n> transactions : One or more valid, signed Bitcoin transactions that\n> fully pay the Invoice\n>\n> refund_to : One or more outputs where the merchant may return funds,\n> if necessary.\n>\n> memo : UTF-8 encoded, plain-text note from the customer to the merchant.\n>\n> If the customer authorizes payment, then the Bitcoin client:\n>\n> 1. Creates and signs a transaction with one output sending the Invoice.script\n> 2. If there is no Invoice.receiptURI, then the transaction is\n> broadcast on the Bitcoin p2p network.\n> 3. Else POST a Payment message to Invoice.receiptURI and expect a\n> SignedReceipt in response.\n>\n> Invoice.receiptURI must be secure against man-in-the-middle attacks\n> that might alter Payment.refund_to.\n>\n> *Note: an alternative would be a SignedPayment message that ties the\n> signatures in Payment.transactions to a signature for the entire\n> Payment message. Spending multisig inputs that may be controlled by\n> more than one person or spending arbitrary non-standard transactions\n> makes that non-trivial.*\n>\n> Receipt/SignedReceipt\n> ---------------------\n>\n> ::\n>\n>     message Receipt {\n>         required Payment payment = 1;\n>         required bool accepted = 2;\n>         optional string memo = 3;\n>     }\n>\n> accepted : true if the Payment is accepted and will be broadcast on\n> the Bitcoin p2p network.\n>\n> memo : UTF-8 encoded note that should be displayed to the customer\n> indicating that the transaction is complete.\n>\n> ::\n>\n>     message SignedReceipt {\n>         required Receipt receipt = 1;\n>         required bytes signature = 3;\n>     }\n>\n> A SignedReceipt is a Receipt signed using the private key\n> corresponding to the public key in the first certificate in the\n> Receipt->Payment->Invoice.x509chain and the HMAC SHA-256 algorithm.\n>\n> Upon receiving a SignedReceipt, a Bitcoin client should validate the\n> signature and, if valid, display the Receipt.memo and store the\n> SignedReceipt as proof-of-payment.\n>\n> If a SignedReceipt is not received for any reason (timeout, error) and\n> Payment.transactions has not been broadcast by the merchant on the\n> Bitcoin p2p network, then the Bitcoin client should assume that the\n> payment failed, inform the customer that the payment failed, and\n> return coins involved in the transaction to the customer's wallet.\n>\n>\n> Certificates\n> ============\n>\n> The Invoice.x509chain (X.509 Certificate Chain) field contains the\n> X.509 public key certificate or certificate chain [RFC5280]\n> corresponding to the key used to digitally sign the Invoice and\n> Receipt. The certificate or certificate chain is represented as an\n> array of DER [ITU.X690.1994] PKIX certificate value. The certificate\n> containing the public key of the entity that digitally signed the\n> Invoice MUST be the first certificate. This MAY be followed by\n> additional certificates, with each subsequent certificate being the\n> one used to certify the previous one. The recipient MUST verify the\n> certificate chain according to [RFC5280] and reject the payment\n> request if any validation failure occurs.\n>\n> *What should we say about root certificates and certificate management\n> in general? Any requirements, or leave it up to each Bitcoin client to\n> determine which root CA's are trustworthy, as happens with web\n> browsers? Gavin suggests trusting only (say) ten of the Extended\n> Validation authorities:\n> http://en.wikipedia.org/wiki/Extended_Validation_Certificate#Extended_Validation_certificate_identification\n> *\n>\n> *X.509 is widely criticised for doing too much. However, it is the\n> Public Key Infrastructure (PKI) system we're stuck with. Do web\n> browsers / certificate authorities support the full X.509 spec, or\n> only a subset? Should Bitcoin clients only support some well-defined\n> subset of X.509 ? More research needed here... *\n>\n> Use Cases\n> =========\n>\n> Merchant Payment Service\n> ------------------------\n>\n> A merchant payment service (like Paysius or bit-pay.com) would use\n> Invoices and Receipts as follows:\n>\n> 1. Merchant pays for a certificate from a certificate authority, and\n> then gives the payment service the certificate and their private key.\n> This could be the same certificate and private key as is used for the\n> merchant's web site, but best security practice would be to purchase a\n> separate certificate for authenticating Invoices. Very successful\n> merchant payment services might act as intermediate certificate\n> authorities, issuing certificates for their merchants.\n> 2. Customer goes through the checkout process on either the merchant's\n> or payment service's web site.\n> 3. At the end of the checkout process, a SignedInvoice is generated\n> and sent to the customer's Bitcoin client.\n> 4. Customer's Bitcoin client displays the Invoice, showing that the\n> payment is for the merchant.\n> 5. On customer approval, a Payment is sent to the payment service's\n> paymentURI. The merchant is notified of the payment, and the customer\n> receives a SignedReceipt as proof-of-payment.\n>\n> SatoshiDice\n> -----------\n>\n> SatoshiDice (www.satoshidice.com) is an extremely popular game that\n> uses tiny transactions for some customer/service communications. In\n> particular, customers can add an extra output to their transactions to\n> indicate where winnings should be sent. And SatoshiDice creates tiny\n> transactions to let their customers know that a bet was received, but\n> lost.\n>\n> Assuming Bitcoin clients upgrade to support this proposal, a bet on\n> SatoshiDice would proceed as follows:\n>\n> 1. Customer clicks on a link on SatoshiDice.com and their Bitcoin\n> client receives a SignedInvoice.\n> 2. Customer authorizes payment, and their Bitcoin client creates a\n> Payment message and submits it directly to\n> https://satoshidice.com/something\n> 3. The SatoshiDice web server checks to make sure the transaction is\n> valid, broadcasts it, and determines whether the customer wins or\n> loses. It returns a SignedReceipt with either a \"You win\" or \"You\n> lost\" memo.\n> 4. If the customer won, it broadcasts a transaction to pay them using\n> Payment.refund_to\n> 5. Customer's Bitcoin client displays the win/lose memo, and if they\n> won the winnings appear in their wallet when received over the p2p\n> network.\n>\n> Multiperson Wallet\n> ------------------\n>\n> This use case starts with a multi-signature Bitcoin address or wallet,\n> with keys held by two different people (Alice and Bob). Payments from\n> that address/wallet must be authorized by both Alice and Bob, and both\n> are running multi-signature-capable Bitcoin clients.\n>\n> Alice begins the payment process by getting a SignedInvoice from a\n> merchant that needs to be paid. She authorizes payment and her Bitcoin\n> client creates a Payment message with a partially-signed transaction,\n> which is then sent to Bob any way that is convenient (email\n> attachment, smoke signals...).\n>\n> Bob's Bitcoin client validates the SignedInvoice and asks Bob to\n> authorize the transaction. He says OK, his Bitcoin client completes\n> the transaction by providing his signature, submits the payment to the\n> merchant, and then sends a message to Alice with the SignedReceipt he\n> received from the merchant, completing the payment process.\n>\n>\n> Design Notes\n> ============\n>\n> Why X.509 Certificates?\n> -----------------------\n>\n> This proposal uses X.509 certificates as the identity system for\n> merchants because most of them will have already purchased a\n> certificate to secure their website and will be familiar with the\n> process of proving their identity to a certificate issuing authority.\n>\n> Implementing a better global PKI is outside the scope of this\n> proposal. If a better PKI is adopted, the only change to this proposal\n> would be to replace the Invoice.x509chain with whatever that better\n> infrastructure uses to identify entities.\n>\n>\n> Why not JSON?\n> -------------\n>\n> Invoice, Payment and Receipt messages could all be JSON-encoded. And\n> the Javascript Object Signing and Encryption (JOSE) working group at\n> the IETF has a draft specification for signing JSON data.\n>\n> But the spec is non-trivial. Signing JSON data is troublesome because\n> JSON can encode the same data in multiple ways (whitespace is\n> insignificant, characters in strings can be represented escaped or\n> un-escaped, etc.), and the standards committee identified at least one\n> security-related issue that will require special JSON parsers for\n> handling JSON-Web-Signed (JWS) data (duplicate keys must be rejected\n> by the parser, which is more strict than the JSON spec requires).\n>\n> A binary message format has none of those complicating issues. Which\n> encoding format to pick is largely a matter of taste, but Protocol\n> Buffers is a simple, robust, multi-programming-language,\n> well-documented, easy-to-work-with, extensible format.\n>\n> What about a merchant-pays-fee feature?\n> ---------------------------------------\n>\n> It is desireable to allow a merchant to pay the cost of any Bitcoin\n> network transaction processing fees, so if a customer is paying for a\n> 1 BTC item they pay exactly 1 BTC.\n>\n> One way of accomplishing that is to add a 'maxfee' field to the\n> Invoice, and have the Bitcoin client construct a transaction that pays\n> the merchant (amount-maxfee).\n>\n> Another way of accomplishing that is to change the transaction\n> selection code used by Bitcoin miners, so that dependent transactions\n> are considered as a group. Then a merchant with several unconfirmed\n> zero-fee transaction from customers can create a pay-to-self\n> transaction with a large enough fee to pay for the set of transactions\n> to be confirmed.\n>\n> A third way of accomplishing that is for the Bitcoin client to sign\n> Payment.transactions[0] using the SIGHASH_ANYONECANPAY flag, and for\n> the merchant to add an additional, small-BTC-value input to the\n> transaction before broadcasting it. That additional input would go\n> directly to miners as a fee. *Note: Gavin is not sure if he loves or\n> hates this idea.*\n>\n> Checking for revoked certificates\n> ---------------------------------\n>\n> The Online Certificate Checking Protocol (OCSP) is supposed to be a\n> quick and easy way for applications to check for revoked certificates.\n>\n> In practice, it doesn't work very well. Certificate Authorities have\n> no financial incentive to support a robust infrastructure that can\n> handle millions of OCSP validation requests quickly.\n>\n> Ideally, Bitcoin clients would use OCSP to check certificate statuses\n> every time they received or re-used an Invoice. But if that results in\n> long pauses or lots of false-positive rejections (because an OCSP\n> endpoint is offline or overwhelmed, perhaps) then merchants and\n> customers might revert to just using \"never fails\" Bitcoin addresses.\n>\n>\n>\n> References\n> ==========\n>\n> Public-Key Infrastructure (X.509) working group :\n> http://datatracker.ietf.org/wg/pkix/charter/\n>\n> RFC 2560, X.509 Internet Public Key Infrastructure Online Certificate\n> Status Protocol - OCSP : http://tools.ietf.org/html/rfc2560\n>\n> Protocol Buffers : https://developers.google.com/protocol-buffers/\n>\n> See Also\n> ========\n>\n> Javascript Object Signing and Encryption working group :\n> http://datatracker.ietf.org/wg/jose/\n>\n> sipa's payment protocol proposal: https://gist.github.com/1237788\n>\n> ThomasV's \"Signed Aliases\" proposal : http://ecdsa.org/bitcoin_URIs.html\n>\n> ------------------------------------------------------------------------------\n> Monitor your physical, virtual and cloud infrastructure from a single\n> web console. Get in-depth insight into apps, servers, databases, vmware,\n> SAP, cloud infrastructure, etc. Download 30-day Free Trial.\n> Pricing starts from $795 for 25 servers or applications!\n> http://p.sf.net/sfu/zoho_dev2dev_nov\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Jeff Garzik",
                "date": "2012-11-26T23:52:55",
                "message_text_only": "On Mon, Nov 26, 2012 at 5:37 PM, Gavin Andresen <gavinandresen at gmail.com> wrote:\n> This is the next big \"lets all agree to do things the same way\" thing\n> I think we should tackle. I'm particularly looking for feedback from\n> other bitcoin client developers, even if it is just a quick \"looks\n> reasonable, if everybody else is going to do it then I will\n> (eventually) too...\"\n\nComments:\n\n1) Payment message should include ability to specify the transaction\n_or_ a transaction id sent via normal means over the network.\n\n2) I think a significant bitcoin userbase will want to operate outside\nthe full root-CA chain.  Just look at https:// websites now.\nSelf-signed certs are quite common, because it is easier, while being\nmore secure than http://\n\nSo some provision for self-signed certs, a use case in wide use\nelsewhere, or equivalent thereof, seems reasonable.\n\n-- \nJeff Garzik\nexMULTI, Inc.\njgarzik at exmulti.com"
            },
            {
                "author": "Rick Wesson",
                "date": "2012-11-27T00:02:42",
                "message_text_only": "I hope you all take a moment to see what DANE leverages with DNSSEC\nand SelfSigned x.509 certs. DANE provides the capability for any\nentity to associate a self signed certificate with a domain name. This\ncapability removes the critical path of whitelists and/or Root CA\ncerts.\n\nAnother nifty thing is that it can associate a cert to a domain and a\npayment address, if one were to put said address in the DNS :)\n\nNow I am sure the majority of the bitcoin user-base desires anonymity,\nbut as a merchant I would like to be knowable and wouldn't mind it if\nmy identity and those of my transactions were \"known\" and associated\nboth with my domains and x.509 cert. In most commercial transactions\n(which include many of those that leverage invoices) identity is\nimportant, at least for the merchant.\n\n-rick\n\n\nOn Mon, Nov 26, 2012 at 3:52 PM, Jeff Garzik <jgarzik at exmulti.com> wrote:\n> On Mon, Nov 26, 2012 at 5:37 PM, Gavin Andresen <gavinandresen at gmail.com> wrote:\n>> This is the next big \"lets all agree to do things the same way\" thing\n>> I think we should tackle. I'm particularly looking for feedback from\n>> other bitcoin client developers, even if it is just a quick \"looks\n>> reasonable, if everybody else is going to do it then I will\n>> (eventually) too...\"\n>\n> Comments:\n>\n> 1) Payment message should include ability to specify the transaction\n> _or_ a transaction id sent via normal means over the network.\n>\n> 2) I think a significant bitcoin userbase will want to operate outside\n> the full root-CA chain.  Just look at https:// websites now.\n> Self-signed certs are quite common, because it is easier, while being\n> more secure than http://\n>\n> So some provision for self-signed certs, a use case in wide use\n> elsewhere, or equivalent thereof, seems reasonable.\n>\n> --\n> Jeff Garzik\n> exMULTI, Inc.\n> jgarzik at exmulti.com\n>\n> ------------------------------------------------------------------------------\n> Monitor your physical, virtual and cloud infrastructure from a single\n> web console. Get in-depth insight into apps, servers, databases, vmware,\n> SAP, cloud infrastructure, etc. Download 30-day Free Trial.\n> Pricing starts from $795 for 25 servers or applications!\n> http://p.sf.net/sfu/zoho_dev2dev_nov\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Luke-Jr",
                "date": "2012-11-27T00:31:16",
                "message_text_only": "On Tuesday, November 27, 2012 12:02:42 AM Rick Wesson wrote:\n> Another nifty thing is that it can associate a cert to a domain and a\n> payment address, if one were to put said address in the DNS :)\n> \n> Now I am sure the majority of the bitcoin user-base desires anonymity,\n> but as a merchant I would like to be knowable and wouldn't mind it if\n> my identity and those of my transactions were \"known\" and associated\n> both with my domains and x.509 cert. In most commercial transactions\n> (which include many of those that leverage invoices) identity is\n> important, at least for the merchant.\n\nAnonymity isn't a feature we claim to have, nor a goal of the project for the \nmost part. Using a single Bitcoin address has many problems besides non-\nanonymity: your customers are denied basic privacy and there is no good way to \nguarantee the user who says he paid you really did (since transaction ids are \npublic record, anyone can claim they sent it).\n\nIn short, it is for the most part considered a rule to always use a unique \naddress per transaction or at least per customer.\n\nLuke"
            },
            {
                "author": "Rick Wesson",
                "date": "2012-11-27T00:37:29",
                "message_text_only": "On Mon, Nov 26, 2012 at 4:31 PM, Luke-Jr <luke at dashjr.org> wrote:\n> On Tuesday, November 27, 2012 12:02:42 AM Rick Wesson wrote:\n>> Another nifty thing is that it can associate a cert to a domain and a\n>> payment address, if one were to put said address in the DNS :)\n>>\n>> Now I am sure the majority of the bitcoin user-base desires anonymity,\n>> but as a merchant I would like to be knowable and wouldn't mind it if\n>> my identity and those of my transactions were \"known\" and associated\n>> both with my domains and x.509 cert. In most commercial transactions\n>> (which include many of those that leverage invoices) identity is\n>> important, at least for the merchant.\n>\n> Anonymity isn't a feature we claim to have, nor a goal of the project for the\n> most part. Using a single Bitcoin address has many problems besides non-\n> anonymity: your customers are denied basic privacy and there is no good way to\n> guarantee the user who says he paid you really did (since transaction ids are\n> public record, anyone can claim they sent it).\n>\n> In short, it is for the most part considered a rule to always use a unique\n> address per transaction or at least per customer.\n\nputting payment addresses in the DNS does not require that only a\nsingle address be used. This is an assumption and a possible use case,\nbut there is no requirement that payment addresses must be 1:1\nassociated.\n\n-rick"
            },
            {
                "author": "Walter Stanish",
                "date": "2012-11-27T02:16:01",
                "message_text_only": "> This is the next big \"lets all agree to do things the same way\" thing\n> I think we should tackle. I'm particularly looking for feedback from\n> other bitcoin client developers, even if it is just a quick \"looks\n> reasonable, if everybody else is going to do it then I will\n> (eventually) too...\"\n\nI agree this is a very pertinent subject, and with a bit of looking\naround it is clear that there is a requirement here for emerging\nfinancial ecosystems of many types, certainly not just for the Bitcoin\ncommunity, which until now seems to have been getting along just about\nOK despite the current levels of complexity.\n\nThat said, I have a number of serious concerns with the proposal.\n\n1. Undue Broadening of Scope: From an architectural perspective, if\none accepts the unix mantra of \"do one thing and do it well\" as\nreasonable and time-proven doctrine, given that Bitcoin is already\ntrying to be both a commodity and a distributed consensus-based\nsettlement system, does it really make sense to attempt to tack-on\nbusiness-level functions?\n\n2. X.509: I have read (somewhere or other, recently) that it is\ngenerally considered bad form to mandate specific cryptographic\nsystems in new protocols where open support is possible. Given the\nrecent issues with X.509, the security nightmare that already exists\nwith the volume of (sometimes cracked, sometimes\ngovernment-compromised?) issuers, and the complexity of the scheme, it\nseems a little strange to singularly mandate X.509, despite its\nwidespread use at present.  There are also a swathe of potential\nissues around DNS interdependence, information leakage within\ncertificates themselves and/or their DNS-interpretation by clients,\netc. I would consider suggesting open support with initial support for\nGPG, as it is apparently preferred as a simple and further\ndecentralized solution by the majority of the open source and\ncryptographic software development community.\n\n3. Failure to Review Existing Work: I would urge anyone to be wary of\nadopting any proposal that does not inform itself through reference to\nexisting protocols in the same area.  In this area there are a few\nprotocols in current use (chiefly in Europe) such as those listed at\nhttp://en.wikipedia.org/wiki/Invoice#Electronic_invoices as well as\nvarious hosted platforms such as http://xero.co.nz/ (chiefly\nAustralia/New Zealand). Often, existing work shows its age with\nafter-the-fact alterations that sit poorly with initial assumptions:\nexactly the kind of situation one can walk in to developing against a\nproposal before adequately researching the area.\n\n4. Complexity of Metadata: Physical and digital invoicing for\nbusinesses operating at scale often requires delivery terms, product\nclassification codes, locale-specific taxation (often at multiple\nlevels), various fees and discounts (sometimes fulfillment-speed\nlinked with multiple tiers/thresholds), and other features that I am\nskeptical are ever going to be made fully available within a business\nprotocol tacked on to a hybrid digital currency/settlement system\n(like Bitcoin) as a secondary concern.\n\n5. Non-BTC Currencies/Currency-like Commodities: No approach to\nnon-BTC currencies appears to have been made, which makes the\n\"invoice\" of limited utility for almost all businesses, save those\nwilling to accept all of the 'capital risk' (exchange rate fluctuation\nrisk) inherent in a BTC-based fulfilment process with a potential term\nlong enough to justify an invoicing process. (Does this narrow scope\nactually cover any existing business?)\n\n6. DNS: As already mentioned with regards to X.509: a huge red flag as\nan area of potential vulnerability, or at least information leakage.\n\nI must now admit that in raising the above I am definitely biased.  My\nemployer (Payward, Inc.) and other organizations (OpenCoin, Inc.,\netc.) have been working with the Internet Engineering Task Force\n(IETF) on tabling some open proposals within this area under the\nauspices of the Internet Financial Exchange Project\n(http://ifex-project.org/).  Our hope is to facilitate the requisite\nstandardisation within internet-connected systems to deal with what is\nperhaps fairly characterised as a relatively heterogeneous outlook on\nthe rise of cryptographic (and other alternate) currencies and\ncommodities, and emerging settlement infrastructures.\n\nWhilst the current Bitcoin proposal is admirable for correctly raising\nthe area as one of immediate concern, I hope that the above points out\nsome of the perhaps as-yet unconsidered complexities and draws in to\nquestion whether Bitcoin is in fact the appropriate place to implement\na solution, given the hassles that will entail.  After all, wouldn't\nBitcoin developer time would be better spent improving the core of\nbitcoin (ie. distributed settlement system and commodity) rather than\nadding new features?\n\nI would invite parties within the Bitcoin community with an interest\nin non directly settlement-linked financial transaction negotiation\nand reporting features to consider contributing to the existing,\nre-usable efforts at the IFEX Project, rather than supporting the\nextension of one currency/commodity and settlement infrastructure (ie.\nBitcoin) which IMHO is likely to detract from developer time, increase\ncomplexity, and perhaps result in a less polished and re-applicable\nsolution overall.\n\nOur proposals:\n - X-ISO4217-A3 (X-ISO4217-A3). A published proposal that provides a\nmechanism for the open identification of currencies or currency-like\ncommodities on the internet.  (Bitcoin is registered as XBTC).\nhttp://www.ifex-project.org/our-proposals/x-iso4217-a3\n - Internet IBAN (IIBAN). A published proposal that provides a\nmechanism for the open identification of financial endpoints on the\ninternet. (IBAN compatible, checksum-included, name-squatting problem\navoiding. The registry of entities is IANA-managed, encourages GPG\nuse, and avoids the X.509 requirement.)\nhttp://www.ifex-project.org/our-proposals/iiban\n - Internet MIC (IMIC). A published proposal that provides a mechanism\nfor the open identification of financial markets on the internet.\n(Such as most Bitcoin exchanges)\nhttp://www.ifex-project.org/our-proposals/imic\n - Internet Financial EXchange (IFEX). A proposal under development\nthat facilitates the negotiation of financial transactions between\ninternet-based financial endpoints. (The area we would love your\ninput) http://www.ifex-project.org/our-proposals/ifex\n\nSincerely and with the utmost respect for the Bitcoin project's excellent work,\nWalter Stanish"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2012-11-27T02:47:52",
                "message_text_only": "On Mon, Nov 26, 2012 at 9:16 PM, Walter Stanish <walter at stani.sh> wrote:\n> X-ISO4217-A3\n\nI see that draft-stanish-x-iso4217-a3 is not standards track, is there\na reason for this?\n\nIt also doesn't appear to address ~any of the the targeted items here.\nIs there another draft I should be looking for which has more overlap\nwith the discussion here?"
            },
            {
                "author": "Walter Stanish",
                "date": "2012-11-27T03:16:26",
                "message_text_only": ">> X-ISO4217-A3\n>\n> I see that draft-stanish-x-iso4217-a3 is not standards track, is there\n> a reason for this?\n\nOf the three currently published proposals, all are essentially IANA\nregistry proposals.\n\nWe are currently working with IETF staff, with open offers of support\nfrom multiple well funded commercial bodies, to transition these\nproposals through to IANA management.\n\nIt appears that the Independent Stream Editor path will be used to\ntransition these through to IANA, at which time the proposals\nthemselves will be converted to Informational status.\n\n(As far as I understand right now, Within the IETF, Standards Track\nhas special meaning and entails relatively large degrees of\nbureaucracy that are not within the current contributors' resources.\nIt is also worth pointing out that many popular protocols implemented\non the majority of systems (IIRC, such as IMAP) never reach formal\nstandardization for this reason. It should be noted that in these\ncases, this does not make the protocols any less attractive as\npotential components for system implementation.)\n\n> It also doesn't appear to address ~any of the the targeted items here.\n> Is there another draft I should be looking for which has more overlap\n> with the discussion here?\n\nAs outlined in the previous post:\n  - Internet Financial EXchange (IFEX). A proposal under development\nthat facilitates the negotiation of financial transactions between\ninternet-based financial endpoints. (The area we would love your\ninput) http://www.ifex-project.org/our-proposals/ifex\n\nAs well as the information linked to above, significant but not\nparticularly well grounded discussions have occurred regarding the\nIFEX-based paradigm for settlement versus some other proposed\nparadigms, in particular Ripple (as it appeared some months ago),\nwhich can be read here:\nhttps://groups.google.com/forum/?fromgroups#!topic/rippleusers/v4bEBZZVEsA[1-25]\n\nKind regards and with the hopes of combining our efforts as a joint\nproposal that can benefit other currencies/commodities and settlement\nsystems as well as Bitcoin,\nWalter Stanish\nSkype:walter.stanish"
            },
            {
                "author": "Rick Wesson",
                "date": "2012-11-27T03:29:11",
                "message_text_only": "On Mon, Nov 26, 2012 at 7:16 PM, Walter Stanish <walter at stani.sh> wrote:\n>>> X-ISO4217-A3\n>>\n>> I see that draft-stanish-x-iso4217-a3 is not standards track, is there\n>> a reason for this?\n>\n> Of the three currently published proposals, all are essentially IANA\n> registry proposals.\n>\n> We are currently working with IETF staff, with open offers of support\n> from multiple well funded commercial bodies, to transition these\n> proposals through to IANA management.\n\nI hate to inform you that you have been mislead. The IETF and the IANA\ndo not operate as you outlined above. Having spent too many years\nwithin ICANN/IETF/IANA I can assure you are mistaken.\nYour drafts are expired and it appears that there is no support for a\n\"finance\" working group in the IETF.\n\n\n-rick"
            },
            {
                "author": "Walter Stanish",
                "date": "2012-11-27T03:31:36",
                "message_text_only": ">> We are currently working with IETF staff, with open offers of support\n>> from multiple well funded commercial bodies, to transition these\n>> proposals through to IANA management.\n>\n> I hate to inform you that you have been mislead. The IETF and the IANA\n> do not operate as you outlined above. Having spent too many years\n> within ICANN/IETF/IANA I can assure you are mistaken.\n> Your drafts are expired and it appears that there is no support for a\n> \"finance\" working group in the IETF.\n\nWe are not establishing an IETF working group, which is an option that\nwas explored prior to the Paris meeting and has been sidelined at\npresent for depth-of-bureaucracy by the backing commercial entities.\nRather, we are establishing a top-level IANA registry group. This is\nnot anticipated by the IETF old-guard working with us to be either (a)\ncontroversial or (b) possible to block.\n\n- Walter"
            },
            {
                "author": "Rick Wesson",
                "date": "2012-11-27T03:54:44",
                "message_text_only": ">\n> We are not establishing an IETF working group, which is an option that\n> was explored prior to the Paris meeting and has been sidelined at\n> present for depth-of-bureaucracy by the backing commercial entities.\n> Rather, we are establishing a top-level IANA registry group. This is\n> not anticipated by the IETF old-guard working with us to be either (a)\n> controversial or (b) possible to block.\n\nMy last note in this sub-thread.\n\nThere are no IANA registry groups, there is no such thing, and no way\nto form one. The IETF can ask the IANA to form a registry but these\nthings take lots of support and take a long time, and these are only\ncreated through standards track RFC. ICANN runs the IANA and there is\nno such framework that you elude to. Review\nhttp://www.iana.org/protocols/\n\nIf you are applying for a gTLD, good luck with that.\n\n\n-rick"
            },
            {
                "author": "Walter Stanish",
                "date": "2012-11-27T04:17:35",
                "message_text_only": ">> We are not establishing an IETF working group, which is an option that\n>> was explored prior to the Paris meeting and has been sidelined at\n>> present for depth-of-bureaucracy by the backing commercial entities.\n>> Rather, we are establishing a top-level IANA registry group. This is\n>> not anticipated by the IETF old-guard working with us to be either (a)\n>> controversial or (b) possible to block.\n>\n> My last note in this sub-thread.\n\nMine too!\n\n> There are no IANA registry groups, there is no such thing, and no way\n> to form one.\n\nReading between the lines, I believe this phrase, which is not my own\nbut that of experienced IETF staff, refers to the groups visible at\nhttp://www.iana.org/protocols/ (which you yourself cited). Whether it\nis formally used or not is unknown to me.\n\n> The IETF can ask the IANA to form a registry but these\n> things take lots of support and take a long time,\n\nExpert opinion estimates six weeks, and by current estimates, we\nshould have an arrival circa February.\n\n> and these are only\n> created through standards track RFC. ICANN runs the IANA and there is\n> no such framework that you elude to. Review\n> http://www.iana.org/protocols/\n\nI would like to suggest that perhaps exactly this sort of banter is an\nexcellent illustration for the Bitcoin community of what we have been\nup against in this (conceivable simple an public benefit oriented)\nendeavour. If you also look at the fact that the ISO4217 registry (to\ntake currency/commodity codes as just one example) there is apparently\nnot even a public list of requirements for codepoint issue.  This sort\nof thing is *exactly* why the internet community appears to\ndesperately need an open registry - allowing public internet bodies\n(IANA) to function to support innovation and interconnectivity for all\nsectors of the internet's various financial communities so that\nanyone, including innovators, can obtain interoperability via simple,\nhassle-free paths, without encountering self-important bureaucrats.\n\nWe anticipate victory circa February.\n\n- Walter"
            },
            {
                "author": "Michael Gronager",
                "date": "2012-11-27T08:43:39",
                "message_text_only": "Short comments:\n\n* What if the SignedReceipt is not received AND the transactions IS posted on the p2p. Then you have payed for the goods, but you don't have a receipt. This could happen both from malice or system failures.\n** Suggestion - sign the invoice with the key to which to send the transaction, the proof of payment, equivalent to a signed receipt is then in the blockchain.\n\nThis scheme would work both with or without x509, if you want to include x509, the message in the invoice could simply be signed by the x509 certificate as well.\n\nPRO: Any user can send signed invoices, not only those with a x509 cert.\nPRO: No limbo situation with no SignedReceipt\nCON: This disables the use of anything but payment to key/address incl multisig etc.\n\nHowever, the wast majority of use will anyway be payment to key/address.\n\nSupport of general pay to script could be supported through the payment scheme proposed earlier by Mike: No non-fee payments are accepted, except in a group - i.e. it is up to the merchant to generate the final transaction incl the fees, and that one could be to a general script. This also keeps the support of pay to general script needed for a client to a minimum.\n\nCheers,\n\nMichael"
            },
            {
                "author": "Mike Hearn",
                "date": "2012-11-27T10:23:26",
                "message_text_only": "On Tue, Nov 27, 2012 at 9:43 AM, Michael Gronager <gronager at ceptacle.com> wrote:\n> * What if the SignedReceipt is not received AND the transactions IS posted on the p2p.\n\nI think this is a problem with confusing terminology rather then the\nspec itself.\n\nThe original formulation had a receipt being something generated\npurely by the buyer. The signed Invoice message  + the Bitcoin\ntransactions paying to the outputs + the merkle branches showing\nacceptance by the network *is* the receipt.\n\nThe SignedReceipt message is useful in the sense that it shows\nconfirmation by the merchant, but if you don't get one, you can still\nprove you paid the invoice. So from this perspective perhaps\nSignedReceipt should be renamed to Acceptance or something like that,\nand then the spec should call out that a signed invoice plus accepted\nBitcoin transactions is mathematically a proof of purchase."
            },
            {
                "author": "Michael Gronager",
                "date": "2012-11-27T10:42:01",
                "message_text_only": "> \n> The SignedReceipt message is useful in the sense that it shows\n> confirmation by the merchant, but if you don't get one, you can still\n> prove you paid the invoice. So from this perspective perhaps\n> SignedReceipt should be renamed to Acceptance or something like that,\n> and then the spec should call out that a signed invoice plus accepted\n> Bitcoin transactions is mathematically a proof of purchase.\n\nWhich is why I find the \"SignedReceipt\" somewhat superfluous. If you implement a payment system, like bit-pay/wallet you are likely to double that through some sort of e-mail receipt anyway.\n\nFurther, the inclusion of x509 is not really needed in the spec - you don't need to sign the invoice with an x509, you can use the payment key. The proof would still be equally binding, and valid also for non holders of x509 (server) certificates (like normal people).\nFinally, host certificates does not normally keep in their \"purpose\" S/MIME Signing. So you are bending the intended use of the x509 certificate anyway.\n\n/M\n\n> \n> ------------------------------------------------------------------------------\n> Monitor your physical, virtual and cloud infrastructure from a single\n> web console. Get in-depth insight into apps, servers, databases, vmware,\n> SAP, cloud infrastructure, etc. Download 30-day Free Trial.\n> Pricing starts from $795 for 25 servers or applications!\n> http://p.sf.net/sfu/zoho_dev2dev_nov\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Pieter Wuille",
                "date": "2012-11-27T11:36:13",
                "message_text_only": "On Tue, Nov 27, 2012 at 11:42:01AM +0100, Michael Gronager wrote:\n> > \n> > The SignedReceipt message is useful in the sense that it shows\n> > confirmation by the merchant, but if you don't get one, you can still\n> > prove you paid the invoice. So from this perspective perhaps\n> > SignedReceipt should be renamed to Acceptance or something like that,\n> > and then the spec should call out that a signed invoice plus accepted\n> > Bitcoin transactions is mathematically a proof of purchase.\n> \n> Which is why I find the \"SignedReceipt\" somewhat superfluous. If you implement a payment system, like bit-pay/wallet you are likely to double that through some sort of e-mail receipt anyway.\n\nGavin's proposal differs in this from my original proposal, where I\nexactly *didn't* want to couple the receipt with the acceptance of\nthe Bitcoin transaction.\n\nIf a merchant/payment processor is willing to take the risk of zero or\nlow confirmation transactions (because they are insured against it,\nfor example), they were allowed to reply \"accepted\" immediately, and\nthis would be a permanent proof of payment, even if the actual Bitcoin\ntransaction that backs it gets reverted.\n\nFor that reason, I also had a separate \"pending\" state, which means the\nreceiver isn't willing to just accept the current state as irrevocably\npaid. In this case, the sender was allowed to retry until the receipt\nsayd \"accepted\" or \"rejected\".\n\nThe whole point was to avoid that customers/merchants would have to\ndeal with the uncertainty involved in Bitcoin transaction. At some\npoint, someone is going to accept the transaction (whether that is at\n0 or at 120 confirmations), and acceptance will at the higher level\nbe considered a boolean anyway - not some \"probably, unless reorg\".\n\n-- \nPieter"
            },
            {
                "author": "Michael Gronager",
                "date": "2012-11-27T11:46:17",
                "message_text_only": "> \n> If a merchant/payment processor is willing to take the risk of zero or\n> low confirmation transactions (because they are insured against it,\n> for example), they were allowed to reply \"accepted\" immediately, and\n> this would be a permanent proof of payment, even if the actual Bitcoin\n> transaction that backs it gets reverted.\n\nI guess that moves the discussion from developers to lawyers ;) Even though you send a signed receipt, if you can proof you didn't get the money, you will never be expected to deliver the goods. (and you can even write that in the the receipt ...)\n\nSo the SignedReceipt is legally not worth the bits it is composed of, hence I don't see the point in supporting it.\n\nIf you are selling atoms you can usually wait for N confirmations (even though you start shipping I guess you can recall a parcel within 144 blocks). If you are selling bits (like access to a site), you can revoke that access once you discover the transaction did not go through. So I can't find a use case where a Signed Receipt in the proposed form is advantageous.\n\n/M"
            },
            {
                "author": "Mike Hearn",
                "date": "2012-11-27T12:03:35",
                "message_text_only": "> Further, the inclusion of x509 is not really needed in the spec - you don't need to sign the invoice with an x509, you can use the payment key.\n\nNo, the point of using X509 certs is to get a verified identity (a\ndomain name) on the receipt, this is needed for multi-factor\nauthentication. You can't do that without some kind of third party\nasserting to an identity."
            },
            {
                "author": "Michael Gronager",
                "date": "2012-11-27T12:39:30",
                "message_text_only": "> No, the point of using X509 certs is to get a verified identity (a\n> domain name) on the receipt, this is needed for multi-factor\n> authentication. You can't do that without some kind of third party\n> asserting to an identity.\n\n\nAgree that you need a third party to verify identity. But the verification policy of sites is the job for a payment provider not a payment technology. So if you would like verification of the site you could just sign the memo using standard S/MIME - why mix it with the payment protocol?\n\nFurther, it is controversial use of the host key to use it for digital signing of documents, and not even within the policy of a host certificate as far as I recall.\n\nThe problem you are trying to tackle is that we don't have an ID solution on the internet today for this purpose. Certificates for signing messages are distributed freely and insecurely only based on temporarily having an email from within an organization, and the host certificates are meant for SSL handshakes. Funnily, any CA can issue digital certificates for email signing for any domain, even though they don't own them, and without notifying the owner. DANE actually solves this, but until then using the host certificates is unintended use, it is cryptographically a nice solution, but legally and standard-wise a hack.\n\n/M"
            },
            {
                "author": "Gavin Andresen",
                "date": "2012-11-27T14:05:13",
                "message_text_only": "RE: SignedReceipt:  I agree it is superfluous.  I'll remove it from the spec.\n\nRE: \"it is controversial use of the host key to use it for digital\nsigning of documents\"  :  The idea of embedding a x509 certificate\nchain comes from the IETF's JSON Object Signing and Encryption working\ngroup \"JWS\" specification, so I can't be TOO controversial.\n\nRE: the ifex-project and other electronic invoicing standards:  Thanks\nfor the pointers, Walter! I'm all for adopting the best ideas that\nhave come before, as long as we end up with something useful and small\nenough to convince ourselves it is as secure as we can make it. I\nlooked at the ifex spec, and quickly got lost. It would help me if you\ncould write up what our motivating use cases would look like if\nimplemented on top of ifex.\n\nRE: jgarzik's suggestion to allow txids in the Payment: that worries\nme, because it is trivial to create several different variations of\nthe same transaction (same inputs to same outputs) with different\ntxids (re-signing inputs uses a different signature nonce, which\nchanges the signature/txid, for example).\n\nRE: using self-signed certificates:  as Mike said, I assume Bitcoin\nclients will have some way of managing root certificates, so experts\ncould add trusted self-signed certs.\n\n-- \n--\nGavin Andresen"
            },
            {
                "author": "Gavin Andresen",
                "date": "2012-11-27T14:26:07",
                "message_text_only": "One more thought:\n\nRE: \"Receipt\" verus \"Acceptance\" :\n\nI believe \"Receipt\" is the right term-- it means \"I got your payment\",\nNOT \"your payment has cleared.\"  E.g. if I hand a merchant a paper\ncheck they'll hand me a receipt, but the check could still bounce.\nThat's the analogy here-- a merchant might give you a receipt, but if\nthe transaction is rejected by the network for whatever reason (Finney\nattack maybe) you cannot expect to go to court with your\ninvoice/receipt and claim you made a valid payment.\n\n\n-- \n--\nGavin Andresen"
            },
            {
                "author": "Walter Stanish",
                "date": "2012-11-28T13:55:22",
                "message_text_only": "> RE: the ifex-project and other electronic invoicing standards:  Thanks\n> for the pointers, Walter! I'm all for adopting the best ideas that\n> have come before, as long as we end up with something useful and small\n> enough to convince ourselves it is as secure as we can make it.\n\nFair enough, although I would posit:\n 0. You can't get more secure than not doing it at all.\n 1. Small is sometimes beautiful, but sometimes just the 999th\ncrippled and half-featured attempt at a nontrivial problem space\n(...linked heavily to implementation-time assumptions and/or specific\npeer systems, and by its very nature destined for the dustbin of time?\nWell, maybe. Eventually, we all are.)\n 2. X.509 is not small (or beautiful, unless one is some weird new\nkind of centralized cryptographic trust fetishist, of some sort you\nmight see with furrowed brows, boozing at midday sporting key & anchor\ntattoos in old convention polo-shirts, mumbling to themselves about\nthe employee-motivation benefits of single sign-on...)\n\n> looked at the ifex spec, and quickly got lost. It would help me if you\n> could write up what our motivating use cases would look like if\n> implemented on top of ifex.\n\nYes. Understandable. Thoughts around an IFEX protocol proposal, unlike\nthe other proposals, are still drafty (err...as a coastal verandah?)\nand not the clearest. However, we have much research and progress has\nbeen achieved in the odd year-or-so since beginning.  The fundamental\nconcerns of such a protocol (regarding the establishment of neutral,\nopen and technically-viable proposals for internet-wide\ncurrency/commodity, market and financial endpoint identification) have\nalready been reasonably met.\n\nThis has opened the door to the potential for faster progress on the\nIFEX protocol itself (\"a mechanism for the identification,\nnegotiation, description, execution and management of financial\ntransactions over their lifetime\"), like, right about now. Which is\nkind of the same zone of potential functionality (at least in a naive,\nlinguistic comparison sense) that people are talking about here.\nBecause of the hope to garner more interest from the Bitcoin community\nwith this post (do read on!), I spent a bunch of hours today cleaning\nup and converting the IFEX Protocol's current breezy-draft form back\nfrom the wiki formatting it had been lazing and grazing (and growing,\nalbeit slowly) in for the greater part of the year and moving to\nGithub (forks and issues very much encouraged) over here:\nhttps://github.com/globalcitizen/ifex-protocol\n  (Discussion list at http://group.ifex-project.org/ actually has\nquite a few members at present, despite appearances to the contrary)\n\n> implemented on top of ifex.\n\nRe: \"implemented on top of ifex\", this is kind of opposite to how IFEX works.\n\nIFEX's idea is to provide a flexible yet stable protocol that lets\nindividual (potential, ongoing, or completed) transactions on\narbitrary (legacy, conventional, emerging, or future) settlement\nsystems (in arbitrary currencies/commodities) to be described and\nfacilitated (executed, routed, monitored, etc.) in real time, by\ndescribing accurately the objective properties of each of those\nsystems and components.\n\nSo, for example, an end user, requiring a transfer of <x> of <y>\ncurrency/commodity from 'point a' to 'point b' would find routes to\nachieve that, evaluate them in terms of monetary and temporal\noverheads against their own trust and risk models plus any legal,\nprivacy or other requirements in order to select and effect the most\nappropriate manner of settlement.\n\nIn short, IFEX sees Bitcoin as having such-and-such properties,\nmatches that to a need to transfer some funds, and effects the\ntransfer, monitoring and/or reporting on its state in a normalized\nfashion throughout its lifetime.\n\nI'll try again to describe the motivating use case:\n==============\nRecognising that Bitcoin is not the only emerging financial community\nor settlement system facing real world business integration\nchallenges, and recognising the significant complexity of these in\ncommon situations (multi-hop transactions, arbitrary currency\ntransactions, foreign exchange automation, liquidity guarantee\nchallenges, settlement latency negotiation, invoicing periods,\ncommercial payment or shipping terms, sovereign (exchange rate\nfluctuation) and other forms of risk management, potentially\nsimultaneous multi-level fee, tax and discount requirements,\nproduct/service coding, line items, complex tax calculations\n(particularly in the US, and which may be based on both buyer and\nseller geolocation), legal requirements to include various metadata,\netc.), instead of investing valuable developer time on internal\nimplementation (and subsequent maintenance) of a tightly-scoped\n(==crippled?) business-level protocol extension to Bitcoin that can be\nperhaps fairly characterised as unlikely to quickly evolve to meet\nmany of these real world requirements, and with as yet unclear real\nworld demand for such from the Bitcoin community, who must already\novercome significant complexity hurdles to use Bitcoin at all, Bitcoin\ndevelopers can instead simply declare this \"out of scope\" (win!) and\nfocus on Bitcoin's current roles as a digital commodity and settlement\nsystem.\n\nThis approach to scope limitation has excellent historical support\nfrom the unix community - \"do one thing and do it well\". Bitcoin\nalready does a few things, notably in its triple roles as\nnetwork-community, currency-like-commodity, and settlement system.\n\nThe alternative is that instead of creating load for the Bitcoin\ndevelopers, who may be ill-equipped and ill-resourced to properly\ntackle these peripheral requirements, interested parties instead\ncontribute to projects like IFEX that view systems such as Bitcoin as\ncore use cases but are not limited by Bitcoin developer time or\nproject trajectory, and promise re-usability for other conventional,\nemerging and future currencies/commodities/settlement systems, thus\nretaining the capacity to attract interest and resources from those\ncommunities (and broader, internet-centric interest groups and\ninfrastructure) toward a common goal, while creating a valuable shared\nplatform for interoperability between Bitcoin and those other systems\n(including legacy financial systems) that allows Bitcoin to\nobjectively showcase its strengths.\n\nNet result: Bitcoin developers can focus on Bitcoin. Meanwhile,\nbusiness level integration things completely tangential to the core\nbitcoin codebase get done with a far broader scope and applicability,\nproviding a broader community and potential resource base for moving\nthings forward, and presenting a less \"shifting-sands\" approach to\npotential implementers (who are safe in the knowledge that their now\nstandardized infrastructure can support a wide range of\ncurrencies/commodities, settlement systems, financial network\ntopologies settlement paradigms, and will not critically rely upon any\ngiven component system as a single point of failure). Bitcoin, through\nthe platform IFEX develops, gets to compete at the business level on a\nfair and even basis with legacy and other emerging systems based upon\nits highly desirable objective properties (speed, reach, low\noverheads, rapid connection, lack of wacky X.509 certificate\npurchasing requirements... yet, etc.), such that a business case *not*\nto use it in various commercial settings becomes difficult to field.\nEveryone wins.\n==============\n\nNote that the above basically echoes much of the (less verbose? more\ndigestible?) information available at http://ifex-project.org/ where -\nalong with http://tools.ietf.org/ - the full text of existing\nproposals are also available, but attempts to do so in a more specific\nfashion for Bitcoin developer community.\n\nConsidering the above, and that a single system is never going to meet\nevery person's needs all of the time (yes, even Bitcoin!), I really\nhope that the Bitcoin developer community will see the benefits of\nsupporting an external rather than internal solution to business level\n(or at least non directly settlement-facilitating) financial\ntransaction requirements, both for the Bitcoin project itself, its\nusers, and for that broader and longer-term goal (in very much the\nsame spirit) of effecting some sorely-needed, socially positive and\nlasting change in global financial systems.  Nothing can be all things\nto all people (especially X.509, which can be completely different\nkinds of pain to all who come in to contact with it) - but at least\nwith an open, platform neutral financial transaction oriented protocol\noutside of individual settlement system, currency and commodity\nprojects, each new system can stand on its own merit and support the\nothers, deriving shared fruits of increased user base, usability and\nliquidity through heterogeneous interoperability.\n\nSincerely, hoping to work together with interested parties to move\nforward in this area (come issue/fork the github repo!), and with the\nutmost respect for all of the valuable work of the Bitcoin community\n(though scratching my head a bit on the lack of an April 1 date or\npunchline for this X.509 stuff!!), and, and, out of breath,\nWalter Stanish"
            },
            {
                "author": "Andy Parkins",
                "date": "2012-11-27T17:03:39",
                "message_text_only": "On Monday 26 November 2012 22:37:31 Gavin Andresen wrote:\n\n> x509chain: one or more DER-encoded X.509 certificates that identifies\n> the merchant. See the \"Certificates\" section below for details.\n\nPersonally, I'd like to see fewer implicit ties to X509.  With X509 as one \noption.  For example, I'd much prefer to see a doorway to the future left open \nlike this:\n\n    message Invoice {\n        repeated bytes issuerIdentityType;\n        repeated bytes issuerIdentityBytes;\n\nor similar, instead of \"x509chain\".\n\nIn particular two additional identification types:\n\n - GnuPG (obviously)\n - Hash based\n\nThe hash-based system would be there as a method of leveraging an existing \ntrusted connection, without needing to get into the nitty-gritty of \ncertificates.  For example, I am paying for something on a web site; I \npresumably already have a secure connection that I trust to that site.  That \nsite can issue me an invoice (which is to be sent to the bitcoin client) _and_ \na hash of the certificate on the same page.\n\nI trust that hash because I received it over a secure connection from a \ntrusted source.  When my bitcoin client pops up with the received invoice, it \nshows me the hash of the invoice, and I can be sure that it is from the web \nsite I thought it was from.\n\nImagine I'm a (very) small business, I have two or three customers.  I want to \nemail one of my customers an invoice.  I don't want to have to get an X509 \ncertificate, and I don't necessarily know how.  However, I can ring my \ncustomer up and say \"I've generated an invoice with my bitcoin client, it is \nhashed A7DE-521X-9977.  Write that down and confirm it when you get my \ninvoice\".  Alternatively, I might attach a file called\ninvoice-A7DE-521X-9977.bitinv to a signed GnuPG email.  The receipient can \neasily confirm I sent it because the filename must match the contents and \nGnuPG protects against tampering.\n\n\n\n\nAndy\n\n-- \nDr Andy Parkins\nandyparkins at gmail.com"
            },
            {
                "author": "Mike Hearn",
                "date": "2012-11-27T17:14:19",
                "message_text_only": "> Personally, I'd like to see fewer implicit ties to X509.  With X509 as one\n> option.\n\nThat's pretty much what we have today - in future other schemes can be\nproposed as extensions. Protocol buffers are easily extended, they\nignore unknown fields. Then you'd wait and see what the invoice\nrequest looked like and produce an invoice with the right security\nbits.\n\n> In particular two additional identification types:\n>\n>  - GnuPG (obviously)\n\nIt's not obvious to me, incidentally. The web of trust has been\ndead-on-arrival since it was first proposed, and for good reasons.\nSSL/X.509, for better or worse, has significant usage.\n\nYour case of a small business is a perfect example of people who won't\nbe using GPG. If they don't want to buy an SSL cert, they can just as\nwell put a reference number in the memo field or a \"Hey Bob, here is\nthe bill we discussed\". The payer does not get the multi-factor auth\nprotection so if their computer has a virus, they may be hosed. But\nthat's good incentive for sellers to get verified. Some CA authorities\ndo it for free these days."
            },
            {
                "author": "Andy Parkins",
                "date": "2012-11-27T17:26:56",
                "message_text_only": "On Tuesday 27 November 2012 17:14:19 Mike Hearn wrote:\n\n> That's pretty much what we have today - in future other schemes can be\n> proposed as extensions. Protocol buffers are easily extended, they\n> ignore unknown fields. Then you'd wait and see what the invoice\n> request looked like and produce an invoice with the right security\n> bits.\n\nThat's good; I've not done anything with protocol buffers, so wasn't aware it \nwas that simple.\n\n> > In particular two additional identification types:\n> >  - GnuPG (obviously)\n> \n> It's not obvious to me, incidentally. The web of trust has been\n> dead-on-arrival since it was first proposed, and for good reasons.\n> SSL/X.509, for better or worse, has significant usage.\n\nSorry, I meant \"obviously\" in the sense that \"obviously that's the other one \nthat everyone will want\".  The web-of-trust as a universal identity mechanism \nis, I agree, not useful.  However, as a localised, smaller-scale identity \nverification system it's used by every GnuPG user.  You become your own \ncertificate authority.  For example, I've set up my whole family with GnuPG; \nI've set them up to trust me to authenticate (and I doubt any of them has ever \nadded anyone else).  Then I take on the responsibility of signing all my \nfamily/friends keys and they don't need to worry about it.\n\nThere's no reason that a small group of companies wouldn't do exactly the same \nsort of thing.\n\n> Your case of a small business is a perfect example of people who won't\n> be using GPG. If they don't want to buy an SSL cert, they can just as\n\nBear in mind, I was using that example as an example of a hash protected in a \nGPG envelope, not a GPG-signed invoice.  People who've already got their GPG \nsystem in place will appreciate being able to leverage it.\n\n> well put a reference number in the memo field or a \"Hey Bob, here is\n> the bill we discussed\". The payer does not get the multi-factor auth\n\nHow can they put a hash of an invoice inside the invoice?  In my \"hash mode\" \ninvoices, it would be a random number (or possibly specifying the hash \nalgorithm) then the SignedInvoice would simply be the original invoice + hash.  \nThat hash would then be reported via some secure channel outside of bitcoin's \ndomain.\n\n> protection so if their computer has a virus, they may be hosed. But\n> that's good incentive for sellers to get verified. Some CA authorities\n> do it for free these days.\n\nI don't understand what the relevance of multi-factor is to invoices?  The \npayment is performed via normal bitcoin mechanisms isn't it -- multi-factor or \nnot?  This invoice system has one primary job: to ensure that the target of \nthe payment is who the payer thinks it is -- that's not affected by multi-\nfactor methods of protecting my wallet.\n\n\n\nAndy\n\n-- \nDr Andy Parkins\nandyparkins at gmail.com"
            },
            {
                "author": "Mike Hearn",
                "date": "2012-11-27T18:16:53",
                "message_text_only": "> That hash would then be reported via some secure channel outside of bitcoin's\n> domain.\n\nOK, I see. I guess that could be a reasonable fallback for the case\nwhere you have a secure channel.\n\n> I don't understand what the relevance of multi-factor is to invoices?\n\nYes, exactly. It's about paying who you think you're paying (when you\nconfirm on a second uncompromised device)."
            },
            {
                "author": "Gavin Andresen",
                "date": "2012-11-27T21:39:55",
                "message_text_only": "Spec updated: https://gist.github.com/4120476\n\nNotable changes are:\n\n+ Removed SignedReceipt\n\n+ Replaced Invoice.x509chain with a \"pki_type\" and \"pki_data\" to make\nusing other identity systems cleaner.\n\n+ Added a \"Why not an existing electronic invoice standard?\" section\nto the design notes\n\n-- \n--\nGavin Andresen"
            },
            {
                "author": "Mike Hearn",
                "date": "2012-11-28T10:43:19",
                "message_text_only": "The current spec is ambiguous in the case of what to do if the invoice\ncontains one output of a fixed amount and one or more outputs of an\nunspecified amount. Should the user be prompted once per output? That\nseems suboptimal. Prompted once for a value that's then randomly\ndistributed between all open-value outputs? It seems this ability of\nthe protocol is somewhat more complex than it appears. The ability to\nhave open outputs is nice for tips though.\n\nYou could consider moving pki_type and pki_data into a separate\nmessage and making both fields required, then making the pki message\noptional. Otherwise you can have pki_type set but no data or\nvice-versa. It doesn't make much difference in the end, just slightly\nimproves the automatic sanity checks produced by the proto compiler.\n\nw.r.t SIGHASH_ANYONECANPAY. I think it's best not to use this\nroutinely as it relaxes the signature checks in ways that may open\nnon-obvious holes when combined with other features. I thought we\npretty much had consensus on recursively calculating fees including\ndependents in the memory pool?\n\nPeter is correct that there are a few degrees of freedom in protobuf\nserialization, though far fewer than with JSON. I'd like to think\nupstream would be open to resolving these ambiguities.\nRe-serialization of an Invoice message in the Payment message is a\npotential source of mistakes. There's no need to ever concatenate\nthese messages and alternative implementations that don't order\nserialized fields by tag number are missing an important optimization,\nso they could be fixed. The main issue is treatment of unknown fields.\nIf/when the Invoice message is extended with other fields that are\nround-tripped through an old client, the data may get lost. JSON\ndoesn't help resolve that either, of course. There are a few\nsolutions:\n\n1) Change the type of the Invoice field in Payment to be \"bytes\" and\nset it to be the hash of the originally received binary Invoice\nmessage. Downside, requires merchants to track all outstanding\ninvoices.\n2) Ask protobufs upstream to modify the spec/implementations so\nordering of unknown fields is specified. The Python implementation\ncould be extended to support them so Python implementors don't end up\nwith accidental message downgrades.\n3) Language of the spec could be changed to explicitly state that the\nreceived Invoice may not be binary-identical to the one that was sent,\nin the case of a client that incorrectly downgrades the message. Thus\nyou'd be expected to check what the Invoice was using merchant_data\nwhich is opaque and could just be, eg, a database key on your own end.\n4) Instead of submitting the entire Invoice back to the merchant, just\nthe merchant_data could be in the Payment message.\n\nOf the four options I prefer the last. What is the use case for\nresubmitting the entire invoice anyway? Even if protobufs are improved\nso handling of round-tripping new messages through old [Python]\nclients is more rigorous, some implementors will probably convert the\nprotobuf objects into some internal forms for whatever reason (or\nserialize them to a database, etc) and they're very likely to mess up\nthe handling of unknown fields when they do it."
            },
            {
                "author": "Peter Todd",
                "date": "2012-11-28T12:57:10",
                "message_text_only": "On Wed, Nov 28, 2012 at 11:43:19AM +0100, Mike Hearn wrote:\n> Peter is correct that there are a few degrees of freedom in protobuf\n> serialization, though far fewer than with JSON.\n\nFWIW I re-read the specs again and turns out my memory was wrong. (I\nlast looked at this about four months ago) Duplicated fields are handled\nin a defined manner, with the last field seen in the serialization being\nthe one whose value is used. Again, repeated fields are treated as\nelements of a list, preserving order.\n\nIt does raise the interesting question do the implementations that don't\npreserve order of unknown fields, preserve the order of multiple unknown\nfields, either repeated or not?\n\n> I'd like to think upstream would be open to resolving these\n> ambiguities.\n\nI gotta admit, I suspect they won't be that open. Protocol buffers was\ndesigned because Google needed a fast serialization method suitable for\nmany different internal projects. Needing round-trip idempotence seems\nlike a rare requirement to me, especially for internal use.\n\n> Re-serialization of an Invoice message in the Payment message is a\n> potential source of mistakes. There's no need to ever concatenate\n> these messages and alternative implementations that don't order\n> serialized fields by tag number are missing an important optimization,\n> so they could be fixed. The main issue is treatment of unknown fields.\n> If/when the Invoice message is extended with other fields that are\n> round-tripped through an old client, the data may get lost. JSON\n> doesn't help resolve that either, of course. There are a few\n> solutions:\n\nWell, actually you can take advantage of the message concatination\nability of protocol buffers to extend a message by simply appending the\nnew fields to the existing thus either defining new fields, or\noverriding old values as required. If you want to de-duplicate though\nyou run into the problem all over again.\n\nOn the other hand JSON handles this case fine too provided that your\nJSON implementation supports dictionary objects with arbitrary fields.\nJust use the object as is and the unknown fields will be re-serialized\nproperly at the other end. Some implementations will have to be careful\nto handle collisions with existing keys in the namespace. (consider in\nPython what would happen if you mapped your object to a class instance,\nand the serialization included the key \"__init__\")\n\nThat said, JSON is quite problematic with numbers. For instance, you\nhave to be careful to keep integers represented as pure integers below\nwhat Javascript can handle, the maximum integer exactly representable in\na double float, or the JSON won't be parsable in Javascript even if many\nother languages handle it fine. Protocol buffers is at least pretty\nexplicit about what size integers are.\n\n> 1) Change the type of the Invoice field in Payment to be \"bytes\" and\n> set it to be the hash of the originally received binary Invoice\n> message. Downside, requires merchants to track all outstanding\n> invoices.\n> 2) Ask protobufs upstream to modify the spec/implementations so\n> ordering of unknown fields is specified. The Python implementation\n> could be extended to support them so Python implementors don't end up\n> with accidental message downgrades.\n> 3) Language of the spec could be changed to explicitly state that the\n> received Invoice may not be binary-identical to the one that was sent,\n> in the case of a client that incorrectly downgrades the message. Thus\n> you'd be expected to check what the Invoice was using merchant_data\n> which is opaque and could just be, eg, a database key on your own end.\n> 4) Instead of submitting the entire Invoice back to the merchant, just\n> the merchant_data could be in the Payment message.\n> \n> Of the four options I prefer the last. What is the use case for\n> resubmitting the entire invoice anyway? Even if protobufs are improved\n\nNote that I think the SignedInvoice message itself is broken, because\nprotobuf implementations have no reason to guarantee that they can give\nyou the serialized bytes of the Invoice sub-message. It's a quite\nspecific use-case that isn't needed for pretty much anything but crypto.\nFWIW I took a quick look at the official API's, C++, Java and Python,\nand as far as I can tell none of them support accessing the binary\nserialization of a message field other than by re-serializing the\nmessage.\n\nReally the invoice field should be declared as bytes serialized_invoice,\nas inconvenient as that is to work with.\n\n> so handling of round-tripping new messages through old [Python]\n> clients is more rigorous, some implementors will probably convert the\n> protobuf objects into some internal forms for whatever reason (or\n> serialize them to a database, etc) and they're very likely to mess up\n> the handling of unknown fields when they do it.\n\nSince the Payment message includes an *untrusted* Invoice that the\nvendor needs to authenticate the whole invoice no matter what on Payment\nreception. In many cases that implies they have to keep some sort of\ndatabase of \"quotes\" or similar anyway as the client can change anything\nthey want otherwise. Again that leads back to the argument of why not\njust stick with the merchant_dat as you suggest, which will usually be\nsome short invoice number attached to a database? A vendor that wants to\noperation a stateless invoicing system can just stuff a HMAC-protected\nserialized invoice into the merchant_data\n\nI guess you could use a mutable invoice field as a way of achieving some\nsort of negotiation protocol, but I think it's better to stick to the\noriginal concept of just ensuring that the user is really paying the\nright amount to the right address.\n\n-- \n'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20121128/46255e3d/attachment.sig>"
            },
            {
                "author": "Gavin Andresen",
                "date": "2012-11-28T14:09:45",
                "message_text_only": "RE: Changing SignedInvoice's invoice field to 'bytes serialized_invoice':\n\nGood Idea, I agree it will avoid potential issues. I think it then\nmakes sense to pull the pki_type and pki_data into SignedInvoice, too,\nand specify that the signature is on the SHA256-HMAC of pki_type,\npki_data, and serialized_invoice (being careful to combine them in a\nway that is secure).\n\nRE: Changing Payment to include just merchant_data and not the entire Invoice:\n\nAgreed, good idea.\n\n\nRE: Mr. Stanish's suggestion to punt all of this and wait for a Grand\nUnified Solution:\n\nNo, we have problems that need a solution right now. And, having\nwritten one (I was the lead author of the ISO/IEC 14772-1\ninternational standard) I'm very pessimistic about your chances for\nanything like IFEX to actually be adopted.\n\n-- \n--\nGavin Andresen"
            },
            {
                "author": "Peter Todd",
                "date": "2012-11-28T08:33:06",
                "message_text_only": "On Mon, Nov 26, 2012 at 05:37:31PM -0500, Gavin Andresen wrote:\n> Why not JSON?\n> -------------\n> \n> Invoice, Payment and Receipt messages could all be JSON-encoded. And\n> the Javascript Object Signing and Encryption (JOSE) working group at\n> the IETF has a draft specification for signing JSON data.\n> \n> But the spec is non-trivial. Signing JSON data is troublesome because\n> JSON can encode the same data in multiple ways (whitespace is\n> insignificant, characters in strings can be represented escaped or\n> un-escaped, etc.), and the standards committee identified at least one\n> security-related issue that will require special JSON parsers for\n> handling JSON-Web-Signed (JWS) data (duplicate keys must be rejected\n> by the parser, which is more strict than the JSON spec requires).\n> \n> A binary message format has none of those complicating issues. Which\n> encoding format to pick is largely a matter of taste, but Protocol\n> Buffers is a simple, robust, multi-programming-language,\n> well-documented, easy-to-work-with, extensible format.\n\nI'm not sure this is actually as much of an advantage as you'd expect. I\nlooked into Google Protocol buffers a while back for a timestamping\nproject and unfortunately there are many ways in which the actual binary\nencoding of a message can differ even if the meaning of the message is\nthe same, just like JSON.\n\nFirst of all while the order in which fields are encoded *should* be\nwritten sequentially, parsers are also required to accept the fields in\nany order. There is also a repeated fields feature where the\nfields can either be serialized as one packed key-list pair, or multiple\nkey-value(s) pairs; in the latter case the payloads are concatenated.\n\nThe general case of how to handle a duplicated field that isn't supposed\nto be repeated seems to be undefined in the standard. Yet at the same\ntime the standard mentions creating messages by concatenating two\nmessages together. Presumably parsers treat that case as an error, but I\nwouldn't be surprised if that isn't always true.\n\nImplementations differ as well. The current Java and C++ implementations\nwrite unknown fields in arbitrary order after the sequentially-ordered\nknown fields, while on the other hand the Python implementation simply\ndrops unknown fields entirely. As far as I know no implementation\npreserves order for unknown fields.\n\nFinally, while not a Protocol Buffers specific problem, UTF8 encoded\ntext isn't guaranteed to survive a UTF8-UTFx-UTF8 round trip.  Multiple\ncode point sequences can be semanticly identical so you can expect some\nsoftware to convert one to the other. Similarly lots of languages\ninternally store unicode strings by converting to something like UTF16.\nOne solution is to use one of the normalization forms such as NFKD - an\nidempotent transformation - although I wouldn't be surprised if\nnormalization itself is complex enough that implementation bugs exist,\nnot to mention the fact that the normalization forms have undergone\ndifferent versions.\n\nI think the best way(1) to handle (most) the above by simply treating the\nbinary message as immutable and never re-serializing a deserialized\nmessage, but if you're willing to do that just using JSON isn't\nunreasonable either.\n\n\n1) Of course I went off an created Yet Another Binary Serialization for\nmy project, but I'm young and foolish...\n\n-- \n'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20121128/ac1eb23f/attachment.sig>"
            },
            {
                "author": "Roy Badami",
                "date": "2012-11-28T23:36:19",
                "message_text_only": "> If a Receipt is not received for any reason (timeout, error) and\n> Payment.transactions has not been broadcast by the merchant on the\n> Bitcoin p2p network, then the Bitcoin client should assume that the\n> payment failed, inform the customer that the payment failed, and\n> return coins involved in the transaction to the customer's wallet.\n\nI'm not sure I understand the rationale for this.  In the above\nscenario the buyer has no way to determine whether the merchant still\nhas a copy of the transaction that they could broadcast in future.\nMaybe there is simply a systems problem at the merchant which has\ntemporarily delayed the transaction broadcast. Or maybe a dishonest\nmerchant deliberately engineered this situation in an attempt to\nmislead the buyer as to the status of their payment.\n\nEither way, having the buyer think the coins have been returned to\ntheir wallet - only to disappear from their wallet again at some later\ntime - would seriously damage user confidence in Bitcoin IMHO.\n\nIt seems to me that the first thing the buyer should do given the\nprotocol as it stands is simply resend the Payment message - if there\nwas a temporary problem then resending the payment message (with the\nsame signed transation) might resolve the sitution.\n\nIf after several retries the status of the transaction is still\nundefined then it's really not clear what to do, but it seems\ndesireable to have the client take steps so that it can return to a\nstate of certainly about its wallet balance as quickly as possible.\nTwo things I can imagine that the buyer might want their client to do\nat this point are:\n\n * broadcast the transaction itself, so they are sure the payment\n   transaction will make it into the blockchain without any further\n   action on their part, or\n\n * invalidate the transaction by immediately broadcasting a\n   pay-to-self transaction that spends one or more of the same outputs\n   that the payment transaction spends (and treat the funds as part of\n   the unconfirmed balance until this pay-to-self transaction\n   confirms).  This ensures the merchant can't subsequently use a\n   transaction which the buyer thinks has failed\n\nIt seems to me it would be simpler and cleaner if the buyer just\nalways broadcasted the transaction on the p2p network, regardless of\nwhether the Invoice includes a receiptURI.  If a receiptURI is\nincluded, the buyer's client would also include the transaction in the\nPurchase message.  The merchant then tries to broadcast the\ntransaction as well (unless their bitcoind has already seen it, which\nmay well be the common case).  This approach seems to me to have fewer\nnasty edge cases.s\n\nroy"
            },
            {
                "author": "Watson Ladd",
                "date": "2012-11-29T00:30:45",
                "message_text_only": "After doing more thinking, what about letting a spend sign more information\nassociated with the transaction, such as a transaction ID provided by the\nmerchant? This seems to solve a lot of the problems being put forward, with\nmuch less complexity.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20121128/588982d1/attachment.html>"
            },
            {
                "author": "slush",
                "date": "2012-11-29T08:16:31",
                "message_text_only": "Hi,\n\nnot sure if you already noticed, but I and my friends are actively working\non bitcoin hardware wallet. This should be pocket size device with\nsomething like 256kB flash and 80 MHz CPU, talking with the computer over\nUSB. User will prepare transaction on the machine, send it to the device,\ndevice shows target address on the display and user confirms it by pressing\nthe button.\n\nWe're trying to make bitcoin payments safe even on hacked computer. For\nthis reason we're also implementing SPV so device don't need to trust\ncomputer with any kind of information. The biggest existing problem is that\nuser cannot be sure that the address displayed on computer screen is\ncorrect and he's confirming valid address.\n\nI don't have any solution for this problem yet. I just appreciate an\nactivity in payment protocol area, because it can (with some care) solve\nthis problem and my appeal si to keep all this simple. I'd be very happy\nwith simple payment protocol which can be implemented even on devices like\nI'm working on, so device with few widely used certificates stored in the\nmemory will be able to display origin of the invoice and confirm its\nvalidity.\n\nslush\n\n\nOn Thu, Nov 29, 2012 at 1:30 AM, Watson Ladd <wbl at uchicago.edu> wrote:\n\n> After doing more thinking, what about letting a spend sign more\n> information associated with the transaction, such as a transaction ID\n> provided by the merchant? This seems to solve a lot of the problems being\n> put forward, with much less complexity.\n>\n> ------------------------------------------------------------------------------\n> Keep yourself connected to Go Parallel:\n> VERIFY Test and improve your parallel project with help from experts\n> and peers. http://goparallel.sourceforge.net\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20121129/fe7ebf3e/attachment.html>"
            },
            {
                "author": "Gavin Andresen",
                "date": "2012-11-29T16:11:51",
                "message_text_only": "RE: Roy Badami's comments on edge cases around submitting a Payment\nmessage to a merchant and then not receiving a timely response:\n\nI agree, it is messy.\n\nI'm hesitant to try to specify One True Way of handling it in the\nspec; I've got a feeling that this might be a place where different\nimplementations might try different things, with the best\nimplementation winning.\n\nFor example, if some future nifty-keen Bitcoin client is re-using an\nold Invoice to send a monthly subscription payment and they can't\ncontact the paymentURI, then the right thing is probably for it to\nretry once a day for three or four days and if they all fail then give\nup and tell the user that the service is no longer in business (or\nchanged their paymentURI without leaving behind a redirect).\n\nIf it has a single-use Invoice created a minute or two ago, the right\nlogic might be:\n  + If the paymentURI is completely non-responsive, just error and\ntell the user \"payment failed\"\n  + If connected to the paymentURI and payment sent, but disconnected\nbefore receiving a response, then try to send-to-self the coins to\ncancel payment.\n\nAgain, I'm not at all sure that is the best way to handle it;\nimplementors have the right incentives to give their users the best\nuser experience, so I feel comfortable leaving the spec fuzzy for now.\n\n-- \n--\nGavin Andresen"
            },
            {
                "author": "Roy Badami",
                "date": "2012-11-29T17:07:13",
                "message_text_only": "I'd still like to understand the rationale for having the merchant\nbroadcast the transaction - it seems to add complexity and create edge\ncases.\n\nHow about this as an alternative proposal:\n\nThe buyer's client prepares the transaction and computes its txid.  It\nthen sends a ValidatePurchase message to the merchant containing the\nproposed Outputs and a copy of the merchant_data along with the txid.\n\nAssuming the proposed payment is accepted as valid by the merchant,\nthe buyer's client simply broadcasts the pre-prepared transaction in\nthe normal way, and it is the merchant's responsibility to watch for\nthis transaction to arrive over the p2p network/blockchain to complete\nthe purchase.  (So if the merchant rejects the purchase at the\nValidatePurchase stage, they never get to see the transaction that the\nbuyer prepared, and there's therefore no need for a send-to-self to\ncancel it.)\n\nAn optional RequestReceipt message (perhaps containing the\nmerchant_data and txid) can be sent by the client after the\ntransaction has been broadcast - but by making this explicitly\noptional it forces the merchant to rely on seeing the bitcoin\ntransaction to 'commit' the payment and not on the RequestReceipt\nmessage.\n\nAs far as I can see this proposal has no edge cases where the buyer\nand merchant have differing ideas as to whether the transaction has\n'comitted' - or at least, no more edge cases than the standard bitcoin\nprotocol has.\n\nroy"
            },
            {
                "author": "Gavin Andresen",
                "date": "2012-11-29T17:30:33",
                "message_text_only": "On Thu, Nov 29, 2012 at 12:07 PM, Roy Badami <roy at gnomon.org.uk> wrote:\n> I'd still like to understand the rationale for having the merchant\n> broadcast the transaction - it seems to add complexity and create edge\n> cases.\n\nMike Hearn has experimented with in-person payments using\nbluetooth/NFC on a phone, where the merchant has full Internet\nconnectivity but the phone might only be able to connect to the\nmerchant via a Bluetooth/NFC paymentURI.\n\nI think I agree with you, though: if the device DOES have\nbitcoin-p2p-network-connectivity, then expecting the client to\nbroadcast the transaction might be cleaner.\n\nHowever, if a connection to the paymentURI is made and the transaction\ndata has been sent, clients have to deal with the case where the\nmerchant also broadcasts the transaction, no matter what the spec says\nand even if the merchant sends an \"accepted : false\" response.\n\n\n-- \n--\nGavin Andresen"
            },
            {
                "author": "Mike Hearn",
                "date": "2012-11-29T17:31:24",
                "message_text_only": "> I'd still like to understand the rationale for having the merchant\n> broadcast the transaction\n\nThere are several reasons for this:\n\n1) P2P network sockets are a limited resource and bringing up\nconnections to the network, whilst somewhat fast today, is not\nguaranteed to be fast in future. Passing transactions to the merchant\nfor broadcast reduces the load on the P2P nodes because lots of thin\nclients aren't any longer connecting and disconnecting when sending.\nThey only need to talk to the network when the user has received\nmoney.\n\n2) Some users may not have network connectivity at all. For example,\nthis happens quite often whilst traveling at Bitcoin conferences ;)\nThe solution, which Andreas and I prototyped in Berlin together, is\nfor the buyer to communicate only with the seller which can be done\nover Bluetooth or WiFi Direct or some other mobile radio protocol.\nAgain, send only, but for the common case where you load up your\nwallet before setting out and then buy things, it works OK.\n\n4) A longer term reason - in time, people may choose to not broadcast\ntransactions at all in some cases. I think how network speed will be\nfunded post-inflation is still an open question. Assuming the simplest\narrangement where users pay fees, getting transactions into the chain\nhas a cost. In cases where you trust the sender to not double spend on\nyou, you may keep a fee-less transaction around \"in your pocket\". Then\nwhen it's your turn to pay, you use some unconfirmed transactions to\ndo so. People pass around longer and longer chains of un-broadcast\ntransactions until a payment crosses a trust boundary, at which point\nthe receiver adds on their own transaction that spends back to himself\nbut with a fee, and broadcasts them all together as a unit. In this\nway only people who genuinely need to fear double spends pay for\nsecurity."
            },
            {
                "author": "Roy Badami",
                "date": "2012-11-29T19:01:24",
                "message_text_only": "On Thu, Nov 29, 2012 at 06:31:24PM +0100, Mike Hearn wrote:\n> > I'd still like to understand the rationale for having the merchant\n> > broadcast the transaction\n> \n> There are several reasons for this:\n\n[snip]\n\nAll good reasons, thanks for the explanation.\n\nThough I still like my idea of a ValidatePurchase message that allows\na buyer to ask a merchant \"would you accept this payment?\" without\nactually supplying a signed transaction.  Make it optional if you care\nabout minimising the number of round trips, e.g. for fast NFC\npayments.\n\nHaving such a message reduces the extent to which you need to trust\nthe merchant not to spend a transaction that they've rejected.  (And\nin the non-Internet connected case this is particularly useful since\nthe client won't have the ability to broadcast a pay-to-self\ntransaction.)\n\nroy"
            }
        ],
        "thread_summary": {
            "title": "Payment Protocol Proposal: Invoices/Payments/Receipts",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Luke-Jr",
                "Rick Wesson",
                "Gavin",
                "Michael Gronager",
                "slush",
                "Mike Hearn",
                "Walter Stanish",
                "Roy Badami",
                "Peter Todd",
                "Gregory Maxwell",
                "Andy Parkins",
                "Gavin Andresen",
                "Pieter Wuille",
                "Watson Ladd"
            ],
            "messages_count": 53,
            "total_messages_chars_count": 119299
        }
    },
    {
        "title": "[Bitcoin-development] [ANNOUNCE] picocoin and libccoin -- C-based bitcoin library and client",
        "thread_messages": [
            {
                "author": "Jeff Garzik",
                "date": "2012-11-27T20:34:08",
                "message_text_only": "Source code URL:  https://github.com/jgarzik/picocoin/\n\nI'd like to announce another bitcoin implementation, which is really\ntwo useful pieces in one:\n\n     libccoin - a bitcoin library, written in C\n     picocoin - A lightweight, C-based SPV bitcoin wallet client\n\nlibccoin supports all key network datastructures (block, transaction,\netc.), script parsing and validation, transaction and block\nvalidation, a \"headers-only\" or full block database, and many other\nfeatures essential to any bitcoin client.  libccoin passes all key\nencoding, script and transaction tests available in the Satoshi\nreference bitcoin client.\n\npicocoin is much more under construction.  When complete, it will be a\nvery low resource, command line / JSON-driven bitcoin wallet.\nAdvanced security features already implemented include required wallet\nencryption, fork-based process separation of P2P networking and wallet\n(and chroot/SELinux jailing coming soon), something that the reference\nSatoshi client does not even support.\n\nStatus:  Alpha quality, developer release.  Passes reference client\nbase58/script/transaction tests, but is still a developer-only\npreview.\n\nFeature list:\n\n    Intended to be a full-feature bitcoin support library.  The\nlibrary will not be limited to \"what picocoin needs.\"\n    Supports all core data structures and network messages\n    Full script implementation\n    Passes hundreds of available reference client tests\n    Supports multiple block chains: main or testnet3\n    Very low resource usage (cpu, disk, and memory)\n    Small codebase (both source code and compiled object)\n    Supports advanced thin-client features such as \"bloom filtering\",\nan upcoming proposal that will reduce client bandwidth usage.\n    Works on big endian machines, as well as little endian machines\n    Multi-platform: Linux supported currently.  Should work on\nOSX/BSD/Windows with minimal modifications.\n    libccoin should work on Windows.  picocoin will work on Windows,\nbut be a bit less secure than other platforms due to lack of fork.\n    Improved security:  fork-based process separation firewall between\nnetworking and wallet code -- your wallet is never directly exposed to\nthe network.\n    Follows the philosophy of \"do, not hype.\"  This library is already\nfar more secure and capable than other libraries hyped as the \"future\nof bitcoin\" by their authors.\n\nCode contributions are welcome (see github URL above).\nComments are welcome.\nDonations are welcome too (1BrufViLKnSWtuWGkryPsKsxonV2NQ7Tcj).\n\n-- \nJeff Garzik\nexMULTI, Inc.\njgarzik at exmulti.com"
            },
            {
                "author": "Mike Hearn",
                "date": "2012-11-28T11:26:27",
                "message_text_only": "Cool, will check it out soon.\n\n>     libccoin should work on Windows.  picocoin will work on Windows,\n> but be a bit less secure than other platforms due to lack of fork.\n\nFYI, Windows has quite good sandboxing support. You could implement\nthe same thing later with Win32 if you want."
            },
            {
                "author": "Peter Vessenes",
                "date": "2012-11-28T17:29:04",
                "message_text_only": "Jeff,\n\nThis rocks. Thank you!\n\nPeter\n\nOn Wed, Nov 28, 2012 at 3:26 AM, Mike Hearn <mike at plan99.net> wrote:\n\n> Cool, will check it out soon.\n>\n> >     libccoin should work on Windows.  picocoin will work on Windows,\n> > but be a bit less secure than other platforms due to lack of fork.\n>\n> FYI, Windows has quite good sandboxing support. You could implement\n> the same thing later with Win32 if you want.\n>\n>\n> ------------------------------------------------------------------------------\n> Keep yourself connected to Go Parallel:\n> INSIGHTS What's next for parallel hardware, programming and related areas?\n> Interviews and blogs by thought leaders keep you ahead of the curve.\n> http://goparallel.sourceforge.net\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n\n\n\n-- \n------------------------------\n\n[image: CoinLab Logo]PETER VESSENES\nCEO\n\n*peter at coinlab.com * /  206.486.6856  / SKYPE: vessenes\n811 FIRST AVENUE  /  SUITE 480  /  SEATTLE, WA 98104\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20121128/f02d5160/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "picocoin and libccoin -- C-based bitcoin library and client",
            "categories": [
                "Bitcoin-development",
                "ANNOUNCE"
            ],
            "authors": [
                "Jeff Garzik",
                "Peter Vessenes",
                "Mike Hearn"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 4132
        }
    },
    {
        "title": "[Bitcoin-development] Crowdfunding Bitcoin development on FreedomSponsors",
        "thread_messages": [
            {
                "author": "Tony Fran\u00e7a",
                "date": "2012-11-28T20:24:58",
                "message_text_only": "Howdy everyone.\n\nThis is my first post on this lits, so please allow me to introduce myself.\nI'm Tony, 31, software engineer, brazilian.\nMore about myself here <http://tonylampada.blogspot.com.br/> and\nhere<http://dicasdolampada.wordpress.com/>\n.\n\nI'm reaching out to this list because I've built a free software\ncrowdfunding platform that you might find interesting/useful.\n\nIt's called FreedomSponsors - will you please take a look?\n- http://www.freedomsponsors.org\n- http://blog.freedomsponsors.org/\n\nFS lets people place money bounties on issues of open source projects.\n(like bitcoins issues listed at https://github.com/bitcoin/bitcoin/issues). If\nmore people have the same needs, they can \"chip in\" on that offer. Payments\nare made directly to developer *after* the issue has been resolved (no\nescrows involved).\n\nRight now, the only supported payment option is Paypal, but I'm already\nworking on enabling the use of Bitcoin both as a currency and a payment\noption.\n\nSo, if you like it, feel free to use it, and maybe even contribute to it\n(which is *very* welcome) - it's open source on Github -\nhttps://github.com/freedomsponsors.\nIf you have any feedback, I'm happy to hear about it.\n\nThanks!\nTony L\u00e2mpada\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20121128/17d828a7/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Crowdfunding Bitcoin development on FreedomSponsors",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Tony Fran\u00e7a"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1398
        }
    }
]