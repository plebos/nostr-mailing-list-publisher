[
    {
        "title": "[Bitcoin-development] BIP: Voluntary deposit bonds",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2015-01-03T03:48:29",
                "message_text_only": "On Mon, Dec 29, 2014 at 04:21:02PM -0300, Sergio Lerner wrote:\n> I propose to allow miners to voluntarily lock funds by letting miners\n> add additional inputs to the coinbase transaction. Currently the\n> coinbase transaction does not allow any real input  to be added (only a\n> pseudo-input).\n> This is a hard-fork, and we could include it the next time a hardfork is\n> made.\n> The modifications to the code are minimal (no more than 12 lines\n> modified where IsCoinBase() is called), and they generally involve\n> removing code, not adding.\n> \n> Why ?\n> \n> Because sometime in the future (maybe 5-10 years) we may have to deal\n> with problems of securing the blockchain, as the subsidy is lowered. We\n> don't want the number of confirmation blocks to be increased in\n> compensation because Bitcoin won't be able to compete with other payment\n> networks.\n> Then by having this hardfork now, we will be able to soft-fork later to\n> any rule we may came come up with involving deposit bonds,\n> proof-of-stake, and the penalization of double-mining (mining two blocks\n> at the same height) to prevent short-range attacks.\n> \n> Can it hurt?\n> \n> No. I doesn't not change the incentives or the security in any way, as\n\nIt definitely does change the incentives as it makes it easy and secure\nto pay miners to mine specific blocks rather than specific transactions.\nFor instance I could securely pay a miner to mine a re-org in a specific\nway, something I can't do right now. From the perspective of \"the\nblockchain must move forward\" this is worrying. I have proposed this\nidea before myself for my PowPay(1) micropayments scheme, but on\nreflection I don't think it's a good idea anymore.\n\nPowPay in general is an idea I'm now rather dubious about: it works much\nbetter with large mining pools, which would further incentivise pools to\nget bigger. In general we want mining to be dumber, not smarter, to keep\nthe overhead of it as small as possible to getting into it is as easy as\npossible.\n\nre: hard-fork vs. soft-fork, Gregory Maxwell's comments elsewhere in the\nthread are what I'd say myself.\n\n1) [Bitcoin-development] Coinbase TxOut Hashcash,\n   Peter Todd, May 10th 2013,\n   http://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg02159.html\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000008bb7f424d81b7a0ea568086f4d320c2867705f88c27bb0a\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 650 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150102/f46b00e9/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "BIP: Voluntary deposit bonds",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Peter Todd"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2632
        }
    },
    {
        "title": "[Bitcoin-development] Re-enabling simple tx replacement",
        "thread_messages": [
            {
                "author": "Ross Nicoll",
                "date": "2015-01-04T14:43:05",
                "message_text_only": "Dear all,\n\nI've been looking at atomic cross-chain trading (\nhttps://en.bitcoin.it/wiki/Atomic_cross-chain_trading ) between the\nBitcoin and Dogecoin blockchains, and have a mostly functional\nprototype. However as it stands if the refund transaction is relayed\nbefore the actual spend transaction, it \"blocks\" the legitimate spend\ntransaction from being accepted into the memory pool.\n\nI'd like to enable TX replacement in the case where all conflicting\ntransactions are not final, and the replacement is final. While yes,\nthis still leaves scope for \"unpaid for\" bandwidth, hopefully being able\nto do a single replacement isn't a major issue.\n\nFor those wanting background on this,\nhttps://github.com/bitcoin/bitcoin/pull/2516 may be useful reading.\n\nI've drafted a patch for this\nhttps://github.com/rnicoll/bitcoin/commit/e668d36607f008990ccaac7275e463a6efdd9b5a\nbut have not yet raised a PR, as historically this has lead to a lot of\ndiscussion in Github which is better suited to this mailing list.\n\nI'm therefore looking for feedback while I continue testing that patch,\nand any comments would be welcomed.\n\nRoss"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2015-01-04T17:04:24",
                "message_text_only": "On Sun, Jan 4, 2015 at 2:43 PM, Ross Nicoll <jrn at jrn.me.uk> wrote:\n> Dear all,\n>\n> I've been looking at atomic cross-chain trading (\n> https://en.bitcoin.it/wiki/Atomic_cross-chain_trading ) between the\n> Bitcoin and Dogecoin blockchains, and have a mostly functional\n> prototype. However as it stands if the refund transaction is relayed\n> before the actual spend transaction, it \"blocks\" the legitimate spend\n> transaction from being accepted into the memory pool.\n\nUnless there is a serious bug that I am not aware of this is not the\ncase. The unlocked transaction is not relayable and will not be\nmempooled (well, until right before it locks).\n\n> I've drafted a patch for this\n> https://github.com/rnicoll/bitcoin/commit/e668d36607f008990ccaac7275e463a6efdd9b5a\n> but have not yet raised a PR, as historically this has lead to a lot of\n> discussion in Github which is better suited to this mailing list.\n>\n> I'm therefore looking for feedback while I continue testing that patch,\n> and any comments would be welcomed.\n\nThis appears to have absolutely no protection against denial of\nservice, it seems to me that a single user can rapidly update their\ntransaction and exhaust the relay bandwidth of the entire network."
            },
            {
                "author": "Ross Nicoll",
                "date": "2015-01-04T17:22:11",
                "message_text_only": "On 04/01/15 17:04, Gregory Maxwell wrote:\n> On Sun, Jan 4, 2015 at 2:43 PM, Ross Nicoll <jrn at jrn.me.uk> wrote:\n>> Dear all,\n>>\n>> I've been looking at atomic cross-chain trading (\n>> https://en.bitcoin.it/wiki/Atomic_cross-chain_trading ) between the\n>> Bitcoin and Dogecoin blockchains, and have a mostly functional\n>> prototype. However as it stands if the refund transaction is relayed\n>> before the actual spend transaction, it \"blocks\" the legitimate spend\n>> transaction from being accepted into the memory pool.\n> \n> Unless there is a serious bug that I am not aware of this is not the\n> case. The unlocked transaction is not relayable and will not be\n> mempooled (well, until right before it locks).\n\nGrabbing a simple test case:\nhttps://chain.so/tx/BTCTEST/f903a31f2474df737d324c60abf2407e1cf7e052844da4ccffbfab81cf6ac1f8\n- that won't lock until 0028 UTC on the 5th.\n\nI've tried closing the wallet, moving the wallet.dat file out of the\nway, and then attempting the spend transaction (which can be locked\nimmediately), and it either rejects it on acceptance to mempool, or it\nis never included in a block.\n\nCompare with\nhttps://chain.so/tx/BTCTEST/0b96eb0c9bf8a6ca08bb9d75e44970889db77779c6d3122296c0169959f979cc\nwhere the refund was not sent first, and the transaction has succeeded.\n\n>> I've drafted a patch for this\n>> https://github.com/rnicoll/bitcoin/commit/e668d36607f008990ccaac7275e463a6efdd9b5a\n>> but have not yet raised a PR, as historically this has lead to a lot of\n>> discussion in Github which is better suited to this mailing list.\n>>\n>> I'm therefore looking for feedback while I continue testing that patch,\n>> and any comments would be welcomed.\n> \n> This appears to have absolutely no protection against denial of\n> service, it seems to me that a single user can rapidly update their\n> transaction and exhaust the relay bandwidth of the entire network.\n> \n\nThey can only replace a non-final transaction with a final transaction,\nso the replacement can happen at most once (any later replacement would\nbe attempting to replace a final transaction, and therefore fails). So,\nwhile they can expend twice the bandwidth compared to a non-replacement,\nI don't think that's a major issue?"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2015-01-04T17:35:37",
                "message_text_only": "On Sun, Jan 4, 2015 at 5:22 PM, Ross Nicoll <jrn at jrn.me.uk> wrote:\n> Grabbing a simple test case:\n> https://chain.so/tx/BTCTEST/f903a31f2474df737d324c60abf2407e1cf7e052844da4ccffbfab81cf6ac1f8\n> - that won't lock until 0028 UTC on the 5th.\n>\n> I've tried closing the wallet, moving the wallet.dat file out of the\n> way, and then attempting the spend transaction (which can be locked\n> immediately), and it either rejects it on acceptance to mempool, or it\n> is never included in a block.\n\nCan you send me the actual raw transaction (that site doesn't appear\nhave a way to get it, only some cooked json output; which doesn't\ninclude the sequence number).\n\nAs I said, it's a severe bug if unlocked transactions are being\nrelayed or mempooled far in advance.\n\n> They can only replace a non-final transaction with a final transaction,\n\nAh I missed that the replacement had to be final. Thats indeed a much\nmore sane thing to do than I was thinking (sorry for some reason I saw\nthe +1 and thought it was just checking the sequence number was\nhigher.)\n\n> I don't think that's a major issue?\n\nIf they can relay the first one to begin with its an an issue, the\nreplacement just makes it twice an issue. :)"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2015-01-04T17:44:59",
                "message_text_only": "On Sun, Jan 4, 2015 at 5:35 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n> Can you send me the actual raw transaction (that site doesn't appear\n> have a way to get it, only some cooked json output; which doesn't\n> include the sequence number).\n\nNevermind, I guess. I think I figured out your problem: The behaviour\non testnet is busted because the non-mempooling is enforced by\nIsStandardTx which is bypassed in testnet. We should enforce that\nelsewhere.\n\nThis isn't the case on the real network."
            },
            {
                "author": "Peter Todd",
                "date": "2015-01-04T17:47:36",
                "message_text_only": "On Sun, Jan 04, 2015 at 05:44:59PM +0000, Gregory Maxwell wrote:\n> On Sun, Jan 4, 2015 at 5:35 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n> > Can you send me the actual raw transaction (that site doesn't appear\n> > have a way to get it, only some cooked json output; which doesn't\n> > include the sequence number).\n> \n> Nevermind, I guess. I think I figured out your problem: The behaviour\n> on testnet is busted because the non-mempooling is enforced by\n> IsStandardTx which is bypassed in testnet. We should enforce that\n> elsewhere.\n> \n> This isn't the case on the real network.\n\nYup.\n\nI have a pull-req open to fix this:\n\nhttps://github.com/bitcoin/bitcoin/pull/5521\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000000237ec84e4b02efbdf3bcbf62308c873da802caedd12432f\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 650 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150104/f83dab5f/attachment.sig>"
            },
            {
                "author": "Ross Nicoll",
                "date": "2015-01-04T18:11:52",
                "message_text_only": "On 04/01/15 17:44, Gregory Maxwell wrote:\n> On Sun, Jan 4, 2015 at 5:35 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n>> Can you send me the actual raw transaction (that site doesn't appear\n>> have a way to get it, only some cooked json output; which doesn't\n>> include the sequence number).\n> \n> Nevermind, I guess. I think I figured out your problem: The behaviour\n> on testnet is busted because the non-mempooling is enforced by\n> IsStandardTx which is bypassed in testnet. We should enforce that\n> elsewhere.\n> \n> This isn't the case on the real network.\n> \n\nAh, thanks for that.\n\nI'll try Peter's patch for testnet tomorrow, sounds like it should fix\nthis for my use case."
            },
            {
                "author": "Gregory Maxwell",
                "date": "2015-01-04T18:31:12",
                "message_text_only": "On Sun, Jan 4, 2015 at 6:11 PM, Ross Nicoll <jrn at jrn.me.uk> wrote:\n> Ah, thanks for that.\n>\n> I'll try Peter's patch for testnet tomorrow, sounds like it should fix\n> this for my use case.\n\nThanks for presenting your solution as code in any case. In spite of\nthe fact that I gave it a crappy read this time, it really is a useful\nway to communicate and I wish more people did that."
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2015-01-04T23:06:13",
                "message_text_only": "On Sun, Jan 4, 2015 at 7:31 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n> Thanks for presenting your solution as code in any case. It really is a useful\n> way to communicate and I wish more people did that.\n\n+1"
            },
            {
                "author": "Ross Nicoll",
                "date": "2015-01-04T17:45:01",
                "message_text_only": "On 04/01/15 17:35, Gregory Maxwell wrote:\n> On Sun, Jan 4, 2015 at 5:22 PM, Ross Nicoll <jrn at jrn.me.uk> wrote:\n>> Grabbing a simple test case:\n>> https://chain.so/tx/BTCTEST/f903a31f2474df737d324c60abf2407e1cf7e052844da4ccffbfab81cf6ac1f8\n>> - that won't lock until 0028 UTC on the 5th.\n>>\n>> I've tried closing the wallet, moving the wallet.dat file out of the\n>> way, and then attempting the spend transaction (which can be locked\n>> immediately), and it either rejects it on acceptance to mempool, or it\n>> is never included in a block.\n> \n> Can you send me the actual raw transaction (that site doesn't appear\n> have a way to get it, only some cooked json output; which doesn't\n> include the sequence number).\n> \n> As I said, it's a severe bug if unlocked transactions are being\n> relayed or mempooled far in advance.\n\nAttached. Sequence number for the input is set to 1, please do tell me\nif I've misunderstood how it's used.\n\n>> They can only replace a non-final transaction with a final transaction,\n> \n> Ah I missed that the replacement had to be final. Thats indeed a much\n> more sane thing to do than I was thinking (sorry for some reason I saw\n> the +1 and thought it was just checking the sequence number was\n> higher.)\n> \n>> I don't think that's a major issue?\n> \n> If they can relay the first one to begin with its an an issue, the\n> replacement just makes it twice an issue. :)\n> \n\nI'll set up a few nodes tomorrow and double check it's in fact relaying\nin the latest version. If it's simply an issue of incorrect relaying,\nthat's significantly simpler at least, and the problem can be tackled\nthrough that instead.\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: f903a31f2474df737d324c60abf2407e1cf7e052844da4ccffbfab81cf6ac1f8.hex\nType: text/x-hex\nSize: 606 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150104/4c954510/attachment.bin>"
            }
        ],
        "thread_summary": {
            "title": "Re-enabling simple tx replacement",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jorge Tim\u00f3n",
                "Gregory Maxwell",
                "Ross Nicoll",
                "Peter Todd"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 10539
        }
    },
    {
        "title": "[Bitcoin-development] The relationship between Proof-of-Publication and Anti-Replay Oracles",
        "thread_messages": [
            {
                "author": "joliver at airmail.cc",
                "date": "2015-01-06T11:03:47",
                "message_text_only": "On 2014-12-22 00:11, Peter Todd wrote:\n> On Sat, Dec 20, 2014 at 09:48:01AM -0500, Peter Todd wrote:\n> The classic \"proof-of-publication\" system is to embed opaque data (as\n> far as bitcoin miners are concerned) in transactions using OP_RETURN.\n> A significance of establishing \"proof-of-publication\" as a universal\n> underlying primitive is that this OP_RETURN trick is then sufficient\n> for anything you might want. But part of what Bitcoin provides is\n> indexing and validation/exclusion, and this is important for\n> supporting efficient anti-replay proofs. Proof-of-(non)-publication\n> alone isn't sufficient for this.\n\nAre we going to get an answer to this or Adam Back's critique? Doesn't \nsound like this so-called \"proof-of-publication\" actually works \naccording to the experts. Is it an concept anyone but Peter Todd \nactually believes in?"
            }
        ],
        "thread_summary": {
            "title": "The relationship between Proof-of-Publication and Anti-Replay Oracles",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "joliver at airmail.cc"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 848
        }
    },
    {
        "title": "[Bitcoin-development] A look back and a look forward",
        "thread_messages": [
            {
                "author": "21E14",
                "date": "2015-01-08T18:36:29",
                "message_text_only": "Alex Daley recently stated that \"one of the problems with Bitcoin is that\nit takes us backwards in the transaction chain. Suddenly, you're dealing\nwith something that's much more cash-like. If Target had been hacked, and\ninstead of using credit-cards, what was stolen from them were actually\nbitcoins, that they have been storing Bitcoin addresses in their systems\nand those systems were compromised, Target wouldn't just have a PR\nnightmare in their hands. They would be out of business.\"\n\nOf course, it needn't be Target. The scenario has played out with a number\nof exchanges, and is a sword of Damocles hanging over the cryptocurrency\nspace. The recent Winklevoss Bitcoin Trust SEC filing warns that \"the\nTrust\u2019s bitcoins may be subject to loss, damage, theft or restriction on\naccess. There is a risk that part or all of the Trust\u2019s bitcoins could be\nlost, stolen or destroyed. The Sponsor believes that the Trust\u2019s bitcoins\nheld in the Trust Custody Account will be an appealing target to hackers or\nmalware distributors seeking to destroy, damage or steal the Trust\u2019s\nbitcoins. Although the Security System\u2019s design includes various elements,\nsuch as redundancy, segregation and cold storage, to minimize the risk of\nloss, damage and theft, neither the Custodian nor the Sponsor can guarantee\nthat the Security System will prevent such loss, damage or theft...\"\n\nThis needn't be so, once an optional identity layer, modeled after the\nInternet itself, is provided, as proposed in late August of last year on\nthis mailing list:\n\nhttp://sourceforge.net/p/bitcoin/mailman/message/32737796/\nhttp://sourceforge.net/p/bitcoin/mailman/message/32742809/\n\nI hope it is apparent that this is the killer app folks have been searching\nfor in vain. Like its Internet analogues, BCIs will not be created\novernight and without collaboration - and TNABC is as good a place as any\nfor it.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150108/964d2eef/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2015-01-09T14:00:59",
                "message_text_only": ">\n> This needn't be so, once an optional identity layer, modeled after the\n> Internet itself, is provided, as proposed in late August of last year on\n> this mailing list\n>\n\nI think the observation about Target vs Bitcoin exchanges is a sharp one,\nbut I'm not sure how your proposal helps. You say it's an optional identity\nlayer, but obviously any thief is going to opt out of being identified.\n\nFor things like the Bitstamp hack, it's not clear how identity can help,\nbecause they were already doing KYC for all their customers. To take that\nfurther at the protocol level would require* all* transactions to have\nattached identity info, and that isn't going to happen - it wouldn't be\nBitcoin, at that point.\n\nI think that long term, it's probably possible to defend private keys\nadequately, even for large sums of money (maybe not bitstamp-large but\nwe'll see). You can have very minimalist secure hardware that would have\nsome additional policies on top, like refusing to sign transactions without\nan identity proof of who controls the target address. Very tight hot\nwallets that risk analyse the instructions they're receiving have been\nproposed years ago.\n\nNo such hardware presently exists, but that's mostly because\nimplementations always lag behind a long way behind ideas rather than any\nfundamental technical bottleneck. Perhaps the Bitstamp event will finally\nspur development of such things forward.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150109/bf8adcd6/attachment.html>"
            },
            {
                "author": "21E14",
                "date": "2015-01-09T19:36:18",
                "message_text_only": "> I think the observation about Target vs Bitcoin exchanges is a sharp one,\n> but I'm not sure how your proposal helps. You say it's an optional\nidentity\n> layer, but obviously any thief is going to opt out of being identified.\n\nLet me translate it to this year's vocabulary. Think of BCIs as a\nsidechain: let the legacy financial system migrate, to the extent desired,\nto a more heavily regulated pegged sidechain with a stronger identity\nlayer. Let protocol-level rules regulate this nexus between the custodial\n(sidechain) and non-custodial address spaces (blockchain). This isn't\nentirely unlike the rules currently governing coin issuance i.e. coinbase\ntransactions. Let the market forces play it out. Iterate as needed. I\nsuspect that in retrospect it'll seem obvious. Many moons from now the\nbalance might shift between the two, but it won't matter much. The system\nwill have means to recover from catastrophic failure modes.\n\nTo help internalize such an evolution, please consider the layers the\nBitcoin protocol builds on top of: segment 52:32 (\"The Internet is being\nupgraded\") of the BBC documentary \"Inside The Dark Web\" (\nhttps://www.youtube.com/watch?v=qXajND7BQzk#t=3152). Kaspersky's comments a\nfew minutes earlier (50:06) aren't entirely out of context here either.\nClearly, the need is acute for Bitcoin to become institutional i.e. for\n\"billions of dollars of human value\" to flow through it, as one Money 20/20\nparticipant put it.\n\n\nOn Fri, Jan 9, 2015 at 2:00 PM, Mike Hearn <mike at plan99.net> wrote:\n\n> This needn't be so, once an optional identity layer, modeled after the\n>> Internet itself, is provided, as proposed in late August of last year on\n>> this mailing list\n>>\n>\n> I think the observation about Target vs Bitcoin exchanges is a sharp one,\n> but I'm not sure how your proposal helps. You say it's an optional identity\n> layer, but obviously any thief is going to opt out of being identified.\n>\n> For things like the Bitstamp hack, it's not clear how identity can help,\n> because they were already doing KYC for all their customers. To take that\n> further at the protocol level would require* all* transactions to have\n> attached identity info, and that isn't going to happen - it wouldn't be\n> Bitcoin, at that point.\n>\n> I think that long term, it's probably possible to defend private keys\n> adequately, even for large sums of money (maybe not bitstamp-large but\n> we'll see). You can have very minimalist secure hardware that would have\n> some additional policies on top, like refusing to sign transactions without\n> an identity proof of who controls the target address. Very tight hot\n> wallets that risk analyse the instructions they're receiving have been\n> proposed years ago.\n>\n> No such hardware presently exists, but that's mostly because\n> implementations always lag behind a long way behind ideas rather than any\n> fundamental technical bottleneck. Perhaps the Bitstamp event will finally\n> spur development of such things forward.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150109/aa8619e3/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "A look back and a look forward",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Mike Hearn",
                "21E14"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 6818
        }
    },
    {
        "title": "[Bitcoin-development] Bi-directional micropayment channels with CHECKLOCKTIMEVERIFY",
        "thread_messages": [
            {
                "author": "Nathan Cook",
                "date": "2015-01-09T11:40:53",
                "message_text_only": "A limitation on most existing micropayment channel ideas is that payments\ncan only flow in one direction. This is because the payment receiver can\nsign -any- transaction you send them, not just the most recent one, and so\nit's possible to just sign the transaction transferring the largest amount\ninto their control. This is easily remedied by opening a second payment\nchannel in the opposite direction, but now both parties have to deposit\nfunds over the lifetime of the two channels. If one party doesn't know\nahead of time whether or not the other party will go into credit, having\nonly one channel may save the use of a deposit.\n\nI propose a way of using CHECKLOCKTIMEVERIFY to allow a reversible payment\nchannel, introducing at most one additional broadcast transaction, with a\nwaiting period before the payment receiver can access deposited funds. The\nextra transaction and waiting period apply only when the depositor doesn't\nco-operate with the receiver.\n\nIn this protocol, the setup is identical, with a deposit made to a P2SH\naddress matching a script allowing either single-party+CHECKLOCKTIME or\n2-of-2. In this case, however, payments made by the depositor occur in the\nform of unbroadcast transactions to special -holding addresses-.\n\nThese holding addresses are themselves P2SH addresses, with scripts known\nto both parties. Each script may be redeemed in one of two ways:\nby the payment receiver, using their signature with a CHECKLOCKTIME\nrestriction that expires some period of time after the restriction on the\ndepositor's refund transaction, or\nby the depositor, using their own signature, together with a hashlock.\n\nIn the second case, we actually use a double hashlock, i.e. the depositor\nmust provide a value which when SHA256-hashed twice produces the value in\nthe script.\n\nThe receiver generates these values according to the following algorithm:\nBeginning with a secret S_0, they double hash S_0 to make the hashlock\nvalue for the first payment, D_0 =H(H(S_0)). Then to make S_i+1 given S_i,\nthey create a public nonce, N_i, and let S_i+1 = H(N_i | H(S_i)), where a|b\ndenotes the string a followed by the string b. The hashlock values D_i are\nnot secret, and can be disclosed in advance or as part of the process of\nreceiving the associated payment.\n\nWhen the receiver wants to refund some amount to the depositor, the\nreceiver finds the last payment which left the depositor with a balance\n-greater- than the desired balance, and negotiates a rewind of the payment\nsequence to that point, with an additional payment of the remainder by the\ndepositor. Suppose the last payment that will remain valid was the i-th\npayment, counting from zero. The receiver creates a new nonce, N'_i,\ncreates the associated new secret value S'_i+1 by S'_i+1 = H(N'_i |\nH(S_i)), and sends D'_i+1 to the depositor with a request for payment of\nthe right amount. This amount will be greater than that associated to D_i,\nbut less than that associated to D_i+1, so the depositor does not need to\ntrust the receiver in order to honour the request. The payment chain is now\nforked at D_i, with a branch D_i+1, D_i+2... and a branch that only has\nD'_i+1. The receiver now unwinds the old branch, back to D_i, by revealing\nS_i+1 to the depositor. The depositor can now generate - and check - the\nsecrets S_i+1, S_i+2..., and so knows that if the receiver attempts to sign\nand broadcast a transaction to an address using one of those secrets, the\ndepositor can take back all their funds before the receiver is able to put\ntheir own (CHECKLOCKTIME restricted) transaction from that address on the\nblockchain. Now the best usable payment to the receiver is the one\nassociated to D'_i+1.\n\nWhen the two parties want to close the payment channel, one party signs a\ntransaction from the deposit address to whatever addresses are desired, and\nsends the transaction to the other party to add their own signature and\npublish. This avoids either party having to wait for CHECKLOCKTIME\nrestrictions to expire. If either party abandons the protocol at this\npoint, the other can use the CHECKLOCKTIME restrictions to ensure they get\nat least as much as they would if both cooperated. Note that the holding\naddresses are only used on the blockchain when the protocol is abandoned.\n\nThis protocol does not deal with the case of malicious attacks on a party's\nnetwork connection, which could keep them offline until CHECKLOCKTIME has\nexpired. This is something that each party should consider when choosing\nhow long the restrictions should be in place for. The protocol improves on\nblueadept's use of a new nLockTime for each reverse payment[1], by keeping\nthe wait time independent of the number of payments, and not requiring\neither party to predict ahead of time how many payments will occur.\n\nA note on generating hashlock secrets: the protocol works perfectly well\nwithout generating them deterministically. Using an HMAC-style derivation\nis more of a convenience than anything else - it saves storing and\ntransmitting all the secrets when a chain needs to be invalidated - but it\ndoes encode the fact that the addresses form a chain into the addresses'\nscripts, which is a nice property to have.\n\n[1] https://bitcointalk.org/index.php?topic=814770.msg9185225#msg9185225\n\nI first posted this at https://bitcointalk.org/index.php?topic=918018.0 and\nhave edited it slightly for posting on this list. Thanks to Peter Todd for\nthe suggestion to submit it here for review.\n\nNathan Cook\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150109/dc18ce68/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2015-01-09T13:20:07",
                "message_text_only": ">\n> A limitation on most existing micropayment channel ideas is that payments\n> can only flow in one direction.\n>\n\nIt's worth noting that the original protocol as designed by Satoshi did not\nhave this limitation. It has evolved this way because of ad-hoc DoS fixes\nover time (btw I'm not saying they were the wrong thing to do, as non \"ad\nhoc\" solutions are significantly more work). But it seems like eventually a\ndifferent approach to handling DoS attacks based on resource prioritisation\nand scheduling will become needed / implemented, and at that point the\noriginal design could be safely brought back to life.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150109/dee4f22b/attachment.html>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2015-01-09T13:22:00",
                "message_text_only": "Mike, Can you be more specific?  You reference \"original design\" without\nsaying how it was different/better.\n\n\n\nOn Fri, Jan 9, 2015 at 8:20 AM, Mike Hearn <mike at plan99.net> wrote:\n\n> A limitation on most existing micropayment channel ideas is that payments\n>> can only flow in one direction.\n>>\n>\n> It's worth noting that the original protocol as designed by Satoshi did\n> not have this limitation. It has evolved this way because of ad-hoc DoS\n> fixes over time (btw I'm not saying they were the wrong thing to do, as non\n> \"ad hoc\" solutions are significantly more work). But it seems like\n> eventually a different approach to handling DoS attacks based on resource\n> prioritisation and scheduling will become needed / implemented, and at that\n> point the original design could be safely brought back to life.\n>\n>\n>\n> ------------------------------------------------------------------------------\n> Dive into the World of Parallel Programming! The Go Parallel Website,\n> sponsored by Intel and developed in partnership with Slashdot Media, is\n> your\n> hub for all things parallel software development, from weekly thought\n> leadership blogs to news, videos, case studies, tutorials and more. Take a\n> look and join the conversation now. http://goparallel.sourceforge.net\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150109/d9790647/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2015-01-09T13:42:52",
                "message_text_only": "The original design is documented at the bottom of here:\n\nhttps://en.bitcoin.it/wiki/Contracts#Example_7:_Rapidly-adjusted_.28micro.29payments_to_a_pre-determined_party\n\nIn this design, time locked transactions can be broadcast across the\nnetwork and replaced by broadcasting a new transaction that uses higher\nsequence numbers. That's what the sequence number field is for. It was\nintended to allow arbitrary high frequency trading between a set of\nparties, though the \"channel\" notion is a simple way to think about the two\nparty case.\n\nThe issue is that you can broadcast transactions with a lock time far in\nthe future to fill up memory, and keep broadcasting replacements to use up\nCPU time and bandwidth.\n\nAdditionally, there is a school of thought that says Bitcoin must work even\nif lots of miners are malicious and willing to break arbitrary things in\norder to try and get more money. I don't think Bitcoin can really be a\nmainstream success under such a threat model, for a whole bunch of reasons\n(e.g. the economy relies pretty heavily on unconfirmed transactions), but\nunder such a threat model there's nothing that forces miners to actually\ninclude the latest version in the block chain. They could pick any version.\nIn the 2-of-2 channel model it takes both parties to sign, so clients can\nenforce that all versions have the same fee attached.\n\nI disagree with Gregory that people refuse to use protocols that are\naffected by malleability. There aren't any user-friendly apps that use\nrefunds currently, so we have no idea whether people would refuse to use\nthem or not. It's an open question. The answer would probably depend on the\nreal prevalence of attacks, which is currently unknowable and likely\napplication specific.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150109/0e36b48d/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2015-01-09T14:50:09",
                "message_text_only": "On Fri, Jan 9, 2015 at 1:42 PM, Mike Hearn <mike at plan99.net> wrote:\n> Additionally, there is a school of thought that says Bitcoin must work even\n> if lots of miners are malicious and willing to break arbitrary things in\n> order to try and get more money. I don't think Bitcoin can really be a\n\nThis being unsafe doesn't require \"a lot\" though, if 1% of the\nhashpower is naughty, an attacker will have a 1% success rate. Naughty\ncan also just mean broken in various ways, like mining while somewhat\npartitioned (didn't hear the update) potentially due to a DOS attack,\nor because of some garbage collection policy made it forget the\ntransaction to conserve resources.  An unkind user can simply run\nsoftware that automatically attempts (by sending naughty miners an\nearlier conflict right before the locktime expires).  \"Use Blue\nRewards wallet for 2% cash back for all the Bitcoin purchases you make\nonline!\" :P\n\nOf course, all the miners who don't play along will very much see how\nmuch income they're missing.\n\n> so clients can enforce that all versions have the same fee attached\n\nSadly, they cannot.  This is why I specifically mentioned child pays for parent.\n\nIn any case,  sometimes a 1% fault rate is acceptable. But generally\nfor cases that they are, even weaker constructs (e.g. no payment\nchannel at all, just accept an IOU) are also often acceptable, and\ncannot be modulated in their success by resource starvation attacks on\nthe network.\n\nWe have objective proof of substantial miners behaving maliciously,\nthat much isn't a speculative concern.\n\nThe school of thought view is a bit too black and white. My\nperspective is that absolute soundness is best (rules which cannot be\nbroken at all), followed by cryptographic soundness (rules that\nbreaking requires P=NP, theft of a secret, or insane luck), followed\nby economic soundness (rules that cannot be profitably broken),\nfollowed by honesty soundness (rules that hold when the participants\nfollow the rules and aren't faulty).  We should try to move up that\nstack as far towards absolutely soundness as possible; and be\nincreasingly cautious about compromises as we move down it espeically\nbecause the last two are unstable and difficult to reason about\nbecause they strongly import the vulgarities of humanity into the\nsecurity model.   If we could make the whole system absolutely sound\nor cryptographically sound, I would think we should (and would) even\nif it implied other compromises. But we can't and so users of Bitcoin\nmust navigate this risk stack.\n\nOne thing that I think you miss in this argument is that one man's\nintegrity is another man's malice.  The history of security and\nprivacy is filled with instances where someone's trust was violated\nbecause there someone was, rightly or wrongly, convinced that Some\nReason was Good Enough to justify it. Because of this a risk analysis\nhas to import the clarity of judgement, morality, coerceability,\npersonal values, etc. of everyone in the trust chain; and many of\nthese things are unknowable; this greatly increases the costs of\ntransacting, and the efforts to mitigate those costs (and the failures\nto remove the harms) result in an unequitable enviroment where some\npeople get unjust rewards and unequal access to justice. The gain from\ncryptographic tools is being able to make some level of stronger\nassurances which cut out most of that trust, they're predictable,\n'cheap' on a marginal basis, and fair in a fundamental sense (in\ntheory everyone has equal access to math).  So, while I could even buy\nthe argument that miners will never believe themselves to be \"actually\nmalicious\", history shows that people's ability to convince themselves\nof the justification of something is basically unbounded, even\noutright thieves often believe they're owed their spoils-- and there\nare a lot of ways to misbehave in Bitcoin that stop short of theft.\nAnd so, where we cannot have cryptographic security enforce the rules,\nwe-- those who use and depend on Bitcoin-- _generally_ ought to behave\nin ways that cannot be harmed by a failure to follow the rules so that\nwe don't _invite_ failures to follow the rules and thereby create an\ninstitution of it.\n\nOf course, all things equal I don't want to choose for other people\nwhat tools they can use and what risks they take. But in the case of\nrelaying locked transactions this isn't an otherwise neutral choice: A\nstraight forward \"relay and store any locked spend\" policy has\nunbounded space and communications complexity.  It's not clear to me\nthat if any real degree of \"you can take your risks, it'll probably\nwork, but maybe not\" can be supported without a very large resource\ncost to the network, and without creating incentives to DOS attack the\nnetwork (e.g. to make it forget previous spends).  It may be that\nthere is some set of constraints that actually do make it workable and\ndon't create the incentives though... meaning that it may _merely_ be\nunsafe for people who choose to use it. If so, then it might be\nreasonable but we also cannot ignore the incentives it creates in a\nwider ecosystem and what their ultimate conclusion might be. E.g. If\nyou put a bounty for miners to behave 'wrong' in a way the system\ncannot prevent, some will. Is the next step to try to say that only\n\"good\" miners can mine?   If so, how many more steps until every\ntransaction is being tested against a set of system external goodness\ncriteria?  In that state, is Bitcoin any better than a very\ncomputationally and bandwidth inefficient version of Paypal?\n\nSlipper slope arguments can be a bit slippery. I don't have any clear\nanswers. I do know that ignoring the risks we know about isn't a good\npath."
            },
            {
                "author": "Mike Hearn",
                "date": "2015-01-11T18:56:29",
                "message_text_only": "Firstly, apologies to Nathan for not actually providing feedback on his\nprotocol. I've put pondering it onto my mental todo list. The notion of a\npayment tree is interesting but complicated - I would need to think about\nit and maybe draw myself some diagrams before having useful feedback here.\nIf you wanted to implement it, you could fork the existing code in bitcoinj\nand extend it with the new functionality.\n\nI raised the original Satoshi design mainly to inform and so the approaches\ncan be compared. It may well be that this proposed protocol is superior in\nevery way, in which case the nSequence approach would be of no further use,\nassuming Nathan's protocol generalises to n-party HFT.\n\nReplying now to Gregory:\n\nI think we agree, and are just phrasing things differently (or slowly\ngroping towards consensus at the speed of email threads :-).\n\nIt's likely that over time Bitcoin will end up being multi-layered, with\nthe block chain being the base layer that syncs everyone up, and higher\nlayers doing things that miners either can't do or can't be trusted to do.\nLike the proposal from GreenAddress to be a well known signer who is\ntrusted to not double spend.\n\n>From miners perspective, there are multiple schemes where they are viable\nif cost(fraud) < benefit, at the moment unconfirmed transactions appear to\nbe an example of that, and putting resource control considerations to one\nside, it's possible that tx replacement would be the same. Or not. The\ncalculation for miners isn't easy, because if they play by the rules then\nthey may have a long term and reliable income stream, but if they break the\nrules then that payment traffic will migrate to other solutions and they\nend up with nothing. Whether it's worth it depends on how long term they're\nthinking.\n\nIf we imagine a hypothetical future where lots of economic activity is\nbeing done over Satoshi-style replaceable contracts, and suddenly a new big\nshort-termist miner comes along who decides that just breaking the rules\nwill give him more profit before the business dries up, what would happen?\nIf fraud costs get too extreme the old fallback of a purely centralised\nsolution is always there - for software compatibility purposes this would\nlook like a trusted node who doesn't broadcast the transactions at all and\njust keeps them centrally, then mines or broadcasts the final version\nthemselves. Client apps would just be configured to connect directly to\nthat node.\n\nMaking that more competitive means having more such nodes/miners, until\neventually you have a network of miners that are regulated by identity and\nbannable and don't share the tx's outside their network. That probably gets\nyou 95% of the benefit of the old model with maybe 150% (wild ass guess) of\nthe costs. \"Identity\" in this case can mean lots of fancy crypto things\nbeyond old-fashioned govt name+address style.\n\nI don't think that'd be just an expensive and inefficient PayPal, as you'd\nstill have the key difference that simplifies so much - the trusted third\nparty doesn't hold any funds on deposit and can't directly\nsteal/lend/gamble with any funds. To earn money by being corrupt requires\ncomplicated schemes where they strike secret deals to favour one party or\nanother, and that corruption can then be easily detected and published, so\nit seems like the risk is much lower.\n\nBitcoin is already a pretty complex ecosystem with different kinds of trust\nand decentralisation models in use. I see the next 5-10 years as a giant\ncost optimisation experiment  .... where are the best settings of the\nvarious decentralisation/speed/fees/complexity/identity knobs for different\nkinds of people?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150111/6ed6eb1c/attachment.html>"
            },
            {
                "author": "odinn",
                "date": "2015-01-11T09:16:47",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nPlease comment if possible on some of the techno-cultural implications\nof ongoing development of bi-directional micropayment channels?\n\nFor example, consider zakat example(s):\nwww[dot]hidaya[dot]org/publications/zakat-information/10-what-is-zakat-obligatory-charity\nThat involves a system based on trust and which is somewhat circular\nin nature (such funds as are going in one direction may also be going\nsimultaneously on balance in another direction somewhere else), where\nthe trustless bitcoin utilizes math, rather than personal trust in\norder to keep the system going.\nHere is some more on zakat:\nen[dot]wikipedia[dot]org/wiki/Zakat\nen[dot]wikipedia[dot]org/wiki/Ridda_wars (Discusses in depth some\ndifferences between Sunni and Shiite on the subject of Zakat)\n\nA sort of traditional philanthropic historic overview in the USA from\nthe 1900s forward is seen here, but it is fairly minimal and not too\nrevealing:\nwww[dot]nptrust[dot]org/history-of-giving/timeline/1900s/\n\nA general microgiving example(s) (not yet fully modeled but for which\nsome prototype software ideas and concepts are in process today):\nabis[dot]io\n\nCheers,\n\n- -O\n\nMike Hearn:\n> The original design is documented at the bottom of here:\n> \n> https://en.bitcoin.it/wiki/Contracts#Example_7:_Rapidly-adjusted_.28micro.29payments_to_a_pre-determined_party\n>\n>\n>\n> \nIn this design, time locked transactions can be broadcast across\n> the network and replaced by broadcasting a new transaction that \n> uses higher sequence numbers. That's what the sequence number field\n> is for. It was intended to allow arbitrary high frequency trading\n> between a set of parties, though the \"channel\" notion is a simple\n> way to think about the two party case.\n> \n> The issue is that you can broadcast transactions with a lock time \n> far in the future to fill up memory, and keep broadcasting \n> replacements to use up CPU time and bandwidth.\n> \n> Additionally, there is a school of thought that says Bitcoin must \n> work even if lots of miners are malicious and willing to break \n> arbitrary things in order to try and get more money. I don't think\n>  Bitcoin can really be a mainstream success under such a threat \n> model, for a whole bunch of reasons (e.g. the economy relies pretty\n> heavily on unconfirmed transactions), but under such a threat model\n> there's nothing that forces miners to actually include the latest\n> version in the block chain. They could pick any version. In the\n> 2-of-2 channel model it takes both parties to sign, so clients can\n> enforce that all versions have the same fee attached.\n> \n> I disagree with Gregory that people refuse to use protocols that \n> are affected by malleability. There aren't any user-friendly apps \n> that use refunds currently, so we have no idea whether people would\n> refuse to use them or not. It's an open question. The answer would\n> probably depend on the real prevalence of attacks, which is \n> currently unknowable and likely application specific.\n> \n> \n> \n> ------------------------------------------------------------------------------\n>\n>\n>\n> \nDive into the World of Parallel Programming! The Go Parallel Website,\n> sponsored by Intel and developed in partnership with Slashdot \n> Media, is your hub for all things parallel software development, \n> from weekly thought leadership blogs to news, videos, case studies,\n> tutorials and more. Take a look and join the conversation now.\n> http://goparallel.sourceforge.net\n> \n> \n> \n> _______________________________________________ Bitcoin-development\n> mailing list Bitcoin-development at lists.sourceforge.net \n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> \n\n- -- \nhttp://abis.io ~\n\"a protocol concept to enable decentralization\nand expansion of a giving economy, and a new social good\"\nhttps://keybase.io/odinn\n-----BEGIN PGP SIGNATURE-----\n\niQEcBAEBCgAGBQJUsj9+AAoJEGxwq/inSG8Cvu8H/RutYcVPdN+GrtAYxNkm2x7n\nv/NtBIZwGs7iN6g14Te/ynEfBQRzYwVABL+d1nEuNdlYl6IB4mCXkFrz7hlFJNgK\n2WOq4iKApS1tV9MFAcaxnYy6W8z5T8VpQRqxNbbFEG145cGP2l/5CYwXOmPOBdp7\nqTnLs9oVyhixcfb/piFhd/4xRvlvwxVyvCamrAXBUIpgpW/VB/kfG8ikCazvcJB6\nlSY+CogSGqObjlO7PhKcsZz/gTNrSIp40upyktfqZvQxWLp4WR7+GYz7vUXoofQO\nObt3ya6lZBLLL0EHYkJzAiKRy4aoIgIUzyshIHTdiQIwZC6HWnv2++sJdneng8g=\n=+e6h\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2015-01-09T13:26:14",
                "message_text_only": "On Fri, Jan 9, 2015 at 1:20 PM, Mike Hearn <mike at plan99.net> wrote:\n>> A limitation on most existing micropayment channel ideas is that payments\n>> can only flow in one direction.\n> It's worth noting that the original protocol as designed by Satoshi did not\n> have this limitation. It has evolved this way because of ad-hoc DoS fixes\n> over time (btw I'm not saying they were the wrong thing to do, as non \"ad\n> hoc\" solutions are significantly more work). But it seems like eventually a\n> different approach to handling DoS attacks based on resource prioritisation\n> and scheduling will become needed / implemented, and at that point the\n> original design could be safely brought back to life.\n\nI don't agree with your understanding.  Expecting replacement to work\nand be enforced is completely unsafe. People (sanely) refuse to use\nprotocols which are broken by refund malleability, which is a much\nnarrower expectation for miners than expecting the sequence ratchet to\ngo one way."
            },
            {
                "author": "Peter Todd",
                "date": "2015-01-11T22:24:47",
                "message_text_only": "On Fri, Jan 09, 2015 at 01:40:53PM +0200, Nathan Cook wrote:\n\nWould you mind doing up some actual scriptPubKeys/transactions using\nthis idea as an example? I think it'd make the review process a lot\neasier for everyone if there was something more concrete. (equally,\nsorry I haven't had a chance to look at this, very busy for the rest of\nthe month)\n\nYou may find my CLTV-using micropayment channel demo useful reference\nmaterial too:\n\nhttps://github.com/petertodd/checklocktimeverify-demos/blob/master/micropayment-channel.py\n\n> A limitation on most existing micropayment channel ideas is that payments\n> can only flow in one direction. This is because the payment receiver can\n> sign -any- transaction you send them, not just the most recent one, and so\n> it's possible to just sign the transaction transferring the largest amount\n> into their control. This is easily remedied by opening a second payment\n> channel in the opposite direction, but now both parties have to deposit\n> funds over the lifetime of the two channels. If one party doesn't know\n> ahead of time whether or not the other party will go into credit, having\n> only one channel may save the use of a deposit.\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000000d41f9ac3e2a4a621769f4f077c490bf2b2a967ebfd04e42\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 650 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150111/8ab79b84/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Bi-directional micropayment channels with CHECKLOCKTIMEVERIFY",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "odinn",
                "Nathan Cook",
                "Mike Hearn",
                "Peter Todd",
                "Gregory Maxwell"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 26487
        }
    },
    {
        "title": "[Bitcoin-development] OpenSSL 1.0.0p / 1.0.1k incompatible, causes blockchain rejection.",
        "thread_messages": [
            {
                "author": "Gregory Maxwell",
                "date": "2015-01-10T04:26:23",
                "message_text_only": "OpenSSL 1.0.0p / 1.0.1k was recently released and is being\npushed out by various operating system maintainers.  My review\ndetermined that this update is incompatible with the Bitcoin\nsystem and could lead to consensus forks.\n\nBitcoin Core released binaries from Bitcoin.org are unaffected,\nas are any built with the gitian deterministic build system.\n\nIf you are running third-party or self-compiled Bitcoin Core\nor an alternative implementation using OpenSSL you must not\nupdate OpenSSL or must run a Bitcoin software containing a\nworkaround:\n\nhttps://github.com/bitcoin/bitcoin/commit/488ed32f2ada1d1dd108fc245d025c4d5f252783\n(versions of this will be backported to other stable branches soon)\n\nThe tests included with Bitcoin Core in the test_bitcoin\nutility already detect this condition and fail.  (_Do not ignore or\ndisable the tests in order to run or distribute software\nwhich fails_)\n\nThe incompatibility is due to the OpenSSL update changing the\nbehavior of ECDSA validation to reject any signature which is\nnot encoded in a very rigid manner.  This was a result of\nOpenSSL's change for CVE-2014-8275 \"Certificate fingerprints\ncan be modified\".\n\nWhile for most applications it is generally acceptable to eagerly\nreject some signatures, Bitcoin is a consensus system where all\nparticipants must generally agree on the exact validity or\ninvalidity of the input data.  In a sense, consistency is more\nimportant than \"correctness\".\n\nAs a result, an uncontrolled 'fix' can constitute a security\nvulnerability for the Bitcoin system.  The Bitcoin Core developers\nhave been aware of this class of risk for a long time and have\ntaken measures to mitigate it generally; e.g., shipping static\nbinaries, internalizing the Leveldb library... etc.\n\nIt was somewhat surprising, however, to see this kind of change show\nup as a \"low\" priority fix in a security update and pushed out live\nonto large numbers of systems within hours.\n\nWe were specifically aware of potential hard-forks due to signature\nencoding handling and had been hoping to close them via BIP62 in 0.10.\nBIP62's purpose is to improve transaction malleability handling and\nas a side effect rigidly defines the encoding for signatures, but the\noverall scope of BIP62 has made it take longer than we'd like to\ndeploy.\n\n(Coincidentally, I wrote about this concern and our unique demands on\n cryptographic software as part of a comment on Reddit shortly before\n discovering that part of this OpenSSL update was actually\n incompatible with Bitcoin:\n https://www.reddit.com/r/Bitcoin/comments/2rrxq7/on_why_010s_release_notes_say_we_have_reason_to/cnitbz3\n)\n\nThe patches above, however, only fix one symptom of the general\nproblem: relying on software not designed or distributed for\nconsensus use (in particular OpenSSL) for consensus-normative\nbehavior.  Therefore, as an incremental improvement, I propose\na targeted soft-fork to enforce strict DER compliance soon,\nutilizing a subset of BIP62.\n\nAdding a blockchain rule for strict DER will reduce the risk of\nconsensus inconsistencies from alternative implementations of\nsignature parsing or signature verification, simplify BIP62,\nand better isolate the cryptographic validation code from the\nconsensus algorithm. A failure to do so will likely leave us\nin this situation, or possibly worse, again in the future.\n\nThe relevant incompatible transactions are already non-standard on\nthe network since 0.8.0's release in February 2013, although there\nwas seemingly a single miner still mining incompatible transactions.\nThat miner has been contacted and has fixed their software, so a\nsoft-fork with no chain forking should be possible."
            },
            {
                "author": "Peter Todd",
                "date": "2015-01-10T05:40:38",
                "message_text_only": "On Sat, Jan 10, 2015 at 04:26:23AM +0000, Gregory Maxwell wrote:\n> The incompatibility is due to the OpenSSL update changing the\n> behavior of ECDSA validation to reject any signature which is\n> not encoded in a very rigid manner.  This was a result of\n> OpenSSL's change for CVE-2014-8275 \"Certificate fingerprints\n> can be modified\".\n> \n> While for most applications it is generally acceptable to eagerly\n> reject some signatures, Bitcoin is a consensus system where all\n> participants must generally agree on the exact validity or\n> invalidity of the input data.  In a sense, consistency is more\n> important than \"correctness\".\n\nAs an aside, it's interesting to note that this issue is not entirely\nunique to miners.\n\nFor example in micropayment channel protocols the receiver must validate\nsignatures from the sender to ensure that they will be able to broadcast\ntransactions containing those signatures in the near-future. If they\naccept a signature as valid that the majority of hashing power rejects\nas invalid the sender can simply wait until the micropayment channel\ntimeout expires to recover 100% of their funds, ripping off the\nreceiver. There's many other advanced Bitcoin protocols with similar\nvulnerabilities; I'd be interested to hear if anyone can come up with a\nsimilar vulnerability in a non-Bitcoin protocol, and wouldn't be that\nsurprised if they did.\n\nWhile I have often cautioned people before to avoid using libsecp256k1\nfor verification on the grounds that consensus trumps correctness, the\nabove incompatibility does strongly suggest that OpenSSL may not itself\nhave very good consensus-critical design. Along with Maxwell and\nWuille's recent findings\u00b9 CVE-2014-3570 - strong evidence of the\nexcellent testing the library has undergone - I personally am now of the\nopinion that migrating Bitcoin Core to libsecp256k1 in the near future\nis a good idea on the grounds that it provides us with a well-written,\nand well-understood library designed with consensus in mind that'll\nprobably give us fewer consensus problems than our existing OpenSSL\ndependency. It'll also help advanced protocol implementations by giving\nthem a clear dependency to use when they need consensus-critical\nsignature evaluation.\n\n1) https://www.reddit.com/r/Bitcoin/comments/2rrxq7/on_why_010s_release_notes_say_we_have_reason_to/\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000003b82d8644b56c846e7497118b04a6ec68d3e0a23d33323b82e\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 650 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150110/ad0d1541/attachment.sig>"
            },
            {
                "author": "Wladimir",
                "date": "2015-01-10T08:35:47",
                "message_text_only": "On Sat, Jan 10, 2015 at 4:26 AM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n> https://github.com/bitcoin/bitcoin/commit/488ed32f2ada1d1dd108fc245d025c4d5f252783\n> (versions of this will be backported to other stable branches soon)\n\nFor those that build from source, patches to cope with the new OpenSSL\nversions are now available on stable branches 0.8, 0.9 and rc branch\n0.10:\n\n0.8 branch (on top of 0.8.6)\n========================\nhttps://github.com/bitcoin/bitcoin/tree/0.8\nhttps://github.com/bitcoin/bitcoin/commits/0.8\n\nTo fetch, build, and test:\n```\ngit clone -b 0.8 https://github.com/bitcoin/bitcoin.git bitcoin-0.8\ncd bitcoin-0.8/src\nmake -f makefile.unix\nmake -f makefile.unix check\n```\n\n0.9 branch (on top of 0.9.3+)\n========================\nhttps://github.com/bitcoin/bitcoin/tree/0.9\nhttps://github.com/bitcoin/bitcoin/commits/0.9\n\nTo fetch, build, and test:\n```\ngit clone -b 0.9 https://github.com/bitcoin/bitcoin.git bitcoin-0.9\ncd bitcoin-0.9/src\n./autogen.sh\n./configure\nmake\nmake check\n```\n\n0.10 branch (on top of 0.10.0rc1+)\n========================\nhttps://github.com/bitcoin/bitcoin/tree/0.10\nhttps://github.com/bitcoin/bitcoin/commits/0.10\n\n```\ngit clone -b 0.10 https://github.com/bitcoin/bitcoin.git bitcoin-0.10\ncd bitcoin-0.10/src\n./autogen.sh\n./configure\nmake\nmake check\n```\n\nWladimir"
            },
            {
                "author": "Ivan Jelincic",
                "date": "2015-01-10T12:18:31",
                "message_text_only": "Is openssl1.0.1j unaffected?\n\nOn 01/10/2015 09:35 AM, Wladimir wrote:\n> On Sat, Jan 10, 2015 at 4:26 AM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n>> https://github.com/bitcoin/bitcoin/commit/488ed32f2ada1d1dd108fc245d025c4d5f252783\n>> (versions of this will be backported to other stable branches soon)\n> For those that build from source, patches to cope with the new OpenSSL\n> versions are now available on stable branches 0.8, 0.9 and rc branch\n> 0.10:\n>\n> 0.8 branch (on top of 0.8.6)\n> ========================\n> https://github.com/bitcoin/bitcoin/tree/0.8\n> https://github.com/bitcoin/bitcoin/commits/0.8\n>\n> To fetch, build, and test:\n> ```\n> git clone -b 0.8 https://github.com/bitcoin/bitcoin.git bitcoin-0.8\n> cd bitcoin-0.8/src\n> make -f makefile.unix\n> make -f makefile.unix check\n> ```\n>\n> 0.9 branch (on top of 0.9.3+)\n> ========================\n> https://github.com/bitcoin/bitcoin/tree/0.9\n> https://github.com/bitcoin/bitcoin/commits/0.9\n>\n> To fetch, build, and test:\n> ```\n> git clone -b 0.9 https://github.com/bitcoin/bitcoin.git bitcoin-0.9\n> cd bitcoin-0.9/src\n> ./autogen.sh\n> ./configure\n> make\n> make check\n> ```\n>\n> 0.10 branch (on top of 0.10.0rc1+)\n> ========================\n> https://github.com/bitcoin/bitcoin/tree/0.10\n> https://github.com/bitcoin/bitcoin/commits/0.10\n>\n> ```\n> git clone -b 0.10 https://github.com/bitcoin/bitcoin.git bitcoin-0.10\n> cd bitcoin-0.10/src\n> ./autogen.sh\n> ./configure\n> make\n> make check\n> ```\n>\n> Wladimir\n>\n> ------------------------------------------------------------------------------\n> Dive into the World of Parallel Programming! The Go Parallel Website,\n> sponsored by Intel and developed in partnership with Slashdot Media, is your\n> hub for all things parallel software development, from weekly thought\n> leadership blogs to news, videos, case studies, tutorials and more. Take a\n> look and join the conversation now. http://goparallel.sourceforge.net\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Wladimir",
                "date": "2015-01-12T09:40:51",
                "message_text_only": "On Sat, Jan 10, 2015 at 12:18 PM, Ivan Jelincic <parazyd at archlinux.info> wrote:\n> Is openssl1.0.1j unaffected?\n\nYes. It concerns CVE-2014-8275.\n\nWhich in https://www.openssl.org/news/openssl-1.0.1-notes.html is under:\n\nMajor changes between OpenSSL 1.0.1j and OpenSSL 1.0.1k [8 Jan 2015]\n\nWladimir"
            }
        ],
        "thread_summary": {
            "title": "OpenSSL 1.0.0p / 1.0.1k incompatible, causes blockchain rejection.",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Wladimir",
                "Gregory Maxwell",
                "Peter Todd",
                "Ivan Jelincic"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 10094
        }
    },
    {
        "title": "[Bitcoin-development] i need money",
        "thread_messages": [
            {
                "author": "ggprodukcija kig",
                "date": "2015-01-10T11:37:17",
                "message_text_only": "Hi, can you send me 5btc  to my bitcoin actun. i rely need plees man\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150110/d0648455/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "i need money",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "ggprodukcija kig"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 251
        }
    },
    {
        "title": "[Bitcoin-development] [ANN] 0.10.0rc2 has been tagged",
        "thread_messages": [
            {
                "author": "Wladimir",
                "date": "2015-01-12T11:31:33",
                "message_text_only": "I've just tagged 0.10.0rc2 in git.\n\nTo fetch, build, and test (see also doc/build-*.md):\n```\ngit clone -b v0.10.0rc2 https://github.com/bitcoin/bitcoin.git bitcoin-0.10\ncd bitcoin-0.10\n./autogen.sh\n./configure\nmake\nmake check\n```\n\nNote: This includes the changes required for interoperability with\nOpenSSL 1.0.1k.\n\nNotable changes relative to v0.10.0rc1:\n\n- 4e7c219 Catch UTXO set read errors and shutdown\n- a3a7317 Introduce 10 minute block download timeout\n- 12b7c44 Improve robustness of DER recoding code\n- 76ce5c8 fail immediately on an empty signature\n- 2d375fe depends: bump openssl to 1.0.1k\n- ace39db consensus: guard against openssl's new strict DER checks\n- 263b65e tests: run sanity checks in tests too\n- e2677d7 Fix smartfees test for change to relay policy\n- b7a4ecc Build: Only check for boost when building code that requires it\n- 867c600 Catch LevelDB errors during flush\n- 008138c Bugfix: only track UTXO modification after lookup\n- 3022e7d Require sufficent priority for relay of free transactions\n- 06fdf32 bitcoin-tx: Fix JSON validation of prevtxs\n- 58fda4d Update seed IPs, based on bitcoin.sipa.be crawler data\n- 94b362d On close of splashscreen interrupt verifyDB\n- 1eadfd9 Bugfix: prioritisetransaction: Do some basic sanity checking on txid\n- 18021d0 Remove bitnodes.io from dnsseeds.\n- b790d13 English translation update\n- 8543b0d Correct tooltip on address book page\n- 87d43a3 rpcserver: attempt to fix uncaught exception.\n- 06ca065 Fix CScriptID(const CScript& in) in empty script case\n\nWladmir"
            }
        ],
        "thread_summary": {
            "title": "0.10.0rc2 has been tagged",
            "categories": [
                "Bitcoin-development",
                "ANN"
            ],
            "authors": [
                "Wladimir"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1524
        }
    },
    {
        "title": "[Bitcoin-development] [ANN] 0.10.0rc3 has been tagged",
        "thread_messages": [
            {
                "author": "Wladimir",
                "date": "2015-01-13T21:13:27",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\n\nOn Mon, Jan 12, 2015 at 3:28 PM, Wladimir <laanwj at gmail.com> wrote:\n> On Mon, Jan 12, 2015 at 11:31 AM, Wladimir <laanwj at gmail.com> wrote:\n>\n> If you build from source, and have already built rc2, there is no\n> reason to build rc3.\n\n0.10.0rc3 executables have been uploaded to https://bitcoin.org/bin/0.10.0/test\n\nWladimir\n\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQEcBAEBCgAGBQJUtYo5AAoJEHSBCwEjRsmmGZkH/j51NRB/qJpIFuqz8fQo+ojI\n3ZX3Njgcs8mwGcJrOqURJTuLYkj/FVCIsgvIrfCDAkWssxSh320vdktSj6vfBL4T\nt0IlOHZI+vCXEB6OW+guIF9huae5OHMnuxzxcVye8dJEMrQ76Zm9CmubyOTsvZCn\neSDHIqjdu9ygbrPdGXiVQAZ1YVVV2KtHTU+AVGLPkw6EfclefXgVPm3Sp+78LJl7\nZBwgr+NpZQesOh+bIafeJLeEbMfqjOHGzZrh66dTgxhw7Eyd7QpnsRehmRozKGtg\ng7FPepeDRC1tRElJlzaHn1+V61YHEj6dADCLrZ57gSXPljlnXCWo4YfAF5D6IfQ=\n=yml9\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "0.10.0rc3 has been tagged",
            "categories": [
                "Bitcoin-development",
                "ANN"
            ],
            "authors": [
                "Wladimir"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 852
        }
    },
    {
        "title": "[Bitcoin-development] convention/standard for sorting public keys for p2sh multisig transactions",
        "thread_messages": [
            {
                "author": "Ruben de Vries",
                "date": "2015-01-14T16:37:10",
                "message_text_only": "For p2sh multisig TXs the order of the public keys affect the hash and\nthere doesn't seem to be an agreed upon way of sorting the public keys.\n\nIf there would be a standard (recommended) way of sorting the public keys\nthat would make it easier for services that implement some form of multisig\nto be compatible with each other without much hassle and making it possible\nto import keys from one service to another.\n\nI'm not suggesting forcing the order, just setting a standard to recommend,\nthere doesn't seem to be much reason for (new) services to not follow that\nrecommendation.\n\nRyan from BitPay broad this up before (\nhttps://sourceforge.net/p/bitcoin/mailman/message/32092958/) and in bitcore\nthey've implemented lexicographical sorting on the hex of the public key.\nIn a short search I can't find any other library that has a sorting\nfunction, let alone using it by default, so bitcore is currently my only\nreference.\n\n\n\u200bRuben de Vries\n\u200bCTO, BlockTrail\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150114/9114f30a/attachment.html>"
            },
            {
                "author": "devrandom",
                "date": "2015-01-14T17:39:10",
                "message_text_only": "At CryptoCorp we recommend to our customers that they sort\nlexicographically by the public key bytes of the leaf public keys.  i.e.\nthe same as BitPay.\n\nOn Wed, 2015-01-14 at 17:37 +0100, Ruben de Vries wrote:\n> For p2sh multisig TXs the order of the public keys affect the hash and\n> there doesn't seem to be an agreed upon way of sorting the public\n> keys.\n> \n> \n> If there would be a standard (recommended) way of sorting the public\n> keys that would make it easier for services that implement some form\n> of multisig to be compatible with each other without much hassle and\n> making it possible to import keys from one service to another.\n> \n> \n> I'm not suggesting forcing the order, just setting a standard to\n> recommend, there doesn't seem to be much reason for (new) services to\n> not follow that recommendation.\n> \n> \n> Ryan from BitPay broad this up before\n> (https://sourceforge.net/p/bitcoin/mailman/message/32092958/) and in\n> bitcore they've implemented lexicographical sorting on the hex of the\n> public key.\n> In a short search I can't find any other library that has a sorting\n> function, let alone using it by default, so bitcore is currently my\n> only reference.\n> \n> \n> \n> \n> \u200bRuben de Vries\n> \u200bCTO, BlockTrail\n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n> _______________________________________________ Bitcoin-development mailing list Bitcoin-development at lists.sourceforge.net https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n-- \nMiron / devrandom"
            },
            {
                "author": "Eric Lombrozo",
                "date": "2015-01-14T18:00:39",
                "message_text_only": "I think everyone is pretty much following this standard now.\n\n- Eric\nOn Jan 14, 2015 12:58 PM, \"devrandom\" <c1.sf-bitcoin at niftybox.net> wrote:\n\n> At CryptoCorp we recommend to our customers that they sort\n> lexicographically by the public key bytes of the leaf public keys.  i.e.\n> the same as BitPay.\n>\n> On Wed, 2015-01-14 at 17:37 +0100, Ruben de Vries wrote:\n> > For p2sh multisig TXs the order of the public keys affect the hash and\n> > there doesn't seem to be an agreed upon way of sorting the public\n> > keys.\n> >\n> >\n> > If there would be a standard (recommended) way of sorting the public\n> > keys that would make it easier for services that implement some form\n> > of multisig to be compatible with each other without much hassle and\n> > making it possible to import keys from one service to another.\n> >\n> >\n> > I'm not suggesting forcing the order, just setting a standard to\n> > recommend, there doesn't seem to be much reason for (new) services to\n> > not follow that recommendation.\n> >\n> >\n> > Ryan from BitPay broad this up before\n> > (https://sourceforge.net/p/bitcoin/mailman/message/32092958/) and in\n> > bitcore they've implemented lexicographical sorting on the hex of the\n> > public key.\n> > In a short search I can't find any other library that has a sorting\n> > function, let alone using it by default, so bitcore is currently my\n> > only reference.\n> >\n> >\n> >\n> >\n> > \u200bRuben de Vries\n> > \u200bCTO, BlockTrail\n> >\n> ------------------------------------------------------------------------------\n> > New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> > GigeNET is offering a free month of service with a new server in Ashburn.\n> > Choose from 2 high performing configs, both with 100TB of bandwidth.\n> > Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> > http://p.sf.net/sfu/gigenet\n> > _______________________________________________ Bitcoin-development\n> mailing list Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n> --\n> Miron / devrandom\n>\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150114/230bd912/attachment.html>"
            },
            {
                "author": "Jean-Pierre Rupp",
                "date": "2015-01-14T18:58:07",
                "message_text_only": "We in Haskoin do the same.\n\nOn 14/01/15 17:39, devrandom wrote:\n> At CryptoCorp we recommend to our customers that they sort\n> lexicographically by the public key bytes of the leaf public keys.  i.e.\n> the same as BitPay.\n\n-- \nBe Happy :)"
            },
            {
                "author": "Jeffrey Paul",
                "date": "2015-01-14T19:27:30",
                "message_text_only": "> On 20150114, at 09:39, devrandom <c1.sf-bitcoin at niftybox.net> wrote:\n> \n> At CryptoCorp we recommend to our customers that they sort\n> lexicographically by the public key bytes of the leaf public keys.  i.e.\n> the same as BitPay.\n\nTo clarify: the raw bytes of the public key itself, not the ascii base58 representation of the pubkey hash - right?\n\n-jp\n\n--\nJeffrey Paul                                                      EEQJ\njp at eeqj.com                                           https://eeqj.com\n+1-800-403-1126 (America)                  +1-312-361-0355 (Worldwide)\n5539 AD00 DE4C 42F3 AFE1                      1575 0524 43F4 DF2A 55C2"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2015-01-14T19:58:54",
                "message_text_only": "On 14/01/15 20:27, Jeffrey Paul wrote:\n> To clarify: the raw bytes of the public key itself, not the ascii base58 representation of the pubkey hash - right?\n\nCould you give an example of two pubkeys where the following condition\nis met?\n\nraw(pubkey1) > raw(pubkey2) and base58(pubkey1) < base58(pubkey2)\n\n-- \nBest Regards / S pozdravom,\n\nPavol Rusnak <stick at gk2.sk>"
            },
            {
                "author": "Eric Lombrozo",
                "date": "2015-01-14T23:53:26",
                "message_text_only": "I would highly recommend NOT using Base58 for anything except stuff that is\nto be copy/pasted by the enduser.\n\nInternally, pubkeys are DER-encoded integers.\n\n- Eric\nOn Jan 14, 2015 2:54 PM, \"Jeffrey Paul\" <jp at eeqj.com> wrote:\n\n>\n> > On 20150114, at 09:39, devrandom <c1.sf-bitcoin at niftybox.net> wrote:\n> >\n> > At CryptoCorp we recommend to our customers that they sort\n> > lexicographically by the public key bytes of the leaf public keys.  i.e.\n> > the same as BitPay.\n>\n> To clarify: the raw bytes of the public key itself, not the ascii base58\n> representation of the pubkey hash - right?\n>\n> -jp\n>\n> --\n> Jeffrey Paul                                                      EEQJ\n> jp at eeqj.com                                           https://eeqj.com\n> +1-800-403-1126 (America)                  +1-312-361-0355 (Worldwide)\n> 5539 AD00 DE4C 42F3 AFE1                      1575 0524 43F4 DF2A 55C2\n>\n>\n>\n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150114/2a23f3b3/attachment.html>"
            },
            {
                "author": "Matt Whitlock",
                "date": "2015-01-15T01:17:52",
                "message_text_only": "On Wednesday, 14 January 2015, at 3:53 pm, Eric Lombrozo wrote:\n> Internally, pubkeys are DER-encoded integers.\n\nI thought pubkeys were represented as raw integers (i.e., they're embedded in Script as a push operation whose payload is the raw bytes of the big-endian representation of the integer). As far as I know, DER encoding is only used for signatures. Am I mistaken?"
            },
            {
                "author": "Jean-Pierre Rupp",
                "date": "2015-01-15T12:33:39",
                "message_text_only": "A public key is a point in the elliptic curve.  As such it has an X and\na Y component.  Its serialization is described very succintly here:\n\nhttps://en.bitcoin.it/wiki/Protocol_specification#Signatures\n\nOn 15/01/15 01:17, Matt Whitlock wrote:\n> I thought pubkeys were represented as raw integers (i.e., they're embedded in Script as a push operation whose payload is the raw bytes of the big-endian representation of the integer). As far as I know, DER encoding is only used for signatures. Am I mistaken?\n\n-- \nBe Happy :)"
            },
            {
                "author": "Jeff Garzik",
                "date": "2015-01-14T20:32:57",
                "message_text_only": "Sounds like this warrants a micro-BIP just to get everybody on the same\npage.\n\n\nOn Wed, Jan 14, 2015 at 11:37 AM, Ruben de Vries <ruben at blocktrail.com>\nwrote:\n\n> For p2sh multisig TXs the order of the public keys affect the hash and\n> there doesn't seem to be an agreed upon way of sorting the public keys.\n>\n> If there would be a standard (recommended) way of sorting the public keys\n> that would make it easier for services that implement some form of multisig\n> to be compatible with each other without much hassle and making it possible\n> to import keys from one service to another.\n>\n> I'm not suggesting forcing the order, just setting a standard to\n> recommend, there doesn't seem to be much reason for (new) services to not\n> follow that recommendation.\n>\n> Ryan from BitPay broad this up before (\n> https://sourceforge.net/p/bitcoin/mailman/message/32092958/) and in\n> bitcore they've implemented lexicographical sorting on the hex of the\n> public key.\n> In a short search I can't find any other library that has a sorting\n> function, let alone using it by default, so bitcore is currently my only\n> reference.\n>\n>\n> \u200bRuben de Vries\n> \u200bCTO, BlockTrail\n>\n>\n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150114/2468d959/attachment.html>"
            },
            {
                "author": "Jonathan Brown",
                "date": "2015-01-15T11:59:15",
                "message_text_only": "In BIP45 it mentions \"lexicographically sorting the public keys\".\n\nhttps://github.com/bitcoin/bips/blob/master/bip-0045.mediawiki#Address_Generation_Procedure\n\nOn 15 January 2015 at 03:32, Jeff Garzik <jgarzik at bitpay.com> wrote:\n\n> Sounds like this warrants a micro-BIP just to get everybody on the same\n> page.\n>\n>\n> On Wed, Jan 14, 2015 at 11:37 AM, Ruben de Vries <ruben at blocktrail.com>\n> wrote:\n>\n>> For p2sh multisig TXs the order of the public keys affect the hash and\n>> there doesn't seem to be an agreed upon way of sorting the public keys.\n>>\n>> If there would be a standard (recommended) way of sorting the public keys\n>> that would make it easier for services that implement some form of multisig\n>> to be compatible with each other without much hassle and making it possible\n>> to import keys from one service to another.\n>>\n>> I'm not suggesting forcing the order, just setting a standard to\n>> recommend, there doesn't seem to be much reason for (new) services to not\n>> follow that recommendation.\n>>\n>> Ryan from BitPay broad this up before (\n>> https://sourceforge.net/p/bitcoin/mailman/message/32092958/) and in\n>> bitcore they've implemented lexicographical sorting on the hex of the\n>> public key.\n>> In a short search I can't find any other library that has a sorting\n>> function, let alone using it by default, so bitcore is currently my only\n>> reference.\n>>\n>>\n>> \u200bRuben de Vries\n>> \u200bCTO, BlockTrail\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n>> GigeNET is offering a free month of service with a new server in Ashburn.\n>> Choose from 2 high performing configs, both with 100TB of bandwidth.\n>> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n>> http://p.sf.net/sfu/gigenet\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>>\n>\n>\n> --\n> Jeff Garzik\n> Bitcoin core developer and open source evangelist\n> BitPay, Inc.      https://bitpay.com/\n>\n>\n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150115/b521875e/attachment.html>"
            },
            {
                "author": "Eric Lombrozo",
                "date": "2015-01-15T01:09:54",
                "message_text_only": "Ciphrex was using this convention well before BitPay...and BitPay's BIP32\nimplementation was at least partly taken from ours.\n\n- Eric\nOn Jan 14, 2015 8:03 PM, \"Andy Alness\" <andy at coinbase.com> wrote:\n\n> Doing same (BitPay convention) for our multisig support.\n>\n> On Wed, Jan 14, 2015 at 3:53 PM, Eric Lombrozo <elombrozo at gmail.com>\n> wrote:\n> > I would highly recommend NOT using Base58 for anything except stuff that\n> is\n> > to be copy/pasted by the enduser.\n> >\n> > Internally, pubkeys are DER-encoded integers.\n> >\n> > - Eric\n> >\n> > On Jan 14, 2015 2:54 PM, \"Jeffrey Paul\" <jp at eeqj.com> wrote:\n> >>\n> >>\n> >> > On 20150114, at 09:39, devrandom <c1.sf-bitcoin at niftybox.net> wrote:\n> >> >\n> >> > At CryptoCorp we recommend to our customers that they sort\n> >> > lexicographically by the public key bytes of the leaf public keys.\n> i.e.\n> >> > the same as BitPay.\n> >>\n> >> To clarify: the raw bytes of the public key itself, not the ascii base58\n> >> representation of the pubkey hash - right?\n> >>\n> >> -jp\n> >>\n> >> --\n> >> Jeffrey Paul                                                      EEQJ\n> >> jp at eeqj.com                                           https://eeqj.com\n> >> +1-800-403-1126 (America)                  +1-312-361-0355 (Worldwide)\n> >> 5539 AD00 DE4C 42F3 AFE1                      1575 0524 43F4 DF2A 55C2\n> >>\n> >>\n> >>\n> >>\n> ------------------------------------------------------------------------------\n> >> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> >> GigeNET is offering a free month of service with a new server in\n> Ashburn.\n> >> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> >> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> >> http://p.sf.net/sfu/gigenet\n> >> _______________________________________________\n> >> Bitcoin-development mailing list\n> >> Bitcoin-development at lists.sourceforge.net\n> >> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> >\n> >\n> >\n> ------------------------------------------------------------------------------\n> > New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> > GigeNET is offering a free month of service with a new server in Ashburn.\n> > Choose from 2 high performing configs, both with 100TB of bandwidth.\n> > Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> > http://p.sf.net/sfu/gigenet\n> > _______________________________________________\n> > Bitcoin-development mailing list\n> > Bitcoin-development at lists.sourceforge.net\n> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> >\n>\n>\n>\n> --\n> Andy Alness\n> Software Engineer\n> Coinbase\n> San Francisco, CA\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150114/df980217/attachment.html>"
            },
            {
                "author": "Ruben de Vries",
                "date": "2015-01-16T10:16:56",
                "message_text_only": "Since we only need the sorting for creating the scriptPubKey,\nwouldn't it make the most sense to sort it by the way it represented in\nthat context?\n\n\nOn Thu, Jan 15, 2015 at 2:03 PM, Wladimir <laanwj at gmail.com> wrote:\n\n> On Thu, Jan 15, 2015 at 1:17 AM, Matt Whitlock <bip at mattwhitlock.name>\n> wrote:\n> > On Wednesday, 14 January 2015, at 3:53 pm, Eric Lombrozo wrote:\n> >> Internally, pubkeys are DER-encoded integers.\n> >\n> > I thought pubkeys were represented as raw integers (i.e., they're\n> embedded in Script as a push operation whose payload is the raw bytes of\n> the big-endian representation of the integer). As far as I know, DER\n> encoding is only used for signatures. Am I mistaken?\n>\n> OP_CHECKSIG (and OP_CHECKSIGVERIFY) takes a DER-encoded pubkey and a\n> DER-encoded signature on the stack.\n>\n> Possibly you're confused with OP_HASH160 <hash160> OP_EQUALVERIFY as\n> used in outputs, which compares the 160-bit hash of the pubkey against\n> the given hash (usually taken from a bitcoin address).\n>\n> It doesn't help understanding to consider either as integers. They are\n> binary blob objects with either a fixed format (DER) or a fixed size\n> (hashes).\n>\n> Wladimir\n>\n\n\n\n-- \nBlockTrail B.V.\nBarbara Strozzilaan 201\n1083HN Amsterdam\nThe Netherlands\n\nPhone: +31 (0)612227277\nE-mail: ruben at blocktrail.com\nWeb: www.blocktrail.com\nGithub: www.github.com/rubensayshi\n\nBlockTrail B.V. Is registered with the Dutch Chamber of Commerce in\nAmsterdam with registration No.:60262060 and VAT No.:NL853833035B01\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150116/6dcebfd8/attachment.html>"
            },
            {
                "author": "Thomas Kerin",
                "date": "2015-01-16T16:34:17",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nIt would - it assumes you have the set of keys and are sorting before\nyou derive and send funds to such a P2SH address.\n\nIt seems there is scope for further narrowing down how a multisig\nscripthash address should be determined - what do people think of\nanticipating only compressed keys for scripts?\n\nIt's possible to cause confusion if one put forward a compressed key at\nsome time, and an uncompressed key at another. A different script hash\nwould be produced even though there is no difference to the keys\ninvolved. The client will not search for this.\n\n\nHaving spoken with Jean-Pierre and Ruben about this for quite some time\nnow, there is 100% the need for a BIP outlining this. Everyone has had\nthe idea at some point, and some of us already using it, but people\nshouldn't have to go digging in BIP45 for the two lines which mention\nit. All we need is a place to put the docs.\n\nI am building up a list of implementations which currently support\nsorting, and briefly describing a motivation for such a BIP.\n\n\nOn 16/01/15 10:16, Ruben de Vries wrote:\n> Since we only need the sorting for creating the scriptPubKey,\n> wouldn't it make the most sense to sort it by the way it represented\nin that context?\n>\n>\n> On Thu, Jan 15, 2015 at 2:03 PM, Wladimir <laanwj at gmail.com\n<mailto:laanwj at gmail.com>> wrote:\n>\n>     On Thu, Jan 15, 2015 at 1:17 AM, Matt Whitlock\n<bip at mattwhitlock.name <mailto:bip at mattwhitlock.name>> wrote:\n>     > On Wednesday, 14 January 2015, at 3:53 pm, Eric Lombrozo wrote:\n>     >> Internally, pubkeys are DER-encoded integers.\n>     >\n>     > I thought pubkeys were represented as raw integers (i.e.,\nthey're embedded in Script as a push operation whose payload is the raw\nbytes of the big-endian representation of the integer). As far as I\nknow, DER encoding is only used for signatures. Am I mistaken?\n>\n>     OP_CHECKSIG (and OP_CHECKSIGVERIFY) takes a DER-encoded pubkey and a\n>     DER-encoded signature on the stack.\n>\n>     Possibly you're confused with OP_HASH160 <hash160> OP_EQUALVERIFY as\n>     used in outputs, which compares the 160-bit hash of the pubkey against\n>     the given hash (usually taken from a bitcoin address).\n>\n>     It doesn't help understanding to consider either as integers. They are\n>     binary blob objects with either a fixed format (DER) or a fixed size\n>     (hashes).\n>\n>     Wladimir\n>\n>\n>\n>\n> --\n> BlockTrail B.V.\n> Barbara Strozzilaan 201\n> 1083HN Amsterdam\n> The Netherlands\n>\n> Phone:+31 (0)612227277\n> E-mail:ruben at blocktrail.com <mailto:ruben at blocktrail.com>\n> Web:www.blocktrail.com\n> <http://www.blocktrail.com/>\n> Github:www.github.com/rubensayshi <http://www.github.com/rubensayshi>\n>\n> BlockTrail B.V. Is registered with the Dutch Chamber of Commerce in\nAmsterdam with registration No.:60262060 and VAT No.:NL853833035B01\n>\n>\n>\n------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n- -- \nThomas Kerin\n- -------------------------\n\nMy PGP key can be found here\n<http://pgp.mit.edu/pks/lookup?op=get&search=0x3F0D2F83A2966155>\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQJ8BAEBCgBmBQJUuT2EXxSAAAAAAC4AKGlzc3Vlci1mcHJAbm90YXRpb25zLm9w\nZW5wZ3AuZmlmdGhob3JzZW1hbi5uZXQ2MzI1MzM4QjJGOTU5OEUzREMzQzc0MzAz\nRjBEMkY4M0EyOTY2MTU1AAoJED8NL4OilmFV4GgP/Rr955cDBA34e58lLdjXkqzi\nEYDH5QfsTdUQQVUvkK0OBq7RQwkbb7Kn5u6U8UD3hEhaWwQGhrQ/gOJrqM68glma\nYfYupugMesTTu4Fxm/AtNv4Cifr29EZB1gu9hBeZGT4FL863+0ShvWHdHvscOcmg\n3SGv0De+1bd93j7p+9jyWh/sYpHEdi0lQBMkkCzSzhXPZzoHEglUmVYBRcmrjaag\nycHuQfN5zjM0fJ18R6f7PCOOAhDi9+7xpikDArvHmKb4BZjOuMBTprN2Mzdg98Uz\nRw4LRsLuht5VCnWHvC8+TUUEMUO8QOMrRxLYJSDVGcl0XYXT0EiRfnkqCr5ab8mm\nKqLcxpSLxrDGd4OiHwWB7oDsg9tWXwVmyQgFsTLsxaNkL8AFRG59mAhbK9j+0+1E\nBd/pMx0VgGXpn1Urism5YlrR4FZ5USbYn9O0NxhUkQb550qvRtaAQNUVSJPEW0AG\n/2pQdFOOqkI1wI0g2L/ZcC+fwBqUok+5MyMTb4NuuvaMDpR7vOeeobIpYLjL0VVZ\ndNzfnlCQxGw/7QrFIbvnye8fNIMZZ9qtJx00bvXYizRyUhrF/FrRgwj2DhEjz6xM\n3+CHKXNmb0qGg6jKgHvXQFic2DVo3IaNmZtVDBqyqCBKmC/A65rRws5uxIimUsIC\nk4af62ZBGpSAhJ4ajCIY\n=Ni9V\n-----END PGP SIGNATURE-----\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150116/12059b7e/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0xA2966155.asc\nType: application/pgp-keys\nSize: 5712 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150116/12059b7e/attachment.bin>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0xA2966155.asc.sig\nType: application/pgp-signature\nSize: 639 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150116/12059b7e/attachment.sig>"
            },
            {
                "author": "Alan Reiner",
                "date": "2015-01-16T17:09:39",
                "message_text_only": "I see no reason to restrict compressed/uncompressed.  Strings don't have\nto be the same length to sort them lexicographically.  If a multi-sig\nparticipant provides an uncompressed key, they are declaring that the\nkey that they use and it will only be used uncompressed.   Clients don't\nhave to go looking for all combinations of compressed & uncompressed.\n\nOn 01/16/2015 11:34 AM, Thomas Kerin wrote:\n>\n>\n> It seems there is scope for further narrowing down how a multisig\n> scripthash address should be determined - what do people think of\n> anticipating only compressed keys for scripts?\n>\n> It's possible to cause confusion if one put forward a compressed key\n> at some time, and an uncompressed key at another. A different script\n> hash would be produced even though there is no difference to the keys\n> involved. The client will not search for this.\n>\n>\n> Having spoken with Jean-Pierre and Ruben about this for quite some\n> time now, there is 100% the need for a BIP outlining this. Everyone\n> has had the idea at some point, and some of us already using it, but\n> people shouldn't have to go digging in BIP45 for the two lines which\n> mention it. All we need is a place to put the docs.\n>\n> I am building up a list of implementations which currently support\n> sorting, and briefly describing a motivation for such a BIP.\n>\n>\n> On 16/01/15 10:16, Ruben de Vries wrote:\n> > Since we only need the sorting for creating the scriptPubKey,\n> > wouldn't it make the most sense to sort it by the way it represented\n> in that context?\n>\n>\n> > On Thu, Jan 15, 2015 at 2:03 PM, Wladimir <laanwj at gmail.com\n> <mailto:laanwj at gmail.com>> wrote:\n>\n> >     On Thu, Jan 15, 2015 at 1:17 AM, Matt Whitlock\n> <bip at mattwhitlock.name <mailto:bip at mattwhitlock.name>> wrote:\n> >     > On Wednesday, 14 January 2015, at 3:53 pm, Eric Lombrozo wrote:\n> >     >> Internally, pubkeys are DER-encoded integers.\n> >     >\n> >     > I thought pubkeys were represented as raw integers (i.e.,\n> they're embedded in Script as a push operation whose payload is the\n> raw bytes of the big-endian representation of the integer). As far as\n> I know, DER encoding is only used for signatures. Am I mistaken?\n>\n> >     OP_CHECKSIG (and OP_CHECKSIGVERIFY) takes a DER-encoded pubkey and a\n> >     DER-encoded signature on the stack.\n>\n> >     Possibly you're confused with OP_HASH160 <hash160> OP_EQUALVERIFY as\n> >     used in outputs, which compares the 160-bit hash of the pubkey\n> against\n> >     the given hash (usually taken from a bitcoin address).\n>\n> >     It doesn't help understanding to consider either as integers.\n> They are\n> >     binary blob objects with either a fixed format (DER) or a fixed size\n> >     (hashes).\n>\n> >     Wladimir\n>\n>\n>\n>\n> > --\n> > BlockTrail B.V.\n> > Barbara Strozzilaan 201\n> > 1083HN Amsterdam\n> > The Netherlands\n>\n> > Phone:+31 (0)612227277\n> > E-mail:ruben at blocktrail.com <mailto:ruben at blocktrail.com>\n> > Web:www.blocktrail.com\n> > <http://www.blocktrail.com/>\n> > Github:www.github.com/rubensayshi <http://www.github.com/rubensayshi>\n>\n> > BlockTrail B.V. Is registered with the Dutch Chamber of Commerce in\n> Amsterdam with registration No.:60262060 and VAT No.:NL853833035B01\n>\n>\n> >\n> ------------------------------------------------------------------------------\n> > New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> > GigeNET is offering a free month of service with a new server in\n> Ashburn.\n> > Choose from 2 high performing configs, both with 100TB of bandwidth.\n> > Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> > http://p.sf.net/sfu/gigenet\n>\n>\n> > _______________________________________________\n> > Bitcoin-development mailing list\n> > Bitcoin-development at lists.sourceforge.net\n> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n>\n>\n------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150116/74819d20/attachment.html>"
            },
            {
                "author": "Jean-Pierre Rupp",
                "date": "2015-01-16T18:40:17",
                "message_text_only": "It is better if the scheme is strongly deterministic.On 16 Jan 2015 17:09, Alan Reiner <etotheipi at gmail.com> wrote:\n>\n> I see no reason to restrict compressed/uncompressed.\u00a0 Strings don't have to be the same length to sort them lexicographically.\u00a0 If a multi-sig participant provides an uncompressed key, they are declaring that the key that they use and it will only be used uncompressed.\u00a0\u00a0 Clients don't have to go looking for all combinations of compressed & uncompressed.\n>\n> On 01/16/2015 11:34 AM, Thomas Kerin wrote:\n> >\n>>\n>>\n>> It seems there is scope for further narrowing down how a multisig scripthash address should be determined - what do people think of anticipating only compressed keys for scripts?\n>>\n>> It's possible to cause confusion if one put forward a compressed key at some time, and an uncompressed key at another. A different script hash would be produced even though there is no difference to the keys involved. The client will not search for this.\n>>\n>>\n>> Having spoken with Jean-Pierre and Ruben about this for quite some time now, there is 100% the need for a BIP outlining this. Everyone has had the idea at some point, and some of us already using it, but people shouldn't have to go digging in BIP45 for the two lines which mention it. All we need is a place to put the docs.\n>>\n>> I am building up a list of implementations which currently support sorting, and briefly describing a motivation for such a BIP.\n>>\n>>\n>> On 16/01/15 10:16, Ruben de Vries wrote:\n>> > Since we only need the sorting for creating the scriptPubKey,\n>> > wouldn't it make the most sense to sort it by the way it represented in that context?\n>>\n>>\n>> > On Thu, Jan 15, 2015 at 2:03 PM, Wladimir <laanwj at gmail.com <mailto:laanwj at gmail.com>> wrote:\n>>\n>> >\u00a0\u00a0\u00a0\u00a0 On Thu, Jan 15, 2015 at 1:17 AM, Matt Whitlock <bip at mattwhitlock.name <mailto:bip at mattwhitlock.name>> wrote:\n>> >\u00a0\u00a0\u00a0\u00a0 > On Wednesday, 14 January 2015, at 3:53 pm, Eric Lombrozo wrote:\n>> >\u00a0\u00a0\u00a0\u00a0 >> Internally, pubkeys are DER-encoded integers.\n>> >\u00a0\u00a0\u00a0\u00a0 >\n>> >\u00a0\u00a0\u00a0\u00a0 > I thought pubkeys were represented as raw integers (i.e., they're embedded in Script as a push operation whose payload is the raw bytes of the big-endian representation of the integer). As far as I know, DER encoding is only used for signatures. Am I mistaken?\n>>\n>> >\u00a0\u00a0\u00a0\u00a0 OP_CHECKSIG (and OP_CHECKSIGVERIFY) takes a DER-encoded pubkey and a\n>> >\u00a0\u00a0\u00a0\u00a0 DER-encoded signature on the stack.\n>>\n>> >\u00a0\u00a0\u00a0\u00a0 Possibly you're confused with OP_HASH160 <hash160> OP_EQUALVERIFY as\n>> >\u00a0\u00a0\u00a0\u00a0 used in outputs, which compares the 160-bit hash of the pubkey against\n>> >\u00a0\u00a0\u00a0\u00a0 the given hash (usually taken from a bitcoin address).\n>>\n>> >\u00a0\u00a0\u00a0\u00a0 It doesn't help understanding to consider either as integers. They are\n>> >\u00a0\u00a0\u00a0\u00a0 binary blob objects with either a fixed format (DER) or a fixed size\n>> >\u00a0\u00a0\u00a0\u00a0 (hashes).\n>>\n>> >\u00a0\u00a0\u00a0\u00a0 Wladimir\n>>\n>>\n>>\n>>\n>> > --\n>> > BlockTrail B.V.\n>> > Barbara Strozzilaan 201\n>> > 1083HN Amsterdam\n>> > The Netherlands\n>>\n>> > Phone:+31 (0)612227277\n>> > E-mail:ruben at blocktrail.com <mailto:ruben at blocktrail.com>\n>> > Web:www.blocktrail.com\n>> > <http://www.blocktrail.com/>\n>> > Github:www.github.com/rubensayshi <http://www.github.com/rubensayshi>\n>>\n>> > BlockTrail B.V. Is registered with the Dutch Chamber of Commerce in Amsterdam with registration No.:60262060 and VAT No.:NL853833035B01\n>>\n>>\n>> > ------------------------------------------------------------------------------\n>> > New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n>> > GigeNET is offering a free month of service with a new server in Ashburn.\n>> > Choose from 2 high performing configs, both with 100TB of bandwidth.\n>> > Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n>> > http://p.sf.net/sfu/gigenet\n>>\n>>\n>> > _______________________________________________\n>> > Bitcoin-development mailing list\n>> > Bitcoin-development at lists.sourceforge.net\n>> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n> >\n> >\n> >\n> > ------------------------------------------------------------------------------\n> > New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> > GigeNET is offering a free month of service with a new server in Ashburn.\n> > Choose from 2 high performing configs, both with 100TB of bandwidth.\n> > Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> > http://p.sf.net/sfu/gigenet\n> >\n> >\n> > _______________________________________________\n> > Bitcoin-development mailing list\n> > Bitcoin-development at lists.sourceforge.net\n> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>"
            }
        ],
        "thread_summary": {
            "title": "convention/standard for sorting public keys for p2sh multisig transactions",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Eric Lombrozo",
                "Jean-Pierre Rupp",
                "Ruben de Vries",
                "Thomas Kerin",
                "Pavol Rusnak",
                "Jeffrey Paul",
                "Matt Whitlock",
                "Jonathan Brown",
                "Alan Reiner",
                "devrandom"
            ],
            "messages_count": 16,
            "total_messages_chars_count": 33949
        }
    },
    {
        "title": "[Bitcoin-development] IMPULSE: Instant Payments using the Bitcoin protocol",
        "thread_messages": [
            {
                "author": "Rune Kj\u00e6r Svendsen",
                "date": "2015-01-17T20:45:27",
                "message_text_only": "Hi list\n\nFound this on reddit: http://impulse.is/\n\nPDF: http://impulse.is/impulse.pdf\n\nI'd love to hear this list's thoughts.\n\n/runeks\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150117/813343df/attachment.html>"
            },
            {
                "author": "Tom Harding",
                "date": "2015-01-22T15:19:26",
                "message_text_only": "On 1/17/2015 12:45 PM, Rune Kj\u00e6r Svendsen wrote:\n> PDF: http://impulse.is/impulse.pdf\n>\n> I'd love to hear this list's thoughts.\n>\n\nWill success be defined by \"BitPay Payment Channels Accepted Here\" signs \nappearing in shop windows?"
            },
            {
                "author": "Jeff Garzik",
                "date": "2015-01-22T16:29:24",
                "message_text_only": "The user experience is significantly more secure than today.\n\nPresumably the future supports many payment facilitators, including m-of-n\noracles, and this is perfectly compatible with that.\n\n\nOn Thu, Jan 22, 2015 at 10:19 AM, Tom Harding <tomh at thinlink.com> wrote:\n\n> On 1/17/2015 12:45 PM, Rune Kj\u00e6r Svendsen wrote:\n> > PDF: http://impulse.is/impulse.pdf\n> >\n> > I'd love to hear this list's thoughts.\n> >\n>\n> Will success be defined by \"BitPay Payment Channels Accepted Here\" signs\n> appearing in shop windows?\n>\n>\n>\n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150122/44b184f9/attachment.html>"
            },
            {
                "author": "Justus Ranvier",
                "date": "2015-01-22T16:36:31",
                "message_text_only": "On 01/17/2015 08:45 PM, Rune Kj\u00e6r Svendsen wrote:\n> Hi list\n> \n> Found this on reddit: http://impulse.is/\n> \n> PDF: http://impulse.is/impulse.pdf\n> \n> I'd love to hear this list's thoughts.\n> \n> /runeks\n\nI'm concerned about the silence that always erupts whenever\nprivacy-hostile products are proposed.\n\n\n-- \nSupport online privacy by using email encryption whenever possible.\nLearn how here: http://www.youtube.com/watch?v=bakOKJFtB-k"
            }
        ],
        "thread_summary": {
            "title": "IMPULSE: Instant Payments using the Bitcoin protocol",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Rune Kj\u00e6r Svendsen",
                "Justus Ranvier",
                "Tom Harding"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 2401
        }
    },
    {
        "title": "[Bitcoin-development] BIP70: why Google Protocol Buffers for encoding?",
        "thread_messages": [
            {
                "author": "Richard Brady",
                "date": "2015-01-19T19:07:30",
                "message_text_only": "Hi Gavin, Mike and co\n\nIs there a strong driver behind the choice of Google Protocol Buffers for\npayment request encoding in BIP-0070?\n\nPerformance doesn't feel that relevant when you think that:\n1. Payment requests are not broadcast, this is a request / response flow,\nmuch more akin to a web request.\n2. One would be cramming this data into a binary format just so you can\nthen attach it to a no-so-binary format such as HTTP.\n\nSome great things about protocols/encodings such as HTTP/JSON/XML are:\n1. They are human readable on-the-wire. No Wireshark plugin required,\ntcpdump or ngrep will do.\n2. There are tons of great open source libraries and API for parsing /\nmanipulating / generating.\n3. It's really easy to hand-craft a test message for debugging.\n4. The standards are much easier to read and write. They don't need to\ncontain code like BIP-0070 currently does and they can contain examples,\nwhich BIP70 does not.\n5. They are thoroughly specified by independent standards bodies such as\nthe IETF. Gotta love a bit of MUST / SHOULD / MAY in a standard.\n6. They're a family ;-)\n\nKeen to hear your thoughts on this and very keen to watch the payment\nprotocol grow regardless of encoding choice! My background is SIP / VoIP\nand I think that could be a fascinating use case for this protocol which\nI'm hoping to do some work on.\n\nBest,\nRichard\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/6edaa8fd/attachment.html>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2015-01-19T19:09:13",
                "message_text_only": "Text formats such as XML or JSON are far less deterministic, are more\nloosely specified, have wide variance in parsing, are not very hash-able,\nthe list goes on.\n\n\nOn Mon, Jan 19, 2015 at 2:07 PM, Richard Brady <rnbrady at gmail.com> wrote:\n\n> Hi Gavin, Mike and co\n>\n> Is there a strong driver behind the choice of Google Protocol Buffers for\n> payment request encoding in BIP-0070?\n>\n> Performance doesn't feel that relevant when you think that:\n> 1. Payment requests are not broadcast, this is a request / response flow,\n> much more akin to a web request.\n> 2. One would be cramming this data into a binary format just so you can\n> then attach it to a no-so-binary format such as HTTP.\n>\n> Some great things about protocols/encodings such as HTTP/JSON/XML are:\n> 1. They are human readable on-the-wire. No Wireshark plugin required,\n> tcpdump or ngrep will do.\n> 2. There are tons of great open source libraries and API for parsing /\n> manipulating / generating.\n> 3. It's really easy to hand-craft a test message for debugging.\n> 4. The standards are much easier to read and write. They don't need to\n> contain code like BIP-0070 currently does and they can contain examples,\n> which BIP70 does not.\n> 5. They are thoroughly specified by independent standards bodies such as\n> the IETF. Gotta love a bit of MUST / SHOULD / MAY in a standard.\n> 6. They're a family ;-)\n>\n> Keen to hear your thoughts on this and very keen to watch the payment\n> protocol grow regardless of encoding choice! My background is SIP / VoIP\n> and I think that could be a fascinating use case for this protocol which\n> I'm hoping to do some work on.\n>\n> Best,\n> Richard\n>\n>\n>\n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/2046cd15/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2015-01-19T19:48:26",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\n\n\nOn 19 January 2015 12:09:13 GMT-07:00, Jeff Garzik <jgarzik at bitpay.com> wrote:\n>Text formats such as XML or JSON are far less deterministic, are more\n>loosely specified, have wide variance in parsing, are not very\n>hash-able,\n>the list goes on.\n\nProtocol buffers isn't any more hashable than XML or json - round trips aren't deterministic with standard protobuf libraries. To make it deterministic you end up creating a new standard.\n\nI have this problem for an asset representation standard for one of my clients, and I've reluctantly had to roll my own format.\n-----BEGIN PGP SIGNATURE-----\nVersion: APG v1.1.1\n\niQFQBAEBCAA6BQJUvV+KMxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8\ncGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhRwcCACNkpkkjIh8Zv5I8bOy\nBpM2Tc5hVpg4KY6eKRXYLYgxoEnekDXN1/LJ5bfl+xzJTMTdt4f7YF0EjFJSIJ0C\nUpR9KbEVShmt7UsoNwwAFxtMQmZe84vANGG11NI/cb95GO2TOlxYtPMFizQrp80s\nULAelID3Pd8yPeadU/yrF+daz9I8UHqOyioL0piWUT+kshuzqQNclHQaPKWoOPbW\nXF4w1SAJjb1tHmkHqCY1HRvwlv8fqxXgjtEyjkz/HK70ZzOI+8aR49aigx2njwyL\nF8EJ1gO3XkivRidTRKfbSloeq96TRneXXXfmyB6p8jI3O3BRkrk9x465EWMnzYu7\nuJqo\n=N1G+\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Richard Brady",
                "date": "2015-01-19T19:57:47",
                "message_text_only": "Thanks guys, great answers.\n\nThe design choice certainly makes a lot more sense now regardless of\nwhether one agrees with it or not.\n\nRegards,\nRichard\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/3e66c433/attachment.html>"
            },
            {
                "author": "Alan Reiner",
                "date": "2015-01-19T20:03:32",
                "message_text_only": "I'm a bit confused.  It's been a long time since I looked at protobuf\n(and will have to dig into it soon), but I seem to recall it doesn't\nhave any of the determinism properties you guys just said.  It is\nintended to allow you to skip details of the on-the-wire representations\nand just send a bunch of named fields between systems.  I thought there\nwas no guarantee that two identical protobuf structures will get\nserialized identically...?\n\n\n\n\nOn 01/19/2015 02:57 PM, Richard Brady wrote:\n> Thanks guys, great answers. \n>\n> The design choice certainly makes a lot more sense now regardless of\n> whether one agrees with it or not.\n>\n> Regards,\n> Richard\n>\n>\n>\n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/c6c82c2c/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2015-01-19T20:06:38",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nThat's 100% true: BIP70 passes around serialized protobuf data that it signs directly for this reason; it could just as easily be a byte array with json in it. (not that json/XML/etc. doesn't have other flaws)\n\n\nOn 19 January 2015 13:03:32 GMT-07:00, Alan Reiner <etotheipi at gmail.com> wrote:\n>I'm a bit confused.  It's been a long time since I looked at protobuf\n>(and will have to dig into it soon), but I seem to recall it doesn't\n>have any of the determinism properties you guys just said.  It is\n>intended to allow you to skip details of the on-the-wire\n>representations\n>and just send a bunch of named fields between systems.  I thought there\n>was no guarantee that two identical protobuf structures will get\n>serialized identically...?\n>\n>\n>\n>\n>On 01/19/2015 02:57 PM, Richard Brady wrote:\n>> Thanks guys, great answers.\n>>\n>> The design choice certainly makes a lot more sense now regardless of\n>> whether one agrees with it or not.\n>>\n>> Regards,\n>> Richard\n>>\n>>\n>>\n>>\n>------------------------------------------------------------------------------\n>> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n>> GigeNET is offering a free month of service with a new server in\n>Ashburn.\n>> Choose from 2 high performing configs, both with 100TB of bandwidth.\n>> Higher redundancy.Lower latency.Increased capacity.Completely\n>compliant.\n>> http://p.sf.net/sfu/gigenet\n>>\n>>\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n>------------------------------------------------------------------------\n>\n>------------------------------------------------------------------------------\n>New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n>GigeNET is offering a free month of service with a new server in\n>Ashburn.\n>Choose from 2 high performing configs, both with 100TB of bandwidth.\n>Higher redundancy.Lower latency.Increased capacity.Completely\n>compliant.\n>http://p.sf.net/sfu/gigenet\n>\n>------------------------------------------------------------------------\n>\n>_______________________________________________\n>Bitcoin-development mailing list\n>Bitcoin-development at lists.sourceforge.net\n>https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n-----BEGIN PGP SIGNATURE-----\nVersion: APG v1.1.1\n\niQFQBAEBCAA6BQJUvWPOMxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8\ncGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhbq4CACAptz1s1rYdQtviI5Y\nUrqoifRAldRlUaOphle5OKCK+Gus0zqhqm/kiaQtbCg39F1gZ43QrJ/+t9kjZ19l\nQcrtnIEffAyBdzCXiZH7N9HwGalxBRyiUcKc5iZT2DOYw4rwdJvYXB/PdlPOvGkq\nrx/q93r2dJSFMFonnmM9pzbvUKS6dLrAWUTJCWH9EVK54TxBjVkoPXuZJEGBHr88\n6MMTiRu1+KblxZbOozGRIXmrfd/7+akM6jLMU9FO4BwosUitOc9OWznGS1rvumlQ\n5ESTzaiM9TpBLIW3rkJZmqA51Z1lbgVxXFA4HbctyQeMKIZxNn8e+RpWGYdpCblc\nwfd6\n=GYj6\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Mike Hearn",
                "date": "2015-01-19T20:40:13",
                "message_text_only": ">\n> I'm a bit confused.  It's been a long time since I looked at protobuf (and\n> will have to dig into it soon), but I seem to recall it doesn't have any of\n> the determinism properties you guys just said.\n>\n\nIt's not guaranteed no, which is why we store signed sub-messages as byte\narrays instead of typed submessages. In practice though, most\nimplementations do seem to serialise things the same way. I recall Python\nused to be an odd one out, unsure if it still is.\n\nOK, I guess we can boil this down more simply. BIP 70 uses protocol buffers\nbecause I designed it and implemented the original prototype (with lots of\ninput from Gavin and an earlier proposal by sipa). I used protocol buffers\nbecause, beyond all their nice properties, I used to work at Google and so\nwas very familiar with them.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/bbd8b7d4/attachment.html>"
            },
            {
                "author": "Gavin Andresen",
                "date": "2015-01-19T20:56:37",
                "message_text_only": "On Mon, Jan 19, 2015 at 3:40 PM, Mike Hearn <mike at plan99.net> wrote:\n\n> OK, I guess we can boil this down more simply. BIP 70 uses protocol\n>> buffers because I designed it and implemented the original prototype (with\n>> lots of input from Gavin and an earlier proposal by sipa). I used protocol\n>> buffers because, beyond all their nice properties, I used to work at Google\n>> and so was very familiar with them.\n>>\n>\nWhat Mike said. Runner-up for encoding was JSON.\n\nXML+ASN.1 was Right Out, because lots of us hate XML and ASN.1 with a\nburning passion. Complexity is the Enemy of Security, and both XML and\nASN.1 are too complex.\n\n\n-- \n--\nGavin Andresen\nChief Scientist, Bitcoin Foundation\nhttps://www.bitcoinfoundation.org/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/e1a3fb5a/attachment.html>"
            },
            {
                "author": "Brian Hoffman",
                "date": "2015-01-19T21:22:49",
                "message_text_only": "Damn if SPKI had won out we would be parsing S-expressions instead of X.509 certificates. ASN.1 is not fun IMHO.\n\n\n> On Jan 19, 2015, at 3:56 PM, Gavin Andresen <gavin at bitcoinfoundation.org> wrote:\n> \n> On Mon, Jan 19, 2015 at 3:40 PM, Mike Hearn <mike at plan99.net> wrote:\n>>> OK, I guess we can boil this down more simply. BIP 70 uses protocol buffers because I designed it and implemented the original prototype (with lots of input from Gavin and an earlier proposal by sipa). I used protocol buffers because, beyond all their nice properties, I used to work at Google and so was very familiar with them.\n> \n> \n> What Mike said. Runner-up for encoding was JSON.\n> \n> XML+ASN.1 was Right Out, because lots of us hate XML and ASN.1 with a burning passion. Complexity is the Enemy of Security, and both XML and ASN.1 are too complex.\n> \n> \n> -- \n> --\n> Gavin Andresen\n> Chief Scientist, Bitcoin Foundation\n> https://www.bitcoinfoundation.org/\n> \n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/ea970d31/attachment.html>"
            },
            {
                "author": "Ross Nicoll",
                "date": "2015-01-19T20:59:16",
                "message_text_only": "For what it's worth, there was consideration of replacing protocol\nbuffers when modifying BIP70 to function with the altcoin I work on\n(changes were required anyway in eliminate any risk that payment\nrequests could not be accidentally applied to the wrong blockchain). The\neventual conclusion was that while we might have used JSON or XML if we\nwere starting from scratch, there's no choice that's clearly better.\nWhile deployed infrastructure for payment protocol is still quite\nlimited, it seems that the cost to replace at this point is higher than not.\n\nIf there's ever a major reworking of the standard, for example to handle\nrecurring payments, it's probably worth thinking about then, but\nprotocol buffers result in a compact data format which is supported by\nmost major languages (and size is a concern if dealing with Bluetooth or\nNFC), and has no major drawbacks I am aware of.\n\nRoss\n\nOn 19/01/2015 20:40, Mike Hearn wrote:\n>> I'm a bit confused.  It's been a long time since I looked at protobuf (and\n>> will have to dig into it soon), but I seem to recall it doesn't have any of\n>> the determinism properties you guys just said.\n>>\n> It's not guaranteed no, which is why we store signed sub-messages as byte\n> arrays instead of typed submessages. In practice though, most\n> implementations do seem to serialise things the same way. I recall Python\n> used to be an odd one out, unsure if it still is.\n>\n> OK, I guess we can boil this down more simply. BIP 70 uses protocol buffers\n> because I designed it and implemented the original prototype (with lots of\n> input from Gavin and an earlier proposal by sipa). I used protocol buffers\n> because, beyond all their nice properties, I used to work at Google and so\n> was very familiar with them.\n>\n>\n>\n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/c508d0e9/attachment.html>"
            },
            {
                "author": "Isidor Zeuner",
                "date": "2015-01-24T13:19:34",
                "message_text_only": "> For what it's worth, there was consideration of replacing protocol\n> buffers when modifying BIP70 to function with the altcoin I work on\n> (changes were required anyway in eliminate any risk that payment\n> requests could not be accidentally applied to the wrong blockchain).\n\nWhy not serialize some kind of blockchain identifier with the\nmessages? Arbitrarily deviating from a given design choice just for\nthe sake of doing it differently may serve the goal of creating more\noverall code diversity, but would not necessarily serve the quality of\nthe blockchain network where it is done for.\n\nBest regards,\n\nIsidor"
            },
            {
                "author": "Ross Nicoll",
                "date": "2015-01-25T22:59:37",
                "message_text_only": "That was essentially what we did in the end, we replaced the network\nidentifier (\"main\"/\"test\") with the genesis block hash. The result is\nnever going to accidentally work with Bitcoin Core (nor vice-versa), but\nis readily extensible to any other altcoins that want to use the\nspecification without requiring any sort of central registry.\n\nRoss\n\nOn 24/01/15 13:19, Isidor Zeuner wrote:\n>> For what it's worth, there was consideration of replacing protocol\n>> buffers when modifying BIP70 to function with the altcoin I work on\n>> (changes were required anyway in eliminate any risk that payment\n>> requests could not be accidentally applied to the wrong blockchain).\n>\n> Why not serialize some kind of blockchain identifier with the\n> messages? Arbitrarily deviating from a given design choice just for\n> the sake of doing it differently may serve the goal of creating more\n> overall code diversity, but would not necessarily serve the quality of\n> the blockchain network where it is done for.\n>\n> Best regards,\n>\n> Isidor"
            },
            {
                "author": "Jeff Garzik",
                "date": "2015-01-19T21:21:54",
                "message_text_only": "Correct.  I should have said \"more likely to be deterministic\"  Bitcoin\nCore does not *rely* on determinism in BIP70; I was referring to recent\nupstream efforts to make protobufs usable in a deterministic fashion by\ndefault.\n\nOn Mon, Jan 19, 2015 at 3:03 PM, Alan Reiner <etotheipi at gmail.com> wrote:\n\n>  I'm a bit confused.  It's been a long time since I looked at protobuf\n> (and will have to dig into it soon), but I seem to recall it doesn't have\n> any of the determinism properties you guys just said.  It is intended to\n> allow you to skip details of the on-the-wire representations and just send\n> a bunch of named fields between systems.  I thought there was no guarantee\n> that two identical protobuf structures will get serialized identically...?\n>\n>\n>\n>\n>\n> On 01/19/2015 02:57 PM, Richard Brady wrote:\n>\n>   Thanks guys, great answers.\n>\n>  The design choice certainly makes a lot more sense now regardless of\n> whether one agrees with it or not.\n>\n>  Regards,\n> Richard\n>\n>\n>\n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.http://p.sf.net/sfu/gigenet\n>\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing listBitcoin-development at lists.sourceforge.nethttps://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/5f969ba7/attachment.html>"
            },
            {
                "author": "Matt Whitlock",
                "date": "2015-01-19T19:19:50",
                "message_text_only": "Even if a compact binary encoding is a high priority, there are more \"standard\" choices than Google Protocol Buffers. For example, ASN.1 is a very rigorously defined standard that has been around for decades, and ASN.1 even has an XML encoding (XER) that is directly convertible to/from the binary encoding (BER/DER), given the schema. In practice, I'm mostly agnostic about what encoding is actually used in BIP70, and I wouldn't fault BIP70 for choosing Google Protocol Buffers, but the very existence of Protobuf perplexes me, as it apparently re-solves a problem that was solved 40 years ago by ASN.1. It's as though the engineers at Google weren't aware that ASN.1 existed.\n\n\nOn Monday, 19 January 2015, at 7:07 pm, Richard Brady wrote:\n> Hi Gavin, Mike and co\n> \n> Is there a strong driver behind the choice of Google Protocol Buffers for\n> payment request encoding in BIP-0070?\n> \n> Performance doesn't feel that relevant when you think that:\n> 1. Payment requests are not broadcast, this is a request / response flow,\n> much more akin to a web request.\n> 2. One would be cramming this data into a binary format just so you can\n> then attach it to a no-so-binary format such as HTTP.\n> \n> Some great things about protocols/encodings such as HTTP/JSON/XML are:\n> 1. They are human readable on-the-wire. No Wireshark plugin required,\n> tcpdump or ngrep will do.\n> 2. There are tons of great open source libraries and API for parsing /\n> manipulating / generating.\n> 3. It's really easy to hand-craft a test message for debugging.\n> 4. The standards are much easier to read and write. They don't need to\n> contain code like BIP-0070 currently does and they can contain examples,\n> which BIP70 does not.\n> 5. They are thoroughly specified by independent standards bodies such as\n> the IETF. Gotta love a bit of MUST / SHOULD / MAY in a standard.\n> 6. They're a family ;-)\n> \n> Keen to hear your thoughts on this and very keen to watch the payment\n> protocol grow regardless of encoding choice! My background is SIP / VoIP\n> and I think that could be a fascinating use case for this protocol which\n> I'm hoping to do some work on.\n> \n> Best,\n> Richard"
            },
            {
                "author": "Mike Hearn",
                "date": "2015-01-19T19:37:22",
                "message_text_only": "The engineers at Google were well aware that ASN.1 existed. I can assure\nyou of that, because I was one of them.\n\nThe protobuf FAQ has a very polite take on the matter:\n\n   https://developers.google.com/protocol-buffers/docs/faq\n\nThis email thread gives more enlightenment:\n\n   https://groups.google.com/forum/#!topic/protobuf/eNAZlnPKVW4\n\nAnyone who has actually had to work with both ASN.1 and protocol buffers\nwill be able to explain why ASN.1 should not be chosen for any modern\nformats. A lot of it boils down to simplicty and quality of\nimplementations, especially open source implementations.\n\nWith respect to the specific concerns Richard raises:\n\nPerformance doesn't feel that relevant when you think that:\n>\n\nPerformance wasn't a concern.\n\n\n> 2. One would be cramming this data into a binary format just so you can\n> then attach it to a no-so-binary format such as HTTP.\n>\n\nHTTP transmits files as binary on the wire. So it's binary-clean and,\nmoreover, HTTP/2 aka SPDY is fully binary and doesn't use text anywhere\nexcept the gzip dictionary.\n\n\n> 2. There are tons of great open source libraries and API for parsing /\n> manipulating / generating.\n>\n\nLuckily, this is also true of protocol buffers. Language support is pretty\ngood these days.\n\n\n> 4. The standards are much easier to read and write. They don't need to\n> contain code like BIP-0070 currently does and they can contain examples,\n> which BIP70 does not.\n>\n\nBIP 70 doesn't contain any code, as far as I know. The protobuf schema\nmight look like code, but it's not - it's just a description of what fields\na message can contain and their types. This is very relevant for a\nspecification!\n\nJSON in particular is pretty awful and I don't like it much. It suffers\ncomplexities with things as basic as encoding numbers and strings. It's\nvery much unsuited to applications where correctness matters and where\nyou're dealing with binary structures.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/e6a76662/attachment.html>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2015-01-19T19:38:23",
                "message_text_only": "ASN.1 is not nearly as flexible when it comes to well-supported libraries,\ngenerators, and the ecosystem that surrounds the actual encoding.  You\ndon't see ASN.1 compilers + language support packages for [all popular\nprogramming languages], as you do with protobufs.\n\nGoogle engineers were well aware it existed I'm sure.  There are wider\nconsiderations beyond the low-level specified format.\n\nProtobufs have their problems and aren't perfect, but ASN.1 ecosystem is\nfar less developed in the programming ecosystem, far less approachable for\nprogrammers.  BIP70 wouldn't have been as easily and widely adopted if\nASN.1 had been chosen.\n\n\n\n\nOn Mon, Jan 19, 2015 at 2:19 PM, Matt Whitlock <bip at mattwhitlock.name>\nwrote:\n\n> Even if a compact binary encoding is a high priority, there are more\n> \"standard\" choices than Google Protocol Buffers. For example, ASN.1 is a\n> very rigorously defined standard that has been around for decades, and\n> ASN.1 even has an XML encoding (XER) that is directly convertible to/from\n> the binary encoding (BER/DER), given the schema. In practice, I'm mostly\n> agnostic about what encoding is actually used in BIP70, and I wouldn't\n> fault BIP70 for choosing Google Protocol Buffers, but the very existence of\n> Protobuf perplexes me, as it apparently re-solves a problem that was solved\n> 40 years ago by ASN.1. It's as though the engineers at Google weren't aware\n> that ASN.1 existed.\n>\n>\n> On Monday, 19 January 2015, at 7:07 pm, Richard Brady wrote:\n> > Hi Gavin, Mike and co\n> >\n> > Is there a strong driver behind the choice of Google Protocol Buffers for\n> > payment request encoding in BIP-0070?\n> >\n> > Performance doesn't feel that relevant when you think that:\n> > 1. Payment requests are not broadcast, this is a request / response flow,\n> > much more akin to a web request.\n> > 2. One would be cramming this data into a binary format just so you can\n> > then attach it to a no-so-binary format such as HTTP.\n> >\n> > Some great things about protocols/encodings such as HTTP/JSON/XML are:\n> > 1. They are human readable on-the-wire. No Wireshark plugin required,\n> > tcpdump or ngrep will do.\n> > 2. There are tons of great open source libraries and API for parsing /\n> > manipulating / generating.\n> > 3. It's really easy to hand-craft a test message for debugging.\n> > 4. The standards are much easier to read and write. They don't need to\n> > contain code like BIP-0070 currently does and they can contain examples,\n> > which BIP70 does not.\n> > 5. They are thoroughly specified by independent standards bodies such as\n> > the IETF. Gotta love a bit of MUST / SHOULD / MAY in a standard.\n> > 6. They're a family ;-)\n> >\n> > Keen to hear your thoughts on this and very keen to watch the payment\n> > protocol grow regardless of encoding choice! My background is SIP / VoIP\n> > and I think that could be a fascinating use case for this protocol which\n> > I'm hoping to do some work on.\n> >\n> > Best,\n> > Richard\n>\n>\n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/439ccfd3/attachment.html>"
            },
            {
                "author": "Richard Brady",
                "date": "2015-01-19T19:16:54",
                "message_text_only": "Fair points, although for me the line is blurred between which of those are\nsecurity considerations vs performance considerations.\n\nRichard\n\nOn 19 January 2015 at 19:09, Jeff Garzik <jgarzik at bitpay.com> wrote:\n\n> Text formats such as XML or JSON are far less deterministic, are more\n> loosely specified, have wide variance in parsing, are not very hash-able,\n> the list goes on.\n>\n>\n> On Mon, Jan 19, 2015 at 2:07 PM, Richard Brady <rnbrady at gmail.com> wrote:\n>\n>> Hi Gavin, Mike and co\n>>\n>> Is there a strong driver behind the choice of Google Protocol Buffers for\n>> payment request encoding in BIP-0070?\n>>\n>> Performance doesn't feel that relevant when you think that:\n>> 1. Payment requests are not broadcast, this is a request / response flow,\n>> much more akin to a web request.\n>> 2. One would be cramming this data into a binary format just so you can\n>> then attach it to a no-so-binary format such as HTTP.\n>>\n>> Some great things about protocols/encodings such as HTTP/JSON/XML are:\n>> 1. They are human readable on-the-wire. No Wireshark plugin required,\n>> tcpdump or ngrep will do.\n>> 2. There are tons of great open source libraries and API for parsing /\n>> manipulating / generating.\n>> 3. It's really easy to hand-craft a test message for debugging.\n>> 4. The standards are much easier to read and write. They don't need to\n>> contain code like BIP-0070 currently does and they can contain examples,\n>> which BIP70 does not.\n>> 5. They are thoroughly specified by independent standards bodies such as\n>> the IETF. Gotta love a bit of MUST / SHOULD / MAY in a standard.\n>> 6. They're a family ;-)\n>>\n>> Keen to hear your thoughts on this and very keen to watch the payment\n>> protocol grow regardless of encoding choice! My background is SIP / VoIP\n>> and I think that could be a fascinating use case for this protocol which\n>> I'm hoping to do some work on.\n>>\n>> Best,\n>> Richard\n>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/edf3572c/attachment.html>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2015-01-19T19:34:18",
                "message_text_only": "None of those listed were in the context of performance.  Parsing of binary\nor text is quite fast these days, and is not really a consideration versus\nother needs such as a predictable encoding for a single data\nrepresentation.  XML and JSON both can represent the same post-evaluation\nuser data a million different ways, which is awful for anything you are\nsigning and hashing.  Text formats also transit binary data very poorly,\nleading to unnecessary wrapping and unwrappiing (a programmatic, visibility\n& bug; again performance not a primary concern).\n\nThis is evident because both XML and JSON have standards efforts under way\nto correct some of these problems and make them more deterministic.\nHowever, such standards are not field deployed and widely supported by\nparsers and generators alike.\n\n\n\n\nOn Mon, Jan 19, 2015 at 2:16 PM, Richard Brady <rnbrady at gmail.com> wrote:\n\n> Fair points, although for me the line is blurred between which of those\n> are security considerations vs performance considerations.\n>\n> Richard\n>\n> On 19 January 2015 at 19:09, Jeff Garzik <jgarzik at bitpay.com> wrote:\n>\n>> Text formats such as XML or JSON are far less deterministic, are more\n>> loosely specified, have wide variance in parsing, are not very hash-able,\n>> the list goes on.\n>>\n>>\n>> On Mon, Jan 19, 2015 at 2:07 PM, Richard Brady <rnbrady at gmail.com> wrote:\n>>\n>>> Hi Gavin, Mike and co\n>>>\n>>> Is there a strong driver behind the choice of Google Protocol Buffers\n>>> for payment request encoding in BIP-0070?\n>>>\n>>> Performance doesn't feel that relevant when you think that:\n>>> 1. Payment requests are not broadcast, this is a request / response\n>>> flow, much more akin to a web request.\n>>> 2. One would be cramming this data into a binary format just so you can\n>>> then attach it to a no-so-binary format such as HTTP.\n>>>\n>>> Some great things about protocols/encodings such as HTTP/JSON/XML are:\n>>> 1. They are human readable on-the-wire. No Wireshark plugin required,\n>>> tcpdump or ngrep will do.\n>>> 2. There are tons of great open source libraries and API for parsing /\n>>> manipulating / generating.\n>>> 3. It's really easy to hand-craft a test message for debugging.\n>>> 4. The standards are much easier to read and write. They don't need to\n>>> contain code like BIP-0070 currently does and they can contain examples,\n>>> which BIP70 does not.\n>>> 5. They are thoroughly specified by independent standards bodies such as\n>>> the IETF. Gotta love a bit of MUST / SHOULD / MAY in a standard.\n>>> 6. They're a family ;-)\n>>>\n>>> Keen to hear your thoughts on this and very keen to watch the payment\n>>> protocol grow regardless of encoding choice! My background is SIP / VoIP\n>>> and I think that could be a fascinating use case for this protocol which\n>>> I'm hoping to do some work on.\n>>>\n>>> Best,\n>>> Richard\n>>>\n>>>\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/eb614bf2/attachment.html>"
            },
            {
                "author": "Nicolas DORIER",
                "date": "2015-01-28T12:45:29",
                "message_text_only": "I agree that the use protocol buffer and x509 by BIP70 is a poor choice.\n\nThe choice should have been done to maximize portability, not to maximize\nefficiency and flexibility.\n\nWhat I ended up doing for having a similar codebase on all plateform is to\nparse a BIP70 messages with the help of a web service that convert it to\nJSON.\nI don't like this solution since it had a trust dependency, and the\ncertificate verification become handled by the web service, not the device.\nBut even if I solved google buffer problem, I would stumble upon having\nheadache to validate the x509 certificate chain on every plateforms.\n\nA simple BIP70 using JSON + HTTPS would have make things more easy.\nI agree that it requires that the merchant own the domain name of the BIP70\nendpoint, but I don't consider such a big of a deal, since this is how\ne-commerce works.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/6e5b0a0e/attachment.html>"
            },
            {
                "author": "Wladimir",
                "date": "2015-01-28T13:32:40",
                "message_text_only": "On Wed, 28 Jan 2015, Nicolas DORIER wrote:\n\n> I agree that the use protocol buffer and x509 by BIP70 is a poor choice.\n\nWell x509 is an international standard in common use, you can't do much \nbetter with regard to portability. Your suggestion about HTTPS makes \nlittle sense, you do know what TLS uses x509 internally as well?\n\nRe: protocol buffers, I don't know if it's the best possible one, but one \nserialization method had to be picked. If it weren't, we could still have \nstill been discussing which one to use by now. Just like for JSON there \nare bindings for many languages.\n\nThough JSON parsers are much more diverse, which people using Bitcoin \nCore's RPC have bumped into e.g. some have some problems \nhandling large numbers. Something you wouldn't expect using a \nstraightforward binary format. There's no obvious best choice.\n\nWladimir"
            },
            {
                "author": "Nicolas DORIER",
                "date": "2015-01-28T14:00:40",
                "message_text_only": "Sure I know that x509 is international standard. And that HTTPS uses TLS.\nThis is not my point, my point is that when we use HTTPS the developer\ndelegates certificates verification to the plateform he is running on, so\ndeveloper don't have to bother about it, making the implementation safer\nand easier.\n\nOn the other hand, if you charge the developer (and not the plateform) to\ncheck certificate validity, it means that you have to develop a different\ncodebase for all plateform you are targeting, because each plateform store\ntrusted root certificate in a different manner with different APIs, and\nalso have different types representing a X509 Certificate.\n\nSo, let's say I want to target IOS + WP + Android + WinRT + desktop win, I\nneed to develop 4 times chain verification and certificate parsing.\n(Because I can't verify a certificate if it is not in the specific type of\nthe underlying plateform)\n\nAnd since it would take too much time to do that, I end up delegating\nparsing and trust verification to a third party service.\n\n2015-01-28 14:32 GMT+01:00 Wladimir <laanwj at gmail.com>:\n\n>\n> On Wed, 28 Jan 2015, Nicolas DORIER wrote:\n>\n>  I agree that the use protocol buffer and x509 by BIP70 is a poor choice.\n>>\n>\n> Well x509 is an international standard in common use, you can't do much\n> better with regard to portability. Your suggestion about HTTPS makes little\n> sense, you do know what TLS uses x509 internally as well?\n>\n> Re: protocol buffers, I don't know if it's the best possible one, but one\n> serialization method had to be picked. If it weren't, we could still have\n> still been discussing which one to use by now. Just like for JSON there are\n> bindings for many languages.\n>\n> Though JSON parsers are much more diverse, which people using Bitcoin\n> Core's RPC have bumped into e.g. some have some problems handling large\n> numbers. Something you wouldn't expect using a straightforward binary\n> format. There's no obvious best choice.\n>\n> Wladimir\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/193f06f5/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2015-01-28T15:42:42",
                "message_text_only": ">\n> On the other hand, if you charge the developer (and not the plateform) to\n> check certificate validity, it means that you have to develop a different\n> codebase for all plateform you are targeting, because each plateform store\n> trusted root certificate in a different manner with different APIs, and\n> also have different types representing a X509 Certificate.\n>\n\nThat's what cross-platform abstraction libraries are for. Both Java and Qt\nprovide a key store library that can load from either the OS root store or\na custom one. If your chosen app platform doesn't, OK, then you'll have to\nmake or find one yourself. Perhaps contribute it upstream or make it a\nlibrary. But that's not a limitation of BIP70.\n\nJust as a reminder, there is no obligation to use the OS root store. You\ncan (and quite possibly should) take a snapshot of the Mozilla/Apple/MSFT\netc stores and load it in your app. We do this in bitcoinj by default to\navoid cases where BIP70 requests work on some platforms and not others,\nalthough the developer can easily override this and use the OS root store\ninstead.\n\nOf all possible solutions, using a third party service to convert things to\nJSON is one of the least obvious and highest effort. I don't know anyone\nelse who arrived at such a conclusion and respectfully disagree that this\nis a problem with the design choices in BIP70. It sounds like a bizarre\nhack around lack of features in whatever runtime you're using.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/aabfe25a/attachment.html>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2015-01-28T16:04:58",
                "message_text_only": "Not to mention the tiresome and error-prone task of writing your own\nJSON-to-schema marshalling code -- or something equivalent to the protobufs\ncompiler and libs for JSON.\n\nprotobufs -- and its modern competitors such as msgpack -- natively provide\ntype support in a way that must be hacked into JSON or XML.\n\nThe protobuf/msgpack design is engineered to avoid bugs routinely found in\nJSON parsing code; due to the amount of code & effort involved in JSON\ninput sanity checking, bugs and inconsistencies inevitable arise.  We have\nseen this in bitcoind with JSON-RPC.\n\n\n\nOn Wed, Jan 28, 2015 at 10:42 AM, Mike Hearn <mike at plan99.net> wrote:\n\n> On the other hand, if you charge the developer (and not the plateform) to\n>> check certificate validity, it means that you have to develop a different\n>> codebase for all plateform you are targeting, because each plateform store\n>> trusted root certificate in a different manner with different APIs, and\n>> also have different types representing a X509 Certificate.\n>>\n>\n> That's what cross-platform abstraction libraries are for. Both Java and Qt\n> provide a key store library that can load from either the OS root store or\n> a custom one. If your chosen app platform doesn't, OK, then you'll have to\n> make or find one yourself. Perhaps contribute it upstream or make it a\n> library. But that's not a limitation of BIP70.\n>\n> Just as a reminder, there is no obligation to use the OS root store. You\n> can (and quite possibly should) take a snapshot of the Mozilla/Apple/MSFT\n> etc stores and load it in your app. We do this in bitcoinj by default to\n> avoid cases where BIP70 requests work on some platforms and not others,\n> although the developer can easily override this and use the OS root store\n> instead.\n>\n> Of all possible solutions, using a third party service to convert things\n> to JSON is one of the least obvious and highest effort. I don't know anyone\n> else who arrived at such a conclusion and respectfully disagree that this\n> is a problem with the design choices in BIP70. It sounds like a bizarre\n> hack around lack of features in whatever runtime you're using.\n>\n>\n>\n> ------------------------------------------------------------------------------\n> Dive into the World of Parallel Programming. The Go Parallel Website,\n> sponsored by Intel and developed in partnership with Slashdot Media, is\n> your\n> hub for all things parallel software development, from weekly thought\n> leadership blogs to news, videos, case studies, tutorials and more. Take a\n> look and join the conversation now. http://goparallel.sourceforge.net/\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/328f8f70/attachment.html>"
            },
            {
                "author": "Nicolas DORIER",
                "date": "2015-01-28T16:52:54",
                "message_text_only": "For the number of field there is in the spec, I don't consider having a\nJSON to schama really worthwhile.\nIf you fear it is error prone, then we should provide some testing data for\nthe BIP70. (Which I already did for protobuf, but was rejected, because\ndeemed no useful thanks to the code generator... But such code generator\ngave me inconsistencies with gavin's implementation for example)\n\nWhy do you think type support is very useful in our case ? we have 3 types,\nand dealing only with bytes, int, and string.\nIt cost me more time to find a suitable cross plateform lib for protobuf\n(in c#, that works in ios and winrt) than I would by just coding the json\nwrapper classes by hand. (JSON libs are more wildspread and supported than\nprotobuf)\n\n2015-01-28 17:04 GMT+01:00 Jeff Garzik <jgarzik at bitpay.com>:\n\n> Not to mention the tiresome and error-prone task of writing your own\n> JSON-to-schema marshalling code -- or something equivalent to the protobufs\n> compiler and libs for JSON.\n>\n> protobufs -- and its modern competitors such as msgpack -- natively\n> provide type support in a way that must be hacked into JSON or XML.\n>\n> The protobuf/msgpack design is engineered to avoid bugs routinely found in\n> JSON parsing code; due to the amount of code & effort involved in JSON\n> input sanity checking, bugs and inconsistencies inevitable arise.  We have\n> seen this in bitcoind with JSON-RPC.\n>\n>\n>\n> On Wed, Jan 28, 2015 at 10:42 AM, Mike Hearn <mike at plan99.net> wrote:\n>\n>> On the other hand, if you charge the developer (and not the plateform) to\n>>> check certificate validity, it means that you have to develop a different\n>>> codebase for all plateform you are targeting, because each plateform store\n>>> trusted root certificate in a different manner with different APIs, and\n>>> also have different types representing a X509 Certificate.\n>>>\n>>\n>> That's what cross-platform abstraction libraries are for. Both Java and\n>> Qt provide a key store library that can load from either the OS root store\n>> or a custom one. If your chosen app platform doesn't, OK, then you'll have\n>> to make or find one yourself. Perhaps contribute it upstream or make it a\n>> library. But that's not a limitation of BIP70.\n>>\n>> Just as a reminder, there is no obligation to use the OS root store. You\n>> can (and quite possibly should) take a snapshot of the Mozilla/Apple/MSFT\n>> etc stores and load it in your app. We do this in bitcoinj by default to\n>> avoid cases where BIP70 requests work on some platforms and not others,\n>> although the developer can easily override this and use the OS root store\n>> instead.\n>>\n>> Of all possible solutions, using a third party service to convert things\n>> to JSON is one of the least obvious and highest effort. I don't know anyone\n>> else who arrived at such a conclusion and respectfully disagree that this\n>> is a problem with the design choices in BIP70. It sounds like a bizarre\n>> hack around lack of features in whatever runtime you're using.\n>>\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> Dive into the World of Parallel Programming. The Go Parallel Website,\n>> sponsored by Intel and developed in partnership with Slashdot Media, is\n>> your\n>> hub for all things parallel software development, from weekly thought\n>> leadership blogs to news, videos, case studies, tutorials and more. Take a\n>> look and join the conversation now. http://goparallel.sourceforge.net/\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>>\n>\n>\n> --\n> Jeff Garzik\n> Bitcoin core developer and open source evangelist\n> BitPay, Inc.      https://bitpay.com/\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/2eaf6cc2/attachment.html>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2015-01-28T17:29:53",
                "message_text_only": "It is not \"fear\", it is field experience.\n\nJSON has proven to be a bug generator for the reasons already stated.\n\nJSON does not include type marshalling and input validation.\nProtobufs/msgpack/etc. engineered those to occur automatically, because\nthat is an area shown by field experience to be a constant source of bugs\nand inconsistent parsing/validation behavior.\n\n\n\n\nOn Wed, Jan 28, 2015 at 11:52 AM, Nicolas DORIER <nicolas.dorier at gmail.com>\nwrote:\n\n> For the number of field there is in the spec, I don't consider having a\n> JSON to schama really worthwhile.\n> If you fear it is error prone, then we should provide some testing data\n> for the BIP70. (Which I already did for protobuf, but was rejected, because\n> deemed no useful thanks to the code generator... But such code generator\n> gave me inconsistencies with gavin's implementation for example)\n>\n> Why do you think type support is very useful in our case ? we have 3\n> types, and dealing only with bytes, int, and string.\n> It cost me more time to find a suitable cross plateform lib for protobuf\n> (in c#, that works in ios and winrt) than I would by just coding the json\n> wrapper classes by hand. (JSON libs are more wildspread and supported than\n> protobuf)\n>\n> 2015-01-28 17:04 GMT+01:00 Jeff Garzik <jgarzik at bitpay.com>:\n>\n>> Not to mention the tiresome and error-prone task of writing your own\n>> JSON-to-schema marshalling code -- or something equivalent to the protobufs\n>> compiler and libs for JSON.\n>>\n>> protobufs -- and its modern competitors such as msgpack -- natively\n>> provide type support in a way that must be hacked into JSON or XML.\n>>\n>> The protobuf/msgpack design is engineered to avoid bugs routinely found\n>> in JSON parsing code; due to the amount of code & effort involved in JSON\n>> input sanity checking, bugs and inconsistencies inevitable arise.  We have\n>> seen this in bitcoind with JSON-RPC.\n>>\n>>\n>>\n>> On Wed, Jan 28, 2015 at 10:42 AM, Mike Hearn <mike at plan99.net> wrote:\n>>\n>>> On the other hand, if you charge the developer (and not the plateform)\n>>>> to check certificate validity, it means that you have to develop a\n>>>> different codebase for all plateform you are targeting, because each\n>>>> plateform store trusted root certificate in a different manner with\n>>>> different APIs, and also have different types representing a X509\n>>>> Certificate.\n>>>>\n>>>\n>>> That's what cross-platform abstraction libraries are for. Both Java and\n>>> Qt provide a key store library that can load from either the OS root store\n>>> or a custom one. If your chosen app platform doesn't, OK, then you'll have\n>>> to make or find one yourself. Perhaps contribute it upstream or make it a\n>>> library. But that's not a limitation of BIP70.\n>>>\n>>> Just as a reminder, there is no obligation to use the OS root store. You\n>>> can (and quite possibly should) take a snapshot of the Mozilla/Apple/MSFT\n>>> etc stores and load it in your app. We do this in bitcoinj by default to\n>>> avoid cases where BIP70 requests work on some platforms and not others,\n>>> although the developer can easily override this and use the OS root store\n>>> instead.\n>>>\n>>> Of all possible solutions, using a third party service to convert things\n>>> to JSON is one of the least obvious and highest effort. I don't know anyone\n>>> else who arrived at such a conclusion and respectfully disagree that this\n>>> is a problem with the design choices in BIP70. It sounds like a bizarre\n>>> hack around lack of features in whatever runtime you're using.\n>>>\n>>>\n>>>\n>>> ------------------------------------------------------------------------------\n>>> Dive into the World of Parallel Programming. The Go Parallel Website,\n>>> sponsored by Intel and developed in partnership with Slashdot Media, is\n>>> your\n>>> hub for all things parallel software development, from weekly thought\n>>> leadership blogs to news, videos, case studies, tutorials and more. Take\n>>> a\n>>> look and join the conversation now. http://goparallel.sourceforge.net/\n>>> _______________________________________________\n>>> Bitcoin-development mailing list\n>>> Bitcoin-development at lists.sourceforge.net\n>>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>>\n>>>\n>>\n>>\n>> --\n>> Jeff Garzik\n>> Bitcoin core developer and open source evangelist\n>> BitPay, Inc.      https://bitpay.com/\n>>\n>\n>\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/37d1a41c/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2015-01-28T17:45:10",
                "message_text_only": ">\n> It is not \"fear\", it is field experience.\n>\n> JSON has proven to be a bug generator for the reasons already stated.\n>\n\nTo back Jeff up on this point, today we see this story:\n\nhttp://www.theregister.co.uk/2015/01/27/trivial_hole_left_black_phones_open_to_plunder/\n\nThe maker of BlackPhone \u2013 a mobile marketed as offering unusually high\nlevels of security \u2013 has patched *a critical vulnerability that allows\nhackers to run malicious code on the handsets*. Attackers need little more\nthan a phone number to send a message that can compromise the devices via\nthe Silent Text application.\n\n\"The SCIMP protocol encodes messages as JSON objects, which are then\ntransmitted to the remote party over XMPP,\" Dowd explained to *The Register*.\n\"*The flaw I discovered occurs during the deserialization of these JSON\nobjects*. It is *a type confusion vulnerability*, which when exploited\nallows an attacker to overwrite a pointer in memory, either partially or in\nfull. This pointer is later manipulated by the program and also the system\nallocator, allowing you to do things such as pass arbitrary pointers to\nfree().\"\n\nThe C++/Java/Python protocol buffer implementations are used by Google for\nall internal inter-server communication. Any similar exploit in them would\nresult in total bypass of their entire internal security and auditing\nsystem by allowing you to run code as any user. The Google security team is\nvery good, the protobuf code is carefully reviewed and the format is\nrelatively constrained. The chances of there being any security problems in\nthe parsing code generated by the protobuf compilers is drastically\nsmaller. As BIP70 requests are parsed by security sensitive code, this\nmatters.\n\nThe vision for BIP70 has always been to be a foundation for many features.\nWe haven't really done much with it so far because there have always been\nhigher priorities. But I hope that if Bitcoin continues to be successful\nand grows, one day payment requests will have many different features in\nthem and those will likely include many complex data structures.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/ec7ad39e/attachment.html>"
            },
            {
                "author": "Giuseppe Mazzotta",
                "date": "2015-01-28T16:19:55",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nOn 28-01-15 16:42, Mike Hearn wrote:\n> Just as a reminder, there is no obligation to use the OS root\n> store. You can (and quite possibly should) take a snapshot of the \n> Mozilla/Apple/MSFT etc stores and load it in your app. We do this\n> in bitcoinj by default to avoid cases where BIP70 requests work on\n> some platforms and not others, although the developer can easily\n> override this and use the OS root store instead.\n> \nExcept that Mozilla/Apple/MSFT will update these certificate stores -\nsecond their policies - and your snapshot/collection might get\noutdated at a different pace than the OS-provided certificates,\ndepending on how you (or the package maintainer) are rolling out updates.\n\nI am not saying that OS-provided certificate stores are a holy grail,\nas they comes with their quirks&headaches (for example try to install\nyour CA certificate on Mac), but generally I consider shipping your\nown snapshot a bad practice, as it makes the system less secure by\ndefault for the casual user and harder to audit for the (eventual) admins.\n\nIf you are a developer, that's a whole different story.\n\n- -- \n  Giuseppe Mazzotta\n    /- Bitonic _/\n-----BEGIN PGP SIGNATURE-----\n\niQEcBAEBCgAGBQJUyQwrAAoJEKWX1kB3NXekfLkH/3Bd2yPD0ccZRUzWJ47wQmFd\nuRxpOjlxZMy3ww4PpxPxqJTrSwyH0gwbNCbuXkds9kkx9+AwxEkT8VZXZVA1KNeo\nRaLNgqs4R5zK06shTjV+AXe5HwDCEeFuJIIRGM35D8kSKtbPuzKe5UtiIRaBRdZG\ne+d6CQKklYK8yn24hUGg30Y0rEcrLicXmcJlrjElA+8pKYDIeP3SrMWjLj9QKFhJ\nVBKxXlyviZ2LGf9wD6p+GLgjDu4LNEQdJPpTNzg7yWSegnKmxopefojkCrHtqJQ7\nLC4Lr3K3hp5Nbct1YWRt09VQYic/xaGBCSUdKTEL1xTUv7oD/DY7l15zjKi7gtw=\n=ZJVu\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Matt Whitlock",
                "date": "2015-01-28T16:51:06",
                "message_text_only": "On Wednesday, 28 January 2015, at 5:19 pm, Giuseppe Mazzotta wrote:\n> On 28-01-15 16:42, Mike Hearn wrote:\n> > Just as a reminder, there is no obligation to use the OS root\n> > store. You can (and quite possibly should) take a snapshot of the\n> > Mozilla/Apple/MSFT etc stores and load it in your app. We do this\n> > in bitcoinj by default to avoid cases where BIP70 requests work on\n> > some platforms and not others, although the developer can easily\n> > override this and use the OS root store instead.\n> >\n> Except that Mozilla/Apple/MSFT will update these certificate stores -\n> second their policies - and your snapshot/collection might get\n> outdated at a different pace than the OS-provided certificates,\n> depending on how you (or the package maintainer) are rolling out updates.\n\nI'm frankly _horrified_ to learn that BitcoinJ ships its own root CA certificates bundle. This means that, if a root CA gets breached and a certificate gets revoked, all BitcoinJ-using software will be vulnerable until BitcoinJ ships an update *and* the software in question pulls in the new BitcoinJ update and releases its own update. That might never happen."
            },
            {
                "author": "Mike Hearn",
                "date": "2015-01-28T17:02:15",
                "message_text_only": ">\n> I'm frankly _horrified_ to learn that BitcoinJ ships its own root CA\n> certificates bundle. This means that, if a root CA gets breached and a\n> certificate gets revoked, all BitcoinJ-using software will be vulnerable\n> until BitcoinJ ships an update *and* the software in question pulls in the\n> new BitcoinJ update and releases its own update. That might never happen.\n\n\nIf your wallet is unmaintained, you have other problems beyond (extremely\nrare) root CA revocations.\n\nAs far as I know the only time a CA in wide usage has been revoked entirely\nis DigiNotar.\n\nOne advantage of doing it this way is if, for example, a widely used piece\nof community infrastructure (e.g. bitcointalk, reddit, whatever) decides to\nbecome a CA, the Bitcoin community can decide to have different inclusion\nrules vs the OS/browser root CA programs. For example we'd probably relax\nthe constraint to use an HSM and just ensure that the rendering of the\nasserted identity isn't confusible with other kinds of more strongly\nprotected identities. For example no forum usernames like \"foo.com\" but\nrendering it in the UI as \"Reddit forum user foo.com\" would be OK.\n\nAlso you don't get problems due to old operating systems not including new\ncerts.\n\nFinally, Linux doesn't have any kind of standardised cert/keystore API.\nThere are a few places where popular distros put certs but AFAIK they\naren't standardised and there's no standard code to load them. So that's\nanother reason why there's a built in store.\n\nBut yes, this is a debatable topic on which reasonable people can disagree.\nThe API makes it easy to use the platform OS store for wallet devs that\nwant to do that, and I think using the platform store on Android is the\ndefault. It's only on the desktop where we fall back to a different store.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/bdcd16f5/attachment.html>"
            },
            {
                "author": "Nicolas DORIER",
                "date": "2015-01-28T16:34:26",
                "message_text_only": "My point is not that there is a limitation in BIP70. My point is that you\nput the burden of certificate verification on developer's shoulder when we\ncan just leverage built in HTTPS support of the platform.\nThis make cross plateform dev a nightmare.\n\nSure I can use a snapshot of moz/apple/msft store. I depends on\nBouncyCastle, as bitcoinj, so I theorically can use that way.\nHowever, if you want to use your plateform's store, then you are toasted,\nand the code for converting from BC X509 Certificate to one of each\nplateform is not obvious and is a headache. Thing that could be just left\nto the HTTPS support of your plateform.\n\nHave you tried to do that on windows RT and IOS ? I tried, and I quickly\nstopped doing that since it is not worth the effort. (Frankly I am not even\nsure you can on win rt, since the API is a stripped down version of windows)\n\nWhy have you not heard about the problem ? (until now, because I have this\nproblem because I need to have the same codebase on\nwinrt/win/android/ios/tablets)\nBecause bitcoinj just rely either java's own abstraction of certificate or\non BC one. But I highly doubt they are using the plateform store, and even\nif you theorically can, dealing with X509 is very prone to error... for\nsomething that the plateform should just do for you.\nAlso, you bundle mozilla's store in bitcoinj, what happen when the store\nchange and your customer have not intent to use bitcoinj new version ? by\nleveraging the plateform you benefit from automatic updates.\nAlso, does java stores deals with certificate revocations ? sure you can\ntheorically code that too... or just let the plateform deals with it.\n\nBIP70 does not limit to anything but it is a gigantic pain in the ass for\neasy cross development because of protobuff and embedded certificates.\nBIP70 is a client side technology, not a performance and storage critical\ndata structure.\n\nThe only valid point of having embedded certificates is to allow the owner\nof the website to be different from the merchant. But since merchants often\nhave their own website, a protocol without having to reinvent x509 would\nhave been better suited to current needs.\n\n2015-01-28 16:42 GMT+01:00 Mike Hearn <mike at plan99.net>:\n\n> On the other hand, if you charge the developer (and not the plateform) to\n>> check certificate validity, it means that you have to develop a different\n>> codebase for all plateform you are targeting, because each plateform store\n>> trusted root certificate in a different manner with different APIs, and\n>> also have different types representing a X509 Certificate.\n>>\n>\n> That's what cross-platform abstraction libraries are for. Both Java and Qt\n> provide a key store library that can load from either the OS root store or\n> a custom one. If your chosen app platform doesn't, OK, then you'll have to\n> make or find one yourself. Perhaps contribute it upstream or make it a\n> library. But that's not a limitation of BIP70.\n>\n> Just as a reminder, there is no obligation to use the OS root store. You\n> can (and quite possibly should) take a snapshot of the Mozilla/Apple/MSFT\n> etc stores and load it in your app. We do this in bitcoinj by default to\n> avoid cases where BIP70 requests work on some platforms and not others,\n> although the developer can easily override this and use the OS root store\n> instead.\n>\n> Of all possible solutions, using a third party service to convert things\n> to JSON is one of the least obvious and highest effort. I don't know anyone\n> else who arrived at such a conclusion and respectfully disagree that this\n> is a problem with the design choices in BIP70. It sounds like a bizarre\n> hack around lack of features in whatever runtime you're using.\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/8a32ba6e/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2015-01-28T16:55:43",
                "message_text_only": ">\n> My point is not that there is a limitation in BIP70. My point is that you\n> put the burden of certificate verification on developer's shoulder when we\n> can just leverage built in HTTPS support of the platform.\n>\n\nPlatforms that support HTTPS but not certificate handling are rare - I know\nHTML5 is such a platform but such apps are inherently dependent on the\nserver anyway and the server can just do the parsing and validation work\nitself. If WinRT is such a platform, OK, too bad.\n\nThe embedding of the certificates is not arbitrary or pointless, by the\nway. It's there for a very good reason - it makes the signed payment\nrequest verifiable by third parties. Effectively you can store the signed\nmessage and present it later to someone else, it's undeniable. Combined\nwith the transactions and merkle branches linking them to the block chain,\nwhat you have is a form of digital receipt ... a proof of purchase that can\nbe automatically verified as legitimate. This has all kinds of use cases.\n\nBecause of how HTTPS works, you can't easily prove to a third party that a\nserver gave you a piece of data. Doing so requires staggeringly complex\nhacks (see tls notary) and when we designed BIP70, those hacks didn't even\nexist. So we'd lose the benefit of having a digitally signed request.\n\nAdditionally, doing things this way means BIP70 requests can be signed by\nthings which are not HTTPS servers. For example you can sign with an email\naddress cert, an EV certificate i.e. a company, a certificate issued by\nsome user forum, whatever else we end up wanting. Not every payment\nrecipient can be identified by a domain name + dynamic session.\n\n\n> However, if you want to use your plateform's store, then you are toasted\n>\n\nThat's a bit melodramatic. BitcoinJ is able to use the Android, JRE,\nWindows and Mac certificate stores all using the same code or very minor\nvariants on it (e.g. on Mac you have to specify you want the system store\nbut it's a one-liner).\n\nYes, that's not *every* platform. Some will require custom binding glue and\nit depends what abstractions and languages you are using.\n\n\n> Have you tried to do that on windows RT and IOS ? I tried, and I quickly\n> stopped doing that since it is not worth the effort. (Frankly I am not even\n> sure you can on win rt, since the API is a stripped down version of windows)\n>\n\nThere is code to do iOS using the Apple APIs here:\n\nhttps://github.com/voisine/breadwallet/blob/master/BreadWallet/BRPaymentProtocol.m#L391\n\n\n> Why have you not heard about the problem ? (until now, because I have this\n> problem because I need to have the same codebase on\n> winrt/win/android/ios/tablets)\n>\n\nWinRT is a minority platform in the extreme, and all the other platforms\nyou mentioned have the necessary APIs. Java abstracts you from them. So I\nthink you are encountering this problem because you desire to target WinRT\nand other platforms with a single codebase. That's an unusual constraint.\n\nAFAIK the only other people who encountered this are BitPay, because they\nwant to do everything in Javascript which doesn't really provide any major\nAPIs.\n\n\n> Also, you bundle mozilla's store in bitcoinj, what happen when the store\n> change and your customer have not intent to use bitcoinj new version ? by\n> leveraging the plateform you benefit from automatic updates.\n>\n\nYes, there are pros and cons to bundling a custom root store.\n\n\n> Also, does java stores deals with certificate revocations ? sure you can\n> theorically code that too... or just let the plateform deals with it.\n>\n\nIt can do OCSP checks, yes, although I believe no wallets currently do so.\nA better solution would be to implement an OCSP stapling extension to BIP70\nthough.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/04112261/attachment.html>"
            },
            {
                "author": "Nicolas Dorier",
                "date": "2015-01-28T17:04:40",
                "message_text_only": "Mike, I am not denying it is impossible to do all of that.\nJust that it is not a trivial stuff to do to make it works everywhere, and\nI think that it is not a good thing for a client side technology.\nBIP70 has its use, and I understand why there is case where it is good to\nship the certs in the message and not depends on the transport.\n\nBut a standard that just use JSON and HTTPS, even if less flexible that\nBIP70, would make it easier and sufficient for today's use case.\n\nOn Wed, Jan 28, 2015 at 5:55 PM, Mike Hearn <mike at plan99.net> wrote:\n\n> My point is not that there is a limitation in BIP70. My point is that you\n>> put the burden of certificate verification on developer's shoulder when we\n>> can just leverage built in HTTPS support of the platform.\n>>\n>\n> Platforms that support HTTPS but not certificate handling are rare - I\n> know HTML5 is such a platform but such apps are inherently dependent on the\n> server anyway and the server can just do the parsing and validation work\n> itself. If WinRT is such a platform, OK, too bad.\n>\n> The embedding of the certificates is not arbitrary or pointless, by the\n> way. It's there for a very good reason - it makes the signed payment\n> request verifiable by third parties. Effectively you can store the signed\n> message and present it later to someone else, it's undeniable. Combined\n> with the transactions and merkle branches linking them to the block chain,\n> what you have is a form of digital receipt ... a proof of purchase that can\n> be automatically verified as legitimate. This has all kinds of use cases.\n>\n> Because of how HTTPS works, you can't easily prove to a third party that a\n> server gave you a piece of data. Doing so requires staggeringly complex\n> hacks (see tls notary) and when we designed BIP70, those hacks didn't even\n> exist. So we'd lose the benefit of having a digitally signed request.\n>\n> Additionally, doing things this way means BIP70 requests can be signed by\n> things which are not HTTPS servers. For example you can sign with an email\n> address cert, an EV certificate i.e. a company, a certificate issued by\n> some user forum, whatever else we end up wanting. Not every payment\n> recipient can be identified by a domain name + dynamic session.\n>\n>\n>> However, if you want to use your plateform's store, then you are toasted\n>>\n>\n> That's a bit melodramatic. BitcoinJ is able to use the Android, JRE,\n> Windows and Mac certificate stores all using the same code or very minor\n> variants on it (e.g. on Mac you have to specify you want the system store\n> but it's a one-liner).\n>\n> Yes, that's not *every* platform. Some will require custom binding glue\n> and it depends what abstractions and languages you are using.\n>\n>\n>> Have you tried to do that on windows RT and IOS ? I tried, and I quickly\n>> stopped doing that since it is not worth the effort. (Frankly I am not even\n>> sure you can on win rt, since the API is a stripped down version of windows)\n>>\n>\n> There is code to do iOS using the Apple APIs here:\n>\n>\n> https://github.com/voisine/breadwallet/blob/master/BreadWallet/BRPaymentProtocol.m#L391\n>\n>\n>> Why have you not heard about the problem ? (until now, because I have\n>> this problem because I need to have the same codebase on\n>> winrt/win/android/ios/tablets)\n>>\n>\n> WinRT is a minority platform in the extreme, and all the other platforms\n> you mentioned have the necessary APIs. Java abstracts you from them. So I\n> think you are encountering this problem because you desire to target WinRT\n> and other platforms with a single codebase. That's an unusual constraint.\n>\n> AFAIK the only other people who encountered this are BitPay, because they\n> want to do everything in Javascript which doesn't really provide any major\n> APIs.\n>\n>\n>> Also, you bundle mozilla's store in bitcoinj, what happen when the store\n>> change and your customer have not intent to use bitcoinj new version ? by\n>> leveraging the plateform you benefit from automatic updates.\n>>\n>\n> Yes, there are pros and cons to bundling a custom root store.\n>\n>\n>> Also, does java stores deals with certificate revocations ? sure you can\n>> theorically code that too... or just let the plateform deals with it.\n>>\n>\n> It can do OCSP checks, yes, although I believe no wallets currently do so.\n> A better solution would be to implement an OCSP stapling extension to BIP70\n> though.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/0b7e5cdf/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2015-01-28T17:14:07",
                "message_text_only": "I think we'll just have to agree to disagree on this one. I've implemented\nBIP70 a couple of times now and didn't find it to be difficult. I know you\nhad odd problems with the C# protobuf implementation you were using but\nlibrary bugs can happen for any kind of programming.\n\nI forgot to mention the other reason it's done this way. One of the driving\ngoals of BIP70 was to support the TREZOR and similar devices. For hardware\nwallets, it's critical to keep the amount of code they need to run as small\nas possible. Any bugs in the code there can cause security holes and lead\nto the device being hacked.\n\nDoing it the way you suggest would mean the secure code would have to\ncontain complex and bug-prone text parsing logic as well as a full blown\nHTTP and SSL stack, that requires not only X.509 handling but also lots of\nother stuff on top. It'd increase cost, complexity and decrease security\nquite a bit.\n\nWhilst I appreciate if your platform provides a scripting-like API and\nnothing low level it might seem easier to use JSON+HTTPS, that isn't the\ncase for one of the primary design targets.\n\n\n\nOn Wed, Jan 28, 2015 at 6:04 PM, Nicolas Dorier <nicolas.dorier at gmail.com>\nwrote:\n\n> Mike, I am not denying it is impossible to do all of that.\n> Just that it is not a trivial stuff to do to make it works everywhere, and\n> I think that it is not a good thing for a client side technology.\n> BIP70 has its use, and I understand why there is case where it is good to\n> ship the certs in the message and not depends on the transport.\n>\n> But a standard that just use JSON and HTTPS, even if less flexible that\n> BIP70, would make it easier and sufficient for today's use case.\n>\n> On Wed, Jan 28, 2015 at 5:55 PM, Mike Hearn <mike at plan99.net> wrote:\n>\n>> My point is not that there is a limitation in BIP70. My point is that you\n>>> put the burden of certificate verification on developer's shoulder when we\n>>> can just leverage built in HTTPS support of the platform.\n>>>\n>>\n>> Platforms that support HTTPS but not certificate handling are rare - I\n>> know HTML5 is such a platform but such apps are inherently dependent on the\n>> server anyway and the server can just do the parsing and validation work\n>> itself. If WinRT is such a platform, OK, too bad.\n>>\n>> The embedding of the certificates is not arbitrary or pointless, by the\n>> way. It's there for a very good reason - it makes the signed payment\n>> request verifiable by third parties. Effectively you can store the signed\n>> message and present it later to someone else, it's undeniable. Combined\n>> with the transactions and merkle branches linking them to the block chain,\n>> what you have is a form of digital receipt ... a proof of purchase that can\n>> be automatically verified as legitimate. This has all kinds of use cases.\n>>\n>> Because of how HTTPS works, you can't easily prove to a third party that\n>> a server gave you a piece of data. Doing so requires staggeringly complex\n>> hacks (see tls notary) and when we designed BIP70, those hacks didn't even\n>> exist. So we'd lose the benefit of having a digitally signed request.\n>>\n>> Additionally, doing things this way means BIP70 requests can be signed by\n>> things which are not HTTPS servers. For example you can sign with an email\n>> address cert, an EV certificate i.e. a company, a certificate issued by\n>> some user forum, whatever else we end up wanting. Not every payment\n>> recipient can be identified by a domain name + dynamic session.\n>>\n>>\n>>> However, if you want to use your plateform's store, then you are toasted\n>>>\n>>\n>> That's a bit melodramatic. BitcoinJ is able to use the Android, JRE,\n>> Windows and Mac certificate stores all using the same code or very minor\n>> variants on it (e.g. on Mac you have to specify you want the system store\n>> but it's a one-liner).\n>>\n>> Yes, that's not *every* platform. Some will require custom binding glue\n>> and it depends what abstractions and languages you are using.\n>>\n>>\n>>> Have you tried to do that on windows RT and IOS ? I tried, and I quickly\n>>> stopped doing that since it is not worth the effort. (Frankly I am not even\n>>> sure you can on win rt, since the API is a stripped down version of windows)\n>>>\n>>\n>> There is code to do iOS using the Apple APIs here:\n>>\n>>\n>> https://github.com/voisine/breadwallet/blob/master/BreadWallet/BRPaymentProtocol.m#L391\n>>\n>>\n>>> Why have you not heard about the problem ? (until now, because I have\n>>> this problem because I need to have the same codebase on\n>>> winrt/win/android/ios/tablets)\n>>>\n>>\n>> WinRT is a minority platform in the extreme, and all the other platforms\n>> you mentioned have the necessary APIs. Java abstracts you from them. So I\n>> think you are encountering this problem because you desire to target WinRT\n>> and other platforms with a single codebase. That's an unusual constraint.\n>>\n>> AFAIK the only other people who encountered this are BitPay, because they\n>> want to do everything in Javascript which doesn't really provide any major\n>> APIs.\n>>\n>>\n>>> Also, you bundle mozilla's store in bitcoinj, what happen when the store\n>>> change and your customer have not intent to use bitcoinj new version ? by\n>>> leveraging the plateform you benefit from automatic updates.\n>>>\n>>\n>> Yes, there are pros and cons to bundling a custom root store.\n>>\n>>\n>>> Also, does java stores deals with certificate revocations ? sure you can\n>>> theorically code that too... or just let the plateform deals with it.\n>>>\n>>\n>> It can do OCSP checks, yes, although I believe no wallets currently do\n>> so. A better solution would be to implement an OCSP stapling extension to\n>> BIP70 though.\n>>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/c4fd4b47/attachment.html>"
            },
            {
                "author": "Angel Leon",
                "date": "2015-01-28T17:17:54",
                "message_text_only": "why not allow both serializations and keep serialization format a\nparameter, keep everyone happy.\n\nhttp://twitter.com/gubatron\n\nOn Wed, Jan 28, 2015 at 12:14 PM, Mike Hearn <mike at plan99.net> wrote:\n\n> I think we'll just have to agree to disagree on this one. I've implemented\n> BIP70 a couple of times now and didn't find it to be difficult. I know you\n> had odd problems with the C# protobuf implementation you were using but\n> library bugs can happen for any kind of programming.\n>\n> I forgot to mention the other reason it's done this way. One of the\n> driving goals of BIP70 was to support the TREZOR and similar devices. For\n> hardware wallets, it's critical to keep the amount of code they need to run\n> as small as possible. Any bugs in the code there can cause security holes\n> and lead to the device being hacked.\n>\n> Doing it the way you suggest would mean the secure code would have to\n> contain complex and bug-prone text parsing logic as well as a full blown\n> HTTP and SSL stack, that requires not only X.509 handling but also lots of\n> other stuff on top. It'd increase cost, complexity and decrease security\n> quite a bit.\n>\n> Whilst I appreciate if your platform provides a scripting-like API and\n> nothing low level it might seem easier to use JSON+HTTPS, that isn't the\n> case for one of the primary design targets.\n>\n>\n>\n> On Wed, Jan 28, 2015 at 6:04 PM, Nicolas Dorier <nicolas.dorier at gmail.com>\n> wrote:\n>\n>> Mike, I am not denying it is impossible to do all of that.\n>> Just that it is not a trivial stuff to do to make it works everywhere,\n>> and I think that it is not a good thing for a client side technology.\n>> BIP70 has its use, and I understand why there is case where it is good to\n>> ship the certs in the message and not depends on the transport.\n>>\n>> But a standard that just use JSON and HTTPS, even if less flexible that\n>> BIP70, would make it easier and sufficient for today's use case.\n>>\n>> On Wed, Jan 28, 2015 at 5:55 PM, Mike Hearn <mike at plan99.net> wrote:\n>>\n>>> My point is not that there is a limitation in BIP70. My point is that\n>>>> you put the burden of certificate verification on developer's shoulder when\n>>>> we can just leverage built in HTTPS support of the platform.\n>>>>\n>>>\n>>> Platforms that support HTTPS but not certificate handling are rare - I\n>>> know HTML5 is such a platform but such apps are inherently dependent on the\n>>> server anyway and the server can just do the parsing and validation work\n>>> itself. If WinRT is such a platform, OK, too bad.\n>>>\n>>> The embedding of the certificates is not arbitrary or pointless, by the\n>>> way. It's there for a very good reason - it makes the signed payment\n>>> request verifiable by third parties. Effectively you can store the signed\n>>> message and present it later to someone else, it's undeniable. Combined\n>>> with the transactions and merkle branches linking them to the block chain,\n>>> what you have is a form of digital receipt ... a proof of purchase that can\n>>> be automatically verified as legitimate. This has all kinds of use cases.\n>>>\n>>> Because of how HTTPS works, you can't easily prove to a third party that\n>>> a server gave you a piece of data. Doing so requires staggeringly complex\n>>> hacks (see tls notary) and when we designed BIP70, those hacks didn't even\n>>> exist. So we'd lose the benefit of having a digitally signed request.\n>>>\n>>> Additionally, doing things this way means BIP70 requests can be signed\n>>> by things which are not HTTPS servers. For example you can sign with an\n>>> email address cert, an EV certificate i.e. a company, a certificate issued\n>>> by some user forum, whatever else we end up wanting. Not every payment\n>>> recipient can be identified by a domain name + dynamic session.\n>>>\n>>>\n>>>> However, if you want to use your plateform's store, then you are toasted\n>>>>\n>>>\n>>> That's a bit melodramatic. BitcoinJ is able to use the Android, JRE,\n>>> Windows and Mac certificate stores all using the same code or very minor\n>>> variants on it (e.g. on Mac you have to specify you want the system store\n>>> but it's a one-liner).\n>>>\n>>> Yes, that's not *every* platform. Some will require custom binding glue\n>>> and it depends what abstractions and languages you are using.\n>>>\n>>>\n>>>> Have you tried to do that on windows RT and IOS ? I tried, and I\n>>>> quickly stopped doing that since it is not worth the effort. (Frankly I am\n>>>> not even sure you can on win rt, since the API is a stripped down version\n>>>> of windows)\n>>>>\n>>>\n>>> There is code to do iOS using the Apple APIs here:\n>>>\n>>>\n>>> https://github.com/voisine/breadwallet/blob/master/BreadWallet/BRPaymentProtocol.m#L391\n>>>\n>>>\n>>>> Why have you not heard about the problem ? (until now, because I have\n>>>> this problem because I need to have the same codebase on\n>>>> winrt/win/android/ios/tablets)\n>>>>\n>>>\n>>> WinRT is a minority platform in the extreme, and all the other platforms\n>>> you mentioned have the necessary APIs. Java abstracts you from them. So I\n>>> think you are encountering this problem because you desire to target WinRT\n>>> and other platforms with a single codebase. That's an unusual constraint.\n>>>\n>>> AFAIK the only other people who encountered this are BitPay, because\n>>> they want to do everything in Javascript which doesn't really provide any\n>>> major APIs.\n>>>\n>>>\n>>>> Also, you bundle mozilla's store in bitcoinj, what happen when the\n>>>> store change and your customer have not intent to use bitcoinj new version\n>>>> ? by leveraging the plateform you benefit from automatic updates.\n>>>>\n>>>\n>>> Yes, there are pros and cons to bundling a custom root store.\n>>>\n>>>\n>>>> Also, does java stores deals with certificate revocations ? sure you\n>>>> can theorically code that too... or just let the plateform deals with it.\n>>>>\n>>>\n>>> It can do OCSP checks, yes, although I believe no wallets currently do\n>>> so. A better solution would be to implement an OCSP stapling extension to\n>>> BIP70 though.\n>>>\n>>\n>>\n>\n>\n> ------------------------------------------------------------------------------\n> Dive into the World of Parallel Programming. The Go Parallel Website,\n> sponsored by Intel and developed in partnership with Slashdot Media, is\n> your\n> hub for all things parallel software development, from weekly thought\n> leadership blogs to news, videos, case studies, tutorials and more. Take a\n> look and join the conversation now. http://goparallel.sourceforge.net/\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/42f6b20a/attachment.html>"
            },
            {
                "author": "Nicolas DORIER",
                "date": "2015-01-28T17:27:44",
                "message_text_only": "Sure,\n\nBut the mobile targets, it is still easier to use Json + HTTPS, especially\nwhen you want one code base for everything.\nAnd as you said, developers need to think about fetching mozilla store time\nto time, and check revocations themselves. This is not obvious thing to do,\nand hard to test correctly.\n\nIf your use case was the primary utility of BIP70, then I'd say it fit the\nbill. But for cross plateform client development an atlernative would be\neasier.\n\n> why not allow both serializations and keep serialization format a\nparameter, keep everyone happy.\n\nIt would be another BIP, because if we use JSON with HTTPS, the difference\nis also in the semantic (no embedded certificates)\n\nI will likely provide this option for a product I am developing. I will\nonly use another Content Type. We'll see then how it goes.\n\n2015-01-28 18:14 GMT+01:00 Mike Hearn <mike at plan99.net>:\n\n> I think we'll just have to agree to disagree on this one. I've implemented\n> BIP70 a couple of times now and didn't find it to be difficult. I know you\n> had odd problems with the C# protobuf implementation you were using but\n> library bugs can happen for any kind of programming.\n>\n> I forgot to mention the other reason it's done this way. One of the\n> driving goals of BIP70 was to support the TREZOR and similar devices. For\n> hardware wallets, it's critical to keep the amount of code they need to run\n> as small as possible. Any bugs in the code there can cause security holes\n> and lead to the device being hacked.\n>\n> Doing it the way you suggest would mean the secure code would have to\n> contain complex and bug-prone text parsing logic as well as a full blown\n> HTTP and SSL stack, that requires not only X.509 handling but also lots of\n> other stuff on top. It'd increase cost, complexity and decrease security\n> quite a bit.\n>\n> Whilst I appreciate if your platform provides a scripting-like API and\n> nothing low level it might seem easier to use JSON+HTTPS, that isn't the\n> case for one of the primary design targets.\n>\n>\n>\n> On Wed, Jan 28, 2015 at 6:04 PM, Nicolas Dorier <nicolas.dorier at gmail.com>\n> wrote:\n>\n>> Mike, I am not denying it is impossible to do all of that.\n>> Just that it is not a trivial stuff to do to make it works everywhere,\n>> and I think that it is not a good thing for a client side technology.\n>> BIP70 has its use, and I understand why there is case where it is good to\n>> ship the certs in the message and not depends on the transport.\n>>\n>> But a standard that just use JSON and HTTPS, even if less flexible that\n>> BIP70, would make it easier and sufficient for today's use case.\n>>\n>> On Wed, Jan 28, 2015 at 5:55 PM, Mike Hearn <mike at plan99.net> wrote:\n>>\n>>> My point is not that there is a limitation in BIP70. My point is that\n>>>> you put the burden of certificate verification on developer's shoulder when\n>>>> we can just leverage built in HTTPS support of the platform.\n>>>>\n>>>\n>>> Platforms that support HTTPS but not certificate handling are rare - I\n>>> know HTML5 is such a platform but such apps are inherently dependent on the\n>>> server anyway and the server can just do the parsing and validation work\n>>> itself. If WinRT is such a platform, OK, too bad.\n>>>\n>>> The embedding of the certificates is not arbitrary or pointless, by the\n>>> way. It's there for a very good reason - it makes the signed payment\n>>> request verifiable by third parties. Effectively you can store the signed\n>>> message and present it later to someone else, it's undeniable. Combined\n>>> with the transactions and merkle branches linking them to the block chain,\n>>> what you have is a form of digital receipt ... a proof of purchase that can\n>>> be automatically verified as legitimate. This has all kinds of use cases.\n>>>\n>>> Because of how HTTPS works, you can't easily prove to a third party that\n>>> a server gave you a piece of data. Doing so requires staggeringly complex\n>>> hacks (see tls notary) and when we designed BIP70, those hacks didn't even\n>>> exist. So we'd lose the benefit of having a digitally signed request.\n>>>\n>>> Additionally, doing things this way means BIP70 requests can be signed\n>>> by things which are not HTTPS servers. For example you can sign with an\n>>> email address cert, an EV certificate i.e. a company, a certificate issued\n>>> by some user forum, whatever else we end up wanting. Not every payment\n>>> recipient can be identified by a domain name + dynamic session.\n>>>\n>>>\n>>>> However, if you want to use your plateform's store, then you are toasted\n>>>>\n>>>\n>>> That's a bit melodramatic. BitcoinJ is able to use the Android, JRE,\n>>> Windows and Mac certificate stores all using the same code or very minor\n>>> variants on it (e.g. on Mac you have to specify you want the system store\n>>> but it's a one-liner).\n>>>\n>>> Yes, that's not *every* platform. Some will require custom binding glue\n>>> and it depends what abstractions and languages you are using.\n>>>\n>>>\n>>>> Have you tried to do that on windows RT and IOS ? I tried, and I\n>>>> quickly stopped doing that since it is not worth the effort. (Frankly I am\n>>>> not even sure you can on win rt, since the API is a stripped down version\n>>>> of windows)\n>>>>\n>>>\n>>> There is code to do iOS using the Apple APIs here:\n>>>\n>>>\n>>> https://github.com/voisine/breadwallet/blob/master/BreadWallet/BRPaymentProtocol.m#L391\n>>>\n>>>\n>>>> Why have you not heard about the problem ? (until now, because I have\n>>>> this problem because I need to have the same codebase on\n>>>> winrt/win/android/ios/tablets)\n>>>>\n>>>\n>>> WinRT is a minority platform in the extreme, and all the other platforms\n>>> you mentioned have the necessary APIs. Java abstracts you from them. So I\n>>> think you are encountering this problem because you desire to target WinRT\n>>> and other platforms with a single codebase. That's an unusual constraint.\n>>>\n>>> AFAIK the only other people who encountered this are BitPay, because\n>>> they want to do everything in Javascript which doesn't really provide any\n>>> major APIs.\n>>>\n>>>\n>>>> Also, you bundle mozilla's store in bitcoinj, what happen when the\n>>>> store change and your customer have not intent to use bitcoinj new version\n>>>> ? by leveraging the plateform you benefit from automatic updates.\n>>>>\n>>>\n>>> Yes, there are pros and cons to bundling a custom root store.\n>>>\n>>>\n>>>> Also, does java stores deals with certificate revocations ? sure you\n>>>> can theorically code that too... or just let the plateform deals with it.\n>>>>\n>>>\n>>> It can do OCSP checks, yes, although I believe no wallets currently do\n>>> so. A better solution would be to implement an OCSP stapling extension to\n>>> BIP70 though.\n>>>\n>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/15e3e5bb/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP70: why Google Protocol Buffers for encoding?",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Brian Hoffman",
                "Isidor Zeuner",
                "Wladimir",
                "Nicolas DORIER",
                "Nicolas Dorier",
                "Mike Hearn",
                "Giuseppe Mazzotta",
                "Peter Todd",
                "Angel Leon",
                "Matt Whitlock",
                "Richard Brady",
                "Alan Reiner",
                "Ross Nicoll",
                "Gavin Andresen"
            ],
            "messages_count": 35,
            "total_messages_chars_count": 89887
        }
    },
    {
        "title": "[Bitcoin-development] The legal risks of auto-updating wallet software; custodial relationships",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2015-01-20T15:46:41",
                "message_text_only": "I was talking to a lawyer with a background in finance law the other day\nand we came to a somewhat worrying conclusion: authors of Bitcoin wallet\nsoftware probably have a custodial relationship with their users,\nespecially if they use auto-update mechanisms. Unfortunately this has\npotential legal implications as custodial relationships tend to be\npretty highly regulated.\n\nWhy is this? Well, in most jurisdictions financial laws a custodial\nrelationship is defined as having the ability, but not the right, to\ndispose of an asset. If you have the private keys for your users'\nbitcoins - e.g. an exchange or \"online\" wallet - you clearly have the\nability to spend those bitcoins, thus you have a custodial relationship.\nHowever if you can trivially obtain those private keys you can also\nargue you have a custodial relationship. For instance StrongCoin was\nable to seize funds stolen from OzCoin\u00b9 with a small change to the\nclient-side Javascript their users download from them every time they\nvisit the site. Portraying that as \"the ability to dispose of an asset\"\nin a court of law would be pretty easy. Equally on a technical level\nthis isn't much different from how auto-updating software works.\n\nNow I'm sure people in this audience will immediately point out that by\nthat logic your OS vendor is also in a custodial relationship - they\nafter all can push an update that steals everyones' bitcoins regardless\nof what local wallet you use. But the law isn't a deterministic\nalgorithm, it's a political process. Circle is easy to portray as having\na custodial relationship, StrongCoin and Blockchain.info are a little\nharder, Android Wallet harder still, Bitcoin Core's multi-party\ndeterministicly compiled releases even harder.\n\nBut ultimately we're not going to know until court cases start\nhappening. In the meantime probably the best advice - other than getting\nout of the wallet business! - is to do everything you can to prevent\nlosses through malicious auto-updates. Create systems where as many\npeople as possible have to sign off and review an update before it has\nthe opportunity to spend user funds. Not having auto-updates at all is a\n(legally) safe way to achieve that goal; if you do have them make sure\nthe process by which an update happens is controlled by more than one\nperson and there are mechanisms in place to create good audit logs of\nhow exactly an update happened.\n\nFinally keep in mind that one of the consequences of a custodial\nrelationship is that some legal authority might try to *force* you to\nseize user funds. StrongCoin made it 100% clear to authorities that they\nand sites like them are able to seize funds at will - I won't be\nsurprised if authorities use that power in the future. The more\nautomatic and less transparent an update is, the higher the chance some\nauthority will lean on you to seize funds. So don't make it easy for\nyourself to meet those demands.\n\n1) https://bitcoinmagazine.com/4273/ozcoin-hacked-stolen-funds-seized-and-returned-by-strongcoin/\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000001a5e1dc75b28e8445c6e8a5c35c76637e33a3e96d487b74c\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 650 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/7cff1133/attachment.sig>"
            },
            {
                "author": "Matt Whitlock",
                "date": "2015-01-20T17:23:14",
                "message_text_only": "On Tuesday, 20 January 2015, at 10:46 am, Peter Todd wrote:\n> I was talking to a lawyer with a background in finance law the other day\n> and we came to a somewhat worrying conclusion: authors of Bitcoin wallet\n> software probably have a custodial relationship with their users,\n> especially if they use auto-update mechanisms. Unfortunately this has\n> potential legal implications as custodial relationships tend to be\n> pretty highly regulated.\n> \n> Why is this? Well, in most jurisdictions financial laws a custodial\n> relationship is defined as having the ability, but not the right, to\n> dispose of an asset. If you have the private keys for your users'\n> bitcoins - e.g. an exchange or \"online\" wallet - you clearly have the\n> ability to spend those bitcoins, thus you have a custodial relationship.\n\nIf you have the private keys for your users' bitcoins, then you are every bit as much the owner of those bitcoins as your users are. There is no custodial relationship, as you have both the ability and the right to spend those bitcoins. Possession of a private key is equivalent to ownership of the bitcoins controlled by that private key."
            },
            {
                "author": "Peter Todd",
                "date": "2015-01-20T17:40:05",
                "message_text_only": "On Tue, Jan 20, 2015 at 12:23:14PM -0500, Matt Whitlock wrote:\n> On Tuesday, 20 January 2015, at 10:46 am, Peter Todd wrote:\n> > I was talking to a lawyer with a background in finance law the other day\n> > and we came to a somewhat worrying conclusion: authors of Bitcoin wallet\n> > software probably have a custodial relationship with their users,\n> > especially if they use auto-update mechanisms. Unfortunately this has\n> > potential legal implications as custodial relationships tend to be\n> > pretty highly regulated.\n> > \n> > Why is this? Well, in most jurisdictions financial laws a custodial\n> > relationship is defined as having the ability, but not the right, to\n> > dispose of an asset. If you have the private keys for your users'\n> > bitcoins - e.g. an exchange or \"online\" wallet - you clearly have the\n> > ability to spend those bitcoins, thus you have a custodial relationship.\n> \n> If you have the private keys for your users' bitcoins, then you are every bit as much the owner of those bitcoins as your users are. There is no custodial relationship, as you have both the ability and the right to spend those bitcoins. Possession of a private key is equivalent to ownership of the bitcoins controlled by that private key.\n\nPosessing a private key certainly does not give you an automatic legal\nright to anything. As an example I could sign an agreement with you that\npromised I would manage some BTC on your behalf. That agreement without\nany doubt takes away any legal right I had to your BTC, enough though I\nmay have have the technical ability to spend them. This is the very\nreason why the law has the notion of a custodial relationship in the\nfirst place.\n\nDon't assume the logic you'd use with tech has anything to do with the\nlogic courts use.\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000001a5e1dc75b28e8445c6e8a5c35c76637e33a3e96d487b74c\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 650 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/38300c4b/attachment.sig>"
            },
            {
                "author": "Matt Whitlock",
                "date": "2015-01-20T17:44:25",
                "message_text_only": "On Tuesday, 20 January 2015, at 12:40 pm, Peter Todd wrote:\n> On Tue, Jan 20, 2015 at 12:23:14PM -0500, Matt Whitlock wrote:\n> > If you have the private keys for your users' bitcoins, then you are every bit as much the owner of those bitcoins as your users are. There is no custodial relationship, as you have both the ability and the right to spend those bitcoins. Possession of a private key is equivalent to ownership of the bitcoins controlled by that private key.\n> \n> Posessing a private key certainly does not give you an automatic legal\n> right to anything. As an example I could sign an agreement with you that\n> promised I would manage some BTC on your behalf. That agreement without\n> any doubt takes away any legal right I had to your BTC, enough though I\n> may have have the technical ability to spend them. This is the very\n> reason why the law has the notion of a custodial relationship in the\n> first place.\n\nI never signed any kind of agreement with Andreas Schildbach. I keep my bitcoins in his wallet with the full knowledge that an auto-update could clean me out. (I only hold \"walking around\" amounts of money in my mobile wallet for exactly this reason.) I would love it if Andreas offered me an agreement not to spend my bitcoins without my consent, but I doubt he'd legally be allowed to offer such an agreement, as that would indeed set up a custodial relationship, which would put him into all sorts of regulatory headache."
            },
            {
                "author": "Tamas Blummer",
                "date": "2015-01-20T17:44:31",
                "message_text_only": "Knowing the private key and owning the linked coins is not necessarily the same in front of a court.\n\nAt least in german law there is a difference between \u2018Eigentum' means ownership and \u2018Besitz\u2019 means ability to deal with it.\nBeing able to deal with an asset does not make you the owner.\n\nTamas Blummer\n\nOn Jan 20, 2015, at 6:23 PM, Matt Whitlock <bip at mattwhitlock.name> wrote:\n> \n> If you have the private keys for your users' bitcoins, then you are every bit as much the owner of those bitcoins as your users are. There is no custodial relationship, as you have both the ability and the right to spend those bitcoins. Possession of a private key is equivalent to ownership of the bitcoins controlled by that private key.\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/8260e6bb/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 496 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/8260e6bb/attachment.sig>"
            },
            {
                "author": "Matt Whitlock",
                "date": "2015-01-20T17:47:04",
                "message_text_only": "On Tuesday, 20 January 2015, at 6:44 pm, Tamas Blummer wrote:\n> Knowing the private key and owning the linked coins is not necessarily the same in front of a court.\n> \n> At least in german law there is a difference between \u2018Eigentum' means ownership and \u2018Besitz\u2019 means ability to deal with it.\n> Being able to deal with an asset does not make you the owner.\n\nSo what we're telling the newbies in /r/bitcoin is plain wrong. Bitcoins *do* have an owner independent from the parties who have access to the private keys that control their disposition. That's pretty difficult to reconcile from a technological perspective."
            },
            {
                "author": "Peter Todd",
                "date": "2015-01-20T17:49:45",
                "message_text_only": "On Tue, Jan 20, 2015 at 12:47:04PM -0500, Matt Whitlock wrote:\n> On Tuesday, 20 January 2015, at 6:44 pm, Tamas Blummer wrote:\n> > Knowing the private key and owning the linked coins is not necessarily the same in front of a court.\n> > \n> > At least in german law there is a difference between \u2018Eigentum' means ownership and \u2018Besitz\u2019 means ability to deal with it.\n> > Being able to deal with an asset does not make you the owner.\n> \n> So what we're telling the newbies in /r/bitcoin is plain wrong. Bitcoins *do* have an owner independent from the parties who have access to the private keys that control their disposition. That's pretty difficult to reconcile from a technological perspective.\n\nThe law concerns itself with what should be done, not what can be done.\n\nBitcoin the technology doesn't have a concept of \"ownership\" - that's a\nlegal notion, not a mathematical one.\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000001a5e1dc75b28e8445c6e8a5c35c76637e33a3e96d487b74c\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 650 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/58de4e30/attachment.sig>"
            },
            {
                "author": "Tamas Blummer",
                "date": "2015-01-20T17:56:28",
                "message_text_only": "I am not a lawyer, just thinking loud.\nI think that technology is a strong argument before court, but I suspect that it is just that, as of now.\n\nTamas Blummer\nOn Jan 20, 2015, at 6:47 PM, Matt Whitlock <bip at mattwhitlock.name> wrote:\n\n> On Tuesday, 20 January 2015, at 6:44 pm, Tamas Blummer wrote:\n>> Knowing the private key and owning the linked coins is not necessarily the same in front of a court.\n>> \n>> At least in german law there is a difference between \u2018Eigentum' means ownership and \u2018Besitz\u2019 means ability to deal with it.\n>> Being able to deal with an asset does not make you the owner.\n> \n> So what we're telling the newbies in /r/bitcoin is plain wrong. Bitcoins *do* have an owner independent from the parties who have access to the private keys that control their disposition. That's pretty difficult to reconcile from a technological perspective.\n> \n> \n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/516a0e8b/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 496 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/516a0e8b/attachment.sig>"
            },
            {
                "author": "Justus Ranvier",
                "date": "2015-01-20T17:47:23",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nOn 01/20/2015 03:46 PM, Peter Todd wrote:\n> But ultimately we're not going to know until court cases start \n> happening. In the meantime probably the best advice - other than\n> getting out of the wallet business! - is to do everything you can\n> to prevent losses through malicious auto-updates. Create systems\n> where as many people as possible have to sign off and review an\n> update before it has the opportunity to spend user funds. Not\n> having auto-updates at all is a (legally) safe way to achieve that\n> goal; if you do have them make sure the process by which an update\n> happens is controlled by more than one person and there are\n> mechanisms in place to create good audit logs of how exactly an\n> update happened.\n> \n> Finally keep in mind that one of the consequences of a custodial \n> relationship is that some legal authority might try to *force* you\n> to seize user funds. StrongCoin made it 100% clear to authorities\n> that they and sites like them are able to seize funds at will - I\n> won't be surprised if authorities use that power in the future. The\n> more automatic and less transparent an update is, the higher the\n> chance some authority will lean on you to seize funds. So don't\n> make it easy for yourself to meet those demands.\n\nOne suggestion you didn't mention was jurisdictional arbitrage - don't\nbe located in the same country as the majority of your users.\n\nOr, from the other perspective, users should be strongly encouraged to\nget their wallet software from companies/organizations not located in\nthe same country as them.\n\n\n- -- \nJustus Ranvier                   | Monetas <http://monetas.net/>\n<mailto:justus at monetas.net>      | Public key ID : C3F7BB2638450DB5\n                                 | BM-2cTepVtZ6AyJAs2Y8LpcvZB8KbdaWLwKqc\n-----BEGIN PGP SIGNATURE-----\n\niQIcBAEBAgAGBQJUvpSqAAoJECpf2nDq2eYj0oQQAI62vLPzFrkLZoRw3bIw5GWt\n6L8dpLUviRS7ZaQlNB49TT4L4Ky+MJ1PxaHwb4YPxrVcCWDLiJb51CtODduF/9rR\n8N4xoQuf/6DhsBHWJE8NDwP+9JUOlY23xdSe/BlLz9N1Ql/EV0HTCu28A9xbhK1L\nQHgwX3p5/ZCJo7PCARF3o+EZOif5MsA4MdQ11HhyFWN/fgww9AVOIg/0m+tIqkjR\nyoOzFww4AejC7nxi+Q+elljpvp2Q/Nv8cVOVlp9l4+f9P7sg0em9YUCE+iAxoZTT\n7b9soUXFUjWlxFITR5RnjlDUnmra9QhBIhogBQbLelt/vdoRInz+kXxroR2x3uKh\nEJoet2czRB1oiRKHE4iSAv+1pnavQJDVo5/mUMzeM15zCnQ16Mfu9aOpqvijK0cw\nu67E4IAPJ2PmUy4sPPJ/4H4FPLmJrSUkLxxzq/4prmLLmeZZvPwjavnULHir4jyG\naaxFqMkbeJSeK3hLk7hnlrwpQRAEq7om+EpQ7fAx1lmEoA3eOHaeclh7/XzDwIB4\nAK/jX+1ylhGvfuKNzwTQVX8dEzaHRwLAfLfHUNnP80WhBzH5ODicwcOwwOanL6/A\nqgqwDSSB/Q5aj3VsThQ+PR81u/wA5t/Av9+Wn/g+AEMyzCnJcnHxDe41ZEn4UzYY\n+RAX1P8yzF/M2ZQUeMLh\n=G0GE\n-----END PGP SIGNATURE-----\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0xEAD9E623.asc\nType: application/pgp-keys\nSize: 17528 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/7edc7d91/attachment.bin>"
            },
            {
                "author": "Tamas Blummer",
                "date": "2015-01-20T18:48:38",
                "message_text_only": "Justus,\n\nIn contrary. \n\nNot being in the jurisdiction of the wallet provider makes it harder for the user to reclaim funds taken by the wallet provider.\nThe legal hurdle to force confiscation through a wallet provider might also be lower if the target user is not domestic.\n\nTamas Blummer\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/328a83be/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 496 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/328a83be/attachment.sig>"
            },
            {
                "author": "Justus Ranvier",
                "date": "2015-01-20T19:31:14",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nOn 01/20/2015 12:48 PM, Tamas Blummer wrote:\n> The legal hurdle to force confiscation through a wallet provider\n> might also be lower if the target user is not domestic.\n\nDepending on the threat model, the incentive to force confiscation\nmight also be lower.\n\n- -- \nJustus Ranvier                   | Monetas <http://monetas.net/>\n<mailto:justus at monetas.net>      | Public key ID : C3F7BB2638450DB5\n                                 | BM-2cTepVtZ6AyJAs2Y8LpcvZB8KbdaWLwKqc\n-----BEGIN PGP SIGNATURE-----\n\niQIcBAEBAgAGBQJUvq0CAAoJECpf2nDq2eYjr9kP/RWEg8Az43T+7qMFnrk37+y/\n0pyEQ/zisao1d0LouxyGFu704U8Qayk96hUu+2GAQpS8hHVA0CmDW8E1hqKG2nGl\nMTTQYp7932NY2NysIvNaQDhVErZZFqMpPYCnsSrnwUrygh+QjWAI8nvrrcgprG5/\nzybzs5IJjFQ7QwYJ92D01shkqQJLYYspp2ME3z97AwPCBanN8eG4Iji/V8/aJqcZ\nZqF7yUjAySVUOUzR+Vju1C7N1i9MHzIG9vZA/jkaCiqZ8bvyQTm9LwSK3quoxGAB\nlTplIwKjWsEvs0nm0RyurcPIWq1ppfPiWCaMCNDA5Byz3mJbSrRW5ErFgBtpYkgw\nCF+WqoWU8fajQjqd8xcsKJmVyQqk4dUWXJQLGnd6pC3DCZGOPhr+6674vgmEQG5A\nbXoBAtJfAJkxkDGEsngs4EBGc08iy+t6tJUh7+wI/La8xulM5BgJkQRTnL4Hn6KS\npcgYV9JP1BWMB4fkdL81mKnG98BJ98pj019C0nuPYQtSA0rUsWG9d3NYDPe87I+K\n7UJ6NlNxTLxnS7nhr8Wk9UdqkFMsCQxF/RFR6I9vCQ/FMSD+i1786I72kkyf4cWJ\n4ZssTX3yo6pN/faU2cBk84PQlA2ziARXqO+jzbxVR7AFpT2BESUtBdirh1CPEMfR\npiBBTr6I86R2bpZYv046\n=pJvU\n-----END PGP SIGNATURE-----\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0xEAD9E623.asc\nType: application/pgp-keys\nSize: 17528 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/e0e51275/attachment.bin>"
            },
            {
                "author": "odinn",
                "date": "2015-01-20T21:33:53",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nUm ~ \"jurisdiction of wallet provider?\"\n\nIf that's the (perhaps ot) bit you want to run on this thread then my\ncomments are:\n\nGet out of web wallet businesses now.  It's not a jurisdictional\nquestion anymore, although I think there used to be very valid long\nrunning debates on where it would be best to do business.  Now it just\nfeels like you will be bouncing from one place to another -\ndetermining where your exit is as soon as you establish a (physical)\npresence, because jurisdictions sense a serious threat from the\nadvancement of financial cryptography as it will evolve in the next\nseveral years. So you have to be mobile, or do something like what\nthey are establishing at blueseed (see http://blueseed.com which is\njust off coast of San Francisco).  Please perk up and don't just swipe\nto delete, read the whole e-mail.  There are some configurations (e.g.\nthe zero knowledge bit) you can do to mitigate the issues but if you\nare asking users to log in and log out of a service that relies on a\nweb site then in the end you doom them (and any service you provide)\nto mandatory storage of customer data and ultimately loss of customer\nresources due to identification of the customer.\n\nI think you need to stop quibbling about the details and just get over\nit and understand that the problem of web wallet users and\ncorporations that serve web wallet customers being forced to give up\ninformation constantly to governments means that web wallets are\ncertainly no longer a viable solution.  And post-cromnibus with the\nextra financial surveillance provisions now passed on 3rd party\nmatters, it's even worse.  This is not subject to debate, it's just a\nfact.  Period.  Web wallet corps exist now only on a model that exists\nto burn the users.  Convenient?  Yes.  But is it good for the users in\nthe long haul?  Absolutely not.  Do alternative to the web wallets\nexist? Absolutely.\n\nBack off.. Go to p2p.  Stop advocating for webby solutions.  In fact,\nI don't think that anyone working for coinbase or bitpay should be,\nanymore.  I think that on principle you should withdraw and end your\nemployment from such services.\n\nCore?  Good.  Electrum Wallet?  good.  Mycelium? Local Trader? Open\nBazaar?  Could be better, but great.  These are the kind of things we\nneed.  No signups, avoids centralizations, no grabbing your data, no\nID collection and requirements.\n\nAs to the issue of auto-updating itself... I think the simplest answer\nto this question (personally) is that (go ahead and attack me here)\nthere shouldn't be auto-updates... but that there should be\nauto-notifications for update when (a) update is available, but that\n(b) this notification should never \"push\" the user to update (e.g. the\nnotification should never say \"oh hey user if you don't update by such\nand such a date, your wallet will not work or satoshis will die\nbecause of your inaction\"\n(stays quiet while likely 100-e-mail thread is spawned from this)\n\n- -O\n\nTamas Blummer:\n> Justus,\n> \n> In contrary.\n> \n> Not being in the jurisdiction of the wallet provider makes it\n> harder for the user to reclaim funds taken by the wallet provider. \n> The legal hurdle to force confiscation through a wallet provider\n> might also be lower if the target user is not domestic.\n> \n> Tamas Blummer\n> \n> \n> \n> ------------------------------------------------------------------------------\n>\n> \nNew Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in\n> Ashburn. Choose from 2 high performing configs, both with 100TB of\n> bandwidth. Higher redundancy.Lower latency.Increased\n> capacity.Completely compliant. http://p.sf.net/sfu/gigenet\n> \n> \n> \n> _______________________________________________ Bitcoin-development\n> mailing list Bitcoin-development at lists.sourceforge.net \n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> \n\n- -- \nhttp://abis.io ~\n\"a protocol concept to enable decentralization\nand expansion of a giving economy, and a new social good\"\nhttps://keybase.io/odinn\n-----BEGIN PGP SIGNATURE-----\n\niQEcBAEBCgAGBQJUvsnBAAoJEGxwq/inSG8CGekIAJH4lUdk81sVfQqxZ4sKOKFM\n5iAvCD4JNuV+xcCZBiNNr1GxIZEVoDRQYupo7wB1A5uGW+STLHDGsEMuDNyiOcNl\noSsJQFZJabxL7dIn8g89Gw+8J8LtYKEkHHZLk5J5QF0DkRljXjEcOV4KL6WXhdl5\nToV01POMUBbSJsQt2lLznmCvQ+4QW5/GJ9Hk04HIub+kzuil0R23CgRH9QFevC9S\n2/RT3NnfGFu+jU5+K/o8RbuUuzExq94x4w266IEmJc0NsLHxnxsg2PefabQbfdzp\nP7FU7+D9NsIOaBGTXnQK80kpgRCJ49Gf9HXHKFYg2KCFuqgJYa8DnHm1Xlfo7DQ=\n=yS8H\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Roy Badami",
                "date": "2015-01-20T21:49:52",
                "message_text_only": "> Why is this? Well, in most jurisdictions financial laws a custodial\n> relationship is defined as having the ability, but not the right, to\n> dispose of an asset.\n\nSo if I leave my window open while I'm out and there's some cash on my\ndesk, visible from the street, then every passer by now has a\ncustodial relationship with me?\n\nYour example of a malicious software update seems more akin to a theft\nlike that (which is clearly not a custodial relationship) rather than\na true custodial relationship.\n\nroy"
            },
            {
                "author": "Peter Todd",
                "date": "2015-01-20T17:15:57",
                "message_text_only": "On Tue, Jan 20, 2015 at 08:43:57AM -0800, Daniel Stadulis wrote:\n> Hey Peter,\n> \n> What would you say to the argument: given developers have auto update\n> capabilities they only have the ability to *give themselves* *the ability* to\n> have custodial rights?\n\nHeh, well, courts tend not to have the narrow-minded pedantic logic that\nprogrammers do; quite likely that they'd see having the ability to give\nthemselves the ability as equivalent to simply having the ability. What\nmatters more is intent: the authors of an operating system had no intent\nto have a custodial relationship over anyones' BTC, so they'd be off the\nhook. The authors of a Bitcoin wallet on the other hand, depends on how\nyou go about it.\n\nFor instance Lighthouse has something called UpdateFX, which allows for\nmulti-signature updates. It also supports deterministic builds, and\nallows users to chose whether or not they'll follow new updates\nautomatically, or only update on demand. In a court that could be all\nbrought up as examples of intent *not* to have a custodial relationship,\nwhich may be enough to sway judge/jury, and certainly will help avoid\nending up in court in the first place by virtue of the fact that all\nthose protections help avoid theft, and increase the # of people that an\nauthority need to involve to seize funds via an update.\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000001a5e1dc75b28e8445c6e8a5c35c76637e33a3e96d487b74c\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 650 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/f81ee500/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "The legal risks of auto-updating wallet software; custodial relationships",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "odinn",
                "Tamas Blummer",
                "Roy Badami",
                "Peter Todd",
                "Matt Whitlock",
                "Justus Ranvier"
            ],
            "messages_count": 14,
            "total_messages_chars_count": 24564
        }
    },
    {
        "title": "[Bitcoin-development] Request for Comment: Bitcoin Wallet Privacy Ratings Criteria",
        "thread_messages": [
            {
                "author": "Kristov Atlas",
                "date": "2015-01-20T18:52:14",
                "message_text_only": "The Open Bitcoin Privacy Project is seeking public comment on our ratings\ncriteria for Bitcoin wallet privacy. Please provide your feedback within\nthe next week through Jan 23, 2015 to ensure that it will be considered for\nversion 1.0 of the document.\n\nhttps://github.com/OpenBitcoinPrivacyProject/wallet-ratings/blob/master/criteria.md\n\nIn conjunction with a scoring matrix that will determine the weight of each\nsub-category, this criteria will be used to evaluate and score a variety of\nBitcoin wallets, which will be published on our website at\nopenbitcoinprivacyproject.org.\n\nFeedback through this mailing list is, of course, welcome; if you have a\nGitHub account, this is the preferred medium for proposing changes to the\ndocument.\n\nThe current version of the criteria was authored by myself, as well as\nother OBPP members including Justus Ranvier (Monetas), Chris Pacia (Bitcoin\nAuthenticator), and Samuel Patterson (Open Bazaar).\n\nThank you in advance for your feedback,\n\nKristov Atlas\nkristovatlas at gmail.com\nauthor at anonymousbitcoinbook.com\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/994fedb5/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Request for Comment: Bitcoin Wallet Privacy Ratings Criteria",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Kristov Atlas"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1237
        }
    },
    {
        "title": "[Bitcoin-development] [softfork proposal] Strict DER signatures",
        "thread_messages": [
            {
                "author": "Pieter Wuille",
                "date": "2015-01-21T00:35:49",
                "message_text_only": "Hello everyone,\n\nWe've been aware of the risk of depending on OpenSSL for consensus\nrules for a while, and were trying to get rid of this as part of BIP\n62 (malleability protection), which was however postponed due to\nunforeseen complexities. The recent evens (see the thread titled\n\"OpenSSL 1.0.0p / 1.0.1k incompatible, causes blockchain rejection.\"\non this mailing list) have made it clear that the problem is very\nreal, however, and I would prefer to have a fundamental solution for\nit sooner rather than later.\n\nI therefore propose a softfork to make non-DER signatures illegal\n(they've been non-standard since v0.8.0). A draft BIP text can be\nfound on:\n\n    https://gist.github.com/sipa/5d12c343746dad376c80\n\nThe document includes motivation and specification. In addition, an\nimplementation (including unit tests derived from the BIP text) can be\nfound on:\n\n    https://github.com/sipa/bitcoin/commit/bipstrictder\n\nComments/criticisms are very welcome, but I'd prefer keeping the\ndiscussion here on the mailinglist (which is more accessible than on\nthe gist).\n\n-- \nPieter"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-01-21T04:45:26",
                "message_text_only": "Pieter Wuille <pieter.wuille at gmail.com> writes:\n> Hello everyone,\n>\n> We've been aware of the risk of depending on OpenSSL for consensus\n> rules for a while, and were trying to get rid of this as part of BIP\n> 62 (malleability protection), which was however postponed due to\n> unforeseen complexities. The recent evens (see the thread titled\n> \"OpenSSL 1.0.0p / 1.0.1k incompatible, causes blockchain rejection.\"\n> on this mailing list) have made it clear that the problem is very\n> real, however, and I would prefer to have a fundamental solution for\n> it sooner rather than later.\n>\n> I therefore propose a softfork to make non-DER signatures illegal\n> (they've been non-standard since v0.8.0). A draft BIP text can be\n> found on:\n>\n>     https://gist.github.com/sipa/5d12c343746dad376c80\n\nCut and paste bug in the last check:\n\n// Null bytes at the start of R are not allowed, unless it would otherwise be\n// interpreted as a negative number.\n    if (lenS > 1 && (sig[lenR + 6] == 0x00) && !(sig[lenR + 7] & 0x80))\n    return false;\n\nYou mean \"null bytes at the start of S\".\n\nCheers,\nRusty."
            },
            {
                "author": "Pieter Wuille",
                "date": "2015-01-21T16:49:28",
                "message_text_only": "On Tue, Jan 20, 2015 at 11:45 PM, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> // Null bytes at the start of R are not allowed, unless it would otherwise be\n> // interpreted as a negative number.\n>     if (lenS > 1 && (sig[lenR + 6] == 0x00) && !(sig[lenR + 7] & 0x80))\n>     return false;\n>\n> You mean \"null bytes at the start of S\".\n\nThanks, fixed.\n\n-- \nPieter"
            },
            {
                "author": "Peter Todd",
                "date": "2015-01-21T19:10:53",
                "message_text_only": "On Tue, Jan 20, 2015 at 07:35:49PM -0500, Pieter Wuille wrote:\n\nI read this and it's boring, now that all my objections have been met. :)\n\nI'll try get a chance to actually test/review this in detail; in SF for\nthe next three weeks with some ugly deadlines and a slow laptop. :(\n\n> Hello everyone,\n> \n> We've been aware of the risk of depending on OpenSSL for consensus\n> rules for a while, and were trying to get rid of this as part of BIP\n> 62 (malleability protection), which was however postponed due to\n> unforeseen complexities. The recent evens (see the thread titled\n> \"OpenSSL 1.0.0p / 1.0.1k incompatible, causes blockchain rejection.\"\n> on this mailing list) have made it clear that the problem is very\n> real, however, and I would prefer to have a fundamental solution for\n> it sooner rather than later.\n> \n> I therefore propose a softfork to make non-DER signatures illegal\n> (they've been non-standard since v0.8.0). A draft BIP text can be\n> found on:\n> \n>     https://gist.github.com/sipa/5d12c343746dad376c80\n> \n> The document includes motivation and specification. In addition, an\n> implementation (including unit tests derived from the BIP text) can be\n> found on:\n> \n>     https://github.com/sipa/bitcoin/commit/bipstrictder\n> \n> Comments/criticisms are very welcome, but I'd prefer keeping the\n> discussion here on the mailinglist (which is more accessible than on\n> the gist).\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000001a5e1dc75b28e8445c6e8a5c35c76637e33a3e96d487b74c\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 650 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150121/39547316/attachment.sig>"
            },
            {
                "author": "Douglas Roark",
                "date": "2015-01-21T19:29:52",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nOn 2015/1/20 19:35, Pieter Wuille wrote:> Hello everyone,\n> Comments/criticisms are very welcome, but I'd prefer keeping the \n> discussion here on the mailinglist (which is more accessible than\n> on the gist).\n\nNice paper, Pieter. I do have a bit of feedback.\n\n1)The first sentence of \"Deployment\" has a typo. \"We reuse the\ndouble-threshold switchover mechanism from BIP 34, with the same\n*thresholds*, [....]\"\n\n2)I think the handling of the sighash byte in the comments of\nIsDERSignature() could use a little tweaking. If you look at\nCheckSignatureEncoding() in the actual code (src/script/interpreter.cpp\nin master), it's clear that the sighash byte is included as part of the\nsignature struct, even though it's not part of the actual DER encoding\nbeing checked by IsDERSignature(). This is fine. I just think that the\ncode comments in the paper ought to make this point clearer, either in\nthe sighash description, or as a comment when checking the sig size\n(i.e., size-3 is valid because sighash is included), or both.\n\n3)The paper says a sig with size=0 is correctly coded but is neither\nvalid nor DER. Perhaps this code should be elsewhere in the Bitcoin\ncode? It seems to me that letting a sig pass in IsDERSignature() when\nit's not actually DER-encoded is incorrect.\n\nThanks.\n\n- ---\nDouglas Roark\nSenior Developer\nArmory Technologies, Inc.\ndoug at bitcoinarmory.com\nPGP key ID: 92ADC0D7\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG/MacGPG2 v2.0.22 (Darwin)\nComment: GPGTools - https://gpgtools.org\n\niQIcBAEBCgAGBQJUv/4vAAoJEGybVGGSrcDXMxkP/1N2lLAloCKdRUpMBLPEZ5jh\nbJ4reCeqrMy6JetsKSGfGKdAe7kGkeRl6s8dlHYnpUmnODXU9BCku3zHi3+qm8IC\nGZlwSdSSgmRneP7btPula0CG31o7X2UJiDW/2IOZl6ul8b7LB2L56O+Ew+PNm+at\ntCfRcpKtq9LYCnRYR0azd4c5YY9/o7zlkpGi8CututzuEa4Rcm92U1extoo2tC/j\nnzUfbfcQVL0a7JaRU4VYNceYrcG/xSpKPjsEU/F+5IwnUxL/kebz0EDt1kzm+fOE\nEMUMXyYgoyW5VDFNjxu00PnJUfVNCOXN/N/h9eCdskCL3AtH6xg1kzam5OGvpEZS\nQDMNSmQl4Zpx5WiATylNkhhzb/8GowamkSFg4SUjBsjpwOTMTIF0Qhnt+DdzwpI2\netxCGds154nL4p/bkulseczwxOZWin9oZxJnCxp40oFl8fva0BwHVx45uMyI61Ko\nqRJ9Ol0CDoId3h1EMTt4uyoNxrOzgrj8/+V4BBytOAMMmsfD0VgY68xzdywJxYnC\njgU99huhwtJpn9QT6JAbgPAaboomu6hDCohV+J+DCCkIiYFk1jxp+FQ4xZDzcKeo\ngMYpmFefPAxnHvDXf1v1A+Xw8plN6/NREaIpprh7Ep+q/8vYAiwwHfKjubdMkB3D\nWnTR5YbqyGxc/Pvh9Ncq\n=C/wj\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Pieter Wuille",
                "date": "2015-01-21T20:30:44",
                "message_text_only": "On Wed, Jan 21, 2015 at 2:29 PM, Douglas Roark <doug at bitcoinarmory.com> wrote:\n> Nice paper, Pieter. I do have a bit of feedback.\n\nThanks for the comments. I hope I have clarified the text a bit accordingly.\n\n> 1)The first sentence of \"Deployment\" has a typo. \"We reuse the\n> double-threshold switchover mechanism from BIP 34, with the same\n> *thresholds*, [....]\"\n\nFixed.\n\n> 2)I think the handling of the sighash byte in the comments of\n> IsDERSignature() could use a little tweaking. If you look at\n> CheckSignatureEncoding() in the actual code (src/script/interpreter.cpp\n> in master), it's clear that the sighash byte is included as part of the\n> signature struct, even though it's not part of the actual DER encoding\n> being checked by IsDERSignature(). This is fine. I just think that the\n> code comments in the paper ought to make this point clearer, either in\n> the sighash description, or as a comment when checking the sig size\n> (i.e., size-3 is valid because sighash is included), or both.\n\nI've renamed the function to IsValidSignatureEncoding, as it is not\nstrictly about DER (it adds a Bitcoin-specific byte, and supports and\nempty string too).\n\n> 3)The paper says a sig with size=0 is correctly coded but is neither\n> valid nor DER. Perhaps this code should be elsewhere in the Bitcoin\n> code? It seems to me that letting a sig pass in IsDERSignature() when\n> it's not actually DER-encoded is incorrect.\n\nI've expanded the comments about it a bit.\n\n-- \nPieter"
            },
            {
                "author": "Douglas Roark",
                "date": "2015-01-21T20:39:50",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nOn 2015/1/21 15:30, Pieter Wuille wrote:\n> Thanks for the comments. I hope I have clarified the text a bit \n> accordingly.\n\nYou're welcome. All the revisions look good to me.\n\n- ---\nDouglas Roark\nSenior Developer\nArmory Technologies, Inc.\ndoug at bitcoinarmory.com\nPGP key ID: 92ADC0D7\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG/MacGPG2 v2.0.22 (Darwin)\nComment: GPGTools - https://gpgtools.org\n\niQIcBAEBCgAGBQJUwA6WAAoJEGybVGGSrcDXvmEP/A09j4lq2P0RMqrvtwnDQRmH\noimbGwC2a/BbpACBegn0cdFYMURFFcec4gHKyvuN7xR4SRsgQ+Djq/KranAMkYbs\nZQVFGXRWdZhfsh7bY4zbBUj+H8c8PAsKL0D7S8r4iXviuUimXJXqESUYote9Ylz3\nrwjiK3oRiCSMpTMiI3eDjrbQt5HHLw3hKL7W6zTerx64eCaO2JsIn/Pk4Krf9xwd\n1ejpyqrK/9s90NPB0Qqieqbgg7WoQYP+ZMzFi5oNxtNrZjlOCNSQKLN0IXqnnMnS\n+AoB4B5TUGCdLq3Wlo69mhLaLYNaPNHEoGNUwikXqsd5WeqsayuYDl36rI4MLWgB\nZBVO6D2BErqdqMTrmUEurubXMb6CCAuFu6iYjO3vucQ0l+7xD7OW/XiK7ZPNFuwj\n2fJCjRHjqgDwKlIUF3Gh7BwRrT2iZRoFYWXDVRBMiJpHvs1+U79pQENp4BmQLWE+\nxn3gX9r755mVDJL10MFM6jKijgTCGA2hEFjK2Vu1JJMeVSIGaOdEIen2DxS2mqnZ\nb/t9VDxfbFQRw5pj2zHsvFDGBe7DEhvBSqbNtiPrY5/LITeP8Nt4CZ9PHrYPJV5A\nocUx98l1sqy7P0QiYzAEp5tpdjTS17MVNPt84JLJnk7wL+fDRfKKV3A7tI/ziFJe\nhjW91YNTIrs+ZFLV/HJc\n=Rjcd\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Gavin Andresen",
                "date": "2015-01-21T20:37:06",
                "message_text_only": "DERSIG BIP looks great to me, just a few nit-picky changes suggested:\n\nYou mention the \"DER standard\" : should link to\nhttp://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf (or\nwhatever is best reference for DER).\n\n\"this would simplify avoiding OpenSSL in consensus implementations\"  -->\n\"this would make it easier for non-OpenSSL implementations\"\n\n\"causing opcode failure\"  : I know what you mean by \"opcode failure\", but\nit might be good to be more explicit.\n\n\"since v0.8.0, and nearly no transactions\" -->  \"and very few\ntransactions...\"\n\n\"reducing this avenue for malleability is useful on itself as well\"  :\nawkward English. How about just \"This proposal has the added benefit of\nreducing transaction malleability (see BIP62).\"\n\n\n-- \n--\nGavin Andresen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150121/c90302a5/attachment.html>"
            },
            {
                "author": "Douglas Roark",
                "date": "2015-01-21T20:52:12",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nOn 2015/1/21 15:37, Gavin Andresen wrote:\n> You mention the \"DER standard\" : should link to\n> http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf\n>\n> \n(or whatever is best reference for DER).\n\nThe link you gave is to the 2002 revision.\nhttp://www.itu.int/rec/T-REC-X.690-200811-I/en has the latest revision\n(Nov. 2008) and, AFAIK, is the most visible link to people searching\nfor X.690.\n\nThat said, X.690 is the definitive DER document (if not exactly the\neasiest read). A link to it wouldn't hurt.\n\n> \"this would simplify avoiding OpenSSL in consensus implementations\"\n> --> \"this would make it easier for non-OpenSSL implementations\"\n> \n> \"causing opcode failure\"  : I know what you mean by \"opcode\n> failure\", but it might be good to be more explicit.\n> \n> \"since v0.8.0, and nearly no transactions\" -->  \"and very few \n> transactions...\"\n> \n> \"reducing this avenue for malleability is useful on itself as well\"\n> : awkward English. How about just \"This proposal has the added\n> benefit of reducing transaction malleability (see BIP62).\"\n\nThese all look good to me.\n\n- ---\nDouglas Roark\nSenior Developer\nArmory Technologies, Inc.\ndoug at bitcoinarmory.com\nPGP key ID: 92ADC0D7\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG/MacGPG2 v2.0.22 (Darwin)\nComment: GPGTools - https://gpgtools.org\n\niQIcBAEBCgAGBQJUwBF8AAoJEGybVGGSrcDXBxcP/j9dKIeXkOvDFgSzON2hmjxT\nnzpPcxovGt+ds1KqHMtuMm8+Mmc/Z8kOhKWzgQKYlxq8eQayQ4X/DUr97IY248NX\nudVM6vEp/azPkXLOQnO6POpv8Il6twyuYGvFAHLiYe9k9qMfdSKZetx5xFKVBsuj\nDhRY2TnWC7/OXNUrT7H5TPHDaGHyXeJ47XSOVjGQ/qxdczIzvmt11amZ/Vn2+uXh\nRvz+0CzbpXYaqYB04ZnIv5lxknmjWGbxPdht/SoOly8INehQacWnwUNZJpilKb6x\nqEpbDGNxW2zHEFgfNHmtr9PCBN8KyiVnTt+VZpNNl7PJCxZiK6uiwyNxsmOBhBtm\nHrsvxb9GqEO/6PKesEo+Hi+6hhzzQRC6Xrf85SaFMzw9UjKuuRhstxx7XhudKFkN\nlBJcxd40G7kWk0Gv+YQmhFUyXUBqloEFGrFlzWniFKaJGzZs5D0JPd83DsPI4RuT\n0M63YabL8qplYN8vnyUXabFpzglvQdAFqZS2GsO6zwAeWrqxsojpcEpikj4T+izR\nW1TzaRDdm5pEaMMxvb6wFIgO32uAjN1a8GrRj+uk5cxuiOuk/C4Ii18FYhqEtDNd\nGv80rPxWEOxbCoSqH6igPnySw3ePFLBzgC4eSLBTnqfKYltd8fTeS9wGy47+L1YO\nqb5K/xlqt+REOdbTGLHi\n=MNXG\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Pieter Wuille",
                "date": "2015-01-21T21:22:07",
                "message_text_only": "On Wed, Jan 21, 2015 at 3:37 PM, Gavin Andresen <gavinandresen at gmail.com> wrote:\n> DERSIG BIP looks great to me, just a few nit-picky changes suggested:\n>\n> You mention the \"DER standard\" : should link to\n> http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf (or\n> whatever is best reference for DER).\n>\n> \"this would simplify avoiding OpenSSL in consensus implementations\"  -->\n> \"this would make it easier for non-OpenSSL implementations\"\n>\n> \"causing opcode failure\"  : I know what you mean by \"opcode failure\", but it\n> might be good to be more explicit.\n>\n> \"since v0.8.0, and nearly no transactions\" -->  \"and very few\n> transactions...\"\n>\n> \"reducing this avenue for malleability is useful on itself as well\"  :\n> awkward English. How about just \"This proposal has the added benefit of\n> reducing transaction malleability (see BIP62).\"\n\nNit addressed, hopefully.\n\n-- \nPieter"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2015-01-21T20:27:37",
                "message_text_only": "I've read this and it looks A-OK to me.\n\nAndrew\n\n\n\nOn Tue, Jan 20, 2015 at 07:35:49PM -0500, Pieter Wuille wrote:\n> Hello everyone,\n> \n> We've been aware of the risk of depending on OpenSSL for consensus\n> rules for a while, and were trying to get rid of this as part of BIP\n> 62 (malleability protection), which was however postponed due to\n> unforeseen complexities. The recent evens (see the thread titled\n> \"OpenSSL 1.0.0p / 1.0.1k incompatible, causes blockchain rejection.\"\n> on this mailing list) have made it clear that the problem is very\n> real, however, and I would prefer to have a fundamental solution for\n> it sooner rather than later.\n> \n> I therefore propose a softfork to make non-DER signatures illegal\n> (they've been non-standard since v0.8.0). A draft BIP text can be\n> found on:\n> \n>     https://gist.github.com/sipa/5d12c343746dad376c80\n> \n> The document includes motivation and specification. In addition, an\n> implementation (including unit tests derived from the BIP text) can be\n> found on:\n> \n>     https://github.com/sipa/bitcoin/commit/bipstrictder\n> \n> Comments/criticisms are very welcome, but I'd prefer keeping the\n> discussion here on the mailinglist (which is more accessible than on\n> the gist).\n> \n> -- \n> Pieter\n> \n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> \n\n-- \nAndrew Poelstra\nMathematics Department, University of Texas at Austin\nEmail: apoelstra at wpsoftware.net\nWeb:   http://www.wpsoftware.net/andrew\n\n\"If they had taught a class on how to be the kind of citizen Dick Cheney\n worries about, I would have finished high school.\"   --Edward Snowden\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: not available\nType: application/pgp-signature\nSize: 490 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150121/c2345e35/attachment.sig>"
            },
            {
                "author": "Dave Collins",
                "date": "2015-01-21T22:57:22",
                "message_text_only": "I'm really glad to see this proposal.  We already treat non-DER\nsignatures as non-standard in btcd and agree that extending them be\nillegal as a part of a soft fork is a smart and sane thing to do.\n\nIt's also good to see the explicit use of signature parsing since it\nmatches what we already do as well because we noticed noticed OpenSSL's\nnotion of big numbers (unsigned) didn't agree with Go's (signed).  By\nhaving the explicit signature scheme and checking clearly called out in\na BIP, it greatly lowers the chances of there being any disagreement\nabout what is valid or invalid due to an underlying dependency.\n\n+1\n\nOn 1/20/2015 6:35 PM, Pieter Wuille wrote:\n> Hello everyone,\n> \n> We've been aware of the risk of depending on OpenSSL for consensus\n> rules for a while, and were trying to get rid of this as part of BIP\n> 62 (malleability protection), which was however postponed due to\n> unforeseen complexities. The recent evens (see the thread titled\n> \"OpenSSL 1.0.0p / 1.0.1k incompatible, causes blockchain rejection.\"\n> on this mailing list) have made it clear that the problem is very\n> real, however, and I would prefer to have a fundamental solution for\n> it sooner rather than later.\n> \n> I therefore propose a softfork to make non-DER signatures illegal\n> (they've been non-standard since v0.8.0). A draft BIP text can be\n> found on:\n> \n>     https://gist.github.com/sipa/5d12c343746dad376c80\n> \n> The document includes motivation and specification. In addition, an\n> implementation (including unit tests derived from the BIP text) can be\n> found on:\n> \n>     https://github.com/sipa/bitcoin/commit/bipstrictder\n> \n> Comments/criticisms are very welcome, but I'd prefer keeping the\n> discussion here on the mailinglist (which is more accessible than on\n> the gist).\n> \n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 834 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150121/8834b942/attachment.sig>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-01-22T00:32:35",
                "message_text_only": "Pieter Wuille <pieter.wuille at gmail.com> writes:\n> Hello everyone,\n>\n> We've been aware of the risk of depending on OpenSSL for consensus\n> rules for a while, and were trying to get rid of this as part of BIP\n> 62 (malleability protection), which was however postponed due to\n> unforeseen complexities. The recent evens (see the thread titled\n> \"OpenSSL 1.0.0p / 1.0.1k incompatible, causes blockchain rejection.\"\n> on this mailing list) have made it clear that the problem is very\n> real, however, and I would prefer to have a fundamental solution for\n> it sooner rather than later.\n\nOK, I worked up a clearer (but more verbose) version with fewer\nmagic numbers.  More importantly, feel free to steal the test cases.\n\nOne weirdness is the restriction on maximum total length, rather than a\n32 byte (33 with 0-prepad) limit on signatures themselves.\n\nApologies for my babytalk C++.  Am sure there's a neater way.\n\n/* Licensed under Creative Commons zero (public domain). */\n#include <vector>\n#include <cstdlib>\n#include <cassert>\n\n#ifdef CLARIFY\nbool ConsumeByte(const std::vector<unsigned char> &sig, size_t &off,\n                 unsigned int &val)\n{\n    if (off >= sig.size()) return false;\n\n    val = sig[off++];\n    return true;\n}\n\nbool ConsumeTypeByte(const std::vector<unsigned char> &sig, size_t &off,\n                     unsigned int t)\n{\n    unsigned int type;\n    if (!ConsumeByte(sig, off, type)) return false;\n\n    return (type == t);\n}\n\nbool ConsumeNonZeroLength(const std::vector<unsigned char> &sig, size_t &off,\n                          unsigned int &len)\n{\n    if (!ConsumeByte(sig, off, len)) return false;\n\n    // Zero-length integers are not allowed.\n    return (len != 0);\n}\n\nbool ConsumeNumber(const std::vector<unsigned char> &sig, size_t &off,\n                   unsigned int len)\n{\n    // Length of number should be within signature.\n    if (off + len > sig.size()) return false;\n\n    // Negative numbers are not allowed.\n    if (sig[off] & 0x80) return false;\n\n    // Zero bytes at the start are not allowed, unless it would\n    // otherwise be interpreted as a negative number.\n    if (len > 1 && (sig[off] == 0x00) && !(sig[off+1] & 0x80)) return false;\n\n    // Consume number itself.\n    off += len;\n    return true;\n}\n\n// Consume a DER encoded integer, update off if successful.\nbool ConsumeDERInteger(const std::vector<unsigned char> &sig, size_t &off) {\n    unsigned int len;\n\n    // Type byte must be \"integer\"\n    if (!ConsumeTypeByte(sig, off, 0x02)) return false;\n    if (!ConsumeNonZeroLength(sig, off, len)) return false;\n    // Now the BE encoded value itself.\n    if (!ConsumeNumber(sig, off, len)) return false;\n\n    return true;\n}\n\nbool IsValidSignatureEncoding(const std::vector<unsigned char> &sig) {\n    // Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S] [sighash]\n    // * total-length: 1-byte length descriptor of everything that follows,\n    //     excluding the sighash byte.\n    // * R-length: 1-byte length descriptor of the R value that follows.\n    // * R: arbitrary-length big-endian encoded R value. It cannot start with any\n    //     null bytes, unless the first byte that follows is 0x80 or higher, in which\n    //     case a single null byte is required.\n    // * S-length: 1-byte length descriptor of the S value that follows.\n    // * S: arbitrary-length big-endian encoded S value. The same rules apply.\n    // * sighash: 1-byte value indicating what data is hashed.\n\n    // Accept empty signature as correctly encoded (but invalid) signature,\n    // even though it is not strictly DER.\n    if (sig.size() == 0) return true;\n\n    // Maximum size constraint.\n    if (sig.size() > 73) return false;\n\n    size_t off = 0;\n\n    // A signature is of type \"compound\".\n    if (!ConsumeTypeByte(sig, off, 0x30)) return false;\n\n    unsigned int len;\n    if (!ConsumeNonZeroLength(sig, off, len)) return false;\n\n    // Make sure the length covers the rest (except sighash).\n    if (len + 1 != sig.size() - off) return false;\n\n    // Check R value.\n    if (!ConsumeDERInteger(sig, off)) return false;\n\n    // Check S value.\n    if (!ConsumeDERInteger(sig, off)) return false;\n\n    // There should exactly one byte left (the sighash).\n    return off + 1 == sig.size() ? true : false;\n}\n#else\nbool IsValidSignatureEncoding(const std::vector<unsigned char> &sig) {\n    // Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S] [sighash]\n    // * total-length: 1-byte length descriptor of everything that follows,\n    //     excluding the sighash byte.\n    // * R-length: 1-byte length descriptor of the R value that follows.\n    // * R: arbitrary-length big-endian encoded R value. It must use the shortest\n    //     possible encoding for a positive integers (which means no null bytes at\n    //     the start, except a single one when the next byte has its highest bit set).\n    // * S-length: 1-byte length descriptor of the S value that follows.\n    // * S: arbitrary-length big-endian encoded S value. The same rules apply.\n    // * sighash: 1-byte value indicating what data is hashed (not part of the DER\n    //     signature)\n\n    // Accept empty signature as correctly encoded (but invalid) signature,\n    // even though it is not strictly DER. This avoids needing full DER signatures\n    // in places where any invalid signature would do. Given that the empty string is\n    // always invalid as signature, this is safe.\n    if (sig.size() == 0) return true;\n\n    // Minimum and maximum size constraints.\n    if (sig.size() < 9) return false;\n    if (sig.size() > 73) return false;\n\n    // A signature is of type 0x30 (compound).\n    if (sig[0] != 0x30) return false;\n\n    // Make sure the length covers the entire signature.\n    if (sig[1] != sig.size() - 3) return false;\n\n    // Extract the length of the R element.\n    unsigned int lenR = sig[3];\n\n    // Make sure the length of the S element is still inside the signature.\n    if (5 + lenR >= sig.size()) return false;\n\n    // Extract the length of the S element.\n    unsigned int lenS = sig[5 + lenR];\n\n    // Verify that the length of the signature matches the sum of the length\n    // of the elements.\n    if ((size_t)(lenR + lenS + 7) != sig.size()) return false;\n \n    // Check whether the R element is an integer.\n    if (sig[2] != 0x02) return false;\n\n    // Zero-length integers are not allowed for R.\n    if (lenR == 0) return false;\n\n    // Negative numbers are not allowed for R.\n    if (sig[4] & 0x80) return false;\n\n    // Null bytes at the start of R are not allowed, unless R would\n    // otherwise be interpreted as a negative number.\n    if (lenR > 1 && (sig[4] == 0x00) && !(sig[5] & 0x80)) return false;\n\n    // Check whether the S element is an integer.\n    if (sig[lenR + 4] != 0x02) return false;\n\n    // Zero-length integers are not allowed for S.\n    if (lenS == 0) return false;\n\n    // Negative numbers are not allowed for S.\n    if (sig[lenR + 6] & 0x80) return false;\n\n    // Null bytes at the start of S are not allowed, unless S would otherwise be\n    // interpreted as a negative number.\n    if (lenS > 1 && (sig[lenR + 6] == 0x00) && !(sig[lenR + 7] & 0x80)) return false;\n\n    return true;\n}\n#endif\n\n#define COMPOUND 0x30\n#define NOT_COMPOUND 0x31\n\n// Len gets adjusted by check() to be actual length with this offset.\n#define LEN_OK 0\n#define LEN_TOO_BIG 1\n#define LEN_TOO_SMALL 0xff\n\n#define INT 0x02\n#define NOT_INT 0x03\n\n#define MINIMAL_SIGLEN 1\n#define MINIMAL_SIGVAL 0x0\n\n#define NORMAL_SIGLEN 32\n#define NORMAL_SIGVAL(S) S, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, \\\n        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,              \\\n        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,              \\\n        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f\n\n// 33 bytes is possible, with 0 prepended.\n#define MAXIMAL_SIGLEN 33\n#define MAXIMAL_SIGVAL(S) NORMAL_SIGVAL(S), 0x20\n\n#define OVERSIZE_SIGLEN 34\n#define OVERSIZE_SIGVAL(S) MAXIMAL_SIGVAL(S), 0x21\n\n#define ZEROPAD_SIGLEN (1 + NORMAL_SIGLEN)\n#define ZEROPAD_SIGVAL(S) 00, NORMAL_SIGVAL(S)\n\n#define SIGHASH 0xf0\n\nstatic bool check(const std::vector<unsigned char> &sig)\n{\n    std::vector<unsigned char> fixed = sig;\n\n    // Fixup length\n    if (fixed.size() > 1)\n        fixed[1] += fixed.size() - 3;\n    return IsValidSignatureEncoding(fixed);\n}\n\n#define good(arr) assert(check(std::vector<unsigned char>(arr, arr+sizeof(arr))))\n#define bad(arr) assert(!check(std::vector<unsigned char>(arr, arr+sizeof(arr))))\n\n// The OK cases.\nstatic unsigned char zerolen[] = { };\nstatic unsigned char normal[] = { COMPOUND, LEN_OK,\n                                  INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n                                  INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n                                  SIGHASH };\nstatic unsigned char min_r[] = { COMPOUND, LEN_OK,\n                                 INT, MINIMAL_SIGLEN, MINIMAL_SIGVAL,\n                                 INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n                                 SIGHASH };\nstatic unsigned char min_s[] = { COMPOUND, LEN_OK,\n                                 INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n                                 INT, MINIMAL_SIGLEN, MINIMAL_SIGVAL,\n                                 SIGHASH };\nstatic unsigned char max_r[] = { COMPOUND, LEN_OK,\n                                 INT, MAXIMAL_SIGLEN, MAXIMAL_SIGVAL(0x1),\n                                 INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n                                 SIGHASH };\nstatic unsigned char max_s[] = { COMPOUND, LEN_OK,\n                                 INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n                                 INT, MAXIMAL_SIGLEN, MAXIMAL_SIGVAL(0x2),\n                                 SIGHASH };\n// As long as total size doesn't go over, a single sig is allowed > 33 bytes\nstatic unsigned char wierd_s_len[] = { COMPOUND, LEN_OK,\n                                       INT, OVERSIZE_SIGLEN, OVERSIZE_SIGVAL(0x1),\n                                       INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n                                       SIGHASH };\nstatic unsigned char wierd_r_len[] = { COMPOUND, LEN_OK,\n                                       INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n                                       INT, OVERSIZE_SIGLEN, OVERSIZE_SIGVAL(0x2),\n                                       SIGHASH };\nstatic unsigned char zeropad_s[] = { COMPOUND, LEN_OK,\n                                     INT, ZEROPAD_SIGLEN, ZEROPAD_SIGVAL(0x81),\n                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n                                     SIGHASH };\nstatic unsigned char zeropad_r[] = { COMPOUND, LEN_OK,\n                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n                                     INT, ZEROPAD_SIGLEN, ZEROPAD_SIGVAL(0x82),\n                                     SIGHASH };\n\n\n// The fail cases.\nstatic unsigned char not_compound[] = { NOT_COMPOUND, LEN_OK,\n                                        INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n                                        INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n                                        SIGHASH };\nstatic unsigned char short_len[] = { COMPOUND, LEN_TOO_SMALL,\n                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n                                     SIGHASH };\nstatic unsigned char long_len[] = { COMPOUND, LEN_TOO_BIG,\n                                    INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n                                    INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n                                    SIGHASH };\nstatic unsigned char r_notint[] = { COMPOUND, LEN_OK,\n                                    NOT_INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n                                    INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n                                    SIGHASH };\nstatic unsigned char s_notint[] = { COMPOUND, LEN_OK,\n                                    INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n                                    NOT_INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n                                    SIGHASH };\nstatic unsigned char s_oversig[] = { COMPOUND, LEN_OK,\n                                     INT, OVERSIZE_SIGLEN, OVERSIZE_SIGVAL(0x1),\n                                     INT, MAXIMAL_SIGLEN, MAXIMAL_SIGVAL(0x2),\n                                     SIGHASH };\nstatic unsigned char r_oversig[] = { COMPOUND, LEN_OK,\n                                     INT, MAXIMAL_SIGLEN, MAXIMAL_SIGVAL(0x1),\n                                     INT, OVERSIZE_SIGLEN, OVERSIZE_SIGVAL(0x2),\n                                     SIGHASH };\nstatic unsigned char s_negative[] = { COMPOUND, LEN_OK,\n                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x81),\n                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n                                      SIGHASH };\nstatic unsigned char r_negative[] = { COMPOUND, LEN_OK,\n                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x82),\n                                      SIGHASH };\nstatic unsigned char zeropad_bad_s[] = { COMPOUND, LEN_OK,\n                                         INT, ZEROPAD_SIGLEN, ZEROPAD_SIGVAL(0x1),\n                                         INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n                                         SIGHASH };\nstatic unsigned char zeropad_bad_r[] = { COMPOUND, LEN_OK,\n                                         INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n                                         INT, ZEROPAD_SIGLEN, ZEROPAD_SIGVAL(0x2),\n                                         SIGHASH };\nstatic unsigned char missing_sighash[] = { COMPOUND, LEN_OK,\n                                           INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n                                           INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2) };\nstatic unsigned char extra_byte[] = { COMPOUND, LEN_OK,\n                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n                                      SIGHASH, 0 };\n\n// Bad signature lengths\nstatic unsigned char zerolen_r[] = { COMPOUND, LEN_OK,\n                                     INT, 0,\n                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n                                     SIGHASH };\nstatic unsigned char zerolen_s[] = { COMPOUND, LEN_OK,\n                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n                                     INT, 0,\n                                     SIGHASH };\nstatic unsigned char overlen_r_by_1[] = { COMPOUND, LEN_OK,\n                                          INT, NORMAL_SIGLEN + 1 + 1 + NORMAL_SIGLEN + 1 + 1, NORMAL_SIGVAL(0x1),\n                                          INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n                                          SIGHASH };\nstatic unsigned char overlen_s_by_1[] = { COMPOUND, LEN_OK,\n                                          INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n                                          INT, NORMAL_SIGLEN+1+1, NORMAL_SIGVAL(0x2),\n                                          SIGHASH };\nstatic unsigned char underlen_r_by_1[] = { COMPOUND, LEN_OK,\n                                           INT, NORMAL_SIGLEN-1, NORMAL_SIGVAL(0x1),\n                                           INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n                                           SIGHASH };\nstatic unsigned char underlen_s_by_1[] = { COMPOUND, LEN_OK,\n                                           INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n                                           INT, NORMAL_SIGLEN-1, NORMAL_SIGVAL(0x2),\n                                           SIGHASH };\n\nint main()\n{\n    good(zerolen);\n    good(normal);\n    good(min_r);\n    good(min_s);\n    good(max_r);\n    good(max_s);\n    good(wierd_s_len);\n    good(wierd_r_len);\n    good(zeropad_s);\n    good(zeropad_r);\n\n    // Try different amounts of truncation.\n    for (size_t i = 1; i < sizeof(normal)-1; i++)\n        assert(!check(std::vector<unsigned char>(normal, normal+i)));\n\n    bad(not_compound);\n    bad(short_len);\n    bad(long_len);\n    bad(r_notint);\n    bad(s_notint);\n    bad(s_oversig);\n    bad(r_oversig);\n    bad(s_negative);\n    bad(r_negative);\n    bad(s_negative);\n    bad(r_negative);\n    bad(zeropad_bad_s);\n    bad(zeropad_bad_r);\n    bad(zerolen_r);\n    bad(zerolen_s);\n    bad(overlen_r_by_1);\n    bad(overlen_s_by_1);\n    bad(underlen_r_by_1);\n    bad(underlen_s_by_1);\n    bad(missing_sighash);\n    bad(extra_byte);\n\n    return 0;\n}"
            },
            {
                "author": "David Vorick",
                "date": "2015-01-22T03:12:31",
                "message_text_only": "Seems like a good change to me.\n\nOn Wed, Jan 21, 2015 at 7:32 PM, Rusty Russell <rusty at rustcorp.com.au>\nwrote:\n\n> Pieter Wuille <pieter.wuille at gmail.com> writes:\n> > Hello everyone,\n> >\n> > We've been aware of the risk of depending on OpenSSL for consensus\n> > rules for a while, and were trying to get rid of this as part of BIP\n> > 62 (malleability protection), which was however postponed due to\n> > unforeseen complexities. The recent evens (see the thread titled\n> > \"OpenSSL 1.0.0p / 1.0.1k incompatible, causes blockchain rejection.\"\n> > on this mailing list) have made it clear that the problem is very\n> > real, however, and I would prefer to have a fundamental solution for\n> > it sooner rather than later.\n>\n> OK, I worked up a clearer (but more verbose) version with fewer\n> magic numbers.  More importantly, feel free to steal the test cases.\n>\n> One weirdness is the restriction on maximum total length, rather than a\n> 32 byte (33 with 0-prepad) limit on signatures themselves.\n>\n> Apologies for my babytalk C++.  Am sure there's a neater way.\n>\n> /* Licensed under Creative Commons zero (public domain). */\n> #include <vector>\n> #include <cstdlib>\n> #include <cassert>\n>\n> #ifdef CLARIFY\n> bool ConsumeByte(const std::vector<unsigned char> &sig, size_t &off,\n>                  unsigned int &val)\n> {\n>     if (off >= sig.size()) return false;\n>\n>     val = sig[off++];\n>     return true;\n> }\n>\n> bool ConsumeTypeByte(const std::vector<unsigned char> &sig, size_t &off,\n>                      unsigned int t)\n> {\n>     unsigned int type;\n>     if (!ConsumeByte(sig, off, type)) return false;\n>\n>     return (type == t);\n> }\n>\n> bool ConsumeNonZeroLength(const std::vector<unsigned char> &sig, size_t\n> &off,\n>                           unsigned int &len)\n> {\n>     if (!ConsumeByte(sig, off, len)) return false;\n>\n>     // Zero-length integers are not allowed.\n>     return (len != 0);\n> }\n>\n> bool ConsumeNumber(const std::vector<unsigned char> &sig, size_t &off,\n>                    unsigned int len)\n> {\n>     // Length of number should be within signature.\n>     if (off + len > sig.size()) return false;\n>\n>     // Negative numbers are not allowed.\n>     if (sig[off] & 0x80) return false;\n>\n>     // Zero bytes at the start are not allowed, unless it would\n>     // otherwise be interpreted as a negative number.\n>     if (len > 1 && (sig[off] == 0x00) && !(sig[off+1] & 0x80)) return\n> false;\n>\n>     // Consume number itself.\n>     off += len;\n>     return true;\n> }\n>\n> // Consume a DER encoded integer, update off if successful.\n> bool ConsumeDERInteger(const std::vector<unsigned char> &sig, size_t &off)\n> {\n>     unsigned int len;\n>\n>     // Type byte must be \"integer\"\n>     if (!ConsumeTypeByte(sig, off, 0x02)) return false;\n>     if (!ConsumeNonZeroLength(sig, off, len)) return false;\n>     // Now the BE encoded value itself.\n>     if (!ConsumeNumber(sig, off, len)) return false;\n>\n>     return true;\n> }\n>\n> bool IsValidSignatureEncoding(const std::vector<unsigned char> &sig) {\n>     // Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n> [sighash]\n>     // * total-length: 1-byte length descriptor of everything that follows,\n>     //     excluding the sighash byte.\n>     // * R-length: 1-byte length descriptor of the R value that follows.\n>     // * R: arbitrary-length big-endian encoded R value. It cannot start\n> with any\n>     //     null bytes, unless the first byte that follows is 0x80 or\n> higher, in which\n>     //     case a single null byte is required.\n>     // * S-length: 1-byte length descriptor of the S value that follows.\n>     // * S: arbitrary-length big-endian encoded S value. The same rules\n> apply.\n>     // * sighash: 1-byte value indicating what data is hashed.\n>\n>     // Accept empty signature as correctly encoded (but invalid) signature,\n>     // even though it is not strictly DER.\n>     if (sig.size() == 0) return true;\n>\n>     // Maximum size constraint.\n>     if (sig.size() > 73) return false;\n>\n>     size_t off = 0;\n>\n>     // A signature is of type \"compound\".\n>     if (!ConsumeTypeByte(sig, off, 0x30)) return false;\n>\n>     unsigned int len;\n>     if (!ConsumeNonZeroLength(sig, off, len)) return false;\n>\n>     // Make sure the length covers the rest (except sighash).\n>     if (len + 1 != sig.size() - off) return false;\n>\n>     // Check R value.\n>     if (!ConsumeDERInteger(sig, off)) return false;\n>\n>     // Check S value.\n>     if (!ConsumeDERInteger(sig, off)) return false;\n>\n>     // There should exactly one byte left (the sighash).\n>     return off + 1 == sig.size() ? true : false;\n> }\n> #else\n> bool IsValidSignatureEncoding(const std::vector<unsigned char> &sig) {\n>     // Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n> [sighash]\n>     // * total-length: 1-byte length descriptor of everything that follows,\n>     //     excluding the sighash byte.\n>     // * R-length: 1-byte length descriptor of the R value that follows.\n>     // * R: arbitrary-length big-endian encoded R value. It must use the\n> shortest\n>     //     possible encoding for a positive integers (which means no null\n> bytes at\n>     //     the start, except a single one when the next byte has its\n> highest bit set).\n>     // * S-length: 1-byte length descriptor of the S value that follows.\n>     // * S: arbitrary-length big-endian encoded S value. The same rules\n> apply.\n>     // * sighash: 1-byte value indicating what data is hashed (not part of\n> the DER\n>     //     signature)\n>\n>     // Accept empty signature as correctly encoded (but invalid) signature,\n>     // even though it is not strictly DER. This avoids needing full DER\n> signatures\n>     // in places where any invalid signature would do. Given that the\n> empty string is\n>     // always invalid as signature, this is safe.\n>     if (sig.size() == 0) return true;\n>\n>     // Minimum and maximum size constraints.\n>     if (sig.size() < 9) return false;\n>     if (sig.size() > 73) return false;\n>\n>     // A signature is of type 0x30 (compound).\n>     if (sig[0] != 0x30) return false;\n>\n>     // Make sure the length covers the entire signature.\n>     if (sig[1] != sig.size() - 3) return false;\n>\n>     // Extract the length of the R element.\n>     unsigned int lenR = sig[3];\n>\n>     // Make sure the length of the S element is still inside the signature.\n>     if (5 + lenR >= sig.size()) return false;\n>\n>     // Extract the length of the S element.\n>     unsigned int lenS = sig[5 + lenR];\n>\n>     // Verify that the length of the signature matches the sum of the\n> length\n>     // of the elements.\n>     if ((size_t)(lenR + lenS + 7) != sig.size()) return false;\n>\n>     // Check whether the R element is an integer.\n>     if (sig[2] != 0x02) return false;\n>\n>     // Zero-length integers are not allowed for R.\n>     if (lenR == 0) return false;\n>\n>     // Negative numbers are not allowed for R.\n>     if (sig[4] & 0x80) return false;\n>\n>     // Null bytes at the start of R are not allowed, unless R would\n>     // otherwise be interpreted as a negative number.\n>     if (lenR > 1 && (sig[4] == 0x00) && !(sig[5] & 0x80)) return false;\n>\n>     // Check whether the S element is an integer.\n>     if (sig[lenR + 4] != 0x02) return false;\n>\n>     // Zero-length integers are not allowed for S.\n>     if (lenS == 0) return false;\n>\n>     // Negative numbers are not allowed for S.\n>     if (sig[lenR + 6] & 0x80) return false;\n>\n>     // Null bytes at the start of S are not allowed, unless S would\n> otherwise be\n>     // interpreted as a negative number.\n>     if (lenS > 1 && (sig[lenR + 6] == 0x00) && !(sig[lenR + 7] & 0x80))\n> return false;\n>\n>     return true;\n> }\n> #endif\n>\n> #define COMPOUND 0x30\n> #define NOT_COMPOUND 0x31\n>\n> // Len gets adjusted by check() to be actual length with this offset.\n> #define LEN_OK 0\n> #define LEN_TOO_BIG 1\n> #define LEN_TOO_SMALL 0xff\n>\n> #define INT 0x02\n> #define NOT_INT 0x03\n>\n> #define MINIMAL_SIGLEN 1\n> #define MINIMAL_SIGVAL 0x0\n>\n> #define NORMAL_SIGLEN 32\n> #define NORMAL_SIGVAL(S) S, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, \\\n>         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,              \\\n>         0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,              \\\n>         0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f\n>\n> // 33 bytes is possible, with 0 prepended.\n> #define MAXIMAL_SIGLEN 33\n> #define MAXIMAL_SIGVAL(S) NORMAL_SIGVAL(S), 0x20\n>\n> #define OVERSIZE_SIGLEN 34\n> #define OVERSIZE_SIGVAL(S) MAXIMAL_SIGVAL(S), 0x21\n>\n> #define ZEROPAD_SIGLEN (1 + NORMAL_SIGLEN)\n> #define ZEROPAD_SIGVAL(S) 00, NORMAL_SIGVAL(S)\n>\n> #define SIGHASH 0xf0\n>\n> static bool check(const std::vector<unsigned char> &sig)\n> {\n>     std::vector<unsigned char> fixed = sig;\n>\n>     // Fixup length\n>     if (fixed.size() > 1)\n>         fixed[1] += fixed.size() - 3;\n>     return IsValidSignatureEncoding(fixed);\n> }\n>\n> #define good(arr) assert(check(std::vector<unsigned char>(arr,\n> arr+sizeof(arr))))\n> #define bad(arr) assert(!check(std::vector<unsigned char>(arr,\n> arr+sizeof(arr))))\n>\n> // The OK cases.\n> static unsigned char zerolen[] = { };\n> static unsigned char normal[] = { COMPOUND, LEN_OK,\n>                                   INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                   INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n>                                   SIGHASH };\n> static unsigned char min_r[] = { COMPOUND, LEN_OK,\n>                                  INT, MINIMAL_SIGLEN, MINIMAL_SIGVAL,\n>                                  INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n>                                  SIGHASH };\n> static unsigned char min_s[] = { COMPOUND, LEN_OK,\n>                                  INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                  INT, MINIMAL_SIGLEN, MINIMAL_SIGVAL,\n>                                  SIGHASH };\n> static unsigned char max_r[] = { COMPOUND, LEN_OK,\n>                                  INT, MAXIMAL_SIGLEN, MAXIMAL_SIGVAL(0x1),\n>                                  INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n>                                  SIGHASH };\n> static unsigned char max_s[] = { COMPOUND, LEN_OK,\n>                                  INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                  INT, MAXIMAL_SIGLEN, MAXIMAL_SIGVAL(0x2),\n>                                  SIGHASH };\n> // As long as total size doesn't go over, a single sig is allowed > 33\n> bytes\n> static unsigned char wierd_s_len[] = { COMPOUND, LEN_OK,\n>                                        INT, OVERSIZE_SIGLEN,\n> OVERSIZE_SIGVAL(0x1),\n>                                        INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x2),\n>                                        SIGHASH };\n> static unsigned char wierd_r_len[] = { COMPOUND, LEN_OK,\n>                                        INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x1),\n>                                        INT, OVERSIZE_SIGLEN,\n> OVERSIZE_SIGVAL(0x2),\n>                                        SIGHASH };\n> static unsigned char zeropad_s[] = { COMPOUND, LEN_OK,\n>                                      INT, ZEROPAD_SIGLEN,\n> ZEROPAD_SIGVAL(0x81),\n>                                      INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x2),\n>                                      SIGHASH };\n> static unsigned char zeropad_r[] = { COMPOUND, LEN_OK,\n>                                      INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x1),\n>                                      INT, ZEROPAD_SIGLEN,\n> ZEROPAD_SIGVAL(0x82),\n>                                      SIGHASH };\n>\n>\n> // The fail cases.\n> static unsigned char not_compound[] = { NOT_COMPOUND, LEN_OK,\n>                                         INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x1),\n>                                         INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x2),\n>                                         SIGHASH };\n> static unsigned char short_len[] = { COMPOUND, LEN_TOO_SMALL,\n>                                      INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x1),\n>                                      INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x2),\n>                                      SIGHASH };\n> static unsigned char long_len[] = { COMPOUND, LEN_TOO_BIG,\n>                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n>                                     SIGHASH };\n> static unsigned char r_notint[] = { COMPOUND, LEN_OK,\n>                                     NOT_INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x1),\n>                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n>                                     SIGHASH };\n> static unsigned char s_notint[] = { COMPOUND, LEN_OK,\n>                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                     NOT_INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x2),\n>                                     SIGHASH };\n> static unsigned char s_oversig[] = { COMPOUND, LEN_OK,\n>                                      INT, OVERSIZE_SIGLEN,\n> OVERSIZE_SIGVAL(0x1),\n>                                      INT, MAXIMAL_SIGLEN,\n> MAXIMAL_SIGVAL(0x2),\n>                                      SIGHASH };\n> static unsigned char r_oversig[] = { COMPOUND, LEN_OK,\n>                                      INT, MAXIMAL_SIGLEN,\n> MAXIMAL_SIGVAL(0x1),\n>                                      INT, OVERSIZE_SIGLEN,\n> OVERSIZE_SIGVAL(0x2),\n>                                      SIGHASH };\n> static unsigned char s_negative[] = { COMPOUND, LEN_OK,\n>                                       INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x81),\n>                                       INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x2),\n>                                       SIGHASH };\n> static unsigned char r_negative[] = { COMPOUND, LEN_OK,\n>                                       INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x1),\n>                                       INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x82),\n>                                       SIGHASH };\n> static unsigned char zeropad_bad_s[] = { COMPOUND, LEN_OK,\n>                                          INT, ZEROPAD_SIGLEN,\n> ZEROPAD_SIGVAL(0x1),\n>                                          INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x2),\n>                                          SIGHASH };\n> static unsigned char zeropad_bad_r[] = { COMPOUND, LEN_OK,\n>                                          INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x1),\n>                                          INT, ZEROPAD_SIGLEN,\n> ZEROPAD_SIGVAL(0x2),\n>                                          SIGHASH };\n> static unsigned char missing_sighash[] = { COMPOUND, LEN_OK,\n>                                            INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x1),\n>                                            INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x2) };\n> static unsigned char extra_byte[] = { COMPOUND, LEN_OK,\n>                                       INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x1),\n>                                       INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x2),\n>                                       SIGHASH, 0 };\n>\n> // Bad signature lengths\n> static unsigned char zerolen_r[] = { COMPOUND, LEN_OK,\n>                                      INT, 0,\n>                                      INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x2),\n>                                      SIGHASH };\n> static unsigned char zerolen_s[] = { COMPOUND, LEN_OK,\n>                                      INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x1),\n>                                      INT, 0,\n>                                      SIGHASH };\n> static unsigned char overlen_r_by_1[] = { COMPOUND, LEN_OK,\n>                                           INT, NORMAL_SIGLEN + 1 + 1 +\n> NORMAL_SIGLEN + 1 + 1, NORMAL_SIGVAL(0x1),\n>                                           INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x2),\n>                                           SIGHASH };\n> static unsigned char overlen_s_by_1[] = { COMPOUND, LEN_OK,\n>                                           INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x1),\n>                                           INT, NORMAL_SIGLEN+1+1,\n> NORMAL_SIGVAL(0x2),\n>                                           SIGHASH };\n> static unsigned char underlen_r_by_1[] = { COMPOUND, LEN_OK,\n>                                            INT, NORMAL_SIGLEN-1,\n> NORMAL_SIGVAL(0x1),\n>                                            INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x2),\n>                                            SIGHASH };\n> static unsigned char underlen_s_by_1[] = { COMPOUND, LEN_OK,\n>                                            INT, NORMAL_SIGLEN,\n> NORMAL_SIGVAL(0x1),\n>                                            INT, NORMAL_SIGLEN-1,\n> NORMAL_SIGVAL(0x2),\n>                                            SIGHASH };\n>\n> int main()\n> {\n>     good(zerolen);\n>     good(normal);\n>     good(min_r);\n>     good(min_s);\n>     good(max_r);\n>     good(max_s);\n>     good(wierd_s_len);\n>     good(wierd_r_len);\n>     good(zeropad_s);\n>     good(zeropad_r);\n>\n>     // Try different amounts of truncation.\n>     for (size_t i = 1; i < sizeof(normal)-1; i++)\n>         assert(!check(std::vector<unsigned char>(normal, normal+i)));\n>\n>     bad(not_compound);\n>     bad(short_len);\n>     bad(long_len);\n>     bad(r_notint);\n>     bad(s_notint);\n>     bad(s_oversig);\n>     bad(r_oversig);\n>     bad(s_negative);\n>     bad(r_negative);\n>     bad(s_negative);\n>     bad(r_negative);\n>     bad(zeropad_bad_s);\n>     bad(zeropad_bad_r);\n>     bad(zerolen_r);\n>     bad(zerolen_s);\n>     bad(overlen_r_by_1);\n>     bad(overlen_s_by_1);\n>     bad(underlen_r_by_1);\n>     bad(underlen_s_by_1);\n>     bad(missing_sighash);\n>     bad(extra_byte);\n>\n>     return 0;\n> }\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150121/fba1f709/attachment.html>"
            },
            {
                "author": "Matt Whitlock",
                "date": "2015-01-22T04:18:07",
                "message_text_only": "To be more in the C++ spirit, I would suggest changing the (const std::vector<unsigned char> &sig, size_t &off) parameters to (std::vector<unsigned char>::const_iterator &itr, std::vector<unsigned char>::const_iterator end).\n\nExample:\n\nbool ConsumeNumber(std::vector<unsigned char>::const_iterator &itr, std::vector<unsigned char>::const_iterator end, unsigned int len)\n{\n\t// Length of number should be within signature.\n\tif (itr + len >= end) return false;\n \n\t// Negative numbers are not allowed.\n\tif (*itr & 0x80) return false;\n \n\t// Zero bytes at the start are not allowed, unless it would\n\t// otherwise be interpreted as a negative number.\n\tif (len > 1 && (*itr == 0x00) && !(*(itr + 1) & 0x80)) return false;\n \n\t// Consume number itself.\n\titr += len;\n\treturn true;\n}\n\n\nOn Thursday, 22 January 2015, at 11:02 am, Rusty Russell wrote:\n> Pieter Wuille <pieter.wuille at gmail.com> writes:\n> > Hello everyone,\n> >\n> > We've been aware of the risk of depending on OpenSSL for consensus\n> > rules for a while, and were trying to get rid of this as part of BIP\n> > 62 (malleability protection), which was however postponed due to\n> > unforeseen complexities. The recent evens (see the thread titled\n> > \"OpenSSL 1.0.0p / 1.0.1k incompatible, causes blockchain rejection.\"\n> > on this mailing list) have made it clear that the problem is very\n> > real, however, and I would prefer to have a fundamental solution for\n> > it sooner rather than later.\n> \n> OK, I worked up a clearer (but more verbose) version with fewer\n> magic numbers.  More importantly, feel free to steal the test cases.\n> \n> One weirdness is the restriction on maximum total length, rather than a\n> 32 byte (33 with 0-prepad) limit on signatures themselves.\n> \n> Apologies for my babytalk C++.  Am sure there's a neater way.\n> \n> /* Licensed under Creative Commons zero (public domain). */\n> #include <vector>\n> #include <cstdlib>\n> #include <cassert>\n> \n> #ifdef CLARIFY\n> bool ConsumeByte(const std::vector<unsigned char> &sig, size_t &off,\n>                  unsigned int &val)\n> {\n>     if (off >= sig.size()) return false;\n> \n>     val = sig[off++];\n>     return true;\n> }\n> \n> bool ConsumeTypeByte(const std::vector<unsigned char> &sig, size_t &off,\n>                      unsigned int t)\n> {\n>     unsigned int type;\n>     if (!ConsumeByte(sig, off, type)) return false;\n> \n>     return (type == t);\n> }\n> \n> bool ConsumeNonZeroLength(const std::vector<unsigned char> &sig, size_t &off,\n>                           unsigned int &len)\n> {\n>     if (!ConsumeByte(sig, off, len)) return false;\n> \n>     // Zero-length integers are not allowed.\n>     return (len != 0);\n> }\n> \n> bool ConsumeNumber(const std::vector<unsigned char> &sig, size_t &off,\n>                    unsigned int len)\n> {\n>     // Length of number should be within signature.\n>     if (off + len > sig.size()) return false;\n> \n>     // Negative numbers are not allowed.\n>     if (sig[off] & 0x80) return false;\n> \n>     // Zero bytes at the start are not allowed, unless it would\n>     // otherwise be interpreted as a negative number.\n>     if (len > 1 && (sig[off] == 0x00) && !(sig[off+1] & 0x80)) return false;\n> \n>     // Consume number itself.\n>     off += len;\n>     return true;\n> }\n> \n> // Consume a DER encoded integer, update off if successful.\n> bool ConsumeDERInteger(const std::vector<unsigned char> &sig, size_t &off) {\n>     unsigned int len;\n> \n>     // Type byte must be \"integer\"\n>     if (!ConsumeTypeByte(sig, off, 0x02)) return false;\n>     if (!ConsumeNonZeroLength(sig, off, len)) return false;\n>     // Now the BE encoded value itself.\n>     if (!ConsumeNumber(sig, off, len)) return false;\n> \n>     return true;\n> }\n> \n> bool IsValidSignatureEncoding(const std::vector<unsigned char> &sig) {\n>     // Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S] [sighash]\n>     // * total-length: 1-byte length descriptor of everything that follows,\n>     //     excluding the sighash byte.\n>     // * R-length: 1-byte length descriptor of the R value that follows.\n>     // * R: arbitrary-length big-endian encoded R value. It cannot start with any\n>     //     null bytes, unless the first byte that follows is 0x80 or higher, in which\n>     //     case a single null byte is required.\n>     // * S-length: 1-byte length descriptor of the S value that follows.\n>     // * S: arbitrary-length big-endian encoded S value. The same rules apply.\n>     // * sighash: 1-byte value indicating what data is hashed.\n> \n>     // Accept empty signature as correctly encoded (but invalid) signature,\n>     // even though it is not strictly DER.\n>     if (sig.size() == 0) return true;\n> \n>     // Maximum size constraint.\n>     if (sig.size() > 73) return false;\n> \n>     size_t off = 0;\n> \n>     // A signature is of type \"compound\".\n>     if (!ConsumeTypeByte(sig, off, 0x30)) return false;\n> \n>     unsigned int len;\n>     if (!ConsumeNonZeroLength(sig, off, len)) return false;\n> \n>     // Make sure the length covers the rest (except sighash).\n>     if (len + 1 != sig.size() - off) return false;\n> \n>     // Check R value.\n>     if (!ConsumeDERInteger(sig, off)) return false;\n> \n>     // Check S value.\n>     if (!ConsumeDERInteger(sig, off)) return false;\n> \n>     // There should exactly one byte left (the sighash).\n>     return off + 1 == sig.size() ? true : false;\n> }\n> #else\n> bool IsValidSignatureEncoding(const std::vector<unsigned char> &sig) {\n>     // Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S] [sighash]\n>     // * total-length: 1-byte length descriptor of everything that follows,\n>     //     excluding the sighash byte.\n>     // * R-length: 1-byte length descriptor of the R value that follows.\n>     // * R: arbitrary-length big-endian encoded R value. It must use the shortest\n>     //     possible encoding for a positive integers (which means no null bytes at\n>     //     the start, except a single one when the next byte has its highest bit set).\n>     // * S-length: 1-byte length descriptor of the S value that follows.\n>     // * S: arbitrary-length big-endian encoded S value. The same rules apply.\n>     // * sighash: 1-byte value indicating what data is hashed (not part of the DER\n>     //     signature)\n> \n>     // Accept empty signature as correctly encoded (but invalid) signature,\n>     // even though it is not strictly DER. This avoids needing full DER signatures\n>     // in places where any invalid signature would do. Given that the empty string is\n>     // always invalid as signature, this is safe.\n>     if (sig.size() == 0) return true;\n> \n>     // Minimum and maximum size constraints.\n>     if (sig.size() < 9) return false;\n>     if (sig.size() > 73) return false;\n> \n>     // A signature is of type 0x30 (compound).\n>     if (sig[0] != 0x30) return false;\n> \n>     // Make sure the length covers the entire signature.\n>     if (sig[1] != sig.size() - 3) return false;\n> \n>     // Extract the length of the R element.\n>     unsigned int lenR = sig[3];\n> \n>     // Make sure the length of the S element is still inside the signature.\n>     if (5 + lenR >= sig.size()) return false;\n> \n>     // Extract the length of the S element.\n>     unsigned int lenS = sig[5 + lenR];\n> \n>     // Verify that the length of the signature matches the sum of the length\n>     // of the elements.\n>     if ((size_t)(lenR + lenS + 7) != sig.size()) return false;\n>  \n>     // Check whether the R element is an integer.\n>     if (sig[2] != 0x02) return false;\n> \n>     // Zero-length integers are not allowed for R.\n>     if (lenR == 0) return false;\n> \n>     // Negative numbers are not allowed for R.\n>     if (sig[4] & 0x80) return false;\n> \n>     // Null bytes at the start of R are not allowed, unless R would\n>     // otherwise be interpreted as a negative number.\n>     if (lenR > 1 && (sig[4] == 0x00) && !(sig[5] & 0x80)) return false;\n> \n>     // Check whether the S element is an integer.\n>     if (sig[lenR + 4] != 0x02) return false;\n> \n>     // Zero-length integers are not allowed for S.\n>     if (lenS == 0) return false;\n> \n>     // Negative numbers are not allowed for S.\n>     if (sig[lenR + 6] & 0x80) return false;\n> \n>     // Null bytes at the start of S are not allowed, unless S would otherwise be\n>     // interpreted as a negative number.\n>     if (lenS > 1 && (sig[lenR + 6] == 0x00) && !(sig[lenR + 7] & 0x80)) return false;\n> \n>     return true;\n> }\n> #endif\n> \n> #define COMPOUND 0x30\n> #define NOT_COMPOUND 0x31\n> \n> // Len gets adjusted by check() to be actual length with this offset.\n> #define LEN_OK 0\n> #define LEN_TOO_BIG 1\n> #define LEN_TOO_SMALL 0xff\n> \n> #define INT 0x02\n> #define NOT_INT 0x03\n> \n> #define MINIMAL_SIGLEN 1\n> #define MINIMAL_SIGVAL 0x0\n> \n> #define NORMAL_SIGLEN 32\n> #define NORMAL_SIGVAL(S) S, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, \\\n>         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,              \\\n>         0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,              \\\n>         0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f\n> \n> // 33 bytes is possible, with 0 prepended.\n> #define MAXIMAL_SIGLEN 33\n> #define MAXIMAL_SIGVAL(S) NORMAL_SIGVAL(S), 0x20\n> \n> #define OVERSIZE_SIGLEN 34\n> #define OVERSIZE_SIGVAL(S) MAXIMAL_SIGVAL(S), 0x21\n> \n> #define ZEROPAD_SIGLEN (1 + NORMAL_SIGLEN)\n> #define ZEROPAD_SIGVAL(S) 00, NORMAL_SIGVAL(S)\n> \n> #define SIGHASH 0xf0\n> \n> static bool check(const std::vector<unsigned char> &sig)\n> {\n>     std::vector<unsigned char> fixed = sig;\n> \n>     // Fixup length\n>     if (fixed.size() > 1)\n>         fixed[1] += fixed.size() - 3;\n>     return IsValidSignatureEncoding(fixed);\n> }\n> \n> #define good(arr) assert(check(std::vector<unsigned char>(arr, arr+sizeof(arr))))\n> #define bad(arr) assert(!check(std::vector<unsigned char>(arr, arr+sizeof(arr))))\n> \n> // The OK cases.\n> static unsigned char zerolen[] = { };\n> static unsigned char normal[] = { COMPOUND, LEN_OK,\n>                                   INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                   INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n>                                   SIGHASH };\n> static unsigned char min_r[] = { COMPOUND, LEN_OK,\n>                                  INT, MINIMAL_SIGLEN, MINIMAL_SIGVAL,\n>                                  INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n>                                  SIGHASH };\n> static unsigned char min_s[] = { COMPOUND, LEN_OK,\n>                                  INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                  INT, MINIMAL_SIGLEN, MINIMAL_SIGVAL,\n>                                  SIGHASH };\n> static unsigned char max_r[] = { COMPOUND, LEN_OK,\n>                                  INT, MAXIMAL_SIGLEN, MAXIMAL_SIGVAL(0x1),\n>                                  INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n>                                  SIGHASH };\n> static unsigned char max_s[] = { COMPOUND, LEN_OK,\n>                                  INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                  INT, MAXIMAL_SIGLEN, MAXIMAL_SIGVAL(0x2),\n>                                  SIGHASH };\n> // As long as total size doesn't go over, a single sig is allowed > 33 bytes\n> static unsigned char wierd_s_len[] = { COMPOUND, LEN_OK,\n>                                        INT, OVERSIZE_SIGLEN, OVERSIZE_SIGVAL(0x1),\n>                                        INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n>                                        SIGHASH };\n> static unsigned char wierd_r_len[] = { COMPOUND, LEN_OK,\n>                                        INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                        INT, OVERSIZE_SIGLEN, OVERSIZE_SIGVAL(0x2),\n>                                        SIGHASH };\n> static unsigned char zeropad_s[] = { COMPOUND, LEN_OK,\n>                                      INT, ZEROPAD_SIGLEN, ZEROPAD_SIGVAL(0x81),\n>                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n>                                      SIGHASH };\n> static unsigned char zeropad_r[] = { COMPOUND, LEN_OK,\n>                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                      INT, ZEROPAD_SIGLEN, ZEROPAD_SIGVAL(0x82),\n>                                      SIGHASH };\n> \n> \n> // The fail cases.\n> static unsigned char not_compound[] = { NOT_COMPOUND, LEN_OK,\n>                                         INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                         INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n>                                         SIGHASH };\n> static unsigned char short_len[] = { COMPOUND, LEN_TOO_SMALL,\n>                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n>                                      SIGHASH };\n> static unsigned char long_len[] = { COMPOUND, LEN_TOO_BIG,\n>                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n>                                     SIGHASH };\n> static unsigned char r_notint[] = { COMPOUND, LEN_OK,\n>                                     NOT_INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n>                                     SIGHASH };\n> static unsigned char s_notint[] = { COMPOUND, LEN_OK,\n>                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                     NOT_INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n>                                     SIGHASH };\n> static unsigned char s_oversig[] = { COMPOUND, LEN_OK,\n>                                      INT, OVERSIZE_SIGLEN, OVERSIZE_SIGVAL(0x1),\n>                                      INT, MAXIMAL_SIGLEN, MAXIMAL_SIGVAL(0x2),\n>                                      SIGHASH };\n> static unsigned char r_oversig[] = { COMPOUND, LEN_OK,\n>                                      INT, MAXIMAL_SIGLEN, MAXIMAL_SIGVAL(0x1),\n>                                      INT, OVERSIZE_SIGLEN, OVERSIZE_SIGVAL(0x2),\n>                                      SIGHASH };\n> static unsigned char s_negative[] = { COMPOUND, LEN_OK,\n>                                       INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x81),\n>                                       INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n>                                       SIGHASH };\n> static unsigned char r_negative[] = { COMPOUND, LEN_OK,\n>                                       INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                       INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x82),\n>                                       SIGHASH };\n> static unsigned char zeropad_bad_s[] = { COMPOUND, LEN_OK,\n>                                          INT, ZEROPAD_SIGLEN, ZEROPAD_SIGVAL(0x1),\n>                                          INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n>                                          SIGHASH };\n> static unsigned char zeropad_bad_r[] = { COMPOUND, LEN_OK,\n>                                          INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                          INT, ZEROPAD_SIGLEN, ZEROPAD_SIGVAL(0x2),\n>                                          SIGHASH };\n> static unsigned char missing_sighash[] = { COMPOUND, LEN_OK,\n>                                            INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                            INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2) };\n> static unsigned char extra_byte[] = { COMPOUND, LEN_OK,\n>                                       INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                       INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n>                                       SIGHASH, 0 };\n> \n> // Bad signature lengths\n> static unsigned char zerolen_r[] = { COMPOUND, LEN_OK,\n>                                      INT, 0,\n>                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n>                                      SIGHASH };\n> static unsigned char zerolen_s[] = { COMPOUND, LEN_OK,\n>                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                      INT, 0,\n>                                      SIGHASH };\n> static unsigned char overlen_r_by_1[] = { COMPOUND, LEN_OK,\n>                                           INT, NORMAL_SIGLEN + 1 + 1 + NORMAL_SIGLEN + 1 + 1, NORMAL_SIGVAL(0x1),\n>                                           INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n>                                           SIGHASH };\n> static unsigned char overlen_s_by_1[] = { COMPOUND, LEN_OK,\n>                                           INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                           INT, NORMAL_SIGLEN+1+1, NORMAL_SIGVAL(0x2),\n>                                           SIGHASH };\n> static unsigned char underlen_r_by_1[] = { COMPOUND, LEN_OK,\n>                                            INT, NORMAL_SIGLEN-1, NORMAL_SIGVAL(0x1),\n>                                            INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),\n>                                            SIGHASH };\n> static unsigned char underlen_s_by_1[] = { COMPOUND, LEN_OK,\n>                                            INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),\n>                                            INT, NORMAL_SIGLEN-1, NORMAL_SIGVAL(0x2),\n>                                            SIGHASH };\n> \n> int main()\n> {\n>     good(zerolen);\n>     good(normal);\n>     good(min_r);\n>     good(min_s);\n>     good(max_r);\n>     good(max_s);\n>     good(wierd_s_len);\n>     good(wierd_r_len);\n>     good(zeropad_s);\n>     good(zeropad_r);\n> \n>     // Try different amounts of truncation.\n>     for (size_t i = 1; i < sizeof(normal)-1; i++)\n>         assert(!check(std::vector<unsigned char>(normal, normal+i)));\n> \n>     bad(not_compound);\n>     bad(short_len);\n>     bad(long_len);\n>     bad(r_notint);\n>     bad(s_notint);\n>     bad(s_oversig);\n>     bad(r_oversig);\n>     bad(s_negative);\n>     bad(r_negative);\n>     bad(s_negative);\n>     bad(r_negative);\n>     bad(zeropad_bad_s);\n>     bad(zeropad_bad_r);\n>     bad(zerolen_r);\n>     bad(zerolen_s);\n>     bad(overlen_r_by_1);\n>     bad(overlen_s_by_1);\n>     bad(underlen_r_by_1);\n>     bad(underlen_s_by_1);\n>     bad(missing_sighash);\n>     bad(extra_byte);\n> \n>     return 0;\n> }\n> \n> \n> \n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Pieter Wuille",
                "date": "2015-01-22T04:20:25",
                "message_text_only": "On Wed, Jan 21, 2015 at 11:18 PM, Matt Whitlock <bip at mattwhitlock.name> wrote:\n> To be more in the C++ spirit, I would suggest changing the (const std::vector<unsigned char> &sig, size_t &off) parameters to (std::vector<unsigned char>::const_iterator &itr, std::vector<unsigned char>::const_iterator end).\n\nI agree that is more in the spirit of C++, but part of the motivation\nfor including C++ code that it mostly matches the exact code that has\nbeen used in the past two major Bitcoin Core releases (to interpret\nsignatures as standard).\n\n-- \nPieter"
            },
            {
                "author": "Pieter Wuille",
                "date": "2015-01-25T14:34:08",
                "message_text_only": "On Wed, Jan 21, 2015 at 8:32 PM, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> One weirdness is the restriction on maximum total length, rather than a\n> 32 byte (33 with 0-prepad) limit on signatures themselves.\n\nGlad that you point this out; I believe that's a weakness with more\nimpact now that this function is used for consensus. Let me clarify.\n\nThis function was originally written for Bitcoin Core v0.8.0, where it\nwas only used to enforce non-standardness, not consensus. In that\nsetting, there was no need to require a maximum length for the R and S\narguments, as overly-long R or S values (which, because of a further\nrule, do not have excessive padding) will always result in integers >=\n2^256, which means the encoded signature would never be valid\naccording to the ECDSA specification. A restriction on the total\nlength is required however, as BER allows multi-byte length\ndescriptors, which this function cannot (and shouldn't, as it's not\nDER) parse.\n\nHowever, in the currently proposed soft fork, non-DER results in\nimmediate script failure, which is distinguishable from invalid\nsignatures (by negating the result of a CHECKSIG, for example using a\nNOT after it). I must admit that having invalid signatures with\noverly-long R or S but acceptable R+S size be distinguishable from\ninvalid signatures where R+S is too large is ugly, and unnecessary.\n\nAdding individual R and S length restrictions (ideally: saying that no\nmore than 32 bytes, excluding the padding 0 byte in front, is invalid)\nwould be trivial, but it means deviating slightly from the\nstandardness rule implementation that has been deployed for a while.\nThere should not really be much risk in doing so, as there are still\nno node implementation releases (apart from the v0.10.0 rc's) that\nwould mine a CHECKSIG whose result is negated.\n\nSo, I think there are two options:\n* Just add this R/S length restriction rule as a standardness\nrequirement, but not make it part of the soft fork. A later softfork\ncan then add this easily. The same can be done for several other\nchanges if they are deemed useful, like only allowing 0 (the empty\narray) as invalid signature (any other causes failure script\nimmediately), requiring correct encoding even for non-evaluated\nsignatures, ...\n* Add it to the softfork now, and be done with it.\n\nOpinions?\n\n-- \nPieter"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2015-01-25T14:48:10",
                "message_text_only": "On Sun, Jan 25, 2015 at 2:34 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n> * Add it to the softfork now, and be done with it.\n\nInitially I was of the opinion that we couldn't do that, because\nsoft-forks which hit transactions many nodes would relay+mine creates\na forking risk... but with the realization that imbalanced R/S plus\nchecksig-not would only be work with 0.10rc/git changed my mind.\nUnlike two years ago miners no longer appear to be racing the bleeding\nedge, and it's never show up in a release. Obviously the next RC would\nalso make those non-standard. And then we'll have some non-trivial\namount of time before the soft-fork activates for whatever stragglers\nthere are on 0.10 prerelease code to update. The deployment of the\nsoft-fork rules themselves will already drive people to update.\n\nIn terms of being robust to implementation differences, not permitting\noverlarge R/S is obviously prudent.\n\nSo I think we should just go ahead with R/S length upper bounds as\nboth IsStandard and in STRICTDER."
            },
            {
                "author": "Zooko Wilcox-OHearn",
                "date": "2015-01-22T22:41:47",
                "message_text_only": ".Hi there. Thank you for your work on this.\n\nI've looked over https://gist.github.com/sipa/5d12c343746dad376c80 and\nhttps://github.com/sipa/bitcoin/commit/bipstrictder . I didn't\nactually audit the included reference implementation of\nIsValidSignatureEncoding(), and I didn't check whether the test\nvectors in https://github.com/sipa/bitcoin/commit/f94e806f8bfa007a3de4b45fa3c9860f2747e427\nexercise all of the branches that are changed by this patch.\n\nI have the following comments:\n\n* It seems like a good idea to do this.\n\n* I don't see any problem with using the upgrade mechanism from BIP 34\nfor this. It's cool! I'm happy that such a mechanism seems to work in\npractice.\n\n* Should the bipstrictder give a rationale or link to why accept the\n0-length sig as correctly-encoded-but-invalid? I guess the rationale\nis an efficiency issue as described in the log entry for\nhttps://github.com/sipa/bitcoin/commit/041f1e3597812c250ebedbd8f4ef1565591d2c34\n.\n\n* Does this mean there are still multiple ways to encode a correctly\nencoded but invalid signature, one of which is the 0-length string?\nWould it make sense for this change to also treat any *other*\ncorrectly-encoded-but-invalid sig (besides the 0-length string) as\nincorrectly-encoded? Did I just step in some BIP62?\n\n* It would be good to verify that all the branches of the new\nIsDERSignature() from\nhttps://github.com/sipa/bitcoin/commit/0c427135151a6bed657438ffb2e670be84eb3642\nare tested by the test vectors in\nhttps://github.com/sipa/bitcoin/commit/f94e806f8bfa007a3de4b45fa3c9860f2747e427\n. Eyeballing it, there are about 20 branches touched by the patch, and\nabout 24 new test vectors.\n\n* It would be good to finish the TODOs in\nhttps://github.com/sipa/bitcoin/commit/b7986119a5d41337fea1e83804ed6223438158ec\nso that it was actually testing the upgrade behavior.\n\n* missing comment:\nhttps://github.com/sipa/bitcoin/commit/e186f6a80161f9fa45fbced82ab1d22f081b942c#commitcomment-9406643\n\nOkay, that's all I've got. Hope it helps! Thanks again for your good work!\n\nRegards,\n\nZooko"
            },
            {
                "author": "Pieter Wuille",
                "date": "2015-01-25T16:57:23",
                "message_text_only": "On Thu, Jan 22, 2015 at 6:41 PM, Zooko Wilcox-OHearn\n<zooko at leastauthority.com> wrote:\n> * Should the bipstrictder give a rationale or link to why accept the\n> 0-length sig as correctly-encoded-but-invalid? I guess the rationale\n> is an efficiency issue as described in the log entry for\n> https://github.com/sipa/bitcoin/commit/041f1e3597812c250ebedbd8f4ef1565591d2c34\n\nI've lately been updating the BIP text without updating the code in\nthe repository; I've synced them now. The sigsize=0 case was actually\nalready handled elsewhere already, so I removed the code and added a\ncomment about it now in the BIP text.\n\n> * Does this mean there are still multiple ways to encode a correctly\n> encoded but invalid signature, one of which is the 0-length string?\n> Would it make sense for this change to also treat any *other*\n> correctly-encoded-but-invalid sig (besides the 0-length string) as\n> incorrectly-encoded? Did I just step in some BIP62?\n\nYou didn't miss anything; that's correct. In fact, Peter Todd already\npointed out the possibility of making non-empty invalid signatures\nillegal. The reason for not doing it yet is that I'd like this BIP to\nbe minimal and uncontroversial - it's a real problem we want to fix as\nfast as is reasonable. It wouldn't be hard to make this a standardness\nrule though, and perhaps later softfork it in as consensus rule if\nthere was sufficient agreement about it.\n\n> * It would be good to verify that all the branches of the new\n> IsDERSignature() from\n> https://github.com/sipa/bitcoin/commit/0c427135151a6bed657438ffb2e670be84eb3642\n> are tested by the test vectors in\n> https://github.com/sipa/bitcoin/commit/f94e806f8bfa007a3de4b45fa3c9860f2747e427\n> . Eyeballing it, there are about 20 branches touched by the patch, and\n> about 24 new test vectors.\n\nA significiant part of DERSIG behaviour (which didn't change, only the\ncases in which it is enforced) was already tested, in fact. Some\nbranches remained untested however; I've added extra test cases in the\nrepository. They give 100% coverage for IsValidSignatureEncoding (the\nnew name for IsDERSignature) now (tested with gcov).\n\n> * It would be good to finish the TODOs in\n> https://github.com/sipa/bitcoin/commit/b7986119a5d41337fea1e83804ed6223438158ec\n> so that it was actually testing the upgrade behavior.\n\nI agree, but that requires very significant changes to the codebase,\nas we currently have no way to mine blocks with non-acceptable\ntransactions. Ideally, the RPC tests gain some means of\nbuilding/mining blocks from without the Python test framework. Things\nlike that would make the code changes also hard to backport, which we\ndefinitely will need to do to roll this out quickly.\n\n> * missing comment:\n> https://github.com/sipa/bitcoin/commit/e186f6a80161f9fa45fbced82ab1d22f081b942c#commitcomment-9406643\n\nFixed.\n\n> Okay, that's all I've got. Hope it helps! Thanks again for your good work!\n\nThanks!\n\n-- \nPieter"
            },
            {
                "author": "Pieter Wuille",
                "date": "2015-01-26T05:14:39",
                "message_text_only": "On Tue, Jan 20, 2015 at 8:35 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n> I therefore propose a softfork to make non-DER signatures illegal\n> (they've been non-standard since v0.8.0). A draft BIP text can be\n> found on:\n>\n>     https://gist.github.com/sipa/5d12c343746dad376c80\n\nI'd like to request a BIP number for this.\n\n-- \nPieter"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2015-01-26T18:35:47",
                "message_text_only": "On Mon, Jan 26, 2015 at 5:14 AM, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n> On Tue, Jan 20, 2015 at 8:35 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n>> I therefore propose a softfork to make non-DER signatures illegal\n>> (they've been non-standard since v0.8.0). A draft BIP text can be\n>> found on:\n>>\n>>     https://gist.github.com/sipa/5d12c343746dad376c80\n>\n> I'd like to request a BIP number for this.\n\nSure. BIP0066. There was also some feedback on Bitcointalk, which I\nthink you've addressed:\nhttps://bitcointalk.org/index.php?topic=932054.0 I also had off-list\npositive feedback from Amir Taak, so we have positive feedback from\nseveral implementers.\n\nOne of the points that was raised which we'd discussed pre-proposal\nthat was brought up there that I thought I should summarize here was\nthe possibility that someone had previously authored an nlocked spend\nwith an invalidly encoded signature. In those cases the signature can\njust be mutated to get it mined, and would need to be already to pass\nIsStandard rules. A case that isn't covered if if they have a chain of\ntransactions after that nlocked transaction, but those cases would\nalready be at extreme risk of malleability (esp since their unchanged\nform is non-standard), and that coupled with the fact that avoiding\nthis would undermine the intent of the BIP (independence from  a\nspecific encoding scheme) seems to have been convincing as much."
            },
            {
                "author": "Wladimir",
                "date": "2015-01-28T06:24:06",
                "message_text_only": "On Mon, 26 Jan 2015, Gregory Maxwell wrote:\n\n> On Mon, Jan 26, 2015 at 5:14 AM, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n>> On Tue, Jan 20, 2015 at 8:35 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n>>> I therefore propose a softfork to make non-DER signatures illegal\n>>> (they've been non-standard since v0.8.0). A draft BIP text can be\n>>> found on:\n>>>\n>>>     https://gist.github.com/sipa/5d12c343746dad376c80\n>>\n>> I'd like to request a BIP number for this.\n>\n> Sure. BIP0066. There was also some feedback on Bitcointalk, which I\n> think you've addressed\n\nProgress information for the list: there is now a pull request\nimplementing the strict DER verification behavior, as well as the\ndeployment specified in BIP66 for Bitcoin Core. It needs\nyour review and testing:\n\nhttps://github.com/bitcoin/bitcoin/pull/5713\n\nWladimir"
            }
        ],
        "thread_summary": {
            "title": "Strict DER signatures",
            "categories": [
                "Bitcoin-development",
                "softfork proposal"
            ],
            "authors": [
                "Rusty Russell",
                "Dave Collins",
                "Douglas Roark",
                "David Vorick",
                "Zooko Wilcox-OHearn",
                "Wladimir",
                "Peter Todd",
                "Andrew Poelstra",
                "Matt Whitlock",
                "Gregory Maxwell",
                "Gavin Andresen",
                "Pieter Wuille"
            ],
            "messages_count": 23,
            "total_messages_chars_count": 83640
        }
    },
    {
        "title": "[Bitcoin-development] Why Bitcoin is and isn't like the Internet",
        "thread_messages": [
            {
                "author": "21E14",
                "date": "2015-01-21T06:07:13",
                "message_text_only": "This is a response to a wonderfully insightful recent post by Joichi Ito,\nthe Director of the MIT Media Lab. In it, Dr. Ito, notably a former Board\nMember of ICANN, offered his thoughts on \"Why Bitcoin is and isn't like the\nInternet\" and asked a most pertinent question: \"Whether there is an ICANN\nequivalent needed for Bitcoin.\" As suggested in recent posts to the mailing\nlist, I believe there might be, but for a reason that may not seem obvious\nat first.\n\nAlan Reiner expressed the need this way: \"I think one of the biggest issues\nfacing Bitcoin right now is not the lack of a 'killer app.' It is lack of\ninsurance options. Early adopters would like to believe that the majority\nof users will hold their own Bitcoin, but I believe that is not a realistic\noption when life-changing quantities of Bitcoin are involved. We should not\ntrust Grandma to secure her own retirement savings via complicated computer\nmaneuvers. More to the point, she should not trust herself or anyone else\n(sic!) to hold it unless there is a strong protection against loss events.\nRight now the solution is for Grandma to avoid keeping her money in\nBitcoin. Bitcoin needs a strong backbone of insured storage options so that\nGrandma can confidently participate in this new technology.\" This is\ncertainly an observation to take heed of coming from the founder of Armory\nTechnologies.\n\nThe protection against loss events ought to be understood in the broadest\nsense. What is needed is a disaster recovery mechanism. Andreas\nAntonopoulos remarks expressed this candidly last year: \"Bitcoin doesn't\nhave a middle of the road mediocre growth model. It basically either dies,\nbecause of a fundamental flaw in the Bitcoin system. Not an external\nfactor, an internal factor: We blow it up by accident. And that could\nhappen... Bitcoin will play out in the next three years. In the next three\nyears we're going to see Bitcoin arrive on the global stage and make a\nsubstantial impact, both in financial terms and in political terms. It will\nhappen. Or it will die. Either way. I'm not sure. In which case we'll\nreboot another currency.\"\n\nA body, not entirely unlike ICANN, can manage the nexus to the physical\nworld, and help address Bitcoin's catastrophic failure modes. Bitcoin's\ncoin ownership protocol would thus join the ranks of its payment protocol,\ncoin issuance protocol, consensus mechanism and inflation control that pose\nno lethal threat to the ecosystem. In addition to their coin-agnostic\nnature, I suspect the high valuation of large Bitcoin hubs relative to\nBitcoin's market cap at this stage in its lifecycle is partly reflective of\nthe sneaking suspicion that a custodial bitcoin (a bitcoin attached to an\nidentity) may be worth more than a non-custodial one. With this in mind,\nI'll pitch in for the ticket should Dr. Ito decide to join the next month's\nDevCore Boston conference aimed at supporting the future development of\nBitcoin. It's an hour's walk from MIT after all.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150121/45fa2d7d/attachment.html>"
            },
            {
                "author": "Aaron Voisine",
                "date": "2015-01-21T07:35:50",
                "message_text_only": "Ultimately the only way to insure bitcoin holdings is with an insurer\nwho themselves holds enough bitcoin to cover replacement of insured\nfunds. In the existing insurance industry, this is handled through a\nsystem of re-insurance, where smaller firms are themselves insured\nagainst catastrophic events that might cause a large number of\nsimultaneous claims. At the top of the chain sits super-cat insurance\nfirms like Berkshire Hathaway who do actually have the reserves to pay\nout in case of such a super catastrophy. This is one of the most\nlucrative businesses in the world, and one that today's very large\nbitcoin holders will find themselves uniquely positioned to engage in\nas bitcoin grows into a major global currency.\n\nAaron Voisine\nbreadwallet.com\n\n\nOn Tue, Jan 20, 2015 at 10:07 PM, 21E14 <21xe14 at gmail.com> wrote:\n> This is a response to a wonderfully insightful recent post by Joichi Ito,\n> the Director of the MIT Media Lab. In it, Dr. Ito, notably a former Board\n> Member of ICANN, offered his thoughts on \"Why Bitcoin is and isn't like the\n> Internet\" and asked a most pertinent question: \"Whether there is an ICANN\n> equivalent needed for Bitcoin.\" As suggested in recent posts to the mailing\n> list, I believe there might be, but for a reason that may not seem obvious\n> at first.\n>\n> Alan Reiner expressed the need this way: \"I think one of the biggest issues\n> facing Bitcoin right now is not the lack of a 'killer app.' It is lack of\n> insurance options. Early adopters would like to believe that the majority of\n> users will hold their own Bitcoin, but I believe that is not a realistic\n> option when life-changing quantities of Bitcoin are involved. We should not\n> trust Grandma to secure her own retirement savings via complicated computer\n> maneuvers. More to the point, she should not trust herself or anyone else\n> (sic!) to hold it unless there is a strong protection against loss events.\n> Right now the solution is for Grandma to avoid keeping her money in Bitcoin.\n> Bitcoin needs a strong backbone of insured storage options so that Grandma\n> can confidently participate in this new technology.\" This is certainly an\n> observation to take heed of coming from the founder of Armory Technologies.\n>\n> The protection against loss events ought to be understood in the broadest\n> sense. What is needed is a disaster recovery mechanism. Andreas Antonopoulos\n> remarks expressed this candidly last year: \"Bitcoin doesn't have a middle of\n> the road mediocre growth model. It basically either dies, because of a\n> fundamental flaw in the Bitcoin system. Not an external factor, an internal\n> factor: We blow it up by accident. And that could happen... Bitcoin will\n> play out in the next three years. In the next three years we're going to see\n> Bitcoin arrive on the global stage and make a substantial impact, both in\n> financial terms and in political terms. It will happen. Or it will die.\n> Either way. I'm not sure. In which case we'll reboot another currency.\"\n>\n> A body, not entirely unlike ICANN, can manage the nexus to the physical\n> world, and help address Bitcoin's catastrophic failure modes. Bitcoin's coin\n> ownership protocol would thus join the ranks of its payment protocol, coin\n> issuance protocol, consensus mechanism and inflation control that pose no\n> lethal threat to the ecosystem. In addition to their coin-agnostic nature, I\n> suspect the high valuation of large Bitcoin hubs relative to Bitcoin's\n> market cap at this stage in its lifecycle is partly reflective of the\n> sneaking suspicion that a custodial bitcoin (a bitcoin attached to an\n> identity) may be worth more than a non-custodial one. With this in mind,\n> I'll pitch in for the ticket should Dr. Ito decide to join the next month's\n> DevCore Boston conference aimed at supporting the future development of\n> Bitcoin. It's an hour's walk from MIT after all.\n>\n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Alon Muroch",
                "date": "2015-01-21T08:20:42",
                "message_text_only": "Bitcoin has a major crossroad ahead regarding a suitable platform for the\naverage non technical main stream user. Until now the majority of the\navailable solutions were at two extremes, or DIY your security and privacy\n*OR* let a 3rd party service do it for you. The DIY solution is obviously\nnot scalable, but it seems that 3rd party solutions are not scalable as\nwell. If we compare for a second a 3rd party services with traditional\nbanks, it seems banks have two major \"advantages\" over them. Entry costs\nfor creating a bank are HUGE so a priori very few people can actually\ncreate such a service, second, their physical and IT security\ninfrastructure are heavily regulated which insures a minimum of security\nlevel to the end user (and even so money is stolen frequently). Entry costs\nand regulation do not exist in the bitcoin space, meaning two programers in\ntheir spare time can create a wallet/ platform and the non technical end\nuser cannot know if his money is safe, did they hire the right security\nexpert, did they invest enough in protecting and backing up his keys, etc.\n\nMany services tried to tackle those problems with multisig (2 of 2 and 2 of\n3) to create a syntactical 2 factor authentication/ authorisation mechanism\nbut in reality those solutions didn't really increase security and their\nfailure point is always a single device. Coupling those said problems with\nthe fact that bitcoin transactions are irreversible and are a scarce\ncommodity, trying to insure them the way our money is insured by the\ngovernment when we deposit it in the bank becomes a huge problem. Premiums\nwill be very high and will only grow as the appetite of hackers to steal\ncoins increase.\n\nI personally believe we have the tools for creating a platform that is both\nsecure and private but most importantly it does it in a decentralised way.\nCreating true 2 (or more) factor authentication/ authorisation schemes can\nimprove dramatically personal security to a point where 3rd party wallet\nservices will become a thing of the past. Succeeding in that will mean the\nnext billion non technical bitcoin users will have a platform to use\nsecurely and a base line for building cool services on top.\n\nAlon Muroch\nbitcoinauthenticator.org\n\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150121/f6a0836a/attachment.html>"
            },
            {
                "author": "odinn",
                "date": "2015-01-21T19:44:35",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\n3rd party / web wallets are no longer viable except as means to burn\ncustomers and divulge (or be forced to divulge) their data to\ngovernments and corporations.\n\nRather than restate what I have already posted on this matter I'll\nleave it there. It's time also for those who are managing bitcoin.org\nto reconsider what's posted there (the criteria for what's posted there\n\n - at present the \"web wallet\" section should be excluded, that is to\nsay, Removed! from bitcoin.org\n\n with the possible exception of CoinKite to remain, which has a\nreasonable argument for having made such privacy advances as to merit\nusage by people (and to remain at bitcoin.org)\n\nAdditionally, I see no point in recommending any of the other wallets\nexcept Electrum, Mycelium, Core, and in the hardware side, the ones\nthat appear (Trezor and HW1).\n\nFurthermore, I believe those of you who are working for Coinbase\ncustomer operations or Bitpay (I will not name names, you know who you\nare) should resign from your employment.  I will bring this point up\nregularly.  You can easily find employment elsewhere, your skills are\nin high demand.\n\n- -O\n\nAlon Muroch:\n> Bitcoin has a major crossroad ahead regarding a suitable platform\n> for the average non technical main stream user. Until now the\n> majority of the available solutions were at two extremes, or DIY\n> your security and privacy *OR* let a 3rd party service do it for\n> you. The DIY solution is obviously not scalable, but it seems that\n> 3rd party solutions are not scalable as well. If we compare for a\n> second a 3rd party services with traditional banks, it seems banks\n> have two major \"advantages\" over them. Entry costs for creating a\n> bank are HUGE so a priori very few people can actually create such\n> a service, second, their physical and IT security infrastructure\n> are heavily regulated which insures a minimum of security level to\n> the end user (and even so money is stolen frequently). Entry costs \n> and regulation do not exist in the bitcoin space, meaning two\n> programers in their spare time can create a wallet/ platform and\n> the non technical end user cannot know if his money is safe, did\n> they hire the right security expert, did they invest enough in\n> protecting and backing up his keys, etc.\n> \n> Many services tried to tackle those problems with multisig (2 of 2\n> and 2 of 3) to create a syntactical 2 factor authentication/\n> authorisation mechanism but in reality those solutions didn't\n> really increase security and their failure point is always a single\n> device. Coupling those said problems with the fact that bitcoin\n> transactions are irreversible and are a scarce commodity, trying to\n> insure them the way our money is insured by the government when we\n> deposit it in the bank becomes a huge problem. Premiums will be\n> very high and will only grow as the appetite of hackers to steal \n> coins increase.\n> \n> I personally believe we have the tools for creating a platform that\n> is both secure and private but most importantly it does it in a\n> decentralised way. Creating true 2 (or more) factor authentication/\n> authorisation schemes can improve dramatically personal security to\n> a point where 3rd party wallet services will become a thing of the\n> past. Succeeding in that will mean the next billion non technical\n> bitcoin users will have a platform to use securely and a base line\n> for building cool services on top.\n> \n> Alon Muroch bitcoinauthenticator.org\n> \n>> \n>> \n> \n> \n> \n> ------------------------------------------------------------------------------\n>\n> \nNew Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in\n> Ashburn. Choose from 2 high performing configs, both with 100TB of\n> bandwidth. Higher redundancy.Lower latency.Increased\n> capacity.Completely compliant. http://p.sf.net/sfu/gigenet\n> \n> \n> \n> _______________________________________________ Bitcoin-development\n> mailing list Bitcoin-development at lists.sourceforge.net \n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> \n\n- -- \nhttp://abis.io ~\n\"a protocol concept to enable decentralization\nand expansion of a giving economy, and a new social good\"\nhttps://keybase.io/odinn\n-----BEGIN PGP SIGNATURE-----\n\niQEcBAEBCgAGBQJUwAGjAAoJEGxwq/inSG8CJoAIAMDR0h40IhFQNa8BW4AFeKUR\n7tg84e752c7wY153GY/P7MOFL6w3E9h4tXzxdohTMMfF5Q6Ip6HaaifYmMpegFSS\nWEHK0a3C2F+4sQMmMBtWbfyPsG5sJYtldY5hboSbh/6vXJJLXLSd+Sz3WHYx1Qjs\nqn6sw5CA2Q0fborTxcsNZixUXD/OF5tTjDozp+KfnZ0imvBoKfhfJFlaNUXNon7U\nzdPfahOrRIM5o70pjo6VwoutKRXr49JIoi47r9Uc3ujckUbLA5CVBApj4FApayb5\nsXk8Ks+p6IvBr6Q0ycxXOKmPwbSALC5pLa7Ncb1MFFBGzxKFsMjoRwOLTXHlLUE=\n=WgO4\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Why Bitcoin is and isn't like the Internet",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "odinn",
                "Alon Muroch",
                "21E14",
                "Aaron Voisine"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 14791
        }
    },
    {
        "title": "[Bitcoin-development] Deanonymisation of clients in Bitcoin P2P network paper",
        "thread_messages": [
            {
                "author": "Isidor Zeuner",
                "date": "2015-01-22T00:44:16",
                "message_text_only": "Hi there,\n\nsome thoughts in-line:\n> >\n> > Finally, distributors of consumer wallets can use this research in\n> > order to distribute their wallet with policies which may be less prone\n> > to Tor-specific attacks. Or leave this out altogether if their\n> > audience has different expectations for connecting to Bitcoin.\n> >\n>\n> Sure. I guess there will be wallets for all kinds of people in future,\n> sharing a common core that they can customise (this is certainly the vision\n> and general direction for bitcoinj, and it's working out OK).\n>\n> To clarify, my comments above were for mainstream granny-focused wallets.\n> Wallets designed for crypto geeks can and should expose all the knobs to\n> let people run wild.\n>\n\nI hear that. But I don't see why mainstream wallets and wallets\ndesigned for crypto research should not share a common core. Nor do I\nunderstand why having a common core for different types of wallets\nshould be reserved for BitcoinJ.\n\nWhen Bitcoin was pretty new, having a less customizable core did\nprobably have more of a merit in order to achieve network stability\nthrough monoculture. But as of today, Bitcoin has proven itself as\nbeing capable of allowing a variety of client application to run on\nthe network, so why should the reference implementation not reflect\nthis kind of diversity? The policy the mainstream distribution imposes\nupon the core can still be rather restrictive.\n\n> One possible direction to go is to use Tor for writing to the network and\n> use general link encryption and better Bloom filtering for reading it. Thus\n> new transactions would pop out of Tor exits, but there isn't much they can\n> do that's malicious there except mutate them or block them entirely. If you\n> insert the same transaction into the P2P network via say 10 randomly chosen\n> exits, the worst a malicious mutator can do is race the real transaction\n> and that's no different to a malicious P2P node. Even in a world where an\n> attacker has DoS-banned a lot of nodes and now controls your TX submission\n> path entirely, it's hard to see how it helps them.\n>\n\nIt might deserve some research in order to determine how Tor's\nprivacy guarantees might be impacted if we allow attackers to mess\naround with exit node choices in a rather predictable and low-cost\nmanner. Unfortunately, I can't think of another (non-Bitcoin)\napplication which puts Tor to a similar test.\n\n> The nice thing about the above approach is that it solves the latency\n> problems. Startup speed is really an issue for reading from the network:\n> just syncing the block chain is already enough of a speed hit without\n> adding consensus sync as well. But if you're syncing the block chain via\n> the clearnet you can connect to Tor in parallel so that by the time the\n> user has scanned a QR code, verified the details on the screen and then\n> pressed the Pay button, you have a warm connection and can upload the TX\n> through that. It reduces the level of startup time optimisation needed,\n> although Tor consensus download is still too slow even to race a QR code\n> scan at the moment. I think tuning the consensus caching process and\n> switching to a fresh one on the fly might be the way to go.\n>\n\nI do agree that hybrid clearnet/Tor approaches come with interesting\nperformance properties.\n\n> When BIP70 is in use, you wouldn't write the tx to the network yourself but\n> you could download the PaymentRequest and upload the Payment message via an\n> SSLd Tor connection to the merchant. Then malicious exits can only DoS you\n> but not do anything else so there's no need for multiple exit paths\n> simultaneously.\n>\n\nBIP70 is interesting, indeed, although I still fail to understand why\n(according to the specs I saw) the PaymentRequest message is signed,\nbut not the Payment message.\n\nBut in context of the discussed protocol issues, I think it just moves\nthe issue from the payer to the payee, so it may or may not partially\nrelieve network-related issues, depending on the usage scenario.\n\nBest regards,\n\nIsidor"
            },
            {
                "author": "Mike Hearn",
                "date": "2015-01-22T13:20:29",
                "message_text_only": ">\n> I hear that. But I don't see why mainstream wallets and wallets\n> designed for crypto research should not share a common core.\n>\n\nI think there was some misunderstanding. I was saying they *could and\nshould* share common cores, so we are in agreement without realising it :)\nI also didn't mean to imply there was anything special about bitcoinj, just\nthat it's an example of a wallet engine that's already in use.\n\n\n> BIP70 is interesting, indeed, although I still fail to understand why\n> (according to the specs I saw) the PaymentRequest message is signed,\n> but not the Payment message.\n>\n\nBecause it's intended to be submitted via HTTPS. But what would you sign\nthe message with? Some arbitrary key bound to the transaction?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150122/03b843c2/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Deanonymisation of clients in Bitcoin P2P network paper",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Mike Hearn",
                "Isidor Zeuner"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 4917
        }
    },
    {
        "title": "[Bitcoin-development] Securing wallet on paper",
        "thread_messages": [
            {
                "author": "U.Mutlu",
                "date": "2015-01-22T09:36:23",
                "message_text_only": "I don't know yet the details of how a wallet looks like internally,\nbut I think it should be possible to print the wallet incl. acct nbr\nout on classical paper (as base16 or base64 etc.) for filing it\nin a physical home or bank safe.\n\nLater, typing it from paper to a small converter program that recreates the \nwallet file.\n\nIMO this is a good security against possible computer hardware disasters.\n\nOf course one has to secure this further with encryption against bank \nfraud/theft etc.\nIe. the output on paper should be encrypted, and the owner\nshould place the key somewhere else.\n\nI would suggest the developers make such functionality available for the user.\n\ncu\nUenal"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2015-01-22T09:46:26",
                "message_text_only": "On 22/01/15 10:36, U.Mutlu wrote:\n> Later, typing it from paper to a small converter program that recreates the \n> wallet file.\n\nBitcoin Core still does not support Hierarchical Deterministic aka BIP32\nWallets. Without them it is possible to backup just one private key per\nbackup, which is rather useless and in fact dangerous.\n\n> I would suggest the developers make such functionality available for the user.\n\nI would suggest looking at different software wallets that do support\nsuch functionality such as Electrum or Multibit.\n\n-- \nBest Regards / S pozdravom,\n\nPavol Rusnak <stick at gk2.sk>"
            }
        ],
        "thread_summary": {
            "title": "Securing wallet on paper",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "U.Mutlu",
                "Pavol Rusnak"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1269
        }
    },
    {
        "title": "[Bitcoin-development] Ensuring security of funds and preserving anonymity when using Bitcoin for e-commerce",
        "thread_messages": [
            {
                "author": "Jonathan Brown",
                "date": "2015-01-22T10:20:51",
                "message_text_only": "I wrote a blog post entitled \"Ensuring security of funds and preserving\nanonymity when using Bitcoin for e-commerce\".\n\nI thought the readers of this list might be interested.\n\nhttp://jonathanpatrick.me/blog/bitcoin-ecommerce\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150122/587f8ea1/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Ensuring security of funds and preserving anonymity when using Bitcoin for e-commerce",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jonathan Brown"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 407
        }
    },
    {
        "title": "[Bitcoin-development] SIGHASH_WITHINPUTVALUE",
        "thread_messages": [
            {
                "author": "slush",
                "date": "2015-01-23T14:51:02",
                "message_text_only": "Hi,\n\nis any progress or even discussion in this area?\n\nhttps://bitcointalk.org/index.php?topic=181734.0\n\nI don't insist on any specific solution, but this is becoming a real issue\nas hardware wallets are more widespread. I'm sitting next to TREZOR for 40\nminutes already, because it streams and validate some complex transaction.\nBy using proposed solution, such signature would be a matter of few seconds.\n\nThat's also not just about time/resource/hw cost optimization. I'm talking\nabout possibility of huge simplification of the firmware (=security FTW),\nbecause 50% of actual codebase is solving this particular downside of\nBitcoin protocol.\n\nSo, there's real world problem. On which solution can we as a community\nfind a wide agreement?\n\nBest,\nMarek\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/30a6ffb5/attachment.html>"
            },
            {
                "author": "Alan Reiner",
                "date": "2015-01-23T15:24:17",
                "message_text_only": "The SIGHASH_WITHINPUTVALUE proposal is a hardfork, but otherwise\nnon-intrusive, doesn't change any TxOut scripts, doesn't change any\ntx/block parsing (besides verification), it works with all existing\ncoins in the network, and existing software doesn't have to use it if\nthey don't want to upgrade their signers.   The proposal simply provides\na way to optionally sign the input values with the TxOut scripts.  In\nother words a signature right now says \"I sign this transaction using\nthese inputs, whatever value they are.\"  With this SIGHASH type, the\nsignature says \"I sign this transaction assuming that input 0 is X BTC,\ninput 1 is Y BTC,....\".  If the online computer providing the data to be\nsigned lies about the value of any input, the resulting signature will\nbe invalid.\n\nUnfortunately, it seems that there was no soft-fork way to achieve this\nbenefit, at least not one that had favorable properties.  Most of the\nsoft-fork variations of it required the coins being spent to have been\noriginated in a special way.  In other words, it would only work if the\ncoins had entered the wallet with some special, modified TxOut script. \nSo it wouldn't work with existing coins, and would require senders to\nupdate their software to reshape the way they send transactions to be\ncompatible with our goals.\n\nI *strongly* encourage this to be considered for inclusion at some\npoint.  Not only does it simplify HW as Marek suggested, it increases\nthe options for online-offline communication channels, which is also a\nwin for security.  Right now, QR codes don't work because of the\npossibility of having to transfer megabytes over the channel, and no way\nto for the signer to control that size.  With this change, it's possible\nfor the signer to control the size of each chunk of data to guarantee it\nfits in, say, a QR code (even if it means breaking it up into a couple\nsmaller transactions).\n\n-Alan\n\n\n\nOn 01/23/2015 09:51 AM, slush wrote:\n> Hi,\n>\n> is any progress or even discussion in this area? \n>\n> https://bitcointalk.org/index.php?topic=181734.0\n>\n> I don't insist on any specific solution, but this is becoming a real\n> issue as hardware wallets are more widespread. I'm sitting next to\n> TREZOR for 40 minutes already, because it streams and validate some\n> complex transaction. By using proposed solution, such signature would\n> be a matter of few seconds.\n>\n> That's also not just about time/resource/hw cost optimization. I'm\n> talking about possibility of huge simplification of the firmware\n> (=security FTW), because 50% of actual codebase is solving this\n> particular downside of Bitcoin protocol.\n>\n> So, there's real world problem. On which solution can we as a\n> community find a wide agreement?\n>\n> Best,\n> Marek\n>\n>\n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/46e022bd/attachment.html>"
            },
            {
                "author": "slush",
                "date": "2015-01-23T15:40:39",
                "message_text_only": "> I *strongly* encourage this to be considered for inclusion at some point.\n\nThanks Alan for a nice summary. I also agree that such stuff should be\nimplemented at some point. Anyway, I would probably not vote for doing hard\nfork *just* for this change, but if I remember well, there're other ideas\nflying around in the air and waiting for hardfork...\n\nMarek\n\nOn Fri, Jan 23, 2015 at 4:24 PM, Alan Reiner <etotheipi at gmail.com> wrote:\n\n>  The SIGHASH_WITHINPUTVALUE proposal is a hardfork, but otherwise\n> non-intrusive, doesn't change any TxOut scripts, doesn't change any\n> tx/block parsing (besides verification), it works with all existing coins\n> in the network, and existing software doesn't have to use it if they don't\n> want to upgrade their signers.   The proposal simply provides a way to\n> optionally sign the input values with the TxOut scripts.  In other words a\n> signature right now says \"I sign this transaction using these inputs,\n> whatever value they are.\"  With this SIGHASH type, the signature says \"I\n> sign this transaction assuming that input 0 is X BTC, input 1 is Y\n> BTC,....\".  If the online computer providing the data to be signed lies\n> about the value of any input, the resulting signature will be invalid.\n>\n> Unfortunately, it seems that there was no soft-fork way to achieve this\n> benefit, at least not one that had favorable properties.  Most of the\n> soft-fork variations of it required the coins being spent to have been\n> originated in a special way.  In other words, it would only work if the\n> coins had entered the wallet with some special, modified TxOut script.  So\n> it wouldn't work with existing coins, and would require senders to update\n> their software to reshape the way they send transactions to be compatible\n> with our goals.\n>\n> I *strongly* encourage this to be considered for inclusion at some\n> point.  Not only does it simplify HW as Marek suggested, it increases the\n> options for online-offline communication channels, which is also a win for\n> security.  Right now, QR codes don't work because of the possibility of\n> having to transfer megabytes over the channel, and no way to for the signer\n> to control that size.  With this change, it's possible for the signer to\n> control the size of each chunk of data to guarantee it fits in, say, a QR\n> code (even if it means breaking it up into a couple smaller transactions).\n>\n> -Alan\n>\n>\n>\n>\n> On 01/23/2015 09:51 AM, slush wrote:\n>\n> Hi,\n>\n>  is any progress or even discussion in this area?\n>\n>  https://bitcointalk.org/index.php?topic=181734.0\n>\n>  I don't insist on any specific solution, but this is becoming a real\n> issue as hardware wallets are more widespread. I'm sitting next to TREZOR\n> for 40 minutes already, because it streams and validate some complex\n> transaction. By using proposed solution, such signature would be a matter\n> of few seconds.\n>\n>  That's also not just about time/resource/hw cost optimization. I'm\n> talking about possibility of huge simplification of the firmware (=security\n> FTW), because 50% of actual codebase is solving this particular downside of\n> Bitcoin protocol.\n>\n>  So, there's real world problem. On which solution can we as a community\n> find a wide agreement?\n>\n>  Best,\n> Marek\n>\n>\n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.http://p.sf.net/sfu/gigenet\n>\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing listBitcoin-development at lists.sourceforge.nethttps://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> T\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/0b4fa4b3/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2015-01-23T16:05:10",
                "message_text_only": "On Fri, Jan 23, 2015 at 3:24 PM, Alan Reiner <etotheipi at gmail.com> wrote:\n> Unfortunately, it seems that there was no soft-fork way to achieve this\n> benefit, at least not one that had favorable properties.  Most of the\n> soft-fork variations of it required the coins being spent to have been\n> originated in a special way.  In other words, it would only work if the\n> coins had entered the wallet with some special, modified TxOut script.  So\n> it wouldn't work with existing coins, and would require senders to update\n> their software to reshape the way they send transactions to be compatible\n> with our goals.\n\nI think this is unreasonable. There is a straight-forward soft-fork\napproach which is safe (e.g. no risk of invalidating existing\ntransactions). Yes, it means that you need to use newly created\naddresses to get coins that use the new signature type... but thats\nonly the case for people who want the new capability. This is\nmassively preferable to expecting _every_ _other_ user of the system\n(including miners, full nodes, etc.) to replace their software with an\nincompatible new version just to accommodate your transactions, for\nwhich they may care nothing about and which would otherwise not have\nany urgent need to change.\n\nI've expected this need to be addressed simply as a side effect of a\nnew, more efficient, checksig operator which some people have been\nworking on and off on but which has taken a backseat to other more\nurgent issues.\n\nOn Fri, Jan 23, 2015 at 2:51 PM, slush <slush at centrum.cz> wrote:\n> as hardware wallets are more widespread. I'm sitting next to TREZOR for 40\n> minutes already, because it streams and validate some complex transaction.\n\nCan you help me understand whats taking 40 minutes here? Thats a\nsurprisingly high number, and so I'm wondering if I'm not missing\nsomething there."
            },
            {
                "author": "slush",
                "date": "2015-01-23T16:18:34",
                "message_text_only": "On Fri, Jan 23, 2015 at 5:05 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n\n> I think this is unreasonable. There is a straight-forward soft-fork\n> approach which is safe (e.g. no risk of invalidating existing\n> transactions). Yes, it means that you need to use newly created\n> addresses to get coins that use the new signature type...\n\n\nCan you send me any reference about this? Of course if that solves the\nproblem, hard fork would not be necessary anymore. I'm just not aware of\nany.\n\nCan you help me understand whats taking 40 minutes here? Thats a\n> surprisingly high number, and so I'm wondering if I'm not missing\n> something there.\n>\n>\nTo sign transaction with hundreds of inputs on device with limited memory\ncapabilities, I need to stream all previous transactions into device, for\nevery signed input.\n\nThat means roughly 200^2 transaction verifications for 200 inputs to sign.\nVery slow, but does not limit the device for any particular size of signed\ntransaction.\n\nMarek\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/26b40164/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2015-01-23T16:52:28",
                "message_text_only": "On Fri, Jan 23, 2015 at 4:18 PM, slush <slush at centrum.cz> wrote:\n> Can you send me any reference about this? Of course if that solves the\n> problem, hard fork would not be necessary anymore. I'm just not aware of\n> any.\n\nSure; will aggregate up the citations when I'm not travling later today.\n\n> To sign transaction with hundreds of inputs on device with limited memory\n> capabilities, I need to stream all previous transactions into device, for\n> every signed input.\n>\n> That means roughly 200^2 transaction verifications for 200 inputs to sign.\n> Very slow, but does not limit the device for any particular size of signed\n> transaction.\n\nI'm not sure where the ^2 is coming from.  So what I'd understand that\nyou'd do is stream in the input txid:vouts which you spend, then you'd\nstream the actual inputs which would just be hashed and value\nextracted (but no other verification), and you'd build a table of\ntxid:vout->value, then the actual transaction to be signed.\n\nThis should have O(inputs) hashing and communications overhead. Is\nthere a step I'm missing?"
            },
            {
                "author": "slush",
                "date": "2015-01-23T17:40:54",
                "message_text_only": "Yes, the step you're missing is \"and build the table\". Dynamic memory\nallocation is something you want to avoid, as well as any artifical\nrestrictions to number of inputs or outputs. Current solution is slow, but\nthere's really no limitation on tx size.\n\nPlus there're significant restrictions to memory in embedded world.\nActually TREZOR uses pretty powerful (and expensive) MCU just because it\nneeds to do such validations and calculate such hashes. With\nSIGHASH_WITHINPUTVALUE or similar we may cut hardware cost significantly.\n\nMarek\n\nOn Fri, Jan 23, 2015 at 5:52 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n\n> I'm not sure where the ^2 is coming from.  So what I'd understand that\n> you'd do is stream in the input txid:vouts which you spend, then you'd\n> stream the actual inputs which would just be hashed and value\n> extracted (but no other verification), and you'd build a table of\n> txid:vout->value, then the actual transaction to be signed.\n>\n> This should have O(inputs) hashing and communications overhead. Is\n> there a step I'm missing?\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/20ba09ee/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2015-01-23T18:51:06",
                "message_text_only": "On Fri, Jan 23, 2015 at 5:40 PM, slush <slush at centrum.cz> wrote:\n> Yes, the step you're missing is \"and build the table\". Dynamic memory\n> allocation is something you want to avoid, as well as any artifical\n> restrictions to number of inputs or outputs. Current solution is slow, but\n> there's really no limitation on tx size.\n>\n> Plus there're significant restrictions to memory in embedded world. Actually\n> TREZOR uses pretty powerful (and expensive) MCU just because it needs to do\n> such validations and calculate such hashes. With SIGHASH_WITHINPUTVALUE or\n> similar we may cut hardware cost significantly.\n\nI'm quite familiar with embedded development :), and indeed trezor MCU\nis what I would generally consider (over-)powered which is why I was\nsomewhat surprised by the numbers; I'm certainly not expecting you to\nperform dynamic allocation... but wasn't clear on how 40 minutes and\nwas I just trying to understand. Using a table to avoid retransmitting\nreused transactions is just an optimization and can be done in\nconstant memory (e.g. falling back to retransmission if filled).\n\nSo what I'm understanding now is that you stream the transaction along\nwith its inputs interleaved in order to reduce the memory requirement\nto two midstates and a value accumulator; requiring resending the\ntransaction... so in the worst case transaction (since you can't get\nin more than about 800 inputs at the maximum transaction size) each\ninput spending from (one or more, since even one would be repeated)\n100kb input transactions you might send about 800MBytes of data, which\ncould take a half an hour if hashing runs at 45KB/s or slower?\n\n(If so, okay then there isn't another thing that I was missing)."
            },
            {
                "author": "slush",
                "date": "2015-01-23T19:19:40",
                "message_text_only": "You're right, there can be done some optimizations. Workarounds of\nworkaround. All this adds complexity, which reduces the security.\n\nMarek\n\nOn Fri, Jan 23, 2015 at 7:51 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n\n> On Fri, Jan 23, 2015 at 5:40 PM, slush <slush at centrum.cz> wrote:\n> > Yes, the step you're missing is \"and build the table\". Dynamic memory\n> > allocation is something you want to avoid, as well as any artifical\n> > restrictions to number of inputs or outputs. Current solution is slow,\n> but\n> > there's really no limitation on tx size.\n> >\n> > Plus there're significant restrictions to memory in embedded world.\n> Actually\n> > TREZOR uses pretty powerful (and expensive) MCU just because it needs to\n> do\n> > such validations and calculate such hashes. With SIGHASH_WITHINPUTVALUE\n> or\n> > similar we may cut hardware cost significantly.\n>\n> I'm quite familiar with embedded development :), and indeed trezor MCU\n> is what I would generally consider (over-)powered which is why I was\n> somewhat surprised by the numbers; I'm certainly not expecting you to\n> perform dynamic allocation... but wasn't clear on how 40 minutes and\n> was I just trying to understand. Using a table to avoid retransmitting\n> reused transactions is just an optimization and can be done in\n> constant memory (e.g. falling back to retransmission if filled).\n>\n> So what I'm understanding now is that you stream the transaction along\n> with its inputs interleaved in order to reduce the memory requirement\n> to two midstates and a value accumulator; requiring resending the\n> transaction... so in the worst case transaction (since you can't get\n> in more than about 800 inputs at the maximum transaction size) each\n> input spending from (one or more, since even one would be repeated)\n> 100kb input transactions you might send about 800MBytes of data, which\n> could take a half an hour if hashing runs at 45KB/s or slower?\n>\n> (If so, okay then there isn't another thing that I was missing).\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/c2669876/attachment.html>"
            },
            {
                "author": "Alan Reiner",
                "date": "2015-01-23T16:23:06",
                "message_text_only": "On 01/23/2015 11:05 AM, Gregory Maxwell wrote:\n> On Fri, Jan 23, 2015 at 3:24 PM, Alan Reiner <etotheipi at gmail.com> wrote:\n>> Unfortunately, it seems that there was no soft-fork way to achieve this\n>> benefit, at least not one that had favorable properties.  Most of the\n>> soft-fork variations of it required the coins being spent to have been\n>> originated in a special way.  In other words, it would only work if the\n>> coins had entered the wallet with some special, modified TxOut script.  So\n>> it wouldn't work with existing coins, and would require senders to update\n>> their software to reshape the way they send transactions to be compatible\n>> with our goals.\n> I think this is unreasonable. There is a straight-forward soft-fork\n> approach which is safe (e.g. no risk of invalidating existing\n> transactions). Yes, it means that you need to use newly created\n> addresses to get coins that use the new signature type... but thats\n> only the case for people who want the new capability. This is\n> massively preferable to expecting _every_ _other_ user of the system\n> (including miners, full nodes, etc.) to replace their software with an\n> incompatible new version just to accommodate your transactions, for\n> which they may care nothing about and which would otherwise not have\n> any urgent need to change.\n>\n>\n\n\nAs far as I'm concerned, anything that requires the coins to originate\nin the wallet with some special form is a non-starter.  The new SIGHASH\ntype allows you to sign transactions with any coins already in your\nwallet, and imposes no requirements on anyone paying your cold wallet. \nAny such proposals that require origination structure means that 100% of\npeople paying you need to \"be nice\" and use this new script type, or\nelse you *have* to"
            },
            {
                "author": "Alan Reiner",
                "date": "2015-01-23T16:27:27",
                "message_text_only": "On 01/23/2015 11:05 AM, Gregory Maxwell wrote:\n> On Fri, Jan 23, 2015 at 3:24 PM, Alan Reiner <etotheipi at gmail.com> wrote:\n>> Unfortunately, it seems that there was no soft-fork way to achieve this\n>> benefit, at least not one that had favorable properties.  Most of the\n>> soft-fork variations of it required the coins being spent to have been\n>> originated in a special way.  In other words, it would only work if the\n>> coins had entered the wallet with some special, modified TxOut script.  So\n>> it wouldn't work with existing coins, and would require senders to update\n>> their software to reshape the way they send transactions to be compatible\n>> with our goals.\n> I think this is unreasonable. There is a straight-forward soft-fork\n> approach which is safe (e.g. no risk of invalidating existing\n> transactions). Yes, it means that you need to use newly created\n> addresses to get coins that use the new signature type... but thats\n> only the case for people who want the new capability. This is\n> massively preferable to expecting _every_ _other_ user of the system\n> (including miners, full nodes, etc.) to replace their software with an\n> incompatible new version just to accommodate your transactions, for\n> which they may care nothing about and which would otherwise not have\n> any urgent need to change.\n>\n>\n\n\nAs far as I'm concerned, anything that requires the coins to originate\nin the wallet with some special form is a non-starter.  The new SIGHASH\ntype allows you to sign transactions with *any* coins already in your\nwallet, and imposes no requirements on anyone paying your cold wallet to\nbe compatible with your signer. \n\nAny proposals that require coin origination features means that 100% of\npeople paying you need to \"be nice\" and send you coins with this special\nstructure.  You can't spend old coins that were sent before this\nproposal was implemented, and if anyone sends you coins without\nrespecting the new structure, then your signing devices need the\nfull-complexity routines to accommodate, which defeats the entire purpose.\n\nI am happy to entertain other ideas that achieve our goals here, but I'm\nfairly confident that the new SIGHASH type is the only way that would\nallow devices like Trezor to truly simplify their design (and still work\nsecurely on 100% of funds contained by the wallet)."
            },
            {
                "author": "Alan Reiner",
                "date": "2015-01-23T16:33:54",
                "message_text_only": "On 01/23/2015 11:27 AM, Alan Reiner wrote:\n>\n> I am happy to entertain other ideas that achieve our goals here, but I'm\n> fairly confident that the new SIGHASH type is the only way that would\n> allow devices like Trezor to truly simplify their design (and still work\n> securely on 100% of funds contained by the wallet).\n>\n \nSelf-correction ... I didn't mean it's the \"only way\", I mean it's by\nfar the easiest, simplest, least-intrusive way that achieves the\nproperties we need for this to be useful."
            },
            {
                "author": "slush",
                "date": "2015-01-23T16:35:23",
                "message_text_only": "Oh, now I got the 'soft-fork' alternative. If that means that *senders* to\nTrezor need to be nice guys and use some special outputs, then it's,\nobviously, no-go solution.\n\nI understand political aspect around hard-fork. Anyway, are there any other\npending projects waiting for hard-fork? Maybe we should join our effort in\nsome way.\n\nM.\n\nOn Fri, Jan 23, 2015 at 5:27 PM, Alan Reiner <etotheipi at gmail.com> wrote:\n\n>\n> I am happy to entertain other ideas that achieve our goals here, but I'm\n> fairly confident that the new SIGHASH type is the only way that would\n> allow devices like Trezor to truly simplify their design (and still work\n> securely on 100% of funds contained by the wallet).\n>\n>\n>\n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/be814f81/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2015-01-23T17:49:59",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\n\n\nOn 23 January 2015 08:35:23 GMT-08:00, slush <slush at centrum.cz> wrote:\n>Oh, now I got the 'soft-fork' alternative. If that means that *senders*\n>to\n>Trezor need to be nice guys and use some special outputs, then it's,\n>obviously, no-go solution.\n\nThat's what P2SH is for; the senders will just be sending to a P2SH address.\n\n>I understand political aspect around hard-fork. Anyway, are there any\n>other\n>pending projects waiting for hard-fork?\n\nHard-forks aren't hard for directly political issues, they're politically hard because they're risky by requiring everyone yo upgrade at once. In the case of signature validation, that touches a *lot* of third party code that people rely on to avoid being defrauded.\n\nFWIW I've actually got a half-finished writeup for how to use OP_CODESEPARATOR and a CHECKSIG2 soft-fork to have signatures sign fees and so forth.\n-----BEGIN PGP SIGNATURE-----\nVersion: APG v1.1.1\n\niQFQBAEBCAA6BQJUwonGMxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8\ncGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhbwkCADP7AcJ6a6V/y7MHt2x\nZiCXYsfHq5j03kbSWXGi1Q/9RqWGVha1fhWPp62yhDxbWOfh5QKauCbrt2g1AqT3\nxbnh+2XE1rApBQIiJ6u0wZmpCi+4EhH2M9R8UYu9oIMzBe4K2jhzUbzcOR9Qplyq\n9j6yevNrvtNHZb2OTiaKelxnuZUEiAsONHPOvR8Fkflwbd/w279OeilRjHYt3A/J\nU22KOwjNrpa7/QE/HeC0QINqr3S132Yg4iYFwPviBwGq/WXQuLHIzGtgKOzrIC1T\nh6kpWO9CjSxVbjMrf68IrSHRv92K8y1LiHFRZvzp3ulzcGBo2btazmrp/fUDLCr0\n6uFg\n=uDeM\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Tamas Blummer",
                "date": "2015-01-23T15:31:46",
                "message_text_only": "Not a fix, but would reduce the financial risk, if nodes were not relaying excessive fee transactions.\n\nTamas Blummer\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/04250c18/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 496 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/04250c18/attachment.sig>"
            },
            {
                "author": "Alan Reiner",
                "date": "2015-01-23T15:42:54",
                "message_text_only": "Unfortunately, one major attack vector is someone isolating your node,\ngetting you to sign away your whole wallet to fee, and then selling it\nto a mining pool to mine it before you can figure why your transactions\naren't making it to the network.  In such an attack, the relay rules\naren't relevant, and if the attacker can DoS you for 24 hours, it\ndoesn't take a ton of mining power to make the attack extremely likely\nto succeed.\n\n\n\n\nOn 01/23/2015 10:31 AM, Tamas Blummer wrote:\n> Not a fix, but would reduce the financial risk, if nodes were not\n> relaying excessive fee transactions.\n>\n> Tamas Blummer\n>\n>\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/af0bb7ef/attachment.html>"
            },
            {
                "author": "slush",
                "date": "2015-01-23T15:47:41",
                "message_text_only": "Correct, plus the most likely scenario in such attack is that the malware\neven don't push such tx with excessive fees to the network, but send it\ndirectly to attacker's pool/miner.\n\nM.\n\nOn Fri, Jan 23, 2015 at 4:42 PM, Alan Reiner <etotheipi at gmail.com> wrote:\n\n>  Unfortunately, one major attack vector is someone isolating your node,\n> getting you to sign away your whole wallet to fee, and then selling it to a\n> mining pool to mine it before you can figure why your transactions aren't\n> making it to the network.  In such an attack, the relay rules aren't\n> relevant, and if the attacker can DoS you for 24 hours, it doesn't take a\n> ton of mining power to make the attack extremely likely to succeed.\n>\n>\n>\n>\n> On 01/23/2015 10:31 AM, Tamas Blummer wrote:\n>\n> Not a fix, but would reduce the financial risk, if nodes were not relaying\n> excessive fee transactions.\n>\n>  Tamas Blummer\n>\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/2562323d/attachment.html>"
            },
            {
                "author": "Tamas Blummer",
                "date": "2015-01-23T16:08:50",
                "message_text_only": "You mean an isolated signing device without memory right? \n\nAn isolated node would still know the transactions substantiating its coins, why would it sign them away to fees ?\n\nTamas Blummer\n\nOn Jan 23, 2015, at 4:47 PM, slush <slush at centrum.cz> wrote:\n\n> Correct, plus the most likely scenario in such attack is that the malware even don't push such tx with excessive fees to the network, but send it directly to attacker's pool/miner.\n> \n> M.\n> \n> On Fri, Jan 23, 2015 at 4:42 PM, Alan Reiner <etotheipi at gmail.com> wrote:\n> Unfortunately, one major attack vector is someone isolating your node, getting you to sign away your whole wallet to fee, and then selling it to a mining pool to mine it before you can figure why your transactions aren't making it to the network.  In such an attack, the relay rules aren't relevant, and if the attacker can DoS you for 24 hours, it doesn't take a ton of mining power to make the attack extremely likely to succeed.\n> \n> \n> \n> \n> On 01/23/2015 10:31 AM, Tamas Blummer wrote:\n>> Not a fix, but would reduce the financial risk, if nodes were not relaying excessive fee transactions.\n>> \n>> Tamas Blummer\n>> \n>> \n> \n> \n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/5dc6f4b7/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 496 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/5dc6f4b7/attachment.sig>"
            },
            {
                "author": "Adam Back",
                "date": "2015-01-23T16:12:28",
                "message_text_only": "its an always offline node, so it knows nothing really other than a\nBIP 32 hierarchy of keys & a signature request.\n\nSo the signature request has to drag with it information to validate\nwhat the value is, in order to be sure not to sign away 99% to fees.\nSigning the transaction value and having the network validate that the\nvalue in the sig matches full nodes view of the tx value avoids that\nissue.  Simple, elegant, but... we have no live beta mechanism, and\nhence risk & testing makes that tricky.  Plus the full network upgrade\nissue if its not backwards compatible.\n\nAdam\n\nOn 23 January 2015 at 16:08, Tamas Blummer <tamas at bitsofproof.com> wrote:\n> You mean an isolated signing device without memory right?\n>\n> An isolated node would still know the transactions substantiating its coins,\n> why would it sign them away to fees ?\n>\n> Tamas Blummer\n>\n> On Jan 23, 2015, at 4:47 PM, slush <slush at centrum.cz> wrote:\n>\n> Correct, plus the most likely scenario in such attack is that the malware\n> even don't push such tx with excessive fees to the network, but send it\n> directly to attacker's pool/miner.\n>\n> M.\n>\n> On Fri, Jan 23, 2015 at 4:42 PM, Alan Reiner <etotheipi at gmail.com> wrote:\n>>\n>> Unfortunately, one major attack vector is someone isolating your node,\n>> getting you to sign away your whole wallet to fee, and then selling it to a\n>> mining pool to mine it before you can figure why your transactions aren't\n>> making it to the network.  In such an attack, the relay rules aren't\n>> relevant, and if the attacker can DoS you for 24 hours, it doesn't take a\n>> ton of mining power to make the attack extremely likely to succeed.\n>>\n>>\n>>\n>>\n>> On 01/23/2015 10:31 AM, Tamas Blummer wrote:\n>>\n>> Not a fix, but would reduce the financial risk, if nodes were not relaying\n>> excessive fee transactions.\n>>\n>> Tamas Blummer\n>>\n>>\n>>\n>>\n>\n>\n> ------------------------------------------------------------------------------\n> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n> GigeNET is offering a free month of service with a new server in Ashburn.\n> Choose from 2 high performing configs, both with 100TB of bandwidth.\n> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n> http://p.sf.net/sfu/gigenet\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Adam Back",
                "date": "2015-01-23T16:17:25",
                "message_text_only": "Issues like that particular one (simple elegant fix, strong utility\njustification) plus previously more privacy stuff (like committed tx,\nhomomorphic encrypted values) was what got me wondering about a way to\ndo a live beta (one-way peg) and then to get excited about the 2wp &\nGreg's mechanism for that.\n\nI think it would be hypothetically possible to make a \"special\"\nsingleton sidechain which is merge mined, and has a consensus rule to\nrequire some proportion of reward be sent to it via coinbase tx (a\nmechanism to address incentive incompatibility) and a general timeline\neg 12mo to next version +/- etc. might be an interesting thing to\nexplore as a place to store live versions of \"hard fork wishlist\"\nitems where people who need them early can help validate them.\n\nI am not sure that helps the full network upgrade issue though.\n\nAdam\n\nOn 23 January 2015 at 16:12, Adam Back <adam at cypherspace.org> wrote:\n> its an always offline node, so it knows nothing really other than a\n> BIP 32 hierarchy of keys & a signature request.\n>\n> So the signature request has to drag with it information to validate\n> what the value is, in order to be sure not to sign away 99% to fees.\n> Signing the transaction value and having the network validate that the\n> value in the sig matches full nodes view of the tx value avoids that\n> issue.  Simple, elegant, but... we have no live beta mechanism, and\n> hence risk & testing makes that tricky.  Plus the full network upgrade\n> issue if its not backwards compatible.\n>\n> Adam\n>\n> On 23 January 2015 at 16:08, Tamas Blummer <tamas at bitsofproof.com> wrote:\n>> You mean an isolated signing device without memory right?\n>>\n>> An isolated node would still know the transactions substantiating its coins,\n>> why would it sign them away to fees ?\n>>\n>> Tamas Blummer\n>>\n>> On Jan 23, 2015, at 4:47 PM, slush <slush at centrum.cz> wrote:\n>>\n>> Correct, plus the most likely scenario in such attack is that the malware\n>> even don't push such tx with excessive fees to the network, but send it\n>> directly to attacker's pool/miner.\n>>\n>> M.\n>>\n>> On Fri, Jan 23, 2015 at 4:42 PM, Alan Reiner <etotheipi at gmail.com> wrote:\n>>>\n>>> Unfortunately, one major attack vector is someone isolating your node,\n>>> getting you to sign away your whole wallet to fee, and then selling it to a\n>>> mining pool to mine it before you can figure why your transactions aren't\n>>> making it to the network.  In such an attack, the relay rules aren't\n>>> relevant, and if the attacker can DoS you for 24 hours, it doesn't take a\n>>> ton of mining power to make the attack extremely likely to succeed.\n>>>\n>>>\n>>>\n>>>\n>>> On 01/23/2015 10:31 AM, Tamas Blummer wrote:\n>>>\n>>> Not a fix, but would reduce the financial risk, if nodes were not relaying\n>>> excessive fee transactions.\n>>>\n>>> Tamas Blummer\n>>>\n>>>\n>>>\n>>>\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.\n>> GigeNET is offering a free month of service with a new server in Ashburn.\n>> Choose from 2 high performing configs, both with 100TB of bandwidth.\n>> Higher redundancy.Lower latency.Increased capacity.Completely compliant.\n>> http://p.sf.net/sfu/gigenet\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>"
            }
        ],
        "thread_summary": {
            "title": "SIGHASH_WITHINPUTVALUE",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Tamas Blummer",
                "slush",
                "Adam Back",
                "Peter Todd",
                "Alan Reiner",
                "Gregory Maxwell"
            ],
            "messages_count": 20,
            "total_messages_chars_count": 36520
        }
    },
    {
        "title": "[Bitcoin-development] Is there a way to estimate the maximum number of transactions per minute Bitcoin can handle as it is today?",
        "thread_messages": [
            {
                "author": "Angel Leon",
                "date": "2015-01-31T00:48:40",
                "message_text_only": "On the Chinese \"Single's Day\" (sort of like the american Black Friday)\naccording to MIT's Tech Review\n<http://www.technologyreview.com/news/534001/alipay-leads-a-digital-finance-revolution-in-china/>\nmagazine\n\n\"Alipay handled up to 2.85 million transactions per minute, and 54 percent\nof its transactions are made via mobile device.\"\n\nFor a few weeks I've been reading the conversations about block sizes and\nthe experiments being done on the subject with larger blocks.\n\nOn the day with the most transactions, the Bitcoin block chain averages\nabout 73 transactions per minute. I kept wondering what blocksize we'd need\nfor handling 100,000 transactions per minute, and estimated that roughly\nwe'd need a blocksize of about 1300x times larger than what we have now, so\nbigger than 1Gb block... but seeing the numbers Alipay gets to handle just\nin China make me wonder how scalable is Bitcoin if it were to truly compete\nwith worldwide financial services.\n\nIf you were to include double the number Alipay can handle, you'd be\nshooting about 6 million transactions per minute, or roughly 60 million\ntransactions per block.\n\nIf you average every transaction around 250 bytes, then you'd need ~15\nGigabytes per block to be broadcast and hashed by all the full nodes every\n10 minutes, eating good 2Tb of storage daily... do miners have enough\nbandwidth and CPU power to handle this?\n\nare my scalability concerns absurd?\n\nhttp://twitter.com/gubatron\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/3b354179/attachment.html>"
            },
            {
                "author": "Nick Simpson",
                "date": "2015-01-31T02:58:29",
                "message_text_only": "This has been discussed before. I believe most people don't expect Bitcoin\nto replace all of the various methods of payment.  Scalability is always a\nconcern, just not to the level of  Alipay this year (or the next or the\nnext for that matter.)\n\nNick\nOn Jan 30, 2015 7:08 PM, \"Angel Leon\" <gubatron at gmail.com> wrote:\n\n> On the Chinese \"Single's Day\" (sort of like the american Black Friday)\n> according to MIT's Tech Review\n> <http://www.technologyreview.com/news/534001/alipay-leads-a-digital-finance-revolution-in-china/>\n> magazine\n>\n> \"Alipay handled up to 2.85 million transactions per minute, and 54 percent\n> of its transactions are made via mobile device.\"\n>\n> For a few weeks I've been reading the conversations about block sizes and\n> the experiments being done on the subject with larger blocks.\n>\n> On the day with the most transactions, the Bitcoin block chain averages\n> about 73 transactions per minute. I kept wondering what blocksize we'd need\n> for handling 100,000 transactions per minute, and estimated that roughly\n> we'd need a blocksize of about 1300x times larger than what we have now, so\n> bigger than 1Gb block... but seeing the numbers Alipay gets to handle just\n> in China make me wonder how scalable is Bitcoin if it were to truly compete\n> with worldwide financial services.\n>\n> If you were to include double the number Alipay can handle, you'd be\n> shooting about 6 million transactions per minute, or roughly 60 million\n> transactions per block.\n>\n> If you average every transaction around 250 bytes, then you'd need ~15\n> Gigabytes per block to be broadcast and hashed by all the full nodes every\n> 10 minutes, eating good 2Tb of storage daily... do miners have enough\n> bandwidth and CPU power to handle this?\n>\n> are my scalability concerns absurd?\n>\n> http://twitter.com/gubatron\n>\n>\n> ------------------------------------------------------------------------------\n> Dive into the World of Parallel Programming. The Go Parallel Website,\n> sponsored by Intel and developed in partnership with Slashdot Media, is\n> your\n> hub for all things parallel software development, from weekly thought\n> leadership blogs to news, videos, case studies, tutorials and more. Take a\n> look and join the conversation now. http://goparallel.sourceforge.net/\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150130/249fbe2e/attachment.html>"
            },
            {
                "author": "Wladimir",
                "date": "2015-01-31T13:11:42",
                "message_text_only": "On Fri, 30 Jan 2015, Nick Simpson wrote:\n\n> This has been discussed before. I believe most people don't expect Bitcoin to replace all of the various methods of payment.\u00a0 Scalability is\n> always a concern, just not to the level of\u00a0 Alipay this year (or the next or the next for that matter.)\n\nYes, that about summarizes it.\n\nThe block chain is a single channel broadcasted over the entire \nworld, and I don't believe it will ever be possible nor desirable to broadcast all the \nworld's transactions over one channel.\n\nThe everyone-validates-everything approach doesn't scale. It is however\nuseful to settle larger transactions in an irreversible, zero-trust way. \nThat's what makes the bitcoin system, as it is now, valuable.\n\nBut it is absurd for the whole world to have to validate every purchase of \na cup of coffee or a bus ticket by six billion others.\n\nNaively scaling up the block size will get some leeway in the short term, \nbut I believe a future scalable payment system based on bitcoin will be \nmostly based on off-blockchain transactions (in some form) or that there \nwill be a hierarchical or subdivided system (e.g. temporary or per-locale \nsidechains).\n\nWladimir"
            },
            {
                "author": "Allen Piscitello",
                "date": "2015-01-31T02:58:51",
                "message_text_only": "You are assuming that the only way to use Bitcoin is on-chain transactions\nand that is the only way for it to scale.  This is a mistake.\n\nOn Fri, Jan 30, 2015 at 6:48 PM, Angel Leon <gubatron at gmail.com> wrote:\n\n> On the Chinese \"Single's Day\" (sort of like the american Black Friday)\n> according to MIT's Tech Review\n> <http://www.technologyreview.com/news/534001/alipay-leads-a-digital-finance-revolution-in-china/>\n> magazine\n>\n> \"Alipay handled up to 2.85 million transactions per minute, and 54 percent\n> of its transactions are made via mobile device.\"\n>\n> For a few weeks I've been reading the conversations about block sizes and\n> the experiments being done on the subject with larger blocks.\n>\n> On the day with the most transactions, the Bitcoin block chain averages\n> about 73 transactions per minute. I kept wondering what blocksize we'd need\n> for handling 100,000 transactions per minute, and estimated that roughly\n> we'd need a blocksize of about 1300x times larger than what we have now, so\n> bigger than 1Gb block... but seeing the numbers Alipay gets to handle just\n> in China make me wonder how scalable is Bitcoin if it were to truly compete\n> with worldwide financial services.\n>\n> If you were to include double the number Alipay can handle, you'd be\n> shooting about 6 million transactions per minute, or roughly 60 million\n> transactions per block.\n>\n> If you average every transaction around 250 bytes, then you'd need ~15\n> Gigabytes per block to be broadcast and hashed by all the full nodes every\n> 10 minutes, eating good 2Tb of storage daily... do miners have enough\n> bandwidth and CPU power to handle this?\n>\n> are my scalability concerns absurd?\n>\n> http://twitter.com/gubatron\n>\n>\n> ------------------------------------------------------------------------------\n> Dive into the World of Parallel Programming. The Go Parallel Website,\n> sponsored by Intel and developed in partnership with Slashdot Media, is\n> your\n> hub for all things parallel software development, from weekly thought\n> leadership blogs to news, videos, case studies, tutorials and more. Take a\n> look and join the conversation now. http://goparallel.sourceforge.net/\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150130/f60165ac/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2015-01-31T17:04:52",
                "message_text_only": ">\n> \"Alipay handled up to 2.85 million transactions per minute, and 54 percent\n> of its transactions are made via mobile device.\"\n>\n\nI know China is a very big place but even so - 47,500 transactions per\nsecond would be almost quintiple what Visa handles across the entire world.\nWith only 300 million users and primarily online usage (?) this claim feels\na little suspect to me.\n\nGiven the wording \"up to 2.85 million\" I wonder if that is some freak spike\ncaused by people's behaviour being synchronised externally (e.g. a fixed\nstart time for the sale that people are waiting for). It's hard to imagine\nthat they sustained anything close to that for the entire day.\n\nSo this is really a discussion about peak performance.\n\nIf you average every transaction around 250 bytes, then you'd need ~15\n> Gigabytes per block to be broadcast and hashed by all the full nodes every\n> 10 minutes, eating good 2Tb of storage daily... do miners have enough\n> bandwidth and CPU power to handle this?\n>\n\nThere's a discussion of such things here that might be useful:\n\nhttps://en.bitcoin.it/wiki/Scalability\n\nIt discusses various optimisations, like not actually sending tx data twice.\n\nI wouldn't worry about it too much. It took decades for Visa to even\napproach 10,000 txns/sec. PayPal, I believe, still \"only\" handles a few\nhundred. And those services had the benefits of minimal competition,\nworking in people's local currencies, integrated dispute mediation and not\nrepresenting any real threat to the political status quo. Bitcoin isn't\ngoing to be needing to handle Alipay's level of traffic any time soon.\n\nFrankly, scaling is a nice problem to have, it means you're popular. It'd\nbe a mistake to just blindly assume Bitcoin will take over the world.\nGrowing market share is difficult. Worry more about how to get 300 million\ncrazy users than the precise broadcast protocol that'd be needed to handle\nthem ;)\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/a5d02aba/attachment.html>"
            },
            {
                "author": "Angel Leon",
                "date": "2015-01-31T20:08:57",
                "message_text_only": "My concerns come from 2 projects that could easily raise the current\ntransaction volume 10x daily in the short term,  perhaps even 100x a year\nfrom now after the media blows it out.\n\nThink legal bittorrent file sales: ebooks, indie music (albums and\nsingles), films, art, stock photography.\n\nThink p2p amazon (OpenBazaar) and how that could grow exponentially in\nterms of transactional volume when ecommerce penetrates geos currently\nunderserved.\n\nThanks for your explanations. it seems as of now we must rely on the likes\nof centralized solutions like Bitpay, Coinbase to manage the transactional\nvolume we expect, or just wait for the technology to be ready finally\nhandle it in a real p2p fashion, no intermediaries.\n\n\n\nOn Sat, Jan 31, 2015, 6:04 PM Mike Hearn <mike at plan99.net> wrote:\n\n> \"Alipay handled up to 2.85 million transactions per minute, and 54 percent\n>> of its transactions are made via mobile device.\"\n>>\n>\n> I know China is a very big place but even so - 47,500 transactions per\n> second would be almost quintiple what Visa handles across the entire world.\n> With only 300 million users and primarily online usage (?) this claim feels\n> a little suspect to me.\n>\n> Given the wording \"up to 2.85 million\" I wonder if that is some freak\n> spike caused by people's behaviour being synchronised externally (e.g. a\n> fixed start time for the sale that people are waiting for). It's hard to\n> imagine that they sustained anything close to that for the entire day.\n>\n> So this is really a discussion about peak performance.\n>\n> If you average every transaction around 250 bytes, then you'd need ~15\n>> Gigabytes per block to be broadcast and hashed by all the full nodes every\n>> 10 minutes, eating good 2Tb of storage daily... do miners have enough\n>> bandwidth and CPU power to handle this?\n>>\n>\n> There's a discussion of such things here that might be useful:\n>\n> https://en.bitcoin.it/wiki/Scalability\n>\n> It discusses various optimisations, like not actually sending tx data\n> twice.\n>\n> I wouldn't worry about it too much. It took decades for Visa to even\n> approach 10,000 txns/sec. PayPal, I believe, still \"only\" handles a few\n> hundred. And those services had the benefits of minimal competition,\n> working in people's local currencies, integrated dispute mediation and not\n> representing any real threat to the political status quo. Bitcoin isn't\n> going to be needing to handle Alipay's level of traffic any time soon.\n>\n> Frankly, scaling is a nice problem to have, it means you're popular. It'd\n> be a mistake to just blindly assume Bitcoin will take over the world.\n> Growing market share is difficult. Worry more about how to get 300 million\n> crazy users than the precise broadcast protocol that'd be needed to handle\n> them ;)\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/3d6e83e1/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Is there a way to estimate the maximum number of transactions per minute Bitcoin can handle as it is today?",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Wladimir",
                "Mike Hearn",
                "Angel Leon",
                "Nick Simpson",
                "Allen Piscitello"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 13054
        }
    },
    {
        "title": "[Bitcoin-development] New BIP: protocol for multisignature payments",
        "thread_messages": [
            {
                "author": "Martin Habov\u0161tiak",
                "date": "2015-01-31T01:30:49",
                "message_text_only": "Hello,\n\nI've been thinking about how to solve security problems of the servers\nholding huge amounts of bitcoins (exchanges, markets...) and came up\nwith this idea: https://gist.github.com/Kixunil/2ec79cf40a53fb899ac5\n\nTL;DR: it's extension of BIP70 (but not fully compatible due to security\nreasons) which supports making of multisig transactions dynamically.\n(The most important thing is that the user provides his address.)\n\nWhat do you think? Is it a good way to solve the problem or do you know\nabout something better? I would really like this or something similar\nimplemented by wallets.\n\nThank you for your feedback!\n\nMartin\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 836 bytes\nDesc: This is a digitally signed message part\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/de9440d7/attachment.sig>"
            },
            {
                "author": "Mike Hearn",
                "date": "2015-01-31T17:19:35",
                "message_text_only": "Hi Martin,\n\nYou're on the right lines. Your writeup is pretty similar to the high level\noverview given here though:\n\nhttps://en.bitcoin.it/wiki/Contracts#Example_2:_Escrow_and_dispute_mediation\n\nTo make 2-of-3 dispute mediation works requires implementing a wallet that\nsupports it, and the tools mediators need to manage incoming tickets, etc.\nThe BIP70 extension is probably the smallest part of the project.\n\n\nOn Sat, Jan 31, 2015 at 2:30 AM, Martin Habov\u0161tiak <\nmartin.habovstiak at gmail.com> wrote:\n\n> Hello,\n>\n> I've been thinking about how to solve security problems of the servers\n> holding huge amounts of bitcoins (exchanges, markets...) and came up\n> with this idea: https://gist.github.com/Kixunil/2ec79cf40a53fb899ac5\n>\n> TL;DR: it's extension of BIP70 (but not fully compatible due to security\n> reasons) which supports making of multisig transactions dynamically.\n> (The most important thing is that the user provides his address.)\n>\n> What do you think? Is it a good way to solve the problem or do you know\n> about something better? I would really like this or something similar\n> implemented by wallets.\n>\n> Thank you for your feedback!\n>\n> Martin\n>\n>\n> ------------------------------------------------------------------------------\n> Dive into the World of Parallel Programming. The Go Parallel Website,\n> sponsored by Intel and developed in partnership with Slashdot Media, is\n> your\n> hub for all things parallel software development, from weekly thought\n> leadership blogs to news, videos, case studies, tutorials and more. Take a\n> look and join the conversation now. http://goparallel.sourceforge.net/\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/0ef5a3d8/attachment.html>"
            },
            {
                "author": "Martin Habov\u0161tiak",
                "date": "2015-01-31T17:47:07",
                "message_text_only": "I know about that wiki page. I just wanted to design protocol which\nwould make it easier in practice. (now it would be done manually)\n\nI could look at implementing it someday, but now I'd like to receive\nfeedback from community.\n\n2015-01-31 19:19 GMT+02:00 Mike Hearn <mike at plan99.net>:\n> Hi Martin,\n>\n> You're on the right lines. Your writeup is pretty similar to the high level\n> overview given here though:\n>\n> https://en.bitcoin.it/wiki/Contracts#Example_2:_Escrow_and_dispute_mediation\n>\n> To make 2-of-3 dispute mediation works requires implementing a wallet that\n> supports it, and the tools mediators need to manage incoming tickets, etc.\n> The BIP70 extension is probably the smallest part of the project.\n>\n>\n> On Sat, Jan 31, 2015 at 2:30 AM, Martin Habov\u0161tiak\n> <martin.habovstiak at gmail.com> wrote:\n>>\n>> Hello,\n>>\n>> I've been thinking about how to solve security problems of the servers\n>> holding huge amounts of bitcoins (exchanges, markets...) and came up\n>> with this idea: https://gist.github.com/Kixunil/2ec79cf40a53fb899ac5\n>>\n>> TL;DR: it's extension of BIP70 (but not fully compatible due to security\n>> reasons) which supports making of multisig transactions dynamically.\n>> (The most important thing is that the user provides his address.)\n>>\n>> What do you think? Is it a good way to solve the problem or do you know\n>> about something better? I would really like this or something similar\n>> implemented by wallets.\n>>\n>> Thank you for your feedback!\n>>\n>> Martin\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> Dive into the World of Parallel Programming. The Go Parallel Website,\n>> sponsored by Intel and developed in partnership with Slashdot Media, is\n>> your\n>> hub for all things parallel software development, from weekly thought\n>> leadership blogs to news, videos, case studies, tutorials and more. Take a\n>> look and join the conversation now. http://goparallel.sourceforge.net/\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>"
            },
            {
                "author": "Mike Hearn",
                "date": "2015-01-31T18:07:40",
                "message_text_only": ">\n> I could look at implementing it someday, but now I'd like to receive\n> feedback from community.\n>\n\nIMO it's better to pair a protocol spec with an implementation. For one, it\ncan show up issues in the design you didn't think of. For another,\nimplementation is a lot more work than speccing out a few protocol buffers\nand high level procedures, so people who are going to write an\nimplementation probably won't follow your design unless they have a great\ndegree of confidence in it and some compelling reason to use it (e.g.\ninterop with other users).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/79e7919b/attachment.html>"
            },
            {
                "author": "Gavin Andresen",
                "date": "2015-01-31T21:50:15",
                "message_text_only": "I agree- standards should be descriptive (\"here is how this thing I did\nworks\") and NOT proscriptive (\"here's what I think will work, lets all try\nto do it this way.\").\n\n\nOn Sat, Jan 31, 2015 at 2:07 PM, Mike Hearn <mike at plan99.net> wrote:\n\n> I could look at implementing it someday, but now I'd like to receive\n>> feedback from community.\n>>\n>\n> IMO it's better to pair a protocol spec with an implementation.\n>\n\n-- \n--\nGavin Andresen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/dbd2ac48/attachment.html>"
            },
            {
                "author": "Martin Habov\u0161tiak",
                "date": "2015-01-31T23:02:45",
                "message_text_only": "I didn't consider that, thank you for feedback! I will try to find\nsome time for implementing it. I'll write again then.\n\n2015-01-31 23:50 GMT+02:00 Gavin Andresen <gavinandresen at gmail.com>:\n> I agree- standards should be descriptive (\"here is how this thing I did\n> works\") and NOT proscriptive (\"here's what I think will work, lets all try\n> to do it this way.\").\n>\n>\n> On Sat, Jan 31, 2015 at 2:07 PM, Mike Hearn <mike at plan99.net> wrote:\n>>>\n>>> I could look at implementing it someday, but now I'd like to receive\n>>> feedback from community.\n>>\n>>\n>> IMO it's better to pair a protocol spec with an implementation.\n>\n>\n> --\n> --\n> Gavin Andresen"
            },
            {
                "author": "Thomas Kerin",
                "date": "2015-01-31T02:10:45",
                "message_text_only": "Ooh, I had a very similar proposal, except it involved sharing generic P2SH scripts. It also involved facilitating requesting of signatures.. We should talk.On 31 Jan 2015 01:30, Martin Habov\u0161tiak <martin.habovstiak at gmail.com> wrote:\n>\n> Hello, \n>\n> I've been thinking about how to solve security problems of the servers \n> holding huge amounts of bitcoins (exchanges, markets...) and came up \n> with this idea: https://gist.github.com/Kixunil/2ec79cf40a53fb899ac5 \n>\n> TL;DR: it's extension of BIP70 (but not fully compatible due to security \n> reasons) which supports making of multisig transactions dynamically. \n> (The most important thing is that the user provides his address.) \n>\n> What do you think? Is it a good way to solve the problem or do you know \n> about something better? I would really like this or something similar \n> implemented by wallets. \n>\n> Thank you for your feedback! \n>\n> Martin\n>\n> ------------------------------------------------------------------------------ \n> Dive into the World of Parallel Programming. The Go Parallel Website, \n> sponsored by Intel and developed in partnership with Slashdot Media, is your \n> hub for all things parallel software development, from weekly thought \n> leadership blogs to news, videos, case studies, tutorials and more. Take a \n> look and join the conversation now. http://goparallel.sourceforge.net/\n> _______________________________________________ \n> Bitcoin-development mailing list \n> Bitcoin-development at lists.sourceforge.net \n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            }
        ],
        "thread_summary": {
            "title": "New BIP: protocol for multisignature payments",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Thomas Kerin",
                "Mike Hearn",
                "Martin Habov\u0161tiak",
                "Gavin Andresen"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 8699
        }
    },
    {
        "title": "[Bitcoin-development] Proposal to address Bitcoin malware",
        "thread_messages": [
            {
                "author": "Brian Erdelyi",
                "date": "2015-01-31T22:15:53",
                "message_text_only": "Hello all,\n\nThe number of incidents involving malware targeting bitcoin users continues to rise.  One category of virus I find particularly nasty is when the bitcoin address you are trying to send money to is modified before the transaction is signed and recorded in the block chain.  This behaviour allows the malware to evade two-factor authentication by becoming active only when the bitcoin address is entered.  This is very similar to how man-in-the-browser malware attack online banking websites.\n\nOut of band transaction verification/signing is one method used with online banking to help protect against this.  This can be done in a variety of ways with SMS, voice, mobile app or even security tokens.  This video demonstrates how HSBC uses a security token to verify transactions online.  https://www.youtube.com/watch?v=Sh2Iha88agE <https://www.youtube.com/watch?v=Sh2Iha88agE>.\n\nMany Bitcoin wallets and services already use Open Authentication (OATH) based one-time passwords (OTP).  Is there any interest (or existing work) in in the Bitcoin community adopting the OATH Challenge-Response Algorithm (OCRA) for verifying transactions?\n\nI know there are other forms of malware, however, I want to get thoughts on this approach as it would involve the use of a decimal representation of the bitcoin address (depending on particular application).  In the HSBC example (see YouTube video above), this was the last 8 digits of the recipient\u2019s account number.  Would it make sense to convert a bitcoin address to decimal and then truncate to 8 digits for this purpose?  I understand that truncating the number in some way only increases the likelihood for collisions\u2026 however, would this still be practical or could the malware generate a rogue bitcoin address that would produce the same 8 digits of the legitimate bitcoin address?\n\nBrian Erdelyi\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/d4aee3b9/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 842 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/d4aee3b9/attachment.sig>"
            },
            {
                "author": "Natanael",
                "date": "2015-01-31T22:38:55",
                "message_text_only": "Den 31 jan 2015 23:17 skrev \"Brian Erdelyi\" <brian.erdelyi at gmail.com>:\n>\n> Hello all,\n>\n> The number of incidents involving malware targeting bitcoin users\ncontinues to rise.  One category of virus I find particularly nasty is when\nthe bitcoin address you are trying to send money to is modified before the\ntransaction is signed and recorded in the block chain.  This behaviour\nallows the malware to evade two-factor authentication by becoming active\nonly when the bitcoin address is entered.  This is very similar to how\nman-in-the-browser malware attack online banking websites.\n>\n> Out of band transaction verification/signing is one method used with\nonline banking to help protect against this.  This can be done in a variety\nof ways with SMS, voice, mobile app or even security tokens.  This video\ndemonstrates how HSBC uses a security token to verify transactions online.\nhttps://www.youtube.com/watch?v=Sh2Iha88agE.\n>\n> Many Bitcoin wallets and services already use Open Authentication (OATH)\nbased one-time passwords (OTP).  Is there any interest (or existing work)\nin in the Bitcoin community adopting the OATH Challenge-Response Algorithm\n(OCRA) for verifying transactions?\n>\n> I know there are other forms of malware, however, I want to get thoughts\non this approach as it would involve the use of a decimal representation of\nthe bitcoin address (depending on particular application).  In the HSBC\nexample (see YouTube video above), this was the last 8 digits of the\nrecipient\u2019s account number.  Would it make sense to convert a bitcoin\naddress to decimal and then truncate to 8 digits for this purpose?  I\nunderstand that truncating the number in some way only increases the\nlikelihood for collisions\u2026 however, would this still be practical or could\nthe malware generate a rogue bitcoin address that would produce the same 8\ndigits of the legitimate bitcoin address?\n\nSee vanitygen. Yes, 8 characters can be bruteforced.\n\nYou need about 100 bits of security for strong security, and at the very\nleast NOT less than ~64 (see distributed bruteforce projects attacking 64\nbit keys for reference, you can find plenty via Google).\n\nYou shouldn't rely on mechanisms intended to be used for one-shot auth\nwhere the secret is supposed to be unguessable for another system where the\nattacker knows what the target string is and have a fair amount of time to\nattempt bruteforce.\n\nUse something more like HMAC instead.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/9343c650/attachment.html>"
            },
            {
                "author": "Brian Erdelyi",
                "date": "2015-01-31T23:04:57",
                "message_text_only": "> See vanitygen. Yes, 8 characters can be brute forced.\n> \n\nThank you for this reference.  Interesting to see that there is a tool to generate a vanity bitcoin address.\n\nI am still researching viruses that are designed to manipulate a bitcoin address.  I suspect they are primitive in that they use a hardcoded rogue bitcoin address as opposed to dynamically generating one.\n\nAs a start, this would help protect against malware that uses a static rogue bitcoin address.  The next thing would be for the malware to brute-force the legitimate bitcoin address and generate a rogue bitcoin address that would produce the same 8 digit code.  Curious to know how long this brute force would take?  Or perhaps, before converting to 8 digits there is some other hashing function that is performed.\n\nBrian Erdelyi\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/88a7c6ef/attachment.html>"
            },
            {
                "author": "Natanael",
                "date": "2015-01-31T23:37:51",
                "message_text_only": "Den 1 feb 2015 00:05 skrev \"Brian Erdelyi\" <brian.erdelyi at gmail.com>:\n>>\n>> See vanitygen. Yes, 8 characters can be brute forced.\n>\n> Thank you for this reference.  Interesting to see that there is a tool to\ngenerate a vanity bitcoin address.\n>\n> I am still researching viruses that are designed to manipulate a bitcoin\naddress.  I suspect they are primitive in that they use a hardcoded rogue\nbitcoin address as opposed to dynamically generating one.\n>\n> As a start, this would help protect against malware that uses a static\nrogue bitcoin address.  The next thing would be for the malware to\nbrute-force the legitimate bitcoin address and generate a rogue bitcoin\naddress that would produce the same 8 digit code.  Curious to know how long\nthis brute force would take?  Or perhaps, before converting to 8 digits\nthere is some other hashing function that is performed.\n>\n> Brian Erdelyi\n\nTo bruteforce 8 decimals, on average you need (10^8)/2 = 50 000 000 tries.\nlog(50M)/log(2) = 25.6 bits of entropy.\n\nOne try = generate a random number, use it to generate an ECDSA keypair,\nSHA256 and RIPEMD160 hash the public key per Bitcoin specs, then run that\nOCRA hashing code, then compare strings. Considering the ECDSA operations\nis by a large margin slower than all the hash functions, consider them to\njust add a small percentage in performance drop vs regular vanitygen usage.\n\nMy non-gaming laptop performed IIRC at *a few million keys per second* with\nOpenCL. I've used it to search for 6 character strings in the base58\nBitcoin addresses with it in 15 minutes to half an hour or so. That's about\n35 bits of entropy (rough estimate, there's some details with padding in\nthe base58 representation that alters it).\n\nSo 2^(35-26) ~= 1 in 500 of that time, and that's if you use a laptop\ninstead of a GPU rig. Seconds at worst. Milliseconds if done on a rig.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150201/aaf8f5e0/attachment.html>"
            },
            {
                "author": "Natanael",
                "date": "2015-01-31T23:41:54",
                "message_text_only": "Den 1 feb 2015 00:37 skrev \"Natanael\" <natanael.l at gmail.com>:\n\n>\n> To bruteforce 8 decimals, on average you need (10^8)/2 = 50 000 000\ntries. log(50M)/log(2) = 25.6 bits of entropy.\n\nOops. Used the wrong number in the entropy calculation. Add one bit, the\ndivision by 2 wasn't supposed to be used in the entropy calculation.\nDoesn't change the equation much, though.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150201/3fc6dca4/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Proposal to address Bitcoin malware",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Natanael",
                "Brian Erdelyi"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 8522
        }
    }
]