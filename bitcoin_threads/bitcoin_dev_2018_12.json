[
    {
        "title": "[bitcoin-dev] BIP Proposal - Address Paste Improvement",
        "thread_messages": [
            {
                "author": "James MacWhyte",
                "date": "2018-12-01T04:57:20",
                "message_text_only": "I liked the cheekiness of your summary, Adam ;)\n\nI'm not sure why this needs to be a BIP. It is a UX detail--not really\nrelated to bitcoin protocol or procedures. I wouldn't even call it a\ndescription of best practices, since every product's use case is going to\nbe different.\n\nIf you think there is a compelling reason for why this needs to be a\ndocumented standard, please elaborate!\n\nThanks,\nJames\n\n\nOn Sun, Nov 11, 2018 at 7:41 PM Adam Ficsor via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Thank you for all your comments. To sum up:\n>\n> - There were no comments related to the implementation details.\n> - There are concerns about this may incentivize users to use copypaste\n> functionality extensively.\n> - A counter argument was made that crypto hijackers use the clipboard,\n> because that is the most convenient thing to hijack, not because they can\n> only hijack that and, if Bitcoin users would move to other ways of\n> specifying destinations, that may end up being just as an issue, too.\n> - The rest of the conversation was about crypto hijackers, which I think\n> is off topic in this thread.\n>\n> Finally I'd like to note, there's already a work in progress\n> implementation in Wasabi:\n> https://github.com/zkSNACKs/WalletWasabi/pull/825\n>\n> On Fri, Nov 9, 2018 at 1:14 AM Dmitry Petukhov via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>>\n>> > > Do you know any reasonably convenient mechanism for end user to\n>> > > transfer an address from, say, a web page to the wallet address\n>> > > input field ?\n>> >\n>> > - QR code scanning of a Bitcoin URI\n>> > - On Android: A \"bitcoin:\" URI intent or a BIP70 payment message\n>> > intent\n>> > - On desktop OSes there are similar mechanisms to launch Apps from the\n>> > browser (e.g. for mailto: links)\n>>\n>> This works if the author of the web page thought about this, and\n>> created appropriate liks/qr codes. In many cases, addresses are\n>> just presented for users as text, to copy.\n>>\n>> People also send addresses in message apps and emails. Maybe if\n>> applications start to autodetect bitcoin addresses and convert them to\n>> bitcoin: links, there will be less need to copy-paste. But I suspect\n>> that this feature will not be quickly adopted by applications.\n>>\n>> > For cases where the payee is a well-known entity the BIP70 payment\n>> > protocol has authentication via certificates. That doesn't work for\n>> > the \"the person in front of you is the only trust anchor you have\"\n>> > usecase though.\n>>\n>> There are also BIP75 and BIP47 that may help, but the number of wallets\n>> that support these protocols is small (I think in part because of\n>> relative complexity of these protocols).\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n>\n> --\n> Best,\n> \u00c1d\u00e1m\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181130/37af33c4/attachment.html>"
            },
            {
                "author": "Adam Ficsor",
                "date": "2018-12-01T12:07:40",
                "message_text_only": "If this needs to be a BIP or not, that is up to this list to decide, I will\nnot be pushy abut it. We simply encountered a well defined and common issue\nand we took the time to work out and specify our solution, so it may come\nin handy for other developers encountering this same issue. We can argue\nabout the significance of it, but I suspect all arguments will come down to\nhow much an individual developer values UX or how much he does not.\n\nOn Sat, Dec 1, 2018 at 11:57 AM James MacWhyte <macwhyte at gmail.com> wrote:\n\n> I liked the cheekiness of your summary, Adam ;)\n>\n> I'm not sure why this needs to be a BIP. It is a UX detail--not really\n> related to bitcoin protocol or procedures. I wouldn't even call it a\n> description of best practices, since every product's use case is going to\n> be different.\n>\n> If you think there is a compelling reason for why this needs to be a\n> documented standard, please elaborate!\n>\n> Thanks,\n> James\n>\n>\n> On Sun, Nov 11, 2018 at 7:41 PM Adam Ficsor via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Thank you for all your comments. To sum up:\n>>\n>> - There were no comments related to the implementation details.\n>> - There are concerns about this may incentivize users to use copypaste\n>> functionality extensively.\n>> - A counter argument was made that crypto hijackers use the clipboard,\n>> because that is the most convenient thing to hijack, not because they can\n>> only hijack that and, if Bitcoin users would move to other ways of\n>> specifying destinations, that may end up being just as an issue, too.\n>> - The rest of the conversation was about crypto hijackers, which I think\n>> is off topic in this thread.\n>>\n>> Finally I'd like to note, there's already a work in progress\n>> implementation in Wasabi:\n>> https://github.com/zkSNACKs/WalletWasabi/pull/825\n>>\n>> On Fri, Nov 9, 2018 at 1:14 AM Dmitry Petukhov via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>>\n>>> > > Do you know any reasonably convenient mechanism for end user to\n>>> > > transfer an address from, say, a web page to the wallet address\n>>> > > input field ?\n>>> >\n>>> > - QR code scanning of a Bitcoin URI\n>>> > - On Android: A \"bitcoin:\" URI intent or a BIP70 payment message\n>>> > intent\n>>> > - On desktop OSes there are similar mechanisms to launch Apps from the\n>>> > browser (e.g. for mailto: links)\n>>>\n>>> This works if the author of the web page thought about this, and\n>>> created appropriate liks/qr codes. In many cases, addresses are\n>>> just presented for users as text, to copy.\n>>>\n>>> People also send addresses in message apps and emails. Maybe if\n>>> applications start to autodetect bitcoin addresses and convert them to\n>>> bitcoin: links, there will be less need to copy-paste. But I suspect\n>>> that this feature will not be quickly adopted by applications.\n>>>\n>>> > For cases where the payee is a well-known entity the BIP70 payment\n>>> > protocol has authentication via certificates. That doesn't work for\n>>> > the \"the person in front of you is the only trust anchor you have\"\n>>> > usecase though.\n>>>\n>>> There are also BIP75 and BIP47 that may help, but the number of wallets\n>>> that support these protocols is small (I think in part because of\n>>> relative complexity of these protocols).\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>\n>>\n>> --\n>> Best,\n>> \u00c1d\u00e1m\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n\n-- \nBest,\n\u00c1d\u00e1m\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181201/21b2a889/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP Proposal - Address Paste Improvement",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Adam Ficsor",
                "James MacWhyte"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 7201
        }
    },
    {
        "title": "[bitcoin-dev] draft proposal: change forwarding (improved fungibility through wallet interoperability)",
        "thread_messages": [
            {
                "author": "James MacWhyte",
                "date": "2018-12-01T05:06:29",
                "message_text_only": "Hi Yuval!\n\nSorry for reviving an old email thread. Could you describe what the UX\nwould be like, or how a wallet developer might implement this? Is the\nintention that someone would open their non-private wallet, and choose an\noption that slowly siphons their funds into a different app? Why would\nanyone want that feature?\n\nIf the user is privacy-conscious, why did they choose the non-private\nwallet to begin with? Why wouldn't they just move all their funds to the\nprivate wallet so they can continue to use just one app?\n\nAnd if the user is not privacy-conscious, they would never choose to enable\nthis option, so why would the wallet developer even bother to implement it?\n\n>From a product standpoint, I can't see how this would be useful, and\ntherefore I'm not sure why it needs to be a BIP. If I'm missing something,\nplease let me know!\n\nThanks,\nJames\n\n\nOn Tue, Nov 6, 2018 at 10:18 AM Yuval Kogman via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello,\n>\n> I would like to propose a method based on BIP32 (and optionally BIP44) for\n> improving fungibility and on chain privacy with wallets for which this is\n> not a primary concern, requiring minimal changes to allow such wallets to\n> safely forward change outputs to more specialized wallets. This is intended\n> to complement more comprehensive proposals such as BIP79.\n>\n> Note that this draft is still incomplete, there are open questions about\n> the particular format to use. In its current form it proposes two viable\n> options (and two more are included completeness) and though I have a slight\n> preference for the first option, I remain undecided given the tradeoffs,\n> and so I am writing the mailing list to solicit inputs/criticism.\n>\n> https://gist.github.com/nothingmuch/652f3a98089a0600637eadab738b2d6a\n>\n> Thanks to SirMeow, Adam Ficsor, and Adam Gibson for reviewing earlier\n> versions and providing valuable feedback and suggestions.\n>\n> Regards,\n> Yuval\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181130/36adb957/attachment-0001.html>"
            },
            {
                "author": "Yuval Kogman",
                "date": "2018-12-01T15:33:52",
                "message_text_only": "Hi,\n\nOn Sat, 1 Dec 2018 at 05:06, James MacWhyte <macwhyte at gmail.com> wrote:\n\n> Is the intention that someone would open their non-private wallet, and\n> choose an option that slowly siphons their funds into a different app?\n>\n\nYes, that's the idea. And then send them back in a controlled manner.\n\n\n> Why would anyone want that feature?\n>\n\nMost mobile wallets have no coin control features, which are tricky to\nimplement (lots of design/UI effort required). Some special purpose wallets\nhave additional privacy concerns and also lack coin control - for example\nprotip.is may inadvertently disclose browsing habits, or bisq arbitration\ncontracts are easily identifiable on the blockchain. The latter is actually\nan inspiration to this, since it has functionality to allow funding\ntransactions from an external wallet, as well as withdrawing to one.\n\nConversely, fungibility focused wallets are highly specialized and limited\nin scope. As far as I'm aware, JoinMarket and Wasabi are the only\nmaintained implementations of mixing wallets available today, and both are\ndesktop apps, with no hardware wallet integration. It is unlikely that e.g.\ncoinjoin functionality would be added the application specific wallets,\nespecially as these features require a great deal of care and effort to do\ncorrectly (cf. SharedCoin)\n\nThe goal then is to allow people who are privacy conscious to utilize a\nspecialized wallet automatically, to isolate the activity of wallets which\ndon't provide a sufficient degree of control in order to achieve that\nmanually, and reducing the possibility of operator error.\n\nCould you describe what the UX would be like\n>\n\n>From a payment standpoint the main difference is that change outputs would\nnot be usable, so the spendable balance would drop. The best idea I have\nfor handling that is to still display that balance but conveying that is\nlocked. However, I think simply removing it from the balance is also\nacceptable. Funds would simply be added to the fungibility wallet similarly\nto how they are used manually today.\n\nFor setup, the fungibility wallet would need to add functionality to export\nthese xpub variants, perhaps with a way of annotating what each account is\nfor (but see concerns about BIP44 recoverability). Like standard xpubs,\nthese would be easily conveyed by QR code.\n\nThe forwarding wallet would then offer an advanced configuration feature,\nthat allows adding and enabling the alternate change address chain. If the\nfungibility wallet derives addresses differently, then the forwarding\nwallet should reject the configuration value (which is the main technical\npoint of the writeup), to ensure funds are not misplaced.\n\n\n> or how a wallet developer might implement this?\n>\n\nFor fungibility wallets, this requires keeping track of these address\nchains, and allowing them to be exported. This is similar to any sort of\nscanning functionality implemented in a BIP32 capable wallet, plus the UI\nto display them.\n\nIn the forwarding wallet, derivation of addresses is again already\nimplemented in any BIP32 capable wallet (i.e. checking for the next free\naddress), with the main change in the spending path being dependency\ninjection required to change the address chain parameters (from what I know\nmost BIP32 implementations are polymorphic with respect to derivations made\nfrom a public extended key vs. a private extended key). The main effort\nthen is the setup functionality, which obviously will vary considerably\nbetween wallets, but I imagine it would still be a simpler and safer change\nthan integrating comprehensive privacy features into the spend path\ndirectly.\n\nIf the user is privacy-conscious, why did they choose the non-private\n> wallet to begin with? Why wouldn't they just move all their funds to the\n> private wallet so they can continue to use just one app?\n>\n\nPlatform limitations, or application specific use cases, see above. More\nbroadly, the main rationale is that diverse, specialized wallets should be\nused in a complementary way, as that is more achievable than expecting all\napplication specific wallets to have robust privacy features.\n\nAnd if the user is not privacy-conscious, they would never choose to enable\n> this option, so why would the wallet developer even bother to implement it?\n>\n\nI believe this is a low hanging fruit, easier to implement than coin\ncontrol, far easier to implement than safe mixing functionality, so wallet\ndevelopers (or contributes) would implement this to allow users more\nreliable access to privacy features implemented by other wallets.\n\n\n> From a product standpoint, I can't see how this would be useful, and\n> therefore I'm not sure why it needs to be a BIP. If I'm missing something,\n> please let me know!\n>\n\nThe reason for documenting it in this way is because if deemed desirable\nfunctionality (which itself is something the BIP process can help\ndetermine), different implementations would need to agree on the details. I\nhope I've managed to convince you of the usefulness, though I'm still not\nsure about the practicality or desirability - as it stands right now I have\nreceived fairly comprehensive criticism from LaurentMT though, and I've\nbeen focusing on related idea to improve zerolink which I hope would to\nrevisit this change forwarding idea and address his concerns when I have\nmore clarity. The main weakness is the assumptions that fungibility wallets\nhandle arbitrary amounts allowing those funds to be tumbled and\nrecycled/consolidated, which realistically only applies to Join Market and\neven then only if used correctly.\n\nRegards,\nYuval\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181201/3d56135c/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "draft proposal: change forwarding (improved fungibility through wallet interoperability)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Yuval Kogman",
                "James MacWhyte"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 8075
        }
    },
    {
        "title": "[bitcoin-dev] CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)",
        "thread_messages": [
            {
                "author": "Bob McElrath",
                "date": "2018-12-02T15:08:39",
                "message_text_only": "I've long thought about using SIGHASH_SINGLE, then either party can add inputs\nto cover whatever fee they want on channel close and it doesn't have to be\npre-planned at setup.\n\nFor Lightning I think you'd want to cross-sign, e.g. Alice signs her input\nand Bob's output, while Bob signs his input and Alice's output.  This would\ndemotivate the two parties from picking apart the transaction and broadcasting\none of the two SIGHASH_SINGLE's in a Lightning transaction.\n\nMatt Corallo via bitcoin-dev [bitcoin-dev at lists.linuxfoundation.org] wrote:\n> (cross-posted to both lists to make lightning-dev folks aware, please take\n> lightning-dev off CC when responding).\n> \n> As I'm sure everyone is aware, Lightning (and other similar systems) work by\n> exchanging pre-signed transactions for future broadcast. Of course in many\n> cases this requires either (a) predicting what the feerate required for\n> timely confirmation will be at some (or, really, any) point in the future,\n> or (b) utilizing CPFP and dependent transaction relay to allow parties to\n> broadcast low-feerate transactions with children created at broadcast-time\n> to increase the effective feerate. Ideally transactions could be constructed\n> to allow for after-the-fact addition of inputs to increase fee without CPFP\n> but it is not always possible to do so.\n> \n> Option (a) is rather obviously intractible, and implementation complexity\n> has led to channel failures in lightning in practice (as both sides must\n> agree on a reasonable-in-the-future feerate). Option (b) is a much more\n> natural choice (assuming some form of as-yet-unimplemented package relay on\n> the P2P network) but is made difficult due to complexity around RBF/CPFP\n> anti-DoS rules.\n> \n> For example, if we take a simplified lightning design with pre-signed\n> commitment transaction A with one 0-value anyone-can-spend output available\n> for use as a CPFP output, a counterparty can prevent confirmation\n> of/significantly increase the fee cost of confirming A by chaining a\n> large-but-only-moderate-feerate transaction off of this anyone-can-spend\n> output. This transaction, B, will have a large absolute fee while making the\n> package (A, B) have a low-ish feerate, placing it solidly at the bottom of\n> the mempool but without significant risk of it getting evicted during memory\n> limiting. This large absolute fee forces a counterparty which wishes to have\n> the commitment transaction confirm to increase on this absolute fee in order\n> to meet RBF rules.\n> \n> For this reason (and many other similar attacks utilizing the package size\n> limits), in discussing the security model around CPFP, we've generally\n> considered it too-difficulty-to-prevent third parties which are able to\n> spend an output of a transaction from delaying its confirmation, at least\n> until/unless the prevailing feerates decline and some of the mempool backlog\n> gets confirmed.\n> \n> You'll note, however, that this attack doesn't have to be permanent to work\n> - Lightning's (and other contracting/payment channel systems') security\n> model assumes the ability to get such commitment transactions confirmed in a\n> timely manner, as otherwise HTLCs may time out and counterparties can claim\n> the timeout-refund before we can claim the HTLC using the hash-preimage.\n> \n> To partially-address the CPFP security model considerations, a next step\n> might involve tweaking Lightning's commitment transaction to have two\n> small-value outputs which are immediately spendable, one by each channel\n> participant, allowing them to chain children off without allowng unrelated\n> third-parties to chain children. Obviously this does not address the\n> specific attack so we need a small tweak to the anti-DoS CPFP rules in\n> Bitcoin Core/BIP 125:\n> \n> The last transaction which is added to a package of dependent transactions\n> in the mempool must:\n>  * Have no more than one unconfirmed parent,\n>  * Be of size no greater than 1K in virtual size.\n> (for implementation sanity, this would effectively reduce all mempool\n> package size limits by 1 1K-virtual-size transaction, and the last would be\n> \"allowed to violate the limits\" as long as it meets the above criteria).\n> \n> For contracting applications like lightning, this means that as long as the\n> transaction we wish to confirm (in this case the commitment transaction)\n>  * Has only two immediately-spendable (ie non-CSV) outputs,\n>  * where each immediately-spendable output is only spendable by one\n> counterparty,\n>  * and is no larger than MAX_PACKAGE_VIRTUAL_SIZE - 1001 Vsize,\n> each counterparty will always be able to independantly CPFP the transaction\n> in question. ie because if the \"malicious\" (ie transaction-delaying) party\n> bradcasts A with a child, it can never meet the \"last transaction\" carve-out\n> as its transaction cannot both meet the package limit and have only one\n> unconfirmed ancestor. Thus, the non-delaying counterparty can always\n> independently add its own CPFP transaction, increasing the (A, Tx2) package\n> feerate and confirming A without having to concern themselves with the (A,\n> Tx1) package.\n> \n> As an alternative proposal, at various points there have been discussions\n> around solving the \"RBF-pinning\" problem by allowing transactors to mark\n> their transactions as \"likely-to-be-RBF'ed\", which could enable a relay\n> policy where children of such transactions would be rejected unless the\n> resulting package would be \"near the top of the mempool\". This would\n> theoretically imply such attacks are not possible to pull off consistently,\n> as any \"transaction-delaying\" channel participant will have to place the\n> package containing A at an effective feerate which makes confirmation to\n> occur soon with some likelihood. It is, however, possible to pull off this\n> attack with low probability in case of feerate spikes right after broadcast.\n> \n> Note that this clearly relies on some form of package relay, which comes\n> with its own challenges, but I'll start a separate thread on that.\n> \n> See-also: lightning-dev thread about the changes to lightning spec required\n> to incorporate this: https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001643.html\n> \n> Matt\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> \n> !DSPAM:5c014daf168271726154759!\n--\nCheers, Bob McElrath\n\n\"For every complex problem, there is a solution that is simple, neat, and wrong.\"\n    -- H. L. Mencken"
            }
        ],
        "thread_summary": {
            "title": "CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Bob McElrath"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 6565
        }
    },
    {
        "title": "[bitcoin-dev] [Lightning-dev] CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-03T04:16:10",
                "message_text_only": "Good morning Bob,\n\nWould `SIGHASH_SINGLE` work?\nCommitment transactions have a single input but multiple outputs.\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Sunday, December 2, 2018 11:08 PM, Bob McElrath <bob at mcelrath.org> wrote:\n\n> I've long thought about using SIGHASH_SINGLE, then either party can add inputs\n> to cover whatever fee they want on channel close and it doesn't have to be\n> pre-planned at setup.\n>\n> For Lightning I think you'd want to cross-sign, e.g. Alice signs her input\n> and Bob's output, while Bob signs his input and Alice's output. This would\n> demotivate the two parties from picking apart the transaction and broadcasting\n> one of the two SIGHASH_SINGLE's in a Lightning transaction.\n>\n> Matt Corallo via bitcoin-dev [bitcoin-dev at lists.linuxfoundation.org] wrote:\n>\n> > (cross-posted to both lists to make lightning-dev folks aware, please take\n> > lightning-dev off CC when responding).\n> > As I'm sure everyone is aware, Lightning (and other similar systems) work by\n> > exchanging pre-signed transactions for future broadcast. Of course in many\n> > cases this requires either (a) predicting what the feerate required for\n> > timely confirmation will be at some (or, really, any) point in the future,\n> > or (b) utilizing CPFP and dependent transaction relay to allow parties to\n> > broadcast low-feerate transactions with children created at broadcast-time\n> > to increase the effective feerate. Ideally transactions could be constructed\n> > to allow for after-the-fact addition of inputs to increase fee without CPFP\n> > but it is not always possible to do so.\n> > Option (a) is rather obviously intractible, and implementation complexity\n> > has led to channel failures in lightning in practice (as both sides must\n> > agree on a reasonable-in-the-future feerate). Option (b) is a much more\n> > natural choice (assuming some form of as-yet-unimplemented package relay on\n> > the P2P network) but is made difficult due to complexity around RBF/CPFP\n> > anti-DoS rules.\n> > For example, if we take a simplified lightning design with pre-signed\n> > commitment transaction A with one 0-value anyone-can-spend output available\n> > for use as a CPFP output, a counterparty can prevent confirmation\n> > of/significantly increase the fee cost of confirming A by chaining a\n> > large-but-only-moderate-feerate transaction off of this anyone-can-spend\n> > output. This transaction, B, will have a large absolute fee while making the\n> > package (A, B) have a low-ish feerate, placing it solidly at the bottom of\n> > the mempool but without significant risk of it getting evicted during memory\n> > limiting. This large absolute fee forces a counterparty which wishes to have\n> > the commitment transaction confirm to increase on this absolute fee in order\n> > to meet RBF rules.\n> > For this reason (and many other similar attacks utilizing the package size\n> > limits), in discussing the security model around CPFP, we've generally\n> > considered it too-difficulty-to-prevent third parties which are able to\n> > spend an output of a transaction from delaying its confirmation, at least\n> > until/unless the prevailing feerates decline and some of the mempool backlog\n> > gets confirmed.\n> > You'll note, however, that this attack doesn't have to be permanent to work\n> >\n> > -   Lightning's (and other contracting/payment channel systems') security\n> >     model assumes the ability to get such commitment transactions confirmed in a\n> >     timely manner, as otherwise HTLCs may time out and counterparties can claim\n> >     the timeout-refund before we can claim the HTLC using the hash-preimage.\n> >\n> >\n> > To partially-address the CPFP security model considerations, a next step\n> > might involve tweaking Lightning's commitment transaction to have two\n> > small-value outputs which are immediately spendable, one by each channel\n> > participant, allowing them to chain children off without allowng unrelated\n> > third-parties to chain children. Obviously this does not address the\n> > specific attack so we need a small tweak to the anti-DoS CPFP rules in\n> > Bitcoin Core/BIP 125:\n> > The last transaction which is added to a package of dependent transactions\n> > in the mempool must:\n> >\n> > -   Have no more than one unconfirmed parent,\n> > -   Be of size no greater than 1K in virtual size.\n> >     (for implementation sanity, this would effectively reduce all mempool\n> >     package size limits by 1 1K-virtual-size transaction, and the last would be\n> >     \"allowed to violate the limits\" as long as it meets the above criteria).\n> >\n> >\n> > For contracting applications like lightning, this means that as long as the\n> > transaction we wish to confirm (in this case the commitment transaction)\n> >\n> > -   Has only two immediately-spendable (ie non-CSV) outputs,\n> > -   where each immediately-spendable output is only spendable by one\n> >     counterparty,\n> >\n> > -   and is no larger than MAX_PACKAGE_VIRTUAL_SIZE - 1001 Vsize,\n> >     each counterparty will always be able to independantly CPFP the transaction\n> >     in question. ie because if the \"malicious\" (ie transaction-delaying) party\n> >     bradcasts A with a child, it can never meet the \"last transaction\" carve-out\n> >     as its transaction cannot both meet the package limit and have only one\n> >     unconfirmed ancestor. Thus, the non-delaying counterparty can always\n> >     independently add its own CPFP transaction, increasing the (A, Tx2) package\n> >     feerate and confirming A without having to concern themselves with the (A,\n> >     Tx1) package.\n> >\n> >\n> > As an alternative proposal, at various points there have been discussions\n> > around solving the \"RBF-pinning\" problem by allowing transactors to mark\n> > their transactions as \"likely-to-be-RBF'ed\", which could enable a relay\n> > policy where children of such transactions would be rejected unless the\n> > resulting package would be \"near the top of the mempool\". This would\n> > theoretically imply such attacks are not possible to pull off consistently,\n> > as any \"transaction-delaying\" channel participant will have to place the\n> > package containing A at an effective feerate which makes confirmation to\n> > occur soon with some likelihood. It is, however, possible to pull off this\n> > attack with low probability in case of feerate spikes right after broadcast.\n> > Note that this clearly relies on some form of package relay, which comes\n> > with its own challenges, but I'll start a separate thread on that.\n> > See-also: lightning-dev thread about the changes to lightning spec required\n> > to incorporate this: https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001643.html\n> > Matt\n> >\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> > !DSPAM:5c014daf168271726154759!\n>\n> --\n> Cheers, Bob McElrath\n>\n> \"For every complex problem, there is a solution that is simple, neat, and wrong.\"\n> -- H. L. Mencken\n>\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Rusty Russell",
                "date": "2018-12-04T03:33:53",
                "message_text_only": "Matt Corallo <lf-lists at mattcorallo.com> writes:\n> As an alternative proposal, at various points there have been \n> discussions around solving the \"RBF-pinning\" problem by allowing \n> transactors to mark their transactions as \"likely-to-be-RBF'ed\", which \n> could enable a relay policy where children of such transactions would be \n> rejected unless the resulting package would be \"near the top of the \n> mempool\". This would theoretically imply such attacks are not possible \n> to pull off consistently, as any \"transaction-delaying\" channel \n> participant will have to place the package containing A at an effective \n> feerate which makes confirmation to occur soon with some likelihood. It \n> is, however, possible to pull off this attack with low probability in \n> case of feerate spikes right after broadcast.\n\nI like this idea.\n\nFirstly, it's incentive-compatible[1]: assuming blocks are full, miners\nshould always take a higher feerate tx if that tx would be in the\ncurrent block and the replaced txs would not.[2]\n\nSecondly, it reduces the problem that the current lightning proposal\nadds to the UTXO set with two anyone-can-spend txs for 1000 satoshis,\nwhich might be too small to cleanup later.  This rule would allow a\nsimple single P2WSH(OP_TRUE) output, or, with IsStandard changed,\na literal OP_TRUE.\n\n> Note that this clearly relies on some form of package relay, which comes \n> with its own challenges, but I'll start a separate thread on that.\n\nCould be done client-side, right?  Do a quick check if this is above 250\nsatoshi per kweight but below minrelayfee, put it in a side-cache with a\n60 second timeout sweep.  If something comes in which depends on it\nwhich is above minrelayfee, then process them as a pair[3].\n\nCheers,\nRusty.\n[1] Miners have generally been happy with Defaults Which Are Good For The\n    Network, but I feel a long term development aim should to be reduce\n    such cases to smaller and smaller corners.\n[2] The actual condition is subtler, but this is a clear subset AFAICT.\n[3] For Lightning, we don't care about child-pays-for-grandparent etc."
            }
        ],
        "thread_summary": {
            "title": "CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)",
            "categories": [
                "bitcoin-dev",
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Rusty Russell"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 9299
        }
    },
    {
        "title": "[bitcoin-dev] Proposal for Palindromic (Reversible) Mnemonics",
        "thread_messages": [
            {
                "author": "Steven Hatzakis",
                "date": "2018-12-03T18:27:52",
                "message_text_only": "Hi All,\n\nI've developed a method to check if a mnemonic is also valid when the words\nare put into reverse order (not the entropy), where a given 12 or 24-word\nmnemonic could be valid both in little endian and big endian format. I've\ncoined these \"Palindromic Mnemonics\", but perhaps more user-friendly is\n\"reversible mnemonics.\"\n\nPurpose:\nA checksum-valid reversible mnemonic allows two separate vaults to be\nconnected to the same mnemonic string of words, where all a users must do\nis enter the words in reverse order (the last word becomes first, second to\nlast becomes second, and so on) to access the secondary (reversed words)\nvault. This utility could provide multiple use-cases, including related to\ncombinations with passphrases and plausible deniability, as well as\nconveniences for those wishing to use a separate vault tied to the same\nstring of words.\n\nSecurity:\nFor any randomly generated 12-word mnemonic (128-bits of security) the\nchances of it also being reversible are 1/16 (I believe), as a total of 4\nbit positions must be identical (4 bits from the normal mnemonic and\nanother 4 bits from the reversed string must match). For a 24-word\nmnemonic, those values increase to 8 bits which need to match 8 bits from\nthe reversed string, leading to about 1 in every 256 mnemonics also being\nreversible. While the message space of valid reversible mnemonics should be\n2^124 for 12 words, that search must still be conducted over a field of 2^128,\nas the hash-derived checksum values otherwise prevent a way to\ndeterministically find valid reversible mnemonics without first going\nthrough invalid reversible ones to check. I think others should chime in on\nwhether they believe there is any security loss, in terms of entropy bits\n(assuming the initial 128 bits were generated securely). I estimate at most\nit would be 4-bits of loss for a 12-word mnemonic, but only if an attacker\nhad a way to search only the space of valid reversible mnemonics (2**124)\nwhich I don't think is feasible (could be wrong?). There could also be\nerrors in my above assumptions, this is a work in progress and sharing it\nhere to solicit initial feedback/interest.\n\nI've already written the code that can be used for testing (on GitHub user\n@hatgit), and when run from terminal/command prompt it is pretty fast to\nfind a valid reversible mnemonics, whereas on IDLE in Python on a 32-bit\nand 64-bit machine it could take a few seconds for 12 words and sometimes\n10 minutes to find a valid 24-word reversible mnemonic.\nExample 12 words reversible (with valid checksum each way):\n\nlimit exact seven clarify utility road image fresh leg cabbage hint canoe\n\nAnd Reversed:\n\ncanoe hint cabbage leg fresh image road utility clarify seven exact limit\n\n\nExample 24 reversible:\n\nfavorite uncover sugar wealth army shift goose fury market toe message\nremain direct arrow duck afraid enroll salt knife school duck sunny grunt\nargue\n\nAnd reversed:\n\nargue grunt sunny duck school knife salt enroll afraid duck arrow direct\nremain message toe market fury goose shift army wealth sugar uncover\nfavorite\n\n\nMy two questions 1) are how useful could this be for you/users/devs/service\nproviders etc.. and 2) is any security loss occurring and whether it is\nnegligible or not?\n\nBest regards,\n\nSteven Hatzakis\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181203/cd2ca4c8/attachment.html>"
            },
            {
                "author": "Joseph Gleason \u2448",
                "date": "2018-12-03T20:54:10",
                "message_text_only": "I have a suggestion.  If you are concerned about plausible deniability,\nthen it might make sense to just have the single mnemonic seed lead to a\nsingle xprv key (as usual) and then do a private key derivation from that\nbased on a password string.  The password can be simple, as it is based on\nthe security of the seed, just as long as the user feels they need for\ndeniability.\n\nA simple reverse scheme like you describe would just be another thing a\nperson would know to check if given some seed so I don't see it as\nproviding much value, but I could be missing something.\n\nOn Mon, Dec 3, 2018 at 10:45 AM Steven Hatzakis via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi All,\n>\n> I've developed a method to check if a mnemonic is also valid when the\n> words are put into reverse order (not the entropy), where a given 12 or\n> 24-word mnemonic could be valid both in little endian and big endian\n> format. I've coined these \"Palindromic Mnemonics\", but perhaps more\n> user-friendly is \"reversible mnemonics.\"\n>\n> Purpose:\n> A checksum-valid reversible mnemonic allows two separate vaults to be\n> connected to the same mnemonic string of words, where all a users must do\n> is enter the words in reverse order (the last word becomes first, second to\n> last becomes second, and so on) to access the secondary (reversed words)\n> vault. This utility could provide multiple use-cases, including related to\n> combinations with passphrases and plausible deniability, as well as\n> conveniences for those wishing to use a separate vault tied to the same\n> string of words.\n>\n> Security:\n> For any randomly generated 12-word mnemonic (128-bits of security) the\n> chances of it also being reversible are 1/16 (I believe), as a total of 4\n> bit positions must be identical (4 bits from the normal mnemonic and\n> another 4 bits from the reversed string must match). For a 24-word\n> mnemonic, those values increase to 8 bits which need to match 8 bits from\n> the reversed string, leading to about 1 in every 256 mnemonics also being\n> reversible. While the message space of valid reversible mnemonics should be\n> 2^124 for 12 words, that search must still be conducted over a field of 2^128,\n> as the hash-derived checksum values otherwise prevent a way to\n> deterministically find valid reversible mnemonics without first going\n> through invalid reversible ones to check. I think others should chime in on\n> whether they believe there is any security loss, in terms of entropy bits\n> (assuming the initial 128 bits were generated securely). I estimate at most\n> it would be 4-bits of loss for a 12-word mnemonic, but only if an attacker\n> had a way to search only the space of valid reversible mnemonics (2**124)\n> which I don't think is feasible (could be wrong?). There could also be\n> errors in my above assumptions, this is a work in progress and sharing it\n> here to solicit initial feedback/interest.\n>\n> I've already written the code that can be used for testing (on GitHub user\n> @hatgit), and when run from terminal/command prompt it is pretty fast to\n> find a valid reversible mnemonics, whereas on IDLE in Python on a 32-bit\n> and 64-bit machine it could take a few seconds for 12 words and sometimes\n> 10 minutes to find a valid 24-word reversible mnemonic.\n> Example 12 words reversible (with valid checksum each way):\n>\n> limit exact seven clarify utility road image fresh leg cabbage hint canoe\n>\n> And Reversed:\n>\n> canoe hint cabbage leg fresh image road utility clarify seven exact limit\n>\n>\n> Example 24 reversible:\n>\n> favorite uncover sugar wealth army shift goose fury market toe message\n> remain direct arrow duck afraid enroll salt knife school duck sunny grunt\n> argue\n>\n> And reversed:\n>\n> argue grunt sunny duck school knife salt enroll afraid duck arrow direct\n> remain message toe market fury goose shift army wealth sugar uncover\n> favorite\n>\n>\n> My two questions 1) are how useful could this be for\n> you/users/devs/service providers etc.. and 2) is any security loss\n> occurring and whether it is negligible or not?\n>\n> Best regards,\n>\n> Steven Hatzakis\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181203/4182bf2d/attachment.html>"
            },
            {
                "author": "James MacWhyte",
                "date": "2018-12-04T12:16:12",
                "message_text_only": "I agree with Joseph. If you want plausible deniability, it would be better\nto simply hide the funds somewhere in the HD chain. Same if you want a\nsecond vault tied to the same phrase.\n\nYou are reducing security by eliminating all entropy that doesn't fit the\nreversible criteria, although in practice it doesn't make a difference\nbecause the numbers are so big. However, it doesn't seem like a very useful\nfeature to have.\n\nThanks for doing all that work though, it was fun to read about your idea\nand what you found out through experimenting!\n\nJames\n\n\nOn Mon, Dec 3, 2018 at 1:00 PM Joseph Gleason \u2448 via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I have a suggestion.  If you are concerned about plausible deniability,\n> then it might make sense to just have the single mnemonic seed lead to a\n> single xprv key (as usual) and then do a private key derivation from that\n> based on a password string.  The password can be simple, as it is based on\n> the security of the seed, just as long as the user feels they need for\n> deniability.\n>\n> A simple reverse scheme like you describe would just be another thing a\n> person would know to check if given some seed so I don't see it as\n> providing much value, but I could be missing something.\n>\n> On Mon, Dec 3, 2018 at 10:45 AM Steven Hatzakis via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi All,\n>>\n>> I've developed a method to check if a mnemonic is also valid when the\n>> words are put into reverse order (not the entropy), where a given 12 or\n>> 24-word mnemonic could be valid both in little endian and big endian\n>> format. I've coined these \"Palindromic Mnemonics\", but perhaps more\n>> user-friendly is \"reversible mnemonics.\"\n>>\n>> Purpose:\n>> A checksum-valid reversible mnemonic allows two separate vaults to be\n>> connected to the same mnemonic string of words, where all a users must do\n>> is enter the words in reverse order (the last word becomes first, second to\n>> last becomes second, and so on) to access the secondary (reversed words)\n>> vault. This utility could provide multiple use-cases, including related to\n>> combinations with passphrases and plausible deniability, as well as\n>> conveniences for those wishing to use a separate vault tied to the same\n>> string of words.\n>>\n>> Security:\n>> For any randomly generated 12-word mnemonic (128-bits of security) the\n>> chances of it also being reversible are 1/16 (I believe), as a total of 4\n>> bit positions must be identical (4 bits from the normal mnemonic and\n>> another 4 bits from the reversed string must match). For a 24-word\n>> mnemonic, those values increase to 8 bits which need to match 8 bits from\n>> the reversed string, leading to about 1 in every 256 mnemonics also being\n>> reversible. While the message space of valid reversible mnemonics should be\n>> 2^124 for 12 words, that search must still be conducted over a field of 2\n>> ^128, as the hash-derived checksum values otherwise prevent a way to\n>> deterministically find valid reversible mnemonics without first going\n>> through invalid reversible ones to check. I think others should chime in on\n>> whether they believe there is any security loss, in terms of entropy bits\n>> (assuming the initial 128 bits were generated securely). I estimate at most\n>> it would be 4-bits of loss for a 12-word mnemonic, but only if an attacker\n>> had a way to search only the space of valid reversible mnemonics (2**124)\n>> which I don't think is feasible (could be wrong?). There could also be\n>> errors in my above assumptions, this is a work in progress and sharing it\n>> here to solicit initial feedback/interest.\n>>\n>> I've already written the code that can be used for testing (on GitHub\n>> user @hatgit), and when run from terminal/command prompt it is pretty fast\n>> to find a valid reversible mnemonics, whereas on IDLE in Python on a 32-bit\n>> and 64-bit machine it could take a few seconds for 12 words and sometimes\n>> 10 minutes to find a valid 24-word reversible mnemonic.\n>> Example 12 words reversible (with valid checksum each way):\n>>\n>> limit exact seven clarify utility road image fresh leg cabbage hint canoe\n>>\n>> And Reversed:\n>>\n>> canoe hint cabbage leg fresh image road utility clarify seven exact limit\n>>\n>>\n>> Example 24 reversible:\n>>\n>> favorite uncover sugar wealth army shift goose fury market toe message\n>> remain direct arrow duck afraid enroll salt knife school duck sunny grunt\n>> argue\n>>\n>> And reversed:\n>>\n>> argue grunt sunny duck school knife salt enroll afraid duck arrow direct\n>> remain message toe market fury goose shift army wealth sugar uncover\n>> favorite\n>>\n>>\n>> My two questions 1) are how useful could this be for\n>> you/users/devs/service providers etc.. and 2) is any security loss\n>> occurring and whether it is negligible or not?\n>>\n>> Best regards,\n>>\n>> Steven Hatzakis\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181204/fbd20ae0/attachment.html>"
            },
            {
                "author": "Steven Hatzakis",
                "date": "2018-12-04T12:42:42",
                "message_text_only": "Thanks, James and Joseph, for the feedback,\nIt has been a fun experiment!\n\nI just want to note that the plausible deniability was not the motive but\njust an example use-case, there are perhaps other use-cases that would be\non the user to decide. I think having a mnemonic that is also reversible\ncould be useful for other reasons - convenience related perhaps.\n*Re security:* I am still not convinced entirely that security is reduced\nat all because one still has to search through all entropy in the range\nof 2^128 to see whether any of those are reversible (unless there is a way\nto only search the field of 2^124 that are reversible, which I don't think\nis possible because the hash-derived checksum cannot be determined before\nhashing, only afterward). Therefore, security should still be 2^128 for a\n12-word mnemonic whether it is reversible or not (as one in every 16 people\nthat already have one (12-word) is reversible, they just might not realize\nit, so we can't say those are less secure).\n\nBest regards,\n\nOn Tue, Dec 4, 2018 at 2:16 PM James MacWhyte <macwhyte at gmail.com> wrote:\n\n> I agree with Joseph. If you want plausible deniability, it would be better\n> to simply hide the funds somewhere in the HD chain. Same if you want a\n> second vault tied to the same phrase.\n>\n> You are reducing security by eliminating all entropy that doesn't fit the\n> reversible criteria, although in practice it doesn't make a difference\n> because the numbers are so big. However, it doesn't seem like a very useful\n> feature to have.\n>\n> Thanks for doing all that work though, it was fun to read about your idea\n> and what you found out through experimenting!\n>\n> James\n>\n>\n> On Mon, Dec 3, 2018 at 1:00 PM Joseph Gleason \u2448 via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> I have a suggestion.  If you are concerned about plausible deniability,\n>> then it might make sense to just have the single mnemonic seed lead to a\n>> single xprv key (as usual) and then do a private key derivation from that\n>> based on a password string.  The password can be simple, as it is based on\n>> the security of the seed, just as long as the user feels they need for\n>> deniability.\n>>\n>> A simple reverse scheme like you describe would just be another thing a\n>> person would know to check if given some seed so I don't see it as\n>> providing much value, but I could be missing something.\n>>\n>> On Mon, Dec 3, 2018 at 10:45 AM Steven Hatzakis via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Hi All,\n>>>\n>>> I've developed a method to check if a mnemonic is also valid when the\n>>> words are put into reverse order (not the entropy), where a given 12 or\n>>> 24-word mnemonic could be valid both in little endian and big endian\n>>> format. I've coined these \"Palindromic Mnemonics\", but perhaps more\n>>> user-friendly is \"reversible mnemonics.\"\n>>>\n>>> Purpose:\n>>> A checksum-valid reversible mnemonic allows two separate vaults to be\n>>> connected to the same mnemonic string of words, where all a users must do\n>>> is enter the words in reverse order (the last word becomes first, second to\n>>> last becomes second, and so on) to access the secondary (reversed words)\n>>> vault. This utility could provide multiple use-cases, including related to\n>>> combinations with passphrases and plausible deniability, as well as\n>>> conveniences for those wishing to use a separate vault tied to the same\n>>> string of words.\n>>>\n>>> Security:\n>>> For any randomly generated 12-word mnemonic (128-bits of security) the\n>>> chances of it also being reversible are 1/16 (I believe), as a total of 4\n>>> bit positions must be identical (4 bits from the normal mnemonic and\n>>> another 4 bits from the reversed string must match). For a 24-word\n>>> mnemonic, those values increase to 8 bits which need to match 8 bits from\n>>> the reversed string, leading to about 1 in every 256 mnemonics also being\n>>> reversible. While the message space of valid reversible mnemonics should be\n>>> 2^124 for 12 words, that search must still be conducted over a field of\n>>> 2^128, as the hash-derived checksum values otherwise prevent a way to\n>>> deterministically find valid reversible mnemonics without first going\n>>> through invalid reversible ones to check. I think others should chime in on\n>>> whether they believe there is any security loss, in terms of entropy bits\n>>> (assuming the initial 128 bits were generated securely). I estimate at most\n>>> it would be 4-bits of loss for a 12-word mnemonic, but only if an attacker\n>>> had a way to search only the space of valid reversible mnemonics (2**124)\n>>> which I don't think is feasible (could be wrong?). There could also be\n>>> errors in my above assumptions, this is a work in progress and sharing it\n>>> here to solicit initial feedback/interest.\n>>>\n>>> I've already written the code that can be used for testing (on GitHub\n>>> user @hatgit), and when run from terminal/command prompt it is pretty fast\n>>> to find a valid reversible mnemonics, whereas on IDLE in Python on a 32-bit\n>>> and 64-bit machine it could take a few seconds for 12 words and sometimes\n>>> 10 minutes to find a valid 24-word reversible mnemonic.\n>>> Example 12 words reversible (with valid checksum each way):\n>>>\n>>> limit exact seven clarify utility road image fresh leg cabbage hint canoe\n>>>\n>>> And Reversed:\n>>>\n>>> canoe hint cabbage leg fresh image road utility clarify seven exact limit\n>>>\n>>>\n>>> Example 24 reversible:\n>>>\n>>> favorite uncover sugar wealth army shift goose fury market toe message\n>>> remain direct arrow duck afraid enroll salt knife school duck sunny grunt\n>>> argue\n>>>\n>>> And reversed:\n>>>\n>>> argue grunt sunny duck school knife salt enroll afraid duck arrow direct\n>>> remain message toe market fury goose shift army wealth sugar uncover\n>>> favorite\n>>>\n>>>\n>>> My two questions 1) are how useful could this be for\n>>> you/users/devs/service providers etc.. and 2) is any security loss\n>>> occurring and whether it is negligible or not?\n>>>\n>>> Best regards,\n>>>\n>>> Steven Hatzakis\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181204/6b7a7b5b/attachment-0001.html>"
            },
            {
                "author": "Steven Hatzakis",
                "date": "2018-12-04T21:39:17",
                "message_text_only": "Hi Michael, thanks for the feedback.\nTo answer your question, the motivation was partly that some applications\ndo not accept passphrases, making mnemonics less versatile in those cases\nin terms of vault separation when logging in to those services, although I\nagree in that specific context reversible mnemonics don't add further\nsecurity (like a passphrase can) but it shouldn't lessen security either\n(in terms of entropy and bit-security).\n\nOf course, If someone finds a plaintexts recovery phrase (i.e. hacker) then\nthere is no security to prevent the funds being moved out whether it is\nreversible or not (unless again a passphrase was present, and even that can\nbe brute forced so protecting the words are key) unless it represented some\nmulti-sig key or was a Shamir secret share (such as is being proposed under\nSLIP0039 by Satoshi Labs, and Ian Coleman hosts a prototype).\n\nI think comparable to vanity addresses, reversible mnemonics could be part\nnovelty, but I do think there is also an actual utility. I am not\nsuggesting they are used 100% of the time, rather a user could choose to\ngenerate one manually or check if their existing one is already reversible.\nThose options could be provided at the software level and then it would be\nup to the user to chose. Bottom line, I think that users who have smaller\namounts in hot wallets could find it useful to have reversible mnemonics\nfor switching from one service to another without having to access yet\nanother mnemonic. Whereas, for those creating them offline (cold storage)\nit could provide an additional vault and additional passphrase options.\nHere's an example:\n\nVault #1 normal mnemonic\nVault #2 normal mnemonic w/passphrase\nVault #3 reversed mnemonic\nVault #4 reversed mnemonic w/passphrase\n\n\nBest regards,\n\nSteven Hatzakis\n\n\nOn Tue, Dec 4, 2018 at 4:16 PM Michael Dunworth <mike at sendwyre.com> wrote:\n\n> Cool idea, and appreciate the explainer surrounding it!\n>\n> What are the motivators to have it? Simplifying the recovery process\n> (easier to remember?) - Would love to know more from that if you're happy\n> to share! That'd help gauge the security considerations.\n>\n> Security thoughts:\n> - Probability of guessing is one thing, probability of getting access to a\n> keyword/phrase is another thing. So if the recovery/accessibility becomes a\n> motivator, that then can broaden the attack vectors pretty significantly.\n> Which would result in a significant decrease in the security (IMO?).\n> - Broadcasting the use of reversable mnemonics would become an attack\n> vector potentially. Now any members of the security team or members within\n> close proximity could learn that reversible phrases are used, and\n> insulating this information from becoming public knowledge would become\n> it's own security consideration. If it's already a 6.25% (1/16) chance\n> they're reversible, I wouldn't want it publicly known that it's a 100%\n> chance.\n> - Feels like it could be useful in terms of a \"duress password\" although\n> that might be implemented similarly to what Joseph mentioned where you\n> would route the reverse phrase to somewhere other than the core assets.\n>\n> May be misunderstanding or have bad maths this early in the morning, but I\n> think I'd be nervous to implement something like this without a pretty\n> clear upside. Seems like it only adds additional risk?\n>\n> Thank you.\n>\n> Kind regards,\n>\n> Michael.\n> \u1427\n>\n> On Tue, Dec 4, 2018 at 5:11 AM Steven Hatzakis via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Thanks, James and Joseph, for the feedback,\n>> It has been a fun experiment!\n>>\n>> I just want to note that the plausible deniability was not the motive but\n>> just an example use-case, there are perhaps other use-cases that would be\n>> on the user to decide. I think having a mnemonic that is also reversible\n>> could be useful for other reasons - convenience related perhaps.\n>> *Re security:* I am still not convinced entirely that security is\n>> reduced at all because one still has to search through all entropy in the\n>> range of 2^128 to see whether any of those are reversible (unless there is\n>> a way to only search the field of 2^124 that are reversible, which I don't\n>> think is possible because the hash-derived checksum cannot be determined\n>> before hashing, only afterward). Therefore, security should still be 2^128\n>> for a 12-word mnemonic whether it is reversible or not (as one in every 16\n>> people that already have one (12-word) is reversible, they just might not\n>> realize it, so we can't say those are less secure).\n>>\n>> Best regards,\n>>\n>> On Tue, Dec 4, 2018 at 2:16 PM James MacWhyte <macwhyte at gmail.com> wrote:\n>>\n>>> I agree with Joseph. If you want plausible deniability, it would be\n>>> better to simply hide the funds somewhere in the HD chain. Same if you want\n>>> a second vault tied to the same phrase.\n>>>\n>>> You are reducing security by eliminating all entropy that doesn't fit\n>>> the reversible criteria, although in practice it doesn't make a difference\n>>> because the numbers are so big. However, it doesn't seem like a very useful\n>>> feature to have.\n>>>\n>>> Thanks for doing all that work though, it was fun to read about your\n>>> idea and what you found out through experimenting!\n>>>\n>>> James\n>>>\n>>>\n>>> On Mon, Dec 3, 2018 at 1:00 PM Joseph Gleason \u2448 via bitcoin-dev <\n>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>>> I have a suggestion.  If you are concerned about plausible deniability,\n>>>> then it might make sense to just have the single mnemonic seed lead to a\n>>>> single xprv key (as usual) and then do a private key derivation from that\n>>>> based on a password string.  The password can be simple, as it is based on\n>>>> the security of the seed, just as long as the user feels they need for\n>>>> deniability.\n>>>>\n>>>> A simple reverse scheme like you describe would just be another thing a\n>>>> person would know to check if given some seed so I don't see it as\n>>>> providing much value, but I could be missing something.\n>>>>\n>>>> On Mon, Dec 3, 2018 at 10:45 AM Steven Hatzakis via bitcoin-dev <\n>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>>\n>>>>> Hi All,\n>>>>>\n>>>>> I've developed a method to check if a mnemonic is also valid when the\n>>>>> words are put into reverse order (not the entropy), where a given 12 or\n>>>>> 24-word mnemonic could be valid both in little endian and big endian\n>>>>> format. I've coined these \"Palindromic Mnemonics\", but perhaps more\n>>>>> user-friendly is \"reversible mnemonics.\"\n>>>>>\n>>>>> Purpose:\n>>>>> A checksum-valid reversible mnemonic allows two separate vaults to be\n>>>>> connected to the same mnemonic string of words, where all a users must do\n>>>>> is enter the words in reverse order (the last word becomes first, second to\n>>>>> last becomes second, and so on) to access the secondary (reversed words)\n>>>>> vault. This utility could provide multiple use-cases, including related to\n>>>>> combinations with passphrases and plausible deniability, as well as\n>>>>> conveniences for those wishing to use a separate vault tied to the same\n>>>>> string of words.\n>>>>>\n>>>>> Security:\n>>>>> For any randomly generated 12-word mnemonic (128-bits of security) the\n>>>>> chances of it also being reversible are 1/16 (I believe), as a total of 4\n>>>>> bit positions must be identical (4 bits from the normal mnemonic and\n>>>>> another 4 bits from the reversed string must match). For a 24-word\n>>>>> mnemonic, those values increase to 8 bits which need to match 8 bits from\n>>>>> the reversed string, leading to about 1 in every 256 mnemonics also being\n>>>>> reversible. While the message space of valid reversible mnemonics should be\n>>>>> 2^124 for 12 words, that search must still be conducted over a field\n>>>>> of 2^128, as the hash-derived checksum values otherwise prevent a way\n>>>>> to deterministically find valid reversible mnemonics without first going\n>>>>> through invalid reversible ones to check. I think others should chime in on\n>>>>> whether they believe there is any security loss, in terms of entropy bits\n>>>>> (assuming the initial 128 bits were generated securely). I estimate at most\n>>>>> it would be 4-bits of loss for a 12-word mnemonic, but only if an attacker\n>>>>> had a way to search only the space of valid reversible mnemonics (2**124)\n>>>>> which I don't think is feasible (could be wrong?). There could also be\n>>>>> errors in my above assumptions, this is a work in progress and sharing it\n>>>>> here to solicit initial feedback/interest.\n>>>>>\n>>>>> I've already written the code that can be used for testing (on GitHub\n>>>>> user @hatgit), and when run from terminal/command prompt it is pretty fast\n>>>>> to find a valid reversible mnemonics, whereas on IDLE in Python on a 32-bit\n>>>>> and 64-bit machine it could take a few seconds for 12 words and sometimes\n>>>>> 10 minutes to find a valid 24-word reversible mnemonic.\n>>>>> Example 12 words reversible (with valid checksum each way):\n>>>>>\n>>>>> limit exact seven clarify utility road image fresh leg cabbage hint\n>>>>> canoe\n>>>>>\n>>>>> And Reversed:\n>>>>>\n>>>>> canoe hint cabbage leg fresh image road utility clarify seven exact\n>>>>> limit\n>>>>>\n>>>>>\n>>>>> Example 24 reversible:\n>>>>>\n>>>>> favorite uncover sugar wealth army shift goose fury market toe message\n>>>>> remain direct arrow duck afraid enroll salt knife school duck sunny grunt\n>>>>> argue\n>>>>>\n>>>>> And reversed:\n>>>>>\n>>>>> argue grunt sunny duck school knife salt enroll afraid duck arrow\n>>>>> direct remain message toe market fury goose shift army wealth sugar uncover\n>>>>> favorite\n>>>>>\n>>>>>\n>>>>> My two questions 1) are how useful could this be for\n>>>>> you/users/devs/service providers etc.. and 2) is any security loss\n>>>>> occurring and whether it is negligible or not?\n>>>>>\n>>>>> Best regards,\n>>>>>\n>>>>> Steven Hatzakis\n>>>>> _______________________________________________\n>>>>> bitcoin-dev mailing list\n>>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>>\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>\n>>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n>\n> --\n> Michael Dunworth\n> Co-Founder, CEO\n>\n>\n>\n> We're now Wyre, Inc! Read about the rebrand here\n> <https://medium.com/@wyre/wyre-raises-5-8m-series-a-10e90718009b>.\n>\n> Wyre uses blockchain technology to help make your bank transfers faster\n> than email.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181204/6a7a371a/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Proposal for Palindromic (Reversible) Mnemonics",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Steven Hatzakis",
                "James MacWhyte",
                "Joseph Gleason \u2448"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 30919
        }
    },
    {
        "title": "[bitcoin-dev] How much is too much time between difficulty changes?",
        "thread_messages": [
            {
                "author": "Dave Scotese",
                "date": "2018-12-03T20:37:17",
                "message_text_only": "The last difficulty change took about 20% longer than expected.  How large\ndoes the time between difficulty changes have to get for us to make\nchanges?  In other words, if, at some point, block confirmation times are\naveraging, say, hours or days, will we hardfork to speed things up?\n\nOne option is NO.  When enough economic interests align to amass the\ncomputing power to get important bitcoin transactions into a block, then\nthey will work out a way to get that block confirmed.  This allows other\ncryptocurrencies and technologies like LN to fill in.\n\nThere may be a group that will fork the code in order to adjust the\ndifficulty more rapidly, and bitcoin holders will put a value on\nbitcoin-FDA (\"Faster-Difficuly-Adjustment\"), which is fine with me.  We can\nlearn how to fork peacefully from what we learned when BCH was born, and\nwhat we learned when it split.\n\nI think some insight into how core developers will handle increasing\ndemands to use faster difficulty adjustments (if they respond at all) will\nbe helpful, and this is why I'm asking.\n\nDave Scotese\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181203/9ca5ce6b/attachment-0001.html>"
            },
            {
                "author": "Zawy",
                "date": "2018-12-05T14:08:56",
                "message_text_only": "It's possible to let the difficulty linearly drop as the solvetime\ngoes beyond some limit (credit AS). If the limit is greater than any\ndelay in the past it could be backwards-compatible.\n\nA simple daily-rolling average DA like BCH is probably the best option\nif a faster DA is ever needed.\n\nAs a point of research interest (not likely to be needed by BTC), I've\ntaken the first above idea of \"intra-block\" timestamp-based difficulty\nadjustment to the limit and made it symmetrical (higher D for fast\nsolves) and continuous. The result is a \"tightening of the Poisson\"\nthat increases \"availability\" (predictable solution times) at an\nexpense in \"consistency\" (orphans). It requires a very tight future\ntime limit to reduce timestamp manipulation. My objective was to help\nsmall coins deal with persistent 20x hash rate changes that result in\nlong delays. About 3 coins have it on testnet.\nhttps://github.com/zawy12/difficulty-algorithms/issues/36"
            }
        ],
        "thread_summary": {
            "title": "How much is too much time between difficulty changes?",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Dave Scotese",
                "Zawy"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2201
        }
    },
    {
        "title": "[bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT",
        "thread_messages": [
            {
                "author": "Russell O'Connor",
                "date": "2018-12-06T16:57:09",
                "message_text_only": "One more item to consider is \"signature covers witness weight\".\n\nWhile signing the witness weight doesn't completely eliminate witness\nmalleability (of the kind that can cause grief for compact blocks), it does\neliminate the worst kind of witness malleability from the user's\nperspective, the kind where malicious relay nodes increase the amount of\nwitness data and therefore reduce the overall fee-rate of the transaction.\nGenerally users should strive to construct their Bitcoin Scripts in such a\nway that witness malleability isn't possible, but as you are probably\naware, this can be quite difficult to achieve as Scripts become more\ncomplex and maybe isn't even possible for some complex Scripts.\n\nGiven the new fixed-sized signature of the Schnorr BIP, it becomes much\neasier to compute the final witness weight prior to signing.  In complex\nmulti-party signing protocol, the final witness weight might not be known\nat signing time for everyone involved, so the \"signature covers witness\nweight\" ought to be optional.\n\n\nOn Tue, Nov 27, 2018 at 11:59 PM Pieter Wuille via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Mon, 19 Nov 2018 at 14:37, Pieter Wuille <pieter.wuille at gmail.com>\n> wrote:\n> > Here is a combined proposal:\n> > * Three new sighash flags are added: SIGHASH_NOINPUT, SIGHASH_NOFEE, and\n> SIGHASH_SCRIPTMASK.\n> > * A new opcode OP_MASK is added, which acts as a NOP during execution.\n> > * The sighash is computed like in BIP143, but:\n> >   * If SIGHASH_SCRIPTMASK is present, for every OP_MASK in scriptCode\n> the subsequent opcode/push is removed.\n> >   * The scriptPubKey being spent is added to the sighash, unless\n> SIGHASH_SCRIPTMASK is set.\n> >   * The transaction fee is added to the sighash, unless SIGHASH_NOFEE is\n> set.\n> >   * hashPrevouts, hashSequence, and outpoint are set to null when\n> SIGHASH_NOINPUT is set (like BIP118, but not for scriptCode).\n>\n> Thanks for all the input so far. Going over the suggestions and other\n> ideas:\n>\n> * OP_MASK should be required to be followed by a push, as suggested by\n> Anthony Towns. The alternative would permit substituting arbitrary\n> opcodes for masked pushes, which is at least very hard to reason\n> about. This would effectively turn it into a multi-byte OP_MASKEDPUSH\n> opcode.\n>\n> * It's probably better to sign the amounts of all inputs, as suggested\n> by Johnson Lau. As that would cause default sighashes to sign all\n> input and output amounts, is there still a need to sign the tx fee\n> explicitly? Or in other words, are there situations where changing the\n> set of inputs or outputs after signing is desired, but the net\n> difference between them cannot change? If not, that would remove the\n> need for NOFEE.\n>\n> * Do we need to keep the rule that sequence values of other inputs are\n> only signed with default sighash? It feels cleaner to always sign the\n> sequence values of all inputs that are included in the sighash anyway\n> (so all of them, unless ANYONECANPAY or NOINPUT, which would make it\n> sign only the current input's sequence value). If NOINPUT also blanks\n> the sequence values (as currently specified by BIP118), and all input\n> amounts are signed, that would make amounts/sequence values always be\n> treated identically.\n>\n> * If MASK implies NOINPUT, and NOINPUT implies ANYONECANPAY, the 3 of\n> them can be encoded in just 2 bits using the\n> PARTIALSCRIPT/KNOWNSCRIPT/KNOWNTX/ALL_INPUTS encoding Anthony Towns\n> suggested.\n>\n> * Regarding the discussion about preventing signatures from being\n> rebound to a different script(path)/checksig:\n>   * With MAST there is indeed less need for this, but at least\n> single-tree MAST constructions cannot replace all script branches (a\n> script with 40 IF/THEN/ELSE constructions may have 2^40 different\n> execution paths, for which computing a Merkle tree is intractable).\n>   * Just signing the opcode position of the CHECKSIG operator isn't\n> enough for all cases either. For example, you could have a complex\n> nested set of branches that puts a number of pubkeys on the stack, and\n> then a CHECKMULTISIG after the last ENDIF to verify all of them. In\n> such a situation, if the same key can occur in multiple combinations,\n> you still may want to prevent a signature generated for one\n> combination from being rebindable to the same key in another\n> combination. I believe that signing the opcode position plus the\n> true/false condition of all previous(?) IF statements is probably\n> sufficient to achieve that, but it would also introduce unnecessary\n> complexity for signers in most cases (see next point).\n>   * Thinking about signing code, adding these sort of execution trace\n> commitments to the sighash means they need to know which checksig\n> operator etc. they are signing for. I believe that in practice for\n> example HW devices will just whatever position the wallet indicated,\n> rather than verifying it corresponds with a particular intended code\n> path. Preventing rebinding isn't very useful if an attacker can make\n> you bind to the wrong thing regardless, so I'm not convinced this is\n> even worth having by default.\n>   * An alternative (not sure who suggested it) is to simply make every\n> CHECKSIG sign the opcode position of the last executed CODESEPARATOR\n> (and remove the earlier cut-of-scriptCode effect of CODESEPARATOR).\n> This gives a simple (but somewhat limited) way for scripts that need\n> to prevent certain kinds of cross-execution-trace rebinding.\n>\n> A few misc ideas:\n> * (Taken from\n> https://github.com/jl2012/bips/blob/sighash2/bip-sighash2.mediawiki)\n> For a default sign-everything sighash, the sighash byte can be\n> dropped.\n> * For the commitments to the scriptPubKey and scriptCode, an\n> intermediary hash should be used (so the data included in the sighash\n> includes a hash of those, rather than the script directly). This\n> prevents a blow up in hashing time for large scripts with many\n> different sighash types in its signatures.\n> * When masking the scriptCode, the push opcode immediately following\n> OP_MASKEDPUSH can be replaced by OP_VERIF (which will never collide\n> with any real script, as OP_VERIF makes a script invalid even when\n> occurring in an unexecuted branch).\n> * Sighashes (and really all new hashes that are introduced) should be\n> prefixed with a fixed 64-byte array as \"tag\", chosen to not collide\n> with any existing use of SHA256 in Bitcoin, to prevent signatures from\n> being re-interpretable as something else. Picking 64 bytes as tag size\n> means it can be efficiently implemented as just a modified SHA256 IV.\n>\n> So a combined proposal:\n> * All existing sighash flags, plus NOINPUT and MASK\n> (ANYONECANPAY/NOINPUT/MASK are encoded in 2 bits).\n> * A new opcode called OP_MASKEDPUSH, whose only runtime behaviour is\n> failing if not immediately followed by a push, or when appearing as\n> last opcode in the script.\n> * Signatures are 64 plus an optional sighash byte. A missing sighash\n> byte implies ALL, and ALL cannot be specified explicitly.\n> * The sighash is computed from the following:\n>   * A 64-byte constant tag\n>   * Data about the spending transaction:\n>     * The transaction version number\n>     * The hash of txins' prevouts+amounts+sequences (or nothing if\n> ANYONECANPAY)\n>     * The hash of all txouts (or just the corresponding txout if\n> SINGLE; nothing if NONE)\n>     * The transaction locktime\n>   * Data about the output being spent:\n>     * The prevout (or nothing if NOINPUT)\n>     * The amount\n>     * The sequence number\n>     * The hash of the scriptPubKey (or nothing if MASK)\n>   * Data about the script being executed:\n>     * The hash of the scriptCode (after masking out, if MASK is set)\n>     * The opcode number of the last executed OP_CODESEPARATOR (or\n> 0xFFFFFFFF if none)\n>   * The sighash mode\n>\n> Cheers,\n>\n> --\n> Pieter\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181206/49fae6ab/attachment.html>"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-12-09T19:13:34",
                "message_text_only": "The current proposal is that a 64-byte signature will be used for the default \u201csigning all\u201d sighash, and 65-byte for other sighash types. The space saved will allow a few more txs in a block, so I think it worths doing. However, this also makes witness weight estimation more difficult in multisig cases.\n\nThis idea of signing witness weight has been brought up before. I think the concern is the difficulty to estimate the witness weight for complex scripts, which need this feature most. So it will work when it is not needed, and will not work when it is needed.\n\nIs there any script example that witness size malleability is unavoidable?\n\n> On 7 Dec 2018, at 12:57 AM, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> One more item to consider is \"signature covers witness weight\".\n> \n> While signing the witness weight doesn't completely eliminate witness malleability (of the kind that can cause grief for compact blocks), it does eliminate the worst kind of witness malleability from the user's perspective, the kind where malicious relay nodes increase the amount of witness data and therefore reduce the overall fee-rate of the transaction.  Generally users should strive to construct their Bitcoin Scripts in such a way that witness malleability isn't possible, but as you are probably aware, this can be quite difficult to achieve as Scripts become more complex and maybe isn't even possible for some complex Scripts.\n> \n> Given the new fixed-sized signature of the Schnorr BIP, it becomes much easier to compute the final witness weight prior to signing.  In complex multi-party signing protocol, the final witness weight might not be known at signing time for everyone involved, so the \"signature covers witness weight\" ought to be optional.\n> \n>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2018-12-11T22:50:24",
                "message_text_only": "On Sun, Dec 9, 2018 at 2:13 PM Johnson Lau <jl2012 at xbt.hk> wrote:\n\n> The current proposal is that a 64-byte signature will be used for the\n> default \u201csigning all\u201d sighash, and 65-byte for other sighash types. The\n> space saved will allow a few more txs in a block, so I think it worths\n> doing. However, this also makes witness weight estimation more difficult in\n> multisig cases.\n>\n> This idea of signing witness weight has been brought up before. I think\n> the concern is the difficulty to estimate the witness weight for complex\n> scripts, which need this feature most. So it will work when it is not\n> needed, and will not work when it is needed.\n>\n> Is there any script example that witness size malleability is unavoidable?\n>\n\nI tend to think in opposite terms. Is there a proof that any script can be\ntransformed into an equivalent one that avoids witness weight\nmalleability?   But I admit there is a trade off:  If we don't allow for\nsignature covers weight, and we do need it, it will be too late to add.  On\nthe other hand if we add signature covers weight, but it turns out that no\nScript ever needs to use it, then we've added that software complexity for\nno gain.  However, I think the software complexity is relatively low,\nmaking it worthwhile.\n\nMoreover, even if witness weight malleability is entirely avoidable, it\nalways seems to come at a cost.  Taking as an example libwally's proposed \"\n<https://github.com/ElementsProject/libwally-core/blob/c6db6ccdfa54571afeeb582919240263424736a2/src/script.c#L718-L735>csv_2of3_then_2\"\nScript\n<https://github.com/ElementsProject/libwally-core/blob/c6db6ccdfa54571afeeb582919240263424736a2/src/script.c#L718-L735>,\nit begins with \"OP_DEPTH OP_1SUB OP_1SUB\" spending 3 vbytes to avoid any\npossible witness malleability versus just taking a witness stack item to\ndetermine the branch, costing 1 or 2 (unmalleated) vbytes.  Now to be fair,\nunder Taproot this particular script's witness malleability problem\nprobably goes away.  Nonetheless, I think it is fair to say that Bitcoin\nScript was designed without any regard given to scriptSig/witness\nmalleability concerns and the result is that one is constantly fighting\nagainst malleability issues.  Short of a wholesale replacement of Bitcoin\nScript, I do think that having an option for signature covers weight is one\nof the best ways to address the whole problem.\n\nRegarding your point about 64/65-byte signatures; I speculate that in most\nprotocols, all parties that are able to consider signing the weight, know\nwhat sighash flags the other parties are expected to be using.  However,\nyour point is well-taken, and if we choose to adopt the option of\nsignatures covering weight, we ought to make sure there exists a 65-byte\nsignature that performs the equivalent of a sigHashAll (of course, still\ncovering that particular sighash flag under the signature), to ensure that\nanti-weight-malleability can be use even when the sighash flags that other\nparties will use are unknown.  Even with the extra vbytes in the\nsignatures, there may be a net weight savings by avoiding the need for\nanti-malleability Script code. (It might also be reasonable to have\nparticipants create signatures for a small range of different weight\nvalues? (Sorry in advance to PSBT)).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181211/1f119c76/attachment.html>"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-12-12T19:53:38",
                "message_text_only": "> On 12 Dec 2018, at 6:50 AM, Russell O'Connor <roconnor at blockstream.io> wrote:\n> \n> On Sun, Dec 9, 2018 at 2:13 PM Johnson Lau <jl2012 at xbt.hk <mailto:jl2012 at xbt.hk>> wrote:\n> The current proposal is that a 64-byte signature will be used for the default \u201csigning all\u201d sighash, and 65-byte for other sighash types. The space saved will allow a few more txs in a block, so I think it worths doing. However, this also makes witness weight estimation more difficult in multisig cases.\n> \n> This idea of signing witness weight has been brought up before. I think the concern is the difficulty to estimate the witness weight for complex scripts, which need this feature most. So it will work when it is not needed, and will not work when it is needed.\n> \n> Is there any script example that witness size malleability is unavoidable?\n> \n> I tend to think in opposite terms. Is there a proof that any script can be transformed into an equivalent one that avoids witness weight malleability?   But I admit there is a trade off:  If we don't allow for signature covers weight, and we do need it, it will be too late to add.  On the other hand if we add signature covers weight, but it turns out that no Script ever needs to use it, then we've added that software complexity for no gain.  However, I think the software complexity is relatively low, making it worthwhile.\n> \n> Moreover, even if witness weight malleability is entirely avoidable, it always seems to come at a cost.  Taking as an example libwally's proposed \" <https://github.com/ElementsProject/libwally-core/blob/c6db6ccdfa54571afeeb582919240263424736a2/src/script.c#L718-L735>csv_2of3_then_2\" Script <https://github.com/ElementsProject/libwally-core/blob/c6db6ccdfa54571afeeb582919240263424736a2/src/script.c#L718-L735>, it begins with \"OP_DEPTH OP_1SUB OP_1SUB\" spending 3 vbytes to avoid any possible witness malleability versus just taking a witness stack item to determine the branch, costing 1 or 2 (unmalleated) vbytes.  Now to be fair, under Taproot this particular script's witness malleability problem probably goes away.  Nonetheless, I think it is fair to say that Bitcoin Script was designed without any regard given to scriptSig/witness malleability concerns and the result is that one is constantly fighting against malleability issues.  Short of a wholesale replacement of Bitcoin Script, I do think that having an option for signature covers weight is one of the best ways to address the whole problem.\n> \n> Regarding your point about 64/65-byte signatures; I speculate that in most protocols, all parties that are able to consider signing the weight, know what sighash flags the other parties are expected to be using.  However, your point is well-taken, and if we choose to adopt the option of signatures covering weight, we ought to make sure there exists a 65-byte signature that performs the equivalent of a sigHashAll (of course, still covering that particular sighash flag under the signature), to ensure that anti-weight-malleability can be use even when the sighash flags that other parties will use are unknown.  Even with the extra vbytes in the signatures, there may be a net weight savings by avoiding the need for anti-malleability Script code. (It might also be reasonable to have participants create signatures for a small range of different weight values? (Sorry in advance to PSBT)).\n\nI think the root cause of witness weight malleability is some opcodes accept variable size input (without affecting the output), and that input is provided by the puzzle solver. Going through the opcode list, I think such opcodes include IF, NOTIF, VERIFY, DROP, 2DROP, NIP, DEPTH, and all arithmetic opcode that accepts CScriptNum (including CHECKMULTISIG)\n\nVERIFY, DROP, 2DROP, NIP are not real problem, since they should not be the first opcode to interact with data directly provided by the puzzle solver.\n\nCHECKMULTISIG is fixed by BIP147. For the key number and sig number, they should be part of the script, so not malleable.\n\nDEPTH is a problem only if its inputs are not later examined by other opcodes. Again, this is pointless.\n\nThe liberally example should be protected by the MINIMAL_IF policy, which requires the input of OP_IF be minimal. As you note, OP_IF could be replaced by taproot in many cases\n\nNon-minimal CScriptNum is also banned as BIP62 policy.\n\nFor the purpose of preventing malicious third party witness bloating, all we need is the miners to enforce the policy. There is no reason for miners to accept size malleated txs, as that will reduce the usable block space. If they hate a tx, they would simply drop it, instead of wasting the block space.\n\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181213/a18091cd/attachment-0001.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2018-12-13T16:50:10",
                "message_text_only": "On Wed, Dec 12, 2018 at 2:53 PM Johnson Lau <jl2012 at xbt.hk> wrote:\n\n>\n> I think the root cause of witness weight malleability is some opcodes\n> accept variable size input (without affecting the output), and that input\n> is provided by the puzzle solver. Going through the opcode list, I think\n> such opcodes include IF, NOTIF, VERIFY, DROP, 2DROP, NIP, DEPTH, and all\n> arithmetic opcode that accepts CScriptNum (including CHECKMULTISIG)\n>\n> VERIFY, DROP, 2DROP, NIP are not real problem, since they should not be\n> the first opcode to interact with data directly provided by the puzzle\n> solver.\n>\n> CHECKMULTISIG is fixed by BIP147. For the key number and sig number, they\n> should be part of the script, so not malleable.\n>\n> DEPTH is a problem only if its inputs are not later examined by other\n> opcodes. Again, this is pointless.\n>\n> The liberally example should be protected by the MINIMAL_IF policy, which\n> requires the input of OP_IF be minimal. As you note, OP_IF could be\n> replaced by taproot in many cases\n>\n> Non-minimal CScriptNum is also banned as BIP62 policy.\n>\n> For the purpose of preventing malicious third party witness bloating, all\n> we need is the miners to enforce the policy. There is no reason for miners\n> to accept size malleated txs, as that will reduce the usable block space.\n> If they hate a tx, they would simply drop it, instead of wasting the block\n> space.\n>\n\nI don't know if it such a clear cut case for miner's policy.  A miner is\npassed a malleated tx.  They know that there is probably a non-malleated\nvariant floating around out there somewhere, and they would rather have\nit.  But right now they don't, and they probably not going to try to\nunmalleate it themselves.  So, why not stick it into their mempool?  If it\neventually makes it into one of their blocks, then it will because it has\nthe best fee rate available, and to reject it outright is harmful to their\nbottom line.  If they find the non-malleated variant later, great, they can\nreplace it and gain a higher-fee rate tx.  Of course, such a policy opens\nthem up to a Denial of Service attack.\n\nSo what do they do?  Do they accept malleated tx's and implement an RBF\npolicy that requires sufficient fee rate increases?  Do they reject\nmalleated txs outright to avoid falling in this trap in the first place as\nyou suggest?  I don't know, but I don't think things are as clear cut as\nyou present.\n\n\nThat aside, your list of weight malleable opcodes is shorter than I\nimagined and I'm grateful you've compiled it.  Perhaps the best solution is\nto make MINIMAL_IF and minimal CScriptNum consensus enforced in the next\nversion of Script and all but eliminate weight malleability in practice?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181213/b5787537/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2018-12-13T00:05:53",
                "message_text_only": "On Tue, Dec 11, 2018 at 05:50:24PM -0500, Russell O'Connor via bitcoin-dev wrote:\n> On Sun, Dec 9, 2018 at 2:13 PM Johnson Lau <jl2012 at xbt.hk> wrote:\n>     The current proposal is that a 64-byte signature will be used for the\n>     default \u201csigning all\u201d sighash, and 65-byte for other sighash types. The\n>     space saved will allow a few more txs in a block, so I think it worths\n>     doing. However, this also makes witness weight estimation more difficult in\n>     multisig cases.\n\nThis seems strange to me -- why wouldn't you just assume every signature\nis 65 witness bytes, and just be grateful for the prioritisation benefit\nif someone chooses a shorter signature? Your error margin is just 0.25\nvbytes per signature.\n\n> I tend to think in opposite terms. Is there a proof that any script can be\n> transformed into an equivalent one that avoids witness weight malleability?\n\nAn alternative generalisation: is there a proof that all valid witnesses\nwill have a weight within some small range?\n\n> Moreover, even if witness weight malleability is entirely avoidable, it always\n> seems to come at a cost.\u00a0 Taking as an example libwally's proposed \"\n> csv_2of3_then_2\" Script, it begins with \"OP_DEPTH OP_1SUB OP_1SUB\"\n\n(DEPTH 2 NUMNOTEQUAL seems like it would have been more obvious...)\n\nCheers,\naj"
            },
            {
                "author": "Russell O'Connor",
                "date": "2018-12-13T16:21:10",
                "message_text_only": "On Wed, Dec 12, 2018 at 7:06 PM Anthony Towns <aj at erisian.com.au> wrote:\n\n> On Tue, Dec 11, 2018 at 05:50:24PM -0500, Russell O'Connor via bitcoin-dev\n> wrote:\n> > On Sun, Dec 9, 2018 at 2:13 PM Johnson Lau <jl2012 at xbt.hk> wrote:\n> >     The current proposal is that a 64-byte signature will be used for the\n> >     default \u201csigning all\u201d sighash, and 65-byte for other sighash types.\n> The\n> >     space saved will allow a few more txs in a block, so I think it\n> worths\n> >     doing. However, this also makes witness weight estimation more\n> difficult in\n> >     multisig cases.\n>\n> This seems strange to me -- why wouldn't you just assume every signature\n> is 65 witness bytes, and just be grateful for the prioritisation benefit\n> if someone chooses a shorter signature? Your error margin is just 0.25\n> vbytes per signature.\n>\n\nThe issue is that the proposal is to sign the actual weight, rather than\nsign an upper bound on the weight.\nThe problem with signing an upper bound, is that you need to specify that\nupper bound someplace in the transaction, and we are out of sneaky places\nto stash that data.\nSigning the actual weight is easy because the total weight is implicit, but\nnow you need to know the total weight before signing.\n\n\n> > I tend to think in opposite terms. Is there a proof that any script can\n> be\n> > transformed into an equivalent one that avoids witness weight\n> malleability?\n>\n> An alternative generalisation: is there a proof that all valid witnesses\n> will have a weight within some small range?\n>\n> > Moreover, even if witness weight malleability is entirely avoidable, it\n> always\n> > seems to come at a cost.  Taking as an example libwally's proposed \"\n> > csv_2of3_then_2\" Script, it begins with \"OP_DEPTH OP_1SUB OP_1SUB\"\n>\n> (DEPTH 2 NUMNOTEQUAL seems like it would have been more obvious...)\n>\n> I think the 1SUB idea was derived from the csv_2of2_then_1 Script where\nDEPTH 1SUB is shorter than DEPTH 1 NUMNOTEQUAL.\n\n\n> Cheers,\n> aj\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181213/f03327b9/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2018-12-14T00:47:29",
                "message_text_only": "On Thu, Dec 13, 2018 at 11:21:10AM -0500, Russell O'Connor wrote:\n> On Wed, Dec 12, 2018 at 7:06 PM Anthony Towns <aj at erisian.com.au> wrote:\n>     On Tue, Dec 11, 2018 at 05:50:24PM -0500, Russell O'Connor via bitcoin-dev\n>     wrote:\n>     > On Sun, Dec 9, 2018 at 2:13 PM Johnson Lau <jl2012 at xbt.hk> wrote:\n>     >\u00a0 \u00a0 \u00a0The current proposal is that a 64-byte signature will be used for the\n>     >\u00a0 \u00a0 \u00a0default \u201csigning all\u201d sighash, and 65-byte for other sighash types.\n>     The\n>     >\u00a0 \u00a0 \u00a0space saved will allow a few more txs in a block, so I think it\n>     worths\n>     >\u00a0 \u00a0 \u00a0doing. However, this also makes witness weight estimation more\n>     difficult in\n>     >\u00a0 \u00a0 \u00a0multisig cases.\n>     This seems strange to me -- why wouldn't you just assume every signature\n>     is 65 witness bytes, and just be grateful for the prioritisation benefit\n>     if someone chooses a shorter signature? Your error margin is just 0.25\n>     vbytes per signature.\n> The issue is that the proposal is to sign the actual weight, rather than sign\n> an upper bound on the weight.\n\nSorry, I elided some of my reasoning. Suppose witness data wasn't\nmalleable; in that case any valid witness for a particular script would\nhave the exact same weight, and it would be good enough to just sign\nthe script, because that also commits to the witness weight. (And if\nyou're doing SIGHASH_ALL, you're committing to the exact transaction\nweight too)\n\nI think the benefit of signing the weight is mostly that it also commits\nto the feerate and hence transaction priority: you know how much you're\npaying in fees when you sign, but the reason you're paying any fees is\nto get a particular priority for your transaction, so if that can change\nfrom under you because the tx weight changes, you're being ripped off\n(either because you get less priority than you were paying for, or\nbecause you get more than you wanted and would have paid less if you'd\nknown).\n\nBut if, just from looking at the script, you can be sure the witness\nweight will be between \"w\" and \"w + 0.8%\" and your fee is \"f\", you\nknow your feerate (and hence priority) is between \"f/w - 0.8%\" and\n\"f/w\". If the \"0.8%\" is small enough, that's just a rounding error and\nyou probably have more uncertainty in your feerate estimations anyway. So\nI think at that point it's reasonable to target the lower bound feerate\n(\"f/w - 0.8%\"), because your only potential loss is that you get a higher\nfeerate and would have saved \"0.8%\" on f if you'd been able to be 100%\nsure of that.\n\n> The problem with signing an upper bound, is that you need to specify that upper\n> bound someplace in the transaction, and we are out of sneaky places to stash\n> that data.\n> Signing the actual weight is easy because the total weight is implicit, but now\n> you need to know the total weight before signing.\n\nThe cases where the tx is malleable by someone else, and you know what\nthe weight should be in advance, and you can't take the final tx once it\nhits your mempool and fix the weight to what it should be and\nrebroadcast, seem limited to me?\n\nBeing able to commit to a minimum feerate seems like it would be more\ngenerally useful: it would apply for ANYONECANPAY crowd-funding type\ntxes as well; \"here's my input, and I'm paying 3 sat/vb feerate, but only\nif everyone else does too!\". You could do that, I think, with a rule\nalong the lines of:\n\n  (a) take the actual tx feerate, f*4000/w\n  (b) round it down to the nearest exponent of 1.05 sat/kvbyte,\n      so 1.3 sat/vbyte becomes 1240.62 (1.05**146 < 1.05**147=1302)\n  (c) if the signature doesn't have an extra byte, then it should\n      commit to that exponent (146)\n  (d) if the signature does have an extra byte, b, then b<=146 and\n      the signature should commit to 146-(1+b)\n\nThat way if you sign something that says \"minimum fee rate of 0.001 sat\nper vbyte\", you commit to an exponent of 0, and someone else can raise the\nfeerate anywhere up to 265.7 sat/vb just by tweaking your signature to\nindicate how much they've raised the feerate. Likewise you could commit\nto some other exponent, and anyone else could adjust your signature to\nremain valid for a tx with a feerate of up to 265,742 times greater than\nwhat you expected, but never more than 5% less than what you expected.\n\nThis seems too complicated to do any time soon; and maybe more\ncomplicated than will ever be worthwhile, though.\n\nCheers,\naj"
            },
            {
                "author": "David A. Harding",
                "date": "2018-12-09T22:41:57",
                "message_text_only": "On Thu, Dec 06, 2018 at 11:57:09AM -0500, Russell O'Connor via bitcoin-dev wrote:\n> One more item to consider is \"signature covers witness weight\".\n> \n> While signing the witness weight doesn't completely eliminate witness\n> malleability (of the kind that can cause grief for compact blocks), it does\n> eliminate the worst kind of witness malleability from the user's\n> perspective, the kind where malicious relay nodes increase the amount of\n> witness data and therefore reduce the overall fee-rate of the transaction.\n\nTo what degree is this an actual problem?  If the mutated transaction\npays a feerate at least incremental-relay-fee[1] below the original\ntransaction, then the original transaction can be rebroadcast as an RBF\nreplacement of the mutated transaction (unless the mutated version has\nbeen pinned[2]).\n\n-Dave\n\n[1] $ bitcoind -help-debug | grep -A2 incremental\n  -incrementalrelayfee=<amt>\n       Fee rate (in BTC/kB) used to define cost of relay, used for mempool\n       limiting and BIP 125 replacement. (default: 0.00001)\n\n[2] https://bitcoin.stackexchange.com/questions/80803/what-is-meant-by-transaction-pinning\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181209/7ae94da5/attachment.sig>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2018-12-11T15:36:59",
                "message_text_only": "I don't believe that the default RBF policy works that way.  My\nunderstanding is that current policy requires an absolute fee increase (by\nan amount related to incrementalrelayfee).  There have been proposals to\nchange default RBF policy, however even my proposal <\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015717.html>\nstill requires a minimal amount of absolute fee increase as a DoS defense.\n\n(I'm reading your comment as attempting to rebroadcast the original\ntransaction with the same fee amount, with its relatively higher fee-rate).\n\nOn Mon, Dec 10, 2018 at 10:00 AM David A. Harding <dave at dtrt.org> wrote:\n\n> On Thu, Dec 06, 2018 at 11:57:09AM -0500, Russell O'Connor via bitcoin-dev\n> wrote:\n> > One more item to consider is \"signature covers witness weight\".\n> >\n> > While signing the witness weight doesn't completely eliminate witness\n> > malleability (of the kind that can cause grief for compact blocks), it\n> does\n> > eliminate the worst kind of witness malleability from the user's\n> > perspective, the kind where malicious relay nodes increase the amount of\n> > witness data and therefore reduce the overall fee-rate of the\n> transaction.\n>\n> To what degree is this an actual problem?  If the mutated transaction\n> pays a feerate at least incremental-relay-fee[1] below the original\n> transaction, then the original transaction can be rebroadcast as an RBF\n> replacement of the mutated transaction (unless the mutated version has\n> been pinned[2]).\n>\n> -Dave\n>\n> [1] $ bitcoind -help-debug | grep -A2 incremental\n>   -incrementalrelayfee=<amt>\n>        Fee rate (in BTC/kB) used to define cost of relay, used for mempool\n>        limiting and BIP 125 replacement. (default: 0.00001)\n>\n> [2]\n> https://bitcoin.stackexchange.com/questions/80803/what-is-meant-by-transaction-pinning\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181211/ba277d2d/attachment.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2018-12-11T17:47:24",
                "message_text_only": "On Tue, Dec 11, 2018 at 10:36:59AM -0500, Russell O'Connor wrote:\n> I don't believe that the default RBF policy works that way.  My\n> understanding is that current policy requires an absolute fee increase (by\n> an amount related to incrementalrelayfee).  \n\nIndeed, you are correct (BIP125 rule 4[1]).\n\nThanks for the correction,\n\n-Dave\n\n[1] For the curious, the relevant code from master's validation.cpp:\n\n    // Finally in addition to paying more fees than the conflicts the\n    // new transaction must pay for its own bandwidth.\n    CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n    if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n    {\n        return state.DoS(0, false,\n                REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n                      hash.ToString(),\n                      FormatMoney(nDeltaFees),\n                      FormatMoney(::incrementalRelayFee.GetFee(nSize))));\n    }\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181211/20ba89d0/attachment.sig>"
            },
            {
                "author": "Rusty Russell",
                "date": "2018-12-12T09:42:10",
                "message_text_only": "Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:\n> Here is a combined proposal:\n> * Three new sighash flags are added: SIGHASH_NOINPUT, SIGHASH_NOFEE,\n> and SIGHASH_SCRIPTMASK.\n> * A new opcode OP_MASK is added, which acts as a NOP during execution.\n> * The sighash is computed like in BIP143, but:\n>   * If SIGHASH_SCRIPTMASK is present, for every OP_MASK in scriptCode\n> the subsequent opcode/push is removed.\n\nI'm asking on-list because I'm sure I'm not the only confused one.\n\nHaving the SIGHASH_SCRIPTMASK flag is redundant AFAICT: why not always\nperform mask-removal for signing?\n\nIf you're signing arbitrary scripts, you're surely in trouble already?\n\nAnd I am struggling to understand the role of scriptmask in a taproot\nworld, where the alternate script is both hidden and general?\n\nI look forward to learning what I missed!\nRusty."
            },
            {
                "author": "Johnson Lau",
                "date": "2018-12-12T20:00:50",
                "message_text_only": "> On 12 Dec 2018, at 5:42 PM, Rusty Russell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:\n>> Here is a combined proposal:\n>> * Three new sighash flags are added: SIGHASH_NOINPUT, SIGHASH_NOFEE,\n>> and SIGHASH_SCRIPTMASK.\n>> * A new opcode OP_MASK is added, which acts as a NOP during execution.\n>> * The sighash is computed like in BIP143, but:\n>>  * If SIGHASH_SCRIPTMASK is present, for every OP_MASK in scriptCode\n>> the subsequent opcode/push is removed.\n> \n> I'm asking on-list because I'm sure I'm not the only confused one.\n> \n> Having the SIGHASH_SCRIPTMASK flag is redundant AFAICT: why not always\n> perform mask-removal for signing?\n\nBecause a hardware wallet may want to know what exact script it is signing?\n\nMasked script has reduced security, but this is a tradeoff with functionality (e.g. eltoo can\u2019t work without masking part of the script). So when you don\u2019t need that extra functionality, you go back to better security\n\nHowever, I\u2019m not sure if there is any useful NOINPUT case with unmasked script.\n\n> \n> If you're signing arbitrary scripts, you're surely in trouble already?\n> \n> And I am struggling to understand the role of scriptmask in a taproot\n> world, where the alternate script is both hidden and general?\n\nIt makes sure that your signature is applicable to a specific script branch, not others (assuming you use the same pubkey in many branches, which is avoidable)\n\n> \n> I look forward to learning what I missed!\n> Rusty.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Rusty Russell",
                "date": "2018-12-12T23:49:02",
                "message_text_only": "Johnson Lau <jl2012 at xbt.hk> writes:\n>> On 12 Dec 2018, at 5:42 PM, Rusty Russell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> \n>> Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:\n>>> Here is a combined proposal:\n>>> * Three new sighash flags are added: SIGHASH_NOINPUT, SIGHASH_NOFEE,\n>>> and SIGHASH_SCRIPTMASK.\n>>> * A new opcode OP_MASK is added, which acts as a NOP during execution.\n>>> * The sighash is computed like in BIP143, but:\n>>>  * If SIGHASH_SCRIPTMASK is present, for every OP_MASK in scriptCode\n>>> the subsequent opcode/push is removed.\n>> \n>> Having the SIGHASH_SCRIPTMASK flag is redundant AFAICT: why not always\n>> perform mask-removal for signing?\n>\n> Because a hardware wallet may want to know what exact script it is signing?\n\nOK, removing OP_MASKs unconditionally would introduce a hole without\nsome explicit flag to say they've been removed (the \"real script\" could\nbe something different with OP_MASKs).  We could have the signature\ncommit to the outputscript, but that's a bit meh.\n\n> Masked script has reduced security, but this is a tradeoff with\n> functionality (e.g. eltoo can\u2019t work without masking part of the\n> script). So when you don\u2019t need that extra functionality, you go back\n> to better security\n>\n> However, I\u2019m not sure if there is any useful NOINPUT case with unmasked script.\n\nThis is *not* true of Eltoo; the script itself need not change for the\nrebinding (Christian, did something change?).\n\nSo, can we find an example where OP_MASK is useful?\n\n>> If you're signing arbitrary scripts, you're surely in trouble already?\n>> \n>> And I am struggling to understand the role of scriptmask in a taproot\n>> world, where the alternate script is both hidden and general?\n>\n> It makes sure that your signature is applicable to a specific script branch, not others (assuming you use the same pubkey in many branches, which is avoidable)\n\nIf I'm using SIGHASH_NOINPUT, I'm already required to take care with key\nreuse.\n\nWithout a concrete taproot proposal it's hard to make assertions, but\nif the signature flags that it's using the taproot script, it's\nno less safe, and more general AFAICT.\n\nThanks!\nRusty."
            },
            {
                "author": "Rusty Russell",
                "date": "2018-12-13T00:37:28",
                "message_text_only": "Rusty Russell <rusty at rustcorp.com.au> writes:\n>> However, I\u2019m not sure if there is any useful NOINPUT case with unmasked script.\n>\n> This is *not* true of Eltoo; the script itself need not change for the\n> rebinding (Christian, did something change?).\n\nThis is wrong, sorry.  I re-checked the paper, and the constant for the\ntimelock comparison changes on each new update.\n\n(The alternative was a new opcode like OP_TIMELOCKGREATERVERIFY which\nrequired remembering the nLocktime for the UTXO).\n\nSo now my opinion is closer to yours: what's the use for NOINPUT &&\n!NOMASK?\n\nAnd is it worthwhile doing the mask complexity, rather than just\nremoving the commitment to script with NOINPUT?  It *feels* safer to\nrestrict what scripts we can sign, but is it?\n\nNote that NOINPUT is only useful when you can't just re-sign the tx, and\nyou need to be able to create a new tx even if this input is spent once\n(an attacker can do this with SIGHASH_MASK or not!).  ie. any other\ninputs need to be signed NOINPUT or this one\nSIGHASH_SINGLE|ANYONECANPAY.\n\nYou already need both key-reuse and amount-reuse to be exploited.\nSIGHASH_MASK only prevents you from reusing this input for a \"normal\"\noutput; if you used this key for multiple scripts of the same form,\nyou're vulnerable[1].  Which, given the lightning software will be using\nthe One True Script, is more likely that your normal wallet using the\nsame keys.\n\nSo I don't think it's worth it.  SIGHASH_NOINPUT is simply dangerous\nwith key-reuse, and Don't Do That.\n\nCheers,\nRusty.\n[1] Attacker can basically clone channel state to another channel."
            },
            {
                "author": "Anthony Towns",
                "date": "2018-12-14T09:30:02",
                "message_text_only": "On Thu, Dec 13, 2018 at 11:07:28AM +1030, Rusty Russell via bitcoin-dev wrote:\n> And is it worthwhile doing the mask complexity, rather than just\n> removing the commitment to script with NOINPUT?  It *feels* safer to\n> restrict what scripts we can sign, but is it?\n\nIf it's not safer in practice, we've spent a little extra complexity\ncommitting to a subset of the script in each signature to no gain. If\nit is safer in practice, we've prevented people from losing funds. I'm\nall for less complexity, but not for that tradeoff.\n\nAlso, saying \"I can't see how to break this, so it's probably good\nenough, even if other people have a bad feeling about it\" is a crypto\nanti-pattern, isn't it?\n\nI don't see how you could feasibly commit to more information than script\nmasking does for use cases where you want to be able to spend different\nscripts with the same signature [0]. If that's possible, I'd probably\nbe for it.\n\nAt the same time, script masking does seem feasible, both for\nlightning/eltoo, and even for possibly complex variations of scripts. So\ncommitting to less doesn't seem wise.\n\n> You already need both key-reuse and amount-reuse to be exploited.\n> SIGHASH_MASK only prevents you from reusing this input for a \"normal\"\n> output; if you used this key for multiple scripts of the same form,\n> you're vulnerable[1].\n\nFor example, script masking seems general enough to prevent footguns\neven if (for some reason) key and value reuse across eltoo channels\nwere a requirement, rather than prohibited: you'd make the script be\n\"<eltoo-channel-id> MASK <statenum> CLTV 2DROP <a+b> CHECKSIG\", and your\nsignature will only apply to that channel, even if another channel has\nthe same capacity and uses the same keys, a and b.\n\n> So I don't think it's worth it.  SIGHASH_NOINPUT is simply dangerous\n> with key-reuse, and Don't Do That.\n\nFor my money, \"NOINPUT\" commits to dangerously little context, and\ndoesn't really feel safe to include as a primitive -- as evidenced by\nthe suggestion to add \"_UNSAFE\" or similar to its name. Personally, I'm\nwilling to accept a bit of risk, so that feeling doesn't make me strongly\nagainst the idea; but it also makes it hard for me to want to support\nadding it. To me, committing to a masked script is a huge improvement.\n\nHeck, if it also makes it easier to do something safer, that's also\nprobably a win...\n\nCheers,\naj\n\n[0] You could, perhaps, commit to knowing the private keys for all the\n    *outputs* you're spending to, as well as the inputs, which comes\n    close to saying \"I know this is a scary NOINPUT transaction, but\n    we're paying to ourselves, so it will all be okay\"."
            },
            {
                "author": "Johnson Lau",
                "date": "2018-12-14T13:55:43",
                "message_text_only": "I don\u2019t think this has been mentioned: without signing the script or masked script, OP_CODESEPARATOR becomes unusable or insecure with NOINPUT.\n\nIn the new sighash proposal, we will sign the hash of the full script (or masked script), without any truncation. To make OP_CODESEPARATOR works like before, we will commit to the position of the last executed OP_CODESEPARATOR. If NOINPUT doesn\u2019t commit to the masked script, it will just blindly committing to a random OP_CODESEPARATOR position, which a wallet couldn\u2019t know what codes are actually being executed.\n\n> On 14 Dec 2018, at 5:30 PM, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> On Thu, Dec 13, 2018 at 11:07:28AM +1030, Rusty Russell via bitcoin-dev wrote:\n>> And is it worthwhile doing the mask complexity, rather than just\n>> removing the commitment to script with NOINPUT?  It *feels* safer to\n>> restrict what scripts we can sign, but is it?\n> \n> If it's not safer in practice, we've spent a little extra complexity\n> committing to a subset of the script in each signature to no gain. If\n> it is safer in practice, we've prevented people from losing funds. I'm\n> all for less complexity, but not for that tradeoff.\n> \n> Also, saying \"I can't see how to break this, so it's probably good\n> enough, even if other people have a bad feeling about it\" is a crypto\n> anti-pattern, isn't it?\n> \n> I don't see how you could feasibly commit to more information than script\n> masking does for use cases where you want to be able to spend different\n> scripts with the same signature [0]. If that's possible, I'd probably\n> be for it.\n> \n> At the same time, script masking does seem feasible, both for\n> lightning/eltoo, and even for possibly complex variations of scripts. So\n> committing to less doesn't seem wise.\n> \n>> You already need both key-reuse and amount-reuse to be exploited.\n>> SIGHASH_MASK only prevents you from reusing this input for a \"normal\"\n>> output; if you used this key for multiple scripts of the same form,\n>> you're vulnerable[1].\n> \n> For example, script masking seems general enough to prevent footguns\n> even if (for some reason) key and value reuse across eltoo channels\n> were a requirement, rather than prohibited: you'd make the script be\n> \"<eltoo-channel-id> MASK <statenum> CLTV 2DROP <a+b> CHECKSIG\", and your\n> signature will only apply to that channel, even if another channel has\n> the same capacity and uses the same keys, a and b.\n> \n>> So I don't think it's worth it.  SIGHASH_NOINPUT is simply dangerous\n>> with key-reuse, and Don't Do That.\n> \n> For my money, \"NOINPUT\" commits to dangerously little context, and\n> doesn't really feel safe to include as a primitive -- as evidenced by\n> the suggestion to add \"_UNSAFE\" or similar to its name. Personally, I'm\n> willing to accept a bit of risk, so that feeling doesn't make me strongly\n> against the idea; but it also makes it hard for me to want to support\n> adding it. To me, committing to a masked script is a huge improvement.\n> \n> Heck, if it also makes it easier to do something safer, that's also\n> probably a win...\n> \n> Cheers,\n> aj\n> \n> [0] You could, perhaps, commit to knowing the private keys for all the\n>    *outputs* you're spending to, as well as the inputs, which comes\n>    close to saying \"I know this is a scary NOINPUT transaction, but\n>    we're paying to ourselves, so it will all be okay\".\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Rusty Russell",
                "date": "2018-12-17T03:10:42",
                "message_text_only": "Johnson Lau <jl2012 at xbt.hk> writes:\n> I don\u2019t think this has been mentioned: without signing the script or masked script, OP_CODESEPARATOR becomes unusable or insecure with NOINPUT.\n>\n> In the new sighash proposal, we will sign the hash of the full script (or masked script), without any truncation. To make OP_CODESEPARATOR works like before, we will commit to the position of the last executed OP_CODESEPARATOR. If NOINPUT doesn\u2019t commit to the masked script, it will just blindly committing to a random OP_CODESEPARATOR position, which a wallet couldn\u2019t know what codes are actually being executed.\n\nMy anti-complexity argument leads me to ask why we'd support\nOP_CODESEPARATOR at all?  Though my argument is weaker here: no wallet\nneed support it.\n\nBut I don't see how OP_CODESEPARATOR changes anything here, wrt NOINPUT?\nRemember, anyone can create an output which can be spent by any NOINPUT,\nwhether we go for OP_MASK or simply not commiting to the input script.\n\nConfused,\nRusty."
            },
            {
                "author": "Johnson Lau",
                "date": "2018-12-20T19:34:38",
                "message_text_only": "> On 17 Dec 2018, at 11:10 AM, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> \n> Johnson Lau <jl2012 at xbt.hk> writes:\n>> I don\u2019t think this has been mentioned: without signing the script or masked script, OP_CODESEPARATOR becomes unusable or insecure with NOINPUT.\n>> \n>> In the new sighash proposal, we will sign the hash of the full script (or masked script), without any truncation. To make OP_CODESEPARATOR works like before, we will commit to the position of the last executed OP_CODESEPARATOR. If NOINPUT doesn\u2019t commit to the masked script, it will just blindly committing to a random OP_CODESEPARATOR position, which a wallet couldn\u2019t know what codes are actually being executed.\n> \n> My anti-complexity argument leads me to ask why we'd support\n> OP_CODESEPARATOR at all?  Though my argument is weaker here: no wallet\n> need support it.\n\nBecause it could make scripts more compact in some cases?\n\nThis is an example: https://github.com/bitcoin/bitcoin/pull/11423#issuecomment-333441321 <https://github.com/bitcoin/bitcoin/pull/11423#issuecomment-333441321>\n\nBut this is probably not a good example for taproot, as it could be more efficient by making the 2 branches as different script merkle leaves.\n\n\n> \n> But I don't see how OP_CODESEPARATOR changes anything here, wrt NOINPUT?\n> Remember, anyone can create an output which can be spent by any NOINPUT,\n> whether we go for OP_MASK or simply not commiting to the input script.\n> \n\nLet me elaborate more. Currently, scriptCode is truncated at the last executed CODESEPARATOR. If we have a very big script with many CODESEPARATORs and CHECKSIGs, there will be a lot of hashing to do.\n\nTo fix this problem, it is proposed that the new sighash will always commit to the same H(script), instead of the truncated scriptCode. So we only need to do the H(script) once, even if the script is very big\n\nIn the case of NOINPUT with MASKEDSCRIPT, it will commit to the H(masked_script) instead of H(script).\n\nTo make CODESEPARATOR works as before, the sighash will also commit to the position of the last executed CODESEPARATOR. So the semantics doesn\u2019t change. For scripts without CODESEPARATOR, the committed value is a constant.\n\nIF NOINPUT does not commit to H(masked_script), technically it could still commit to the position of the last executed CODESEPARATOR. But since the wallet is not aware of the actual content of the script, it has to guess the meaning of such committed positions, like \u201cwith the HD key path m/x/y/z, I assume the script template is blah blah blah because I never use this path for another script template, and the meaning of signing the 3rd CODESEPARATOR is blah blah blah\u201d. It still works if the assumptions hold, but sounds quite unreliable to me.\n\nJohnson\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181221/9fff479c/attachment-0001.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2018-12-20T23:17:15",
                "message_text_only": "Johnson Lau <jl2012 at xbt.hk> writes:\n\n>> On 17 Dec 2018, at 11:10 AM, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>> My anti-complexity argument leads me to ask why we'd support\n>> OP_CODESEPARATOR at all?  Though my argument is weaker here: no wallet\n>> need support it.\n>\n> Because it could make scripts more compact in some cases?\n>\n> This is an example: https://github.com/bitcoin/bitcoin/pull/11423#issuecomment-333441321 <https://github.com/bitcoin/bitcoin/pull/11423#issuecomment-333441321>\n>\n> But this is probably not a good example for taproot, as it could be more efficient by making the 2 branches as different script merkle leaves.\n\nThanks, I hadn't seen this before!  That's also the first time I've seen\nSIGHASH_NONE used.\n\n>> But I don't see how OP_CODESEPARATOR changes anything here, wrt NOINPUT?\n>> Remember, anyone can create an output which can be spent by any NOINPUT,\n>> whether we go for OP_MASK or simply not commiting to the input script.\n>> \n>\n> Let me elaborate more. Currently, scriptCode is truncated at the last executed CODESEPARATOR. If we have a very big script with many CODESEPARATORs and CHECKSIGs, there will be a lot of hashing to do.\n>\n> To fix this problem, it is proposed that the new sighash will always commit to the same H(script), instead of the truncated scriptCode. So we only need to do the H(script) once, even if the script is very big\n\nYes, I read this as proposed, it is clever.  Not sure we'd be\nintroducing it if OP_CODESEPARATOR didn't already exist, but at least\nit's a simplfication.\n\n> In the case of NOINPUT with MASKEDSCRIPT, it will commit to the H(masked_script) instead of H(script).\n>\n> To make CODESEPARATOR works as before, the sighash will also commit to the position of the last executed CODESEPARATOR. So the semantics doesn\u2019t change. For scripts without CODESEPARATOR, the committed value is a constant.\n>\n> IF NOINPUT does not commit to H(masked_script), technically it could still commit to the position of the last executed CODESEPARATOR. But since the wallet is not aware of the actual content of the script, it has to guess the meaning of such committed positions, like \u201cwith the HD key path m/x/y/z, I assume the script template is blah blah blah because I never use this path for another script template, and the meaning of signing the 3rd CODESEPARATOR is blah blah blah\u201d. It still works if the assumptions hold, but sounds quite unreliable to me.\n\nMy question is more fundamental.  If NOINPUT doesn't commit to the input\nat all, no script, no code separator, nothing.  I'm struggling to\nunderstand your original comment was \"without signing the script or\nmasked script, OP_CODESEPARATOR becomes unusable or insecure with\nNOINPUT.\"\n\nI mean, non-useful, sure.  Its purpose is to alter signature behavior,\nand from the script POV there's no signature with this form of NOINPUT.\nBut other than the already-established \"I reused keys for multiple\noutputs\" oops, I don't see any new dangers?\n\nThanks,\nRusty."
            },
            {
                "author": "Johnson Lau",
                "date": "2018-12-21T18:54:42",
                "message_text_only": "> On 21 Dec 2018, at 7:17 AM, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> \n> Johnson Lau <jl2012 at xbt.hk> writes:\n> \n>>> But I don't see how OP_CODESEPARATOR changes anything here, wrt NOINPUT?\n>>> Remember, anyone can create an output which can be spent by any NOINPUT,\n>>> whether we go for OP_MASK or simply not commiting to the input script.\n>>> \n>> \n>> Let me elaborate more. Currently, scriptCode is truncated at the last executed CODESEPARATOR. If we have a very big script with many CODESEPARATORs and CHECKSIGs, there will be a lot of hashing to do.\n>> \n>> To fix this problem, it is proposed that the new sighash will always commit to the same H(script), instead of the truncated scriptCode. So we only need to do the H(script) once, even if the script is very big\n> \n> Yes, I read this as proposed, it is clever.  Not sure we'd be\n> introducing it if OP_CODESEPARATOR didn't already exist, but at least\n> it's a simplfication.\n> \n>> In the case of NOINPUT with MASKEDSCRIPT, it will commit to the H(masked_script) instead of H(script).\n>> \n>> To make CODESEPARATOR works as before, the sighash will also commit to the position of the last executed CODESEPARATOR. So the semantics doesn\u2019t change. For scripts without CODESEPARATOR, the committed value is a constant.\n>> \n>> IF NOINPUT does not commit to H(masked_script), technically it could still commit to the position of the last executed CODESEPARATOR. But since the wallet is not aware of the actual content of the script, it has to guess the meaning of such committed positions, like \u201cwith the HD key path m/x/y/z, I assume the script template is blah blah blah because I never use this path for another script template, and the meaning of signing the 3rd CODESEPARATOR is blah blah blah\u201d. It still works if the assumptions hold, but sounds quite unreliable to me.\n> \n> My question is more fundamental.  If NOINPUT doesn't commit to the input\n> at all, no script, no code separator, nothing.  I'm struggling to\n> understand your original comment was \"without signing the script or\n> masked script, OP_CODESEPARATOR becomes unusable or insecure with\n> NOINPUT.\"\n> \n> I mean, non-useful, sure.  Its purpose is to alter signature behavior,\n> and from the script POV there's no signature with this form of NOINPUT.\n> But other than the already-established \"I reused keys for multiple\n> outputs\" oops, I don't see any new dangers?\n> \n> Thanks,\n> Rusty.\n\nThe question I would like to ask is: is OP_CODESEPARATOR useful under taproot? Generally speaking, CODESEPARATOR is useful only with conditional opcodes (OP_IF etc), and conditional opcodes are mostly replaced by merklized scripts. I am not sure how much usability is left with CODESEPARATOR\n\nIf no one needs CODESEPARATOR, we might just disable it, and makes the validation code a bit simpler\n\nIf CODESEPARATOR is useful, then we should find a way to make it works with NOINPUT. With H(masked_script) committed, the meaning of the CODESEPARATOR position is very clear. Without H(masked_script), the meaning of the position totally relies on the assumption that \u201cthis public key is only used in this script template\u201d.\n\nIgnore CODESEPARATOR and more generally, I agree with you that script masking does not help in the case of address (scriptPubKey) reuse, which is the commonest type of reuse. However, it prevents replayability when the same public key is reused in different scripts"
            },
            {
                "author": "Anthony Towns",
                "date": "2018-12-23T04:26:59",
                "message_text_only": "On Sat, Dec 22, 2018 at 02:54:42AM +0800, Johnson Lau wrote:\n> The question I would like to ask is: is OP_CODESEPARATOR useful under taproot? Generally speaking, CODESEPARATOR is useful only with conditional opcodes (OP_IF etc), and conditional opcodes are mostly replaced by merklized scripts. I am not sure how much usability is left with CODESEPARATOR\n\nIf you don't have conditionals, then I think committing to the (masked)\nscript gives you everything you could do with codeseparator.\n\nIf you don't commit to the (masked) script, don't have conditionals,\nand don't have codeseparator, then I don't think you can make a signature\ndistinguish which alternative script it's intending to sign; but you can\njust give each alternative script in the MAST a slight variation of the\nkey and that seems good enough.\n\nOTOH, I think for (roughly) the example you gave:\n\n  DEPTH 3 EQUAL\n  IF <Bob> CHECKSIGVERIFY HASH160 <H> EQUALVERIFY CODESEP\n  ELSE <n> CLTV DROP\n  ENDIF\n  <Alice> CHECKSIG\n\nthen compared to the taproot equivalent:\n\n  P = muSig(Alice,Bob)\n  S1 = <Alice1> CHECKSIGVERIFY <Bob> CHECKSIGVERIFY HASH160 <H> EQUAL\n  S2 = <Alice2> CHECKSIGVERIFY <n> CLTV\n\nthe IF+CODESEP approach is actually cheaper (lighter weight) if you're\nmostly (>2/3rds of the time) taking the S1 branch. This is because the\n\"DEPTH 3 EQUAL IF/ELSE/ENDIF CODESEP <n> CLTV DROP\" overhead is less\nthan the 32B overhead to choose a merkle branch).\n\n(That said, I'm not sure what Alice's signature in the S1 branch actually\nachieves in that script; and without that in S1, the taproot approach is\ncheaper all the time. Scriptless scripts would be cheaper still)\n\n> If no one needs CODESEPARATOR, we might just disable it, and makes the validation code a bit simpler\n\nSince it only affects the behaviour of the checkdls (checksig) operators,\neven if it was disabled, it could be re-enabled fairly easily in a new\nscript subversion if needed (ie, it could be re-added when upgrading\nwitness version 1 from script version 0 to 1).\n\nCheers,\naj"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-12-23T16:33:48",
                "message_text_only": "> On 23 Dec 2018, at 12:26 PM, Anthony Towns <aj at erisian.com.au> wrote:\n> \n> On Sat, Dec 22, 2018 at 02:54:42AM +0800, Johnson Lau wrote:\n>> The question I would like to ask is: is OP_CODESEPARATOR useful under taproot? Generally speaking, CODESEPARATOR is useful only with conditional opcodes (OP_IF etc), and conditional opcodes are mostly replaced by merklized scripts. I am not sure how much usability is left with CODESEPARATOR\n> \n> If you don't have conditionals, then I think committing to the (masked)\n> script gives you everything you could do with codeseparator.\n\nI don\u2019t think CODESEPARATOR is useful without conditionals. By useful I mean making a script more compact\n\n> \n> If you don't commit to the (masked) script, don't have conditionals,\n> and don't have codeseparator, then I don't think you can make a signature\n> distinguish which alternative script it's intending to sign; but you can\n> just give each alternative script in the MAST a slight variation of the\n> key and that seems good enough.\n\nYou can and should always use a different in different branch. If this best practice is always followed, committing to masked script is not necessary\n\n> \n> OTOH, I think for (roughly) the example you gave:\n> \n>  DEPTH 3 EQUAL\n>  IF <Bob> CHECKSIGVERIFY HASH160 <H> EQUALVERIFY CODESEP\n>  ELSE <n> CLTV DROP\n>  ENDIF\n>  <Alice> CHECKSIG\n> \n> then compared to the taproot equivalent:\n> \n>  P = muSig(Alice,Bob)\n>  S1 = <Alice1> CHECKSIGVERIFY <Bob> CHECKSIGVERIFY HASH160 <H> EQUAL\n>  S2 = <Alice2> CHECKSIGVERIFY <n> CLTV\n> \n> the IF+CODESEP approach is actually cheaper (lighter weight) if you're\n> mostly (>2/3rds of the time) taking the S1 branch. This is because the\n> \"DEPTH 3 EQUAL IF/ELSE/ENDIF CODESEP <n> CLTV DROP\" overhead is less\n> than the 32B overhead to choose a merkle branch).\n> \n> (That said, I'm not sure what Alice's signature in the S1 branch actually\n> achieves in that script; and without that in S1, the taproot approach is\n> cheaper all the time. Scriptless scripts would be cheaper still)\n> \n>> If no one needs CODESEPARATOR, we might just disable it, and makes the validation code a bit simpler\n> \n> Since it only affects the behaviour of the checkdls (checksig) operators,\n> even if it was disabled, it could be re-enabled fairly easily in a new\n> script subversion if needed (ie, it could be re-added when upgrading\n> witness version 1 from script version 0 to 1).\n> \n> Cheers,\n> aj\n> \n\nYes, I don\u2019t think it needs Alice signature in S1 at all. So the original example doesn\u2019t even need CODESEPARATOR at all. \n\nCould anyone propose a better use case of CODESEPARATOR?"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-24T12:01:58",
                "message_text_only": "Good morning,\n\n> Could anyone propose a better use case of CODESEPARATOR?\n\nLong ago, aj sent an email on Lightning-dev about use of CODESEPARATOR to impose Scriptless Script even without Schnorr. It involved 3 signatures with different CODESEPARATOR places, and forced R reuse so that the signatures to claim the funds revealed the privkey.\n\nThe script shown had all CODESEPARATOR in a single branch.\n\nI cannot claim to understand the script, and am having difficulty digging through the mailinglist\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-12-24T21:23:44",
                "message_text_only": "I find another proposed use of CODESEPARATOR here: https://lists.linuxfoundation.org/pipermail/lightning-dev/2016-March/000455.html <https://lists.linuxfoundation.org/pipermail/lightning-dev/2016-March/000455.html>\n\n<KeyA> OP_CHECKSIG\nOP_IF\n<KeyB>\nOP_ELSE\n<Delay> OP_CSV OP_DROP\nOP_CODESEPARATOR <KeyA>\nOP_ENDIF\nOP_CHECKSIG\nIt is actually 2 scripts:\n\nS1: <KeyA> OP_CHECKSIGVERIFY <KeyB> OP_CHECKSIG\nS2: <Delay> OP_CSV OP_DROP <KeyA> OP_CHECKSIG\n\nUnder taproot, we could make Q = P + H(P||S2)G, where P = MuSig(KeyA, KeyB)\n\nS1 becomes a direct spending with Q, and there is no need to use OP_IF or CODESEPARATOR in S2 at all.\n\n\n==================\n\nIf it is only to force R reuse, there is no need to use CODESEPARATOR:\n\nInput: <R> <S2>  <S1>  Script: 2DUP EQUAL NOT VERIFY 2 PICK SWAP CAT <key> DUP TOALTSTACK CHECKSIGVERIFY CAT FROMALTSTACK CHECKSIG\n\nBut using CODESEPARATOR will save 3 bytes\nInput: <S2> <R> <S1>    Script:  OVER SWAP CAT <key> DUP TOALTSTACK CHECKSIGVERIFY CODESEPARATOR SWAP CAT FROMALTSTACK CHECKSIG\n\nHowever, a much better way would be:\n\nInput: <S> Script: <known R> SWAP CAT <key> CHECKSIG\n\nThe discrete log of R could be a shared secret between A and B. If the purpose is to publish the private key to the whole world, R = G could be used.\n\n> On 24 Dec 2018, at 8:01 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> \n> Good morning,\n> \n>> Could anyone propose a better use case of CODESEPARATOR?\n> \n> Long ago, aj sent an email on Lightning-dev about use of CODESEPARATOR to impose Scriptless Script even without Schnorr. It involved 3 signatures with different CODESEPARATOR places, and forced R reuse so that the signatures to claim the funds revealed the privkey.\n> \n> The script shown had all CODESEPARATOR in a single branch.\n> \n> I cannot claim to understand the script, and am having difficulty digging through the mailinglist\n> \n> Regards,\n> ZmnSCPxj\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181225/2bf63818/attachment-0001.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2018-12-16T06:55:48",
                "message_text_only": "Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:\n> On Thu, Dec 13, 2018 at 11:07:28AM +1030, Rusty Russell via bitcoin-dev wrote:\n>> And is it worthwhile doing the mask complexity, rather than just\n>> removing the commitment to script with NOINPUT?  It *feels* safer to\n>> restrict what scripts we can sign, but is it?\n>\n> If it's not safer in practice, we've spent a little extra complexity\n> committing to a subset of the script in each signature to no gain. If\n> it is safer in practice, we've prevented people from losing funds. I'm\n> all for less complexity, but not for that tradeoff.\n\nThere are many complexities we could add, each of which would prevent\nloss of funds in some theoretical case.\n\n>From practical experience; reuse of private keys between lightning and\nother things is not how people will lose funds[1].\n\nIt *is* however non-trivially more complicated for wallets; they\ncurrently have a set of script templates which they will sign (ie. no\nOP_CODESEPARATOR) and I implemented BIP 143 with only the simplest of\nnaive code[2].  In particular, there is no code to parse scripts.\n\nBitcoind developers are not in a good position to assess complexity\nhere.  They have to implement *everything*, so each increment seems\nminor.  In addition, none of these new script versions will ever make\nbitcoind simpler, since they have to support all prior ones.  Wallets,\nhowever, do not have to.\n\nI also think that minimal complexity for (future) wallets is an\nunderappreciated feature: the state of wallets in bitcoin is poor[3]\nso simplicity should be a key goal.\n\nRespectfully,\nRusty.\n\n[1] Reusing your revocation base point across two channels will lose\n    funds in a much more trivial way, as will reusing payment hashes\n    across invoices.\n[2] In fact, I added SIGHASH_ANYONECANPAY and SIGHASH_SINGLE recently\n    for Segwit and it worked first time!  Kudos to BIP143's authors for\n    such a clear guide.\n[3] Bitcoind's wallet can't restore from seed; this neatly demonstrates\n    how hard the wallet problem is, but there are many others.\n\n\n\n\n\n\n\n\n\n\n\n\ncode, as modern wallets currently don't have to parse the scripts they\nsign.\n\n\n\n\n\n\n\nI'm telling you that this is not how people are losing funds.\n\n\n\n>\n> Also, saying \"I can't see how to break this, so it's probably good\n> enough, even if other people have a bad feeling about it\" is a crypto\n> anti-pattern, isn't it?\n>\n> I don't see how you could feasibly commit to more information than script\n> masking does for use cases where you want to be able to spend different\n> scripts with the same signature [0]. If that's possible, I'd probably\n> be for it.\n>\n> At the same time, script masking does seem feasible, both for\n> lightning/eltoo, and even for possibly complex variations of scripts. So\n> committing to less doesn't seem wise.\n>\n>> You already need both key-reuse and amount-reuse to be exploited.\n>> SIGHASH_MASK only prevents you from reusing this input for a \"normal\"\n>> output; if you used this key for multiple scripts of the same form,\n>> you're vulnerable[1].\n>\n> For example, script masking seems general enough to prevent footguns\n> even if (for some reason) key and value reuse across eltoo channels\n> were a requirement, rather than prohibited: you'd make the script be\n> \"<eltoo-channel-id> MASK <statenum> CLTV 2DROP <a+b> CHECKSIG\", and your\n> signature will only apply to that channel, even if another channel has\n> the same capacity and uses the same keys, a and b.\n>\n>> So I don't think it's worth it.  SIGHASH_NOINPUT is simply dangerous\n>> with key-reuse, and Don't Do That.\n>\n> For my money, \"NOINPUT\" commits to dangerously little context, and\n> doesn't really feel safe to include as a primitive -- as evidenced by\n> the suggestion to add \"_UNSAFE\" or similar to its name. Personally, I'm\n> willing to accept a bit of risk, so that feeling doesn't make me strongly\n> against the idea; but it also makes it hard for me to want to support\n> adding it. To me, committing to a masked script is a huge improvement.\n>\n> Heck, if it also makes it easier to do something safer, that's also\n> probably a win...\n>\n> Cheers,\n> aj\n>\n> [0] You could, perhaps, commit to knowing the private keys for all the\n>     *outputs* you're spending to, as well as the inputs, which comes\n>     close to saying \"I know this is a scary NOINPUT transaction, but\n>     we're paying to ourselves, so it will all be okay\".\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-12-17T19:08:26",
                "message_text_only": "> On 16 Dec 2018, at 2:55 PM, Rusty Russell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:\n>> On Thu, Dec 13, 2018 at 11:07:28AM +1030, Rusty Russell via bitcoin-dev wrote:\n>>> And is it worthwhile doing the mask complexity, rather than just\n>>> removing the commitment to script with NOINPUT?  It *feels* safer to\n>>> restrict what scripts we can sign, but is it?\n>> \n>> If it's not safer in practice, we've spent a little extra complexity\n>> committing to a subset of the script in each signature to no gain. If\n>> it is safer in practice, we've prevented people from losing funds. I'm\n>> all for less complexity, but not for that tradeoff.\n> \n> There are many complexities we could add, each of which would prevent\n> loss of funds in some theoretical case.\n\nEvery security measures are overkill, until someone get burnt. If these security measures are really effective, no one will get burnt. The inevitable conclusion is: every effective security measures are overkill.\n\n> \n> From practical experience; reuse of private keys between lightning and\n> other things is not how people will lose funds[1].\n\nAssuming an user holds a private key exclusively and securely, currently there are only 2 ways to lose funds by private key reuse: 1. reusing the same signature nonce; 2. signing the hash \u201cone\u201d, for the SIGHASH_SINGLE consensus bug.\n\nPeople lost money for the first reason. Since this is a feature of the signature schemes we use, unavoidably that will happen again from time to time. The second one has been fixed in segwit (though incompletely), and could be completely fixed with a simple softfork.\n\nOverall speaking, while private key reuse hurts fungibility and privacy, it is not terribly insecure, as long as you use rfc6979 and are not foolish enough to sign hash \u201cone\u201d. This actually thanks to the fact that signatures always committed to the previous txid. It makes sure that a signature is never valid for more than one UTXO. Unfortunately, the guarantee of non-replayability incentified the practice of key-reuse, since the day-one of bitcoin. While NOINPUT fundamentally changes this security assumption, it won\u2019t change this long-established culture of key reuse.\n\nSo you argument seems just begging the question. Without NOINPUT, it is just impossible to lose money by key reuse, and this is exactly the topic we are debating.\n\n\n> \n> It *is* however non-trivially more complicated for wallets; they\n> currently have a set of script templates which they will sign (ie. no\n> OP_CODESEPARATOR) and I implemented BIP 143 with only the simplest of\n> naive code[2].  In particular, there is no code to parse scripts.\n\nSorry that I\u2019m not familiar with the implementation details of your wallet. But as you don\u2019t have code to parse scripts, I assume your wallet can\u2019t handle OP_CODESEPARATOR? However, this is exactly what you should do: only implement what you actually need, and ignore those unrelated details.\n\nAlso, trying to faithfully and completely reproduce the consensus code in a wallet (even if you don\u2019t need that at all) could be extremely dangerous. Such wallet might be tricked, for example, to sign the hash \u201cone\u201d and get all money stolen (I was told someone really did that, but I don\u2019t know the details)\n\nIf you didn\u2019t implement OP_CODESEPARATOR because you didn\u2019t use it, there is no reason for you to fully implement OP_MASKEDPUSH nor script parsing. In existing signature schemes (e.g. BIP143), signatures always commit to the script being executed (the \u201cscriptCode\u201d). I assume that all wallets would re-construct the scriptCode at signing time, based on the limited set of script templates they support. If a wallet had a function called GetScriptCodeForMultiSig() for this purpose, all they need now is a GetMaskedScriptCodeForMultiSig() that returns the masked template, or a new option in the existing GetScriptCodeForMultiSig(). It does not need to be something like GetMaskedScript(GetScriptCodeForMultiSig()). After all, only a very small number of script templates really need NOINPUT. A GetMaskedScript() in a wallet is just an overkill (and a vulnerability if mis-implemented) \n\n> \n> Bitcoind developers are not in a good position to assess complexity\n> here.  They have to implement *everything*, so each increment seems\n> minor.  In addition, none of these new script versions will ever make\n> bitcoind simpler, since they have to support all prior ones.  Wallets,\n> however, do not have to.\n> \n> I also think that minimal complexity for (future) wallets is an\n> underappreciated feature: the state of wallets in bitcoin is poor[3]\n> so simplicity should be a key goal.\n\nIt is a 3-way tradeoff of security, complexity, and functionality. While not everyone might appreciate this, security seems to always be the dominent factor in bitcoin protocol development. It was the reason why most core contributors were hesitant towards BIP148, despite they all love the functionality of segwit.\n\nIt\u2019s also about functionality here: as I mentioned in another reply, OP_CODESEPARATOR couldn\u2019t function properly with NOINPUT but without OP_MASKEDPUSH\n\nThis debate happens because NOINPUT introduces the third way to lose fund with key reuse. And once it is deployed, we have to support it forever, and is not something that we could softfork it away.\n\n\n> \n> Respectfully,\n> Rusty.\n> \n> [1] Reusing your revocation base point across two channels will lose\n>    funds in a much more trivial way, as will reusing payment hashes\n>    across invoices.\n> [2] In fact, I added SIGHASH_ANYONECANPAY and SIGHASH_SINGLE recently\n>    for Segwit and it worked first time!  Kudos to BIP143's authors for\n>    such a clear guide.\n> [3] Bitcoind's wallet can't restore from seed; this neatly demonstrates\n>    how hard the wallet problem is, but there are many others.\n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> code, as modern wallets currently don't have to parse the scripts they\n> sign.\n> \n> \n> \n> \n> \n> \n> \n> I'm telling you that this is not how people are losing funds.\n> \n> \n> \n>> \n>> Also, saying \"I can't see how to break this, so it's probably good\n>> enough, even if other people have a bad feeling about it\" is a crypto\n>> anti-pattern, isn't it?\n>> \n>> I don't see how you could feasibly commit to more information than script\n>> masking does for use cases where you want to be able to spend different\n>> scripts with the same signature [0]. If that's possible, I'd probably\n>> be for it.\n>> \n>> At the same time, script masking does seem feasible, both for\n>> lightning/eltoo, and even for possibly complex variations of scripts. So\n>> committing to less doesn't seem wise.\n>> \n>>> You already need both key-reuse and amount-reuse to be exploited.\n>>> SIGHASH_MASK only prevents you from reusing this input for a \"normal\"\n>>> output; if you used this key for multiple scripts of the same form,\n>>> you're vulnerable[1].\n>> \n>> For example, script masking seems general enough to prevent footguns\n>> even if (for some reason) key and value reuse across eltoo channels\n>> were a requirement, rather than prohibited: you'd make the script be\n>> \"<eltoo-channel-id> MASK <statenum> CLTV 2DROP <a+b> CHECKSIG\", and your\n>> signature will only apply to that channel, even if another channel has\n>> the same capacity and uses the same keys, a and b.\n>> \n>>> So I don't think it's worth it.  SIGHASH_NOINPUT is simply dangerous\n>>> with key-reuse, and Don't Do That.\n>> \n>> For my money, \"NOINPUT\" commits to dangerously little context, and\n>> doesn't really feel safe to include as a primitive -- as evidenced by\n>> the suggestion to add \"_UNSAFE\" or similar to its name. Personally, I'm\n>> willing to accept a bit of risk, so that feeling doesn't make me strongly\n>> against the idea; but it also makes it hard for me to want to support\n>> adding it. To me, committing to a masked script is a huge improvement.\n>> \n>> Heck, if it also makes it easier to do something safer, that's also\n>> probably a win...\n>> \n>> Cheers,\n>> aj\n>> \n>> [0] You could, perhaps, commit to knowing the private keys for all the\n>>    *outputs* you're spending to, as well as the inputs, which comes\n>>    close to saying \"I know this is a scary NOINPUT transaction, but\n>>    we're paying to ourselves, so it will all be okay\".\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Peter Todd",
                "date": "2018-12-18T04:22:58",
                "message_text_only": "On Tue, Dec 18, 2018 at 03:08:26AM +0800, Johnson Lau via bitcoin-dev wrote:\n> >> If it's not safer in practice, we've spent a little extra complexity\n> >> committing to a subset of the script in each signature to no gain. If\n> >> it is safer in practice, we've prevented people from losing funds. I'm\n> >> all for less complexity, but not for that tradeoff.\n> > \n> > There are many complexities we could add, each of which would prevent\n> > loss of funds in some theoretical case.\n> \n> Every security measures are overkill, until someone get burnt. If these security measures are really effective, no one will get burnt. The inevitable conclusion is: every effective security measures are overkill.\n\nThis isn't really a security issue, it's a software reliability issue. And\nyou're making a trade-off between complexity of the core protocol and\ncomplexity of wallet software.\n\nA core protocol failure has high costs for every single Bitcoin user; a wallet\nsoftware failure affects a much smaller number of people. So I'd be inclined to\nprioritise core protocol simplicity rather than stamping out one of many, many,\nways that wallet software can screw up and lose money.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181217/d4893b80/attachment-0001.sig>"
            },
            {
                "author": "Rusty Russell",
                "date": "2018-12-19T00:39:26",
                "message_text_only": "Johnson Lau <jl2012 at xbt.hk> writes:\n>> On 16 Dec 2018, at 2:55 PM, Rusty Russell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> \n>> Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:\n>>> On Thu, Dec 13, 2018 at 11:07:28AM +1030, Rusty Russell via bitcoin-dev wrote:\n>>>> And is it worthwhile doing the mask complexity, rather than just\n>>>> removing the commitment to script with NOINPUT?  It *feels* safer to\n>>>> restrict what scripts we can sign, but is it?\n>>> \n>>> If it's not safer in practice, we've spent a little extra complexity\n>>> committing to a subset of the script in each signature to no gain. If\n>>> it is safer in practice, we've prevented people from losing funds. I'm\n>>> all for less complexity, but not for that tradeoff.\n>> \n>> There are many complexities we could add, each of which would prevent\n>> loss of funds in some theoretical case.\n>\n> Every security measures are overkill, until someone get burnt. If these security measures are really effective, no one will get burnt. The inevitable conclusion is: every effective security measures are overkill.\n>\n>> \n>> From practical experience; reuse of private keys between lightning and\n>> other things is not how people will lose funds[1].\n>\n> So you argument seems just begging the question. Without NOINPUT, it is just impossible to lose money by key reuse, and this is exactly the topic we are debating.\n\nI think we're getting confused here.  I'm contributing my thoughts from\nthe lightning implementer's point of view; there are other important\nconsiderations, but this is my contribution.\n\nIn *lightning* there are more ways to lose funds via secret reuse.\n\nMeanwhile, both SIGHASH_NOINPUT and OP_MASK have the reuse-is-dangerous\nproperty; with OP_MASK the danger is limited to reuse-on-the-same-script\n(ie. if you use the same key for a non-lightning output and a lightning\noutput, you're safe with OP_MASK.  However, this is far less likely in\npractice).\n\nI state again: OP_MASK doesn't seem to gain *lightning* any significant\nsecurity benefit.\n\n> It does not need to be something like GetMaskedScript(GetScriptCodeForMultiSig()). After all, only a very small number of script templates really need NOINPUT. A GetMaskedScript() in a wallet is just an overkill (and a vulnerability if mis-implemented) \n\nOur current transaction signing code is quite generic (and, if I may say\nso, readable and elegant).  We could, of course, special case\nGetMaskedScript() for the case we need (the Eltoo examples I've seen\nhave a single OP_MASK at the front, which makes it trivial).\n\n> It\u2019s also about functionality here: as I mentioned in another reply, OP_CODESEPARATOR couldn\u2019t function properly with NOINPUT but without OP_MASKEDPUSH\n\nThe mailing list seems a bit backed up or something; I replied to that\nin the hope you can clear my confusion on that one.\n\n> This debate happens because NOINPUT introduces the third way to lose fund with key reuse. And once it is deployed, we have to support it forever, and is not something that we could softfork it away.\n\nA would use the same words to encourage you to create the simplest\npossible implementation?\n\nI don't think we disagree on philosophy, just trade-offs.  And that's\nOK.\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2018-12-13T00:24:38",
                "message_text_only": "On Wed, Dec 12, 2018 at 08:12:10PM +1030, Rusty Russell via bitcoin-dev wrote:\n> Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:\n> > Here is a combined proposal:\n> > * Three new sighash flags are added: SIGHASH_NOINPUT, SIGHASH_NOFEE,\n> > and SIGHASH_SCRIPTMASK.\n> > * A new opcode OP_MASK is added, which acts as a NOP during execution.\n> > * The sighash is computed like in BIP143, but:\n> >   * If SIGHASH_SCRIPTMASK is present, for every OP_MASK in scriptCode\n> > the subsequent opcode/push is removed.\n> I'm asking on-list because I'm sure I'm not the only confused one.\n> Having the SIGHASH_SCRIPTMASK flag is redundant AFAICT: why not always\n> perform mask-removal for signing?\n\nThe way I'm thinking about it is there's four amounts of knowledge you\ncould have about the input you're spending at the time you generate a\nsignature:\n\n ALL: you know everything about every input for this tx\n\n SINGLE: you know everything about the input you're signing for, but\n   not necessarily the others\n\n SCRIPTPUBKEY: you know the exact scriptPubKey you're trying to satisfy, but\n   don't know the txid\n\n SCRIPTMASK: you don't know the txid, don't know the scriptPubKey, don't\n   know the other taproot branches, and maybe don't even know the masked\n   out terms in the script -- but you do know the structure of the\n   script, and the non-masked terms\n\nThere's no value to masking in any but the final case -- the txid and\nscriptPubKey commit to the full scriptcode already, so also signing the\nscriptcode is just belt-and-suspenders protection.\n\n(It might be that the \"SCRIPTPUBKEY\" option isn't very useful in\npractice; maybe you'll always either know the txid, or need to mask\nsomething?)\n\n> And I am struggling to understand the role of scriptmask in a taproot\n> world, where the alternate script is both hidden and general?\n\nIn a taproot world, your scriptPubKey is a point P=Q+H(Q,S)*G, where S\nis a merkle root of possibly many scripts, and is spendable either by:\n\n  sig(P)\n  Q, path(S,script), script, witness(script)\n\nSCRIPTMASK lets you prepare a signature for one particular script in\nadvance, even before you've decided what the other scripts are (and even\nwhat the base point Q is), let alone built an actual transaction.\n\nAt least, that's my current understanding; and I think it makes sense...\n\nCheers,\naj"
            },
            {
                "author": "Russell O'Connor",
                "date": "2018-12-13T16:34:17",
                "message_text_only": "On Wed, Dec 12, 2018 at 12:26 PM Gregory Maxwell <gmaxwell at gmail.com> wrote:\n\n> On Wed, Dec 12, 2018 at 5:15 PM Russell O'Connor via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > I tend to think in opposite terms. Is there a proof that any script can\n> be transformed into an equivalent one that avoids witness weight\n> malleability?   But I admit there is a trade off:  If we don't allow for\n> signature covers weight, and we do need it, it will be too late to add.  On\n> the other hand if we add signature covers weight, but it turns out that no\n> Script ever needs to use it, then we've added that software complexity for\n> no gain.  However, I think the software complexity is relatively low,\n> making it worthwhile.\n> >\n> > Moreover, even if witness weight malleability is entirely avoidable, it\n> always seems to come at a cost.  Taking as an example libwally's proposed\n> \"csv_2of3_then_2\"\n>\n> I'm largely in agreement with you-- but my difficulty in arguing for\n> signing the weight is that it seemed to me that it was only easy to\n> sign an upper bound because some witnesses are variable size... and\n> signing an upper bound means more signalling overhead... offsetting\n> the space gains for demalleating.\n>\n\nIn multi-party protocols, the last person to sign knows what the total\nweight is going to be (now that we have fixed sized signatures) and at\nleast they have the ability to sign it.  They are probably motivated to\nsign the weight as long as they are interested in the success of the\ntransaction.  I suppose there could be asynchronous protocols where there\nisn't a last person to sign, but that seems a bit weird.  Greg, you are\nprobably more familiar with examples of multi-party protocols than I am.\n\nOTOH maybe the last person to sign isn't interested in the success of the\ntransaction and wants to cause grief by bloating the transaction and\nsigning the bloated weight.  I guess in such protocols, you'll have to keep\nthe anti-malleablity Script Code.\n\nI totally get the idea that signing weight has a lot of issues in many\nscenarios.  But I still feel than on the whole it is better to make the\noption available than to be forced to rely on anti-malleability Script Code\nor non-consensus relay policy.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181213/b933196e/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Safer sighashes and more granular SIGHASH_NOINPUT",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Rusty Russell",
                "David A. Harding",
                "Anthony Towns",
                "Johnson Lau",
                "Peter Todd",
                "Russell O'Connor",
                "ZmnSCPxj"
            ],
            "messages_count": 31,
            "total_messages_chars_count": 86774
        }
    },
    {
        "title": "[bitcoin-dev] call for demos: Cryptocurrency Implementers' Workshop",
        "thread_messages": [
            {
                "author": "Andrew Miller",
                "date": "2018-12-07T19:25:31",
                "message_text_only": "Hi all,\n  I'm happy to announce the first Cryptocurrency Implementers' Workshop,\ncohosted with Financial Crypto.\n  http://fc19.ifca.ai/ciw/\n  Now that the BITCOIN cryptocurrency research workshop has been folded\ninto the main FC conference, it's time to try something new. The goal of\nthis workshop is to focus on real world experience and engineering efforts.\nAs such we're soliciting submission of *running code* to give a live demo\nat the workshop. Because of the tight timeline, there are only two weeks to\ngo before the submission deadline, Dec 21. More details below the fold, and\nat the website link.\n\n-- \nAndrew Miller\nUniversity of Illinois at Urbana-Champaign\n\nWith the inclusion of the BITCOIN: Bitcoin and Cryptocurrency Research\nWorkshop into the \"Blockchain Track\" of the Financial Cryptography\nconference, we now want to try out an experimental new workshop format,\nwhich focuses on engineering, development, and real world use of\ncryptocurrencies and permissionless blockchains.\n\nIn this first iteration, the workshop will be a half day, and the program\nwill consist of two main components:\n\nInvited talks on implementation post mortems:\n-----\nwe will aim to have several talks from developers and engineers that have\nled and maintained open source software projects in use by cryptocurrencies\ntoday.\n\nArtifact Evaluation and Demo show and tell:\n----\nWe will have a technical program of demo presentations about open source\nsoftware artifacts. Presenters must submit their talk and demo abstract\nalong with the open source software itself for review. Presentation\nabstracts should be no more than 6 pages in LNCS format, or the equivalent\nlength (no more than 2000 words) of text, Markdown, etc. The write up\nshould include:\nmotivation and application,\nnovelty or differences compared to alternative or related implementations,\nchallenges faced,\npossible evaluation approaches\nSubmissions must include a software artifact that can be reviewed. It is\nexpected the review committee will at least be able to run the artifact and\nobserve the outputs. We recommend including a virtual machine image or\nDocker-based build instructions to facilitate this.\n\nSuggested topics\n====\nThe following list is non-exhaustive:\nCryptography implementations, such as digital signatures, ring signatures,\nzero knowledge proofs\nProof-of-work consensus protocols\nProof-of-stake consensus protocols\nMining hardware designs\nPeer-to-peer networking and broadcast relay code\nFull node synchronization\nSPV and lightweight clients\nWallets and key management\nSecurity vulnerabilities and defenses\nMining pools\nMining rig controllers\nStaking wallets\n\nImportant Dates\n====\nDec 21: Submission deadline\nJan 7: Presenter notification\nFeb 22: Workshop\n\nSubmission Instructions\n===\nThe submission website and instructions will be available mid December.\nDemos accepted to this program will not be included in any proceedings.\nSubmission and acceptance in this workshop does not preclude publication\nelsewhere.\n\nSubmissions may be anonymized at the authors' discretion, but it is not a\nrequirement.\n\nProgram Commitee\n====\nJ. Ayo Akinyele (Yeletech)\nRebekah Mercer (Aarhus)\nPieter Wuille (Blockstream)\nBenedikt B\u00fcnz (Stanford)\nEthan Heilman (Boston University, Commonwealth Crypto)\nPatrick McCorry (Kings College London)\nJustin Ehrenhofer (Monero Community WorkGroup)\nJacob Eberhardt (tu-berlin)\n... (more to come)\n\nProgram Chairs\n====\nAndrew Miller (UIUC)\nChristopher Allen\n\nContact email address: Andrew Miller <soc1024 at illinois.edu>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181207/e92b7511/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "call for demos: Cryptocurrency Implementers' Workshop",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Andrew Miller"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3699
        }
    },
    {
        "title": "[bitcoin-dev] Safer NOINPUT with output tagging",
        "thread_messages": [
            {
                "author": "Johnson Lau",
                "date": "2018-12-13T12:32:44",
                "message_text_only": "NOINPUT is very powerful, but the tradeoff is the risks of signature replay. While the key holders are expected not to reuse key pair, little could be done to stop payers to reuse an address. Unfortunately, key-pair reuse has been a social and technical norm since the creation of Bitcoin (the first tx made in block 170 reused the previous public key). I don\u2019t see any hope to change this norm any time soon, if possible at all.\n\nAs the people who are designing the layer-1 protocol, we could always blame the payer and/or payee for their stupidity, just like those people laughed at victims of Ethereum dumb contracts (DAO, Parity multisig, etc). The existing bitcoin script language is so restrictive. It disallows many useful smart contracts, but at the same time prevented many dumb contracts. After all, \u201csmart\u201d and \u201cdumb\u201d are non-technical judgement. The DAO contract has always been faithfully executed. It\u2019s dumb only for those invested in the project. For me, it was just a comedy show.\n\nSo NOINPUT brings us more smart contract capacity, and at the same time we are one step closer to dumb contracts. The target is to find a design that exactly enables the smart contracts we want, while minimising the risks of misuse.\n\nThe risk I am trying to mitigate is a payer mistakenly pay to a previous address with the exactly same amount, and the previous UTXO has been spent using NOINPUT. Accidental double payment is not uncommon. Even if the payee was honest and willing to refund, the money might have been spent with a replayed NOINPUT signature. Once people lost a significant amount of money this way, payers (mostly exchanges) may refuse to send money to anything other than P2PKH, native-P2WPKH and native-P2WSH (as the only 3 types without possibility of NOINPUT)\n\nThe proposed solution is that an output must be \u201ctagged\u201d for it to be spendable with NOINPUT, and the \u201ctag\u201d must be made explicitly by the payer. There are 2 possible ways to do the tagging:\n\n1. A certain bit in the tx version must be set\n2. A certain bit in the scriptPubKey must be set\n\nI will analyse the pros and cons later.\n\nUsing eltoo as example. The setup utxo is a simple 2-of-2 multisig, and should not be tagged. This makes it indistinguishable from normal 1-of-1 utxo. The trigger tx, which spends the setup utxo, should be tagged, so the update txs could spend the trigger utxo with NOINPUT. Similarly, all update txs should be tagged, so they could be spent by other update txs and settlement tx with NOINPUT. As the final destination, there is no need to tag in the settlement tx.\n\nIn payer\u2019s perspective, tagging means \u201cI believe this address is for one-time-use only\u201d Since we can\u2019t control how other people manage their addresses, we should never do tagging when paying to other people.\n\nI mentioned 2 ways of tagging, and they have pros and cons. First of all, tagging in either way should not complicate the eltoo protocol in anyway, nor bring extra block space overhead.\n\nA clear advantage of tagging with scriptPubKey is we could tag on a per-output basis. However, scriptPubKey tagging is only possible with native-segwit, not P2SH. That means we have to disallow NOINPUT in P2SH-segwit (Otherwise, *all* P2SH addresses would become \u201crisky\u201d for payers) This should be ok for eltoo, since it has no reason to use P2SH-segwit in intermediate txs, which is more expensive.\n\nAnother problem with scriptPubKey tagging is all the existing bech32 implementations will not understand the special tag, and will pay to a tagged address as usual. An upgrade would be needed for them to refuse sending to tagged addresses by default.\n\nOn the other hand, tagging with tx version will also protect P2SH-segwit, and all existing wallets are protected by default. However, it is somewhat a layer violation and you could only tag all or none output in the same tx. Also, as Bitcoin Core has just removed the tx version from the UTXO database, adding it back could be a little bit annoying, but doable.\n\nThere is an extension to the version tagging, which could make NOINPUT even safer. In addition to tagging requirement, NOINPUT will also sign the version of the previous tx. If the wallet always uses a randomised tx version, it makes accidental replay very unlikely. However, that will burn a few more bits in the tx version field.\n\nWhile this seems fully compatible with eltoo, is there any other proposals require NOINPUT, and is adversely affected by either way of tagging?"
            },
            {
                "author": "Ruben Somsen",
                "date": "2018-12-17T15:48:15",
                "message_text_only": "Hi Johnson,\n\nThe design considerations here seem similar to the ML discussion of\nwhether Graftroot should be optional [1].\n\n>While this seems fully compatible with eltoo, is there any other proposals require NOINPUT, and is adversely affected by either way of tagging?\n\nAs far as I can tell it should be compatible with Statechains [2],\nsince it pretty much mirrors Eltoo in setup.\n\nMy understanding is somewhat lacking, so perhaps I am missing the\nmark, but it is not completely clear to me how this affects\nfungibility if taproot gets added and the setup and trigger tx for\nEltoo get combined into a single transaction. Would the NOINPUT\nspending condition be hidden inside the taproot commitment?\n\nCheers,\nRuben Somsen\n\n[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-May/016006.html\n[2]  https://www.reddit.com/r/Bitcoin/comments/9nhjea/eli51525faq_for_statechains_offchain_transfer_of/\n\nOn Mon, Dec 17, 2018 at 8:20 PM Johnson Lau via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> NOINPUT is very powerful, but the tradeoff is the risks of signature replay. While the key holders are expected not to reuse key pair, little could be done to stop payers to reuse an address. Unfortunately, key-pair reuse has been a social and technical norm since the creation of Bitcoin (the first tx made in block 170 reused the previous public key). I don\u2019t see any hope to change this norm any time soon, if possible at all.\n>\n> As the people who are designing the layer-1 protocol, we could always blame the payer and/or payee for their stupidity, just like those people laughed at victims of Ethereum dumb contracts (DAO, Parity multisig, etc). The existing bitcoin script language is so restrictive. It disallows many useful smart contracts, but at the same time prevented many dumb contracts. After all, \u201csmart\u201d and \u201cdumb\u201d are non-technical judgement. The DAO contract has always been faithfully executed. It\u2019s dumb only for those invested in the project. For me, it was just a comedy show.\n>\n> So NOINPUT brings us more smart contract capacity, and at the same time we are one step closer to dumb contracts. The target is to find a design that exactly enables the smart contracts we want, while minimising the risks of misuse.\n>\n> The risk I am trying to mitigate is a payer mistakenly pay to a previous address with the exactly same amount, and the previous UTXO has been spent using NOINPUT. Accidental double payment is not uncommon. Even if the payee was honest and willing to refund, the money might have been spent with a replayed NOINPUT signature. Once people lost a significant amount of money this way, payers (mostly exchanges) may refuse to send money to anything other than P2PKH, native-P2WPKH and native-P2WSH (as the only 3 types without possibility of NOINPUT)\n>\n> The proposed solution is that an output must be \u201ctagged\u201d for it to be spendable with NOINPUT, and the \u201ctag\u201d must be made explicitly by the payer. There are 2 possible ways to do the tagging:\n>\n> 1. A certain bit in the tx version must be set\n> 2. A certain bit in the scriptPubKey must be set\n>\n> I will analyse the pros and cons later.\n>\n> Using eltoo as example. The setup utxo is a simple 2-of-2 multisig, and should not be tagged. This makes it indistinguishable from normal 1-of-1 utxo. The trigger tx, which spends the setup utxo, should be tagged, so the update txs could spend the trigger utxo with NOINPUT. Similarly, all update txs should be tagged, so they could be spent by other update txs and settlement tx with NOINPUT. As the final destination, there is no need to tag in the settlement tx.\n>\n> In payer\u2019s perspective, tagging means \u201cI believe this address is for one-time-use only\u201d Since we can\u2019t control how other people manage their addresses, we should never do tagging when paying to other people.\n>\n> I mentioned 2 ways of tagging, and they have pros and cons. First of all, tagging in either way should not complicate the eltoo protocol in anyway, nor bring extra block space overhead.\n>\n> A clear advantage of tagging with scriptPubKey is we could tag on a per-output basis. However, scriptPubKey tagging is only possible with native-segwit, not P2SH. That means we have to disallow NOINPUT in P2SH-segwit (Otherwise, *all* P2SH addresses would become \u201crisky\u201d for payers) This should be ok for eltoo, since it has no reason to use P2SH-segwit in intermediate txs, which is more expensive.\n>\n> Another problem with scriptPubKey tagging is all the existing bech32 implementations will not understand the special tag, and will pay to a tagged address as usual. An upgrade would be needed for them to refuse sending to tagged addresses by default.\n>\n> On the other hand, tagging with tx version will also protect P2SH-segwit, and all existing wallets are protected by default. However, it is somewhat a layer violation and you could only tag all or none output in the same tx. Also, as Bitcoin Core has just removed the tx version from the UTXO database, adding it back could be a little bit annoying, but doable.\n>\n> There is an extension to the version tagging, which could make NOINPUT even safer. In addition to tagging requirement, NOINPUT will also sign the version of the previous tx. If the wallet always uses a randomised tx version, it makes accidental replay very unlikely. However, that will burn a few more bits in the tx version field.\n>\n> While this seems fully compatible with eltoo, is there any other proposals require NOINPUT, and is adversely affected by either way of tagging?\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-12-17T20:08:55",
                "message_text_only": "> On 17 Dec 2018, at 11:48 PM, Ruben Somsen <rsomsen at gmail.com> wrote:\n> \n> Hi Johnson,\n> \n> The design considerations here seem similar to the ML discussion of\n> whether Graftroot should be optional [1].\n\nYes, but the \u201ctagging\u201d emphasises more on the payer\u2019s side: if the payer cannot guarantee that the payee would never reuse the key, the payer could avoid any NOINPUT-related trouble by tagging properly.\n\n> \n>> While this seems fully compatible with eltoo, is there any other proposals require NOINPUT, and is adversely affected by either way of tagging?\n> \n> As far as I can tell it should be compatible with Statechains [2],\n> since it pretty much mirrors Eltoo in setup.\n> \n> My understanding is somewhat lacking, so perhaps I am missing the\n> mark, but it is not completely clear to me how this affects\n> fungibility if taproot gets added and the setup and trigger tx for\n> Eltoo get combined into a single transaction. Would the NOINPUT\n> spending condition be hidden inside the taproot commitment?\n\nFor the design considerations I mentioned above, the tags must be explicit and configurable by the payer. So it couldn\u2019t be hidden in taproot.\n\nIf you don\u2019t care about fungibility, you can always tag your setup output, and makes it ready for NOINPUT spending. Every update will need 2 signatures: a NOINPUT to spend the setup output or an earlier update output, and a NOINPUT to settle the latest update output.\n\nIf you care about fungibility, you can\u2019t tag your setup output. Every update will need 3 signatures: a SINGLEINPUT (aka ANYONECANPAY) to spend the setup output, a NOINPUT to spend an earlier update output, and a NOINPUT to settle the latest update output.\n\n(Actually, as soon as you made the first update tx with SINGLEINPUT, you don\u2019t strictly need to make any SINGLEINPUT signatures in the later updates again, as the first update tx (or any update with a SINGLEINPUT signature) could be effectively the trigger tx. While it makes the settlement more expensive, it also means accidentally missing a SINGLEINPUT signature will not lead to any fund loss. So security-wise it\u2019s same as the always-tagging scenario.)\n\nThe most interesting observation is: you never have the need to use NOINPUT on an already confirmed UTXO, since nothing about a confirmed UTXO is mutable. And every smart contract must anchor to a confirmed UTXO, or the whole contract is double-spendable. So the ability to NOINPUT-spend a setup output should not be strictly needed. In some (but not all) case it might make the protocol simpler, though.\n\nSo the philosophy behind output tagging is \u201cavoid NOINPUT at all cost, until it is truly unavoidable\"\n\n> \n> Cheers,\n> Ruben Somsen\n> \n> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-May/016006.html\n> [2]  https://www.reddit.com/r/Bitcoin/comments/9nhjea/eli51525faq_for_statechains_offchain_transfer_of/\n> \n> On Mon, Dec 17, 2018 at 8:20 PM Johnson Lau via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> \n>> NOINPUT is very powerful, but the tradeoff is the risks of signature replay. While the key holders are expected not to reuse key pair, little could be done to stop payers to reuse an address. Unfortunately, key-pair reuse has been a social and technical norm since the creation of Bitcoin (the first tx made in block 170 reused the previous public key). I don\u2019t see any hope to change this norm any time soon, if possible at all.\n>> \n>> As the people who are designing the layer-1 protocol, we could always blame the payer and/or payee for their stupidity, just like those people laughed at victims of Ethereum dumb contracts (DAO, Parity multisig, etc). The existing bitcoin script language is so restrictive. It disallows many useful smart contracts, but at the same time prevented many dumb contracts. After all, \u201csmart\u201d and \u201cdumb\u201d are non-technical judgement. The DAO contract has always been faithfully executed. It\u2019s dumb only for those invested in the project. For me, it was just a comedy show.\n>> \n>> So NOINPUT brings us more smart contract capacity, and at the same time we are one step closer to dumb contracts. The target is to find a design that exactly enables the smart contracts we want, while minimising the risks of misuse.\n>> \n>> The risk I am trying to mitigate is a payer mistakenly pay to a previous address with the exactly same amount, and the previous UTXO has been spent using NOINPUT. Accidental double payment is not uncommon. Even if the payee was honest and willing to refund, the money might have been spent with a replayed NOINPUT signature. Once people lost a significant amount of money this way, payers (mostly exchanges) may refuse to send money to anything other than P2PKH, native-P2WPKH and native-P2WSH (as the only 3 types without possibility of NOINPUT)\n>> \n>> The proposed solution is that an output must be \u201ctagged\u201d for it to be spendable with NOINPUT, and the \u201ctag\u201d must be made explicitly by the payer. There are 2 possible ways to do the tagging:\n>> \n>> 1. A certain bit in the tx version must be set\n>> 2. A certain bit in the scriptPubKey must be set\n>> \n>> I will analyse the pros and cons later.\n>> \n>> Using eltoo as example. The setup utxo is a simple 2-of-2 multisig, and should not be tagged. This makes it indistinguishable from normal 1-of-1 utxo. The trigger tx, which spends the setup utxo, should be tagged, so the update txs could spend the trigger utxo with NOINPUT. Similarly, all update txs should be tagged, so they could be spent by other update txs and settlement tx with NOINPUT. As the final destination, there is no need to tag in the settlement tx.\n>> \n>> In payer\u2019s perspective, tagging means \u201cI believe this address is for one-time-use only\u201d Since we can\u2019t control how other people manage their addresses, we should never do tagging when paying to other people.\n>> \n>> I mentioned 2 ways of tagging, and they have pros and cons. First of all, tagging in either way should not complicate the eltoo protocol in anyway, nor bring extra block space overhead.\n>> \n>> A clear advantage of tagging with scriptPubKey is we could tag on a per-output basis. However, scriptPubKey tagging is only possible with native-segwit, not P2SH. That means we have to disallow NOINPUT in P2SH-segwit (Otherwise, *all* P2SH addresses would become \u201crisky\u201d for payers) This should be ok for eltoo, since it has no reason to use P2SH-segwit in intermediate txs, which is more expensive.\n>> \n>> Another problem with scriptPubKey tagging is all the existing bech32 implementations will not understand the special tag, and will pay to a tagged address as usual. An upgrade would be needed for them to refuse sending to tagged addresses by default.\n>> \n>> On the other hand, tagging with tx version will also protect P2SH-segwit, and all existing wallets are protected by default. However, it is somewhat a layer violation and you could only tag all or none output in the same tx. Also, as Bitcoin Core has just removed the tx version from the UTXO database, adding it back could be a little bit annoying, but doable.\n>> \n>> There is an extension to the version tagging, which could make NOINPUT even safer. In addition to tagging requirement, NOINPUT will also sign the version of the previous tx. If the wallet always uses a randomised tx version, it makes accidental replay very unlikely. However, that will burn a few more bits in the tx version field.\n>> \n>> While this seems fully compatible with eltoo, is there any other proposals require NOINPUT, and is adversely affected by either way of tagging?\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-12-18T10:48:40",
                "message_text_only": "> On 18 Dec 2018, at 4:08 AM, Johnson Lau via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \n> \n>> On 17 Dec 2018, at 11:48 PM, Ruben Somsen <rsomsen at gmail.com <mailto:rsomsen at gmail.com>> wrote:\n>> \n>> Hi Johnson,\n>> \n>> The design considerations here seem similar to the ML discussion of\n>> whether Graftroot should be optional [1].\n> \n> Yes, but the \u201ctagging\u201d emphasises more on the payer\u2019s side: if the payer cannot guarantee that the payee would never reuse the key, the payer could avoid any NOINPUT-related trouble by tagging properly.\n> \n>> \n>>> While this seems fully compatible with eltoo, is there any other proposals require NOINPUT, and is adversely affected by either way of tagging?\n>> \n>> As far as I can tell it should be compatible with Statechains [2],\n>> since it pretty much mirrors Eltoo in setup.\n>> \n>> My understanding is somewhat lacking, so perhaps I am missing the\n>> mark, but it is not completely clear to me how this affects\n>> fungibility if taproot gets added and the setup and trigger tx for\n>> Eltoo get combined into a single transaction. Would the NOINPUT\n>> spending condition be hidden inside the taproot commitment?\n> \n> For the design considerations I mentioned above, the tags must be explicit and configurable by the payer. So it couldn\u2019t be hidden in taproot.\n> \n> If you don\u2019t care about fungibility, you can always tag your setup output, and makes it ready for NOINPUT spending. Every update will need 2 signatures: a NOINPUT to spend the setup output or an earlier update output, and a NOINPUT to settle the latest update output.\n> \n> If you care about fungibility, you can\u2019t tag your setup output. Every update will need 3 signatures: a SINGLEINPUT (aka ANYONECANPAY) to spend the setup output, a NOINPUT to spend an earlier update output, and a NOINPUT to settle the latest update output.\n> \n> (Actually, as soon as you made the first update tx with SINGLEINPUT, you don\u2019t strictly need to make any SINGLEINPUT signatures in the later updates again, as the first update tx (or any update with a SINGLEINPUT signature) could be effectively the trigger tx. While it makes the settlement more expensive, it also means accidentally missing a SINGLEINPUT signature will not lead to any fund loss. So security-wise it\u2019s same as the always-tagging scenario.)\n> \n> The most interesting observation is: you never have the need to use NOINPUT on an already confirmed UTXO, since nothing about a confirmed UTXO is mutable. And every smart contract must anchor to a confirmed UTXO, or the whole contract is double-spendable. So the ability to NOINPUT-spend a setup output should not be strictly needed. In some (but not all) case it might make the protocol simpler, though.\n> \n> So the philosophy behind output tagging is \u201cavoid NOINPUT at all cost, until it is truly unavoidable\"\n> \n\nAfter thinking more carefully, I believe output tagging could have no adverse effect on eltoo.\n\nConsider a system without tagging, where you could always spend an output with NOINPUT. Under taproot, state update could be made in 2 ways:\n\na) Making 2 sigs for each update. One sig is a \u201cscript path\u201d locktime NOINPUT spending of the setup output or an earlier update output. One sig is a \u201ckey path\u201d relative-locktime NOINPUT spending of the new update output. In taproot terminology, \u201ckey path\u201d means direct spending with the scriptPubKey, and \u201cscript path\u201d means revealing the script hidden in taproot. Key path spending is always cheaper.\n\nb) Making 3 sigs for each update. One sig is a key path SINGLEINPUT (aka ANYONECANPAY) or NOINPUT spending of the setup output, without any locktime. One sig is a script path locktime NOINPUT spending of an earlier update output (if this is not the first update). One sig is a key path relative-locktime NOINPUT spending of the new update output\n\nNote that in b), the first signature could be either SINGLEINPUT or NOINPUT, and they just work as fine. So SINGLEINPUT should be used to avoid unnecessary replayability.\n\nIn the case of uncooperative channel closing, b) is always cheaper than a), since this first broadcast signature will be a key path signature. Also, b) has better privacy if no one is cheating (only the last update is broadcast). The only information leaked in b) is the use of SINGLEINPUT and the subsequent relative-locktime NOINPUT. However, the script path signature in a) will leak the state number, which is the maximum number of updates made in this channel.\n\nIn conclusion, b) is cheaper and more private, but it is more complex by requiring 3 sigs per update rather than 2. I think it is an acceptable tradeoff. (And as I mentioned in my last mail, missing some SINGLEINPUT sigs is not the end of the world. As long as you find one SINGLEINPUT sig in your backup, it safely falls back to the trigger tx model)\n\nWhat if we require output tagging? For privacy reason you shouldn\u2019t tag your setup tx, so the setup output could not be spent with NOINPUT. Option a) doesn\u2019t work, but b) only requires SINGLEINPUT and has no problem. So in a fee-minimising and privacy-maximising eltoo design, output tagging should have no adverse effect.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181218/76d443f8/attachment-0001.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2018-12-19T22:09:50",
                "message_text_only": "Ruben Somsen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nwrites:\n\n> Hi Johnson,\n>\n> The design considerations here seem similar to the ML discussion of\n> whether Graftroot should be optional [1].\n>\n>>While this seems fully compatible with eltoo, is there any other proposals require NOINPUT, and is adversely affected by either way of tagging?\n>\n> As far as I can tell it should be compatible with Statechains [2],\n> since it pretty much mirrors Eltoo in setup.\n>\n> My understanding is somewhat lacking, so perhaps I am missing the\n> mark, but it is not completely clear to me how this affects\n> fungibility if taproot gets added and the setup and trigger tx for\n> Eltoo get combined into a single transaction. Would the NOINPUT\n> spending condition be hidden inside the taproot commitment?\n\nI'm not aware of a way to combine the setup and trigger transaction. The\ntrigger transaction was introduced in order to delay the start of the\ntimeouts until a later time, to avoid having an absolute lifetime limit\nand having really huge timeout. If we were to combine the trigger\ntransaction with the setup transaction (which is broadcast during\nchannel creation), all of those timeouts would start counting down\nimmediately, and we could just skip the trigger transaction\naltogether. It'd be more interesting to combine update and trigger\ntransactions in a sort of cut-through combination, but that doesn't seem\npossible outside of Mimblewimble.\n\nCheers,\nChristian"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-12-20T11:00:53",
                "message_text_only": "> On 20 Dec 2018, at 6:09 AM, Christian Decker <decker.christian at gmail.com> wrote:\n> \n> Ruben Somsen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>>\n> writes:\n> \n>> Hi Johnson,\n>> \n>> The design considerations here seem similar to the ML discussion of\n>> whether Graftroot should be optional [1].\n>> \n>>> While this seems fully compatible with eltoo, is there any other proposals require NOINPUT, and is adversely affected by either way of tagging?\n>> \n>> As far as I can tell it should be compatible with Statechains [2],\n>> since it pretty much mirrors Eltoo in setup.\n>> \n>> My understanding is somewhat lacking, so perhaps I am missing the\n>> mark, but it is not completely clear to me how this affects\n>> fungibility if taproot gets added and the setup and trigger tx for\n>> Eltoo get combined into a single transaction. Would the NOINPUT\n>> spending condition be hidden inside the taproot commitment?\n> \n> I'm not aware of a way to combine the setup and trigger transaction. The\n> trigger transaction was introduced in order to delay the start of the\n> timeouts until a later time, to avoid having an absolute lifetime limit\n> and having really huge timeout. If we were to combine the trigger\n> transaction with the setup transaction (which is broadcast during\n> channel creation), all of those timeouts would start counting down\n> immediately, and we could just skip the trigger transaction\n> altogether. It'd be more interesting to combine update and trigger\n> transactions in a sort of cut-through combination, but that doesn't seem\n> possible outside of Mimblewimble.\n> \n> Cheers,\n> Christian\n\n\nCorrect me if I\u2019m wrong.\n\nFor the sake of simplicity, in the following I assume BIP118, 143, and 141-P2WSH are used (i.e. no taproot). Also, I skipped all the possible optimisations.\n\n1. A and B are going to setup a channel.\n\n2. They create one setup tx, with a setup output of the following script: <s> CLTV DROP 2 Au Bu 2 CHECKMULTISIG. Do not sign\n\n3. They create the update tx 0, spending the setup output with NOINPUT and locktime = s+1, to the update-0 output with the script:\nIF 2 As0 Bs0 2 CHECKMULTISIG ELSE <s+1> CLTV DROP 2 Au Bu 2 CHECKMULTISIG ENDIF\n\n4. They create the settlement tx 0, spending the update-0 output with As0 and Bs0 using BIP68 relative-locktime, with 2 settlement outputs\n\n5. They sign the setup tx and let it confirm\n\n6. To update, they create the update tx 1, spending the setup output with NOINPUT and locktime = s+2, to the update-1 output with the script:\nIF 2 As1 Bs1 2 CHECKMULTISIG ELSE <s+2> CLTV DROP 2 Au Bu 2 CHECKMULTISIG ENDIF\nand create the settlement tx 1, spending the update-1 output with As1 and Bs1 using relative-locktime, with 2 settlement outputs\n\n7. To close the channel, broadcast update tx 1. Wait for several confirmations. And broadcast settlement-tx-1\n\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181220/4c9d8779/attachment-0001.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2018-12-20T17:20:54",
                "message_text_only": "Johnson Lau <jl2012 at xbt.hk> writes:\n> Correct me if I\u2019m wrong.\n>\n> For the sake of simplicity, in the following I assume BIP118, 143, and\n> 141-P2WSH are used (i.e. no taproot). Also, I skipped all the possible\n> optimisations.\n>\n> 1. A and B are going to setup a channel.\n>\n> 2. They create one setup tx, with a setup output of the following\n> script: <s> CLTV DROP 2 Au Bu 2 CHECKMULTISIG. Do not sign\n\nIf we are using a trigger transaction the output of the setup\ntransaction would simply be `2 Au Bu 2 OP_CMS`. If we were to use a CLTV\nin there we would not have an option to later attach a collaborative\nclose transaction that is valid immediately. Furthermore the timeout of\nthe CLTV would start ticking down the exact moment the setup transaction\nis confirmed, hence whatever effect we are trying to achieve with that\ntimelock is limited, and we have a limit to the total lifetime of the\nchannel.\n\n> 3. They create the update tx 0, spending the setup output with NOINPUT\n> and locktime = s+1, to the update-0 output with the script: IF 2 As0\n> Bs0 2 CHECKMULTISIG ELSE <s+1> CLTV DROP 2 Au Bu 2 CHECKMULTISIG ENDIF\n\nUpdate 0 is usually what I call the trigger transaction. It takes the\n2-of-2 multisig from the setup transaction and translates it into the\ntwo-branch output that further updates or settlements can be attached\nto. The settlement transaction attached to the trigger / update 0\nreflects the initial state of the channel, i.e., if A added 2 BTC and B\nadded 1 BTC then settlement 0 will have 2 outputs with value 2 and 1\nrespectively, with the user's keys (this can also be considered the\nrefund in case of one party disappearing right away).\n\nThe second branch in the script you posted is the update branch, which is\nnot encumbered by a CSV, while the first branch is the one encumbered\nwith the CSV and is called the settlement branch since we'll be\nattaching settlement txs to it.\n\nThe CLTV looks correct to me and ensures that we can only attach any\nstate >= s+1.\n\nSo just to show the output script for state `i` how I think they are\ncorrect:\n\n```\nOP_IF\n  <timeout> OP_CSV 2 <As_i> <Bs_i> 2 OP_CHECKMULTISIG\nOP_ELSE\n  <s+1> OP_CLTV OP_DROP 2 <Au> <Bu> 2 OP_CHECKMULTISIG \n```\n\nAnd the input scripts for the update tx and the settlement tx\nrespectively would be:\n\n```\nOP_FALSE <Sig_Bu> <Sig_Au>\n```\n\nand\n\n```\nOP_TRUE <Sig_Bs_i> <Sig_As_i>\n```\n\n> 4. They create the settlement tx 0, spending the update-0 output with\n> As0 and Bs0 using BIP68 relative-locktime, with 2 settlement outputs\n\nIf I'm not mistaken the CSV needs to be in the scriptPubkey (or P2WSH\nequivalent) since segwit witnesses only allow pushes. Hence the script\nin point 3 needs to add that :-)\n\n> 5. They sign the setup tx and let it confirm\n\nThey also need to sign (but not broadcast) update_0, in order to allow\neither party to initiate the closure if the counterparty become\nunresponsive. The order in which settlement_0 and update_0 are signed is\nnot important by the way, so we can just batch these. The important part\nis that signing the setup acts as a commitment.\n\n> 6. To update, they create the update tx 1, spending the setup output\n> with NOINPUT and locktime = s+2, to the update-1 output with the\n> script: IF 2 As1 Bs1 2 CHECKMULTISIG ELSE <s+2> CLTV DROP 2 Au Bu 2\n> CHECKMULTISIG ENDIF and create the settlement tx 1, spending the\n> update-1 output with As1 and Bs1 using relative-locktime, with 2\n> settlement outputs\n\nThe output script of the updates are identical to the ones in the\ntrigger or update_0 transaction, so they'd also need a CSV (this is why\ncommitting to the script structure with masking still works).\n\n> 7. To close the channel, broadcast update tx 1. Wait for several\n> confirmations. And broadcast settlement-tx-1\n\nWe have to differentiate 2 cases: collaborative close and unilateral\nclose. In the collaborative close we come to a mutual agreement that\nwe'd like to take this latest state and settle. So we create a new\ntransaction that spends the setup output, and add outputs according to\nthe state we agreed upon, and we sign it. This transaction is\nimmediately valid, and does not need to be signed with NOINPUT. So all\nthe chain sees is a setup transaction with some inputs and one multisig\noutput (singlesig with Schnorr) and a collaborative close transaction\nthat spends the setup (also not signed with NOINPUT). About as normal as\ntransactions in Bitcoin can get.\n\nIn the unilateral case, one party isn't there anymore, or refuses to\nsign. So we take the trigger transaction (not signed with NOINPUT) and\nthe latest update_n transaction (signed with NOINPUT) and broadcast\nthem. Then we wait for the CSV timeout to expire, and then send the\nsettlement transaction, which gives us the enforcement of the latest\nstate that we agreed on. The chain sees a setup transaction and a\ntrigger transaction (normal transactions for all intents and purposes,\nexcept for the output script of the trigger, but we can hide that with\ntaproot), followed by two more transactions which are signed with\nNOINPUT. So 4 transactions in the worst case, of which 2 are special,\nand 2 transactions in the good case.\n\n\nSo all in all I think it's a tradeoff between having a larger on-chain\nfootprint (4 txs vs 3 txs in the worst case) and putting a fixed\nlifetime on the channel for the refund case if one party disappears\nright away. We'll probably find out what acceptable parameters are for\nthese and where the cutoff points are :-)"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-12-20T18:04:37",
                "message_text_only": "> On 21 Dec 2018, at 1:20 AM, Christian Decker <decker.christian at gmail.com> wrote:\n> \n> Johnson Lau <jl2012 at xbt.hk> writes:\n>> Correct me if I\u2019m wrong.\n>> \n>> For the sake of simplicity, in the following I assume BIP118, 143, and\n>> 141-P2WSH are used (i.e. no taproot). Also, I skipped all the possible\n>> optimisations.\n>> \n>> 1. A and B are going to setup a channel.\n>> \n>> 2. They create one setup tx, with a setup output of the following\n>> script: <s> CLTV DROP 2 Au Bu 2 CHECKMULTISIG. Do not sign\n> \n> If we are using a trigger transaction the output of the setup\n> transaction would simply be `2 Au Bu 2 OP_CMS`. If we were to use a CLTV\n> in there we would not have an option to later attach a collaborative\n> close transaction that is valid immediately. Furthermore the timeout of\n> the CLTV would start ticking down the exact moment the setup transaction\n> is confirmed, hence whatever effect we are trying to achieve with that\n> timelock is limited, and we have a limit to the total lifetime of the\n> channel.\n\nCLTV is absolute locktime. Only CSV will have the \u201ctime ticking\u201d issue, but that\u2019s not used here. The required locktime <s> is many years in the past. To collaboratively close, you just need to sign with SIGHASH_ALL, with a locktime s+1.\n\n> \n>> 3. They create the update tx 0, spending the setup output with NOINPUT\n>> and locktime = s+1, to the update-0 output with the script: IF 2 As0\n>> Bs0 2 CHECKMULTISIG ELSE <s+1> CLTV DROP 2 Au Bu 2 CHECKMULTISIG ENDIF\n> \n> Update 0 is usually what I call the trigger transaction. It takes the\n> 2-of-2 multisig from the setup transaction and translates it into the\n> two-branch output that further updates or settlements can be attached\n> to. The settlement transaction attached to the trigger / update 0\n> reflects the initial state of the channel, i.e., if A added 2 BTC and B\n> added 1 BTC then settlement 0 will have 2 outputs with value 2 and 1\n> respectively, with the user's keys (this can also be considered the\n> refund in case of one party disappearing right away).\n> \n> The second branch in the script you posted is the update branch, which is\n> not encumbered by a CSV, while the first branch is the one encumbered\n> with the CSV and is called the settlement branch since we'll be\n> attaching settlement txs to it.\n> \n> The CLTV looks correct to me and ensures that we can only attach any\n> state >= s+1.\n> \n> So just to show the output script for state `i` how I think they are\n> correct:\n> \n> ```\n> OP_IF\n>  <timeout> OP_CSV 2 <As_i> <Bs_i> 2 OP_CHECKMULTISIG\n> OP_ELSE\n>  <s+1> OP_CLTV OP_DROP 2 <Au> <Bu> 2 OP_CHECKMULTISIG \n> ```\n> \n> And the input scripts for the update tx and the settlement tx\n> respectively would be:\n> \n> ```\n> OP_FALSE <Sig_Bu> <Sig_Au>\n> ```\n> \n> and\n> \n> ```\n> OP_TRUE <Sig_Bs_i> <Sig_As_i>\n> ```\n\nI think the use of OP_CSV (BIP112) is not needed here (although it doesn\u2019t really harm except taking a few more bytes). All you need is to sign the settlement tx with a BIP68 relative locktime. Since this is a 2-of-2 branch, both parties need to agree with the relative locktime, so it is not necessary to restrict it through OP_CSV\n\n\n> \n>> 4. They create the settlement tx 0, spending the update-0 output with\n>> As0 and Bs0 using BIP68 relative-locktime, with 2 settlement outputs\n> \n> If I'm not mistaken the CSV needs to be in the scriptPubkey (or P2WSH\n> equivalent) since segwit witnesses only allow pushes. Hence the script\n> in point 3 needs to add that :-)\n\nI believe you confused OP_CSV (BIP112) with BIP68. Relative locktime is enforced by BIP68 (i.e. setting the nSequence). OP_CSV indirectly enforces relative-locktime by checking the value of nSequence. BIP68 could work standalone without OP_CSV, while OP_CSV is dependant on BIP68. In the case of n-of-n eltoo state update, OP_CSV is not needed because all n parties need to agree with the same nSequence value of the settlement tx. This is enough to make sure the settlement tx has delayed settlement.\n\n> \n>> 5. They sign the setup tx and let it confirm\n> \n> They also need to sign (but not broadcast) update_0, in order to allow\n> either party to initiate the closure if the counterparty become\n> unresponsive. The order in which settlement_0 and update_0 are signed is\n> not important by the way, so we can just batch these. The important part\n> is that signing the setup acts as a commitment.\n\nSure. This is obvious.\n\n> \n>> 6. To update, they create the update tx 1, spending the setup output\n>> with NOINPUT and locktime = s+2, to the update-1 output with the\n>> script: IF 2 As1 Bs1 2 CHECKMULTISIG ELSE <s+2> CLTV DROP 2 Au Bu 2\n>> CHECKMULTISIG ENDIF and create the settlement tx 1, spending the\n>> update-1 output with As1 and Bs1 using relative-locktime, with 2\n>> settlement outputs\n> \n> The output script of the updates are identical to the ones in the\n> trigger or update_0 transaction, so they'd also need a CSV (this is why\n> committing to the script structure with masking still works).\n> \n>> 7. To close the channel, broadcast update tx 1. Wait for several\n>> confirmations. And broadcast settlement-tx-1\n> \n> We have to differentiate 2 cases: collaborative close and unilateral\n> close. In the collaborative close we come to a mutual agreement that\n> we'd like to take this latest state and settle. So we create a new\n> transaction that spends the setup output, and add outputs according to\n> the state we agreed upon, and we sign it. This transaction is\n> immediately valid, and does not need to be signed with NOINPUT. So all\n> the chain sees is a setup transaction with some inputs and one multisig\n> output (singlesig with Schnorr) and a collaborative close transaction\n> that spends the setup (also not signed with NOINPUT). About as normal as\n> transactions in Bitcoin can get.\n\nCollaborative close is always simple as I explained in the beginning\n\n> \n> In the unilateral case, one party isn't there anymore, or refuses to\n> sign. So we take the trigger transaction (not signed with NOINPUT) and\n> the latest update_n transaction (signed with NOINPUT) and broadcast\n> them. Then we wait for the CSV timeout to expire, and then send the\n> settlement transaction, which gives us the enforcement of the latest\n> state that we agreed on. The chain sees a setup transaction and a\n> trigger transaction (normal transactions for all intents and purposes,\n> except for the output script of the trigger, but we can hide that with\n> taproot), followed by two more transactions which are signed with\n> NOINPUT. So 4 transactions in the worst case, of which 2 are special,\n> and 2 transactions in the good case.\n> \n> \n> So all in all I think it's a tradeoff between having a larger on-chain\n> footprint (4 txs vs 3 txs in the worst case) and putting a fixed\n> lifetime on the channel for the refund case if one party disappears\n> right away. We'll probably find out what acceptable parameters are for\n> these and where the cutoff points are :-)\n\nIf no one is cheating (i.e. only the last update is broadcast), you always need only 3 txs. Think about this: every update tx could be a trigger tx, and you can settle directly on a trigger tx, so effectively you eliminate trigger tx."
            },
            {
                "author": "Christian Decker",
                "date": "2018-12-21T11:15:37",
                "message_text_only": "Johnson Lau <jl2012 at xbt.hk> writes:\n>> If we are using a trigger transaction the output of the setup\n>> transaction would simply be `2 Au Bu 2 OP_CMS`. If we were to use a CLTV\n>> in there we would not have an option to later attach a collaborative\n>> close transaction that is valid immediately. Furthermore the timeout of\n>> the CLTV would start ticking down the exact moment the setup transaction\n>> is confirmed, hence whatever effect we are trying to achieve with that\n>> timelock is limited, and we have a limit to the total lifetime of the\n>> channel.\n>\n> CLTV is absolute locktime. Only CSV will have the \u201ctime ticking\u201d\n> issue, but that\u2019s not used here. The required locktime <s> is many\n> years in the past. To collaboratively close, you just need to sign\n> with SIGHASH_ALL, with a locktime s+1.\n\nCorrect, we're using the CLTV here as a weird \"compare two numbers that\nare committed to in the signatures\" operation, by using locktimes in the\npast as you correctly point out.\n\n> I think the use of OP_CSV (BIP112) is not needed here (although it\n> doesn\u2019t really harm except taking a few more bytes). All you need is\n> to sign the settlement tx with a BIP68 relative locktime. Since this\n> is a 2-of-2 branch, both parties need to agree with the relative\n> locktime, so it is not necessary to restrict it through OP_CSV\n\nI keep forgetting about BIP68, but you're right, that should be\nsufficient for our use-case and would safe us a few bytes.\n\n>> In the unilateral case, one party isn't there anymore, or refuses to\n>> sign. So we take the trigger transaction (not signed with NOINPUT) and\n>> the latest update_n transaction (signed with NOINPUT) and broadcast\n>> them. Then we wait for the CSV timeout to expire, and then send the\n>> settlement transaction, which gives us the enforcement of the latest\n>> state that we agreed on. The chain sees a setup transaction and a\n>> trigger transaction (normal transactions for all intents and purposes,\n>> except for the output script of the trigger, but we can hide that with\n>> taproot), followed by two more transactions which are signed with\n>> NOINPUT. So 4 transactions in the worst case, of which 2 are special,\n>> and 2 transactions in the good case.\n>> \n>> \n>> So all in all I think it's a tradeoff between having a larger on-chain\n>> footprint (4 txs vs 3 txs in the worst case) and putting a fixed\n>> lifetime on the channel for the refund case if one party disappears\n>> right away. We'll probably find out what acceptable parameters are for\n>> these and where the cutoff points are :-)\n>\n> If no one is cheating (i.e. only the last update is broadcast), you\n> always need only 3 txs. Think about this: every update tx could be a\n> trigger tx, and you can settle directly on a trigger tx, so\n> effectively you eliminate trigger tx.\n\nI seem to keep mentally mixing different variants of the protocol in my\nhead. You are of course correct that the trigger and the update can be\nconsidered the same, hence the 3 txs limit is right. Sorry for the\nconfusion :-("
            },
            {
                "author": "Johnson Lau",
                "date": "2018-12-21T16:21:42",
                "message_text_only": "> On 21 Dec 2018, at 7:15 PM, Christian Decker <decker.christian at gmail.com> wrote:\n> \n> Johnson Lau <jl2012 at xbt.hk> writes:\n> \n>> I think the use of OP_CSV (BIP112) is not needed here (although it\n>> doesn\u2019t really harm except taking a few more bytes). All you need is\n>> to sign the settlement tx with a BIP68 relative locktime. Since this\n>> is a 2-of-2 branch, both parties need to agree with the relative\n>> locktime, so it is not necessary to restrict it through OP_CSV\n> \n> I keep forgetting about BIP68, but you're right, that should be\n> sufficient for our use-case and would safe us a few bytes.\n> \n\nWith taproot, this actually saves a lot more than a few bytes. For each update, you will make 3 signatures. One is a SIGHASH_ALL spending the setup TXO with no locktime. One is a NOINPUT spending a previous update TXO with absolute locktime. One is a NOINPUT spending the latest update TXO with relative locktime. For the first and third signatures, you will just sign directly with the scriptPubKey, without revealing the hidden taproot script. The second signature will reveal the taproot script, but it is needed only when someone published an outdated update tx."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-21T11:40:06",
                "message_text_only": "Good morning Johnson,\n\n> The proposed solution is that an output must be \u201ctagged\u201d for it to be spendable with NOINPUT, and the \u201ctag\u201d must be made explicitly by the payer. There are 2 possible ways to do the tagging:\n\nFirst off, this is a very good idea I think.\n\n\n>     While this seems fully compatible with eltoo, is there any other proposals require NOINPUT, and is adversely affected by either way of tagging?\n\n\nIt prevents use of SIGHASH_NOINPUT to support walletless offchain protocols.\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-May/015925.html\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-May/015926.html\n\nIn brief, this idea of \"walletless offchain software\" is motivated by the fact, that various onchain wallets exist with many features.\nFor instance, privacy-enhancement as in Samourai/Wasabi/etc.\nAnd so on.\nThere are requests to include such features in e.g. Lightning software, for example: https://github.com/ElementsProject/lightning/issues/2105\nBut it is enough of a challenge to implement Lightning, without the additional burden of implementing nice onchain features like coin control and change labelling.\n\nIt would be best if we can retain features from an onchain wallet, while using our coin on an offchain system.\nFurther, it would allow onchain wallet developers to focus and gain expertise on onchain wallet features, and, vice versa, for offchain walletless software developers to focus on offchain software features.\n\nThe core idea comes from the way that offchain systems need to be set up:\n\n1.  First we agree on a (currently unconfirmed) txid and output number on which to anchor our offchain system (the funding transaction).\n2.  Then we sign a backout transaction (the initial commitment transactions under Poon-Dryja, or the timelock branches for CoinSwapCS, or the initial kickoff-settlement transactions for Decker-Russell-Osuntokun) spending the agreed TXO, to return the money back to the owner(s) in case some participant aborts the setting up of the offchain system.\n3.  Then we sign and broadcast the funding transaction.\n\nUnfortunately, the typical onchain wallet has a very simple and atomic (uncuttable) process for making transactions:\n\n1.  Make, sign, and broadcast transaction with an output paying to the desired address.\n\nThus a typical onchain wallet cannot be used to set up a funding transaction for an offchain system.\n\nNow suppose we take advantage of `SIGHASH_NOINPUT`, and modify our offchain system setup as below:\n\n1.  First we agree on a N-of-N pubkey on which to anchor our offchain system (the funding address).\n2.  Then we sign (with SIGHASH_NOINPUT) a backout transaction (the initial commitment transactions under Poon-Dryja, or the timelock branches for CoinSwapCS, or the initial kickoff-settlement transactions for Decker-Russell-Osuntokun), spending the agreed funding address, to return the money back to the owner(s) in case some participant aborts the setting up of the offchain system.\n3.  Make, sign, and broadcast transaction with an output paying to the funding address.  This step can be done by any typical onchain wallet.\n\nNote that only the starting backout transaction is *required* to sign with `SIGHASH_NOINPUT`.\nFor instance, a Poon-Dryja channel may sign succeeding commitment transactions with `SIGHASH_ALL`.\nFinally, only in case of disaster (some participant aborts before the offchain system is set up) is the `SIGHASH_NOINPUT` backoff transaction broadcasted.\nA \"normal close\" of the offchain system can be signed with typical `SIGHASH_ALL` for no fungibility problems.\n\nWith this, an offchain system need not require its implementing software to implement its own wallet.\nFurther, onchain wallets can directly put its funds into an offchain system, without requiring an onchain transfer to an offchain software wallet.\n\nThis can be helpful when building overall software.\nWe might take any commodity onchain wallet and any commodity offchain software, and we can integrate them easily to create a seamless wallet experience that allows spending and receiving onchain and offchain.\nFurther, improvements in one software component do not require re-building of the other software component.\n\n--\n\nThat said:\n\n1.  For Lightning and similar systems, the fact that the Lightning node will give you an address that, when paid using any commodity onchain wallet, opens a channel, means that people will make wrong assumptions.\n    In particular, they are likely to assume that address reuse is safe and will attempt to \"refill\" their channel by paying to the same address again in the future.\n    From this alone, we can immediately see that this idea is pointless.\n2.  Dual-funding, which for some reason is asked for as a feature, cannot be done with this anyway.\n3.  It may be better to provide some standard way of signing transactions without broadcasting them.\n    This would still allow similar separation of concerns between onchain and offchain software components.\n\nSo output tagging still seems fine to me, even if this particular use cannot be supported.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-12-21T15:37:05",
                "message_text_only": "> On 21 Dec 2018, at 7:40 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> \n> Good morning Johnson,\n> \n>> The proposed solution is that an output must be \u201ctagged\u201d for it to be spendable with NOINPUT, and the \u201ctag\u201d must be made explicitly by the payer. There are 2 possible ways to do the tagging:\n> \n> First off, this is a very good idea I think.\n> \n> \n>>    While this seems fully compatible with eltoo, is there any other proposals require NOINPUT, and is adversely affected by either way of tagging?\n> \n> \n> It prevents use of SIGHASH_NOINPUT to support walletless offchain protocols.\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-May/015925.html\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-May/015926.html\n> \n> In brief, this idea of \"walletless offchain software\" is motivated by the fact, that various onchain wallets exist with many features.\n> For instance, privacy-enhancement as in Samourai/Wasabi/etc.\n> And so on.\n> There are requests to include such features in e.g. Lightning software, for example: https://github.com/ElementsProject/lightning/issues/2105\n> But it is enough of a challenge to implement Lightning, without the additional burden of implementing nice onchain features like coin control and change labelling.\n> \n> It would be best if we can retain features from an onchain wallet, while using our coin on an offchain system.\n> Further, it would allow onchain wallet developers to focus and gain expertise on onchain wallet features, and, vice versa, for offchain walletless software developers to focus on offchain software features.\n> \n> The core idea comes from the way that offchain systems need to be set up:\n> \n> 1.  First we agree on a (currently unconfirmed) txid and output number on which to anchor our offchain system (the funding transaction).\n> 2.  Then we sign a backout transaction (the initial commitment transactions under Poon-Dryja, or the timelock branches for CoinSwapCS, or the initial kickoff-settlement transactions for Decker-Russell-Osuntokun) spending the agreed TXO, to return the money back to the owner(s) in case some participant aborts the setting up of the offchain system.\n> 3.  Then we sign and broadcast the funding transaction.\n> \n> Unfortunately, the typical onchain wallet has a very simple and atomic (uncuttable) process for making transactions:\n> \n> 1.  Make, sign, and broadcast transaction with an output paying to the desired address.\n> \n> Thus a typical onchain wallet cannot be used to set up a funding transaction for an offchain system.\n> \n> Now suppose we take advantage of `SIGHASH_NOINPUT`, and modify our offchain system setup as below:\n> \n> 1.  First we agree on a N-of-N pubkey on which to anchor our offchain system (the funding address).\n> 2.  Then we sign (with SIGHASH_NOINPUT) a backout transaction (the initial commitment transactions under Poon-Dryja, or the timelock branches for CoinSwapCS, or the initial kickoff-settlement transactions for Decker-Russell-Osuntokun), spending the agreed funding address, to return the money back to the owner(s) in case some participant aborts the setting up of the offchain system.\n> 3.  Make, sign, and broadcast transaction with an output paying to the funding address.  This step can be done by any typical onchain wallet.\n> \n> Note that only the starting backout transaction is *required* to sign with `SIGHASH_NOINPUT`.\n> For instance, a Poon-Dryja channel may sign succeeding commitment transactions with `SIGHASH_ALL`.\n> Finally, only in case of disaster (some participant aborts before the offchain system is set up) is the `SIGHASH_NOINPUT` backoff transaction broadcasted.\n> A \"normal close\" of the offchain system can be signed with typical `SIGHASH_ALL` for no fungibility problems.\n> \n> With this, an offchain system need not require its implementing software to implement its own wallet.\n> Further, onchain wallets can directly put its funds into an offchain system, without requiring an onchain transfer to an offchain software wallet.\n> \n> This can be helpful when building overall software.\n> We might take any commodity onchain wallet and any commodity offchain software, and we can integrate them easily to create a seamless wallet experience that allows spending and receiving onchain and offchain.\n> Further, improvements in one software component do not require re-building of the other software component.\n> \n> --\n> \n> That said:\n> \n> 1.  For Lightning and similar systems, the fact that the Lightning node will give you an address that, when paid using any commodity onchain wallet, opens a channel, means that people will make wrong assumptions.\n>    In particular, they are likely to assume that address reuse is safe and will attempt to \"refill\" their channel by paying to the same address again in the future.\n>    From this alone, we can immediately see that this idea is pointless.\n> 2.  Dual-funding, which for some reason is asked for as a feature, cannot be done with this anyway.\n> 3.  It may be better to provide some standard way of signing transactions without broadcasting them.\n>    This would still allow similar separation of concerns between onchain and offchain software components.\n> \n> So output tagging still seems fine to me, even if this particular use cannot be supported.\n> \n> Regards,\n> ZmnSCPxj\n> \n> \n\nGenerally speaking, I think walletless protocol is needed only when you want to rely a third party to open a offchain smart contract. It could be coinswap, eltoo, or anything similar.\n\nHowever, since NOINPUT still commits to the input value, if the third party paid an unexpected value, even off by 1 satoshi, the smart contract is toast. It is not uncommon as some exchanges would deduct fees from withdrawal amount. Since we don\u2019t have a social norm to require the payer to always pay the exact requested amount, the exchange might not be liable for the loss.\n\nIt is of course possible to have a NOINPUT_NOAMOUNT, but I can\u2019t see any chance for this being accepted.\n\nSo, unless the payer is liable for paying a wrong amount, walletless contract opening is unreliable.\n\nJohnson"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-22T14:25:16",
                "message_text_only": "Good morning Johnson,\n\n> Generally speaking, I think walletless protocol is needed only when you want to rely a third party to open a offchain smart contract. It could be coinswap, eltoo, or anything similar.\n\nI think a third party would be pointless in general, but then I am strongly against custodiality.\n\nThe idea is that you have some kind of hardware wallet or similar \"somewhat cold\" storage *that you control yourself*, and crate channels for your hot offchain Lightning wallet, without adding more transactions from your somewhat-cold storage to your hot offchain Lightning wallet on the blockchain.\n\nThen you could feed a set of addresses to the hot offchain wallet (addresses your somewhat-cold storage controls) so that when channels are closed, the funds go to your somwhat-cold storage.\n\nI also doubt that any custodial service would want to mess around with deducting funds from what the user input as the desired payment.  I have not seen a custodial service that does so (this is not a scientific study; I rarely use custodial services); custodial services will deduct more from your balance than what you send, but will not modify what you send, and will prevent you from sending more than your balance minus the fees they charge for sending onchain.\n\nEven today, custodial services deducting from your sent value (rather than the balance remaining after you send) would be problematic when interacting with merchants (or their payment processors) accepting onchain payments; the merchant would refuse to service a lower value than what it charges and it may be very technically difficult to recover such funds from the merchant.\nI expect such a custodial service would quickly lose users, but the world surprises me often.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-12-22T16:56:29",
                "message_text_only": "> On 22 Dec 2018, at 10:25 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> \n> Good morning Johnson,\n> \n>> Generally speaking, I think walletless protocol is needed only when you want to rely a third party to open a offchain smart contract. It could be coinswap, eltoo, or anything similar.\n> \n> I think a third party would be pointless in general, but then I am strongly against custodiality.\n> \n> The idea is that you have some kind of hardware wallet or similar \"somewhat cold\" storage *that you control yourself*, and crate channels for your hot offchain Lightning wallet, without adding more transactions from your somewhat-cold storage to your hot offchain Lightning wallet on the blockchain.\n> \n> Then you could feed a set of addresses to the hot offchain wallet (addresses your somewhat-cold storage controls) so that when channels are closed, the funds go to your somwhat-cold storage.\n> \n> I also doubt that any custodial service would want to mess around with deducting funds from what the user input as the desired payment.  I have not seen a custodial service that does so (this is not a scientific study; I rarely use custodial services); custodial services will deduct more from your balance than what you send, but will not modify what you send, and will prevent you from sending more than your balance minus the fees they charge for sending onchain.\n> \n> Even today, custodial services deducting from your sent value (rather than the balance remaining after you send) would be problematic when interacting with merchants (or their payment processors) accepting onchain payments; the merchant would refuse to service a lower value than what it charges and it may be very technically difficult to recover such funds from the merchant.\n> I expect such a custodial service would quickly lose users, but the world surprises me often.\n> \n> Regards,\n> ZmnSCPxj\n\n\nIf the users are expected to manually operate a hardware wallet to fund the channel, they might do stupid things like using 2 wallets to make 2 txs, thinking that they could combine the values this way; or \u201crefilling\u201d the offchain wallet with the address, as you suggested. While I appreciate the goal to separate the coin-selecting wallet with the offchain wallet, I am not sure if we should rely on users to do critical steps like entering the right value or not reusing the address. Especially, the setup address should be hidden from user\u2019s view, so only a very few \u201cintelligent advanced users\" could try to refill the channel.\n\nIf we don\u2019t rely on the user as the bridge between the hardware wallet and the offchain wallet, we need a communication protocol between them. With such protocol, there is no need to spend the setup TXO with NOINPUT."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-24T11:47:38",
                "message_text_only": "Good morning Johnson,\n\nIndeed, manual operation is risky.\n\nHowever the intent is to reduce the requirements on commodity wallets in order to integrate them into a combined onchain and offchain UI.\n\nA boutique protocol would reduce the number of existing onchain wallets that could be integrated in such UI.\n\n\nIf we could make walletless offchain software in such method, *any* existing wallet with an API to programmatically send arbitrary amount to arbitrary address can be integrated into such UI.\nThis could include hardware wallets.\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Sunday, December 23, 2018 12:56 AM, Johnson Lau <jl2012 at xbt.hk> wrote:\n\n> > On 22 Dec 2018, at 10:25 PM, ZmnSCPxj ZmnSCPxj at protonmail.com wrote:\n> > Good morning Johnson,\n> >\n> > > Generally speaking, I think walletless protocol is needed only when you want to rely a third party to open a offchain smart contract. It could be coinswap, eltoo, or anything similar.\n> >\n> > I think a third party would be pointless in general, but then I am strongly against custodiality.\n> > The idea is that you have some kind of hardware wallet or similar \"somewhat cold\" storage that you control yourself, and crate channels for your hot offchain Lightning wallet, without adding more transactions from your somewhat-cold storage to your hot offchain Lightning wallet on the blockchain.\n> > Then you could feed a set of addresses to the hot offchain wallet (addresses your somewhat-cold storage controls) so that when channels are closed, the funds go to your somwhat-cold storage.\n> > I also doubt that any custodial service would want to mess around with deducting funds from what the user input as the desired payment. I have not seen a custodial service that does so (this is not a scientific study; I rarely use custodial services); custodial services will deduct more from your balance than what you send, but will not modify what you send, and will prevent you from sending more than your balance minus the fees they charge for sending onchain.\n> > Even today, custodial services deducting from your sent value (rather than the balance remaining after you send) would be problematic when interacting with merchants (or their payment processors) accepting onchain payments; the merchant would refuse to service a lower value than what it charges and it may be very technically difficult to recover such funds from the merchant.\n> > I expect such a custodial service would quickly lose users, but the world surprises me often.\n> > Regards,\n> > ZmnSCPxj\n>\n> If the users are expected to manually operate a hardware wallet to fund the channel, they might do stupid things like using 2 wallets to make 2 txs, thinking that they could combine the values this way; or \u201crefilling\u201d the offchain wallet with the address, as you suggested. While I appreciate the goal to separate the coin-selecting wallet with the offchain wallet, I am not sure if we should rely on users to do critical steps like entering the right value or not reusing the address. Especially, the setup address should be hidden from user\u2019s view, so only a very few \u201cintelligent advanced users\" could try to refill the channel.\n>\n> If we don\u2019t rely on the user as the bridge between the hardware wallet and the offchain wallet, we need a communication protocol between them. With such protocol, there is no need to spend the setup TXO with NOINPUT."
            }
        ],
        "thread_summary": {
            "title": "Safer NOINPUT with output tagging",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Ruben Somsen",
                "Johnson Lau",
                "Christian Decker"
            ],
            "messages_count": 15,
            "total_messages_chars_count": 63744
        }
    },
    {
        "title": "[bitcoin-dev] METABIP: ONE SEED STANDARD",
        "thread_messages": [
            {
                "author": "GOLEM XIV",
                "date": "2018-12-13T14:35:22",
                "message_text_only": "From a user perspective it is desirable that, independent from software/hardware used, a seed would be the only information necessary to recover a wallet. Unfortunately, many users think that is currently the case with BIP39, while at the same time it is marked as \"Unanimously discourage for implementation\" in the bitcoin wiki. The situation is confusing, and a arguably a threat to users funds.\n\nThis METABIP is *not* proposing or advocating a specific format. It only claims the importance and urgency of a clear definition, remaining indifferent about the possible outcome even if it should be 'interoperability is not desired'. Its purpose is to be as synthetic and clear as possible about the characteristics of each existing format. Advantages/disadvantages categorization was explicitly avoided.\n\nBIP39 (https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki):\n- \"Unanimously discouraged for implementation\"\n- widely implemented/supported\n- weak KDF\n- no version number\n- no birth date\n- requires a fixed word list\n- extendable with pass phrases\n- simple implementation\n\nElectrum seeds (http://docs.electrum.org/en/latest/seedphrase.html):\n- only supported by Electrum\n- includes version number\n- no birth date\n- does not require a fixed word list\n- extendable with pass phrases\n- simple implementation\n\nAEZeeds (https://github.com/lightningnetwork/lnd/tree/master/aezeed):\n- only supported by LND\n- includes version number\n- includes birth date\n- requires fixed word list\n- pass phrase not only extends, but encrypts seed\n- pass phrase can be modified\n- complex implementation\u00b9\n\nCypherseed(https://gist.github.com/jonasschnelli/245f35894f6ff585b3f3d33c6f208991):\nIncludes all aspects of AEZeeds, with the differences:\n- still in draft stage\n- does not use words at all, but 5char blocks\n- uses MAC tags for plausible deniability\n\n\u00b9) AEZ is an authenticated-encryption (AE) scheme optimized for ease of correct use (\u201cAE made EZ\u201d). - \"Easy to use, not to implement. The easiness claim for AEZ is with respect to ease and versatility of use, not implementation. Writing software for AEZ is not easy, while doing a hardware design for AEZ is far worse. From the hardware designer\u2019s perspective, AEZ\u2019s name might seem ironic, the name better suggesting anti-easy, the antithesis of easy, or anything-but easy!\" - quoted from the original AEZ paper (http://web.cs.ucdavis.edu/~rogaway/aez/aez.pdf)\n\nHopefully, a tiny step towards consensus in this sensible theme.\n\nG.\n--\n// there would be no flight without the dream of flying - Lem\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181213/37aeff0c/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "METABIP: ONE SEED STANDARD",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "GOLEM XIV"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2732
        }
    },
    {
        "title": "[bitcoin-dev] Schnorr and taproot (etc) upgrade",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2018-12-14T10:48:39",
                "message_text_only": "Hi *,\n\n(All the following is heavily informed by talking with other smart people,\nand while probably all the clever ideas are theirs, any nonsense and\nmistakes are certainly my own. I guess I'll pretend there were Chatham\nHouse rules or something to avoid any blame/responsibility accidently\nlanding on their shoulders? Anyway, I hope discussing this in public\nturns out more useful and productive than disastrous and bikesheddy :)\n\n\nRusty wrote \"Without a concrete taproot proposal it's hard to make\nassertions\". I'm not going to offer a completely concrete proposal,\nbut fwiw, here's my thoughts on what should be included in the segwit v1\nproposal, which I think might be concrete enough for discussion purposes:\n\n - introduce 33-byte v1 witness addresses should encode a secp256k1 ECC\n   point (P), spendable either by:\n\n    - a direct schnorr signature (s,R) on that point\n      (s*G = R + H(R,P,txdigest)*P), with the 1-byte sighash per the\n      other thread indicating exactly what goes into the tx digest, etc\n\n    - a script (s), the witness data for the script (wit(s)),\n      with a taproot/merkle path to the script (P,path(S,s)),\n      satisfying the taproot condition (Q = P + H(P,S)*G)\n\n - the taproot scripts should get a version, and since you have to\n   provide P anyway in order to spend by a script, you've got 7-bits spare\n   in the byte that encodes the evenness/oddness of P, so that gives you\n   v1.0 to v1.127 for free. So if we define script version 0 initially,\n   and just automatically accept any script with a later version, we\n   can soft-fork arbitrary script upgrades without bumping the segwit\n   (major) version.\n\n - we should replace the ECDSA CHECKSIG/CHECKMULTISIG ops with new\n   Schnorr ops. A name that's been suggested for the new ops is \"CHECKDLS\"\n   for discrete-log-signature; I'm using that.\n\n   Rather than CHECKMULTISIG, a simple, more general approach seems to\n   be \"CHECKDLSADD\" which takes a signature, a number, and a pubkey,\n   and increments the number if the signature is valid, and leaves it\n   untouched if not. So \"2 of 3 multisig\" becomes \"0 <p> CHECKDLSADD\n   <q> CHECKDLSADD <r> CHECKDLSADD 2 EQ\", eg. That means replacing the\n   current four CHECK(multi)SIG(verify) opcodes, with three opcodes:\n   CHECKDLS, CHECKDLSVERIFY and CHECKDLSADD.\n\n   To make batch verifiability of signatures work, the only acceptable\n   invalid signature for CHECKDLS or CHECKDLSADD needs to be an empty\n   vector; anything else should fail the script/transaction/block.\n\n - adding OP_MASK to support script masking via sighash per the other\n   thread; note this only matters for the new CHECKDLS opcodes, since for\n   direct signatures on the scriptPubKey, there is no script to mask.\n   This means it's completely changeable with new script versions,\n   if desired.\n\n - making (almost) all the currently invalid opcodes upgradeable\n   with what I'm calling \"OP_SUCCESS\" semantics [0], so that we have more\n   flexibility than OP_NOP gives us. An approach for those semantics\n   that seems fairly easy to analyse is to treat script processing as\n   going in phases:\n\n      1. tokenise; check push sizes and overall script size\n      2. if any OP_SUCCESS appeared; succeed\n      3. if banned opcodes appeared; fail (OP_VERIF, OP_VERNOTIF?)\n      4. otherwise, run the script; fail if there's an error\n      5. if there's exactly one, non-zero item on the stack; succeed\n      6. otherwise; fail\n\n   (Obviously an implementation can do these in parallel if that's more\n   efficient)\n\n   That way any of the \"OP_SUCCESS\" opcodes can be replaced by any\n   normal opcode (eg addition, a different sort of signature checking,\n   push tx or blockchain data to the stack) in a soft-fork; and you\n   can easily be sure that the new functionality is a soft-fork (as\n   long as you're not trying to change how pushes work)\n\n   [1]\n\n   This even means you could use an OP_SUCCESS opcode to signal an\n   upgrade of other opcodes, eg an OP_ARITH64BIT that upgrades OP_ADD\n   etc to support arithmetic on 64 bit inputs.\n\n - and that's it.\n\nI think this is a fairly modest collection of changes:\n\n signature/address stuff:\n   - schnorr\n   - new sighash (including \"noinput\")\n   - taproot\n   - merkelized-scripts\n   - avoid weird CHECKMULTISIG behaviour\n upgradeability:\n   - script minor versions\n   - OP_SUCCESS\n\nI think there's a good reason to bundle all those together: the signature\nstuff go together with a new address version, and the upgradeability\nstuff helps reduce the need to do more new address versions.\n\nWell, it's modest at least compared to what's conceivable: there are a\n*lot* of other neat ideas that could theoretically be done in the same\nsoft-fork, but IMHO are better left for later, eg:\n\n - graftroot, g'root, cross-input signature aggregation\n - non-interactive half-signature aggregation\n - re-enabling opcodes (CAT, MUL, XOR, etc)\n - check-sig-of-msg-on-stack, push txdata, other covenant-y things\n - different cryptosystems (eg, 384 bit curves for better protection\n   against future quantum computing advances; conceivably pairing curves?)\n - \"EVAL\" and similar language features\n - [etc]\n\nAs far as how those things could get done in future, this collection of\nfeatures leaves four ways to make further improvements:\n\n - new segwit version (v2-v16)\n   (needed for graftroot, signature aggregation, different signature\n    systems)\n\n - different length segwit v1 pubkey\n   (could be used to provide a hash instead of the actual taproot point,\n    or use a larger ECC curve)\n\n - new segwit v1 script version (v1.0-v1.127)\n   (needed for big redesigns/simplifications of script)\n\n - additional opcodes (OP_SUCCESS replacement)\n   (can be used to re-enable disabled opcodes like MUL/CAT/XOR/etc;\n    can be used to add more complicated things like CHECKSTACKDLS,\n    or PUSHTXDATA; can be used to try out different signature\n    schemes)\n\nI think its worth noting that OP_SUCCESS upgrades could be\ndeveloped/deployed in parallel, since you just need to choose an opcode to\ntake over and (presumably) a versionbit to signal when the new behaviour\ngets activated. The other methods require agreeing on everything that's\ngoing to go in the new version, which needs a bit more coordination.\n\n[2] \n\n\n\nAnyway, to get back to the intro sentence, and to give an example of how I\nthink v1 addresses will work, here's my take on Eltoo in a taproot world:\n\n  Funding tx:\n    inputs: <whatever>\n    outputs:\n      ...\n      i. pay to Q = P+H(P,S)G\n         P = muSig(A,B)\n         S = \"MASK <500M> CLTV <P> CHECKDLSVERIFY\"\n      ...\n\n  Update tx n:\n    nlocktime = 500M + n\n    inputs:\n      1. Funding tx, or Update tx m, m<n; \n           witness: P, (S or Sm),\n             sig(P, sighash=in_scriptmask:\"MASK VERIF CLTV <P> CHECKDLSVERIFY\")\n    outputs:\n      1. pay to Qn = P+H(P,Sn)G\n         Sn = \"MASK <500M+n+1> CLTV <P> CHECKDLSVERIFY\n\n  Settlement tx n:\n    inputs:\n      1. Update tx n (unknown txid); \n\t   witness: sig(Qn, sighash=in_scriptpubkey)\n           nseq = csv delay\n           (note: Qn != Qm unless n=m, because Sn != Sm)\n    outputs:\n      1: pay A's balance to A\n      2: pay B's balance to B\n      3..n: HTLC paying to B: see below\n\n  Cooperative close:\n    inputs:\n      Funding tx, sig(Q, sighash=in_all+out_all)\n    outputs:\n      1..n: as agreed\n\n(I'm assuming you create \"Update tx 0\" and \"Settlement tx 0\" to pay\nyourself back if setup fails, prior to publishing the funding tx. The\neltoo paper has a \"trigger\" phase for that purpose instead, aiui. Also,\nthese two txs don't actually need to use NOINPUT, because they directly\nspend from the funding tx)\n\nAs far as the HTLC outputs go... For SHA256 preimages, you prepare\na taproot address Q=P+H(P,SH), where SH is the merkle root for the\ntree of two scripts, \"<t> CLTV <A> CHECKDLSVERIFY\" and \"HASH160 <h>\nEQUAL <B> CHECKDLSVERIFY\". For secp256k1 preimages, your address is\nP'=muSig(A,B,n*G) for some value n that just ensures you have different\nkeys for each htlc, and you prepare two pre-signed transactions, spending\nthe settlement output (whose txid is unknown), both signed with sighash\ncommitting to the scriptPubKey and a single output. One pays A and has\na partial signature from B and nTimeLock set to the timeout; so A can\ncomplete the signature and claim after the timeout; the other pays B\nand has a conditional partial signature from A, which B can complete\nupon finding out the preimage.\n\nThe settlement and pre-signed-HTLC-spend transactions all make use of\nthe NOINPUT-commit-to-scriptPubKey varaint in this arrangement; so it\ndoes seem like it's probably useful in practice; scriptless scripts make\nthe direct-signature path pretty useful.\n\nCheers,\naj\n\n[0] aka OP_RETURNTRUE https://bitcointalk.org/index.php?topic=1106586.0\n    aka OP_RETURNVALID https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015838.html\n\n[1] The \"drawback\" to this approach is that it means that you can't\n    partially verify a script if you think you know what the first few\n    opcodes mean; so if a script upgrade has happened but your node hasn't\n    upgraded, even if you see a transaction in a block with what you\n    think is \"<p> OP_CHECKDLS OP_SUCCESS\", you don't check the signature.\n\n[2] One thing that could be feasible would be to have some simple\n    OP_SUCCESS upgrades (like enabling CAT/XOR/etc or adding\n    CHECKSTACKDLS) specced, implemented, and tested, and have them\n    activate at the same time as schnorr/taproot/etc, while keeping them\n    as an independent feature at the BIP/concept/implementation levels.\n\n    The idea there is that if it turns out they're not ready in time,\n    schnorr/taproot/etc don't need to get delayed, and the others can\n    just be enabled when they're ready later using a separate version bit.\n    I'm not sure if there's anyone who's interested in shepherding/doing\n    the spec/implementation for any of the more straight-forward features\n    like that, though."
            },
            {
                "author": "Russell O'Connor",
                "date": "2018-12-15T23:38:46",
                "message_text_only": "On Fri, Dec 14, 2018 at 8:39 AM Anthony Towns via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>       5. if there's exactly one, non-zero item on the stack; succeed\n>\n\nUnless it is too much bikeshedding, I'd like to propose that to succeed the\nstack must be exactly empty.  Script is more composable that way, removing\nthe need for special logic to handle top-level CHECKSIG, vs mid-level\nCHECKSIGVERIFY.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181215/599d8d6a/attachment.html>"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-12-17T20:16:12",
                "message_text_only": "> On 16 Dec 2018, at 7:38 AM, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> On Fri, Dec 14, 2018 at 8:39 AM Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>       5. if there's exactly one, non-zero item on the stack; succeed\n> \n> Unless it is too much bikeshedding, I'd like to propose that to succeed the stack must be exactly empty.  Script is more composable that way, removing the need for special logic to handle top-level CHECKSIG, vs mid-level CHECKSIGVERIFY.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\nI proposed the same in BIP114. I wish Satoshi had designed that way. But I\u2019m not sure if that would do more harm than good. For example, people might lose money by copying an existing script template. But they might also lose money in the same way as CHECKMULTISIG is disabled. So I\u2019m not sure.\n\nAnother related thing I\u2019d like to bikeshed is to pop the stack after OP_CLTV and OP_CSV. The same pros and cons apply.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181218/27c5b742/attachment.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2018-12-18T03:18:40",
                "message_text_only": "On Mon, Dec 17, 2018 at 3:16 PM Johnson Lau <jl2012 at xbt.hk> wrote:\n\n>\n> I proposed the same in BIP114. I wish Satoshi had designed that way.\n>\n\nThanks.  I probably read that and internalized it and forgot you wrote it.\n\n\n> But I\u2019m not sure if that would do more harm than good. For example, people\n> might lose money by copying an existing script template. But they might\n> also lose money in the same way as CHECKMULTISIG is disabled. So I\u2019m not\n> sure.\n>\n> Another related thing I\u2019d like to bikeshed is to pop the stack after\n> OP_CLTV and OP_CSV. The same pros and cons apply.\n>\n\nThis one is almost a no-brainer I think.  Nearly every instance of OP_CSV\nis followed by an OP_DROP and we'd save 1 WU per OP_CSV if we pop the stack\nafterwards.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181217/8d9e5536/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2018-12-18T04:58:26",
                "message_text_only": "On Mon, Dec 17, 2018 at 10:18:40PM -0500, Russell O'Connor wrote:\n> On Mon, Dec 17, 2018 at 3:16 PM Johnson Lau <jl2012 at xbt.hk> wrote:\n>     But I\u2019m not sure if that would do more harm than good. For example, people\n>     might lose money by copying an existing script template. But they might\n>     also lose money in the same way as CHECKMULTISIG is disabled. So I\u2019m not\n>     sure.\n\nWell, if CHECKSIG* and CHECKMULTISIG* are all disabled in favour of\nCHECKDLS, CHECKDLSVERIFY and CHECKDLSADD with both different names and\ndifferent opcodes, copying a script template opcode-for-opcode from v0\nto v1 will always fail. (With taproot, this doesn't necessarily mean you\nlose money, even if the script is impossible to ever satisfy, since you\nmay be able to recover via the direct signature path)\n\n>     Another related thing I\u2019d like to bikeshed is to pop the stack after\n>     OP_CLTV and OP_CSV. The same pros and cons apply.\n> This one is almost a no-brainer I think.\u00a0 Nearly every instance of OP_CSV is\n> followed by an OP_DROP and we'd save 1 WU per OP_CSV if we pop the stack\n> afterwards.\n\nIt's definitely bikeshedding so whatever; but to me, it seems like it'd\nbe easier for everyone to have it so that if you've got the same opcode\nin v0 script and v1.0 script; they have precisely the same semantics.\n\n(That said, constructions like \"<n> CLTV <p> CHECKSIGVERIFY\" that avoid\nthe DROP and work when you're expected to leave a true value on the\nstack won't work if you have to end up with an empty stack)\n\nCheers,\naj"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-12-18T10:00:59",
                "message_text_only": "> On 18 Dec 2018, at 12:58 PM, Anthony Towns <aj at erisian.com.au> wrote:\n> \n> On Mon, Dec 17, 2018 at 10:18:40PM -0500, Russell O'Connor wrote:\n>> On Mon, Dec 17, 2018 at 3:16 PM Johnson Lau <jl2012 at xbt.hk> wrote:\n>>    But I\u2019m not sure if that would do more harm than good. For example, people\n>>    might lose money by copying an existing script template. But they might\n>>    also lose money in the same way as CHECKMULTISIG is disabled. So I\u2019m not\n>>    sure.\n> \n> Well, if CHECKSIG* and CHECKMULTISIG* are all disabled in favour of\n> CHECKDLS, CHECKDLSVERIFY and CHECKDLSADD with both different names and\n> different opcodes, copying a script template opcode-for-opcode from v0\n> to v1 will always fail. (With taproot, this doesn't necessarily mean you\n> lose money, even if the script is impossible to ever satisfy, since you\n> may be able to recover via the direct signature path)\n> \n>>    Another related thing I\u2019d like to bikeshed is to pop the stack after\n>>    OP_CLTV and OP_CSV. The same pros and cons apply.\n>> This one is almost a no-brainer I think.  Nearly every instance of OP_CSV is\n>> followed by an OP_DROP and we'd save 1 WU per OP_CSV if we pop the stack\n>> afterwards.\n> \n> It's definitely bikeshedding so whatever; but to me, it seems like it'd\n> be easier for everyone to have it so that if you've got the same opcode\n> in v0 script and v1.0 script; they have precisely the same semantics.\n> \n> (That said, constructions like \"<n> CLTV <p> CHECKSIGVERIFY\" that avoid\n> the DROP and work when you're expected to leave a true value on the\n> stack won't work if you have to end up with an empty stack)\n> \n> Cheers,\n> aj\n> \n\nI think you mean  <p> CHECKSIGVERIFY <n> CLTV, but this works only for simple script. Most likely you need a DROP if you use IF or CODESEPARATOR.\n\nHowever, if we change the rule from \u201cone true stack item\u201d to \u201cempty stack\u201d, CLTV/CSV popping stack will make more sense. So I think either we change all, or change nothing.\n\nThe \u201ctrue stack item\u201d and CLTV/CSV as NOP are tech debt. Fixing them in new script version makes script creation easier and sometimes cheaper, but the fix itself creates further tech debts in the code. So I don\u2019t have strong opinion on this topic."
            }
        ],
        "thread_summary": {
            "title": "Schnorr and taproot (etc) upgrade",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Russell O'Connor",
                "Anthony Towns",
                "Johnson Lau"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 16614
        }
    },
    {
        "title": "[bitcoin-dev] BIP39 seeds",
        "thread_messages": [
            {
                "author": "Aymeric Vitte",
                "date": "2018-12-21T23:58:04",
                "message_text_only": "Has anybody already looked at this: given N randomly chosen words\nbelonging to a BIP39 2048 words dictionary, what is the probability to\nget a \"valid\" BIP39 seed (ie with the right checksum)?\n\nThe result looks (very) surprising to me and might have some use cases,\njust would like to know if this topic has already been discussed before\ngoing further\n\n-- \nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2018-12-23T18:46:12",
                "message_text_only": "On 22/12/2018 00:58, Aymeric Vitte via bitcoin-dev wrote:\n> Has anybody already looked at this: given N randomly chosen words\n> belonging to a BIP39 2048 words dictionary, what is the probability to\n> get a \"valid\" BIP39 seed (ie with the right checksum)?\n\n1:256 for 24 words\n1:16 for 12 words\n\nThis ratio is not too great and will be improved in the upcoming SLIP39\nstandard: https://github.com/satoshilabs/slips/blob/master/slip-0039.md\n\n-- \nBest Regards / S pozdravom,\n\nPavol \"stick\" Rusnak\nCTO, SatoshiLabs"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2018-12-23T22:41:00",
                "message_text_only": "Exactly\n\nThis is surprising, I would have expected the probabilities to be much\nmore lower\n\nIt just means that scanning whatever (secret) book, document, link, etc,\nyou will find easily BIP39 seeds, even of 24 words\n\nSo, it just means that you don't have to write your seed since you can\nrecover it that way, given a secret source and specific algo with custom\nparameters, this could be used for plausible deniability also\n\nFor now I still dislike BIP39 and alike (because I don't see very well\nwhy it's easier to write n words that you cannot choose rather than a\n32B BIP32 hex seed, and I have seen many people completely lost with\ntheir wallets because of this), but I could change my mind, and despite\nof further improvements for this ratio, could what I am suggesting make\nsense?\n\nLe 23/12/2018 \u00e0 19:46, Pavol Rusnak a \u00e9crit\u00a0:\n> On 22/12/2018 00:58, Aymeric Vitte via bitcoin-dev wrote:\n>> Has anybody already looked at this: given N randomly chosen words\n>> belonging to a BIP39 2048 words dictionary, what is the probability to\n>> get a \"valid\" BIP39 seed (ie with the right checksum)?\n> 1:256 for 24 words\n> 1:16 for 12 words\n>\n> This ratio is not too great and will be improved in the upcoming SLIP39\n> standard: https://github.com/satoshilabs/slips/blob/master/slip-0039.md\n>"
            },
            {
                "author": "James MacWhyte",
                "date": "2018-12-25T00:30:26",
                "message_text_only": "On Mon, Dec 24, 2018 at 2:48 PM Aymeric Vitte via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> I don't see very well why it's easier to write n words that you cannot\n> choose rather than a 32B BIP32 hex seed, and I have seen many people\n> completely lost with their wallets because of this\n>\n\nIn practice it has quite a few qualities that make it a bit more resilient\nfor physical (written) storage.\n\nIf a few letters of a word get rubbed off or otherwise become illegible, it\nis pretty easy for a native speaker to figure out what the word is supposed\nto be. Even a non-native speaker could look through the word list and\nfigure out which word fits. Missing characters in a hex string require more\nadvanced brute force searching, which the average user isn't capable of.\n\nAdditionally, having the bits grouped into words makes a more serious\nrecovery easier. If you lose one entire word, it can be brute forced in\nabout 5 minutes on a normal pc, even if you don't know which position the\nmissing word is in (I have published a tool that does just this:\nhttps://jmacwhyte.github.io/recovery-phrase-recovery). If you are missing\ntwo words, you can brute force it in about a week (napkin math).\n\nIf you were missing a random chunk of a hex string, I don't know how you'd\ngo about brute forcing that in a timely manner.\n\nAs an aside, from a UX standpoint we've seen that the 12 words don't *look*\nimportant so people don't take them seriously (and they get lost). A hex\nstring or equivalent would look more password-y, and therefore would most\nlikely be better protected by users.\n\nJames\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181225/81287f18/attachment.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2018-12-26T11:33:27",
                "message_text_only": "Another drawback I think is that people are not using it as seeds, they\njust go to a wallet sw which proposes a new seed, write it somewhere, do\nsomething with the wallet and forget about it, go to another one, create\nanother wallet, etc\n\nApparently it is not very well known even here that the probabilities\nare very high to get a valid BIP39 seed even with 24 words, so, even\nwith a tool like yours, they can be misleaded, for example trying a few\nwords to replace the missing/incorrect one, get a valid seed and stay\nstuck with it forever trying to play with BIP44/49 to find their keys\n\nProbably what I am suggesting is not new (and therefore maybe not a good\nsuggestion): given a secret seed (a book, a document, a link, etc) and a\nderivation path (an algo with secret parameter(s) to derive/order the\nwords and select the valid bip39 sequences), you get your BIP39 seeds\nand don't have to write them\n\nOf course we don't have to use necessarilly BIP39 for this but this is\nwhat we have everywhere and this is what is compatible with it, then you\ncould use the same or a fake written \"not very well hidden\" BIP39 seed\nto plausibly deny your real wallet\n\nLe 25/12/2018 \u00e0 01:30, James MacWhyte a \u00e9crit\u00a0:\n>\n>\n> On Mon, Dec 24, 2018 at 2:48 PM Aymeric Vitte via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>\n>\n>     I don't see very well why it's easier to write n words that you\n>     cannot choose rather than a 32B BIP32 hex seed, and I have seen\n>     many people completely lost with their wallets because of this\n>\n>\n> In practice it has quite a few qualities that make it a bit more\n> resilient for physical (written) storage.\n>\n> If a few letters of a word get rubbed off or otherwise become\n> illegible, it is pretty easy for a native speaker to figure out what\n> the word is supposed to be. Even a non-native speaker could look\n> through the word list and figure out which word fits. Missing\n> characters in a hex string require more advanced brute force\n> searching, which the average user isn't capable of.\n>\n> Additionally, having the bits grouped into words makes a more serious\n> recovery easier. If you lose one entire word, it can be brute forced\n> in about 5 minutes on a normal pc, even if you don't know which\n> position the missing word is in (I have published a tool that does\n> just this:\u00a0https://jmacwhyte.github.io/recovery-phrase-recovery). If\n> you are missing two words, you can brute force it in about a week\n> (napkin math).\n>\n> If you were missing a random chunk of a hex string, I don't know how\n> you'd go about brute forcing that in a timely manner.\n>\n> As an aside, from a UX standpoint we've seen that the 12 words don't\n> *look* important so people don't take them seriously (and they get\n> lost). A hex string or equivalent would look more password-y, and\n> therefore would most likely be better protected by users.\n>\n> James\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181226/e047093a/attachment-0001.html>"
            },
            {
                "author": "James MacWhyte",
                "date": "2018-12-26T18:54:25",
                "message_text_only": "On Wed, Dec 26, 2018 at 11:33 AM Aymeric Vitte <vitteaymeric at gmail.com>\nwrote:\n\n> so, even with a tool like yours, they can be misleaded, for example trying\n> a few words to replace the missing/incorrect one, get a valid seed and stay\n> stuck with it forever trying to play with BIP44/49 to find their keys\n>\n\nJust a small detail, but my tool actually looks up all the possible\ncombinations and then finds which one has been used before by looking for\npast transactions on the blockchain. Therefore, it won't tell you your\nphrase is correct unless it is a phrase that has actually been used before\n(preventing what you described).\n\nUsing some algorithm to take some input and generate a bip39 phrase that\nyou can use with any bip39 wallet sounds perfectly reasonable.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181226/270226c7/attachment-0001.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2018-12-27T11:04:18",
                "message_text_only": "Le 26/12/2018 \u00e0 19:54, James MacWhyte a \u00e9crit\u00a0:\n>\n> On Wed, Dec 26, 2018 at 11:33 AM Aymeric Vitte <vitteaymeric at gmail.com\n> <mailto:vitteaymeric at gmail.com>> wrote:\n>\n>     so, even with a tool like yours, they can be misleaded, for\n>     example trying a few words to replace the missing/incorrect one,\n>     get a valid seed and stay stuck with it forever trying to play\n>     with BIP44/49 to find their keys\n>\n>\n> Just a small detail, but my tool actually looks up all the possible\n> combinations and then finds which one has been used before by looking\n> for past transactions on the blockchain. Therefore, it won't tell you\n> your phrase is correct unless it is a phrase that has actually been\n> used before (preventing what you described).\n\nI saw that your tool was querying blockchain.info, but it cannot guess\nwhat derivation path was used and if it is a standard one what addresses\nwere used, and even if successful it works only for bitcoin (so maybe it\nshould just output the ~1500 possible phrases and/or xprv, and be\ncompletely offline, this is still doable for people)\n\n>\n> Using some algorithm to take some input and generate a bip39 phrase\n> that you can use with any bip39 wallet sounds perfectly reasonable.\n\nI forgot to mention that this can help also solving the \"what if\nsomething happens to me\" case giving to the family the seed and the\nparameter(s) for the derivation path, or an easy way to find it (better\nthan something like: remind this passphrase, take the sha256 of it, then\nuse some other stuff to find the encryption algo, take n bytes of the\nhash, use it to decode my wallet or my seed... and then everybody\nlooking at you like crazy)\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181227/2d00c181/attachment-0001.html>"
            },
            {
                "author": "Alan Evans",
                "date": "2018-12-31T16:52:24",
                "message_text_only": "> Using some algorithm to take some input and generate a bip39 phrase that\nyou can use with any bip39 wallet sounds perfectly reasonable.\n\nI think any method that doesn't use real entropy, but some fake source of\nrandomness, such as a book is asking to be hacked and so is not a\nreasonable idea.\n\nIf an algorithm for book text to BIP39 sentence ever became well used,\ncommon books will be systematically searched for accounts. People will also\nchoose their favourite passages, so I would expect to see collisions.\n\nYou should also note that BIP39 does not need input that is from the word\nlist. You can use *any text as its input*, the word list and checksum check\nis just recommended to be a warning, but again, text chosen from public\nsources or common phrases is a bad idea for many reasons.\n\n>From BIP0039:\n*> The conversion of the mnemonic sentence to a binary seed is completely\nindependent from generating the sentence. This results in rather simple\ncode; there are no constraints on sentence structure and clients are free\nto implement their own wordlists or even whole sentence generators,\nallowing for flexibility in wordlists for typo detection or other purposes.*\n*> Although using a mnemonic not generated by the algorithm described in\n\"Generating the mnemonic\" section is possible, this is not advised and\nsoftware must compute a checksum for the mnemonic sentence using a wordlist\nand issue a warning if it is invalid.*\n\nWhat you could do is use a regular true random BIP39 sentence in\nconjunction with a phrase from a book as the \"passphrase\" giving you that\nplausible deniability, right up to the point you put that in your will or\ntell someone, i.e. for the \"what if something happens to me\" case. Though I\nstill think redirecting people to a book phase is risky for this, e.g.\nbooks have editions, there may be a change in the key place.\n\n>From BIP0039:\n*> The described method also provides plausible deniability, because every\npassphrase generates a valid seed (and thus a deterministic wallet) but\nonly the correct one will make the desired wallet available.*\n\nAlan\n\nP.S. \"I have seen many people completely lost with their wallets because of\n[BIP39]\": I would say \"despite\" not \"because\". These people would have\nlost/miss recorded a BIP32 hex seed as well.\n\n\nOn Thu, 27 Dec 2018 at 11:02, Aymeric Vitte via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> Le 26/12/2018 \u00e0 19:54, James MacWhyte a \u00e9crit :\n>\n>\n> On Wed, Dec 26, 2018 at 11:33 AM Aymeric Vitte <vitteaymeric at gmail.com>\n> wrote:\n>\n>> so, even with a tool like yours, they can be misleaded, for example\n>> trying a few words to replace the missing/incorrect one, get a valid seed\n>> and stay stuck with it forever trying to play with BIP44/49 to find their\n>> keys\n>>\n>\n> Just a small detail, but my tool actually looks up all the possible\n> combinations and then finds which one has been used before by looking for\n> past transactions on the blockchain. Therefore, it won't tell you your\n> phrase is correct unless it is a phrase that has actually been used before\n> (preventing what you described).\n>\n> I saw that your tool was querying blockchain.info, but it cannot guess\n> what derivation path was used and if it is a standard one what addresses\n> were used, and even if successful it works only for bitcoin (so maybe it\n> should just output the ~1500 possible phrases and/or xprv, and be\n> completely offline, this is still doable for people)\n>\n>\n> Using some algorithm to take some input and generate a bip39 phrase that\n> you can use with any bip39 wallet sounds perfectly reasonable.\n>\n> I forgot to mention that this can help also solving the \"what if something\n> happens to me\" case giving to the family the seed and the parameter(s) for\n> the derivation path, or an easy way to find it (better than something like:\n> remind this passphrase, take the sha256 of it, then use some other stuff to\n> find the encryption algo, take n bytes of the hash, use it to decode my\n> wallet or my seed... and then everybody looking at you like crazy)\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181231/9e7da7d2/attachment-0001.html>"
            },
            {
                "author": "Tiago Romagnani Silveira",
                "date": "2018-12-24T14:58:43",
                "message_text_only": "Why is this a SLIP and not a BIP?\nWill it require a BIP39 seed, or will work with any seed format?\n\n\nOn 12/23/18 19:46, Pavol Rusnak via bitcoin-dev wrote:\n> On 22/12/2018 00:58, Aymeric Vitte via bitcoin-dev wrote:\n>> Has anybody already looked at this: given N randomly chosen words\n>> belonging to a BIP39 2048 words dictionary, what is the probability to\n>> get a \"valid\" BIP39 seed (ie with the right checksum)?\n> 1:256 for 24 words\n> 1:16 for 12 words\n>\n> This ratio is not too great and will be improved in the upcoming SLIP39\n> standard: https://github.com/satoshilabs/slips/blob/master/slip-0039.md\n>"
            },
            {
                "author": "Eric Scrivner",
                "date": "2018-12-23T20:55:31",
                "message_text_only": "Quite interesting. Not familiar with prior art here, but would be\ninterested in what your results are showing if you\u2019re willing to share?\n\nOn Sun, Dec 23, 2018 at 11:44 Aymeric Vitte via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Has anybody already looked at this: given N randomly chosen words\n> belonging to a BIP39 2048 words dictionary, what is the probability to\n> get a \"valid\" BIP39 seed (ie with the right checksum)?\n>\n> The result looks (very) surprising to me and might have some use cases,\n> just would like to know if this topic has already been discussed before\n> going further\n>\n> --\n> Move your coins by yourself (browser version): https://peersm.com/wallet\n> Bitcoin transactions made simple:\n> https://github.com/Ayms/bitcoin-transactions\n> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets\n> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\n> Get the torrent dynamic blocklist: http://peersm.com/getblocklist\n> Check the 10 M passwords list: http://peersm.com/findmyass\n> Anti-spies and private torrents, dynamic blocklist:\n> http://torrent-live.org\n> Peersm : http://www.peersm.com\n> torrent-live: https://github.com/Ayms/torrent-live\n> node-Tor : https://www.github.com/Ayms/node-Tor\n> GitHub : https://www.github.com/Ayms\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-- \nEric Scrivner\nRemote Software Engineer\nM: (760) 617-5067\nCoinbase\n<https://www.google.com/url?q=https%3A%2F%2Fwww.coinbase.com%2F&sa=D&sntz=1&usg=AFrqEzct8dGnZ3Hwf_fvfMFBfoF5ElGMfA>\nSan Francisco, CA, USA\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181223/9bf930cc/attachment.html>"
            },
            {
                "author": "Jameson Lopp",
                "date": "2018-12-23T21:08:13",
                "message_text_only": "I believe it would depend upon the entropy used for the seed, as that would\naffect how many bits the checksum represents.\nhttps://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#Generating_the_mnemonic\n\nSo for a 24 word / 256 bit mnemonic the checksum is 8 bits, thus there are\n8 valid checksums and if you picked a random checksum from the wordlist of\n2048 words you'd have a 1 in 256 chance of picking a valid one.\n\nOn Sun, Dec 23, 2018 at 1:44 PM Aymeric Vitte via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Has anybody already looked at this: given N randomly chosen words\n> belonging to a BIP39 2048 words dictionary, what is the probability to\n> get a \"valid\" BIP39 seed (ie with the right checksum)?\n>\n> The result looks (very) surprising to me and might have some use cases,\n> just would like to know if this topic has already been discussed before\n> going further\n>\n> --\n> Move your coins by yourself (browser version): https://peersm.com/wallet\n> Bitcoin transactions made simple:\n> https://github.com/Ayms/bitcoin-transactions\n> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets\n> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\n> Get the torrent dynamic blocklist: http://peersm.com/getblocklist\n> Check the 10 M passwords list: http://peersm.com/findmyass\n> Anti-spies and private torrents, dynamic blocklist:\n> http://torrent-live.org\n> Peersm : http://www.peersm.com\n> torrent-live: https://github.com/Ayms/torrent-live\n> node-Tor : https://www.github.com/Ayms/node-Tor\n> GitHub : https://www.github.com/Ayms\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181223/1e291f73/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP39 seeds",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tiago Romagnani Silveira",
                "Eric Scrivner",
                "Pavol Rusnak",
                "Aymeric Vitte",
                "James MacWhyte",
                "Jameson Lopp",
                "Alan Evans"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 19420
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Core 0.17.1 released",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2018-12-25T09:27:42",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nBitcoin Core version 0.17.1 is now available from:\n\n  <https://bitcoincore.org/bin/bitcoin-core-0.17.1/>\n\nor through BitTorrent:\n\n    magnet:?xt=urn:btih:c56c87ccfaa8e6fbccc90d549121e61efd97cb6f&dn=bitcoin-core-0.17.1&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969&tr=udp%3A%2F%2Fzer0day.ch%3A1337&tr=udp%3A%2F%2Fexplodie.org%3A6969    \n\nThis is a new minor version release, with various bugfixes\nand performance improvements, as well as updated translations.\n\nPlease report bugs using the issue tracker at GitHub:\n\n  <https://github.com/bitcoin/bitcoin/issues>\n\nTo receive security and update notifications, please subscribe to:\n\n  <https://bitcoincore.org/en/list/announcements/join/>\n\nHow to Upgrade\n==============\n\nIf you are running an older version, shut it down. Wait until it has completely\nshut down (which might take a few minutes for older versions), then run the\ninstaller (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)\nor `bitcoind`/`bitcoin-qt` (on Linux).\n\nIf your node has a txindex, the txindex db will be migrated the first time you run 0.17.0 or newer, which may take up to a few hours. Your node will not be functional until this migration completes.\n\nThe first time you run version 0.15.0 or newer, your chainstate database will be converted to a\nnew format, which will take anywhere from a few minutes to half an hour,\ndepending on the speed of your machine.\n\nNote that the block database format also changed in version 0.8.0 and there is no\nautomatic upgrade code from before version 0.8 to version 0.15.0. Upgrading\ndirectly from 0.7.x and earlier without redownloading the blockchain is not supported.\nHowever, as usual, old wallet versions are still supported.\n\nDowngrading warning\n- -------------------\n\nThe chainstate database for this release is not compatible with previous\nreleases, so if you run 0.15 and then decide to switch back to any\nolder version, you will need to run the old release with the `-reindex-chainstate`\noption to rebuild the chainstate data structures in the old format.\n\nIf your node has pruning enabled, this will entail re-downloading and\nprocessing the entire blockchain.\n\nCompatibility\n==============\n\nBitcoin Core is extensively tested on multiple operating systems using\nthe Linux kernel, macOS 10.10+, and Windows 7 and newer (Windows XP is not supported).\n\nBitcoin Core should also work on most other Unix-like systems but is not\nfrequently tested on them.\n\n- From 0.17.0 onwards macOS <10.10 is no longer supported. 0.17.0 is built using Qt 5.9.x, which doesn't\nsupport versions of macOS older than 10.10.\n\nNotable changes\n===============\n\n`listtransactions` label support\n- --------------------------------\n\nThe `listtransactions` RPC `account` parameter which was deprecated in 0.17.0\nand renamed to `dummy` has been un-deprecated and renamed again to `label`.\n\nWhen bitcoin is configured with the `-deprecatedrpc=accounts` setting, specifying\na label/account/dummy argument will return both outgoing and incoming\ntransactions. Without the `-deprecatedrpc=accounts` setting, it will only return\nincoming transactions (because it used to be possible to create transactions\nspending from specific accounts, but this is no longer possible with labels).\n\nWhen `-deprecatedrpc=accounts` is set, it's possible to pass the empty string \"\"\nto list transactions that don't have any label. Without\n`-deprecatedrpc=accounts`, passing the empty string is an error because returning\nonly non-labeled transactions is not generally useful behavior and can cause\nconfusion.\n\n0.17.1 change log\n=================\n\n### P2P protocol and network code\n- - #14685 `9406502` Fix a deserialization overflow edge case (kazcw)\n- - #14728 `b901578` Fix uninitialized read when stringifying an addrLocal (kazcw)\n\n### Wallet\n- - #14441 `5150acc` Restore ability to list incoming transactions by label (jnewbery)\n- - #13546 `91fa15a` Fix use of uninitialized value `bnb_used` in CWallet::CreateTransaction(\u2026) (practicalswift)\n- - #14310 `bb90695` Ensure wallet is unlocked before signing (gustavonalle)\n- - #14690 `5782fdc` Throw error if CPubKey is invalid during PSBT keypath serialization (instagibbs)\n- - #14852 `2528443` backport: [tests] Add `wallet_balance.py` (MarcoFalke)\n- - #14196 `3362a95` psbt: always drop the unnecessary utxo and convert non-witness utxo to witness when necessary (achow101)\n- - #14588 `70ee1f8` Refactor PSBT signing logic to enforce invariant and fix signing bug (gwillen)\n- - #14424 `89a9a9d` Stop requiring imported pubkey to sign non-PKH schemes (sipa, MeshCollider)\n\n### RPC and other APIs\n- - #14417 `fb9ad04` Fix listreceivedbyaddress not taking address as a string (etscrivner)\n- - #14596 `de5e48a` Bugfix: RPC: Add `address_type` named param for createmultisig (luke-jr)\n- - #14618 `9666dba` Make HTTP RPC debug logging more informative (practicalswift)\n- - #14197 `7bee414` [psbt] Convert non-witness UTXOs to witness if witness sig created (achow101)\n- - #14377 `a3fe125` Check that a separator is found for psbt inputs, outputs, and global map (achow101)\n- - #14356 `7a590d8` Fix converttopsbt permitsigdata arg, add basic test (instagibbs)\n- - #14453 `75b5d8c` Fix wallet unload during walletpassphrase timeout (promag)\n\n### GUI\n- - #14403 `0242b5a` Revert \"Force TLS1.0+ for SSL connections\" (real-or-random)\n- - #14593 `df5131b` Explicitly disable \"Dark Mode\" appearance on macOS (fanquake)\n\n### Build system\n- - #14647 `7edebed` Remove illegal spacing in darwin.mk (ch4ot1c)\n- - #14698 `ec71f06` Add bitcoin-tx.exe into Windows installer (ken2812221)\n\n### Tests and QA\n- - #13965 `29899ec` Fix extended functional tests fail (ken2812221)\n- - #14011 `9461f98` Disable wallet and address book Qt tests on macOS minimal platform (ryanofsky)\n- - #14180 `86fadee` Run all tests even if wallet is not compiled (MarcoFalke)\n- - #14122 `8bc1bad` Test `rpc_help.py` failed: Check whether ZMQ is enabled or not (Kvaciral)\n- - #14101 `96dc936` Use named args in validation acceptance tests (MarcoFalke)\n- - #14020 `24d796a` Add tests for RPC help (promag)\n- - #14052 `7ff32a6` Add some actual witness in `rpc_rawtransaction` (MarcoFalke)\n- - #14215 `b72fbab` Use correct python index slices in example test (sdaftuar)\n- - #14024 `06544fa` Add `TestNode::assert_debug_log` (MarcoFalke)\n- - #14658 `60f7a97` Add test to ensure node can generate all rpc help texts at runtime (MarcoFalke)\n- - #14632 `96f15e8` Fix a comment (fridokus)\n- - #14700 `f9db08e` Avoid race in `p2p_invalid_block` by waiting for the block request (MarcoFalke)\n- - #14845 `67225e2` Add `wallet_balance.py` (jnewbery)\n\n### Documentation\n- - #14161 `5f51fd6` doc/descriptors.md tweaks (ryanofsky)\n- - #14276 `85aacc4` Add autogen.sh in ARM Cross-compilation (walterwhite81)\n\nCredits\n=======\n\nThanks to everyone who directly contributed to this release:\n\n- - Andrew Chow\n- - Chun Kuan Lee\n- - David A. Harding\n- - Eric Scrivner\n- - fanquake\n- - fridokus\n- - Glenn Willen\n- - Gregory Sanders\n- - gustavonalle\n- - John Newbery\n- - Jon Layton\n- - Jonas Schnelli\n- - Jo\u00e3o Barbosa\n- - Kaz Wesley\n- - Kvaciral\n- - Luke Dashjr\n- - MarcoFalke\n- - MeshCollider\n- - Pieter Wuille\n- - practicalswift\n- - Russell Yanofsky\n- - Sjors Provoost\n- - Suhas Daftuar\n- - Tim Ruffing\n- - Walter\n- - Wladimir J. van der Laan\n\nAs well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).\n-----BEGIN PGP SIGNATURE-----\n\niQEzBAEBCgAdFiEEnerg3HBjJJ+wVHRoHkrtYphs0l0FAlwh9x0ACgkQHkrtYphs\n0l1yqQf/WzqxJkIrzyO9ZRaLKjaaxVz8E7jqHsyA+4mdObsSPjneGfKh7OEC2Fhx\nVV7EF+A5kNFQgwnPwXlW3AaiuDhcGHEG4T0AB0JGaggLD6KrjpzuWHYx5k0COwdG\n5sYRH4tZxbtWoF1+IQ1R8Ceac20VBqBUBJJfAAntg4VrGaBjDqFJzf+0GmQM0gyW\ntq12nMIwevHWXsmtrQWhAbCeLI8pyhGLOtLqCgrrD5hqe72iV7t6Njs5E+kRkEM1\nUm6a3nc7LTUMXufTwBf6Sie6azubybvI2/G2HvYEn7DKpLAXiihyO8iiheAi6g4U\nJtAgFUiyIvmeLh8etboF3pLy/Q8F5A==\n=LFNX\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.17.1 released",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Wladimir J. van der Laan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 8049
        }
    },
    {
        "title": "[bitcoin-dev] Create a BIP to implement Confidential Transactions in Bitcoin Core",
        "thread_messages": [
            {
                "author": "Kenshiro []",
                "date": "2018-12-27T20:15:19",
                "message_text_only": "Hi,\n\nI think Confidential Transactions (CT) are a great idea to provide enough privacy for normal users (hidden amounts) and fungibility.\n\nI would like to request the creation of a BIP to implement CT in Bitcoin Core. I read that CT are already implemented in Grin and Monero so it looks that CT are enough mature to be implemented in Bitcoin.\n\nIf the CT transaction size is 3x the size of a normal transaction the block size could be increased by 3x too, or just keep the current block size and make CT transactions optional.\n\nThank you!\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181227/06d06157/attachment.html>"
            },
            {
                "author": "SomberNight",
                "date": "2018-12-28T21:41:51",
                "message_text_only": "Hi Kenshiro,\n\nThat is not how the BIP process works. Instead of requesting the creation\nof a BIP, you just create one. :)\n\nRe CT in Bitcoin, I have my doubts whether you can get consensus for that.\n>From section 4.6 of the Bulletproofs paper [0]:\n\n\"Bulletproofs ... are computationally binding. An adversary that could\nbreak the discrete logarithm assumption could generate acceptable range\nproofs for a value outside the correct range. ... An adversary that can\nbreak the binding property of the commitment scheme or the soundness of\nthe proof system can generate coins out of thin air and thus create\nuncontrolled but undetectable inflation rendering the currency useless\"\n\nI don't have the domain knowledge to debate whether quantum computers will\never exist but AFAICT their emergence would easily kill a currency that\nuses these kind of range proofs for confidential transactions.\n\n\n[0]: https://eprint.iacr.org/2017/1066.pdf\n\n\n> From: \"Kenshiro []\" tensiam at hotmail.com\n>\n> Hi,\n>\n> I think Confidential Transactions (CT) are a great idea to provide enough privacy for normal users (hidden amounts) and fungibility.\n>\n> I would like to request the creation of a BIP to implement CT in Bitcoin Core. I read that CT are already implemented in Grin and Monero so it looks that CT are enough mature to be implemented in Bitcoin.\n>\n> If the CT transaction size is 3x the size of a normal transaction the block size could be increased by 3x too, or just keep the current block size and make CT transactions optional.\n>\n> Thank you!"
            },
            {
                "author": "Kenshiro []",
                "date": "2018-12-29T11:56:08",
                "message_text_only": "I understand, thank you! :)\n\n\nFrom: SomberNight <somber.night at protonmail.com>\nSent: Friday, December 28, 2018 22:41\nTo: bitcoin-dev at lists.linuxfoundation.org; tensiam at hotmail.com\nSubject: [bitcoin-dev] Create a BIP to implement Confidential Transactions in Bitcoin Core\n\nHi Kenshiro,\n\nThat is not how the BIP process works. Instead of requesting the creation\nof a BIP, you just create one. :)\n\nRe CT in Bitcoin, I have my doubts whether you can get consensus for that.\n>From section 4.6 of the Bulletproofs paper [0]:\n\n\"Bulletproofs ... are computationally binding. An adversary that could\nbreak the discrete logarithm assumption could generate acceptable range\nproofs for a value outside the correct range. ... An adversary that can\nbreak the binding property of the commitment scheme or the soundness of\nthe proof system can generate coins out of thin air and thus create\nuncontrolled but undetectable inflation rendering the currency useless\"\n\nI don't have the domain knowledge to debate whether quantum computers will\never exist but AFAICT their emergence would easily kill a currency that\nuses these kind of range proofs for confidential transactions.\n\n\n[0]: https://eprint.iacr.org/2017/1066.pdf\n\n\n> From: \"Kenshiro []\" tensiam at hotmail.com\n>\n> Hi,\n>\n> I think Confidential Transactions (CT) are a great idea to provide enough privacy for normal users (hidden amounts) and fungibility.\n>\n> I would like to request the creation of a BIP to implement CT in Bitcoin Core. I read that CT are already implemented in Grin and Monero so it looks that CT are enough mature to be implemented in Bitcoin.\n>\n> If the CT transaction size is 3x the size of a normal transaction the block size could be increased by 3x too, or just keep the current block size and make CT transactions optional.\n>\n> Thank you!\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181229/71457bb6/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Create a BIP to implement Confidential Transactions in Bitcoin Core",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Kenshiro []",
                "SomberNight"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 4249
        }
    }
]