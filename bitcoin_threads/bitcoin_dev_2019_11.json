[
    {
        "title": "[bitcoin-dev] Draft BIP for SNICKER",
        "thread_messages": [
            {
                "author": "Riccardo Casatta",
                "date": "2019-11-06T16:52:06",
                "message_text_only": "Hello Adam,\n\nare you sure you can't tackle the watch-only issue?\n\nWhat if the proposer create the coinjoin-tx, plus another tx (encrypted\nwith the shared secret) which is a 1 input-1 output (1to1) tx which spend\nhis output to another of his key.\nAt this point when the receiver accept the proposal tx he could create\nother tx 1to1 which are spending his tweaked output to pure bip32 derived\nkey, he than broadcast together the coinjoin tx and for every output of the\ncoinjoin tx one other tx which is a 1to1 tx.\n\nNotes:\n* We are obviously spending more fee because there are more txs involved\nbut the receiver ends up having only bip32 derived outputs.\n* The receiver must create the 1to1 tx or the receiver lose privacy by\nbeing the only one to create 1to1 tx\n* a good strategy could be to let the coinjoin tx have a very low fee,\nwhile the 1to1 tx an higher one so there is less risk that only the\ncoinjoin gets mined\n* Whit this spending strategy, the wallet initial scan does not need to be\nmodified\n\n\nIl giorno mar 22 ott 2019 alle ore 15:29 AdamISZ via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> ha scritto:\n\n> Just to chime in on these points:\n>\n> My discussions with ghost43 and ThomasV led me to the same conclusion, at\n> least in general, for the whole watch-only issue:\n>\n> It's necessary that the key tweak (`c` as per draft BIP) be known by\n> Proposer (because has to add it to transaction before signing) and Receiver\n> (to check ownership), but must not be known by anyone else (else Coinjoin\n> function fails), hence it can't be publically derivable in any way but must\n> require information secret to the two parties. This can be a pure random\n> sent along with the encrypted proposal (the original concept), or based on\n> such, or implicit via ECDH (arubi's suggestion, now in the draft, requiring\n> each party to access their own secret key). So I reached the same\n> conclusion: the classic watch-only use case of monitoring a wallet in real\n> time with no privkey access is incompatible with this.\n>\n> It's worth mentioning a nuance, however: distinguish two requirements: (1)\n> to recover from zero information and (2) to monitor in real time as new\n> SNICKER transactions arrive.\n>\n> For (2) it's interesting to observe that the tweak `c` is not a\n> money-controlling secret; it's only a privacy-controlling secret. If you\n> imagined two wallets, one hot and one cold, with the second tracking the\n> first but having a lower security requirement because cold, then the `c`\n> values could be sent along from the hot to the cold, as they are created,\n> without changing the cold's security model as they are not\n> money-controlling private keys. They should still be encrypted of course,\n> but that's largely a technical detail, if they were exposed it would only\n> break the effect of the coinjoin outputs being indistinguishable.\n>\n> For (1) the above does not apply; for there, we don't have anyone telling\n> us what `c` values to look for, we have to somehow rederive, and to do that\n> we need key access, so it reverts to the discussion above about whether it\n> might be possible to interact with the cold wallet 'manually' so to speak.\n>\n> To be clear, I don't think either of the above paragraphs describe things\n> that are particularly likely to be implemented, but the hot/cold monitoring\n> is at least feasible, if there were enough desire for it.\n>\n> At the higher level, how important is this? I guess it just depends; there\n> are similar problems (not identical, and perhaps more addressable?) in\n> Lightning; importing keys is generally non-trivial; one can always sweep\n> non-standard keys back into the HD tree, but clearly that is not really a\n> solution in general; one can mark out wallets/seeds of this type as\n> distinct; not all wallets need to have watch-only (phone wallets? small\n> wallets? lower security?) one can prioritise spends of these coins. Etc.\n>\n> Some more general comments:\n>\n> Note Elichai's comment on the draft (repeated here for local convenience:\n> https://gist.github.com/AdamISZ/2c13fb5819bd469ca318156e2cf25d79#gistcomment-3014924)\n> about AES-GCM vs AES-CBC, any thoughts?\n>\n> I didn't discuss the security of the construction for a Receiver from a\n> Proposer who should after all be assumed to be an attacker (except, I\n> emphasised that PSBT parsing could be sensitive on this point); I hope it's\n> clear to everyone that the construction Q = P + cG is only controllable by\n> the owner of the discrete log of P (trivial reduction: if an attacker who\n> knows c, can find the private key q of Q, he can derive the private key p\n> of P as q - c, thus he is an ECDLP cracker).\n>\n> Thanks for all the comments so far, it's been very useful.\n>\n> AdamISZ/waxwing/Adam Gibson\n>\n> Sent with ProtonMail Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Monday, October 21, 2019 4:04 PM, SomberNight via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > > The SNICKER recovery process is, of course, only required for wallet\n> >\n> > recovery and not normal wallet use, so I don't think a small amount of\n> > round-trip communication between the hot wallet and the cold wallet is\n> > too much to ask---especially since anyone using SNICKER with a\n> > watching-only wallet must be regularly interacting with their cold\n> > wallet anyway to sign the coinjoins.\n> >\n> > What you described only considers the \"initial setup\" of a watch-only\n> wallet. There are many usecases for watch-only wallets. There doesn't even\n> necessarily need to be any offline-signing involved. For example, consider\n> a user who has a hot wallet on their laptop with xprv; and wants to watch\n> their addresses using an xpub from their mobile. Or consider giving an xpub\n> to an accountant. Or giving an xpub to your Electrum Personal Server (which\n> is how it works).\n> >\n> > Note that all these usecases require \"on-going\" discovery of addresses,\n> and so they would break.\n> >\n> > ghost43\n> >\n> > (ps: Apologies Dave for the double-email; forgot to cc list originally)\n> >\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n-- \nRiccardo Casatta - @RCasatta <https://twitter.com/RCasatta>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191106/8c5a95bc/attachment.html>"
            },
            {
                "author": "AdamISZ",
                "date": "2019-11-22T14:02:56",
                "message_text_only": "Hi Riccardo,\nApologies for not answering before, this slipped my mind.\nClearly what you propose is possible, and adding the proposer's own signed transaction is a nice touch to make it more privacy-viable.\nFor now my inclination is not to add this complexity, especially because of the cost implication.\nI'd note though that your idea about adding in second-stage transactions aligns with the CoinJoinXT idea (or perhaps, just the segwit idea!). Proposers could send sequences of transactions with various patterns, including backouts and promises, but it would clearly be way more complicated than what we're considering right now.\nRegards,\nAdam/waxwing\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Wednesday, November 6, 2019 4:52 PM, Riccardo Casatta via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello Adam,\n>\n> are you sure you can't tackle the watch-only issue?\n>\n> What if the proposer create the coinjoin-tx, plus another tx (encrypted with the shared secret) which is a 1 input-1 output (1to1) tx which spend his output to another of his key.\n> At this point when the receiver accept the proposal tx he could create other tx 1to1 which are spending his tweaked output to pure bip32 derived key, he than broadcast together the coinjoin tx and for every output of the coinjoin tx one other tx which is a 1to1 tx.\n>\n> Notes:\n> * We are obviously spending more fee because there are more txs involved but the receiver ends up having only bip32 derived outputs.\n>\n> * The receiver must create the 1to1 tx or the receiver lose privacy by being the only one to create 1to1 tx\n> * a good strategy could be to let the coinjoin tx have a very low fee, while the 1to1 tx an higher one so there is less risk that only the coinjoin gets mined\n> * Whit this spending strategy, the wallet initial scan does not need to be modified\n>\n> Il giorno mar 22 ott 2019 alle ore 15:29 AdamISZ via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> ha scritto:\n>\n>> Just to chime in on these points:\n>>\n>> My discussions with ghost43 and ThomasV led me to the same conclusion, at least in general, for the whole watch-only issue:\n>>\n>> It's necessary that the key tweak (`c` as per draft BIP) be known by Proposer (because has to add it to transaction before signing) and Receiver (to check ownership), but must not be known by anyone else (else Coinjoin function fails), hence it can't be publically derivable in any way but must require information secret to the two parties. This can be a pure random sent along with the encrypted proposal (the original concept), or based on such, or implicit via ECDH (arubi's suggestion, now in the draft, requiring each party to access their own secret key). So I reached the same conclusion: the classic watch-only use case of monitoring a wallet in real time with no privkey access is incompatible with this.\n>>\n>> It's worth mentioning a nuance, however: distinguish two requirements: (1) to recover from zero information and (2) to monitor in real time as new SNICKER transactions arrive.\n>>\n>> For (2) it's interesting to observe that the tweak `c` is not a money-controlling secret; it's only a privacy-controlling secret. If you imagined two wallets, one hot and one cold, with the second tracking the first but having a lower security requirement because cold, then the `c` values could be sent along from the hot to the cold, as they are created, without changing the cold's security model as they are not money-controlling private keys. They should still be encrypted of course, but that's largely a technical detail, if they were exposed it would only break the effect of the coinjoin outputs being indistinguishable.\n>>\n>> For (1) the above does not apply; for there, we don't have anyone telling us what `c` values to look for, we have to somehow rederive, and to do that we need key access, so it reverts to the discussion above about whether it might be possible to interact with the cold wallet 'manually' so to speak.\n>>\n>> To be clear, I don't think either of the above paragraphs describe things that are particularly likely to be implemented, but the hot/cold monitoring is at least feasible, if there were enough desire for it.\n>>\n>> At the higher level, how important is this? I guess it just depends; there are similar problems (not identical, and perhaps more addressable?) in Lightning; importing keys is generally non-trivial; one can always sweep non-standard keys back into the HD tree, but clearly that is not really a solution in general; one can mark out wallets/seeds of this type as distinct; not all wallets need to have watch-only (phone wallets? small wallets? lower security?) one can prioritise spends of these coins. Etc.\n>>\n>> Some more general comments:\n>>\n>> Note Elichai's comment on the draft (repeated here for local convenience: https://gist.github.com/AdamISZ/2c13fb5819bd469ca318156e2cf25d79#gistcomment-3014924) about AES-GCM vs AES-CBC, any thoughts?\n>>\n>> I didn't discuss the security of the construction for a Receiver from a Proposer who should after all be assumed to be an attacker (except, I emphasised that PSBT parsing could be sensitive on this point); I hope it's clear to everyone that the construction Q = P + cG is only controllable by the owner of the discrete log of P (trivial reduction: if an attacker who knows c, can find the private key q of Q, he can derive the private key p of P as q - c, thus he is an ECDLP cracker).\n>>\n>> Thanks for all the comments so far, it's been very useful.\n>>\n>> AdamISZ/waxwing/Adam Gibson\n>>\n>> Sent with ProtonMail Secure Email.\n>>\n>> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>> On Monday, October 21, 2019 4:04 PM, SomberNight via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> > The SNICKER recovery process is, of course, only required for wallet\n>>>\n>>> recovery and not normal wallet use, so I don't think a small amount of\n>>> round-trip communication between the hot wallet and the cold wallet is\n>>> too much to ask---especially since anyone using SNICKER with a\n>>> watching-only wallet must be regularly interacting with their cold\n>>> wallet anyway to sign the coinjoins.\n>>>\n>>> What you described only considers the \"initial setup\" of a watch-only wallet. There are many usecases for watch-only wallets. There doesn't even necessarily need to be any offline-signing involved. For example, consider a user who has a hot wallet on their laptop with xprv; and wants to watch their addresses using an xpub from their mobile. Or consider giving an xpub to an accountant. Or giving an xpub to your Electrum Personal Server (which is how it works).\n>>>\n>>> Note that all these usecases require \"on-going\" discovery of addresses, and so they would break.\n>>>\n>>> ghost43\n>>>\n>>> (ps: Apologies Dave for the double-email; forgot to cc list originally)\n>>>\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> --\n> Riccardo Casatta - [@RCasatta](https://twitter.com/RCasatta)\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191122/340f75bb/attachment.html>"
            },
            {
                "author": "popo",
                "date": "2019-11-22T14:57:10",
                "message_text_only": "Hi, AFAIK snicker is limited to 2 party mixes for the foreseeable future.\nWhat makes this a useful anonymity system for cryptocurrency/Bitcoin?\n\nThanks\n\nOn 11/22/19 3:02 PM, AdamISZ via bitcoin-dev wrote:\n> Hi Riccardo,\n> Apologies for not answering before, this slipped my mind.\n> Clearly what you propose is possible, and adding the proposer's own\n> signed transaction is a nice touch to make it more privacy-viable.\n> For now my inclination is not to add this complexity, especially because\n> of the cost implication.\n> I'd note though that your idea about adding in second-stage transactions\n> aligns with the CoinJoinXT idea (or perhaps, just the segwit idea!).\n> Proposers could send sequences of transactions with various patterns,\n> including backouts and promises, but it would clearly be way more\n> complicated than what we're considering right now.\n> Regards,\n> Adam/waxwing\n> \n> \n> Sent with ProtonMail <https://protonmail.com> Secure Email.\n> \n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Wednesday, November 6, 2019 4:52 PM, Riccardo Casatta via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n>> Hello Adam,\n>>\n>> are you sure you can't tackle the watch-only issue?\n>>\n>> What if the proposer create the coinjoin-tx, plus another tx\n>> (encrypted with the shared secret) which is a 1 input-1 output (1to1)\n>> tx which spend his output to another of his key.\n>> At this point when the receiver accept the proposal tx he could create\n>> other tx 1to1 which are spending his tweaked output to pure bip32\n>> derived key, he than broadcast together the coinjoin tx and for every\n>> output of the coinjoin tx one other tx which is a 1to1 tx.\n>>\n>> Notes:\n>> * We are obviously spending more fee because there are more txs\n>> involved but the receiver ends up having only bip32 derived outputs.\n>>\n>> * The receiver must create the 1to1 tx or the receiver lose privacy by\n>> being the only one to create 1to1 tx\n>> * a good strategy could be to let the coinjoin tx have a very low fee,\n>> while the 1to1 tx an higher one so there is less risk that only the\n>> coinjoin gets mined\n>> * Whit this spending strategy, the wallet initial scan does not need\n>> to be modified\n>>\n>>\n>> Il giorno mar 22 ott 2019 alle ore 15:29 AdamISZ via bitcoin-dev\n>> <bitcoin-dev at lists.linuxfoundation.org\n>> <mailto:bitcoin-dev at lists.linuxfoundation.org>> ha scritto:\n>>\n>>     Just to chime in on these points:\n>>\n>>     My discussions with ghost43 and ThomasV led me to the same\n>>     conclusion, at least in general, for the whole watch-only issue:\n>>\n>>     It's necessary that the key tweak (`c` as per draft BIP) be known\n>>     by Proposer (because has to add it to transaction before signing)\n>>     and Receiver (to check ownership), but must not be known by anyone\n>>     else (else Coinjoin function fails), hence it can't be publically\n>>     derivable in any way but must require information secret to the\n>>     two parties. This can be a pure random sent along with the\n>>     encrypted proposal (the original concept), or based on such, or\n>>     implicit via ECDH (arubi's suggestion, now in the draft, requiring\n>>     each party to access their own secret key). So I reached the same\n>>     conclusion: the classic watch-only use case of monitoring a wallet\n>>     in real time with no privkey access is incompatible with this.\n>>\n>>     It's worth mentioning a nuance, however: distinguish two\n>>     requirements: (1) to recover from zero information and (2) to\n>>     monitor in real time as new SNICKER transactions arrive.\n>>\n>>     For (2) it's interesting to observe that the tweak `c` is not a\n>>     money-controlling secret; it's only a privacy-controlling secret.\n>>     If you imagined two wallets, one hot and one cold, with the second\n>>     tracking the first but having a lower security requirement because\n>>     cold, then the `c` values could be sent along from the hot to the\n>>     cold, as they are created, without changing the cold's security\n>>     model as they are not money-controlling private keys. They should\n>>     still be encrypted of course, but that's largely a technical\n>>     detail, if they were exposed it would only break the effect of the\n>>     coinjoin outputs being indistinguishable.\n>>\n>>     For (1) the above does not apply; for there, we don't have anyone\n>>     telling us what `c` values to look for, we have to somehow\n>>     rederive, and to do that we need key access, so it reverts to the\n>>     discussion above about whether it might be possible to interact\n>>     with the cold wallet 'manually' so to speak.\n>>\n>>     To be clear, I don't think either of the above paragraphs describe\n>>     things that are particularly likely to be implemented, but the\n>>     hot/cold monitoring is at least feasible, if there were enough\n>>     desire for it.\n>>\n>>     At the higher level, how important is this? I guess it just\n>>     depends; there are similar problems (not identical, and perhaps\n>>     more addressable?) in Lightning; importing keys is generally\n>>     non-trivial; one can always sweep non-standard keys back into the\n>>     HD tree, but clearly that is not really a solution in general; one\n>>     can mark out wallets/seeds of this type as distinct; not all\n>>     wallets need to have watch-only (phone wallets? small wallets?\n>>     lower security?) one can prioritise spends of these coins. Etc.\n>>\n>>     Some more general comments:\n>>\n>>     Note Elichai's comment on the draft (repeated here for local\n>>     convenience:\n>>     https://gist.github.com/AdamISZ/2c13fb5819bd469ca318156e2cf25d79#gistcomment-3014924)\n>>     about AES-GCM vs AES-CBC, any thoughts?\n>>\n>>     I didn't discuss the security of the construction for a Receiver\n>>     from a Proposer who should after all be assumed to be an attacker\n>>     (except, I emphasised that PSBT parsing could be sensitive on this\n>>     point); I hope it's clear to everyone that the construction Q = P\n>>     + cG is only controllable by the owner of the discrete log of P\n>>     (trivial reduction: if an attacker who knows c, can find the\n>>     private key q of Q, he can derive the private key p of P as q - c,\n>>     thus he is an ECDLP cracker).\n>>\n>>     Thanks for all the comments so far, it's been very useful.\n>>\n>>     AdamISZ/waxwing/Adam Gibson\n>>\n>>     Sent with ProtonMail Secure Email.\n>>\n>>     \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>>     On Monday, October 21, 2019 4:04 PM, SomberNight via bitcoin-dev\n>>     <bitcoin-dev at lists.linuxfoundation.org\n>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>>\n>>     > > The SNICKER recovery process is, of course, only required for\n>>     wallet\n>>     >\n>>     > recovery and not normal wallet use, so I don't think a small\n>>     amount of\n>>     > round-trip communication between the hot wallet and the cold\n>>     wallet is\n>>     > too much to ask---especially since anyone using SNICKER with a\n>>     > watching-only wallet must be regularly interacting with their cold\n>>     > wallet anyway to sign the coinjoins.\n>>     >\n>>     > What you described only considers the \"initial setup\" of a\n>>     watch-only wallet. There are many usecases for watch-only wallets.\n>>     There doesn't even necessarily need to be any offline-signing\n>>     involved. For example, consider a user who has a hot wallet on\n>>     their laptop with xprv; and wants to watch their addresses using\n>>     an xpub from their mobile. Or consider giving an xpub to an\n>>     accountant. Or giving an xpub to your Electrum Personal Server\n>>     (which is how it works).\n>>     >\n>>     > Note that all these usecases require \"on-going\" discovery of\n>>     addresses, and so they would break.\n>>     >\n>>     > ghost43\n>>     >\n>>     > (ps: Apologies Dave for the double-email; forgot to cc list\n>>     originally)\n>>     >\n>>     > bitcoin-dev mailing list\n>>     > bitcoin-dev at lists.linuxfoundation.org\n>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>>     > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>>     _______________________________________________\n>>     bitcoin-dev mailing list\n>>     bitcoin-dev at lists.linuxfoundation.org\n>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>>\n>> -- \n>> Riccardo Casatta - @RCasatta <https://twitter.com/RCasatta>\n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "AdamISZ",
                "date": "2019-11-23T12:43:27",
                "message_text_only": "Two party mixes can be useful in the context of a very large number of them.\nThere is no pretence that doing one such, or even doing several such, gives any privacy *guarantees*.\nHowever, if it can be arranged that such 'mixes' occur frequently across a broad spectrum of wallets - and the claim is that that is possible precisely because at least one of the two participants needs to do *absolutely nothing at all* for the join to happen - then the degradation of blockchain analysis could be pretty severe.\n\nWhat's described here therefore is essentially an attempt to go to the other far extreme from 'rigidly controlled and coordinated large mix sets' to 'ultra loosely coupled almost zero coordination mixing', trading off size in one step for convenience/low effort/even zero effort mixing. Part of that may (or may not) involve Proposers being specialised entities, and it's only the Receiver side that's zero effort.\n\nIt should be noted that the two extremes are not incompatible; if one is valuable, it doesn't mean the other isn't.\n\nBut what I think you can deduce: a proposal to do SNICKER that just involved a very small set of users would not be much use (still not zero, though); the tradeoffs have been made having in mind the idea of more usage, especially more *broad* usage.\n\nAnswering about 2 party joins in more general terms:\n\nAny such coinjoin, no matter its pattern, will break the common input ownership heuristic. If there are equal sized outputs of the same scriptpubkey type (as is proposed) then that delinking effect is of considerable value also.\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Friday, November 22, 2019 2:57 PM, popo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi, AFAIK snicker is limited to 2 party mixes for the foreseeable future.\n> What makes this a useful anonymity system for cryptocurrency/Bitcoin?\n>\n> Thanks\n>\n> On 11/22/19 3:02 PM, AdamISZ via bitcoin-dev wrote:\n>\n> > Hi Riccardo,\n> > Apologies for not answering before, this slipped my mind.\n> > Clearly what you propose is possible, and adding the proposer's own\n> > signed transaction is a nice touch to make it more privacy-viable.\n> > For now my inclination is not to add this complexity, especially because\n> > of the cost implication.\n> > I'd note though that your idea about adding in second-stage transactions\n> > aligns with the CoinJoinXT idea (or perhaps, just the segwit idea!).\n> > Proposers could send sequences of transactions with various patterns,\n> > including backouts and promises, but it would clearly be way more\n> > complicated than what we're considering right now.\n> > Regards,\n> > Adam/waxwing\n> > Sent with ProtonMail https://protonmail.com Secure Email.\n> > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> > On Wednesday, November 6, 2019 4:52 PM, Riccardo Casatta via bitcoin-dev\n> > bitcoin-dev at lists.linuxfoundation.org wrote:\n> >\n> > > Hello Adam,\n> > > are you sure you can't tackle the watch-only issue?\n> > > What if the proposer create the coinjoin-tx, plus another tx\n> > > (encrypted with the shared secret) which is a 1 input-1 output (1to1)\n> > > tx which spend his output to another of his key.\n> > > At this point when the receiver accept the proposal tx he could create\n> > > other tx 1to1 which are spending his tweaked output to pure bip32\n> > > derived key, he than broadcast together the coinjoin tx and for every\n> > > output of the coinjoin tx one other tx which is a 1to1 tx.\n> > > Notes:\n> > >\n> > > -   We are obviously spending more fee because there are more txs\n> > >     involved but the receiver ends up having only bip32 derived outputs.\n> > >\n> > > -   The receiver must create the 1to1 tx or the receiver lose privacy by\n> > >     being the only one to create 1to1 tx\n> > >\n> > > -   a good strategy could be to let the coinjoin tx have a very low fee,\n> > >     while the 1to1 tx an higher one so there is less risk that only the\n> > >     coinjoin gets mined\n> > >\n> > > -   Whit this spending strategy, the wallet initial scan does not need\n> > >     to be modified\n> > >\n> > >\n> > > Il giorno mar 22 ott 2019 alle ore 15:29 AdamISZ via bitcoin-dev\n> > > <bitcoin-dev at lists.linuxfoundation.org\n> > > mailto:bitcoin-dev at lists.linuxfoundation.org> ha scritto:\n> > >\n> > >     Just to chime in on these points:\n> > >\n> > >     My discussions with ghost43 and ThomasV led me to the same\n> > >     conclusion, at least in general, for the whole watch-only issue:\n> > >\n> > >     It's necessary that the key tweak (`c` as per draft BIP) be known\n> > >     by Proposer (because has to add it to transaction before signing)\n> > >     and Receiver (to check ownership), but must not be known by anyone\n> > >     else (else Coinjoin function fails), hence it can't be publically\n> > >     derivable in any way but must require information secret to the\n> > >     two parties. This can be a pure random sent along with the\n> > >     encrypted proposal (the original concept), or based on such, or\n> > >     implicit via ECDH (arubi's suggestion, now in the draft, requiring\n> > >     each party to access their own secret key). So I reached the same\n> > >     conclusion: the classic watch-only use case of monitoring a wallet\n> > >     in real time with no privkey access is incompatible with this.\n> > >\n> > >     It's worth mentioning a nuance, however: distinguish two\n> > >     requirements: (1) to recover from zero information and (2) to\n> > >     monitor in real time as new SNICKER transactions arrive.\n> > >\n> > >     For (2) it's interesting to observe that the tweak `c` is not a\n> > >     money-controlling secret; it's only a privacy-controlling secret.\n> > >     If you imagined two wallets, one hot and one cold, with the second\n> > >     tracking the first but having a lower security requirement because\n> > >     cold, then the `c` values could be sent along from the hot to the\n> > >     cold, as they are created, without changing the cold's security\n> > >     model as they are not money-controlling private keys. They should\n> > >     still be encrypted of course, but that's largely a technical\n> > >     detail, if they were exposed it would only break the effect of the\n> > >     coinjoin outputs being indistinguishable.\n> > >\n> > >     For (1) the above does not apply; for there, we don't have anyone\n> > >     telling us what `c` values to look for, we have to somehow\n> > >     rederive, and to do that we need key access, so it reverts to the\n> > >     discussion above about whether it might be possible to interact\n> > >     with the cold wallet 'manually' so to speak.\n> > >\n> > >     To be clear, I don't think either of the above paragraphs describe\n> > >     things that are particularly likely to be implemented, but the\n> > >     hot/cold monitoring is at least feasible, if there were enough\n> > >     desire for it.\n> > >\n> > >     At the higher level, how important is this? I guess it just\n> > >     depends; there are similar problems (not identical, and perhaps\n> > >     more addressable?) in Lightning; importing keys is generally\n> > >     non-trivial; one can always sweep non-standard keys back into the\n> > >     HD tree, but clearly that is not really a solution in general; one\n> > >     can mark out wallets/seeds of this type as distinct; not all\n> > >     wallets need to have watch-only (phone wallets? small wallets?\n> > >     lower security?) one can prioritise spends of these coins. Etc.\n> > >\n> > >     Some more general comments:\n> > >\n> > >     Note Elichai's comment on the draft (repeated here for local\n> > >     convenience:\n> > >     https://gist.github.com/AdamISZ/2c13fb5819bd469ca318156e2cf25d79#gistcomment-3014924)\n> > >     about AES-GCM vs AES-CBC, any thoughts?\n> > >\n> > >     I didn't discuss the security of the construction for a Receiver\n> > >     from a Proposer who should after all be assumed to be an attacker\n> > >     (except, I emphasised that PSBT parsing could be sensitive on this\n> > >     point); I hope it's clear to everyone that the construction Q = P\n> > >     + cG is only controllable by the owner of the discrete log of P\n> > >     (trivial reduction: if an attacker who knows c, can find the\n> > >     private key q of Q, he can derive the private key p of P as q - c,\n> > >     thus he is an ECDLP cracker).\n> > >\n> > >     Thanks for all the comments so far, it's been very useful.\n> > >\n> > >     AdamISZ/waxwing/Adam Gibson\n> > >\n> > >     Sent with ProtonMail Secure Email.\n> > >\n> > >     \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> > >     On Monday, October 21, 2019 4:04 PM, SomberNight via bitcoin-dev\n> > >     <bitcoin-dev at lists.linuxfoundation.org\n> > >     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> > >\n> > >     > > The SNICKER recovery process is, of course, only required for\n> > >     wallet\n> > >     >\n> > >     > recovery and not normal wallet use, so I don't think a small\n> > >     amount of\n> > >     > round-trip communication between the hot wallet and the cold\n> > >     wallet is\n> > >     > too much to ask---especially since anyone using SNICKER with a\n> > >     > watching-only wallet must be regularly interacting with their cold\n> > >     > wallet anyway to sign the coinjoins.\n> > >     >\n> > >     > What you described only considers the \"initial setup\" of a\n> > >     watch-only wallet. There are many usecases for watch-only wallets.\n> > >     There doesn't even necessarily need to be any offline-signing\n> > >     involved. For example, consider a user who has a hot wallet on\n> > >     their laptop with xprv; and wants to watch their addresses using\n> > >     an xpub from their mobile. Or consider giving an xpub to an\n> > >     accountant. Or giving an xpub to your Electrum Personal Server\n> > >     (which is how it works).\n> > >     >\n> > >     > Note that all these usecases require \"on-going\" discovery of\n> > >     addresses, and so they would break.\n> > >     >\n> > >     > ghost43\n> > >     >\n> > >     > (ps: Apologies Dave for the double-email; forgot to cc list\n> > >     originally)\n> > >     >\n> > >     > bitcoin-dev mailing list\n> > >     > bitcoin-dev at lists.linuxfoundation.org\n> > >     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n> > >     > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> > >\n> > >\n> > >     _______________________________________________\n> > >     bitcoin-dev mailing list\n> > >     bitcoin-dev at lists.linuxfoundation.org\n> > >     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n> > >     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> > >\n> > >\n> > > --\n> > > Riccardo Casatta - @RCasatta https://twitter.com/RCasatta\n> >\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "Draft BIP for SNICKER",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "AdamISZ",
                "Riccardo Casatta",
                "popo"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 33651
        }
    },
    {
        "title": "[bitcoin-dev] Dynamic MaxBlockSize - 3 Byte Solution",
        "thread_messages": [
            {
                "author": "Trevor Groves",
                "date": "2019-11-07T03:33:36",
                "message_text_only": "Dynamic MaxBlockSize  - 3 Byte Solution\n\"DMBS\"\n\nIf\n(Last TOTAL Block Trans fees)  >  (AVG (Last 100 Blocks Trans Fees))\nAND\ncurrent MaxBlockSize  => 0.99 MB\nAND\nMaxBlockSize has not changed in 10 Blocks\n** see error catch below\nThen\nON (Current Block #  + 9)  Set MaxBlockSize  = (MaxBlockSize x 1.1)\nELSE\nAT (Current Block #  + 9)  Set MaxBlockSize  = (MaxBlockSize  / 1.1)\nELSEIF\n(current MaxBlockSize  =< 0.99  or current MaxBlockSize > 6553.5 MB)\nNull (no action taken)\n**where 9 above represents the ActivateONBlock (software side) Variable\n -------------\nWe add this 3 Byte Variable Factor to the white space in the Current Block.\n\neg.  this 3 byte HEX    19000A\nthe first bit \"1\"  can be 1,2 or 0\n1  =  increase future block (9 blocks ahead)\n2  decrease future block  (9 blocks ahead)\n0    No Action (rules evaluate to null)\n**where 9 above represents the ActivateONBlock (software side) Variable\n--------------\nThe Second bit is a Global Variable \"9\" represents a countdown to the set\nvalue action, placed to synchronize network forward  changes in \"x\" blocks.\nsoftware lowers value if evaluates to True a second time  and so on.\n(\"Count down\" if you will)\nthe last 2 bytes represent  the globally accepted \"MaxBlockSize\" Variable,\nand is distributed within each block moving forward in this rightmost (2\nbyte) factor.  In this case above,\nThe variable portion  \"000A\" (32 Bit value) represents decimal value 10\nbeing 1.0 MB block.\nthe decimal place is Always Assumed, and must be hard coded\nBecause this presents a  theoretical  Max limit of \"FFFF\"  or 6553.5 MB, We\nwould\nhave to add a last rule \"only as a error catch\"\n ** AND IF MaxBlockSize < 6553.5\n---\nIncreasing and decreasing\nOn Every Block mined or distributed, the software can run the above rule\nset, Change the Variable and Distribute the next block \" In Synchronized\nfashion\". The above rules when combined evaluate to a YES or NO, This\ntranslates to a market reflection of increased system pressure or decreased\nmarket pressure.   I think we can agree, at peak periods the system chokes\nitself off with fees and this is always only temporarily.  So we can have\nthe block, analyse system demand dynamically, and adjust on a globally\nagreed rule dynamically by market driven demand.\nConsidering the ruleset above also Decreases  the Block ONLY if its greater\nthan 0.99mb this brings size back to a competitive state /and size once\nmarket demand pressures subside, yet achieves the smallest market feasible\nblock size while also maintaining all current rule sets.\n An attacker would have to affect all block fees over the last 16 hours\nworth of transactions to affect a 10% max block size increase but then only\nafter waiting 1.5 hours, so long as nothing has changed in the last 1.5\nhours and only for a limited amount of time. This approach also limits\nbloat. This safety block window of 9 blocks provides a look forward and\nlook behind value, in turn provides the network time to synchronize.\n10 block sync window.  This, by design, also limits changes to one change\nevery 3 hours (20 blocks), if there is a market pressure \"STATE\" occurring.\nMy Question to the community is. Will our current Block accommodate the 3\nByte\nVariable, Is solving the Scaling issue worth using the 3 Bytes of space?\nI believe it is.\n--\nSoftware,  Will need  to Evaluate MaxBlockSize Variable, and\nActivateONBlock Variable from the most recent distributed blocks DMBS  3\nbyte value.\nRun the rules , get the answer set the now known MaxBlockSize Var and\nPropegate the \"DMBS\" value.\n\nAs capacity limits are breached, I think the majority agree \"we need to\nagree\".\n\nMaxBlockSize would provide a suitable middle ground and address concerns in\na dynamic fashion, without compromising  or changing  existing security.\n Examples reflected in the blockchain 19000A   rules has evaluates to\ntrue, increase expected in 9 blocks.1.0mb increases to 1.1mb\nif true for 9 more blocks  MaxBlockSize Var becomes  18000A..\n17000A..,16000A ..and so on if  still true at 10000A var written becomes\n00000B when read from left to right,  0-no change, in 0 blocks current \"\nDMBS\" value 000B or 1.1MB  and stays that way  00000B until MaxBlockSize\nevaluates to \"True\" under a market pressure/ relief situation.\nI hope this makes sense, I would appreciate some feedback.\nTG\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191106/ec280d20/attachment-0001.html>"
            },
            {
                "author": "Emil Engler",
                "date": "2019-11-08T14:36:52",
                "message_text_only": "NACK!\n1. We have Lightning and SegWit so thankfully we do not need to deal with\nblocksizes anymore really.\n2. What if a reorg happens? Then it could generate huge problems at the\nvalidation.\n\nCorrect me if I understood it wrong please.\n\nGreetings,\nEmil Engler\n\nTrevor Groves via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nschrieb am Fr. 8. Nov. 2019 um 15:26:\n\n> Dynamic MaxBlockSize  - 3 Byte Solution\n> \"DMBS\"\n>\n> If\n> (Last TOTAL Block Trans fees)  >  (AVG (Last 100 Blocks Trans Fees))\n> AND\n> current MaxBlockSize  => 0.99 MB\n> AND\n> MaxBlockSize has not changed in 10 Blocks\n> ** see error catch below\n> Then\n> ON (Current Block #  + 9)  Set MaxBlockSize  = (MaxBlockSize x 1.1)\n> ELSE\n> AT (Current Block #  + 9)  Set MaxBlockSize  = (MaxBlockSize  / 1.1)\n> ELSEIF\n> (current MaxBlockSize  =< 0.99  or current MaxBlockSize > 6553.5 MB)\n> Null (no action taken)\n> **where 9 above represents the ActivateONBlock (software side) Variable\n>  -------------\n> We add this 3 Byte Variable Factor to the white space in the Current Block.\n>\n> eg.  this 3 byte HEX    19000A\n> the first bit \"1\"  can be 1,2 or 0\n> 1  =  increase future block (9 blocks ahead)\n> 2  decrease future block  (9 blocks ahead)\n> 0    No Action (rules evaluate to null)\n> **where 9 above represents the ActivateONBlock (software side) Variable\n> --------------\n> The Second bit is a Global Variable \"9\" represents a countdown to the set\n> value action, placed to synchronize network forward  changes in \"x\" blocks.\n> software lowers value if evaluates to True a second time  and so on.\n> (\"Count down\" if you will)\n> the last 2 bytes represent  the globally accepted \"MaxBlockSize\" Variable,\n> and is distributed within each block moving forward in this rightmost (2\n> byte) factor.  In this case above,\n> The variable portion  \"000A\" (32 Bit value) represents decimal value 10\n> being 1.0 MB block.\n> the decimal place is Always Assumed, and must be hard coded\n> Because this presents a  theoretical  Max limit of \"FFFF\"  or 6553.5 MB,\n> We would\n> have to add a last rule \"only as a error catch\"\n>  ** AND IF MaxBlockSize < 6553.5\n> ---\n> Increasing and decreasing\n> On Every Block mined or distributed, the software can run the above rule\n> set, Change the Variable and Distribute the next block \" In Synchronized\n> fashion\". The above rules when combined evaluate to a YES or NO, This\n> translates to a market reflection of increased system pressure or decreased\n> market pressure.   I think we can agree, at peak periods the system chokes\n> itself off with fees and this is always only temporarily.  So we can have\n> the block, analyse system demand dynamically, and adjust on a globally\n> agreed rule dynamically by market driven demand.\n> Considering the ruleset above also Decreases  the Block ONLY if its\n> greater than 0.99mb this brings size back to a competitive state /and size\n> once market demand pressures subside, yet achieves the smallest market\n> feasible block size while also maintaining all current rule sets.\n>  An attacker would have to affect all block fees over the last 16 hours\n> worth of transactions to affect a 10% max block size increase but then only\n> after waiting 1.5 hours, so long as nothing has changed in the last 1.5\n> hours and only for a limited amount of time. This approach also limits\n> bloat. This safety block window of 9 blocks provides a look forward and\n> look behind value, in turn provides the network time to synchronize.\n> 10 block sync window.  This, by design, also limits changes to one change\n> every 3 hours (20 blocks), if there is a market pressure \"STATE\" occurring.\n> My Question to the community is. Will our current Block accommodate the 3\n> Byte\n> Variable, Is solving the Scaling issue worth using the 3 Bytes of space?\n> I believe it is.\n> --\n> Software,  Will need  to Evaluate MaxBlockSize Variable, and\n> ActivateONBlock Variable from the most recent distributed blocks DMBS  3\n> byte value.\n> Run the rules , get the answer set the now known MaxBlockSize Var and\n> Propegate the \"DMBS\" value.\n>\n> As capacity limits are breached, I think the majority agree \"we need to\n> agree\".\n>\n> MaxBlockSize would provide a suitable middle ground and address concerns\n> in a dynamic fashion, without compromising  or changing  existing\n> security.\n>  Examples reflected in the blockchain 19000A   rules has evaluates to\n> true, increase expected in 9 blocks.1.0mb increases to 1.1mb\n> if true for 9 more blocks  MaxBlockSize Var becomes  18000A..\n> 17000A..,16000A ..and so on if  still true at 10000A var written becomes\n> 00000B when read from left to right,  0-no change, in 0 blocks current \"\n> DMBS\" value 000B or 1.1MB  and stays that way  00000B until MaxBlockSize\n> evaluates to \"True\" under a market pressure/ relief situation.\n> I hope this makes sense, I would appreciate some feedback.\n> TG\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191108/788a634f/attachment.html>"
            },
            {
                "author": "Joachim Str\u00f6mbergson",
                "date": "2019-11-08T15:19:17",
                "message_text_only": "While I agree on NACKing the proposal as it does not add anything new and fundamentally misunderstands what scaling is (or is not in this case), I disagree with the claim that we do not need to deal with block size issue in the future any more. Segwit increased our possibilities on how to use the space more efficiently, but so far it did not completely. It's yet to be seen if advanced offchain constructions such as channel factories are enough. At this moment to claim that would be very bold and hardly justified.\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Friday, November 8, 2019 2:36 PM, Emil Engler via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> NACK!\n> 1. We have Lightning and SegWit so thankfully we do not need to deal with blocksizes anymore really.\n> 2. What if a reorg happens? Then it could generate huge problems at the validation.\n>\n> Correct me if I understood it wrong please.\n>\n> Greetings,\n> Emil Engler\n>\n> Trevor Groves via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> schrieb am Fr. 8. Nov. 2019 um 15:26:\n>\n>> Dynamic MaxBlockSize  - 3 Byte Solution\n>> \"DMBS\"\n>>\n>> If\n>> (Last TOTAL Block Trans fees)  >  (AVG (Last 100 Blocks Trans Fees))\n>> AND\n>> current MaxBlockSize  => 0.99 MB\n>> AND\n>> MaxBlockSize has not changed in 10 Blocks\n>> ** see error catch below\n>> Then\n>> ON (Current Block #  + 9)  Set MaxBlockSize  = (MaxBlockSize x 1.1)\n>> ELSE\n>> AT (Current Block #  + 9)  Set MaxBlockSize  = (MaxBlockSize  / 1.1)\n>> ELSEIF\n>> (current MaxBlockSize  =< 0.99  or current MaxBlockSize > 6553.5 MB)\n>> Null (no action taken)\n>> **where 9 above represents the ActivateONBlock (software side) Variable\n>>  -------------\n>> We add this 3 Byte Variable Factor to the white space in the Current Block.\n>>\n>> eg.  this 3 byte HEX    19000A\n>> the first bit \"1\"  can be 1,2 or 0\n>> 1  =  increase future block (9 blocks ahead)\n>> 2  decrease future block  (9 blocks ahead)\n>> 0    No Action (rules evaluate to null)\n>> **where 9 above represents the ActivateONBlock (software side) Variable\n>> --------------\n>> The Second bit is a Global Variable \"9\" represents a countdown to the set value action, placed to synchronize network forward  changes in \"x\" blocks. software lowers value if evaluates to True a second time  and so on.\n>> (\"Count down\" if you will)\n>> the last 2 bytes represent  the globally accepted \"MaxBlockSize\" Variable, and is distributed within each block moving forward in this rightmost (2 byte) factor.  In this case above,\n>> The variable portion  \"000A\" (32 Bit value) represents decimal value 10 being 1.0 MB block.\n>> the decimal place is Always Assumed, and must be hard coded\n>> Because this presents a  theoretical  Max limit of \"FFFF\"  or 6553.5 MB, We would\n>> have to add a last rule \"only as a error catch\"\n>>  ** AND IF MaxBlockSize < 6553.5\n>> ---\n>> Increasing and decreasing\n>> On Every Block mined or distributed, the software can run the above rule set, Change the Variable and Distribute the next block \" In Synchronized fashion\". The above rules when combined evaluate to a YES or NO, This translates to a market reflection of increased system pressure or decreased market pressure.   I think we can agree, at peak periods the system chokes itself off with fees and this is always only temporarily.  So we can have the block, analyse system demand dynamically, and adjust on a globally agreed rule dynamically by market driven demand.\n>> Considering the ruleset above also Decreases  the Block ONLY if its greater than 0.99mb this brings size back to a competitive state /and size once market demand pressures subside, yet achieves the smallest market feasible block size while also maintaining all current rule sets.\n>>  An attacker would have to affect all block fees over the last 16 hours worth of transactions to affect a 10% max block size increase but then only after waiting 1.5 hours, so long as nothing has changed in the last 1.5 hours and only for a limited amount of time. This approach also limits bloat. This safety block window of 9 blocks provides a look forward and look behind value, in turn provides the network time to synchronize.\n>> 10 block sync window.  This, by design, also limits changes to one change  every 3 hours (20 blocks), if there is a market pressure \"STATE\" occurring.\n>> My Question to the community is. Will our current Block accommodate the 3 Byte\n>> Variable, Is solving the Scaling issue worth using the 3 Bytes of space?\n>> I believe it is.\n>> --\n>> Software,  Will need  to Evaluate MaxBlockSize Variable, and ActivateONBlock Variable from the most recent distributed blocks DMBS  3 byte value.\n>> Run the rules , get the answer set the now known MaxBlockSize Var and Propegate the \"DMBS\" value.\n>>\n>> As capacity limits are breached, I think the majority agree \"we need to agree\".\n>>\n>> MaxBlockSize would provide a suitable middle ground and address concerns in a dynamic fashion, without compromising  or changing  existing security.\n>>  Examples reflected in the blockchain 19000A   rules has evaluates to  true, increase expected in 9 blocks.1.0mb increases to 1.1mb\n>> if true for 9 more blocks  MaxBlockSize Var becomes  18000A.. 17000A..,16000A ..and so on if  still true at 10000A var written becomes\n>> 00000B when read from left to right,  0-no change, in 0 blocks current \" DMBS\" value 000B or 1.1MB  and stays that way  00000B until MaxBlockSize  evaluates to \"True\" under a market pressure/ relief situation.\n>> I hope this makes sense, I would appreciate some feedback.\n>> TG\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191108/d63a8de2/attachment-0001.html>"
            },
            {
                "author": "Alberto Aldave",
                "date": "2019-11-08T17:04:20",
                "message_text_only": "NACK\n\n1.- At some point in time, fees will need to be the the main part of the reward of miners, so, I do not see any need to lower them. If we keep them forever low, the network will be less and less secure because of the halvings.\n2.- I think this change involves a Hard Fork (please correct me if I am wrong). In my opinion, the risk of a HF is not worth it.\n3.- And more important for me, If blocks get bigger and bigger it would hurt decentralization which is absolutely key for Bitcoin to be valuable.\n\nAlberto\n\n\n> El 8 nov 2019, a las 16:54, Joachim Str\u00f6mbergson via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> escribi\u00f3:\n> \n> \ufeff\n> While I agree on NACKing the proposal as it does not add anything new and fundamentally misunderstands what scaling is (or is not in this case), I disagree with the claim that we do not need to deal with block size issue in the future any more. Segwit increased our possibilities on how to use the space more efficiently, but so far it did not completely. It's yet to be seen if advanced offchain constructions such as channel factories are enough. At this moment to claim that would be very bold and hardly justified.\n> \n> \n> Sent with ProtonMail Secure Email.\n> \n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>> On Friday, November 8, 2019 2:36 PM, Emil Engler via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> \n>> NACK!\n>> 1. We have Lightning and SegWit so thankfully we do not need to deal with blocksizes anymore really.\n>> 2. What if a reorg happens? Then it could generate huge problems at the validation.\n>> \n>> Correct me if I understood it wrong please.\n>> \n>> Greetings,\n>> Emil Engler\n>> \n>> Trevor Groves via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> schrieb am Fr. 8. Nov. 2019 um 15:26:\n>>> Dynamic MaxBlockSize  - 3 Byte Solution\n>>> \"DMBS\"\n>>> \n>>> If \n>>> (Last TOTAL Block Trans fees)  >  (AVG (Last 100 Blocks Trans Fees))\n>>> AND\n>>> current MaxBlockSize  => 0.99 MB  \n>>> AND \n>>> MaxBlockSize has not changed in 10 Blocks\n>>> ** see error catch below\n>>> Then  \n>>> ON (Current Block #  + 9)  Set MaxBlockSize  = (MaxBlockSize x 1.1)\n>>> ELSE  \n>>> AT (Current Block #  + 9)  Set MaxBlockSize  = (MaxBlockSize  / 1.1)\n>>> ELSEIF \n>>> (current MaxBlockSize  =< 0.99  or current MaxBlockSize > 6553.5 MB)\n>>> Null (no action taken)\n>>> **where 9 above represents the ActivateONBlock (software side) Variable\n>>>  -------------\n>>> We add this 3 Byte Variable Factor to the white space in the Current Block.\n>>> \n>>> eg.  this 3 byte HEX    19000A\n>>> the first bit \"1\"  can be 1,2 or 0    \n>>> 1  =  increase future block (9 blocks ahead)\n>>> 2  decrease future block  (9 blocks ahead)\n>>> 0    No Action (rules evaluate to null)\n>>> **where 9 above represents the ActivateONBlock (software side) Variable\n>>> --------------\n>>> The Second bit is a Global Variable \"9\" represents a countdown to the set value action, placed to synchronize network forward  changes in \"x\" blocks. software lowers value if evaluates to True a second time  and so on. \n>>> (\"Count down\" if you will)\n>>> the last 2 bytes represent  the globally accepted \"MaxBlockSize\" Variable, and is distributed within each block moving forward in this rightmost (2 byte) factor.  In this case above,\n>>> The variable portion  \"000A\" (32 Bit value) represents decimal value 10 being 1.0 MB block.\n>>> the decimal place is Always Assumed, and must be hard coded \n>>> Because this presents a  theoretical  Max limit of \"FFFF\"  or 6553.5 MB, We would \n>>> have to add a last rule \"only as a error catch\"\n>>>  ** AND IF MaxBlockSize < 6553.5 \n>>> ---\n>>> Increasing and decreasing\n>>> On Every Block mined or distributed, the software can run the above rule set, Change the Variable and Distribute the next block \" In Synchronized fashion\". The above rules when combined evaluate to a YES or NO, This translates to a market reflection of increased system pressure or decreased market pressure.   I think we can agree, at peak periods the system chokes itself off with fees and this is always only temporarily.  So we can have the block, analyse system demand dynamically, and adjust on a globally agreed rule dynamically by market driven demand.\n>>> Considering the ruleset above also Decreases  the Block ONLY if its greater than 0.99mb this brings size back to a competitive state /and size once market demand pressures subside, yet achieves the smallest market feasible block size while also maintaining all current rule sets.\n>>>  An attacker would have to affect all block fees over the last 16 hours worth of transactions to affect a 10% max block size increase but then only after waiting 1.5 hours, so long as nothing has changed in the last 1.5 hours and only for a limited amount of time. This approach also limits bloat. This safety block window of 9 blocks provides a look forward and look behind value, in turn provides the network time to synchronize. \n>>> 10 block sync window.  This, by design, also limits changes to one change  every 3 hours (20 blocks), if there is a market pressure \"STATE\" occurring.\n>>> My Question to the community is. Will our current Block accommodate the 3 Byte \n>>> Variable, Is solving the Scaling issue worth using the 3 Bytes of space?  \n>>> I believe it is.  \n>>> --\n>>> Software,  Will need  to Evaluate MaxBlockSize Variable, and ActivateONBlock Variable from the most recent distributed blocks DMBS  3 byte value. \n>>> Run the rules , get the answer set the now known MaxBlockSize Var and Propegate the \"DMBS\" value. \n>>> \n>>> As capacity limits are breached, I think the majority agree \"we need to agree\".  \n>>> \n>>> MaxBlockSize would provide a suitable middle ground and address concerns in a dynamic fashion, without compromising  or changing  existing security.   \n>>>  Examples reflected in the blockchain 19000A   rules has evaluates to  true, increase expected in 9 blocks.1.0mb increases to 1.1mb\n>>> if true for 9 more blocks  MaxBlockSize Var becomes  18000A.. 17000A..,16000A ..and so on if  still true at 10000A var written becomes \n>>> 00000B when read from left to right,  0-no change, in 0 blocks current \" DMBS\" value 000B or 1.1MB  and stays that way  00000B until MaxBlockSize  evaluates to \"True\" under a market pressure/ relief situation. \n>>> I hope this makes sense, I would appreciate some feedback. \n>>> TG\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191108/f6739b1b/attachment.html>"
            },
            {
                "author": "Hampus Sj\u00f6berg",
                "date": "2019-11-11T16:08:43",
                "message_text_only": "> 1. We have Lightning and SegWit so thankfully we do not need to deal with\nblocksizes anymore really.\n\nRegardless of the current proposal in this email thread, just because we\nhave Lightning doesn't mean we don't ever have to increase the blocksize\nagain.\nEven with Lightning there would be too many channel open and closes to be\nable to handle million users without transaction fees going through the\nroof.\nI am advocating to keep the blocksize low right now, but I don't leave out\nin increasing it in the future when we have a need for it, preferably via\nan extension block (softfork).\n\nHampus\n\nDen fre 8 nov. 2019 kl 15:44 skrev Emil Engler via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org>:\n\n> NACK!\n> 1. We have Lightning and SegWit so thankfully we do not need to deal with\n> blocksizes anymore really.\n> 2. What if a reorg happens? Then it could generate huge problems at the\n> validation.\n>\n> Correct me if I understood it wrong please.\n>\n> Greetings,\n> Emil Engler\n>\n> Trevor Groves via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> schrieb am Fr. 8. Nov. 2019 um 15:26:\n>\n>> Dynamic MaxBlockSize  - 3 Byte Solution\n>> \"DMBS\"\n>>\n>> If\n>> (Last TOTAL Block Trans fees)  >  (AVG (Last 100 Blocks Trans Fees))\n>> AND\n>> current MaxBlockSize  => 0.99 MB\n>> AND\n>> MaxBlockSize has not changed in 10 Blocks\n>> ** see error catch below\n>> Then\n>> ON (Current Block #  + 9)  Set MaxBlockSize  = (MaxBlockSize x 1.1)\n>> ELSE\n>> AT (Current Block #  + 9)  Set MaxBlockSize  = (MaxBlockSize  / 1.1)\n>> ELSEIF\n>> (current MaxBlockSize  =< 0.99  or current MaxBlockSize > 6553.5 MB)\n>> Null (no action taken)\n>> **where 9 above represents the ActivateONBlock (software side) Variable\n>>  -------------\n>> We add this 3 Byte Variable Factor to the white space in the Current\n>> Block.\n>>\n>> eg.  this 3 byte HEX    19000A\n>> the first bit \"1\"  can be 1,2 or 0\n>> 1  =  increase future block (9 blocks ahead)\n>> 2  decrease future block  (9 blocks ahead)\n>> 0    No Action (rules evaluate to null)\n>> **where 9 above represents the ActivateONBlock (software side) Variable\n>> --------------\n>> The Second bit is a Global Variable \"9\" represents a countdown to the set\n>> value action, placed to synchronize network forward  changes in \"x\" blocks.\n>> software lowers value if evaluates to True a second time  and so on.\n>> (\"Count down\" if you will)\n>> the last 2 bytes represent  the globally accepted \"MaxBlockSize\"\n>> Variable, and is distributed within each block moving forward in this\n>> rightmost (2 byte) factor.  In this case above,\n>> The variable portion  \"000A\" (32 Bit value) represents decimal value 10\n>> being 1.0 MB block.\n>> the decimal place is Always Assumed, and must be hard coded\n>> Because this presents a  theoretical  Max limit of \"FFFF\"  or 6553.5 MB,\n>> We would\n>> have to add a last rule \"only as a error catch\"\n>>  ** AND IF MaxBlockSize < 6553.5\n>> ---\n>> Increasing and decreasing\n>> On Every Block mined or distributed, the software can run the above rule\n>> set, Change the Variable and Distribute the next block \" In Synchronized\n>> fashion\". The above rules when combined evaluate to a YES or NO, This\n>> translates to a market reflection of increased system pressure or decreased\n>> market pressure.   I think we can agree, at peak periods the system chokes\n>> itself off with fees and this is always only temporarily.  So we can have\n>> the block, analyse system demand dynamically, and adjust on a globally\n>> agreed rule dynamically by market driven demand.\n>> Considering the ruleset above also Decreases  the Block ONLY if its\n>> greater than 0.99mb this brings size back to a competitive state /and size\n>> once market demand pressures subside, yet achieves the smallest market\n>> feasible block size while also maintaining all current rule sets.\n>>  An attacker would have to affect all block fees over the last 16 hours\n>> worth of transactions to affect a 10% max block size increase but then only\n>> after waiting 1.5 hours, so long as nothing has changed in the last 1.5\n>> hours and only for a limited amount of time. This approach also limits\n>> bloat. This safety block window of 9 blocks provides a look forward and\n>> look behind value, in turn provides the network time to synchronize.\n>> 10 block sync window.  This, by design, also limits changes to one\n>> change  every 3 hours (20 blocks), if there is a market pressure \"STATE\"\n>> occurring.\n>> My Question to the community is. Will our current Block accommodate the 3\n>> Byte\n>> Variable, Is solving the Scaling issue worth using the 3 Bytes of space?\n>> I believe it is.\n>> --\n>> Software,  Will need  to Evaluate MaxBlockSize Variable, and\n>> ActivateONBlock Variable from the most recent distributed blocks DMBS  3\n>> byte value.\n>> Run the rules , get the answer set the now known MaxBlockSize Var and\n>> Propegate the \"DMBS\" value.\n>>\n>> As capacity limits are breached, I think the majority agree \"we need to\n>> agree\".\n>>\n>> MaxBlockSize would provide a suitable middle ground and address concerns\n>> in a dynamic fashion, without compromising  or changing  existing\n>> security.\n>>  Examples reflected in the blockchain 19000A   rules has evaluates to\n>> true, increase expected in 9 blocks.1.0mb increases to 1.1mb\n>> if true for 9 more blocks  MaxBlockSize Var becomes  18000A..\n>> 17000A..,16000A ..and so on if  still true at 10000A var written becomes\n>> 00000B when read from left to right,  0-no change, in 0 blocks current \"\n>> DMBS\" value 000B or 1.1MB  and stays that way  00000B until MaxBlockSize\n>> evaluates to \"True\" under a market pressure/ relief situation.\n>> I hope this makes sense, I would appreciate some feedback.\n>> TG\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191111/01e64494/attachment.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2019-11-11T16:47:04",
                "message_text_only": "On Monday 11 November 2019 16:08:43 Hampus Sj\u00f6berg via bitcoin-dev wrote:\n> I am advocating to keep the blocksize low right now, \n\nIt ISN'T low right now...\n\n> but I don't leave out \n> in increasing it in the future when we have a need for it, preferably via\n> an extension block (softfork).\n\nExtension blocks are not softforks, and are unreasonably convoluted for no \nreal gain. When the time comes, the block size should be increased only using \na hardfork.\n\nLuke"
            },
            {
                "author": "Hampus Sj\u00f6berg",
                "date": "2019-11-11T17:10:16",
                "message_text_only": "> It ISN'T low right now...\n\nI agree, but I don't think it's a good idea to softfork it to lower than 4M\nWU though, and I don't think we need to;\nhopefully when exchanges start using Lightning or Liquid, avg blocksize\nwill go down.\n\n> Extension blocks are not softforks, and are unreasonably convoluted for\nno\nreal gain. When the time comes, the block size should be increased only\nusing\na hardfork.\n\nIt depends on how you define soft and hardforks, I suspect you don't see\nextension blocks as a softforks because old nodes won't maintain a correct\nUTXO set.\nI think an extension block is a softfork because old nodes will still be\nable to follow the mainchain.\n\nI don't know if a blocksize increase hardfork will get consensus as the\nidea has been ruined by all malicious hijack attempts we've seen over the\nyears.\n\nHampus\n\nDen m\u00e5n 11 nov. 2019 kl 17:47 skrev Luke Dashjr <luke at dashjr.org>:\n\n> On Monday 11 November 2019 16:08:43 Hampus Sj\u00f6berg via bitcoin-dev wrote:\n> > I am advocating to keep the blocksize low right now,\n>\n> It ISN'T low right now...\n>\n> > but I don't leave out\n> > in increasing it in the future when we have a need for it, preferably via\n> > an extension block (softfork).\n>\n> Extension blocks are not softforks, and are unreasonably convoluted for no\n> real gain. When the time comes, the block size should be increased only\n> using\n> a hardfork.\n>\n> Luke\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191111/606aa93f/attachment.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2019-11-11T19:56:15",
                "message_text_only": "On Monday 11 November 2019 17:10:16 Hampus Sj\u00f6berg wrote:\n> > It ISN'T low right now...\n>\n> I agree, but I don't think it's a good idea to softfork it to lower than 4M\n> WU though, and I don't think we need to;\n> hopefully when exchanges start using Lightning or Liquid, avg blocksize\n> will go down.\n\nNot likely, so long as spam continues to pad blocks full.\n\n> > Extension blocks are not softforks, and are unreasonably convoluted for\n> no\n> real gain. When the time comes, the block size should be increased only\n> using\n> a hardfork.\n>\n> It depends on how you define soft and hardforks, I suspect you don't see\n> extension blocks as a softforks because old nodes won't maintain a correct\n> UTXO set.\n> I think an extension block is a softfork because old nodes will still be\n> able to follow the mainchain.\n\nSoftforks leave old nodes *working*, so yes, maintaining the correct UTXO \nstate.\n\nSimply \"following\" is meaningless, as even soft-hardforks are \"followed\".\n\n> I don't know if a blocksize increase hardfork will get consensus as the\n> idea has been ruined by all malicious hijack attempts we've seen over the\n> years.\n\nIf there isn't consensus, then it shouldn't be done, period.\n\nLuke"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-11-11T13:52:49",
                "message_text_only": "Several days late, I would like to add my NACK here.\n\n* The actual fees paid to miners are not in fact known.\n  Miners may accept side fees that are not explicitly visible on the block, and miners may pad their blocks with faked self-paying transactions.\n  Further, such side fees and faked transactions do not modify the economic assumptions of Bitcoin.\n  * Mining fees are simply an anonymity technique: what is material economically is that miners are paid for confirming transactions, thus side fees are perfectly fine when considering economic incentives of Bitcoin mining.\n  * Without this proposed mechanism, padding blocks with faked self-paying transactions is self-destructive behavior for miners, as the transaction takes up space that cannot be used for actually-paying transactions.\n  * However, by computing only using the explicit fees on the block (and not the actual fees that miners actually get), various additional games can be played by miners.\n    Such games make considering the overall security of mining much harder and we may end up with worse security due to misaligned incentives, including encouraging miners to pad blocks with faked transactions (which otherwise is discouraged by the current protocol).\n* Scaling means getting more impact for less resource consumption.\n  ***All*** block size increases are getting more impact for ***more*** resource consumption, thus not scaling.\n\n\n> Dynamic MaxBlockSize \u00a0- 3 Byte Solution\n> \"DMBS\"\n>\n> If\n> (Last TOTAL Block Trans fees)\u00a0 > \u00a0(AVG (Last 100 Blocks Trans Fees))\n> AND\n> current MaxBlockSize \u00a0=> 0.99 MB \u00a0\n> AND\n> MaxBlockSize has not changed in 10 Blocks\n> ** see error catch below\n> Then \u00a0\n> ON (Current Block # \u00a0+ 9) \u00a0Set MaxBlockSize \u00a0= (MaxBlockSize x 1.1)\n> ELSE \u00a0\n> AT (Current Block # \u00a0+ 9) \u00a0Set MaxBlockSize \u00a0= (MaxBlockSize \u00a0/ 1.1)\n> ELSEIF\n> (current MaxBlockSize \u00a0=< 0.99 \u00a0or current MaxBlockSize > 6553.5 MB)\n> Null (no action taken)\n> **where 9 above represents the ActivateONBlock (software side) Variable\n> \u00a0-------------\n> We add this 3 Byte Variable Factor to the white space in the Current Block.\n>\n> eg. \u00a0this 3 byte HEX\u00a0 \u00a0 19000A\n> the first bit \"1\" \u00a0can be 1,2 or 0 \u00a0 \u00a0\n> 1 \u00a0= \u00a0increase future block (9 blocks ahead)\n> 2 \u00a0decrease future block \u00a0(9 blocks ahead)\n> 0 \u00a0 \u00a0No Action (rules evaluate to null)\n> **where 9 above represents the ActivateONBlock (software side) Variable\n> --------------\n> The Second bit is a Global Variable \"9\" represents a countdown to the set value action, placed to synchronize network forward \u00a0changes in \"x\" blocks. software lowers value if evaluates to True a second time\u00a0 and so on.\u00a0\n> (\"Count down\" if you will)\n> the last 2 bytes represent \u00a0the globally accepted \"MaxBlockSize\" Variable, and is distributed within each block moving forward in this rightmost (2 byte) factor.\u00a0 In this case above,\n> The variable portion \u00a0\"000A\" (32 Bit value) represents decimal value 10 being 1.0 MB block.\n> the decimal place is Always Assumed, and must be hard coded\n> Because this presents a \u00a0theoretical \u00a0Max limit of \"FFFF\" \u00a0or 6553.5 MB, We would\n> have to add a last rule \"only as a error catch\"\n> \u00a0** AND IF MaxBlockSize < 6553.5\n> ---\n> Increasing and decreasing\n> On Every Block mined or distributed, the software can run the above rule set, Change the Variable and Distribute the next block \" In Synchronized fashion\". The above rules when combined evaluate to a YES or NO, This translates to a market reflection of increased system pressure or decreased market pressure. \u00a0 I think we can agree, at peak periods the system chokes itself off with fees and this is always only temporarily.\u00a0 So we can have the block, analyse system demand dynamically, and adjust on a globally agreed rule dynamically by market driven demand.\n> Considering the ruleset above also Decreases \u00a0the Block ONLY if its greater than 0.99mb this brings size back to a competitive state /and size once market demand pressures subside, yet achieves the smallest market feasible block size while also maintaining all current rule sets.\n> \u00a0An attacker would have to affect all block fees over the last 16 hours worth of transactions to affect a 10% max block size increase but then only after waiting 1.5 hours, so long as nothing has changed in the last 1.5 hours and only for a limited amount of time. This approach also limits bloat. This safety block window of 9 blocks provides a look forward and look behind value, in turn provides the network time to synchronize.\n> 10 block sync window.\u00a0 This, by design, also limits changes to one change\u00a0 every 3 hours (20 blocks), if there is a market pressure \"STATE\" occurring.\n> My Question to the community is. Will our current Block accommodate the 3 Byte\n> Variable, Is solving the Scaling issue worth using the 3 Bytes of space? \u00a0\n> I believe it is. \u00a0\n> --\n> Software, \u00a0Will need \u00a0to Evaluate MaxBlockSize Variable, and ActivateONBlock Variable from the most recent distributed blocks DMBS \u00a03 byte value.\n> Run the rules , get the answer set the now known MaxBlockSize Var and Propegate the \"DMBS\" value.\n>\n> As capacity limits are breached, I think the majority agree \"we need to agree\". \u00a0\n>\n> MaxBlockSize would provide a suitable middle ground and address concerns in a dynamic fashion, without compromising \u00a0or changing \u00a0existing security.\u00a0 \u00a0\n> \u00a0Examples reflected in the blockchain 19000A\u00a0 \u00a0rules has evaluates to\u00a0 true, increase expected in 9 blocks.1.0mb increases to 1.1mb\n> if true for 9 more blocks\u00a0 MaxBlockSize Var becomes\u00a0 18000A.. 17000A..,16000A ..and so on if\u00a0 still true at 10000A var written becomes\u00a0\n> 00000B when read from left to right,\u00a0 0-no change, in 0 blocks current \" DMBS\" value 000B or 1.1MB\u00a0 and stays that way\u00a0 00000B until MaxBlockSize\u00a0 evaluates to \"True\" under a market pressure/ relief situation.\u00a0\n> I hope this makes sense, I would appreciate some feedback.\u00a0\n> TG"
            }
        ],
        "thread_summary": {
            "title": "Dynamic MaxBlockSize - 3 Byte Solution",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Trevor Groves",
                "Emil Engler",
                "Hampus Sj\u00f6berg",
                "ZmnSCPxj",
                "Luke Dashjr",
                "Alberto Aldave",
                "Joachim Str\u00f6mbergson"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 37889
        }
    },
    {
        "title": "[bitcoin-dev] Bech32 weakness and impact on bip-taproot addresses",
        "thread_messages": [
            {
                "author": "Pieter Wuille",
                "date": "2019-11-07T22:35:42",
                "message_text_only": "Hello all,\n\nA while ago it was discovered that bech32 has a mutation weakness (see\nhttps://github.com/sipa/bech32/issues/51 for details). Specifically,\nwhen a bech32 string ends with a \"p\", inserting or erasing \"q\"s right\nbefore that \"p\" does not invalidate it. While insertion/erasure\nrobustness was not an explicit goal (BCH codes in general only have\nguarantees about substitution errors), this is very much not by\ndesign, and this specific issue could have been made much less\nimpactful with a slightly different approach. I'm sorry it wasn't\ncaught earlier.\n\nThis has little effect on the security of P2WPKH/P2WSH addresses, as\nthose are only valid (per BIP173) for specific lengths (42 and 62\ncharacters respectively). Inserting 20 consecutive \"p\"s in a typo\nseems highly improbable.\n\nI'm making this post because this property may unfortunately influence\ndesign decisions around bip-taproot, as was brought up in the review\nsession (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-October/017427.html)\npast tuesday. In the current draft, witness v1 outputs of length other\nthan 32 remain unencumbered, which means that for now such an\ninsertion or erasure would result in an output that can be spent by\nanyone. If that is considered unacceptable, it could be prevented by\nfor example outlawing v1 witness outputs of length 31 and 33.\n\nThoughts?\n\nCheers,\n\n-- \nPieter"
            },
            {
                "author": "Greg Sanders",
                "date": "2019-11-07T22:45:02",
                "message_text_only": "Could the softer touch of just making them non-standard apply as a future\npreparation for an accepted softfork? Relaxations could easily be done\nlater if desired.\n\nOn Thu, Nov 7, 2019, 5:37 PM Pieter Wuille via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello all,\n>\n> A while ago it was discovered that bech32 has a mutation weakness (see\n> https://github.com/sipa/bech32/issues/51 for details). Specifically,\n> when a bech32 string ends with a \"p\", inserting or erasing \"q\"s right\n> before that \"p\" does not invalidate it. While insertion/erasure\n> robustness was not an explicit goal (BCH codes in general only have\n> guarantees about substitution errors), this is very much not by\n> design, and this specific issue could have been made much less\n> impactful with a slightly different approach. I'm sorry it wasn't\n> caught earlier.\n>\n> This has little effect on the security of P2WPKH/P2WSH addresses, as\n> those are only valid (per BIP173) for specific lengths (42 and 62\n> characters respectively). Inserting 20 consecutive \"p\"s in a typo\n> seems highly improbable.\n>\n> I'm making this post because this property may unfortunately influence\n> design decisions around bip-taproot, as was brought up in the review\n> session (\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-October/017427.html\n> )\n> past tuesday. In the current draft, witness v1 outputs of length other\n> than 32 remain unencumbered, which means that for now such an\n> insertion or erasure would result in an output that can be spent by\n> anyone. If that is considered unacceptable, it could be prevented by\n> for example outlawing v1 witness outputs of length 31 and 33.\n>\n> Thoughts?\n>\n> Cheers,\n>\n> --\n> Pieter\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191107/ffd8acac/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2019-11-08T00:41:54",
                "message_text_only": "Given the issue is in the address format, not the consensus/standardness layer, it does seem somewhat strange to jump to addressing it with a consensus/standardness fix. Maybe the ship has sailed, but for the sake of considering all our options, we could also redefine bech32 to not allow such addresses.\n\nMatt\n\n>> On Nov 7, 2019, at 17:47, Greg Sanders via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \ufeff\n> Could the softer touch of just making them non-standard apply as a future preparation for an accepted softfork? Relaxations could easily be done later if desired.\n> \n>>> On Thu, Nov 7, 2019, 5:37 PM Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> Hello all,\n>> \n>> A while ago it was discovered that bech32 has a mutation weakness (see\n>> https://github.com/sipa/bech32/issues/51 for details). Specifically,\n>> when a bech32 string ends with a \"p\", inserting or erasing \"q\"s right\n>> before that \"p\" does not invalidate it. While insertion/erasure\n>> robustness was not an explicit goal (BCH codes in general only have\n>> guarantees about substitution errors), this is very much not by\n>> design, and this specific issue could have been made much less\n>> impactful with a slightly different approach. I'm sorry it wasn't\n>> caught earlier.\n>> \n>> This has little effect on the security of P2WPKH/P2WSH addresses, as\n>> those are only valid (per BIP173) for specific lengths (42 and 62\n>> characters respectively). Inserting 20 consecutive \"p\"s in a typo\n>> seems highly improbable.\n>> \n>> I'm making this post because this property may unfortunately influence\n>> design decisions around bip-taproot, as was brought up in the review\n>> session (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-October/017427.html)\n>> past tuesday. In the current draft, witness v1 outputs of length other\n>> than 32 remain unencumbered, which means that for now such an\n>> insertion or erasure would result in an output that can be spent by\n>> anyone. If that is considered unacceptable, it could be prevented by\n>> for example outlawing v1 witness outputs of length 31 and 33.\n>> \n>> Thoughts?\n>> \n>> Cheers,\n>> \n>> -- \n>> Pieter\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191107/37c1fe47/attachment.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2019-11-08T02:15:41",
                "message_text_only": "On Thu, Nov 07, 2019 at 02:35:42PM -0800, Pieter Wuille via bitcoin-dev wrote:\n> In the current draft, witness v1 outputs of length other\n> than 32 remain unencumbered, which means that for now such an\n> insertion or erasure would result in an output that can be spent by\n> anyone. If that is considered unacceptable, it could be prevented by\n> for example outlawing v1 witness outputs of length 31 and 33.\n\nEither a consensus rule or a standardness rule[1] would require anyone\nusing a bech32 library supporting v1+ segwit to upgrade their library.\nOtherwise, users of old libraries will still attempt to pay v1 witness\noutputs of length 31 or 33, causing their transactions to get rejected\nby newer nodes or get stuck on older nodes.  This is basically the\nproblem #15846[2] was meant to prevent.\n\nIf we're going to need everyone to upgrade their bech32 libraries\nanyway, I think it's probably best that the problem is fixed in the\nbech32 algorithm rather than at the consensus/standardness layer.\n\n-Dave\n\n[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-November/017444.html\n[2] https://github.com/bitcoin/bitcoin/pull/15846\n\nP.S. My thanks as well to the people who asked the question during\n     review that lead to this discussion:\n\n     http://www.erisian.com.au/meetbot/taproot-bip-review/2019/taproot-bip-review.2019-11-05-19.00.log.html#l-88"
            },
            {
                "author": "Eric Voskuil",
                "date": "2019-11-08T03:15:53",
                "message_text_only": "> On Nov 8, 2019, at 11:16, David A. Harding via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \ufeffOn Thu, Nov 07, 2019 at 02:35:42PM -0800, Pieter Wuille via bitcoin-dev wrote:\n>> In the current draft, witness v1 outputs of length other\n>> than 32 remain unencumbered, which means that for now such an\n>> insertion or erasure would result in an output that can be spent by\n>> anyone. If that is considered unacceptable, it could be prevented by\n>> for example outlawing v1 witness outputs of length 31 and 33.\n> \n> Either a consensus rule or a standardness rule[1] would require anyone\n> using a bech32 library supporting v1+ segwit to upgrade their library.\n> Otherwise, users of old libraries will still attempt to pay v1 witness\n> outputs of length 31 or 33, causing their transactions to get rejected\n> by newer nodes or get stuck on older nodes.  This is basically the\n> problem #15846[2] was meant to prevent.\n> \n> If we're going to need everyone to upgrade their bech32 libraries\n> anyway, I think it's probably best that the problem is fixed in the\n> bech32 algorithm rather than at the consensus/standardness layer.\n\nAs an implementer of both the address encoding and script validation, I agree.\n\ne\n\n> -Dave\n> \n> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-November/017444.html\n> [2] https://github.com/bitcoin/bitcoin/pull/15846\n> \n> P.S. My thanks as well to the people who asked the question during\n>     review that lead to this discussion:\n> \n>     http://www.erisian.com.au/meetbot/taproot-bip-review/2019/taproot-bip-review.2019-11-05-19.00.log.html#l-88\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Pieter Wuille",
                "date": "2019-11-10T21:51:48",
                "message_text_only": "On Thu, Nov 7, 2019, 18:16 David A. Harding <dave at dtrt.org> wrote:\n\n> On Thu, Nov 07, 2019 at 02:35:42PM -0800, Pieter Wuille via bitcoin-dev\n> wrote:\n> > In the current draft, witness v1 outputs of length other\n> > than 32 remain unencumbered, which means that for now such an\n> > insertion or erasure would result in an output that can be spent by\n> > anyone. If that is considered unacceptable, it could be prevented by\n> > for example outlawing v1 witness outputs of length 31 and 33.\n>\n> Either a consensus rule or a standardness rule[1] would require anyone\n> using a bech32 library supporting v1+ segwit to upgrade their library.\n> Otherwise, users of old libraries will still attempt to pay v1 witness\n> outputs of length 31 or 33, causing their transactions to get rejected\n> by newer nodes or get stuck on older nodes.  This is basically the\n> problem #15846[2] was meant to prevent.\n>\n> If we're going to need everyone to upgrade their bech32 libraries\n> anyway, I think it's probably best that the problem is fixed in the\n> bech32 algorithm rather than at the consensus/standardness layer.\n>\n\nAdmittedly, this affecting development of consensus or standardness rules\nwould feel unnatural. In addition, it also has the potential downside of\nbreaking batched transactions in some settings (ask an exchange for a\nwithdrawal to a invalid/nonstandard version, which they batch with other\noutputs that then get stuck because the transaction does not go through).\n\nSo, Ideally this is indeed solved entirely on the bech32/address encoding\nside of things. I did not initially expect the discussion here to go in\nthat direction, as that could come with all problems that rolling out a new\naddress scheme in the first place has. However, there may be a way to\nmostly avoid those problems for the time being, while also not having any\nimpact on consensus or standardness rules.\n\nI believe that most new witness programs we'd want to introduce anyway will\nbe 32 bytes in the future, if the option exists. It's enough for a 256-bit\nhash (which has up to 128-bit collision security, and more than 128 bits is\nhard to achieve in Bitcoin anyway), or for X coordinates directly. Either\nof those, plus a small version number to indicate the commitment structure\nshould be enough to encode any spendability condition we'd want with any\nachievable security level.\n\nWith that observation, I propose the following. We amend BIP173 to be\nrestricted to witness programs of length 20 or 32 (but still support\nversions other than 0). This seems like it may be sufficient for several\nyears, until version numbers run out. I believe that some wallet\nimplementations already restrict sending to known versions only, which\nmeans effectively no change for them in addition to normal deployment.\n\nIn the mean time we develop a variant of bech32 with better\ninsertion/erasure detecting properties, which will be used for witness\nprograms of length different from 20 or 32. If we make sure that there are\nnever two distinct valid checksum algorithms for the same output, I don't\nbelieve there is any need for a new address scheme or a different HRP. The\nlatter is something I'd strongly try to avoid anyway, as it would mean\nadditional cognitive load on users because of another visually distinct\naddress style, plus more logistical overhead (coordination and keeping\ntrack of 2 HRPs per chain).\n\nI believe improving bech32 itself is preferable over changing the way\nsegwit addresses use bech32, as that can be done without making addresses\neven longer. Furthermore, the root of the issue is in bech32, and it is\nsimplest to fix things there. The easiest solution is to simply change the\nconstant 1 that is xor'ed into the checksum before encoding it to a 30-bit\nnumber. This has the advantage that a single checksum is never valid for\nboth algoritgms simultaneously. Another approach is to implicitly including\nthe length into the checksummed data.\n\nWhat do people think?\n\nCheers,\n\n-- \nPieter\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191110/5894b93f/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2019-11-11T01:02:15",
                "message_text_only": "Seems good to me, though I'm curious if we have any (even vaguely)\nimmediate need for non-32/20-byte Segwit outputs? It seems to me this\ncan be resolved by just limiting the size of bech32 outputs and calling\nit a day - adding yet another address format has very significant\necosystem costs, and if we don't anticipate needing it for 5 years (if\nat all)...lets not jump to pay that cost.\n\nMatt\n\nOn 11/10/19 9:51 PM, Pieter Wuille via bitcoin-dev wrote:\n> On Thu, Nov 7, 2019, 18:16 David A. Harding <dave at dtrt.org\n> <mailto:dave at dtrt.org>> wrote:\n> \n>     On Thu, Nov 07, 2019 at 02:35:42PM -0800, Pieter Wuille via\n>     bitcoin-dev wrote:\n>     > In the current draft, witness v1 outputs of length other\n>     > than 32 remain unencumbered, which means that for now such an\n>     > insertion or erasure would result in an output that can be spent by\n>     > anyone. If that is considered unacceptable, it could be prevented by\n>     > for example outlawing v1 witness outputs of length 31 and 33.\n> \n>     Either a consensus rule or a standardness rule[1] would require anyone\n>     using a bech32 library supporting v1+ segwit to upgrade their library.\n>     Otherwise, users of old libraries will still attempt to pay v1 witness\n>     outputs of length 31 or 33, causing their transactions to get rejected\n>     by newer nodes or get stuck on older nodes.\u00a0 This is basically the\n>     problem #15846[2] was meant to prevent.\n> \n>     If we're going to need everyone to upgrade their bech32 libraries\n>     anyway, I think it's probably best that the problem is fixed in the\n>     bech32 algorithm rather than at the consensus/standardness layer.\n> \n> \n> Admittedly, this affecting development of consensus or standardness\n> rules would feel unnatural. In addition, it also\u00a0has the potential\n> downside of breaking batched transactions in some settings (ask an\n> exchange for a withdrawal to a invalid/nonstandard version, which they\n> batch with other outputs that then get stuck because the transaction\n> does not go through).\n> \n> So, Ideally this is indeed solved entirely on the bech32/address\n> encoding side of things. I\u00a0did not initially expect the discussion here\n> to go in that direction, as that could come with all problems that\n> rolling out a new address scheme in the first place has. However, there\n> may be a way to mostly avoid those problems for the time being, while\n> also not having any impact on consensus or standardness rules.\n> \n> I believe that most new witness programs we'd want to introduce anyway\n> will be 32 bytes in the future, if the option exists. It's enough for a\n> 256-bit hash (which has up to 128-bit collision security, and more than\n> 128 bits is hard to achieve in Bitcoin anyway), or for X coordinates\n> directly. Either of those, plus a small version number to indicate the\n> commitment structure should be enough to encode any spendability\n> condition we'd want with any achievable security level.\n> \n> With that observation, I propose the following. We amend BIP173 to be\n> restricted to witness programs of length 20 or 32 (but still support\n> versions other than 0). This seems like it may be sufficient for several\n> years, until version numbers run out. I believe that some wallet\n> implementations already restrict sending to known versions only, which\n> means effectively no change for them in addition to normal deployment.\n> \n> In the mean time we develop a variant of bech32 with better\n> insertion/erasure detecting properties, which will be used for witness\n> programs of length different from 20 or 32. If we make sure that there\n> are never two distinct valid checksum algorithms for the same output, I\n> don't believe there is any need for a new address scheme or a different\n> HRP. The latter is something I'd strongly try to avoid anyway, as it\n> would mean additional cognitive load on users because of another\n> visually distinct address style, plus more logistical overhead\n> (coordination and keeping track of 2 HRPs per chain).\n> \n> I believe improving bech32 itself is preferable over changing the way\n> segwit addresses use bech32, as that can be done without making\n> addresses even longer. Furthermore, the root of the issue is in bech32,\n> and it is simplest to fix things there. The easiest solution is to\n> simply change the constant 1 that is xor'ed into the checksum before\n> encoding it to a 30-bit number. This has the advantage that a single\n> checksum is never valid for both algoritgms simultaneously. Another\n> approach is to implicitly including the length into the checksummed data.\n> \n> What do people think?\n> \n> Cheers,\n> \n> --\u00a0\n> Pieter\n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Clark Moody",
                "date": "2019-11-13T02:56:54",
                "message_text_only": "I agree on all points. The address space already brings enough confusion to\nusers out there. As it stands, we can use script version and program length\nfor address validity. Sneaking an alternate checksum into the mix for\ndifferent length programs lets us lean on our parsing libraries and not\nincrease cognitive load for users.\n\n\n-Clark\n\n\nOn Sun, Nov 10, 2019 at 7:02 PM Matt Corallo via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Seems good to me, though I'm curious if we have any (even vaguely)\n> immediate need for non-32/20-byte Segwit outputs? It seems to me this\n> can be resolved by just limiting the size of bech32 outputs and calling\n> it a day - adding yet another address format has very significant\n> ecosystem costs, and if we don't anticipate needing it for 5 years (if\n> at all)...lets not jump to pay that cost.\n>\n> Matt\n>\n> On 11/10/19 9:51 PM, Pieter Wuille via bitcoin-dev wrote:\n> > On Thu, Nov 7, 2019, 18:16 David A. Harding <dave at dtrt.org\n> > <mailto:dave at dtrt.org>> wrote:\n> >\n> >     On Thu, Nov 07, 2019 at 02:35:42PM -0800, Pieter Wuille via\n> >     bitcoin-dev wrote:\n> >     > In the current draft, witness v1 outputs of length other\n> >     > than 32 remain unencumbered, which means that for now such an\n> >     > insertion or erasure would result in an output that can be spent by\n> >     > anyone. If that is considered unacceptable, it could be prevented\n> by\n> >     > for example outlawing v1 witness outputs of length 31 and 33.\n> >\n> >     Either a consensus rule or a standardness rule[1] would require\n> anyone\n> >     using a bech32 library supporting v1+ segwit to upgrade their\n> library.\n> >     Otherwise, users of old libraries will still attempt to pay v1\n> witness\n> >     outputs of length 31 or 33, causing their transactions to get\n> rejected\n> >     by newer nodes or get stuck on older nodes.  This is basically the\n> >     problem #15846[2] was meant to prevent.\n> >\n> >     If we're going to need everyone to upgrade their bech32 libraries\n> >     anyway, I think it's probably best that the problem is fixed in the\n> >     bech32 algorithm rather than at the consensus/standardness layer.\n> >\n> >\n> > Admittedly, this affecting development of consensus or standardness\n> > rules would feel unnatural. In addition, it also has the potential\n> > downside of breaking batched transactions in some settings (ask an\n> > exchange for a withdrawal to a invalid/nonstandard version, which they\n> > batch with other outputs that then get stuck because the transaction\n> > does not go through).\n> >\n> > So, Ideally this is indeed solved entirely on the bech32/address\n> > encoding side of things. I did not initially expect the discussion here\n> > to go in that direction, as that could come with all problems that\n> > rolling out a new address scheme in the first place has. However, there\n> > may be a way to mostly avoid those problems for the time being, while\n> > also not having any impact on consensus or standardness rules.\n> >\n> > I believe that most new witness programs we'd want to introduce anyway\n> > will be 32 bytes in the future, if the option exists. It's enough for a\n> > 256-bit hash (which has up to 128-bit collision security, and more than\n> > 128 bits is hard to achieve in Bitcoin anyway), or for X coordinates\n> > directly. Either of those, plus a small version number to indicate the\n> > commitment structure should be enough to encode any spendability\n> > condition we'd want with any achievable security level.\n> >\n> > With that observation, I propose the following. We amend BIP173 to be\n> > restricted to witness programs of length 20 or 32 (but still support\n> > versions other than 0). This seems like it may be sufficient for several\n> > years, until version numbers run out. I believe that some wallet\n> > implementations already restrict sending to known versions only, which\n> > means effectively no change for them in addition to normal deployment.\n> >\n> > In the mean time we develop a variant of bech32 with better\n> > insertion/erasure detecting properties, which will be used for witness\n> > programs of length different from 20 or 32. If we make sure that there\n> > are never two distinct valid checksum algorithms for the same output, I\n> > don't believe there is any need for a new address scheme or a different\n> > HRP. The latter is something I'd strongly try to avoid anyway, as it\n> > would mean additional cognitive load on users because of another\n> > visually distinct address style, plus more logistical overhead\n> > (coordination and keeping track of 2 HRPs per chain).\n> >\n> > I believe improving bech32 itself is preferable over changing the way\n> > segwit addresses use bech32, as that can be done without making\n> > addresses even longer. Furthermore, the root of the issue is in bech32,\n> > and it is simplest to fix things there. The easiest solution is to\n> > simply change the constant 1 that is xor'ed into the checksum before\n> > encoding it to a 30-bit number. This has the advantage that a single\n> > checksum is never valid for both algoritgms simultaneously. Another\n> > approach is to implicitly including the length into the checksummed data.\n> >\n> > What do people think?\n> >\n> > Cheers,\n> >\n> > --\n> > Pieter\n> >\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191112/a92d5501/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-11-13T05:32:32",
                "message_text_only": "Good morning all,\n\nIt seems to me that adding the length for checksumming purposes need not require the length to be *actually* added in the address format.\n\nSo, currently, below is my understanding of bech32 validation:\n\n* Run BCH checksum on witness program.\n* Compare checksum to checksum in address.\n  * If the checksum matches:\n    * If version is 0, validate that the witness program is length 20 or 32.\n    * Else accept.\n  * If the checksum does not match:\n    * Reject\n\nLet me propose then:\n\n* Run BCH checksum on witness program.\n* Compare checksum to checksum in address.\n  * If the checksum matches:\n    * If version is 0, validate that the witness program is length 20 or 32.\n    * Else validate that the witness program is length 32.\n  * If the checksum does not match:\n    * Get the length of the witness program.\n    * Prepend the length to the witness program.\n    * Run BCH checksum on concatenated length | witness program.\n    * Compare checksum to checksum in address.\n      * If the checksum matches:\n        * Accept.\n      * Else reject.\n\nA writer of bech32 addresses would then:\n\n* If the witness program is length 32, or witness version is 0 and witness program length is 20, use a non-length-prefixed checksum.\n* Otherwise, use a length-prefixed checksum (but not include the length in the address, just change the BCH checksum).\n\nThis has the following properties:\n\n* The bech32 address format is retained, and no explicit length is added.\n* There are now two checksum formats: one with just the witness program, the other which validates with the witness program length.\n  * Readers that do not understand the new checksum format will simply reject them without mis-sending to the wrong witness program.\n\nIs the above acceptable?\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Pieter Wuille",
                "date": "2019-11-13T06:30:18",
                "message_text_only": "On Tue, Nov 12, 2019, 21:33 ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning all,\n>\n> It seems to me that adding the length for checksumming purposes need not\n> require the length to be *actually* added in the address format.\n>\n\nIndeed!\n\nThis has the following properties:\n>\n> * The bech32 address format is retained, and no explicit length is added.\n> * There are now two checksum formats: one with just the witness program,\n> the other which validates with the witness program length.\n>   * Readers that do not understand the new checksum format will simply\n> reject them without mis-sending to the wrong witness program.\n>\n\nThat's very close to what I was suggesting: create an improved bech32\nalgorithm and use that for future addresses, rather than working around the\nproblem in the address encoding while keeping the existing bech32 checksum.\nSorry if that wasn't clear from my previous email.\n\nIn this case, there is no need to even implicitly include the length in the\nchecksum algorithm. Replacing the \"xor 1\" at the end of the algorithm to\n\"xor (2^30 - 1)\" would reduce the occurrence of this weakness from 1/32 to\n1/2^30, and have no downsides otherwise. I'd like to do some analysis to\nascertain it actually will catch any other kind of insertion/deletion\nerrors with high probability as well before actually proposing it, though.\n\nThere are other solutions which do include the length in some fashion\ndirectly in the checksum calculation, which may be preferable (I need to\nanalyse things...). It's also possible to do this in such a way that for\n33-symbol and 53-symbol data parts (corresponding to P2WPKH and P2WSH\nlengths) the new algorithm is defined as identical to the old one. That\nwould simplify upstream users of a bech32 library (which would then\neffectively need no changes at all, apart from updating the\nchecksum/decoder code).\n\nThat brings me to Matt's point: there is no need to do this right now. We\ncan simply amend BIP173 to only permit length 20 and length 32 (and only\nlength 20 for v0, if you like; but they're so far apart that permitting\nboth shouldn't hurt), for now. Introducing the \"new\" address format (the\none using an improved checksum algorithm) only needs to be there in time\nfor when a non-32-byte-witness-program would come in sight.\n\nOf course, I should update BIP173 to indicate the issue, and have a\nsuggested improvement for other users of bech32, if they feel this issue is\nsignificant enough.\n\nCheers,\n\n-- \nPieter\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191112/936e319a/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-11-08T05:11:53",
                "message_text_only": "Good morning Pieter, and all,\n\nCan we modify Bech32 SegWit address format for version 1 and above as below?\n\n      * The data-part values:\n      ** 1 byte: the witness version\n    + ** If the witness version is non-zero, 1 byte: the length of the witness program.\n      ** A conversion of the 2-to-40-byte witness program (as defined by [https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki BIP141]) to base32:\n      *** Start with the bits of the witness program, most significant bit per byte first.\n      *** Re-arrange those bits into groups of 5, and pad with zeroes at the end if needed.\n      *** Translate those bits to characters using the table above.\n\nThis retains the ability of a bech32 address to specify any valid witness length and allows future version 1 addresses with lengths other than 32, while closing this malleation.\n\nOlder software being given the modified v1 address format would mis-send it to the wrong witness program, however.\n\nAlternately we could just keep using version 0 in the address format forever.\nThe requirement would be to ensure that SegWit vN (N >= 1) output witness programs would have a data-part value encoded as below:\n\n    * The data-part values:\n    ** 1 byte: legacy witness version, which must always be 0.\n    ** 1 byte: actual witness version, which must be non-zero.\n    ** 1 byte: padding length: 0 or 1.\n    ** If padding length is 1, 1 byte: padding, which must be 0.\n    ** 1 byte: witness program length.\n    ** variable: witness program.\n\nA writer for a v1 or later address would initially set an empty padding, then compute:\n\n      1 // actual witness version\n    + 1 // padding length\n    + 1 // witness length\n    + witness_length\n\nIf the above sum is 20 or 32, then the writer selects a non-zero padding and inserts the padding byte so that the above sum is now 21 or 33.\n\nTo a reader that understands only bech32 v0, such an encoding would look like a SegWit v0 invalid-program-length, and be rejected.\nA reader which understands the above protocol would, instead of rejecting a SegWit v0 invalid-program-length, instead attempt to parse it as above first, and consider it as SegWit v1 or higher if it was parsed correctly as above.\n\nThe above proposal is of course ridiculous and I am now currently running diagnostics on my processing units to see if further glitches occur in test reasoning skills.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-11-08T13:03:52",
                "message_text_only": "I do like the idea of length prefixing the witness program.  I will note\nthat the 1 byte witness version is really more like a 1 character witness\nversion.  There are 17 different segwit versions and there are 32\ncharacters in the bech32 alphabet.  That leaves 15 unused characters that\nwe can use for assigning new meanings too.\n\nThat said, it is probably most sensible to define a new\nhuman-readable-prefix for length prefixed bitcoin witness programs.  \"btc1\"\nanyone?\n\nOn Fri, Nov 8, 2019 at 12:12 AM ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Pieter, and all,\n>\n> Can we modify Bech32 SegWit address format for version 1 and above as\n> below?\n>\n>       * The data-part values:\n>       ** 1 byte: the witness version\n>     + ** If the witness version is non-zero, 1 byte: the length of the\n> witness program.\n>       ** A conversion of the 2-to-40-byte witness program (as defined by [\n> https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki BIP141])\n> to base32:\n>       *** Start with the bits of the witness program, most significant bit\n> per byte first.\n>       *** Re-arrange those bits into groups of 5, and pad with zeroes at\n> the end if needed.\n>       *** Translate those bits to characters using the table above.\n>\n> This retains the ability of a bech32 address to specify any valid witness\n> length and allows future version 1 addresses with lengths other than 32,\n> while closing this malleation.\n>\n> Older software being given the modified v1 address format would mis-send\n> it to the wrong witness program, however.\n>\n> Alternately we could just keep using version 0 in the address format\n> forever.\n> The requirement would be to ensure that SegWit vN (N >= 1) output witness\n> programs would have a data-part value encoded as below:\n>\n>     * The data-part values:\n>     ** 1 byte: legacy witness version, which must always be 0.\n>     ** 1 byte: actual witness version, which must be non-zero.\n>     ** 1 byte: padding length: 0 or 1.\n>     ** If padding length is 1, 1 byte: padding, which must be 0.\n>     ** 1 byte: witness program length.\n>     ** variable: witness program.\n>\n> A writer for a v1 or later address would initially set an empty padding,\n> then compute:\n>\n>       1 // actual witness version\n>     + 1 // padding length\n>     + 1 // witness length\n>     + witness_length\n>\n> If the above sum is 20 or 32, then the writer selects a non-zero padding\n> and inserts the padding byte so that the above sum is now 21 or 33.\n>\n> To a reader that understands only bech32 v0, such an encoding would look\n> like a SegWit v0 invalid-program-length, and be rejected.\n> A reader which understands the above protocol would, instead of rejecting\n> a SegWit v0 invalid-program-length, instead attempt to parse it as above\n> first, and consider it as SegWit v1 or higher if it was parsed correctly as\n> above.\n>\n> The above proposal is of course ridiculous and I am now currently running\n> diagnostics on my processing units to see if further glitches occur in test\n> reasoning skills.\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191108/7280da70/attachment.html>"
            },
            {
                "author": "Damian Mee",
                "date": "2019-11-08T13:42:13",
                "message_text_only": "> a new human-readable-prefix for length prefixed bitcoin witness\nprograms.  \"btc1\" anyone?\n\nYes, please!\n\nOn Fri, Nov 8, 2019 at 2:04 PM Russell O'Connor via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I do like the idea of length prefixing the witness program.  I will note\n> that the 1 byte witness version is really more like a 1 character witness\n> version.  There are 17 different segwit versions and there are 32\n> characters in the bech32 alphabet.  That leaves 15 unused characters that\n> we can use for assigning new meanings too.\n>\n> That said, it is probably most sensible to define a new\n> human-readable-prefix for length prefixed bitcoin witness programs.  \"btc1\"\n> anyone?\n>\n> On Fri, Nov 8, 2019 at 12:12 AM ZmnSCPxj via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Good morning Pieter, and all,\n>>\n>> Can we modify Bech32 SegWit address format for version 1 and above as\n>> below?\n>>\n>>       * The data-part values:\n>>       ** 1 byte: the witness version\n>>     + ** If the witness version is non-zero, 1 byte: the length of the\n>> witness program.\n>>       ** A conversion of the 2-to-40-byte witness program (as defined by [\n>> https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki BIP141])\n>> to base32:\n>>       *** Start with the bits of the witness program, most significant\n>> bit per byte first.\n>>       *** Re-arrange those bits into groups of 5, and pad with zeroes at\n>> the end if needed.\n>>       *** Translate those bits to characters using the table above.\n>>\n>> This retains the ability of a bech32 address to specify any valid witness\n>> length and allows future version 1 addresses with lengths other than 32,\n>> while closing this malleation.\n>>\n>> Older software being given the modified v1 address format would mis-send\n>> it to the wrong witness program, however.\n>>\n>> Alternately we could just keep using version 0 in the address format\n>> forever.\n>> The requirement would be to ensure that SegWit vN (N >= 1) output witness\n>> programs would have a data-part value encoded as below:\n>>\n>>     * The data-part values:\n>>     ** 1 byte: legacy witness version, which must always be 0.\n>>     ** 1 byte: actual witness version, which must be non-zero.\n>>     ** 1 byte: padding length: 0 or 1.\n>>     ** If padding length is 1, 1 byte: padding, which must be 0.\n>>     ** 1 byte: witness program length.\n>>     ** variable: witness program.\n>>\n>> A writer for a v1 or later address would initially set an empty padding,\n>> then compute:\n>>\n>>       1 // actual witness version\n>>     + 1 // padding length\n>>     + 1 // witness length\n>>     + witness_length\n>>\n>> If the above sum is 20 or 32, then the writer selects a non-zero padding\n>> and inserts the padding byte so that the above sum is now 21 or 33.\n>>\n>> To a reader that understands only bech32 v0, such an encoding would look\n>> like a SegWit v0 invalid-program-length, and be rejected.\n>> A reader which understands the above protocol would, instead of rejecting\n>> a SegWit v0 invalid-program-length, instead attempt to parse it as above\n>> first, and consider it as SegWit v1 or higher if it was parsed correctly as\n>> above.\n>>\n>> The above proposal is of course ridiculous and I am now currently running\n>> diagnostics on my processing units to see if further glitches occur in test\n>> reasoning skills.\n>>\n>> Regards,\n>> ZmnSCPxj\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191108/e3ee321a/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Bech32 weakness and impact on bip-taproot addresses",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Eric Voskuil",
                "David A. Harding",
                "Damian Mee",
                "Clark Moody",
                "ZmnSCPxj",
                "Russell O'Connor",
                "Matt Corallo",
                "Pieter Wuille",
                "Greg Sanders"
            ],
            "messages_count": 13,
            "total_messages_chars_count": 38487
        }
    },
    {
        "title": "[bitcoin-dev] CVE-2017-18350 disclosure",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2019-11-08T15:07:36",
                "message_text_only": "CVE-2017-18350 is a buffer overflow vulnerability which allows a malicious \nSOCKS proxy server to overwrite the program stack on systems with a signed \n`char` type (including common 32-bit and 64-bit x86 PCs).\n\nThe vulnerability was introduced in 60a87bce873ce1f76a80b7b8546e83a0cd4e07a5 \n(SOCKS5 support) and first released in Bitcoin Core v0.7.0rc1 in 2012 Aug 27.\nA fix was hidden in d90a00eabed0f3f1acea4834ad489484d0012372 (\"Improve and \ndocument SOCKS code\") released in v0.15.1, 2017 Nov 6.\n\nTo be vulnerable, the node must be configured to use such a malicious proxy in \nthe first place. Note that using *any* proxy over an insecure network (such \nas the Internet) is potentially a vulnerability since the connection could be \nintercepted for such a purpose.\n\nUpon a connection request from the node, the malicious proxy would respond \nwith an acknowledgement of a different target domain name than the one\nrequested. Normally this acknowledgement is entirely ignored, but if the \nlength uses the high bit (ie, a length 128-255 inclusive), it will be \ninterpreted by vulnerable versions as a negative number instead. When the \nnegative number is passed to the recv() system call to read the domain name, \nit is converted back to an unsigned/positive number, but at a much wider size \n(typically 32-bit), resulting in an effectively infinite read into and beyond \nthe 256-byte dummy stack buffer.\n\nTo fix this vulnerability, the dummy buffer was changed to an explicitly \nunsigned data type, avoiding the conversion to/from a negative number.\n\nCredit goes to practicalswift (https://twitter.com/practicalswift) for \ndiscovering and providing the initial fix for the vulnerability, and Wladimir \nJ. van der Laan for a disguised version of the fix as well as general cleanup \nto the at-risk code.\n\nTimeline:\n- 2012-04-01: Vulnerability introduced in PR #1141.\n- 2012-05-08: Vulnerability merged to master git repository.\n- 2012-08-27: Vulnerability published in v0.7.0rc1.\n- 2012-09-17: Vulnerability released in v0.7.0.\n...\n- 2017-09-21: practicalswift discloses vulnerability to security team.\n- 2017-09-23: Wladimir opens PR #11397 to quietly fix vulernability.\n- 2017-09-27: Fix merged to master git repository.\n- 2017-10-18: Fix merged to 0.15 git repository.\n- 2017-11-04: Fix published in v0.15.1rc1.\n- 2017-11-09: Fix released in v0.15.1.\n...\n- 2019-06-22: Vulnerability existence disclosed to bitcoin-dev ML.\n- 2019-11-08: Vulnerability details disclosure to bitcoin-dev ML."
            },
            {
                "author": "LORD HIS EXCELLENCY JAMES HRMH",
                "date": "2019-11-08T17:03:02",
                "message_text_only": "It goes without saying in that all privately known CVE should be handled so professionally but, that is, well done team.\n\nRegards,\nLORD HIS EXCELLENCY JAMES HRMH\n\n\n________________________________\nFrom: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nSent: Saturday, 9 November 2019 2:07 AM\nTo: bitcoin-dev at lists.linuxfoundation.org <bitcoin-dev at lists.linuxfoundation.org>\nCc: security at bitcoincore.org <security at bitcoincore.org>\nSubject: [bitcoin-dev] CVE-2017-18350 disclosure\n\nCVE-2017-18350 is a buffer overflow vulnerability which allows a malicious\nSOCKS proxy server to overwrite the program stack on systems with a signed\n`char` type (including common 32-bit and 64-bit x86 PCs).\n\nThe vulnerability was introduced in 60a87bce873ce1f76a80b7b8546e83a0cd4e07a5\n(SOCKS5 support) and first released in Bitcoin Core v0.7.0rc1 in 2012 Aug 27.\nA fix was hidden in d90a00eabed0f3f1acea4834ad489484d0012372 (\"Improve and\ndocument SOCKS code\") released in v0.15.1, 2017 Nov 6.\n\nTo be vulnerable, the node must be configured to use such a malicious proxy in\nthe first place. Note that using *any* proxy over an insecure network (such\nas the Internet) is potentially a vulnerability since the connection could be\nintercepted for such a purpose.\n\nUpon a connection request from the node, the malicious proxy would respond\nwith an acknowledgement of a different target domain name than the one\nrequested. Normally this acknowledgement is entirely ignored, but if the\nlength uses the high bit (ie, a length 128-255 inclusive), it will be\ninterpreted by vulnerable versions as a negative number instead. When the\nnegative number is passed to the recv() system call to read the domain name,\nit is converted back to an unsigned/positive number, but at a much wider size\n(typically 32-bit), resulting in an effectively infinite read into and beyond\nthe 256-byte dummy stack buffer.\n\nTo fix this vulnerability, the dummy buffer was changed to an explicitly\nunsigned data type, avoiding the conversion to/from a negative number.\n\nCredit goes to practicalswift (https://twitter.com/practicalswift) for\ndiscovering and providing the initial fix for the vulnerability, and Wladimir\nJ. van der Laan for a disguised version of the fix as well as general cleanup\nto the at-risk code.\n\nTimeline:\n- 2012-04-01: Vulnerability introduced in PR #1141.\n- 2012-05-08: Vulnerability merged to master git repository.\n- 2012-08-27: Vulnerability published in v0.7.0rc1.\n- 2012-09-17: Vulnerability released in v0.7.0.\n...\n- 2017-09-21: practicalswift discloses vulnerability to security team.\n- 2017-09-23: Wladimir opens PR #11397 to quietly fix vulernability.\n- 2017-09-27: Fix merged to master git repository.\n- 2017-10-18: Fix merged to 0.15 git repository.\n- 2017-11-04: Fix published in v0.15.1rc1.\n- 2017-11-09: Fix released in v0.15.1.\n...\n- 2019-06-22: Vulnerability existence disclosed to bitcoin-dev ML.\n- 2019-11-08: Vulnerability details disclosure to bitcoin-dev ML.\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191108/aace00bf/attachment-0001.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2019-11-08T19:40:17",
                "message_text_only": "Sure, but what is questionable here is the use of SOCKS proxy, for Tor I\nthink as the main purpose, making it dangerous for the \"whole bitcoin\nworld\" while it's something like of zero interest/use (or please let me\nknow what it is beside Tor)\n\nThe Tor network is very centralized and not designed at all to handle\np2p networks (which bitcoin is still not), it is designed to be used via\nthe Tor Browser to browse the web and to hide web servers, not bitcoin\nnodes, and there are a lot of misbehaving/dangerous nodes there, there\nis no encryption in bitcoin protocol, an exit node can fake whatever it\nlikes, this seems to be a use case as far as I can see, but even if the\ninitiator is configured to connect to a hidden bitcoin node, I don't see\nthe point\n\nI have advertised recentlty the open sourcing of node-Tor\n(https://github.com/Ayms/node-Tor) here\n\nThis one is designed for p2p, not over the Tor network but using the Tor\nprotocol, as simple as bitcoin.pipe(node-Tor), or <any\nprotocol>.pipe(node-Tor), which is the finality of the project as far as\nI see it since years (maybe see http://www.peersm.com/Convergence.pdf\neven if I would modify some parts now)\n\nInside servers or browsers acting as servers also (WebRTC or\nWebSockets), bitcoin peers (servers/browsers) relaying the bitcoin\nanonymized protocol using the Tor protocol (and not the Tor network)\nbetween each others, there is no story of exit nodes here and rdv points\nwould not apply for bitcoin use, this \"just\" adds the internal missing\nencryption and anonymity layer to the bitcoin protocol\n\nPersonally I would remove the socks proxy interface from bitcoin core,\nindependently of Tor this can be misused too and offers absolutely zero\nsecurity\n\n\nLe 08/11/2019 \u00e0 18:03, LORD HIS EXCELLENCY JAMES HRMH via bitcoin-dev a\n\u00e9crit\u00a0:\n> It goes without saying in that all privately known CVE should be\n> handled so professionally but, that is, well done team.\n>\n> Regards,\n> LORD HIS EXCELLENCY JAMES HRMH\n>\n>\n> ------------------------------------------------------------------------\n> *From:* bitcoin-dev-bounces at lists.linuxfoundation.org\n> <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Luke\n> Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> *Sent:* Saturday, 9 November 2019 2:07 AM\n> *To:* bitcoin-dev at lists.linuxfoundation.org\n> <bitcoin-dev at lists.linuxfoundation.org>\n> *Cc:* security at bitcoincore.org <security at bitcoincore.org>\n> *Subject:* [bitcoin-dev] CVE-2017-18350 disclosure\n> \u00a0\n> CVE-2017-18350 is a buffer overflow vulnerability which allows a\n> malicious\n> SOCKS proxy server to overwrite the program stack on systems with a\n> signed\n> `char` type (including common 32-bit and 64-bit x86 PCs).\n>\n> The vulnerability was introduced in\n> 60a87bce873ce1f76a80b7b8546e83a0cd4e07a5\n> (SOCKS5 support) and first released in Bitcoin Core v0.7.0rc1 in 2012\n> Aug 27.\n> A fix was hidden in d90a00eabed0f3f1acea4834ad489484d0012372 (\"Improve\n> and\n> document SOCKS code\") released in v0.15.1, 2017 Nov 6.\n>\n> To be vulnerable, the node must be configured to use such a malicious\n> proxy in\n> the first place. Note that using *any* proxy over an insecure network\n> (such\n> as the Internet) is potentially a vulnerability since the connection\n> could be\n> intercepted for such a purpose.\n>\n> Upon a connection request from the node, the malicious proxy would\n> respond\n> with an acknowledgement of a different target domain name than the one\n> requested. Normally this acknowledgement is entirely ignored, but if the\n> length uses the high bit (ie, a length 128-255 inclusive), it will be\n> interpreted by vulnerable versions as a negative number instead. When the\n> negative number is passed to the recv() system call to read the domain\n> name,\n> it is converted back to an unsigned/positive number, but at a much\n> wider size\n> (typically 32-bit), resulting in an effectively infinite read into and\n> beyond\n> the 256-byte dummy stack buffer.\n>\n> To fix this vulnerability, the dummy buffer was changed to an explicitly\n> unsigned data type, avoiding the conversion to/from a negative number.\n>\n> Credit goes to practicalswift (https://twitter.com/practicalswift) for\n> discovering and providing the initial fix for the vulnerability, and\n> Wladimir\n> J. van der Laan for a disguised version of the fix as well as general\n> cleanup\n> to the at-risk code.\n>\n> Timeline:\n> - 2012-04-01: Vulnerability introduced in PR #1141.\n> - 2012-05-08: Vulnerability merged to master git repository.\n> - 2012-08-27: Vulnerability published in v0.7.0rc1.\n> - 2012-09-17: Vulnerability released in v0.7.0.\n> ...\n> - 2017-09-21: practicalswift discloses vulnerability to security team.\n> - 2017-09-23: Wladimir opens PR #11397 to quietly fix vulernability.\n> - 2017-09-27: Fix merged to master git repository.\n> - 2017-10-18: Fix merged to 0.15 git repository.\n> - 2017-11-04: Fix published in v0.15.1rc1.\n> - 2017-11-09: Fix released in v0.15.1.\n> ...\n> - 2019-06-22: Vulnerability existence disclosed to bitcoin-dev ML.\n> - 2019-11-08: Vulnerability details disclosure to bitcoin-dev ML.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191108/e9797500/attachment.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2019-11-09T19:33:25",
                "message_text_only": "???\n\n\nWell, you obviously don't know what you are talking about and did not\neven consider reading correctly what I wrote, neither to read node-Tor\n\n\nWhat you are saying here is quite trivial, typical of people thinking\nthat the Tor network will solve everything and is not centralized (but\nyou seem unsure about it), that's not the case, it's completely wrong\nand the \"normal\" use of the Tor network is for browsing only, basically\nthe Tor network is still the same since years: 1000 guards, 1000 relays,\n1000 exits (so not \"hundreds\", happier, and there are of course\nintersections between them, knowing that they are the supposed working\nnodes as tested by node-Tor), quite small at the end with finally many\nmisbehaving nodes among the 3000 set, not at all able or willing to\nhandle bitcoin nodes load\n\n\nUsing bitcoin with the Tor network is absurd, using socks proxy with\nbitcoin is absurd too (I don't get the comparison with a http proxy,\nnothing to do),\u00a0 except if limited to a local use, ie you socks proxy\ninside your device, for example to pipe to node-Tor, but this remains as\na whole dangerous if the local proxy has been hacked, as we could see\nrecently with malware Tor sw being used by people\n\n\nUsing the Tor protocol for bitcoin is not absurd at all (do you\nunderstand the difference?) + browsers, webRTC, etc I will not repeat\nwhat I wrote\n\n\nPlease do some readings or consider at least what I sent, or ask\nquestions if what I am saying is unclear for you\n\n\nBut from my standpoint the discussion on this list is not about\nexplaining all of this that is probably well known by everybody but what\ncan/could be next to anonymize/help anonymizing bitcoin\n\n\u00a0when required and make it a real p2p network\n\n\nUnfortunately I am afraid that we get moderated here because that's not\nthe place to give basic lessons about Tor that you don't know\n\n\nLe 09/11/2019 \u00e0 12:42, LORD HIS EXCELLENCY JAMES HRMH a \u00e9crit\u00a0:\n> Socks proxies have their use in controlled gateway infrastructure and\n> is a relevant feature for any software required to operate behind a\n> secure network boundary and allows for UDP connectivity (whether it is\n> utilised in any particular application) which a HTTP proxy does not.\n>\n> You are obviously not well abreast of the Tor project, regardless of\n> whether it seems centralised, whether it is or it isn't, the Tor\n> project is to allow anonymity and connection privacy. For this it\n> works very well and there seem to be hundreds of known Tor nodes, to\n> be known they are not isolated and are connected.\n>\n> Even if an exit node performs all logging it is only aware of the node\n> one hop up but the originator is higher still. In the case where we\n> perform a Tor cluster and make hundreds of guard, middle and exit\n> nodes we still cannot with absolute certainty say that the connecting\n> node is the originator and, the eventual Bitcoin node is still unaware\n> of the originator IP which is the primary objective. Otherwise, can\n> you hide your IP from your ISP would be a better goal?\n>\n> You may prefer to familiarise yourself first with the history of Tor,\n> even a brief from [WikipediaTor_(anonymity_network)\n> <https://en.wikipedia.org/wiki/Tor_(anonymity_network)>](https://en.wikipedia.org/wiki/Tor_(anonymity_network))\n> and consider some of the possible uses, and consider how its\n> implementation benefits the privacy and anonymity of Bitcoin in public\n> where it is allowed in many countries; Tor is just as useful in\n> countries where Bitcoin is allowed to hide from third-parties. You may\n> also enjoy an example of activating Bitcoin Cores Tor implementation:\n> [How can I setup Bitcoin to be anonymous with\n> Tor?](https://bitcoin.stackexchange.com/questions/70069/how-can-i-setup-bitcoin-to-be-anonymous-with-tor/70070#70070)\n> <https://en.wikipedia.org/wiki/Tor_(anonymity_network)>\n> \t\n> Tor (anonymity network) - Wikipedia\n> <https://en.wikipedia.org/wiki/Tor_(anonymity_network)>\n> Tor is free and open-source software for enabling anonymous\n> communication.The name is derived from an acronym for the original\n> software project name \"The Onion Router\". Tor directs Internet traffic\n> through a free, worldwide, volunteer overlay network consisting of\n> more than seven thousand relays to conceal a user's location and usage\n> from anyone conducting network surveillance or traffic analysis.\n> en.wikipedia.org\n>\n>\n> <https://bitcoin.stackexchange.com/questions/70069/how-can-i-setup-bitcoin-to-be-anonymous-with-tor/70070#70070>\n> \t\n> bitcoind - How can I setup Bitcoin to be anonymous with Tor? - Bitcoin\n> Stack Exchange\n> <https://bitcoin.stackexchange.com/questions/70069/how-can-i-setup-bitcoin-to-be-anonymous-with-tor/70070#70070>\n> Bitcoin is billed as many things, among them its anonymity is highly\n> regarded. While it is true that a transaction does not identify a user\n> or wallet, recent news shows that there is the potential ...\n> bitcoin.stackexchange.com\n>\n>\n>\n> There should be no rational consideration that gives rise to reducing\n> Tor connectivity, possibly v3 integration will be coming along.\n>\n> Regards,\n> LORD HIS EXCELLENCY JAMES HRMH\n>\n>\n> ------------------------------------------------------------------------\n> *From:* Aymeric Vitte <vitteaymeric at gmail.com>\n> *Sent:* Saturday, 9 November 2019 6:40 AM\n> *To:* LORD HIS EXCELLENCY JAMES HRMH <willtech at live.com.au>; Bitcoin\n> Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>; Luke\n> Dashjr <luke at dashjr.org>\n> *Cc:* security at bitcoincore.org <security at bitcoincore.org>\n> *Subject:* Re: [bitcoin-dev] CVE-2017-18350 disclosure\n> \u00a0\n>\n> Sure, but what is questionable here is the use of SOCKS proxy, for Tor\n> I think as the main purpose, making it dangerous for the \"whole\n> bitcoin world\" while it's something like of zero interest/use (or\n> please let me know what it is beside Tor)\n>\n> The Tor network is very centralized and not designed at all to handle\n> p2p networks (which bitcoin is still not), it is designed to be used\n> via the Tor Browser to browse the web and to hide web servers, not\n> bitcoin nodes, and there are a lot of misbehaving/dangerous nodes\n> there, there is no encryption in bitcoin protocol, an exit node can\n> fake whatever it likes, this seems to be a use case as far as I can\n> see, but even if the initiator is configured to connect to a hidden\n> bitcoin node, I don't see the point\n>\n> I have advertised recentlty the open sourcing of node-Tor\n> (https://github.com/Ayms/node-Tor) here\n>\n> This one is designed for p2p, not over the Tor network but using the\n> Tor protocol, as simple as bitcoin.pipe(node-Tor), or <any\n> protocol>.pipe(node-Tor), which is the finality of the project as far\n> as I see it since years (maybe see\n> http://www.peersm.com/Convergence.pdf even if I would modify some\n> parts now)\n>\n> Inside servers or browsers acting as servers also (WebRTC or\n> WebSockets), bitcoin peers (servers/browsers) relaying the bitcoin\n> anonymized protocol using the Tor protocol (and not the Tor network)\n> between each others, there is no story of exit nodes here and rdv\n> points would not apply for bitcoin use, this \"just\" adds the internal\n> missing encryption and anonymity layer to the bitcoin protocol\n>\n> Personally I would remove the socks proxy interface from bitcoin core,\n> independently of Tor this can be misused too and offers absolutely\n> zero security\n>\n>\n> Le 08/11/2019 \u00e0 18:03, LORD HIS EXCELLENCY JAMES HRMH via bitcoin-dev\n> a \u00e9crit\u00a0:\n>> It goes without saying in that all privately known CVE should be\n>> handled so professionally but, that is, well done team.\n>>\n>> Regards,\n>> LORD HIS EXCELLENCY JAMES HRMH\n>>\n>>\n>> ------------------------------------------------------------------------\n>> *From:* bitcoin-dev-bounces at lists.linuxfoundation.org\n>> <mailto:bitcoin-dev-bounces at lists.linuxfoundation.org>\n>> <bitcoin-dev-bounces at lists.linuxfoundation.org>\n>> <mailto:bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of\n>> Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n>> <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>> *Sent:* Saturday, 9 November 2019 2:07 AM\n>> *To:* bitcoin-dev at lists.linuxfoundation.org\n>> <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>> <bitcoin-dev at lists.linuxfoundation.org>\n>> <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>> *Cc:* security at bitcoincore.org <mailto:security at bitcoincore.org>\n>> <security at bitcoincore.org> <mailto:security at bitcoincore.org>\n>> *Subject:* [bitcoin-dev] CVE-2017-18350 disclosure\n>> \u00a0\n>> CVE-2017-18350 is a buffer overflow vulnerability which allows a\n>> malicious\n>> SOCKS proxy server to overwrite the program stack on systems with a\n>> signed\n>> `char` type (including common 32-bit and 64-bit x86 PCs).\n>>\n>> The vulnerability was introduced in\n>> 60a87bce873ce1f76a80b7b8546e83a0cd4e07a5\n>> (SOCKS5 support) and first released in Bitcoin Core v0.7.0rc1 in 2012\n>> Aug 27.\n>> A fix was hidden in d90a00eabed0f3f1acea4834ad489484d0012372\n>> (\"Improve and\n>> document SOCKS code\") released in v0.15.1, 2017 Nov 6.\n>>\n>> To be vulnerable, the node must be configured to use such a malicious\n>> proxy in\n>> the first place. Note that using *any* proxy over an insecure network\n>> (such\n>> as the Internet) is potentially a vulnerability since the connection\n>> could be\n>> intercepted for such a purpose.\n>>\n>> Upon a connection request from the node, the malicious proxy would\n>> respond\n>> with an acknowledgement of a different target domain name than the one\n>> requested. Normally this acknowledgement is entirely ignored, but if the\n>> length uses the high bit (ie, a length 128-255 inclusive), it will be\n>> interpreted by vulnerable versions as a negative number instead. When\n>> the\n>> negative number is passed to the recv() system call to read the\n>> domain name,\n>> it is converted back to an unsigned/positive number, but at a much\n>> wider size\n>> (typically 32-bit), resulting in an effectively infinite read into\n>> and beyond\n>> the 256-byte dummy stack buffer.\n>>\n>> To fix this vulnerability, the dummy buffer was changed to an explicitly\n>> unsigned data type, avoiding the conversion to/from a negative number.\n>>\n>> Credit goes to practicalswift (https://twitter.com/practicalswift) for\n>> discovering and providing the initial fix for the vulnerability, and\n>> Wladimir\n>> J. van der Laan for a disguised version of the fix as well as general\n>> cleanup\n>> to the at-risk code.\n>>\n>> Timeline:\n>> - 2012-04-01: Vulnerability introduced in PR #1141.\n>> - 2012-05-08: Vulnerability merged to master git repository.\n>> - 2012-08-27: Vulnerability published in v0.7.0rc1.\n>> - 2012-09-17: Vulnerability released in v0.7.0.\n>> ...\n>> - 2017-09-21: practicalswift discloses vulnerability to security team.\n>> - 2017-09-23: Wladimir opens PR #11397 to quietly fix vulernability.\n>> - 2017-09-27: Fix merged to master git repository.\n>> - 2017-10-18: Fix merged to 0.15 git repository.\n>> - 2017-11-04: Fix published in v0.15.1rc1.\n>> - 2017-11-09: Fix released in v0.15.1.\n>> ...\n>> - 2019-06-22: Vulnerability existence disclosed to bitcoin-dev ML.\n>> - 2019-11-08: Vulnerability details disclosure to bitcoin-dev ML.\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191109/0e41bee1/attachment-0001.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2019-11-10T00:23:03",
                "message_text_only": "Do not find excuses (and vague statements or technical bulls) and learn,\nyou don't know what you are talking about and don't get the global\npicture, we don't care about the Tor network and they don't care about\nothers neither do they care that they increase their network, so indeed\nlet's stop this discussion\n\n\nJust replying here (for the last time) because expecting more clever\nthoughts about what I wrote, maybe one day... but for sure something\nlike this will happen in the future\n\n\nLe 09/11/2019 \u00e0 21:21, LORD HIS EXCELLENCY JAMES HRMH a \u00e9crit\u00a0:\n> We do not need to discuss this back and forward publickly. I am not\n> concerned whether Tors seems or is much centralised or not, it is not\n> the concern of m statements, and it required directory nodes of which\n> there are several and we could discuss the operation of its nodes and\n> infrastructure all day, even comparing directory nodes to seed nodes.\n> The fact is that browsing is the most common publicly understood usage\n> of Tor but like with and without Tor the internet provides many services.\n>\n> It seems you have misunderstood the reason I reference making so many\n> Tor nodes also but do not concern I will no reiterate. Also, whether\n> Tor can provide for the bandwidth and connectivity required for\n> Bitcoin you have not tested and provide only your opinion, where it\n> seems that actually it can. The matter is that Tor carries Bitcoin\n> traffic quite easily now and in fact as there is more Bitcoin traffic\n> likely the Tor capacity increases in some proportion.\n>\n> Also, socks proxy is not a door in, it is a door out, do you realise\n> but just works at a different network layer to HTTP proxy which works\n> at layer 7 of the OSI model and Socks a bit lower?\n>\n> I have had some communication difficulty before where the native\n> language is not English and although the communication happens in\n> native English the though is still being formed in another language\n> and so the presentation of the thought is not clear to the English\n> presentation. Even if not this I do not consider wrong just that we\n> write to consider not the same thing.\n>\n> Good day.\n>\n> Regards,\n> LORD HIS EXCELLENCY JAMES HRMH\n>\n>\n> ------------------------------------------------------------------------\n> *From:* Aymeric Vitte <vitteaymeric at gmail.com>\n> *Sent:* Sunday, 10 November 2019 6:33 AM\n> *To:* LORD HIS EXCELLENCY JAMES HRMH <willtech at live.com.au>; Bitcoin\n> Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>; Luke\n> Dashjr <luke at dashjr.org>\n> *Cc:* security at bitcoincore.org <security at bitcoincore.org>\n> *Subject:* Re: [bitcoin-dev] CVE-2017-18350 disclosure\n> \u00a0\n>\n> ???\n>\n>\n> Well, you obviously don't know what you are talking about and did not\n> even consider reading correctly what I wrote, neither to read node-Tor\n>\n>\n> What you are saying here is quite trivial, typical of people thinking\n> that the Tor network will solve everything and is not centralized (but\n> you seem unsure about it), that's not the case, it's completely wrong\n> and the \"normal\" use of the Tor network is for browsing only,\n> basically the Tor network is still the same since years: 1000 guards,\n> 1000 relays, 1000 exits (so not \"hundreds\", happier, and there are of\n> course intersections between them, knowing that they are the supposed\n> working nodes as tested by node-Tor), quite small at the end with\n> finally many misbehaving nodes among the 3000 set, not at all able or\n> willing to handle bitcoin nodes load\n>\n>\n> Using bitcoin with the Tor network is absurd, using socks proxy with\n> bitcoin is absurd too (I don't get the comparison with a http proxy,\n> nothing to do),\u00a0 except if limited to a local use, ie you socks proxy\n> inside your device, for example to pipe to node-Tor, but this remains\n> as a whole dangerous if the local proxy has been hacked, as we could\n> see recently with malware Tor sw being used by people\n>\n>\n> Using the Tor protocol for bitcoin is not absurd at all (do you\n> understand the difference?) + browsers, webRTC, etc I will not repeat\n> what I wrote\n>\n>\n> Please do some readings or consider at least what I sent, or ask\n> questions if what I am saying is unclear for you\n>\n>\n> But from my standpoint the discussion on this list is not about\n> explaining all of this that is probably well known by everybody but\n> what can/could be next to anonymize/help anonymizing bitcoin\n>\n> \u00a0when required and make it a real p2p network\n>\n>\n> Unfortunately I am afraid that we get moderated here because that's\n> not the place to give basic lessons about Tor that you don't know\n>\n>\n> Le 09/11/2019 \u00e0 12:42, LORD HIS EXCELLENCY JAMES HRMH a \u00e9crit\u00a0:\n>> Socks proxies have their use in controlled gateway infrastructure and\n>> is a relevant feature for any software required to operate behind a\n>> secure network boundary and allows for UDP connectivity (whether it\n>> is utilised in any particular application) which a HTTP proxy does not.\n>>\n>> You are obviously not well abreast of the Tor project, regardless of\n>> whether it seems centralised, whether it is or it isn't, the Tor\n>> project is to allow anonymity and connection privacy. For this it\n>> works very well and there seem to be hundreds of known Tor nodes, to\n>> be known they are not isolated and are connected.\n>>\n>> Even if an exit node performs all logging it is only aware of the\n>> node one hop up but the originator is higher still. In the case where\n>> we perform a Tor cluster and make hundreds of guard, middle and exit\n>> nodes we still cannot with absolute certainty say that the connecting\n>> node is the originator and, the eventual Bitcoin node is still\n>> unaware of the originator IP which is the primary objective.\n>> Otherwise, can you hide your IP from your ISP would be a better goal?\n>>\n>> You may prefer to familiarise yourself first with the history of Tor,\n>> even a brief from [WikipediaTor_(anonymity_network)\n>> <https://en.wikipedia.org/wiki/Tor_(anonymity_network)>](https://en.wikipedia.org/wiki/Tor_(anonymity_network))\n>> and consider some of the possible uses, and consider how its\n>> implementation benefits the privacy and anonymity of Bitcoin in\n>> public where it is allowed in many countries; Tor is just as useful\n>> in countries where Bitcoin is allowed to hide from third-parties. You\n>> may also enjoy an example of activating Bitcoin Cores Tor\n>> implementation: [How can I setup Bitcoin to be anonymous with\n>> Tor?](https://bitcoin.stackexchange.com/questions/70069/how-can-i-setup-bitcoin-to-be-anonymous-with-tor/70070#70070)\n>> <https://en.wikipedia.org/wiki/Tor_(anonymity_network)>\n>> \t\n>> Tor (anonymity network) - Wikipedia\n>> <https://en.wikipedia.org/wiki/Tor_(anonymity_network)>\n>> Tor is free and open-source software for enabling anonymous\n>> communication.The name is derived from an acronym for the original\n>> software project name \"The Onion Router\". Tor directs Internet\n>> traffic through a free, worldwide, volunteer overlay network\n>> consisting of more than seven thousand relays to conceal a user's\n>> location and usage from anyone conducting network surveillance or\n>> traffic analysis.\n>> en.wikipedia.org\n>>\n>>\n>> <https://bitcoin.stackexchange.com/questions/70069/how-can-i-setup-bitcoin-to-be-anonymous-with-tor/70070#70070>\n>> \t\n>> bitcoind - How can I setup Bitcoin to be anonymous with Tor? -\n>> Bitcoin Stack Exchange\n>> <https://bitcoin.stackexchange.com/questions/70069/how-can-i-setup-bitcoin-to-be-anonymous-with-tor/70070#70070>\n>> Bitcoin is billed as many things, among them its anonymity is highly\n>> regarded. While it is true that a transaction does not identify a\n>> user or wallet, recent news shows that there is the potential ...\n>> bitcoin.stackexchange.com\n>>\n>>\n>>\n>> There should be no rational consideration that gives rise to reducing\n>> Tor connectivity, possibly v3 integration will be coming along.\n>>\n>> Regards,\n>> LORD HIS EXCELLENCY JAMES HRMH\n>>\n>>\n>> ------------------------------------------------------------------------\n>> *From:* Aymeric Vitte <vitteaymeric at gmail.com>\n>> <mailto:vitteaymeric at gmail.com>\n>> *Sent:* Saturday, 9 November 2019 6:40 AM\n>> *To:* LORD HIS EXCELLENCY JAMES HRMH <willtech at live.com.au>\n>> <mailto:willtech at live.com.au>; Bitcoin Protocol Discussion\n>> <bitcoin-dev at lists.linuxfoundation.org>\n>> <mailto:bitcoin-dev at lists.linuxfoundation.org>; Luke Dashjr\n>> <luke at dashjr.org> <mailto:luke at dashjr.org>\n>> *Cc:* security at bitcoincore.org <mailto:security at bitcoincore.org>\n>> <security at bitcoincore.org> <mailto:security at bitcoincore.org>\n>> *Subject:* Re: [bitcoin-dev] CVE-2017-18350 disclosure\n>> \u00a0\n>>\n>> Sure, but what is questionable here is the use of SOCKS proxy, for\n>> Tor I think as the main purpose, making it dangerous for the \"whole\n>> bitcoin world\" while it's something like of zero interest/use (or\n>> please let me know what it is beside Tor)\n>>\n>> The Tor network is very centralized and not designed at all to handle\n>> p2p networks (which bitcoin is still not), it is designed to be used\n>> via the Tor Browser to browse the web and to hide web servers, not\n>> bitcoin nodes, and there are a lot of misbehaving/dangerous nodes\n>> there, there is no encryption in bitcoin protocol, an exit node can\n>> fake whatever it likes, this seems to be a use case as far as I can\n>> see, but even if the initiator is configured to connect to a hidden\n>> bitcoin node, I don't see the point\n>>\n>> I have advertised recentlty the open sourcing of node-Tor\n>> (https://github.com/Ayms/node-Tor) here\n>>\n>> This one is designed for p2p, not over the Tor network but using the\n>> Tor protocol, as simple as bitcoin.pipe(node-Tor), or <any\n>> protocol>.pipe(node-Tor), which is the finality of the project as far\n>> as I see it since years (maybe see\n>> http://www.peersm.com/Convergence.pdf\n>> <http://www.peersm.com/Convergence.pdf> even if I would modify some\n>> parts now)\n>>\n>> Inside servers or browsers acting as servers also (WebRTC or\n>> WebSockets), bitcoin peers (servers/browsers) relaying the bitcoin\n>> anonymized protocol using the Tor protocol (and not the Tor network)\n>> between each others, there is no story of exit nodes here and rdv\n>> points would not apply for bitcoin use, this \"just\" adds the internal\n>> missing encryption and anonymity layer to the bitcoin protocol\n>>\n>> Personally I would remove the socks proxy interface from bitcoin\n>> core, independently of Tor this can be misused too and offers\n>> absolutely zero security\n>>\n>>\n>> Le 08/11/2019 \u00e0 18:03, LORD HIS EXCELLENCY JAMES HRMH via bitcoin-dev\n>> a \u00e9crit\u00a0:\n>>> It goes without saying in that all privately known CVE should be\n>>> handled so professionally but, that is, well done team.\n>>>\n>>> Regards,\n>>> LORD HIS EXCELLENCY JAMES HRMH\n>>>\n>>>\n>>> ------------------------------------------------------------------------\n>>> *From:* bitcoin-dev-bounces at lists.linuxfoundation.org\n>>> <mailto:bitcoin-dev-bounces at lists.linuxfoundation.org>\n>>> <bitcoin-dev-bounces at lists.linuxfoundation.org>\n>>> <mailto:bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of\n>>> Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n>>> <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>>> *Sent:* Saturday, 9 November 2019 2:07 AM\n>>> *To:* bitcoin-dev at lists.linuxfoundation.org\n>>> <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>>> <bitcoin-dev at lists.linuxfoundation.org>\n>>> <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>>> *Cc:* security at bitcoincore.org <mailto:security at bitcoincore.org>\n>>> <security at bitcoincore.org> <mailto:security at bitcoincore.org>\n>>> *Subject:* [bitcoin-dev] CVE-2017-18350 disclosure\n>>> \u00a0\n>>> CVE-2017-18350 is a buffer overflow vulnerability which allows a\n>>> malicious\n>>> SOCKS proxy server to overwrite the program stack on systems with a\n>>> signed\n>>> `char` type (including common 32-bit and 64-bit x86 PCs).\n>>>\n>>> The vulnerability was introduced in\n>>> 60a87bce873ce1f76a80b7b8546e83a0cd4e07a5\n>>> (SOCKS5 support) and first released in Bitcoin Core v0.7.0rc1 in\n>>> 2012 Aug 27.\n>>> A fix was hidden in d90a00eabed0f3f1acea4834ad489484d0012372\n>>> (\"Improve and\n>>> document SOCKS code\") released in v0.15.1, 2017 Nov 6.\n>>>\n>>> To be vulnerable, the node must be configured to use such a\n>>> malicious proxy in\n>>> the first place. Note that using *any* proxy over an insecure\n>>> network (such\n>>> as the Internet) is potentially a vulnerability since the connection\n>>> could be\n>>> intercepted for such a purpose.\n>>>\n>>> Upon a connection request from the node, the malicious proxy would\n>>> respond\n>>> with an acknowledgement of a different target domain name than the one\n>>> requested. Normally this acknowledgement is entirely ignored, but if\n>>> the\n>>> length uses the high bit (ie, a length 128-255 inclusive), it will be\n>>> interpreted by vulnerable versions as a negative number instead.\n>>> When the\n>>> negative number is passed to the recv() system call to read the\n>>> domain name,\n>>> it is converted back to an unsigned/positive number, but at a much\n>>> wider size\n>>> (typically 32-bit), resulting in an effectively infinite read into\n>>> and beyond\n>>> the 256-byte dummy stack buffer.\n>>>\n>>> To fix this vulnerability, the dummy buffer was changed to an\n>>> explicitly\n>>> unsigned data type, avoiding the conversion to/from a negative number.\n>>>\n>>> Credit goes to practicalswift (https://twitter.com/practicalswift) for\n>>> discovering and providing the initial fix for the vulnerability, and\n>>> Wladimir\n>>> J. van der Laan for a disguised version of the fix as well as\n>>> general cleanup\n>>> to the at-risk code.\n>>>\n>>> Timeline:\n>>> - 2012-04-01: Vulnerability introduced in PR #1141.\n>>> - 2012-05-08: Vulnerability merged to master git repository.\n>>> - 2012-08-27: Vulnerability published in v0.7.0rc1.\n>>> - 2012-09-17: Vulnerability released in v0.7.0.\n>>> ...\n>>> - 2017-09-21: practicalswift discloses vulnerability to security team.\n>>> - 2017-09-23: Wladimir opens PR #11397 to quietly fix vulernability.\n>>> - 2017-09-27: Fix merged to master git repository.\n>>> - 2017-10-18: Fix merged to 0.15 git repository.\n>>> - 2017-11-04: Fix published in v0.15.1rc1.\n>>> - 2017-11-09: Fix released in v0.15.1.\n>>> ...\n>>> - 2019-06-22: Vulnerability existence disclosed to bitcoin-dev ML.\n>>> - 2019-11-08: Vulnerability details disclosure to bitcoin-dev ML.\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-- \nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191110/51ff57f0/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "CVE-2017-18350 disclosure",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Luke Dashjr",
                "LORD HIS EXCELLENCY JAMES HRMH",
                "Aymeric Vitte"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 39890
        }
    },
    {
        "title": "[bitcoin-dev] Towards a singular payment protocol",
        "thread_messages": [
            {
                "author": "ee at cypherpunk.org",
                "date": "2019-11-12T15:02:09",
                "message_text_only": "A proposal for a new blockchain-agnostic payment protocol:\n\nhttps://cypherpunk.org/2019/11/10/towards-a-singular-payment-protocol/\n\nIncludes the following characteristics:\n\n- can be used with crypto or fiat currencies\n- multiple currency options for a single transaction\n- multiple payments in a single transaction\n- allow a payment in one currency, but the value to be referenced from a second currency\n- fee payment by sender or recipient\n- calculation of valuation and fees through common trusted third parties\n\nThis is a proposal for a new payment protocol that is not linked to a specific blockchain, and could be supported by many of them, as well as fiat currencies. With one system, wallet developers working on multiple currencies could still look to a single payment system, and thus full support for a single protocol would increase.\n\nI understand that some people will oppose something like this simply because it supports other coins, but I ask that it be looked at from the perspective of a) does it offer better functionality for Bitcoin, and b) would increased support by more wallets for a payment protocol be better for Bitcoin? If those are true, and I think they are, then this can be developed to the benefit of everyone.\n\nThis is the first section, focused on the actual payments. Other future sections are planned to include a section on smart contracts and tokens, and a transport mechanism for private communications between buyer and seller.\n\nThe goal would be to transform this into a BIP, but I think it needs some discussion first. I would appreciate constructive criticism on the proposal. While I\u2019m open to the argument that payment protocols need to be coin-specific, I think at this point it would be more useful to discuss the functionality first.\n\nNothing in this section is really blockchain-specific, and the goal would be to keep it that way, and offer the same functionality to everyone.\n\nI thank anyone who takes the time to read this proposal, and I hope to see good feedback on it.\n\nThank you,\n\nEE\n\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191112/488872fd/attachment.html>"
            },
            {
                "author": "Ben Dewaal",
                "date": "2019-11-13T08:52:19",
                "message_text_only": "I really don't see any merit to this idea.  To keep the reply brief, here's three of the larger problems I see with it:\n\n1. Other schemes will still exist and aren't likely to be deprecated.  All this proposal is doing is adding one /more/ scheme for wallet developers to support.  It doesn't make their lives any easier.\n\n2. Beyond basic payments, these kinds of simple URI scheme aren't going to be enough anyway.  As we build more complex payment systems with more advanced features, we'll find these kinds of schemes less and less suitable as they grow in the number and complexity of attributes we need to include.  It's just not future-proof, even in the short term.\n\n3. I don't see any reasonable way to define the attributes and what developers should do when their software encounters something it doesn't understand.  It'd either be too strict so that no one implements it, or become a nightmare of incompatible and misunderstood implementations that you never trust your wallet is going to interpret how the URI creator intended.\n\nRegards,\nBen\n--"
            },
            {
                "author": "EE",
                "date": "2019-11-13T17:49:05",
                "message_text_only": "Ben,\n\nThank you for your comments. Let me take a stab.\n\n> On 13 Nov 2019, at 10:52 AM, Ben Dewaal <b.dewaal at northernbitcoin.com> wrote:\n> \n> I really don't see any merit to this idea.  To keep the reply brief, here's three of the larger problems I see with it:\n> \n> 1. Other schemes will still exist and aren't likely to be deprecated.  All this proposal is doing is adding one /more/ scheme for wallet developers to support.  It doesn't make their lives any easier.\n\nTo be fully realized, clearly it would be best to have the others depreciated. I would argue almost no existing standard is fully implemented in any wallet. I\u2019m not even sure that BIP-21 is fully implemented \u2013 which wallets include the req- option for example? Most implementations of the Ethereum standards are incomplete, and I haven\u2019t seen anyone implement BUIP-86 for BCH yet (and its creator is working on BSV anyways). BIP-70 was just depreciated by Bitcoin Core, and its future is iffy (perhaps rightly so for having privacy problems). Part of the problem here is that these are under supported, and because they are different, it takes longer for wallet developers to implement. Keeping track of multiple standards is difficult for developers as well. The idea here is to get the major proposed standards (BIP-21, BIP-70-75, ERC-67, EIP-681, EIP-831, BUIP-86, etc. see my background article https://cypherpunk.org/2019/11/02/a-look-at-cryptocurrency-uris/ that goes further into what already exists) to merge into a single standard used by everyone. This helps everyone, and allows efforts to be focused on a single standard. I think it\u2019s a mistake to say that the payment protocol is part of the blockchain and needs to be developed in tandem with it. In almost every way, it is not part of the blockchain, and is a layer above it. This is a chance to step back from what has been done here, take what is good, drop what is not, and move forward with a single protocol. If Bitcoin developers agree, I imagine other blockchain developers will also agree, and a common system can be developed.\n\n> 2. Beyond basic payments, these kinds of simple URI scheme aren't going to be enough anyway.  As we build more complex payment systems with more advanced features, we'll find these kinds of schemes less and less suitable as they grow in the number and complexity of attributes we need to include.  It's just not future-proof, even in the short term.\n\nAs mentioned, this is really the first section of a larger system, the basic payments section. This could be thought of as the basis of the first BIP, and then additional BIPs would be added that are dependent on this one. However, getting this right is key to existing payments that use QR and NFC, and the changes described bring a lot of nice functionality (like being able to ask for payment in one currency based on the value of a second one).\n\n> 3. I don't see any reasonable way to define the attributes and what developers should do when their software encounters something it doesn't understand.  It'd either be too strict so that no one implements it, or become a nightmare of incompatible and misunderstood implementations that you never trust your wallet is going to interpret how the URI creator intended.\n\nI don\u2019t think this is too difficult to define. If there are things that are difficult to interpret, then we can fix them before standardizing. Part of the problem with some of the existing efforts is the sparse standard documents that defined them, leaving things open to interpretation. A well written spec should be able to foresee issues of conflict and design around them.\n\nThere could also be different levels of support for this proposal, like 'pay: simple' that supports single payments, 'pay: multi' that supports multiple payments, etc. I\u2019m not sure it\u2019s necessary to do that, but this kind of break down would allow wallets and payment processors to explain exactly what they support without the current confusion where no one really knows which parts of which standards are supported. As they add support for other sets of features, they could announce the additional support.\n\nThe end-goal would be that wallets and payment systems would fully support this standard, and be able to say something like 'pay:' supported, and perhaps the other sections would be considered add-ons that could also be used. For example, a merchant could have an NFC terminal with a pay: logo on it. Tap your phone and get the pay: URI sent to your phone, to be processed by your wallet. If the section I\u2019m working on that will discuss a private communication method is also supported by the merchant, the logo might show an additional icon to show that support, and the two-way functionality will be supported (allowing you to confirm things interactively). This is the beginning of a process to figure out these issues and develop a plan to address them.\n\n> Regards,\n> Ben\n\nThank you,\n\nEE\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191113/8cf5f4c5/attachment.html>"
            },
            {
                "author": "Ben Dewaal",
                "date": "2019-11-14T12:31:44",
                "message_text_only": "On 13 Nov 2019, at 18:49, EE wrote:\n\n> To be fully realized, clearly it would be best to have the others depreciated.\n\nAnd I'd argue that others won't be deprecated without a strong reason to switch. Bitcoin is an open protocol and no individual gets to dictate \"the right way\".  Just because something makes it in to a draft BIP, it doesn't mean it's going to be agreed or implemented.\n\n>  I would argue almost no existing standard is fully implemented in any wallet.\n\nThis may be the case, but for Bitcoin at least, BIP-21 is relatively well standardised even if not fully implemented by everyone.  That said, I think most wallet developers - including myself and my team - would rather keep things simple until we see a clear way to proceed.  My current expectation is to support BOLT11 with BIP-21 fallback, plus BIP-21 standalone.  We're building a Bitcoin wallet, not a \"cryptocurrency\" wallet, so the complexities and difficulties that are faced by things other than Bitcoin really aren't a concern to me.\n\n> BIP-70 was just depreciated by Bitcoin Core\n\nJust to nitpick: BIP-70 was just deprecated *in* Bitcoin Core.  Again, see above where no individual gets to dictate those sorts of things.\n\n> Part of the problem here is that these are under supported, and because they are different, it takes longer for wallet developers to implement.\n\nThis works on the assumption of people building cryptocurrency wallets rather than Bitcoin wallets.  I reject the idea that that basic assumption has any merit to it since in practical terms I see no push towards adoption of anything other than Bitcoin, and in theoretical terms, I see no way that anything other than Bitcoin will continue to exist over the mid to long term.  Spending effort to add standards to Bitcoin that bring no benefit to Bitcoin simply seems like a waste of time.\n\n> I think it\u2019s a mistake to say that the payment protocol is part of the blockchain and needs to be developed in tandem with it. In almost every way, it is not part of the blockchain, and is a layer above it.\n\nHere, we agree.  Payments are indeed separate to the underlying technology.  The Lightning Network is a payment network and can be used with other blockchains (assuming you're willing to trust their fundamentally flawed security models).  With this in mind, why define a new standard when those other projects could just start using Lightning and take advantage of its invoice standard?\n\n> the changes described bring a lot of nice functionality (like being able to ask for payment in one currency based on the value of a second one).\n\nI don't understand the value of this.  Right now, I use Bitcoin exclusively, but goods are services around me are (usually) priced in euro.  The merchant will quote a price in euro and their system will ask me to pay in Bitcoin.  My wallet will then display this to me with an equivalent euro value.  It may differ slightly due to different exchange rate providers being called, but I am clear on what I need to pay and have an idea of whether it accords to the listed price of the item.\nIf however as you suggest, the merchant were to provide a payment request for \u20ac5.00 in BTC, then they'd be reliant on my exchange rate provider to pay them.  What if they don't accept what my wallet then says?  It's adding confusion and complexity where that's neither needed nor wanted.  The current behaviour is superior to that.\n\n> I don\u2019t think this is too difficult to define.\n> A well written spec should be able to foresee issues of conflict and design around them.\n\nI don't have that level of optimism.  You're talking about a very broad array of different systems each with their own unique features, metadata, and expected two-way communication steps.  It feels to me like you're trying to shoehorn too much in to one thing and would end up with the worst of all possible worlds as the result.\n\nI'm sorry for the quite negative-sounding answer here, but as my team is in the process of building a wallet, I'm strongly against proposals that - if adopted - would add complexity to our work without any obvious benefits to us.  I feel like Lightning invoices and the current discussions around enhancements and improvements in them are more than sufficient to cover our needs for the foreseeable future and beyond that I'd prefer solutions built on top of that than something built with complexity that I see as entirely unnecessary.\n\nRegards,\nBen\n--"
            }
        ],
        "thread_summary": {
            "title": "Towards a singular payment protocol",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ee at cypherpunk.org",
                "Ben Dewaal",
                "EE"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 12822
        }
    },
    {
        "title": "[bitcoin-dev] PSBT_GLOBAL_XPUB: Version bytes in xpub",
        "thread_messages": [
            {
                "author": "Ian Kroozbi",
                "date": "2019-11-15T22:29:01",
                "message_text_only": "What\u2019s the rational for including the version bytes in the xpub in the\nGLOBAL_XPUB field? This was briefly touched upon in an earlier email from\nStepan, but I don\u2019t think it was every fully addressed.\n\nI am not sure if we need the whole xpub or keeping chain_code and\n> public_key is enough, but I would suggest to keep other data\n> just in case. For example, keeping prefix that defines if the key is used\n> for testnet or mainnet may be useful.\n>\n\nThe version bytes seem to be superfluous data considering the transaction\nformat and the rest of the PSBT key-values are network agnostic. If we\nwanted to attach network data to the PSBT then I think that would be better\nserved by using a new key.\n\nThere is also a potential issue where we could have conflicting versions on\ndifferent xpubs in the PSBT. If we remove the version bytes then we can\neliminate this possibility.\n\nI haven\u2019t formed an opinion on whether or not the other data outside of the\npublic key and chain code should be included, but I think it would be good\nto discuss any rational for either including it or omitting it.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191115/b63c95c8/attachment.html>"
            },
            {
                "author": "Andrew Chow",
                "date": "2019-11-16T04:54:49",
                "message_text_only": "The rationale was that xpubs was already a predefined standard which many software already have serialization code for. It's simpler to just reuse what has been defined before.\n\nIMO, the version bytes don't matter and should be ignored. In the proposed implementation to Bitcoin Core, the version bytes are ignored.\n\nAndrew\n\nOn 11/15/19 5:29 PM, Ian Kroozbi via bitcoin-dev wrote:\n\n> What\u2019s the rational for including the version bytes in the xpub in the GLOBAL_XPUB field? This was briefly touched upon in an earlier email from Stepan, but I don\u2019t think it was every fully addressed.\n>\n>> I am not sure if we need the whole xpub or keeping chain_code and\n>> public_key is enough, but I would suggest to keep other data\n>> just in case. For example, keeping prefix that defines if the key is used\n>> for testnet or mainnet may be useful.\n>\n> The version bytes seem to be superfluous data considering the transaction format and the rest of the PSBT key-values are network agnostic. If we wanted to attach network data to the PSBT then I think that would be better served by using a new key.\n>\n> There is also a potential issue where we could have conflicting versions on different xpubs in the PSBT. If we remove the version bytes then we can eliminate this possibility.\n>\n> I haven\u2019t formed an opinion on whether or not the other data outside of the public key and chain code should be included, but I think it would be good to discuss any rational for either including it or omitting it.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191116/7cfb25e7/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "PSBT_GLOBAL_XPUB: Version bytes in xpub",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Andrew Chow",
                "Ian Kroozbi"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2944
        }
    },
    {
        "title": "[bitcoin-dev] v3 onion services",
        "thread_messages": [
            {
                "author": "Mr. Lee Chiffre",
                "date": "2019-11-17T04:33:31",
                "message_text_only": "Right now bitcoin client core supports use of tor hidden service. It\nsupports v2 hidden service. I am in progress of creating a new bitcoin\nnode which will use v3 hidden service instead of v2. I am looking at\nbitcoin core and btcd to use. Do any of these or current node software\nsupport the v3 onion addresses for the node address? What about I2P\naddresses? If not what will it take to get it to support the longer\naddresses that is used by i2p and tor v3?\n\n\n-- \nlee.chiffre at secmail.pro\nPGP 97F0C3AE985A191DA0556BCAA82529E2025BDE35"
            },
            {
                "author": "s7r",
                "date": "2019-11-17T15:35:16",
                "message_text_only": "Mr. Lee Chiffre via bitcoin-dev wrote:\n> Right now bitcoin client core supports use of tor hidden service. It\n> supports v2 hidden service. I am in progress of creating a new bitcoin\n> node which will use v3 hidden service instead of v2. I am looking at\n> bitcoin core and btcd to use. Do any of these or current node software\n> support the v3 onion addresses for the node address? What about I2P\n> addresses? If not what will it take to get it to support the longer\n> addresses that is used by i2p and tor v3?\n> \n> \n\nHello,\n\nYes, that is correct. Currently at present moment only v2 onion services\nare supported. Bitcoin Core is limited at 128 bit 'addresses' in the p2p\nprotocol, so it requires a rework of the p2p protocol. v3 onion services\nare whole ed25519 public keys, base32 encoded with .onion at the end.\n\nSame reason applies to I2P 'address types' as well. However, I am not an\nexpert in I2P and don't actually know how many bitcoin full nodes might\nexist in I2P.\n\nSee:\nhttps://github.com/bitcoin/bitcoin/issues/9214\n\nhttps://github.com/bitcoin/bitcoin/issues/2091\n\n\nFor the default `ADD_ONION` feature, the onion service key was\ndowngraded to explicitly RSA1024 (legacy, v2 onion services) to ensure\nthe feature still works out of the box:\n\nhttps://github.com/bitcoin/bitcoin/pull/9234\n\nIf you want a Tor only full node, you are best to use v2 onion services\nfor now. Why do you need the bitcoin node to explicitly have a v3 onion\naddress? You can have a service that is accessible to the general public\nas a v3 onion service, and in the back uses a bitcoin full node that\nuses v2 onion service to talk to other nodes. The v2 onion service\nbitcoin network is extended fairly.\n\nYou can use in the same torrc (Tor configuration file), implicitly same\nTor process/daemon simultaneously v2 and v3 onion services by setting\nHiddenServiceVersion parameter after every HiddenServiceDir parameter.\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191117/5a13ed1e/attachment.sig>"
            },
            {
                "author": "LORD HIS EXCELLENCY JAMES HRMH",
                "date": "2019-11-17T20:04:04",
                "message_text_only": "For those perhaps not so well versed in the operation of Bitcoin (and Bitcoin Core) with Tor, connectivity through the outgoing connection to other nodes is all accomplished via the socks5 proxy which enables all current gossip and the distribution of the nodes own transactions to other nodes. This is a full connectivity feature.\n\nFor listening, Bitcoin Core instructs Tor to create an ephemeral hidden service which, depending on the various factors, may be currently v2 only or v3 (future implementation). This is not necessary for the functionality of node connectivity in any way and is only used to allow for hidden listening so that other nodes connecting out on the onion can connect privately without hopping on the public internet at all and without exposing the nodes public IP or ports as listening (no port forwarding required and no listing on nodes list with public IP). It is currently possible for many nodes to exist as onion only nodes.\n\nFor the time being, although I did wonder myself, the use of v3 ephemeral service is not a requirement of operation on Bitcoin and hardly adds anything to security especially if we enable transient onion listening (a feature proposal is currently waiting for consideration/approval on bitcoin-core-dev and GitHub), however, eventually it will be essential to make use of the v3 ephemeral service as the v2 service support will, as I understand, eventually be dropped from the Tor network. I do not know if there are any current distinct plans.\n\nMy opinion is, v3 support is a nice idea but hardly urgent yet. Good luck if it ends up with an ack as I suspect some of the changes required will be complex and this may be perhaps the best reason to begin on it while there is interest.\n\nRegards,\nLORD HIS EXCELLENCY JAMES HRMH\n\n________________________________\nFrom: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of s7r via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nSent: Monday, 18 November 2019 2:35 AM\nTo: Mr. Lee Chiffre <lee.chiffre at secmail.pro>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>\nSubject: Re: [bitcoin-dev] v3 onion services\n\nMr. Lee Chiffre via bitcoin-dev wrote:\n> Right now bitcoin client core supports use of tor hidden service. It\n> supports v2 hidden service. I am in progress of creating a new bitcoin\n> node which will use v3 hidden service instead of v2. I am looking at\n> bitcoin core and btcd to use. Do any of these or current node software\n> support the v3 onion addresses for the node address? What about I2P\n> addresses? If not what will it take to get it to support the longer\n> addresses that is used by i2p and tor v3?\n>\n>\n\nHello,\n\nYes, that is correct. Currently at present moment only v2 onion services\nare supported. Bitcoin Core is limited at 128 bit 'addresses' in the p2p\nprotocol, so it requires a rework of the p2p protocol. v3 onion services\nare whole ed25519 public keys, base32 encoded with .onion at the end.\n\nSame reason applies to I2P 'address types' as well. However, I am not an\nexpert in I2P and don't actually know how many bitcoin full nodes might\nexist in I2P.\n\nSee:\nhttps://github.com/bitcoin/bitcoin/issues/9214\n\nhttps://github.com/bitcoin/bitcoin/issues/2091\n\n\nFor the default `ADD_ONION` feature, the onion service key was\ndowngraded to explicitly RSA1024 (legacy, v2 onion services) to ensure\nthe feature still works out of the box:\n\nhttps://github.com/bitcoin/bitcoin/pull/9234\n\nIf you want a Tor only full node, you are best to use v2 onion services\nfor now. Why do you need the bitcoin node to explicitly have a v3 onion\naddress? You can have a service that is accessible to the general public\nas a v3 onion service, and in the back uses a bitcoin full node that\nuses v2 onion service to talk to other nodes. The v2 onion service\nbitcoin network is extended fairly.\n\nYou can use in the same torrc (Tor configuration file), implicitly same\nTor process/daemon simultaneously v2 and v3 onion services by setting\nHiddenServiceVersion parameter after every HiddenServiceDir parameter.\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191117/d4a1d20f/attachment.html>"
            },
            {
                "author": "Christopher Allen",
                "date": "2019-11-17T23:01:23",
                "message_text_only": "Blockchain Commons is using v3 tor authentication for remote clients\ncontrolling a full node created using our Bitcoin Standup project\n(currently only macOS but more platforms coming):\nhttps://github.com/BlockchainCommons/Bitcoin-Standup\n\nDocs at:\nhttps://github.com/BlockchainCommons/Bitcoin-Standup#tor-v3-authentication-using-standup-and-fullynoded\n\n\nVideo demonstrating securing remote connection of a full node to the iOS\nwallet Fully Noded: https://youtu.be/pSm2VftTCBI\n\nMore details on v3 authentication at:\nhttps://github.com/AnarchoTechNYC/meta/wiki/Connecting-to-an-authenticated-Onion-service#connecting-to-authenticated-version-3-onion-services\n\n\u2014 Christopher Allen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191117/bcf562f0/attachment-0001.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2019-11-17T23:42:03",
                "message_text_only": "There is effort ongoing to upgrade the Bitcoin P2P protocol to support other address types, including onion v3. There are various posts on this ML under the title \u201caddrv2\u201d. Further review and contributions to that effort is, as always, welcome.\n\n> On Nov 17, 2019, at 00:05, Mr. Lee Chiffre via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \ufeffRight now bitcoin client core supports use of tor hidden service. It\n> supports v2 hidden service. I am in progress of creating a new bitcoin\n> node which will use v3 hidden service instead of v2. I am looking at\n> bitcoin core and btcd to use. Do any of these or current node software\n> support the v3 onion addresses for the node address? What about I2P\n> addresses? If not what will it take to get it to support the longer\n> addresses that is used by i2p and tor v3?\n> \n> \n> -- \n> lee.chiffre at secmail.pro\n> PGP 97F0C3AE985A191DA0556BCAA82529E2025BDE35\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2019-11-18T11:59:03",
                "message_text_only": "As I briefly sketched here before I think that a better long term\nsolution would be to link the bitcoin traffic with something like\nnode-Tor (https://github.com/Ayms/node-Tor)\n\nMuch more light (the whole code not minified is only ~1MB), not using\ntons of libraries prone to security/maintenance issues, easy to\nuse/configure/maintain and you don't need the (heavy/complicate) onions\nRDV concepts and addresses, which in addition is useless for bitcoin\n\nAs simple as a duplex stream *bitcoin.pipe(node-Tor)* inside servers or\nbrowsers (difficult to imagine full nodes and the blocks inside browsers\nbut why not one day, so for light clients probably implementing part of\nthe bitcoin protocol like https://peersm.com/wallet, for now it's a\nstandalone offline webapp but of course it would be interesting to\nconnect it in a secure way to bitcoin nodes to retrieve info from the\nutxo set and send txs for example since it's not obvious for users to\ncreate their txs in its current form)\n\nThis would be a separate network using the Tor protocol over TCP,\nWebSockets and WebRTC, making it possible also for browsers to relay the\ntraffic, probably the nodes discovery (to get the keys) could be linked\nto the bitcoin peer discovery system (we just have to add the onion key\nto the peer profile, and maybe long term id key), anyway that's simple\nto setup, and probably for a p2p network 2 hops will be enough\n\nI really don't think that the Tor network is designed and adapted to\nsupport bitcoin nodes, using it for something else than browsing is just\na workaround and I would be surprised that the Tor project team\ncontradicts this and/or encourage this use\n\nLe 18/11/2019 \u00e0 00:42, Matt Corallo via bitcoin-dev a \u00e9crit\u00a0:\n> There is effort ongoing to upgrade the Bitcoin P2P protocol to support other address types, including onion v3. There are various posts on this ML under the title \u201caddrv2\u201d. Further review and contributions to that effort is, as always, welcome.\n>\n>> On Nov 17, 2019, at 00:05, Mr. Lee Chiffre via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> \ufeffRight now bitcoin client core supports use of tor hidden service. It\n>> supports v2 hidden service. I am in progress of creating a new bitcoin\n>> node which will use v3 hidden service instead of v2. I am looking at\n>> bitcoin core and btcd to use. Do any of these or current node software\n>> support the v3 onion addresses for the node address? What about I2P\n>> addresses? If not what will it take to get it to support the longer\n>> addresses that is used by i2p and tor v3?\n>>\n>>\n>> -- \n>> lee.chiffre at secmail.pro\n>> PGP 97F0C3AE985A191DA0556BCAA82529E2025BDE35\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191118/d8a62908/attachment.html>"
            },
            {
                "author": "LORD HIS EXCELLENCY JAMES HRMH",
                "date": "2019-11-18T12:34:49",
                "message_text_only": "The Tor team encourages active participating Tor nodes, preferably exit/ middle/guard nodes and not only client nodes, which is actually a significant part of the reason that the documentation I put together in Bitcoin.SE does not deal much with configuration tweaking Tor; as out of the box Tor participates actively in the Tor network.\n\nAs for applications other than web browsing, i is simply not true to suggest that Tor is implemented solely for web browsing and I suppose that this view has come about because of the Tor browser, an attempt to engage more active Tor nodes while providing an OOB privacy solution to simplify setup for the not-so-technical. As just one example of other uses, you will note the Tor configuration item `LongLivedPorts` and its implications. No, it is completely not necessary to tweak this option for Bitcoin although you may.\n\nI encourage you to forward these comments to the Tor mailing list.\n\n>I really don't think that the Tor network is designed and adapted to support bitcoin nodes, using it for something else than browsing is just a workaround and I would be surprised that the Tor project team contradicts this and/or encourage this use\n\nRegards,\nLORD HIS EXCELLENCY JAMES HRMH\n\n________________________________\nFrom: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Aymeric Vitte via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nSent: Monday, 18 November 2019 10:59 PM\nTo: Matt Corallo <lf-lists at mattcorallo.com>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>; Mr. Lee Chiffre <lee.chiffre at secmail.pro>\nCc: fontainedenton at googlemail.com <fontainedenton at googlemail.com>\nSubject: Re: [bitcoin-dev] v3 onion services\n\n\nAs I briefly sketched here before I think that a better long term solution would be to link the bitcoin traffic with something like node-Tor (https://github.com/Ayms/node-Tor)\n\nMuch more light (the whole code not minified is only ~1MB), not using tons of libraries prone to security/maintenance issues, easy to use/configure/maintain and you don't need the (heavy/complicate) onions RDV concepts and addresses, which in addition is useless for bitcoin\n\nAs simple as a duplex stream bitcoin.pipe(node-Tor) inside servers or browsers (difficult to imagine full nodes and the blocks inside browsers but why not one day, so for light clients probably implementing part of the bitcoin protocol like https://peersm.com/wallet, for now it's a standalone offline webapp but of course it would be interesting to connect it in a secure way to bitcoin nodes to retrieve info from the utxo set and send txs for example since it's not obvious for users to create their txs in its current form)\n\nThis would be a separate network using the Tor protocol over TCP, WebSockets and WebRTC, making it possible also for browsers to relay the traffic, probably the nodes discovery (to get the keys) could be linked to the bitcoin peer discovery system (we just have to add the onion key to the peer profile, and maybe long term id key), anyway that's simple to setup, and probably for a p2p network 2 hops will be enough\n\nI really don't think that the Tor network is designed and adapted to support bitcoin nodes, using it for something else than browsing is just a workaround and I would be surprised that the Tor project team contradicts this and/or encourage this use\n\nLe 18/11/2019 \u00e0 00:42, Matt Corallo via bitcoin-dev a \u00e9crit :\n\nThere is effort ongoing to upgrade the Bitcoin P2P protocol to support other address types, including onion v3. There are various posts on this ML under the title \u201caddrv2\u201d. Further review and contributions to that effort is, as always, welcome.\n\n\n\nOn Nov 17, 2019, at 00:05, Mr. Lee Chiffre via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org><mailto:bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n\ufeffRight now bitcoin client core supports use of tor hidden service. It\nsupports v2 hidden service. I am in progress of creating a new bitcoin\nnode which will use v3 hidden service instead of v2. I am looking at\nbitcoin core and btcd to use. Do any of these or current node software\nsupport the v3 onion addresses for the node address? What about I2P\naddresses? If not what will it take to get it to support the longer\naddresses that is used by i2p and tor v3?\n\n\n--\nlee.chiffre at secmail.pro<mailto:lee.chiffre at secmail.pro>\nPGP 97F0C3AE985A191DA0556BCAA82529E2025BDE35\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191118/c266cf38/attachment.html>"
            },
            {
                "author": "Carl Dong",
                "date": "2019-11-18T16:44:00",
                "message_text_only": "Hi Mr. Lee Chiffre,\n\nI have been working on an implementation of addrv2 (BIP-155). Is this what you meant by I2P and Torv3 address support?\n\nMy WIP pull request: https://github.com/bitcoin/bitcoin/pull/16748\nMerged BIP: https://github.com/bitcoin/bips/blob/master/bip-0155.mediawiki\nOngoing discussion: https://github.com/bitcoin/bips/pull/766\nNote: Even though the pull request to the BIP repo is merged, we\u2019re still discussing some details in the pull request thread and will amend the BIP once it seems like we\u2019ve worked out all the kinks\n\nReview and further discussion is very much welcome! :-)\n\nCheers,\nCarl Dong\ncontact at carldong.me\n\"I fight for the users\"\n\n> On Nov 16, 2019, at 11:33 PM, Mr. Lee Chiffre via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \n> Right now bitcoin client core supports use of tor hidden service. It\n> supports v2 hidden service. I am in progress of creating a new bitcoin\n> node which will use v3 hidden service instead of v2. I am looking at\n> bitcoin core and btcd to use. Do any of these or current node software\n> support the v3 onion addresses for the node address? What about I2P\n> addresses? If not what will it take to get it to support the longer\n> addresses that is used by i2p and tor v3?\n> \n> \n> --\n> lee.chiffre at secmail.pro\n> PGP 97F0C3AE985A191DA0556BCAA82529E2025BDE35\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2019-11-18T22:19:23",
                "message_text_only": "So I must ask the question: what is the rational for a bitcoin node to\nbe hidden? ie to use RDV points like hidden services?\n\nFor me the rational for bitcoin is to anonymize communications between\nnodes and/or clients, typically who sent this tx, not to hide that you\nare operating a bitcoin node, then back to what I sent earlier\n\nI tried to find the explaination in the bitcoin docs before sending this\npost but did not find any, except referring to the fact that bitcoin\ncommunications should be anonymized, which does not need RDV points\n\nAnother question is why to mimic the Tor network for RDV points with\n.onion addresses?\n\nThe answers might be \"this is what exists and we have no other way to do\nit\", I am proposing another way\n\nI will not repeat what I wrote before, but I am operating node-Tor nodes\ninside the Tor network since ~10 years, the js implementation of the Tor\nprotocol had not been easy (as well as putting everything inside\nbrowsers) but I consider that the most difficult had been to handle all\nunexpected events that happen inside the Tor network, even after\nselecting carefully the nodes and testing them, this is a mess, nodes\nare coming in, going out, responding, not responding, responding\ncorrecltly or all of a sudden responding shxtty stuff, I was even\nconsidering to get the entropy for the js prng from all of those\nunexpected events\n\nI don't think that any other people except the Tor project team know\nthis, a good example is http://peersm.com/peersm2, see the logs (destroy\nand destroy and destroy) and how long it takes to establish 6 circuits\nknowing that our server is the first one in the path (eliminating one\ndubious node among 3)\n\nI am not \"promoting\" this, everything is open source now and it is made\nto be used, and I think that my proposal has some interest, using the\nTor network for bitcoin is a very bad idea, for security and\nperformances reasons\n\nLe 18/11/2019 \u00e0 17:44, Carl Dong via bitcoin-dev a \u00e9crit\u00a0:\n> Hi Mr. Lee Chiffre,\n>\n> I have been working on an implementation of addrv2 (BIP-155). Is this what you meant by I2P and Torv3 address support?\n>\n> My WIP pull request: https://github.com/bitcoin/bitcoin/pull/16748\n> Merged BIP: https://github.com/bitcoin/bips/blob/master/bip-0155.mediawiki\n> Ongoing discussion: https://github.com/bitcoin/bips/pull/766\n> Note: Even though the pull request to the BIP repo is merged, we\u2019re still discussing some details in the pull request thread and will amend the BIP once it seems like we\u2019ve worked out all the kinks\n>\n> Review and further discussion is very much welcome! :-)\n>\n> Cheers,\n> Carl Dong\n> contact at carldong.me\n> \"I fight for the users\"\n>\n>> On Nov 16, 2019, at 11:33 PM, Mr. Lee Chiffre via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>\n>> Right now bitcoin client core supports use of tor hidden service. It\n>> supports v2 hidden service. I am in progress of creating a new bitcoin\n>> node which will use v3 hidden service instead of v2. I am looking at\n>> bitcoin core and btcd to use. Do any of these or current node software\n>> support the v3 onion addresses for the node address? What about I2P\n>> addresses? If not what will it take to get it to support the longer\n>> addresses that is used by i2p and tor v3?\n>>\n>>\n>> --\n>> lee.chiffre at secmail.pro\n>> PGP 97F0C3AE985A191DA0556BCAA82529E2025BDE35\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms"
            }
        ],
        "thread_summary": {
            "title": "v3 onion services",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Christopher Allen",
                "LORD HIS EXCELLENCY JAMES HRMH",
                "Carl Dong",
                "s7r",
                "Aymeric Vitte",
                "Matt Corallo",
                "Mr. Lee Chiffre"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 23132
        }
    },
    {
        "title": "[bitcoin-dev] CVE-2018-20586 disclosure (log injection vulnerability)",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2019-11-22T17:13:14",
                "message_text_only": "CVE-2018-20586 is a log injection vulnerability which allows any software with \naccess to the RPC port to create fake or confusing entries in the debug log. \nValid authentication (username/password/cookie) for the RPC service is NOT \nrequired to exploit this vulnerability, only the ability to connect to the \nRPC port (which is by default only exposed to the local machine).\n\nThe vulnerability was introduced in 40b556d3742a1f65d67e2d4c760d0b13fe8be5b7 \n(\"libevent-based http server\") and first released in Bitcoin Core v0.12.0rc1 \nin 2016 Jan 13. A fix was hidden in 79358817e53ac0a7afa64c747115d492a74e3155 \n(\"rpc: Make HTTP RPC debug logging more informative\") released in v0.17.1, \n2018 Dec 22.\n\nTo be vulnerable, the malicious software must either be running on the same \nmachine as the node, have the ability to proxy connections to the node via \nthe local machine, or the node must be configured to accept RPC connections \nfrom a network via which the attacker can connect. Additionally, a human user \nmust read the debug log and act on or otherwise believe the injected data, in \na way that is somehow harmful.\n\nBecause the node would log the arbitrary POST request from any connection, an \nattacker can add nearly any content to the request to inject it into the log. \nTo ensure their entire request is injected, standard spaces would need to be \nreplaced with alternative whitespace characters, and newlines would need to \nbecome other control characters (such as \"\\r\\v\"). Because the injected data \nmust use such non-standard characters, it is most likely to not fool other \nsoftware parsing the debug log, and only a human visually reading it.\n\nTo fix this vulnerability, POST requests are now sanitised before being \nlogged, removing all characters that shouldn't be in an ordinary POST \nrequest.\n\nCredit goes to practicalswift (https://twitter.com/practicalswift) for \ndiscovering and fixing the vulnerability.\n\nTimeline:\n- 2015-01-18: Vulnerability introduced in PR #5677.\n- 2015-09-04: Vulnerability merged to master git repository.\n- 2016-01-13: Vulnerability published in v0.12.0rc1.\n- 2016-02-18: Vulnerability released in v0.12.0.\n...\n- 2018-10-25: practicalswift discloses vulnerability to security team.\n- 2018-10-31: practicalswift opens PR #14618 to quietly fix vulnerability.\n- 2018-11-05: Fix merged to master git repository.\n- 2018-11-30: Fix merged to 0.17 git repository.\n- 2018-12-07: Fix published in v0.17.1rc1.\n- 2018-12-22: Fix released in v0.17.1.\n...\n- 2019-06-22: Vulnerability existence disclosed to bitcoin-dev ML.\n- 2019-11-22: Vulnerability details disclosure to bitcoin-dev ML."
            }
        ],
        "thread_summary": {
            "title": "CVE-2018-20586 disclosure (log injection vulnerability)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Luke Dashjr"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2620
        }
    },
    {
        "title": "[bitcoin-dev] I want to rebuild the GUI in JavaScript",
        "thread_messages": [
            {
                "author": "M.K. Safi",
                "date": "2019-11-23T06:45:02",
                "message_text_only": "I\u2019d like to try to rebuild Bitcoin Core GUI using the JavaScript Electron\nframework. My goal is to get a real world understanding of the pros and\ncons of moving from Qt to Electron.\n\nBefore I start, I\u2018d like to know if this has been tried before or if there\nare ongoing efforts in this direction by anyone?\n\nI spent sometime looking into how to implement this. One approach could be\nfor Electron to drive the UI by running bitcoind and communicating with it\nthrough RPC. But I don\u2019t know if such implementation can achieve\nfeature-parity with the Qt implementation. Qt has the advantage of direct\naccess to Bitcoin Core code.\n\nAnyways, I just wanted to share these ideas before going further with them,\nso please let me know if you have any information on the above!\n-- \nSent from my iPhone\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191122/e28e30c4/attachment.html>"
            },
            {
                "author": "Oscar Lafarga",
                "date": "2019-11-23T16:49:18",
                "message_text_only": "Hi MK,\n\nI very much share your interests and curiosities here and actually don't\nhave an answer on whether it's been tried before.\n\nOne of the few things I am imagining is that given the security-focused\nnature of the Bitcoin Core software, any vulnerabilities in the way NPM\nhandles the dependencies of the Electron app would be a very high priority\n(see https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/)\n\nIn NodeJS-land, my sense is that there is a \"move fast and break things\"\nmentality that may have seeped into some practices that may be considered\nstandard. I have seen some recent developments over the past few years to\naddress these kinds of issues such as npm-audit (as of Node v6+) but I\nwould recommend doing some thorough research on this front to make sure\nthere is a secure dependency management solution in place for such a GUI.\n\nAnother comment I'd make is that if we consider the GUI as a layer that is\nseparate from the protocol layer, this mailing list may not be the best\nplace to fully discuss this. However I think if anyone here who has been\naround longer can contribute info on past attempts at this, it could be\nquite productive. This could technically exist as an independent client,\nbut I guess there's a conversation on whether this new Electron UI would\never replace the Qt UI, but since it doesn't exist yet it could be far too\nearly for that.\n\nThanks,\n\n\n\n\n\n\nOn Sat, Nov 23, 2019, 2:17 PM M.K. Safi via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I\u2019d like to try to rebuild Bitcoin Core GUI using the JavaScript Electron\n> framework. My goal is to get a real world understanding of the pros and\n> cons of moving from Qt to Electron.\n>\n> Before I start, I\u2018d like to know if this has been tried before or if there\n> are ongoing efforts in this direction by anyone?\n>\n> I spent sometime looking into how to implement this. One approach could be\n> for Electron to drive the UI by running bitcoind and communicating with it\n> through RPC. But I don\u2019t know if such implementation can achieve\n> feature-parity with the Qt implementation. Qt has the advantage of direct\n> access to Bitcoin Core code.\n>\n> Anyways, I just wanted to share these ideas before going further with\n> them, so please let me know if you have any information on the above!\n> --\n> Sent from my iPhone\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191123/9e503a84/attachment-0001.html>"
            },
            {
                "author": "Daniel Edgecumbe",
                "date": "2019-11-23T20:07:17",
                "message_text_only": "You may find my (incomplete) front-end of interest:\n\nhttps://bitcoin.electronrelocation.com\n\nThe live demo is backed by a -disablewallet node, but it was able to accept payments and send them via QR codes before I stopped development.\n\nThe source is available via AGPLv3.\n\nhttps://git.esotericnonsense.com/pub/bitcoin-top.git\n\nI am unable to continue development due to time constraints.\n\nDaniel Edgecumbe | esotericnonsense\nemail at esotericnonsense.com | https://esotericnonsense.com\n\nOn Sat, Nov 23, 2019, at 17:49, Oscar Lafarga via bitcoin-dev wrote:\n> Hi MK,\n> \n> I very much share your interests and curiosities here and actually \n> don't have an answer on whether it's been tried before.\n> \n> One of the few things I am imagining is that given the security-focused \n> nature of the Bitcoin Core software, any vulnerabilities in the way NPM \n> handles the dependencies of the Electron app would be a very high \n> priority (see \n> https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/) \n> \n> In NodeJS-land, my sense is that there is a \"move fast and break \n> things\" mentality that may have seeped into some practices that may be \n> considered standard. I have seen some recent developments over the past \n> few years to address these kinds of issues such as npm-audit (as of \n> Node v6+) but I would recommend doing some thorough research on this \n> front to make sure there is a secure dependency management solution in \n> place for such a GUI.\n> \n> Another comment I'd make is that if we consider the GUI as a layer that \n> is separate from the protocol layer, this mailing list may not be the \n> best place to fully discuss this. However I think if anyone here who \n> has been around longer can contribute info on past attempts at this, it \n> could be quite productive. This could technically exist as an \n> independent client, but I guess there's a conversation on whether this \n> new Electron UI would ever replace the Qt UI, but since it doesn't \n> exist yet it could be far too early for that. \n> \n> Thanks,\n> \n> \n> \n> \n> \n> \n> On Sat, Nov 23, 2019, 2:17 PM M.K. Safi via bitcoin-dev \n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > I\u2019d like to try to rebuild Bitcoin Core GUI using the JavaScript Electron framework. My goal is to get a real world understanding of the pros and cons of moving from Qt to Electron.\n> > \n> > Before I start, I\u2018d like to know if this has been tried before or if there are ongoing efforts in this direction by anyone?\n> > \n> > I spent sometime looking into how to implement this. One approach could be for Electron to drive the UI by running bitcoind and communicating with it through RPC. But I don\u2019t know if such implementation can achieve feature-parity with the Qt implementation. Qt has the advantage of direct access to Bitcoin Core code.\n> > \n> > Anyways, I just wanted to share these ideas before going further with them, so please let me know if you have any information on the above!\n> > -- \n> > Sent from my iPhone\n> >  _______________________________________________\n> >  bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2019-11-23T18:27:47",
                "message_text_only": "Hi\n\nThis is probably the wrong place to discuss that (OT).\n\n> I\u2019d like to try to rebuild Bitcoin Core GUI using the JavaScript Electron framework. My goal is to get a real world understanding of the pros and cons of moving from Qt to Electron.\n\nThere is a relatively new Bitcoin Core Github issue that covers that topic [1].\nAFAIK many Bitcoin Core contributors (and users?) don\u2019t like the idea of having a Browser and JavaScript to achieve a UI with relatively simple user-stories.\n\nI think if you want to do this, try to work on a third party project and let your Electron UI connect to Bitcoin Core over RPC.\nTo avoid pulling, eventually use ZMQ or help getting long polling into Bitcoin Core [2].\n\nAdding a Electron/JavaScript UI to the Bitcoin Core repository is very unlikely to happen.\n\n[1] https://github.com/bitcoin/bitcoin/issues/17395\n[2] https://github.com/bitcoin/bitcoin/pull/7949\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191123/2ef48e0b/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "I want to rebuild the GUI in JavaScript",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Oscar Lafarga",
                "Daniel Edgecumbe",
                "Jonas Schnelli",
                "M.K. Safi"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 8226
        }
    },
    {
        "title": "[bitcoin-dev] Composable MuSig",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2019-11-25T11:00:22",
                "message_text_only": "So I heard you like MuSig.\n\n\nIntroduction\n============\n\nPreviously on lightning-dev, I propose Lightning Nodelets, wherein one signatory of a channel is in fact not a single entity, but instead an aggregate: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002236.html\n\nGeneralizing:\n\n* There exists some protocol that requires multiple participants agreeing.\n  * This can be implemented by use of MuSig on the public keys of the participants.\n* One or more of the participants in the above protocol is in fact an aggregate, not a single participant.\n  * Ideally, no protocol modification should be needed to support such aggregates, \"only\" software development without modifying the protocol layer.\n  * Obviously, any participant of such a protocol, whether a direct participant, or a member of an aggregated participant of that protocol, would want to retain control of its own money in that protocol, without having to determine if it is being Sybilled (and all other participants are in fact just one participant).\n  * Motivating example: a Lightning Network channel is the aggregate of two participants, the nodes creating that channel.\n    However, with nodelets as proposed above, one of the participants is actually itself an aggregate of multiple nodelets.\n    * This requires that a Lightning Network channel with a MuSig address, to have one or both participants, be potentially an aggregate of two or more nodelet participants, e.g. `MuSig(MuSig(A, B), C)`\n\nThis is the \"MuSig composition\" problem.\nThat is, given `MuSig(MuSig(A, B), C)`, and the *possibility* that in fact `B == C`, what protocol can A use to ensure that it uses the three-phase MuSig protocol (which has a proof of soundness) and not inadvertently use a two-phase MuSig protocol?\n\nSchnorr Signatures\n==================\n\nThe scheme is as follows.\n\nSuppose an entity A needs to show a signature.\nAt setup:\n\n* It generates a random scalar `a`.\n* It computes `A` as `A = a * G`, where `G` is the standard generator point.\n* It publishes `A`.\n\nAt signing a message `m`:\n\n* It generates a random scalar `r`.\n* It computes `R` as `R = r * G`.\n* It computes `e` as `h(R | m)`, where `h()` is a standard hash function and `x | y` denotes the serialization of `x` concatenated by the serialization of `y`.\n* It computes `s` as `s = r + e * a`.\n* It publishes as signature the tuple of `(R, s)`.\n\nAn independent validator can then get `A`, `m`, and the signature `(R, s)`.\nAt validation:\n\n* It recovers `e[validator]` as so: `e[validator] = h(R | m)`\n* It computes `S[validator]` as so: `S[validator] = R + e[validator] * A`.\n* It checks if `s * G == S[validator]`.\n  * If `R` and `s` were indeed generated as per signing algorithm above, then:\n    * `S[validator] = R + e[validator] * A`\n    * `== r * G + e[validator] * A`; subbstitution of `R`\n    * `== r * G + h(R | m) * A`; substitution of `e[validator]`\n    * `== r * G + h(R | m) * a * G`; substitution of `A`.\n    * `== (r + h(R | m) * a) * G`; factor out `G`\n    * `== (r + e * a) * G`; substitution of `h(R | m)` with `e`\n    * `== s * G`; substitution of `r + e * a`.\n\nMuSig\n=====\n\nUnder MuSig, validation must remain the same, and multiple participants must provide a single aggregate key and signature.\n\nSuppose there exist two participants A and B.\nAt setup:\n\n* A generates a random scalar `a` and B generates a random scalar `b`.\n* A computes `A` as `A = a * G` and B computes `B` as `B = b * G`.\n* A and B exchange `A` and `B`.\n* They generate the list `L`, by sorting their public keys and concatenating their representations.\n* They compute their aggregate public key `P` as `P = h(L) * A + h(L) * B`.\n* They publish the aggregate public key `P`.\n\nSigning takes three phases.\n\n1.  `R` commitment exchange.\n  * A generates a random scalar `r[a]` and B generates a random scalar `r[b]`.\n  * A computes `R[a]` as `R[a] = r[a] * G` and B computes `R[b]` as `R[b] = r[b] * G`.\n  * A computes `h(R[a])` and B computes `h(R[b])`.\n  * A and B exchange `h(R[a])` and `h(R[b])`.\n2.  `R` exchange.\n  * A and B exchange `R[a]` and `R[b]`.\n  * They validate that the previous given `h(R[a])` and `h(R[b])` matches.\n3.  `s` exchange.\n  * They compute `R` as `R = R[a] + R[b]`.\n  * They compute `e` as `h(R | m)`.\n  * A computes `s[a]` as `s[a] = r[a] + e * h(L) * a` and B computes `s[b]` as `s[b] = r[b] + e * h(L) * b`.\n  * They exchange `s[a]` and `s[b]`.\n  * They compute `s` as `s = s[a] + s[b]`.\n  * They publish the signature as the tuple `(e, s)`.\n\nAt validation, the validator knows `P`, `m`, and the signature `(R, s)`.\n\n* It recovers `e[validator]` as so: `e[validator] = h(R | m)`\n* It computes `S[validator]` as so: `S[validator] = R + e[validator] * P`.\n* It checks if `s * G == S[validator]`.\n  * `S[validator] = R + e[validator] * P`\n  * `== R[a] + R[b] + e[validator] * P`; substitution of `R`\n  * `== r[a] * G + r[b] * G + e[validator] * P`; substitution of `R[a]` and `R[b]`\n  * `== r[a] * G + r[b] * G + e * P`; substitution of `e[validator]` with `e`\n  * `== r[a] * G + r[b] * G + e * (h(L) * A + h(L) * B)`; substitution of `P`\n  * `== r[a] * G + r[b] * G + e * h(L) * A + e * h(L) * B`; distribution of `e` inside parentheses.\n  * `== r[a] * G + r[b] * G + e * h(L) * a * G + e * h(L) * b * G`; substitution of `A` and `B`.\n  * `== (r[a] + r[b] + e * h(L) * a + e * h(L) * b) * G`; factoring out of `G`\n  * `== (r[a] + e * h(L) * a + r[b] + e * h(L) * b) * G`; rearrangement of terms\n  * `== (s[a] + s[b]) * G`; substitution of `r[a] + e * h(L) * a` and `r[b] + e * h(L) * b`\n  * `== s * G`;  substitution of `s[a] + s[b]`\n\n\nTwo-Phase MuSig Unsafe\n======================\n\nOriginal proposal of MuSig only had two phases, `R` exchange and `s` exchange.\nHowever, there was a flaw found in the security proof in this two-phase MuSig.\nIn response, an earlier phase of exchanging commitments to `R` was added.\n\nThus, two-phase MuSig is potentially unsafe.\n\nhttps://eprint.iacr.org/2018/417.pdf describes the argument.\nBriefly, with two-phase MuSig, one of the participants can deliberately delay its side of a `R` exchange and control the resulting sum `R` by cancelling the `R` of the other participant.\nExecuted over many (aborted) signing sessions, one participant can induce the other to create a signature for a message it might not agree to, by using the Wagner Generalized Birthday Paradox attack.\n\nBriefly, a two-phase MuSig signing would go this way:\n\n1.  `R` exchange.\n  * A generates random scalar `r[a]` and B generates random scalar `r[b]`.\n  * A computes `R[a]` as `r[a] * G` and B computes `R[b]` as `r[b] * G`.\n  * They exchange `R[a]` and `R[b]`.\n2.  `s` exchange.\n  * They compute `R` as `R = R[a] + R[b]`.\n  * They compute `e` as `h(R | m)`.\n  * A computes `s[a]` as `s[a] = r[a] + e * h(L) * a` and B computes `s[b]` as `s[b] = r[b] + e * h(L) * b`.\n  * They exchange `s[a]` and `s[b]`.\n  * They compute `s` as `s = s[a] + s[b]`.\n  * They publish the signature as the tuple `(R, s)`.\n\nThe sticking point is \"exchange\" here.\nGiven that we live in a relativistic universe where there is no such thing as simultaneity-in-time-without-simultaneity-in-space, it is impossible to ensure that both A and B send their data \"at the same time\" in such a way that it is impossible for, for example, the send of B to be outside the future light cone of the send of A.\nOr in human-level terms, it is not possible to ensure over the network that B will not send `R[b]` *after* it receives `R[a]`.\n\nSuppose that instead of B generating a random `r[b]` and *then* computing `R[b] = r[b] * G`, it instead selects an arbitrary `R[selected]` it wants to target, then compute `R[b]` as `R[selected] - R[a]`.\nThen at `s` exchange:\n\n* They compute `R` as `R[a] + R[b]`, which is in fact `R[a] + R[selected] - R[a]`, or `R[selected]`, i.e. `R == R[selected]`.\n* They compute `e` as `h(R[selected] | m)`.\n* A computes `s[a]` as `s[a] = r[a] + e * h(L) * a`.\n* B is unable to compute `s[b]` as it has no `r[b]` it can use in the computation, and aborts the signing.\n\nThe attack involved is that multiple such signing sessions, for the same message or for separate distinct messages, might be done in parallel.\nSuppose that there are `n` such sessions, such that A provides `n` different `R[a][i]`, e.g. `R[a][1]`, `R[a][2]`, `R[a][3]` up to `R[a][n]`.\nThen:\n\n* B delays each session, pretending to have Internet connectivity problems.\n* B selects a message `m[target]` that it knows A will never sign (e.g. \"I, A, give all my money to B\").\n* B computes `R[target]` as `sum where i = 1 to n of R[a][i]`.\n* B uses the Wagner Generalized Birthday Paradox technique to find `R[selected][i]` with the following constraint:\n  * `h(R[target] | m[target]) == sum where i = 1 to n of h(R[selected][i] | m[i])`.\n  * Given a large enough number of parallel sessions `n`, this can greatly reduce the effort from 2^128 to find a match to within the realm of a large computer to compute within a few seconds.\n* B computes `R[b][i]` as `R[selected][i] - R[a][i]`, for each `i` from 1 to `n`.\n* B provides `R[b][i]` for each session.\n* A computes `R[i]` as `R[a][i] + R[b][i]` for each session.\n  * However we know that `R[b][i] == R[selected][i] - R[a][i]` for each session, cancelling out `R[a][i]` and leaving `R[i] == R[selected][i]`\n* A computes `s[a][i]` as `r[a][i] + h(R[selected][i] | m[i]) * h(L) * a` for each session.\n* A gives `s[a][i]` for each session.\n* B aborts each session.\n* B sums up all the `s[a][i]`:\n  * `(sum where i = 1 to n of r[a][i]) + (sum where i = 1 to n of h(R[selected][i] | m[i]) * h(L) * a)`.\n  * Remember, B has specifically selected `R[selected][i]` such that `h(R[target] | m[target])` is equal to the sum of `h(R[selected][i] | m[i])`.\n  * `== (sum where i = 1 to n of r[a][i]) + h(R[target] | m[target]) * h(L) * a)`.\n* B adds `h(R[target] | m[target]) * h(L) * b` to the above sum.\n  * This results in a signature for MuSig(A, B) to the message `m[target]`, even though A would never have agreed to this message.\n\nThus, 2-phase MuSig enables a Wagner attack on the participant, thus it is unsafe.\n\nNow, any method of ensuring a \"simultaneous\" exchange of `R` points is largely the same as adding a \"commit to `R`\" phase, i.e. the fix for this is simply to add the \"`R` commitment exchange\" phase.\n\nReferences: https://eprint.iacr.org/2018/417.pdf\n\nMuSig Composition\n=================\n\nLet us suppose that we have some protocol that requires a MuSig signing session between signers with public keys `P` and `C`.\nLet us further suppose that in fact, `P = MuSig(A, B)`, i.e. one of the public keys in this protocol is, in reality, itself a MuSig of two participants.\n\nAt the point of view of signer C, P is a single participant and it acts as such.\nHowever, in reality, P is an aggregate.\n\nWe want to have the following properties:\n\n* C should never need to know that P is in fact an aggregate.\n* Even if B is secretly the same as C, the entire protocol as a whole (including the aggregate signing of `MuSig(A, B)`) should remain three-phase MuSig.\n\nNow, from the point of view of C, what it sees are:\n\nAt setup:\n\n* It generates a random scalar `c` and the public key `C` as `C = c * G`.\n* It exchanges keys with P and gets the public key `P`.\n* It computes `L` by sorting `C` and `P` and concatenating them.\n* It determines their aggregate key as `h(L) * C + h(L) * P`.\n\nAt signing:\n\n1.  `R` commitment exchange.\n  * It generates a random scalar `r[c]` and computes `R[c]` as `R[c] = r[c] * G`.\n  * It computes `h(R[c])`.\n  * It exchanges the hash `h(R[c])` with P and gets `h(R[p])`.\n2.  `R` exchange.\n  * It exchanges `R[c]` with P and gets `R[p]`.\n  * It validates that the hash `h(R[p])` matches the previously-committed hash.\n3.  `s` exchange.\n  * It computes `R` as `R = R[c] + R[p]`.\n  * It computes `e` as `e = h(R | m)`.\n  * It computes `s[c]` as `s[c] = r[c] + e * c`.\n  * It exchanges `s[c]` with P and gets `s[p]`.\n  * It computes `s` as `s = s[c] + s[p]`.\n\nHowever, from point of view of A and B, what actually happens is this:\n\nAt setup:\n\n* A generates a random scalar `a` and computes `A = a * G`, B generates a random scalar `b` and computes `B = b * G`.\n* They exchange `A` and `B`.\n* They generate their own `L[ab]`, by sorting `A` and `B` and concatenating their representations.\n* They compute the inner MuSig pubkey `P` as `P = h(L[ab]) * A + h(L[ab]) * B`.\n* They exchange `P` with C, and get `C`.\n* They compute the outer MuSig pubkey as `h(L) * P + h(L) * C`.\n\nAt signing:\n\n1.  `R` commitment exchange.\n  * A generates a random scalar `r[a]` and computes `R[a] = r[a] * G`, B generates a random scalar `r[b]` and computes `R[b] = r[b] * G`.\n  * A computes `h(R[a])`, B computes `h(R[b])`.\n  * They exchange `h(R[a])` and `h(R[b])`.\n  * They need to compute `h(R[p])` for the protocol with C.\n    * However, even if we know `R[p] == R[a] + R[b]`, we cannot generate `h(R[p])`.\n    * Thus, they have no choice but to exchange `R[a]` and `R[b]` at this phase, even though this is supposed to be the `R` commitment exchange phase (and they should not share `R[a]` and `R[b]` yet)!\n\nUnfortunately, this means that, between A and B, we are now reduced to a two-phase MuSig.\nThis is relevant if B and C happen to be the same entity or are cooperating.\n\nBasically, before C has to provide its `h(R[c])`, B now knows the generated `R[a]` and `R[b]`.\nIf B and C are really the same entity, then C can compute `R[c]` as `R[selected] - R[a] - R[b]` before providing `h(R[c])`.\nThen this devolves to the same attack that brings down 2-phase MuSig.\n\nThus, composition with the current MuSig proposal is insecure.\n\nTowards a Composable Multi-`R` MuSig\n====================================\n\nA key element is that the first phase simply requires that all participants provide *commitments* to their individual `R`, and the second phase reveals their `R`.\n\nI propose here the modification below:\n\n* In the first phase, any participant in the MuSig may submit one *or more* `R` commitments.\n* In the second phase, the participant in the MuSig submits each `R` that decommits each of the `R` commitments it sent.\n\nI call this the Remote R Replacement Remanded: Redundant R Required Realistically, or, in shorter terms, the Multi-`R` proposal.\n\nThis is a simple and direct extension of the MuSig protocol, and expected to not have any effect on the security proof of MuSig.\n\nIn the case where all MuSig participants are singletons and each participant just generates and sends a single `R` commitment, then this proposal reduces to the original MuSig proposal.\n\nHowever, in the case where one participant is in reality itself an aggregate, then we shall describe it below.\nThe below example is `MuSig(MuSig(A, B), C)`.\n\n1.  `R` commitment exchange.\n  * A generates a random number `r[a]`, B generates a random number `r[b]`, C generates a random number `r[c]`.\n  * A computes `R[a]` as `r[a] * G`, B computes `R[b]` as `r[b] * G`, C computes `R[c]` as `r[c] * G`.\n  * A computes `h(R[a])`, B computes `h(R[b])`, C computes `h(R[c])`.\n  * A and B exchange their hashes with each other.\n  * A and B jointly exchange their `h(R[a])` and `h(R[b])` with the `h(R[c])` from C.\n2.  `R` exchange.\n  * A and B reveal their `R[a]` and `R[b]` with each other.\n  * A and B validate the given `R[a]` matches `h(R[a])` and the given `R[b]` matches `h(R[b])`.\n  * A and B jointly exchange their `R[a]` and `R[b]` with the `R[c]` from C.\n  * C validates `R[a]` and `R[b]`, A and B validate `R[c]`.\n  * They compute `R` as the sum of all `R[a] + R[b] + R[c]`.\n3.  `s` exchange.\n  * They compute `e` as `h(R | m)`.\n  * A computes `s[a]` as `r[a] + e * h(L[abc]) * h(L[ab]) * a`, B computes `s[b]` as `r[b] + e * h(L[abc]) * h(L[ab]) * b`.\n  * C computes `s[c]` as `r[c] + e * h(L[abc]) * c`.\n  * A and B exchange `s[a]` and `s[b]`.\n  * A and B compute `s[ab]` as `s[a] + s[b]`.\n  * A and B jointly exchange their `s[ab]` with `s[c]` from C.\n  * They compute `s` as `s[ab] + s[c]`.\n  * They publish the signature as the tuple `(R, s)`.\n\nOf note, is that the number of `R` a participant provides is a strong hint as to whether it is actually an aggregate or not, and forms an upper bound as to the size of the aggregate (i.e. an aggregate of `n` members can pretend to be an aggregate of `m` members where `n < m`, but cannot pretend with `n > m`).\nThus, C here learns that its counterparty is actually itself an aggregate rather than a singleton.\nThis may be acceptable as a weak reduction in privacy (in principle, C should never learn that it is talking to an aggregate rather than a single party).\n\nAlternative Composable MuSig Schemes\n====================================\n\nThe above proposal is not the only one.\nBelow are some additional proposals which have various flaws, ranging from outright insecurity to practical implementation complexity issues.\n\nPedersen Commitments in Phase 1\n-------------------------------\n\nMy initial proposal was to use Pedersen commitments in phase 1.\nAt phase 1, each party would generate a `r[x]` and `q[x]`, and exchange the Pedersen commitments `r[x] * G + q[x] * H`, where `H` is a NUMS point used as a second standard generator.\nThen at phase 2, each party reveals its `q[x]`.\nAll the Pedersen commitments are summed, then all `q[x]` are summed, multiplied by `H`, then subtracted from the sum of Pedersen commitments.\n\nUnfortunately, this leads to a Wagner attack.\n\nSuppose A and B have an aggregate MuSig(A, B).\n\n* B initiates multiple parallel signing sessions with A.\n* B selects a message `m[target]` that it knows A will never sign (e.g. \"I, A, give all my money to B\").\n* In the first phase, B selects random points `R[b][i]` for each session `i` and provides that as its Pedersen commitment, receiving `R[a][i] + q[a][i] * H` in exchange.\n* In the second phase, B delays each session, pretending to have Internet connectivity problems.\n* A sends B the `q[a][i]` for all `i`.\n* B computes `R[a][i]` for all `i` by subtracting `q[a][i] * H` from the Pedersen commitments given by A.\n* B computes `R[target]` as `sum where i = 1 to n of R[a][i]`.\n* B uses the Wagner Generalized Birthday Paradox technique to find `q[b][i]` with the following constraint:\n  * First compute `R[selected][i]` as `R[a][i] +  R[b][i] - q[b][i] * H` for all `i`.\n  * Then ensure this constraint: `h(R[target] | m[target]) == sum where i = 1 to n of h(R[selected][i] | m[i])`.\n* B sends the `q[b][i]` found above.\n* A computes `R[i]` as `R[a][i] + q[a][i] * H + R[b][i] - q[a][i] * H - q[b][i] * H` for all `i`.\n  * This resolves down to `R[a][i] + R[b][i] - q[b][i] * H`, or `R[selected][i]`.\n* A computes `s[a][i]` as `r[a][i] + h(R[selected][i] | m[i]) * a` for all `i`.\n* B sums all `s[a][i]` for all `i` together, forming `(sum where i = 1 to n of r[a][i]) + (sum where i = 1 to n of h(R[selected][i] | m[i])) * a`.\n  * This is also a valid signature on `m[target]`, since `sum where i = 1 to n of h(R[selected][i] | m[i])` equals `h(R[target] | m[target])`.\n\nThus, Pedersen commitments for phase 1 are insecure, as it allows counterparties to control `R`.\n\nElGamal Commitments in Phase 1\n------------------------------\n\nElGamal commitments prevent B from just giving random `q[b][i]`, thus preventing the above Wagner attack.\nHowever, it is still possible for B to control the resulting `R`, but in doing so this prevents the protocol from completing (thus, even with full control of `R`, B is still unable to promote this to an `R`-reuse attack or the above Wagner attack schema).\nThis is not quite as bad as the above case, but having just one participant control the nonce `R` should make us worry that other attacks may now become possible (unless we acquire some proof that this will be equivalent in security to the hash-using MuSig).\n\nBriefly, with ElGamal commitments in Phase 1:\n\n1. `R` commitment exchange.\n  * A generates random numbers `r[a]` and `q[a]`, B generates random numbers `r[b]` and `q[b]`.\n  * A computes its commitment as two points, `q[a] * G` and `r[a] * G + q[a] * H`, B computes its commitment as two points, `q[b] * G` and `r[b] * G + q[b] * H`.\n    * `H` is a NUMS point used as a second standard generator.\n    * Note that one point uses `q[] * G` while the other adds `q[] * H` to `r[] * G`.\n  * They exchange their pairs of points.\n2. `R` exchange.\n  * They exchange `q[a]` and `q[b]`, and the points `r[a] * G` (== `R[a]`) and `r[b] * G` (== `R[b]`).\n  * They validate the exchanged data from the previous `R` commitments.\n  * They compute `R` as `R[a]` + `R[b]`.\n3. `s` exchange.\n  * Same as before.\n\nB can attack this by delaying its phases as below:\n\n1. `R` commitment exchange.\n  * B generates random `q[selected]`.\n  * B selects target `R[selected]`.\n  * After receiving `q[a] * G` and `r[a] * G + q[a] * H`, B computes `q[selected] * G - q[a] * G` and `R[selected] + q[selected] * H - r[a] * G - q[a] * H` and sends those points as its own commitment.\n2. `R` exchange.\n  * After receiving `q[a]` and `R[a]`, B computes `q[b]` as `q[selected] - q[a]` and computes `R[b]` as `R[selected] - R[a]` and sends both as its decommitment.\n  * The resulting `R` will now be `R[selected]` chosen by B.\n\n`s` exchange cannot complete, as that would require that B know `r[selected] - r[a]` where `R[selected] = r[selected] * G`.\nEven if B generates `R[selected]` from `r[selected]`, it does not know `r[a]`.\nA would provide `r[a] + h(R[selected] | m) * h(L[ab]) * a`, but B would be unable to complete this signature.\n\nThe difference here is that B has to select `R[selected]` before it learns `R[a]`, and thus is unable to mount the above Wagner attack schema.\nIn particular, B first has to compute an `R[target]` equal to `sum where i = 1 to n of R[a][i]` across `n` sessions numbered `i`, in addition to selecting a message `m[i]`.\nThen B has to perform a Wagner attack with the constraint `h(R[target] | m[target]) == sum where i = 1 to n of h(R[selected][i] | m[i])`\nFortunately for this scheme, B cannot determine such an `R[target]` before it has to select `R[selected]`, thus preventing this attack.\n\nIt may be possible that this scheme is safe, however I am not capable of proving it safe.\n\nAcknowledgments\n===============\n\nI contacted Yannick Seurin, Andrew Poelstra, Pieter Wuille, and Greg Maxwell, the authors of MuSig, regarding this issue, and proposing to use Pedersen commitments for the first phase.\nThey informed me that Tim Ruffing had actually been thinking of similar issue before I did, and also pointed out that Pedersen commitments do not commit to `r * G`, only to `r` (i.e. would have to reveal `r` to serve as a verifiable commitment).\nIt seemed to me that the general agreement was that ElGamal commitments should work for committing to `r * G`.\nHowever as I show above, this still allows a delaying participant to cancel the `R` contributions of the other parties, allowing it to control the aggregate `R` (though not quite to launch a Wagner attack).\n\n`nickler` and `waxwing` on IRC confirmed my understanding of the attack on 2-phase MuSig.\n`waxwing` also mentioned that the paper attacking 2-phase MuSig really attacks CoSi, and that the paper itself admits that given a knowledge-of-secret-keys, CoSi (and presumably 2-phase MuSig) would be safe."
            },
            {
                "author": "Lloyd Fournier",
                "date": "2019-11-29T05:50:33",
                "message_text_only": "Hi ZmnSCPxj,\n\nVery interesting problem.\n\nJust a quick note: I think there is a way to commit to a point properly\nwith Pedersen commitments. Consider the following:\nCOM(X) = (y*G + z*H, y*G + X)  where y and z are random and the opening is\n(y,z,X).  This seems to be a  unconditionally hiding and computationally\nbinding homomorphic commitment scheme to a point based on the DL problem\nrather than DDH.\n\nLL\n\nOn Mon, Nov 25, 2019 at 10:00 PM ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> So I heard you like MuSig.\n>\n>\n> Introduction\n> ============\n>\n> Previously on lightning-dev, I propose Lightning Nodelets, wherein one\n> signatory of a channel is in fact not a single entity, but instead an\n> aggregate:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002236.html\n>\n> Generalizing:\n>\n> * There exists some protocol that requires multiple participants agreeing.\n>   * This can be implemented by use of MuSig on the public keys of the\n> participants.\n> * One or more of the participants in the above protocol is in fact an\n> aggregate, not a single participant.\n>   * Ideally, no protocol modification should be needed to support such\n> aggregates, \"only\" software development without modifying the protocol\n> layer.\n>   * Obviously, any participant of such a protocol, whether a direct\n> participant, or a member of an aggregated participant of that protocol,\n> would want to retain control of its own money in that protocol, without\n> having to determine if it is being Sybilled (and all other participants are\n> in fact just one participant).\n>   * Motivating example: a Lightning Network channel is the aggregate of\n> two participants, the nodes creating that channel.\n>     However, with nodelets as proposed above, one of the participants is\n> actually itself an aggregate of multiple nodelets.\n>     * This requires that a Lightning Network channel with a MuSig address,\n> to have one or both participants, be potentially an aggregate of two or\n> more nodelet participants, e.g. `MuSig(MuSig(A, B), C)`\n>\n> This is the \"MuSig composition\" problem.\n> That is, given `MuSig(MuSig(A, B), C)`, and the *possibility* that in fact\n> `B == C`, what protocol can A use to ensure that it uses the three-phase\n> MuSig protocol (which has a proof of soundness) and not inadvertently use a\n> two-phase MuSig protocol?\n>\n> Schnorr Signatures\n> ==================\n>\n> The scheme is as follows.\n>\n> Suppose an entity A needs to show a signature.\n> At setup:\n>\n> * It generates a random scalar `a`.\n> * It computes `A` as `A = a * G`, where `G` is the standard generator\n> point.\n> * It publishes `A`.\n>\n> At signing a message `m`:\n>\n> * It generates a random scalar `r`.\n> * It computes `R` as `R = r * G`.\n> * It computes `e` as `h(R | m)`, where `h()` is a standard hash function\n> and `x | y` denotes the serialization of `x` concatenated by the\n> serialization of `y`.\n> * It computes `s` as `s = r + e * a`.\n> * It publishes as signature the tuple of `(R, s)`.\n>\n> An independent validator can then get `A`, `m`, and the signature `(R, s)`.\n> At validation:\n>\n> * It recovers `e[validator]` as so: `e[validator] = h(R | m)`\n> * It computes `S[validator]` as so: `S[validator] = R + e[validator] * A`.\n> * It checks if `s * G == S[validator]`.\n>   * If `R` and `s` were indeed generated as per signing algorithm above,\n> then:\n>     * `S[validator] = R + e[validator] * A`\n>     * `== r * G + e[validator] * A`; subbstitution of `R`\n>     * `== r * G + h(R | m) * A`; substitution of `e[validator]`\n>     * `== r * G + h(R | m) * a * G`; substitution of `A`.\n>     * `== (r + h(R | m) * a) * G`; factor out `G`\n>     * `== (r + e * a) * G`; substitution of `h(R | m)` with `e`\n>     * `== s * G`; substitution of `r + e * a`.\n>\n> MuSig\n> =====\n>\n> Under MuSig, validation must remain the same, and multiple participants\n> must provide a single aggregate key and signature.\n>\n> Suppose there exist two participants A and B.\n> At setup:\n>\n> * A generates a random scalar `a` and B generates a random scalar `b`.\n> * A computes `A` as `A = a * G` and B computes `B` as `B = b * G`.\n> * A and B exchange `A` and `B`.\n> * They generate the list `L`, by sorting their public keys and\n> concatenating their representations.\n> * They compute their aggregate public key `P` as `P = h(L) * A + h(L) * B`.\n> * They publish the aggregate public key `P`.\n>\n> Signing takes three phases.\n>\n> 1.  `R` commitment exchange.\n>   * A generates a random scalar `r[a]` and B generates a random scalar\n> `r[b]`.\n>   * A computes `R[a]` as `R[a] = r[a] * G` and B computes `R[b]` as `R[b]\n> = r[b] * G`.\n>   * A computes `h(R[a])` and B computes `h(R[b])`.\n>   * A and B exchange `h(R[a])` and `h(R[b])`.\n> 2.  `R` exchange.\n>   * A and B exchange `R[a]` and `R[b]`.\n>   * They validate that the previous given `h(R[a])` and `h(R[b])` matches.\n> 3.  `s` exchange.\n>   * They compute `R` as `R = R[a] + R[b]`.\n>   * They compute `e` as `h(R | m)`.\n>   * A computes `s[a]` as `s[a] = r[a] + e * h(L) * a` and B computes\n> `s[b]` as `s[b] = r[b] + e * h(L) * b`.\n>   * They exchange `s[a]` and `s[b]`.\n>   * They compute `s` as `s = s[a] + s[b]`.\n>   * They publish the signature as the tuple `(e, s)`.\n>\n> At validation, the validator knows `P`, `m`, and the signature `(R, s)`.\n>\n> * It recovers `e[validator]` as so: `e[validator] = h(R | m)`\n> * It computes `S[validator]` as so: `S[validator] = R + e[validator] * P`.\n> * It checks if `s * G == S[validator]`.\n>   * `S[validator] = R + e[validator] * P`\n>   * `== R[a] + R[b] + e[validator] * P`; substitution of `R`\n>   * `== r[a] * G + r[b] * G + e[validator] * P`; substitution of `R[a]`\n> and `R[b]`\n>   * `== r[a] * G + r[b] * G + e * P`; substitution of `e[validator]` with\n> `e`\n>   * `== r[a] * G + r[b] * G + e * (h(L) * A + h(L) * B)`; substitution of\n> `P`\n>   * `== r[a] * G + r[b] * G + e * h(L) * A + e * h(L) * B`; distribution\n> of `e` inside parentheses.\n>   * `== r[a] * G + r[b] * G + e * h(L) * a * G + e * h(L) * b * G`;\n> substitution of `A` and `B`.\n>   * `== (r[a] + r[b] + e * h(L) * a + e * h(L) * b) * G`; factoring out of\n> `G`\n>   * `== (r[a] + e * h(L) * a + r[b] + e * h(L) * b) * G`; rearrangement of\n> terms\n>   * `== (s[a] + s[b]) * G`; substitution of `r[a] + e * h(L) * a` and\n> `r[b] + e * h(L) * b`\n>   * `== s * G`;  substitution of `s[a] + s[b]`\n>\n>\n> Two-Phase MuSig Unsafe\n> ======================\n>\n> Original proposal of MuSig only had two phases, `R` exchange and `s`\n> exchange.\n> However, there was a flaw found in the security proof in this two-phase\n> MuSig.\n> In response, an earlier phase of exchanging commitments to `R` was added.\n>\n> Thus, two-phase MuSig is potentially unsafe.\n>\n> https://eprint.iacr.org/2018/417.pdf describes the argument.\n> Briefly, with two-phase MuSig, one of the participants can deliberately\n> delay its side of a `R` exchange and control the resulting sum `R` by\n> cancelling the `R` of the other participant.\n> Executed over many (aborted) signing sessions, one participant can induce\n> the other to create a signature for a message it might not agree to, by\n> using the Wagner Generalized Birthday Paradox attack.\n>\n> Briefly, a two-phase MuSig signing would go this way:\n>\n> 1.  `R` exchange.\n>   * A generates random scalar `r[a]` and B generates random scalar `r[b]`.\n>   * A computes `R[a]` as `r[a] * G` and B computes `R[b]` as `r[b] * G`.\n>   * They exchange `R[a]` and `R[b]`.\n> 2.  `s` exchange.\n>   * They compute `R` as `R = R[a] + R[b]`.\n>   * They compute `e` as `h(R | m)`.\n>   * A computes `s[a]` as `s[a] = r[a] + e * h(L) * a` and B computes\n> `s[b]` as `s[b] = r[b] + e * h(L) * b`.\n>   * They exchange `s[a]` and `s[b]`.\n>   * They compute `s` as `s = s[a] + s[b]`.\n>   * They publish the signature as the tuple `(R, s)`.\n>\n> The sticking point is \"exchange\" here.\n> Given that we live in a relativistic universe where there is no such thing\n> as simultaneity-in-time-without-simultaneity-in-space, it is impossible to\n> ensure that both A and B send their data \"at the same time\" in such a way\n> that it is impossible for, for example, the send of B to be outside the\n> future light cone of the send of A.\n> Or in human-level terms, it is not possible to ensure over the network\n> that B will not send `R[b]` *after* it receives `R[a]`.\n>\n> Suppose that instead of B generating a random `r[b]` and *then* computing\n> `R[b] = r[b] * G`, it instead selects an arbitrary `R[selected]` it wants\n> to target, then compute `R[b]` as `R[selected] - R[a]`.\n> Then at `s` exchange:\n>\n> * They compute `R` as `R[a] + R[b]`, which is in fact `R[a] + R[selected]\n> - R[a]`, or `R[selected]`, i.e. `R == R[selected]`.\n> * They compute `e` as `h(R[selected] | m)`.\n> * A computes `s[a]` as `s[a] = r[a] + e * h(L) * a`.\n> * B is unable to compute `s[b]` as it has no `r[b]` it can use in the\n> computation, and aborts the signing.\n>\n> The attack involved is that multiple such signing sessions, for the same\n> message or for separate distinct messages, might be done in parallel.\n> Suppose that there are `n` such sessions, such that A provides `n`\n> different `R[a][i]`, e.g. `R[a][1]`, `R[a][2]`, `R[a][3]` up to `R[a][n]`.\n> Then:\n>\n> * B delays each session, pretending to have Internet connectivity problems.\n> * B selects a message `m[target]` that it knows A will never sign (e.g.\n> \"I, A, give all my money to B\").\n> * B computes `R[target]` as `sum where i = 1 to n of R[a][i]`.\n> * B uses the Wagner Generalized Birthday Paradox technique to find\n> `R[selected][i]` with the following constraint:\n>   * `h(R[target] | m[target]) == sum where i = 1 to n of h(R[selected][i]\n> | m[i])`.\n>   * Given a large enough number of parallel sessions `n`, this can greatly\n> reduce the effort from 2^128 to find a match to within the realm of a large\n> computer to compute within a few seconds.\n> * B computes `R[b][i]` as `R[selected][i] - R[a][i]`, for each `i` from 1\n> to `n`.\n> * B provides `R[b][i]` for each session.\n> * A computes `R[i]` as `R[a][i] + R[b][i]` for each session.\n>   * However we know that `R[b][i] == R[selected][i] - R[a][i]` for each\n> session, cancelling out `R[a][i]` and leaving `R[i] == R[selected][i]`\n> * A computes `s[a][i]` as `r[a][i] + h(R[selected][i] | m[i]) * h(L) * a`\n> for each session.\n> * A gives `s[a][i]` for each session.\n> * B aborts each session.\n> * B sums up all the `s[a][i]`:\n>   * `(sum where i = 1 to n of r[a][i]) + (sum where i = 1 to n of\n> h(R[selected][i] | m[i]) * h(L) * a)`.\n>   * Remember, B has specifically selected `R[selected][i]` such that\n> `h(R[target] | m[target])` is equal to the sum of `h(R[selected][i] |\n> m[i])`.\n>   * `== (sum where i = 1 to n of r[a][i]) + h(R[target] | m[target]) *\n> h(L) * a)`.\n> * B adds `h(R[target] | m[target]) * h(L) * b` to the above sum.\n>   * This results in a signature for MuSig(A, B) to the message\n> `m[target]`, even though A would never have agreed to this message.\n>\n> Thus, 2-phase MuSig enables a Wagner attack on the participant, thus it is\n> unsafe.\n>\n> Now, any method of ensuring a \"simultaneous\" exchange of `R` points is\n> largely the same as adding a \"commit to `R`\" phase, i.e. the fix for this\n> is simply to add the \"`R` commitment exchange\" phase.\n>\n> References: https://eprint.iacr.org/2018/417.pdf\n>\n> MuSig Composition\n> =================\n>\n> Let us suppose that we have some protocol that requires a MuSig signing\n> session between signers with public keys `P` and `C`.\n> Let us further suppose that in fact, `P = MuSig(A, B)`, i.e. one of the\n> public keys in this protocol is, in reality, itself a MuSig of two\n> participants.\n>\n> At the point of view of signer C, P is a single participant and it acts as\n> such.\n> However, in reality, P is an aggregate.\n>\n> We want to have the following properties:\n>\n> * C should never need to know that P is in fact an aggregate.\n> * Even if B is secretly the same as C, the entire protocol as a whole\n> (including the aggregate signing of `MuSig(A, B)`) should remain\n> three-phase MuSig.\n>\n> Now, from the point of view of C, what it sees are:\n>\n> At setup:\n>\n> * It generates a random scalar `c` and the public key `C` as `C = c * G`.\n> * It exchanges keys with P and gets the public key `P`.\n> * It computes `L` by sorting `C` and `P` and concatenating them.\n> * It determines their aggregate key as `h(L) * C + h(L) * P`.\n>\n> At signing:\n>\n> 1.  `R` commitment exchange.\n>   * It generates a random scalar `r[c]` and computes `R[c]` as `R[c] =\n> r[c] * G`.\n>   * It computes `h(R[c])`.\n>   * It exchanges the hash `h(R[c])` with P and gets `h(R[p])`.\n> 2.  `R` exchange.\n>   * It exchanges `R[c]` with P and gets `R[p]`.\n>   * It validates that the hash `h(R[p])` matches the previously-committed\n> hash.\n> 3.  `s` exchange.\n>   * It computes `R` as `R = R[c] + R[p]`.\n>   * It computes `e` as `e = h(R | m)`.\n>   * It computes `s[c]` as `s[c] = r[c] + e * c`.\n>   * It exchanges `s[c]` with P and gets `s[p]`.\n>   * It computes `s` as `s = s[c] + s[p]`.\n>\n> However, from point of view of A and B, what actually happens is this:\n>\n> At setup:\n>\n> * A generates a random scalar `a` and computes `A = a * G`, B generates a\n> random scalar `b` and computes `B = b * G`.\n> * They exchange `A` and `B`.\n> * They generate their own `L[ab]`, by sorting `A` and `B` and\n> concatenating their representations.\n> * They compute the inner MuSig pubkey `P` as `P = h(L[ab]) * A + h(L[ab])\n> * B`.\n> * They exchange `P` with C, and get `C`.\n> * They compute the outer MuSig pubkey as `h(L) * P + h(L) * C`.\n>\n> At signing:\n>\n> 1.  `R` commitment exchange.\n>   * A generates a random scalar `r[a]` and computes `R[a] = r[a] * G`, B\n> generates a random scalar `r[b]` and computes `R[b] = r[b] * G`.\n>   * A computes `h(R[a])`, B computes `h(R[b])`.\n>   * They exchange `h(R[a])` and `h(R[b])`.\n>   * They need to compute `h(R[p])` for the protocol with C.\n>     * However, even if we know `R[p] == R[a] + R[b]`, we cannot generate\n> `h(R[p])`.\n>     * Thus, they have no choice but to exchange `R[a]` and `R[b]` at this\n> phase, even though this is supposed to be the `R` commitment exchange phase\n> (and they should not share `R[a]` and `R[b]` yet)!\n>\n> Unfortunately, this means that, between A and B, we are now reduced to a\n> two-phase MuSig.\n> This is relevant if B and C happen to be the same entity or are\n> cooperating.\n>\n> Basically, before C has to provide its `h(R[c])`, B now knows the\n> generated `R[a]` and `R[b]`.\n> If B and C are really the same entity, then C can compute `R[c]` as\n> `R[selected] - R[a] - R[b]` before providing `h(R[c])`.\n> Then this devolves to the same attack that brings down 2-phase MuSig.\n>\n> Thus, composition with the current MuSig proposal is insecure.\n>\n> Towards a Composable Multi-`R` MuSig\n> ====================================\n>\n> A key element is that the first phase simply requires that all\n> participants provide *commitments* to their individual `R`, and the second\n> phase reveals their `R`.\n>\n> I propose here the modification below:\n>\n> * In the first phase, any participant in the MuSig may submit one *or\n> more* `R` commitments.\n> * In the second phase, the participant in the MuSig submits each `R` that\n> decommits each of the `R` commitments it sent.\n>\n> I call this the Remote R Replacement Remanded: Redundant R Required\n> Realistically, or, in shorter terms, the Multi-`R` proposal.\n>\n> This is a simple and direct extension of the MuSig protocol, and expected\n> to not have any effect on the security proof of MuSig.\n>\n> In the case where all MuSig participants are singletons and each\n> participant just generates and sends a single `R` commitment, then this\n> proposal reduces to the original MuSig proposal.\n>\n> However, in the case where one participant is in reality itself an\n> aggregate, then we shall describe it below.\n> The below example is `MuSig(MuSig(A, B), C)`.\n>\n> 1.  `R` commitment exchange.\n>   * A generates a random number `r[a]`, B generates a random number\n> `r[b]`, C generates a random number `r[c]`.\n>   * A computes `R[a]` as `r[a] * G`, B computes `R[b]` as `r[b] * G`, C\n> computes `R[c]` as `r[c] * G`.\n>   * A computes `h(R[a])`, B computes `h(R[b])`, C computes `h(R[c])`.\n>   * A and B exchange their hashes with each other.\n>   * A and B jointly exchange their `h(R[a])` and `h(R[b])` with the\n> `h(R[c])` from C.\n> 2.  `R` exchange.\n>   * A and B reveal their `R[a]` and `R[b]` with each other.\n>   * A and B validate the given `R[a]` matches `h(R[a])` and the given\n> `R[b]` matches `h(R[b])`.\n>   * A and B jointly exchange their `R[a]` and `R[b]` with the `R[c]` from\n> C.\n>   * C validates `R[a]` and `R[b]`, A and B validate `R[c]`.\n>   * They compute `R` as the sum of all `R[a] + R[b] + R[c]`.\n> 3.  `s` exchange.\n>   * They compute `e` as `h(R | m)`.\n>   * A computes `s[a]` as `r[a] + e * h(L[abc]) * h(L[ab]) * a`, B computes\n> `s[b]` as `r[b] + e * h(L[abc]) * h(L[ab]) * b`.\n>   * C computes `s[c]` as `r[c] + e * h(L[abc]) * c`.\n>   * A and B exchange `s[a]` and `s[b]`.\n>   * A and B compute `s[ab]` as `s[a] + s[b]`.\n>   * A and B jointly exchange their `s[ab]` with `s[c]` from C.\n>   * They compute `s` as `s[ab] + s[c]`.\n>   * They publish the signature as the tuple `(R, s)`.\n>\n> Of note, is that the number of `R` a participant provides is a strong hint\n> as to whether it is actually an aggregate or not, and forms an upper bound\n> as to the size of the aggregate (i.e. an aggregate of `n` members can\n> pretend to be an aggregate of `m` members where `n < m`, but cannot pretend\n> with `n > m`).\n> Thus, C here learns that its counterparty is actually itself an aggregate\n> rather than a singleton.\n> This may be acceptable as a weak reduction in privacy (in principle, C\n> should never learn that it is talking to an aggregate rather than a single\n> party).\n>\n> Alternative Composable MuSig Schemes\n> ====================================\n>\n> The above proposal is not the only one.\n> Below are some additional proposals which have various flaws, ranging from\n> outright insecurity to practical implementation complexity issues.\n>\n> Pedersen Commitments in Phase 1\n> -------------------------------\n>\n> My initial proposal was to use Pedersen commitments in phase 1.\n> At phase 1, each party would generate a `r[x]` and `q[x]`, and exchange\n> the Pedersen commitments `r[x] * G + q[x] * H`, where `H` is a NUMS point\n> used as a second standard generator.\n> Then at phase 2, each party reveals its `q[x]`.\n> All the Pedersen commitments are summed, then all `q[x]` are summed,\n> multiplied by `H`, then subtracted from the sum of Pedersen commitments.\n>\n> Unfortunately, this leads to a Wagner attack.\n>\n> Suppose A and B have an aggregate MuSig(A, B).\n>\n> * B initiates multiple parallel signing sessions with A.\n> * B selects a message `m[target]` that it knows A will never sign (e.g.\n> \"I, A, give all my money to B\").\n> * In the first phase, B selects random points `R[b][i]` for each session\n> `i` and provides that as its Pedersen commitment, receiving `R[a][i] +\n> q[a][i] * H` in exchange.\n> * In the second phase, B delays each session, pretending to have Internet\n> connectivity problems.\n> * A sends B the `q[a][i]` for all `i`.\n> * B computes `R[a][i]` for all `i` by subtracting `q[a][i] * H` from the\n> Pedersen commitments given by A.\n> * B computes `R[target]` as `sum where i = 1 to n of R[a][i]`.\n> * B uses the Wagner Generalized Birthday Paradox technique to find\n> `q[b][i]` with the following constraint:\n>   * First compute `R[selected][i]` as `R[a][i] +  R[b][i] - q[b][i] * H`\n> for all `i`.\n>   * Then ensure this constraint: `h(R[target] | m[target]) == sum where i\n> = 1 to n of h(R[selected][i] | m[i])`.\n> * B sends the `q[b][i]` found above.\n> * A computes `R[i]` as `R[a][i] + q[a][i] * H + R[b][i] - q[a][i] * H -\n> q[b][i] * H` for all `i`.\n>   * This resolves down to `R[a][i] + R[b][i] - q[b][i] * H`, or\n> `R[selected][i]`.\n> * A computes `s[a][i]` as `r[a][i] + h(R[selected][i] | m[i]) * a` for all\n> `i`.\n> * B sums all `s[a][i]` for all `i` together, forming `(sum where i = 1 to\n> n of r[a][i]) + (sum where i = 1 to n of h(R[selected][i] | m[i])) * a`.\n>   * This is also a valid signature on `m[target]`, since `sum where i = 1\n> to n of h(R[selected][i] | m[i])` equals `h(R[target] | m[target])`.\n>\n> Thus, Pedersen commitments for phase 1 are insecure, as it allows\n> counterparties to control `R`.\n>\n> ElGamal Commitments in Phase 1\n> ------------------------------\n>\n> ElGamal commitments prevent B from just giving random `q[b][i]`, thus\n> preventing the above Wagner attack.\n> However, it is still possible for B to control the resulting `R`, but in\n> doing so this prevents the protocol from completing (thus, even with full\n> control of `R`, B is still unable to promote this to an `R`-reuse attack or\n> the above Wagner attack schema).\n> This is not quite as bad as the above case, but having just one\n> participant control the nonce `R` should make us worry that other attacks\n> may now become possible (unless we acquire some proof that this will be\n> equivalent in security to the hash-using MuSig).\n>\n> Briefly, with ElGamal commitments in Phase 1:\n>\n> 1. `R` commitment exchange.\n>   * A generates random numbers `r[a]` and `q[a]`, B generates random\n> numbers `r[b]` and `q[b]`.\n>   * A computes its commitment as two points, `q[a] * G` and `r[a] * G +\n> q[a] * H`, B computes its commitment as two points, `q[b] * G` and `r[b] *\n> G + q[b] * H`.\n>     * `H` is a NUMS point used as a second standard generator.\n>     * Note that one point uses `q[] * G` while the other adds `q[] * H` to\n> `r[] * G`.\n>   * They exchange their pairs of points.\n> 2. `R` exchange.\n>   * They exchange `q[a]` and `q[b]`, and the points `r[a] * G` (== `R[a]`)\n> and `r[b] * G` (== `R[b]`).\n>   * They validate the exchanged data from the previous `R` commitments.\n>   * They compute `R` as `R[a]` + `R[b]`.\n> 3. `s` exchange.\n>   * Same as before.\n>\n> B can attack this by delaying its phases as below:\n>\n> 1. `R` commitment exchange.\n>   * B generates random `q[selected]`.\n>   * B selects target `R[selected]`.\n>   * After receiving `q[a] * G` and `r[a] * G + q[a] * H`, B computes\n> `q[selected] * G - q[a] * G` and `R[selected] + q[selected] * H - r[a] * G\n> - q[a] * H` and sends those points as its own commitment.\n> 2. `R` exchange.\n>   * After receiving `q[a]` and `R[a]`, B computes `q[b]` as `q[selected] -\n> q[a]` and computes `R[b]` as `R[selected] - R[a]` and sends both as its\n> decommitment.\n>   * The resulting `R` will now be `R[selected]` chosen by B.\n>\n> `s` exchange cannot complete, as that would require that B know\n> `r[selected] - r[a]` where `R[selected] = r[selected] * G`.\n> Even if B generates `R[selected]` from `r[selected]`, it does not know\n> `r[a]`.\n> A would provide `r[a] + h(R[selected] | m) * h(L[ab]) * a`, but B would be\n> unable to complete this signature.\n>\n> The difference here is that B has to select `R[selected]` before it learns\n> `R[a]`, and thus is unable to mount the above Wagner attack schema.\n> In particular, B first has to compute an `R[target]` equal to `sum where i\n> = 1 to n of R[a][i]` across `n` sessions numbered `i`, in addition to\n> selecting a message `m[i]`.\n> Then B has to perform a Wagner attack with the constraint `h(R[target] |\n> m[target]) == sum where i = 1 to n of h(R[selected][i] | m[i])`\n> Fortunately for this scheme, B cannot determine such an `R[target]` before\n> it has to select `R[selected]`, thus preventing this attack.\n>\n> It may be possible that this scheme is safe, however I am not capable of\n> proving it safe.\n>\n> Acknowledgments\n> ===============\n>\n> I contacted Yannick Seurin, Andrew Poelstra, Pieter Wuille, and Greg\n> Maxwell, the authors of MuSig, regarding this issue, and proposing to use\n> Pedersen commitments for the first phase.\n> They informed me that Tim Ruffing had actually been thinking of similar\n> issue before I did, and also pointed out that Pedersen commitments do not\n> commit to `r * G`, only to `r` (i.e. would have to reveal `r` to serve as a\n> verifiable commitment).\n> It seemed to me that the general agreement was that ElGamal commitments\n> should work for committing to `r * G`.\n> However as I show above, this still allows a delaying participant to\n> cancel the `R` contributions of the other parties, allowing it to control\n> the aggregate `R` (though not quite to launch a Wagner attack).\n>\n> `nickler` and `waxwing` on IRC confirmed my understanding of the attack on\n> 2-phase MuSig.\n> `waxwing` also mentioned that the paper attacking 2-phase MuSig really\n> attacks CoSi, and that the paper itself admits that given a\n> knowledge-of-secret-keys, CoSi (and presumably 2-phase MuSig) would be safe.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191129/921bf18d/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Composable MuSig",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Lloyd Fournier"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 48309
        }
    },
    {
        "title": "[bitcoin-dev] BIP OP_CHECKTEMPLATEVERIFY",
        "thread_messages": [
            {
                "author": "Jeremy",
                "date": "2019-11-26T01:50:40",
                "message_text_only": "Bitcoin Developers,\n\nPleased to announce refinements to the BIP draft for OP_CHECKTEMPLATEVERIFY\n(replaces previous OP_SECURETHEBAG BIP). Primarily:\n\n1) Changed the name to something more fitting and acceptable to the\ncommunity\n2) Changed the opcode specification to use the argument off of the stack\nwith a primitive constexpr/literal tracker rather than script lookahead\n3) Permits future soft-fork updates to loosen or remove \"constexpr\"\nrestrictions\n4) More detailed comparison to alternatives in the BIP, and why\nOP_CHECKTEMPLATEVERIFY should be favored even if a future technique may\nmake it semi-redundant.\n\nPlease see:\nBIP: https://github.com/JeremyRubin/bips/blob/ctv/bip-ctv.mediawiki\nReference Implementation:\nhttps://github.com/JeremyRubin/bitcoin/tree/checktemplateverify\n\nI believe this addresses all outstanding feedback on the design of this\nopcode, unless there are any new concerns with these changes.\n\nI'm also planning to host a review workshop in Q1 2020, most likely in San\nFrancisco. Please fill out the form here https://forms.gle/pkevHNj2pXH9MGee9\nif you're interested in participating (even if you can't physically attend).\n\nAnd as a \"but wait, there's more\":\n\n1) RPC functions are under preliminary development, to aid in testing and\nevaluation of OP_CHECKTEMPLATEVERIFY. The new command `sendmanycompacted`\nshows one way to use OP_CHECKTEMPLATEVERIFY. See:\nhttps://github.com/JeremyRubin/bitcoin/tree/checktemplateverify-rpcs.\n`sendmanycompacted` is still under early design. Standard practices for\nusing OP_CHECKTEMPLATEVERIFY & wallet behaviors may be codified into a\nseparate BIP. This work generalizes even if an alternative strategy is used\nto achieve the scalability techniques of OP_CHECKTEMPLATEVERIFY.\n2) Also under development are improvements to the mempool which will, in\nconjunction with improvements like package relay, help make it safe to lift\nsome of the mempool's restrictions on longchains specifically for\nOP_CHECKTEMPLATEVERIFY output trees. See:\nhttps://github.com/bitcoin/bitcoin/pull/17268\nThis work offers an improvement irrespective of OP_CHECKTEMPLATEVERIFY's\nfate.\n\n\nNeither of these are blockers for proceeding with the BIP, as they are\nergonomics and usability improvements needed once/if the BIP is activated.\n\nSee prior mailing list discussions here:\n\n*\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016934.html\n*\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016997.html\n\nThanks to the many developers who have provided feedback on iterations of\nthis design.\n\nBest,\n\nJeremy\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191125/5fc81eb3/attachment.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-11-27T21:32:51",
                "message_text_only": "Thanks for this work Jeremy.\n\nI know we've discussed this before, but I'll restate my concerns with\nadding a new \"global\" state variable to the Script interpreter for tracking\nwhether the previous opcode was a push-data operation or not.  While it\nisn't so hard to implement this in Bitcoin Core's Script interpreter,\nadding a new global state variable adds that much more complexity to anyone\ntrying to formally model Script semantics.  Perhaps one can argue that\nthere is already (non-stack) state in Script, e.g. to deal with\nCODESEPARATOR, so why not add more?  But I'd argue that we should avoid\nmaking bad problems worse.\n\nIf we instead make the CHECKTEMPLATEVERIFY operation fail if it isn't\npreceded by (or alternatively followed by) an appropriate sized\n(canonical?) PUSHDATA constant, even in an unexecuted IF branch, then we\ncan model the Script semantics by considering the\nPUSHDATA-CHECKTEMPLATEVERIFY pair as a single operation.  This allows\nimplementations to consider improper use of CHECKTEMPLATEVERIFY as a\nparsing error (just as today unbalanced IF-ENDIF pairs can be modeled as a\nparsing error, even though that isn't how it is implemented in Bitcoin\nCore).\n\nI admit we would lose your soft-fork upgrade path to reading values off the\nstack; however, in my opinion, this is a reasonable tradeoff.  When we are\nready to add programmable covenants to Script, we'll do so by adding CAT\nand operations to push transaction data right onto the stack, rather than\nposting a preimage to this template hash.\n\nPleased to announce refinements to the BIP draft for OP_CHECKTEMPLATEVERIFY\n> (replaces previous OP_SECURETHEBAG BIP). Primarily:\n>\n> 1) Changed the name to something more fitting and acceptable to the\n> community\n> 2) Changed the opcode specification to use the argument off of the stack\n> with a primitive constexpr/literal tracker rather than script lookahead\n> 3) Permits future soft-fork updates to loosen or remove \"constexpr\"\n> restrictions\n> 4) More detailed comparison to alternatives in the BIP, and why\n> OP_CHECKTEMPLATEVERIFY should be favored even if a future technique may\n> make it semi-redundant.\n>\n> Please see:\n> BIP: https://github.com/JeremyRubin/bips/blob/ctv/bip-ctv.mediawiki\n> Reference Implementation:\n> https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify\n>\n> I believe this addresses all outstanding feedback on the design of this\n> opcode, unless there are any new concerns with these changes.\n>\n> I'm also planning to host a review workshop in Q1 2020, most likely in San\n> Francisco. Please fill out the form here\n> https://forms.gle/pkevHNj2pXH9MGee9 if you're interested in participating\n> (even if you can't physically attend).\n>\n> And as a \"but wait, there's more\":\n>\n> 1) RPC functions are under preliminary development, to aid in testing and\n> evaluation of OP_CHECKTEMPLATEVERIFY. The new command `sendmanycompacted`\n> shows one way to use OP_CHECKTEMPLATEVERIFY. See:\n> https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify-rpcs.\n> `sendmanycompacted` is still under early design. Standard practices for\n> using OP_CHECKTEMPLATEVERIFY & wallet behaviors may be codified into a\n> separate BIP. This work generalizes even if an alternative strategy is used\n> to achieve the scalability techniques of OP_CHECKTEMPLATEVERIFY.\n> 2) Also under development are improvements to the mempool which will, in\n> conjunction with improvements like package relay, help make it safe to lift\n> some of the mempool's restrictions on longchains specifically for\n> OP_CHECKTEMPLATEVERIFY output trees. See: https://github.com/bitcoin/bitcoin/pull/17268\n> This work offers an improvement irrespective of OP_CHECKTEMPLATEVERIFY's\n> fate.\n>\n>\n> Neither of these are blockers for proceeding with the BIP, as they are\n> ergonomics and usability improvements needed once/if the BIP is activated.\n>\n> See prior mailing list discussions here:\n>\n> *\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016934.html\n> *\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016997.html\n>\n> Thanks to the many developers who have provided feedback on iterations of\n> this design.\n>\n> Best,\n>\n> Jeremy\n>\n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191127/4bb82570/attachment.html>"
            },
            {
                "author": "Jeremy",
                "date": "2019-11-28T19:59:42",
                "message_text_only": "Thanks for the feedback Russell, now and early. It deeply informed the\nversion I'm proposing here.\n\nI weighed carefully when selecting this design that I thought it would be\nan acceptable tradeoff after our discussion, but I recognize this isn't\nexactly what you had argued for.\n\nFirst off, with respect to the 'global state' issue, I figured it was\nreasonable with this choice of constexpr rule given that a reasonable tail\nrecursive parser might look something like:\n\nparse (code : rest) stack alt_stack just_pushed =\n    match code with\n        OP_PUSH => parse rest (x:stack) alt_stack True\n        OP_DUP => parse rest (x:stack) alt_stack False\n        // ...\n\nSo we're only adding one parameter which is a bool, and we only need to\never set it to an exact value based on the current code path, no\ncomplicated rules. I'm sensitive to the complexity added when formally\nmodeling script, but I think because it is only ever a literal, you could\nre-write it as co-recursive:\n\nparse_non_constexpr (code : rest) stack alt_stack =\n    match code with\n        OP_PUSH => parse_constexpr rest (x:stack) alt_stack\n        OP_DUP => parse_non_constexpr rest (x:stack) alt_stack\n        // ...\n\nparse_constexpr (code : rest) stack alt_stack  =\n    match code with\n        OP_CTV => ...\n        _ => parese_non_constexpr (code : rest) stack alt_stack\n\n\nIf I recall, this should help a bit with the proof automatability as it's\neasier in the case by case breakdown to see the unconditional code paths.\n\n\nIn terms of upgrade-ability, one of the other reasons I liked this design\nis that if we do enable OP_CTV for non-constexpr arguments, the issue\nbasically goes away and the OP becomes \"pure\" without any state tracking.\n(I think the switching on argument size is much less a concern because we\nalready use similar upgrade mechanisms elsewhere, and it doesn't add\nparsing context).\n\n\nIt's also possible, as I think *should be done* for tooling to treat an\nunbalanced OP_CTV as a parsing error. This will always produce\nconsensus-valid scripts! However by keeping the consensus rules more\nrelaxed we keep our upgrade-ability paths open for OP_CTV, which as I\nunderstand from speaking with other users is quite desirable.\n\n\nBest (and happy thanksgiving to those celebrating),\n\nJeremy\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\n\nOn Thu, Nov 28, 2019 at 6:33 AM Russell O'Connor <roconnor at blockstream.io>\nwrote:\n\n> Thanks for this work Jeremy.\n>\n> I know we've discussed this before, but I'll restate my concerns with\n> adding a new \"global\" state variable to the Script interpreter for tracking\n> whether the previous opcode was a push-data operation or not.  While it\n> isn't so hard to implement this in Bitcoin Core's Script interpreter,\n> adding a new global state variable adds that much more complexity to anyone\n> trying to formally model Script semantics.  Perhaps one can argue that\n> there is already (non-stack) state in Script, e.g. to deal with\n> CODESEPARATOR, so why not add more?  But I'd argue that we should avoid\n> making bad problems worse.\n>\n> If we instead make the CHECKTEMPLATEVERIFY operation fail if it isn't\n> preceded by (or alternatively followed by) an appropriate sized\n> (canonical?) PUSHDATA constant, even in an unexecuted IF branch, then we\n> can model the Script semantics by considering the\n> PUSHDATA-CHECKTEMPLATEVERIFY pair as a single operation.  This allows\n> implementations to consider improper use of CHECKTEMPLATEVERIFY as a\n> parsing error (just as today unbalanced IF-ENDIF pairs can be modeled as a\n> parsing error, even though that isn't how it is implemented in Bitcoin\n> Core).\n>\n> I admit we would lose your soft-fork upgrade path to reading values off\n> the stack; however, in my opinion, this is a reasonable tradeoff.  When we\n> are ready to add programmable covenants to Script, we'll do so by adding\n> CAT and operations to push transaction data right onto the stack, rather\n> than posting a preimage to this template hash.\n>\n> Pleased to announce refinements to the BIP draft for\n>> OP_CHECKTEMPLATEVERIFY (replaces previous OP_SECURETHEBAG BIP). Primarily:\n>>\n>> 1) Changed the name to something more fitting and acceptable to the\n>> community\n>> 2) Changed the opcode specification to use the argument off of the stack\n>> with a primitive constexpr/literal tracker rather than script lookahead\n>> 3) Permits future soft-fork updates to loosen or remove \"constexpr\"\n>> restrictions\n>> 4) More detailed comparison to alternatives in the BIP, and why\n>> OP_CHECKTEMPLATEVERIFY should be favored even if a future technique may\n>> make it semi-redundant.\n>>\n>> Please see:\n>> BIP: https://github.com/JeremyRubin/bips/blob/ctv/bip-ctv.mediawiki\n>> Reference Implementation:\n>> https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify\n>>\n>> I believe this addresses all outstanding feedback on the design of this\n>> opcode, unless there are any new concerns with these changes.\n>>\n>> I'm also planning to host a review workshop in Q1 2020, most likely in\n>> San Francisco. Please fill out the form here\n>> https://forms.gle/pkevHNj2pXH9MGee9 if you're interested in\n>> participating (even if you can't physically attend).\n>>\n>> And as a \"but wait, there's more\":\n>>\n>> 1) RPC functions are under preliminary development, to aid in testing and\n>> evaluation of OP_CHECKTEMPLATEVERIFY. The new command `sendmanycompacted`\n>> shows one way to use OP_CHECKTEMPLATEVERIFY. See:\n>> https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify-rpcs.\n>> `sendmanycompacted` is still under early design. Standard practices for\n>> using OP_CHECKTEMPLATEVERIFY & wallet behaviors may be codified into a\n>> separate BIP. This work generalizes even if an alternative strategy is used\n>> to achieve the scalability techniques of OP_CHECKTEMPLATEVERIFY.\n>> 2) Also under development are improvements to the mempool which will, in\n>> conjunction with improvements like package relay, help make it safe to lift\n>> some of the mempool's restrictions on longchains specifically for\n>> OP_CHECKTEMPLATEVERIFY output trees. See: https://github.com/bitcoin/bitcoin/pull/17268\n>> This work offers an improvement irrespective of OP_CHECKTEMPLATEVERIFY's\n>> fate.\n>>\n>>\n>> Neither of these are blockers for proceeding with the BIP, as they are\n>> ergonomics and usability improvements needed once/if the BIP is activated.\n>>\n>> See prior mailing list discussions here:\n>>\n>> *\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016934.html\n>> *\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016997.html\n>>\n>> Thanks to the many developers who have provided feedback on iterations of\n>> this design.\n>>\n>> Best,\n>>\n>> Jeremy\n>>\n>> --\n>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191129/880e74bc/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP OP_CHECKTEMPLATEVERIFY",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Russell O'Connor",
                "Jeremy"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 14244
        }
    },
    {
        "title": "[bitcoin-dev] Signing CHECKSIG position in Tapscript",
        "thread_messages": [
            {
                "author": "Russell O'Connor",
                "date": "2019-11-27T21:29:32",
                "message_text_only": "Hi all,\n\nI'd like to revisit an old topic from last year about the data signed in\ntapscript signatures <\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016508.html\n>.\n\nThe current tapscript proposal requires a signature on the last executed\nCODESEPRATOR position.  I'd like to propose an amendment whereby instead of\nsigning the last executed CODESEPRATOR position, we simply always sign the\nposition of the CHECKSIG (or other signing opcode) being executed. Then we\ncan deprecate CODESEPARTOR (either by making it OP_SUCCESS, or a nop, or\nalways fail when executed, or whatever).\n\nThe main motivation for this proposal is to increase robustness against\nvarious signature-copying attacks in Scripts that have multiple spending\nconditions.  Bitcoin is already robust against attacks where the attacker\nattempts to peddle a victim's UTXO as their own and try to copy the\nvictim's signature from one transaction input to another input.  Because\nBitcoin signatures specify which input within a transaction is being signed\nfor, such attacks fail (see https://bitcoin.stackexchange.com/a/85665/49364\n).\n\nHowever, unless CODESEPARATOR is explicitly used, there is no protection\nagainst these sorts of attacks when there are multiple participants that\nhave signing conditions within a single UTXO (or rather within a single\ntapleaf in the tapscript case).  As it stands, Bitcoin's signed data only\ncovers which input is being signed, and not the specific conditions are\nbeing signed for.  So for example, if Alice and Bob are engaged in some\nkind of multi-party protocol, and Alice wants to pre-sign a transaction\nredeeming a UTXO but subject to the condition that a certain hash-preimage\nis revealed, she might verify the Script template shows that the code path\nto her public key enforces that the hash pre-image is revealed (using a\ntoolkit like miniscript can aid in this), and she might make her signature\nfeeling secure that it, if her signature is used, the required preimage\nmust be revealed on the blockchain.  But perhaps Bob has masquated Alice's\npubkey as his own, and maybe he has inserted a copy of Alice's pubkey into\na different path of the Script template.  Now Alice's signature can be\ncopied and used in this alternate path, allowing the UTXO to be redeemed\nunder circumstances that Alice didn't believe she was authorizing.  In\ngeneral, to protect herself, Alice needs to inspect the Script to see if\nher pubkey occurs in any other branch.  Given that her pubkey, in\nprinciple, could be derived from a computation rather that pushed directly\ninto the stack, it is arguably infeasible for Alice to perform the required\ncheck in general.\n\nI believe that it would be safer, and less surprising to users, to always\nsign the CHECKSIG position by default.  This will automatically enforce\nconditions with the signature in most cases, rather than requiring users to\nproactively try to reason if CODESEPARATOR is required for protection\nwithin their protocol or not, and risk having them leave it out for cost\nsavings when it ends up being required for security after all.\n\nI do not believe signing the CHECKSIG position is an undue burden on those\nsigners who have no conditions they require enforcement for.  As it stands,\nthe tapscript proposal already requires the tapleaf_hash value under the\nsignature; this CHECKSIG position value is simply more of the same kind of\ndata.  In simple Script templates (e.g. those with only one CHECKSIG\noperation) the signed position will be a fixed known value.  Complex Script\ntemplates are precisely the situations where you want to be careful about\nenforcement of conditions with your signature.\n\nAs a side benefit, we get to eliminate CODESEPARATOR, removing a fairly\nawkward opcode from this script version.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191127/8cc191b9/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2019-11-28T08:06:59",
                "message_text_only": "On Wed, Nov 27, 2019 at 04:29:32PM -0500, Russell O'Connor via bitcoin-dev wrote:\n> The current tapscript proposal requires a signature on the last executed\n> CODESEPRATOR position.\u00a0 I'd like to propose an amendment whereby instead of\n> signing the last executed CODESEPRATOR position, we simply always sign the\n> position of the CHECKSIG (or other signing opcode) being executed.\n\nFWIW, there's discussion of this at\nhttp://www.erisian.com.au/taproot-bip-review/log-2019-11-28.html#l-65\n\n> However, unless CODESEPARATOR is explicitly used, there is no protection\n> against these sorts of attacks when there are multiple participants that have\n> signing conditions within a single UTXO (or rather within a single tapleaf in\n> the tapscript case).\n\n(You already know this, but:)\n\nWith taproot key path spending, the only other conditions that can be\nplaced on a transaction are nSequence, nLockTime, and the annex, all of\nwhich are committed to via the signature; so I think this concern only\napplies to taproot script path spending.\n\nThe proposed sighashes for taproot script path spending all commit to\nthe script being used, so you can't reuse the signature in a different\nleaf of the merkle tree of scripts for the UTXO, only in a separate\nexecution path within the script you're already looking at.\n\n> So for example, if Alice and Bob are engaged in some kind of multi-party\n> protocol, and Alice wants to pre-sign a transaction redeeming a UTXO but\n> subject to the condition that a certain hash-preimage is revealed, she might\n> verify the Script template shows that the code path to her public key enforces\n> that the hash pre-image is revealed (using a toolkit like miniscript can aid in\n> this), and she might make her signature feeling secure that it, if her\n> signature is used, the required preimage must be revealed on the blockchain.\u00a0\n> But perhaps Bob has masquated Alice's pubkey as his own, and maybe he has\n> inserted a copy of Alice's pubkey into a different path of the Script\n> template.\n>\n> Now Alice's signature can be copied and used in this alternate path,\n> allowing the UTXO to be redeemed under circumstances that Alice didn't believe\n> she was authorizing.\u00a0 In general, to protect herself, Alice needs to inspect\n> the Script to see if her pubkey occurs in any other branch.\u00a0 Given that her\n> pubkey, in principle, could be derived from a computation rather that pushed\n> directly into the stack, it is arguably infeasible for Alice to perform the\n> required check in general.\n\nFirst, it seems like a bad idea for Alice to have put funds behind a\nscript she doesn't understand in the first place. There's plenty of\nscripts that are analysable, so just not using ones that are too hard to\nanalyse sure seems like an option.\n\nSecond, if there are many branches in the script, it's probably more\nefficient to do them via different branches in the merkle tree, which\nat least for this purpose would make them easier to analyse as well\n(since you can analyse them independently).\n\nThird, if you are doing something crazy complex where a particular key\ncould appear in different CHECKSIG operators and they should have\nindependent signatures, that seems like you're at the level of\ncomplexity where learning about CODESEPARATOR is a reasonable thing to\ndo.\n\nI think CODESEPARATOR is a better solution to this problem anyway. In\nparticular, consider a \"leaf path root OP_MERKLEPATHVERIFY\" opcode,\nand a script that says \"anyone in group A can spend if the preimage for\nX is revelaed, anyone in group B can spend unconditionally\":\n\n IF HASH160 x EQUALVERIFY groupa ELSE groupb ENDIF\n MERKLEPATHVERIFY CHECKSIG\n\nspendable by\n\n siga keya path preimagex 1\n\nor\n\n sigb keyb path 0\n\nWith your proposed semantics, if my pubkey is in both groups, my signature\nwill sign for position 10, and still be valid on either path, even if\nthe signature commits to the CHECKSIG position.\n\nI could fix my script either by having two CHECKSIG opcodes (one for\neach branch) and also duplicating the MERKLEPATHVERIFY; or I could\nadd a CODESEPARATOR in either IF branch.\n\n(Or I could just not reuse the exact same pubkey across groups; or I could\nhave two separate scripts: \"HASH160 x EQUALVERIFY groupa MERKLEPATHVERIFY\nCHECKSIG\" and \"groupb MERKLEPATHVERIFY CHECKSIG\")\n\n> I believe that it would be safer, and less surprising to users, to always sign\n> the CHECKSIG position by default.\n\n> As a side benefit, we get to eliminate CODESEPARATOR, removing a fairly awkward\n> opcode from this script version.\n\nAs it stands, ANYPREVOUTANYSCRIPT proposes to not sign the script code\n(allowing the signature to be reused in different scripts) but does\ncontinue signing the CODESEPARATOR position, allowing you to optionally\nrestrict how flexibly you can reuse signatures. That seems like a better\ntradeoff than having ANYPREVOUTANYSCRIPT signatures commit to the CHECKSIG\nposition which would make it a fair bit harder to design scripts that\ncan share signatures, or not having any way to restrict which scripts\nthe signature could apply to other than changing the pubkey.\n\nA hypothetical alternate \"codeseparator\" design: when script execution\nstarts, initialise an empty byte string \"trace\"; each time an opcode\nis executed append \"0xFF\"; each time an opcode is skipped append\n\"0x00\". When a CODESEPARATOR is seen, calculate sha256(trace) and store\nit, everytime a CHECKSIG is executed, include the sha256(trace) from the\nlast CODESEPARATOR in the digest [0]. That should make each checksig\ncommit to the exact path the script took up to the last CODESEPARATOR\nseen. I think it's probably more complex than is really useful though,\nso I'm not proposing it seriously.\n\n[0] If there's not been a CODESEPARATOR, then sha256(trace)=sha256(\"\");\n    if there's been one CODESEPARATOR and it was the first opcode seen,\n    sha256(trace)=sha256(\"\\xff\").\n\nCheers,\naj"
            }
        ],
        "thread_summary": {
            "title": "Signing CHECKSIG position in Tapscript",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Russell O'Connor",
                "Anthony Towns"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 9814
        }
    }
]